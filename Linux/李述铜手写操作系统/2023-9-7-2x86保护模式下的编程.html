<!DOCTYPE html>

<html lang="zh-CN"  class="">


<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="keywords" content="">
    
    
    <meta name="description" content="">
    
    <meta name="generator" content="teedoc">
    <meta name="theme" content="teedoc-plugin-theme-default">
    
        
        <meta name="markdown-generator" content="teedoc-plugin-markdown-parser">
        
        <script>
MathJax = {"loader": {"load": ["output/svg"]}, "tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]]}, "svg": {"fontCache": "global"}};
</script>
        
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        
        <meta name="html-generator" content="teedoc-plugin-jupyter-notebook-parser">
        
        <script src="/note/static/js/theme_default/pre_main.js"></script>
        
        <link rel="stylesheet" href="/note/static/css/theme_default/prism.min.css" type="text/css"/>
        
        <link rel="stylesheet" href="/note/static/css/theme_default/viewer.min.css" type="text/css"/>
        
        <link rel="stylesheet" href="/note/static/css/theme_default/dark.css" type="text/css"/>
        
        <link rel="stylesheet" href="/note/static/css/theme_default/light.css" type="text/css"/>
        
        <script src="/note/static/js/theme_default/jquery.min.js"></script>
        
        <script src="/note/static/js/theme_default/split.js"></script>
        
        <link rel="stylesheet" href="/note/static/css/search/style.css" type="text/css"/>
        
        <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4d52982572d5512e9762879ebf063c86";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
        
        <meta name="blog-generator" content="teedoc-plugin-blog">
        
        <link rel="stylesheet" href="/note/static/css/gitalk/gitalk.css" type="text/css"/>
        
        <link rel="stylesheet" href="/note/static/css/gitalk/custom_gitalk.css" type="text/css"/>
        
        <link rel="stylesheet" href="/note/static/css/custom.css" type="text/css"/>
        
    
    
    <title>x86保护模式下的编程 - XvSenfeng's Note</title>
    
    <script type="text/javascript">js_vars = {"teedoc-plugin-ad-hint": {"type": "hint", "label": "☆", "content": "这是一个支持国际化的消息示例</br>喜欢项目请<a target=\"_blank\" href=\"https://github.com/teedoc/teedoc\">点下 ☆ star </a>哦~🦀🦀", "show_times": 2, "show_after_s": 432000, "date": "2021-11-16 14:40", "color": "#a0421d", "link_color": "#e53935", "link_bg_color": "#e6ae5c", "bg_color": "#ffcf89", "color_hover": "white", "bg_color_hover": "#f57c00", "close_color": "#eab971"}}</script>
    <script type="text/javascript">metadata = {"tags": ["李述铜"], "date": "2026-02-05", "update": [], "ts": 1770297751, "author": "", "brief": "", "cover": "", "layout": "post"}</script>
</head>


<body class="type_doc">
    
    <div id="navbar">
        <div id="navbar_menu">
            <a class="site_title" href="/note/">
                
                    <img class="site_logo" src="/note/static/image/logo.png" alt="XvSenfeng logo">
                
                
                    <h2>XvSenfeng</h2>
                
        </a>
            <a id="navbar_menu_btn"></a>
        </div>
        <div id="navbar_items">
            <div>
                <ul id="nav_left">
<li class=""><a  href="/note/blog/">博客</a></li>
<li class="active"><a  href="/note/Linux/">Linux</a></li>
<li class=""><a  href="/note/代码分析/">代码分析</a></li>
<li class=""><a  href="/note/使用软件/">使用软件</a></li>
<li class=""><a  href="/note/嵌入式/">嵌入式</a></li>
<li class=""><a  href="/note/手机安卓/">手机安卓</a></li>
<li class=""><a  href="/note/机器学习/">机器学习</a></li>
<li class=""><a  href="/note/编程基础/">编程基础</a></li>
<li class=""><a  href="/note/网络/">网络</a></li>
</ul>

            </div>
            <div>
                <ul id="nav_right">
<li class=""><a target="_blank" href="https://github.com/XuSenfeng/note/">github</a></li>
</ul>

                <ul class="nav_plugins"><li><a id="google_translate_element"><img class="icon" src="/note/static/image/google_translate/translate.svg"/>Translate</a></li></ul><ul class="nav_plugins"><li><a id="themes" class="light"></a></li></ul><ul class="nav_plugins"><li><a id="search"><span class="icon"></span><span class="placeholder">搜索</span>
                            <div id="search_hints">
                                <span id="search_input_hint">输入关键词，多关键词空格隔开</span>
                                <span id="search_loading_hint">正在加载，请稍候。。。</span>
                                <span id="search_download_err_hint">下载文件失败，请刷新重试或检查网络</span>
                                <span id="search_other_docs_result_hint">来自其它文档的结果</span>
                                <span id="search_curr_doc_result_hint">当前文档搜索结果</span>
                            </div></a></li></ul>
            </div>
        </div>
    </div>
    
    <div id="wrapper">
        <div id="sidebar_wrapper">
            <div id="sidebar">
                <div id="sidebar_title">
                    
                </div>
                <ul class="show">
<li class="not_active with_link"><a href="/note/Linux/index.html"><span class="label">README</span><span class=""></span></a></li>
<li class="not_active no_link"><a><span class="label">Linux命令行与shell脚本编程大全</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-1-初认识Linux_shell.html"><span class="label">2022-8-1-初认识Linux_shell</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-1-基本bashshell命令.html"><span class="label">2022-8-1-基本bashshell命令</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-1-走进shell.html"><span class="label">2022-8-1-走进shell</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-10-sed进阶.html"><span class="label">2022-8-10-sed进阶</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-11-gawk进阶.html"><span class="label">2022-8-11-gawk进阶</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-11-使用其他shell.html"><span class="label">2022-8-11-使用其他shell</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-11-实例.html"><span class="label">2022-8-11-实例</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-12-邮件相关.html"><span class="label">2022-8-12-邮件相关</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-2-更多命令.html"><span class="label">2022-8-2-更多命令</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-2-理解shell.html"><span class="label">2022-8-2-理解shell</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-3-使用Linux环境变量.html"><span class="label">2022-8-3-使用Linux环境变量</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-3-理解Linux的文件权限.html"><span class="label">2022-8-3-理解Linux的文件权限</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-4-安装软件程序.html"><span class="label">2022-8-4-安装软件程序</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-4-管理文件系统.html"><span class="label">2022-8-4-管理文件系统</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-5-使用编辑器.html"><span class="label">2022-8-5-使用编辑器</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-5-构建基本脚本.html"><span class="label">2022-8-5-构建基本脚本</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-6-使用结构初始化.html"><span class="label">2022-8-6-使用结构初始化</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-6-处理用户输入.html"><span class="label">2022-8-6-处理用户输入</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-6-更多结构化命令.html"><span class="label">2022-8-6-更多结构化命令</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-7-呈现数据.html"><span class="label">2022-8-7-呈现数据</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-7-控制脚本.html"><span class="label">2022-8-7-控制脚本</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-8-创建函数.html"><span class="label">2022-8-8-创建函数</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-9-图形化桌面环境中的脚本编程.html"><span class="label">2022-8-9-图形化桌面环境中的脚本编程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-9-正则表达式.html"><span class="label">2022-8-9-正则表达式</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-9-认识sed和gawk.html"><span class="label">2022-8-9-认识sed和gawk</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">Linux就该这么学</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/Linux就该这么学/2022-8-23-.html"><span class="label">2022-8-23-</span><span class=""></span></a></li>
<li class="not_active no_link"><a><span class="label">鸟哥的linux私房菜</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/Linux就该这么学/鸟哥的linux私房菜/2022-9-10-计算机概论.html"><span class="label">2022-9-10-计算机概论</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux就该这么学/鸟哥的linux私房菜/2022-9-20-主机规划与磁盘分区.html"><span class="label">2022-9-20-主机规划与磁盘分区</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux就该这么学/鸟哥的linux私房菜/2022-9-20-安装CentOS.html"><span class="label">2022-9-20-安装CentOS</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux就该这么学/鸟哥的linux私房菜/2022-9-20-首次登录.html"><span class="label">2022-9-20-首次登录</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux就该这么学/鸟哥的linux私房菜/2022-9-25-文件权限以及目录.html"><span class="label">2022-9-25-文件权限以及目录</span><span class=""></span></a></li>
</ul>
</li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">Linux源码趣读</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/Linux源码趣读/2024-1-26-01最开始的代码.html"><span class="label">2024-1-26-01最开始的代码</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">Linux系统编程</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/Linux系统编程/2024-2-14-01文件IO.html"><span class="label">2024-2-14-01文件IO</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux系统编程/2024-3-19-02文件系统.html"><span class="label">2024-3-19-02文件系统</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux系统编程/2024-3-21-03程序和进程.html"><span class="label">2024-3-21-03程序和进程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux系统编程/2024-3-23-04进程间通信.html"><span class="label">2024-3-23-04进程间通信</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux系统编程/2024-3-25-05信号.html"><span class="label">2024-3-25-05信号</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux系统编程/2024-3-28-06守护进程、线程.html"><span class="label">2024-3-28-06守护进程、线程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux系统编程/2024-3-31-07线程同步.html"><span class="label">2024-3-31-07线程同步</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">Linux网络编程</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-10-04线程池.html"><span class="label">2024-4-10-04线程池</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-13-05本地套接字.html"><span class="label">2024-4-13-05本地套接字</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-14-06libevent库.html"><span class="label">2024-4-14-06libevent库</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-16-07简单的Web服务器.html"><span class="label">2024-4-16-07简单的Web服务器</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-16-08html入门.html"><span class="label">2024-4-16-08html入门</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-17-09CSS.html"><span class="label">2024-4-17-09CSS</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-17-09HTTP协议.html"><span class="label">2024-4-17-09HTTP协议</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-2-01网络基础.html"><span class="label">2024-4-2-01网络基础</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-20-10telnet调试.html"><span class="label">2024-4-20-10telnet调试</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-20-11服务器.html"><span class="label">2024-4-20-11服务器</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-3-02Socket编程.html"><span class="label">2024-4-3-02Socket编程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-6-03高并发服务器.html"><span class="label">2024-4-6-03高并发服务器</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">原子Linux</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-10-Linux常用命令.html"><span class="label">2022-8-10-Linux常用命令</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-11-压缩解压缩.html"><span class="label">2022-8-11-压缩解压缩</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-11-文件系统结构.html"><span class="label">2022-8-11-文件系统结构</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-11-磁盘管理.html"><span class="label">2022-8-11-磁盘管理</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-12-LinuxC.html"><span class="label">2022-8-12-LinuxC</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-12-Makefile书.html"><span class="label">2022-8-12-Makefile书</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-12-make和Makefile.html"><span class="label">2022-8-12-make和Makefile</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-12-开发环境搭建.html"><span class="label">2022-8-12-开发环境搭建</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-12-用户和用户组.html"><span class="label">2022-8-12-用户和用户组</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-12-链接文件.html"><span class="label">2022-8-12-链接文件</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-13-IMX启动方式.html"><span class="label">2022-8-13-IMX启动方式</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-13-vscode.html"><span class="label">2022-8-13-vscode</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-13-开发板简介.html"><span class="label">2022-8-13-开发板简介</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-13-汇编LED驱动.html"><span class="label">2022-8-13-汇编LED驱动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-14-C语言点灯.html"><span class="label">2022-8-14-C语言点灯</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-14-按键检测.html"><span class="label">2022-8-14-按键检测</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-14-模仿stm32编程.html"><span class="label">2022-8-14-模仿stm32编程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-15-中断.html"><span class="label">2022-8-15-中断</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-15-主频时钟配置.html"><span class="label">2022-8-15-主频时钟配置</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-16-EPIT定时器.html"><span class="label">2022-8-16-EPIT定时器</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-16-GPT时钟.html"><span class="label">2022-8-16-GPT时钟</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-17-DDR3.html"><span class="label">2022-8-17-DDR3</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-17-RGBLED.html"><span class="label">2022-8-17-RGBLED</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-17-串口.html"><span class="label">2022-8-17-串口</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-18-I2C.html"><span class="label">2022-8-18-I2C</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-18-RTC.html"><span class="label">2022-8-18-RTC</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-19-PWM.html"><span class="label">2022-8-19-PWM</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-19-SPI.html"><span class="label">2022-8-19-SPI</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-19-多点电容触摸屏.html"><span class="label">2022-8-19-多点电容触摸屏</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-20-uBoot.html"><span class="label">2022-8-20-uBoot</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-20-系统烧写.html"><span class="label">2022-8-20-系统烧写</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-22-源码目录分析.html"><span class="label">2022-8-22-源码目录分析</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-22-顶层Makefile.html"><span class="label">2022-8-22-顶层Makefile</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-23-Linux内核.html"><span class="label">2022-8-23-Linux内核</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-23-uboot图形化配置界面.html"><span class="label">2022-8-23-uboot图形化配置界面</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-23-启动流程.html"><span class="label">2022-8-23-启动流程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-23-移植.html"><span class="label">2022-8-23-移植</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-24-驱动开发.html"><span class="label">2022-8-24-驱动开发</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-26-linux点灯.html"><span class="label">2022-8-26-linux点灯</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-27-设备树.html"><span class="label">2022-8-27-设备树</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-28-led设备树.html"><span class="label">2022-8-28-led设备树</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-29-Linux的并发与竞争.html"><span class="label">2022-8-29-Linux的并发与竞争</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-29-pinclt和gpio.html"><span class="label">2022-8-29-pinclt和gpio</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-30-Linux中断.html"><span class="label">2022-8-30-Linux中断</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-30-Linux内核定时器.html"><span class="label">2022-8-30-Linux内核定时器</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-31-异步通知.html"><span class="label">2022-8-31-异步通知</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-31-阻塞非阻塞.html"><span class="label">2022-8-31-阻塞非阻塞</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-1-platform设备驱动.html"><span class="label">2022-9-1-platform设备驱动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-10-WIFI.html"><span class="label">2022-9-10-WIFI</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-10-网络驱动.html"><span class="label">2022-9-10-网络驱动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-11-4G.html"><span class="label">2022-9-11-4G</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-11-IIO.html"><span class="label">2022-9-11-IIO</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-11-PWM.html"><span class="label">2022-9-11-PWM</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-11-RGBtoHDMI.html"><span class="label">2022-9-11-RGBtoHDMI</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-11-Regmap.html"><span class="label">2022-9-11-Regmap</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-2-INPUT子系统.html"><span class="label">2022-9-2-INPUT子系统</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-2-LCD屏幕.html"><span class="label">2022-9-2-LCD屏幕</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-2-Linux自带的led.html"><span class="label">2022-9-2-Linux自带的led</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-2-MISC.html"><span class="label">2022-9-2-MISC</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-3-I2C.html"><span class="label">2022-9-3-I2C</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-3-RTC.html"><span class="label">2022-9-3-RTC</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-3-SPI.html"><span class="label">2022-9-3-SPI</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-4-串口.html"><span class="label">2022-9-4-串口</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-5-触摸屏.html"><span class="label">2022-9-5-触摸屏</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-5-音频驱动.html"><span class="label">2022-9-5-音频驱动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-6-CAN协议.html"><span class="label">2022-9-6-CAN协议</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-7-USB.html"><span class="label">2022-9-7-USB</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-7-块设备驱动.html"><span class="label">2022-9-7-块设备驱动</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">操作系统原理</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-17-1操作系统.html"><span class="label">2023-6-17-1操作系统</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-17-2操作系统目标和作用.html"><span class="label">2023-6-17-2操作系统目标和作用</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-17-3操作系统特征.html"><span class="label">2023-6-17-3操作系统特征</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-17-4操作系统的发展.html"><span class="label">2023-6-17-4操作系统的发展</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-17-5运行机制.html"><span class="label">2023-6-17-5运行机制</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-18-6中断异常.html"><span class="label">2023-6-18-6中断异常</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-18-7系统调用.html"><span class="label">2023-6-18-7系统调用</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-19-8体系结构.html"><span class="label">2023-6-19-8体系结构</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-20-10虚拟机.html"><span class="label">2023-6-20-10虚拟机</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-20-11进程.html"><span class="label">2023-6-20-11进程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-20-9操作系统的引导.html"><span class="label">2023-6-20-9操作系统的引导</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-22-12线程.html"><span class="label">2023-6-22-12线程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-23-13调度.html"><span class="label">2023-6-23-13调度</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-27-14进程同步进程互斥.html"><span class="label">2023-6-27-14进程同步进程互斥</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-28-15锁.html"><span class="label">2023-6-28-15锁</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-28-16信号量机制.html"><span class="label">2023-6-28-16信号量机制</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">服务器</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/服务器/2023-6-12-代理.html"><span class="label">2023-6-12-代理</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/服务器/2023-6-12-新服务器搭建.html"><span class="label">2023-6-12-新服务器搭建</span><span class=""></span></a></li>
</ul>
</li>
<li class="active_parent no_link"><a><span class="label">李述铜手写操作系统</span><span class="sub_indicator"></span></a><ul class="show">
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2023-10-26-05中断和异常处理.html"><span class="label">2023-10-26-05中断和异常处理</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2023-11-10-06日志与printf输出.html"><span class="label">2023-11-10-06日志与printf输出</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2023-9-23-03引导程序接管控制权.html"><span class="label">2023-9-23-03引导程序接管控制权</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2023-9-28-04加载器loader的实现.html"><span class="label">2023-9-28-04加载器loader的实现</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2023-9-6-01补充知识2.html"><span class="label">2023-9-6-01补充知识2</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2023-9-6-0补充知识.html"><span class="label">2023-9-6-0补充知识</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2023-9-6-1操作系统准备.html"><span class="label">2023-9-6-1操作系统准备</span><span class=""></span></a></li>
<li class="active with_link"><a href="/note/Linux/李述铜手写操作系统/2023-9-7-2x86保护模式下的编程.html"><span class="label">2023-9-7-2x86保护模式下的编程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-2-17-07进程切换.html"><span class="label">2024-2-17-07进程切换</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-2-17-08链表.html"><span class="label">2024-2-17-08链表</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-2-17添加任务管理器.html"><span class="label">2024-2-17添加任务管理器</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-2-18-内存管理.html"><span class="label">2024-2-18-内存管理</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-2-24-系统调用.html"><span class="label">2024-2-24-系统调用</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-2-26-移植Newlib库.html"><span class="label">2024-2-26-移植Newlib库</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-2-27-屏幕显示信息.html"><span class="label">2024-2-27-屏幕显示信息</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-2-29-键盘初始化.html"><span class="label">2024-2-29-键盘初始化</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-3-1-设备管理.html"><span class="label">2024-3-1-设备管理</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-3-3-Shell.html"><span class="label">2024-3-3-Shell</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-3-4-文件系统.html"><span class="label">2024-3-4-文件系统</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-3-5-磁盘.html"><span class="label">2024-3-5-磁盘</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-3-7-Fat16.html"><span class="label">2024-3-7-Fat16</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">树莓派</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/树莓派/2024-2-1-01开始使用.html"><span class="label">2024-2-1-01开始使用</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/树莓派/2024-2-1-02-使用命令了解树莓派.html"><span class="label">2024-2-1-02-使用命令了解树莓派</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/树莓派/2024-2-1-03-安装mysql.html"><span class="label">2024-2-1-03-安装mysql</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/树莓派/2024-2-3-04网络连接.html"><span class="label">2024-2-3-04网络连接</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/树莓派/2024-2-8-时钟设置.html"><span class="label">2024-2-8-时钟设置</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">泰山派</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-12-20-05-lvgl程序.html"><span class="label">2025-12-20-05-lvgl程序</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-12-24-06-二维码识别.html"><span class="label">2025-12-24-06-二维码识别</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-12-24-07-yolo部署.html"><span class="label">2025-12-24-07-yolo部署</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-12-25-08-OpenCV.html"><span class="label">2025-12-25-08-OpenCV</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-12-26-09-拍照.html"><span class="label">2025-12-26-09-拍照</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-12-26-10-Qt.html"><span class="label">2025-12-26-10-Qt</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-5-11-01环境搭建.html"><span class="label">2025-5-11-01环境搭建</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-5-11-02设备树.html"><span class="label">2025-5-11-02设备树</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-5-14-03屏幕驱动.html"><span class="label">2025-5-14-03屏幕驱动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-5-17-04触摸驱动.html"><span class="label">2025-5-17-04触摸驱动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2026-1-27-ROS.html"><span class="label">2026-1-27-ROS</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2026-1-30-Ubuntu22.html"><span class="label">2026-1-30-Ubuntu22</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">瑞芯微Linux</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/瑞芯微Linux/2025-12-10-Cpp提供C接口.html"><span class="label">2025-12-10-Cpp提供C接口</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/瑞芯微Linux/2025-12-5-01-EchoAI编译代码.html"><span class="label">2025-12-5-01-EchoAI编译代码</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/瑞芯微Linux/2025-12-5-02-EchoAI代码.html"><span class="label">2025-12-5-02-EchoAI代码</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/瑞芯微Linux/2025-12-7-03-添加板子.html"><span class="label">2025-12-7-03-添加板子</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/瑞芯微Linux/2025-12-8-04-内核.html"><span class="label">2025-12-8-04-内核</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/瑞芯微Linux/2025-12-9-05-模型.html"><span class="label">2025-12-9-05-模型</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/瑞芯微Linux/配置网络.html"><span class="label">配置网络</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">野火Linux</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-11-55-buildroot.html"><span class="label">2025-10-11-55-buildroot</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-11-56-裸机汇编开发.html"><span class="label">2025-10-11-56-裸机汇编开发</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-12-57-Uboot编译脚本.html"><span class="label">2025-10-12-57-Uboot编译脚本</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-2-47-镜像构建.html"><span class="label">2025-10-2-47-镜像构建</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-2-48-systemd.html"><span class="label">2025-10-2-48-systemd</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-2-49-deb包.html"><span class="label">2025-10-2-49-deb包</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-2-50-修改img文件.html"><span class="label">2025-10-2-50-修改img文件</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-2-51-备份量产.html"><span class="label">2025-10-2-51-备份量产</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-2-52-Uboot启动.html"><span class="label">2025-10-2-52-Uboot启动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-28-58-Uboot移植.html"><span class="label">2025-10-28-58-Uboot移植</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-30-59-Uboot图形配置界面语法.html"><span class="label">2025-10-30-59-Uboot图形配置界面语法</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-30-60-Linux编译脚本.html"><span class="label">2025-10-30-60-Linux编译脚本</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-31-61-Linux启动流程.html"><span class="label">2025-10-31-61-Linux启动流程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-9-53-Uboot启动(二).html"><span class="label">2025-10-9-53-Uboot启动(二)</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-9-54-Uboot启动(三).html"><span class="label">2025-10-9-54-Uboot启动(三)</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-1-62-linux移植.html"><span class="label">2025-11-1-62-linux移植</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-1-63-Busybox.html"><span class="label">2025-11-1-63-Busybox</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-10-65-定时器.html"><span class="label">2025-11-10-65-定时器</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-12-66-信号.html"><span class="label">2025-11-12-66-信号</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-14-67-MISC设备.html"><span class="label">2025-11-14-67-MISC设备</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-15-68-RTC.html"><span class="label">2025-11-15-68-RTC</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-16-69-串口.html"><span class="label">2025-11-16-69-串口</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-18-70-中断线程化.html"><span class="label">2025-11-18-70-中断线程化</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-18-71-音频.html"><span class="label">2025-11-18-71-音频</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-19-72-CAN.html"><span class="label">2025-11-19-72-CAN</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-19-73-USB.html"><span class="label">2025-11-19-73-USB</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-2-64-mfgtool.html"><span class="label">2025-11-2-64-mfgtool</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-20-74-块设备.html"><span class="label">2025-11-20-74-块设备</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-21-75-网络设备.html"><span class="label">2025-11-21-75-网络设备</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-22-76-Wifi.html"><span class="label">2025-11-22-76-Wifi</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-22-77-PWM.html"><span class="label">2025-11-22-77-PWM</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-22-78-Regmap通用寄存器.html"><span class="label">2025-11-22-78-Regmap通用寄存器</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-22-79-IIO驱动框架.html"><span class="label">2025-11-22-79-IIO驱动框架</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-25-80-ADC驱动.html"><span class="label">2025-11-25-80-ADC驱动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-12-6-81-音频驱动.html"><span class="label">2025-12-6-81-音频驱动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-12-8-82-DRM显示设备.html"><span class="label">2025-12-8-82-DRM显示设备</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-6-11-01-入门.html"><span class="label">2025-6-11-01-入门</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-6-22-02-开发板下载启动.html"><span class="label">2025-6-22-02-开发板下载启动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-12-04-镜像文件.html"><span class="label">2025-7-12-04-镜像文件</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-13-06-GPIO.html"><span class="label">2025-7-13-06-GPIO</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-13-07-中断.html"><span class="label">2025-7-13-07-中断</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-14-05-ARMv7汇编.html"><span class="label">2025-7-14-05-ARMv7汇编</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-14-08-时钟控制模块.html"><span class="label">2025-7-14-08-时钟控制模块</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-14-09-串口.html"><span class="label">2025-7-14-09-串口</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-15-10-内核模块.html"><span class="label">2025-7-15-10-内核模块</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-15-11-字符设备.html"><span class="label">2025-7-15-11-字符设备</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-15-12-驱动设备模型.html"><span class="label">2025-7-15-12-驱动设备模型</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-19-13-Kset.html"><span class="label">2025-7-19-13-Kset</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-19-14-uevent消息.html"><span class="label">2025-7-19-14-uevent消息</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-19-15-class设备管理.html"><span class="label">2025-7-19-15-class设备管理</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-19-16-17-总结.html"><span class="label">2025-7-19-16-17-总结</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-19-16-xbus和platform.html"><span class="label">2025-7-19-16-xbus和platform</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-2-03-控制设备.html"><span class="label">2025-7-2-03-控制设备</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-20-18-DTS设备树.html"><span class="label">2025-7-20-18-DTS设备树</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-20-19-DeviceTreeOverlay.html"><span class="label">2025-7-20-19-DeviceTreeOverlay</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-16-21-iomux节点(中).html"><span class="label">2025-9-16-21-iomux节点(中)</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-16-22-iomux节点(下).html"><span class="label">2025-9-16-22-iomux节点(下)</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-17-23-iomux节点(应用).html"><span class="label">2025-9-17-23-iomux节点(应用)</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-17-24-GPIO子系统.html"><span class="label">2025-9-17-24-GPIO子系统</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-17-25-并发硬件同步原语.html"><span class="label">2025-9-17-25-并发硬件同步原语</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-18-26-IIC驱动框架.html"><span class="label">2025-9-18-26-IIC驱动框架</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-20-27-IIC驱动框架使用.html"><span class="label">2025-9-20-27-IIC驱动框架使用</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-25-28-阻塞和非阻塞IO.html"><span class="label">2025-9-25-28-阻塞和非阻塞IO</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-25-29-POLL机制.html"><span class="label">2025-9-25-29-POLL机制</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-25-30-Completion.html"><span class="label">2025-9-25-30-Completion</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-25-31-kthread_worker.html"><span class="label">2025-9-25-31-kthread_worker</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-26-32-SPI.html"><span class="label">2025-9-26-32-SPI</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-26-33-SPI使用.html"><span class="label">2025-9-26-33-SPI使用</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-27-34-中断.html"><span class="label">2025-9-27-34-中断</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-27-35-软中断和tasklet.html"><span class="label">2025-9-27-35-软中断和tasklet</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-27-36-工作队列.html"><span class="label">2025-9-27-36-工作队列</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-27-37-Input子系统.html"><span class="label">2025-9-27-37-Input子系统</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-28-38-电容触摸屏.html"><span class="label">2025-9-28-38-电容触摸屏</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-28-39-PWM.html"><span class="label">2025-9-28-39-PWM</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-28-40-LCD-FB设备.html"><span class="label">2025-9-28-40-LCD-FB设备</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-29-41-Linux系统构成.html"><span class="label">2025-9-29-41-Linux系统构成</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-29-42-Uboot基础使用.html"><span class="label">2025-9-29-42-Uboot基础使用</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-29-43-Linux.html"><span class="label">2025-9-29-43-Linux</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-29-44-添加驱动(设备树).html"><span class="label">2025-9-29-44-添加驱动(设备树)</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-30-45-图标.html"><span class="label">2025-9-30-45-图标</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-30-46-根文件系统.html"><span class="label">2025-9-30-46-根文件系统</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-4-20-iomux节点(上).html"><span class="label">2025-9-4-20-iomux节点(上)</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/Untitled.html"><span class="label">Untitled</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">问题处理</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/问题处理/2022-11-20-Linux图形界面.html"><span class="label">2022-11-20-Linux图形界面</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2022-8-24-tftp下载.html"><span class="label">2022-8-24-tftp下载</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2022-8-26-uboot设置.html"><span class="label">2022-8-26-uboot设置</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2022-8-27-根文件系统被删除.html"><span class="label">2022-8-27-根文件系统被删除</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2022-8-5-没有release文件.html"><span class="label">2022-8-5-没有release文件</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2022-9-7-备份根文件.html"><span class="label">2022-9-7-备份根文件</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2022-9-9-ubuntu移植问题处理.html"><span class="label">2022-9-9-ubuntu移植问题处理</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2023-11-11-树莓派.html"><span class="label">2023-11-11-树莓派</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2023-6-14-打不开gpedit-msc.html"><span class="label">2023-6-14-打不开gpedit-msc</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2023-6-28-vscode配置.html"><span class="label">2023-6-28-vscode配置</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2023-8-27-开发板网络设置.html"><span class="label">2023-8-27-开发板网络设置</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">韦东山Linux</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/韦东山Linux/2025-3-4-基础.html"><span class="label">2025-3-4-基础</span><span class=""></span></a></li>
</ul>
</li>
</ul>

            </div>
        </div>
        <div id="article">
            <div id="menu_wrapper">
                <div id="menu">
                </div>
            </div>
            <div id="content_wrapper">
                <div id="content_body">
                    <div id="article_head">
                        <div id="article_title">
                            
                            <h1>x86保护模式下的编程</h1>
                            
                        </div>
                        <div id="article_tags">
                            <ul>
                            
                                <li>李述铜</li>
                            
                            </ul>
                        </div>
                        <div id="article_info">
                        <div id="article_info_left">
                            <span class="article_author">
                                
                            </span>
                            
                                <span class="article_date" title="最后修改日期： 2026-02-05">
                                    2026-02-05
                                </span>
                            
                        </div>
                        <div id="article_info_right">
                            
                            <div id="source_link">
                                <a href="https://github.com/XuSenfeng/note/tree/master/doc/Linux/李述铜手写操作系统/2023-9-7-2x86保护模式下的编程.md" target="_blank">
                                    编辑本页
                                </a>
                            </div>
                            
                        </div>
                        </div>
                    </div>
                    <div id="article_tools">
                        <span></span>
                        <span id="toc_btn"></span>
                    </div>
                    <div id="update_history">
                        
                    </div>
                    <div id="article_content">
                        
                            <h1 id="x86%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84%E7%BC%96%E7%A8%8B">x86保护模式下的编程</h1>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202408242301008.jpg" alt="总体框图" /></p>
<p>实现一个小型的操作系统</p>
<p>实模式=&gt;BIOS中断=&gt;保护模式=&gt;GDT/LDT表</p>
<p>​												 =&gt;TSS任务状态</p>
<p>​												 =&gt;调用门(系统调用)</p>
<h2 id="%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B">创建工程</h2>
<ul>
<li>Makefile文件</li>
</ul>

<pre class="language-makefile"><code class="language-makefile"># 功能：工程目标创建的makefile文件
# 
# 创建时间：2022年8月31日
# 作者：李述铜
# 联系邮箱: 527676163@qq.com
# 相关信息：此工程为《从0写x86 Linux操作系统》的前置课程，用于帮助预先建立对32位x86体系结构的理解
# 课程请见：https://study.163.com/course/introduction.htm?courseId=1212765805&amp;_trace_c_p_k2_=0bdf1e7edda543a8b9a0ad73b5100990

# 工具链前缀，如果是windows和mac，使用x86_64-elf-
# 如果是linux，使用x86_64-linux-gnu-
# 工具链前缀，如果是windows和mac，使用x86_64-elf-
# 如果是linux，使用x86_64-linux-gnu-
ifeq ($(LANG),)
    TOOL_PREFIX = x86_64-linux-gnu-
else
    TOOL_PREFIX = x86_64-elf-
endif

# GCC编译参数
CFLAGS = -g -c -O0 -m32 -fno-pie -fno-stack-protector -nostdlib -nostdinc

# 目标创建:涉及编译、链接、二进制转换、反汇编、写磁盘映像
all: source/os.c source/os.h source/start.S
    $(TOOL_PREFIX)gcc $(CFLAGS) source/start.S
    $(TOOL_PREFIX)gcc $(CFLAGS) source/os.c	
    $(TOOL_PREFIX)ld -m elf_i386 -Ttext=0x7c00 start.o os.o -o os.elf
    ${TOOL_PREFIX}objcopy -O binary os.elf os.bin
    ${TOOL_PREFIX}objdump -x -d -S  os.elf &gt; os_dis.txt	
    ${TOOL_PREFIX}readelf -a  os.elf &gt; os_elf.txt	
    dd if=os.bin of=../image/disk.img conv=notrunc

# 清理
clean:
    rm -f *.elf *.o
</code></pre>
<blockquote>
<p>首先进行编译, 之后进行链接文件, 对链接的文件转化为二进制, 二进制的文件最后反汇编, 还有对elf文件进行解析, dd命令会把二进制文件写入磁盘映像文件, 磁盘映像文件会被之后的qemu调用执行</p>
<p>这个命令的作用是将 <code>os.bin</code> 文件的内容写入到 <code>../image/disk.img</code> 文件中，不截断（<code>notrunc</code>）原有的内容。</p>
<ul>
<li><code>dd</code>: 用于复制文件或转换文件格式的命令。</li>
<li><code>if=os.bin</code>: 指定输入文件为 <code>os.bin</code>。</li>
<li><code>of=../image/disk.img</code>: 指定输出文件为 <code>../image/disk.img</code>，即磁盘映像文件。</li>
<li><code>conv=notrunc</code>: 指定不截断原有的内容，即在磁盘映像文件中保留原有的内容。</li>
</ul>
</blockquote>

<pre class="language-json"><code class="language-json">{
    // See https://go.microsoft.com/fwlink/?LinkId=733558
    // for the documentation about the tasks.json format
    &quot;version&quot;: &quot;2.0.0&quot;, 
    &quot;tasks&quot;: [
       {
            &quot;label&quot;: &quot;启动qemu&quot;,
            &quot;type&quot;: &quot;shell&quot;,
            &quot;command&quot;: &quot;bash ${workspaceRoot}/script/qemu-debug-osx.sh&quot;,
            &quot;windows&quot;: {
                // windows下特殊一些
                &quot;command&quot;: &quot;${workspaceRoot}/script/qemu-debug-win.bat&quot;,
            },
            &quot;linux&quot;:{
                &quot;command&quot;: &quot;bash ${workspaceRoot}/script/qemu-debug-linux.sh&quot;,
            },
            &quot;options&quot;: {
                &quot;cwd&quot;: &quot;${workspaceRoot}/../image/&quot;
            }
        },
    ]
}
</code></pre>
<blockquote>
<p>在这里设置了启动qemu的命令</p>
</blockquote>
<ul>
<li>c文件</li>
</ul>

<pre class="language-c"><code class="language-c">/**
 * 功能：32位代码，完成多任务的运行
 *
 *创建时间：2022年8月31日
 *作者：李述铜
 *联系邮箱: 527676163@qq.com
 *相关信息：此工程为《从0写x86 Linux操作系统》的前置课程，用于帮助预先建立对32位x86体系结构的理解。整体代码量不到200行（不算注释）
 *课程请见：https://study.163.com/course/introduction.htm?courseId=1212765805&amp;_trace_c_p_k2_=0bdf1e7edda543a8b9a0ad73b5100990
 */
#include &quot;os.h&quot;
</code></pre>
<ul>
<li>h文件</li>
</ul>

<pre class="language-c"><code class="language-c">/**
 * 功能：公共头文件
 *
 *创建时间：2022年8月31日
 *作者：李述铜
 *联系邮箱: 527676163@qq.com
 *相关信息：此工程为《从0写x86 Linux操作系统》的前置课程，用于帮助预先建立对32位x86体系结构的理解。整体代码量不到200行（不算注释）
 *课程请见：https://study.163.com/course/introduction.htm?courseId=1212765805&amp;_trace_c_p_k2_=0bdf1e7edda543a8b9a0ad73b5100990
 */
#ifndef OS_H
#define OS_H

#endif // OS_H
</code></pre>
<ul>
<li>汇编</li>
</ul>

<pre class="language-assembly"><code class="language-assembly">/**
 * 功能：16位与32位的启动混合代码
 *
 *创建时间：2022年8月31日
 *作者：李述铜
 *联系邮箱: 527676163@qq.com
 *相关信息：此工程为《从0写x86 Linux操作系统》的前置课程，用于帮助预先建立对32位x86体系结构的理解。整体代码量不到200行（不算注释）
 *课程请见：https://study.163.com/course/introduction.htm?courseId=1212765805&amp;_trace_c_p_k2_=0bdf1e7edda543a8b9a0ad73b5100990
 */
    #include &quot;os.h&quot;

    // 声明本地以下符号是全局的，在其它源文件中可以访问
    .global _start

    // 指定以下的代码生成16位的机器指令，这样才能在启动时的实模式下运行
    .code16

    // 以下是代码区
    .text
_start: 
    jmp .
</code></pre>
<ul>
<li>qemu</li>
</ul>

<pre class="language-bash"><code class="language-bash">start qemu-system-i386 -m 128M -s -S  -drive file=disk.img,index=0,media=disk,format=raw
</code></pre>
<blockquote>
<ul>
<li><code>qemu-system-i386</code>: 这是 QEMU 模拟器的命令，用于启动一个 x86 架构的虚拟机。</li>
<li><code>-m 128M</code>: 指定虚拟机的内存大小为 128MB。</li>
<li><code>-s</code>: 启用 GDB 调试，允许在虚拟机运行时进行调试。</li>
<li><code>-S</code>: 在启动时停止 CPU，等待调试器连接。这样可以在虚拟机启动前设置调试器。</li>
<li><code>-drive</code>: 指定虚拟机的磁盘映像文件。<ul>
<li><code>file=disk.img</code>: 指定磁盘映像文件的名称为 <code>disk.img</code>。</li>
<li><code>index=0</code>: 指定磁盘的索引为 0。</li>
<li><code>media=disk</code>: 指定磁盘的介质类型为磁盘。</li>
<li><code>format=raw</code>: 指定磁盘映像文件的格式为原始格式，即未经过任何压缩或编码的二进制数据。</li>
</ul>
</li>
</ul>
<p>总之，这个命令的作用是启动一个 x86 架构的虚拟机，并加载一个名为 <code>disk.img</code> 的磁盘映像文件，同时启用 GDB 调试功能。</p>
</blockquote>
<h2 id="%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F">启动方式</h2>
<p>首先使用的是16位的模式, 之后会启用BIOS, BIOS进行自检, 运行引导代码, 之后进入操作系统</p>
<p>前三部分是不能控制的, 但是后面的引导代码等是可以自己写的</p>
<h3 id="%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B">启动流程</h3>
<p>这一堂课使用了一块硬盘, disk.img硬盘, 一般的情况下硬盘是按照数据块512字节进行的, 这是读取的最小单位</p>
<p>还有一块自己的内存, 可以在任意位置进行读取</p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001637.png" alt="Screenshot_20230908_100954_com.xiaoe.client" /></p>
<p>BIOS会检查硬盘的第一个扇区的最后两个字节如果是上面的两个数据, 就会进行拷贝, 之后进行执行, 拷贝到0x7c00位置, os.bin文件会通过dd命令写入disk.img文件的开头</p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001638.png" alt="image-20230908102628762" /></p>
<p>没有加载有效字节的结果</p>

<pre class="language-c"><code class="language-c">    #include &quot;os.h&quot;

    // 声明本地以下符号是全局的，在其它源文件中可以访问
    .global _start

    // 指定以下的代码生成16位的机器指令，这样才能在启动时的实模式下运行
    .code16

    // 以下是代码区
    .text
_start: 
    jmp .

    .org 0x1fe				//十进制是510,在这里跳转到对应的位置
    .byte 0x55, 0xaa
</code></pre>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001639.png" alt="image-20230908103332365" /></p>
<blockquote>
<p>识别成功</p>
</blockquote>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001640.png" alt="image-20230908103606213" /></p>
<blockquote>
<p>指令执行的位置到达对应的位置</p>
</blockquote>
<h2 id="x86%E5%A4%84%E7%90%86%E5%99%A8%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B">x86处理器编程模型</h2>
<h3 id="%E5%86%85%E6%A0%B8%E5%AF%84%E5%AD%98%E5%99%A8">内核寄存器</h3>
<ul>
<li>通用寄存器</li>
</ul>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001641.png" alt="Screenshot_20230908_104010_com.xiaoe.client" /></p>
<blockquote>
<p>可以利用不同的名字对各个寄存器的不同位置进行操作</p>
<p>ABCD寄存器是通用寄存器, 16位的时候BX可以用来寻址, 32位的时候都可以</p>
<p>BP:基指针寄存器</p>
<p>SP和SS指向栈</p>
<p>SI和DI一般用于传递数据</p>
</blockquote>
<ul>
<li>段寄存器</li>
</ul>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001642.png" alt="Screenshot_20230908_104329_com.xiaoe.client" /></p>
<blockquote>
<p>CS和IP指向下一条指令</p>
<p>DS数据段寄存器</p>
</blockquote>
<p>早期的十六位CPU访问的范围比较小, 所以设置一个起始位置, 之后在上面进行叠加访问</p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001643.png" alt="Screenshot_20230908_104618_com.xiaoe.client" /></p>
<blockquote>
<p>段寄存器的值会进行左移四位, 用来扩大储存数据的位置</p>
</blockquote>
<blockquote>
<p>在这时候把这些全部设置为0, 为了简化操作, 之后直接进行访问就可以了, 这里只设置上面的几个寄存器DS, SS, ES(附加扩展段)</p>
<p>CS不可以用mov直接写, 可以用jmp设置</p>
</blockquote>
<blockquote>
<p>写操作时，会写入96位，其中源操作数的16位写入到段寄存器的段选择子部分，另外80位会根据段选择子从GDT表（全局描述表）中获取.</p>
</blockquote>
<ul>
<li>EIP</li>
</ul>
<p>指定当前的程序运行到的位置</p>
<ul>
<li>状态寄存器EFLAGS</li>
</ul>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202401261458367.png" alt="image-20240126145805261" /></p>
<p>有一些标志位</p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202401261458886.png" alt="image-20240126145850827" /></p>

<pre class="language-assembly"><code class="language-assembly">    #include &quot;os.h&quot;

    // 声明本地以下符号是全局的，在其它源文件中可以访问
    .global _start

    // 指定以下的代码生成16位的机器指令，这样才能在启动时的实模式下运行
    .code16

    // 以下是代码区
    .text
_start: 
    jmp $0, $offset			//这个是用来设置cs寄存器的, 可以不加,因为会自动跳转
offset:
    mov $0, %ax				//不能直接对段寄存器进行写入,通过ax进行中转
    mov %ax, %ds
    mov %ax, %es
    mov %ax, %ss
    mov %ax, %gs
    mov %ax, %fs

    jmp .

    .org 0x1fe				//十进制是510,在这里跳转到对应的位置
    .byte 0x55, 0xaa
</code></pre>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001644.png" alt="image-20230908123951948" /></p>
<ul>
<li>配置栈空间</li>
</ul>
<p>设置为栈空间的末尾地址</p>

<pre class="language-c"><code class="language-c">    #include &quot;os.h&quot;

    // 声明本地以下符号是全局的，在其它源文件中可以访问
    .global _start

    // 指定以下的代码生成16位的机器指令，这样才能在启动时的实模式下运行
    .code16

    // 以下是代码区
    .text
_start:
    jmp $0, $offset			//设置cs为0
offset:
    mov $0, %ax
    mov %ax, %ds
    mov %ax, %es
    mov %ax, %ss
    mov %ax, %gs
    mov %ax, %fs
    mov $_start, %esp		//在这里设置栈顶指针
    jmp .

    .org 0x1fe				//十进制是510,在这里跳转到对应的位置
    .byte 0x55, 0xaa
</code></pre>
<h2 id="%E5%8A%A0%E8%BD%BD%E8%87%AA%E5%B7%B1%E7%9A%84%E5%89%A9%E4%BD%99%E7%A8%8B%E5%BA%8F">加载自己的剩余程序</h2>
<p>由于第一块的内存太小, 不够存储所有的代码, 所以需要加载后面的程序</p>
<p>BIOS会提供一些中断, 这里使用的中断是INT 13, 在0地址会有一个中断向量表, 跳转到BIOS的处理函数</p>
<p>入口参数:</p>
<ul>
<li>ah= 2表示读扇区、3表示写扇区</li>
<li>al=读取/写入的扇区数</li>
<li>ch=磁道号</li>
<li>cl=扇区号</li>
<li>dh=磁头号(对于软盘即面号，对软盘—个面用一个磁头来读写)</li>
<li>dl=驱动器号软驱从0开始，0:软驱A、1:软驱B。硬盘从80H开始，80H:硬盘C、81H:硬盘D</li>
<li>es:bx指向接收从扇区读入数据的内存区/指向将写入磁盘的数据</li>
</ul>
<p>之前将es设置为0, 所以这里需要设置bx的保存的位置</p>
<p>读取失败的话会把EFLAGS里面的CF设置为1</p>

<pre class="language-assembly"><code class="language-assembly">_start:

    mov $0, %ax
    mov %ax, %ds
    mov %ax, %es
    mov %ax, %ss
    mov %ax, %gs
    mov %ax, %fs
    mov $_start, %esp

read_self_all:
    //首先设置读取到的位置
    mov $0x7E00, %bx
    //在这里设置开始的扇区数
    mov $0x2, %cx
    //在这里设置的是读取的数量,以及是使用的读取模式, 低位是64个扇区, 高位的2是读取磁盘
    mov $0x240, %ax
    //在这里设置读取的是C盘, 第一块磁盘
    mov $0x80, %dx
    /调用中断
    int $0x13
    //读取失败再次读取
    jc read_self_all


    jmp .
</code></pre>
<ul>
<li>测试</li>
</ul>

<pre class="language-assembly"><code class="language-assembly">    jmp .

    //以下是标志位
    .org 0x1fe				//十进制是510,在这里跳转到对应的位置
    .byte 0x55, 0xaa

    .fill 64*1024, 1, 0x25
</code></pre>
<blockquote>
<p>在后面填进去一些数据</p>
</blockquote>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001645.png" alt="image-20230908193552168" /></p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001646.png" alt="image-20230908193533914" /></p>
<blockquote>
<p>img文件以及运行时候内存的文件, 在运行的时候使用这一个命令可以查看对应位置的内存</p>
</blockquote>
<h2 id="%E8%BF%9B%E5%85%A5%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F">进入保护模式</h2>
<p>在进入系统的时候进入的实际上是16位的CPU工作模式(实模式), 之后需要进入32位的模式</p>
<p>通过段寄存器记录一个基地址, 之后通过偏移量进行访问数据, 这一种模式是比较危险的, 可以随意设置段寄存器的位置, 但是进入保护模式之后对于存储的访问会进行一些检查, 还会检查是否超过边界, 还会有中断向量表以及多任务运行的功能</p>
<h3 id="GDT%E8%A1%A8">GDT表</h3>
<blockquote>
<p>这一部分在手册第三章</p>
</blockquote>
<p>CPU需要一些设置, 首先需要一个GDP表, 还需要修改一个寄存器, 还需要修改段寄存器的设置, 这时候存放的是索引, 这个表的位置保存在GDTR寄存器里面, 表里面记录有大小, 位置, 权限等</p>
<p>在进入32位的模式以后段寄存器记录的值实际上是这一个表里面的偏移, 使用某一段记录的信息进行寻址</p>
<p>每一个字段是8字节</p>
<blockquote>
<p>这一个表里面的信息除了可以用来记录地址段, 还可以用来进行记录任务切换信息TSS表的位置等</p>
</blockquote>
<h3 id="%E8%A1%A8%E9%A1%B9%E7%9A%84%E6%A0%BC%E5%BC%8F">表项的格式</h3>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001647.png" alt="image-20230911165013102" /></p>
<blockquote>
<p>Base: 指明段的地址</p>
<p>limit: 段的长度</p>
<p>S: 0的时候是系统段, TSS/LDT等, 1的时候表示这一段是数据段或者代码段</p>
<p>DPL: 段的访问权限, 0-3</p>
<blockquote>
<ul>
<li><strong>DPL = 0</strong>: 最高特权级，通常用于内核态或操作系统核心。</li>
<li><strong>DPL = 1</strong>: 次高特权级，可以用于某些特权操作或驱动程序。</li>
<li><strong>DPL = 2</strong>: 较低的特权级，通常用于一些特定的应用程序。</li>
<li><strong>DPL = 3</strong>: 最低特权级，通常用于用户态程序。</li>
</ul>
</blockquote>
<p>P: 这一个段是否有效</p>
<p>D/B: 代码段的时候制定了操作数和地址是32位还是16位, 栈的时候指定了栈是32位还是16位</p>
<p>G: 指定limit的单位是byte还是4KB</p>
<p>L: 64位下面使用</p>
<p>AVL: 保留</p>
<p>type: 段的类型</p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001648.png" alt="image-20230911170239279" /></p>
</blockquote>
<blockquote>
<p>TSS（任务状态段，Task State Segment）和LDT（局部描述符表，Local Descriptor Table）是处理器在保护模式下管理任务和内存的重要结构。它们各自扮演着不同的角色。</p>
<h3 id="TSS%EF%BC%88%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81%E6%AE%B5%EF%BC%89">TSS（任务状态段）</h3>
<ol>
<li><strong>定义</strong>：TSS 是一种特殊的段描述符，用于存储与特定任务（或线程）状态相关的信息。</li>
<li><strong>作用</strong>：<ul>
<li><strong>保存上下文</strong>：TSS 包含了一些必要的状态信息，如CPU寄存器的值、堆栈指针、段选择子等。这使得操作系统能够在任务切换时保存当前任务的状态并恢复另一个任务的状态。</li>
<li><strong>任务切换</strong>：当处理器执行任务切换时，会加载新的TSS，这样处理器就可以从正确的状态继续执行。</li>
<li><strong>特权级</strong>：TSS可以用于管理任务的特权级（如内核模式和用户模式），确保不同任务之间的隔离和安全。</li>
</ul>
</li>
<li><strong>结构</strong>：TSS 包含多个字段，例如：<ul>
<li>堆栈指针（SS0、ESP0）：用于不同特权级之间的切换。</li>
<li>I/O 权限位图：用于定义该任务可以访问的I/O端口。</li>
</ul>
</li>
</ol>
<h3 id="LDT%EF%BC%88%E5%B1%80%E9%83%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6%E8%A1%A8%EF%BC%89">LDT（局部描述符表）</h3>
<ol>
<li><strong>定义</strong>：LDT 是一种描述符表，允许一个进程（或任务）拥有自己的段描述符，用于定义私有代码段和数据段。</li>
<li><strong>作用</strong>：<ul>
<li><strong>私有段</strong>：LDT允许每个进程有自己的段描述符，进程可以使用这些描述符访问自己的代码和数据而不干扰其他进程的内存空间。</li>
<li><strong>分段支持</strong>：通过LDT，可以实现更灵活的分段管理，使每个任务能够使用不同的段而不影响全局描述符表（GDT）的内容。</li>
</ul>
</li>
<li><strong>结构</strong>：LDT类似于GDT，但其描述符只对特定的进程或任务可见，每个任务可以有自己的LDT。</li>
</ol>
<h3 id="%E6%80%BB%E7%BB%93">总结</h3>
<ul>
<li><strong>TSS</strong> 主要用于任务的状态管理和上下文保存，适用于任务切换。</li>
<li><strong>LDT</strong> 提供了一个机制，使每个任务能够拥有自己的段描述符，支持更细粒度的内存管理和保护。</li>
</ul>
<p>这两者在操作系统的实现中是非常重要的，尤其是在多任务环境中，帮助实现对任务的有效管理和资源的隔离。</p>
</blockquote>
<ul>
<li>第一个表段必须为0</li>
<li>进入模式的时候需要指定一个代码段和一个数据段</li>
</ul>
<h3 id="%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8%28%E8%AE%BE%E7%BD%AE%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E6%AE%B5%29">实际使用(设置一个代码段一个数据段)</h3>
<p>0xcf9a: 1100 1111 1001 1010</p>

<pre class="language-c"><code class="language-c">// 各选择子
#define KERNEL_CODE_SEG         (1 * 8)
#define KERNEL_DATA_SEG         (2 * 8)
//任务段, 设置任务等级为3  之后由于使用LDT便不再使用
#define APP_CODE_SEG            ((3 * 8) | 3)
#define APP_DATA_SEG            ((4 * 8) | 3)

//任务的TSS保存位置
#define TASK0_TSS_SEG           ((5 * 8))
#define TASK1_TSS_SEG           ((6 * 8))
//系统调用
#define SYSCALL_SEG             ((7 * 8))
//保存两个LDT的描述
#define TASK0_LDT_SEG           ((8 * 8))
#define TASK1_LDT_SEG           ((9 * 8))


//这里是任务的LDT的配置
#define TASK_CODE_SEG           (0 * 8 | 0x4 | 3)
#define TASK_DATA_SEG           (1 * 8 | 0x4 | 3)

</code></pre>

<pre class="language-c"><code class="language-c">typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
//这一个表需要进行八字节对齐
struct {uint16_t limit_l, base_l, basehl_attr, base_limit;}gdt_table[256] __attribute__((aligned(8))) = {
    // 0x00cf9a000000ffff - 从0地址开始，P存在，DPL=0，Type=非系统段，32位代码段（非一致代码段），界限4G，
    [KERNEL_CODE_SEG / 8] = {0xffff, 0x0000, 0x9a00, 0x00cf},
    // 0x00cf93000000ffff - 从0地址开始，P存在，DPL=0，Type=非系统段，数据段，界限4G，可读写
    [KERNEL_DATA_SEG/ 8] = {0xffff, 0x0000, 0x9200, 0x00cf},
};
</code></pre>
<blockquote>
<p>这里是初步初始化一个GDT表</p>
</blockquote>
<h3 id="%E5%BC%80%E5%90%AF%E4%BD%BF%E7%94%A8">开启使用</h3>
<ul>
<li>设置GDT的位置之后需要将CR0的最低位PE设置为1(335592-sdm-vol-4.pdf)</li>
</ul>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402042121029.png" alt="image-20240204212101934" /></p>
<blockquote>
<p>lmsw: 将源操作数加载到机器状态字，即寄存器 CR0 的位 0 到 15。源操作数可以是 16 位通用寄存器或内存位置。只有源操作数的低 4 位（也就是 PE、MP、EM 及 TS 标志）会加载到 CR0。CR0 的 PG、CD、NW、AM、WP、NE 及 ET 标志不受影响。操作数大小属性不影响此指令。</p>
</blockquote>
<ul>
<li>之后需要进行一次跳转, 跳转位置是选择子+偏移量, 用于清除流水线(335592-sdm-vol-4.pdf 9.9)</li>
</ul>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402042126603.png" alt="image-20240204212645492" /></p>

<pre class="language-assembly"><code class="language-assembly">    //进入保护模式
    //关中断
    cli
    //加载新的GDT表
    lgdt gdt_desc
    //设置CR0的0位, 操作的时候使用16位的操作寄存器
    mov $1, %eax
    lmsw %ax
    //跳转到内核代码段,进入32位模式,第二个数字是偏移量,也就是C语言程序被复制到的位置, 这一个会改变cs
    jmp $(KERNEL_CODE_SEG),$_start_32
    jmp .

    //以下是标志位
    .org 0x1fe				//十进制是510,在这里跳转到对应的位置
    .byte 0x55, 0xaa
    
    //标记下面是32位, 以及是代码段
    .code32
    .text
_start_32:
    //在这里设置段地址
    mov $KERNEL_DATA_SEG, %ax
    mov %ax, %ds
    mov %ax, %es
    mov %ax, %ss
    mov %ax, %gs
    mov %ax, %fs
    mov $_start, %esp
    jmp .

//这里记录的是GDT表的数据,包括32位的基地址以及16位的大小界限
gdt_desc:
    //界限+地址
    .word (256*8)-1
    .long gdt_table
</code></pre>
<blockquote>
<p>这个gdt_desc的值会放到GDTR寄存器里面, 是一个48位的寄存器, 用来描述GDT表的格式</p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402042117309.png" alt="image-20240204211734186" /></p>
</blockquote>
<ul>
<li>调试</li>
</ul>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001649.png" alt="image-20230911213220046" /></p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001650.png" alt="image-20230911213417535" /></p>
<blockquote>
<p>使用命令<code>info registers</code></p>
</blockquote>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001651.png" alt="image-20230911213826872" /></p>
<blockquote>
<p>进入32位模式</p>
</blockquote>
<h2 id="%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6">分页机制</h2>
<blockquote>
<p>这一部分在手册第四章</p>
</blockquote>
<p>在不使用分页机制的时候, 我们看到的是物理内存, 物理内存有多大, 我们就可以使用多大的内存</p>
<p>使用内存分页机制, 我们就可以扩充访问的地址范围, 也可以实现权限的细分, 实际上就是实现虚拟内存, 将地址进行映射, 看到的内存更大了, 但是实际上可以使用的内存的大小还是不变的</p>
<p>访问过程: 根据段寄存器找到对应的记录的GDT表, 之后根据表找到自己的使用的内存, 加上偏移量之后就是实际的地址, 这一个地址会通过分页机制里面的页表, 页表的地址放在CR3的寄存器里面</p>
<blockquote>
<p>这样会使得用户使用内存的时候感觉是一块连续的内存, 但是实际的内存可能是不连续的</p>
<p>处理器在访问数据、获取指令时，使用的都是线性地址，只要它是连续的就可以了，最终都能够通过映射表找到实际的物理地址。</p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402042145583.png" alt="image-20240204214518458" /></p>
</blockquote>
<ul>
<li>使用4KB的模式, 使用二级页表</li>
</ul>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001652.png" alt="image-20230912091325312" /></p>
<blockquote>
<p>实际的位置使用不同的位进行索引不同的表</p>
</blockquote>
<ul>
<li>使用4M的模式: 使用一级页表</li>
</ul>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402042219580.png" alt="image-20240204221949465" /></p>
<blockquote>
<p>这个是现在使用的</p>
</blockquote>
<blockquote>
<p>会根据传过来的数据的地址(逻辑地址)分段之后进行访问不同的页表, 获得一个4KB的空间的地址, 最后通过偏移量进行实际的访问,  &quot;页表（Page Table）&quot; 或 &quot;页面目录（Page Directory）&quot;</p>
<p>页表有好几级, 这里的图像是两级, 使用逻辑地址的不同位进行索引</p>
<p>这一个表的地址在CR3里面</p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402042209996.png" alt="image-20240204220942889" /></p>
<blockquote>
<p>CR3以及使用4M模式的一级页表(只有这一个表, 不需要二级页表)</p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202503011556590.png" alt="image-20250301155653454" /></p>
</blockquote>
</blockquote>
<blockquote>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402042212168.png" alt="image-20240204221254066" /></p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402042211993.png" alt="image-20240204221129884" /></p>
<blockquote>
<p>使用4KB模式的时候的一二级页表</p>
</blockquote>
</blockquote>
<blockquote>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402042157676.png" alt="image-20240204215743557" /></p>
<blockquote>
<ol>
<li><strong>PWT (Page-level Write-Through)</strong>:<ul>
<li>该位控制是否使用“直写（Write-Through）”缓存策略。</li>
<li>当 PWT 位被设置时，CPU 使用直写缓存策略，这意味着数据会同时写入缓存和主存。</li>
<li>如果 PWT 位未设置，则可能使用回写（Write-Back）缓存策略，数据先写入缓存，稍后再写回主存。</li>
</ul>
</li>
<li><strong>PCD (Page-level Cache Disable)</strong>:<ul>
<li>该位控制是否禁用缓存。</li>
<li>当 PCD 位被设置时，页面目录的访问将绕过缓存，直接访问主存。</li>
<li>如果 PCD 位未设置，则允许缓存页面目录的访问。</li>
</ul>
</li>
</ol>
<p>地址是4096对齐的, 所以低位都是0</p>
</blockquote>
<p>使用CR4以及CR0控制实际使用的模式</p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402051419994.png" alt="image-20240205141932827" /></p>
<blockquote>
<p>这一个位控制使用分页</p>
</blockquote>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402042208601.png" alt="image-20240204220801499" /></p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402042202892.png" alt="image-20240204220257786" /></p>
<blockquote>
<p>使用这一个位开启4MB的模式</p>
</blockquote>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402042216439.png" alt="image-20240204221645335" /></p>
</blockquote>
<h3 id="%E5%AE%9E%E9%99%85%E7%9A%84%E5%AE%9E%E7%8E%B0">实际的实现</h3>
<p>第一级映射(页目录表PDE)有两种的格式, 一种是4MB的映射, 一种是4KB的映射使用4MB模式的时候, 就不需要二级页表了, 只有一个表, 最后可以使用的内存实际上是4MB, 使用4KB模式的时候会使用两级页表, 最后实际控制的内存大小是4GB</p>
<p>第二级映射(页表PTE)</p>
<h4 id="%E5%AE%9E%E9%99%85%E5%AE%9E%E7%8E%B0%E4%B8%80%E7%BA%A7%E6%98%A0%E5%B0%84%284MB%29">实际实现一级映射(4MB)</h4>
<p>需要在打开页表之前实现映射, 否则CPU会找不到对应的内存, 直接映射到0地址的位置</p>

<pre class="language-c"><code class="language-c">//这个表是否有效
#define PDE_P                   (1&lt;&lt;0)
//是否可写
#define PDE_W                   (1&lt;&lt;1)
//是否可以被低权限访问
#define PDE_U                   (1&lt;&lt;2)
//设置使用的模式(4M模式)
#define PDE_PS                  (1&lt;&lt;7)

//定义一个页表的结构体,需要设置低0的表项
//这一个设置的是逻辑地址0地址的分页, 是一个恒等的映射, 使得代码的访问正常, 映射 的地址还是0
uint32_t pg_dir[1024] __attribute__((aligned(4096))) = {
    [0] = (0) | PDE_P |  PDE_W | PDE_U | PDE_PS;
};
</code></pre>
<blockquote>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402042205861.png" alt="image-20240204220553713" /></p>
</blockquote>

<pre class="language-assembly"><code class="language-assembly">_start_32:
    //在这里设置段地址
    mov $KERNEL_DATA_SEG, %ax
    mov %ax, %ds
    mov %ax, %es
    mov %ax, %ss
    mov %ax, %gs
    mov %ax, %fs
    mov $_start, %esp

    //打开页表, 记录位置
    mov $pg_dir, %eax
    mov %eax, %cr3
    //CR4里面有一个位控制是否允许这一个模式 
    mov %cr4, %eax
    orl $(1&lt;&lt;4), %eax
    mov %eax, %cr4
    //还需要控制PR0最高位w为1
    mov %cr0, %eax
    orl $(1&lt;&lt;31), %eax
    mov %eax, %cr0

    jmp .
</code></pre>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001653.png" alt="image-20230912100752988" /></p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001654.png" alt="image-20230912100916065" /></p>
<blockquote>
<p>分页打开后, 可以使用这一个命令查看映射关系, 权限是u: 用户 r: 读 w: 写</p>
</blockquote>
<h4 id="%E5%AE%9E%E9%99%85%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BA%A7%E6%98%A0%E5%B0%84">实际实现二级映射</h4>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402042232954.png" alt="image-20240204223228835" /></p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402051433652.png" alt="image-20240205143304590" /></p>
<blockquote>
<p>一级表, bit7为0</p>
</blockquote>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402051432287.png" alt="image-20240205143202219" /></p>
<blockquote>
<p>二级表, bit7为1</p>
</blockquote>

<pre class="language-c"><code class="language-c">//一级页表
//使用位字段的语法
typedef union _pdet_t {
    uint32_t v;
    struct {
        uint32_t present : 1;
        uint32_t write_enable : 1;
        uint32_t user_mode_acc : 1;
        uint32_t write_through : 1;
        uint32_t cache_disable :1;
        uint32_t access : 1;
        uint32_t : 1;
        uint32_t ps : 1;
        uint32_t : 4;
        uint32_t phy_paddr : 20;
    };
}pdet_t;

typedef union _pet_t {
    uint32_t v;
    struct {
        uint32_t present : 1;
        uint32_t write_enable : 1;
        uint32_t user_mode_acc : 1;
        uint32_t write_through : 1;
        uint32_t cache_disable :1;
        uint32_t access : 1;
        uint32_t dirty : 1;
        uint32_t pat : 1;
        uint32_t global : 1;
        uint32_t : 3;
        uint32_t phy_paddr : 20;
    };
}pte_t;
</code></pre>

<pre class="language-c"><code class="language-c">//这个表是否有效
#define PDE_P                   (1&lt;&lt;0)
//是否可写
#define PDE_W                   (1&lt;&lt;1)
//是否可以被低权限访问
#define PDE_U                   (1&lt;&lt;2)
//设置使用的模式4KB/4MB
#define PDE_PS                  (1&lt;&lt;7)
//新建另一个映射的地址
#define MAG_ADDR                0x80000000
//使用二级表进行控制内存测试, 这里是实际上的地址
uint8_t map_phy_buffer[4096] __attribute__((aligned(4096))) = {0x36};
//创建一个二级表项,随便给一个值,在后面会进行设置,随便初始化一个值连接器会把其他的位置设置为0,否则会为随机的
static uint32_t page_table[1024] __attribute__((aligned(4096))) = {PDE_U};

//定义一个页表的结构体,需要设置低0的表项
uint32_t pg_dir[1024] __attribute__((aligned(4096))) = {
    [0] = (0) | PDE_P |  PDE_W | PDE_U | PDE_PS,
};

void os_init(void){
    //设置一级表,使用的是表的高10位,这里会找到想要的虚拟地址所在的位置,设置为二级表的位置
    /********************************************************************************/
    //计算一下4KB的话对应的表项 = 二级表项地址+权限(这里没有使用4M的映射(PDE_PS))
    pg_dir[MAG_ADDR&gt;&gt;22] = (uint32_t)page_table | PDE_P | PDE_W | PDE_U;
    /********************************************************************************/
    //初始化表的二级,这里是实际的地址,之后需要设置对应的位置,这里会设置二级表指向的是上面的数组
    page_table[(MAG_ADDR&gt;&gt;12)&amp;0x3ff] = (uint32_t)map_phy_buffer | PDE_P | PDE_W | PDE_U;

}
</code></pre>
<blockquote>
<p>实际的地址计算</p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402042233790.png" alt="image-20240204223356678" /></p>
</blockquote>

<pre class="language-assembly"><code class="language-assembly">_start_32:
    //在这里设置段地址
    mov $KERNEL_DATA_SEG, %ax
    mov %ax, %ds
    mov %ax, %es
    mov %ax, %ss
    mov %ax, %gs
    mov %ax, %fs
    mov $_start, %esp
    //在这里调用设置4KB的分页表
    call os_init
    # 打开页表机制
    mov $pg_dir, %eax
    mov %eax, %cr3
    //CR4里面有一个位控制是否允许这一个模式(这一个没用上)
    mov %cr4, %eax
    orl $(1&lt;&lt;4), %eax
    mov %eax, %cr4
    //还需要控制PR0最高位w为1
    mov %cr0, %eax
    orl $(1&lt;&lt;31), %eax
    mov %eax, %cr0

    jmp .
</code></pre>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402051441552.png" alt="image-20240205144130516" /></p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001655.png" alt="image-20230912144435370" /></p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001656.png" alt="image-20230912144527920" /></p>
<blockquote>
<p>在修改之后发现两个位置是同步的, 可以直接操控第二个映射地址或者采用第一个映射的地址</p>
</blockquote>
<h3 id="%E6%80%BB%E7%BB%93">总结</h3>
<p>也就是说，在没有开启分页机制时，由程序员给出的<strong>逻辑地址</strong>，需要先通过分段机制转换成物理地址。但在开启分页机制后，逻辑地址仍然要先通过分段机制进行转换，只不过转换后不再是最终的物理地址，而是<strong>线性地址</strong>，然后再通过一次分页机制转换，得到最终的物理地址。</p>
<h2 id="%E5%BC%80%E5%90%AF%E5%AE%9A%E6%97%B6%E5%99%A8">开启定时器</h2>
<p>8253定时器, 频率1193180, 16位计数器</p>
<p>一般情况下是内置在CPU里面的, 不需要了解所有的, 因为现在已经内置在CPU里面很多并不需要了解</p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001657.png" alt="image-20230913092705738" /></p>
<p>定时器连接在IRQ0, 一共有三个定时器,其他的中断进行屏蔽</p>
<h3 id="IDT%E8%A1%A8%28%E4%B8%AD%E6%96%AD%E5%90%91%E9%87%8F%E8%A1%A8%29">IDT表(中断向量表)</h3>
<blockquote>
<p>手册6.11</p>
</blockquote>
<p>IDTR寄存器进行控制, 中断发生的时候会参考这一个表进行进行处理, 表里面记录的值是段的选择子以及偏移, 用于查找一个一个GDT表的表项, 应该是代码段的描述符, 之后使用offset进行偏移</p>
<p>定时器的中断会使用0x20位置的中断</p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001658.png" alt="image-20230913093734029" /></p>
<blockquote>
<p>Segment Selector 这里记录是段选择子, 指向GDT表的某一个段, 这里应该是代码段</p>
<p>Offset 偏移, 具体的处理函数所在的位置</p>
<p>D 表示是否是32位模式</p>
<p>P 存在的标志位</p>
<p>通过中断门进入中断服务程序时cpu会自动将中断关闭，也就是将cpu中eflags寄存器中IF标志复位，防止嵌套中断的发生；而通过陷阱门进入服务程序时则维持IF标志不变。</p>
</blockquote>
<h3 id="%E5%AE%9E%E9%99%85%E7%9A%84%E5%AE%9E%E7%8E%B0">实际的实现</h3>
<p>对于intel架构的CPU在操控外设的寄存器的时候使用命令out, ARM的时候直接操控寄存器映射</p>
<p>中断在使用的时候需要设置具体的表项,前面的表项已经被CPU使用了</p>
<blockquote>
<p>手册6.3章节</p>
<p>时钟实际使用的是IRQ0, 需要查找的位置是0x20, 从片使用的位置是0x28开始</p>
</blockquote>

<pre class="language-assembly"><code class="language-assembly">
    #include &quot;os.h&quot;

    // 声明本地以下符号是全局的，在其它源文件中可以访问,在这里声明中断处理函数
    .global _start, timer_int

    // 指定以下的代码生成16位的机器指令，这样才能在启动时的实模式下运行
    .code16

    // 以下是代码区
    .text
    
    ...
    
    //关中断
    cli
    //加载新的GDT表
    lgdt gdt_desc
    //加载中断向量表
    lidt idt_desc

    ...
    
_start_32:

    ...
    //在这里跳转到C文件初始化中断以及初始化段
    call os_init
    //打开页表
    mov $pg_dir, %eax
    mov %eax, %cr3
    //CR4里面有一个位控制是否允许这一个模式 
    mov %cr4, %eax
    orl $(1&lt;&lt;4), %eax
    mov %eax, %cr4
    //还需要控制PR0最高位w为1
    mov %cr0, %eax
    orl $(1&lt;&lt;31), %eax
    mov %eax, %cr0

    //打开中断
    sti
    jmp .
//中断处理函数
timer_int:

    //对寄存器进行保护
    push %ds
    pusha

    //清除中断
    mov $0x20, %al
    outb %al, $0x20
    
    popa
    pop %ds
    
    iret

//这里记录的是GDT表的数据,包括32位的基地址以及16位的大小界限
gdt_desc:
    //界限+地址
    .word (256*8)-1
    .long gdt_table
//描述中断的数据
idt_desc:
    //界限+地址
    .word (256*8)-1
    .long idt_table
</code></pre>

<pre class="language-c"><code class="language-c">//中断向量表
struct {uint16_t offset_l, selector, attr, offset_h;}idt_table[256] __attribute__((aligned(8)));
//对汇编指令进行一个封装
void outb(uint8_t data,uint16_t port){
    //这里传入两个数据,第一个数据是data,第二个数据是port,之后进行数据的关联,&quot;d&quot;会识别为%dx,之后会把port放进去
    __asm__ __volatile__(&quot;outb %[v], %[p]&quot;::[p]&quot;d&quot;(port), [v]&quot;a&quot;(data));
}

//在汇编文件中实现的中断处理函数
void timer_int(void);
//初始化一个页表,并在之后设置为0x80000000映射到这一个数组的位置
void os_init(void){
    //初始化定时器
    //初始化中断控制器(使用0x20 0x21控制主片以及使用0xA0和0xA1控制从片)
    outb(0x11, 0x20);
    outb(0x11, 0xA0);
    //设置主片的中断起始位置
    outb(0x20, 0x21);
    //设置从片的中断起始位置
    outb(0x28, 0xa1);
    //设置从片连接主片的位置
    outb((1&lt;&lt;2), 0x21);
    //设置从片连接主片使用的引脚
    outb(2, 0xa1);
    //设置连接的模式
    outb(0x1,0x21);
    outb(0x1,0xa1);
    //设置中断的屏蔽, 这里只打开定时器的中断
    outb(0xfe,0x21);
    outb(0xff,0xa1);
    //配置外部时钟源,是一个16位的计数器,减到0的时候会产生中断,这里计算每秒产生100次中断大概需要的数值
    int tmo = 1193180 / 100;//使用实际的频率除以100使得每秒100次中断
    //写入数值
    //设置使用的时钟以及自动加载
    outb(0x36, 0x43);
    //中断频率的设置
    outb((uint8_t)tmo, 0x40);
    outb(tmo&gt;&gt;8, 0x40);
    //记录中断处理函数的地址
    idt_table[0x20].offset_l = (uint32_t)timer_int &amp; 0xffff;
    idt_table[0x20].offset_h = (uint32_t)timer_int &gt;&gt; 16;
    idt_table[0x20].selector = KERNEL_CODE_SEG;
    //设置为中断门,32位模式
    idt_table[0x20].attr = 0x8e00;

    //设置一级表,使用的是表的高10位
    pg_dir[MAG_ADDR&gt;&gt;22] = (uint32_t)page_table | PDE_P | PDE_W | PDE_U;
    //初始化表的二级,这里是实际的地址,之后需要设置对应的位置
    page_table[(MAG_ADDR&gt;&gt;12)&amp;0x3ff] = (uint32_t)map_phy_buffer | PDE_P | PDE_W | PDE_U;
}

</code></pre>
<ul>
<li>任务门(task gate)</li>
</ul>
<p>当中断信号发生时，必须取代当前进程的那个进程的TSS选择符存放在任务门中。</p>
<ul>
<li>中断门(interruptgate)</li>
</ul>
<p>包含段选择符和中断或异常处理程序的段内偏移量.当控制权转移到一个适当的段 时，处理器 清IF标志，从而关闭将来会发生的可屏蔽中断., 主要是为了INTR中断(计算机系统中的一种机制，用于在CPU执行程序时，暂停当前程序的执行，转而执行其他程序或处理器的中断请求)。</p>
<ul>
<li>陷阱门(Trap gate)</li>
</ul>
<p>与中断门相似，只是控制权传递到一个适当的段时处理器不修改IF标志.所以依旧会产生INTR中断</p>
<h3 id="%E6%80%BB%E7%BB%93">总结</h3>
<p>在使用分页以后在进行访问内存的时候, 首先会进行分页表找到实际的物理地址, 之后在根据GDT表对实际的物理地址权限等进行分类, 最后在进行操作</p>
<h2 id="%E5%88%87%E6%8D%A2%E5%88%B0%E4%BD%8E%E7%89%B9%E6%9D%83%E6%A8%A1%E5%BC%8F">切换到低特权模式</h2>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001659.png" alt="image.png" /></p>
<p>最高等级一般是操作系统, 可以访问所有的资源Level 0, 应用一般使用最低等级</p>
<p>只允许访问相同等级或者低权限的代码或者数据</p>
<p>用户级不允许执行一些命令, 以及不允许访问一些区域, 方便操作系统对其进行检测, 杀掉或者进行其他处理</p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402061944137.png" alt="image-20240206194427159" /></p>
<p>CPU会执行CS指针指向的代码段, CS的最低两位CPL代表的是访问的时候的特权等级, GDT表里面的DPL设置的是这一个段的访问权限, 其他的段寄存器最低位存放的是RPL进行特权级的检查</p>
<blockquote>
<p>段选择子是8byte为单位的, 所以低两位没有使用</p>
</blockquote>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402201751004.png" alt="image-20240220175154923" /></p>
<blockquote>
<p>这个时候的权限只有DPL&gt;=Max(CPL, RPL)的时候才可以访问, 自己的权限要高, 不能主动把自己的权限降低</p>
<p>访问SS(栈段寄存器)的时候需要CPL=DPL=RPL</p>
</blockquote>
<p>在GDP里还有一个C位(Type里面)</p>
<ul>
<li>C=0(用的这一个)</li>
</ul>
<p>CPL必须等于DPL, 并且RPL&lt;=CPL的时候才可以访问</p>
<ul>
<li>C=1</li>
</ul>
<p>CPL&gt;=DPL, RPL不检查, 访问者的权限比较低的时候可以访问</p>
<h3 id="%E8%AE%BE%E8%AE%A1%E4%B8%80%E6%AE%B5%E8%BF%9B%E7%A8%8B">设计一段进程</h3>
<p>进程不可以使用内核段的数据段以及数据段, 这里给它添加两个段</p>

<pre class="language-c"><code class="language-c">struct {uint16_t limit_l, base_l, basehl_attr, base_limit;}gdt_table[256] __attribute__((aligned(8))) = {
    // 0x00cf9a000000ffff - 从0地址开始，P存在，DPL=0，Type=非系统段，32位代码段（非一致代码段），界限4G，
    [KERNEL_CODE_SEG / 8] = {0xffff, 0x0000, 0x9a00, 0x00cf},
    // 0x00cf93000000ffff - 从0地址开始，P存在，DPL=0，Type=非系统段，数据段，界限4G，可读写
    [KERNEL_DATA_SEG/ 8] = {0xffff, 0x0000, 0x9200, 0x00cf},
    //这里是进程使用的段, 这里使用的是重合的模式, 设置优先级为3
    [APP_CODE_SEG /8] = {0xffff, 0x0000, 0xfa00, 0x00cf},
    [APP_DATA_SEG /8] = {0xffff, 0x0000, 0xf300, 0x00cf},
};
</code></pre>
<ul>
<li>实际的特权切换</li>
</ul>
<p>在切换的时候不能使用jmp指令, 而是应该使用iret命令从中断返回的指令, 需要对栈进行配置(模拟从中断返回)</p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001660.png" alt="image.png" /></p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001909.png" alt="image-20240206200132789" /></p>
<blockquote>
<p>手册6.12</p>
</blockquote>
<p>这里相当于从一个中断函数进行返回, 在进入中断的时候会自动保存上面右侧显示的寄存器内容, SS栈的段寄存器, ESP栈的指针, CS代码段段寄存器, EIP指令对应的地址, 返回的时候会自动设置这些值</p>
<blockquote>
<p>为了进行特权级的切换, 需要把这两个段寄存器的最低位设置为3, 标志使用用户等级的段</p>
</blockquote>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001661.png" alt="image-20230920130514065" /></p>
<blockquote>
<p>这设置设个的时候主要是需要设置中断标志位为使能中断,设置为0x202(0010 0000 0010)</p>
</blockquote>
<h3 id="%E5%AE%9E%E9%99%85%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%BB%A3%E7%A0%81">实际实现的代码</h3>

<pre class="language-c"><code class="language-c">//任务段, 设置任务等级为3  之后由于使用LDT便不再使用
#define APP_CODE_SEG            ((3 * 8) | 3)
#define APP_DATA_SEG            ((4 * 8) | 3)
</code></pre>

<pre class="language-assembly"><code class="language-assembly">    //打开中断, 由于在进入任务的时候会设置IF位, 所以在这里的时候不再进行设置
    //sti
    
    //设置进入低特权级时候的所需要的栈
    push $APP_DATA_SEG
    //设置栈的指针
    push $0
    //设置EFLAGS, 主要是设置中断的状态
    push $0x202
    //这是代码段
    push $APP_CODE_SEG
    push $task_0_entry

    //在这里进入低特权级
    iret
    jmp .

//进程0
task_0_entry:
    jmp .
</code></pre>
<blockquote>
<p>这时候会出现异常, 这是因为CPU在出战的时候会进行检查, 这时候发现代码段数据段的最低位没有设置为对应的权限</p>
</blockquote>

<pre class="language-c"><code class="language-c">// 各选择子
#define KERNEL_CODE_SEG         (1 * 8)
#define KERNEL_DATA_SEG         (2 * 8)
#define APP_CODE_SEG            ((3 * 8) | 3)
#define APP_DATA_SEG            ((4 * 8) | 3)
</code></pre>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001662.png" alt="img" /></p>
<blockquote>
<p>进入特权级3的模式</p>
</blockquote>
<ul>
<li>之后需要给这一个特权级的任务定义一个数组作为栈</li>
</ul>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001663.png" alt="image-20230920230330223" /></p>
<blockquote>
<p>最好先把中断关掉, 否则会死机(先push一个0给EFLOG), 这是因为没有设置TSS, 进入中断的话没有可以使用的栈</p>
</blockquote>
<h2 id="%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%28%E4%BD%BF%E7%94%A8TSS%29">实现任务切换(使用TSS)</h2>
<blockquote>
<p>• The current program, task, or procedure executes a JMP or CALL instruction to a TSS descriptor in the GDT.</p>
<p>• The current program, task, or procedure executes a JMP or CALL instruction to a task-gate descriptor in the  GDT or the current LDT.</p>
</blockquote>
<p>x86实现了任务切换的硬件上的支持, 只需要给每一个任务一个TSS就可以方便的使用一条指令进行任务切换</p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001664.png" alt="image.png" /></p>
<blockquote>
<p>x86使用一个这样的结构进行保存任务的状态</p>
<p>这里面存放的是当前任务的状态, CPU会自动把寄存器的状态存放在这里面</p>
<p>这里面的SS, ESP等有多个是给不同特权级的时候使用不同的段, 在处理终中断的时候使用不同的栈</p>
<p>在使用的时候可以使用一个jmp指令进行跳转</p>
<p>使用<strong>TR寄存器</strong>指向当前的任务</p>
</blockquote>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001665.png" alt="image-20230920232807856" /></p>
<blockquote>
<p>在产生中断的时候会从特权级0的位置找到栈, 之后执行中断相关的内容</p>
</blockquote>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001666.png" alt="image-20230921083651573" /></p>
<p>需要在GDT里面使用两个段来记录两个任务的TSS, 通过GDT的描述符进行区分</p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001667.png" alt="image.png" /></p>
<blockquote>
<p>Base: 起始地址</p>
<p>Segment Limit: 界限-1</p>
<p>DPL: 段的访问权限, 0-3</p>
<p>P: 这一个段是否有效</p>
<p>G: 指定limit的单位是byte还是4KB</p>
<p>AVL: 保留</p>
<p>type: 段的类型</p>
<p>B: 忙标志</p>
</blockquote>

<pre class="language-c"><code class="language-c">//任务的TSS保存位置
#define TASK0_TSS_SEG           ((5 * 8))
#define TASK1_TSS_SEG           ((6 * 8))

//这一个表需要进行八字节对齐
struct {uint16_t limit_l, base_l, basehl_attr, base_limit;}gdt_table[256] __attribute__((aligned(8))) = {
    ....
    //TSS表, 由于直接使用一个数组作为TSS会导致报错,这里基地址初始化为0, 后面在C语言里面加地址
    [TASK0_TSS_SEG /8] = {0x68, 0, 0xe900, 0},
    [TASK1_TSS_SEG /8] = {0x68, 0, 0xe900, 0},
};
....
//初始化几个32位的栈, 使用模式为特权级3
uint32_t task0_dpl3_stack[1024];//用户级的栈
uint32_t task1_dpl3_stack[1024];
uint32_t task0_dpl0_stack[1024];//系统级的栈
uint32_t task1_dpl0_stack[1024];

//定义一个TSS结构
//任务切换的时候栈之类的寄存器不会保存, 需要初始化设置
uint32_t task0_tss[] = {
    // prelink, esp0, ss0, esp1, ss1, esp2, ss2
    0,  (uint32_t)task0_dpl0_stack + 4*1024, KERNEL_DATA_SEG , /* 后边不用使用 */ 0x0, 0x0, 0x0, 0x0,
    // cr3, eip, eflags, eax, ecx, edx, ebx, esp, ebp, esi, edi,
    (uint32_t)pg_dir,  (uint32_t)task_0/*入口地址*/, 0x202, 0xa, 0xc, 0xd, 0xb, (uint32_t)task0_dpl3_stack + 4*1024/* 栈 */, 0x1, 0x2, 0x3,
    // es, cs, ss, ds, fs, gs, ldt, iomap
    APP_DATA_SEG, APP_CODE_SEG, APP_DATA_SEG, APP_DATA_SEG, APP_DATA_SEG, APP_DATA_SEG, 0x0, 0x0,
};
//设置要切换的任务的栈以及任务的入口
uint32_t task1_tss[] = {
    // prelink, esp0, ss0, esp1, ss1, esp2, ss2
    0,  (uint32_t)task1_dpl0_stack + 4*1024, KERNEL_DATA_SEG , /* 后边不用使用 */ 0x0, 0x0, 0x0, 0x0,
    // cr3, eip, eflags, eax, ecx, edx, ebx, esp, ebp, esi, edi,
    (uint32_t)pg_dir,  (uint32_t)task_1/*入口地址*/, 0x202, 0xa, 0xc, 0xd, 0xb, (uint32_t)task1_dpl3_stack + 4*1024/* 栈 */, 0x1, 0x2, 0x3,
    // es, cs, ss, ds, fs, gs, ldt, iomap
    APP_DATA_SEG, APP_CODE_SEG, APP_DATA_SEG, APP_DATA_SEG, APP_DATA_SEG, APP_DATA_SEG, 0x0, 0x0,
};

.....
    //这里使用的内存比较小
    gdt_table[TASK0_TSS_SEG / 8].base_l = (uint16_t)(uint32_t)task0_tss;
    gdt_table[TASK1_TSS_SEG / 8].base_l = (uint16_t)(uint32_t)task1_tss;
</code></pre>
<ul>
<li>使用TR寄存器保存当前的任务的TSS对应的GDT位置, 需要使用汇编指令设置这一个值</li>
</ul>

<pre class="language-assembly"><code class="language-assembly">    //告诉CPU正在运行的任务
    mov $TASK0_TSS_SEG, %ax
    ltr %ax
</code></pre>

<pre class="language-assembly"><code class="language-assembly">//中断处理函数
timer_int:

    //对寄存器进行保护
    push %ds
    pusha

    //清除中断
    mov $0x20, %al
    outb %al, $0x20
    //配置使用的数据段, 因为处于特权级0, 需要访问
    mov $KERNEL_DATA_SEG, %ax
    mov %ax, %ds
    //调用切换任务的函数
    call task_sched

    popa
    pop %ds
    
    iret
</code></pre>

<pre class="language-c"><code class="language-c">void task_sched(void){
    static int task_tss = TASK0_TSS_SEG;

    task_tss = (task_tss == TASK0_TSS_SEG) ? TASK1_TSS_SEG : TASK0_TSS_SEG;
    uint32_t addr[] = {0, task_tss};//偏移以及选择子
    __asm__ __volatile__(&quot;ljmpl *(%[a])&quot;::[a]&quot;r&quot;(addr));
}
</code></pre>
<blockquote>
<p><code>*()</code> 是通过间接寻址方式访问内存中的内容。在这段代码中，<code>*(%[a])</code> 表示将 <code>%[a]</code> 所代表的地址作为一个指针，然后访问这个指针指向的内存位置。</p>
<p>在远跳指令 <code>ljmp</code> 中，需要跳转的目标地址是通过一个指针来指定的。所以，使用 <code>*()</code> 来对指针进行间接寻址，以获取指针所指向的内容（即跳转目标地址），并将该地址作为参数传递给 <code>ljmp</code> 指令。</p>
<p>在这段代码中，<code>*(%[a])</code> 中的 <code>%[a]</code> 是一个占位符，用来表示汇编代码中的输入变量 <code>[a]</code>，即地址数组 addr 的地址。所以 <code>*(%[a])</code> 表示获取 addr 数组的地址所对应的内容，即跳转的目标地址。</p>
</blockquote>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001668.png" alt="image-20230921100950824" /></p>
<blockquote>
<p>跳转之前的任务1</p>
</blockquote>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001669.png" alt="image-20230921101039232" /></p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001670.png" alt="image-20230921101421193" /></p>
<blockquote>
<p>跳转之后, 有一些寄存器会发生自动的更改, 这时候的段寄存器发生了变化, 由于是在中断中发生的</p>
</blockquote>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001671.png" alt="image-20230921101010695" /></p>
<blockquote>
<p>这是任务1没有开始执行的时候的数据</p>
</blockquote>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001672.png" alt="image-20230921101832319" /></p>
<blockquote>
<p>进入任务1以后会写入寄存器里面</p>
</blockquote>
<h2 id="%E5%A2%9E%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8">增加系统调用</h2>
<p>允许应用调用操作系统的一些函数, 主要是由于权限, 需要在特区级下面运行一些操作</p>
<p>页表相关设置的时候有一个设置是PDE_U位, 这时候用户就可以访问这一段地址, 否则就是需要系统操作级来进行操作</p>
<p>实现系统调用的话使用的是系统调用门, 也是GDT表里面的一项</p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402071344960.png" alt="image-20240207134441751" /></p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001673.png" alt="image.png" /></p>
<blockquote>
<p>这里填写的是选择子, 指向一个代码段, 也是注册在GDT表里面, 以及一个函数位置的偏移</p>
<ol>
<li>调用门描述符给出了代码段的选择子，有了段选择子，就可以访问GDT或者LDT得到代码段的基地址, 需要选择内核代码段, 用于进行权限的切换</li>
<li>指的是偏移量, 实际指向的就是要运行的函数</li>
<li>TYPE字段用于标识门的类型，1100表示调用门。</li>
<li>P: 描述符中的P位是有效位，通常是1。当它为0时，调用这样的门会导致处理器产生异常。</li>
<li>DPL字段指明调用门的特权级，从而指定通过调用门访问特定过程所要求的特权级。</li>
<li>Param Count: 参数个数字段指明在发生堆栈切换时从调用者堆栈复制到新堆栈中的参数个数。</li>
</ol>

<pre class="language-c"><code class="language-c">//这里是系统调用,首先不初始化任务的函数地址, 之后是系统代码段, 权限设置为3, 使用三个参数
[SYSCALL_SEG / 8] = {0x0000, KERNEL_CODE_SEG, 0xec03, 0},

//设置系统调用函数的地址
gdt_table[SYSCALL_SEG / 8].limit_l = (uint16_t)(uint32_t)syscall_handler;
</code></pre>
</blockquote>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402221156534.png" alt="image-20240222115654303" /></p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402221158524.png" alt="image-20240222115814460" /></p>
<blockquote>
<p>栈里面的参数的传递</p>
</blockquote>
<p>需要的权限</p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402221205111.png" alt="image-20240222120542064" /></p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402221203487.png" alt="image-20240222120318424" /></p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402221203899.png" alt="image-20240222120338844" /></p>
<h3 id="%E5%9C%A8%E5%B1%8F%E5%B9%95%E6%98%BE%E7%A4%BA">在屏幕显示</h3>

<pre class="language-c"><code class="language-c">void task_0(void)
{
    uint8_t color = 0;

    unsigned short *dest = (unsigned short *)0xb8000;
    dest [0] = 'a' | 0x3500;//在这个地址写入一个'a'字符

    for(;;){
        color++;
    }
}
</code></pre>
<blockquote>
<p>显示一个字符, 这一块是内存的位置, 这是一个80列25行的位置</p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001674.png" alt="image-20230921161254909" /></p>
<p>有80列25行</p>
</blockquote>

<pre class="language-c"><code class="language-c">//系统调用
void do_syscall(int func, char * str, char color)
{
    static int row=1;
    if(func==2)
    {
        //显示一个字符串
        //计算一下实际写入的位置
        unsigned short *dest = (unsigned short *)0xb8000 + 80*row;
        while(*str){
            *dest ++ = *str ++ | (color&lt;&lt;8);
        }
        row = (row&gt;=25)?0:row+1;
        for(int i=0;i&lt;0xffffff;i++);
    }

}
</code></pre>
<h3 id="%E5%AE%9E%E7%8E%B0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92">实现系统调用的参数传递</h3>
<p>在使用的时候需要人工传递一下参数</p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001675.png" alt="image-20230921165941136" /></p>
<blockquote>
<p>会按照之前设置的参数, 会自动从栈里面取出来三个参数到系统的栈里面, 这个三是系统调用设置的那一个</p>
<p>之后人工把这三个值复制到系统栈最前面, 用于C语言的函数调用</p>
</blockquote>

<pre class="language-c"><code class="language-c">//这一个函数给用户使用
void sys_show(char *str, char color)
{
    //这个是调用门的跳转位置, 偏移量不需要, 需要一个系统调用门的GDT偏移
    uint32_t addr[] = {0, SYSCALL_SEG};
    //把这几个参数记录一下, 然后调用系统调用门
    __asm__ __volatile__(&quot;push %[color];push %[str];push %[id];lcalll *(%[a])&quot;::
                    [a]&quot;r&quot;(addr), [color]&quot;m&quot;(color), [str]&quot;m&quot;(str), [id]&quot;r&quot;(2));
}
</code></pre>
<blockquote>
<p>传入使用的三个参数, 之后跳转到对应的GDT对应的位置</p>

<pre class="language-c"><code class="language-c">    //设置系统调用函数的地址
    gdt_table[SYSCALL_SEG / 8].limit_l = (uint16_t)(uint32_t)syscall_handler;
</code></pre>
<p>这个函数是在汇编文件里面实现的</p>
</blockquote>
<p>之后再由汇编到C的时候传递参数使用的栈</p>

<pre class="language-assembly"><code class="language-assembly">syscall_handler:
    //对寄存器进行保护
    push %ds
    pusha
    //使用内核数据段
    mov $KERNEL_DATA_SEG, %ax
    mov %ax, %ds
    //获取传进来的参数, 之后再次入栈
    mov %esp, %ebp
    push 13*4(%ebp)
    push 12*4(%ebp)
    push 11*4(%ebp)

    call do_syscall
    //把之前的三个参数取出来
    add $(3*4), %esp
    popa
    pop %ds
    //由于这时候使用的特权级的栈, 返回的时候用使用这一个, 后面的参数是需要从栈里面取出来的参数个数
    retf $(3*4)
</code></pre>

<pre class="language-c"><code class="language-c">//这是系统调用在高权限的时候执行的函数
void do_syscall(int func, char * str, char color)
{
    static int row=1;
    if(func==2)
    {
        unsigned short *dest = (unsigned short *)0xb8000 + 80*row;
        while(*str){
            *dest ++ = *str ++ | (color&lt;&lt;8);
        }
        row = (row&gt;=25)?0:row+1;
        for(int i=0;i&lt;0xffffff;i++);
    }

}
</code></pre>

<pre class="language-c"><code class="language-c">//任务1
void task_0(void)
{
    char * str = &quot;task1 a:1234&quot;;
    uint8_t color = 0;

    for(;;){
     	//在这里可以调用系统接口
        sys_show(str, color++);
    }
}
</code></pre>
<h3 id="%E5%8F%A6%E4%B8%80%E7%A7%8D%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8int-%240x80">另一种系统调用int $0x80</h3>
<p>可以使用命令int $num的方式进行调用一个中断</p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402221502627.png" alt="image-20240222150221562" /></p>
<h2 id="LDT">LDT</h2>
<p>GDT: Global Descriptor Table</p>
<p>LDT: Local Descriptor Table</p>
<p>GDT可以被多个进程使用, LDT是每一个进程都有属于自己的一个表, 这会记录在TSS和GDT里面, TSS里面记录的是GDT里面的位置</p>
<ul>
<li>LDT的作用</li>
</ul>
<p>之前使用的时候直接把段设置为同一个代码段, 所以进程空间被两个进程同时使用, 相互之间的数据可以被看到</p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001676.png" alt="image-20230922142341114" /></p>
<blockquote>
<p>CS和DS使用相同的值但是访问的内存的位置是不同的</p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402071504563.png" alt="image-20240207150405514" /></p>
</blockquote>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402062001677.png" alt="image-20230922142400371" /></p>
<blockquote>
<p>使用LDTR保存当前使用的LDT表, 每一个进程的LDT存在他的TSS里面</p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402071444008.png" alt="image-20240207144407930" /></p>
</blockquote>
<p>CPU会根据段寄存器的第2位来选择从GDT还是LDT获取信息, 1的时候是LDT, 0和1位设置的是权限</p>

<pre class="language-c"><code class="language-c">//保存两个LDT的描述, 这个是GDT表里面使用的
#define TASK0_LDT_SEG           ((8 * 8))
#define TASK1_LDT_SEG           ((9 * 8))

//这里是任务的LDT的配置
#define TASK_CODE_SEG           (0 * 8 | 0x4 | 3)
#define TASK_DATA_SEG           (1 * 8 | 0x4 | 3)
</code></pre>

<pre class="language-assembly"><code class="language-assembly">    //打开中断, 由于在进入任务的时候会设置IF位, 所以在这里的时候不再进行设置
    //sti
    
    //告诉CPU正在运行的任务
    mov $TASK0_TSS_SEG, %ax
    ltr %ax

    //设置任务的LDT
    mov $TASK0_LDT_SEG, %ax
    lldt %ax
    //设置进入低特权级时候的所需要的栈, 这时候在使用的就是LDT的位置了
    push $TASK_DATA_SEG
    //设置栈的指针
    push $task0_dpl3_stack + 1024*4
    //设置EFLAGS, 主要是设置中断的状态
    push $0x202
    //这是代码段
    push $TASK_CODE_SEG
    push $task_0_entry

    //在这里进入低特权级
    iret
    jmp .
</code></pre>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402071452732.png" alt="image-20240207145219679" /></p>

<pre class="language-c"><code class="language-c">//定义一个TSS结构, 这个是任务一的表
uint32_t task0_tss[] = {
    // prelink, esp0, ss0, esp1, ss1, esp2, ss2
    0,  (uint32_t)task0_dpl0_stack + 4*1024, KERNEL_DATA_SEG , /* 后边不用使用 */ 0x0, 0x0, 0x0, 0x0,
    // cr3, eip, eflags, eax, ecx, edx, ebx, esp, ebp, esi, edi,
    (uint32_t)pg_dir,  (uint32_t)task_0/*入口地址*/, 0x202, 0xa, 0xc, 0xd, 0xb, (uint32_t)task0_dpl3_stack + 4*1024/* 栈 */, 0x1, 0x2, 0x3,
    // es, cs, ss, ds, fs, gs, ldt, iomap
    TASK_DATA_SEG, TASK_CODE_SEG, TASK_DATA_SEG, TASK_DATA_SEG, TASK_DATA_SEG, TASK_DATA_SEG, TASK0_LDT_SEG, 0x0,
};
//这个是任务二的表
uint32_t task1_tss[] = {
    // prelink, esp0, ss0, esp1, ss1, esp2, ss2
    0,  (uint32_t)task1_dpl0_stack + 4*1024, KERNEL_DATA_SEG , /* 后边不用使用 */ 0x0, 0x0, 0x0, 0x0,
    // cr3, eip, eflags, eax, ecx, edx, ebx, esp, ebp, esi, edi,
    (uint32_t)pg_dir,  (uint32_t)task_1/*入口地址*/, 0x202, 0xa, 0xc, 0xd, 0xb, (uint32_t)task1_dpl3_stack + 4*1024/* 栈 */, 0x1, 0x2, 0x3,
    // es, cs, ss, ds, fs, gs, ldt, iomap
    TASK_DATA_SEG, TASK_CODE_SEG, TASK_DATA_SEG, TASK_DATA_SEG, TASK_DATA_SEG, TASK_DATA_SEG, TASK1_LDT_SEG, 0x0,
};
</code></pre>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402071458978.png" alt="image-20240207145829919" /></p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202503041537535.png" alt="image-20250304153737379" /></p>

<pre class="language-c"><code class="language-c">//任务的LDT
[TASK0_LDT_SEG / 8] = {sizeof(task0_ldt_table-1), 0x0, 0xe200, 0x00c0},
[TASK1_LDT_SEG / 8] = {sizeof(task1_ldt_table-1), 0x0, 0xe200, 0x00c0},    
//设置LDT的起始位置
gdt_table[TASK0_LDT_SEG / 8].base_l = (uint16_t)(uint32_t)task0_ldt_table;
gdt_table[TASK1_LDT_SEG / 8].base_l = (uint16_t)(uint32_t)task1_ldt_table;
</code></pre>
<h2 id="%E6%80%BB%E7%BB%93">总结</h2>
<ul>
<li>首先BIOS会把磁盘第一部分加载到0x7c00的位置,加载512字节, 之后在这一段运行之后把其他的应用加载到内存</li>
<li>之后了解了通用寄存器和段寄存器, 段寄存器用于内存的访问, 还有EIP和EFLAG寄存器</li>
<li>之后使用了一些数据结构, GDT: 指示某一个内存区域的作用, LDT: 记录进程自己的区域, TSS: 进程的运行状态保存的位置, IDT: 中断向量表</li>
<li>几个不同的特权级, 特权级切换: 中断发生的时候, 使用系统调用的时候</li>
<li>分页机制: 使用之后, CPU操控的就不再是实际的内存空间, 会把地址分为三部分, 之后根据这个进行地址的索引</li>
</ul>

                        
                    </div>
                </div>
                <div id="previous_next">
                    <div id="previous">
                        
                        <a href="/note/Linux/李述铜手写操作系统/2023-9-6-1操作系统准备.html">
                            <span class="icon"></span>
                            <span class="label">2023-9-6-1操作系统准备</span>
                        </a>
                        
                    </div>
                    <div id="next">
                        
                        <a href="/note/Linux/李述铜手写操作系统/2024-2-17-07进程切换.html">
                            <span class="label">2024-2-17-07进程切换</span>
                            <span class="icon"></span>
                        </a>
                        
                    </div>
                </div>
                <div id="comments-container"></div>
            </div>
            <div id="toc_wrapper">
                <div id="toc">
                    <div id="toc_content">
                            
                    </div>
                </div>
            </div>
        </div>
    </div>
    <a id="to_top" href="#"></a>
    <div id="doc_footer">
        <div id="footer">
            <div id="footer_top">
                <ul>
<li><a>链接</a><ul><li><a target="_blank" href="https://teedoc.neucrack.com">网站使用 teedoc 生成</a></li>
<li><a target="_blank" href="https://neucrack.com">Copyright © 2021 Neucrack</a></li>
<li><a  href="/note/sitemap.xml">网站地图</a></li>
</ul>
</li>
<li><a>源码</a><ul><li><a target="_blank" href="https://github.com/XuSenfeng/note/">github</a></li>
<li><a target="_blank" href="https://github.com/teedoc/teedoc">本网站源文件</a></li>
</ul>
</li>
</ul>

            </div>
            <div id="footer_bottom">
                <ul>
<li><a target="_blank" href="https://beian.miit.gov.cn">渝ICP备19015320号</a></li>
<li><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44030602004109">粤公网安备44030602004109号</a></li>
</ul>

            </div>
        </div>
    </div>
    
        <script src="/note/teedoc-plugin-markdown-parser/mermaid.min.js"></script>
    
        <script>mermaid.initialize({startOnLoad:true});</script>
    
        <script type="text/javascript">
                var transLoaded = false;
                var loading = false;
                var domain = "translate.google.com";
                var domainDefault = domain;
                var storeDomain = localStorage.getItem("googleTransDomain");
                if(storeDomain){
                    domain = storeDomain;
                    console.log("load google translate domain from local storage:" + domain);
                }
                function getUrl(domain){
                    if(domain == "/")
                        return "/static/js/google_translate/element.js?cb=googleTranslateElementInit";
                    else
                        return "https://" + domain + "/translate_a/element.js?cb=googleTranslateElementInit";
                }
                var url = getUrl(domain);
                console.log("google translate domain:" + domain + ", url: " + url);
                function googleTranslateElementInit() {
                    new google.translate.TranslateElement({pageLanguage: "auto", layout: google.translate.TranslateElement.InlineLayout.SIMPLE}, 'google_translate_element');
                }
                function loadJS( url, callback ){
                    var script = document.createElement('script');
                    fn = callback || function(){ };
                    script.type = 'text/javascript';
                    if(script.readyState){
                        script.onreadystatechange = function(){
                            if( script.readyState == 'loaded' || script.readyState == 'complete' ){
                                script.onreadystatechange = null;
                                fn();
                            }
                        };
                    }else{
                        script.onload = function(){
                            fn();
                        };
                    }
                    script.src = url;
                    document.getElementsByTagName('head')[0].appendChild(script);
                }
                function removeHint(){
                    var hint = document.getElementById("loadingTranslate");
                    if(hint){
                        hint.remove();
                    }
                }
                var btn = document.getElementById("google_translate_element");
                btn.onclick = function(){
                    if(transLoaded) return;
                    if(loading){
                        var flag = confirm("loading from " + domain + ", please wait, or change domain?");
                        if(flag){
                            newDomain = prompt("domain, default: " + domainDefault + ", now: " + domain);
                            if(newDomain){
                                domain = newDomain;
                                console.log(domain);
                                url = getUrl(domain);
                                loadJS(url, function(){
                                    localStorage.setItem("googleTransDomain", domain);
                                    removeHint()
                                    transLoaded = true;
                                });
                            }
                        }
                        return;
                    }
                    btn.innerHTML = '<span id="loadingTranslate"><img class="icon" src="/note/static/image/google_translate/translate.svg"/>Loading ...</span>';
                    loading = true;
                    loadJS(url, function(){
                        localStorage.setItem("googleTransDomain", domain);
                        removeHint()
                        transLoaded = true;
                    });
                }
                </script>
            
    
        <script src="/note/static/js/theme_default/tocbot.min.js"></script>
    
        <script src="/note/static/js/theme_default/main.js"></script>
    
        <script src="/note/static/js/theme_default/viewer.min.js"></script>
    
        <script src="/note/static/css/theme_default/prism.min.js"></script>
    
        <script src="/note/static/js/search/search_main.js"></script>
    
        <script src="/note/static/js/plugin_blog/main.js"></script>
    
        <link rel="stylesheet" href="/note/static/js/add_hint/style.css" type="text/css"/>
    
        <script src="/note/static/js/add_hint/main.js"></script>
    
        <script src="/note/static/js/gitalk/gitalk.min.js"></script>
    
        <script src="/note/static/js/gitalk/main.js"></script>
    
        <script src="/note/static/js/custom.js"></script>
    
</body>

</html>