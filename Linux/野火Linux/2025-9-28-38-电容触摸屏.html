<!DOCTYPE html>

<html lang="zh-CN"  class="">


<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="keywords" content="">
    
    
    <meta name="description" content="">
    
    <meta name="generator" content="teedoc">
    <meta name="theme" content="teedoc-plugin-theme-default">
    
        
        <meta name="markdown-generator" content="teedoc-plugin-markdown-parser">
        
        <script>
MathJax = {"loader": {"load": ["output/svg"]}, "tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]]}, "svg": {"fontCache": "global"}};
</script>
        
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        
        <meta name="html-generator" content="teedoc-plugin-jupyter-notebook-parser">
        
        <script src="/note/static/js/theme_default/pre_main.js"></script>
        
        <link rel="stylesheet" href="/note/static/css/theme_default/prism.min.css" type="text/css"/>
        
        <link rel="stylesheet" href="/note/static/css/theme_default/viewer.min.css" type="text/css"/>
        
        <link rel="stylesheet" href="/note/static/css/theme_default/dark.css" type="text/css"/>
        
        <link rel="stylesheet" href="/note/static/css/theme_default/light.css" type="text/css"/>
        
        <script src="/note/static/js/theme_default/jquery.min.js"></script>
        
        <script src="/note/static/js/theme_default/split.js"></script>
        
        <link rel="stylesheet" href="/note/static/css/search/style.css" type="text/css"/>
        
        <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4d52982572d5512e9762879ebf063c86";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
        
        <meta name="blog-generator" content="teedoc-plugin-blog">
        
        <link rel="stylesheet" href="/note/static/css/gitalk/gitalk.css" type="text/css"/>
        
        <link rel="stylesheet" href="/note/static/css/gitalk/custom_gitalk.css" type="text/css"/>
        
        <link rel="stylesheet" href="/note/static/css/custom.css" type="text/css"/>
        
    
    
    <title>XvSenfeng's Note</title>
    
    <script type="text/javascript">js_vars = {"teedoc-plugin-ad-hint": {"type": "hint", "label": "☆", "content": "这是一个支持国际化的消息示例</br>喜欢项目请<a target=\"_blank\" href=\"https://github.com/teedoc/teedoc\">点下 ☆ star </a>哦~🦀🦀", "show_times": 2, "show_after_s": 432000, "date": "2021-11-16 14:40", "color": "#a0421d", "link_color": "#e53935", "link_bg_color": "#e6ae5c", "bg_color": "#ffcf89", "color_hover": "white", "bg_color_hover": "#f57c00", "close_color": "#eab971"}}</script>
    <script type="text/javascript">metadata = {"tags": [], "date": null, "update": [], "ts": 0, "author": "", "brief": "", "cover": ""}</script>
</head>


<body class="type_doc">
    
    <div id="navbar">
        <div id="navbar_menu">
            <a class="site_title" href="/note/">
                
                    <img class="site_logo" src="/note/static/image/logo.png" alt="XvSenfeng logo">
                
                
                    <h2>XvSenfeng</h2>
                
        </a>
            <a id="navbar_menu_btn"></a>
        </div>
        <div id="navbar_items">
            <div>
                <ul id="nav_left">
<li class=""><a  href="/note/blog/">博客</a></li>
<li class="active"><a  href="/note/Linux/">Linux</a></li>
<li class=""><a  href="/note/代码分析/">代码分析</a></li>
<li class=""><a  href="/note/使用软件/">使用软件</a></li>
<li class=""><a  href="/note/嵌入式/">嵌入式</a></li>
<li class=""><a  href="/note/手机安卓/">手机安卓</a></li>
<li class=""><a  href="/note/机器学习/">机器学习</a></li>
<li class=""><a  href="/note/编程基础/">编程基础</a></li>
<li class=""><a  href="/note/网络/">网络</a></li>
</ul>

            </div>
            <div>
                <ul id="nav_right">
<li class=""><a target="_blank" href="https://github.com/XuSenfeng/note/">github</a></li>
</ul>

                <ul class="nav_plugins"><li><a id="google_translate_element"><img class="icon" src="/note/static/image/google_translate/translate.svg"/>Translate</a></li></ul><ul class="nav_plugins"><li><a id="themes" class="light"></a></li></ul><ul class="nav_plugins"><li><a id="search"><span class="icon"></span><span class="placeholder">搜索</span>
                            <div id="search_hints">
                                <span id="search_input_hint">输入关键词，多关键词空格隔开</span>
                                <span id="search_loading_hint">正在加载，请稍候。。。</span>
                                <span id="search_download_err_hint">下载文件失败，请刷新重试或检查网络</span>
                                <span id="search_other_docs_result_hint">来自其它文档的结果</span>
                                <span id="search_curr_doc_result_hint">当前文档搜索结果</span>
                            </div></a></li></ul>
            </div>
        </div>
    </div>
    
    <div id="wrapper">
        <div id="sidebar_wrapper">
            <div id="sidebar">
                <div id="sidebar_title">
                    
                </div>
                <ul class="show">
<li class="not_active with_link"><a href="/note/Linux/index.html"><span class="label">README</span><span class=""></span></a></li>
<li class="not_active no_link"><a><span class="label">Linux命令行与shell脚本编程大全</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-1-初认识Linux_shell.html"><span class="label">2022-8-1-初认识Linux_shell</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-1-基本bashshell命令.html"><span class="label">2022-8-1-基本bashshell命令</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-1-走进shell.html"><span class="label">2022-8-1-走进shell</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-10-sed进阶.html"><span class="label">2022-8-10-sed进阶</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-11-gawk进阶.html"><span class="label">2022-8-11-gawk进阶</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-11-使用其他shell.html"><span class="label">2022-8-11-使用其他shell</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-11-实例.html"><span class="label">2022-8-11-实例</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-12-邮件相关.html"><span class="label">2022-8-12-邮件相关</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-2-更多命令.html"><span class="label">2022-8-2-更多命令</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-2-理解shell.html"><span class="label">2022-8-2-理解shell</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-3-使用Linux环境变量.html"><span class="label">2022-8-3-使用Linux环境变量</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-3-理解Linux的文件权限.html"><span class="label">2022-8-3-理解Linux的文件权限</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-4-安装软件程序.html"><span class="label">2022-8-4-安装软件程序</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-4-管理文件系统.html"><span class="label">2022-8-4-管理文件系统</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-5-使用编辑器.html"><span class="label">2022-8-5-使用编辑器</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-5-构建基本脚本.html"><span class="label">2022-8-5-构建基本脚本</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-6-使用结构初始化.html"><span class="label">2022-8-6-使用结构初始化</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-6-处理用户输入.html"><span class="label">2022-8-6-处理用户输入</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-6-更多结构化命令.html"><span class="label">2022-8-6-更多结构化命令</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-7-呈现数据.html"><span class="label">2022-8-7-呈现数据</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-7-控制脚本.html"><span class="label">2022-8-7-控制脚本</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-8-创建函数.html"><span class="label">2022-8-8-创建函数</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-9-图形化桌面环境中的脚本编程.html"><span class="label">2022-8-9-图形化桌面环境中的脚本编程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-9-正则表达式.html"><span class="label">2022-8-9-正则表达式</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-9-认识sed和gawk.html"><span class="label">2022-8-9-认识sed和gawk</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">Linux就该这么学</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/Linux就该这么学/2022-8-23-.html"><span class="label">2022-8-23-</span><span class=""></span></a></li>
<li class="not_active no_link"><a><span class="label">鸟哥的linux私房菜</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/Linux就该这么学/鸟哥的linux私房菜/2022-9-10-计算机概论.html"><span class="label">2022-9-10-计算机概论</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux就该这么学/鸟哥的linux私房菜/2022-9-20-主机规划与磁盘分区.html"><span class="label">2022-9-20-主机规划与磁盘分区</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux就该这么学/鸟哥的linux私房菜/2022-9-20-安装CentOS.html"><span class="label">2022-9-20-安装CentOS</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux就该这么学/鸟哥的linux私房菜/2022-9-20-首次登录.html"><span class="label">2022-9-20-首次登录</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux就该这么学/鸟哥的linux私房菜/2022-9-25-文件权限以及目录.html"><span class="label">2022-9-25-文件权限以及目录</span><span class=""></span></a></li>
</ul>
</li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">Linux源码趣读</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/Linux源码趣读/2024-1-26-01最开始的代码.html"><span class="label">2024-1-26-01最开始的代码</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">Linux系统编程</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/Linux系统编程/2024-2-14-01文件IO.html"><span class="label">2024-2-14-01文件IO</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux系统编程/2024-3-19-02文件系统.html"><span class="label">2024-3-19-02文件系统</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux系统编程/2024-3-21-03程序和进程.html"><span class="label">2024-3-21-03程序和进程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux系统编程/2024-3-23-04进程间通信.html"><span class="label">2024-3-23-04进程间通信</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux系统编程/2024-3-25-05信号.html"><span class="label">2024-3-25-05信号</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux系统编程/2024-3-28-06守护进程、线程.html"><span class="label">2024-3-28-06守护进程、线程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux系统编程/2024-3-31-07线程同步.html"><span class="label">2024-3-31-07线程同步</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">Linux网络编程</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-10-04线程池.html"><span class="label">2024-4-10-04线程池</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-13-05本地套接字.html"><span class="label">2024-4-13-05本地套接字</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-14-06libevent库.html"><span class="label">2024-4-14-06libevent库</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-16-07简单的Web服务器.html"><span class="label">2024-4-16-07简单的Web服务器</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-16-08html入门.html"><span class="label">2024-4-16-08html入门</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-17-09CSS.html"><span class="label">2024-4-17-09CSS</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-17-09HTTP协议.html"><span class="label">2024-4-17-09HTTP协议</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-2-01网络基础.html"><span class="label">2024-4-2-01网络基础</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-20-10telnet调试.html"><span class="label">2024-4-20-10telnet调试</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-20-11服务器.html"><span class="label">2024-4-20-11服务器</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-3-02Socket编程.html"><span class="label">2024-4-3-02Socket编程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-6-03高并发服务器.html"><span class="label">2024-4-6-03高并发服务器</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">原子Linux</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-10-Linux常用命令.html"><span class="label">2022-8-10-Linux常用命令</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-11-压缩解压缩.html"><span class="label">2022-8-11-压缩解压缩</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-11-文件系统结构.html"><span class="label">2022-8-11-文件系统结构</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-11-磁盘管理.html"><span class="label">2022-8-11-磁盘管理</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-12-LinuxC.html"><span class="label">2022-8-12-LinuxC</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-12-Makefile书.html"><span class="label">2022-8-12-Makefile书</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-12-make和Makefile.html"><span class="label">2022-8-12-make和Makefile</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-12-开发环境搭建.html"><span class="label">2022-8-12-开发环境搭建</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-12-用户和用户组.html"><span class="label">2022-8-12-用户和用户组</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-12-链接文件.html"><span class="label">2022-8-12-链接文件</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-13-IMX启动方式.html"><span class="label">2022-8-13-IMX启动方式</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-13-vscode.html"><span class="label">2022-8-13-vscode</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-13-开发板简介.html"><span class="label">2022-8-13-开发板简介</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-13-汇编LED驱动.html"><span class="label">2022-8-13-汇编LED驱动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-14-C语言点灯.html"><span class="label">2022-8-14-C语言点灯</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-14-按键检测.html"><span class="label">2022-8-14-按键检测</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-14-模仿stm32编程.html"><span class="label">2022-8-14-模仿stm32编程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-15-中断.html"><span class="label">2022-8-15-中断</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-15-主频时钟配置.html"><span class="label">2022-8-15-主频时钟配置</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-16-EPIT定时器.html"><span class="label">2022-8-16-EPIT定时器</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-16-GPT时钟.html"><span class="label">2022-8-16-GPT时钟</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-17-DDR3.html"><span class="label">2022-8-17-DDR3</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-17-RGBLED.html"><span class="label">2022-8-17-RGBLED</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-17-串口.html"><span class="label">2022-8-17-串口</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-18-I2C.html"><span class="label">2022-8-18-I2C</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-18-RTC.html"><span class="label">2022-8-18-RTC</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-19-PWM.html"><span class="label">2022-8-19-PWM</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-19-SPI.html"><span class="label">2022-8-19-SPI</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-19-多点电容触摸屏.html"><span class="label">2022-8-19-多点电容触摸屏</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-20-uBoot.html"><span class="label">2022-8-20-uBoot</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-20-系统烧写.html"><span class="label">2022-8-20-系统烧写</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-22-源码目录分析.html"><span class="label">2022-8-22-源码目录分析</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-22-顶层Makefile.html"><span class="label">2022-8-22-顶层Makefile</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-23-Linux内核.html"><span class="label">2022-8-23-Linux内核</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-23-uboot图形化配置界面.html"><span class="label">2022-8-23-uboot图形化配置界面</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-23-启动流程.html"><span class="label">2022-8-23-启动流程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-23-移植.html"><span class="label">2022-8-23-移植</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-24-驱动开发.html"><span class="label">2022-8-24-驱动开发</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-26-linux点灯.html"><span class="label">2022-8-26-linux点灯</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-27-设备树.html"><span class="label">2022-8-27-设备树</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-28-led设备树.html"><span class="label">2022-8-28-led设备树</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-29-Linux的并发与竞争.html"><span class="label">2022-8-29-Linux的并发与竞争</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-29-pinclt和gpio.html"><span class="label">2022-8-29-pinclt和gpio</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-30-Linux中断.html"><span class="label">2022-8-30-Linux中断</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-30-Linux内核定时器.html"><span class="label">2022-8-30-Linux内核定时器</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-31-异步通知.html"><span class="label">2022-8-31-异步通知</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-31-阻塞非阻塞.html"><span class="label">2022-8-31-阻塞非阻塞</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-1-platform设备驱动.html"><span class="label">2022-9-1-platform设备驱动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-10-WIFI.html"><span class="label">2022-9-10-WIFI</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-10-网络驱动.html"><span class="label">2022-9-10-网络驱动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-11-4G.html"><span class="label">2022-9-11-4G</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-11-IIO.html"><span class="label">2022-9-11-IIO</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-11-PWM.html"><span class="label">2022-9-11-PWM</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-11-RGBtoHDMI.html"><span class="label">2022-9-11-RGBtoHDMI</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-11-Regmap.html"><span class="label">2022-9-11-Regmap</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-2-INPUT子系统.html"><span class="label">2022-9-2-INPUT子系统</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-2-LCD屏幕.html"><span class="label">2022-9-2-LCD屏幕</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-2-Linux自带的led.html"><span class="label">2022-9-2-Linux自带的led</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-2-MISC.html"><span class="label">2022-9-2-MISC</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-3-I2C.html"><span class="label">2022-9-3-I2C</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-3-RTC.html"><span class="label">2022-9-3-RTC</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-3-SPI.html"><span class="label">2022-9-3-SPI</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-4-串口.html"><span class="label">2022-9-4-串口</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-5-触摸屏.html"><span class="label">2022-9-5-触摸屏</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-5-音频驱动.html"><span class="label">2022-9-5-音频驱动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-6-CAN协议.html"><span class="label">2022-9-6-CAN协议</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-7-USB.html"><span class="label">2022-9-7-USB</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-7-块设备驱动.html"><span class="label">2022-9-7-块设备驱动</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">操作系统原理</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-17-1操作系统.html"><span class="label">2023-6-17-1操作系统</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-17-2操作系统目标和作用.html"><span class="label">2023-6-17-2操作系统目标和作用</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-17-3操作系统特征.html"><span class="label">2023-6-17-3操作系统特征</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-17-4操作系统的发展.html"><span class="label">2023-6-17-4操作系统的发展</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-17-5运行机制.html"><span class="label">2023-6-17-5运行机制</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-18-6中断异常.html"><span class="label">2023-6-18-6中断异常</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-18-7系统调用.html"><span class="label">2023-6-18-7系统调用</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-19-8体系结构.html"><span class="label">2023-6-19-8体系结构</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-20-10虚拟机.html"><span class="label">2023-6-20-10虚拟机</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-20-11进程.html"><span class="label">2023-6-20-11进程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-20-9操作系统的引导.html"><span class="label">2023-6-20-9操作系统的引导</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-22-12线程.html"><span class="label">2023-6-22-12线程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-23-13调度.html"><span class="label">2023-6-23-13调度</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-27-14进程同步进程互斥.html"><span class="label">2023-6-27-14进程同步进程互斥</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-28-15锁.html"><span class="label">2023-6-28-15锁</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-28-16信号量机制.html"><span class="label">2023-6-28-16信号量机制</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">服务器</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/服务器/2023-6-12-代理.html"><span class="label">2023-6-12-代理</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/服务器/2023-6-12-新服务器搭建.html"><span class="label">2023-6-12-新服务器搭建</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">李述铜手写操作系统</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2023-10-26-05中断和异常处理.html"><span class="label">2023-10-26-05中断和异常处理</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2023-11-10-06日志与printf输出.html"><span class="label">2023-11-10-06日志与printf输出</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2023-9-23-03引导程序接管控制权.html"><span class="label">2023-9-23-03引导程序接管控制权</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2023-9-28-04加载器loader的实现.html"><span class="label">2023-9-28-04加载器loader的实现</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2023-9-6-01补充知识2.html"><span class="label">2023-9-6-01补充知识2</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2023-9-6-0补充知识.html"><span class="label">2023-9-6-0补充知识</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2023-9-6-1操作系统准备.html"><span class="label">2023-9-6-1操作系统准备</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2023-9-7-2x86保护模式下的编程.html"><span class="label">2023-9-7-2x86保护模式下的编程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-2-17-07进程切换.html"><span class="label">2024-2-17-07进程切换</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-2-17-08链表.html"><span class="label">2024-2-17-08链表</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-2-17添加任务管理器.html"><span class="label">2024-2-17添加任务管理器</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-2-18-内存管理.html"><span class="label">2024-2-18-内存管理</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-2-24-系统调用.html"><span class="label">2024-2-24-系统调用</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-2-26-移植Newlib库.html"><span class="label">2024-2-26-移植Newlib库</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-2-27-屏幕显示信息.html"><span class="label">2024-2-27-屏幕显示信息</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-2-29-键盘初始化.html"><span class="label">2024-2-29-键盘初始化</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-3-1-设备管理.html"><span class="label">2024-3-1-设备管理</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-3-3-Shell.html"><span class="label">2024-3-3-Shell</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-3-4-文件系统.html"><span class="label">2024-3-4-文件系统</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-3-5-磁盘.html"><span class="label">2024-3-5-磁盘</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-3-7-Fat16.html"><span class="label">2024-3-7-Fat16</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">树莓派</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/树莓派/2024-2-1-01开始使用.html"><span class="label">2024-2-1-01开始使用</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/树莓派/2024-2-1-02-使用命令了解树莓派.html"><span class="label">2024-2-1-02-使用命令了解树莓派</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/树莓派/2024-2-1-03-安装mysql.html"><span class="label">2024-2-1-03-安装mysql</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/树莓派/2024-2-3-04网络连接.html"><span class="label">2024-2-3-04网络连接</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/树莓派/2024-2-8-时钟设置.html"><span class="label">2024-2-8-时钟设置</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">泰山派</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-12-20-05-lvgl程序.html"><span class="label">2025-12-20-05-lvgl程序</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-12-24-06-二维码识别.html"><span class="label">2025-12-24-06-二维码识别</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-12-24-07-yolo部署.html"><span class="label">2025-12-24-07-yolo部署</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-12-25-08-OpenCV.html"><span class="label">2025-12-25-08-OpenCV</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-12-26-09-拍照.html"><span class="label">2025-12-26-09-拍照</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-12-26-10-Qt.html"><span class="label">2025-12-26-10-Qt</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-5-11-01环境搭建.html"><span class="label">2025-5-11-01环境搭建</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-5-11-02设备树.html"><span class="label">2025-5-11-02设备树</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-5-14-03屏幕驱动.html"><span class="label">2025-5-14-03屏幕驱动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-5-17-04触摸驱动.html"><span class="label">2025-5-17-04触摸驱动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2026-1-27-ROS.html"><span class="label">2026-1-27-ROS</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2026-1-30-Ubuntu22.html"><span class="label">2026-1-30-Ubuntu22</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">瑞芯微Linux</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/瑞芯微Linux/2025-12-10-Cpp提供C接口.html"><span class="label">2025-12-10-Cpp提供C接口</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/瑞芯微Linux/2025-12-5-01-EchoAI编译代码.html"><span class="label">2025-12-5-01-EchoAI编译代码</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/瑞芯微Linux/2025-12-5-02-EchoAI代码.html"><span class="label">2025-12-5-02-EchoAI代码</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/瑞芯微Linux/2025-12-7-03-添加板子.html"><span class="label">2025-12-7-03-添加板子</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/瑞芯微Linux/2025-12-8-04-内核.html"><span class="label">2025-12-8-04-内核</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/瑞芯微Linux/2025-12-9-05-模型.html"><span class="label">2025-12-9-05-模型</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/瑞芯微Linux/配置网络.html"><span class="label">配置网络</span><span class=""></span></a></li>
</ul>
</li>
<li class="active_parent no_link"><a><span class="label">野火Linux</span><span class="sub_indicator"></span></a><ul class="show">
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-11-55-buildroot.html"><span class="label">2025-10-11-55-buildroot</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-11-56-裸机汇编开发.html"><span class="label">2025-10-11-56-裸机汇编开发</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-12-57-Uboot编译脚本.html"><span class="label">2025-10-12-57-Uboot编译脚本</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-2-47-镜像构建.html"><span class="label">2025-10-2-47-镜像构建</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-2-48-systemd.html"><span class="label">2025-10-2-48-systemd</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-2-49-deb包.html"><span class="label">2025-10-2-49-deb包</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-2-50-修改img文件.html"><span class="label">2025-10-2-50-修改img文件</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-2-51-备份量产.html"><span class="label">2025-10-2-51-备份量产</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-2-52-Uboot启动.html"><span class="label">2025-10-2-52-Uboot启动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-28-58-Uboot移植.html"><span class="label">2025-10-28-58-Uboot移植</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-30-59-Uboot图形配置界面语法.html"><span class="label">2025-10-30-59-Uboot图形配置界面语法</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-30-60-Linux编译脚本.html"><span class="label">2025-10-30-60-Linux编译脚本</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-31-61-Linux启动流程.html"><span class="label">2025-10-31-61-Linux启动流程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-9-53-Uboot启动(二).html"><span class="label">2025-10-9-53-Uboot启动(二)</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-9-54-Uboot启动(三).html"><span class="label">2025-10-9-54-Uboot启动(三)</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-1-62-linux移植.html"><span class="label">2025-11-1-62-linux移植</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-1-63-Busybox.html"><span class="label">2025-11-1-63-Busybox</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-10-65-定时器.html"><span class="label">2025-11-10-65-定时器</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-12-66-信号.html"><span class="label">2025-11-12-66-信号</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-14-67-MISC设备.html"><span class="label">2025-11-14-67-MISC设备</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-15-68-RTC.html"><span class="label">2025-11-15-68-RTC</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-16-69-串口.html"><span class="label">2025-11-16-69-串口</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-18-70-中断线程化.html"><span class="label">2025-11-18-70-中断线程化</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-18-71-音频.html"><span class="label">2025-11-18-71-音频</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-19-72-CAN.html"><span class="label">2025-11-19-72-CAN</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-19-73-USB.html"><span class="label">2025-11-19-73-USB</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-2-64-mfgtool.html"><span class="label">2025-11-2-64-mfgtool</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-20-74-块设备.html"><span class="label">2025-11-20-74-块设备</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-21-75-网络设备.html"><span class="label">2025-11-21-75-网络设备</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-22-76-Wifi.html"><span class="label">2025-11-22-76-Wifi</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-22-77-PWM.html"><span class="label">2025-11-22-77-PWM</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-22-78-Regmap通用寄存器.html"><span class="label">2025-11-22-78-Regmap通用寄存器</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-22-79-IIO驱动框架.html"><span class="label">2025-11-22-79-IIO驱动框架</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-25-80-ADC驱动.html"><span class="label">2025-11-25-80-ADC驱动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-12-6-81-音频驱动.html"><span class="label">2025-12-6-81-音频驱动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-12-8-82-DRM显示设备.html"><span class="label">2025-12-8-82-DRM显示设备</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-6-11-01-入门.html"><span class="label">2025-6-11-01-入门</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-6-22-02-开发板下载启动.html"><span class="label">2025-6-22-02-开发板下载启动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-12-04-镜像文件.html"><span class="label">2025-7-12-04-镜像文件</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-13-06-GPIO.html"><span class="label">2025-7-13-06-GPIO</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-13-07-中断.html"><span class="label">2025-7-13-07-中断</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-14-05-ARMv7汇编.html"><span class="label">2025-7-14-05-ARMv7汇编</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-14-08-时钟控制模块.html"><span class="label">2025-7-14-08-时钟控制模块</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-14-09-串口.html"><span class="label">2025-7-14-09-串口</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-15-10-内核模块.html"><span class="label">2025-7-15-10-内核模块</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-15-11-字符设备.html"><span class="label">2025-7-15-11-字符设备</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-15-12-驱动设备模型.html"><span class="label">2025-7-15-12-驱动设备模型</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-19-13-Kset.html"><span class="label">2025-7-19-13-Kset</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-19-14-uevent消息.html"><span class="label">2025-7-19-14-uevent消息</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-19-15-class设备管理.html"><span class="label">2025-7-19-15-class设备管理</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-19-16-17-总结.html"><span class="label">2025-7-19-16-17-总结</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-19-16-xbus和platform.html"><span class="label">2025-7-19-16-xbus和platform</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-2-03-控制设备.html"><span class="label">2025-7-2-03-控制设备</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-20-18-DTS设备树.html"><span class="label">2025-7-20-18-DTS设备树</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-20-19-DeviceTreeOverlay.html"><span class="label">2025-7-20-19-DeviceTreeOverlay</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-16-21-iomux节点(中).html"><span class="label">2025-9-16-21-iomux节点(中)</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-16-22-iomux节点(下).html"><span class="label">2025-9-16-22-iomux节点(下)</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-17-23-iomux节点(应用).html"><span class="label">2025-9-17-23-iomux节点(应用)</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-17-24-GPIO子系统.html"><span class="label">2025-9-17-24-GPIO子系统</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-17-25-并发硬件同步原语.html"><span class="label">2025-9-17-25-并发硬件同步原语</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-18-26-IIC驱动框架.html"><span class="label">2025-9-18-26-IIC驱动框架</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-20-27-IIC驱动框架使用.html"><span class="label">2025-9-20-27-IIC驱动框架使用</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-25-28-阻塞和非阻塞IO.html"><span class="label">2025-9-25-28-阻塞和非阻塞IO</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-25-29-POLL机制.html"><span class="label">2025-9-25-29-POLL机制</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-25-30-Completion.html"><span class="label">2025-9-25-30-Completion</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-25-31-kthread_worker.html"><span class="label">2025-9-25-31-kthread_worker</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-26-32-SPI.html"><span class="label">2025-9-26-32-SPI</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-26-33-SPI使用.html"><span class="label">2025-9-26-33-SPI使用</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-27-34-中断.html"><span class="label">2025-9-27-34-中断</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-27-35-软中断和tasklet.html"><span class="label">2025-9-27-35-软中断和tasklet</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-27-36-工作队列.html"><span class="label">2025-9-27-36-工作队列</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-27-37-Input子系统.html"><span class="label">2025-9-27-37-Input子系统</span><span class=""></span></a></li>
<li class="active with_link"><a href="/note/Linux/野火Linux/2025-9-28-38-电容触摸屏.html"><span class="label">2025-9-28-38-电容触摸屏</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-28-39-PWM.html"><span class="label">2025-9-28-39-PWM</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-28-40-LCD-FB设备.html"><span class="label">2025-9-28-40-LCD-FB设备</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-29-41-Linux系统构成.html"><span class="label">2025-9-29-41-Linux系统构成</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-29-42-Uboot基础使用.html"><span class="label">2025-9-29-42-Uboot基础使用</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-29-43-Linux.html"><span class="label">2025-9-29-43-Linux</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-29-44-添加驱动(设备树).html"><span class="label">2025-9-29-44-添加驱动(设备树)</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-30-45-图标.html"><span class="label">2025-9-30-45-图标</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-30-46-根文件系统.html"><span class="label">2025-9-30-46-根文件系统</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-4-20-iomux节点(上).html"><span class="label">2025-9-4-20-iomux节点(上)</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/Untitled.html"><span class="label">Untitled</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">问题处理</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/问题处理/2022-11-20-Linux图形界面.html"><span class="label">2022-11-20-Linux图形界面</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2022-8-24-tftp下载.html"><span class="label">2022-8-24-tftp下载</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2022-8-26-uboot设置.html"><span class="label">2022-8-26-uboot设置</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2022-8-27-根文件系统被删除.html"><span class="label">2022-8-27-根文件系统被删除</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2022-8-5-没有release文件.html"><span class="label">2022-8-5-没有release文件</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2022-9-7-备份根文件.html"><span class="label">2022-9-7-备份根文件</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2022-9-9-ubuntu移植问题处理.html"><span class="label">2022-9-9-ubuntu移植问题处理</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2023-11-11-树莓派.html"><span class="label">2023-11-11-树莓派</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2023-6-14-打不开gpedit-msc.html"><span class="label">2023-6-14-打不开gpedit-msc</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2023-6-28-vscode配置.html"><span class="label">2023-6-28-vscode配置</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2023-8-27-开发板网络设置.html"><span class="label">2023-8-27-开发板网络设置</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">韦东山Linux</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/韦东山Linux/2025-3-4-基础.html"><span class="label">2025-3-4-基础</span><span class=""></span></a></li>
</ul>
</li>
</ul>

            </div>
        </div>
        <div id="article">
            <div id="menu_wrapper">
                <div id="menu">
                </div>
            </div>
            <div id="content_wrapper">
                <div id="content_body">
                    <div id="article_head">
                        <div id="article_title">
                            
                            <h1></h1>
                            
                        </div>
                        <div id="article_tags">
                            <ul>
                            
                            </ul>
                        </div>
                        <div id="article_info">
                        <div id="article_info_left">
                            <span class="article_author">
                                
                            </span>
                            
                                <span class="article_date" title="最后修改日期： 2025-12-14">
                                    2025-12-14
                                </span>
                            
                        </div>
                        <div id="article_info_right">
                            
                            <div id="source_link">
                                <a href="https://github.com/XuSenfeng/note/tree/master/doc/Linux/野火Linux/2025-9-28-38-电容触摸屏.md" target="_blank">
                                    编辑本页
                                </a>
                            </div>
                            
                        </div>
                        </div>
                    </div>
                    <div id="article_tools">
                        <span></span>
                        <span id="toc_btn"></span>
                    </div>
                    <div id="update_history">
                        
                    </div>
                    <div id="article_content">
                        
                            <h2 id="%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%B1%8F%E9%A9%B1%E5%8A%A8%E7%AE%80%E4%BB%8B">电容触摸屏驱动简介</h2>
<h2 id="%E4%BD%BF%E7%94%A8">使用</h2>
<p>使用i2c驱动, 初始化中断引脚, 读取设备数据, 在中断里面上报input子系统</p>
<h2 id="%E7%AE%80%E4%BB%8B">简介</h2>
<h4 id="%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%8F%A3">硬件接口</h4>
<ul>
<li>SCL、SDA信号线：IIC接口，读取坐标信息</li>
<li>INT信号线：检测触摸信号，产生外部中断</li>
<li>RST信号线：复位触摸芯片</li>
</ul>
<h4 id="%E9%A9%B1%E5%8A%A8%E6%A0%B8%E5%BF%83">驱动核心</h4>
<ul>
<li>i2c驱动框架</li>
<li>中断机制</li>
<li>input子系统</li>
<li>多点触摸协议</li>
</ul>
<h4 id="%E5%A4%9A%E7%82%B9%E8%A7%A6%E6%91%B8%28Multi-touch%29-%E5%8D%8F%E8%AE%AE">多点触摸(Multi-touch) 协议</h4>
<p>Documentation/input/multi-touch-protocol.rst</p>
<ul>
<li><p>TypeA ：触摸点不能被区分，哪怕是两次相同的触摸数据信息，一律上报, 使用的是点的原始数据, 系统里面计算点是不是同一个序列(很少使用)</p>
</li>
<li><p>TypeB：触摸点能够被硬件追踪区分，两次相同的触摸数据不上报，而是缓存在slot对象中。</p>
</li>
</ul>
<p>触摸点的信息通过一系列的 ABS_MT 事件(有的资料也叫消息)上报给 linux 内核，只有 ABS_MT 事件是用于多点触摸的，ABS_MT 事件定义在文件 include/uapi/linux/input.h 中</p>
<h5 id="%E5%A4%9A%E7%82%B9%E8%A7%A6%E6%91%B8%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B">多点触摸事件类型</h5>
<p>include/uapi/linux/input-event-codes.h / include/uapi/linux/input.h</p>

<pre class="language-c"><code class="language-c">#define ABS_RESERVED		0x2e

#define ABS_MT_SLOT		0x2f	/* MT slot being modified */
#define ABS_MT_TOUCH_MAJOR	0x30	/* Major axis of touching ellipse */
#define ABS_MT_TOUCH_MINOR	0x31	/* Minor axis (omit if circular) */
#define ABS_MT_WIDTH_MAJOR	0x32	/* Major axis of approaching ellipse */
#define ABS_MT_WIDTH_MINOR	0x33	/* Minor axis (omit if circular) */
#define ABS_MT_ORIENTATION	0x34	/* Ellipse orientation */
#define ABS_MT_POSITION_X	0x35	/* Center X touch position */
#define ABS_MT_POSITION_Y	0x36	/* Center Y touch position */
#define ABS_MT_TOOL_TYPE	0x37	/* Type of touching device */
#define ABS_MT_BLOB_ID		0x38	/* Group a set of packets as a blob */
#define ABS_MT_TRACKING_ID	0x39	/* Unique ID of initiated contact */
#define ABS_MT_PRESSURE		0x3a	/* Pressure on contact area */
#define ABS_MT_DISTANCE		0x3b	/* Contact hover distance */
#define ABS_MT_TOOL_X		0x3c	/* Center X tool position */
#define ABS_MT_TOOL_Y		0x3d	/* Center Y tool position */
</code></pre>
<ul>
<li>ABS_MT_SLOT：上报触点序号</li>
<li>ABS_MT_TRACKING_ID：为触摸点分配ID，用于轨迹跟踪</li>
<li>ABS_MT_POSITION_X：上报触摸点X轴坐标信息</li>
<li>ABS_MT_POSITION_Y：上报触摸点Y轴坐标信息</li>
<li>ABS_MT_TOUCH_MAJOR：上报触摸区域长轴信息（触点椭圆形）</li>
<li>ABS_MT_WIDTH_MAJOR：上报触摸区域短轴信息（触点椭圆形）</li>
</ul>
<h3 id="%E8%A7%A6%E6%91%B8%E6%97%B6%E5%BA%8F">触摸时序</h3>
<h4 id="TypeA">TypeA</h4>
<p>对于 Type A 类型的设备，通过 input_mt_sync()函数来隔离不同的触摸点数据信息, 会触发 SYN_MT_REPORT 事件</p>

<pre class="language-c"><code class="language-c">void input_mt_sync(struct input_dev *dev)
</code></pre>

<pre class="language-c"><code class="language-c">ABS_MT_POSITION_X x[0] // input_report_abs
ABS_MT_POSITION_Y y[0]
SYN_MT_REPORT // input_mt_sync
ABS_MT_POSITION_X x[1]
ABS_MT_POSITION_Y y[1]
SYN_MT_REPORT
SYN_REPORT // input_sync
</code></pre>
<h4 id="TypeB%E8%AE%BE%E5%A4%87%E4%B8%8A%E6%8A%A5%E6%97%B6%E5%BA%8F">TypeB设备上报时序</h4>
<p>上报触摸点信息的时候需要通过 input_mt_slot()函数区分是哪一个触摸点, 函数会触发 ABS_MT_SLOT 事件</p>

<pre class="language-c"><code class="language-c">void input_mt_slot(struct input_dev *dev, int slot)
</code></pre>

<pre class="language-c"><code class="language-c">ABS_MT_SLOT 0				//上报触摸点序号(一次读取里面的点的序号) input_mt_slot
ABS_MT_TRACKING_ID 45		//为触摸点分配ID(动态分配) input_mt_report_slot_state
ABS_MT_POSITION_X x[0]		//上报触摸点X轴坐标信息 input_report_abs
ABS_MT_POSITION_Y y[0]		//上报触摸点Y轴坐标信息
ABS_MT_SLOT 1				//以下同上
ABS_MT_TRACKING_ID 46		
ABS_MT_POSITION_X x[1]
ABS_MT_POSITION_Y y[1]
SYN_REPORT					//同步事件 input_sync
</code></pre>
<p>Type B设备驱动需要给每个识别出来的触摸点分配一个 slot，后面使用这个 slot来上报触摸点信息。可以通过 slot 的 ABS_MT_TRACKING_ID 来新增、替换或删除触摸点。一个非负数的ID表示一个有效的触摸点，-1这个ID表示未使用 slot。一个以前不存在的 ID表示这是一个新加的触摸点，一个 ID如果再也不存在了就表示删除了</p>
<h3 id="API">API</h3>
<h4 id="input_mt_init_slots%28%29%E5%87%BD%E6%95%B0">input_mt_init_slots()函数</h4>
<p>drivers/input/input-mt.c</p>
<p>初始化所有触摸点slot对象, 在初始化的时候进行设置, 指定可以使用的触摸点的最大数量</p>

<pre class="language-c"><code class="language-c">int input_mt_init_slots(struct input_dev *dev, unsigned int num_slots,
    		unsigned int flags)
</code></pre>
<p>参数：</p>
<ul>
<li><p>dev：具体输入设备</p>
</li>
<li><p>num_slots：设备要使用触摸点数量，由触摸芯片决定, 在初始化的时候设置一下这个设备支持的最多的点数</p>
</li>
<li><p>flags：触摸输入设备的flags信息</p>
<ul>
<li><p>INPUT_MT_POINTER：触控板</p>
</li>
<li><p>INPUT_MT_DIRECT：触摸屏</p>
</li>
<li><p>...</p>
</li>
</ul>
</li>
</ul>
<p>返回值：</p>
<ul>
<li><p>成功：0</p>
</li>
<li><p>失败：负数</p>
</li>
</ul>
<h4 id="input_mt_slot%28%29%E5%87%BD%E6%95%B0">input_mt_slot()函数</h4>
<p>include/linux/input/mt.h</p>
<p>上报触摸点的序号, 在TypeB里面的一次上报里面处理不同的触摸点</p>

<pre class="language-c"><code class="language-c">static inline void input_mt_slot(struct input_dev *dev, int slot)
{
    input_event(dev, EV_ABS, ABS_MT_SLOT, slot);
}
</code></pre>
<p>参数：</p>
<ul>
<li>dev ： 具体输入设备</li>
<li>slot：slot对象的序号，也就是哪个触摸点</li>
</ul>
<p>返回值：</p>
<ul>
<li>成功：0</li>
<li>失败：负数</li>
</ul>
<h4 id="%E4%B8%BA%E8%A7%A6%E6%91%B8%E7%82%B9%E5%88%86%E9%85%8DID">为触摸点分配ID</h4>
<h5 id="input_mt_report_slot_state%28%29%E5%87%BD%E6%95%B0">input_mt_report_slot_state()函数</h5>
<p>drivers/input/input-mt.c</p>
<p>在TypeB里面用于产生 ABS_MT_TRACKING_ID, 给 slot 关联一个 ABS_MT_TRACKING_ID</p>

<pre class="language-c"><code class="language-c">bool input_mt_report_slot_state(struct input_dev *dev,
    			unsigned int tool_type, bool active)
</code></pre>
<p>参数：</p>
<ul>
<li><p>dev ： 具体输入设备</p>
</li>
<li><p>tool_type：触摸类型</p>
<ul>
<li>MT_TOOL_FINGER：手指</li>
<li>MT_TOOL_PEN：笔</li>
<li>MT_TOOL_PALM：手掌</li>
</ul>
</li>
<li><p>active：</p>
<ul>
<li>true：连续触摸，动态分配id</li>
<li>false：触摸点离开，表示触摸点无效，id为-1</li>
</ul>
</li>
</ul>
<h4 id="%E4%B8%8A%E6%8A%A5%E8%A7%A6%E6%91%B8%E7%82%B9%E5%9D%90%E6%A0%87%E4%BF%A1%E6%81%AF">上报触摸点坐标信息</h4>

<pre class="language-c"><code class="language-c">static inline void input_report_abs(struct input_dev *dev, unsigned int code, int value)
</code></pre>
<h4 id="%E4%B8%8A%E6%8A%A5%E7%82%B9%E6%95%B0">上报点数</h4>
<ul>
<li>将多个触控点&quot;降级&quot;为传统的单点鼠标指针事件</li>
</ul>
<p>如果追踪到的触摸点数量多于当前上报的数量，驱动程序使用 BTN_TOOL_TAP 事件来通知用户空间当前追踪到的触摸点总数量, 然后调用 input_mt_report_pointer_emulation 函数将 use_count参数设置为 false。否则的话将use_count参数设置为true，表示当前的触摸点数量(此函数会获取到具体的触摸点数量，不需要用户给出)</p>

<pre class="language-c"><code class="language-c">void input_mt_report_pointer_emulation(struct input_dev *dev,
    bool use_count)
</code></pre>
<p><strong>dev</strong>： MT设备对应的 input_dev。</p>
<p><strong>use_count</strong>：true，有效的触摸点数量；false，追踪到的触摸点数量多于当前上报的数量。</p>
<p>返回值：无。</p>
<h3 id="%E4%B8%8A%E6%8A%A5%E6%97%B6%E5%BA%8F%E6%A1%88%E4%BE%8B">上报时序案例</h3>
<p>drivers/input/touchscreen/ili210x.c</p>
<h5 id="ili210x_report_events%28%29%E5%87%BD%E6%95%B0">ili210x_report_events()函数</h5>

<pre class="language-c"><code class="language-c">static bool ili210x_report_events(struct ili210x *priv, u8 *touchdata)
{
    struct input_dev *input = priv-&gt;input;
    int i;
    bool contact = false, touch = false;
    unsigned int x = 0, y = 0;

    for (i = 0; i &lt; priv-&gt;max_touches; i++) {
    	...
    touch = touchdata-&gt;status &amp; (1 &lt;&lt; i); // 判断这个触摸点的状态
    // 每个触摸点处理
    	input_mt_slot(input, i);
    	input_mt_report_slot_state(input, MT_TOOL_FINGER, touch);
    	if (!touch)
    		continue;
    	touchscreen_report_pos(input, &amp;priv-&gt;prop, x, y,
    			       true);
    }

    input_mt_report_pointer_emulation(input, false);
    // 同步
    input_sync(input);

    if (priv-&gt;model == MODEL_ILI210X)
    	contact = touchdata[0] &amp; 0xf3;

    return contact;
}
</code></pre>
<h5 id="touchscreen_report_pos%28%29%E5%87%BD%E6%95%B0">touchscreen_report_pos()函数</h5>
<p>drivers/input/touchscreen/of_touchscreen.c</p>

<pre class="language-c"><code class="language-c">void touchscreen_report_pos(struct input_dev *input,
    		    const struct touchscreen_properties *prop,
    		    unsigned int x, unsigned int y,
    		    bool multitouch)
{
    touchscreen_apply_prop_to_x_y(prop, &amp;x, &amp;y);
    input_report_abs(input, multitouch ? ABS_MT_POSITION_X : ABS_X, x);
    input_report_abs(input, multitouch ? ABS_MT_POSITION_Y : ABS_Y, y);
}
</code></pre>
<h4 id="%E5%A4%9A%E7%82%B9%E8%A7%A6%E6%91%B8%E5%B1%8F%E9%A9%B1%E5%8A%A8%E6%A1%86%E6%9E%B6">多点触摸屏驱动框架</h4>
<p>I2C驱动入口</p>

<pre class="language-c"><code class="language-c">/* i2c设备驱动*/
static struct i2c_driver ft5x06_ts_driver = {
    .driver = {
        .owner = THIS_MODULE,
        .name = &quot;xxx&quot;,
        .of_match_table = of_match_ptr(xxx_of_match),
    },
    .probe = yyy_probe,
    .remove = zzz_remove,
};
/* 模块入口函数 */
static int __init xxx_init(void)
{
    int ret = 0;

    ret = i2c_add_driver(&amp;xxx_ts_driver);

    return ret;
}
</code></pre>
<h5 id="yyy_probe%28%29%E5%87%BD%E6%95%B0">yyy_probe()函数</h5>
<p>初始化触摸芯片、外部中断、input子系统</p>

<pre class="language-c"><code class="language-c">static int yyy_probe(struct i2c_client *client, const struct
i2c_device_id *id)
{
    struct input_dev *input;
    //初始化触摸芯片，iic配置相关寄存器
    ...
    //申请中断
    devm_request_threaded_irq(&amp;client-&gt;dev, client-&gt;irq, NULL,
    zzz_handler, IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
    client-&gt;name, &amp;XXX);
    
    //分配外部输入设备并初步初始化
    input = devm_input_allocate_device(&amp;client-&gt;dev);
    
    ts-&gt;input_dev-&gt;name = &quot;Goodix Capacitive TouchScreen&quot;;
    ts-&gt;input_dev-&gt;phys = &quot;input/ts&quot;;
    ts-&gt;input_dev-&gt;id.bustype = BUS_I2C;
    
    //配置输入设备的事件类型
    input_set_capability(ts-&gt;input_dev, EV_ABS, ABS_MT_POSITION_X);
    input_set_capability(ts-&gt;input_dev, EV_ABS, ABS_MT_POSITION_Y);
    
    //初始化所有触摸点slot对象
    input_mt_init_slots(input, MAX_SUPPORT_POINTS, 0);
    
    //注册输入设备
    input_register_device(input);
    ...
}
</code></pre>
<blockquote>
<p>devm_开始的中断可以自动释放</p>
<p>devm_request_threaded_irq处理的函数是作为一个内核线程进行的</p>
</blockquote>
<h4 id="%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E5%87%BD%E6%95%B0%E4%B8%8A%E6%8A%A5%E5%9D%90%E6%A0%87">中断处理函数上报坐标</h4>
<p>zzz_handler()函数</p>
<p>按时序上报多点触摸屏信息</p>
<h2 id="%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%B1%8F%E9%A9%B1%E5%8A%A8%E5%AE%9E%E9%AA%8C">电容触摸屏驱动实验</h2>
<h4 id="%E7%A1%AC%E4%BB%B6%E5%8E%9F%E7%90%86%E5%9B%BE">硬件原理图</h4>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509281035079.png" alt="image-20200923115400613" /></p>
<h4 id="%E8%AE%BE%E5%A4%87%E6%A0%91%E8%8A%82%E7%82%B9">设备树节点</h4>
<h5 id="iomuxc%E5%AD%90%E8%8A%82%E7%82%B9">iomuxc子节点</h5>

<pre class="language-json"><code class="language-json">pinctrl_i2c1: i2c1grp {
            fsl,pins = &lt;
                    MX6UL_PAD_UART4_TX_DATA__I2C1_SCL 0x4001b8b0
                    MX6UL_PAD_UART4_RX_DATA__I2C1_SDA 0x4001b8b0
            &gt;;
        };

pinctrl_tsc_reset: tscresetgrp {
        fsl,pins = &lt;
            /* used for tsc reset */
            MX6UL_PAD_LCD_RESET__GPIO3_IO04         0x10b0
        &gt;;
    };
</code></pre>
<h5 id="iomuxc_snvs%E5%AD%90%E8%8A%82%E7%82%B9">iomuxc_snvs子节点</h5>

<pre class="language-json"><code class="language-json">pinctrl_tsc_irq: tsc_irq {
        fsl,pins = &lt;
            MX6ULL_PAD_SNVS_TAMPER9__GPIO5_IO09        0x4001b8b0
        &gt;;
    };
</code></pre>
<blockquote>
<p>snvs开头的节点属于是电源管理相关的引脚, 在这一个节点里面配置</p>
</blockquote>
<h5 id="i2c1%E5%AD%90%E8%8A%82%E7%82%B9">i2c1子节点</h5>

<pre class="language-c"><code class="language-c">gtxx_tsc@5d {
            compatible = &quot;fire,gt9xx_test&quot;;
    					pinctrl-names = &quot;default&quot;;
            pinctrl-0 = &lt;&amp;pinctrl_tsc_reset &amp;pinctrl_tsc_irq&gt;;
            reg = &lt;0x5d&gt;;
            status = &quot;okay&quot;;

            /*gpio*/
            reset-gpios = &lt;&amp;gpio3 4 GPIO_ACTIVE_LOW&gt;;
            irq-gpios = &lt;&amp;gpio5 9 GPIO_ACTIVE_HIGH&gt;;

            /*中断*/
            interrupt-parent = &lt;&amp;gpio5&gt;;
            interrupts = &lt;9 IRQ_TYPE_EDGE_FALLING&gt;;
            irq-flags = &lt;2&gt;;                /*1:rising 2: falling*/
    };
</code></pre>
<h4 id="GT9157%E8%A7%A6%E6%91%B8%E8%8A%AF%E7%89%87%E4%BB%8B%E7%BB%8D">GT9157触摸芯片介绍</h4>
<p>《STM32 HAL库开发实战指南》--&gt;第29章 电容触摸屏--触摸画板</p>
<h5 id="%E4%B8%8A%E7%94%B5%E6%97%B6%E5%BA%8F%E4%B8%8E-I2C%E8%AE%BE%E5%A4%87%E5%9C%B0%E5%9D%80">上电时序与 I2C设备地址</h5>
<h5 id="%E5%AF%84%E5%AD%98%E5%99%A8%E9%85%8D%E7%BD%AE">寄存器配置</h5>
<ul>
<li>版本寄存器</li>
<li>X、Y坐标范围</li>
<li>触点个数</li>
<li>模式切换</li>
<li>配置校验</li>
<li>状态寄存器</li>
</ul>
<h4 id="%E7%94%B5%E5%AE%B9%E8%A7%A6%E6%91%B8%E5%B1%8F%E9%A9%B1%E5%8A%A8">电容触摸屏驱动</h4>
<p>drivers/input/touchscreen/goodix.c</p>
<h5 id="goodix_ts_data%E7%BB%93%E6%9E%84%E4%BD%93">goodix_ts_data结构体</h5>

<pre class="language-c"><code class="language-c">struct goodix_ts_data {
    struct i2c_client *client;  //i2c 从设备结构体
    struct input_dev *input_dev; //输入设备结构体
    const struct goodix_chip_data *chip;  //goodix相关内容
    struct touchscreen_properties prop;   //未知内容
    unsigned int max_touch_num;     //做大支持的触摸点
    unsigned int int_trigger_type;  //触摸类型
    struct gpio_desc *gpiod_int;    //触摸中断引脚
    struct gpio_desc *gpiod_rst;    //触摸芯片复位引脚
    u16 id;                         //触摸芯片, 从寄存器里面进行读取
    u16 version;                    //版本
    const char *cfg_name;           //名字
    struct completion firmware_loading_complete;  //固件加载完成标志, 从用户空间读取寄存器加载的内容
    unsigned long irq_flags;        //中断标记
};
</code></pre>
<h5 id="goodix_chip_data%E7%BB%93%E6%9E%84%E4%BD%93">goodix_chip_data结构体</h5>

<pre class="language-c"><code class="language-c">struct goodix_chip_data {
    u16 config_addr;		//寄存器配置地址
    int config_len;			//寄存器配置长度
    int (*check_config)(struct goodix_ts_data *, const struct firmware *); // 校验
};
</code></pre>
<h5 id="hexdump%E5%91%BD%E4%BB%A4">hexdump命令</h5>
<p>Linux下的一个二进制文件查看工具</p>

<pre class="language-c"><code class="language-c">hexdump xxx	//十六进制显示文件内容
</code></pre>
<h5 id="%E8%A7%A6%E6%91%B8%E5%B1%8F%E6%95%B0%E6%8D%AE%E6%98%BE%E7%A4%BA%E6%A0%BC%E5%BC%8F%E8%AF%B4%E6%98%8E">触摸屏数据显示格式说明</h5>
<table>
<thead>
<tr>
  <th>数据编号</th>
  <th>时间戳s</th>
  <th>时间戳us</th>
  <th>type</th>
  <th>code</th>
  <th>value</th>
</tr>
</thead>
<tbody>
<tr>
  <td>0000000</td>
  <td>eeec 5f6a</td>
  <td>580c 000e</td>
  <td>0003</td>
  <td>0039</td>
  <td>0000 0000</td>
</tr>
<tr>
  <td>0000010</td>
  <td>eeec 5f6a</td>
  <td>580c 000e</td>
  <td>0003</td>
  <td>0035</td>
  <td>0006 0000</td>
</tr>
<tr>
  <td>...</td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
  <td></td>
</tr>
</tbody>
</table>
<h5 id="input_event%E7%BB%93%E6%9E%84%E4%BD%93">input_event结构体</h5>
<p>include/uapi/linux/input.h</p>

<pre class="language-c"><code class="language-c">struct input_event {
    struct timeval time;
    __u16 type;
    __u16 code;
    __s32 value;
};
</code></pre>
<p>两个错误：</p>
<ul>
<li>触摸芯片名字</li>
<li>cfg_name</li>
</ul>
<h2 id="%E9%A9%B1%E5%8A%A8">驱动</h2>

<pre class="language-c"><code class="language-c">/*
 *  Driver for Goodix Touchscreens
 *
 *  Copyright (c) 2014 Red Hat Inc.
 *  Copyright (c) 2015 K. Merker &lt;merker@debian.org&gt;
 *
 *  This code is based on gt9xx.c authored by andrew@goodix.com:
 *
 *  2010 - 2012 Goodix Technology.
 */

/*
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation; version 2 of the License.
 */

#include &lt;linux/kernel.h&gt;
#include &lt;linux/dmi.h&gt;
#include &lt;linux/firmware.h&gt;
#include &lt;linux/gpio/consumer.h&gt;
#include &lt;linux/i2c.h&gt;
#include &lt;linux/input.h&gt;
#include &lt;linux/input/mt.h&gt;
#include &lt;linux/input/touchscreen.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/delay.h&gt;
#include &lt;asm/io.h&gt;
#include &lt;linux/irq.h&gt;
#include &lt;linux/interrupt.h&gt;
#include &lt;linux/slab.h&gt;
#include &lt;linux/acpi.h&gt;
#include &lt;linux/of.h&gt;
#include &lt;asm/unaligned.h&gt;

struct goodix_ts_data;

struct goodix_chip_data {
    u16 config_addr;
    int config_len;
    int (*check_config)(struct goodix_ts_data *, const struct firmware *);
};



struct goodix_ts_data {
    struct i2c_client *client;
    struct input_dev *input_dev;
    const struct goodix_chip_data *chip;
    struct touchscreen_properties prop;
    unsigned int max_touch_num;
    unsigned int int_trigger_type;
    struct gpio_desc *gpiod_int;
    struct gpio_desc *gpiod_rst;
    u16 id;
    u16 version;
    const char *cfg_name;
    struct completion firmware_loading_complete;
    unsigned long irq_flags;
};

#define GOODIX_GPIO_INT_NAME		&quot;irq&quot;
#define GOODIX_GPIO_RST_NAME		&quot;reset&quot;

#define GOODIX_MAX_HEIGHT		4096
#define GOODIX_MAX_WIDTH		4096
#define GOODIX_INT_TRIGGER		1
#define GOODIX_CONTACT_SIZE		8
#define GOODIX_MAX_CONTACTS		10

#define GOODIX_CONFIG_MAX_LENGTH	242    //fire 修改
#define GOODIX_CONFIG_917_LENGTH	242    //fire 新增
#define GOODIX_CONFIG_5688_LENGTH	242    //fire 新增
#define GOODIX_CONFIG_911_LENGTH	186
#define GOODIX_CONFIG_967_LENGTH	228


/* Register defines */
#define GOODIX_REG_COMMAND		0x8040
#define GOODIX_CMD_SCREEN_OFF		0x05

#define GOODIX_READ_COOR_ADDR		0x814E
#define GOODIX_GT1X_REG_CONFIG_DATA	0x8050

#define GOODIX_GT5688_REG_CONFIG_DATA	0x8050  //fire 新增
#define GOODIX_GT917_REG_CONFIG_DATA	0x8050  //fire 新增


#define GOODIX_GT9X_REG_CONFIG_DATA	0x8047
#define GOODIX_REG_ID			0x8140

#define GOODIX_BUFFER_STATUS_READY	BIT(7)
#define GOODIX_BUFFER_STATUS_TIMEOUT	20

#define RESOLUTION_LOC		1
#define MAX_CONTACTS_LOC	5
#define TRIGGER_LOC		6

static int goodix_check_cfg_8(struct goodix_ts_data *ts,
    		const struct firmware *cfg);
static int goodix_check_cfg_16(struct goodix_ts_data *ts,
    		const struct firmware *cfg);

static const struct goodix_chip_data gt1x_chip_data = {
    .config_addr		= GOODIX_GT1X_REG_CONFIG_DATA,
    .config_len		= GOODIX_CONFIG_MAX_LENGTH,
    .check_config		= goodix_check_cfg_16,
};

static const struct goodix_chip_data gt911_chip_data = {
    .config_addr		= GOODIX_GT9X_REG_CONFIG_DATA,
    .config_len		= GOODIX_CONFIG_911_LENGTH,
    .check_config		= goodix_check_cfg_8,
};

static const struct goodix_chip_data gt967_chip_data = {
    .config_addr		= GOODIX_GT9X_REG_CONFIG_DATA,
    .config_len		= GOODIX_CONFIG_967_LENGTH,
    .check_config		= goodix_check_cfg_8,
};

static const struct goodix_chip_data gt9x_chip_data = {
    .config_addr		= GOODIX_GT9X_REG_CONFIG_DATA,
    .config_len		= GOODIX_CONFIG_MAX_LENGTH,
    .check_config		= goodix_check_cfg_8,
};


/*fire 新增 ----2020/7/14*/
static const struct goodix_chip_data gt917_chip_data = {
    .config_addr		= GOODIX_GT917_REG_CONFIG_DATA,
    .config_len		= GOODIX_CONFIG_917_LENGTH,
    .check_config		= goodix_check_cfg_16,
};

/*fire 新增 ----2020/7/14*/
static const struct goodix_chip_data gt5688_chip_data = {
    .config_addr		= GOODIX_GT917_REG_CONFIG_DATA,
    .config_len		= GOODIX_CONFIG_5688_LENGTH,
    .check_config		= goodix_check_cfg_16,
};


static const unsigned long goodix_irq_flags[] = {
    IRQ_TYPE_EDGE_RISING,
    IRQ_TYPE_EDGE_FALLING,
    IRQ_TYPE_LEVEL_LOW,
    IRQ_TYPE_LEVEL_HIGH,
};

/*
 * Those tablets have their coordinates origin at the bottom right
 * of the tablet, as if rotated 180 degrees
 */
static const struct dmi_system_id rotated_screen[] = {
#if defined(CONFIG_DMI) &amp;&amp; defined(CONFIG_X86)
    {
    	.ident = &quot;WinBook TW100&quot;,
    	.matches = {
    		DMI_MATCH(DMI_SYS_VENDOR, &quot;WinBook&quot;),
    		DMI_MATCH(DMI_PRODUCT_NAME, &quot;TW100&quot;)
    	}
    },
    {
    	.ident = &quot;WinBook TW700&quot;,
    	.matches = {
    		DMI_MATCH(DMI_SYS_VENDOR, &quot;WinBook&quot;),
    		DMI_MATCH(DMI_PRODUCT_NAME, &quot;TW700&quot;)
    	},
    },
#endif
    {}
};

/**
 * goodix_i2c_read - read data from a register of the i2c slave device.
 *
 * @client: i2c device.
 * @reg: the register to read from.
 * @buf: raw write data buffer.
 * @len: length of the buffer to write
 */
static int goodix_i2c_read(struct i2c_client *client,
    		   u16 reg, u8 *buf, int len)
{
    struct i2c_msg msgs[2];
    __be16 wbuf = cpu_to_be16(reg);
    int ret;

    msgs[0].flags = 0;
    msgs[0].addr  = client-&gt;addr;
    msgs[0].len   = 2;
    msgs[0].buf   = (u8 *)&amp;wbuf;

    msgs[1].flags = I2C_M_RD;
    msgs[1].addr  = client-&gt;addr;
    msgs[1].len   = len;
    msgs[1].buf   = buf;

    ret = i2c_transfer(client-&gt;adapter, msgs, 2);
    return ret &lt; 0 ? ret : (ret != ARRAY_SIZE(msgs) ? -EIO : 0);
}

/**
 * goodix_i2c_write - write data to a register of the i2c slave device.
 *
 * @client: i2c device.
 * @reg: the register to write to.
 * @buf: raw data buffer to write.
 * @len: length of the buffer to write
 */
static int goodix_i2c_write(struct i2c_client *client, u16 reg, const u8 *buf,
    		    unsigned len)
{
    u8 *addr_buf;
    struct i2c_msg msg;
    int ret;

    addr_buf = kmalloc(len + 2, GFP_KERNEL);
    if (!addr_buf)
    	return -ENOMEM;

    addr_buf[0] = reg &gt;&gt; 8;
    addr_buf[1] = reg &amp; 0xFF;
    memcpy(&amp;addr_buf[2], buf, len);

    msg.flags = 0;
    msg.addr = client-&gt;addr;
    msg.buf = addr_buf;
    msg.len = len + 2;

    ret = i2c_transfer(client-&gt;adapter, &amp;msg, 1);
    kfree(addr_buf);
    return ret &lt; 0 ? ret : (ret != 1 ? -EIO : 0);
}

static int goodix_i2c_write_u8(struct i2c_client *client, u16 reg, u8 value)
{
    return goodix_i2c_write(client, reg, &amp;value, sizeof(value));
}

static const struct goodix_chip_data *goodix_get_chip_data(u16 id)
{
    switch (id) {
    case 1151:
    	return &amp;gt1x_chip_data;
    case 911:
    case 9271:
    case 9110:
    case 927:
    case 928:
    	return &amp;gt911_chip_data;
    
    case 912:
    case 9157:         // fire 新增 2020/7/14
    	return &amp;gt9x_chip_data;
    case 917:         // fire 新增 2020/7/14
    	return &amp;gt917_chip_data;
    case 5688:         // fire 新增 2020/7/14
    	return &amp;gt5688_chip_data;	
    case 967:
    	return &amp;gt967_chip_data;

    default:
    	return &amp;gt9x_chip_data;
    }
}

static int goodix_ts_read_input_report(struct goodix_ts_data *ts, u8 *data)
{
    unsigned long max_timeout;
    int touch_num;
    int error;

    /*
     * The 'buffer status' bit, which indicates that the data is valid, is
     * not set as soon as the interrupt is raised, but slightly after.
     * This takes around 10 ms to happen, so we poll for 20 ms.
     */
    max_timeout = jiffies + msecs_to_jiffies(GOODIX_BUFFER_STATUS_TIMEOUT);
    do {
    	error = goodix_i2c_read(ts-&gt;client, GOODIX_READ_COOR_ADDR,
    				data, GOODIX_CONTACT_SIZE + 1);
    	if (error) {
    		dev_err(&amp;ts-&gt;client-&gt;dev, &quot;I2C transfer error: %d\n&quot;,
    				error);
    		return error;
    	}

    	if (data[0] &amp; GOODIX_BUFFER_STATUS_READY) {
    		touch_num = data[0] &amp; 0x0f;
    		if (touch_num &gt; ts-&gt;max_touch_num)
    			return -EPROTO;

    		if (touch_num &gt; 1) {
    			data += 1 + GOODIX_CONTACT_SIZE;
    			error = goodix_i2c_read(ts-&gt;client,
    					GOODIX_READ_COOR_ADDR +
    						1 + GOODIX_CONTACT_SIZE,
    					data,
    					GOODIX_CONTACT_SIZE *
    						(touch_num - 1));
    			if (error)
    				return error;
    		}

    		return touch_num;
    	}

    	usleep_range(1000, 2000); /* Poll every 1 - 2 ms */
    } while (time_before(jiffies, max_timeout));

    /*
     * The Goodix panel will send spurious interrupts after a
     * 'finger up' event, which will always cause a timeout.
     */
    return 0;
}

static void goodix_ts_report_touch(struct goodix_ts_data *ts, u8 *coor_data)
{
    int id = coor_data[0] &amp; 0x0F;
    int input_x = get_unaligned_le16(&amp;coor_data[1]);
    int input_y = get_unaligned_le16(&amp;coor_data[3]);
    int input_w = get_unaligned_le16(&amp;coor_data[5]);

    input_mt_slot(ts-&gt;input_dev, id);
    input_mt_report_slot_state(ts-&gt;input_dev, MT_TOOL_FINGER, true);
    touchscreen_report_pos(ts-&gt;input_dev, &amp;ts-&gt;prop,
    		       input_x, input_y, true);
    input_report_abs(ts-&gt;input_dev, ABS_MT_TOUCH_MAJOR, input_w);
    input_report_abs(ts-&gt;input_dev, ABS_MT_WIDTH_MAJOR, input_w);
}

/**
 * goodix_process_events - Process incoming events
 *
 * @ts: our goodix_ts_data pointer
 *
 * Called when the IRQ is triggered. Read the current device state, and push
 * the input events to the user space.
 */
static void goodix_process_events(struct goodix_ts_data *ts)
{
    u8  point_data[1 + GOODIX_CONTACT_SIZE * GOODIX_MAX_CONTACTS];
    int touch_num;
    int i;

    touch_num = goodix_ts_read_input_report(ts, point_data);
    if (touch_num &lt; 0)
    	return;

    /*
     * Bit 4 of the first byte reports the status of the capacitive
     * Windows/Home button.
     */
    input_report_key(ts-&gt;input_dev, KEY_LEFTMETA, point_data[0] &amp; BIT(4));

    for (i = 0; i &lt; touch_num; i++)
    	goodix_ts_report_touch(ts,
    			&amp;point_data[1 + GOODIX_CONTACT_SIZE * i]);

    
}

/**
 * goodix_ts_irq_handler - The IRQ handler
 *
 * @irq: interrupt number.
 * @dev_id: private data pointer.
 */
static irqreturn_t goodix_ts_irq_handler(int irq, void *dev_id)
{
    struct goodix_ts_data *ts = dev_id;

    goodix_process_events(ts);

    if (goodix_i2c_write_u8(ts-&gt;client, GOODIX_READ_COOR_ADDR, 0) &lt; 0)
    	dev_err(&amp;ts-&gt;client-&gt;dev, &quot;I2C write end_cmd error\n&quot;);

    return IRQ_HANDLED;
}

static void goodix_free_irq(struct goodix_ts_data *ts)
{
    devm_free_irq(&amp;ts-&gt;client-&gt;dev, ts-&gt;client-&gt;irq, ts);
}

static int goodix_request_irq(struct goodix_ts_data *ts)
{
    return devm_request_threaded_irq(&amp;ts-&gt;client-&gt;dev, ts-&gt;client-&gt;irq,
    				 NULL, goodix_ts_irq_handler,
    				 ts-&gt;irq_flags, ts-&gt;client-&gt;name, ts);
}

static int goodix_check_cfg_8(struct goodix_ts_data *ts,
    		const struct firmware *cfg)
{
    int i, raw_cfg_len = cfg-&gt;size - 2;


    u8 check_sum = 0;

    for (i = 0; i &lt; raw_cfg_len; i++)
    	check_sum += cfg-&gt;data[i];


    check_sum = (~check_sum) + 1;

    if (check_sum != cfg-&gt;data[raw_cfg_len]) {
    	dev_err(&amp;ts-&gt;client-&gt;dev,
    		&quot;The checksum of the config fw is not correct&quot;);
    	return -EINVAL;
    }

    if (cfg-&gt;data[raw_cfg_len + 1] != 1) {
    	dev_err(&amp;ts-&gt;client-&gt;dev,
    		&quot;Config fw must have Config_Fresh register set&quot;);
    	return -EINVAL;
    }
    return 0;
}

static int goodix_check_cfg_16(struct goodix_ts_data *ts,
    		const struct firmware *cfg)
{
    int i, raw_cfg_len = cfg-&gt;size - 3;
    u16 check_sum = 0;

    for (i = 0; i &lt; raw_cfg_len; i += 2)
    	check_sum += get_unaligned_be16(&amp;cfg-&gt;data[i]);
    check_sum = (~check_sum) + 1;

    dev_err(&amp;ts-&gt;client-&gt;dev,&quot;goodix_check_cfg_16&quot;);

    if (check_sum != get_unaligned_be16(&amp;cfg-&gt;data[raw_cfg_len])) {
    	dev_err(&amp;ts-&gt;client-&gt;dev,
    		&quot;The checksum of the config fw is not correct&quot;);
    	return -EINVAL;
    }

    if (cfg-&gt;data[raw_cfg_len + 2] != 1) {
    	dev_err(&amp;ts-&gt;client-&gt;dev,
    		&quot;Config fw must have Config_Fresh register set&quot;);
    	return -EINVAL;
    }

    return 0;
}

/**
 * goodix_check_cfg - Checks if config fw is valid
 *
 * @ts: goodix_ts_data pointer
 * @cfg: firmware config data
 */
static int goodix_check_cfg(struct goodix_ts_data *ts,
    		    const struct firmware *cfg)
{
    dev_err(&amp;ts-&gt;client-&gt;dev,&quot;cfg-&gt;size = %d,GOODIX_CONFIG_MAX_LENGTH = %d&quot;,cfg-&gt;size,GOODIX_CONFIG_MAX_LENGTH);
    if (cfg-&gt;size &gt; GOODIX_CONFIG_MAX_LENGTH) {
    	dev_err(&amp;ts-&gt;client-&gt;dev,
    		&quot;The length of the config fw is not correct&quot;);
    	return -EINVAL;
    }

    return ts-&gt;chip-&gt;check_config(ts, cfg);
}

/**
 * goodix_send_cfg - Write fw config to device
 *
 * @ts: goodix_ts_data pointer
 * @cfg: config firmware to write to device
 */
static int goodix_send_cfg(struct goodix_ts_data *ts,
    		   const struct firmware *cfg)
{
    int error;

    error = goodix_check_cfg(ts, cfg);
    if (error)
    	return error;

    error = goodix_i2c_write(ts-&gt;client, ts-&gt;chip-&gt;config_addr, cfg-&gt;data,
    			 cfg-&gt;size);
    if (error) {
    	dev_err(&amp;ts-&gt;client-&gt;dev, &quot;Failed to write config data: %d&quot;,
    		error);
    	return error;
    }
    dev_dbg(&amp;ts-&gt;client-&gt;dev, &quot;Config sent successfully.&quot;);

    /* Let the firmware reconfigure itself, so sleep for 10ms */
    usleep_range(10000, 11000);

    return 0;
}

static int goodix_int_sync(struct goodix_ts_data *ts)
{
    int error;

    error = gpiod_direction_output(ts-&gt;gpiod_int, 0);
    if (error)
    	return error;

    msleep(50);				/* T5: 50ms */

    error = gpiod_direction_input(ts-&gt;gpiod_int);
    if (error)
    	return error;

    return 0;
}

/**
 * goodix_reset - Reset device during power on
 *
 * @ts: goodix_ts_data pointer
 */
// 处理复位事件
static int goodix_reset(struct goodix_ts_data *ts)
{
    int error;

    /* begin select I2C slave addr */
    error = gpiod_direction_output(ts-&gt;gpiod_rst, 0);
    if (error)
    	return error;

    msleep(20);				/* T2: &gt; 10ms */

    /* HIGH: 0x28/0x29, LOW: 0xBA/0xBB */
    error = gpiod_direction_output(ts-&gt;gpiod_int, ts-&gt;client-&gt;addr == 0x14);
    if (error)
    	return error;

    usleep_range(100, 2000);		/* T3: &gt; 100us */

    error = gpiod_direction_output(ts-&gt;gpiod_rst, 1);
    if (error)
    	return error;

    usleep_range(6000, 10000);		/* T4: &gt; 5ms */

    /* end select I2C slave addr */
    error = gpiod_direction_input(ts-&gt;gpiod_rst);
    if (error)
    	return error;
    // int引脚设置一下默认电平
    error = goodix_int_sync(ts);
    if (error)
    	return error;

    return 0;
}

/**
 * goodix_get_gpio_config - Get GPIO config from ACPI/DT
 *
 * @ts: goodix_ts_data pointer
 */
static int goodix_get_gpio_config(struct goodix_ts_data *ts)
{
    int error;
    struct device *dev;
    struct gpio_desc *gpiod;

    if (!ts-&gt;client)
    	return -EINVAL;
    dev = &amp;ts-&gt;client-&gt;dev;

    /* Get the interrupt GPIO pin number */
    // 获取int引脚
    gpiod = devm_gpiod_get_optional(dev, GOODIX_GPIO_INT_NAME, GPIOD_IN);
    if (IS_ERR(gpiod)) {
    	error = PTR_ERR(gpiod);
    	if (error != -EPROBE_DEFER)
    		dev_dbg(dev, &quot;Failed to get %s GPIO: %d\n&quot;,
    			GOODIX_GPIO_INT_NAME, error);
    	return error;
    }

    ts-&gt;gpiod_int = gpiod;

    /* Get the reset line GPIO pin number */
    // 获取reset引脚
    gpiod = devm_gpiod_get_optional(dev, GOODIX_GPIO_RST_NAME, GPIOD_IN);
    if (IS_ERR(gpiod)) {
    	error = PTR_ERR(gpiod);
    	if (error != -EPROBE_DEFER)
    		dev_dbg(dev, &quot;Failed to get %s GPIO: %d\n&quot;,
    			GOODIX_GPIO_RST_NAME, error);
    	return error;
    }

    ts-&gt;gpiod_rst = gpiod;

    return 0;
}

/**
 * goodix_read_config - Read the embedded configuration of the panel
 *
 * @ts: our goodix_ts_data pointer
 *
 * Must be called during probe
 */
static void goodix_read_config(struct goodix_ts_data *ts)
{
    u8 config[GOODIX_CONFIG_MAX_LENGTH];
    int x_max, y_max;
    int error;

    error = goodix_i2c_read(ts-&gt;client, ts-&gt;chip-&gt;config_addr,
    			config, ts-&gt;chip-&gt;config_len);
    if (error) {
    	dev_warn(&amp;ts-&gt;client-&gt;dev, &quot;Error reading config: %d\n&quot;,
    		 error);
    	ts-&gt;int_trigger_type = GOODIX_INT_TRIGGER;
    	ts-&gt;max_touch_num = GOODIX_MAX_CONTACTS;
    	return;
    }

    ts-&gt;int_trigger_type = config[TRIGGER_LOC] &amp; 0x03;
    ts-&gt;max_touch_num = config[MAX_CONTACTS_LOC] &amp; 0x0f;

    x_max = get_unaligned_le16(&amp;config[RESOLUTION_LOC]);
    y_max = get_unaligned_le16(&amp;config[RESOLUTION_LOC + 2]);
    if (x_max &amp;&amp; y_max) {
    	input_abs_set_max(ts-&gt;input_dev, ABS_MT_POSITION_X, x_max - 1);
    	input_abs_set_max(ts-&gt;input_dev, ABS_MT_POSITION_Y, y_max - 1);
    }
}

/**
 * goodix_read_version - Read goodix touchscreen version
 *
 * @ts: our goodix_ts_data pointer
 */
static int goodix_read_version(struct goodix_ts_data *ts)
{
    int error;
    u8 buf[6];
    char id_str[5];

    error = goodix_i2c_read(ts-&gt;client, GOODIX_REG_ID, buf, sizeof(buf));
    if (error) {
    	dev_err(&amp;ts-&gt;client-&gt;dev, &quot;read version failed: %d\n&quot;, error);
    	return error;
    }

    memcpy(id_str, buf, 4);
    dev_info(&amp;ts-&gt;client-&gt;dev, &quot;id_str = %s\n&quot;,id_str);

    /**
     * 处理ID为917S的情况
     * 将917S替换为917
    */
    do
    {
    	if((id_str[0]=='9')&amp;&amp;(id_str[1]=='1')&amp;&amp;(id_str[2]=='7')&amp;&amp;(id_str[3]=='S'))
    	{
    		id_str[0] = '0';
    		id_str[1] = '9';
    		id_str[2] = '1';
    		id_str[3] = '7';
    	}
    } while (0);
    
    id_str[4] = 0;
    if (kstrtou16(id_str, 10, &amp;ts-&gt;id))
    	ts-&gt;id = 0x1001;

    ts-&gt;version = get_unaligned_le16(&amp;buf[4]);

    dev_info(&amp;ts-&gt;client-&gt;dev, &quot;ID %d, version: %04x\n&quot;, ts-&gt;id,
    	 ts-&gt;version);

    return 0;
}

/**
 * goodix_i2c_test - I2C test function to check if the device answers.
 *
 * @client: the i2c client
 */
static int goodix_i2c_test(struct i2c_client *client)
{
    int retry = 0;
    int error;
    u8 test;

    while (retry++ &lt; 2) {
        // 读取一下ID
    	error = goodix_i2c_read(client, GOODIX_REG_ID,
    				&amp;test, 1);
    	if (!error)
    		return 0;

    	dev_err(&amp;client-&gt;dev, &quot;i2c test failed attempt %d: %d\n&quot;,
    		retry, error);
    	msleep(20);
    }

    return error;
}

/**
 * goodix_configure_dev - Finish device initialization
 *
 * @ts: our goodix_ts_data pointer
 *
 * Must be called from probe to finish initialization of the device.
 * Contains the common initialization code for both devices that
 * declare gpio pins and devices that do not. It is either called
 * directly from probe or from request_firmware_wait callback.
 */
// 初始化上报的事件以及中断
static int goodix_configure_dev(struct goodix_ts_data *ts)
{
    int error;

    ts-&gt;int_trigger_type = GOODIX_INT_TRIGGER;
    ts-&gt;max_touch_num = GOODIX_MAX_CONTACTS;

    ts-&gt;input_dev = devm_input_allocate_device(&amp;ts-&gt;client-&gt;dev);
    if (!ts-&gt;input_dev) {
    	dev_err(&amp;ts-&gt;client-&gt;dev, &quot;Failed to allocate input device.&quot;);
    	return -ENOMEM;
    }

    ts-&gt;input_dev-&gt;name = &quot;Goodix Capacitive TouchScreen&quot;;
    ts-&gt;input_dev-&gt;phys = &quot;input/ts&quot;;
    ts-&gt;input_dev-&gt;id.bustype = BUS_I2C;
    ts-&gt;input_dev-&gt;id.vendor = 0x0416;
    ts-&gt;input_dev-&gt;id.product = ts-&gt;id;
    ts-&gt;input_dev-&gt;id.version = ts-&gt;version;

    /* Capacitive Windows/Home button on some devices */
    input_set_capability(ts-&gt;input_dev, EV_KEY, KEY_LEFTMETA);

    input_set_capability(ts-&gt;input_dev, EV_ABS, ABS_MT_POSITION_X);
    input_set_capability(ts-&gt;input_dev, EV_ABS, ABS_MT_POSITION_Y);
    input_set_abs_params(ts-&gt;input_dev, ABS_MT_WIDTH_MAJOR, 0, 255, 0, 0);
    input_set_abs_params(ts-&gt;input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0);

    /* Read configuration and apply touchscreen parameters */
    goodix_read_config(ts);

    /* Try overriding touchscreen parameters via device properties */
    touchscreen_parse_properties(ts-&gt;input_dev, true, &amp;ts-&gt;prop);

    if (!ts-&gt;prop.max_x || !ts-&gt;prop.max_y || !ts-&gt;max_touch_num) {
    	dev_err(&amp;ts-&gt;client-&gt;dev, &quot;Invalid config, using defaults\n&quot;);
    	ts-&gt;prop.max_x = GOODIX_MAX_WIDTH - 1;
    	ts-&gt;prop.max_y = GOODIX_MAX_HEIGHT - 1;
    	ts-&gt;max_touch_num = GOODIX_MAX_CONTACTS;
    	input_abs_set_max(ts-&gt;input_dev,
    			  ABS_MT_POSITION_X, ts-&gt;prop.max_x);
    	input_abs_set_max(ts-&gt;input_dev,
    			  ABS_MT_POSITION_Y, ts-&gt;prop.max_y);
    }

    if (dmi_check_system(rotated_screen)) {
    	ts-&gt;prop.invert_x = true;
    	ts-&gt;prop.invert_y = true;
    	dev_dbg(&amp;ts-&gt;client-&gt;dev,
    		&quot;Applying '180 degrees rotated screen' quirk\n&quot;);
    }

    error = input_mt_init_slots(ts-&gt;input_dev, ts-&gt;max_touch_num,
    			    INPUT_MT_DIRECT | INPUT_MT_DROP_UNUSED);
    if (error) {
    	dev_err(&amp;ts-&gt;client-&gt;dev,
    		&quot;Failed to initialize MT slots: %d&quot;, error);
    	return error;
    }

    error = input_register_device(ts-&gt;input_dev);
    if (error) {
    	dev_err(&amp;ts-&gt;client-&gt;dev,
    		&quot;Failed to register input device: %d&quot;, error);
    	return error;
    }

    ts-&gt;irq_flags = goodix_irq_flags[ts-&gt;int_trigger_type] | IRQF_ONESHOT;
    error = goodix_request_irq(ts);
    if (error) {
    	dev_err(&amp;ts-&gt;client-&gt;dev, &quot;request IRQ failed: %d\n&quot;, error);
    	return error;
    }

    return 0;
}

/**
 * goodix_config_cb - Callback to finish device init
 *
 * @ts: our goodix_ts_data pointer
 *
 * request_firmware_wait callback that finishes
 * initialization of the device.
 */
static void goodix_config_cb(const struct firmware *cfg, void *ctx)
{
    struct goodix_ts_data *ts = ctx;
    int error;

    

    if (cfg) {
    	/* send device configuration to the firmware */
    	error = goodix_send_cfg(ts, cfg); // 实际的配置写入函数
    	
    	if (error)
    		goto err_release_cfg;
    }
    goodix_configure_dev(ts);


err_release_cfg:
    release_firmware(cfg);
    complete_all(&amp;ts-&gt;firmware_loading_complete);
}
// 匹配以后得处理函数
static int goodix_ts_probe(struct i2c_client *client,
    		   const struct i2c_device_id *id)
{
    // 描述的结构体
    struct goodix_ts_data *ts;
    int error;

    dev_dbg(&amp;client-&gt;dev, &quot;I2C Address: 0x%02x\n&quot;, client-&gt;addr);

    if (!i2c_check_functionality(client-&gt;adapter, I2C_FUNC_I2C)) {
    	dev_err(&amp;client-&gt;dev, &quot;I2C check functionality failed.\n&quot;);
    	return -ENXIO;
    }

    ts = devm_kzalloc(&amp;client-&gt;dev, sizeof(*ts), GFP_KERNEL);
    if (!ts)
    	return -ENOMEM;
    // 记录i2c
    ts-&gt;client = client;
    i2c_set_clientdata(client, ts);
    init_completion(&amp;ts-&gt;firmware_loading_complete);
    // 读取GPIO的配置
    error = goodix_get_gpio_config(ts);
    if (error)
    	return error;

    if (ts-&gt;gpiod_int &amp;&amp; ts-&gt;gpiod_rst) {
    	/* reset the controller */
    	error = goodix_reset(ts);
    	if (error) {
    		dev_err(&amp;client-&gt;dev, &quot;Controller reset failed.\n&quot;);
    		return error;
    	}
    }
    else
    {
    	dev_err(&amp;client-&gt;dev,&quot;\n requst gpio filed! \n&quot;);
    }
    
    // 测试一下, 读取ID
    error = goodix_i2c_test(client);
    if (error) {
    	dev_err(&amp;client-&gt;dev, &quot;I2C communication failure: %d\n&quot;, error);
    	return error;
    }
    // 读取版本
    error = goodix_read_version(ts);
    if (error) {
    	dev_err(&amp;client-&gt;dev, &quot;Read version failed.\n&quot;);
    	return error;
    }
    // 获取一系列的寄存器配置
    ts-&gt;chip = goodix_get_chip_data(ts-&gt;id);

    if (ts-&gt;gpiod_int &amp;&amp; ts-&gt;gpiod_rst) 
    {
    	/* update device config */
    	ts-&gt;cfg_name = devm_kasprintf(&amp;client-&gt;dev, GFP_KERNEL,
    				      &quot;goodix_%d_cfg.bin&quot;, ts-&gt;id); // 设置一下名字
    	dev_err(&amp;client-&gt;dev, &quot;ts-&gt;cfg_name = %s \n&quot;,ts-&gt;cfg_name);
    	if (!ts-&gt;cfg_name)
    		return -ENOMEM;
        // 用户空间加载指定的
    	error = request_firmware_nowait(THIS_MODULE, true, ts-&gt;cfg_name,
    					&amp;client-&gt;dev, GFP_KERNEL, ts,
    					goodix_config_cb);
    	if (error) {
    		dev_err(&amp;client-&gt;dev,
    			&quot;Failed to invoke firmware loader: %d\n&quot;,
    			error);
    		return error;
    	}
    	return 0;
    } 
    else 
    {
    	dev_err(&amp;client-&gt;dev,&quot;\n requst gpio filed! \n&quot;);//fire 新增 
    	dev_err(&amp;client-&gt;dev,&quot;\n requst gpio filed! \n&quot;);
    	dev_err(&amp;client-&gt;dev,&quot;\n requst gpio filed! \n&quot;);
    	dev_err(&amp;client-&gt;dev,&quot;\n requst gpio filed! \n&quot;);
    	dev_err(&amp;client-&gt;dev,&quot;\n requst gpio filed! \n&quot;);
    	dev_err(&amp;client-&gt;dev,&quot;\n requst gpio filed! \n&quot;);
    	dev_err(&amp;client-&gt;dev,&quot;\n requst gpio filed! \n&quot;);
    	error = goodix_configure_dev(ts);
    	if (error)
    		return error;
    }

    return 0;
}

static int goodix_ts_remove(struct i2c_client *client)
{
    struct goodix_ts_data *ts = i2c_get_clientdata(client);

    if (ts-&gt;gpiod_int &amp;&amp; ts-&gt;gpiod_rst)
    	wait_for_completion(&amp;ts-&gt;firmware_loading_complete);

    return 0;
}

static int __maybe_unused goodix_suspend(struct device *dev)
{
    struct i2c_client *client = to_i2c_client(dev);
    struct goodix_ts_data *ts = i2c_get_clientdata(client);
    int error;

    /* We need gpio pins to suspend/resume */
    if (!ts-&gt;gpiod_int || !ts-&gt;gpiod_rst) {
    	disable_irq(client-&gt;irq);
    	return 0;
    }

    wait_for_completion(&amp;ts-&gt;firmware_loading_complete);

    /* Free IRQ as IRQ pin is used as output in the suspend sequence */
    goodix_free_irq(ts);

    /* Output LOW on the INT pin for 5 ms */
    error = gpiod_direction_output(ts-&gt;gpiod_int, 0);
    if (error) {
    	goodix_request_irq(ts);
    	return error;
    }

    usleep_range(5000, 6000);

    error = goodix_i2c_write_u8(ts-&gt;client, GOODIX_REG_COMMAND,
    			    GOODIX_CMD_SCREEN_OFF);
    if (error) {
    	dev_err(&amp;ts-&gt;client-&gt;dev, &quot;Screen off command failed\n&quot;);
    	gpiod_direction_input(ts-&gt;gpiod_int);
    	goodix_request_irq(ts);
    	return -EAGAIN;
    }

    /*
     * The datasheet specifies that the interval between sending screen-off
     * command and wake-up should be longer than 58 ms. To avoid waking up
     * sooner, delay 58ms here.
     */
    msleep(58);
    return 0;
}

static int __maybe_unused goodix_resume(struct device *dev)
{
    struct i2c_client *client = to_i2c_client(dev);
    struct goodix_ts_data *ts = i2c_get_clientdata(client);
    int error;

    if (!ts-&gt;gpiod_int || !ts-&gt;gpiod_rst) {
    	enable_irq(client-&gt;irq);
    	return 0;
    }

    /*
     * Exit sleep mode by outputting HIGH level to INT pin
     * for 2ms~5ms.
     */
    error = gpiod_direction_output(ts-&gt;gpiod_int, 1);
    if (error)
    	return error;

    usleep_range(2000, 5000);

    error = goodix_int_sync(ts);
    if (error)
    	return error;

    error = goodix_request_irq(ts);
    if (error)
    	return error;

    return 0;
}

static SIMPLE_DEV_PM_OPS(goodix_pm_ops, goodix_suspend, goodix_resume);



#ifdef CONFIG_ACPI
static const struct acpi_device_id goodix_acpi_match[] = {
    { &quot;GDIX1001&quot;, 0 },
    { &quot;GDIX1002&quot;, 0 },
    { }
};
MODULE_DEVICE_TABLE(acpi, goodix_acpi_match);
#endif




static const struct of_device_id goodix_of_match[] = {
    { .compatible = &quot;goodix,gt1151&quot; },
    { .compatible = &quot;goodix,gt911&quot; },
    { .compatible = &quot;goodix,gt9110&quot; },
    { .compatible = &quot;goodix,gt912&quot; },
    { .compatible = &quot;goodix,gt927&quot; },
    { .compatible = &quot;goodix,gt9271&quot; },
    { .compatible = &quot;goodix,gt928&quot; },
    { .compatible = &quot;goodix,gt967&quot; },
    { .compatible = &quot;fire,gt9xx_test&quot; },// 对应的芯片驱动
    { }
};
MODULE_DEVICE_TABLE(of, goodix_of_match);


static struct i2c_driver goodix_ts_driver = {
    .probe = goodix_ts_probe,
    .remove = goodix_ts_remove,
    // .id_table = goodix_ts_id,
    .driver = {
    	.name = &quot;Goodix-TS-CHANGE&quot;,
    	.acpi_match_table = ACPI_PTR(goodix_acpi_match),
    	.of_match_table = of_match_ptr(goodix_of_match),
    	.pm = &amp;goodix_pm_ops,
    },
};
module_i2c_driver(goodix_ts_driver);

MODULE_AUTHOR(&quot;Benjamin Tissoires &lt;benjamin.tissoires@gmail.com&gt;&quot;);
MODULE_AUTHOR(&quot;Bastien Nocera &lt;hadess@hadess.net&gt;&quot;);
MODULE_DESCRIPTION(&quot;Goodix touchscreen driver&quot;);
MODULE_LICENSE(&quot;GPL v2&quot;);
</code></pre>

                        
                    </div>
                </div>
                <div id="previous_next">
                    <div id="previous">
                        
                        <a href="/note/Linux/野火Linux/2025-9-27-37-Input子系统.html">
                            <span class="icon"></span>
                            <span class="label">2025-9-27-37-Input子系统</span>
                        </a>
                        
                    </div>
                    <div id="next">
                        
                        <a href="/note/Linux/野火Linux/2025-9-28-39-PWM.html">
                            <span class="label">2025-9-28-39-PWM</span>
                            <span class="icon"></span>
                        </a>
                        
                    </div>
                </div>
                <div id="comments-container"></div>
            </div>
            <div id="toc_wrapper">
                <div id="toc">
                    <div id="toc_content">
                            
                    </div>
                </div>
            </div>
        </div>
    </div>
    <a id="to_top" href="#"></a>
    <div id="doc_footer">
        <div id="footer">
            <div id="footer_top">
                <ul>
<li><a>链接</a><ul><li><a target="_blank" href="https://teedoc.neucrack.com">网站使用 teedoc 生成</a></li>
<li><a target="_blank" href="https://neucrack.com">Copyright © 2021 Neucrack</a></li>
<li><a  href="/note/sitemap.xml">网站地图</a></li>
</ul>
</li>
<li><a>源码</a><ul><li><a target="_blank" href="https://github.com/XuSenfeng/note/">github</a></li>
<li><a target="_blank" href="https://github.com/teedoc/teedoc">本网站源文件</a></li>
</ul>
</li>
</ul>

            </div>
            <div id="footer_bottom">
                <ul>
<li><a target="_blank" href="https://beian.miit.gov.cn">渝ICP备19015320号</a></li>
<li><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44030602004109">粤公网安备44030602004109号</a></li>
</ul>

            </div>
        </div>
    </div>
    
        <script src="/note/teedoc-plugin-markdown-parser/mermaid.min.js"></script>
    
        <script>mermaid.initialize({startOnLoad:true});</script>
    
        <script type="text/javascript">
                var transLoaded = false;
                var loading = false;
                var domain = "translate.google.com";
                var domainDefault = domain;
                var storeDomain = localStorage.getItem("googleTransDomain");
                if(storeDomain){
                    domain = storeDomain;
                    console.log("load google translate domain from local storage:" + domain);
                }
                function getUrl(domain){
                    if(domain == "/")
                        return "/static/js/google_translate/element.js?cb=googleTranslateElementInit";
                    else
                        return "https://" + domain + "/translate_a/element.js?cb=googleTranslateElementInit";
                }
                var url = getUrl(domain);
                console.log("google translate domain:" + domain + ", url: " + url);
                function googleTranslateElementInit() {
                    new google.translate.TranslateElement({pageLanguage: "auto", layout: google.translate.TranslateElement.InlineLayout.SIMPLE}, 'google_translate_element');
                }
                function loadJS( url, callback ){
                    var script = document.createElement('script');
                    fn = callback || function(){ };
                    script.type = 'text/javascript';
                    if(script.readyState){
                        script.onreadystatechange = function(){
                            if( script.readyState == 'loaded' || script.readyState == 'complete' ){
                                script.onreadystatechange = null;
                                fn();
                            }
                        };
                    }else{
                        script.onload = function(){
                            fn();
                        };
                    }
                    script.src = url;
                    document.getElementsByTagName('head')[0].appendChild(script);
                }
                function removeHint(){
                    var hint = document.getElementById("loadingTranslate");
                    if(hint){
                        hint.remove();
                    }
                }
                var btn = document.getElementById("google_translate_element");
                btn.onclick = function(){
                    if(transLoaded) return;
                    if(loading){
                        var flag = confirm("loading from " + domain + ", please wait, or change domain?");
                        if(flag){
                            newDomain = prompt("domain, default: " + domainDefault + ", now: " + domain);
                            if(newDomain){
                                domain = newDomain;
                                console.log(domain);
                                url = getUrl(domain);
                                loadJS(url, function(){
                                    localStorage.setItem("googleTransDomain", domain);
                                    removeHint()
                                    transLoaded = true;
                                });
                            }
                        }
                        return;
                    }
                    btn.innerHTML = '<span id="loadingTranslate"><img class="icon" src="/note/static/image/google_translate/translate.svg"/>Loading ...</span>';
                    loading = true;
                    loadJS(url, function(){
                        localStorage.setItem("googleTransDomain", domain);
                        removeHint()
                        transLoaded = true;
                    });
                }
                </script>
            
    
        <script src="/note/static/js/theme_default/tocbot.min.js"></script>
    
        <script src="/note/static/js/theme_default/main.js"></script>
    
        <script src="/note/static/js/theme_default/viewer.min.js"></script>
    
        <script src="/note/static/css/theme_default/prism.min.js"></script>
    
        <script src="/note/static/js/search/search_main.js"></script>
    
        <script src="/note/static/js/plugin_blog/main.js"></script>
    
        <link rel="stylesheet" href="/note/static/js/add_hint/style.css" type="text/css"/>
    
        <script src="/note/static/js/add_hint/main.js"></script>
    
        <script src="/note/static/js/gitalk/gitalk.min.js"></script>
    
        <script src="/note/static/js/gitalk/main.js"></script>
    
        <script src="/note/static/js/custom.js"></script>
    
</body>

</html>