<!DOCTYPE html>

<html lang="zh-CN"  class="">


<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="keywords" content="">
    
    
    <meta name="description" content="">
    
    <meta name="generator" content="teedoc">
    <meta name="theme" content="teedoc-plugin-theme-default">
    
        
        <meta name="markdown-generator" content="teedoc-plugin-markdown-parser">
        
        <script>
MathJax = {"loader": {"load": ["output/svg"]}, "tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]]}, "svg": {"fontCache": "global"}};
</script>
        
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        
        <meta name="html-generator" content="teedoc-plugin-jupyter-notebook-parser">
        
        <script src="/note/static/js/theme_default/pre_main.js"></script>
        
        <link rel="stylesheet" href="/note/static/css/theme_default/prism.min.css" type="text/css"/>
        
        <link rel="stylesheet" href="/note/static/css/theme_default/viewer.min.css" type="text/css"/>
        
        <link rel="stylesheet" href="/note/static/css/theme_default/dark.css" type="text/css"/>
        
        <link rel="stylesheet" href="/note/static/css/theme_default/light.css" type="text/css"/>
        
        <script src="/note/static/js/theme_default/jquery.min.js"></script>
        
        <script src="/note/static/js/theme_default/split.js"></script>
        
        <link rel="stylesheet" href="/note/static/css/search/style.css" type="text/css"/>
        
        <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4d52982572d5512e9762879ebf063c86";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
        
        <meta name="blog-generator" content="teedoc-plugin-blog">
        
        <link rel="stylesheet" href="/note/static/css/gitalk/gitalk.css" type="text/css"/>
        
        <link rel="stylesheet" href="/note/static/css/gitalk/custom_gitalk.css" type="text/css"/>
        
        <link rel="stylesheet" href="/note/static/css/custom.css" type="text/css"/>
        
    
    
    <title>字符设备 - XvSenfeng's Note</title>
    
    <script type="text/javascript">js_vars = {"teedoc-plugin-ad-hint": {"type": "hint", "label": "☆", "content": "这是一个支持国际化的消息示例</br>喜欢项目请<a target=\"_blank\" href=\"https://github.com/teedoc/teedoc\">点下 ☆ star </a>哦~🦀🦀", "show_times": 2, "show_after_s": 432000, "date": "2021-11-16 14:40", "color": "#a0421d", "link_color": "#e53935", "link_bg_color": "#e6ae5c", "bg_color": "#ffcf89", "color_hover": "white", "bg_color_hover": "#f57c00", "close_color": "#eab971"}}</script>
    <script type="text/javascript">metadata = {"tags": [], "date": null, "update": [], "ts": 0, "author": "", "brief": "", "cover": ""}</script>
</head>


<body class="type_doc">
    
    <div id="navbar">
        <div id="navbar_menu">
            <a class="site_title" href="/note/">
                
                    <img class="site_logo" src="/note/static/image/logo.png" alt="XvSenfeng logo">
                
                
                    <h2>XvSenfeng</h2>
                
        </a>
            <a id="navbar_menu_btn"></a>
        </div>
        <div id="navbar_items">
            <div>
                <ul id="nav_left">
<li class=""><a  href="/note/blog/">博客</a></li>
<li class="active"><a  href="/note/Linux/">Linux</a></li>
<li class=""><a  href="/note/代码分析/">代码分析</a></li>
<li class=""><a  href="/note/使用软件/">使用软件</a></li>
<li class=""><a  href="/note/嵌入式/">嵌入式</a></li>
<li class=""><a  href="/note/手机安卓/">手机安卓</a></li>
<li class=""><a  href="/note/机器学习/">机器学习</a></li>
<li class=""><a  href="/note/编程基础/">编程基础</a></li>
<li class=""><a  href="/note/网络/">网络</a></li>
</ul>

            </div>
            <div>
                <ul id="nav_right">
<li class=""><a target="_blank" href="https://github.com/XuSenfeng/note/">github</a></li>
</ul>

                <ul class="nav_plugins"><li><a id="google_translate_element"><img class="icon" src="/note/static/image/google_translate/translate.svg"/>Translate</a></li></ul><ul class="nav_plugins"><li><a id="themes" class="light"></a></li></ul><ul class="nav_plugins"><li><a id="search"><span class="icon"></span><span class="placeholder">搜索</span>
                            <div id="search_hints">
                                <span id="search_input_hint">输入关键词，多关键词空格隔开</span>
                                <span id="search_loading_hint">正在加载，请稍候。。。</span>
                                <span id="search_download_err_hint">下载文件失败，请刷新重试或检查网络</span>
                                <span id="search_other_docs_result_hint">来自其它文档的结果</span>
                                <span id="search_curr_doc_result_hint">当前文档搜索结果</span>
                            </div></a></li></ul>
            </div>
        </div>
    </div>
    
    <div id="wrapper">
        <div id="sidebar_wrapper">
            <div id="sidebar">
                <div id="sidebar_title">
                    
                </div>
                <ul class="show">
<li class="not_active with_link"><a href="/note/Linux/index.html"><span class="label">README</span><span class=""></span></a></li>
<li class="not_active no_link"><a><span class="label">Linux命令行与shell脚本编程大全</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-1-初认识Linux_shell.html"><span class="label">2022-8-1-初认识Linux_shell</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-1-基本bashshell命令.html"><span class="label">2022-8-1-基本bashshell命令</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-1-走进shell.html"><span class="label">2022-8-1-走进shell</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-10-sed进阶.html"><span class="label">2022-8-10-sed进阶</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-11-gawk进阶.html"><span class="label">2022-8-11-gawk进阶</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-11-使用其他shell.html"><span class="label">2022-8-11-使用其他shell</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-11-实例.html"><span class="label">2022-8-11-实例</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-12-邮件相关.html"><span class="label">2022-8-12-邮件相关</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-2-更多命令.html"><span class="label">2022-8-2-更多命令</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-2-理解shell.html"><span class="label">2022-8-2-理解shell</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-3-使用Linux环境变量.html"><span class="label">2022-8-3-使用Linux环境变量</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-3-理解Linux的文件权限.html"><span class="label">2022-8-3-理解Linux的文件权限</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-4-安装软件程序.html"><span class="label">2022-8-4-安装软件程序</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-4-管理文件系统.html"><span class="label">2022-8-4-管理文件系统</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-5-使用编辑器.html"><span class="label">2022-8-5-使用编辑器</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-5-构建基本脚本.html"><span class="label">2022-8-5-构建基本脚本</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-6-使用结构初始化.html"><span class="label">2022-8-6-使用结构初始化</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-6-处理用户输入.html"><span class="label">2022-8-6-处理用户输入</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-6-更多结构化命令.html"><span class="label">2022-8-6-更多结构化命令</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-7-呈现数据.html"><span class="label">2022-8-7-呈现数据</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-7-控制脚本.html"><span class="label">2022-8-7-控制脚本</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-8-创建函数.html"><span class="label">2022-8-8-创建函数</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-9-图形化桌面环境中的脚本编程.html"><span class="label">2022-8-9-图形化桌面环境中的脚本编程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-9-正则表达式.html"><span class="label">2022-8-9-正则表达式</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-9-认识sed和gawk.html"><span class="label">2022-8-9-认识sed和gawk</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">Linux就该这么学</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/Linux就该这么学/2022-8-23-.html"><span class="label">2022-8-23-</span><span class=""></span></a></li>
<li class="not_active no_link"><a><span class="label">鸟哥的linux私房菜</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/Linux就该这么学/鸟哥的linux私房菜/2022-9-10-计算机概论.html"><span class="label">2022-9-10-计算机概论</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux就该这么学/鸟哥的linux私房菜/2022-9-20-主机规划与磁盘分区.html"><span class="label">2022-9-20-主机规划与磁盘分区</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux就该这么学/鸟哥的linux私房菜/2022-9-20-安装CentOS.html"><span class="label">2022-9-20-安装CentOS</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux就该这么学/鸟哥的linux私房菜/2022-9-20-首次登录.html"><span class="label">2022-9-20-首次登录</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux就该这么学/鸟哥的linux私房菜/2022-9-25-文件权限以及目录.html"><span class="label">2022-9-25-文件权限以及目录</span><span class=""></span></a></li>
</ul>
</li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">Linux源码趣读</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/Linux源码趣读/2024-1-26-01最开始的代码.html"><span class="label">2024-1-26-01最开始的代码</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">Linux系统编程</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/Linux系统编程/2024-2-14-01文件IO.html"><span class="label">2024-2-14-01文件IO</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux系统编程/2024-3-19-02文件系统.html"><span class="label">2024-3-19-02文件系统</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux系统编程/2024-3-21-03程序和进程.html"><span class="label">2024-3-21-03程序和进程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux系统编程/2024-3-23-04进程间通信.html"><span class="label">2024-3-23-04进程间通信</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux系统编程/2024-3-25-05信号.html"><span class="label">2024-3-25-05信号</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux系统编程/2024-3-28-06守护进程、线程.html"><span class="label">2024-3-28-06守护进程、线程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux系统编程/2024-3-31-07线程同步.html"><span class="label">2024-3-31-07线程同步</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">Linux网络编程</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-10-04线程池.html"><span class="label">2024-4-10-04线程池</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-13-05本地套接字.html"><span class="label">2024-4-13-05本地套接字</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-14-06libevent库.html"><span class="label">2024-4-14-06libevent库</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-16-07简单的Web服务器.html"><span class="label">2024-4-16-07简单的Web服务器</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-16-08html入门.html"><span class="label">2024-4-16-08html入门</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-17-09CSS.html"><span class="label">2024-4-17-09CSS</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-17-09HTTP协议.html"><span class="label">2024-4-17-09HTTP协议</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-2-01网络基础.html"><span class="label">2024-4-2-01网络基础</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-20-10telnet调试.html"><span class="label">2024-4-20-10telnet调试</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-20-11服务器.html"><span class="label">2024-4-20-11服务器</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-3-02Socket编程.html"><span class="label">2024-4-3-02Socket编程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-6-03高并发服务器.html"><span class="label">2024-4-6-03高并发服务器</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">原子Linux</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-10-Linux常用命令.html"><span class="label">2022-8-10-Linux常用命令</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-11-压缩解压缩.html"><span class="label">2022-8-11-压缩解压缩</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-11-文件系统结构.html"><span class="label">2022-8-11-文件系统结构</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-11-磁盘管理.html"><span class="label">2022-8-11-磁盘管理</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-12-LinuxC.html"><span class="label">2022-8-12-LinuxC</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-12-Makefile书.html"><span class="label">2022-8-12-Makefile书</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-12-make和Makefile.html"><span class="label">2022-8-12-make和Makefile</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-12-开发环境搭建.html"><span class="label">2022-8-12-开发环境搭建</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-12-用户和用户组.html"><span class="label">2022-8-12-用户和用户组</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-12-链接文件.html"><span class="label">2022-8-12-链接文件</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-13-IMX启动方式.html"><span class="label">2022-8-13-IMX启动方式</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-13-vscode.html"><span class="label">2022-8-13-vscode</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-13-开发板简介.html"><span class="label">2022-8-13-开发板简介</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-13-汇编LED驱动.html"><span class="label">2022-8-13-汇编LED驱动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-14-C语言点灯.html"><span class="label">2022-8-14-C语言点灯</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-14-按键检测.html"><span class="label">2022-8-14-按键检测</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-14-模仿stm32编程.html"><span class="label">2022-8-14-模仿stm32编程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-15-中断.html"><span class="label">2022-8-15-中断</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-15-主频时钟配置.html"><span class="label">2022-8-15-主频时钟配置</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-16-EPIT定时器.html"><span class="label">2022-8-16-EPIT定时器</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-16-GPT时钟.html"><span class="label">2022-8-16-GPT时钟</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-17-DDR3.html"><span class="label">2022-8-17-DDR3</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-17-RGBLED.html"><span class="label">2022-8-17-RGBLED</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-17-串口.html"><span class="label">2022-8-17-串口</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-18-I2C.html"><span class="label">2022-8-18-I2C</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-18-RTC.html"><span class="label">2022-8-18-RTC</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-19-PWM.html"><span class="label">2022-8-19-PWM</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-19-SPI.html"><span class="label">2022-8-19-SPI</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-19-多点电容触摸屏.html"><span class="label">2022-8-19-多点电容触摸屏</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-20-uBoot.html"><span class="label">2022-8-20-uBoot</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-20-系统烧写.html"><span class="label">2022-8-20-系统烧写</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-22-源码目录分析.html"><span class="label">2022-8-22-源码目录分析</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-22-顶层Makefile.html"><span class="label">2022-8-22-顶层Makefile</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-23-Linux内核.html"><span class="label">2022-8-23-Linux内核</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-23-uboot图形化配置界面.html"><span class="label">2022-8-23-uboot图形化配置界面</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-23-启动流程.html"><span class="label">2022-8-23-启动流程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-23-移植.html"><span class="label">2022-8-23-移植</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-24-驱动开发.html"><span class="label">2022-8-24-驱动开发</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-26-linux点灯.html"><span class="label">2022-8-26-linux点灯</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-27-设备树.html"><span class="label">2022-8-27-设备树</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-28-led设备树.html"><span class="label">2022-8-28-led设备树</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-29-Linux的并发与竞争.html"><span class="label">2022-8-29-Linux的并发与竞争</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-29-pinclt和gpio.html"><span class="label">2022-8-29-pinclt和gpio</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-30-Linux中断.html"><span class="label">2022-8-30-Linux中断</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-30-Linux内核定时器.html"><span class="label">2022-8-30-Linux内核定时器</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-31-异步通知.html"><span class="label">2022-8-31-异步通知</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-31-阻塞非阻塞.html"><span class="label">2022-8-31-阻塞非阻塞</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-1-platform设备驱动.html"><span class="label">2022-9-1-platform设备驱动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-10-WIFI.html"><span class="label">2022-9-10-WIFI</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-10-网络驱动.html"><span class="label">2022-9-10-网络驱动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-11-4G.html"><span class="label">2022-9-11-4G</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-11-IIO.html"><span class="label">2022-9-11-IIO</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-11-PWM.html"><span class="label">2022-9-11-PWM</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-11-RGBtoHDMI.html"><span class="label">2022-9-11-RGBtoHDMI</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-11-Regmap.html"><span class="label">2022-9-11-Regmap</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-2-INPUT子系统.html"><span class="label">2022-9-2-INPUT子系统</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-2-LCD屏幕.html"><span class="label">2022-9-2-LCD屏幕</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-2-Linux自带的led.html"><span class="label">2022-9-2-Linux自带的led</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-2-MISC.html"><span class="label">2022-9-2-MISC</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-3-I2C.html"><span class="label">2022-9-3-I2C</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-3-RTC.html"><span class="label">2022-9-3-RTC</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-3-SPI.html"><span class="label">2022-9-3-SPI</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-4-串口.html"><span class="label">2022-9-4-串口</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-5-触摸屏.html"><span class="label">2022-9-5-触摸屏</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-5-音频驱动.html"><span class="label">2022-9-5-音频驱动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-6-CAN协议.html"><span class="label">2022-9-6-CAN协议</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-7-USB.html"><span class="label">2022-9-7-USB</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-7-块设备驱动.html"><span class="label">2022-9-7-块设备驱动</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">操作系统原理</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-17-1操作系统.html"><span class="label">2023-6-17-1操作系统</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-17-2操作系统目标和作用.html"><span class="label">2023-6-17-2操作系统目标和作用</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-17-3操作系统特征.html"><span class="label">2023-6-17-3操作系统特征</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-17-4操作系统的发展.html"><span class="label">2023-6-17-4操作系统的发展</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-17-5运行机制.html"><span class="label">2023-6-17-5运行机制</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-18-6中断异常.html"><span class="label">2023-6-18-6中断异常</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-18-7系统调用.html"><span class="label">2023-6-18-7系统调用</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-19-8体系结构.html"><span class="label">2023-6-19-8体系结构</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-20-10虚拟机.html"><span class="label">2023-6-20-10虚拟机</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-20-11进程.html"><span class="label">2023-6-20-11进程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-20-9操作系统的引导.html"><span class="label">2023-6-20-9操作系统的引导</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-22-12线程.html"><span class="label">2023-6-22-12线程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-23-13调度.html"><span class="label">2023-6-23-13调度</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-27-14进程同步进程互斥.html"><span class="label">2023-6-27-14进程同步进程互斥</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-28-15锁.html"><span class="label">2023-6-28-15锁</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-28-16信号量机制.html"><span class="label">2023-6-28-16信号量机制</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">服务器</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/服务器/2023-6-12-代理.html"><span class="label">2023-6-12-代理</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/服务器/2023-6-12-新服务器搭建.html"><span class="label">2023-6-12-新服务器搭建</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">李述铜手写操作系统</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2023-10-26-05中断和异常处理.html"><span class="label">2023-10-26-05中断和异常处理</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2023-11-10-06日志与printf输出.html"><span class="label">2023-11-10-06日志与printf输出</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2023-9-23-03引导程序接管控制权.html"><span class="label">2023-9-23-03引导程序接管控制权</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2023-9-28-04加载器loader的实现.html"><span class="label">2023-9-28-04加载器loader的实现</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2023-9-6-01补充知识2.html"><span class="label">2023-9-6-01补充知识2</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2023-9-6-0补充知识.html"><span class="label">2023-9-6-0补充知识</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2023-9-6-1操作系统准备.html"><span class="label">2023-9-6-1操作系统准备</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2023-9-7-2x86保护模式下的编程.html"><span class="label">2023-9-7-2x86保护模式下的编程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-2-17-07进程切换.html"><span class="label">2024-2-17-07进程切换</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-2-17-08链表.html"><span class="label">2024-2-17-08链表</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-2-17添加任务管理器.html"><span class="label">2024-2-17添加任务管理器</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-2-18-内存管理.html"><span class="label">2024-2-18-内存管理</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-2-24-系统调用.html"><span class="label">2024-2-24-系统调用</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-2-26-移植Newlib库.html"><span class="label">2024-2-26-移植Newlib库</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-2-27-屏幕显示信息.html"><span class="label">2024-2-27-屏幕显示信息</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-2-29-键盘初始化.html"><span class="label">2024-2-29-键盘初始化</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-3-1-设备管理.html"><span class="label">2024-3-1-设备管理</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-3-3-Shell.html"><span class="label">2024-3-3-Shell</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-3-4-文件系统.html"><span class="label">2024-3-4-文件系统</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-3-5-磁盘.html"><span class="label">2024-3-5-磁盘</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-3-7-Fat16.html"><span class="label">2024-3-7-Fat16</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">树莓派</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/树莓派/2024-2-1-01开始使用.html"><span class="label">2024-2-1-01开始使用</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/树莓派/2024-2-1-02-使用命令了解树莓派.html"><span class="label">2024-2-1-02-使用命令了解树莓派</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/树莓派/2024-2-1-03-安装mysql.html"><span class="label">2024-2-1-03-安装mysql</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/树莓派/2024-2-3-04网络连接.html"><span class="label">2024-2-3-04网络连接</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/树莓派/2024-2-8-时钟设置.html"><span class="label">2024-2-8-时钟设置</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">泰山派</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-12-20-05-lvgl程序.html"><span class="label">2025-12-20-05-lvgl程序</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-12-24-06-二维码识别.html"><span class="label">2025-12-24-06-二维码识别</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-12-24-07-yolo部署.html"><span class="label">2025-12-24-07-yolo部署</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-12-25-08-OpenCV.html"><span class="label">2025-12-25-08-OpenCV</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-12-26-09-拍照.html"><span class="label">2025-12-26-09-拍照</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-12-26-10-Qt.html"><span class="label">2025-12-26-10-Qt</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-5-11-01环境搭建.html"><span class="label">2025-5-11-01环境搭建</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-5-11-02设备树.html"><span class="label">2025-5-11-02设备树</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-5-14-03屏幕驱动.html"><span class="label">2025-5-14-03屏幕驱动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-5-17-04触摸驱动.html"><span class="label">2025-5-17-04触摸驱动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2026-1-27-ROS.html"><span class="label">2026-1-27-ROS</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2026-1-30-Ubuntu22.html"><span class="label">2026-1-30-Ubuntu22</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">瑞芯微Linux</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/瑞芯微Linux/2025-12-10-Cpp提供C接口.html"><span class="label">2025-12-10-Cpp提供C接口</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/瑞芯微Linux/2025-12-5-01-EchoAI编译代码.html"><span class="label">2025-12-5-01-EchoAI编译代码</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/瑞芯微Linux/2025-12-5-02-EchoAI代码.html"><span class="label">2025-12-5-02-EchoAI代码</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/瑞芯微Linux/2025-12-7-03-添加板子.html"><span class="label">2025-12-7-03-添加板子</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/瑞芯微Linux/2025-12-8-04-内核.html"><span class="label">2025-12-8-04-内核</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/瑞芯微Linux/2025-12-9-05-模型.html"><span class="label">2025-12-9-05-模型</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/瑞芯微Linux/配置网络.html"><span class="label">配置网络</span><span class=""></span></a></li>
</ul>
</li>
<li class="active_parent no_link"><a><span class="label">野火Linux</span><span class="sub_indicator"></span></a><ul class="show">
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-11-55-buildroot.html"><span class="label">2025-10-11-55-buildroot</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-11-56-裸机汇编开发.html"><span class="label">2025-10-11-56-裸机汇编开发</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-12-57-Uboot编译脚本.html"><span class="label">2025-10-12-57-Uboot编译脚本</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-2-47-镜像构建.html"><span class="label">2025-10-2-47-镜像构建</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-2-48-systemd.html"><span class="label">2025-10-2-48-systemd</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-2-49-deb包.html"><span class="label">2025-10-2-49-deb包</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-2-50-修改img文件.html"><span class="label">2025-10-2-50-修改img文件</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-2-51-备份量产.html"><span class="label">2025-10-2-51-备份量产</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-2-52-Uboot启动.html"><span class="label">2025-10-2-52-Uboot启动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-28-58-Uboot移植.html"><span class="label">2025-10-28-58-Uboot移植</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-30-59-Uboot图形配置界面语法.html"><span class="label">2025-10-30-59-Uboot图形配置界面语法</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-30-60-Linux编译脚本.html"><span class="label">2025-10-30-60-Linux编译脚本</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-31-61-Linux启动流程.html"><span class="label">2025-10-31-61-Linux启动流程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-9-53-Uboot启动(二).html"><span class="label">2025-10-9-53-Uboot启动(二)</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-9-54-Uboot启动(三).html"><span class="label">2025-10-9-54-Uboot启动(三)</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-1-62-linux移植.html"><span class="label">2025-11-1-62-linux移植</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-1-63-Busybox.html"><span class="label">2025-11-1-63-Busybox</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-10-65-定时器.html"><span class="label">2025-11-10-65-定时器</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-12-66-信号.html"><span class="label">2025-11-12-66-信号</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-14-67-MISC设备.html"><span class="label">2025-11-14-67-MISC设备</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-15-68-RTC.html"><span class="label">2025-11-15-68-RTC</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-16-69-串口.html"><span class="label">2025-11-16-69-串口</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-18-70-中断线程化.html"><span class="label">2025-11-18-70-中断线程化</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-18-71-音频.html"><span class="label">2025-11-18-71-音频</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-19-72-CAN.html"><span class="label">2025-11-19-72-CAN</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-19-73-USB.html"><span class="label">2025-11-19-73-USB</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-2-64-mfgtool.html"><span class="label">2025-11-2-64-mfgtool</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-20-74-块设备.html"><span class="label">2025-11-20-74-块设备</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-21-75-网络设备.html"><span class="label">2025-11-21-75-网络设备</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-22-76-Wifi.html"><span class="label">2025-11-22-76-Wifi</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-22-77-PWM.html"><span class="label">2025-11-22-77-PWM</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-22-78-Regmap通用寄存器.html"><span class="label">2025-11-22-78-Regmap通用寄存器</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-22-79-IIO驱动框架.html"><span class="label">2025-11-22-79-IIO驱动框架</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-25-80-ADC驱动.html"><span class="label">2025-11-25-80-ADC驱动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-12-6-81-音频驱动.html"><span class="label">2025-12-6-81-音频驱动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-12-8-82-DRM显示设备.html"><span class="label">2025-12-8-82-DRM显示设备</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-6-11-01-入门.html"><span class="label">2025-6-11-01-入门</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-6-22-02-开发板下载启动.html"><span class="label">2025-6-22-02-开发板下载启动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-12-04-镜像文件.html"><span class="label">2025-7-12-04-镜像文件</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-13-06-GPIO.html"><span class="label">2025-7-13-06-GPIO</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-13-07-中断.html"><span class="label">2025-7-13-07-中断</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-14-05-ARMv7汇编.html"><span class="label">2025-7-14-05-ARMv7汇编</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-14-08-时钟控制模块.html"><span class="label">2025-7-14-08-时钟控制模块</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-14-09-串口.html"><span class="label">2025-7-14-09-串口</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-15-10-内核模块.html"><span class="label">2025-7-15-10-内核模块</span><span class=""></span></a></li>
<li class="active with_link"><a href="/note/Linux/野火Linux/2025-7-15-11-字符设备.html"><span class="label">2025-7-15-11-字符设备</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-15-12-驱动设备模型.html"><span class="label">2025-7-15-12-驱动设备模型</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-19-13-Kset.html"><span class="label">2025-7-19-13-Kset</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-19-14-uevent消息.html"><span class="label">2025-7-19-14-uevent消息</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-19-15-class设备管理.html"><span class="label">2025-7-19-15-class设备管理</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-19-16-17-总结.html"><span class="label">2025-7-19-16-17-总结</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-19-16-xbus和platform.html"><span class="label">2025-7-19-16-xbus和platform</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-2-03-控制设备.html"><span class="label">2025-7-2-03-控制设备</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-20-18-DTS设备树.html"><span class="label">2025-7-20-18-DTS设备树</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-20-19-DeviceTreeOverlay.html"><span class="label">2025-7-20-19-DeviceTreeOverlay</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-16-21-iomux节点(中).html"><span class="label">2025-9-16-21-iomux节点(中)</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-16-22-iomux节点(下).html"><span class="label">2025-9-16-22-iomux节点(下)</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-17-23-iomux节点(应用).html"><span class="label">2025-9-17-23-iomux节点(应用)</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-17-24-GPIO子系统.html"><span class="label">2025-9-17-24-GPIO子系统</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-17-25-并发硬件同步原语.html"><span class="label">2025-9-17-25-并发硬件同步原语</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-18-26-IIC驱动框架.html"><span class="label">2025-9-18-26-IIC驱动框架</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-20-27-IIC驱动框架使用.html"><span class="label">2025-9-20-27-IIC驱动框架使用</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-25-28-阻塞和非阻塞IO.html"><span class="label">2025-9-25-28-阻塞和非阻塞IO</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-25-29-POLL机制.html"><span class="label">2025-9-25-29-POLL机制</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-25-30-Completion.html"><span class="label">2025-9-25-30-Completion</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-25-31-kthread_worker.html"><span class="label">2025-9-25-31-kthread_worker</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-26-32-SPI.html"><span class="label">2025-9-26-32-SPI</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-26-33-SPI使用.html"><span class="label">2025-9-26-33-SPI使用</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-27-34-中断.html"><span class="label">2025-9-27-34-中断</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-27-35-软中断和tasklet.html"><span class="label">2025-9-27-35-软中断和tasklet</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-27-36-工作队列.html"><span class="label">2025-9-27-36-工作队列</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-27-37-Input子系统.html"><span class="label">2025-9-27-37-Input子系统</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-28-38-电容触摸屏.html"><span class="label">2025-9-28-38-电容触摸屏</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-28-39-PWM.html"><span class="label">2025-9-28-39-PWM</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-28-40-LCD-FB设备.html"><span class="label">2025-9-28-40-LCD-FB设备</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-29-41-Linux系统构成.html"><span class="label">2025-9-29-41-Linux系统构成</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-29-42-Uboot基础使用.html"><span class="label">2025-9-29-42-Uboot基础使用</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-29-43-Linux.html"><span class="label">2025-9-29-43-Linux</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-29-44-添加驱动(设备树).html"><span class="label">2025-9-29-44-添加驱动(设备树)</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-30-45-图标.html"><span class="label">2025-9-30-45-图标</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-30-46-根文件系统.html"><span class="label">2025-9-30-46-根文件系统</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-4-20-iomux节点(上).html"><span class="label">2025-9-4-20-iomux节点(上)</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/Untitled.html"><span class="label">Untitled</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">问题处理</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/问题处理/2022-11-20-Linux图形界面.html"><span class="label">2022-11-20-Linux图形界面</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2022-8-24-tftp下载.html"><span class="label">2022-8-24-tftp下载</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2022-8-26-uboot设置.html"><span class="label">2022-8-26-uboot设置</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2022-8-27-根文件系统被删除.html"><span class="label">2022-8-27-根文件系统被删除</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2022-8-5-没有release文件.html"><span class="label">2022-8-5-没有release文件</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2022-9-7-备份根文件.html"><span class="label">2022-9-7-备份根文件</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2022-9-9-ubuntu移植问题处理.html"><span class="label">2022-9-9-ubuntu移植问题处理</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2023-11-11-树莓派.html"><span class="label">2023-11-11-树莓派</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2023-6-14-打不开gpedit-msc.html"><span class="label">2023-6-14-打不开gpedit-msc</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2023-6-28-vscode配置.html"><span class="label">2023-6-28-vscode配置</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2023-8-27-开发板网络设置.html"><span class="label">2023-8-27-开发板网络设置</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">韦东山Linux</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/韦东山Linux/2025-3-4-基础.html"><span class="label">2025-3-4-基础</span><span class=""></span></a></li>
</ul>
</li>
</ul>

            </div>
        </div>
        <div id="article">
            <div id="menu_wrapper">
                <div id="menu">
                </div>
            </div>
            <div id="content_wrapper">
                <div id="content_body">
                    <div id="article_head">
                        <div id="article_title">
                            
                            <h1>字符设备</h1>
                            
                        </div>
                        <div id="article_tags">
                            <ul>
                            
                            </ul>
                        </div>
                        <div id="article_info">
                        <div id="article_info_left">
                            <span class="article_author">
                                
                            </span>
                            
                                <span class="article_date" title="最后修改日期： 2025-12-14">
                                    2025-12-14
                                </span>
                            
                        </div>
                        <div id="article_info_right">
                            
                            <div id="source_link">
                                <a href="https://github.com/XuSenfeng/note/tree/master/doc/Linux/野火Linux/2025-7-15-11-字符设备.md" target="_blank">
                                    编辑本页
                                </a>
                            </div>
                            
                        </div>
                        </div>
                    </div>
                    <div id="article_tools">
                        <span></span>
                        <span id="toc_btn"></span>
                    </div>
                    <div id="update_history">
                        
                    </div>
                    <div id="article_content">
                        
                            <p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509012204612.png" alt="image-20250901220422532" /></p>
<h2 id="%3Cstrong%3E%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E6%B3%A8%E5%86%8C%E6%B5%81%E7%A8%8B%3C/strong%3E"><strong>字符设备注册流程</strong></h2>
<ul>
<li><strong>步骤 1</strong>：<br />
  调用 <code>__register_chrdev_region()</code> → 创建/更新 <code>char_device_struct</code>，添加到 <code>chrdevs[]</code> 哈希表。</li>
<li><strong>步骤 2</strong>：<br />
  调用 <code>cdev_add()</code> → 最终触发 <code>kobj_map(cdev_map, ...)</code>：<ul>
<li>向全局 <code>kobj_map</code> 实例 <strong><code>cdev_map</code></strong>（专用于字符设备）插入一个 <code>probe</code>。</li>
<li><code>probe-&gt;data</code> 指向字符设备的 <code>struct cdev</code>。</li>
<li><code>probe-&gt;get</code> 设置为默认回调 <code>exact_match()</code>（通过设备号查找 <code>cdev</code>）。</li>
</ul>
</li>
</ul>
<blockquote>
<p>实际使用的时候有两个框架</p>
<ol>
<li>使用<code>register_chrdev</code>一个函数实现注册以及设备号的分配, 使用结束以后<code>unregister_chrdev</code>释放</li>
</ol>

<pre class="language-c"><code class="language-c">stic inline int register_chrdev(unsigned int major, const char *name, const struct file_operations *fops) 
static inline void unregister_chrdev(unsigned int major, const char *name) 
</code></pre>
<ol start="2">
<li>分配设备号以及字符设备的注册是分开的</li>
</ol>
<p><code>int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *nam e)</code>: 向Linux内核申请, 一般是动态的申请, 可以使用<code>MKDEV</code>合成完整设备号</p>
<p><code>int register_chrdev_region(dev_t from, unsigned count, const char *name)</code>动态获取一下</p>
<p>使用结束以后释放<code>void unregister_chrdev_region(dev_t from, unsigned count)</code></p>
<p>设备号和字符设备是分开的</p>
<p>使用<code>void cdev_init(struct cdev *cdev, const struct file_operations *fops)</code>初始化, 初始化以后<code>int cdev_add(struct cdev *p, dev_t dev, unsigned count)</code>添加, 释放的时候<code>void cdev_del(struct cdev *p)</code></p>
</blockquote>
<h2 id="%3Cstrong%3E%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E6%89%93%E5%BC%80%E6%B5%81%E7%A8%8B%3C/strong%3E"><strong>字符设备打开流程</strong></h2>
<ul>
<li><strong>步骤 1</strong>：<br />
  用户调用 <code>open(&quot;/dev/char_dev&quot;)</code> → VFS 通过设备号查找操作函数集。</li>
<li><strong>步骤 2</strong>：<br />
  调用 <code>kobj_lookup(cdev_map, dev_t, &amp;idx)</code>：<ul>
<li>在 <code>cdev_map</code> 的哈希表中搜索匹配的 <code>probe</code>。</li>
<li>执行 <code>probe-&gt;get()</code> 回调 → 返回 <code>cdev-&gt;kobj</code>。</li>
</ul>
</li>
<li><strong>步骤 3</strong>：<br />
  通过 <code>container_of</code> 从 <code>kobject</code> 获取 <code>struct cdev</code> → 访问其 <code>file_operations</code>。</li>
</ul>
<blockquote>
<ul>
<li><strong><code>char_device_struct</code> 为静态管理</strong>：<br />
  记录设备号分配情况（防止冲突），维护 <code>major/minor</code> 到 <code>cdev</code> 的基本映射。</li>
<li><strong><code>kobj_map</code> 为动态映射</strong>：<br />
  提供高效的设备号（<code>dev_t</code>）到内核对象（<code>kobject</code>）的运行时查找，实际用于设备操作。</li>
</ul>
</blockquote>
<h3 id="%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E6%8A%BD%E8%B1%A1%E6%88%90%E6%96%87%E4%BB%B6">字符设备抽象成文件</h3>
<p>openalloc_chrdev_region()函数,在文件系统中找到指定文件的操作接口，绑定到进程<code>task_srtuct-&gt;files_struct-&gt;fd_array[]-&gt;file_operations</code></p>
<p>实际实现的时候需要read, write等文件操控函数的实现</p>
<h3 id="%E9%A9%B1%E5%8A%A8%E5%B1%82%E5%8E%9F%E7%90%86">驱动层原理</h3>
<p>把file_operations文件操作接口注册到内核，内核通过主次设备号来登记记录它</p>
<ul>
<li><p>构造驱动基本对象：struct cdev，里面记录具体的file_operations</p>

<pre class="language-c"><code class="language-c">cdev_init()
</code></pre>
<blockquote>
<p>实际是建立两个hash表</p>
<ul>
<li><p>chrdevs：登记设备号, 看一下是不是被使用了</p>

<pre class="language-none"><code class="language-none">__register_chrdev_region()
</code></pre>
<blockquote>
<ul>
<li><strong>注册函数</strong>：<code>__register_chrdev_region()</code><ul>
<li>申请主设备号（如 255）</li>
<li>指定次设备号范围（如 0~255）</li>
<li>冲突检测：防止重复注册相同设备号</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>cdev_map-&gt;probe：保存驱动基本对象<code>struct cdev</code></p>

<pre class="language-none"><code class="language-none">cdev_add()
</code></pre>
<blockquote>
<p><strong>注册流程</strong>：</p>
<ol>
<li><p><strong>初始化</strong>：<code>cdev_init(&amp;my_cdev, &amp;my_fops);</code></p>
<ul>
<li>绑定 <code>file_operations</code> 到 <code>cdev</code></li>
</ul>
</li>
<li><p><strong>添加到系统</strong>：<code>cdev_add(&amp;my_cdev, dev, count);</code></p>
<ul>
<li><code>dev</code>：起始设备号（主+次）</li>
<li><code>count</code>：连续设备数量</li>
</ul>
</li>
<li><p><strong>存入 cdev_map</strong>：</p>

<pre class="language-c"><code class="language-c">struct kobj_map *cdev_map; // 全局映射表
kobj_map(cdev_map, dev, count, NULL, exact_match, exact_lock, my_cdev);
</code></pre>
<ul>
<li>生成 <code>dev_t → cdev</code> 的映射关系</li>
</ul>
</li>
</ol>
</blockquote>
</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%B1%82%E5%8E%9F%E7%90%86">文件系统层原理</h3>
<p>mknod指令+主从设备号, 生成一个实际用于读写控制的文件</p>
<ul>
<li><p>构建一个新的设备文件</p>
</li>
<li><p>通过主次设备号在cdev_map中找到cdev-&gt;file_operations</p>
</li>
<li><p>把cdev-&gt;file_operations绑定到新的设备文件中</p>
</li>
</ul>
<p>到这里，应用程序就可以使用open()、write()、read()等函数来控制设备文件了</p>
<h2 id="%E8%AE%BE%E5%A4%87%E5%8F%B7%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E5%93%88%E5%B8%8C%E8%A1%A8">设备号的组成与哈希表</h2>
<h4 id="%E8%AE%BE%E5%A4%87%E5%8F%B7">设备号</h4>
<p>记录在文件<code>ebf-buster-linux/include/linux/kdev_t.h</code></p>

<pre class="language-c"><code class="language-c">#define MINORBITS	20
#define MINORMASK	((1U &lt;&lt; MINORBITS) - 1)

#define MAJOR(dev)	((unsigned int) ((dev) &gt;&gt; MINORBITS))
#define MINOR(dev)	((unsigned int) ((dev) &amp; MINORMASK))
#define MKDEV(ma,mi)	(((ma) &lt;&lt; MINORBITS) | (mi))

理论取值范围
主设备号：2^12=1024*4=4k
次设备号：2^20=1024*1024=1M
</code></pre>
<ul>
<li>已注册的设备号可以使用<code>cat /proc/devices</code>查看</li>
<li>内核是希望一个设备驱动(file_operation)可以独自占有一个主设备号和多个次设备号，而通常一个设备文件绑定一个主设备号和一个次设备号，所以设备驱动与设备文件是一对一或者一对多的关系。</li>
</ul>
<blockquote>
<p>通常情况下主设备号相同的话使用的file_operation是一样的</p>
</blockquote>
<h4 id="hash-table">hash table</h4>
<p>哈希表、散列表</p>
<ul>
<li><p>数组的优缺点：查找快，增删元素效率低，容量固定</p>
</li>
<li><p>链表的优缺点：查找慢，增删元素效率高，容量不限</p>
</li>
<li><p>哈希表：数组+链表</p>
<ul>
<li>以主设备号为编号，使用哈希函数<code>f(major)=major%255</code>来计算数组下标</li>
<li>主设备号冲突(如0、255)，则以次设备号为比较值来排序<strong>链表</strong>节点。</li>
</ul>
</li>
</ul>
<blockquote>
<p>使用一个数组记录链表的头结点</p>
</blockquote>
<p>哈希函数的设计目标：链表节点尽量平均分布在各个数组元素中，提高查询效率</p>
<h2 id="%E7%AE%A1%E7%90%86%E8%AE%BE%E5%A4%87%E5%8F%B7">管理设备号</h2>
<h5 id="%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">关键数据结构</h5>
<p>ebf-buster-linux/fs/char_dev.c</p>

<pre class="language-c"><code class="language-c">static struct char_device_struct {
    //指向下一个链表节点
    struct char_device_struct *next;
    //主设备号
    unsigned int major;
    //次设备号
    unsigned int baseminor;
    //次设备号的数量
    int minorct;
    //设备的名称
    char name[64];
    //内核字符对象(已废弃)
    struct cdev *cdev;      /* will die */

} *chrdevs[CHRDEV_MAJOR_HASH_SIZE]; // 一共有255个, 用于管理设备号
</code></pre>
<blockquote>
<p>一个专门用于设备号管理的结构, 记录字符设备号范围（主设备号 + 次设备号范围）与字符设备驱动程序（<code>struct cdev</code>）的映射关系。</p>
</blockquote>
<h4 id="__register_chrdev_region%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90">__register_chrdev_region函数分析</h4>
<p>ebf-buster-linux/fs/char_dev.c</p>
<p>保存新注册的设备号到chrdevs哈希表中，防止设备号冲突</p>
<p>分析结论：</p>
<ul>
<li><p>主设备号为0，动态分配设备号：</p>
<ul>
<li>优先使用：255~234</li>
</ul>
</li>
<li><p>其次使用：511~384</p>
</li>
<li><p>主设备号最大为512</p>
</li>
</ul>

<pre class="language-c"><code class="language-c">/*
 * Register a single major with a specified minor range.
 *
 * If major == 0 this functions will dynamically allocate a major and return
 * its number.
 *
 * If major &gt; 0 this function will attempt to reserve the passed range of
 * minors and will return zero on success.
 *
 * Returns a -ve errno on failure.
 */
static struct char_device_struct *
__register_chrdev_region(unsigned int major, unsigned int baseminor,
    		   int minorct, const char *name)
{
    struct char_device_struct *cd, **cp;
    int ret = 0;
    int i;
    
    cd = kzalloc(sizeof(struct char_device_struct), GFP_KERNEL);
    if (cd == NULL)
    	return ERR_PTR(-ENOMEM);
    // 获取一个互斥锁
    mutex_lock(&amp;chrdevs_lock);
    // 动态分配一个主设备号
    if (major == 0) {
    	ret = find_dynamic_major();
    	if (ret &lt; 0) {
    		pr_err(&quot;CHRDEV \&quot;%s\&quot; dynamic allocation region is full\n&quot;,
    		       name);
    		goto out;
    	}
    	major = ret;
    }
    // 判断一下是不是合法, 最多512个
    if (major &gt;= CHRDEV_MAJOR_MAX) {
    	pr_err(&quot;CHRDEV \&quot;%s\&quot; major requested (%u) is greater than the maximum (%u)\n&quot;,
    	       name, major, CHRDEV_MAJOR_MAX-1);
    	ret = -EINVAL;
    	goto out;
    }
    
    cd-&gt;major = major;
    cd-&gt;baseminor = baseminor;
    cd-&gt;minorct = minorct;
    strlcpy(cd-&gt;name, name, sizeof(cd-&gt;name));

    i = major_to_index(major);

    for (cp = &amp;chrdevs[i]; *cp; cp = &amp;(*cp)-&gt;next)
    	if ((*cp)-&gt;major &gt; major ||
    	    ((*cp)-&gt;major == major &amp;&amp;
    	     (((*cp)-&gt;baseminor &gt;= baseminor) ||
    	      ((*cp)-&gt;baseminor + (*cp)-&gt;minorct &gt; baseminor))))
    		break;

    /* Check for overlapping minor ranges.  查看一下子设备号范围是不是会冲突*/
    if (*cp &amp;&amp; (*cp)-&gt;major == major) {
    	int old_min = (*cp)-&gt;baseminor;
    	int old_max = (*cp)-&gt;baseminor + (*cp)-&gt;minorct - 1;
    	int new_min = baseminor;
    	int new_max = baseminor + minorct - 1;

    	/* New driver overlaps from the left.  */
    	if (new_max &gt;= old_min &amp;&amp; new_max &lt;= old_max) {
    		ret = -EBUSY;
    		goto out;
    	}

    	/* New driver overlaps from the right.  */
    	if (new_min &lt;= old_max &amp;&amp; new_min &gt;= old_min) {
    		ret = -EBUSY;
    		goto out;
    	}

    	if (new_min &lt; old_min &amp;&amp; new_max &gt; old_max) {
    		ret = -EBUSY;
    		goto out;
    	}

    }
    // 插入链表
    cd-&gt;next = *cp;
    *cp = cd;
    mutex_unlock(&amp;chrdevs_lock);
    return cd;
out:
    mutex_unlock(&amp;chrdevs_lock);
    kfree(cd);
    return ERR_PTR(ret);
}
</code></pre>
<p>动态获取一个空闲的数组位置</p>

<pre class="language-c"><code class="language-c">static int find_dynamic_major(void)
{
    int i;
    struct char_device_struct *cd;
    // 优先234-254
    for (i = ARRAY_SIZE(chrdevs)-1; i &gt;= CHRDEV_MAJOR_DYN_END; i--) {
        // 记录在链表的第一位
    	if (chrdevs[i] == NULL)
    		return i;
    }
    // 511 - 384的设备
    for (i = CHRDEV_MAJOR_DYN_EXT_START;
         i &gt;= CHRDEV_MAJOR_DYN_EXT_END; i--) {
        // major_to_index 哈希函数, 实际是 % 255, 遍历一下链表
    	for (cd = chrdevs[major_to_index(i)]; cd; cd = cd-&gt;next)
    		if (cd-&gt;major == i)
    			break;

    	if (cd == NULL)
    		return i;
    }

    return -EBUSY;
}
</code></pre>
<h2 id="%E4%BF%9D%E5%AD%98file_operation%E6%8E%A5%E5%8F%A3">保存file_operation接口</h2>
<h4 id="%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A2%B3%E7%90%86">关键数据结构梳理</h4>
<p><code>kobj_map</code> 是一个全局的注册表/映射表，而 <code>cdev</code> 是被注册到这个表中的项目。它们共同协作，实现了字符设备号（主设备号、次设备号）到具体字符设备驱动程序（<code>cdev</code> 结构体）的动态查找和关联。</p>
<p>kernel/ebf-buster-linux/include/linux/cdev.h</p>
<p>字符设备管理对象, 记录实际的设备的数据</p>

<pre class="language-c"><code class="language-c">struct cdev {
    //内核驱动基本对象, 继承上一级
    struct kobject kobj;
    //相关内核模块
    struct module *owner;
    //设备驱动接口, 实际调用的各种接口
    const struct file_operations *ops;
    //链表节点
    struct list_head list;
    //设备号
    dev_t dev;
    //次设备号的数量
    unsigned int count;
} __randomize_layout;
</code></pre>
<p>ebf-buster-linux/fs/char_dev.c</p>
<p>另一个哈希表probes, 用于记录file_operations这个接口</p>

<pre class="language-c"><code class="language-c">struct kobj_map {
    struct probe {
    	//指向下一个链表节点
    	struct probe *next;
    	//设备号
    	dev_t dev;
    	//次设备号的数量
    	unsigned long range;
    	struct module *owner;
    	kobj_probe_t *get;
    	int (*lock)(dev_t, void *);
    	//空指针，内核常用技巧, 一般用于记录struct cdev这个结构体
    	void *data;
    } *probes[255];
    // 互斥锁
    struct mutex *lock;
};
</code></pre>
<blockquote>
<p>是<strong>通用设备号映射框架</strong>, 管理设备号（<code>dev_t</code>）到内核对象（<code>kobject</code>）的动态映射。用于字符设备（<code>cdev_map</code>）、块设备（<code>bdev_map</code>）等。</p>
</blockquote>
<h3 id="%E6%96%B0%E7%9A%84%E6%8E%A5%E5%8F%A3">新的接口</h3>
<h4 id="cdev_init%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90">cdev_init函数分析</h4>
<p>实际相比于这个函数使用<code>register_chrdev</code>函数作为<code>cdev_init + cdev_add</code>更方便</p>
<p>ebf-buster-linux/fs/char_dev.c</p>
<p>记录一下实际的操作函数</p>

<pre class="language-c"><code class="language-c">/**
 * cdev_init() - initialize a cdev structure
 * @cdev: the structure to initialize
 * @fops: the file_operations for this device
 *
 * Initializes @cdev, remembering @fops, making it ready to add to the
 * system with cdev_add().
 */
void cdev_init(struct cdev *cdev, const struct file_operations *fops)
{
    memset(cdev, 0, sizeof *cdev);
    INIT_LIST_HEAD(&amp;cdev-&gt;list);
    kobject_init(&amp;cdev-&gt;kobj, &amp;ktype_cdev_default);
    cdev-&gt;ops = fops; // 记录一下file_operations
}
</code></pre>
<p>保存file_operation到cdev中</p>
<h4 id="cdev_add%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90">cdev_add函数分析</h4>
<p>ebf-buster-linux/fs/char_dev.c</p>
<p>根据哈希函数保存cdev到probes哈希表中，方便内核查找file_operation使用</p>

<pre class="language-c"><code class="language-c">/**
 * cdev_add() - add a char device to the system
 * @p: the cdev structure for the device
 * @dev: the first device number for which this device is responsible
 * @count: the number of consecutive minor numbers corresponding to this
 *         device
 *
 * cdev_add() adds the device represented by @p to the system, making it
 * live immediately.  A negative error code is returned on failure.
 */
int cdev_add(struct cdev *p, dev_t dev, unsigned count)
{
    int error;
    // 记录一下设备号以及设备数量
    p-&gt;dev = dev;
    p-&gt;count = count;
    // 实际的填充数据, 记录到prob里面
    error = kobj_map(cdev_map, dev, count, NULL,
    		 exact_match, exact_lock, p);
    if (error)
    	return error;

    kobject_get(p-&gt;kobj.parent);

    return 0;
}
</code></pre>

<pre class="language-c"><code class="language-c">int kobj_map(struct kobj_map *domain, dev_t dev, unsigned long range,
         struct module *module, kobj_probe_t *probe,
         int (*lock)(dev_t, void *), void *data)
{
    // 计算一下次设备号是不是溢出, 溢出的话计算一下需要几个主设备号
    unsigned n = MAJOR(dev + range - 1) - MAJOR(dev) + 1;
    unsigned index = MAJOR(dev);
    unsigned i;
    struct probe *p;
    // 计算一下主设备号的数量
    if (n &gt; 255)
    	n = 255;
    // 获取probe结构体
    p = kmalloc_array(n, sizeof(struct probe), GFP_KERNEL);
    if (p == NULL)
    	return -ENOMEM;
    // 使用probe结构体保存一下cdev的数据
    for (i = 0; i &lt; n; i++, p++) {
    	p-&gt;owner = module;
    	p-&gt;get = probe;
    	p-&gt;lock = lock;
    	p-&gt;dev = dev;
    	p-&gt;range = range;
    	p-&gt;data = data;
    }
    mutex_lock(domain-&gt;lock);
    for (i = 0, p -= n; i &lt; n; i++, p++, index++) {
    	struct probe **s = &amp;domain-&gt;probes[index % 255];
        // 按照范围的大小进行排序, 获取在这个链表的位置
    	while (*s &amp;&amp; (*s)-&gt;range &lt; range)
    		s = &amp;(*s)-&gt;next;
    	p-&gt;next = *s;
    	*s = p;
    }
    mutex_unlock(domain-&gt;lock);
    return 0;
}
</code></pre>
<h3 id="%E6%97%A7%E7%9A%84%E6%8E%A5%E5%8F%A3">旧的接口</h3>
<h4 id="register_chrdev%E5%87%BD%E6%95%B0%28cdev_init-%2B-cdev_add%29">register_chrdev函数(cdev_init + cdev_add)</h4>
<p>ebf-buster-linux/include/linux/fs.h</p>

<pre class="language-c"><code class="language-c">static inline int register_chrdev(unsigned int major, const char *name,
    			  const struct file_operations *fops)
{
    // 实际是设置主设备号随机分配, 次设备号有256个
    return __register_chrdev(major, 0, 256, name, fops);
}
</code></pre>
<h4 id="__register_chrdev%E5%87%BD%E6%95%B0">__register_chrdev函数</h4>
<p>kernel/ebf-buster-linux/fs/char_dev.c</p>

<pre class="language-c"><code class="language-c">int __register_chrdev(unsigned int major, unsigned int baseminor,unsigned int count, const char *name,const struct file_operations *fops)
{
    struct char_device_struct *cd;
    struct cdev *cdev;
    int err = -ENOMEM;
    // 登记设备号, 0的时候自动分分配
    cd = __register_chrdev_region(major, baseminor, count, name);
...
    // 实际是实现cdev_init函数的功能
    cdev = cdev_alloc();
...
    // 记录信息
    cdev-&gt;owner = fops-&gt;owner;
    cdev-&gt;ops = fops;
...
    // 记录实际的cdec到probe里面
    err = cdev_add(cdev, MKDEV(cd-&gt;major, baseminor), count);
...
}
</code></pre>
<ul>
<li>次设备号为0，次设备号数量为256</li>
</ul>
<h2 id="%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6">创建一个设备文件</h2>
<h3 id="mknod%E5%91%BD%E4%BB%A4">mknod命令</h3>
<p>创建指定类型的特殊文件</p>
<p>mknod --help</p>

<pre class="language-none"><code class="language-none">用法：mknod [选项]... 名称 类型 [主设备号 次设备号]
Create the special file NAME of the given TYPE.
...
当类型为&quot;p&quot;时可不指定主设备号和次设备号，否则它们是必须指定的。
如果主设备号和次设备号以&quot;0x&quot;或&quot;0X&quot;开头，它们会被视作十六进制数来
解析；如果以&quot;0&quot;开头，则被视作八进制数；其余情况下被视作十进制数。
可用的类型包括：

  b      创建(有缓冲的)区块特殊文件
  c, u   创建(没有缓冲的)字符特殊文件
  p      创建先进先出(FIFO)特殊文件, 一般不需要设备号
</code></pre>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507171723834.png" alt="image-20250717172315583" /></p>
<blockquote>
<p>vfs是虚拟文件系统, 根据文件系统的类型去使用实际的文件系统进行创建, 最后实际是建立一个inode节点</p>
<p>在Linux和其他类Unix操作系统中，inode（索引节点）是用来存储文件元数据的一个数据结构。它相当于文件的“身份证”或“档案卡”，描述了文件的各种信息，但不包含文件名本身。</p>
<p>一个inode主要包含以下内容：</p>
<ul>
<li>文件的类型（普通文件、目录、符号链接等）</li>
<li>文件的权限（读、写、执行权限）</li>
<li>文件所有者的用户ID（UID）</li>
<li>文件所属组的组ID（GID）</li>
<li>文件的大小</li>
<li>文件的创建、修改、访问时间戳</li>
<li>指向存储文件内容的磁盘块的指针（数据块地址）</li>
</ul>
<p>每个文件在创建时都会分配一个唯一的inode编号，操作系统通过这个编号找到文件的所有元数据。文件名是存储在目录中的条目，目录实际上是从文件名到inode编号的映射。</p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507171733711.png" alt="image-20250717173334639" /></p>
</blockquote>
<h3 id="init_special_inode%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90">init_special_inode函数分析</h3>
<p>ebf-buster-linux/fs/inode.c</p>
<p>判断文件的inode类型，如果是字符设备类型，则把def_chr_fops作为该文件的操作接口，并把设备号记录在inode-&gt;i_rdev。</p>

<pre class="language-c"><code class="language-c">// mode是文件的权限, rdev是设备号
void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)
{
    inode-&gt;i_mode = mode;
    if (S_ISCHR(mode)) {
    	inode-&gt;i_fop = &amp;def_chr_fops; // 初始化一下通用的操作接口(之后这个接口调用自己构建的)
    	inode-&gt;i_rdev = rdev; // 记录一下设备号
    } else if (S_ISBLK(mode)) {
    	inode-&gt;i_fop = &amp;def_blk_fops;
    	inode-&gt;i_rdev = rdev;
    } else if (S_ISFIFO(mode))
    	inode-&gt;i_fop = &amp;pipefifo_fops;
    else if (S_ISSOCK(mode))
    	;	/* leave it no_open_fops */
    else
    	printk(KERN_DEBUG &quot;init_special_inode: bogus i_mode (%o) for&quot;
    			  &quot; inode %s:%lu\n&quot;, mode, inode-&gt;i_sb-&gt;s_id,
    			  inode-&gt;i_ino);
}
</code></pre>
<h2 id="open%E5%87%BD%E6%95%B0%E6%9F%A5%E6%89%BEfile_operation">open函数查找file_operation</h2>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507171911323.png" alt="image-20250717191133208" /></p>
<ul>
<li><p>get_unused_fd_flags</p>
<ul>
<li>为本次操作分配一个未使用过的文件描述符</li>
</ul>
</li>
<li><p>do_file_open</p>
<ul>
<li>生成一个空白struct file结构体</li>
<li>从文件系统中查找到文件对应的inode</li>
</ul>
</li>
<li><ul>
<li><p>do_dentry_open</p>
<ul>
<li>获取到实际inode的chrdev_open 函数, 并进行调用, 记录在任务的文件句柄里面</li>
</ul>
</li>
</ul>
</li>
</ul>

<pre class="language-c"><code class="language-c">static int do_dentry_open(struct file *f,
    		  struct inode *inode,
    		  int (*open)(struct inode *, struct file *))
{
    ...
    /*把inode的file_operation赋值给struct file的f_op*/
    f-&gt;f_op = fops_get(inode-&gt;i_fop); // 这个参数是在创建文件的时候初始化的
    ...
    if (!open)
    	open = f-&gt;f_op-&gt;open;
    if (open) {
    	error = open(inode, f);
    	if (error)
    		goto cleanup_all;
    }
    ...
}
</code></pre>
<ul>
<li><p>def_chr_fops-&gt;chrdev_open 实际用于调用不同的cdev注册的operation的函数</p>
<p>​	ebf-buster-linux/fs/char_dev.c</p>
</li>
</ul>

<pre class="language-c"><code class="language-c">static int chrdev_open(struct inode *inode, struct file *filp)
{
    const struct file_operations *fops;
    struct cdev *p;
    struct cdev *new = NULL;
    ...
    struct kobject *kobj;
    int idx;
    /*从内核哈希表cdev_map中，根据设备号查找自己注册的sturct cdev，获取cdev中的file_operation接口*/
    kobj = kobj_lookup(cdev_map, inode&gt;i_rdev,&amp;idx);
    new = container_of(kobj, struct cdev, kobj);
    ...
    inode-&gt;i_cdev = p = new;
    ...
    fops = fops_get(p-&gt;ops);
    ...
    /*把cdev中的file_operation接口赋值给struct file的f_op*/
    replace_fops(filp, fops);
    
    /*调用自己实现的file_operation接口中的open函数*/
    if (filp-&gt;f_op-&gt;open) {
    	ret = filp-&gt;f_op-&gt;open(inode, filp);
    	if (ret)
    		goto out_cdev_put;
    }
    ...
}
</code></pre>
<h3 id="struct-file">struct file</h3>

<pre class="language-c"><code class="language-c">struct file *filp;
// 在操作函数中常用的 filp 字段
filp-&gt;f_flags;      // 文件打开标志 (O_RDONLY, O_WRONLY, O_NONBLOCK等)
filp-&gt;f_mode;       // 文件访问模式
filp-&gt;f_pos;        // 当前文件位置 (读写偏移量)
filp-&gt;f_op;         // 文件操作函数指针
</code></pre>
<p>可以使用这个结构体里面的<code>private_data</code>传递数据</p>
<h2 id="ioctl">ioctl</h2>
<h3 id="%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4">用户空间</h3>

<pre class="language-c"><code class="language-c">#include &lt;sys/ioctl.h&gt; 
int ioctl(int fd, int cmd, ...);
</code></pre>
<h3 id="%E9%A9%B1%E5%8A%A8">驱动</h3>

<pre class="language-c"><code class="language-c">long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
long (*compat_ioctl) (struct file *, unsigned int, unsigned long);
</code></pre>
<blockquote>
<p>unlocked_ioctl，顾名思义，应该在无大内核锁(BKL)的情况下调用；compat_ioctl，compat 全称 compatible(兼容的)，主要目的是为 64 位系统提供 32 位 ioctl 的兼容方法，也是在无大内核锁的情况下调用</p>
<p>一般情况下只要实现 unlocked_ioctl 函数即可</p>
</blockquote>
<h3 id="cmd">cmd</h3>
<p>ioctl 方法第二个参数 cmd 为用户与驱动的 “协议”，理论上可以为任意 int 型数据，可以为 0、1、2、3……，但是为了确保该 “协议” 的唯一性，ioctl 命令应该使用更科学严谨的方法赋值，在linux中，提供了一种 ioctl 命令的统一格式，将 32 位 int 型数据划分为四个位段</p>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/mac-picture/v2-c4c0b56ac8ca78b86cfa709979a381d0_r.jpg" alt="img" /></p>
<blockquote>
<ol>
<li>dir（direction），ioctl 命令访问模式（数据传输方向），占据 2 bit，可以为 _IOC_NONE、_IOC_READ、_IOC_WRITE、_IOC_READ | _IOC_WRITE，分别指示了四种访问模式：无数据、读数据、写数据、读写数据；</li>
<li>type（device type），设备类型，占据 8 bit，在一些文献中翻译为 “幻数” 或者 “魔数”，可以为任意 char 型字符，例如‘a’、’b’、’c’ 等等，其主要作用是使 ioctl 命令有唯一的设备标识；</li>
<li>nr（number），命令编号/序数，占据 8 bit，可以为任意 unsigned char 型数据，取值范围 0~255，如果定义了多个 ioctl 命令，通常从 0 开始编号递增；</li>
<li>size，涉及到 ioctl 函数 第三个参数 arg ，占据 13bit 或者 14bit（体系相关，arm 架构一般为 14 位），指定了 arg 的数据类型及长度，如果在驱动的 ioctl 实现中不检查，通常可以忽略该参数</li>
</ol>
</blockquote>
<p>实际合成的时候可以使用以下的宏定义</p>

<pre class="language-c"><code class="language-c">/* used to create numbers */
#define _IO(type,nr)        _IOC(_IOC_NONE,(type),(nr),0)
#define _IOR(type,nr,size)  _IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))
#define _IOW(type,nr,size)  _IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))
#define _IOWR(type,nr,size) _IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))
</code></pre>
<blockquote>
<p>_IO：       定义不带参数的 ioctl 命令<br />
_IOW：      定义带写参数的 ioctl 命令（copy_from_user）<br />
_IOR：      定义带读参数的ioctl命令（copy_to_user）<br />
_IOWR：     定义带读写参数的 ioctl 命令</p>
<p>这里面的type指的是魔数, 可以在手册里面查看Documentation/ioctl/ioctl-number.txt</p>
<p>size设置为一个数据类型, 比如<code>struct test</code>, <code>int</code>等, 但是实际传输的还是一个unsigned long类型, 所以可以使用这个参数传递一个指针或一个数字, 传递的参数不受这个宏定义控制, 只是一个约定俗成的定义方式</p>
</blockquote>
<h2 id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</h2>
<ol>
<li>可以直接使用<code>register_chrdev</code>一个函数实现所有的功能</li>
<li>使用分开的函数实现</li>
</ol>
<ul>
<li>使用alloc_chrdev_region动态分配一个内存</li>
<li>使用函数cdev_init初始化一个cdev结构体</li>
<li>使用cdev_add添加设备号等信息</li>
</ul>
<p><code>alloc_chrdev_region(dev_t *, baseminor, count, name)</code></p>
<blockquote>
<p>分别是输出参数, 起始的设备号, 分配的数量以及设备的名字</p>
</blockquote>

<pre class="language-c"><code class="language-c">//第一步
//采用动态分配的方式，获取设备编号，次设备号为0，
//设备名称为EmbedCharDev，可通过命令cat  /proc/devices查看
//DEV_CNT为1，当前只申请一个设备编号
ret = alloc_chrdev_region(&amp;led_devno, 0, DEV_CNT, DEV_NAME);
if(ret &lt; 0){
printk(&quot;fail to alloc led_devno\n&quot;);
goto alloc_err;
}

led_chrdev_class = class_create(THIS_MODULE, &quot;led_chrdev&quot;);
//第二步
//关联字符设备结构体cdev与文件操作结构体file_operations
cdev_init(&amp;led_chr_dev, &amp;led_chr_dev_fops);
//第三步
//添加设备至cdev_map散列表中
ret = cdev_add(&amp;led_chr_dev, led_devno, DEV_CNT);
</code></pre>
<ul>
<li>使用register_chrdev实现</li>
</ul>

<pre class="language-c"><code class="language-c">#include &lt;linux/module.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/kernel.h&gt;

#include &lt;linux/fs.h&gt;
#include &lt;linux/uaccess.h&gt;
#include &lt;asm/io.h&gt;

#define DEV_MAJOR		0		/* 动态申请主设备号 */
#define DEV_NAME		&quot;red_led&quot; 	/*led设备名字 */

/* GPIO虚拟地址指针 */
static void __iomem *IMX6U_CCM_CCGR1;
static void __iomem *SW_MUX_GPIO1_IO04;
static void __iomem *SW_PAD_GPIO1_IO04;
static void __iomem *GPIO1_DR;
static void __iomem *GPIO1_GDIR;

static int led_open(struct inode *inode, struct file *filp)
{
    return 0;
}

static ssize_t led_read(struct file *filp, char __user *buf, size_t cnt, loff_t *offt)
{
    return -EFAULT; // 这里不可以返回一个0, 这个实际表示的是长度一直为0会卡住
}

static ssize_t led_write(struct file *filp, const char __user *buf, size_t cnt, loff_t *offt)
{

    unsigned char databuf[10];

    if(cnt &gt;10)
    	cnt =10;
    	
    /*从用户空间拷贝数据到内核空间, 避免访问非法的内存*/
    if(copy_from_user(databuf, buf, cnt)){
    	return -EIO;
    }
    	
    if(!memcmp(databuf,&quot;on&quot;,2)) {	
    	iowrite32(0 &lt;&lt; 4, GPIO1_DR);	
    } else if(!memcmp(databuf,&quot;off&quot;,3)) {
    	iowrite32(1 &lt;&lt; 4, GPIO1_DR);
    }
    /*写成功后，返回写入的字数*/
    return cnt;
}

static int led_release(struct inode *inode, struct file *filp)
{
    return 0;
}

/* 自定义led的file_operations 接口*/
static struct file_operations led_fops = {
    .owner = THIS_MODULE,
    .open = led_open,
    .read = led_read,
    .write = led_write,
    .release = 	led_release, // 对应close当所有的打开都释放的时候调用这个
};

int major = 0;
static int __init led_init(void)
{
    
    /* GPIO相关寄存器映射 */
    IMX6U_CCM_CCGR1 = ioremap(0x20c406c, 4);
    SW_MUX_GPIO1_IO04 = ioremap(0x20e006c, 4);
    SW_PAD_GPIO1_IO04 = ioremap(0x20e02f8, 4);
    GPIO1_GDIR = ioremap(0x0209c004, 4);
    GPIO1_DR = ioremap(0x0209c000, 4);


    /* 使能GPIO1时钟 */
    iowrite32(0xffffffff, IMX6U_CCM_CCGR1);

    /* 设置GPIO1_IO04复用为普通GPIO*/
    iowrite32(5, SW_MUX_GPIO1_IO04);
    
    /*设置GPIO属性*/
    iowrite32(0x10B0, SW_PAD_GPIO1_IO04);

    /* 设置GPIO1_IO04为输出功能 */
    iowrite32(1 &lt;&lt; 4, GPIO1_GDIR);

    /* LED输出高电平 */
    iowrite32(1&lt;&lt; 4, GPIO1_DR);

    /* 注册字符设备驱动 */
    major = register_chrdev(DEV_MAJOR, DEV_NAME, &amp;led_fops);
    printk(KERN_ALERT &quot;led major:%d\n&quot;,major);

    return 0;
}

static void __exit led_exit(void)
{
    /* 取消映射 */
    iounmap(IMX6U_CCM_CCGR1);
    iounmap(SW_MUX_GPIO1_IO04);
    iounmap(SW_PAD_GPIO1_IO04);
    iounmap(GPIO1_DR);
    iounmap(GPIO1_GDIR);

    /* 注销字符设备驱动 */
    unregister_chrdev(major, DEV_NAME);
}


module_init(led_init);
module_exit(led_exit);

MODULE_LICENSE(&quot;GPL2&quot;);
MODULE_AUTHOR(&quot;embedfire &quot;);
MODULE_DESCRIPTION(&quot;led_module&quot;);
MODULE_ALIAS(&quot;led_module&quot;);
</code></pre>
<h4 id="%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9D%97%E5%88%9D%E5%A7%8B%E5%8C%96">驱动模块初始化</h4>
<h5 id="%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84">地址映射</h5>
<p>GPIO寄存器物理地址和虚拟地址映射</p>
<p>ebf-buster-linux/arch/arm/include/asm/io.h</p>

<pre class="language-c"><code class="language-c">void __iomem *ioremap(resource_size_t res_cookie, size_t size)
</code></pre>
<p>参数：</p>
<ul>
<li><p>res_cookie：物理地址</p>
</li>
<li><p>size：映射长度</p>
</li>
</ul>
<p>返回值：</p>
<ul>
<li>void * 类型的指针，指向被映射的虚拟地址</li>
<li>__iomem 主要是用于编译器的检查地址在内核空间的有效性</li>
</ul>
<h5 id="%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E8%AF%BB%E5%86%99">虚拟地址读写</h5>

<pre class="language-c"><code class="language-c">readl()/ writel()	//过时

void iowrite32(u32 b, void __iomem *addr)   //写入一个双字（32bit）

unsigned int ioread32(void __iomem *addr)   //读取一个双字（32bit）
</code></pre>
<p>检查cpu大小端，调整字节序，以提高驱动的可移植性</p>
<h4 id="%E8%87%AA%E5%AE%9A%E4%B9%89led%E7%9A%84file_operations%E6%8E%A5%E5%8F%A3">自定义led的file_operations接口</h4>

<pre class="language-c"><code class="language-c">static struct file_operations led_fops = {
    .owner = THIS_MODULE,
    .open = led_open,
    .read = led_read,
    .write = led_write,
    .release = led_release,
};
</code></pre>
<ul>
<li>owner：设置驱动接口关联的内核模块，防止驱动程序运行时内核模块被卸载</li>
<li>release：文件引用数为0时调用</li>
</ul>
<h4 id="%E6%8B%B7%E8%B4%9D%E6%95%B0%E6%8D%AE">拷贝数据</h4>
<p>include/linux/uaccess.h</p>
<p>避免访问非法内存, 导致内核崩溃</p>

<pre class="language-c"><code class="language-c">unsigned long copy_from_user(void *to, const void __user *from, unsigned long n)
unsigned long copy_to_user(void __user *to, const void *from, unsigned long n);
</code></pre>
<p>参数：</p>
<ul>
<li><p>*to：将数据拷贝到内核的地址</p>
</li>
<li><p>*from  需要拷贝数据的用户空间地址</p>
</li>
<li><p>n   拷贝数据的长度（字节）</p>
</li>
</ul>
<p>返回值：</p>
<p>失败：没有被拷贝的字节数</p>
<p>成功：0</p>
<h3 id="%E7%8E%B0%E8%B1%A1">现象</h3>
<p>可以在<code>/proc/devices</code>文件里面看到实际的设备文件以及对应的设备号, 在使用insmod加载模块以及, 可以查看到分配的主设备号</p>
<p>之后可以使用命令<code>mknod /dev/xxx c 主次设备号</code>进行设备的创建</p>

                        
                    </div>
                </div>
                <div id="previous_next">
                    <div id="previous">
                        
                        <a href="/note/Linux/野火Linux/2025-7-15-10-内核模块.html">
                            <span class="icon"></span>
                            <span class="label">2025-7-15-10-内核模块</span>
                        </a>
                        
                    </div>
                    <div id="next">
                        
                        <a href="/note/Linux/野火Linux/2025-7-15-12-驱动设备模型.html">
                            <span class="label">2025-7-15-12-驱动设备模型</span>
                            <span class="icon"></span>
                        </a>
                        
                    </div>
                </div>
                <div id="comments-container"></div>
            </div>
            <div id="toc_wrapper">
                <div id="toc">
                    <div id="toc_content">
                            
                    </div>
                </div>
            </div>
        </div>
    </div>
    <a id="to_top" href="#"></a>
    <div id="doc_footer">
        <div id="footer">
            <div id="footer_top">
                <ul>
<li><a>链接</a><ul><li><a target="_blank" href="https://teedoc.neucrack.com">网站使用 teedoc 生成</a></li>
<li><a target="_blank" href="https://neucrack.com">Copyright © 2021 Neucrack</a></li>
<li><a  href="/note/sitemap.xml">网站地图</a></li>
</ul>
</li>
<li><a>源码</a><ul><li><a target="_blank" href="https://github.com/XuSenfeng/note/">github</a></li>
<li><a target="_blank" href="https://github.com/teedoc/teedoc">本网站源文件</a></li>
</ul>
</li>
</ul>

            </div>
            <div id="footer_bottom">
                <ul>
<li><a target="_blank" href="https://beian.miit.gov.cn">渝ICP备19015320号</a></li>
<li><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44030602004109">粤公网安备44030602004109号</a></li>
</ul>

            </div>
        </div>
    </div>
    
        <script src="/note/teedoc-plugin-markdown-parser/mermaid.min.js"></script>
    
        <script>mermaid.initialize({startOnLoad:true});</script>
    
        <script type="text/javascript">
                var transLoaded = false;
                var loading = false;
                var domain = "translate.google.com";
                var domainDefault = domain;
                var storeDomain = localStorage.getItem("googleTransDomain");
                if(storeDomain){
                    domain = storeDomain;
                    console.log("load google translate domain from local storage:" + domain);
                }
                function getUrl(domain){
                    if(domain == "/")
                        return "/static/js/google_translate/element.js?cb=googleTranslateElementInit";
                    else
                        return "https://" + domain + "/translate_a/element.js?cb=googleTranslateElementInit";
                }
                var url = getUrl(domain);
                console.log("google translate domain:" + domain + ", url: " + url);
                function googleTranslateElementInit() {
                    new google.translate.TranslateElement({pageLanguage: "auto", layout: google.translate.TranslateElement.InlineLayout.SIMPLE}, 'google_translate_element');
                }
                function loadJS( url, callback ){
                    var script = document.createElement('script');
                    fn = callback || function(){ };
                    script.type = 'text/javascript';
                    if(script.readyState){
                        script.onreadystatechange = function(){
                            if( script.readyState == 'loaded' || script.readyState == 'complete' ){
                                script.onreadystatechange = null;
                                fn();
                            }
                        };
                    }else{
                        script.onload = function(){
                            fn();
                        };
                    }
                    script.src = url;
                    document.getElementsByTagName('head')[0].appendChild(script);
                }
                function removeHint(){
                    var hint = document.getElementById("loadingTranslate");
                    if(hint){
                        hint.remove();
                    }
                }
                var btn = document.getElementById("google_translate_element");
                btn.onclick = function(){
                    if(transLoaded) return;
                    if(loading){
                        var flag = confirm("loading from " + domain + ", please wait, or change domain?");
                        if(flag){
                            newDomain = prompt("domain, default: " + domainDefault + ", now: " + domain);
                            if(newDomain){
                                domain = newDomain;
                                console.log(domain);
                                url = getUrl(domain);
                                loadJS(url, function(){
                                    localStorage.setItem("googleTransDomain", domain);
                                    removeHint()
                                    transLoaded = true;
                                });
                            }
                        }
                        return;
                    }
                    btn.innerHTML = '<span id="loadingTranslate"><img class="icon" src="/note/static/image/google_translate/translate.svg"/>Loading ...</span>';
                    loading = true;
                    loadJS(url, function(){
                        localStorage.setItem("googleTransDomain", domain);
                        removeHint()
                        transLoaded = true;
                    });
                }
                </script>
            
    
        <script src="/note/static/js/theme_default/tocbot.min.js"></script>
    
        <script src="/note/static/js/theme_default/main.js"></script>
    
        <script src="/note/static/js/theme_default/viewer.min.js"></script>
    
        <script src="/note/static/css/theme_default/prism.min.js"></script>
    
        <script src="/note/static/js/search/search_main.js"></script>
    
        <script src="/note/static/js/plugin_blog/main.js"></script>
    
        <link rel="stylesheet" href="/note/static/js/add_hint/style.css" type="text/css"/>
    
        <script src="/note/static/js/add_hint/main.js"></script>
    
        <script src="/note/static/js/gitalk/gitalk.min.js"></script>
    
        <script src="/note/static/js/gitalk/main.js"></script>
    
        <script src="/note/static/js/custom.js"></script>
    
</body>

</html>