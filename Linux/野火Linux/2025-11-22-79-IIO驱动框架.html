<!DOCTYPE html>

<html lang="zh-CN"  class="">


<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="keywords" content="">
    
    
    <meta name="description" content="">
    
    <meta name="generator" content="teedoc">
    <meta name="theme" content="teedoc-plugin-theme-default">
    
        
        <meta name="markdown-generator" content="teedoc-plugin-markdown-parser">
        
        <script>
MathJax = {"loader": {"load": ["output/svg"]}, "tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]]}, "svg": {"fontCache": "global"}};
</script>
        
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        
        <meta name="html-generator" content="teedoc-plugin-jupyter-notebook-parser">
        
        <script src="/note/static/js/theme_default/pre_main.js"></script>
        
        <link rel="stylesheet" href="/note/static/css/theme_default/prism.min.css" type="text/css"/>
        
        <link rel="stylesheet" href="/note/static/css/theme_default/viewer.min.css" type="text/css"/>
        
        <link rel="stylesheet" href="/note/static/css/theme_default/dark.css" type="text/css"/>
        
        <link rel="stylesheet" href="/note/static/css/theme_default/light.css" type="text/css"/>
        
        <script src="/note/static/js/theme_default/jquery.min.js"></script>
        
        <script src="/note/static/js/theme_default/split.js"></script>
        
        <link rel="stylesheet" href="/note/static/css/search/style.css" type="text/css"/>
        
        <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4d52982572d5512e9762879ebf063c86";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
        
        <meta name="blog-generator" content="teedoc-plugin-blog">
        
        <link rel="stylesheet" href="/note/static/css/gitalk/gitalk.css" type="text/css"/>
        
        <link rel="stylesheet" href="/note/static/css/gitalk/custom_gitalk.css" type="text/css"/>
        
        <link rel="stylesheet" href="/note/static/css/custom.css" type="text/css"/>
        
    
    
    <title>IIO - XvSenfeng's Note</title>
    
    <script type="text/javascript">js_vars = {"teedoc-plugin-ad-hint": {"type": "hint", "label": "☆", "content": "这是一个支持国际化的消息示例</br>喜欢项目请<a target=\"_blank\" href=\"https://github.com/teedoc/teedoc\">点下 ☆ star </a>哦~🦀🦀", "show_times": 2, "show_after_s": 432000, "date": "2021-11-16 14:40", "color": "#a0421d", "link_color": "#e53935", "link_bg_color": "#e6ae5c", "bg_color": "#ffcf89", "color_hover": "white", "bg_color_hover": "#f57c00", "close_color": "#eab971"}}</script>
    <script type="text/javascript">metadata = {"tags": [], "date": null, "update": [], "ts": 0, "author": "", "brief": "", "cover": ""}</script>
</head>


<body class="type_doc">
    
    <div id="navbar">
        <div id="navbar_menu">
            <a class="site_title" href="/note/">
                
                    <img class="site_logo" src="/note/static/image/logo.png" alt="XvSenfeng logo">
                
                
                    <h2>XvSenfeng</h2>
                
        </a>
            <a id="navbar_menu_btn"></a>
        </div>
        <div id="navbar_items">
            <div>
                <ul id="nav_left">
<li class=""><a  href="/note/blog/">博客</a></li>
<li class="active"><a  href="/note/Linux/">Linux</a></li>
<li class=""><a  href="/note/代码分析/">代码分析</a></li>
<li class=""><a  href="/note/使用软件/">使用软件</a></li>
<li class=""><a  href="/note/嵌入式/">嵌入式</a></li>
<li class=""><a  href="/note/手机安卓/">手机安卓</a></li>
<li class=""><a  href="/note/机器学习/">机器学习</a></li>
<li class=""><a  href="/note/编程基础/">编程基础</a></li>
<li class=""><a  href="/note/网络/">网络</a></li>
</ul>

            </div>
            <div>
                <ul id="nav_right">
<li class=""><a target="_blank" href="https://github.com/XuSenfeng/note/">github</a></li>
</ul>

                <ul class="nav_plugins"><li><a id="google_translate_element"><img class="icon" src="/note/static/image/google_translate/translate.svg"/>Translate</a></li></ul><ul class="nav_plugins"><li><a id="themes" class="light"></a></li></ul><ul class="nav_plugins"><li><a id="search"><span class="icon"></span><span class="placeholder">搜索</span>
                            <div id="search_hints">
                                <span id="search_input_hint">输入关键词，多关键词空格隔开</span>
                                <span id="search_loading_hint">正在加载，请稍候。。。</span>
                                <span id="search_download_err_hint">下载文件失败，请刷新重试或检查网络</span>
                                <span id="search_other_docs_result_hint">来自其它文档的结果</span>
                                <span id="search_curr_doc_result_hint">当前文档搜索结果</span>
                            </div></a></li></ul>
            </div>
        </div>
    </div>
    
    <div id="wrapper">
        <div id="sidebar_wrapper">
            <div id="sidebar">
                <div id="sidebar_title">
                    
                </div>
                <ul class="show">
<li class="not_active with_link"><a href="/note/Linux/index.html"><span class="label">README</span><span class=""></span></a></li>
<li class="not_active no_link"><a><span class="label">Linux命令行与shell脚本编程大全</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-1-初认识Linux_shell.html"><span class="label">2022-8-1-初认识Linux_shell</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-1-基本bashshell命令.html"><span class="label">2022-8-1-基本bashshell命令</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-1-走进shell.html"><span class="label">2022-8-1-走进shell</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-10-sed进阶.html"><span class="label">2022-8-10-sed进阶</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-11-gawk进阶.html"><span class="label">2022-8-11-gawk进阶</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-11-使用其他shell.html"><span class="label">2022-8-11-使用其他shell</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-11-实例.html"><span class="label">2022-8-11-实例</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-12-邮件相关.html"><span class="label">2022-8-12-邮件相关</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-2-更多命令.html"><span class="label">2022-8-2-更多命令</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-2-理解shell.html"><span class="label">2022-8-2-理解shell</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-3-使用Linux环境变量.html"><span class="label">2022-8-3-使用Linux环境变量</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-3-理解Linux的文件权限.html"><span class="label">2022-8-3-理解Linux的文件权限</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-4-安装软件程序.html"><span class="label">2022-8-4-安装软件程序</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-4-管理文件系统.html"><span class="label">2022-8-4-管理文件系统</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-5-使用编辑器.html"><span class="label">2022-8-5-使用编辑器</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-5-构建基本脚本.html"><span class="label">2022-8-5-构建基本脚本</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-6-使用结构初始化.html"><span class="label">2022-8-6-使用结构初始化</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-6-处理用户输入.html"><span class="label">2022-8-6-处理用户输入</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-6-更多结构化命令.html"><span class="label">2022-8-6-更多结构化命令</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-7-呈现数据.html"><span class="label">2022-8-7-呈现数据</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-7-控制脚本.html"><span class="label">2022-8-7-控制脚本</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-8-创建函数.html"><span class="label">2022-8-8-创建函数</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-9-图形化桌面环境中的脚本编程.html"><span class="label">2022-8-9-图形化桌面环境中的脚本编程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-9-正则表达式.html"><span class="label">2022-8-9-正则表达式</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux命令行与shell脚本编程大全/2022-8-9-认识sed和gawk.html"><span class="label">2022-8-9-认识sed和gawk</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">Linux就该这么学</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/Linux就该这么学/2022-8-23-.html"><span class="label">2022-8-23-</span><span class=""></span></a></li>
<li class="not_active no_link"><a><span class="label">鸟哥的linux私房菜</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/Linux就该这么学/鸟哥的linux私房菜/2022-9-10-计算机概论.html"><span class="label">2022-9-10-计算机概论</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux就该这么学/鸟哥的linux私房菜/2022-9-20-主机规划与磁盘分区.html"><span class="label">2022-9-20-主机规划与磁盘分区</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux就该这么学/鸟哥的linux私房菜/2022-9-20-安装CentOS.html"><span class="label">2022-9-20-安装CentOS</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux就该这么学/鸟哥的linux私房菜/2022-9-20-首次登录.html"><span class="label">2022-9-20-首次登录</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux就该这么学/鸟哥的linux私房菜/2022-9-25-文件权限以及目录.html"><span class="label">2022-9-25-文件权限以及目录</span><span class=""></span></a></li>
</ul>
</li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">Linux源码趣读</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/Linux源码趣读/2024-1-26-01最开始的代码.html"><span class="label">2024-1-26-01最开始的代码</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">Linux系统编程</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/Linux系统编程/2024-2-14-01文件IO.html"><span class="label">2024-2-14-01文件IO</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux系统编程/2024-3-19-02文件系统.html"><span class="label">2024-3-19-02文件系统</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux系统编程/2024-3-21-03程序和进程.html"><span class="label">2024-3-21-03程序和进程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux系统编程/2024-3-23-04进程间通信.html"><span class="label">2024-3-23-04进程间通信</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux系统编程/2024-3-25-05信号.html"><span class="label">2024-3-25-05信号</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux系统编程/2024-3-28-06守护进程、线程.html"><span class="label">2024-3-28-06守护进程、线程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux系统编程/2024-3-31-07线程同步.html"><span class="label">2024-3-31-07线程同步</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">Linux网络编程</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-10-04线程池.html"><span class="label">2024-4-10-04线程池</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-13-05本地套接字.html"><span class="label">2024-4-13-05本地套接字</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-14-06libevent库.html"><span class="label">2024-4-14-06libevent库</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-16-07简单的Web服务器.html"><span class="label">2024-4-16-07简单的Web服务器</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-16-08html入门.html"><span class="label">2024-4-16-08html入门</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-17-09CSS.html"><span class="label">2024-4-17-09CSS</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-17-09HTTP协议.html"><span class="label">2024-4-17-09HTTP协议</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-2-01网络基础.html"><span class="label">2024-4-2-01网络基础</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-20-10telnet调试.html"><span class="label">2024-4-20-10telnet调试</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-20-11服务器.html"><span class="label">2024-4-20-11服务器</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-3-02Socket编程.html"><span class="label">2024-4-3-02Socket编程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/Linux网络编程/2024-4-6-03高并发服务器.html"><span class="label">2024-4-6-03高并发服务器</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">原子Linux</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-10-Linux常用命令.html"><span class="label">2022-8-10-Linux常用命令</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-11-压缩解压缩.html"><span class="label">2022-8-11-压缩解压缩</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-11-文件系统结构.html"><span class="label">2022-8-11-文件系统结构</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-11-磁盘管理.html"><span class="label">2022-8-11-磁盘管理</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-12-LinuxC.html"><span class="label">2022-8-12-LinuxC</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-12-Makefile书.html"><span class="label">2022-8-12-Makefile书</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-12-make和Makefile.html"><span class="label">2022-8-12-make和Makefile</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-12-开发环境搭建.html"><span class="label">2022-8-12-开发环境搭建</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-12-用户和用户组.html"><span class="label">2022-8-12-用户和用户组</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-12-链接文件.html"><span class="label">2022-8-12-链接文件</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-13-IMX启动方式.html"><span class="label">2022-8-13-IMX启动方式</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-13-vscode.html"><span class="label">2022-8-13-vscode</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-13-开发板简介.html"><span class="label">2022-8-13-开发板简介</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-13-汇编LED驱动.html"><span class="label">2022-8-13-汇编LED驱动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-14-C语言点灯.html"><span class="label">2022-8-14-C语言点灯</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-14-按键检测.html"><span class="label">2022-8-14-按键检测</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-14-模仿stm32编程.html"><span class="label">2022-8-14-模仿stm32编程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-15-中断.html"><span class="label">2022-8-15-中断</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-15-主频时钟配置.html"><span class="label">2022-8-15-主频时钟配置</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-16-EPIT定时器.html"><span class="label">2022-8-16-EPIT定时器</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-16-GPT时钟.html"><span class="label">2022-8-16-GPT时钟</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-17-DDR3.html"><span class="label">2022-8-17-DDR3</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-17-RGBLED.html"><span class="label">2022-8-17-RGBLED</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-17-串口.html"><span class="label">2022-8-17-串口</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-18-I2C.html"><span class="label">2022-8-18-I2C</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-18-RTC.html"><span class="label">2022-8-18-RTC</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-19-PWM.html"><span class="label">2022-8-19-PWM</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-19-SPI.html"><span class="label">2022-8-19-SPI</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-19-多点电容触摸屏.html"><span class="label">2022-8-19-多点电容触摸屏</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-20-uBoot.html"><span class="label">2022-8-20-uBoot</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-20-系统烧写.html"><span class="label">2022-8-20-系统烧写</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-22-源码目录分析.html"><span class="label">2022-8-22-源码目录分析</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-22-顶层Makefile.html"><span class="label">2022-8-22-顶层Makefile</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-23-Linux内核.html"><span class="label">2022-8-23-Linux内核</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-23-uboot图形化配置界面.html"><span class="label">2022-8-23-uboot图形化配置界面</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-23-启动流程.html"><span class="label">2022-8-23-启动流程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-23-移植.html"><span class="label">2022-8-23-移植</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-24-驱动开发.html"><span class="label">2022-8-24-驱动开发</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-26-linux点灯.html"><span class="label">2022-8-26-linux点灯</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-27-设备树.html"><span class="label">2022-8-27-设备树</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-28-led设备树.html"><span class="label">2022-8-28-led设备树</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-29-Linux的并发与竞争.html"><span class="label">2022-8-29-Linux的并发与竞争</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-29-pinclt和gpio.html"><span class="label">2022-8-29-pinclt和gpio</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-30-Linux中断.html"><span class="label">2022-8-30-Linux中断</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-30-Linux内核定时器.html"><span class="label">2022-8-30-Linux内核定时器</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-31-异步通知.html"><span class="label">2022-8-31-异步通知</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-8-31-阻塞非阻塞.html"><span class="label">2022-8-31-阻塞非阻塞</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-1-platform设备驱动.html"><span class="label">2022-9-1-platform设备驱动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-10-WIFI.html"><span class="label">2022-9-10-WIFI</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-10-网络驱动.html"><span class="label">2022-9-10-网络驱动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-11-4G.html"><span class="label">2022-9-11-4G</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-11-IIO.html"><span class="label">2022-9-11-IIO</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-11-PWM.html"><span class="label">2022-9-11-PWM</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-11-RGBtoHDMI.html"><span class="label">2022-9-11-RGBtoHDMI</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-11-Regmap.html"><span class="label">2022-9-11-Regmap</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-2-INPUT子系统.html"><span class="label">2022-9-2-INPUT子系统</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-2-LCD屏幕.html"><span class="label">2022-9-2-LCD屏幕</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-2-Linux自带的led.html"><span class="label">2022-9-2-Linux自带的led</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-2-MISC.html"><span class="label">2022-9-2-MISC</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-3-I2C.html"><span class="label">2022-9-3-I2C</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-3-RTC.html"><span class="label">2022-9-3-RTC</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-3-SPI.html"><span class="label">2022-9-3-SPI</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-4-串口.html"><span class="label">2022-9-4-串口</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-5-触摸屏.html"><span class="label">2022-9-5-触摸屏</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-5-音频驱动.html"><span class="label">2022-9-5-音频驱动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-6-CAN协议.html"><span class="label">2022-9-6-CAN协议</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-7-USB.html"><span class="label">2022-9-7-USB</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/原子Linux/2022-9-7-块设备驱动.html"><span class="label">2022-9-7-块设备驱动</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">操作系统原理</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-17-1操作系统.html"><span class="label">2023-6-17-1操作系统</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-17-2操作系统目标和作用.html"><span class="label">2023-6-17-2操作系统目标和作用</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-17-3操作系统特征.html"><span class="label">2023-6-17-3操作系统特征</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-17-4操作系统的发展.html"><span class="label">2023-6-17-4操作系统的发展</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-17-5运行机制.html"><span class="label">2023-6-17-5运行机制</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-18-6中断异常.html"><span class="label">2023-6-18-6中断异常</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-18-7系统调用.html"><span class="label">2023-6-18-7系统调用</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-19-8体系结构.html"><span class="label">2023-6-19-8体系结构</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-20-10虚拟机.html"><span class="label">2023-6-20-10虚拟机</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-20-11进程.html"><span class="label">2023-6-20-11进程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-20-9操作系统的引导.html"><span class="label">2023-6-20-9操作系统的引导</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-22-12线程.html"><span class="label">2023-6-22-12线程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-23-13调度.html"><span class="label">2023-6-23-13调度</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-27-14进程同步进程互斥.html"><span class="label">2023-6-27-14进程同步进程互斥</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-28-15锁.html"><span class="label">2023-6-28-15锁</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/操作系统原理/2023-6-28-16信号量机制.html"><span class="label">2023-6-28-16信号量机制</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">服务器</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/服务器/2023-6-12-代理.html"><span class="label">2023-6-12-代理</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/服务器/2023-6-12-新服务器搭建.html"><span class="label">2023-6-12-新服务器搭建</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">李述铜手写操作系统</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2023-10-26-05中断和异常处理.html"><span class="label">2023-10-26-05中断和异常处理</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2023-11-10-06日志与printf输出.html"><span class="label">2023-11-10-06日志与printf输出</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2023-9-23-03引导程序接管控制权.html"><span class="label">2023-9-23-03引导程序接管控制权</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2023-9-28-04加载器loader的实现.html"><span class="label">2023-9-28-04加载器loader的实现</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2023-9-6-01补充知识2.html"><span class="label">2023-9-6-01补充知识2</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2023-9-6-0补充知识.html"><span class="label">2023-9-6-0补充知识</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2023-9-6-1操作系统准备.html"><span class="label">2023-9-6-1操作系统准备</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2023-9-7-2x86保护模式下的编程.html"><span class="label">2023-9-7-2x86保护模式下的编程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-2-17-07进程切换.html"><span class="label">2024-2-17-07进程切换</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-2-17-08链表.html"><span class="label">2024-2-17-08链表</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-2-17添加任务管理器.html"><span class="label">2024-2-17添加任务管理器</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-2-18-内存管理.html"><span class="label">2024-2-18-内存管理</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-2-24-系统调用.html"><span class="label">2024-2-24-系统调用</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-2-26-移植Newlib库.html"><span class="label">2024-2-26-移植Newlib库</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-2-27-屏幕显示信息.html"><span class="label">2024-2-27-屏幕显示信息</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-2-29-键盘初始化.html"><span class="label">2024-2-29-键盘初始化</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-3-1-设备管理.html"><span class="label">2024-3-1-设备管理</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-3-3-Shell.html"><span class="label">2024-3-3-Shell</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-3-4-文件系统.html"><span class="label">2024-3-4-文件系统</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-3-5-磁盘.html"><span class="label">2024-3-5-磁盘</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/李述铜手写操作系统/2024-3-7-Fat16.html"><span class="label">2024-3-7-Fat16</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">树莓派</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/树莓派/2024-2-1-01开始使用.html"><span class="label">2024-2-1-01开始使用</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/树莓派/2024-2-1-02-使用命令了解树莓派.html"><span class="label">2024-2-1-02-使用命令了解树莓派</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/树莓派/2024-2-1-03-安装mysql.html"><span class="label">2024-2-1-03-安装mysql</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/树莓派/2024-2-3-04网络连接.html"><span class="label">2024-2-3-04网络连接</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/树莓派/2024-2-8-时钟设置.html"><span class="label">2024-2-8-时钟设置</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">泰山派</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-12-20-05-lvgl程序.html"><span class="label">2025-12-20-05-lvgl程序</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-12-24-06-二维码识别.html"><span class="label">2025-12-24-06-二维码识别</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-12-24-07-yolo部署.html"><span class="label">2025-12-24-07-yolo部署</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-12-25-08-OpenCV.html"><span class="label">2025-12-25-08-OpenCV</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-12-26-09-拍照.html"><span class="label">2025-12-26-09-拍照</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-12-26-10-Qt.html"><span class="label">2025-12-26-10-Qt</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-5-11-01环境搭建.html"><span class="label">2025-5-11-01环境搭建</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-5-11-02设备树.html"><span class="label">2025-5-11-02设备树</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-5-14-03屏幕驱动.html"><span class="label">2025-5-14-03屏幕驱动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2025-5-17-04触摸驱动.html"><span class="label">2025-5-17-04触摸驱动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2026-1-27-ROS.html"><span class="label">2026-1-27-ROS</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/泰山派/2026-1-30-Ubuntu22.html"><span class="label">2026-1-30-Ubuntu22</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">瑞芯微Linux</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/瑞芯微Linux/2025-12-10-Cpp提供C接口.html"><span class="label">2025-12-10-Cpp提供C接口</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/瑞芯微Linux/2025-12-5-01-EchoAI编译代码.html"><span class="label">2025-12-5-01-EchoAI编译代码</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/瑞芯微Linux/2025-12-5-02-EchoAI代码.html"><span class="label">2025-12-5-02-EchoAI代码</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/瑞芯微Linux/2025-12-7-03-添加板子.html"><span class="label">2025-12-7-03-添加板子</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/瑞芯微Linux/2025-12-8-04-内核.html"><span class="label">2025-12-8-04-内核</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/瑞芯微Linux/2025-12-9-05-模型.html"><span class="label">2025-12-9-05-模型</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/瑞芯微Linux/配置网络.html"><span class="label">配置网络</span><span class=""></span></a></li>
</ul>
</li>
<li class="active_parent no_link"><a><span class="label">野火Linux</span><span class="sub_indicator"></span></a><ul class="show">
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-11-55-buildroot.html"><span class="label">2025-10-11-55-buildroot</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-11-56-裸机汇编开发.html"><span class="label">2025-10-11-56-裸机汇编开发</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-12-57-Uboot编译脚本.html"><span class="label">2025-10-12-57-Uboot编译脚本</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-2-47-镜像构建.html"><span class="label">2025-10-2-47-镜像构建</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-2-48-systemd.html"><span class="label">2025-10-2-48-systemd</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-2-49-deb包.html"><span class="label">2025-10-2-49-deb包</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-2-50-修改img文件.html"><span class="label">2025-10-2-50-修改img文件</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-2-51-备份量产.html"><span class="label">2025-10-2-51-备份量产</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-2-52-Uboot启动.html"><span class="label">2025-10-2-52-Uboot启动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-28-58-Uboot移植.html"><span class="label">2025-10-28-58-Uboot移植</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-30-59-Uboot图形配置界面语法.html"><span class="label">2025-10-30-59-Uboot图形配置界面语法</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-30-60-Linux编译脚本.html"><span class="label">2025-10-30-60-Linux编译脚本</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-31-61-Linux启动流程.html"><span class="label">2025-10-31-61-Linux启动流程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-9-53-Uboot启动(二).html"><span class="label">2025-10-9-53-Uboot启动(二)</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-10-9-54-Uboot启动(三).html"><span class="label">2025-10-9-54-Uboot启动(三)</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-1-62-linux移植.html"><span class="label">2025-11-1-62-linux移植</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-1-63-Busybox.html"><span class="label">2025-11-1-63-Busybox</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-10-65-定时器.html"><span class="label">2025-11-10-65-定时器</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-12-66-信号.html"><span class="label">2025-11-12-66-信号</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-14-67-MISC设备.html"><span class="label">2025-11-14-67-MISC设备</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-15-68-RTC.html"><span class="label">2025-11-15-68-RTC</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-16-69-串口.html"><span class="label">2025-11-16-69-串口</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-18-70-中断线程化.html"><span class="label">2025-11-18-70-中断线程化</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-18-71-音频.html"><span class="label">2025-11-18-71-音频</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-19-72-CAN.html"><span class="label">2025-11-19-72-CAN</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-19-73-USB.html"><span class="label">2025-11-19-73-USB</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-2-64-mfgtool.html"><span class="label">2025-11-2-64-mfgtool</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-20-74-块设备.html"><span class="label">2025-11-20-74-块设备</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-21-75-网络设备.html"><span class="label">2025-11-21-75-网络设备</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-22-76-Wifi.html"><span class="label">2025-11-22-76-Wifi</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-22-77-PWM.html"><span class="label">2025-11-22-77-PWM</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-22-78-Regmap通用寄存器.html"><span class="label">2025-11-22-78-Regmap通用寄存器</span><span class=""></span></a></li>
<li class="active with_link"><a href="/note/Linux/野火Linux/2025-11-22-79-IIO驱动框架.html"><span class="label">2025-11-22-79-IIO驱动框架</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-11-25-80-ADC驱动.html"><span class="label">2025-11-25-80-ADC驱动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-12-6-81-音频驱动.html"><span class="label">2025-12-6-81-音频驱动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-12-8-82-DRM显示设备.html"><span class="label">2025-12-8-82-DRM显示设备</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-6-11-01-入门.html"><span class="label">2025-6-11-01-入门</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-6-22-02-开发板下载启动.html"><span class="label">2025-6-22-02-开发板下载启动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-12-04-镜像文件.html"><span class="label">2025-7-12-04-镜像文件</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-13-06-GPIO.html"><span class="label">2025-7-13-06-GPIO</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-13-07-中断.html"><span class="label">2025-7-13-07-中断</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-14-05-ARMv7汇编.html"><span class="label">2025-7-14-05-ARMv7汇编</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-14-08-时钟控制模块.html"><span class="label">2025-7-14-08-时钟控制模块</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-14-09-串口.html"><span class="label">2025-7-14-09-串口</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-15-10-内核模块.html"><span class="label">2025-7-15-10-内核模块</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-15-11-字符设备.html"><span class="label">2025-7-15-11-字符设备</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-15-12-驱动设备模型.html"><span class="label">2025-7-15-12-驱动设备模型</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-19-13-Kset.html"><span class="label">2025-7-19-13-Kset</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-19-14-uevent消息.html"><span class="label">2025-7-19-14-uevent消息</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-19-15-class设备管理.html"><span class="label">2025-7-19-15-class设备管理</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-19-16-17-总结.html"><span class="label">2025-7-19-16-17-总结</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-19-16-xbus和platform.html"><span class="label">2025-7-19-16-xbus和platform</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-2-03-控制设备.html"><span class="label">2025-7-2-03-控制设备</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-20-18-DTS设备树.html"><span class="label">2025-7-20-18-DTS设备树</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-7-20-19-DeviceTreeOverlay.html"><span class="label">2025-7-20-19-DeviceTreeOverlay</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-16-21-iomux节点(中).html"><span class="label">2025-9-16-21-iomux节点(中)</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-16-22-iomux节点(下).html"><span class="label">2025-9-16-22-iomux节点(下)</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-17-23-iomux节点(应用).html"><span class="label">2025-9-17-23-iomux节点(应用)</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-17-24-GPIO子系统.html"><span class="label">2025-9-17-24-GPIO子系统</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-17-25-并发硬件同步原语.html"><span class="label">2025-9-17-25-并发硬件同步原语</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-18-26-IIC驱动框架.html"><span class="label">2025-9-18-26-IIC驱动框架</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-20-27-IIC驱动框架使用.html"><span class="label">2025-9-20-27-IIC驱动框架使用</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-25-28-阻塞和非阻塞IO.html"><span class="label">2025-9-25-28-阻塞和非阻塞IO</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-25-29-POLL机制.html"><span class="label">2025-9-25-29-POLL机制</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-25-30-Completion.html"><span class="label">2025-9-25-30-Completion</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-25-31-kthread_worker.html"><span class="label">2025-9-25-31-kthread_worker</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-26-32-SPI.html"><span class="label">2025-9-26-32-SPI</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-26-33-SPI使用.html"><span class="label">2025-9-26-33-SPI使用</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-27-34-中断.html"><span class="label">2025-9-27-34-中断</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-27-35-软中断和tasklet.html"><span class="label">2025-9-27-35-软中断和tasklet</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-27-36-工作队列.html"><span class="label">2025-9-27-36-工作队列</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-27-37-Input子系统.html"><span class="label">2025-9-27-37-Input子系统</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-28-38-电容触摸屏.html"><span class="label">2025-9-28-38-电容触摸屏</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-28-39-PWM.html"><span class="label">2025-9-28-39-PWM</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-28-40-LCD-FB设备.html"><span class="label">2025-9-28-40-LCD-FB设备</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-29-41-Linux系统构成.html"><span class="label">2025-9-29-41-Linux系统构成</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-29-42-Uboot基础使用.html"><span class="label">2025-9-29-42-Uboot基础使用</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-29-43-Linux.html"><span class="label">2025-9-29-43-Linux</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-29-44-添加驱动(设备树).html"><span class="label">2025-9-29-44-添加驱动(设备树)</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-30-45-图标.html"><span class="label">2025-9-30-45-图标</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-30-46-根文件系统.html"><span class="label">2025-9-30-46-根文件系统</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/2025-9-4-20-iomux节点(上).html"><span class="label">2025-9-4-20-iomux节点(上)</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/野火Linux/Untitled.html"><span class="label">Untitled</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">问题处理</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/问题处理/2022-11-20-Linux图形界面.html"><span class="label">2022-11-20-Linux图形界面</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2022-8-24-tftp下载.html"><span class="label">2022-8-24-tftp下载</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2022-8-26-uboot设置.html"><span class="label">2022-8-26-uboot设置</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2022-8-27-根文件系统被删除.html"><span class="label">2022-8-27-根文件系统被删除</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2022-8-5-没有release文件.html"><span class="label">2022-8-5-没有release文件</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2022-9-7-备份根文件.html"><span class="label">2022-9-7-备份根文件</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2022-9-9-ubuntu移植问题处理.html"><span class="label">2022-9-9-ubuntu移植问题处理</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2023-11-11-树莓派.html"><span class="label">2023-11-11-树莓派</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2023-6-14-打不开gpedit-msc.html"><span class="label">2023-6-14-打不开gpedit-msc</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2023-6-28-vscode配置.html"><span class="label">2023-6-28-vscode配置</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/Linux/问题处理/2023-8-27-开发板网络设置.html"><span class="label">2023-8-27-开发板网络设置</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">韦东山Linux</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/Linux/韦东山Linux/2025-3-4-基础.html"><span class="label">2025-3-4-基础</span><span class=""></span></a></li>
</ul>
</li>
</ul>

            </div>
        </div>
        <div id="article">
            <div id="menu_wrapper">
                <div id="menu">
                </div>
            </div>
            <div id="content_wrapper">
                <div id="content_body">
                    <div id="article_head">
                        <div id="article_title">
                            
                            <h1>IIO</h1>
                            
                        </div>
                        <div id="article_tags">
                            <ul>
                            
                            </ul>
                        </div>
                        <div id="article_info">
                        <div id="article_info_left">
                            <span class="article_author">
                                
                            </span>
                            
                                <span class="article_date" title="最后修改日期： 2025-12-14">
                                    2025-12-14
                                </span>
                            
                        </div>
                        <div id="article_info_right">
                            
                            <div id="source_link">
                                <a href="https://github.com/XuSenfeng/note/tree/master/doc/Linux/野火Linux/2025-11-22-79-IIO驱动框架.md" target="_blank">
                                    编辑本页
                                </a>
                            </div>
                            
                        </div>
                        </div>
                    </div>
                    <div id="article_tools">
                        <span></span>
                        <span id="toc_btn"></span>
                    </div>
                    <div id="update_history">
                        
                    </div>
                    <div id="article_content">
                        
                            <p>IIO全称是Industrial I/O，翻译过来就是工业 I/O，大家不要看到“工业”两个字就觉得IIO是只用于工业领域的。大家一般在搜索IIO子系统的时候，会发现大多数讲的都是ADC，这是因为IIO就是为ADC类传感器准备的，当然了DAC也是可以的</p>
<p>之前使得的传感器在获取到数据以后, 数据的传输是没有一个规定的格式的, 不同的厂商获取的数据格式是不同的, 所以为了解决这个问题提出IIO子系统</p>
<h2 id="%E4%BD%BF%E7%94%A8">使用</h2>
<h3 id="%E4%BD%BF%E8%83%BD">使能</h3>

<pre class="language-none"><code class="language-none">-&gt; Device Drivers
  -&gt; Industrial I/O support (IIO [=y])
    -&gt; [*]Enable buffer support within IIO //选中
      -&gt; &lt;*&gt;Industrial I/O buffering based on kfifo //选中
</code></pre>
<h3 id="%E4%BD%BF%E7%94%A8">使用</h3>
<p>加载驱动以后会出现在<code>/sys/bus/iio/devices</code>文件夹里面, 对应一个文件夹, 里面的文件是这个驱动端的各种属性, 文件的名字是按照特定格式的, 在读取的时候实际获取的是一个字符串</p>
<h3 id="%E7%BC%96%E5%86%99">编写</h3>
<ul>
<li>使用的是也是的IIC之类的驱动框架, 在里面为不同的设备的属性创建自己使用的的通道, 记录在<code>struct iio_chan_spec</code>数组里面</li>
<li>初始化<code>struct iio_info</code>里面的函数, 用于实际的读写, 在这个回调函数里面判断通道来决定返回值, 读取函数return的值是返回的数据的解释方式</li>
<li>使用上面的两个结构体初始化使用<code>devm_iio_device_alloc</code>申请的<code>iio_dev</code>, 进一步使用<code>iio_device_register</code>进行注册</li>
</ul>
<h2 id="IIO%E9%A9%B1%E5%8A%A8">IIO驱动</h2>
<h3 id="iio_dev">iio_dev</h3>
<h4 id="%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</h4>

<pre class="language-c"><code class="language-c">/**
 * struct iio_dev - industrial I/O device
 * @id:			[INTERN] used to identify device internally
 * @modes:		[DRIVER] operating modes supported by device
 * @currentmode:	[DRIVER] current operating mode
 * @dev:		[DRIVER] device structure, should be assigned a parent
 *			and owner
 * @event_interface:	[INTERN] event chrdevs associated with interrupt lines
 * @buffer:		[DRIVER] any buffer present
 * @buffer_list:	[INTERN] list of all buffers currently attached
 * @scan_bytes:		[INTERN] num bytes captured to be fed to buffer demux
 * @mlock:		[INTERN] lock used to prevent simultaneous device state
 *			changes
 * @available_scan_masks: [DRIVER] optional array of allowed bitmasks
 * @masklength:		[INTERN] the length of the mask established from
 *			channels
 * @active_scan_mask:	[INTERN] union of all scan masks requested by buffers
 * @scan_timestamp:	[INTERN] set if any buffers have requested timestamp
 * @scan_index_timestamp:[INTERN] cache of the index to the timestamp
 * @trig:		[INTERN] current device trigger (buffer modes)
 * @pollfunc:		[DRIVER] function run on trigger being received
 * @channels:		[DRIVER] channel specification structure table
 * @num_channels:	[DRIVER] number of channels specified in @channels.
 * @channel_attr_list:	[INTERN] keep track of automatically created channel
 *			attributes
 * @chan_attr_group:	[INTERN] group for all attrs in base directory
 * @name:		[DRIVER] name of the device.
 * @info:		[DRIVER] callbacks and constant info from driver
 * @info_exist_lock:	[INTERN] lock to prevent use during removal
 * @setup_ops:		[DRIVER] callbacks to call before and after buffer
 *			enable/disable
 * @chrdev:		[INTERN] associated character device
 * @groups:		[INTERN] attribute groups
 * @groupcounter:	[INTERN] index of next attribute group
 * @flags:		[INTERN] file ops related flags including busy flag.
 * @debugfs_dentry:	[INTERN] device specific debugfs dentry.
 * @cached_reg_addr:	[INTERN] cached register address for debugfs reads.
 */
struct iio_dev {
    int				id;

    int				modes; // 设备支持的模式
    int				currentmode; // 当前的模式
    struct device			dev;

    struct iio_event_interface	*event_interface;

    struct iio_buffer		*buffer; // 缓冲区
    struct list_head		buffer_list;
    int				scan_bytes; // 获取到给缓冲区的数据个数
    struct mutex			mlock;
    // 可选的扫描位掩码，使用触发缓冲区的时候可以通过设
    // 置掩码来确定使能哪些通道，使能以后的通道会将捕获到的数据发送到 IIO缓冲区
    const unsigned long		*available_scan_masks;
    unsigned			masklength;
  // 为缓冲区已经开启的通道掩码。只有这些使能了的通道数据
    // 才能被发送到缓冲区
    const unsigned long		*active_scan_mask;
  // 为扫描时间戳，如果使能以后会将捕获时间戳放到缓冲区里面
    bool				scan_timestamp;
    unsigned			scan_index_timestamp;
  // 当前触发器，当使用缓冲模式的时候
    struct iio_trigger		*trig;
    struct iio_poll_func		*pollfunc;
    //  IIO 设备通道, 表示设备的测量通道
    struct iio_chan_spec const	*channels;
    int				num_channels; // 通道的数量

    struct list_head		channel_attr_list;
    struct attribute_group		chan_attr_group;
    const char			*name; // 名字
  // 里面有很多函数，需要驱动开发人员编
    // 写，非常重要！我们从用户空间读取 IIO设备内部数据，
  // 最终调用的就是 iio_info里面的函数
    const struct iio_info		*info;
    struct mutex			info_exist_lock;
  // 一些回调函数，在使能或禁用缓冲区的时候会调用
  // 如果未指定的话就默认使用iio_triggered_buffer_setup_ops`
    const struct iio_buffer_setup_ops	*setup_ops;
    struct cdev			chrdev;
#define IIO_MAX_GROUPS 6
    const struct attribute_group	*groups[IIO_MAX_GROUPS + 1];
    int				groupcounter;

    unsigned long			flags;
#if defined(CONFIG_DEBUG_FS)
    struct dentry			*debugfs_dentry;
    unsigned			cached_reg_addr;
#endif
};
</code></pre>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/mac-picture/image-20251123221916970.png" alt="image-20251123221916970" /></p>

<pre class="language-c"><code class="language-c">struct iio_buffer_setup_ops {
    int (*preenable)(struct iio_dev *); /* 缓冲区使能之前调用 */
    int (*postenable)(struct iio_dev *); /* 缓冲区使能之后调用 */
    int (*predisable)(struct iio_dev *); /* 缓冲区禁用之前调用 */
    int (*postdisable)(struct iio_dev *); /* 缓冲区禁用之后调用 */
    bool (*validate_scan_mask)(struct iio_dev *indio_dev,
    const unsigned long *scan_mask); /* 检查扫描掩码是否有效 */
};
</code></pre>
<h4 id="API">API</h4>
<h6 id="%E7%94%B3%E8%AF%B7">申请</h6>

<pre class="language-c"><code class="language-c">struct iio_dev *iio_device_alloc(int sizeof_priv);
void iio_device_free(struct iio_dev *indio_dev);
</code></pre>
<ul>
<li><strong>sizeof_priv</strong>私有数据内存空间大小，一般我们会将自己定义的设备结构体变量作为 iio_dev 的私有数据，这样可以直接通过 iio_device_alloc 函数同时完成 iio_dev 和设备结构体变量的内存申请。申请成功以后使用<code>iio_priv</code>函数来得到自定义的设备结构体变量首地址</li>
</ul>

<pre class="language-c"><code class="language-c">struct icm20608_dev *dev;
struct iio_dev *indio_dev;

/* 1、申请 iio_dev内存 */
indio_dev = iio_device_alloc(sizeof(*dev));
if (!indio_dev)
    	return -ENOMEM;

/* 2、获取设备结构体变量地址 */
dev = iio_priv(indio_dev);
</code></pre>
<h6 id="%E6%B3%A8%E5%86%8C">注册</h6>

<pre class="language-c"><code class="language-c">int iio_device_register(struct iio_dev *indio_dev);
int iio_device_register(struct iio_dev *indio_dev)
</code></pre>
<h3 id="iio_info%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0">iio_info操作函数</h3>

<pre class="language-c"><code class="language-c">/**
 * struct iio_info - constant information about device
 * @driver_module:	module structure used to ensure correct
 *			ownership of chrdevs etc
 * @event_attrs:	event control attributes
 * @attrs:		general purpose device attributes
 * @read_raw:		function to request a value from the device.
 *			mask specifies which value. Note 0 means a reading of
 *			the channel in question.  Return value will specify the
 *			type of value returned by the device. val and val2 will
 *			contain the elements making up the returned value.
 * @read_raw_multi:	function to return values from the device.
 *			mask specifies which value. Note 0 means a reading of
 *			the channel in question.  Return value will specify the
 *			type of value returned by the device. vals pointer
 *			contain the elements making up the returned value.
 *			max_len specifies maximum number of elements
 *			vals pointer can contain. val_len is used to return
 *			length of valid elements in vals.
 * @write_raw:		function to write a value to the device.
 *			Parameters are the same as for read_raw.
 * @write_raw_get_fmt:	callback function to query the expected
 *			format/precision. If not set by the driver, write_raw
 *			returns IIO_VAL_INT_PLUS_MICRO.
 * @read_event_config:	find out if the event is enabled.
 * @write_event_config:	set if the event is enabled.
 * @read_event_value:	read a configuration value associated with the event.
 * @write_event_value:	write a configuration value for the event.
 * @validate_trigger:	function to validate the trigger when the
 *			current trigger gets changed.
 * @update_scan_mode:	function to configure device and scan buffer when
 *			channels have changed
 * @debugfs_reg_access:	function to read or write register value of device
 * @of_xlate:		function pointer to obtain channel specifier index.
 *			When #iio-cells is greater than '0', the driver could
 *			provide a custom of_xlate function that reads the
 *			*args* and returns the appropriate index in registered
 *			IIO channels array.
 * @hwfifo_set_watermark: function pointer to set the current hardware
 *			fifo watermark level; see hwfifo_* entries in
 *			Documentation/ABI/testing/sysfs-bus-iio for details on
 *			how the hardware fifo operates
 * @hwfifo_flush_to_buffer: function pointer to flush the samples stored
 *			in the hardware fifo to the device buffer. The driver
 *			should not flush more than count samples. The function
 *			must return the number of samples flushed, 0 if no
 *			samples were flushed or a negative integer if no samples
 *			were flushed and there was an error.
 **/
struct iio_info {
    struct module			*driver_module;
    struct attribute_group		*event_attrs;
    const struct attribute_group	*attrs;
    // 读取原始数据, 最终的操作函数
  // indio_dev: 需要控制的设备
  // chan: 控制的通道
  // val，val2: read_raw这两个就是应用程序从内核空间读取到数
    // 					 据，一般就是传感器指定通道值，或者传感器的量程、分辨率等
  // 					 val和val2共同组成具体值，val是整数部分，val2是小数部分。但是
    // 					 val2也是对具体的小数部分扩大N倍后的整数值，因为不能直接从内核
  //					 向应用程序返回一个小数值, 扩大的倍数我们不能随便设置，而是要使用 Linux定义的倍数
  // mask: 掩码，用于指定我们读取的是什么数据，比如 ICM20608这样的传感器，他既有原
    // 			 始的测量数据，比如 X,Y,Z 轴的陀螺仪、加速度计等，也有测量范围值，或者分辨率
    int (*read_raw)(struct iio_dev *indio_dev,
    		struct iio_chan_spec const *chan,
    		int *val,
    		int *val2,
    		long mask);

    int (*read_raw_multi)(struct iio_dev *indio_dev,
    		struct iio_chan_spec const *chan,
    		int max_len,
    		int *vals,
    		int *val_len,
    		long mask);
    // 写原始数据, 一般是用于配置的时候
  // val，val2: 程序向设备写入的数据
    int (*write_raw)(struct iio_dev *indio_dev,
    		 struct iio_chan_spec const *chan,
    		 int val,
    		 int val2,
    		 long mask);
    // 用于设置用户空间向内核空间写入的数据格式, 决定了 wtite_raw 
  // 函数中 val 和 val2 的意义, 设置实际使用的 IIO_VAL_XXX
    int (*write_raw_get_fmt)(struct iio_dev *indio_dev,
    		 struct iio_chan_spec const *chan,
    		 long mask);
...
};
</code></pre>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/mac-picture/image-20251123225208106.png" alt="image-20251123225208106" /></p>
<blockquote>
<p>val1以及val2可以使用的模式</p>
</blockquote>
<h3 id="iio_chan_spec%E9%80%9A%E9%81%93">iio_chan_spec通道</h3>
<p>IIO的核心就是通道，一个传感器可能有多路数据，比如一个ADC芯片支持 8路采集，那么这个ADC就有8个通道</p>

<pre class="language-c"><code class="language-c">/**
 * struct iio_chan_spec - specification of a single channel
 * @type:		What type of measurement is the channel making.
 * @channel:		What number do we wish to assign the channel.
 * @channel2:		If there is a second number for a differential
 *			channel then this is it. If modified is set then the
 *			value here specifies the modifier.
 * @address:		Driver specific identifier.
 * @scan_index:		Monotonic index to give ordering in scans when read
 *			from a buffer.
 * @scan_type:		Sign:		's' or 'u' to specify signed or unsigned
 *			realbits:	Number of valid bits of data
 *			storage_bits:	Realbits + padding
 *			shift:		Shift right by this before masking out
 *					realbits.
 *			endianness:	little or big endian
 *			repeat:		Number of times real/storage bits
 *					repeats. When the repeat element is
 *					more than 1, then the type element in
 *					sysfs will show a repeat value.
 *					Otherwise, the number of repetitions is
 *					omitted.
 * @info_mask_separate: What information is to be exported that is specific to
 *			this channel.
 * @info_mask_shared_by_type: What information is to be exported that is shared
 *			by all channels of the same type.
 * @info_mask_shared_by_dir: What information is to be exported that is shared
 *			by all channels of the same direction.
 * @info_mask_shared_by_all: What information is to be exported that is shared
 *			by all channels.
 * @event_spec:		Array of events which should be registered for this
 *			channel.
 * @num_event_specs:	Size of the event_spec array.
 * @ext_info:		Array of extended info attributes for this channel.
 *			The array is NULL terminated, the last element should
 *			have its name field set to NULL.
 * @extend_name:	Allows labeling of channel attributes with an
 *			informative name. Note this has no effect codes etc,
 *			unlike modifiers.
 * @datasheet_name:	A name used in in-kernel mapping of channels. It should
 *			correspond to the first name that the channel is referred
 *			to by in the datasheet (e.g. IND), or the nearest
 *			possible compound name (e.g. IND-INC).
 * @modified:		Does a modifier apply to this channel. What these are
 *			depends on the channel type.  Modifier is set in
 *			channel2. Examples are IIO_MOD_X for axial sensors about
 *			the 'x' axis.
 * @indexed:		Specify the channel has a numerical index. If not,
 *			the channel index number will be suppressed for sysfs
 *			attributes but not for event codes.
 * @output:		Channel is output.
 * @differential:	Channel is differential.
 */
struct iio_chan_spec {
    enum iio_chan_type	type; // 通道类型
    int			channel; // indexed为1的时候, 记录通道的索引
    int			channel2;// modified为1的时候，channel2为通道修饰符
    unsigned long		address; // 可以自定义
    int			scan_index; // 使用触发缓冲区的时候, 记录索引
    struct {
    	char	sign;// ‘u’表示数据为无符号类型，为‘s’的话为有符号类型
    	u8	realbits; // 数据真实的有效位数
    	u8	storagebits; // 存储位数，有效位数+填充位
    	u8	shift; // 右移位数，也就是存储位数和有效位数不一致的时候
    	u8	repeat; // 实际或存储位的重复数量
    // 数据的大小端模式，可设置为IIO_CPU、IIO_BE(大端)或IIO_LE(小端)
    	enum iio_endian endianness;
    } scan_type; // 扫描数据在缓冲区中的存储格式
  // 标记某些属性专属于此通道
    long			info_mask_separate;
  // 标记导出的信息由相同类型的通道共享
  // 例: 使能 IIO_CHAN_INFO_SCALE这个属性，表示这
    // 三个通道的分辨率是共用的，这样在 sysfs下就会只生成一个描述分辨率的文件，这三个通道都
    // 可以使用这一个分辨率文件
    long			info_mask_shared_by_type;
  // 标记某些导出的信息由相同方向的通道共享
    long			info_mask_shared_by_dir;
  // 表设计某些信息所有的通道共享
    long			info_mask_shared_by_all;
    const struct iio_event_spec *event_spec;
    unsigned int		num_event_specs;
    const struct iio_chan_spec_ext_info *ext_info;
    const char		*extend_name;
    const char		*datasheet_name;
  // 为1的时候，channel2为通道修饰符
    unsigned		modified:1;
  // 为1的时候，channel为通道索引
    unsigned		indexed:1;
    unsigned		output:1; // 表示为输出通道
    unsigned		differential:1; // 表示为差分通道
};
</code></pre>
<h4 id="%E7%B1%BB%E5%9E%8B">类型</h4>

<pre class="language-c"><code class="language-c">enum iio_chan_type {
    IIO_VOLTAGE, /* 14 IIO_VOLTAGE, /* 电压类型 */
    IIO_CURRENT, /* 15 IIO_CURRENT, /* 电流类型 */
    IIO_POWER, /* 16 IIO_POWER, /* 功率类型 */
    IIO_ACCEL, /* 17 IIO_ACCEL, /* 加速度类型 */
    IIO_ANGL_VEL, /* 18 IIO_ANGL_VEL, /* 角度类型(陀螺仪) */
    IIO_MAGN, /* 电磁类型(磁力计) */
    IIO_LIGHT, /* 灯光类型 */
    IIO_INTENSITY, /* 强度类型(光强传感器) */
    IIO_PROXIMITY, /* 接近类型(接近传感器) */
    IIO_TEMP, /* 温度类型 */
    IIO_INCLI, /* 倾角类型(倾角测量传感器) */
    IIO_ROT, /* 旋转角度类型 */
    IIO_ANGL, /* 转动角度类型(电机旋转角度测量传感器) */
    IIO_TIMESTAMP, /* 时间戳类型 */
    IIO_CAPACITANCE, /* 电容类型 */
    IIO_ALTVOLTAGE, /* 频率类型 */
    IIO_CCT, /* 笔者暂时未知的类型 */
    IIO_PRESSURE, /* 压力类型 */
    IIO_HUMIDITYRELATIVE, /* 湿度类型 */
    IIO_ACTIVITY, /* 活动类型(计步传感器) */
    IIO_STEPS, /* 步数类型 */
    IIO_ENERGY, /* 能量类型(卡路里) */
    IIO_DISTANCE, /* 距离类型 */
    IIO_VELOCITY, /* 速度类型 */
    IIO_LIGHT, /* 灯光类型 */
    IIO_INTENSITY, /* 强度类型(光强传感器) */
    IIO_PROXIMITY, /* 接近类型(接近传感器) */
    IIO_TEMP, /* 温度类型 */
    IIO_INCLI, /* 倾角类型(倾角测量传感器) */
    IIO_ROT, /* 旋转角度类型 */
    IIO_ANGL, /* 转动角度类型(电机旋转角度测量传感器) */
    IIO_TIMESTAMP, /* 时间戳类型 */
    IIO_CAPACITANCE, /* 电容类型 */
    IIO_ALTVOLTAGE, /* 频率类型 */
    IIO_CCT, /* 笔者暂时未知的类型 */
    IIO_PRESSURE, /* 压力类型 */
    IIO_HUMIDITYRELATIVE, /* 湿度类型 */
    IIO_ACTIVITY, /* 活动类型(计步传感器) */
    IIO_STEPS, /* 步数类型 */
    IIO_ENERGY, /* 能量类型(卡路里) */
    IIO_DISTANCE, /* 距离类型 */
    IIO_VELOCITY, /* 速度类型 */
};
</code></pre>
<h4 id="%E4%BF%AE%E9%A5%B0%E7%AC%A6">修饰符</h4>
<p>主要是影响 sysfs下的通道文件名字</p>

<pre class="language-c"><code class="language-c">enum iio_modifier {
    IIO_NO_MOD,
    IIO_MOD_X,
    IIO_MOD_Y,
    IIO_MOD_Z,
    IIO_MOD_X_AND_Y,
    IIO_MOD_X_AND_Z,
    IIO_MOD_Y_AND_Z,
    IIO_MOD_X_AND_Y_AND_Z,
    IIO_MOD_X_OR_Y,
    IIO_MOD_X_OR_Z,
    IIO_MOD_Y_OR_Z,
    IIO_MOD_X_OR_Y_OR_Z,
    IIO_MOD_LIGHT_BOTH,
    IIO_MOD_LIGHT_IR,
    IIO_MOD_ROOT_SUM_SQUARED_X_Y,
    IIO_MOD_SUM_SQUARED_X_Y_Z,
    IIO_MOD_LIGHT_CLEAR,
    IIO_MOD_LIGHT_RED,
    IIO_MOD_LIGHT_GREEN,
    IIO_MOD_LIGHT_BLUE,
    IIO_MOD_QUATERNION,
    IIO_MOD_TEMP_AMBIENT,
    IIO_MOD_TEMP_OBJECT,
    IIO_MOD_NORTH_MAGN,
    IIO_MOD_NORTH_TRUE,
    IIO_MOD_NORTH_MAGN_TILT_COMP,
    IIO_MOD_NORTH_TRUE_TILT_COMP,
    IIO_MOD_RUNNING,
    IIO_MOD_JOGGING,
    IIO_MOD_WALKING,
    IIO_MOD_STILL,
    IIO_MOD_ROOT_SUM_SQUARED_X_Y_Z,
};
</code></pre>
<h4 id="%E4%B8%93%E5%B1%9E%E5%B1%9E%E6%80%A7">专属属性</h4>

<pre class="language-c"><code class="language-c">    IIO_CHAN_INFO_RAW = 0, // 原始数据
    IIO_CHAN_INFO_PROCESSED,
    IIO_CHAN_INFO_SCALE, // 分辨率
    IIO_CHAN_INFO_OFFSET,
    IIO_CHAN_INFO_CALIBSCALE,
    IIO_CHAN_INFO_CALIBBIAS, // 校准
    IIO_CHAN_INFO_PEAK,
    IIO_CHAN_INFO_PEAK_SCALE,
    IIO_CHAN_INFO_QUADRATURE_CORRECTION_RAW,
    IIO_CHAN_INFO_AVERAGE_RAW,
    IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY,
    IIO_CHAN_INFO_SAMP_FREQ,
    IIO_CHAN_INFO_FREQUENCY,
    IIO_CHAN_INFO_PHASE,
    IIO_CHAN_INFO_HARDWAREGAIN,
    IIO_CHAN_INFO_HYSTERESIS,
    IIO_CHAN_INFO_INT_TIME,
    IIO_CHAN_INFO_ENABLE,
    IIO_CHAN_INFO_CALIBHEIGHT,
    IIO_CHAN_INFO_CALIBWEIGHT,
    IIO_CHAN_INFO_DEBOUNCE_COUNT,
    IIO_CHAN_INFO_DEBOUNCE_TIME,
};
</code></pre>
<h2 id="%E7%BC%96%E5%86%99%E9%A9%B1%E5%8A%A8">编写驱动</h2>
<h3 id="IIC%E9%A9%B1%E5%8A%A8">IIC驱动</h3>

<pre class="language-c"><code class="language-c">/***************************************************************
Copyright © ALIENTEK Co., Ltd. 1998-2029. All rights reserved.
文件名		: ap3216c.c
作者	  	: 正点原子Linux团队
版本	   	: V1.0
描述	   	: AP3216C驱动程序
其他	   	: 无
论坛 	   	: www.openedv.com
日志	   	: 初版V1.0 2021/03/19 正点原子Linux团队创建
    		 V1.1 2021/03/19
    		 使用regmap来访问寄存器	
***************************************************************/
#include &lt;linux/types.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/delay.h&gt;
#include &lt;linux/ide.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/errno.h&gt;
#include &lt;linux/gpio.h&gt;
#include &lt;linux/cdev.h&gt;
#include &lt;linux/device.h&gt;
#include &lt;linux/of_gpio.h&gt;
#include &lt;linux/semaphore.h&gt;
#include &lt;linux/timer.h&gt;
#include &lt;linux/i2c.h&gt;
#include &lt;asm/mach/map.h&gt;
#include &lt;asm/uaccess.h&gt;
#include &lt;asm/io.h&gt;
#include &lt;linux/regmap.h&gt;
#include &lt;linux/iio/iio.h&gt;
#include &lt;linux/iio/sysfs.h&gt;
#include &lt;linux/iio/trigger_consumer.h&gt;
#include &lt;linux/iio/buffer.h&gt;
#include &lt;linux/iio/triggered_buffer.h&gt;
#include &lt;linux/unaligned/be_byteshift.h&gt;
#include &lt;linux/iio/trigger.h&gt;
#include &quot;ap3216creg.h&quot;

#define AP3216C_NAME			&quot;ap3216c&quot;

/* 
 * AP3216C的扫描元素，1路ALS(环境关)，1路PS(距离传感器)，1路IR
 */
enum inv_icm20608_scan {
    AP3216C_ALS,
    AP3216C_PS,
    AP3216C_IR,
};

/* 
 * ap3216c环境光传感器分辨率,扩大1000000倍,
 * 量程依次为0～20661，0～5162，0～1291，0～323。单位：lux
 */
static const int als_scale_ap3216c[] = {315000, 78800, 19700, 4900};

struct ap3216c_dev {
    struct i2c_client *client;	/* i2c 设备 */
    struct regmap *regmap;				/* regmap */
    struct regmap_config regmap_config;	
    struct mutex lock;
    struct iio_trigger  *trig;
};

/*
 * ap3216c通道，1路ALS(环境关)，1路PS(距离传感器)，1路IR
 */
static const struct iio_chan_spec ap3216c_channels[] = {
    /* ALS通道 */
    {
    	.type = IIO_INTENSITY,
    	.modified = 1,
    	.channel2 = IIO_MOD_LIGHT_BOTH,
    	.address = AP3216C_ALSDATALOW,
    	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |
    		BIT(IIO_CHAN_INFO_SCALE),
    	.scan_index = AP3216C_ALS,
    	.scan_type = {
    		.sign = 'u',
    		.realbits = 16,
    		.storagebits = 16,
    		.endianness = IIO_LE,
    	},
    },

    /* PS通道 */
    {
    	.type = IIO_PROXIMITY,
    	.address = AP3216C_PSDATALOW,
    	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),
    	.scan_index = AP3216C_PS,
    	.scan_type = {
    		.sign = 'u',
    		.realbits = 10,
    		.storagebits = 16,
    		.endianness = IIO_LE,
    	},
    },

    /* IR通道 */
    {
    	.type = IIO_INTENSITY,
    	.modified = 1,
    	.channel2 = IIO_MOD_LIGHT_IR,
    	.address = AP3216C_IRDATALOW,
    	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),
    	.scan_index = AP3216C_IR,
    	.scan_type = {
    		.sign = 'u',
    		.realbits = 10,
    		.storagebits = 16,
    		.endianness = IIO_LE,
    	},
    },
};

/*
 * 扫描掩码，两种情况，全启动0X111，或者都不启动0X0
 */
static const unsigned long ap3216c_scan_masks[] = {
    BIT(AP3216C_ALS)
    | BIT(AP3216C_PS)
    | BIT(AP3216C_IR),
    0,
};

/*
 * @description	: 读取ap3216c指定寄存器值，读取一个寄存器
 * @param - dev:  ap3216c设备
 * @param - reg:  要读取的寄存器
 * @return 	  :   读取到的寄存器值
 */
static unsigned char ap3216c_read_reg(struct ap3216c_dev *dev, u8 reg)
{
    u8 ret;
    unsigned int data;

    ret = regmap_read(dev-&gt;regmap, reg, &amp;data);
    return (u8)data;
}

/*
 * @description	: 向ap3216c指定寄存器写入指定的值，写一个寄存器
 * @param - dev:  ap3216c设备
 * @param - reg:  要写的寄存器
 * @param - data: 要写入的值
 * @return   :    无
 */
static void ap3216c_write_reg(struct ap3216c_dev *dev, u8 reg, u8 data)
{
    regmap_write(dev-&gt;regmap, reg, data);
}

/*
 * @description		: 初始化AP3216C
 * @param - dev 	: 要初始化的ap3216c设备
 * @return 			: 0 成功;其他 失败
 */
static int ap3216c_reginit(struct ap3216c_dev *dev)
{
    /* 初始化AP3216C */
    ap3216c_write_reg(dev, AP3216C_SYSTEMCONG, 0x04);		/* 复位AP3216C 			*/
    mdelay(50);												/* AP3216C复位最少10ms 	*/
    ap3216c_write_reg(dev, AP3216C_SYSTEMCONG, 0X03);		/* 开启ALS、PS+IR 		*/
    ap3216c_write_reg(dev, AP3216C_ALSCONFIG, 0X00);		/* ALS单次转换触发，量程为0～20661 lux */
    ap3216c_write_reg(dev, AP3216C_PSLEDCONFIG, 0X13);		/* IR LED 1脉冲，驱动电流100%*/

    return 0;
}

/*
  * @description  	: 读取AP3216C传感器数
  * @param - dev	: ap3216c设备 
  * @param - reg  	: 要读取的通道寄存器首地址。
  * @param - chann2 : 需要读取的通道，比如ALS，IR。
  * @param - val  	: 保存读取到的值。
  * @return			: 0，成功；其他值，错误
  */
static int ap3216c_read_alsir_data(struct ap3216c_dev *dev, int reg,
    			   int chann2, int *val)
{
    int ret = 0;
    unsigned char data[2];

    switch (chann2) {
    case IIO_MOD_LIGHT_BOTH:	/* 读取ALS数据 */
    	ret = regmap_bulk_read(dev-&gt;regmap, reg, data, 2);
    	*val = ((int)data[1] &lt;&lt; 8) | data[0];   
    	break;
    case IIO_MOD_LIGHT_IR:		/* 读取IR数据 */
    	ret = regmap_bulk_read(dev-&gt;regmap, reg, data, 2);
    	*val = ((int)data[1] &lt;&lt; 2) | (data[0] &amp; 0X03); 
    	break;
    default:
    	ret = -EINVAL;
    	break;
    }

    if (ret) {
    	return -EINVAL;
    }
    	
    return IIO_VAL_INT;
}
/*
  * @description  	: 设置AP3216C的ALS量程(分辨率)
  * @param - dev	: ap3216c设备
  * @param - val   	: 量程(分辨率值)。
  * @param - chann2 : 需要设置的通道。
  * @return			: 0，成功；其他值，错误
  */
static int ap3216c_write_als_scale(struct ap3216c_dev *dev, int chann2, int val)
{
    int ret = 0, i;	
    u8 d;

    switch (chann2) {
    case IIO_MOD_LIGHT_BOTH:	/* 设置ALS分辨率 */
    	for (i = 0; i &lt; ARRAY_SIZE(als_scale_ap3216c); ++i) {
    		if (als_scale_ap3216c[i] == val) {
    			d = (i &lt;&lt; 4);
    			ret = regmap_write(dev-&gt;regmap, AP3216C_ALSCONFIG, d);
    		}
    	}
    	break;
    default:
    	ret = -EINVAL;
    	break;
    }
    	
    return ret;
}

/*
  * @description     	: 读函数，当读取sysfs中的文件的时候最终此函数会执行，此函数
  * 					：里面会从传感器里面读取各种数据，然后上传给应用。
  * @param - indio_dev	: iio_dev
  * @param - chan   	: 通道
  * @param - val   		: 读取的值，如果是小数值的话，val是整数部分。
  * @param - val2   	: 读取的值，如果是小数值的话，val2是小数部分。
  * @return				: 0，成功；其他值，错误
  */
static int ap3216c_read_raw(struct iio_dev *indio_dev,
    		   struct iio_chan_spec const *chan,
    		   int *val, int *val2, long mask)
{
    int ret = 0;
    unsigned char data[2];
    unsigned char regdata = 0;
    struct ap3216c_dev *dev = iio_priv(indio_dev);

    switch (mask) {
    case IIO_CHAN_INFO_RAW:								/* 读取ICM20608加速度计、陀螺仪、温度传感器原始值 */
    	mutex_lock(&amp;dev-&gt;lock);								/* 上锁 			*/
    	switch (chan-&gt;type) {
    	case IIO_INTENSITY:
    		ret = ap3216c_read_alsir_data(dev, chan-&gt;address, chan-&gt;channel2, val); /* 读取ALS */
    		break;				/* 值为val */
    	case IIO_PROXIMITY:
    		ret = regmap_bulk_read(dev-&gt;regmap, chan-&gt;address, data, 2);
    		*val = ((int)(data[1] &amp; 0X3F) &lt;&lt; 4) | (data[0] &amp; 0X0F);  
    		ret = IIO_VAL_INT; 	/* 值为val */
    		break;
    	default:
    		ret = -EINVAL;
    		break;
    	}
    	mutex_unlock(&amp;dev-&gt;lock);							/* 释放锁 			*/
    	return ret;
    case IIO_CHAN_INFO_SCALE:
    	switch (chan-&gt;type) {
    	case IIO_INTENSITY:			/* ALS量程 */
    		mutex_lock(&amp;dev-&gt;lock);
    		regdata = (ap3216c_read_reg(dev, AP3216C_ALSCONFIG) &amp; 0X30) &gt;&gt; 4;
    		*val  = 0;
    		*val2 = als_scale_ap3216c[regdata];
    		mutex_unlock(&amp;dev-&gt;lock);
    		return IIO_VAL_INT_PLUS_MICRO;	/* 值为val+val2/1000000 */
    	default:
    		return -EINVAL;
    	}
    	return ret;
    	
    default:
    	return -EINVAL;
    }
    return ret;
}

 /* @description     	: 写函数，当向sysfs中的文件写数据的时候最终此函数会执行，一般在此函数
  * 					：里面设置传感器，比如量程等。
  * @param - indio_dev	: iio_dev
  * @param - chan   	: 通道
  * @param - val   		: 应用程序写入的值，如果是小数值的话，val是整数部分。
  * @param - val2   	: 应用程序写入的值，如果是小数值的话，val2是小数部分。
  * @return				: 0，成功；其他值，错误
  */
static int ap3216c_write_raw(struct iio_dev *indio_dev,
    		    struct iio_chan_spec const *chan,
    		    int val, int val2, long mask)
{
    int ret = 0;
    struct ap3216c_dev *dev = iio_priv(indio_dev);

    switch (mask) {
    case IIO_CHAN_INFO_SCALE:	/* 设置ALS量程 */
    	switch (chan-&gt;type) {
    	case IIO_INTENSITY:		/* 设置ALS量程 */
    		mutex_lock(&amp;dev-&gt;lock);
    		ret = ap3216c_write_als_scale(dev, chan-&gt;channel2, val2);
    		mutex_unlock(&amp;dev-&gt;lock);
    		break;
    	default:
    		ret = -EINVAL;
    		break;
    	}
    	break;
    
    default:
    	ret = -EINVAL;
    	break;
    }

    return ret;
}

/*
  * @description     	: 用户空间写数据格式，比如我们在用户空间操作sysfs来设置传感器的分辨率，
  * 					：如果分辨率带小数，那么这个小数传递到内核空间应该扩大多少倍，此函数就是
  *						: 用来设置这个的。
  * @param - indio_dev	: iio_dev
  * @param - chan   	: 通道
  * @param - mask   	: 掩码
  * @return				: 0，成功；其他值，错误
  */
static int ap3216c_write_raw_get_fmt(struct iio_dev *indio_dev,
    			 struct iio_chan_spec const *chan, long mask)
{
    switch (mask) {
    case IIO_CHAN_INFO_SCALE:
    	switch (chan-&gt;type) {
    	case IIO_INTENSITY:		/* 用户空间写的陀螺仪分辨率数据要乘以1000000 */
    		return IIO_VAL_INT_PLUS_MICRO;
    	default:				
    		return IIO_VAL_INT_PLUS_MICRO;
    	}
    default:
    	return IIO_VAL_INT_PLUS_MICRO;
    }

    return -EINVAL;
}

/*
 * iio_info结构体变量
 */
static const struct iio_info ap3216c_info = {
    .read_raw		= ap3216c_read_raw,
    .write_raw		= ap3216c_write_raw,
    .write_raw_get_fmt = &amp;ap3216c_write_raw_get_fmt,	/* 用户空间写数据格式 */
};

 /*
  * @description     : i2c驱动的probe函数，当驱动与
  *                    设备匹配以后此函数就会执行
  * @param - client  : i2c设备
  * @param - id      : i2c设备ID
  * @return          : 0，成功;其他负值,失败
  */
static int ap3216c_probe(struct i2c_client *client, const struct i2c_device_id *id)
{
    int ret;
    struct ap3216c_dev *dev;
    struct iio_dev *indio_dev;

    /*  1、申请iio_dev内存 */
    indio_dev = devm_iio_device_alloc(&amp;client-&gt;dev, sizeof(*dev));
    if (!indio_dev)
    	return -ENOMEM;

    /* 2、获取ap3216c_dev结构体地址 */
    dev = iio_priv(indio_dev); 
    dev-&gt;client = client;
    
    i2c_set_clientdata(client, indio_dev); /* 保存ap3216cdev结构体 */
    	
    /* 初始化regmap_config设置 */
    dev-&gt;regmap_config.reg_bits = 8;		/* 寄存器长度8bit */
    dev-&gt;regmap_config.val_bits = 8;		/* 值长度8bit */

    /* 初始化IIC接口的regmap */
    dev-&gt;regmap = regmap_init_i2c(client, &amp;dev-&gt;regmap_config);
    if (IS_ERR(dev-&gt;regmap)) {
    	ret = PTR_ERR(dev-&gt;regmap);
    	goto err_regmap_init;
    }	

    mutex_init(&amp;dev-&gt;lock);	

    /* 4、iio_dev的其他成员变量 */
    indio_dev-&gt;dev.parent = &amp;client-&gt;dev;
    indio_dev-&gt;info = &amp;ap3216c_info;
    indio_dev-&gt;name = AP3216C_NAME;	
    indio_dev-&gt;modes = INDIO_DIRECT_MODE;	/* 直接模式，提供sysfs接口 */
    indio_dev-&gt;channels = ap3216c_channels;
    indio_dev-&gt;num_channels = ARRAY_SIZE(ap3216c_channels);
    indio_dev-&gt;available_scan_masks = ap3216c_scan_masks;

    /* 5、注册iio_dev */
    ret = iio_device_register(indio_dev);
    if (ret &lt; 0) {
    	dev_err(&amp;client-&gt;dev, &quot;iio_device_register failed\n&quot;);
    	goto err_iio_register;
    }

    ap3216c_reginit(dev); /* 初始化ap3216c */
    return 0;

err_iio_register:
err_regmap_init:
    iio_device_unregister(indio_dev);
    return ret;
}

/*
 * @description     : i2c驱动的remove函数，移除i2c驱动的时候此函数会执行
 * @param - client 	: i2c设备
 * @return          : 0，成功;其他负值,失败
 */
static int ap3216c_remove(struct i2c_client *client)
{
    struct iio_dev *indio_dev = i2c_get_clientdata(client);
    struct ap3216c_dev *dev;
    
    dev = iio_priv(indio_dev);

    /* 1、释放regmap */
    regmap_exit(dev-&gt;regmap);
    /* 2、注销IIO */
    iio_device_unregister(indio_dev);
    return 0;
}

/* 传统匹配方式ID列表 */
static const struct i2c_device_id ap3216c_id[] = {
    {&quot;alientek,ap3216c&quot;, 0},  
    {}
};

/* 设备树匹配列表 */
static const struct of_device_id ap3216c_of_match[] = {
    { .compatible = &quot;alientek,ap3216c&quot; },
    { /* Sentinel */ }
};

/* i2c驱动结构体 */	
static struct i2c_driver ap3216c_driver = {
    .probe = ap3216c_probe,
    .remove = ap3216c_remove,
    .driver = {
    		.owner = THIS_MODULE,
    	   	.name = &quot;ap3216c&quot;,
    	   	.of_match_table = ap3216c_of_match, 
    	   },
    .id_table = ap3216c_id,
};
    	   
/*
 * @description	: 驱动入口函数
 * @param 		: 无
 * @return 		: 无
 */
static int __init ap3216c_init(void)
{
    int ret = 0;

    ret = i2c_add_driver(&amp;ap3216c_driver);
    return ret;
}

/*
 * @description	: 驱动出口函数
 * @param 		: 无
 * @return 		: 无
 */
static void __exit ap3216c_exit(void)
{
    i2c_del_driver(&amp;ap3216c_driver);
}

/* module_i2c_driver(ap3216c_driver) */

module_init(ap3216c_init);
module_exit(ap3216c_exit);
MODULE_LICENSE(&quot;GPL&quot;);
MODULE_AUTHOR(&quot;ALIENTEK&quot;);
MODULE_INFO(intree, &quot;Y&quot;);
</code></pre>
<h3 id="SPI%E9%A9%B1%E5%8A%A8">SPI驱动</h3>

<pre class="language-c"><code class="language-c">/***************************************************************
Copyright © ALIENTEK Co., Ltd. 1998-2029. All rights reserved.
文件名		: icm20608.c
作者	  	: 正点原子Linux团队
版本	   	: V1.0
描述	   	: ICM20608 SPI驱动程序
其他	   	: 无
论坛 	   	: www.openedv.com
日志	   	: 初版V1.0 2021/03/22 正点原子Linux团队创建
    		  V1.1 2021/08/10 
    		  使用regmap读写SPI外设内部寄存器。

    		  V1.2 2021/08/13 
    		  使用IIO框架，参考bma220_spi.c
***************************************************************/
#include &lt;linux/spi/spi.h&gt;
#include &lt;linux/kernel.h&gt;
#include &lt;linux/module.h&gt;
#include &lt;linux/init.h&gt;
#include &lt;linux/delay.h&gt;
#include &lt;linux/ide.h&gt;
#include &lt;linux/errno.h&gt;
#include &lt;linux/platform_device.h&gt;
#include &quot;icm20608reg.h&quot;
#include &lt;linux/gpio.h&gt;
#include &lt;linux/device.h&gt;
#include &lt;asm/uaccess.h&gt;
#include &lt;linux/cdev.h&gt;
#include &lt;linux/regmap.h&gt;
#include &lt;linux/iio/iio.h&gt;
#include &lt;linux/iio/sysfs.h&gt;
#include &lt;linux/iio/buffer.h&gt;
#include &lt;linux/iio/trigger.h&gt;
#include &lt;linux/iio/triggered_buffer.h&gt;
#include &lt;linux/iio/trigger_consumer.h&gt;
#include &lt;linux/unaligned/be_byteshift.h&gt;

#define ICM20608_NAME	&quot;icm20608&quot;
#define ICM20608_TEMP_OFFSET	     0
#define ICM20608_TEMP_SCALE		     326800000

#define ICM20608_CHAN(_type, _channel2, _index)                    \
    {                                                             \
    	.type = _type,                                        \
    	.modified = 1,                                        \
    	.channel2 = _channel2,                                \
    	.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE), \ // 共用分辨率
    	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) |	      \ // 单独原始数据
    			      BIT(IIO_CHAN_INFO_CALIBBIAS),   \ // 单独校准
    	.scan_index = _index,                                 \
    	.scan_type = {                                        \
    			.sign = 's',                          \
    			.realbits = 16,                       \
    			.storagebits = 16,                    \
    			.shift = 0,                           \
    			.endianness = IIO_BE,                 \
    		     },                                       \
    }

/* 
 * ICM20608的扫描元素，3轴加速度计、
 * 3轴陀螺仪、1路温度传感器，1路时间戳 
 */
enum inv_icm20608_scan {
    INV_ICM20608_SCAN_ACCL_X,
    INV_ICM20608_SCAN_ACCL_Y,
    INV_ICM20608_SCAN_ACCL_Z,
    INV_ICM20608_SCAN_TEMP,
    INV_ICM20608_SCAN_GYRO_X,
    INV_ICM20608_SCAN_GYRO_Y,
    INV_ICM20608_SCAN_GYRO_Z,
    INV_ICM20608_SCAN_TIMESTAMP,
};

struct icm20608_dev {
    struct spi_device *spi;		/* spi设备 */
    struct regmap *regmap;				/* regmap */
    struct regmap_config regmap_config;	
    struct mutex lock;
};

/*
 * icm20608陀螺仪分辨率，对应250、500、1000、2000，计算方法：
 * 以正负250度量程为例，500/2^16=0.007629，扩大1000000倍，就是7629
 */
static const int gyro_scale_icm20608[] = {7629, 15258, 30517, 61035};

/* 
 * icm20608加速度计分辨率，对应2、4、8、16 计算方法：
 * 以正负2g量程为例，4/2^16=0.000061035，扩大1000000000倍，就是61035
 */
static const int accel_scale_icm20608[] = {61035, 122070, 244140, 488281};

/*
 * icm20608通道，1路温度通道，3路陀螺仪，3路加速度计
 */
static const struct iio_chan_spec icm20608_channels[] = {
    /* 温度通道 */
    {
    	.type = IIO_TEMP,
    	.info_mask_separate = BIT(IIO_CHAN_INFO_RAW) // 原始数据
    			| BIT(IIO_CHAN_INFO_OFFSET) // 偏移
    			| BIT(IIO_CHAN_INFO_SCALE), // 分辨率
    	.scan_index = INV_ICM20608_SCAN_TEMP,
    	.scan_type = {
    			.sign = 's',
    			.realbits = 16,
    			.storagebits = 16,
    			.shift = 0,
    			.endianness = IIO_BE,
    		     },
    },
    // 实际只使用到前两个去判断实际获取的是哪一个数据
    ICM20608_CHAN(IIO_ANGL_VEL, IIO_MOD_X, INV_ICM20608_SCAN_GYRO_X),	/* 陀螺仪X轴 */
    ICM20608_CHAN(IIO_ANGL_VEL, IIO_MOD_Y, INV_ICM20608_SCAN_GYRO_Y),	/* 陀螺仪Y轴 */
    ICM20608_CHAN(IIO_ANGL_VEL, IIO_MOD_Z, INV_ICM20608_SCAN_GYRO_Z),	/* 陀螺仪Z轴 */

    ICM20608_CHAN(IIO_ACCEL, IIO_MOD_Y, INV_ICM20608_SCAN_ACCL_Y),	/* 加速度X轴 */
    ICM20608_CHAN(IIO_ACCEL, IIO_MOD_X, INV_ICM20608_SCAN_ACCL_X),	/* 加速度Y轴 */
    ICM20608_CHAN(IIO_ACCEL, IIO_MOD_Z, INV_ICM20608_SCAN_ACCL_Z),	/* 加速度Z轴 */
};

/*
 * @description	: 读取icm20608指定寄存器值，读取一个寄存器
 * @param - dev:  icm20608设备
 * @param - reg:  要读取的寄存器
 * @return 	  :   读取到的寄存器值
 */
static unsigned char icm20608_read_onereg(struct icm20608_dev *dev, u8 reg)
{
    u8 ret;
    unsigned int data;

    ret = regmap_read(dev-&gt;regmap, reg, &amp;data);
    return (u8)data;
}

/*
 * @description	: 向icm20608指定寄存器写入指定的值，写一个寄存器
 * @param - dev:  icm20608设备
 * @param - reg:  要写的寄存器
 * @param - data: 要写入的值
 * @return   :    无
 */	
static void icm20608_write_onereg(struct icm20608_dev *dev, u8 reg, u8 value)
{
    regmap_write(dev-&gt;regmap,  reg, value);
}

/*
 * @description  	: ICM20608内部寄存器初始化函数 
 * @param - spi 	: 要操作的设备
 * @return 			: 无
 */
void icm20608_reginit(struct icm20608_dev *dev)
{
    u8 value = 0;
    
    icm20608_write_onereg(dev, ICM20_PWR_MGMT_1, 0x80);
    mdelay(50);
    icm20608_write_onereg(dev, ICM20_PWR_MGMT_1, 0x01);
    mdelay(50);

    value = icm20608_read_onereg(dev, ICM20_WHO_AM_I);
    printk(&quot;ICM20608 ID = %#X\r\n&quot;, value);	

    icm20608_write_onereg(dev, ICM20_SMPLRT_DIV, 0x00); 	/* 输出速率是内部采样率		*/
    icm20608_write_onereg(dev, ICM20_GYRO_CONFIG, 0x18); 	/* 陀螺仪±2000dps量程 		*/
    icm20608_write_onereg(dev, ICM20_ACCEL_CONFIG, 0x18); 	/* 加速度计±16G量程 		*/
    icm20608_write_onereg(dev, ICM20_CONFIG, 0x04); 		/* 陀螺仪低通滤波BW=20Hz 	*/
    icm20608_write_onereg(dev, ICM20_ACCEL_CONFIG2, 0x04); /* 加速度计低通滤波BW=21.2Hz 	*/
    icm20608_write_onereg(dev, ICM20_PWR_MGMT_2, 0x00); 	/* 打开加速度计和陀螺仪所有轴 	*/
    icm20608_write_onereg(dev, ICM20_LP_MODE_CFG, 0x00); 	/* 关闭低功耗 				*/
    icm20608_write_onereg(dev, ICM20_INT_ENABLE, 0x01);		/* 使能FIFO溢出以及数据就绪中断	*/
}

/*
  * @description  	: 设置ICM20608传感器，可以用于陀螺仪、加速度计设置
  * @param - dev	: icm20608设备 
  * @param - reg  	: 要设置的通道寄存器首地址。
  * @param - anix  	: 要设置的通道，比如X，Y，Z。
  * @param - val  	: 要设置的值。
  * @return			: 0，成功；其他值，错误
  */
static int icm20608_sensor_set(struct icm20608_dev *dev, int reg,
    			int axis, int val)
{
    int ind, result;
    __be16 d = cpu_to_be16(val);

    ind = (axis - IIO_MOD_X) * 2; // 计算出实际的寄存器的偏移的位置
    result = regmap_bulk_write(dev-&gt;regmap, reg + ind, (u8 *)&amp;d, 2);
    if (result)
    	return -EINVAL;

    return 0;
}

/*
  * @description  	: 读取ICM20608传感器数据，可以用于陀螺仪、加速度计、温度的读取
  * @param - dev	: icm20608设备 
  * @param - reg  	: 要读取的通道寄存器首地址。
  * @param - anix  	: 需要读取的通道，比如X，Y，Z。
  * @param - val  	: 保存读取到的值。
  * @return			: 0，成功；其他值，错误
  */
static int icm20608_sensor_show(struct icm20608_dev *dev, int reg,
    			   int axis, int *val)
{
    int ind, result;
    __be16 d;

    ind = (axis - IIO_MOD_X) * 2;
    result = regmap_bulk_read(dev-&gt;regmap, reg + ind, (u8 *)&amp;d, 2);
    if (result)
    	return -EINVAL;
    *val = (short)be16_to_cpup(&amp;d);

    return IIO_VAL_INT;
}

/*
  * @description  		: 读取ICM20608陀螺仪、加速度计、温度通道值
  * @param - indio_dev	: iio设备 
  * @param - chan  		: 通道。
  * @param - val  		: 保存读取到的通道值。
  * @return				: 0，成功；其他值，错误
  */
static int icm20608_read_channel_data(struct iio_dev *indio_dev,
    				 struct iio_chan_spec const *chan,
    				 int *val)
{
    struct icm20608_dev *dev = iio_priv(indio_dev);
    int ret = 0;

    switch (chan-&gt;type) {
    case IIO_ANGL_VEL:	/* 读取陀螺仪数据 */
    	ret = icm20608_sensor_show(dev, ICM20_GYRO_XOUT_H, chan-&gt;channel2, val);  /* channel2为X、Y、Z轴 */
    	break;
    case IIO_ACCEL:		/* 读取加速度计数据 */
    	ret = icm20608_sensor_show(dev, ICM20_ACCEL_XOUT_H, chan-&gt;channel2, val); /* channel2为X、Y、Z轴 */
    	break;
    case IIO_TEMP:		/* 读取温度 */
    	ret = icm20608_sensor_show(dev, ICM20_TEMP_OUT_H, IIO_MOD_X, val);  
    	break;
    default:
    	ret = -EINVAL;
    	break;
    }
    return ret;
}

/*
  * @description  	: 设置ICM20608的陀螺仪计量程(分辨率)
  * @param - dev	: icm20608设备
  * @param - val   	: 量程(分辨率值)。
  * @return			: 0，成功；其他值，错误
  */
static int icm20608_write_gyro_scale(struct icm20608_dev *dev, int val)
{
    int result, i;
    u8 d;

    for (i = 0; i &lt; ARRAY_SIZE(gyro_scale_icm20608); ++i) {
    	if (gyro_scale_icm20608[i] == val) {
    		d = (i &lt;&lt; 3);
    		result = regmap_write(dev-&gt;regmap, ICM20_GYRO_CONFIG, d);
    		if (result)
    			return result;
    		return 0;
    	}
    }
    return -EINVAL;
}

 /*
  * @description  	: 设置ICM20608的加速度计量程(分辨率)
  * @param - dev	: icm20608设备
  * @param - val   	: 量程(分辨率值)。
  * @return			: 0，成功；其他值，错误
  */
static int icm20608_write_accel_scale(struct icm20608_dev *dev, int val)
{
    int result, i;
    u8 d;

    for (i = 0; i &lt; ARRAY_SIZE(accel_scale_icm20608); ++i) {
    	if (accel_scale_icm20608[i] == val) {
    		d = (i &lt;&lt; 3);
    		result = regmap_write(dev-&gt;regmap, ICM20_ACCEL_CONFIG, d);
    		if (result)
    			return result;
    		return 0;
    	}
    }
    return -EINVAL;
}

/*
  * @description     	: 读函数，当读取sysfs中的文件的时候最终此函数会执行，此函数
  * 					：里面会从传感器里面读取各种数据，然后上传给应用。
  * @param - indio_dev	: iio_dev
  * @param - chan   	: 通道
  * @param - val   		: 读取的值，如果是小数值的话，val是整数部分。
  * @param - val2   	: 读取的值，如果是小数值的话，val2是小数部分。
  * @param - mask   	: 掩码。
  * @return				: 0，成功；其他值，错误
  */
static int icm20608_read_raw(struct iio_dev *indio_dev,
    		   struct iio_chan_spec const *chan,
    		   int *val, int *val2, long mask)
{
    struct icm20608_dev *dev = iio_priv(indio_dev);
    int ret = 0;
    unsigned char regdata = 0;

    switch (mask) {
    case IIO_CHAN_INFO_RAW:				/* 读取ICM20608加速度计、陀螺仪、温度传感器原始值 */
    	mutex_lock(&amp;dev-&gt;lock);								/* 上锁 			*/
    	ret = icm20608_read_channel_data(indio_dev, chan, val); 	/* 读取通道值 */
    	mutex_unlock(&amp;dev-&gt;lock);							/* 释放锁 			*/
    	return ret;
    case IIO_CHAN_INFO_SCALE:
    	switch (chan-&gt;type) {
    	case IIO_ANGL_VEL:
    		mutex_lock(&amp;dev-&gt;lock);
      // 从寄存器里面获取当前的分辨率的配置
    		regdata = (icm20608_read_onereg(dev, ICM20_GYRO_CONFIG) &amp; 0X18) &gt;&gt; 3;
    		*val  = 0;
    		*val2 = gyro_scale_icm20608[regdata];
    		mutex_unlock(&amp;dev-&gt;lock);
    		return IIO_VAL_INT_PLUS_MICRO;	/* 值为val+val2/1000000 */
    	case IIO_ACCEL:
    		mutex_lock(&amp;dev-&gt;lock);
    		regdata = (icm20608_read_onereg(dev, ICM20_ACCEL_CONFIG) &amp; 0X18) &gt;&gt; 3;
    		*val = 0;
    		*val2 = accel_scale_icm20608[regdata];;
    		mutex_unlock(&amp;dev-&gt;lock);
    		return IIO_VAL_INT_PLUS_NANO;/* 值为val+val2/1000000000 */
    	case IIO_TEMP:					
    		*val = ICM20608_TEMP_SCALE/ 1000000;
    		*val2 = ICM20608_TEMP_SCALE % 1000000;
    		return IIO_VAL_INT_PLUS_MICRO;	/* 值为val+val2/1000000 */
    	default:
    		return -EINVAL;
    	}
    	return ret;
    case IIO_CHAN_INFO_OFFSET:		/* ICM20608温度传感器offset值 */
    	switch (chan-&gt;type) {
    	case IIO_TEMP:
    		*val = ICM20608_TEMP_OFFSET;
    		return IIO_VAL_INT;
    	default:
    		return -EINVAL;
    	}
    	return ret;
    case IIO_CHAN_INFO_CALIBBIAS:	/* ICM20608加速度计和陀螺仪校准值 */
    	switch (chan-&gt;type) {
    	case IIO_ANGL_VEL:		/* 陀螺仪的校准值 */
    		mutex_lock(&amp;dev-&gt;lock);
    		ret = icm20608_sensor_show(dev, ICM20_XG_OFFS_USRH, chan-&gt;channel2, val);
    		mutex_unlock(&amp;dev-&gt;lock);
    		return ret;
    	case IIO_ACCEL:			/* 加速度计的校准值 */
    		mutex_lock(&amp;dev-&gt;lock);	
    		ret = icm20608_sensor_show(dev, ICM20_XA_OFFSET_H, chan-&gt;channel2, val);
    		mutex_unlock(&amp;dev-&gt;lock);
    		return ret;
    	default:
    		return -EINVAL;
    	}
    	
    default:
    	return ret -EINVAL;
    }
}	

/*
  * @description     	: 写函数，当向sysfs中的文件写数据的时候最终此函数会执行，一般在此函数
  * 					：里面设置传感器，比如量程等。
  * @param - indio_dev	: iio_dev
  * @param - chan   	: 通道
  * @param - val   		: 应用程序写入的值，如果是小数值的话，val是整数部分。
  * @param - val2   	: 应用程序写入的值，如果是小数值的话，val2是小数部分。
  * @return				: 0，成功；其他值，错误
  */
static int icm20608_write_raw(struct iio_dev *indio_dev,
    		    struct iio_chan_spec const *chan,
    		    int val, int val2, long mask)
{
    struct icm20608_dev *dev = iio_priv(indio_dev);
    int ret = 0;

    switch (mask) {
    case IIO_CHAN_INFO_SCALE:	/* 设置陀螺仪和加速度计的分辨率 */
    	switch (chan-&gt;type) {
    	case IIO_ANGL_VEL:		/* 设置陀螺仪 */
    		mutex_lock(&amp;dev-&gt;lock);
    		ret = icm20608_write_gyro_scale(dev, val2);
    		mutex_unlock(&amp;dev-&gt;lock);
    		break;
    	case IIO_ACCEL:			/* 设置加速度计 */
    		mutex_lock(&amp;dev-&gt;lock);
    		ret = icm20608_write_accel_scale(dev, val2);
    		mutex_unlock(&amp;dev-&gt;lock);
    		break;
    	default:
    		ret = -EINVAL;
    		break;
    	}
    	break;
    case IIO_CHAN_INFO_CALIBBIAS:	/* 设置陀螺仪和加速度计的校准值*/
    	switch (chan-&gt;type) {
    	case IIO_ANGL_VEL:		/* 设置陀螺仪校准值 */
    		mutex_lock(&amp;dev-&gt;lock);
    		ret = icm20608_sensor_set(dev, ICM20_XG_OFFS_USRH,
    								    chan-&gt;channel2, val);
    		mutex_unlock(&amp;dev-&gt;lock);
    		break;
    	case IIO_ACCEL:			/* 加速度计校准值 */
    		mutex_lock(&amp;dev-&gt;lock);
    		ret = icm20608_sensor_set(dev, ICM20_XA_OFFSET_H,
    						             chan-&gt;channel2, val);
    		mutex_unlock(&amp;dev-&gt;lock);
    		break;
    	default:
    		ret = -EINVAL;
    		break;
    	}
    	break;
    default:
    	ret = -EINVAL;
    	break;
    }
    return ret;
}

/*
  * @description     	: 用户空间写数据格式，比如我们在用户空间操作sysfs来设置传感器的分辨率，
  * 					：如果分辨率带小数，那么这个小数传递到内核空间应该扩大多少倍，此函数就是
  *						: 用来设置这个的。
  * @param - indio_dev	: iio_dev
  * @param - chan   	: 通道
  * @param - mask   	: 掩码
  * @return				: 0，成功；其他值，错误
  */
static int icm20608_write_raw_get_fmt(struct iio_dev *indio_dev,
    			 struct iio_chan_spec const *chan, long mask)
{
    switch (mask) {
    case IIO_CHAN_INFO_SCALE:
    	switch (chan-&gt;type) {
    	case IIO_ANGL_VEL:		/* 用户空间写的陀螺仪分辨率数据要乘以1000000 */
    		return IIO_VAL_INT_PLUS_MICRO;
    	default:				/* 用户空间写的加速度计分辨率数据要乘以1000000000 */
    		return IIO_VAL_INT_PLUS_NANO;
    	}
    default:
    	return IIO_VAL_INT_PLUS_MICRO;
    }
    return -EINVAL;
}

/*
 * iio_info结构体变量
 */
static const struct iio_info icm20608_info = {
    .read_raw		= icm20608_read_raw,
    .write_raw		= icm20608_write_raw,
    .write_raw_get_fmt = &amp;icm20608_write_raw_get_fmt,	/* 用户空间写数据格式 */
};

/*
  * @description    : spi驱动的probe函数，当驱动与
  *                    设备匹配以后此函数就会执行
  * @param - spi  	: spi设备
  * @return  		: 0,成功；其他值，失败
  */	
static int icm20608_probe(struct spi_device *spi)
{
    int ret;
    struct icm20608_dev *dev;
    struct iio_dev *indio_dev;

    /*  1、申请iio_dev内存 */
    indio_dev = devm_iio_device_alloc(&amp;spi-&gt;dev, sizeof(*dev));
    if (!indio_dev)
    	return -ENOMEM;

    /* 2、获取icm20608_dev结构体地址 */
    dev = iio_priv(indio_dev); 
    dev-&gt;spi = spi;
    spi_set_drvdata(spi, indio_dev);    		/* 将indio_de设置为spi-&gt;dev的driver_data */
    mutex_init(&amp;dev-&gt;lock);

    /* 3、iio_dev的其他成员变量 */
    indio_dev-&gt;dev.parent = &amp;spi-&gt;dev;
    indio_dev-&gt;info = &amp;icm20608_info;
    indio_dev-&gt;name = ICM20608_NAME;	
    indio_dev-&gt;modes = INDIO_DIRECT_MODE;	/* 直接模式，提供sysfs接口 */
    indio_dev-&gt;channels = icm20608_channels;
    indio_dev-&gt;num_channels = ARRAY_SIZE(icm20608_channels);

    /* 4、注册iio_dev */
    ret = iio_device_register(indio_dev);
    if (ret &lt; 0) {
    	dev_err(&amp;spi-&gt;dev, &quot;iio_device_register failed\n&quot;);
    	goto err_iio_register;
    }

    /* 5、初始化regmap_config设置 */
    dev-&gt;regmap_config.reg_bits = 8;			/* 寄存器长度8bit */
    dev-&gt;regmap_config.val_bits = 8;			/* 值长度8bit */
    dev-&gt;regmap_config.read_flag_mask = 0x80;  /* 读掩码设置为0X80，ICM20608使用SPI接口读的时候寄存器最高位应该为1 */

    /* 6、初始化SPI接口的regmap */
    dev-&gt;regmap = regmap_init_spi(spi, &amp;dev-&gt;regmap_config);
    if (IS_ERR(dev-&gt;regmap)) {
    	ret = PTR_ERR(dev-&gt;regmap);
    	goto err_regmap_init;
    }

    /* 7、初始化spi_device */
    spi-&gt;mode = SPI_MODE_0;	/*MODE0，CPOL=0，CPHA=0*/
    spi_setup(spi);
    
    /* 初始化ICM20608内部寄存器 */
    icm20608_reginit(dev);	
    return 0;

err_regmap_init:
    iio_device_unregister(indio_dev);
err_iio_register:
    return ret;
}

/*
 * @description     : spi驱动的remove函数，移除spi驱动的时候此函数会执行
 * @param - spi 	: spi设备
 * @return          : 0，成功;其他负值,失败
 */
static int icm20608_remove(struct spi_device *spi)
{
    struct iio_dev *indio_dev = spi_get_drvdata(spi);
    struct icm20608_dev *dev;
    
    dev = iio_priv(indio_dev);

    /* 1、删除regmap */ 
    regmap_exit(dev-&gt;regmap);

    /* 2、注销IIO */
    iio_device_unregister(indio_dev);
    return 0;
}

/* 传统匹配方式ID列表 */
static const struct spi_device_id icm20608_id[] = {
    {&quot;alientek,icm20608&quot;, 0},
    {}
};

/* 设备树匹配列表 */
static const struct of_device_id icm20608_of_match[] = {
    { .compatible = &quot;alientek,icm20608&quot; },
    { /* Sentinel */ }
};

/* SPI驱动结构体 */
static struct spi_driver icm20608_driver = {
    .probe = icm20608_probe,
    .remove = icm20608_remove,
    .driver = {
    		.owner = THIS_MODULE,
    	   	.name = &quot;icm20608&quot;,
    	   	.of_match_table = icm20608_of_match,
    	   },
    .id_table = icm20608_id,
};

/*
 * @description	: 驱动入口函数
 * @param 		: 无
 * @return 		: 无
 */
static int __init icm20608_init(void)
{
    return spi_register_driver(&amp;icm20608_driver);
}

/*
 * @description	: 驱动出口函数
 * @param 		: 无
 * @return 		: 无
 */
static void __exit icm20608_exit(void)
{
    spi_unregister_driver(&amp;icm20608_driver);
}

module_init(icm20608_init);
module_exit(icm20608_exit);
MODULE_LICENSE(&quot;GPL&quot;);
MODULE_AUTHOR(&quot;ALIENTEK&quot;);
MODULE_INFO(intree, &quot;Y&quot;);

</code></pre>

                        
                    </div>
                </div>
                <div id="previous_next">
                    <div id="previous">
                        
                        <a href="/note/Linux/野火Linux/2025-11-22-78-Regmap通用寄存器.html">
                            <span class="icon"></span>
                            <span class="label">2025-11-22-78-Regmap通用寄存器</span>
                        </a>
                        
                    </div>
                    <div id="next">
                        
                        <a href="/note/Linux/野火Linux/2025-11-25-80-ADC驱动.html">
                            <span class="label">2025-11-25-80-ADC驱动</span>
                            <span class="icon"></span>
                        </a>
                        
                    </div>
                </div>
                <div id="comments-container"></div>
            </div>
            <div id="toc_wrapper">
                <div id="toc">
                    <div id="toc_content">
                            
                    </div>
                </div>
            </div>
        </div>
    </div>
    <a id="to_top" href="#"></a>
    <div id="doc_footer">
        <div id="footer">
            <div id="footer_top">
                <ul>
<li><a>链接</a><ul><li><a target="_blank" href="https://teedoc.neucrack.com">网站使用 teedoc 生成</a></li>
<li><a target="_blank" href="https://neucrack.com">Copyright © 2021 Neucrack</a></li>
<li><a  href="/note/sitemap.xml">网站地图</a></li>
</ul>
</li>
<li><a>源码</a><ul><li><a target="_blank" href="https://github.com/XuSenfeng/note/">github</a></li>
<li><a target="_blank" href="https://github.com/teedoc/teedoc">本网站源文件</a></li>
</ul>
</li>
</ul>

            </div>
            <div id="footer_bottom">
                <ul>
<li><a target="_blank" href="https://beian.miit.gov.cn">渝ICP备19015320号</a></li>
<li><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44030602004109">粤公网安备44030602004109号</a></li>
</ul>

            </div>
        </div>
    </div>
    
        <script src="/note/teedoc-plugin-markdown-parser/mermaid.min.js"></script>
    
        <script>mermaid.initialize({startOnLoad:true});</script>
    
        <script type="text/javascript">
                var transLoaded = false;
                var loading = false;
                var domain = "translate.google.com";
                var domainDefault = domain;
                var storeDomain = localStorage.getItem("googleTransDomain");
                if(storeDomain){
                    domain = storeDomain;
                    console.log("load google translate domain from local storage:" + domain);
                }
                function getUrl(domain){
                    if(domain == "/")
                        return "/static/js/google_translate/element.js?cb=googleTranslateElementInit";
                    else
                        return "https://" + domain + "/translate_a/element.js?cb=googleTranslateElementInit";
                }
                var url = getUrl(domain);
                console.log("google translate domain:" + domain + ", url: " + url);
                function googleTranslateElementInit() {
                    new google.translate.TranslateElement({pageLanguage: "auto", layout: google.translate.TranslateElement.InlineLayout.SIMPLE}, 'google_translate_element');
                }
                function loadJS( url, callback ){
                    var script = document.createElement('script');
                    fn = callback || function(){ };
                    script.type = 'text/javascript';
                    if(script.readyState){
                        script.onreadystatechange = function(){
                            if( script.readyState == 'loaded' || script.readyState == 'complete' ){
                                script.onreadystatechange = null;
                                fn();
                            }
                        };
                    }else{
                        script.onload = function(){
                            fn();
                        };
                    }
                    script.src = url;
                    document.getElementsByTagName('head')[0].appendChild(script);
                }
                function removeHint(){
                    var hint = document.getElementById("loadingTranslate");
                    if(hint){
                        hint.remove();
                    }
                }
                var btn = document.getElementById("google_translate_element");
                btn.onclick = function(){
                    if(transLoaded) return;
                    if(loading){
                        var flag = confirm("loading from " + domain + ", please wait, or change domain?");
                        if(flag){
                            newDomain = prompt("domain, default: " + domainDefault + ", now: " + domain);
                            if(newDomain){
                                domain = newDomain;
                                console.log(domain);
                                url = getUrl(domain);
                                loadJS(url, function(){
                                    localStorage.setItem("googleTransDomain", domain);
                                    removeHint()
                                    transLoaded = true;
                                });
                            }
                        }
                        return;
                    }
                    btn.innerHTML = '<span id="loadingTranslate"><img class="icon" src="/note/static/image/google_translate/translate.svg"/>Loading ...</span>';
                    loading = true;
                    loadJS(url, function(){
                        localStorage.setItem("googleTransDomain", domain);
                        removeHint()
                        transLoaded = true;
                    });
                }
                </script>
            
    
        <script src="/note/static/js/theme_default/tocbot.min.js"></script>
    
        <script src="/note/static/js/theme_default/main.js"></script>
    
        <script src="/note/static/js/theme_default/viewer.min.js"></script>
    
        <script src="/note/static/css/theme_default/prism.min.js"></script>
    
        <script src="/note/static/js/search/search_main.js"></script>
    
        <script src="/note/static/js/plugin_blog/main.js"></script>
    
        <link rel="stylesheet" href="/note/static/js/add_hint/style.css" type="text/css"/>
    
        <script src="/note/static/js/add_hint/main.js"></script>
    
        <script src="/note/static/js/gitalk/gitalk.min.js"></script>
    
        <script src="/note/static/js/gitalk/main.js"></script>
    
        <script src="/note/static/js/custom.js"></script>
    
</body>

</html>