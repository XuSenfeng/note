图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

හਁᇇ๦्ก
图灵社区的电子书没有采用专有客 户端，您可以在任意设备上，用自 己喜欢的浏览器和PDF阅读器进行 阅读。 但您购买的电子书仅供您个人使用， 未经授权，不得进行传播。 我们愿意相信读者具有这样的良知 和觉悟，与我们共同保护知识产权。
如果购买者有侵权行为，我们可能 对该用户实施包括但不限于关闭该 帐号等维权措施，并可能追究法律 责任。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

    图书在版编目（CIP）数据
    自制编程语言./.(日).前桥和弥著；.刘卓，.徐谦， 吴雅明译 ..--.北京：.人民邮电出版社，.2013.12（2016.10 重印） . . （图灵程序设计丛书） . . ISBN. 978-7-115-33320-9 . ...Ⅰ..①自….Ⅱ..①前….②刘….③徐….④吴….Ⅲ . ① C 语言－程序设计.Ⅳ..① TP312 . . 中国版本图书馆 CIP 数据核字（2013）第 238549 号

内  容  提  要
. . 本书手把手地教读者用C 语言制作两种编程语言：crowbar 与 Diksam。crowbar 是运行分析树的无 类型语言，Diksam 是运行字节码的静态类型语言。这两种语言都具备四则运算、变量、条件分支、循环、 函数定义、垃圾回收等功能，最终版则可以支持面向对象、异常处理等高级机制。所有源代码都提供下 载，读者可以一边对照书中的说明一边调试源代码。这个过程对理解程序的运行机制十分有帮助。 . . 本书适合有一定基础的程序员和编程语言爱好者阅读。

◆.著　　　　［. 日］. 前桥和弥

　.译　　　　刘　卓　徐　谦　吴雅明　

　.责任编辑　乐　馨

. .执行编辑　金松月

　.责任印制　焦志炜

◆.人民邮电出版社出版发行　　北京市丰台区成寿寺路 11 号

　.邮编　100164　　电子邮件　315@ptpress.com.cn

　.网址　http://www.ptpress.com.cn

　.北京　　　　　　印刷

◆.开本 ：800×1000　1/16

　.印张 ：24.75

　.字数 ：565 千字.

2013年12 月第.1.版

　.印数：8.001-8.300 册.

2016 年10 月北京第.4.次印刷

著作权合同登记号　图字 ：01-2013-4381 号

定价：79.00 元 读者服务热线：(010)51095186 转 604　印装质量热线：(010)81055316
反盗版热线 ：(010)81055315 广告经营许可证：京东工商广字第 8052 号

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

版 权 声 明
PROGRAMMING GENGO WO TSUKURU..by.Kazuya.Maebashi Copyright.©.2009.Kazuya.Maebashi. All.rights.reserved. Original.Japanese.edition.published.by.Gijyutsu-Hyoron.Co.,Ltd.,Tokyo This.Simplified.Chinese.language.edition.published.by.arrangement.with. Gijyutsu-Hyoron.Co.,Ltd.,Tokyo.in.care.of.Tuttle-Mori.Agency,.Inc.,Tokyo 本书中文简体字版由 Gijyutsu-Hyoron.Co.,Ltd. 授权人民邮电出版社独家出版。未经出 版者书面许可，不得以任何方式复制或抄袭本书内容。 版权所有，侵权必究。 （图灵公司感谢李典对本书的审读）
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

译者序
能翻开这本书的人，想必对编程都有着浓厚的兴趣。大部分编程爱好 者都会利用业余时间写一些小程序、开源项目作为消遣，却很少有人会想 要自己创造一门编程语言，这是为什么呢？
在翻译本书之前，如果别人问我要不要尝试自制编程语言，我一定会 觉得他疯了。因为在潜意识里，我一直认为制作编程语言应该是 C 语言之 父丹尼斯·里奇这样的业界大牛才能完成的浩大工程，作为一个普通程序 员只要安于本分，用好已有的语言就已经足够了。
在翻译完本书后，我才发现自己真的是大错特错。原来创造一门编程 语言，只需要一些 C 语言基础、一些正则表达式知识、加上不断思索的大 脑就可以做到。如果你还觉得难以置信，那么就请看看在这本不算厚的书 中，作者居然已经创造了两门编程语言，并且都具备高级编程语言的所有 特性。
其实一开始的问题已经有了答案：很多看似难如登天的事情，一旦真的 下决心去做，你会发现难度并没有想象中那么高，只是我们往往缺少一颗 勇于挑战的心罢了。
本书记录了作者一步一步从零创造出编程语言的全过程，作者并不是 什么行业精英，而是像你我一样的普通开发者。整本书中也没有用特别复 杂的算法或酷炫的编程技巧，但是就凭借着一行行简单朴实的编程语句， 作者最终完成了一个普通开发者看来几乎不可能完成的任务。阅读完本书 后，除了自制编程语言的知识，我相信读者还能收获到一些更重要的东西。
本书原文讲到了日文编码的知识，为了更好的将内容精髓呈现给读者， 我们大胆地将涉及日文编码的部分全部更改为中文编码的知识，译者刘卓 还对此编写了很多原创的补充内容，力求能与原书保持同样的水平。如有 错误或疏漏，还请读者随时指正。
读完全书后，你会对编程语言的原理和实现方式有一个全面深入的了 解，比如你会明白为什么 Java 中 String 类型明明是对象类型却不能改变其 内容，C 语言中为什么 a++ + ++b 这样看似合理的语句却会报错等。以前
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

vi

译者序

知其然而不知其所以然的问题都会得到答案，这对日后进行更高阶的开发 有很大的帮助。
更重要的是，你可以获得自制编程语言的能力，从而可以去做很多以 前敢想却没有能力做的事情，比如我现在就在构思能否创造一门以文言文 和中国古代文化为基础的编程语言：易经八卦就是天然的二维矩阵，《九 章算术》则有不少基础算法……相信读者还会有更加天才有趣的想法出 现。如果能运用本书中的知识最终将其实现，那么这将是对翻译工作最 好的肯定。
最后，在这里代表其他二位译者一并感谢在翻译过程中给予我们帮助 和支持的家人、同事，让这本书最终得以问世。
徐谦 2013 年中秋

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

前　言
这本书是为那些想独立制作一门编程语言的人而写的。 一听到这个话题，有的人会想：太疯狂了，制作编程语言肯定很有难度 吧？有人会怀疑：制作编程语言能有什么用呢？其实这些都是误解。 制作编程语言在技术层面上其实并不难，只要掌握一些基础知识即可。 而且，制作编程语言对于我们深入理解日常使用的 C、Java、JavaScript 等 语言都有帮助。在一些应用程序的内置脚本语言中，我们也经常会因为种 种限制从而萌生制作替代语言的想法。因此，自制编程语言并不是少数极 客的个人癖好，它对大多数程序员都颇具实用价值。 日本关于制作编程语言的书已经很多了，其中一些还被选定为大学教 科书。这些书中常出现有限状态机、NFA、LL(1)、LR(1)、SLA 等专业词 汇，同时还大量使用∩、∈等数学符号，对于不熟悉这部分理论知识的人 （包括我自己在内）来说非常难以读懂。针对这种现状，本书会偏重实践， 避免枯燥的理论。 本书将分别制作两种编程语言：crowbar 与 Diksam。crowbar 是运行分 析树的无类型语言，Diksam 是运行字节码的静态类型语言。无论哪种语 言，都具备四则运算、变量、条件分支、循环、函数定义、垃圾回收等功 能，最终版则可以支持面向对象、异常处理等高级机制。总之，作为现代 编程语言所必须具备的功能都基本覆盖了（唯一可能没实现的就是多线程 了吧）。所有源代码都提供下载，读者可以一边对照书中的说明一边调试源 代码，这样应该不难理解整个程序的运行机制。 当然，要一次实现如此多功能的编程语言，对于初学者而言可能有点 吃力，因此本书会详细介绍 crowbar、Diksam 的制作步骤，请放心。 在制作编程语言的过程中，我体会到了一种无法用语言形容的快乐。 其实无论在日本或其他地区，世界上还有很多人都在尝试自制编程语言， 这正是编程语言不断增加的原因。如果以本书为契机，有朝一日你也向本 已混乱的巴比伦之塔再添一门新语言的话，作为本书作者，这将是无上的 光荣。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

v i i i 前言
在本书的撰写过程中，得到了很多朋友的帮助与支持： 感谢百忙之中通读原稿并给出很多改进意见的吉田敦、间野健二、藤 井壮一、山本将；感谢对本书原型，即网页版“自制编程语言”提出意见的 朋友；感谢对博客连载“自制编程语言日记”提出意见的读者朋友，以及实 际使用 crowbar 与 Diksam 并提出意见的朋友。最后还要感谢每次对我延迟 交稿仍然充满耐心的技术评论社的熊谷裕美子编辑。多亏大家的鼎力支持， 本书才终能完成，在此我表示深深的谢意。
2009 年 5 月 7 日.01:06.J.S.T 前桥和弥.
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

目录CONTENTS
第 1 章 　引子.................................................................................................................001
1.1  为什么要制作编程语言..........................................................................002 1.2  自制编程语言并不是很难......................................................................003 1.3  本书的构成与面向读者..........................................................................004 1.4  用什么语言来制作..................................................................................006 1.5  要制作怎样的语言..................................................................................007
1.5.1  要设计怎样的语法.........................................................................007 1.5.2  要设计怎样的运行方式..................................................................009 补充知识 　“用户”指的是谁？ ...............................................................012 补充知识 　解释器并不会进行翻译 ..........................................................012 1.6  环境搭建..................................................................................................012 1.6.1  搭建开发环境................................................................................012 补充知识   关于 bison 与 flex 的安装 ........................................................014 1.6.2  本书涉及的源代码以及编译器.......................................................015
第 2 章 　试做一个计算器.......................................................................................017
2.1  yacc/lex 是什么......................................................................................018 补充知识 　词法分析器与解析器是各自独立的 ........................................019
2.2  试做一个计算器......................................................................................020 2.2.1  lex.................................................................................................021 2.2.2  简单正则表达式讲座......................................................................024 2.2.3  yacc...............................................................................................026 2.2.4  生成执行文件................................................................................033 2.2.5  理解冲突所代表的含义..................................................................034 2.2.6  错误处理.......................................................................................040
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

x

目录

2.3  不借助工具编写计算器..........................................................................041 2.3.1  自制词法分析器.............................................................................041 补充知识 　保留字（关键字） ...................................................................046 补充知识   避免重复包含 ........................................................................047 2.3.2  自制语法分析器.............................................................................048 补充知识   预读记号的处理 ....................................................................053
2.4  少许理论知识——LL(1) 与 LALR(1).....................................................054 补充知识   Pascal/C 中的语法处理诀窍 ...................................................056
2.5  习题 ：扩展计算器..................................................................................056 2.5.1  让计算器支持括号.........................................................................056 2.5.2  让计算器支持负数.........................................................................058
第 3 章 　制作无类型语言 crowbar...................................................................061
3.1　制作 crowbar ver.0.1 语言的基础部分.................................................062 3.1.1  crowbar 是什么..............................................................................062 3.1.2  程序的结构....................................................................................063 3.1.3  数据类型.......................................................................................064 3.1.4  变量...............................................................................................064 补充知识   初次赋值兼做变量声明的理由 ...............................................066 补充说明  各种语言的全局变量处理 ........................................................067 3.1.5  语句与结构控制.............................................................................067 补充知识   elif、elsif、elseif 的选择 .......................................................068 3.1.6  语句与运算符................................................................................069 3.1.7  内置函数.......................................................................................069 3.1.8  让 crowbar 支持 C 语言调用............................................................070 3.1.9  从 crowbar 中调用 C 语言（内置函数的编写）.................................071
3.2  预先准备..................................................................................................071
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

目录

xi

3.2.1  模块与命名规则............................................................................ 072 3.2.2  内存管理模块 MEM...................................................................... 073 补充知识   valgrind ................................................................................ 075 补充知识   富翁式编程 .......................................................................... 075 补充知识   符号表与扣留操作 ................................................................ 076 3.2.3  调试模块 DBG. ............................................................................. 076 3.3  crowbar ver.0.1 的实现........................................................................ 077 3.3.1  crowbar 的解释器——CRB_Interpreter......................................... 077 补充知识   不完全类型 .......................................................................... 080 3.3.2  词法分析——crowbar.l................................................................. 081 补充知识   静态变量的许可范围 ............................................................ 084 3.3.3  分析树的构建——crowbar.y 与 create.c........................................ 085 3.3.4  常量折叠...................................................................................... 089 3.3.5  错误信息...................................................................................... 089 补充知识   关于 crowbar 中使用的枚举型定义 ....................................... 091 3.3.6  运行——execute.c....................................................................... 092 3.3.7  表达式求值——eval.c................................................................... 096 3.3.8  值——CRB_Value......................................................................... 104 3.3.9  原生指针型................................................................................... 105 3.3.10  变量............................................................................................ 106 3.3.11  字符串与垃圾回收机制——string_pool.c.................................... 108 3.3.12  编译与运行..................................................................................110
第 4 章 　数组和标记 - 清除垃圾回收器.......................................................113
4.1  crowbar ver.0.2......................................................................................114 4.1.1  crowbar 的数组..............................................................................114 4.1.2  访问数组元素................................................................................115
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

xii

目录

4.1.3  数组是一种引用类型......................................................................116 补充知识 　“数组的数组”和多维数组 ....................................................116 4.1.4  为数组添加元素.............................................................................118 4.1.5  增加调用（伪）方法的功能...........................................................118 4.1.6  其他细节.......................................................................................118 4.2  制作标记 - 清除 GC...............................................................................119 4.2.1  引用数据类型的结构......................................................................119 4.2.2　标记 - 清除 GC..............................................................................121 补充知识   引用和不可变类 ....................................................................123 4.2.3  crowbar 栈.....................................................................................124 4.2.4  其他根...........................................................................................127 4.2.5  原生函数的形式参数......................................................................128 4.3  GC 的实现...............................................................................................129 4.3.1  对象的管理方法.............................................................................129 4.3.2  GC 何时启动..................................................................................129 4.3.3  清除阶段.......................................................................................132 补充知识   GC 现存的问题 ......................................................................133 补充知识   Copying GC ..........................................................................134 4.4  其他修改..................................................................................................136 4.4.1  修改语法.......................................................................................136 4.4.2  方法的模拟....................................................................................137 4.4.3  左值的处理....................................................................................139 4.4.4  创建数组和原生函数的书写方法....................................................142 4.4.5  修改原生指针类型.........................................................................144
第 5 章 　中文支持和 Unicode.............................................................................147
5.1  中文支持策略和基础知识......................................................................148
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

目录 x i i i
5.1.1  现存问题.......................................................................................148 5.1.2  宽字符（双字节）串和多字节字符串.............................................149 补充知识   wchar_t 肯定能表示 1 个字符吗？ ..........................................150 5.1.3  多字节字符 / 宽字符之间的转换函数群...........................................150 5.2  Unicode...................................................................................................153 5.2.1  Unicode 的历史..............................................................................153 5.2.2  Unicode 的编码方式......................................................................154 补充知识   Unicode 可以固定（字节）长度吗？ .....................................156 5.3  crowbar book_ver.0.3 的实现..............................................................156 5.3.1  要实现到什么程度？......................................................................156 5.3.2  发起转换的时机.............................................................................157 5.3.3  关于区域设置................................................................................158 5.3.4  解决 0x5C 问题..............................................................................158 补充知识   失败的 #ifdef.........................................................................160 5.3.5  应该是什么样子.............................................................................160 补充知识   还可以是别的样子——Code Set Independent ......................161
第 6 章 　制作静态类型的语言 Diksam.........................................................163
6.1  制作 Diksam Ver 0.1 语言的基本部分..................................................164 6.1.1  Diksam 的运行状态........................................................................164 6.1.2  什么是 Diksam...............................................................................165 6.1.3  程序结构.......................................................................................165 6.1.4  数据类型.......................................................................................166 6.1.5  变量...............................................................................................166 6.1.6  语句和流程控制.............................................................................167 6.1.7  表达式...........................................................................................167 6.1.8  内建函数.......................................................................................168
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

x i v 目录
6.1.9  其他...............................................................................................168 6.2  什么是静态的 / 执行字节码的语言........................................................169
6.2.1  静态类型的语言.............................................................................169 6.2.2  什么是字节码................................................................................169 6.2.3  将表达式转换为字节码..................................................................170 6.2.4  将控制结构转换为字节码...............................................................173 6.2.5  函数的实现....................................................................................173 6.3  Diksam ver.0.1 的实现——编译篇.......................................................175 6.3.1  目录结构.......................................................................................175 6.3.2  编译的概要....................................................................................176 6.3.3  构建分析树（create.c）..................................................................176 6.3.4  修正分析树（fix_tree.c）................................................................179 6.3.5  Diksam 的运行形式——DVM_Executable.....................................185 6.3.6  常量池...........................................................................................186 补充知识   YARV 的情况 .........................................................................187 6.3.7  全局变量.......................................................................................188 6.3.8  函数...............................................................................................189 6.3.9  顶层结构的字节码.........................................................................189 6.3.10  行号对应表..................................................................................190 6.3.11  栈的需要量..................................................................................190 6.3.12  生成字节码（generate.c）............................................................191 6.3.13  生成实际的编码...........................................................................193 6.4  Diksam 虚拟机........................................................................................197 6.4.1  加载 / 链接 DVM_Executable 到 DVM.............................................200 6.4.2  执行——巨大的 switch case..........................................................202 6.4.3  函数调用.......................................................................................204
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

目录

xv

第 7 章 　为 Diksam 引入数组..............................................................................207
7.1  Diksam 中数组的设计............................................................................208 7.1.1  声明数组类型的变量......................................................................208 7.1.2  数组字面量....................................................................................209 补充知识   D 语言的数组 ........................................................................210
7.2  修改编译器..............................................................................................210 7.2.1  数组的语法规则.............................................................................210 7.2.2  TypeSpecifier 结构体.....................................................................212
7.3  修改 DVM................................................................................................213 7.3.1  增加指令.......................................................................................213 补充知识   创建 Java 的数组字面量.........................................................215 补充知识   C 语言中数组的初始化 ..........................................................217 7.3.2  对象...............................................................................................217 补充知识   ArrayStoreException .............................................................218 7.3.3  增加 null.........................................................................................219 7.3.4  哎 ! 还缺点什么吧？.......................................................................219
第 8 章 　将类引入 Diksam....................................................................................221
8.1  分割源文件..............................................................................................222 8.1.1  包和分割源代码.............................................................................222 补充知识   #include、文件名、行号 .......................................................225 8.1.2  DVM_ExecutableList.....................................................................225 8.1.3  ExecutableEntry............................................................................226 8.1.4  分开编译源代码.............................................................................227 8.1.5  加载和再链接................................................................................230 补充知识   动态加载时的编译器 .............................................................233
8.2  设计 Diksam 中的类...............................................................................233
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

x v i 目录
8.2.1  超简单的面向对象入门..................................................................233 8.2.2  类的定义和实例创建......................................................................237 8.2.3  继承...............................................................................................239 8.2.4  关于接口.......................................................................................241 8.2.5  编译与接口....................................................................................242 8.2.6  Diksam 怎么会设计成这样？.........................................................243 8.2.7  数组和字符串的方法......................................................................245 8.2.8  检查类的类型................................................................................246 8.2.9  向下转型.......................................................................................246 8.3  关于类的实现——继承和多态..............................................................247 8.3.1  字段的内存布局.............................................................................247 8.3.2  多态——以单继承为前提...............................................................249 8.3.3  多继承——C++.............................................................................250 8.3.4  Diksam 的多继承...........................................................................252 补充知识   无类型语言中的继承 .............................................................254 8.3.5  重写的条件....................................................................................254 8.4  关于类的实现..........................................................................................256 8.4.1  语法规则.......................................................................................256 8.4.2  编译时的数据结构.........................................................................258 8.4.3  DVM_Executable 中的数据结构.....................................................260 8.4.4  与类有关的指令 ............................................................................262 补充知识   方法调用、括号和方法指针 ...................................................263 8.4.5  方法调用.......................................................................................264 8.4.6  super.............................................................................................266 8.4.7  类的链接.......................................................................................266 8.4.8  实现数组和字符串的方法...............................................................267 8.4.9  类型检查和向下转型......................................................................267 补充知识   对象终结器（finalizer）和析构函数（destructor） .................268
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

目录 x v i i
第 9 章 　应用篇............................................................................................................271
9.1  为 crowbar 引入对象和闭包..................................................................272 9.1.1  crowbar 的对象..............................................................................272 9.1.2  对象实现.......................................................................................273 9.1.3  闭包...............................................................................................274 9.1.4  方法...............................................................................................276 9.1.5  闭包的实现....................................................................................278 9.1.6  试着跟踪程序实际执行时的轨迹....................................................281 9.1.7  闭包的语法规则.............................................................................284 9.1.8  普通函数.......................................................................................284 9.1.9  模拟方法（修改版）.......................................................................285 9.1.10  基于原型的面向对象....................................................................286
9.2  异常处理机制..........................................................................................286 9.2.1  为 crowbar 引入异常......................................................................286 9.2.2  setjmp()/longjmp().........................................................................289 补充知识   Java 和 C# 异常处理的不同 ....................................................293 9.2.3  为 Diksam 引入异常.......................................................................295 补充知识   catch 的编写方法 ..................................................................296 9.2.4  异常的数据结构.............................................................................297 9.2.5  异常处理时生成的字节码...............................................................299 9.2.6  受查异常.......................................................................................301 补充知识   受查异常的是与非 .................................................................303 补充知识   异常处理本身的是与非 ..........................................................304
9.3  构建脚本..................................................................................................305 9.3.1  基本思路 ......................................................................................306 9.3.2  YY_INPUT.....................................................................................307 9.3.3  Diksam 的构建脚本........................................................................308 9.3.4  三次加载 / 链接..............................................................................308
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

x v i i i 目录
9.4  为 crowbar 引入鬼车..............................................................................309 9.4.1  关于“鬼车”..................................................................................309 9.4.2  正则表达式字面量.........................................................................310 9.4.3  正则表达式的相关函数..................................................................311
9.5  其他..........................................................................................................312 9.5.1  foreach 和迭代器（crowbar）.........................................................312 9.5.2  switch case（Diksam)...................................................................314 9.5.3  enum（Diksam）...........................................................................315 9.5.4  delegate（Diksam）.......................................................................316 9.5.5  final、const（Diksam）..................................................................319
附录 A 　crowbar 语言的设计..............................................................................322 附录 B 　Diksam 语言的设计...............................................................................336 附录 C 　Diksam Virtual Machine 指令集..................................................359
编程语言实用化指南——写在最后...............................................................369 参考文献...........................................................................................................375
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

第1章
引子
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 0 2 第 1 章　引子
1.1 为什么要制作编程语言
本书的主题是自制编程语言。单说现在被广泛使用的编程语言，就有 C、 C++、Java、C#、Perl、Python、Ruby、PHP、Lisp、JavaScript 等。可能有人会质 疑，既然已经有这么多语言了，真的有必要再特意创造一门新的语言吗？
实际上，自制编程语言还是大有益处的。 1. 可以帮助理解编程语言的内部运行机制
编程语言是程序员每天都要使用的工具。深刻地理解这个工具，对程序员来 说非常重要。
一般来说，重新编写一个与已有程序相似的程序会被说成是“重复发明轮 子”，这在行业内是不被认同的。但本书中想要实现的，偏偏是在众多语言存在 的前提下再制作一门新的语言，正是“重复发明轮子”。这是深刻理解编程语言 的最佳途径（缺点是要花很多时间）。 2. 能制作领域专用语言
比如在 Unix 的世界中，有 sed 和 awk 两种历史悠久的专为文本处理定制的 语言（后来在此方向上发展出了 Perl 语言）。PHP 则是专门面向 Web 程序开发的 语言。如果掌握了制作编程语言的技术，就可以在必要的情况下制作出领域专用 语言（DSL，Domain-Specific.Language）。
领域专用语言不一定会像 Perl 与 PHP 那么复杂，在很多情况下，如果能书写 条件分支或者简单语句的话会方便许多，这也可以看作是一种专用领域。
比如在业务流程处理等软件中，很多时候为了切换测试环境与生产环境的数 据库，需要重写配置文件，而这一操作经常会引发问题（比如由于版本升级需要 增加配置文件项目，此时必须与旧版本配置文件合并）。这时候我们可能就会想， 如果能直接在配置文件中写 if 语句将其按域名分开就好了。
除此以外，我们在填写数据时可能希望能支持类似 Excel 的简单算术公式， 在玩游戏时希望能把游戏中的对话导出到一个外部文件中，等等。这些都可以看 作专用领域并制作对应的 DSL。 3. 可以用编程语言扩展应用程序
将以上两方面的考量进一步延伸，我们就会得到以通用语言扩展某个应用
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1.2　自制编程语言并不是很难 0 0 3
程序的构想。Emacs 这个编辑器就内置了 Emacs.Lisp 这种 Lisp 方言，从而为 Emacs 的自定义提供了无限的可能性。同理，Microsoft.Office 也可以使用 VBA 进行扩展。
对于这类应用程序扩展语言，当然完全可以使用某种已有的编程语言（Lua 等就在向这个方向发展），也可以在编写应用程序时从底层到扩展全部自己实现。 这样就无需担心使用其他编程语言在版本升级时引起的兼容性问题了。 4. 说不定还会变成名人
如果自制的编程语言能在世界范围内得到广泛使用，那就太棒了。比如 Ruby 之父松本行弘先生就是世界名人。
不过坦白讲，通过自制编程语言来获得成功实在是太难了。即便语言被创造 出来，如果没人用的话就不会产生相应的软件，这样就更不会有人用了。况且， 即便真的因为发明了新的语言而变成了名人，通过这个赚到钱的希望也十分渺茫 啊。其实我自己最近写的语言处理器都是免费发布的（不这样的话，语言没法普 及呀）。 5. 自制编程语言非常有趣
啰嗦了这么多，说到底其实是因为自制编程语言非常有趣。 自制一门编程语言确实是一件非常有意思的事。有人说过“想写出终极程序 的程序员，最终都去写操作系统或者编程语言了”，你可以通过自制编程语言感 受到接触最核心技术的乐趣。 让尽可能多的人感受到这种乐趣，这正是本书的目标。
1.2 自制编程语言并不是很难
一提起自制编程语言，很多人都会觉得这是一件非常难的事情。 比如，即便是一个很常见的赋值语句：
a1 = b1 + b2 * 0.5;
在自制编程语言时都必须考虑到以下几个要点。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 0 4 第 1 章　引子

1.	需要将 a1、b1、b2 作为变量名解析出来。如果按照 C 语言的语法规则，变量名只 能由字母或下划线开头，从变量名第二个字符开始才允许出现字母或数字。所以 首先必须扫描这个语句，然后将匹配上述语法规则的部分提取出来。
2.	0.5 是一个含有小数点的常量，在提取这类常量时，能否用“数字组合 + 小数点 + 数字组合”来概括所有常量的特征呢（还要考虑是否允许 00.10 这样的数值）。 当然我们的提取规则还要能处理 2 这样不含小数点的数值。
3.	乘法运算符 * 比 + 拥有更高的运算优先级，语句必须被解析为 b1 + (b2 * 0.5)。 4.	b2 * 0.5 的计算结果，必须在与 b1 进行加法运算前就应该取得。也就是说对于
复杂的计算，需要保存很多类似这样的临时运算结果。

* 当然，在早年原始的研 发条件下，人们为了开 发第一个编程语言编译 器还是花费了相当大的 精力，据说实现初版的 FORTRAN 编 译 器 所 花 费的工时，累计达到了 216 人月 [1]。

假如你已经有了一定的编程经验，肯定能想到上面这些难点，甚至可以说你 的编程经验越丰富，就越能感受到这其中隐藏着极大的难题。
不过，编程语言的语言处理器在 FORTRAN 诞生后已经经过了多年的研究， 上面的这些难点都已经可以从前人那里找到解决方法 *。
在本书中，上面 1 ～ 3 的问题会用到名为 yacc 及 lex 的工具。问题 1 和问题 2 用 lex，问题 3 通过 yacc 解决。yacc 和 lex 都是非常老的工具了，现在流行的 LL 语言大多内置了 yacc。可能有人会说：“既然是以学习为目的去制作一门编程语 言，如果还使用工具的话就太投机取巧了吧。”（这话很有道理。）所以在本书中， 也会稍微介绍一下不使用这些工具的解决方法。
无论是使用工具，还是基于一些已有的解决方案自己编写，如果能掌握一些 窍门的话，自制编程语言其实并不难。
那么你想不想试试自己制作一门编程语言呢？自己创造编程语言这件事情， 不管怎么说都是很酷的吧。.

1.3 本书的构成与面向读者
本书由以下的章节构成： ●● 第 1 章　引子 ●● 第 2 章　试做一个计算器 ●● 第 3 ～ 4 章　制作无类型语言 crowbar ●● 第 5 章　中文支持与 Unicode

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1.3　本书的构成与面向读者 0 0 5
●● 第 6 ～ 8 章　制作静态类型的语言 Diksam ●● 第 9 章　应用篇 第 1 章即是你正在阅读的章节。本章会对全书的构成以及讲解方式进行说明。 第 2 章通过制作一个简单的计算器，介绍 yacc/lex 的基本使用方法。其实讲 解 yacc/lex 的部分，选择“计算器”为例实在有点老套，但确实没有比这更合 适的题目了。此外还会介绍如何不依赖 yacc，使用递归下降分析器（Recursive. Descent.Parser）来制作一个计算器。 从第 3 章开始，会实际制作有一定行数规模的编程语言。 3 ～ 4 章会制作一个名为 crowbar 的无类型解释型语言，6 ～ 8 章则主要制作 名为 Diksam 的支持静态类型的编译型语言（名字的由来会在后文提到）。在第 5. 章中，会针对使用编程语言时的中文支持与 Unicode 问题进行说明。 第 9 章阐释闭包（Closure）及异常处理机制等进阶功能。 本书将使用 C 语言作为编程语言的语言处理器（编译器、解释器等）的编写 语言（理由见后文中的具体说明）。而 crowbar 与 Diksam 最终都会累积为具备一 定行数规模的程序（crowbar 约 8000 行，Diksam 约 2 万行）。 因此，阅读本书的读者最好具备两个条件： 1. 已经会 C 语言 2. 具备阅读较长代码的能力
不过无论哪个条件都不是必须的。 对于 条件 1 需要说一点的是，Java、C++、C# 等都是从 C 语言发展出来的语 言，所以对于已经学习过这些语言的人来说，读 C 语言代码不会特别吃力。像预 处理程序、指针等 C 语言特有的知识，建议你借此机会一并学习一下。因为至少 就现阶段来说，无论是专家还是业余爱好者，但凡是程序员都免不了要用到 C 语 言。而在 crowbar 或 Diksam 中，并没有使用很多 C 语言特有的功能。比如说不 会出现 *p++ 这种不易理解的写法，更多是写成数组下标的形式。 对于 条件 2 要说的是，虽然一个语言处理器整体来看是个上规模的程序，但 是其基础构成的部分并不会很庞大。本书不会对每一行代码逐一进行注释，而是 侧重于介绍解决问题的思路，所以如果仅仅是想阅读一下本书的话，是不需要具 备阅读较长代码的经验的。但若你最后不满足于书中的讲解，还想要自己去阅读 一下 crowbar 或者 Diksam 源代码的话，因为代码行数很多，编程经验尚浅的朋友
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 0 6 第 1 章　引子
读起来可能会有压力。不过无论是业界还是外界人士，作为程序员总有一天会接 触到大规模代码的程序，将本次实践作为入门的第一步也不是一件坏事。
综上所述： 如果你觉得自己不是本书所面向的读者，想办法加入其中不就行了？ 所以无需担心什么，门槛其实没有你想的那么高。凡是对语言处理器有兴趣 的朋友都是本书面向的读者。.
1.4 用什么语言来制作
如前文所述，本书将使用 C 语言作为语言处理器的编写语言。 都什么年代了还用 C 语言？可能会有人这样想吧。其实就连我自己也会这 样想。 但本书还是使用了 C 语言，其中一个理由是因为 yacc/lex 都是面向 C 语言的 工具。 yacc/lex 本身是很老的工具。老工具虽然都有一些历史遗留问题，但也有其 优点，即正是因为历史悠久，所以会积累下更详尽的技术文档。如前文所述，目 前的 LL 语言大多使用 yacc。 另一个使用 C 语言的理由是：想要降低“依赖程度”的话，C 语言是最适 合的。 比如说用 Java 编写软件，运行环境中必须安装 JVM（Java 虚拟机）。如果 用 C# 则必须要安装 .NET.Framework。在自制编程语言的理由中，我们曾经列举 了“可以用编程语言扩展应用程序”这一条，并且提到，如果能在编写应用程 序的时候从底层到扩展全部自己实现会更加放心，其目的就是为了不依赖 JVM 或 .NET.Framework。这样在 Java 或 .NET 版本升级时也就无需操心了。 此外考虑到组合各种应用程序这个用途，C 语言在众多编程语言中可以说是 最具通用性的。无论被组合的应用程序采用何种语言编写，毫无疑问都可以调用 C 语言。.
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1.5　要制作怎样的语言 0 0 7

1.5 要制作怎样的语言

1.5.1 要设计怎样的语法

编程语言有很多种，C、C++、Java、C# 等都是 面向过程的编程语言（ . C++、

* 从 这 个 定 义 来 说，Lisp
严格讲还不能算是函数
式编程语言。

Java、C# 虽然也被称为面向对象，但可以把面向对象看作是面向过程的一个派 生）。目前看来，虽然面向过程的语言是主流，但还存在 Haskell、ML 这样的 函 数式编程语言 。函数式编程语言就是“变量值无法被更改”的一种语言 *。
对于已经习惯了面向过程语言的人来说，肯定会想“变量值无法更改还怎 么写程序呀”。其实这类语言已经编写出了很多实用的程序。在函数式编程的 基础上发展出了如 Prolog 这样的 逻辑编程语言 以及被称为 并行程序设计语言 的 Erlang。

不过目前被广泛使用的仍然是面向过程的编程语言，本书中的代码示例使用

的也都是面向过程的语言风格，当然里面还会加入面向对象的一些功能实现。在

本书中，除了会有 C++、Java、C# 这种基于类的面向对象之外，也会涵盖类似

JavaScript 这种没有类的面向对象。

语法层面上，会使用类似 C 语言的风格。crowbar 的示例代码如代码清单 1-1 所示，Diksam 的示例代码如代码清单 1-2 所示。

代码清单 1-1 crowbar 版 FizzBuzz

for (i = 1; i < = 100; i++) { if (i % 15 == 0) { print("FizzBuzz\n"); } elsif (i % 3 == 0) { print("Fizz\n"); } elsif (i % 5 == 0) { print("Buzz\n"); } else { print("" + i + "\n"); }
}

代码清单 1-2 Diksam 版 FizzBuzz 

int i; for (i = 1; i < = 100; i++) {

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 0 8 第 1 章　引子
if (i % 15 == 0) { println("FizzBuzz");
} elsif (i % 3 == 0) { println("Fizz");
} elsif (i % 5 == 0) { println("Buzz");
} else { println("" + i);
} }
顺便说一下这个名为 FizzBuzz 的小程序，其运行机制如下： 输出从1到100的数字，如果为3的倍数时，则将数字替换为Fizz，5的倍数时则输出 Buzz，同时为3与5的倍数时输出FizzBuzz。
这个小程序引自下面的文章。文章大意是建议企业在面试程序员时，至少应 聘者能写出这种程度的代码再考虑录用。
◎为什么自称程序员的人写不出程序？ http://www.aoky.net/articles/jeff_atwood/why_cant_programmers_program.htm
看了示例就能明白，无论 crowbar 还是 Diksam，都是与 C 语言非常类似的语言。 如上所述，本书虽然会创造一门新语言但仍然会用到 C 语言，所以本书所面 向的读者应该是已经掌握了 C 语言的（还没有掌握的人可以先去学习一下）。因 此如果选择 C 语言风格的语法，读者应该会感到很亲切，更重要的是笔者本人已 经习惯了 Java、C# 这种以 C 语言为基础的编程语言。 C 语言是很老的语言了，这门语言不是在前期经过严谨的设计，而是在项目 中一边实践一边慢慢发展起来的，因此语法上难免有很多考虑不周的地方。比如 在 C 语言中赋值使用 =，即数学中的等号。而 C 程序员在初学者阶段编写 if 语 句时，肯定免不了会写成这样：
if (a = 0) { ←应该写 "==" 但是写成了 "="
}
这样惨痛的教训至少也要经历一次吧。赋值在 Pascal 等语言中，一般使 用 :=。如果让一个没有编程经验的人来学习，Pascal 这种语法应该更加友好 一些。
不过我现在是要制作一门新的编程语言，而使用这门新语言的人应该都已经 习惯了 C 语言的运算符，如果这里将赋值运算符定为 := 的话反而会引起混乱，
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

…

1.5　要制作怎样的语言 0 0 9
说不定我自己就先头晕了。所以经验之谈是，语法上的些许优劣还是要给“习 惯”让步的。
——出于这种考虑，我最终决定制作一门与 C 语言类似的编程语言。 决定语法风格是编程语言创造者的特权。如果顾虑用户习惯，可以参考并 整合已有的编程语言。当然，也可以完全不考虑用户的感受，去创造一门“理 想的语言”。虽然我是以 C 语言的语法为基础，但还是想到了以下几点可以改进 的地方。 1.	if条件在C语言中，如果按条件执行的语句只有一句，则{}可以省略。但是这经 常会造成混乱，很多项目的编码规范中都会规定必须包含{}。因此最好在语法层 面直接将{}设置为不可省略（crowbar、Diksam均如此）。 2.	既然已经将if条件中的{}设置为不可省略，那么if后面的()要怎么办呢？（关 于这一点，我起初在crowbar中尝试了一下省略if的括号，结果发现在crowbar 中()是不可省略的。） 3.	伴随着语言的逐步完善，考虑到要增加一些关键字（参考2.3.1节的补充知识）， 此时再处理与已存在程序的变量名相冲突的问题就比较麻烦，所以考虑在所有的 变量前加上$（Perl或PHP等的解决方式），或者将关键字全部以大写字母开头 （Modula-2等的解决方式）。 4. switch case语句中，最好能去掉忘了写break就会进入下一个case这种容易产 生问题的设计（Java没有改进这一点，C#则做了一些半吊子的改进）。 5. switch case语句中，如果没有进入任何一个case条件分支，也没有写default分 支，那么在运行时直接报错会不会更好一些（Pascal就是这样处理的）？ 6.	编码规范通过缩进来约束怎么样？比如像Python那样通过缩进来表明逻辑结构。 7.	对于我来说，阅读Python风格的代码还有些吃力，因此是不是做成像C语言那样用 花括号包裹语法块、把强制缩进的检查交给编译器去做比较好呢？
我希望读者朋友们也能够用好语言开发者的特权，不断去追求“更加理想的 语言”。呃，虽然我这样讲可能会被说成是站着说话不腰疼吧。
1.5.2 要设计怎样的运行方式
程序员中应该无人不知，编程语言有编译型语言和解释型语言两种。 编译型语言中，C 和 C++ 比较有代表性。这类语言通常会将程序员编写的程 序源代码，最终输出为机器码的可执行文件。 但是想要输出机器码的话，必须首先掌握机器码才行。即便学习了机器码并
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 1 0 第 1 章　引子

* 为了解决这个问题，一 般的编译器都会将依赖 CPU 生成的机器码的部 分单独归为一个名为后 端的模块，根据不同的 CPU 可以更换相应的后 端，就可以支持其他型 号的 CPU 了。

写出了编译器，该编译器也无法输出供其他型号 CPU 运行的文件 *。 这类生成机器码的编程语言的优点是运行速度非常快，但是编译器性能优化
的相关技术，学习起来非常有难度。另外，在自制编程语言的理由中曾经列举了 “可以用编程语言扩展应用程序”这一点，而输出机器码的编译器并不适合这个 用途。因此本书中会选择解释型语言。
虽说“解释型语言”只是一个词，但是其实现方法又分很多种。

解释型语言的“解释”一词源自英语的 interpreter ，是“能进行翻译的物体”

的意思。编译器将源代码翻译为机器码，之后 CPU 直接运行机器码就可以了。与

此相对的解释型语言，则将程序员编写的源代码通过解释器这一程序一边解析一

边运行——这种公式化的定义看起来只有简单的两个步骤，但现实中几乎不存在

这么单纯的解释型语言（DOS 的批处理脚本或 UNIX 的 SHELL 脚本是最接近解

释型语言的定义的）。虽说名为“解释型语言”，但其中的大多数都会将源代码临

时转换为某种中间形态。

比如有代码清单 1-3 这样的代码。

代码清单 1-3 简单的 if 语句 *
* 代码中的 hoge、piyo 这 两 个 单 词， 经 常 在 输出无意义的语句时 使 用（ 多 见 于 日 本， 英语国家则较多使 用 foo、bar）。详细请 参考以下的页面： http://avnpc.com/pages/ devlang#hoge

if (a == 10) {  printf("hoge\n");   } else {  printf("piyo\n"); }
从机器的角度看，源代码其实只是一些文字的排列组合而已，机器是无法直接 运行的。现在大多数编程语言，都会将代码转换成一种叫分析树（parse.tree，也叫 语法分析树或语法树）的东西。上面的代码如果做成分析树，则如图 1-1 所示。

图 1-1 分析树示例

条件表达式

if 语句

else 节点

then 节点

左边

右边

块 序列

块 序列

a

10 printf

参数

printf 参数

"hoge\n"

"piyo\n"

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1.5　要制作怎样的语言 0 1 1

代码清单 1-4 Java 的字节码

Perl、Ruby 等语言，一旦将代码转换为分析树后，分析树将无法再还原回源 代码。
本书第 2 章以后所用到的语言 crowbar 就是采用这种运行方式的语言。 对于这类语言来说，从源代码到分析树的构建过程还是得称为“编译”。但 是这里的编译器是在程序启动时自动执行的。由于分析树会生成在内存里，因此 不会生成目标代码或目标文件，所以程序员（用户）一般意识不到有编译器在执 行。这类语言如果存在语法错误，会在刚开始运行时就被报出来，这正是源代码 被一次性全部读入并构建分析树的证明。如果是纯粹的解释型语言，如批处理脚 本或 SHELL 脚本，则会运行到有语法错误的地方才会报错。 那么，相对于 Perl、Ruby 这样的运行分析树型语言，在 Java 等语言中，取 代分析树的则是更底层的字节码，然后通过解释器运行字节码。字节码只是一些 简单的数字排列，为了尽可能地让人读懂字节码，字节码中的所有指令都被加上 了一些名为助记符（mnemonic）的字符，代码清单 1-3 的源代码经过这样一番 处理之后最终会变成代码清单 1-4 的样子（源代码中的 printf 改为 System. out.println，并使用 javap 输出）。

0: bipush 10

2: istore_1

3: iload_1

4: bipush 10

6: if_icmpne

20

9: getstatic

12: ldc

14: invokevirtual

17: goto 28

20: getstatic

23: ldc

25: invokevirtual

本书第 5 章以后所用到的语言 Diksam，就是采用这种运行方式的语言。 在 Java 中，编译器生成的字节码会被保存在 class 文件中。但是在 Diksam 中，编译器会在程序启动时执行，因此字节码保存于内存中，不会生成类似 class 文件的东西。由此可以看出，从用户的角度出发，不需要意识到 Diksam 内部其 实有字节码在执行。Python 也是使用了类似的处理机制。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 1 2 第 1 章　引子
补充知识 　“用户”指的是谁？ 
前文曾写道“因此程序员（用户）一般意识不到有编译器在执行。” 通常来说，用 户 是 指 使 用 程 序 员 编 写 的 程 序 的 人 ， 但 是 在 这 里 ， 因 为 我 们 是 要 制作一门编程语言，所以本书中的用户应该是指使用我们制作的编程语言的人，即 程序员。 这种指代在操作系统、类库、编程语言等面向程序员的文档中经常出现，不过可能 有读者会有误解，在此特别补充说明一下。
  补充知识  　解释器并不会进行翻译 
在很多入门书中，提到编译器与解释器时，一般会采用以下说明： 编译器会将源代码一次性全部翻译为机器码。 与此相对的解释器，不会事先做一次性翻译，而是在运行的同时，逐行分块地 将源代码翻译为机器码。
请允许我说句老实话，这样的说明是完全错误的。 解释器会将源码或分析树解析为字节码这种中间形态，并且一边解析一边运行，但 是解释器并不会将源码翻译为机器码。 Java 或 .NET Framework 都具备在运行的同时将字节码转换为机器码的功能，这 叫作“JIT（Just-In-Time）编译”技术，而这部分技术并不属于解释器。 那么解释器具体是如何运行程序的呢？读到后面你就会明白了。
1.6 环境搭建
1.6.1 搭建开发环境
本书的开发语言是 C 语言，辅助工具是 yacc 和 lex。 UNIX（包含 Linux 等）大部分都已经预装了开发所需的 yacc 和 lex，当然也 有例外，而 Windows 则默认没有预装。不过无需担心这些，我们完全可以全部使 用自由软件来搭建一个可用的开发环境。 那么，下面我们就开始介绍这些软件的获取途径。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1.6　环境搭建 0 1 3

1. C 编译器

免 费 的 C 编 译 器 可 以 使 用 GNU 项 目 提 供 的 GCC（GNU.Compiler.Collec-

tion）。

*

Linux 等 免 费 的 UNIX 环 境 下 大 多 都 预 装 了 GCC*。Windows 下 可 以 使 用

最 近 Linux 不 预 装 GCC

的情况似乎越来越多了。 MinGW（Minimalist.GNU.for.Windows）。

可以从下面的 URL 下载。

http://www.mingw.org/download.shtml
安装 MinGW 时，UNIX 环境下的程序会将构建（build）时使用到的 make 工 具也一并安装。不过，安装完毕后可执行文件名有点奇怪，是 mingw32-make. exe，我将其复制并重命名为 gmake.exe 以方便使用。

* m4 其实也可以单独安
装，但似乎没有独立的安
装包，可能会非常麻烦。

2. cygwin 或 MSYS cygwin 是可以运行在 Windows 上的类 UNIX 环境。比如说想在命令行提示
符中列出当前文件夹内的文件时，Windows（DOS）会使用 DIR 指令，UNIX 则使 用 ls 指令。一般用惯了 UNIX 的人，往往会在 Windows 的命令行提示符中不自觉 地敲出 ls 却尴尬地发现指令不存在，而安装了 cygwin 就可以避免这样的情况发 生。那么对于不经常使用 UNIX 的人还有必要装 cygwin 吗？因为在后文中提到的 bison 要使用 UNIX 中的 m4 工具，所以无论是 cygwin 还是 MSYS，至少还是要安 装其中一个的 *。MSYS 与 cygwin 都是在 Windows 上模拟 UNIX 环境的软件。
cygwin 可以从下面的网址中获取：
http://cygwin.com/

MSYS 可从 MinGW 页面中下载：

http://www.mingw.org/download.shtml
此 外， 因 为 cygwin 也 包 含 GCC， 可 以 没 有 MinGW 而 通 过 cygwin 安 装 GCC。但是使用 cygwin 安装的 GCC 编译，运行时需要依赖 cygwin1.dll 文件，在 其他机器运行还需要把 DLL 也复制过去，所以还是使用 MinGW 更方便。

3. bison 如果环境无法直接运行 yacc，可以使用 GNU 项目提供的 bison。

http://gnuwin32.sourceforge.net/packages/bison.htm

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 1 4 第 1 章　引子
4. flex 同理，如果环境无法直接运行 lex，可以使用 lex 的免费版 flex。
http://gnuwin32.sourceforge.net/packages/flex.htm
  补充知识    关于 bison 与 flex 的安装 
bison 由 GNU 项 目 提 供。GNU 项 目 是 由 理 查 德· 斯 托 曼（Richard Matthew Stallman）创立的项目，目标在于建立一个完全相容于 UNIX 的自由软件环境。
GNU 项 目 提 供 的 软 件 的 许 可 证 为 GPL（通 用 公 共 许 可 协 议，General Public License）。粗略地说，GPL 是这样一种许可证：
●●发行 GPL 的程序时，必须公开源代码并且声明源代码的出处； ●●包含 GPL 源代码的程序，必须受 GPL 许可证条款约束； ●●程序即使以动态链接方式使用 GPL 程序，也必须受 GPL 许可证条款约束。不过
这个限制在 LGPL 许可证（Lesser GPL）中有所放宽。 也就是说，你的程序中只要用到 GPL 的程序，哪怕这部分再小，你的程序也会自 动变成 GPL 程序，必须与源代码同时公开。这对于那些为了防止盗版而不得不采取一 些措施的商用软件来说简直是致命的。因此也有人戏称 GPL 的这个特性是“GPL 传染” 或“GPL 病毒”。 那么 bison 是否也是如此呢？后文会有说明，bison 的作用是将用户编写的配置文 件输出为 C 语言格式的代码。这里的 C 代码中会包含一些属于 bison 的代码。那么是 不是说使用 bison 去制作编程语言，所做出的编程语言在发行上也必须遵守 GPL 许可 证呢？关于 bison 输出的 C 代码这一点，是 GPL 的一个特例，可以不受 GPL 许可证约 束。此处在 GNU 项目有关 GPL 的 FAQ 页面中有如下的记载：
碰巧的是，Bison 也可以用于开发非自由软件。这是因为我们明确允许在 Bison 的输出结果中包含的 Bison 的标准解析程序可以不受限制。我们做此决 定，是因为已经存在与 Bison 类似的工具被用于非自由软件的开发。 http://www.gnu.org/licenses/gpl-faq.ja.html 另一方面，flex 则是遵循 BSD 许可证（Berkeley Software Distribution，加州大学 伯克利分校开发的软件套件集合）的（不是修订版 BSD）。BSD 许可证的程序再次发行 时，文档中必须要附加 BSD 的版权信息。 flex 会像 bison 一样输出 C 代码，这里的 C 代码也像 bison 一样，会包含一些属于 flex 的代码。但是这部分代码并不需要附加 BSD 的版权信息。因为 flex-2.5.34 携带的 COPYING 文件中有这样的描述： Note that the“flex.skl”scanner skeleton carries no copyright notice. You are free to do whatever you please with scanners generated using flex; for them, you are not even bound by the above copyright.
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1.6　环境搭建 0 1 5
1.6.2 本书涉及的源代码以及编译器
本书所涉及的源代码，可以在作者的网站上下载：
http://avnpc.com/pages/devlang#download
在开始撰写本书之前，crowbar 和 Diksam 就已经存在一些公开的版本了， 本书所用到的代码都对其进行了重新的整理和修正，因此本书相关的代码将重 新 以 book_ver 作 为 版 本 号。 比 如 本 书 最 开 始 制 作 的 crowbar 的 版 本 号 就 是 crowbar.book_ver.0.1。.
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

第2章
试做一个计算器
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 1 8 第 2 章　试做一个计算器

2.1 yacc/lex 是什么

如前文所述，本书会使用 yacc 和 lex 这两个工具。本章中将利用 yacc/lex 尝 试编写一个简单的计算器程序。
一般编程语言的语法处理，都会有以下的过程。

1. 词法分析 将源代码分割为若干个 记号（   token）的处理。

* 严格讲，包含代码中所 有记号的叫作分析树或 语法树，将一些无用记 号剔除的才叫作抽象语 法树，本书中并没有特 意区分。

2. 语法分析 即从记号构建 分析树（   parse.tree）的处理。分析树也叫作 语法树（ . syntax.
tree）或 抽象语法树（ . abstract.syntax.tree，AST）*。
3. 语义分析 经过语法分析生成的分析树，并不包含数据类型等语义信息。因此在语义分
析阶段，会检查程序中是否含有语法正确但是存在逻辑问题的错误。 一般来说执行语义分析时主要会做数据类型的解析以及错误检查，但本书中
使用的 crowbar 语言并没有设置变量类型，因此也不会进行数据类型的检查，所 以 crowbar 并不存在一个明确的语义分析阶段（Diksam 中是存在这个阶段的，位 于 fix_tree.c 源文件中，请参考本书 6.3.4 节）。

4. 生成代码 如果是 C 语言等生成机器码的编译器或 Java 这样生成字节码的编译器，在分
析树构建完毕后会进入代码生成阶段。 比如说有如下的代码：

图 2-1 分割为记号

if (a == 10) { printf("hoge\n");
} else { printf("piyo\n");
}
执行词法分析后，将被分割为如图 2-1 所示的记号（每一个块就是一个记号）：
if ( a == 10 ) { printf ( "hoge\n" ) ; } else { printf ( "piyo\n" ) ; } .
对此进行语法分析后构建的分析树，如图 2-2 所示（同图 1-1）。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2.1　yacc/lex 是什么 0 1 9

图 2-2 if 语句的分析树

条件表达式

左边

右边

if 语句

else 节点

then 节点

语句块

语句块

语句序列

语句序列

a

10 printf

参数

printf 参数

"hoge\n"

"piyo\n"

*

执行词法分析的程序称为 词法分析器（ . lexical.analyzer）*。lex 的工作就是根

也称为扫描器（lexer 或

scanner）。

据词法规则自动生成词法分析器。

执行语法分析的程序则称为 解析器（   parser）。yacc 就是能根据语法规则自动

生成解析器的程序。

顺便说一下，yacc 是“Yet.Another.Compiler.Compiler”的缩写。顾名思义，

Compiler.Compiler 就是生成编译器的编译器。yacc 其实只能生成编译器的一部分

（解析器部分），却自称编译器的编译器，未免有些名不副实。而在 yacc 诞生时还因

为存在其他几个编译器的编译器，所以 yacc 的作者干脆取“又一个（Yet.Another）编

* 最近这样的例子还有 Ruby 的 VM 的 YARV， 即“ Yet Another Ruby VM” 的 缩 写， 还 有 YAML 起 初 也 是 叫 作 “Yet Another Markup Language”。

译器的编译器”之意，起名为 yacc*。lex 则只是简单地取自 lexical.analyzer。 yacc 和 lex 一起使用，可以将一个特殊格式的定义文件输出为 C 语言代码。. 因为两者都是很老的工具，所以数据传递都采用全局变量的方式，现在看起
来实在有些简陋。即便如此，至少 yacc 仍然作为 Perl、Ruby 等语言的语言处理 器活跃在第一线。词法分析器则相对简单，完全可以自己编写，所以正式的编程

语言一般都不会使用 lex。

yacc 与 lex 在 UNIX 的标准环境下大多都已经预装了，在 Windows 等环境

一般没有预装，所以需要使用其免费的替代品 bison 和 flex（获得方法请参考

1.6.1 节）。.

  补充知识  　词法分析器与解析器是各自独立的 
如前文所述，源文件的语法分析，首先要经过词法分析器分割为记号，然后才经过 解析器做语法分析，是这样一个分工合作的过程。
常常有人会对于 C 或 Java 提出这样的疑问：
a+++++b;

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 2 0 第 2 章　试做一个计算器
这行代码明明可以理解为 a++ + ++b，为什么编译器还会报错呢？ 正是因为有了前文所说的词法分析器与解析器的分工合作机制，所以产生错误也就 不难理解了。因为词法分析器先于语法分析器运行，在词法分析阶段还无法获得 C 或 Java 的语法规则，代码就会被分割成 a ++ ++ + b，从而导致报错。
2.2 试做一个计算器
向不了解 yacc/lex 的人介绍其功能的话，与其一上来就举“用 yacc/lex 制作 编程语言”的例子，不如先从一些简单的例子讲起比较好。所以我们以一个简单 的“计算器”为例做介绍。
将计算器作为 yacc/lex 的示例实在有些老套，但是又很实用。Windows 都会 预装一个带有图形界面的计算器软件，仔细想来，PC 上明明有好用的键盘，却 还要用鼠标去一个一个点计算器上的按钮未免有些傻 A。正因为 Windows 的计算器 不好用，所以有很多人会选择使用普通的计算器。可明明眼前就摆着高性能的电 脑，偏要用买来的计算器，同样也显得很奇怪，更不要说还有“附带计算器功能 的鼠标垫”这种创意产品，就更加本末倒置了。无论是 Windows 自带的计算器， 还是从日杂店买来的计算器，都从上面看不到运算符号的优先顺序，也无法直接 计算带括号的式子（因为看不到前一个输入的值）。几十个数值求和时，你会不 会担心万一中间输错了该怎么办？我经常会。
而我们要制作的计算器，会通过命令行方式启动，可以通过键盘输入整个算 式，然后直接显示计算结果。因此可以直观地看到运算的优先顺序，比如输入
1 + 2 * 3
会得到结果 7 而不是 9。因为能看到整个算式，所以还可以很容易地检查有 没有输错。
计算器的指令名为 mycalc 。一个实际运行的例子是这样的（% 是命令提 示符）：
A　Windows 的计算器支持使用键盘输入，但是有很多初级用户并不知道这个功能，仍然用鼠标点击。 此外一些迷你键盘去掉了数字键盘区域，在上面使用计算器很不方便。 ——译者注
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2.2　试做一个计算器 0 2 1

代码清单 2-1 mycalc.l 

% mycalc 1+2 >>3.000000 1+2*3 >>7.000000

←启动 mycalc ←输入算式 ←显示结果 ←乘法与加法的混合运算 ←按运算优先顺序输出结果

虽然只用了整数，却输出“3.000000”这样的结果，这是因为 mycalc 在内 部完全使用 double 进行运算。

2.2.1 lex

lex 是自动生成词法分析器的工具，通过输入扩展名为 .l 的文件，输出词法 分析器的 C 语言代码。而 flex 则是增强版的 lex，而且是免费的。
词 法 分 析 器 是 将 输 入 的 字 符 串 分 割 为 记 号 的 程 序， 因 此 必 须 首 先 定 义 mycalc 所用到的记号。  mycalc 所用到的记号包括下列项目：
●● 运算符。在 mycalc 中可以使用四则运算，即 +、-、*、/。 ●● 整数。如 123 等。 ●● 实数。如 123.456 等。 ●● 换行符。一个算式输入后，接着输入换行符就会执行计算，因此这里的换行符也应
当设置为记号。
在 lex 中，使用 正则表达式 定义记号。 为 mycalc 所编写的输入文件 mycalc.l 如代码清单 2-1 所示。

1: %{

2: #include <stdio.h>

3: #include "y.tab.h"

4: 

5: int

6: yywrap(void)

7: {

8:

return 1;

9: }

10: %}

11: %%

12: "+"

return ADD;

13: "-"

return SUB;

14: "*"

return MUL;

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 2 2 第 2 章　试做一个计算器

15: "/"

return DIV;

16: "\n"

return CR;

17: ([1-9][0-9]*)|0|([0-9]+\.[0-9]+) {

18:

double temp;

19:

sscanf(yytext, "%lf", &temp);

20:

yylval.double_value = temp;

21:

return DOUBLE_LITERAL;

22: }

23: [ \t] ;

24: . {

25:

fprintf(stderr, "lexical error.\n");

26:

exit(1);

27: }

28: %%

代码第 11 行为 %%，此行之前的部分叫作 定义区块 。在定义区块内，可以定 义初始状态或者为正则表达式命名（即使不知道正则表达式的具体内容也可以命 名）等。在本例中放置了一些 C 代码。
第 2 行至第 9 行，使用 %{ 和.%} 包裹的部分，是想让生成的词法分析器将 这部分代码原样输出。后续程序所需的头文件 #include 等都包含在这里，比 如第三行用 #include 包含进来的 y.tab.h 头文件，就是之后 yacc 自动生成的头 文件。下面的 ADD、SUB、MUL、DIV、CR、DOUBLE_LITERAL 等都是在 y.tab.h 中 用 #define 定义的宏，其原始出处则定义于 mycalc.y 文件中（详见 2.2.3 节）。 这些宏将记号的种类区分开来。顺便附上表 2-1 说明记号的具体含义。

表 2-1 记号及其含义

记号  ADD SUB MUL DIV CR DOUBLE_LITERAL

 含义 加法（addition）运算符 + 减法（subtraction）运算符 乘法（multiplication）运算符 * 除法（division）运算符 / 回车符（carriage return） double 类型的字面常量（literal）

第 5 行到第 9 行定义了一个名为 yywrap() 的函数。如果没有这个函数的

话，就必须手动链接 lex 的库文件，在不同环境下编译时比较麻烦，因此最好

写上。本书不会再对这个函数做深入说明，简单知道其作用，直接使用就可

以了。

*

第 12 行到 27 行是 规则区块 。读了代码就能明白，这一部分是使用正则表达

关于 lex 的正则表达式，

请参考 2.2.2 节。

式 * 去描述记号。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2.2　试做一个计算器 0 2 3
在规则区块中遵循这样的书写方式：一个正则表达式的后面紧跟若干个空格， 后接 C 代码。如果输入的字符串匹配正则表达式，则执行后面的 C 代码。这里的 C 代码部分称为动作（action）.。
在第 12 ～ 16 行中，会找到四则运算符以及换行符，然后通过 return 返回 其特征符。所谓特征符，就是上文所述在 y.tab.h 中用 #define 定义、用来区别 记号种类的代号。
之前提到了这么多次“记号”，其实我们所说的记号是一个总称，包含三部 分含义，分别是：
1. 记号的种类 比如说计算器中的 123.456 这个记号，这个记号的种类是一个实数（DOUBLE_ LITERAL）。
2. 记号的原始字符 一 个 记 号 会 包 含 输 入 的 原 始 字 符， 比 如 123.456 这 个 记 号 的 原 始 字 符 就 是 123.456。
3. 记号的值 123.456 这个记号代表的是实数 123.456 的值的意思。 对于 + 或 - 这样的记号来说，只需要关注其记号种类就可以了，而如果
是 DOUBLE_LITERAL 记号，记号的种类与记号的值都必须传递给解析器。 第 17 行的正则表达式，是一个匹配“数值”用的正则表达式。表达式匹配
成功的结果，即上面列举的记号三要素中，“记号的原始字符”会在相应动作中 被名为 yytext 的全局变量（这算是 lex 的一个丑的设计）引用，并进一步使用 第 19 行的 sscanf() 进行解析。
动作解析出的值会存放在名为 yylval 的全局变量中（又丑一次）。这个全 局变量 yylval 本质上是一个联合体（union），可以存放各种类型记号的值（在 这个计算器程序中只有 double 类型）。联合体的定义部分写在 yacc 的定义文件 mycalc.y 中。
到第 28 行，又出现了一次 %%。这表示规则区块的结束，这之后的代码则被 称为 用户代码区块 。在用户代码区块中可以编写任意的 C 代码（例子中没有写）。 与定义区块不同，用户代码区块无需使用 %{.%} 包裹。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 2 4 第 2 章　试做一个计算器

2.2.2 简单正则表达式讲座

lex 通过正则表达式定义记号。正则表达式在 Perl、Ruby 语言中广泛使用，而 UNIX 用户也经常会在编辑器或 grep 命令中接触到。本书的读者可能未必都有这 样的技术背景，所以我们在本书涉及的范围内，对正则表达式做一些简单的说明。
在代码清单 2-1 的第 17 行中有这样一个正则表达式（初看可能稍微有点复杂）：

([1-9][0-9]*)|0|([0-9]+\.[0-9]+)

* 因为后面还会有 [09]* 这样的写法，所以 严 格 讲，“ 匹 配 前 面 的 字符”其实是“匹配前 面的表达式”。
表 2-2 字符串的匹配

首先，[ 与 ] 表示匹配此范围内的任意字符。而 [ ] 还支持使用连接符的缩

写方式。比如写 1-9 与写 123456789 是完全一样的。 最初圆括号中的 [1-9] 代表匹配 1 ～ 9 中任意一个数字。其后的 [0-9] 代
表匹配 0 ～ 9 的任意一个数字。 在此之后的 *，代表匹配前面的字符 *.0 次或多次。 因此，[1-9][0-9]* 这个正则表达式，整体代表以 1 ～ 9 开头（只有 1
位），后接 0 个以上的 0 ～ 9 的字符。而这正是我们在 mycalc 中对整数所做 的 定 义。
在表 2-2 中列举了若干字符串，并展示其是否匹配我们所制定的整数规则。

 字符串  5 310 012 0

 是否为整数  是 是 否 否

 备注  5 匹配 [1-9] 3 匹配 [1-9]，后面的 10 匹配 [0-9]* 开头的 0 不匹配 [1-9] 开头的 0 不匹配 [1-9]

如上表所示，mycalc 不会将 012 这样的输入作为数值接收，这完全符合我 们的预期。
但是将 0 也排除的话还是有问题的，程序必须能接受所有的实数。因此在正 则表达式中又使用了 |。| 代表“或”的意思。
第 17 行的正则表达式就被修正为：

([1-9][0-9]*)|0|([0-9]+\.[0-9]+)

现在应该可以明白前半段正则表达式的整体意思了，即将整数（0 以外）的 正则表达式与 0 通过 | 分成两部分然后并列（加上圆括号 () 是将这部分作为一 个集合才能通过 | 与 0 并列）。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2.2　试做一个计算器 0 2 5

后半部分的 [0-9]+\.[0-9]+ 中用到了 +。* 是代表“匹配前面的字符 0

次或多次”，而 + 则是“匹配前面的字符 1 次或多次”，因此这部分整体代表

“0 ～ 9 的数字至少出现一次，后接小数点 . 后又接至少一位 0 ～ 9 数字”。这些

与前面整合起来，共同构成了 mycalc 对于实数的定义。

小数点的书写不是只写一个 . 而是写成了 \.，因为 . 在正则表达式中有特殊

的含义（后文即将介绍），所以需要使用 \ 转义。[ ]、*.、+、. 等这些在正则表 达式中有特殊含义的字符称为 元字符 ，元字符可以像上文那样用 \ 或双引号 A 进

行转义。代码的第 12 ～ 14 行，就是使用双引号转义的方法对乘法和加法的运算

符进行了定义。

第 23 行的正则表达式 [ \t] 是对空格以及制表符进行匹配，对应动作为

空，因此可以忽略每一行的空白字符。

第 24 行的 . 会匹配任意一个字符。这里用于检测是否输入了程序不允许的

字符。

首先，lex 将输入的字符串分割到若干个记号中时，会尽可能选择较长的匹

配。比如 C 语言中同时有 + 运算符和 ++ 运算符，那么当输入 ++ 时，lex 不会匹

配为两个 + 运算符，而是返回一个 ++（如果不按这个逻辑，程序很难正常工作）。

如果两个规则出现同样长度的匹配时，会优先匹配前一个规则。也就是说，如果

输入字符直到最后一条规则（匹配任意字符）才匹配成功的话，说明这个字符不

符合前面所有的规则，是错误的输入。

在表 2-3 中列举了一些常用的元字符。元字符以外的字符直接书写就可以了。

表 2-3 lex 中正则表达式的元 字符

* + . [abc] [a-c] [^a-c] "" \

匹配 0 个或者多个前面的字符 匹配 1 个或者多个前面的字符 匹配任意 1 个字符 匹配 a 或 b 或 c 匹配 a ～ c 的字符 匹配 a ～ c 以外的字符 被包裹的字符不会被作为元字符，而是匹配其字面含义 转义后面的元字符

A　正则表达式有很多不同的风格，lex 所使用的风格支持使用双引号转义元字符，而常用的 PCRE 风格则只支持反斜线转义。 ——译者注
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 2 6 第 2 章　试做一个计算器

代码清单 2-2 mycalc.y 

2.2.3 yacc

yacc 是自动生成语法分析器的工具，输入扩展名为 .y 的文件，就会输出语 法分析器的 C 语言代码。bison 则是 GNU 项目所发布的 yacc 的功能扩充版。  mycalc 中 yacc 的输入文件 mycalc.y 如代码清单 2-2 所示。

1: %{

2: #include <stdio.h>

3: #include <stdlib.h>

4: #define YYDEBUG 1

5: %}

6: %union {

7:

int

int_value;

8:

double

double_value;

9: }

10: %token <double_value>

DOUBLE_LITERAL

11: %token ADD SUB MUL DIV CR

12: %type <double_value> expression term primary_expression

13: %%

14: line_list

15:

: line

16:

| line_list line

17:

;

18: line

19:

: expression CR

20:

{

21:

printf(">>%lf\n", $1);

22:

}

23: expression

24:

: term

25:

| expression ADD term

26:

{

27:

$$ = $1 + $3;

28:

}

29:

| expression SUB term

30:

{

31:

$$ = $1 - $3;

32:

}

33:

;

34: term

35:

: primary_expression

36:

| term MUL primary_expression 

37:

{

38:

$$ = $1 * $3;

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2.2　试做一个计算器 0 2 7

39:

}

40:

| term DIV primary_expression

41:

{

42:

$$ = $1 / $3;

43:

}

44:

;

45: primary_expression

46:

: DOUBLE_LITERAL

47:

;

48: %%

49: int

50: yyerror(char const *str)

51: {

52:

extern char *yytext;

53:

fprintf(stderr, "parser error near %s\n", yytext);

54:

return 0;

55: }

56: 

57: int main(void)

58: {

59:

extern int yyparse(void);

60:

extern FILE *yyin;

61: 

62:

yyin = stdin;

63:

if (yyparse()) {

64:

fprintf(stderr, "Error ! Error ! Error !\n");

65:

exit(1);

66:

}

67: }

第 1 ～ 5 行与 lex 相同，使用 %{%} 包裹了一些 C 代码。 第 4 行有一句 #define YYDEBUG 1，这样将全局变量 yydebug 设置为一 个非零值后会开启 Debug 模式，可以看到程序运行中语法分析的状态。我们现在 还不必关心这个。 第 6 ～ 9 行声明了记号以及 非终结符 的种类。正如前文所写，记号不仅需要 包含种类，还需要包含值。记号的值可能会有很多类型，这些类型都声明在联合 体中。本例中为了方便说明，定义了一个 int 类型的 int_value 和 double 类 型的 double_value，不过目前还没有用到 int_value。 非 终 结 符 是 由 多 个 记 号 共 同 构 成 的， 即 代 码 中 的 line_list、line、. expression、term 这些部分。为了分割非终结符，非终结符最后都会以一个特 殊记号结尾。这种记号称作 终结符 。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 2 8 第 2 章　试做一个计算器

代码清单 2-3 计算器的语法规则

第 10 ～ 11 行 是 记 号 的 声 明。mycalc 所 用 到 的 记 号 种 类 都 在 这 里 定 义。ADD、SUB、MUL、DIV、CR 等记号只需要包含记号的种类就可以了，而种 类 为 DOUBLE_LITERAL 的 记 号， 其 种 类 被 指 定 为 <double_value>。 这 里 的 double_value 是来自上面代码中 %union 联合体的一个成员名。
第 12 行声明了非终结符的种类，并指明了这些非终结符的值在联合体中对 应的成员名。
与 lex 一样，13 行的 %% 为分界，之后是 规则区块 。yacc 的规则区块，由 语 法规则 以及 C 语言编写的相应动作两部分构成。
在 yacc 中，会使用类似 BNF（巴科斯范式，Backus.Normal.Form）的规范来 编写语法规则。
计算器程序因为规则部分中混杂了动作，阅读起来有点难度，所以在代码清 单 2-3 中，仅仅将规则部分抽出，并加入了注释。.

1: line_list /* 多行的规则 */

2:

: line /* 单行 */

3:

| line_list line /* 或者是一个多行后接单行 */

4:

;

5: line /* 单行的规则 */

6:

: expression CR /* 一个表达式后接换行符 */

7:

;

8: expression /* 表达式的规则 */

9:

: term /* 和项 */

10: | expression ADD term /* 或 表达式 + 和项 */

11: | expression SUB term /* 或 表达式 - 和项 */

12: ;

13: term /* 和项的规则 */

14: : primary_expression /* 一元表达式 */

15: | term MUL primary_expression /* 或 和项 * 一元表达式 */

16: | term DIV primary_expression /* 或 和项 / 一元表达式 */

17: ;

18: primary_expression /* 一元表达式的规则 */

19: : DOUBLE_LITERAL /* 实数的字面常量 */

20: ;

为了看得更清楚，可以将语法规则简化为下面的格式：
A : B C | D ;
即 A 的定义是 B 与 C 的组合，或者为 D。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2.2　试做一个计算器 0 2 9
第 1 ～ 4 行的书写方式，是为了表示该语法规则在程序中可能会出现一次以 上。在 mycalc 中，输入一行语句然后敲回车键后就会执行运算，之后还可以继 续输入语句，所以需要设计成支持出现一次以上的模式。
另外，请注意在上面的计算器的语法规则中，语法规则本身就包含了运算符 的优先顺序以及结合规律。如果不考虑运算符的优先顺序（乘法应该比加法优先 执行），上文的语法规则应该写成这样。
expression /* 表达式的规则 */ : primary_expression /* 一元表达式 */ | expression ADD expression /* 或 表达式 + 表达式 */ | expression SUB expression /* 或 表达式 - 表达式 */ | expression MUL expression /* 或 表达式 * 表达式 */ | expression DIV expression /* 或 表达式 / 表达式 */ ;
primary_expression /* 一元表达式的规则 */ : DOUBLE_LITERAL /* 实数的字面常量 */ ;
那么在这样的语法规则下，yacc 是如何运作的呢？我们以代码清单 2-3 为例 一起来看看吧。
大体上可以这样说，yacc 所做的工作，可以想象成一个类似“俄罗斯方块” 的过程。
首先，yacc 生成的解析器会保存在程序内部的栈，在这个栈中，记号就会像 俄罗斯方块中的方块一样，一个个堆积起来。
比如输入.1 + 2 * 3，词法分析器分割出来的记号（最初是 1）会由右边进 入栈并堆积到左边。
Next +
1
像这样一个记号进入并堆积的过程，叫作 移进（ . shift）。  mycalc 所 有 的 计 算 都 是 采 用 double 类 型， 所 以 记 号 1 即 是 DOUBLE_ LITERAL。当记号进入的同时，会触发我们定义的规则：
primary_expression : DOUBLE_LITERAL
然后记号会被换成 primary_expression。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 3 0 第 2 章　试做一个计算器

primary_expression

Next +

类似这样触发某个规则并进行置换的过程，叫作 归约（  reduce）。  primary_expression 将进一步触发规则：

term : primary_expression
然后归约为 term。
term

Next +

再进一步根据规则：

expression : term

最终被归约为一个 expression。

expression

Next +

接下来，记号 + 进入。在进入过程中，由于没有匹配到任何一个规则，所以

只好老老实实地进行移进而不做任何归约。

expression +

Next 2

接下来是记号 2 进入。
expression + 2

Next *

经 过 上 述 同 样 的 规 则， 记 号 2（DOUBLE_LITERAL） 会 经 过 primary_ expression 被归约为 term。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2.2　试做一个计算器 0 3 1

expression + term

Next *

这里记号 2 本应该匹配到如下的规则：

expression | expression ADD term
yacc 和俄罗斯方块一样，可以预先读取下一个要进入的记号，这里我们就可 以知道下一个进入的会是 *，因此应当考虑到记号 2 会匹配到 term 规则的可能性。

term | term MUL primary_expression

归约完毕后再一次移进。
expression + term *

Next 3

接下来记号 3 进入，
Next

expression + term * 3 …

被归约为 primary_expression 后，
Next

expression + term * primary_expression
 term、.*、.primary_expression 这一部分将匹配规则：
term | term MUL primary_expression
被归约为 term。
Next
expression + term

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 3 2 第 2 章　试做一个计算器

之后，expression、.+、.term 又会匹配规则
expression | expression ADD term
最终被归约为 expression。
Next

expression

每次触发归约时，yacc 都会运行该规则的相应动作。比如乘法对应执行的规 则如下文所示。

34: term

36:

| term MUL primary_expression

37:

{

38:

$$ = $1 * $3;

39:

}

动 作 是 使 用 C 语 言 书 写 的， 但 与 普 通 的 C 语 言 又 略 有 不 同， 掺 杂 了 一 些 $$、$1、$3 之类的表达式。
这些表达式中，$1、$3 的意思是分别保存了 term 与 primary_expression. 的值。即 yacc 输出解析器的代码时，栈中相应位置的元素将会转换为一个能表述 元素特征的数组引用。由于这里的 $2 是乘法运算符（*），并不存在记号值，因 此这里引用 $2 的话就会报错。 $1 与 $3 进行乘法运算，然后将其结果赋给 $$，这个结果值将保留在栈中。在 这个例子中，执行的计算为 2 * 3，所以其结果值 6 会保留在栈中（如图 2-3）。

 图 2-3 归约发生时栈的动作

$1 $2 $3 1+2 * 3

reduce
$$ 1+6

$$=$1*$3

咦，$1 与 $3 对应的应该是 term 和 primary_expression，而不是 2 与 3 这样的 DOUBLE_LITERAL 数值才对呀，为什么会作为 2.*.3 来计算呢？
可能会有人提出上面的疑问吧。这是因为如果没有书写动作，yacc 会自动

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2.2　试做一个计算器 0 3 3

补全一个 { $$ = $1; } 的动作。当 DOUBLE_LITERAL 被归约为 primary_ expression、primary_expression 被 归 约 为 term 的 时 候，DOUBLE_ LITERAL 包含的数值也会被继承。

34: term

35:

: primary_expression

{

$$ = $1; /* 自动补全的动作 */

}

…

45: primary_expression

46:

: DOUBLE_LITERAL

{

$$ = $1; /* 自动补全的动作 */

}

$$ 与 $1 的数据类型，分别与其对应的记号或者非终结符的类型一致。比如， DOUBLE_LITERAL 对应的记号被定义为：

9: %token <double_value>

DOUBLE_LITERAL

expression、term、primary_expression 的类型则为：

11: %type <double_value> expression term primary_expression
这里的类型被指定为 <double_value>，其实是使用了在 %union 部分声 明的联合体中的 double_value 成员。
由于我们以计算器为例，计算器的动作会继续计算得出的值，但仅靠这些还 不足以制作编程语言。因为编程语言中都会包含简单的循环，而语法分析只会运 行一次，所以动作还要支持循环处理同一处代码才行。
因此在实际的编程语言中，会从动作中构建分析树。这部分处理的方法会在 后面的章节中介绍。

2.2.4 生成执行文件
接下来，让我们实际编译并链接计算器的源代码，生成执行文件吧。 在标准的 UNIX 中，按顺序执行下面的指令（% 是命令行提示符），就会输 出名为 mycalc 的执行文件。
% yacc -dv mycalc.y ←运行 yacc

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 3 4 第 2 章　试做一个计算器

 图 2-4 yacc/lex 的编译

% lex mycalc.l

←运行 lex

% cc -o mycalc y.tab.c lex.yy.c ←使用 C 编译器编译

如果在 Windows 的环境下，参考 1.6.1 节中的说明，需要安装 gcc、bison、 flex，然后运行下面的指令（C:\Test>.是命令行提示符）。

C:\Test>bison --yacc -dv mycalc.y C:\Test>flex mycalc.l C:\Test>gcc -o mycalc y.tab.c lex.yy.c

←用 bison 代替 yacc 并运行 ←运行 flex ←使用 C 编译器编译

这个过程中会生成若干文件。其流程以图片表示的话，如图 2-4 所示。

mycalc.y

yacc

y.tab.c

y.tab.h #include

C 编译器 / 链接器

mycalc 执行文件

mycalc.l

lex

lex.yy.c

y.tab.c 中包含 yacc 生成的语法分析器的代码，lex.yy.c 是词法分析器的代码。 为了将 mycalc.y 中定义的记号及联合体传递给 lex.yy.c，yacc 会生成 y.tab.h 这个 头文件。
此外，作为 C 语言程序当然要有 main() 函数，在 mycalc 中 main() 位于 mycalc.y 的用户代码区块（第 49 行以后），最终编译器会负责合并代码，所以这里 的 main() 与其他 .c 文件分离也不要紧。在 main() 函数中的全局变量 yyin 可 以设定输入文件，调用 yyparse() 函数。
由于我们使用 bison 替代了 yacc，默认生成的文件就不是 y.tab.c 和 y.tab.h， 而是 mycalc.tab.c 和 mycalc.tab.h。所以在上例中添加了 --yacc 参数，可以让 bison 生成与 yacc 同名的文件。本书为了统一，bison 会始终带上 --yacc 参数。

2.2.5 理解冲突所代表的含义
实际用 yacc 试做一下解析器，可能会被 冲突（   conflict）问题困扰。所谓冲 突，就是遇到语法中模糊不清的地方时，yacc 报出的错误。
比如 C 语言的 if 语句，就很明显有语法模糊问题。
if (a == 0)

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2.2　试做一个计算器 0 3 5

if (b == 0) printf( 在这里 a 与 b 都为 0\n);
else printf( 这里是 a 非 0 ？错 !\n);
上面的代码中，我们不清楚最后的 else 对应的究竟是哪一个 if，这就是 冲突。
yacc 运行时，遇到下面任意一种情况都会发生冲突。

●● 同时可以进行多个归约。 ●● 满足移进的规则，同时又满足归约的规则。

前 者 称 为 归 约 / 归 约（reduce/reduce） 冲 突， 后 者 称 为 移 进 / 归 约（shift/ reduce）冲突。
即便发生冲突，yacc 仍然会生成解析器。如果存在归约 / 归约冲突，则优先 匹配前面的语法规则，移进 / 归约冲突会优先匹配移进规则。很多书会写归约 / 归约冲突是致命错误，而移进 / 归约冲突则允许，这两者的确是存在严重程度的 差别，但是在我来看，无论发生哪一种冲突都是难以容忍的，我恨不得消灭代码 中所有的冲突问题。
yacc 运行时可以附带 -v 参数，标准 yacc 会生成 y.output 文件（bison 则会将 输入文件名中的扩展名 .y 替换为 .output 并生成）。
这个 y.output 文件会包含所有的语法规则、解析器、所有可能的分支状态以 及编译器启动信息。
那么我们实际做出一个冲突，然后观察一下 y.output 文件吧。 将代码清单 2-2 中的语法规则

23: expression

24:

: term

25:

| expression ADD term

←将这里的 ADD

更改为下文所示：

23: expression

24:

: term

25:

| expression MUL term

←更改为 MUL

变更后会产生 3 个移进 / 归约冲突。

% yacc -dv mycalc.y conflicts: 3 shift/reduce

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 3 6 第 2 章　试做一个计算器

然后再看 y.output 文件。

根据 yacc 或 bison 的版本与语言设置，y.output 的输出会有微妙的区别。这

里 以 bison2.3 英 文 模 式 为 例（为 了 节 约 纸 张 将 空 行 都 去 掉 了 ）。 日 语 环 境 下，

“Grammar”会变成“文法”等，错误信息也都会显示为日语。

总体来说，y.output 文件的前半部分看起来基本都会是下面这个样子（代码

清单 2-4）。

代码清单 2-4 y.output（前半部分） 

Terminals which are not used ADD

←没有使用 ADD 的警告

State 5 conflicts: 1 shift/reduce State 14 conflicts: 1 shift/reduce State 15 conflicts: 1 shift/reduce

←冲突信息（见下文）

Grammar

0 $accept: line_list $end

1 line_list: line

2

| line_list line

3 line: expression CR

4 expression: term

5

| expression MUL term

6

|expression SUB term

7 term: primary_expression

8

| term MUL primary_expression

9

| term DIV primary_expression

10 primary_expression: DOUBLE_LITERAL

首先将 ADD 改为 MUL 后，开头会出现“ADD 没有被使用”的警告。下面会 有 3 行冲突信息，此处后文会细说。再后面的“Grammar”跟着的是 mycalc.y 中 定义的语法规则。
mycalc.y 中可以使用 |（ 竖线，表示或）书写下面这样的语法规则：
line_list : line | line_list line
实际上与下面这种写法的语法规则是完全一样的。
line_list : line line_list : line_list line
y.output 文件中，会给每一行规则附上编号。 上面的规则 0，是 yacc 自动附加的规则，$accept 代表输入的内容，$end. 代表输入结束，目前还不需要特别在意这个问题。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2.2　试做一个计算器 0 3 7

y.output 文件的后半部分会将解析器可能遇到的所有“状态”全部列举出来

（代码清单 2-5）。

代码清单 2-5 y.output（后半部分） 

state 0

 0 $accept: . line_list $end

 DOUBLE_LITERAL shift, and go to state 1

 line_list

go to state 2

 line

go to state 3

 expression

go to state 4

 term

go to state 5

 primary_expression go to state 6

state 1  10 primary_expression: DOUBLE_LITERAL .  $default reduce using rule 10 (primary_expression)

state 2

 0 $accept: line_list . $end  2 line_list: line_list . line

 $end

shift, and go to state 7

 DOUBLE_LITERAL shift, and go to state 1

 line

go to state 8

 expression

go to state 4

 term

go to state 5

 primary_expression go to state 6

state 3  1 line_list: line .  $default reduce using rule 1 (line_list)

state 4  3 line: expression . CR

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 3 8 第 2 章　试做一个计算器

 5 expression: expression . MUL term

 6

| expression . SUB term

 SUB shift, and go to state 9  MUL shift, and go to state 10  CR shift, and go to state 11

下略
前文中有一个俄罗斯方块的比喻，读者通过那个比喻可能会这样理解：解析 器在一个记号进入栈后，从栈的开头一个字符一个字符扫描，如果发现这个记号 满足已有的某个规则，就去匹配该规则。但其实这样做会让编译器变得很慢。
现实中，yacc 在生成解析器的阶段，就已经将解析器所能遇到的所有状态都 列举出来，并做成了一个解析对照表（Parse.Table），表中记录了“状态 A 下某种 记号进入后会转换到状态 B”这样的映射关系，y.output 的后半部分就罗列了所有 可能的映射关系。听说这有点像麻将中的听牌，不过因为我不玩麻将，所以也不 是很清楚。
有了这些列举出的状态，当记号进入后，就可以很容易找到在何种状态下移 进，或者根据何种规则归约。那么对于之前我们故意做出的冲突，在我的环境 下，y.output 开头会输出如下信息：
State 5 conflicts: 1 shift/reduce State 14 conflicts: 1 shift/reduce State 15 conflicts: 1 shift/reduce
可以看到 state.5 引起了冲突，我们来看一下：
state 5

4 expression: term .

8 term: term . MUL primary_expression

9

| term . DIV primary_expression

MUL shift, and go to state 12 DIV shift, and go to state 13

MUL

[reduce using rule 4 (expression)]

$default reduce using rule 4 (expression)

上例中，第一行的 state 5 即为状态的编号，1 个空行后接下来的 3 行是 y.output 前半部分中输出的语法规则（语法规则还附加了编号）。语法规则中间 有 .，代表记号在当前规则下能被转换到哪个程度。比如 state.5 这个状态下，记

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2.2　试做一个计算器 0 3 9

号最多被转换为 term，然后需要等待下一个记号进行归约。 再空一行，接下来记录的是当前状态下，下一个记号进入时将如何变化。具
体来讲，这里当 MUL（*）记号进入后会进行移进并转换为 state.12。如果进入的 是 DIV（/），则同样进行移进并转移到 state.13。
再经过 1 个空行后下一行是：

MUL

[reduce using rule 4 (expression)]

意思是当 MUL 进入后，可以按照规则 4 进行归约。这也就是移进 / 归约 冲突。
yacc 默认移进优先，所以 MUL 进入后会转移到状态 12。在 y.output 中 state. 12 是这样的：

state 12

8 term: term MUL . primary_expression

DOUBLE_LITERAL shift, and go to state 1

primary_expression go to state 16
而如果是归约的情况，所要参照的规则 4 是这样的：
4 expression: term
也就是说，当记号被转换为 term 后，下一个记号 * 进入以后，yacc 会报 告有冲突发生，冲突的原因是当前 term 既可以继续进行移进，也可以归约为 expression 并结束。而这正是由于我们将 ADD 修改为 MUL 后，* 的运算优先级被 降低而引发的混乱。
对 y.output 阅读方法的说明就此告一段落，其实在实践中想要探明冲突原因 并解决冲突，是比较有难度的。
因此即便表面上看起来都一样的编程语法，根据语法规则的书写方式不同， yacc 可能报冲突也可能不报冲突（可以参考后文讲到的 LALR(1) 语法规定）。比 如本节开头所说的 C 语言中 if else 语法模糊的问题，在 Java 中就从语法规则 入手回避了这个冲突。而类似这样的小问题以及相应的解决“窍门”，在自制编 程语言中数不胜数，所以从现实出发，模仿已有的编程语言时，最好也要多多参 考其语法规则。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 4 0 第 2 章　试做一个计算器
2.2.6 错误处理
前面的小节中介绍了如何应对语法规则中的冲突问题，即编译器制作阶段的 错误处理。而在自制编程语言时，还要考虑到使用这门语言编程的人如果犯了错 误该怎么办。
在稍微旧一点的编译器书籍中，常常能读到下面这样的文字。 ●● 让用户自己不断的编译，既浪费 CPU 资源也浪费时间，因此编译器最好只经过一
次编译就能看到大部分错误信息。 ●● 但是程序中的一个错误，其原因可能是由于其他错误引起的（可能会引起错误信息
的雪崩现象）。一边不希望无用的错误信息出现，一边又想尽可能多地显示错误的 原因，这其中的平衡点是很难掌握的。 然而时至今日，CPU 已经谈不上什么“浪费资源”了，因为在多数情况下， 编译过程往往一瞬间就能结束。那么即便一次编译显示出很多错误信息，用户一 般也只会看第一条（我就是这样），这样的话，“编译器最好只经过一次编译就能 看到大部分错误信息”也就没什么意义了。 所以最省事的解决方法之一就是，一旦出错，立即使用 exit() 退出。之后 章节中的 crowbar 和 Diksam 都是这样处理的。 但是对于计算器来说，是需要与用户互动，如果输错了一点程序就强制退出 的话，对用户也太不友好了。 因此我们可以利用 yacc 的功能实现一个简单的错误恢复机制。 首先在 mycalc.y 的非终结符 line 的语法规则中，追加下面的部分。 line : expression CR {
printf(">>%lf\n", $1); } | error CR {
yyclearin; yyerrok; } ;
这里新出现的是 error 记号。error 记号是匹配错误的特殊记号。error. 可以后接 CR（换行符），这样书写可以匹配包含了错误的所有记号以及行尾。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2.3　不借助工具编写计算器 0 4 1
动作中的 yyclearin 会丢弃预读的记号，而 yyerrok 则会通知 yacc 程序 已经从错误状态恢复了。
既然是有交互的工具，一般都会使用换行来分割每次的会话，每一个错误信 息后加上换行符应该会显得更美观吧。
2.3 不借助工具编写计算器
至此我们使用 yacc 和 lex 制作了一个计算器，可能会有读者这样想： ●● 我明明是为了弄清楚编程语言的内部机制才要自制编程语言的，但是却将 yacc 和
lex 等工具当作黑匣子使用，这样一来岂不是达不到目的了吗？ ●● bison 和 flex 虽然都是自由软件，但是在项目中客户和上级是不允许使用自由软件的； ●● yacc/lex 或 bison/flex 的版本升级可能会使程序无法工作，这很让人讨厌。 上面每一条理由都足够充分（上级不允许使用自由软件可能有点不讲理，但 是光嘴上说不讲理是没法解决这个问题的）。 因此，以下我们将不会借助 yacc/lex 来制作计算器。
2.3.1 自制词法分析器
首先是词法分析器。 操作本章的计算器时，会将换行作为分割符，把输入分割为一个个算式。跨 复数行的输入是无法被解析为一个算式的，因此词法分析器中应当提供以下的 函数：
/* 将接下来要解析的行置入词法分析器中 */ void set_line(char *line); /* 从被置入的行中，分割记号并返回
* 在行尾会返回 END_OF_LINE_TOKEN 这种特殊的记号 */ void get_token(Token *token);
 get_token() 接受的入口参数为一个 Token 结构体指针，函数中会分割出 记号的信息装入 Token 结构体并返回。上面两个函数的声明以及 Token 结构体的
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 4 2 第 2 章　试做一个计算器

代码清单 2-6 token.h
代码清单 2-7 lexicalanalyzer.c

定义位于 token.h 文件中。

1: #ifndef TOKEN_H_INCLUDED

2: #define TOKEN_H_INCLUDED

3: 

4: typedef enum {

5: BAD_TOKEN,

6: NUMBER_TOKEN,

7: ADD_OPERATOR_TOKEN,

8: SUB_OPERATOR_TOKEN,

9: MUL_OPERATOR_TOKEN,

10: DIV_OPERATOR_TOKEN,

11: END_OF_LINE_TOKEN

12: } TokenKind;

13: 

14: #define MAX_TOKEN_SIZE (100)

15: 

16: typedef struct {

17: TokenKind kind;

18: double

value;

19: char

str[MAX_TOKEN_SIZE];

20: } Token;

21: 

22: void set_line(char *line);

23: void get_token(Token *token);

24: 

25: #endif /* TOKEN_H_INCLUDED */

词法分析器的源代码如代码清单 2-7 所示。

1: #include <stdio.h>

2: #include <stdlib.h>

3: #include <ctype.h>

4: #include "token.h"

5: 

6: static char *st_line;

7: static int st_line_pos;

8: 

9: typedef enum {

10:

INITIAL_STATUS,

11:

IN_INT_PART_STATUS,

12:

DOT_STATUS,

13:

IN_FRAC_PART_STATUS

14: } LexerStatus;

15: 

16: void

17: get_token(Token *token)

18: {

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2.3　不借助工具编写计算器 0 4 3

19: 20: 21: 22:  23: 24: 25: 26:
27: 28: 29: 30: 31: 32: 33: 34: 35: 36: 37: 38: 39: 40:  41: 42: 43: 44: 45: 46: 47: 48: 49:  50: 51: 52: 53: 54: 55: 56: 57: 58: 59: 60: 61: 62: 63: 64:

int out_pos = 0; LexerStatus status = INITIAL_STATUS; char current_char;
token->kind = BAD_TOKEN; while (st_line[st_line_pos] != '\0') {
current_char = st_line[st_line_pos]; if ((status == IN_INT_PART_STATUS || status == IN_FRAC_
PART_STATUS) && !isdigit(current_char) && current_char != '.') { token->kind = NUMBER_TOKEN; sscanf(token->str, "%lf", &token->value); return; } if (isspace(current_char)) { if (current_char == '\n') {
token->kind = END_OF_LINE_TOKEN; return; } st_line_pos++; continue; }
if (out_pos >= MAX_TOKEN_SIZE-1) { fprintf(stderr, "token too long.\n"); exit(1);
} token->str[out_pos] = st_line[st_line_pos]; st_line_pos++; out_pos++; token->str[out_pos] = '\0';
if (current_char == '+') { token->kind = ADD_OPERATOR_TOKEN; return;
} else if (current_char == '-') { token->kind = SUB_OPERATOR_TOKEN; return;
} else if (current_char == '*') { token->kind = MUL_OPERATOR_TOKEN; return;
} else if (current_char == '/') { token->kind = DIV_OPERATOR_TOKEN; return;
} else if (isdigit(current_char)) { if (status == INITIAL_STATUS) { status = IN_INT_PART_STATUS;

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 4 4 第 2 章　试做一个计算器

65:

} else if (status == DOT_STATUS) {

66:

status = IN_FRAC_PART_STATUS;

67:

}

68:

} else if (current_char == '.') {

69:

if (status == IN_INT_PART_STATUS) {

70:

status = DOT_STATUS;

71:

} else {

72:

fprintf(stderr, "syntax error.\n");

73:

exit(1);

74:

}

75:

} else {

76:

fprintf(stderr, "bad character(%c)\n", current_char);

77:

exit(1);

78:

}

79:

}

80: }

81: 

82: void

83: set_line(char *line)

84: {

85:

st_line = line;

86:

st_line_pos = 0;

87: }

88: 

89: /* 下面是测试驱动代码 */

90: void

91: parse_line(char *buf)

92: {

93:

Token token;

94:

95:

set_line(buf);

96:

97:

for (;;) {

98:

get_token(&token);

99:

if (token.kind == END_OF_LINE_TOKEN) {

100:

break;

101:

} else {

102:

printf("kind..%d, str..%s\n", token.kind, token.str);

103:

}

104:

}

105: }

106:

107: int

108: main(int argc, char **argv)

109: {

110:

char buf[1024];

111:

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2.3　不借助工具编写计算器 0 4 5

112: 113: 114: 115: 116: 117: }

while (fgets(buf, 1024, stdin) != NULL) { parse_line(buf);
}
return 0;

这个词法分析器的运行机制为，每传入一行字符串，就会调用一次 get_

token() 并返回分割好的记号。由于词法分析器需要记忆 set_line() 传入的

行，以及该行已经解析到的位置，所以设置了静态变量 st_line 与 st_line_

* 按本书所采用的命名规
范，文件内的 static 变
量 需 要 附 带 前 缀 st_。
请参考 3.2.1 节。

pos（第 6 ～ 7 行）*。  set_line() 函数，只是单纯设置了 st_line 与 st_line_pos 的值。  get_token() 则负责将记号实际分割出来，即词法分析器的核心部分。
第 24 行开始的 while 语句，会逐一按照字符扫描 st_line。

记号中的 +、-、*、/ 四则运算符只占一个字符长度，因此一旦扫描到了，立即

返回就可以了。

数 值 部 分 要 稍 微 复 杂 一 些， 因 为 数 值 由 多 个 字 符 构 成。 鉴 于 我 们 采 用 的

是 while 语句逐字符扫描这种方法，当前扫描到的字符很有可能只是一个数值

的一部分，所以必须想个办法将符合数值特征的值暂存起来。为了暂存数值，我

* 数值可以分为整数部分、 小数点和小数部分。使 用 lex 时， 用 一 个 正 则 表达式描述其特征，之 后全部交给 lex 处理。而 在这里我们就只能自力 更生了。

们采用一个枚举类型 LexerStatus* 的全局变量 status（第 20 行）。 首先，status 的初始状态是 INITIAL_STATUS。当遇到 0 ～ 9 的数字时，
这些数字会被放入整数部分（此时状态为 IN_INT_PART_STATUS）中（第 64 行）。一旦遇到小数点 .，status 会由 IN_INT_PART_STATUS 切换为 DOT_ STATUS（第 70 行 ），DOT_STATUS 再 遇 到 数 字 会 切 换 到 小 数 状 态（IN_

FRAC_PART_STATUS， 第 66 行 ）。 在 IN_INT_PART_STATUS 或 IN_FRAC_

PART_STATUS 的 状 态 下， 如 果 再 无 数 字 或 小 数 点 出 现， 则 结 束， 接 受 数 值

并 return。

按上面的处理，词法分析器会完全排除 .5 或 2..3 这样的输入。而从第 32

行开始的处理，除换行以外的空白符号全部会被跳过。

由于是用于计算器的词法分析器，因此除四则运算符与数值外，没有其他要

处理的对象了，但如果考虑到将其扩展并可以支持编程语言的话，最好提前想到

以下几个要点。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 4 6 第 2 章　试做一个计算器

1.	数值与标识符（如变量名等）可以按照上例的方法通过管理一个当前状态将其解 析出来，比如自增运算符就可以设置一个类似IN_INCREMENT_OPERATOR的状 态，但这样一来程序会变得冗长。因此对于运算符来说，可能为其准备一个字符 串数组会更好。比如做一个下面这样的数组：
static char *st_operator_str[] = {  "++",  "--",  "+",  "-",  (以下省略) };
当前读入的记号可以与这个数组中的元素做前向匹配，从而判别记号的种类。指 针部分同样需要比特征对象再多读入一个字符用以判别（比如输入i+2，就需要 将2也读入看看有没有是i++的可能性）。做判别时，像上例这样将长的运算符放 置在数组前面会比较省事。关于额外读入的一个字符具体应该如何处理，稍后会 介绍。 另外，像if、while这些保留字，比较简单的做法是先将其判别为标识符，之后 再去对照表中查找有没有相应的保留字。 2.	本次的计算器是以行为单位的，st_line会保存一行中的所有信息，但在当下的 编程语言中，换行一般和空白字符是等效的，因此不应该以行为单位处理，而是 从文件中逐字符（使用getc()等函数）读入解析会更好。 那么，上例中用while语句逐字符读取的地方就需要替换为用getc()等函数来读 取，比如输入123.4+2时，判别数值是否结束的时机是读入+时。 上例的词法分析器是通过st_line_pos的自增（第46行st_line_pos++）来实 现的。如果直接从文件逐字符读入，C语言中就需要使用ungetc()等从读入的字 符回退，从而产生1个字符的备份，达到预先读入下一字符的效果。

* 这里的例子仅限于
BASIC 的 旧 版 本， 在
N88-BASIC 中 IFA 的
写法也是不允许的。

  补充知识  　保留字（关键字） 
在 C 语言中，if 与 while 都是保留字，保留字无法再作为变量名使用【C 规范中 一般不称“保留字”（reserved word），而称为“关键字”（keyword），但是关键字的 指代范围太广，所以还是称保留字更加准确】 。
C 语言中的保留字是由词法分析器以特殊的标识符方式处理的。保留字的区分以标 识符为单位，比如 if 不能作为变量名但 ifa 就可以。
对于习惯了 C 语言的人来说，这都是理所当然的事情，但站在其他语言的角度看 却未必如此。
比如在我小时候折腾过一门叫 BASIC 的编程语言 *，可以这样写：
IFA=10THEN...

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2.3　不借助工具编写计算器 0 4 7

* 文 章 的 标 题 是“Fortran story - the real scoop”， 是 当 时 在 NASA 的 Fred Webb 向 新 闻 组 alt.folklore. computers 的 一 篇 投 稿，有兴趣的朋友可以 去搜索一下。

会解析为：
IF A = 10 THEN ...
向杂志投稿的程序中，注释（英语为 remark）都写成了下面这样：
REMARK 这里是注释
BASIC 中的注释只需要写 REM 语句，REM 之后都会被作为注释处理，因此即便写 成 REMARK 也是可以的。
BASIC 是从 FORTRAN 的基础上发展起来的，以前 FORTRAN 中空白字符没有任 何意义。GOTO 可以写成 GO TO，也可以写成 G OTO，而在写循环的时候，下例等于写 了一个 1 到 5 的循环。
 DO 10 I=1,5   处理 10 CONTINUE 如果一不小心将逗号输入成句号，写成下面这样：  DO 10 I=1.5
由于 FORTRAN 中空白没有意义，而且上例中也无需声明变量（D 开始的变量默认 解析成实数型变量），所以最后会变成 DO10I=1.5 这样的赋值语句。有传闻 *说就是 这样一个 BUG 最终导致 NASA 的火箭失控爆炸，当然这多半是谣传了。
另外在 C# 中还有 上下文关键字（  context keyword），是指一些在特殊的区域内才 对编译器有特殊意义的关键字（比如定义属性时使用 get 等）。内容关键字并不等同于 保留字，在普通的变量名中可以使用。保留字与关键字严格讲有不同的意义，但本书中 没有特别区分。
  补充知识    避免重复包含 
在代码清单 2-6 中，开头和结尾处有这样的语句：
#ifndef TOKEN_H_INCLUDED #define TOKEN_H_INCLUDED （中间省略） #endif /* TOKEN_H_INCLUDED */
这是为了防止 token.h 多次用 #include 包含引起多重定义错误而采用的技巧。 头文件经常会用到其他头文件中定义的类型或宏。比如在 a.h 中定义的类型在 b.h 中使用的话，在 b.h 的开头处书写 #include "a.h" 就可以了。如果不这样做，程 序用 #include 包含 b.h 时，必须同时书写 #include a.h 与 #include b.h，还 会弄得代码到处都是长串 #include，之后如果依赖关系发生改变的话修改起来非常 麻烦。 但仅仅在头文件的起始处用 #include 包含 a.h，如果多个头文件都这样书写，会

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 4 8 第 2 章　试做一个计算器
报出类型或宏的重复定义错误。因此采用上面的小技巧，一旦 token.h 用 #include 包 含后会定义 TOKEN_H_INCLUDED，根据开头的 #ifndef 语句，该头文件将被忽略， 也就避免了产生多重定义的错误。
下面的两点是编写 C 头文件的经验之谈，本书中涉及的代码都默认遵循这两点： 1.	所有的头文件都必须用 #include 包含自己所依赖的其他所有头文件，最 终让代码中只需一次 #include ； 2. 所有的头文件都必须加入上文的技巧，防止出现多重定义错误。
2.3.2 自制语法分析器
接下来终于要开始做语法分析器了。 在我看来，只要是有一定编程经验的程序员，即使没有自制编程语言的背 景，都可以大致想明白词法分析器的运行机制。但换成语法分析器，可能很多人 就有点摸不着头脑了。有些人可能会想，总之先只考虑计算器程序，将运算符优 先级最低的 + 与 - 分割出来，然后再处理 * 和 /……这样的思路基本是正确的。 但是按这样的思路实际操作时会发现，用来保存分割字符串的空间可能还有其他 用途，而加入括号的处理也很难。 对于上面的问题，与其自己想破脑袋，不如借鉴一下前人的智慧。因此我们 将使用一种叫 递归下降分析 的方法来编写语法分析器。 yacc 版的计算器曾使用下面的语法规则：
expression /* 表达式的规则 */ : term /* 表达式 */ | expression ADD term /* 或 表达式 + 表达式 */ | expression SUB term /* 或 表达式 - 表达式 */ ;
term /* 表达式的规则 */ : primary_expression /* 一元表达式 */ | term MUL primary_expression /* 或 表达式 * 表达式 */ | term DIV primary_expression /* 或 表达式 / 表达式 */ ;
primary_expression /* 一元表达式的规则 */ : DOUBLE_LITERAL /* 实数的字面常量 */ ;
这些语法规则可以用图 2-5 这样的 语法图（ . syntax.graph 或 syntax.diagram） 来表示。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2.3　不借助工具编写计算器 0 4 9

图 2-5 计算器的语法图
代码清单 2-8 parser.c（节选）

expression
term
+
term
-
term
primary_expression

primary_expression

*
primary_expression
/

DOUBLE_LITERAL

语法图的表示方法应该一看就能明白，比如项目（term）的语法图代表最初

进入一元表达式（primary_expression），一元表达式可以直接结束，也可以

继续进行 * 或 / 运算，然后又有一个一元表达式进入，重复这一流程。作为语法

构成规则的说明，语法图要比 BNF 更容易理解吧。

本书的语法图例中，非终结符用长方形表示，终结符（记号）用椭圆形表示。

正如语法图所示，递归下降分析法读入记号，然后执行语法分析。

比如解析一个项目（term）的函数 parse_term()，如代码清单 2-8 所示，

按照语法图所示流程工作。

    
51: 52: 53:
54: 55:
56: 57: 58:
59: 60: 61:

/* primary expression 的解析函数 */ v1 = parse_primary_expression(); for (;;) {
my_get_token(&token); /* 循环扫描“*”、“/”以外的字符 */ if (token.kind != MUL_OPERATOR_TOKEN
&& token.kind != DIV_OPERATOR_TOKEN) { /* 将记号 Token 退回 */ unget_token(&token); break; } /* primary expression 的解析函数 */ v2 = parse_primary_expression(); if (token.kind == MUL_OPERATOR_TOKEN) { v1 *= v2;

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 5 0 第 2 章　试做一个计算器

62:

} else if (token.kind == DIV_OPERATOR_TOKEN) {

63:

v1 /= v2;

64:

}

65:

}

66:

return v1;

如 同 语 法 图 中 最 开 始 的 primary_expression 进 入 一 样， 第 51 行 的 parse_primary_expression() 会被调用。递归下降分析法中，一个非 终结符总对应一个处理函数，语法图里出现非终结符就代表这个函数被调用。因 此在第 52 行下面的 for 语句会构成一个无限循环，如果 *（MUL_OPERATOR） 与 /（DIV_OPERATOR）进入，循环会持续进行（其他字符进入则通过第 57 行 的 break 跳出）。而第 59 行第二次调用 parse_primary_expression()，与 语法图中 * 和 / 右边的 primary expression 相对应。
比如遇到语句 1 * 2 + 3，第 51 行的 parse_primary_expression() 将 1 读 入，第 53 行 my_get_token() 将 * 读入，接下来第 59 行的 parse_primary_ expression() 将 2 读入。之后的运算符根据种类不同分别执行乘法（第 61 行） 或除法（第 63 行）。
至此已经计算完毕 1 * 2，然后第 53 行的 my_get_token() 读入的记号 是 +。+ 之后再没有 term 进入，用 break 从循环跳出。但由于此时已经将 + 读 进 来 了， 因 此 还 需 要 用 第 56 行 的 unget_token() 将 这 个 记 号 退 回。parser. c 没有直接使用 lexicalanalyzer.c 中写好的 get_token()，而使用了 my_get_ token()，my_get_token() 会对 1 个记号开辟环形缓冲区（Ring.Buffer）（代 码清单 2-9 第 7 行的静态变量 st_look_ahead_token 是全部缓冲），可以借 用环形缓冲区将最后读进来的 1 个记号用 unget_token() 退回。这里被退回 的 +，会重新通过 parse_expression() 第 78 行的 my_get_token() 再次 读入。
完整代码如代码清单 2-9 所示。 根据语法图的流程可以看到，当命中非终结符时，会通过递归的方式调用其 下级函数，因此这种解析器称为递归下降解析器。 这 个 程 序 作 为 一 个 带 有 运 算 优 先 级 功 能 的 计 算 器 来 说， 代 码 是 不 是 出 乎 意料地简单呢。那么请尝试对各种不同的算式进行真机模拟，用 debug 追踪或 者 printf() 实际调试一下吧。

.

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

 代码清单 2-9 parser.c

2.3　不借助工具编写计算器 0 5 1

1: #include <stdio.h>

2: #include <stdlib.h>

3: #include "token.h"

4: 

5: #define LINE_BUF_SIZE (1024)

6: 

7: static Token st_look_ahead_token;

8: static int st_look_ahead_token_exists;

9: 

10: static void

11: my_get_token(Token *token)

12: {

13:

if (st_look_ahead_token_exists) {

14:

*token = st_look_ahead_token;

15:

st_look_ahead_token_exists = 0;

16:

} else {

17:

get_token(token);

18:

}

19: }

20: 

21: static void

22: unget_token(Token *token)

23: {

24:

st_look_ahead_token = *token;

25:

st_look_ahead_token_exists = 1;

26: }

27: 

28: double parse_expression(void);

29: 

30: static double

31: parse_primary_expression()

32: {

33:

Token token;

34: 

35:

my_get_token(&token);

36:

if (token.kind == NUMBER_TOKEN) {

37:

return token.value;

38:

}

39:

fprintf(stderr, "syntax error.\n");

40:

exit(1);

41:

return 0.0; /* make compiler happy */

42: }

43: 

44: static double

45: parse_term()

46: {

47:

double v1;

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 5 2 第 2 章　试做一个计算器

48:

double v2;

49:

Token token;

50: 

51:

v1 = parse_primary_expression();

52:

for (;;) {

53:

my_get_token(&token);

54:

if (token.kind != MUL_OPERATOR_TOKEN

55:

&& token.kind != DIV_OPERATOR_TOKEN) {

56:

unget_token(&token);

57:

break;

58:

}

59:

v2 = parse_primary_expression();

60:

if (token.kind == MUL_OPERATOR_TOKEN) {

61:

v1 *= v2;

62:

} else if (token.kind == DIV_OPERATOR_TOKEN) {

63:

v1 /= v2;

64:

}

65:

}

66:

return v1;

67: }

68: 

69: double

70: parse_expression()

71: {

72:

double v1;

73:

double v2;

74:

Token token;

75: 

76:

v1 = parse_term();

77:

for (;;) {

78:

my_get_token(&token);

79:

if (token.kind != ADD_OPERATOR_TOKEN 

80:

&& token.kind != SUB_OPERATOR_TOKEN) {

81:

unget_token(&token);

82:

break;

83:

}

84:

v2 = parse_term();

85:

if (token.kind == ADD_OPERATOR_TOKEN) {

86:

v1 += v2;

87:

} else if (token.kind == SUB_OPERATOR_TOKEN) {

88:

v1 -= v2;

89:

} else {

90:

unget_token(&token);

91:

}

92:

}

93:

return v1;

94: }

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2.3　不借助工具编写计算器 0 5 3

95: 

96: double

97: parse_line(void)

98: {

99:

double value;

100: 

101:

st_look_ahead_token_exists = 0;

102:

value = parse_expression();

103: 

104:

return value;

105: }

106: 

107: int

108: main(int argc, char **argv)

109: {

110:

char line[LINE_BUF_SIZE];

111:

double value;

112: 

113:

while (fgets(line, LINE_BUF_SIZE, stdin) != NULL) {

114:

set_line(line);

115:

value = parse_line();

116:

printf(">>%f\n", value);

117:

}

118: 

119:

return 0;

120: }

  补充知识    预读记号的处理 
本书中采用的递归下降解析法，会预先读入一个记号，一旦发现预读的记号是不需 要的，则通过 unget_token() 将记号“退回”。
换一种思路，其实也可以考虑“始终保持预读一个记号”的方法。按照这种思路， 代码清单 2-9 可以改写成代码清单 2-10 这样：
代码清单 2-10 parser.c（始终保持预读版） 
/* token 变量已经放入了下一个记号 */ parse_primary_expression(); for (;;) {
/* 这里无需再读入记号 */ if (token.kind != MUL_OPERATOR_TOKEN
&& token.kind != DIV_OPERATOR_TOKEN) { /* 不需要退回处理 */ break; }

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 5 4 第 2 章　试做一个计算器
/* token.kind 之后还会使用，所以将其备份 * 而 parse_primary_expression() 也就可以读入新的记号 */
kind = token.kind; my_get_token(&token); v2 = parse_primary_expression(); if (kind == MUL_OPERATOR_TOKEN) {
v1 *= v2; } else if (kind == DIV_OPERATOR_TOKEN) {
v1 /= v2; } } 比较这两种实现方式，会发现两者的实质基本上是一样的。很多编译器入门书籍中 列举的实例代码，和本书中的例子相差无几。 不过这里还是会有个人偏好，就我而言，更喜欢“边读入边退回”的方法。在“始 终保持预读”的方法中，变量 token 是一个全局变量，代码中相隔很远的地方也会操作 其变量值，追踪数据变化会比较麻烦。
2.4 少许理论知识——LL(1) 与 LALR(1)
2.3.2 节中手写的解析器会对记号进行预读，并按照语法图的流程读入所有记 号。这种类型的解析器叫作 LL(1) 解析器 。LL(1) 解析器所能解析的语法，叫作 LL(1) 语法。
采用 LL(1) 语法，当然能制作出对应的编程语言来。比如 Pascal 的语法就是 LL(1)。
但是看了代码清单 2-9 就能明白，LL(1) 解析器在语法上需要非终结符与解 析器内部的函数一一对应。也就是说，只看第一个进入的记号，还无法判断需不 需要继续往下读取，也不能知道当前非终结符究竟是什么。
比如在 Pascal 中，goto 语句使用的标签只能是数字，这样限制的原因是， 如果像 C 语言一样允许英文字母作为标识符的话，读入第一个记号时，就没有办 法区分这个记号究竟是赋值语句的一部分，还是标签语句的一部分。因为无论赋 值语句还是标签语句，开始的标识符是一样的。由此可知，LL(1) 语法所做出的 解析器都比较简单，语法能表达的范围比较狭窄。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2.4　少许理论知识——LL(1) 与 LALR(1) 0 5 5

那么，在把计算器的 BNF 改写为语法图的过程中，一些敏锐的读者可能已经 有了这样的疑问：
不管是用 BNF 还是语法图，都应该只是表面上有区别，语法实现部分应该是 一样的啊。但你写的代码怎么连算法都不一样？我有种上当了的感觉。
实际上确有此事，在把 BNF 置换为图 2-5 所示的语法图时，我运用了一个小 手法。在 BNF 中语法规则是这样的：

expression /* 表达式的规则 */ | expression ADD term /* 或 表达式 + 项目 */

而在实现递归下降分析时，如果仍然按这个规则在 parse_expression() 刚

开始就调用 parse_expression()，会造成死循环，一个记号也读不了。

BNF 这样的语法称为 左递归 ，原封照搬左递归的语法规则，是无法实现递归

下降分析的。

所以 yacc 生成的解析器称为 LALR(1) 解析器 ，这种解析器能解析的语法称

为 LALR(1) 语法 。LALR(1) 解析器是 LR 解析器的一种。

LL(1) 的第一个 L，代表记号从程序源代码的最左边开始读入。第二个 L 则 邮 
代表 最左推导（   Leftmost.derivation），即读入的记号从左端开始置换为分析树。而

电

与此相对的 LR 解析器，从左端开始读入记号与 LL(1) 解析器一致，但是发生归

约时（参看 2.2.3 节图 2-3），记号从右边开始归约，这称为 最右推导（   Rightmost.

derivation），即 LR 解析器中 R 字母的意思。

递归下降分析会按自上而下的顺序生成分析树，所以称作递归“下降”解析

器或递归“向下”解析器。而 LR 解析器则是按照自下而上的顺序，所以也称为

“自底向上”解析器。

此 外，LL(1)、LALR(1) 等 词 汇 中 的 (1)， 代 表 的 是 解 析 时 所 需 前 瞻 符 号

（lookahead.symbol），即记号的数量。

LALR(1) 开头的 LA 两个字母，是 Look.Ahead 的缩写，可以通过预读一个记

号判明语法规则中所包含的状态并生成语法分析表。LALR 也是由此得名的。

本章中实际制作的计算器是采用 LL(1) 语法作为解析器的，因为比较简单，

所以适合手写。如果是 LALR(1) 等 LR 语法的话，则更适合用 yacc 等工具自动生

成（这话可能已经说了太多遍了）。不过，最近像 ANTLR、JavaCC 等一些采用

LL(k)，即预读任意个记号的 LL 解析器也开始普及起来。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 5 6 第 2 章　试做一个计算器

  补充知识    Pascal/C 中的语法处理诀窍 

前面提到 Pascal 采用的是 LL(1) 语法，但是在 Pascal 中，同时存在赋值语句和过 程调用（C 语言中是函数调用）。按照之前的介绍，这两者都由同一类标识符开始的， LL(1) 解析器似乎无法区分。
在这个问题上，Pascal 并没有从一开始就强行将其区分，而是逆转思路，引入了 一个同时代表“赋值语句或过程调用”的非终结符，然后在下一个记号读入后再将其分 开。这样不用更改 Pascal 语法设计，仅仅变化一下语法规则就解决了问题。
在 C 语言中，如果是通过 typedef 命名的一些类型，其标识符 yacc（LALR(1) 解 析器）是无法解析的。比如 C 语言中可以简单地声明为：

* 即被称为“C 语言圣经” 的 The C Programming Language 一 书， 作 者 名缩写为 K&R[2]。中文 版为《C 程序设计语言 （ 第 2 版· 新 版 ）》， 机 械 工 业 出 版 社 于 2004 年出版。

Hoge *hoge_p = NULL;
其中的星号究竟是乘法运算符还是指针符号，单看 Hoge 这个标识符很难直观得出结论。 对此，C 语言用了一个小诀窍，即在标识符作为类型名被声明的时候，会由语法分析 器通知词法分析器：此后凡遇到这个标识符，不要将其作为标识符，而作为类型名返回。 通过很多类似的诀窍，终于可以让 LL(1)/LALR(1) 解析器解析 Pascal/C 语言了。C 语言图书 K&R* 的附录中，就记录了 BNF 要经过一些修正才可以输入 yacc 的内容。

2.5 习题：扩展计算器

2.5.1 让计算器支持括号

如果要说普通计算器有什么不方便的地方，不能直接输入括号进行计算就是 其中之一。因此为了让 mycalc 支持括号，我做了一些修改。
因为使用的是 yacc/lex，所以首先在 lex 中增加 ( 和 ) 两个记号。

（前略） "+" "-" "*" "/" "("
")"
"\n" （后略）

return ADD; return SUB; return MUL; return DIV; return LP;

←新增

return RP; ←新增

return CR;

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2.5　习题 ：扩展计算器 0 5 7

 LP、RP 分别是 left.paren、right.paren 的缩写。 然后将 primary_expression 的语法规则替换为下面这样：

primary_expression : DOUBLE_LITERAL | LP expression RP { $$ = $2; } ;

一看就能明白，意思是被 ( ) 包裹的 expression 还是一个 primary_ expression。
不过仅这两处修改还不能让 mycalc 支持括号。 使用递归下降分析法制作语法分析器的话，primary_expression 的语法 图需更改为图 2-6 那样。

图 2-6

primary_expression

在语法图中引入括号

DOUBLE_LITERAL

expression

这 表 示 用 括 号 将 expression 包 裹 的 部 分， 整 体 将 会 作 为 primary_ expression 来处理。
那么按这个思路重新编写 parser.c 如下所示。

1: static double

2: parse_primary_expression()

3: {

4:

Token token;

5:

double value;

6:

7:

my_get_token(&token);

8:

if (token.kind == NUMBER_TOKEN) {

9:

return token.value;

10:

} else if (token.kind == LEFT_PAREN_TOKEN) {

11:

value = parse_expression();

12:

my_get_token(&token);

13:

if (token.kind != RIGHT_PAREN_TOKEN) {

14:

fprintf(stderr, "missing ')' error.\n");

15:

exit(1);

16:

}

17:

return value;

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 5 8 第 2 章　试做一个计算器

18: 19: 20: 21: 22: }

} else { unget_token(&token); return 0.0; /* make compiler happy */
}

将 语 法 图 直 接 转 换 为 代 码 应 该 不 是 很 难， 只 要 按 图 中 的 思 路 去 做 即 可。 如 果 进 入 的 不 是 DOUBLE_LITERAL 而 是 (， 则 把 括 号 中 的 部 分 作 为 一 个 expression 去解析就可以了。此外，如果 expression 解析完毕后没有找 到标记结束的右括号 )，则需要报错。

2.5.2 让计算器支持负数
其实目前做出来的计算器，还无法支持负数。因为在定义数值时用的正则表达 式是 [1-9][0-9]* 或 [0-9]*\.[0-9]*，根本没有把负数作为一种数值考虑进来。
那么，如果我们想修改计算器让其支持负数，要怎么办呢？ 可能有人会想，只要在词法分析器中将 -5 这样的输入也作为 DOUBLE_ LITERAL 来处理不就行了吗？按这种思路，3-5 这样的输入会被解析成 3 和 5 两个记号（请参考 2.1 节中的补充知识）。 因此，如果不想将负数作为记号处理，就应该在语法分析器中想办法。 如果用 yacc 的话，我们可能首先会想到这样做：
primary_expression : DOUBLE_LITERAL | SUB DOUBLE_LITERAL ←DOUBLE_LITERAL 之前带“-”的部分也解析为表达式 { $$ = -$2; } （下面省略）
确实，用这种方法可以给定值的实数加上负号 -。 但是，用这种方法给 -(3 * 2) 这样带括号的算式再加上负号是办不到的 （有人可能觉得办不到也无所谓，请允许我吹毛求疵一下）。为了再支持这种括号 的处理，还需要这样修改：
primary_expression : DOUBLE_LITERAL | SUB primary_expression {

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2.5　习题 ：扩展计算器 0 5 9

 图 2-7 包含负号的语法图

$$ = -$2; } （下面省略）
那么在递归下降分析法中，可以允许负号的语法图如图 2-7 所示（这个语法 图还包含了对括号的支持）。
primary_expression
DOUBLE_LITERAL

expression

将其转换为代码，如下所示。

1: static double

2: parse_primary_expression()

3: {

4:

Token token;

5:

double value = 0.0;

6:

int minus_flag = 0;

7:

8:

my_get_token(&token);

9:

if (token.kind == SUB_OPERATOR_TOKEN) {

10:

minus_flag = 1;

11:

} else {

12:

unget_token(&token);

13:

}

14:

15:

my_get_token(&token);

16:

if (token.kind == NUMBER_TOKEN) {

17:

value = token.value;

18:

} else if (token.kind == LEFT_PAREN_TOKEN) {

19:

value = parse_expression();

20:

my_get_token(&token);

21:

if (token.kind != RIGHT_PAREN_TOKEN) {

22:

fprintf(stderr, "missing ')' error.\n");

23:

exit(1);

24:

}

25:

} else {

26:

unget_token(&token);

27:

}

28:

if (minus_flag) {

29:

value = -value;

30:

}

31:

return value;

32: }

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

第3章
制作无类型语言 crowbar
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 6 2 第 3 章　制作无类型语言 crowbar
3.1 　制作 crowbar ver.0.1 语言的基础部分
本书首先制作一门无变量类型的语言。像 Perl、Ruby、Python、PHP 这些近 些年火起来的脚本语言，基本都没有变量类型。我们把将要制作的语言命名为 crowbar。
本章首先对 crowbar 的初始版本（ver.0.1）进行简要说明。
3.1.1 crowbar 是什么
crowbar 不是那种如果找到有四片叶子就会有好运降临的植物（那叫三叶 草），而是如图 3-1 这样形状的工具。
 图 3-1 名为 crowbar 的工具
之所以起名叫 crowbar，主要是因为这次要做的语言会生成分析树并执行。 单就这点来说是与 Perl 比较接近的。有句话是怎么说来着，对了，就是那句经常 能从新闻里听到的：
　撬棍状的物体 A 于是我就以 crowbar 命名了。喂，别向我扔石头啊。 如前文所述，crowbar 的语法应当照顾本书读者的习惯，所以沿袭了 C 语言 的语法。 首先将初版的 crowbar 命名为 crowbar.book_ver.0.1，示例代码如代码清单 3-1 所示。
A　当刑事案件发生时，如果物证尚不充分，警方在新闻发表会上描述犯罪所使用的道具时会经常用 “撬棍状的物体”来形容，这一说法对于日本人来说是耳熟能详的。由于 Perl 与撬棍在日语中发 音很接近，所以作者用 crowbar 命名其实是一语双关的小幽默。——译者注
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3.1　制作 crowbar ver.0.1 语言的基础部分 0 6 3

代码清单 3-1 fizzbuzz_0_1.crb 

. 1: for (i = 1; i < = 100; i = i + 1) {

2:

if (i % 15 == 0) {

3:

print("FizzBuzz\n");

4:

} elsif (i % 3 == 0) {

5:

print("Fizz\n");

6:

} elsif (i % 5 == 0) {

7:

print("Buzz\n");

8:

} else {

9:

print("" + i + "\n");

10:

}

11: }

与代码清单 1-1 不同的是，由于自增运算符 ++ 尚未实现，所以写成了 i = i + 1。
这个版本的 crowbar 还没有实现一门编程语言应当具备的所有基本功能（可 能有读者会说，就这样也敢与 Perl 相提并论呀），当前版本所实现的功能，会在 以后的章节中加以说明。.

3.1.2 程序的结构
crowbar 与 Perl 一样，支持在 顶层结构 书写代码。所谓的顶部结构，即函数 或类的外侧。
C 语言中，在函数的外面可以定义变量却不能书写执行语句，因此即便 只 写 一 句“hello,.world”， 也 需 要 main() 函 数。Java 就 更 悲 惨 了， 必 须 写 长 长 的 一 串 public class HelloWorld 还 有 public static void main(String[] args) 这种外行人看来像咒语一样的东西。如果仅仅想写几 行简单的脚本，这实在很麻烦，而对于初学者来说也增加了学习的难度。
在 crowbar 中，如果想写一个显示“hello,.world”的程序，只需简单地写成 下面这样就可以了。
print("hello, world\n");
无需再包裹函数或者类。 函数的定义，需要使用保留字 function，按如下方式书写：
# 显示将 a 与 b 相加的值，并且作为返回值返回的函数 function hoge(a, b) {
c = a + b;

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 6 4 第 3 章　制作无类型语言 crowbar

print("a+b.." + c + "\n");
return c; }
函数定义在程序中可以写在任意位置。程序执行时，首先将顶层结构中的语 句从上往下顺序执行，函数定义部分会被跳过。直至函数被调用时，才执行该函 数内的语句。
函数如果不存在 return 语句，将返回特殊的常量 null。

3.1.3 数据类型

可以使用的数据类型如下所示。

●● 布尔型。值可以为 true 或 false。 ●● 整数型。其实就是 crowbar 底层运行环境的 C 语言的 int 型。 ●● 实数型。即 crowbar 底层运行环境的 C 语言的 double 型。当整数型与实数型混合
运算时，整数型将被扩充为实数型。 ●● 字符串型。可以通过 + 运算符连接。另外，如果字符串在左侧数值在右侧，用 + 连
接的话，右侧将被转换为字符串型。

例如：

print("10 + 5.." + (10 + 5));

←将显示 10 + 5..15

●● 原生指针型（Native Pointer）。请读者不要根据名字将其想象成那种可以直接访问 内存的邪恶指针，crowbar 的原生指针型类似于 C 语言的 FILE*，是用于在 crowbar 内部移动跳转的类型。详细请参考 3.1.7 节。

在 book_ver.0.1 中，不存在数组、关联数组（associative.array）、类、对象等 类型。

3.1.4 变量
crowbar 与 Perl、Ruby 等相同，都是静态无类型（即变量无需声明类型） 语言。
crowbar 无需变量声明，赋初始值时就包含了声明过程（和 Ruby 非常类似）。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3.1　制作 crowbar ver.0.1 语言的基础部分 0 6 5

 代码清单 3-2 global.crb 

如果直接引用一个还没有赋值的变量则会报错。 变量的命名规则与 C 基本一样，必须以字母开头，第二个字符开始可以使用
字母数字，也支持下划线。与 Perl 等不同的是，变量开头无需书写 $ 符号。 函数内首次进行赋值的变量会作为函数的局部变量，局部变量的生命周期
及作用域仅限于当前函数内部。C 语言等还可以在函数中用 {} 再开辟一个块 （Block），并在块内有更小作用域的局部变量，crowbar 则不支持这种特性。
变量是在赋值语句执行时进行声明的，如下例所示：

if(a == 10) { b = 10;
} print("b.." + b);
a 只有为 10 的时候 b 才被声明，print 语句可以正常显示。如果 a 不为 10 则会报出未定义变量的错误。
在顶层结构中赋值的变量会成为全局变量。函数中引用全局变量时，需要 用 global 语句进行声明。  global 语句可以按以下的方式使用：.

global 变量名 , 变量名 , …;
比如函数内用 global a; 声明之后，在该函数内就可以引用全局变量 a（ 如 果全局变量 a 不存在则会报运行错误）。
比如运行代码清单 3-2，运行结果如下所示：

a..30 a..20

运行结果第 1 行的 a..30 是代码清单 3-2 第 10 行的 print 输出结果，因此

这里显示的是 func2() 中被赋值的局部变量 a 的值。

第 2 行的 a..20 则是第 15 行的 print 结果，显示的是全局变量 a 的值。

因为有了 global 语句，所以第 5 行赋值的是全局变量 a 的引用，而第 9 行

只引用了局部变量，因此即使对其赋值也不会对全局变量产生影响。

. 1: a = 10;

← 定义全局变量 a 的声明

2:

3: function func() {

4:

global a;

5:

a = 20; ←这里的 a 是全局变量

6: }

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 6 6 第 3 章　制作无类型语言 crowbar

7:

8: function func2() {

9:

a = 30;　 ←这里的 a 是局部变量

10:

print("a.." + a + "\n");

11: }

12:

13: func();

14: func2();

15: print("a.." + a + "\n");

那么，为什么一定要使用 global 语句声明后才可以引用全局变量呢？这样 的设计有以下两个原因。

●● 如果没有任何约束就可以直接引用全局变量，那么编写函数时就必须随时掌握所有 全局变量的情况，而对于强调高内聚性的函数来说，这种设计会产生致命的错误。
●● 全局变量的使用频率并不高，因此设置这样一点障碍对编写程序不会产生太大影响。

话虽如此，在使用 STDIN（标准输入的文件指针）这样的全局变量时也必须 声明，还是多少有些不方便的。

* 上面的语句在 Perl 中如
果加上 -w 参数并运行
的话会出现警告。

  补充知识    初次赋值兼做变量声明的理由 
如上文所述，crowbar 会在变量初次赋值时兼做变量声明，即如果直接使用没有赋 值的变量会报错。
比如在 Perl 中，默认情况下，即使没有赋值的变量仍然可以使用。此时该变量值 会根据上下文自动转换。像下面这样书写的话：
print 123 * $a; #对未赋值的变量$a进行乘法运算 运行结果为 0，因为未赋值的变量 $a 的值被自动转换为 0 了。 但是这样的设计容易因为变量名输入有误而引起 BUG*。因此在 crowbar 的设计 中，只能使用进行过初次赋值的变量。 还需要注意的是，crowbar 在执行变量的赋值语句时才会被声明，而 Ruby 只要书 写了赋值语句就完成了变量声明，即赋值语句的执行不是必须的。因此，像下面这样： x = x; #这个例子中，赋值语句执行前，x也可以使用
或
if false  a = 1 end
print a; #赋值语句没有执行，也可以使用a。 这些程序在 Ruby 中都是合法的。关于这样设计的理由，Ruby 的作者松本行弘先 生做了如下说明（请参考 ruby-list 邮件列表的 No.33798）：

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3.1　制作 crowbar ver.0.1 语言的基础部分 0 6 7

* 不 过 我 还 是 有 些 介 意， Ruby 中 连 类 或 方 法 的 定义都是动态可执行 的，为什么偏偏变量的 定义要做成静态的呢。

全局变量的作用域应当通过静态方式决定，也就是说，在赋值语句开始执行才 检查变量是否存在，这样的设计并不好。 因为动态的变量作用域用户理解起来有难度，同时也失去了一次编程语言中为 数不多的可以进行性能优化的机会。
关于这一点我是持同意态度的 *，那为什么 crowbar 中没有这样去做呢？理由其实 很简单，只是想要偷懒一下而已。
  补充说明    各种语言的全局变量处理 
下面来看一看其他语言中全局变量的处理方法。
Perl ：变量默认是全局的，只有加上 local 或 my 等定义后才会变成局部变量。 Ruby ：用 $ 开头的变量是全局变量。 PHP ：与 crowbar 一样，函数内要引用全局变量的话，用 global 语句定义。
一般来说，程序中应该避免到处使用全局变量，而尽可能优先保证局部变量的内 聚性。从这个角度来讲，Perl 式的设计是不能借鉴的（当然如果是一次性的脚本，这 样倒是很方便）。Ruby 式的设计是比较合理的，但按这个设计写出来的程序可能到处 是记号，丧失了程序的美感（这只是我主观的感受）。因此 crowbar 采用了 PHP 风格 的 global 语句的设计。

3.1.5 语句与结构控制
crowbar 与 C 语言一样，有 if、while、for 等结构控制语句。 与 C、C++、Java 等语言有以下两处比较大的区别：
●● crowbar 中不允许出现悬空 else（花括号 {} 是强制书写的）； ●● 因为不允许悬空 else，所以引入了 elsif 语句。
具体来说是下面这样的形式：
# if 语句的例子 if (a == 10) {
# a == 10 时执行 } elsif (a == 11) {
# a == 11 时执行 } else {
# a 不为 10 也不为 11 时执行 }
# while 语句的例子

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 6 8 第 3 章　制作无类型语言 crowbar

while (i < 10) { # i 比 10 小时，此处循环执行
}
# for 语句的例子 for(i = 0; i < 10; i = i + 1) {
# 这里循环 10 次 }
此外，在 crowbar 中也可使用下列语句，其意义与 C 语言相同。
●● break ：从最内层的循环中跳出。 ●● continue ：跳过最内层循环中剩余的代码。 ●● return ：从函数退出，并将后面的值作为返回值返回。
 break 或 continue，最好能像 Java 那样附加一个标签，但当前版本还没有 这个功能（book_ver.0.3 实现了标签功能）。

  补充知识    elif、elsif、elseif 的选择 
C 等语言中，if 语句允许没有花括号的写法（也称作悬空语句），也可以像下例这 样用 else if 排列书写。
if (a < 10) {

…………

} else if (a < 20) {

} else if (a < 30) {

} else {

}

C 或 Java 虽然设置了这种特别的结构控制语法，但偶尔也有初学者会误解其意义， 以为 else if 不是一个专用语句，而是 else 语句后省略花括号又写的一个 if 语句。 说起来在工作中的确会遇到很多项目，在编码规范中明确规定了“禁止省略花括号”， 这样就可以放心地去写 else if 了。
crowbar 中直接废弃了悬空语句，无法书写上述形式的 else if，为此特别引入 了 elsif。不过不同语言对于 elsif 的设计都不太一样，实在让人有些头疼。

B Shell、Python、C 预处理器 Perl、Ruby、MODULA-2、Ada、Eiffel Visual Basic、PHP

elif elsif elseif

因为 crowbar 的目标就是成为“Perl 那样的东西”，所以我就私自决定采用 elsif 了。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3.1　制作 crowbar ver.0.1 语言的基础部分 0 6 9

3.1.6 语句与运算符

首先，crowbar 支持以下形式的常量作为语句。
●● 整数字面常量，如 123 等。 ●● 实数字面常量，如 123.456 等。 ●● 字符串字面常量。双引号包裹的字符串，如 "abc" 等。

另外变量也可以作为语句。

进而可以和运算符结合构成更复杂的语句，当然还支持括号。

crowbar 可使用的运算符如表 3-1 所示（按运算优先级排序）。

表 3-1 crowbar 可使用的运 算符

-（单目取负） * / % + > >= < <= == != && || =

符号的反转 乘法、除法、求余 加法、减法 大小比较 同值比较 逻辑与 逻辑或 赋值

 % 运算也可以用在实数上，本质上是在内部调用了 C 的函数 fmod()。

无论 C 语言还是 crowbar，都没有用常量直接表示负数。想使用负数时，可

以使用单目取负符 -。

而与 C 语言一样，&&、|| 都是短路运算符。也就是说，像下面这样的条件

语句：

if (a < 10 && b < 20) {

…

当 a < 10 的条件不成立时，不再判断 b < 20 这一条件语句（已经短路， 所以表达式无论真伪都不会在 if 语句中执行）。

3.1.7 内置函数
内置函数是 crowbar 最开始就包含的用 C 语言编写的函数。crowbar 当前版 本的内置函数如表 3-2 所示。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 7 0 第 3 章　制作无类型语言 crowbar

表 3-2 crowbar book_ ver.0.1 的内置函数

 函数名  print(arg)
fopen(filename, mode)
fclose(fp) fgets(fp) fputs(str, fp)

 功能  显示 arg。arg 的类型可以是整数、实数、字符串 打开一个文件，返回文件指针。mode 的可选参数与 C 语言的 fopen() 一样（其实就是原封不动的传给了 C 语言） 传入 fp 即关闭文件 从 fp 中读出一行字符串并返回 向 fp 输出字符串，输出时不会自动添加换行

显而易见，基本上所有文件操作函数的设计都沿袭了 C 语言的 stdio.h。只是 因为 crowbar 有字符串类型，所以 fgets() 等的用法会稍有不同。
此外，fopen() 返回的类型是 crowbar 才有的“原生指针型”。上例中只是 单纯指向 C 的 FILE*，但是这个类型的特殊之处远不止于此。比如用内置函数实 现 GUI 时，创建一个打开新窗口的函数 create_window()，其返回值应当能表 示一个“窗口”，此时就可以考虑使用原生指针型来实现。
crowbar 中已经默认声明了 STDIN、STDOUT、STDERR 等全局变量，分别对应 C 语言中的 stdin、stdout、stderr。

3.1.8 让 crowbar 支持 C 语言调用

考虑到 crowbar 的用途之一是扩展应用程序，那么应当让 C 语言编写的其他

应用程序可以很容易地调用 crowbar 解释器。

代码清单 3-3 是与当前版本 crowbar 所属的 main.c 基本一样的代码段。调用

里面这些函数，需要用 #include 包含 CRB.h 文件。

代码清单 3-3

.

crowbar 被 C 语言调用 

CRB_Interpreter FILE *fp; /* 中间省略 */

*interpreter;

/* 生成 crowbar 解释器 */ interpreter = CRB_create_interpreter();

/* 将 FILE* 作为参数传递并生成分析树 */ CRB_compile(interpreter, fp);

/* 运行 */ CRB_interpret(interpreter);

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3.2　预先准备 0 7 1
/* 运行完毕后回收解释器 */ CRB_dispose_interpreter(interpreter);
3.1.9 从 crowbar 中调用 C 语言（内置函数的编写）
反过来，从 crowbar 中调用 C 语言的函数（内置函数）也同样容易。 首先用 #include 包含面向开发人员的头文件 CRB_dev.h，像下面这样表示 C 函数：
CRB_Value hoge_hoge_func(CRB_Interpreter *interpreter, int arg_count, CRB_Value *args)
{ /* 中间省略 */ return value;
}
这里调用的 interpreter 是指向解释器的指针，arg_count 代表向该函 数传递的参数的数量，args 是参数的值（CRB_Value 类型详见 3.3.8 节）。
crowbar 是无类型语言，因此参数的数量与类型的检查都必须在内置函数 进行。
通过这种方式制作出的 C 函数，通过 CRB_add_native_function() 函 数即可注册到解释器中，成为 crowbar 的内置函数。
/* 将 C 的函数 hoge_hoge_func 注册为一个 crowbar 可以调用的内部函数 并命名为 hoge_hoge */
CRB_add_native_function(interpreter, "hoge_hoge", hoge_hoge_func);
3.2 预先准备
crowbar 的语言处理器有一定的行数规模（最终版有 8000 行左右），因此应 当预先约定编码规范，并准备好底层的库。
那么让我们暂时离开语言处理器，先准备下面这些事项吧。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 7 2 第 3 章　制作无类型语言 crowbar
3.2.1 模块与命名规则
crowbar 由以下 3 个模块构成： ●● crowbar 主程序（CRB） ●● 内存管理模块（MEM） ●● Debug 模块（DBG） 括号中的 CRB、MEM 等是模块名。 这里我所指的模块，即可以完成某些特定功能的程序块。一个模块中基本都 会包含多个 .c 文件。 MEM 与 DBG 均 为 通 用 模 块， 并 不 是 crowbar 专 用 的。 代 码 分 别 位 于 crowbar 文件夹下的 memory、debug 子文件夹中。 C 语言中没有 C++ 和 C# 的命名空间，也没有 Java 中的包机制，因此必须制 定命名规范来避免可能出现的命名冲突。因此我们使用以下的命名规范。
1. 模块必须有前缀3个字母的缩写（如：CRB）。 2.		类 型名，以大写字母开始，并使用下划线连接单词（如：CRB_Interpreter）。 3.		变 量名/函数名，全部使用小写字母，使用下划线连接单词（如：alloc_ex-
pression()）。 4.		宏 命名为全大写字母，使用下划线连接单词（如：IDENTIFIER_TABLE_ALLOC_
SIZE）。但如果是带参数的宏，特别是具有函数功能的部分，则要遵循函数的命 名规则（如：small(a, b)）。 5.		模 块 中 向 外 公 开 的 函 数 ， 命 名 以 模 块 名 （ 大 写 字 母 ） + 下 划 线 作 为 前 缀 （如：CRB_create_interpreter()）。 6.		模 块中不对外公开的函数，如果函数的作用域跨文件时，则函数名以模块名（小 写字母） + 下划线作为前缀（如：crb_alloc_expression()）。 7. 函数外的静态变量名以st_作为前缀（如：st_string_literal_buffer）。
各模块中向外部公开的接口需要做成 公有头文件 的形式，在头文件中定义了 公开函数以及调用模块所需的类型。比如 crowbar 中，想使用 crowbar 解释器就 需要包含 CRB.h，而编写 crowbar 的内置函数则需要包含 CRB_dev.h。
各 模 块 内 部 使 用 的 类 型、 宏、 函 数 等， 则 可 以 声 明 为 私 有 头 文 件 。 比 如 在 crowbar 中，crowbar.h 就是一个私有头文件，其中声明的类型名或宏无需附 加 CRB_ 前缀（因为外部是接触不到的）。但是函数与全局变量，为了以防万一还 是需要加上 crb_ 前缀的。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3.2　预先准备 0 7 3

2.3.1 节 后 的 补 充 知 识 中 曾 写 道， 所 有 的 头 文 件 应 当 尽 量 只 用 一 个 #include（前提是已经加入了防止多重定义的处理）。因此大多数情况下，私 有头文件内部可以用 #include 包含公有头文件，反之则不行。内部文件中使用 公共信息，而外部文件中则不能含有私有信息，这应该不难理解。
经过上述的处理，各模块的内部细节都可以对其他模块实现隐藏（即面向对 象中常提到的封装概念）。此外，在 C 语言中，头文件修改后包含该头文件的源 代码都需要重新编译。将头文件划分为公有及私有，只要保证公有头文件不修 改，那么用户利用公有头文件编写的程序也就无需重新编译了。
crowbar 的模块与目录结构如图 3-2 所示。

图 3-2 crowbar 的模块与目录 结构

${CROWBAR}（crowbar 所在目录） CRB.h... 面向 crowbar 用户的接口 CRB_dev.h... 面向内置函数开发人员的接口 MEM.h... 面向 MEM 用户的接口 DBG.h... 面向 DBG 用户的接口 make 可以生成的执行文件及 main.c 等

依赖

依赖

${CROWBAR}/memory （MEM 所在目录）

${CROWBAR}/debug （DBG 所在目录）

3.2.2 内存管理模块 MEM
经常使用 C 的程序员应该深有体会，用 C 语言编程时，难免会遇到诸如内存 损坏（ memory. corruption）BUG、忘记释放内存引起内存泄漏、引用的内存区域 被释放让 BUG 难以重现等问题，总之围绕内存经常会发生很多让人讨厌的 BUG。
而由于 crowbar 还设置有字符串型的变量，可以用 + 运算符连接字符串，因 此我们必须配置某种垃圾回收机制。比如：
a = "a" + "b" + "c"
这个语句运行的时候，首先执行 "a" + "b" 语句生成字符串 "ab"，然后

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 7 4 第 3 章　制作无类型语言 crowbar

为了继续生成 "abc"，"ab" 的内存空间必须自动释放。具体的运行过程请参考 3.3.11 节。正是由于运行时需要运行很多这样繁复的处理，很容易出现 BUG，所 以需要有一种方法来确认内存中到底发生了什么。
基 于 上 述 理 由， 我 制 作 了 一 个 具 备 下 列 功 能 的 内 存 管 理 模 块。 模 块 名 为 MEM，按之前的命名规范，所有的公共函数都以 MEM_ 为前缀。

1.		通 过MEM_malloc()可以分配内存空间，内存空间开始处默认填充有0xCC。常 规的malloc()函数开辟的内存空间值为0的情况很多，因此很容易遗漏初始化过 程。而0xCC毫无疑问是个无意义的值，这样就可以确保能够检查出被遗漏的初始 化过程。
2.		M EM_realloc()用于扩充内存空间时，也会默认填充0xCC。 3.		开 辟的内存空间用MEM_free()释放时，被填充的0xCC也会被释放。由此可以较
早地发现由于引用被释放的内存空间而引起的BUG。 4.		M EM模块会以链表形式保存所有开辟的内存空间，可以使用MEM_dump_block()将
其转储。转储后可以将MEM_malloc调用位置的源文件名及行号显示出来。 用malloc()开辟的内存空间，在不用的时候一定要用free()释放，这是我 们在编程时一定要遵守的一个准则。那么如果在程序结束时调用MEM_dump_ block()仍然看到有结果输出的话，就可以断定某处发生了内存泄漏。 5.		M EM_malloc()开辟的内存空间在传递给程序使用时，空间前后会加上0xCD的记 号，检查这些记号就可以知道由于数组越界等问题引起的内存损坏程度了。 这 个 检 查 还 需 要 配 合 使 用 M E M _ c h e c k _ b l o c k ( ) 、 M E M _ c h e c k _ a l l _ blocks()等函数。

图 3-3 通过 MEM 管理内存

内存管理模块 MEM 会以图 3-3 的形式管理内存。
用双向链表管理内存块

空间大小 _FILE_ _LINE_ CDCDCD...
向应用程序 分配区域
CDCDCD...

空间大小 _FILE_ _LINE_ CDCDCD...
向应用程序 分配区域
CDCDCD...

空间大小 _FILE_ _LINE_ CDCDCD... 向应用程序 分配区域 CDCDCD...

空间大小 _FILE_ _LINE_ CDCDCD...
向应用程序 分配区域
CDCDCD...

_FILE_ 和 _LINE_ 代表 当前内存空间被开辟的 源文件名及行号。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3.2　预先准备 0 7 5
很简单的模块，功能虽然简单，但对于 BUG 的检查非常有用。 对于动态开辟的内存空间，经常会先开辟若干个小型的区域，然后将这些区 域一起释放。分析树的节点就是典型的例子。开辟空间会一点一点地进行，释放 则是一次性的。对此，MEM 模块引入了存储器（storage），作为开辟内存的常规 工具。 1. 由MEM_open_storage()生成一个新的存储器。 2.		M EM_storage_malloc()可以接受存储器和空间的大小作为入口参数，并返回 所请求大小的内存空间。 3. 由MEM_dispose_storage()将存储器内所有的内存空间全部释放。  MEM_storage_malloc() 会 将 MEM_open_storage() 开 辟 的 较 大 内 存 空间，从起始处按照请求的尺寸一次性全部返回。因此无法对其中的子空间单独 释放，也不能通过 realloc() 扩展空间。
  补充知识    valgrind 
我们手动实现了模块 MEM，它可以检查由于 C 语言操作内存而引起的 BUG，其 实也有很多其他工具具备同样的功能。
以 前 这 类 工 具 大 都 是 需 要 付 费 的， 不 过 在 Linux 环 境 下， 可 以 使 用 自 由 软 件 valgrind（许可证为 GPL）。
通常我们使用下面的方式启动程序（% 是命令行提示符）。 % crowbar test.crb 而执行如下指令的话， % valgrind crowbar test.crb 可以帮助我们检查是否忘记释放内存（或内存泄漏），以及是否在程序开辟的内存 空间外部进行了写入。 可能有读者会问，有这么方便的工具为什么还要制作 MEM 模块呢？实际上，我在 写 MEM 模块时完全不知道有 valgrind 这个工具，算是重复发明轮子了。不过自己实现 一个这样的工具也是有好处的吧。 valgrind 的详细内容，请参考官方主页 http://valgrind.org/。
  补充知识    富翁式编程 
MEM 模块中，在应用程序所使用的内存空间前后分别加上了管理专用空间。比如 开发环境中 int 型或者指针一般占用 4 字节，double 型一般占用 8 字节，而其管理空 间前面占用 24 字节，后面则有 8 字节（包含校验信息）。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 7 6 第 3 章　制作无类型语言 crowbar

* 参考 URL ：http://www.
pitecan.com/fugo.html

那么如果生成很多对象时，肯定会浪费很多内存空间。 然而对于现在的电脑来说，这种程度的浪费简直是微不足道的。与其冥思苦想节省 内存空间或提高处理速度的小技巧，倒不如专注于如何提高开发效率。这种编程方式就 叫作 富翁式编程 *。 crowbar 的实现就非常之“富翁”。比如用 crowbar 书写的程序中会出现 hoge_ piyo_foo_bar 这样一个变量。对于现代编程语言来说，这样长的变量名或函数名是 很常见的。在程序中，hoge_piyo_foo_bar 变量名可能还会出现若干次，crowbar 的解释器将会预先对所有出现的变量名分配好空间，当然这都是要消耗内存的，最终只 需要用 strcmp() 简单地对当前变量名做一致性检查就可以了。另外，在检索变量或 函数时，都采用线性检索。 这样设计当然可能会出现运行速度慢的情况，即便如此，等到状况发生时再想办法 优化也不迟。在前期优先考虑的应该是如何让程序更加容易编写、理解起来更加简单。

  补充知识    符号表与扣留操作 
刚刚提到过，无论是内存空间还是处理速度，crowbar 的内部实现都是比较“富翁 式”的。那么如果在此基础上想要进一步提高运行效率的话要怎样做呢？
正如上文所述，crowbar 对于程序中多次出现的变量名等，会分别开辟空间将其保 存。如果变量名较长时比较浪费，因此将同名变量整合为一处保存，不失为一个提高效 率的方法。
具体来说，程序中会存在一个函数，为所有出现的特征符建立数据结构，新出现的 特征符如果已经被记录则会返回其指针，如果尚未记录则会新录入并返回指针。这样的 操作称为 扣留（  intern）。对一个标识符进行扣留操作时，无需判别该标识符是局部变量 还是全局变量，或是函数名（当然进行判别也无妨）。
对程序中出现的所有的标识符一一进行扣留操作的话，在判断两个标识符是否为同 一个时，只需要比较它们的指针就可以了。这比用 strcmp() 更快。
而 crowbar 对于局部变量、全局变量和函数则分别使用链表进行管理。一旦语句中 出现变量名时，将从链表头部开始检索（采用线性检索）。如果要优化这个部分，可以 考虑引入缓存、树或二分法查找等。刚才提到的这些数据结构及算法，都是编程语言语 言处理器普遍使用的，读者可以自行查阅相关图书或网站。
一般来说，我们将编译器保存变量名、函数名的数据结构称为“符号表”。

3.2.3 调试模块 DBG
DBG 是调试时使用的模块，具备若干功能，在 crowbar 的代码中使用的话， 只需要调用宏 DBG_assert() 及 DBG_panic() 即可。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3.3　crowbar ver.0.1 的实现 0 7 7
/* 断言这里 a 的值应该为 5 */ DBG_assert(a == 5, (“a..%d”, a));
这 样 书 写 的 话， 当 a == 5 这 一 条 件 不 成 立 时， 程 序 会 将 该 处 的 源 代 码 行 号 输 出 并 执 行 abort()。 第 二 个 入 口 参 数 则 是 将 想 要 输 出 的 东 西 传 递 给 printf() 并格式化（因为宏无法使用可变长度的参数，因此需要从第二参数 起全部用括号括起来）。
DBG 的输出目标可以通过 DBG_set_debug_write_fp() 函数进行更改， 标准输出目标是 stderr。而输出目标无论如何更改，stderr 仍然会保留一份同样 的信息。因此如果不做任何更改的话，会看到 stderr 输出的是两行同样的信息。  DBG_panic() 函数可以书写在一些程序不应该进入的分支处。典型的例子 就是 switch case 的 default 分支，如：
/* 变量 operator 通过 switch case 判断分支条件 default 分支在正常情况下不应当进入 */
default: DBG_panic((“bad case...%d”, operator));
与 DBG_assert() 一样，用两层括号包裹，最终会通过 printf() 格式化 输出。  DBG_assert() 与 DBG_panic() 都是宏，只要在定义 #define DBG_NO_ DEBUG 的状态下编译，就可以完全删除执行文件中的调试部分。.
3.3 crowbar ver.0.1 的实现
预先准备已经差不多了，终于可以开始阅读 crowbar.book_ver.0.1 的代码了。
3.3.1 crowbar 的解释器——CRB_Interpreter
一般来说，程序的数据结构要比运行流程更加重要，因此我们就从 crowbar 解释器所用的结构体 CRB_Interpreter 开始看起。
想使用 crowbar，首先需要生成解释器，然后将解释器的源码传递给编译器 （生成分析树），就可以运行了。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 7 8 第 3 章　制作无类型语言 crowbar

解 释 器 的 定 义 如 下 所 示（位 于 crowbar.h）。 注 意 CRB.h 中 公 开 的 CRB_ Interpreter 是这个结构体的不完全定义，下面这个结构体定义本身对外是隐 藏的。

struct CRB_Interpreter_tag {

MEM_Storage

interpreter_storage;

MEM_Storage

execute_storage;

Variable

*variable;

FunctionDefinition *function_list;

StatementList

*statement_list;

int

current_line_number;

};

解释器会保存以下内容：

1. 与解释器相同生命周期的 MEM_Storage（interpreter_storage） 不再需要分析树时，需要将其释放，如 3.2.2 节所述，可以使用内存管理模
块 MEM 提供的存储器功能来管理。  interpreter_storage 存储器，在解释器生成时被生成，解释器废弃的 同时被释放。通过 CRB_Interpreter 自己来开辟这个存储器。
该存储器在内存中的开辟，是通过位于 util.c 中的 crb_malloc() 工具函数 实现的。

2. 运行时使用的 MEM_Storage（execute_storage） execute_storage 是运行时使用的存储器。不过由于运行时必备的数据结 构大多数都没有固定的释放顺序，因此 execute_storage 现阶段主要用于存 放全局变量。

3. 全局变量链表（variable） Variable 结构体的定义如下所示：

typedef struct Variable_tag {

char

*name; /* 变量名 */

CRB_Value value; /* 变量值 */

struct Variable_tag *next; /* 指向下一个变量的指针 */

} Variable;

首 先 这 个 结 构 体 中 有 next 这 一 成 员， 这 是 为 了 构 建 链 表 用 的。CRB_ Interpreter 的成员 variable 保存在最开头。通过这样的链表，可以得到所 有的全局变量。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3.3　crowbar ver.0.1 的实现 0 7 9

crowbar 中变量是在首次赋值时生成的，因此在运行时会有变量逐一进入， 链表也会越来越长。  Variable 结构体的 name 成员顾名思义会保存变量名，而 value 成员则会 保存该变量的值，具体请参考 3.3.8 节对 CRB_Value 的说明。

4. 函数定义链表（function_list） function_list 是记录 crowbar 中编写函数的链表。语法解析时会创建这 个 function_list 以及下面的 statement_list。  FunctionDefinition 类型的定义如下所示：

typedef enum { CROWBAR_FUNCTION_DEFINITION = 1, NATIVE_FUNCTION_DEFINITION
} FunctionDefinitionType;

/* crowbar 中定义过的函数 */ /* 内置函数 */

typedef struct FunctionDefinition_tag {

char

*name; /* 函数名 */

FunctionDefinitionType

type; /* 函数的类型 */

union {

struct {

ParameterList

*parameter; /* 参数的定义 */

Block

*block;

/* 函数的主体 */

} crowbar_f;

struct {

CRB_NativeFunctionProc

*proc; /* 后文详述 */

} native_f;

} u;

struct FunctionDefinition_tag

*next; /* 链表用 */

} FunctionDefinition;

 FunctionDefinition 类型的 type 成员中，会区分 crowbar 定义的函数 以及内置函数。crowbar 定义的函数会使用下面联合体 u 的 crowbar_f，而内置 函数则会使用 native_f。通过这种方法，可以让没有继承概念的 C 语言实现类 似继承的功能（具体方法之后会慢慢提到）。
crowbar 定义的函数会通过 crowbar_f 成员保存其函数参数及函数主体 （执行语句）。ParameterList 结构体如下所示，会将变量名做成链表并保存 （crowbar 是无类型语言，无需保存变量类型）。

typedef struct ParameterList_tag {

char

*name;

/* 变量名 */

struct ParameterList_tag *next; /* 链表所用指针 */

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 8 0 第 3 章　制作无类型语言 crowbar

} ParameterList;
用 block 成 员 保 存 函 数 的 执 行 语 句。block 是 Block 类 型 的 结 构 体，Block 类型的定义如下所示：

typedef struct { StatementList
} Block;

*statement_list;

 StatementList 正如其名称，是语句的链表。其结构体内容请参考第 5 项。

5. 语句链表（statement_list）  statement_list 是语句的链表。其类型与上面的 Block 结构体保存时所 用的 StatementList 类型相同。无论是函数定义 { } 内的语句，还是顶层结 构中的语句，从内部来讲都保存在 StatementList 中。
crowbar 的解释器在语法解析后，顶层结构的语句，也就是 statement_ list 最开头保存的语句会按照顺序开始执行。

6. 编译时当前的行号（current_line_number） 出现错误信息需要行号。current_line_number 可以在编译时显示当前
的行号。  current_line_number 在编译结束后不会再使用。运行时如果发生错误 当然也需要显示行号，这里的行号保存在分析树的语句节点中。

  补充知识    不完全类型 
 CRB_Interpreter 类型结构体是在 crowbar 的私有头文件 crowbar.h 中定义的。 不过这是供解释器内部使用的数据结构，不应该向外部公开。
而生成解释器的函数 CRB_create_interpreter()，它的原型定义则是在公有 头文件 CRB.h 中：
CRB_Interpreter *CRB_create_interpreter(void);
 CRB_create_interpreter() 返回值的类型为 CRB_Interpreter*，为了支 持这样的原型定义必须首先定义 CRB_Interpreter 结构体。但是我们不能把解释器 的内部定义直接拿出来放在公有头文件中。
应对这种情况可以使用 不完全类型 。公有头文件中只定义结构体的标识符，实际的 定义是由私有头文件传递给公有头文件的。
比如上面的 CRB_Interpreter 类型，在 CRB.h 中可以做如下的标识符定义，并 用 typedef 命名。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3.3　crowbar ver.0.1 的实现 0 8 1

代码清单 3-4 crowbar.l 

typedef struct CRB_Interpreter_tag CRB_Interpreter;
这种状态的 CRB_Interpreter 就是不完全类型。 不完全类型只能使用指针，即指向不完全类型的指针的变量无法被声明，不完全类 型本身也无法声明变量，对不完全类型无法使用 sizeof。因此，我们是无法知道一个 不完全类型的大小的，当然也无法引用其成员。 而 crowbar.h 是类型初始定义所在的地方，因此没有这些限制（详见 3.3.1 节）。 这里的 CRB_Interpreter 类型就不是不完全类型。 上述都是 C 语言编程中必须掌握的一些技巧，但我意外地发现似乎了解的人不多， 因此写了下来。

3.3.2 词法分析——crowbar.l

crowbar 的 lex 定义文件是 crowbar.l。源代码的摘录版本如代码清单 3-4 所示。

. 1: %{

  省略 C 编码部分

19: %}

开始条件

20: %start COMMENT STRING_LITERAL_STATE

21: %%

保留字的定义

22: <INITIAL>"function"

return FUNCTION;

23: <INITIAL>"if"

return IF;

省略其他的保留字定义

符号类的定义。LP，RP 是 Left/Right Paren 的缩写

LC，RC 是 Left/Right Curly（花括号）的缩写

35: <INITIAL>"("

return LP;

36: <INITIAL>")"

return RP;

37: <INITIAL>"{"

return LC;

38: <INITIAL>"}"

return RC;

省略其他的符号定义

标识符（变量名、函数名等）

55: <INITIAL>[A-Za-z_][A-Za-z_0-9]* {

56:

yylval.identifier = crb_create_identifier(yytext);

57:

return IDENTIFIER;

58: }

数值。整数类型与实数类型分别处理，与 mycalc.y 相同

59: <INITIAL>([1-9][0-9]*)|"0" {

60:

Expression *expression = crb_alloc_expression(INT_EXPRESSION);

61:

sscanf(yytext, "%d", &expression->u.int_value);

62:

yylval.expression = expression;

63:

return INT_LITERAL;

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 8 2 第 3 章　制作无类型语言 crowbar

64: }

65: <INITIAL>[0-9]+\.[0-9]+ {

66:

Expression *expression = crb_alloc_expression(DOUBLE_EXPRESSION);

67:

sscanf(yytext, "%lf", &expression->u.double_value);

68:

yylval.expression = expression;

69:

return DOUBLE_LITERAL;

70: } 定义字符串开始

71: <INITIAL>\" {

72:

crb_open_string_literal();

73:

BEGIN STRING_LITERAL_STATE;

74: }

75: <INITIAL>[ \t] ; 遇到换行符则增加行号

76: <INITIAL>\n {increment_line_number();} 定义注释的开始

77: <INITIAL>#

BEGIN COMMENT;

如果不符合上述定义，则为非法字符并报错

78: <INITIAL>.

{

79:

char buf[LINE_BUF_SIZE];

80:

81:

if (isprint(yytext[0])) {

82:

buf[0] = yytext[0];

83:

buf[1] = '\0';

84:

} else {

85:

sprintf(buf, "0x%02x", (unsigned char)yytext[0]);

86:

}

87:

88:

crb_compile_error(CHARACTER_INVALID_ERR,

89:

STRING_MESSAGE_ARGUMENT, "bad_char", buf,

90:

MESSAGE_ARGUMENT_END);

91: }

92: <COMMENT>\n

{

93:

increment_line_number();

94:

BEGIN INITIAL;

95: }

96: <COMMENT>.

;

97: <STRING_LITERAL_STATE>\"

{

98:

Expression *expression = crb_alloc_expression(STRING_EXPRESSION);

99:

expression->u.string_value = crb_close_string_literal();

100: yylval.expression = expression;

101: BEGIN INITIAL;

102: return STRING_LITERAL;

103: }

104: <STRING_LITERAL_STATE>\n

{

105: crb_add_string_literal('\n');

106: increment_line_number();

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3.3　crowbar ver.0.1 的实现 0 8 3

107: } 108: <STRING_LITERAL_STATE>\\\" 109: <STRING_LITERAL_STATE>\\n 110: <STRING_LITERAL_STATE>\\t 111: <STRING_LITERAL_STATE>\\\\ 112: <STRING_LITERAL_STATE>. 113: %%

crb_add_string_literal('"'); crb_add_string_literal('\n'); crb_add_string_literal('\t'); crb_add_string_literal('\\'); crb_add_string_literal(yytext[0]);

crowbar.l 与之前计算器的例子 mycalc.l 相比（代码清单 2-1）要长很多，但 本质上没有太大变化，只是使用了新的 开始条件 功能。与 mycalc.l 不同的是，在 crowbar.l 的大部分规则前都要书写 <INITIAL>，这就是开始条件。
在 crowbar 中，开始条件主要用于分割注释与字面常量（literal）。 crowbar 的注释由 # 开头直到行尾，可以用简单的正则表达式 #.*$ 将其分 割，分割出的注释暂时保存在全局变量 yytext 中。 在 以 前 的 lex 处 理 器 中， 给 yytext 分 配 了 一 个 固 定 大 小 的 char 数 组， 而 且 数 组 的 大 小 是 无 法 扩 展 的。 不 过 包 含 flex 在 内， 最 近 发 布 的 lex 处 理 器 中，yytext 已经更改为 char*，当一个很长的记号进入时，也可以动态扩展储 存空间，注释最终也是要被丢弃的，如果还在这里特意去扩展存储空间的话，就 显得有点笨了。 crowbar 的字面常量与 C 语言一样，是包含 \n 和 \t 的，还可以通过 \" 显示 双引号本身，因此简单通过 \".*\" 的正则表达式规则进行匹配是不行的。 应对这种情况可以使用开始条件。在动作中书写 BEGIN COMMENT 切换 lex 的 状 态， 其 对 应 的 规 则 就 变 成 后 面 用 <COMMENT> 开 始 的 部 分 了。lex 使 用 INITIAL 定义了开始条件的初始状态。 crowbar.l 中，通过下面的处理将注释读入并丢弃。

77: <INITIAL>#

BEGIN COMMENT;

中间省略

92: <COMMENT>\n

{

93:

increment_line_number();

94:

BEGIN INITIAL;

95: }

96: <COMMENT>.

;

代码第 77 行，INITIAL 状态下如果有 # 进入，则转换为 COMMENT 状态。 crowbar 的注释由 # 开始直至行尾，因此在 COMMENT 状态下如果遇到换行则切换 回 INITIAL 状态（第 92 ～ 95 行的 increment_line_number() 会在后文详 述）。所以，COMMENT 状态下会将除换行符以外的字符全部丢弃（第 96 行）。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 8 4 第 3 章　制作无类型语言 crowbar

关 于 字 符 串 的 字 面 常 量 处 理， 开 始 时 调 用 crb_open_string_literal()，中间的字符通过 crb_add_string_literal() 追加，最后通过 crb_ close_string_literal() 结束一个字符串的处理。
在 这 个 过 程 中， 字 符 串 会 被 保 存 在 string.c 的 st_string_literal_ buffer 这一 static 变量中。我本人对于使用 static 变量还是有些抵制的， 但是鉴于我们只能把 yacc/lex 作为工具来使用，即使有什么想法也无法修改（至 少老版本是不允许修改的），因此 crowbar 最终还是允许在编译器中使用静态变量 的（请参考本节的补充知识）。
语言处理器在编译时如果发生错误，需要显示错误信息，因此错误信息中必 须包含行号。
在 crowbar.l 中的对应处理是，每换行一次，行号都会进行计数。具体来说有 以下三处：
76: <INITIAL>\n {increment_line_number();}

…

92: <COMMENT>\n

{

93:

increment_line_number();

94:

BEGIN INITIAL;

95: }

…

104: <STRING_LITERAL_STATE>\n

{

105:

crb_add_string_literal('\n');

106:

increment_line_number();

107: }

这 里 进 行 计 数 的 行 号 保 存 在 CRB_Interpreter 的 current_line_ number 中。

  补充知识    静态变量的许可范围 
如上文所写，在词法分析中，正在读入的字符串会保存在 string.c 的 st_string_ literal_buffer 中。 在 编 译 时， 当 前 的 编 译 器 会 保 存 在 util.c 的 st_current_ interpreter 中。而在 yacc/lex 中，还会使用 yytext 等全局变量。
使用如此多的静态变量，首当其冲会遇到的就是多线程问题。 当下多线程的程序已经很普及了，静态变量可以在多线程之间共享，因此多个线程 如果同时进行编译的话可能会引发问题。 不过一般来说，编译过程都是一下子就能结束的，因此在这样短的时间内通过加一 个全局锁的方式就可以解决问题了。正因为有这样既简单又实用的方法，crowbar 才放 心地允许在编译过程中使用静态变量。而静态变量仅在编译过程中被使用，一旦程序开

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3.3　crowbar ver.0.1 的实现 0 8 5

* 在 后 面 写 到 的 Diksam 中， 具 备 与 C 语 言 的 #include 相 对 应 的 功 能 require， 同 样由于解析器不能进行 递归，会在解析完一个 文 件 后， 才 开 始 解 析 被 require 的文件。

始运行后就无法使用了。具体来说，由于 MEM 模块会静态地保存内存块链表，这原本 就是以调试为目的创建的链表，可以随时删除，而由于 MEM 模块位于系统最底层，因 此可以对 MEM_malloc() 的运行进行加锁处理。
使用静态变量还会造成另一个问题，就是编译器无法递归运行。比如 crowbar 中的 库函数都书写在独立文件中，在 C 语言中理论上只需要用 #include 就能很简单地把 功能包含进来。但是实际应用中就会发现，使用 #include 包括进来的独立文件，在 编译过程中如果再开始一个解析器，之前的静态变量就会被覆盖。
标准版的 yacc/lex，由于使用了 yytext 等全局变量，因此也无法支持多线程或使用 递归。不过 bison 有单独的扩展可以让其支持多线程。*
3.3.3 分析树的构建——crowbar.y 与 create.c
crowbar 中 yacc 的定义文件为 crowbar.y。从构成来说，与计算器版的 mycalc.y 没有什么变化。
但是在计算器中，归约是在实际进行计算时才进行的，而 crowbar.y 则是在 构建分析树时进行的。
比如一个加法算式（如 10 + a）会按照以下的规则构建：

additive_expression （中间省略） | additive_expression ADD multiplicative_expression { $$ = crb_create_binary_expression(ADD_EXPRESSION, $1, $3); }
这 里 的 additive_expression 对 应 mycalc.y 中 的 expression，.multiplicative_expression 对应 term。
在 动 作 中，crb_create_binary_expression() 被 调 用， 其 实 际 运 行 代码在 create.c 中。这个函数负责常量折叠（参考 3.3.4 节），所以稍微有些复杂， 将这部分以外的核心代码精简一下，可以看到这个函数的主要逻辑如下所示：

Expression * crb_create_binary_expression(ExpressionType operator,
Expression *left, Expression *right) {
Expression *exp; exp = crb_alloc_expression(operator); exp->u.binary_expression.left = left; exp->u.binary_expression.right = right;

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 8 6 第 3 章　制作无类型语言 crowbar

return exp; }
 crb_alloc_expression() 将开辟一个存放 Expression 类型结构体的 内存空间，并将其返回。Expression 类型在 crowbar.h 中的定义如下所示：

struct Expression_tag { ExpressionType type; ←表示表达式的类别

int line_number; union {

←用联合体保存不同种类对应的值

CRB_Boolean

boolean_value;

int

int_value;

double

double_value;

char

*string_value;

char

*identifier;

AssignExpression

assign_expression;

BinaryExpression

binary_expression;

Expression

*minus_expression;

FunctionCallExpression function_call_expression;

} u;

};

这个结构体在分析树中用来表示“表达式”的类型。与 CRB_Value 一样， 用枚举类型的 ExpressionType 表示表达式的类型，用联合体保存各种类型对 应的值。  ExpressionType 具体定义如下：

typedef enum {

BOOLEAN_EXPRESSION = 1,

/* 布尔型常量 */

INT_EXPRESSION,　　　　　　　 /* 整数型常量 */

DOUBLE_EXPRESSION,

/* 实数型常量 */

STRING_EXPRESSION,

/* 字符串型常量 */

IDENTIFIER_EXPRESSION,

/* 变量 */

ASSIGN_EXPRESSION,

/* 赋值表达式 */

ADD_EXPRESSION,

/* 加法表达式 */

SUB_EXPRESSION,

/* 减法表达式 */

MUL_EXPRESSION,

/* 乘法表达式 */

DIV_EXPRESSION,

/* 除法表达式 */

MOD_EXPRESSION,

/* 求余表达式 */

EQ_EXPRESSION,

/* == */

NE_EXPRESSION,

/* != */

GT_EXPRESSION,　　　　　　 /* > */

GE_EXPRESSION,

/* >= */

LT_EXPRESSION,　　　　　　　 /* < */　

LE_EXPRESSION,

/* <= */　

LOGICAL_AND_EXPRESSION,

/* && */　

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3.3　crowbar ver.0.1 的实现 0 8 7

 图 3-4 10+a+b 的分析树 

LOGICAL_OR_EXPRESSION,

/* || */　

MINUS_EXPRESSION,

/* 单目取负 */　

FUNCTION_CALL_EXPRESSION, /* 函数调用表达式 */　

NULL_EXPRESSION,

/* null 表达式 */　

EXPRESSION_TYPE_COUNT_PLUS_1

} ExpressionType;

这其中从 ADD_EXPRESSION 到 LOGICAL_OR_EXPRESSION，都在使用联合 体的 binary_expression 成员。  binary_expression 的类型是 BinaryExpression，其定义如下所示：

typedef struct { Expression *left; Expression *right;
} BinaryExpression;
 crb_create_binary_expression()最终返回这样构建出的 Expression 的 指针，并在 crowbar.y 中将其赋值给 $$。 $$ = crb_create_binary_expression(ADD_EXPRESSION, $1, $3);
比如 10 + a + b 这样的语句，按上面的处理就会构建出如图 3-4 的分析树。

+

+

b

10

a

那么，接下来是 crb_alloc_expression() 函数，这个函数只是简单地 用 crb_malloc() 开辟 Expression 的空间，并且将 type 连同刚被设置的行 号一起返回。
crb_alloc_expression(ExpressionType type) {
Expression *exp;
exp = crb_malloc(sizeof(Expression)); exp->type = type; exp->line_number = crb_get_current_interpreter()->current_line_number;
return exp; }

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 8 8 第 3 章　制作无类型语言 crowbar

在分析树中，不单是表达式，语句（statement）也很重要。构建语句的思路 与表达式基本是一样的，关联的结构体定义从 crowbar.h 中摘录如下：

struct Statement_tag {

StatementType

type;

int

line_number;

union {

Expression

*expression_s;

GlobalStatement global_s;

IfStatement

if_s;

WhileStatement while_s;

ForStatement for_s;

ReturnStatement return_s;

} u;

};

/* 表达式语句 */ /* global 语句 */ /* if 语句 */ /* while 语句 */ /* for 语句 */ /* return 语句 */

随便举一个联合体的例子，比如 WhileStatement 的定义如下所示：

typedef struct {

Expression *condition;

Block

*block;

} WhileStatement;

/* 条件表达式 */ /* 可执行块 */

 Block 在 3.3.1 节中已经出现过一次，即一段用花括号包裹的代码段类型。

 StatementType 的一览表如下所示：

typedef enum { EXPRESSION_STATEMENT = 1, GLOBAL_STATEMENT, IF_STATEMENT, WHILE_STATEMENT, FOR_STATEMENT, RETURN_STATEMENT, BREAK_STATEMENT, CONTINUE_STATEMENT, STATEMENT_TYPE_COUNT_PLUS_1
} StatementType;
 BREAK_STATEMENT 和 CONTINUE_STATEMENT 现阶段都没有信息需要保存
（如果想像 Java 那样支持标签或 break 语句的话就需要保存了），因此没有对应
的联合体成员。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3.3　crowbar ver.0.1 的实现 0 8 9

3.3.4 常量折叠

比如

a = a + 10 * 2;
这样一个表达式，其实与

a = a + 20;

是同值的。诸如这种纯常量构成的表达式或部分表达式，在编译时提前被计

算出来的处理方式叫作 常量折叠（  constant.folding）。由于编译时这部分计算就已

经完成了，所以能有效地提高运行速度。

crowbar 中也部分引入了常量折叠的处理。具体来说，在进行整数型与实数

* 字符串的加法不会做折 叠处理。确实代码中有 时候需要有长文本信 息，但是按当前版本的 处理方式，连接前的字 符 串 是 无 法 被 释 放 的， 也就是说其实这里是我 偷懒了。

型相关的四则运算或者单目取负时会进行常量折叠 *。这部分代码本书不会进行 详细说明，请参考 create.c 的 crb_create_binary_expression() 和 crb_ create_minus_expression()。
crowbar 中的常量折叠其实可以归入所谓程序最优化（optimization）的范畴， 在语言的制作阶段考虑最优化本来为时尚早，但是由于 crowbar 的目标是类似 C 的语言，这种优化在部分场景中是必须的。比如 C 语言在一些特定地方只能写常

* ISO-C99 规范中，auto

量表达式（static 变量的初始化或数组的大小指定等 *），这些地方需要支持常

的数组也可以不是常量。 量折叠的处理。

程序优化是指通过不断调整程序以提高代码的运行速度，但是调整的结果

到底是不是“最优”其实不好评判，因此有些人提出“最优化”这个用词是不恰

当的。

* 可能很多读者会认为显 示错误信息只有英语就 足够了，不过对于初级 用户来说，英文的错误 信息可能有点难以理解 吧。 更 重 要 的 理 由 是： 我觉得自己的英语水平 还不够。
* 不过一般公司对于数据 的管理都是比较严格 的，可能没有办法用 U 盘携带数据吧。

3.3.5 错误信息
错误信息考虑到需要支持多语言 *，所以一般尽可能避免硬编码出现在代码 中，最好以提供外部文件的方式实现。但是在开始设计 crowbar 这样的脚本语言 时，我非常希望 crowbar 只通过一个可执行文件就能运行。比如我想去别的地方 做一些文字处理工作，那么只需要把 crowbar 的唯一一个可执行文件拷入 U 盘就 可以拿去用了。*

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 9 0 第 3 章　制作无类型语言 crowbar

代码清单 3-5 error_message.c

因此 crowbar 还是选择将错误信息硬编码在 error_message.c 的源文件中，参
看代码清单 3-5。
. MessageFormat crb_compile_error_message_format[] = {
 { "dummy"}, { "($(token) 附近有语法错误 )"}, { " 错误的字符 ($(bad_char))"}, { " 函数名重复 ($(name))"}, { "dummy"},
};

MessageFormat crb_runtime_error_message_format[] = {
{ "dummy"}, { " 找不到变量 ($(name))。"}, { " 找不到函数 ($(name))。"}, { " 传递的参数多于函数所要求的参数。"}, { " 传递的参数少于函数所要求的参数。"}, { " 条件语句类型必须为 boolean 型 "},

…

{ "dummy"}, };

通过这种方式，将来如果要支持多语言的话，可以简单地通过修改外部文件

来 实 现。 而 设 置 crb_compile_error_message 与 crb_runtime_error_

message 这两个数组，是为了将编译时的错误信息与运行时的错误信息区分开

来。这些数组的索引，与 crowbar.h 中对应的枚举型的值是一致的。

 代码清单 3-6 crowbar.h 的错误信息 枚举型定义

typedef enum {  PARSE_ERR = 1,  CHARACTER_INVALID_ERR,  FUNCTION_MULTIPLE_DEFINE_ERR,  COMPILE_ERROR_COUNT_PLUS_1 } CompileError;

typedef enum {  VARIABLE_NOT_FOUND_ERR = 1,  FUNCTION_NOT_FOUND_ERR,  ARGUMENT_TOO_MANY_ERR,

…

 RUNTIME_ERROR_COUNT_PLUS_1 } RuntimeError;

代码清单 3-5 中的错误信息，包含了一个 $(token) 这样的字符串，这是错 误信息中的可变部分。比如找不到一个名为 hoge 的变量时，如果能报出“找不

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3.3　crowbar ver.0.1 的实现 0 9 1

* 只适用于运行出错。如
果 是 编 译 出 错， 则 调
用 crb_compile_er-
ror()。

到变量 (hoge)”，要比只报“找不到变量”对用户更加友好。
为 了 实 现 错 误 信 息 中 可 以 包 含 变 量， 显 示 错 误 信 息 时 会 调 用 下 面 的 函
数 crb_runtime_error()*。
crb_runtime_error(expr->line_number, /* 行号 */ VARIABLE_NOT_FOUND_ERR, /* 枚举错误信息类别 */ STRING_MESSAGE_ARGUMENT, /* 可变部分的类型 */ "name", /* 可变部分的标识符 */ expr->u.identifier, /* 所要显示的值 */ MESSAGE_ARGUMENT_END);

第一个参数是行号（在 create.c 中 Expression 结构体中设定），下一个参 数是错误类别（crowbar.h 中的 RuntimeError 枚举型），之后的三个参数为一 组，对应错误信息的可变部分。STRING_MESSAGE_ARGUMENT 代表信息类型 （相当于 printf() 中使用的 %s），name 即错误信息中的 $(name)，expr->u. identifier 则表示可变部分要显示的字符串。由于可变部分可以有多个，因 此 crb_runtime_error 为一个变长参数，所以可以用 MESSAGE_ARGUMENT_ END 表示参数输入结束。
当 前 版 本 无 论 是 编 译 错 误 还 是 运 行 错 误， 显 示 错 误 信 息 后 都 会 立 即 调 用 exit() 终止程序。这样的处理其实还远远不够，如果用于扩展应用程序的话 这样做更是致命的，因此应当参考 9.2.1 节加入异常处理机制。

  补充知识    关于 crowbar 中使用的枚举型定义 

比如在代码清单 3-6 中的 CompileError 类型，我特意将第一个元素 PARSE_ ERR 设置为 1，而最后一个元素引入了名为 COMPILE_ERROR_COUNT_PLUS_1 的可变 元素。

typedef enum { PARSE_ERR = 1,

←特意设置为1

CHARACTER_INVALID_ERR, FUNCTION_MULTIPLE_DEFINE_ERR, COMPILE_ERROR_COUNT_PLUS_1 ←可变元素

} CompileError;

类似这样的处理方式不只有 CompileError 类型。比如用于显示 Expression 类 别的 ExpressionType 类型也采用同样的构造。
特意这样设置的理由有下面几个。

1.　假如忘记进行初始化时，变量中被置入 0 的概率是非常高的，那么枚举类型如 果从 1 开始的话，可以更早地发现异常状态。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 9 2 第 3 章　制作无类型语言 crowbar

2.　有了 COMPILE_ERROR_COUNT_PLUS_1 这个可变元素，就可以借助其遍历所 有枚举元素，并在后续程序中利用这一特性进行更丰富的处理。
当然实际使用时，我发现这两处设置似乎也不是特别有效。 另外在错误信息中，错误信息数组的第一个和最后一个元素都是 dummy，这是为 了防止在以后修改时只改了 crowbar.h 中的枚举类型，而忘记修改 error_message.c 中 的对应错误信息，这样设置的话能在一定程度上自动检测这种遗漏（请参考 error.c 中 的 self_check() 函数）。
MessageFormat crb_compile_error_message_format[] = {  {"dummy"},
 {"dummy"}, };
.
3.3.6 运行——execute.c

…

crowbar 程序的运行是从 CRB_interpret() 开始的，其函数实现如下：

void CRB_interpret(CRB_Interpreter *interpreter) {
interpreter->execute_storage = MEM_open_storage(0); crb_add_std_fp(interpreter); crb_execute_statement_list(interpreter, NULL, interpreter->statement_list); }

第一行准备了运行时要用的 MEM_Storage，第二行的函数 crb_add_std_

fp() 注册了三个内部全局变量 STDIN、STDOUT 和 STDERR，然后通过 crb_

execute_statement_list() 将解释器中保存的语句链表按顺序执行。

那么我们就来看一看 crb_execute_statement_list() 函数（代码清单

3-7）。

代码清单 3-7 crb_execute_statement_list()

StatementResult crb_execute_statement_list(CRB_Interpreter *inter, LocalEnvironment
*env, StatementList *list) {  StatementList *pos;  StatementResult result;

 result.type = NORMAL_STATEMENT_RESULT;  for (pos = list; pos; pos = pos->next) {

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3.3　crowbar ver.0.1 的实现 0 9 3

    }

result = execute_statement(inter, env, pos->statement); if (result.type != NORMAL_STATEMENT_RESULT)
goto FUNC_END;

FUNC_END:  return result; }

即按照链表的顺序，调用 execute_statement()。

execute_statement() 则会根据不同的 Statement 类型执行不同的处

理（代码清单 3-8）。

 代码清单 3-8

.

execute_statement()

static StatementResult

execute_statement(CRB_Interpreter *inter, LocalEnvironment *env,



Statement *statement)

{

 StatementResult result;

 result.type = NORMAL_STATEMENT_RESULT;

 switch (statement->type) {

 case EXPRESSION_STATEMENT:



crb_eval_expression(inter, env, statement->u.expression_s);



break;

 case GLOBAL_STATEMENT:



result = execute_global_statement(inter, env, statement);



break;

 case IF_STATEMENT:



result = execute_if_statement(inter, env, statement);



break;

 case WHILE_STATEMENT:



result = execute_while_statement(inter, env, statement);



break;

…

 case STATEMENT_TYPE_COUNT_PLUS_1: /* FALLTHRU */

 default:



DBG_panic(("bad case...%d", statement->type));

 }

 return result; }
execute_statement() 的第二个参数需要传递 LocalEnvironment 类型 的结构体（指向其的指针）。这个结构体保存了当前运行中的函数的局部变量，

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 9 4 第 3 章　制作无类型语言 crowbar

如果函数还没有运行，则传递 NULL。

execute_statement() 内部采用了 switch case 来区分条件处理。如

果将其调用的函数全部进行分析的话有点浪费篇幅了，这里以 while 语句调用

的 execute_while_statement() 为代表进行说明（代码清单 3-9，移除了错

误检查等与核心功能无关的代码）：

代码清单 3-9

.

execute_while_state-

ment() 

static StatementResult execute_while_statement(CRB_Interpreter *inter, LocalEnvironment
*env, Statement *statement) {  StatementResult result;  CRB_Value cond;

 result.type = NORMAL_STATEMENT_RESULT;  for (;;) { /* 首先是一个无限循环 */
/* 通过条件语句判别 */ cond = crb_eval_expression(inter, env, statement->u.while_
s.condition); /* 条件为真则结束循环 */ if (!cond.u.boolean_value)
break;

/* 条件不为真则执行内部语句 */ result = crb_execute_statement_list(inter, env,
statement->u.while_s.block ->statement_list);

/* break, continue, return 的处理 */ if (result.type == RETURN_STATEMENT_RESULT) {
break; } else if (result.type == BREAK_STATEMENT_RESULT) {
result.type = NORMAL_STATEMENT_RESULT; break; } }

return result; }
 if 语句或 while 语句都会包含一些内部的语句，这些内部语句被称为嵌套 （nest）。在 crowbar 中，如果存在嵌套，则不会进行递归，而是转向运行嵌套内的
语句。 事实上，实现上面的机制主要用到的是 break、continue、return 等，从

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3.3　crowbar ver.0.1 的实现 0 9 5

* Ruby 的 设 计 中 也 使 用
了这种必杀技。

某种程度上来说用 goto 实现结构控制反而非常麻烦。  break、continue、return 等出现时，必须从递归的最深处强制返回上层。  break 或 continue 的 作 用 是 从 最 内 层 的 循 环 中 跳 出， 当 然 break. 或 continue 很可能会出现在很多层嵌套的 if 语句中，而无论其出现在哪里， 正在进行的递归都必须从最底层一次性返回，这是不会改变的。
为了实现这一点，我们有一个“必杀技”可以使用——setjmp()/longjmp()*。 这个必杀技还被应用到异常处理机制中，因此在 crowbar 中，返回值与结束状态 会逐步返回。 execute_statement() 以及内部被调用的函数群 execute_XXX_statement()，返回值均为 StatementResult 的结构体。StatementResult 的定 义如下：

typedef enum { NORMAL_STATEMENT_RESULT = 1, RETURN_STATEMENT_RESULT, BREAK_STATEMENT_RESULT, CONTINUE_STATEMENT_RESULT, STATEMENT_RESULT_TYPE_COUNT_PLUS_1
} StatementResultType;

typedef struct {

StatementResultType type;

union {

CRB_Value

return_value;

} u;

} StatementResult;

通常，type 会返回一个装入 NORMAL_STATEMENT_RESULT.的 StatementResult， 而 当 执 行 return、break、continue 时， 则 分 别 在 RETURN_STATEMENT_ RESULT、BREAK_STATEMENT_RESULT、CONTINUE_STATEMENT_RESULT 装入对 应 的 StatementResult 并 返 回。 此 外， 在 代 码 清 单 3-9 的 execute_while_ statement() 等中会根据执行语句的返回值不同而所有不同，如果是 BREAK_ STATEMENT_RESULT 或 RETURN_STATEMENT_RESULT 则 会 中 断 循 环， 而 如 果 是 continue 的话，只会中断 crb_execute_statement_list() 中的运行。
如果是 return，那么不只要中断函数的运行，还要携带其返回值返回，此 时会将返回值放入 StatementResult 的 return_value 中。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 9 6 第 3 章　制作无类型语言 crowbar

3.3.7 表达式求值——eval.c

代码清单 3-10 eval_expression() 

表达式求值在 eval.c 中进行。 表达式求值，是在调用分析树进行递归下降分析后，通过对分析结果进行 运算来实现的。其运算结果会装入 CRB_Value 结构体中并返回。关于 CRB_ Value 的定义请参考 3.3.8 节。 语句的运行是通过 execute_statement() 中的 switch case 判断分支 条件来实现的，而表达式求值则是通过 eval_expression() 来执行的（代码 清单 3-10）。

static CRB_Value

eval_expression(CRB_Interpreter *inter, LocalEnvironment *env,



Expression *expr)

{

 CRB_Value v;

 switch (expr->type) {

 case BOOLEAN_EXPRESSION: /* 布尔型变量 */

v = eval_boolean_expression(expr->u.boolean_value);

break;

case INT_EXPRESSION: /* 整数型变量 */

v = eval_int_expression(expr->u.int_value);

break;

case DOUBLE_EXPRESSION: /* 实数型变量 */

v = eval_double_expression(expr->u.double_value);

break;

case STRING_EXPRESSION: /* 字符串变量 */

v = eval_string_expression(inter, expr->u.string_value);

break;

case IDENTIFIER_EXPRESSION: /* 变量 */

v = eval_identifier_expression(inter, env, expr);

break;

case ASSIGN_EXPRESSION: /* 赋值表达式 */

v = eval_assign_expression(inter, env,

expr->u.assign_expression.variable,

expr->u.assign_expression.operand);

break;

/* 大部分二元运算符都整合在 eval_binary_expression() 中 */

case ADD_EXPRESSION:

/* FALLTHRU */

case SUB_EXPRESSION:

/* FALLTHRU */

case MUL_EXPRESSION:

/* FALLTHRU */

case DIV_EXPRESSION:

/* FALLTHRU */

case MOD_EXPRESSION:

/* FALLTHRU */

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3.3　crowbar ver.0.1 的实现 0 9 7
case EQ_EXPRESSION: /* FALLTHRU */ case NE_EXPRESSION: /* FALLTHRU */ case GT_EXPRESSION: /* FALLTHRU */ case GE_EXPRESSION: /* FALLTHRU */ case LT_EXPRESSION: /* FALLTHRU */ case LE_EXPRESSION:
v = crb_eval_binary_expression(inter, env, expr->type, expr->u.binary_expression.left, expr->u.binary_expression.right);
break; /* 逻辑与，逻辑或 */ case LOGICAL_AND_EXPRESSION:/* FALLTHRU */ case LOGICAL_OR_EXPRESSION:
v = eval_logical_and_or_expression(inter, env, expr->type, expr->u.binary_expression.left, expr->u.binary_expression.right);
break; case MINUS_EXPRESSION: /* 单目取负运算符 */
v = crb_eval_minus_expression(inter, env, expr->u.minus_expression); break; case FUNCTION_CALL_EXPRESSION: /* 调用函数 */ v = eval_function_call_expression(inter, env, expr); break; case NULL_EXPRESSION: /* 常数 null */ v = eval_null_expression(); break; case EXPRESSION_TYPE_COUNT_PLUS_1: /* FALLTHRU */ default: DBG_panic(("bad case. type..%d\n", expr->type)); } return v; }
比如 Expression 结构体的 type 是 INT_EXPRESSION（整数的常数）时会 调用 eval_int_expression()，其实现如下所示。最后在 CRB_Value 结构 体中装入值并返回。
static CRB_Value eval_int_expression(int int_value) {
CRB_Value v; v.type = CRB_INT_VALUE; v.u.int_value = int_value; return v; }
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

0 9 8 第 3 章　制作无类型语言 crowbar

再比如分析树的加法节点（ADD_EXPRESSION）对于其左右项目会分别调 用 eval_expression()，然后对其值进行加法运算，最后装入 CRB_Value 并 返回。
上面看起来只有很简单的一句话，其实对于加法运算来说，左右项目的组合 有以下几种情况：

* 在 C 语言中做除法运算， 用整数除以整数商仍然 为整数。而对于无类型 语言来说，这种处理方 式 似 乎 不 够 好（crowbar 中 商 也 为 整 数 ）。  对 于 函 数 的 参 数 来 说， 由于没有变量类型检 查，因此如果向一个入 口参数应为实数的函数 传入整数值，Debug 时 肯定会非常困难，并且 容易产生 BUG[3]。

1. 左边是整数，右边也是整数（整数相加，返回整数） 2. 左边是实数，右边也是实数（实数相加，返回实数） 3. 左边是整数，右边是实数（左边转换为实数，最后返回实数） 4. 左边是实数，右边是整数（右边转换为实数，最后返回实数） 5. 左边是字符串，右边也是字符串（返回连接后的字符串） 6. 左边是字符串，右边是整数（右边转换为字符串，返回连接后的字符串） 7. 左边是字符串，右边是实数（右边转换为字符串，返回连接后的字符串） 8.	左边是字符串，右边是布尔型（右边转换为内容是true或false的字符串，返回
连接后的字符串） 9. 左边是字符串，右边是null（右边转换为内容是null的字符串，返回连接后的字符串）
对于 1~4 项来说，不只是加法，减法和乘法也都必须进行这样的类型转换 *， 因此单独将评估加法表达式的函数独立出来并不是好的处理方式。crowbar 使 用 eval_binary_expression() 函数对所有的二元运算符进行评估（代码清 单 3-11），实际上这个函数中已经将同为整数、同为实数的运算单独划分为函数 处理了，但代码整体还是很长（虽然有点长不过并不难，请读者尝试阅读一下）。 这其中调用的子函数 eval_binary_int() 请参考代码清单 3-12。.

代码清单 3-11 eval_binary_expression() 

CRB_Value crb_eval_binary_expression(CRB_Interpreter *inter, LocalEnvironment
*env, ExpressionType operator,Expression *left, Expression *right) {  CRB_Value left_val;  CRB_Value right_val;  CRB_Value result;

 left_val = eval_expression(inter, env, left);  right_val = eval_expression(inter, env, right);

 if (left_val.type == CRB_INT_VALUE



&& right_val.type == CRB_INT_VALUE) {



eval_binary_int(inter, operator,



left_val.u.int_value, right_val.u.int_value,



&result, left->line_number);

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3.3　crowbar ver.0.1 的实现 0 9 9

 } else if (left_val.type == CRB_DOUBLE_VALUE



&& right_val.type == CRB_DOUBLE_VALUE) {



eval_binary_double(inter, operator,



left_val.u.double_value, right_val.u.double_value,



&result, left->line_number);

 } else if (left_val.type == CRB_INT_VALUE



&& right_val.type == CRB_DOUBLE_VALUE) {



left_val.u.double_value = left_val.u.int_value;



eval_binary_double(inter, operator,

left_val.u.double_value, right_val.u.double_value,



&result, left->line_number);

 } else if (left_val.type == CRB_DOUBLE_VALUE



&& right_val.type == CRB_INT_VALUE) {



right_val.u.double_value = right_val.u.int_value;



eval_binary_double(inter, operator,



left_val.u.double_value, right_val.u.double_value,

&result, left->line_number);

 } else if (left_val.type == CRB_BOOLEAN_VALUE



&& right_val.type == CRB_BOOLEAN_VALUE) {



result.type = CRB_BOOLEAN_VALUE;



result.u.boolean_value



= eval_binary_boolean(inter, operator,



left_val.u.boolean_value,



right_val.u.boolean_value,



left->line_number);

 } else if (left_val.type == CRB_STRING_VALUE



&& operator == ADD_EXPRESSION) {



char buf[LINE_BUF_SIZE];



CRB_String *right_str;



if (right_val.type == CRB_INT_VALUE) {



sprintf(buf, "%d", right_val.u.int_value);



right_str = crb_create_crowbar_string(inter, MEM_strdup(buf));



} else if (right_val.type == CRB_DOUBLE_VALUE) {



sprintf(buf, "%f", right_val.u.double_value);



right_str = crb_create_crowbar_string(inter, MEM_strdup(buf));



} else if (right_val.type == CRB_BOOLEAN_VALUE) {



if (right_val.u.boolean_value) {



right_str = crb_create_crowbar_string(inter,



MEM_strdup("true"));



} else {



right_str = crb_create_crowbar_string(inter,



MEM_strdup("false"));



}



} else if (right_val.type == CRB_STRING_VALUE) {



right_str = right_val.u.string_value;



} else if (right_val.type == CRB_NATIVE_POINTER_VALUE) {

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 0 0 第 3 章　制作无类型语言 crowbar

代码清单 3-12 eval_binary_int() 



sprintf(buf, "(%s:%p)",



right_val.u.native_pointer.info->name,



right_val.u.native_pointer.pointer);



right_str = crb_create_crowbar_string(inter, MEM_strdup(buf));



} else if (right_val.type == CRB_NULL_VALUE) {



right_str = crb_create_crowbar_string(inter, MEM_strdup("null"));



} 



result.type = CRB_STRING_VALUE;



result.u.string_value = chain_string(inter,



left_val.u.string_value,



right_str);

 } else if (left_val.type == CRB_STRING_VALUE



&& right_val.type == CRB_STRING_VALUE) {



result.type = CRB_BOOLEAN_VALUE;



result.u.boolean_value



= eval_compare_string(operator, &left_val, &right_val,



left->line_number);

 } else if (left_val.type == CRB_NULL_VALUE



|| right_val.type == CRB_NULL_VALUE) {



result.type = CRB_BOOLEAN_VALUE;



result.u.boolean_value



= eval_binary_null(inter, operator, &left_val, &right_val,



left->line_number);

 } else {



char *op_str = crb_get_operator_string(operator);



crb_runtime_error(left->line_number, BAD_OPERAND_TYPE_ERR,



STRING_MESSAGE_ARGUMENT, "operator", op_str,



MESSAGE_ARGUMENT_END);

 }

 return result; }

static void

eval_binary_int(CRB_Interpreter *inter, ExpressionType operator,



int left, int right,



CRB_Value *result, int line_number)

{

 if (dkc_is_math_operator(operator)) {



result->type = CRB_INT_VALUE;

 } else if (dkc_is_compare_operator(operator)) {



result->type = CRB_BOOLEAN_VALUE;

 } else {



DBG_panic(("operator..%d\n", operator));

 }

 switch (operator) {

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3.3　crowbar ver.0.1 的实现 1 0 1

 case BOOLEAN_EXPRESSION: /* FALLTHRU */

 case INT_EXPRESSION:

/* FALLTHRU */

 case DOUBLE_EXPRESSION:

/* FALLTHRU */

 case STRING_EXPRESSION:

/* FALLTHRU */

 case IDENTIFIER_EXPRESSION: /* FALLTHRU */

 case ASSIGN_EXPRESSION:



DBG_panic(("bad case...%d", operator));



break;

 case ADD_EXPRESSION:



result->u.int_value = left + right;



break;

 case SUB_EXPRESSION:



result->u.int_value = left - right;



break;

 case MUL_EXPRESSION:



result->u.int_value = left * right;



break;

 case DIV_EXPRESSION:



result->u.int_value = left / right;



break;

 case MOD_EXPRESSION:



result->u.int_value = left % right;



break;

 case LOGICAL_AND_EXPRESSION:

/* FALLTHRU */

 case LOGICAL_OR_EXPRESSION:



DBG_panic(("bad case...%d", operator));



break;

 case EQ_EXPRESSION:



result->u.boolean_value = left == right;



break;

 case NE_EXPRESSION:



result->u.boolean_value = left != right;



break;

 case GT_EXPRESSION:



result->u.boolean_value = left > right;



break;

 case GE_EXPRESSION:



result->u.boolean_value = left >= right;



break;

 case LT_EXPRESSION:



result->u.boolean_value = left < right;



break;

 case LE_EXPRESSION:



result->u.boolean_value = left <= right;



break;

 case MINUS_EXPRESSION:

/* FALLTHRU */

 case FUNCTION_CALL_EXPRESSION:

/* FALLTHRU */

 case NULL_EXPRESSION:

/* FALLTHRU */

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 0 2 第 3 章　制作无类型语言 crowbar

 case EXPRESSION_TYPE_COUNT_PLUS_1: /* FALLTHRU */

 default:



DBG_panic(("bad case...%d", operator));

 }

}

类似这样，在运行表达式求值时，会进行值的类型判定等很多处理，这也就

* 对编译器进行优化的话，
其实可以在编译阶段对
值的类型进行判定。

是 crowbar 这样的无类型语言运行速度慢的原因之一 *。 在评估其他表达式时，比较重要的是调用函数。调用函数时会执行 eval_
function_call_expression()（代码清单 3-13）。

代码清单 3-13 eval_function_call_ expression()

static CRB_Value

eval_function_call_expression(CRB_Interpreter *inter, LocalEnvironment

*env, Expression *expr)

{

 CRB_Value

value;

 FunctionDefinition *func;

 char *identifier = expr->u.function_call_expression.identifier;

 func = crb_search_function(identifier);

 if (func == NULL) {



crb_runtime_error(expr->line_number, FUNCTION_NOT_FOUND_ERR,



STRING_MESSAGE_ARGUMENT, "name", identifier,



MESSAGE_ARGUMENT_END);

 }

 switch (func->type) {

 case CROWBAR_FUNCTION_DEFINITION:



value = call_crowbar_function(inter, env, expr, func);



break;

 case NATIVE_FUNCTION_DEFINITION:



value = call_native_function(inter, env, expr, func->u.native_f.proc);



break;

 default:



DBG_panic(("bad case..%d\n", func->type));

 }

 return value; }

这个函数本身只负责将 crowbar 中的函数和 C 语言中的函数（内置函数）按 条件区分处理。
如果是 crowbar 中的函数，会调用 call_crowbar_function()（代码清 单 3-14）。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3.3　crowbar ver.0.1 的实现 1 0 3

代码清单 3-14 call_crowbar_function() 

static CRB_Value

call_crowbar_function(CRB_Interpreter *inter, LocalEnvironment *env,



Expression *expr, FunctionDefinition *func)

{

 CRB_Value value;

 StatementResult

result;

 ArgumentList

*arg_p;

 ParameterList

*param_p;

 LocalEnvironment *local_env;

 /* 开辟空间用于存放被调用函数的局部变量 */ local_env = alloc_local_environment();

/* 对参数进行评估，并存放到局部变量中 arg_p 指向函数调用的实参链表 param_p 指向函数定义的形参链表 */
for (arg_p = expr->u.function_call_expression.argument, param_p = func->u.crowbar_f.parameter;
arg_p; arg_p = arg_p->next, param_p = param_p->next) { CRB_Value arg_val;

if (param_p == NULL) { /* param_p 被用尽：说明实参过多 */ crb_runtime_error(expr->line_number, ARGUMENT_TOO_MANY_ERR, MESSAGE_ARGUMENT_END);
} arg_val = eval_expression(inter, env, arg_p->expression); crb_add_local_variable(local_env, param_p->name, &arg_val); } if (param_p) { /* param_p 剩余：说明实参数量不够 */ crb_runtime_error(expr->line_number, ARGUMENT_TOO_FEW_ERR,
MESSAGE_ARGUMENT_END); } /* 运行函数内部语句 */ result = crb_execute_statement_list(inter, local_env,
func->u.crowbar_f.block ->statement_list);

/* 如果 return 语句已经运行，则返回其返回值 */ if (result.type == RETURN_STATEMENT_RESULT) {
value = result.u.return_value; } else {
value.type = CRB_NULL_VALUE; } dispose_local_environment(inter, local_env);
return value; }

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 0 4 第 3 章　制作无类型语言 crowbar
crowbar 与 C 语言一样，是局部变量的生命周期，在函数被销毁时截止（局 部变量生成的时机与 C 语言不同，是在变量被赋值时生成的）。因此在一个函数 开始时，需要为这个函数准备一个运行环境，随着赋值开始注册新生成的局部变 量，同时在函数结束后将其运行环境一同废弃。按照这个思路，我们为函数的运 行环境准备了 LocalEnvironment 结构体。  LocalEnvironment 结构体的定义如下：
typedef struct { Variable *variable; /* 保存局部变量的链表 */ GlobalVariableRef *global_variable; /* 根据 global 语句生成的引用全局变量的链表 */
} LocalEnvironment;
 Variable 是为了保存全局变量而使用的结构体（参考 3.3.1 节）。该结构体 是通过链表构建的，链表内保存了函数内的局部变量。
函 数 的 参 数 中 包 含 了 所 有 函 数 内 要 用 到 的 局 部 变 量， 通 过 调 用 call_ crowbar_function() 中评估的 crb_add_local_variable() 函数将变量 装入 LocalEnvironment。
全局变量在函数内被引用时，crowbar 中需要使用 global 语句进行声明（参 考 3.1.4 节 ）。LocalEnvironment 结 构 体 的 global_variable 成 员 中 保 存 了 global 语句声明的指向全局变量的引用链表，其类型 GlobalVariableRef 的 定义如下所示：
typedef struct GlobalVariableRef_tag { Variable *variable; /* 指向全局变量 */ struct GlobalVariableRef_tag *next;
} GlobalVariableRef;
 GlobalVariableRef 结 构 体 在 global 语 句 运 行 时 生 成， 同 时 被 追 加 到 LocalEnvironment 结构体中。
3.3.8 值——CRB_Value
执 行 表 达 式 求 值 的 函 数 eval_XXX_expression()， 它 的 返 回 值 类 型 为 CRB_Value。CRB_Value 类型的定义如下：
/* 类型的类别枚举 */ typedef enum {
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3.3　crowbar ver.0.1 的实现 1 0 5

CRB_BOOLEAN_VALUE = 1, CRB_INT_VALUE, CRB_DOUBLE_VALUE, CRB_STRING_VALUE, CRB_NATIVE_POINTER_VALUE, CRB_NULL_VALUE } CRB_ValueType;

/* 布尔型 */ /* 整数型 */ /* 实数型 */ /* 字符串型 */ /* 原生指针型 */
/* NULL */

typedef struct {

CRB_ValueType

type; /* 这个成员用于区别类型 */

union {

/* 实际的值保存在联合体中 */

CRB_Boolean

boolean_value;

int

int_value;

double

double_value;

CRB_String

*string_value;

CRB_NativePointer

native_pointer;

} u;

} CRB_Value;

 CRB_Value 结构体用于保存 crowbar 中的每个值，并用枚举型区别值的类 型，实际的值最终保存在联合体中。
对于无类型语言处理器来说，通常都需要像这样在值中保存值本身的类型。

3.3.9 原生指针型

原 生 指 针 型 的 值， 通 过 CRB_Value 结 构 体 中 的 联 合 体 成 员 CRB_NativePointer.类型体现出来，其定义如下所示：

typedef struct { CRB_NativePointerInfo void
} CRB_NativePointer;

*info; *pointer;

 pointer 成员是指向一些内部对象的指针。比如可以用原生指针型来做文件 指针，此时指针实际会指向 FILE* 类型。为了可以容纳任何类型的指针，这里 特意设置为 void*。
另一个成员 info 保存了原生指针型的信息，因此原生指针型本身就可以获 得自己的类型。如果没有 info 成员只保存 void* 的话，当错误的类型传递给原 生指针型时，内置函数将失去类型检查的方法，引起程序崩溃。作为 crowbar 的 解释器，如果还会被 crowbar 程序的 BUG 弄崩溃就有点说不过去了。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 0 6 第 3 章　制作无类型语言 crowbar

 info 成员的类型 CRB_NativePointerInfo 的定义如下所示：

typedef struct {

char

*name;

} CRB_NativePointerInfo;

这里的 name 成员中，如果原生指针为文件指针时，成员值为 crowbar. lang.file 的字符串。
虽然经过上面的处理，可以对原生指针型进行类型检查，但这还不算是万 全之策。比如为 FILE* 类型时，一个地方用 fclose() 关闭了文件指针，可 能 还 会 在 另 一 个 地 方 被 使 用。 为 了 规 避 这 种 情 况， 原 生 指 针 型 不 应 该 直 接 指 向 FILE*，而是需要经过一个第三方对象。不过当前版本的 crowbar 对第三方对 象的释放处理仍然存在问题。之后的版本会引入标记 - 清除 GC，届时这个问题 会一并解决，请参考 4.4.5 节。

3.3.10 变量

代码清单 3-15 eval_identifier_expression()

我们先后提到了局部变量与全局变量，那么接下来，我再对变量做一些介绍。 变 量 名 在 表 达 式 中 出 现 时， 通 过 eval_expression()（参 考 代 码 清 单 3-10）调用 eval_identifier_expression()（代码清单 3-15）。

static CRB_Value

eval_identifier_expression(CRB_Interpreter *inter,



LocalEnvironment *env, Expression *expr)

{

 CRB_Value v;

 Variable *vp;

 /* 首先查找局部变量 */ vp = crb_search_local_variable(env, expr->u.identifier); if (vp != NULL) { v = vp->value; } else { /* 如果没有找到，则通过 CRB_Interpreter 或 LocalEvironment 连接 GlobalVariableRef，在其中查找全局变量 */ vp = search_global_variable_from_env(inter, env, expr->u.identifier); if (vp != NULL) { v = vp->value; } else { /* 仍然没有找到则报错 */

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3.3　crowbar ver.0.1 的实现 1 0 7

crb_runtime_error(expr->line_number, VARIABLE_NOT_FOUND_ERR, STRING_MESSAGE_ARGUMENT, "name", expr->u.identifier, MESSAGE_ARGUMENT_END);
} } refer_if_string(&v); /* 这里下文会详述 */

return v; }

 crb_search_local_variable() 会从 LocalEnvironment 中查找局部变量。 另外，crb_search_global_variable() 的第二个参数 LocalEnvironment 为空 的话（即在顶层结构中），会从 CRB_Interpreter 中查找。如果两者都没有找到， 则从第二个参数 LocalEnvironment 连接的 GlobalVariableRef 中查找全局 变量。
变 量 赋 值 时 的 处 理 通 过 eval_assign_expression() 进 行（代 码 清 单 3-16）。

代码清单 3-16 eval_assign_expression()

static CRB_Value

eval_assign_expression(CRB_Interpreter *inter, LocalEnvironment *env,



char *identifier, Expression *expression)

{

 CRB_Value v;

 Variable *left;

 /* 首先评估右边 */ v = eval_expression(inter, env, expression);

/* 查找局部变量 */ left = crb_search_local_variable(env, identifier); if (left == NULL) {
/* 没有找到则查找全局变量 */ left = search_global_variable_from_env(inter, env, identifier); } if (left != NULL) { /* 找到变量 */ release_if_string(&left->value); /* 本行后文会详述 */ left->value = v; /* 在这里赋值 */ refer_if_string(&v); /* 本行后文会详述 */ } else { /* 因为没有变量，所以新生成 */ if (env != NULL) {
/* 函数内注册局部变量 */ crb_add_local_variable(env, identifier, &v); } else { /* 函数外注册全局变量 */

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 0 8 第 3 章　制作无类型语言 crowbar

CRB_add_global_variable(inter, identifier, &v); } refer_if_string(&v); /* 本行后文详述 */ }
return v; }
赋值处理的流程已经写入注释，其中后文详述的部分会在之后的章节中说明。 当前的语法规则中，赋值表达式的左边必须保证为变量名。如果之后可以使 用数组等新语法元素，可能会有下面这样的赋值：
a[b[func()]] = 10;
左边可能为非常复杂的表达式，因此还需要进一步考虑。

3.3.11 字符串与垃圾回收机制——string_pool.c

如上文所写，字符串类型通过 + 连接的同时，需要配合某种 垃圾回收机 制（  garbage.collector，GC）。当前版本的 crowbar 是通过 引用计数 这种原始的垃圾 回收机制实现的。
引用计数，即通过管理指向某些对象（这里是字符串）的指针数量，在计数 为零时将其释放的回收机制。
crowbar 的字符串保存在 CRB_String 结构体中。

typedef struct CRB_String_tag {

int

ref_count; /* 引用计数 */

char

*string; /* 字符串本身 */

CRB_Boolean is_literal; /* 是否为字面常量 */

} CRB_String;

这个结构体的 string 最终指向存放字符串的区域。  CRB_String 会在下列的时机中生成，生成时引用计数被置为 1。

1. 字符串字面常量被评估时。 2. 通过+运算符生成新的字符串时。 3. 通过+运算符将整数型或实数型转换为字符串类型时。 4. 通过fget()函数读入文件时。

引 用 计 数 为 零 时 回 收。 此 时 字 符 串 本 身（即 string 成 员 的 指 向 ） 一 般

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3.3　crowbar ver.0.1 的实现 1 0 9
来说也需要被释放，但如果字符串为字面常量（literal，即被 "" 包裹的出现在 crowbar 代码中的字符串）则不释放。字面常量不是通过 MEM_malloc() 而是通 过 MEM_storage_malloc() 在 interpreter_storage 中开辟的。区别字符 串是否为字面常量，通过其成员 is_literal 即可，也就是说，字符串字面常 量所对应的 CRB_String，生成于赋值表达式的字符串字面常量被评估时，但是 其指向的字符串本身，还会在分析树构建时被重复使用。
引用 CRB_String 的指针会存在于以下几处地方： 1. 局部变量 2. 全局变量 3. 函数的参数 4. eval.c中的局部变量、参数、返回值等，eval.c运行时的C栈
那么只需要在这些指针被引用时将引用计数自增，引用解除时将引用计数自 减即可。
因此，在程序中需要在以下的时机对引用计数进行自增处理（条目编号与上 文 CRB_String 生成的编号一一对应）。
1. 局部变量被赋值为字符串时。 2. 全局变量被赋值为字符串时。 3. 	函 数的参数被赋值为字符串时。这里有个例外，如果入口参数为实参时，其表达
式求值结束时会伴随一次自减，会与本应进行的计数自增两相抵消。 4. 	字 符串的变量被评估时。除此之外，当字符串出现在表达式中时，会新生成CRB_
String。
而程序中还需要在以下的时机对引用计数进行自减处理。 1. 存放字符串的局部变量被复写时，以及退出函数，局部变量被释放时。 2. 存放字符串的全局变量被复写时，以及程序运行完毕，全局变量被释放时。 3. 	从 内置函数退出，释放入口参数时（如果是crowbar函数，入口参数是作为局部变
量处理的，此时的处理参考上面的条件1）。 4. 	返 回字符串的表达式会对其进行表达式/语句评估，评估处理结束时。通过+运算符
对字符串进行连接时。通过比较运算符比较字符串后，两边的字符串需要释放时。
在实际处理中，引用计数的自增通过 refer_if_string() 函数实现，其自 减则通过 release_if_string() 函数（类似这种函数名中有 if_string 的函 数，仅限于对象为字符串时才会进行处理）实现。参考代码清单 3-16 可以明显 看到：
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 1 0 第 3 章　制作无类型语言 crowbar

图 3-5 循环引用

●● 当变量被复写时，原来变量中字符串的引用计数会自减； ●● 当变量被赋值为字符串时，该字符串的引用计数会自增。
再举一个复杂一点的例子，比如有如下语句时（hoge() 函数的返回值为字 符串类型）：
a = b = c = hoge(“piyo”);
首先，在评估 piyo 时生成 CRB_String，引用计数被置为 1。将其传递给 函数时，由于入口参数为实参，所以会与本应进行的计数自增相抵消，引用计 数仍然保持为 1 不变。赋值给 c 后计数为 2，赋值给 b 后计数为 3，最后赋值 给 a 后计数为 4。同时，由于对表达式语句的评估结束，又会进行一次自减，所 以计数为 3。通过 a、b、c3 个变量的引用，应用计数最终为 3。
但是引用计数这种垃圾回收机制存在一个致命的缺陷，那就是无法释放 循环 引用 。
循环引用如图 3-5 所示，即几个对象之间相互进行引用。

这种状态下，所有对象的引用计数均为 1，因此通过引用计数的方式进行垃 圾回收显然是行不通的。其实，如果能控制局部变量和全局变量令其无法引用的 话，这种循环引用本来是不应该出现的。也就是说，以引用计数方式进行垃圾回 收时，循环引用会引起内存泄漏。
当前的 crowbar 中，垃圾回收的对象只有字符串一种，而字符串是无法引用 其他对象的，所以还不存在循环引用的问题。但是当下几乎所有的实用编程语 言，都可以用一个对象保存指向另一个对象的引用，因此如果想扩展并支持这样 的功能的话，引用计数式的垃圾回收机制就必须做出改进。
3.3.12 编译与运行
如 1.6.2 节所写，本书中所涉及的代码都可以在以下 URL 下载：
http://avnpc.com/pages/devlang#download

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3.3　crowbar ver.0.1 的实现 1 1 1

* make 是 UNIX 下 经 典 的编译 / 自动化构建工 具， 而 在 集 成 开 发 环 境 中， 很 多 IDE 都 可 以直接从菜单中点击 Build 按 钮 进 行 编 译。  make 指 令 中， 编 译 / 链接等具体步骤都会写 在 Makefile 文件中。

将下载的文件解压缩后，进入该文件夹并运行 make* 即可生成执行文件。 本书涉及的程序所需的包也附加在 Makefile 中了，只是在 Windows 所用的 Makefile 中，C 编译器名称已经设置为了 gcc，make 名称也设置为 gmake 了（参 考 1.6.1 节）。如果你的系统环境不一样的话，请根据实际情况作适当调整。 解压的文件夹中还放入了一个 test.crb 的示例代码，可以通过下面的指令 运行：

% crowbar test.crb

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

第4章
数组和标记 - 清除垃圾回收器
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 1 4 第 4 章　数组和标记 - 清除垃圾回收器

4.1 crowbar ver.0.2
crowbar.book_ver.0.1 不能使用数组，会让用户感觉不太实用，因此在 book_ ver.0.2 中我们将引入数组的概念。

代码清单 4-1 数组

4.1.1 crowbar 的数组
在 crowbar.ver.0.2 中，可以像代码清单 4-1 那样使用数组。.
# 创建数组 a={1,2,3,4,5,6,7,8};
# 显示数组 for(i = 0; i < a.size(); i++){
print("(" + a[i] + ")"); }
print("\n");
# 创建九九乘法表 a99 = new_array(9,9); for(i = 0; i < 9; i++){
for(j = 0; j < 9; j++){ a99[i][j] = (i+1) * (j+1);
} }
# 显示九九乘法表 for(i = 0; i < a99.size(); i = i + 1){
for(j = 0; j < a99[i].size(); j = j + 1){ print("[" + a99[i][j] + "]");
}
print("\n"); }
# 附带：显示字符串长度 print("len.." + "abc".length() + "\n");
与 C 语言不同，在大多数脚本语言中，数组（或者列表）都可以用字面量表 示。例如 Perl 中，像这样：

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

4.1　crowbar ver.0.2 1 1 5
(1, 2, 3)
就可以创建一个由 1、2、3 组成的数组（列表）。. Ruby 和 Python 是这样的：
[1, 2, 3]
而 Tcl 是这样的：
{1, 2, 3}
语言不同，数组的定义方式也不相同。我总觉得 crowbar 与 C 语言比较相似， 既然在 C 中数组用 {} 初始化，那么在 crowbar 中也使用 {} 吧。
{1, 2, 3}
用这种方式来创建数组。同理，
a = {1, 2, 3};
就可以把数组赋值给变量。（如果这么写的话）可以像下面这样直接用下标指定 元素。
{1, 2, 3}[1]
这个表达式的值是整数型的 2。. 另外，数组的元素中可以包含数组或其他所有数据类型，并且每个元素都可 以包含不同类型的数据。
a = {true, 1, "abc", {5,10.0}};
这样一来，在 a 中包含了布尔型、整数型、字符串和数组四个类型的元素， 其中第 4 个元素包含了数组。a[3] 返回一个数组，a[3][1] 返回 10.0。如上 所述，crowbar 中虽然不存在多维数组，但实际上可以用“数组的数组”方式来 实现。
4.1.2 访问数组元素
从上一节给出的例子中我们不难看出，用 [] 的方式可以访问数组元素。当 然，下标是从 0 开始的。
b = a[i];
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 1 6 第 4 章　数组和标记 - 清除垃圾回收器
这个语句把数组 a 的第 i 个元素赋值给变量 b。.
a[i] = 5;
上面这个的语句将整数 5 赋值给 a 的第 i 个元素，但如果 a 不是数组类型的 话，运行时就会出现错误。还有，[] 中必须是整数类型。.
crowbar 的数组不支持自动扩展。在 Perl 等有些语言里，只要使用像 a[100] = 10; 这样的语句就可以让数组自动扩展，与数组当前的大小无关。在把所有数 组都视为关联数组（字符串等也可以作为下标）的语言（如 JavaScript）中，也 可以随时随地给 a[100] 赋值。但是，这种语言的设计方式在我看来迟早会出 现 bug。在 crowbar 里，如果 a 的元素数是 5 的话，无论是给 a[10] 赋值还是引 用 a[10] 元素，都会引发运行时的错误。
4.1.3 数组是一种引用类型
crowbar 的数组是一种引用类型。什么是引用类型呢？说白了，就是指向原 始值的变量类型，其实就是指针。与 C 语言不同的是，crowbar 的数组类型不会 发生访问错误内存地址的情况。
一个数组赋值给变量 a 时，实际上 a 保存的是“指向”这个数组的值，将这 个值赋给其他变量的话，两个变量就指向了同一个数组。因此，下面这段程序会 输出 a[1]..5。
a = {1, 2, 3}; b = a; b[1] = 5; print("a[1].." + a[1] + "\n");
把 a 赋值给 b，这样一来变量 a 和变量 b 就和图 4-1 一样，同时指向同一个 数组。.
 图 4-1 两个变量引用同一个 数组
.   补充知识    “数组的数组”和多维数组 
前面提到过，crowbar 语言中虽然没有多维数组，但有了“数组的数组”基本上就
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

4.1　crowbar ver.0.2 1 1 7

* 不考虑 crowbar 的 MEM 实际会占用更大的管理 空间。
* C 语言中只有“数组的 数组”，数组也不属于引 用类型，在这里道理是 一样的。

可以实现用多维数组做的事情了。 如果要在 crowbar 中引入多维数组的话，就要用下面这种形式引用元素了。

a[3, 4] 这种多维数组有一个不方便的地方，就是不能单独取出数组中的一部分。 举个例子，每天的销售额以月为单位存在数组中，如果想指定月份和日期取出某一 日的销售额，要写成下面这样：
#取11月15日的销售额（month和day都从0开始） uriage[10][14] 如果想要定义一个函数来计算某个月的总营业额，要写成下面这样，只把某个月的 数组作为参数传递给这个函数。
#接受一个数组并计算合计值的函数（以11月的销售额为例） calc_sum(uriage[10]); 上面的例子，数组的数组可以做到，但多维数组就不行了（特别是当 calc_sum() 为 通用函数的时候）。 难道说多维数组就一点优点都没有吗？也不能这么说。由于在 crowbar 语言中数 组是引用类型，因此数组的数组会像图 4-2 中那样分配内存，如果是多维数组的话也许 会像图 4-3 那样。根据 malloc() 函数的机制，申请内存时多少都需要一些管理空间 *， 申请多个不连续的空间会加重 GC 的负担。总而言之，多维数组的运行效率有可能比数 组的数组要高一些 *。

 图 4-2

 图 4-3

“数组的数组”的内存结构 　　　　“多维数组”的内存结构

3×3 的“ 数组的数组 ”

●

　　　　

●

3×3 的“ 二维数组 ”

●

另外，使用数组的数组可以改变某个特定子数组的长度或者将其设置为 null。当 然，要说它的方便性还能举出很多例子来，但是也有不需要它的时候，比如一个五子棋 的棋盘，已经定好了是 8×8，这种情况下用多维数组来表示会更明确。
C#、D、Ada 等语言能够同时支持数组的数组和多维数组。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 1 8 第 4 章　数组和标记 - 清除垃圾回收器
4.1.4 为数组添加元素
crowbar 的数组不能简单地使用赋值语句进行自动扩展，而是需要显式地添 加元素来扩展数组。下面的代码在数组的末尾追加了一个元素。
a = {1, 2, 3}; a.add(4);
这样一来，a 指向的数组就变成了 {1, 2, 3, 4}。. 根据实际情况，我们希望有些数组一次就生成指定的大小。比如，想要管理 40 名学生的身高，用索引值来表示学号，但是生成数据的顺序是随机的。像这种 情况最好从一开始就预先生成一个 40 个元素的数组。 我觉得还是不要过多地摆弄语法，使用原生函数比较好。原生函数 new_ array() 可以生成一个指定大小的数组。.
a = new_array(40);
初始化状态下，所有的元素都是 null。. 给这个函数传入多个参数，也可以生成多维数组（数组的数组）。.
a = new_array(5, 10);
上例创建了一个元素最多到 a[4][9] 的数组。
4.1.5 增加调用（伪）方法的功能
前面的章节中，使用了一种方法调用式的语法结构为数组添加元素。
a.add(3);
为了支持这种方法调用，我们修改了语法结构，也为字符串增加了 length(). 方法。
4.1.6 其他细节
在变更左值的处理方式的同时，我们顺便引入了自增和自减运算符。i++. 时 i 会增加 1，-- 时同理。在 crowbar 中，自增和自减运算符只能放在后面，不
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

4.2　制作标记 - 清除 GC 1 1 9
支持前置的 ++ 和 --。. C 语言中自增和自减运算符前置和后置的含义不同。人们很难读懂在一行里
面写满了表达式的代码，所以我觉得自增和自减最好还是独占一行，这样一来前置 和后置的含义就相同了，不论写在哪边都可以。就我个人而言，一般习惯写在后面。.
也许有人会问了，在一行里只能写一个自增和自减的话，为什么它们非要是 表达式呢？变成语句不是更好吗？如果是这样的话，for 语句的第三个表达式就 没法使用 i++ 了，所以它们还是用作表达式吧。.
4.2 制作标注—清除 GC
crowbar.book_ver.0.1 中采用的引用计数 GC 存在不能释放循环引用的问题， 于是在 book_ver.0.2 中将实现一个标记 - 清除 GC。
4.2.1 引用数据类型的结构
在讨论 GC 的话题之前，先说明一下 crowbar.ver.0.2 中引用数据类型的处理 方式。.
crowbar 中有以下两种引用数据类型： ●● 数组 ●● 字符串 尤其是字符串，它是一个不允许改变内容（immutable）的对象，用户没有必 要意识到它是一个引用（请参考 4.2.2 节的补充知识）。 crowbar 的 所 有 值 都 保 存 在 CRB_Value 中。 在 crowbar.book_ver.0.1 里，CRB_Value 直接保存着指向 CRB_String 的指针。从现在开始，将增加新 的 CRB_Object 类型用来统一处理字符串和数组，在 CRB_Value 中将保存指 向 CRB_Object 的引用。
typedef struct{ CRB_ValueType type; union{ CRB_Boolean boolean_value;
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 2 0 第 4 章　数组和标记 - 清除垃圾回收器

int

int_value;

double

double_value;

CRB_NativePointer native_pointer;

CRB_Object *object;/* 这个是新增的 */

} u;

} CRB_Value;

用 CRB_Object 内的联合体来保存 CRB_String 以及为了这次数组而引入 的类型 CRB_Array。

typedef enum{ ARRAY_OBJECT = 1, STRING_OBJECT, OBJECT_TYPE_COUNT_PLUS_1
} ObjectType;

struct CRB_Object_tag{ ObjectType type; unsigned int marked:1; union{ CRB_Array array; CRB_String string; } u; struct CRB_Object_tag *prev; struct CRB_Object_tag *next;
};
虽然通过 CRB_Value 可以明确地区分出数据类型，但是为了在 GC 的时候 仅通过 CRB_Object 就可以能够辨别数据类型，必须在 CRB_Object 中加入一 个 ObjectType 枚举类型的成员。  CRB_Object 的成员 marked 作为一个标记对象用的标识符，将用于后面要 谈到的标记 - 清除 GC。至于它的数据类型，由于 1 个比特就足够了，因此选择 了位域（bit.field）。.
说起位域这个功能，其实在 C 语言中不太会用到。即使在现在的自由软件 中，应该也有不少自己进行位运算并为 int 变量附加各种标识的情况。但我 认 为， 时 至 今 日 人 们 已 无 需 刻 意 回 避 位 域 这 个 话 题 了。 不 过， 如 果 从 富 翁 式 编 程 的 角 度 出 发， 就 算 是 1 个 比 特 的 标 志 位， 可 能 也 要 给 它 分 配 一 个 CRB_ Boolean 型。.  CRB_Object 的联合体中有 CRB_Array 或 CRB_String，它们的定义如下：

struct CRB_Array_tag {

int

size;/* 显示用的元素数 */

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

图 4-4 循环引用

4.2　制作标记 - 清除 GC 1 2 1

int CRB_Value };

alloc_size;/* 实际占用的元素数 */ *array;/* 数组元素（数组长度可变） */

struct CRB_String_tag {

CRB_Boolean is_literal;

char

*string;

};

为了提高效率，数组在添加元素时会多扩展一些空间，所以在 size 属性之 外还保存了 alloc_size 属性。

4.2.2 　标记 - 清除 GC

前 面 说 过，book_ver.0.1 中 使 用 的 引 用 计 数 GC 不 能 释 放 循 环 引 用。 在 book_ver.0.1 里，GC 对象只是字符串，并不会因为不能释放循环引用而出现问 题。但是有了数组的数组，这样的方式在 book_ver.0.2 中就有可能引起问题， 比如：

a = {1, 2, 3}; b = {4, 5, a}; a[0] = b;
这样一段代码就形成了图 4-4 中描述的循环引用。 发生循环引用时，即使它们整体上不再被引用，引用计数器此时也不为 0。
这就是所谓的内存泄漏。

a

2 3

b

4 5

于是我们抛弃掉引用计数 GC，引入标记 - 清除.GC。本来所谓的垃圾回收 （GC）就是要自动释放不使用的对象占据的内存空间的机制。但是，怎么去定义 “不使用的对象”呢？其实就是“绝对不会被引用到的对象”。比如：
a = {1, 2, 3}; a = {2, 3, 4};
这样一段代码在执行了第二行的赋值语句后，{1, 2, 3} 这个数组就不再被引

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 2 2 第 4 章　数组和标记 - 清除垃圾回收器

用了，即成为了 GC 的对象（如图 4-5 所示）。

图 4-5

a

对象成为 GC 目标的

例子

1 2 3 谁都不会再指向这个数组了 4 5 6

所谓标记 - 清除.GC 是一种直接实现定义“不使用的对象”的 GC 算法。这 个算法有以下几个原则。.
1. 	从 变量之类的“引用起点”开始，追溯所有能引用到的对象并标记。（标注 阶 段）
2. 将没有被标记的对象全部释放。（清除阶段）

crowbar 里能够成为“引用起点”的有以下几处，我们称这些“引用起点” 为 根（   root 或 roots）。
1. 全局变量 2. 局部变量。包含用crowbar语言记述的函数的形式参数。 3. 原生函数的形式参数。 4. 表达式计算时的临时引用。

只有从这些根能够追溯到的对象才可以存留下来，其余的对象将被视作 GC 的目标被释放。

图 4-6

根

堆

成为 GC 目标的对象

全局变量 局部变量 原生函数的参数 表达式计算时的临时值

将被释放的对象 不会被释放的对象

其 实 这 些 根 中 最 难 处 理 的 就 是 表 达 式 计 算 时 的 临 时 引 用。 比 如 有 个 表 达 式 "abc" + "def" + "ghi"，crowbar 的解释器首先会计算 "abc" + "def"，

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

4.2　制作标记 - 清除 GC 1 2 3

* 现在的 crowbar 并没有 在编译时处理多个字 符串字面量的加法运算 （虽然可以这么做），所 以在这个例子中，使用 字符串字面量进行加法 运算的效果与使用字符 串变量相同，这里并不 是为了说明变量和字面 量的差异。

生成字符串 "abcdef"*。这个字符串的存在是必要的，但不论是全局变量还是 局部变量或者原生函数的形式参数都不会引用它，这样一来临时变量就会被 GC 丢弃，情况就会变得很糟。也许有人会想：“在这种关键时刻不要让 GC 启动不就 行了？”下面这个例子就阐述了 crowbar 在此时要启动 GC 的原因。
print("abc" + "def" + long_long_function());
但本例中的 long_long_function() 在执行过程中不进行 GC 是不现实 的，所以在表达式计算的过程中应该允许启动 GC。
crowbar 中 GC 的启动时机将在后面的章节介绍，大概的原则就是，在新分配 内存空间的时候有可能会启动。

* 也不知道 Java 这样的设
计方便性在哪里。可能
是会提升 intern() 的
效率吧。

  补充知识    引用和不可变类
在 crowbar 中，整数和实数类型的变量都是把值直接存在 CRB_Value 中，但是字 符串和数组类型在 CRB_Value 中只保存引用。举例来说，Java 与 crowbar 相同，在 Java 中像 int 或者 double 这样的类型叫作 原始类型（  primitive type），而像字符串或 者数组这样的类型叫作 引用类型（   reference type）。
有人可能会说，存在两个种类的数据类型有违编程之美，可是在 crowbar 中不必认 为字符串是一种引用类型。至于数组，只有像下面这段代码编写出的数组才是一种引用 类型。
a = {1, 2, 3}; b = a; a[1] = 10; ←这行代码也可替换为b[1]，效果相同 如果是字符串的话，就没办法改变内容了（这样的数据类型称为不可变的数据类 型）。比如用 + 运算符连接字符串，就会得到一个新的字符串对象，之前 A 字符串对象的 内容不会发生改变。
a = "abc"; b = a; a = a + "d"; ←a会变为"abcd"，b还是"abc" 另外，crowbar 中如果使用 == 比较字符串的话，不是进行引用之间的比较，而是 比较字符串的内容。Java 在这种情况下比较的就是引用，难不成是特意让人感觉到字 符串是一种引用？ *
按照刚才的思路，可能只能让字符串看起来像是一个原始类型，数组仍然是引用类型。 但这样的解释并不能让刚才说“存在两个种类的数据类型有违编程之美”的人满意吧。

A　即参与运算。——译者注

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 2 4 第 4 章　数组和标记 - 清除垃圾回收器
那么不妨逆向思考一下，可以把整数类型和实数类型都看作是引用类型。这样一 来，不可变的引用类型和原始类型就看不出区别了。如果不考虑实现问题，可以勉强把 整数和实数看作是不可变的引用类型。
不知道上面的解释能否使那些认为“存在两个种类的数据类型有违编程之美”的人 满意，不过，在给编程新手讲这个问题时，这种解释是否行得通，我觉得就另当别论了。
现在的编程入门书，基本上都把变量解释为“像是用来放值的盒子”（我曾经也这 样写过）。“盒子说”是用来解释原始类型的，如果要说明“一切都是引用”，就不得不 引入其他说法（也许是“名片说”？）了。
“盒子说”也不是毫无问题的（b = a; 的时候，a 的内容转移到了 b 里面，那 a 不 是应该变成空的了吗？）。大多数新手好像很难理解引用的概念。另外，关于“存在两个 种类的数据类型有违编程之美”这种说法，新手也不会太在意统一性之类的事情（对编 程语言有了一定程度的了解后才会在意）。以我的经验来看，如果是以教会新手编程为 目的，与其让他们知道统一性之类的道理，不如用盒子说来说明会更加容易。总而言 之，写代码才是对编程语言的学习最有帮助的。
4.2.3 crowbar 栈
让我们继续“表达式计算时的临时引用很难处理”这个话题。. 如果你要问在哪儿出现了“表达式计算时的临时引用”，其实 crowbar.book_ ver.0.1 里面的 eval.c 中各函数的局部变量就是。. 比如字符串连接时，crb_eval_binary_expression() 函数会按照以下 顺序执行（具体代码省略）。
CRB_Value left_val; CRB_Value right_val; CRB_Value result;
/* 计算左边的值 */ left_val = eval_expression(inter, env, left); /* 计算右边的值 */ right_val = eval_expression(inter, env, right);
( 中间省略 ) result.type = CRT_STRING_VALUE; /* chain_string 执行时，GC 可能会启动 */ result.u.string_value = chain_string(inter, left_val.u.string_value, right_str);
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

4.2　制作标记 - 清除 GC 1 2 5

( 中间省略 ) return result;

像 "abc" + "def" + "ghi" 这样的表达式，它的分析树如图 4-7 所示。 因为是从最深层次开始计算，left_val 会暂时持有指向字符串 "abcedf" 的 引用，然后在调用 chain_string() 函数时，由于会申请内存空间，因此也 有可能启动 GC（关于 GC 启动的时机，我将在 4.3.2 节介绍）。此时，虽然会标 记 left_val 指向的对象（chain_string() 会被更深的层级调用），但是从 GC 的角度，是看不到只作为局部变量的 left_val 的。

 图 4-7 字符串连接的分析树

由 left_val 持有引用 +

创建 "abcdef" +

"ghi"

"abc" "def"

想要解决这个问题倒是有一个办法，就是扫描 C 的局部变量内存区域（Ruby 使用的方法）。C 语言的局部变量通常分配在栈上，所以只要在表达式求值开始时 记录下相关局部变量的地址，并且在 GC 的时候再记录一次相关局部变量的地址， 就足以保证在这期间分配的局部变量肯定在这两处地址中（假设没有被优化分配 到寄存器上的话）。这样，扫描 C 的所有局部变量区域，若能发现形似引用对象 指针的地方，就以此为起点开始标记。
只是这个方法有如下缺点，让我不太想用它。

●（● 虽然说移植性相当高，但是）依赖 C 语言的实现，有违编程之美。 ●● 因为不知道是栈中的哪些部分引用的对象，所以不得不采取“把看上去像对象引用
的全部当做对象引用来处理”的方法。如果要处理的区域不是引用对象，就会发生 内存泄漏。顺便说一句，这种 GC 叫作保守式 GC。

* 这种内存溢出会随着运 行时间慢慢泄漏。这种 性质的内存泄漏，在有 些 程 序 中 会 非 常 致 命， 这种类型的保守式 GC 中，泄露的对象数量与 当时栈的长度成一定比 例，而且这个比例几乎 是固定的。

就内存泄漏而言，我觉得（从 Ruby 应用的情况来看）在应用上不成问 题 *。虽说这是 C 语言，但要让我胡乱地将指针作为地址处理也是不可以的。
crowbar 到底要怎么处理呢？既然 C 语言的栈这么不好用，那么全部用独 立的栈管理不就好了吗？对此，把“表达式运算时的临时引用”放在独立 的栈（CRB_Value 数组）中，GC 把这个栈中可以引用到的对象标记起来就 可 以 了。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 2 6 第 4 章　数组和标记 - 清除垃圾回收器

图 4-8 表达式的分析树

用 Stack 结构体来表示栈。

typedef struct {

int

stack_alloc_size;

int

stack_pointer;

CRB_Value *stack;

} Stack;

 CRB_Interpreter 持 有 这 个 结 构 体（只 有 CRB_Interpreter 会 持 有 Stack 结 构 体， 这 么 做 只 是 为 了 划 分 空 间 ）。 在 这 个 栈 中（以 后 就 称 为 crowbar 栈吧），与是否包含对象的引用无关，它会把表达式运算时产生的所有值 都保存起来。.
在此之前，所有的 eval.c 运算函数都将运算的结果值作为返回值，而 ver.0.2 以后的版本都将由栈返回。因此，之前使用过的 eval_xxx_expression() 系 列函数的返回值也从 CRB_Value 变成 void 了。.
例如，有如下表达式：

"1+2*3.." + (1 + 2 * 3);
会形成如图 4-8 这样的分析树，表达式运算时栈的变化如图 4-9 所示。

+

"1+2*3"

+

1

*

2

3

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

4.2　制作标记 - 清除 GC 1 2 7

 图 4-9 表达式运算过程中栈 的变化

"1+2*3.."

2

1

1

"1+2*3..."

"1+2*3..."

3 2
   1
应用

"1+2*3..."

6 1
应用 +

"1+2*3..."

7 应用 +

"1+2*3..."

"1+2*3...7"
总而言之，就是从栈中获取了 * 和 + 运算符的操作数，并将运算结果的值留 在了栈上。这种做法与 JVM 栈运行字节码时的栈动作相同。如此一来，我们就 向字节码解释器又迈进了一步。.
本书的后半部分将介绍字节码解释器型语言的制作方法。
4.2.4 其他根
接下来，将要说明除了“表达式运算时的临时引用”之外的三种根。 1. 全局变量
全局变量可以在 CRB_Interpreter 中以链表的形式追溯，很容易以此为 起点进行标记。 2. 局部变量
在 LocalEnvironment 结构体中持有局部变量，并作为参数传递。. 为了使 GC 能够全部标记当前生效的局部变量，并且在任何时候都能追踪 到这些局部变量，在 LocalEnvironment 中增加了成员 next，使之成为链表 （因为这个版本的结构体都写在 CRB_dev.h 中，所以加上 CRB_ 作为前缀。请参 考 4.4.4 节）。.

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 2 8 第 4 章　数组和标记 - 清除垃圾回收器

struct CRB_LocalEnvironment_tag {

Variable

*variable;

GlobalVariableRef *global_variable;

RefInNativeFunc

*ref_in_native_method;/* 之后会讲到 */

struct CRB_LocalEnvironment_tag *next;/* 新增加 */

};

链表的顶端由 CRB_Interpreter 持有。这里的“顶端”指的是最后被调 用的函数的 CRB_LocalEnvironment。

struct CRB_Interpreter_tag { ( 省略 ) CRB_LocalEnvironment *top_environment;
};
值得一提的是，当前的 crowbar 版本在搜索局部变量的时候，会从最近一次 作为参数传递的 LocalEnvironment 开始搜索，顺着 next 从函数调用路径中 所有 LocalEnvironment 开始搜索，这样一来 A，就可以引用到函数调用者的变 量了。
这样的作用域称为 动态作用域（  dynamic.scope）B。说实话，这点确实让人难 以理解，所以在最近的语言中已经不流行这种方式了（Emacs.Lisp 和 Perl 之类 的 local 变量都是动态作用域）。

4.2.5 原生函数的形式参数
在调用的时候，crowbar 中描述的函数的形式参数是保存在局部变量中的， 因此没有必要特别注意。原生函数的形式参数以数组的形式传递给原生函数，这 样一来，即使 GC 在原生函数执行过程中启动，GC 也可以追溯到这些变量。
原生函数的实际参数存入 crowbar 栈中，传递给原生函数的只是头地址。. crowbar 的栈将占用更大的内存地址。因此，从前往后按顺序计算参数，即 可将参数数组传递给原生函数。.

A　即在函数被调用时。——译者注 B　关于动态作用域的策略，“对一个名字 x 的使用指向的是最近被调用但还没有终止且声明了 x 的
过程中的这个声明”。（摘自“龙书”[1]P19）——译者注
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

4.3　GC 的实现 1 2 9

4.3 GC 的实现
之前介绍了标记 - 清除.GC 的基本原理和 crowbar 中对象引用的根。本节开 始介绍在 crowbar 里运行着什么样的 GC 以及它的实现方式。.
另外，与 GC 相关的代码大部分收录在 heap.c 中。

4.3.1 对象的管理方法

* C 语 言 使 用 malloc() 申
请内存空间，这里指可
以以任意顺序申请或释
放的内存区域。

crowbar 中像字符串和数组这样的对象可以通过 CRB_Object 结构体保存 在 堆（heap） * 中。CRB_Object 需要逐个使用 MEM_malloc() 申请内存空间。.
前面已经给出了 CRB_Object 结构体的定义，它在成员中持有指针 prev 和. next。由名字可以联想到，CRB_Object 是作为双向链表进行管理的。.  CRB_Interpreter 中持有这个链表的头节点。为了方便管理堆相关的信 息，我们定义了结构体 Heap。

typedef struct {

int

current_heap_size;

int

current_threshold;

CRB_Object *header;

} Heap;

 header 指向 CRB_Object 链表的开头。current_heap_size 和 current_ threshold 用于控制 GC 的启动时机。

4.3.2 GC 何时启动
在程序运行的过程中，标记 - 清除 GC 会在某个时机启动，释放不需要的对 象。那么究竟要在何时启动 GC 呢？.
其中一种方案就是内存不足的时候（即 malloc() 返回 NULL 时）。我们先不 考虑 MEM_malloc() 在 malloc() 返回 NULL 时会调用 exit() 的情况，若是 到了 malloc() 返回 NULL 的地步，那就说明内存空间是真的不足了，此时再运 行 GC 为时已晚。像后面说到的那样，现在的标记 - 清除 GC 需要使用大量的栈 空间，因此，如果真是到了 malloc() 返回 NULL 的地步，也不知道 GC 是否能

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 3 0 第 4 章　数组和标记 - 清除垃圾回收器

启动。大多数的操作系统即使调用了 free() 函数，也不会将释放出来的内存空

间还给操作系统，只是可以再次使用 malloc() 而已。因此即使 GC 将内存空间

释放，其他应用（进程）也不能使用，所以 GC 要是坚持到内存被占满时才启动

的话，会给其他程序带来很大的麻烦。.

于是，crowbar 使用了这样一种方式，即耗费了一定量的内存后，就启动

* threshold 是阈值的意思。

GC。这个一定量在 Heap 结构体的 current_threshold* 中保存，初始值由

宏 AHEAP_THRESHOLD_SIZE 定义（#define），暂定为 256KB。.

crowbar 每 次 创 建 对 象， 都 要 把 所 创 建 对 象 的 大 小 值 叠 加 到 CRB_

Interpreter 中 Heap 结构体的 current_heap_size 上。这个大小值也就是

要传给 MEM_malloc() 的大小值，所以这个值不包含 malloc() 或 MEM 模块的

管理空间（毕竟是相似的）。

而且，在创建对象前，要先调用 check_gc()。

static void check_gc(CRB_Interpreter *inter)
{ /* 堆耗费量超过阈值的话…… */ if(inter->heap.current_heap_size > inter->heap.current_threshold) { /* 启动 GC */ crb_garbage_collect(inter);

/* 设定下一个阈值 */ inter->heap.current_threshold
= inter->heap.current_heap_size + HEAP_THRESHOLD_SIZE; } }
上面的函数中，如果堆的消耗量超过了当前的阈值就启动 GC。执行 GC 的 时 候，current_heap_size 的 值 会 变 小， 将 变 小 后 的 current_heap_ size 和 HEAP_THRESHOLD_SIZE 相加，就得出了下一个阈值。.
至于函数 crb_garbage_collect() 就没有必要详细说明了。

void crb_garbage_collect(CRB_Interpreter *inter) {
gc_mark_objects(inter);/* mark */ gc_sweep_objects(inter);/* sweep */ }

A　预处理命令。——译者注

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

4.3　GC 的实现 1 3 1

代码清单 4-2 gc_mark_objects()

上面调用的 gc_mark_objects() 都做了哪些事，请参见代码清单 4-2。在
清除了所有对象标记的基础上，从各个根（前面介绍过）开始调用 gc_mark()。
static void gc_mark_objects(CRB_Interpreter *inter) {  CRB_Object *obj;  Variable *v;  CRB_LocalEnvironment *lv;  int i;

 /* 清除全部标记（mark） */ for (obj = inter->heap.header; obj; obj = obj->next) { gc_reset_mark(obj); }

/* 全局变量 */ for (v = inter->variable; v; v = v->next) {
if (dkc_is_object_value(v->value.type)) { gc_mark(v->value.u.object);
} }

/* 局部变量 */ for (lv = inter->top_environment; lv; lv = lv->next) {
for (v = lv->variable; v; v = v->next) { if (dkc_is_object_value(v->value.type)) { gc_mark(v->value.u.object); }
}

gc_mark_ref_in_native_method(lv); /* ←这里稍后再做说明 */ }

/* crowbar 栈 */ for (i = 0; i < inter->stack.stack_pointer; i++) {
if (dkc_is_object_value(inter->stack.stack[i].type)) { gc_mark(inter->stack.stack[i].u.object);
} } }
 gc_mark() 相 关 内 容 请 参 见 代 码 清 单 4-3。 如 果 对 象 已 经 被 标 记， 就 直
接 return（为了防止循环引用时出现死循环），然后将自己打上标记。如果是数
组的话就遍历每个元素，并以此为参数递归调用 gc_mark()。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 3 2 第 4 章　数组和标记 - 清除垃圾回收器

代码清单 4-3 gc_mark() 

static void

gc_mark(CRB_Object *obj) 

{

 if (obj->marked)



return;

 obj->marked = CRB_TRUE;

 if (obj->type == ARRAY_OBJECT) {



int i;



for (i = 0; i < obj->u.array.size; i++) {



if (dkc_is_object_value(obj->u.array.array[i].type)) {



gc_mark(obj->u.array.array[i].u.object);



}



}

 }

}

4.3.3 清除阶段

在清除阶段释放那些链表中没有被标记的管理对象，并维护链表（见代码清

单 4-4）。

代码清单 4-4 gc_sweep_objects() 

static void gc_sweep_objects(CRB_Interpreter *inter)  {  CRB_Object *obj;  CRB_Object *tmp;

 for (obj = inter->heap.header; obj; ) {



if (!obj->marked) {



if(obj->prev) {



obj->prev->next = obj->next;



} else {



inter->heap.header = obj->next;



}



if (obj->next) {



obj->next->prev = obj->prev;



}



tmp = obj->next;



gc_dispose_object(inter, obj);



obj = tmp;



} else {

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

4.3　GC 的实现 1 3 3



obj = obj->next;



}

 }

}

这其中调用的 gc_dispose_object() 把数组和字符串区分进行处理，释

放了 CRB_Object 头地址指向的空间（见代码清单 4-5）。

代码清单 4-5 gc_dispose_object()

static void

gc_dispose_object(CRB_Interpreter *inter, CRB_Object *obj)

{

 switch (obj->type) {

 case ARRAY_OBJECT:



inter->heap.current_heap_size



-= sizeof(CRB_Value) * obj->u.array.alloc_size;



MEM_free(obj->u.array.array);



break;

 case STRING_OBJECT:



if (!obj->u.string.is_literal) {



inter->heap.current_heap_size -= strlen(obj->u.string.

string) + 1;



MEM_free(obj->u.string.string);



}



break;

 case OBJECT_TYPE_COUNT_PLUS_1:

 default:



DBG_assert(0, (“bad type..%d\n”, obj->type));

 }

 inter->heap.current_heap_size -= sizeof(CRB_Object);

 MEM_free(obj);

}

  补充知识    GC 现存的问题 
crowbar 的 GC 最简单地实现了标记 - 清除 GC。因为是最简单的实现，所以还存 在以下问题。
1. 运行 GC 时，程序会停止运行。 2. 标记（mark）时的递归调用会消耗大量的栈空间。
首先是问题 1。因为是简单实现的标记 - 清除算法，所以在进行标记 - 清除时会完 全停止主程序的运行（crowbar 也是如此）。为了避免（减轻）这个问题，大概有以下 两种方法。
●●让 GC 和主程序异步（并行）执行 ●●使用分代式 GC 技术

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 3 4 第 4 章　数组和标记 - 清除垃圾回收器
如果让 GC 和主程序异步（并行）执行，虽然 GC 占用 CPU 的总耗时不变，但是 可以避免程序停止的情况，这对于一个互动程序来说是非常重要的。但是，实际上 GC 在异步执行时，肯定会发生当 GC 标记对象时，主程序中的对象引用关系同时发生改变 的情况，这样一来有些对象就可能被遗漏，没有打上标记。避免这种情况的方法是有的 （请用“write barrier”等词搜索一下），但是实现起来有点难度。
分代式的 GC 技术基于“经过一段时间后依然存活的对象有可能一直存活下去”的 经验，将对象分为不同世代进行管理。经过一段时间后依然被引用的对象，被当做“老 年代”处理，对于老年代的对象，GC 执行得不会很频繁。
比如需要编辑一个很大的文本时，实际需要编辑的内容只是全文的一小部分，但 是在简单实现的 GC 中，却要对全部文本进行标记，这样会做很多无用功。而分代式 的 GC 避免了这样的无用功，缩短了对于 GC 来说很重要的时间，提高了总体的处理 速度。
问题是，从新生代的对象向老年代对象转变的过程中，在取消新生代对象的标记， 又没有标记为老年代时，就发生了漏标记的情况。这当然是不允许的，必须要有对策。
下面我们再来看一下标记 - 清除的第二个问题，即进行标记（mark）时的递归调 用会消耗大量的栈空间。明明是因为内存不足才启动的 GC，但是 GC 又消耗了大量的 栈空间，这让人有种本末倒置的感觉。数据结构决定了到底要消耗多少栈空间，像“将 巨大的文件全部读入链表中，再进行一些处理”的程序，可想而知是很简单的（特别是 使用脚本语言来做）。大量的小对象链接构成链表，再递归进行标记，光是对象的数量 就足以占用大量的栈空间了。
我们使用称为链接反转法的思考方式来避免这个问题。在标记对象时，为了方便 递归，以及在一个对象标记结束后能够更容易返回到持有它的对象，我们在栈中使用 局部变量来记录已经处理了对象中的哪个引用。链接反转法用下面的方法实现在对象 内的记录。
●●按照对象 A →对象 B 的顺序地标记，在移动到下一个对象 C 时，将对象 B 中指 向 C 的引用指向 A。
●●每个对象都要增加成员“已经处理了哪个引用”。
  补充知识    Copying GC 
Copying GC 是一种已知的（经典的）垃圾回收器实现方法。 Copying GC 有以下 策略（如图 4-10）。
●●一开始就创建一个大的堆区域，并将它一分为二。 ●●创建对象的时候，从其中一半的区域划分出内存投入使用。 ●●当另一半区域被装满时，使用和标记 - 清除的标注阶段相同的方式跟踪对象，
只将生存的对象复制到另一半区域中即可。此时，由于对象的地址发生了变化， 因此需要维护指向它们的所有指针。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

4.3　GC 的实现 1 3 5
●●复制之后，将对象复制的目标区域切换为创建对象时使用的区域。当这半边区域 被装满时，再向另一半区域复制，如此循环往复。
 图 4-10 Copying GC

1 3
 
2
4

1

2

3

5

4

5

6

把存活的对象转移 到这边的区域

移动的同时，对象被整理得 更为紧凑

6

这个方法一目了然，它把最初的内存区域一分为二，在一个时间点只使用其中的一 半，另外一半内存就浪费了。
看上去好像是一个效率极差的方法，但是这个方法和标记 - 清除的 GC 相比有以下 优点。
●●复制对象的同时进行压缩（compaction），由此，消除了碎片（fragmentation）， 提高了虚拟内存和高速缓存的效率。
●●舍弃了标记 - 清除的清除过程，因此，在生存对象占比较小的情况下效率较高。
碎片是指像 malloc() 这样的函数多次对内存进行申请 / 释放的时候，内存如图 4-11 所示，出现极小且不连续的空间的状态。
 图 4-11 碎片

　

像这么小的区域实际上并不能使用

已使用的区域 未使用的区域

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 3 6 第 4 章　数组和标记 - 清除垃圾回收器

* 去 除 这 些 没 用 的 间 隙，
把对象存储空间变紧凑
的操作叫作精简（com-
paction）。

这样一来，对象之间存在间隙的内存区域实际上是不能使用的，这就造成了内存的 浪费 *。
Copying GC 在复制的时候将这些间隙消除。另外，一边追溯指针一边复制的方式 使得相互指向的对象很可能被复制到临近的区域。因此，同时使用的对象也很有可能被 放在一起，并写到虚拟内存的同一页中以减少翻页的几率，提升了性能。

4.4 其他修改
接下来要介绍的是 crowbar.ver.0.2 中除了 GC 之外的其他需要修改的地方。
4.4.1 修改语法
对语法作了如下修改。
●● 数组——表达式之后可以加 [ 表达式 ]。 ●● 方法调用——表达式后面可以加方法名（参数列表）。 ●● 自增 / 自减——表达式后面可以加 ++ 或 --。
增 加 了 很 多 可 以 追 加 在 表 达 式 后 面 的 语 法。 在 语 法 结 构 上 引 入 了 非 终 结 符 postfix_expression（这个名字是从 K&R[2] 的附录 C 中得来的）。
unary_expression : postfix_expression | SUB unary_expression ;
postfix_expression : primary_expression /* 引用数组元素。LB 和 RB 是“[”和“]” */ | postfix_expression LB expression RB /* 调用方法 */ | postfix_expression DOT IDENTIFIER LP argument_list RP | postfix_expression DOT IDENTIFIER LP RP /* 自增，自减 */ | postfix_expression INCREMENT | postfix_expression DECREMENT ;
句 柄 LB 和 RB 是 Left.Bracket 和 Right.Bracket 的 简 写， 分 别 代 表“[” 和 “]”。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

4.4　其他修改 1 3 7

根据这个语法结构创建的结构体如下所示（crowbar.h）。因为都是表达式， 所以都加入到了 Expression 结构体的联合体中。
/* 引用数组元素 */ typedef struct {
Expression *array; Expression *index; } IndexExpression;

/* 自增 / 自减 */ typedef struct {
Expression *operand; } IncrementOrDecrement;

/* 调用方法 */

typedef struct {

Expression

*expression;

char

*identifier;

ArgumentList *argument;

} MethodCallExpression;

4.4.2 方法的模拟
crowbar.ver.0.2 的数组配备了下面这些“像方法一样的函数”。
# 给数组增加元素 a.add(3);
# 取得数组的大小 size = a.size();
# 改变数组的大小 a.resize(10);
另外，（顺便）也给字符串添加了方法。
# 取得字符串的长度 len = "abc".length();
之所以说起方法的“模拟”，是因为现在在 crowbar 中还没有为类型（或者对 象）分配方法的通用手段。book_ver.0.2 的实现虽说属于偷工减料，但也算是用 了嵌入代码的方式。（截取自 eval.c，见代码请单 4-6。）

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 3 8 第 4 章　数组和标记 - 清除垃圾回收器

代码清单 4-6 eval_method_call_expression()

static void eval_method_call_expression(CRB_Interpreter *inter, CRB_LocalEnvironment *env,
Expression *expr) {  CRB_Value *left;  CRB_Value result;  CRB_Boolean error_flag = CRB_FALSE;  eval_expression(inter, env, expr->u.method_call_expression.expression);  left = peek_stack(inter, 0);

 if (left->type == CRB_ARRAY_VALUE) {



if (!strcmp(expr->u.method_call_expression.identifier, "add")) {



CRB_Value *add;



check_method_argument_count(expr->line_number, 



expr->u.method_call_expression



.argument, 1);



eval_expression(inter, env,



expr->u.method_call_expression.argument



->expression);



add = peek_stack(inter, 0);



crb_array_add(inter, left->u.object, *add);



pop_value(inter);



result.type = CRB_NULL_VALUE;



} else if (!strcmp(expr->u.method_call_expression.identifier,



"size")) {



check_method_argument_count(expr->line_number,



expr->u.method_call_expression



.argument, 0);



result.type = CRB_INT_VALUE;



result.u.int_value = left->u.object->u.array.size;



} else if (!strcmp(expr->u.method_call_expression.identifier,



"resize")) {



CRB_Value new_size;



check_method_argument_count(expr->line_number,



expr->u.method_call_expression



.argument, 1);



eval_expression(inter, env,



expr->u.method_call_expression.argument



->expression);



new_size = pop_value(inter);



if (new_size.type != CRB_INT_VALUE) {



crb_runtime_error(expr->line_number,



ARRAY_RESIZE_ARGUMENT_ERR,



MESSAGE_ARGUMENT_END);



}



crb_array_resize(inter, left->u.object, new_size.u.int_value);



result.type = CRB_NULL_VALUE;

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

4.4　其他修改 1 3 9



} else {



error_flag = CRB_TRUE;



}

 } else if (left->type == CRB_STRING_VALUE) {



if (!strcmp(expr->u.method_call_expression.identifier, "length")) {



check_method_argument_count(expr->line_number,



expr->u.method_call_expression



.argument, 0);



result.type = CRB_INT_VALUE;



result.u.int_value = strlen(left->u.object->u.string.string);



} else {



error_flag = CRB_TRUE;



}

 } else {



error_flag = CRB_TRUE;

 }

 if(error_flag) {



crb_runtime_error(expr->line_number, NO_SUCH_METHOD_ERR,



STRING_MESSAGE_ARGUMENT, "method_name",



expr->u,method_call_expression.identifier,



MESSAGE_ARGUMENT_END);

 }

 pop_value(inter);

 push_value(inter, &result);

}

说点题外话，最初在获取数组元素数的时候使用的是 get_size()，作为一 个 getter 方法，为了统一性着想，取名时应为 get_xxx() 的形式。但是，考虑 到这个方法使用频繁，并且经常要放在 for 语句中使用，方法的名字如果太长使 用起来不太方便，因此还是取名为 size() 了。.
我常常在想，虽然统一性很重要，但是方便性一样重要。不论是制作语言还 是程序库，要想兼顾这两个方面还真是不容易。.
不过，取得数组大小为什么不用方法，而只用了 length ？取字符串长 度时用的是 length()，而 Vector 和 ArrayList 这样取大小的为什么用的 是 size() 呢？我想这只是为了与之前的内容兼顾而产生的不统一。

4.4.3 左值的处理
在一般的表达式中，一个变量表示该变量储存的值。比如，将 5 赋值给 a，

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 4 0 第 4 章　数组和标记 - 清除垃圾回收器

代码清单 4-7 eval_assign_ expression 

当表达式中的 a 替换为 5 时表达式的结果保持不变。但是，变量在赋值的左边 时，此时将

a = 10;
变为

5 = 10;
是行不通的。总之，变量在赋值语句的左边时，变量代表的不是它储存的值，而 是储存值的地方（即变量的内存地址），我们称其为 左值（ . left.value）。.
book_ver.0.1 中，赋值语句的左边只能放变量。赋值语句的语法规则如下 所示。

expression : IDENTIFIER ASSIGN expression ;
但是在引入了数组之后，赋值语句的左边就可以写稍微复杂一点的表达 式了。

# 给二维数组 a 赋值，其中一个下标为以 b[i] 为参数 # 调用函数 func() 后的返回值 a[i][func(b[i])] = 5;
当然，使用老的语法结构不能对应这种情况，于是，我们将语法结构改写成 下面这样。

expression : postfix_expression ASSIGN expression ;
左边变成了 postfix_expression， 而 现 在 能 成 为 赋 值 语 句 对 象 的， 只有 primary_expression（变量名）和 postfix_expression（数组元 素）了。.
接着，在 eval.c 中首先计算右边的值，然后调用 get_lvalue() 函数取得 左边表达式的地址，详见代码清单 4-7。并且，这里调用的 peek_stack() 函 数会在不清除栈的情况下获取值，这样一来右边的值会作为赋值表达式整体的 值残留在栈中。

static void

eval_assign_expression(CRB_Interpreter *inter, CRB_LocalEnvironment *env,



Expression *left, Expression *expression) 

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

4.4　其他修改 1 4 1

{  CRB_Value *src;  CRB_Value *dest;

 /* 首先计算右边值 */ eval_expression(inter, env, expression); src = peek_stack(inter, 0);

代码清单 4-8 get_lvalue()

/* 取得左边的地址 */ dest = get_lvalue(inter, env, left); *dest = *src; }
那么，eval_assign_expression() 中调用的函数 get_lvalue() 又是 什么样子呢？请见代码清单 4-8。将标识符和数组分开处理，如果是数组的话， 可以利用 get_array_element_lvalue()（见代码清单 4-9）函数返回数组元 素对应的地址。

CRB_Value *

get_lvalue(CRB_Interpreter *inter, CRB_LocalEnvironment *env,



Expression *expr)

{

 CRB_Value *dest;

 if (expr->type == IDENTIFIER_EXPRESSION) {



dest = get_identifier_lvalue(inter, env, expr->u.identifier);

 } else if (expr->type == INDEX_EXPRESSION) {



dest = get_array_element_lvalue(inter, env, expr);

 } else {



crb_runtime_error(expr->line_number, NOT_LVALUE_ERR,



MESSAGE_ARGUMENT_END);

 }

 return dest;

}

代码清单 4-9 get_array_element_ lvalue() 

{  CRB_Value array;  CRB_Value index;

 /* 运算 [] 左边的表达式 */ eval_expression(inter, env, expr->u.index_expression.array); /* 运算 [] 中的表达式 */ eval_expression(inter, env, expr->u.index_expression.index); /* 取得两个变量的值 */ index = pop_value(inter); array = pop_value(inter);

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 4 2 第 4 章　数组和标记 - 清除垃圾回收器
/* 检查数据类型 */ if (array.type != CRB_ARRAY_VALUE) {
crb_runtime_error(expr->line_number, INDEX_OPERAND_NOT_ARRAY_ERR, MESSAGE_ARGUMENT_END);
} if (index.type != CRB_INT_VALUE) {
crb_runtime_error(expr->line_number, INDEX_OPERAND_NOT_INT_ERR, MESSAGE_ARGUMENT_END);
}
/* 检查下标范围 */ if (index.u.int_value < 0
|| index.u.int_value >= array.u.objext->u.array.size) { crb_runtime_error(expr->line_number, ARRAY_INDEX_OUT_OF_BOUNDS_ERR,
INT_MESSAGE_ARGUMENT, "size", array.u.object->u.array.size, INT_MESSAGE_ARGUMENT,“index”, index.u.int_value, MESSAGE_ARGUMENT_END); } /* 返回地址 */ return &array.u.object->u.array.array[index.u.int_value]; }
另外，在没有左值的情况下，取得数组元素值的引用时调用的函数 eval_ index_expression()，它的内部也使用了 get_array_element_lvalue()。
static void eval_index_expression(CRB_Interpreter *inter,
CRB_LocalEnvironment *env, Expression *expr) {
CRB_Value *left;
left = get_array_element_lvalue(inter, env, expr);
push_value(inter, left); }
自增 / 自减运算符也同样适用于使用 get_lvalue() 获取目标变量的地址。
4.4.4 创建数组和原生函数的书写方法
前面已经说过，用字面量可以创建数组 {1, 2, 3}，用原生函数 new_ array() 也可以。该原生函数的定义请见代码清单 4-10。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

代码清单 4-10 new_array() 

4.4　其他修改 1 4 3
/* 递归调用子例程 */ CRB_Value new_array_sub(CRB_Interpreter *inter, CRB_LocalEnvironment *env,
int arg_count, CRB_Value *args, int arg_idx) {
CRB_Value ret; int size; int i;
if(args[arg_idx].type != CRB_INT_VALUE) { crg_runtime_error(0, NEW_ARRAY_ARGUMENT_TYPE_ERR, MESSAGE_ARGUMENT_END);
} size = args[arg_idx].u.int_value;
ret.type = CRB_ARRAY_VALUE; ret.u.object = CRB_create_array(inter, env, size);
if (arg_idx == arg_count-1) { for (i = 0; i < size; i++) { ret.u.object->u.array.array[i].type = CRB_NULL_VALUE; }
} else { for (i = 0; i < size; i++) { ret.u.object->u.array.array[i] = new_array_sub(inter, env, arg_count, args, arg_idx+1); }
}
return ret; }
/* 原生函数本体 */ CRB_Value crb_nv_new_array_proc(CRB_Interpreter *interpreter,
CRB_LocalEnvironment *env, int arg_count, CRB_Value *args) { CRB_Value value;
if (arg_count < 1) { crb_runtime_error(0, ARGUMENT_TOO_FEW_ERR, MESSAGE_ARGUMENT_END);
}
value = new_array_sub(interpreter, env, arg_count, args, 0);

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 4 4 第 4 章　数组和标记 - 清除垃圾回收器
return value; }
首先，这次的修改在原生函数的参数中增加了 CRB_LocalEnvironment。 上 面 代 码 中 的 处 理 只 是 递 归 地 创 建 了 数 组 的 数 组， 数 组 所 需 内 存 空 间 的 开 辟 工 作 由 CRB_create_array() 完 成。 同 时 还 为 原 生 函 数 增 加 了 形 式 参 数， 从 而 使 CRB_LocalEnvironment 可 以 作 为 参 数 传 递 进 去。 那 么，CRB_ LocalEnvironment 的 用 途 是 什 么 呢？ 在 创 建 多 维 数 组 的 时 候， 会 多 次 调 用 new_array_sub() 开辟内存空间。如果 GC 在进行上述操作的中途启动的 话，就可能立刻释放掉刚分配好的数组。因此，为了把在函数中创建的对象标记 为不回收，我们需要把 CRB_LocalEnvironment 传递到函数中。. 具体来说，CRB_LocalEnvironment 的成员 ref_in_native_method 中 保存了在原生函数中创建的对象（具体请参考 4.2.4 节的定义）。. 类型 RefInNativeFunc 的定义如下，它以链表的形式保存着指向对象的 数组。
typedef struct RefInNativeFunc_tag { CRB_Object *object; struct RefInNativeFunc_tag *next;
} RefInNativeFunc;
这种设计的问题在于，创建于原生函数内部的对象在函数结束前不能被释 放。如果在原生函数中存在大量多次循环时，就会出现很多对象在创建后立即被 丢弃的现象。有些对象在函数结束前不能被释放，造成了内存空间的浪费。但 是，如果只是在原生函数内部使用的对象，那么比起使用麻烦的 crowbar 对象， 使用 C 的 malloc() 更方便。因此，实际情况下像上面那样的问题并不多见， 所以还是维持了这样的设计。
4.4.5 修改原生指针类型
crowbar.book_ver.0.1 的 原 生 指 针 类 型 的 值（CRB_Value 结 构 体 ） 中 包 含 了 void* 的指针和数据类型的标识信息。在 3.3.9 节中提到过，这个方法在“一 个地方用 fclose() 关闭了文件指针，可能还会在另一个地方被使用”的情况下
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

4.4　其他修改 1 4 5

会存在问题。 在 book_ver.0.2 中，原生指针类型的值不再指向实际的原生对象（FILE 结构
体等），而是在中间加入了一个 crowbar 对象进行“隔离”（如图 4-12）。

图 4-12 原生指针的构造（修 改版） 

原生指针类型的变量

CRB_Object

FILE 结构体等的对象

运用上面的方法，例如在调用 fclose() 的时候，将 CRB_Object 中指向 原生对象的指针同时置为 NULL，就能够立刻判断出文件已被关闭。也许有人会 想，在以前的做法中，没有将 CRB_Value 直接指向 FILE 结构体，而是在它们 中间夹了一个别的结构体，不是也起到同样的作用了吗？假设真的这么做了，那 么在对这个结构体进行 free() 的时机就又成了一个问题。何不借着实现 GC 的 机会，让它们中间夹一个可以作为 GC 目标的对象呢？.
顺便说一下，虽然这样一来就可以实现针对原生指针类型的 终结器（   finalizer） 了（GC 在释放原生指针类型的对象时调用之前注册的函数就可以了），但是由于 标记 - 清除型的 GC 中终结器“不知何时启动”，因此使用 crowbar 的用户最好不 要编写依赖于终结器的程序。但是对于一门编程语言来说，提供终结器也不是什 么坏事。.

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

第5章
中文支持和 Unicode
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 4 8 第 5 章　中文支持和 Unicode
5.1 中文支持策略和基础知识
在第 4 章中提到的 crowbar 是不支持中文的。一个标榜着像 Perl 一样的语言， 怎么可以不能正确处理含有本地语的中文文本文件呢？本章开始，我们就来看一 看汉化的处理方式。
5.1.1 现存问题
看了“crowbar 是不支持中文的”这句话后，肯定有人会问：“这是真的吗？”. 举个例子吧。
print(“你好 \n”);
这行代码在大多数环境下应该可以正常运行。但 crowbar 处理器其实并没有 意识到字符编码的问题，只不过是直接输出了一个含有字符串字面量的字节序 列，根本不能说它支持中文。具体有以下这些问题。 1. GB2312 环境下的 0x5C 问题
现在的 crowbar 代码是采用 GB2312 编码保存的，因此可能会因为特殊字符 而引起误动作。具体来说就像中文的“沑”和“昞”。.
比如，“昞”的 GB2312 编码是 0x955C 。第二个字节的 5C，是反斜杠的编 码，这会导致字符串字面量“昞”被编码成“"”和“\”组成的字符串。这里只 是在说字符串字面量的话题，crowbar 程序在读取来自外部文件和标准输入的字 符串时不会受到影响。 2. length() 方法
我 们 在 crowbar.book_ver.0.2 中 为 字 符 串 引 入 了 length() 方 法。 现 在 的 这个函数在执行代码 " 北京欢迎您 ".length() 时会返回 10。这种设计与 C 的 strlen() 相同，但这样的设计在 crowbar 中几乎派不上用场。“北京欢迎您” 是 5 个字，调用 length() 函数就应该返回 5 才对（在 C 语言中，很多情况下 要有很强的“字节数”意识，因此 strlen() 的设计不得不说还是挺方便的）。.
现在的 crowbar 中，字符串只有 length() 方法，今后还要引入截取字符串 的 substr() 等方法，在那个时候这个问题就更为重要了。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

5.1　中文支持策略和基础知识 1 4 9

既然现在 crowbar 的实现有以上的问题，那怎么解决好呢？想要考虑清楚这 个问题，需要很多基础知识。下面我们就对以下几项进行简单说明。

5.1.2 宽字符（双字节）串和多字节字符串

宽字符（wide.character）和 多字节字符（   multibyte.character）的说法源于 C

语言的用语。

多 数 人 在 编 写 C 语 言 程 序 的 时 候 使 用 char 数 组 来 表 示 字 符 串。 可

是，char 只能存储 1 个字节（通常是 8 位），存不下一个中文的字符。因此，中

文 字 符 的 存 储 都 是 使 用 GB2312（EUC， 即 扩 展 UNIX 编 码，Expanded.UNIX.

* EUC-CN 是 GB2312 最 常用的表示方法。浏览 器编码表上的 GB2312， 通 常 都 是 指 EUC-CN 表示法。

code）*、GBK、UTF-8 等 编码 。这种用多个字节保存一个字符的字符串形式称 为 多字节字符串 。
但是，这种保存方式存在一个问题，即不从 char 数组的开头开始看，就找 不到哪里是字符的分割点。C 语言使用 str[i] 获取字符串中一个字符时，也不

知道要取的是一个英文数字字符还是中文字符的第一个字节或第二个字节。在这

种 情 况 下， 如 果 要 制 作 一 个 编 辑 器， 在 按 退 格（ backspace） 键 的 时 候， 如 果 只

是删除了中文字符的第二个字节，那么后面跟着的内容就全都变成乱码了。实际

上，以前的很多编辑器都有这个问题。

GB2312 的 0x5C 问题大概也是这个原因。如果只看一个中文字符的第二个

字节，就会被误认为是“\”。

只保存 8 位的 char 类型显然不能满足需求，要是有一个内存空间足够的类

型用来保存中文等字符就好了。C 语言中的 wchar_t 类型，就是一个有足够内

存空间的类型（或者说是我们期望的类型）。.

以 wchar_t 数 组 表 示 一 个 字 符 串 的 方 式 叫 作 宽 字 符 串 。 正 如 我 们 期 待

* 为什么不是取出第 i 个
字符呢？因为 C 的数组
下标从 0 开始。

的，str[i] 可以取出这个字符串中第 i+1 个字符 *。 在 C 语言的标准中，并没有规定 wchar_t 到底是几个字节，以及 wchar_t 在
存储文字时用什么编码格式。在基于 UNIX 的 gcc 中执行 sizeof(wchar_t) 的

话返回 4，在 Windows（MinGW 的 gcc 或 VC++ 等）中返回 2。另外，在 C 代

码中如果想要定义宽字符和宽字符串的话，宽字符使用 L'a'，宽字符串使

用 L"abc"。.

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 5 0 第 5 章　中文支持和 Unicode
宽字符串 L"abc" 在 wchar_t 是 4 字节的环境中，需要消耗 16 字节的内存空 间（最后的 Null 字符也是 4 个字节）。我们暂且不说这种存储方式进行类型转换 的时候会发生编译错误，存储在内存上的 L"abc"，以字节为单位去看的话中间 可能会出现很多 0，会被误判为字符串末尾的 Null 字符。因此，宽字符串不能使 用 strcpy() 和 strcmp() 之类的函数，必须要用 wcscpy() 代替 strcpy()， 用 wcscmp() 代替 strcmp()。.
  补充知识    wchar_t 肯定能表示 1 个字符吗？ 
我们在 5.1.2 节中说到，wchar_t 类型有足够的内存空间保存中文等字符（或者 说是我们想要的类型）。可能会有人不满意这种模棱两可的说法，那么就让我们来确认 一下 C 语言标准中的定义吧。
在 IOS C99（ISO/9899:1999） 中 关 于 wchar_t 的 最 小 内 存 空 间 记 载 如 下 （7.18.3）：
wchar_t（参考 7.17 节）用带符号整数类型定义的情况下，WCHAR_MIN的值 不得小于 -127，WCHAR_MAX 的值不得大于 127。 wchar_t用 无 符 号 整 数 类 型 定 义 的 情 况 下，WCHAR_MIN 的 值 必 须 是 0，WCHAR_MAX 的值不得大于 255。  WCHAR_MIN 和 WCHAR_MAX，顾名思义是 wchar_t 最大值和最小值的常量。总之， 在标准中保证了 wchar_t 的大小只有 1 个字节，但是从 wchar_t 的定义本身来看， 规定如下： wchar_t 值的范围要能够容纳处理器所支持的区域设置中最大的扩展字符集 （包含全部编码要素的整数类型）。 至少在我看来这句话的意思是，wchar_t 的大小必须能存下所支持字符集的任何 一个字符。 但是，实际上 Windows 的 wchar_t 只有两个字节，所以不能表示超过 UCS2 范 围的字符。因此，至少在 Windows 中，wchar_t 类型不能表示一个字符（实际上 Windows 的宽字符串是 UTF-16）。可见世上没有最理想的事。
5.1.3 多字节字符 / 宽字符之间的转换函数群
字符的表示方法有多字节字符和宽字符两种，具体内容在前面的小节已经介 绍过了，相信大家也应该清楚了它们的使用方法。.
宽字符串把字符保存在 wchar_t 中，因此前面说到的制作编辑器、为字符串
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

5.1　中文支持策略和基础知识 1 5 1

* 在存储容量的价格方
面，考虑到内存要比硬
盘贵，节约内存空间也
是理所当然的。

添加 length() 和 substr() 方法都不成问题。可是，像英文数字这种平时只需 要 1 个字节表示的字符，在这里也需要占用 sizeof(wchar_t) 大小的内存空 间了。.
因此，在保存文件的时候，不推荐使用宽字符形式。宽字符是 C 语言的概 念，显而易见文件和编程语言是独立的。之前，“用同样的字节数来表示所有的 字符”这种想法，在编程时处理字符串是很方便的，但是作为文件处理方式的时 候就不再占据优势了，反而只会单纯地占用容量 *。于是，crowbar 的处理器有必 要进行如下的变化。
●● 从文件和标准输入中输入字符串时，从多字节字符转换为宽字符。 ●● 向文件和标准输出中输出字符串时，从宽字符转换为多字节字符。

这样一来，现在的状态就成了“在 crowbar 外部使用多字节字符，内部使 用宽字符”。在 C 语言中可以使用以下的函数群进行转换操作。这些函数是以 ISO.C95 标准进行了标准化的函数群，这些函数不仅名字具有标准性，十分好 记，详细的设计也编成了手册可在线阅读。在这里，我只对它们的基本功能进 行说明。

■■多字节字符向宽字符转换 ●● int mbtowc(wchar_t *pwc, const char *s, size_t n);
从多字节字符的字节序列中读取出代表一个字符的字节（最大 n 字节）， 将转换后的宽字符的指针保存在变量 pwc 中。功能和名字一样，mb（多字节字 符）转换为 wc（宽字符）。

●● size_t mbrtowc(wchar_t *pwc, const char *s, size_t n, mbstate_t *ps) 在 C 语言的规格书中将多字节字符定义（5.2.1.2）为“可以携带依赖于转
换状态的表现形式”。 利用 换码序列（  escape.sequence）这种特殊的字节序列进行编码间的切换，
当文字中出现了换码序列时，它之后的内容就是中文，而在中文中换码序列之 后的内容就是 ASCII 字符。
用这种方式将某个多字节字符转换为宽字符时，必须要知道它现在是什 么状态。
如 果 使 用 mbtowc() 从 开 头 对 多 字 节 字 符 串 进 行 处 理 的 话， 那 么. mbtowc() 会在内部记住当前的状态，并且根据状态转换出适当的宽字符。可

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 5 2 第 5 章　中文支持和 Unicode
能很多人会觉得这样就已经很好了。但是，如果这段使用了 mbtowc() 的转 换程序用来进行一个多线程的字符串处理时，mbtowc() 的这种“记状态”的 机制就被破坏了。
于是 mbrtowc() 将保存当前状态的内存空间交给了调用者。这个空间的 类型是 mbstate_t。在最初调用的时候，mbstate_t 可以使用 memset() 等 函数进行清零。
函数的名字是 mbrtowc()，中间加了一个 r。我想这个 r 可能是 reentrant 的 r。.
●● size_t mbstowcs(wchar_t *dest, const char *src, size_t len) 上述两个函数是用来转换文字的，这个函数可以将整个字符串一起处理。
于是函数名字在 mb 和 wc 后面都加上了 s。 函数将多字节字符串 src 转换为宽字符串，字符最大为 n 字节，结果保
存在 dest 指针中。函数的返回值会返回写入到 dest 的宽字符个数（不包 含结尾的 L'\0'），如果只想知道宽字符的字符个数的话，经常使用的方法是 给 dest 传 NULL 并获取返回值。.
●● size_t mbsrtowcs(wchar_t *dest, const char **src, size_t len, mbstate_t *ps) 和转换单个字符的函数一样，加上 r 就变成了 reentrant 版。src 变成了 指针的指针，是因为要在转换过程中将 src 移动到下一个要转换的多字节的 开头 A。
■■宽字符向多字节字符转换 ●● int wctomb(char *s, wchar_t wc)
可见，这是反过来将 wc 转换为 mb 的函数，也就是将一个宽字符转换为 多字节字符的字节序列的函数。 ●● size_t wcrtomb(char *s, wchar_t wc, mbstate_t *ps)
加上 r 就是 reentrant 版。 ●● size_t wcstomb(char *dest, const wchar_t *src, size_t n)
加上 s 就是字符串版。
A　这样做是为了对应多线程的情况。——译者注
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

5.2　Unicode 1 5 3
●● size_t wcsrtombs(char *dest, const wchar_t **src, size_t len, mbstate_t *ps) s 和 r 都加上，变成了字符串版的 reentrant 版。 为了能够使用这些函数，在 Windows（MinGW）中编译时必须配置启动项 -
lmsvcp60。
5.2 Unicode
前面章节已经做了简要说明，现在的 Linux 和 Windows 中，宽字符大多使用 的是 Unicode。作为 crowbar 处理器，如果想要制作一个转换宽字符和多字节字 符的程序库，可以不用考虑实际的 wchar_t 中存储的字符到底是什么字符编码。 但是，作为一名程序员是不能回避 Unicode 问题的，所以本章将对此进行介绍。
5.2.1 Unicode 的历史
Unicode 是由 Xerox 提出，并由 Unicode.Consortium 制定的字符编码。 Unicode 最初的内容是“用 16 位表示全世界所有的字符”，所以，中国、日 本、韩国使用的汉字只要字形是一样的，都会分配到同样的字符编码（Unicode 中正确的叫法应该是码位，即 code.point）。截止到 1990 年 12 月的最终草案，汉 字分配了 0x4000~0xE7FF，共 18739 个字符。. 在中国，GB2312（EUC-CN）能表示的汉字总共有 6763 字，由此得知，在 Unicode 出现之前使用普通 PC 可以处理的汉字，全部可以用 Unicode 表示。但 是，考虑到经常有一些人名或者古汉语中的字符无法用国标汉字表示，因此即使是 18739 个字也不一定够用，更何况这个范围内还包含了日本和韩国使用的汉字 A。 另外，对于日本人来说，假名等分配了 0x3000~0x3FFF，共 4096 个字符。 假名的字符很少，这个范围已经足够了，但是韩语一个字符的形状由初声、中 声、终声的排列组合决定，初声 19 种，中声 21 种，终声 27 种，加上有些字符
A　有时候，三个国家使用的汉字即使字形相同也是不一样的，因此分配了不同的码位。——译者注
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 5 4 第 5 章　中文支持和 Unicode

没有终声的情况，一共有 19.×.21.×.(27.+.1).=.11172 个字符 [4]。这么多字符，

* 1987 年 的 时 候， 韩 国 国 内 的 标 准 KSC 5601 修订版中韩语只有 2350 个 字 符， 同 一 时 期的 Unicode 已经包含 了这些字符，如果是日 常 使 用 的 话，16 位 的 Unicode 也没什么问题。

Unicode 当然适应不了了 *。. 如此一来，结果就是在现有的 16 位 Unicode 上进行扩充（现在是 21 位），以
16 位为范围收录的一套字符作为 UCS2（表示 Universal.Coded-Character.Set 的 2 位版）进行标准化，收录不下的所有字符以 4 字节表示，这就是 UCS4。

5.2.2 Unicode 的编码方式

如前所述，Unicode 本来想用 16 位来表示世界上所有的字符（但实际上收录 不下）。那么，在内存和磁盘中保存字符串的时候，只能 2 字节一组表示 1 个字 符吗？也不一定。.
我们首先介绍一下 字符集（ . character.set）和 编码方式（   正确的说法应该是字 符符号化方式）。
计算机想要处理字符，首先要决定什么样的字符是要处理的对象，其次就 是为这些字符分配编号，这就是字符集。为每个字符分配的编号在 Unicode 中称 为 码位（   code.point）。例如中文“啊”的码位是 0x554A，记作 U+554A。.
但是，这些字符想要在内存或者磁盘上表示就是另外一码事了。编码方式是 指规定以何种方式将逻辑上的码位值以字节或位的方式表示出来。虽然很可能某 两种编码方式的目标字符集相同，但因为编码方式和字符在字符集中的顺序不 同，因此在内存上的表现形式也不同。.
Unicode 的编码方式首先要考虑的是，Unicode 是 16 位的，要为一个字符分 配 2 字节，这种方法被称为 UTF-16 。.
但是，假如使用 C 语言中 2 字节的整数类型（short 等）表示 1 个字符，内 存上的表示方式会根据环境的字节序产生变化。因此，UTF-16 根据字节序的不 同分为 UTF-16BE（大尾序）和 UTF-16LE（小尾序）两种。中文“啊”，用 UTF16BE 表示为 0xB0 0xA1，用 UTF-16LE 表示为 0xA1 0xB0。另外，在和其他 PC 通信的时候，如果不知道字节序也很麻烦。可以在 UTF-16 的字符串开头加上 字节序的标识（这种标识叫作 BOM ，即 Byte.Order.Mark，值为 U+FEFF）。读取 带 BOM 的 UTF-16 字符串时，如果第一个字符是 0xFE.0xFF 就是 UTF-16BE，如 果是 0xFF.0xFE 就是 UTF-16LE。.

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

5.2　Unicode 1 5 5

但是，UTF-16 如果要表示字母 A（码位为 U+0041）也要消耗 2 个字节，这 样在英语圈的人（只使用 ASCII 的人）看来，字符串在内存和磁盘上的消耗突然 变成了原来的 2 倍。而且，字符串 ABC 在内存上的表示方式（在 UTF-16BE 的情 况下）为 0x00 0x41 0x00 0x42 0x00 0x43，并不兼容现存的 ASCII 编码。
为 了 解 决 上 述 问 题， 出 现 了 UTF-8 。 首 先，Unicode 在 0x00~0x7F 的 范 围 内分配了和 ASCII 编码相同的码位，由此，在 UTF-8 中上述范围的字符可以用 1 个 字 节 表 示， 在 这 之 后 的 0x80~0x7FF 用 2 个 字 节 的 0xC280~0xDFBF 表 示， 0x800~0xFFFF 用 3 个字节的 0xE0A080~0xEFBFBF 表示。用语言难以描述清楚， 还是看图 5-1 吧。

图 5-1 UTF-8 的二进制表示 方法

　到第 7 位为止 0VVVVVVV 　到第 11 位为止 110VVVVV 10VVVVVV 　到第 16 位为止 1110VVVV 10VVVVVV 10VVVVVV 　到第 21 位为止 11110VVV 10VVVVVV 10VVVVVV 10VVVVVV 　到第 26 位为止 111110VV 10VVVVVV 10VVVVVV 10VVVVVV 10VVVVVV 　到第 31 位为止 1111110V 10VVVVVV 10VVVVVV 10VVVVVV 10VVVVVV 10VVVVVV
　※ 本图中的“V”表示字符编码的位都存储在靠右的位置。

在图 5-1 中的“V”表示字符编码的位都存储在靠右的位置。这种方法的

好处在于，在只使用 ASCII 字符的情况下兼容现存的 ASCII 编码，而且，由于

ASCII 字符以外的字符（UTF-8 需要 2 字节以上来表示的字符）全部使用 0x80 以

上的字节依次表示，因此即便只考虑了 ASCII 编码的程序（编译器等），（只要能

通过 8 位）也可以正常地处理 UTF-8 的文件。像 GB2312 中 0x5C 那样的问题不

会在 UTF-8 中出现。同样，在 GB2312 中有搜索“海”却被匹配成“""”的问题

（因为“海”的 GB2312 编码为 0xB0.0xA1，“""”的编码为 0xA1.0xB0），UTF-8

的第 1 个字节不会与其他字符的第 2 个以及之后的字节重复，因此不会有问题。

* 因此从逻辑上来讲不再 需要 BOM 了，但还是 有附加了 BOM 的编辑 器和没有 BOM 就不能 正常运行的应用存在。

另外，UTF-8 的表示方式是以字节为单位的，所以也不会受字节序的影响 *。 UTF-8 的缺点在于，用 UTF-16 的 2 个字节可以表示的字符，在 UTF-8 中需
要 3 个字节才能表示。. 话说回来，图 5-1 中所示，UTF-8 最大为 6 字节，可以表示 31 位的码位（实

际分配到了 4 字节 21 位）。但是，在使用 UTF-16 的情况下连表示 21 位的字符

也做不到。因此需要使用一种称为代理对（ Surrogate. Pair）的方法，即如果最初

的 2 个字节在特定范围（0xD800~0xDBFF）的话就要连接后面的 2 个字节来表示

1 个字符，以此方法表示 0x10000~0x10FFFF 之间的字符。0x110000 以后不能用

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 5 6 第 5 章　中文支持和 Unicode
UTF-16 表示。
  补充知识    Unicode 可以固定（字节）长度吗？ 
就像 5.1.2 节介绍的那样，在内存中表示某个字符串的时候，如果每个字符占的 内存空间大小是可变的，就会很不方便。试想一下，只要写 str[i] 就能取到 str 的 第 i 个字符的话确实很方便。
基于这点，在 Unicode 中 UCS2 范围内所有的字符都可以用 2 个字节表示，要是 能忍受，即使 ASCII 字符也要消耗 2 个字节的话就太完美了。想法总是美好的，结果接 下来发现 2 个字节容不下了，又引入了代理对，结果 1 个字符又失去了固定长度。真是 蠢死了。肯定会有人这样想（实际上我以前就是这么想的）。
但是，Unicode 在最初的建议稿（1989 年 9 月的 Unicode Draft1）中就提出了， 以在普通的罗马字后面加上方言记号的形式（合成字符）表示德语的元音变音及类似的 字符。因此， 方言在 Unicode 中表示为 U+0041 U+0308（但是为了与现存的 Latin-1 编码兼容，也可以用 U+00C4 表示）。
总之，Unicode 从一开始就没有想让一个字符用固定长度表示。
5.3 crowbar book_ver.0.3 的实现
本节将要说明如何在 crowbar_ver.0.3 中实现（实现到什么程度，怎么实现） 对中文的支持。
5.3.1 要实现到什么程度？
crowbar 对中文（或者说国际化）的支持应该到什么程度呢？这个“程度” 包含了多方面的含义。首先，到目前为止，crowbar 的变量或者函数名之类的标 识符只支持字母。.
Java 等语言可以使用汉字命名变量，但我想很少有人会用到（这只是因为习 惯的问题，其实用汉字来命名变量，代码可读性没准会有飞跃性的提高），这个 功能即使支持了中文也没人会用到。另外，如果要让标识符支持汉字，就要决定 是否允许变量名里面包含全角空格。因为比较麻烦，这里就先跳过了。.
另外还有一个问题就是，要支持一个什么样的字符集？.
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

5.3　crowbar book_ver.0.3 的实现 1 5 7
姑 且 以 宽 字 符（wchar_t） 为 一 个 字 符 来 处 理。 使 用 5.1.3 节 中 介 绍 过 的 mbtowc() 系列函数将多字节字符转换为宽字符。.
在 Linux 中 使 用 sizeof(wchar_t) 返 回 4， 但 在 Windows 中 返 回 2。 因 此，宽字符可以正常处理 ASCII 字符和普通的中文，但是超过了 UCS2 范围的字 符（在 UTF-16 中被组成代理对的字符）就不能直接处理了。A 方言这样的合成 字符也是不能处理的（使用兼容 Latin-1 的 U+00C4 来表示就另当别论了）。当然 并不是完全不能表示，如果使用字符串的 length() 方法获取字符串的长度的 话，会得到和实际长度不同的结果。.
这样一来，也不能说是完全支持了 Unicode，但是对于大多数人来说，暂且 让我可以正常地使用中文和英语就可以了。我想比起花很多时间来追求完美的支 持，把大多数人觉得“可以”的范围赶快做出来，是更好的选择。.
以下两种编码方式为用于输入输出的多字节的字符编码方式。 ●● GB2312 ●● UTF-8 先假设 crowbar 处理器中的 C 代码和用 crowbar 书写的代码以及 fgets() 等 读取输入输出文件的函数，全部使用了统一的编码方式。
5.3.2 发起转换的时机
在 crowbar 中，以下这些情况需要由多字节字符转换为宽字符，或者由宽字 符转换为多字节字符。
1. 用 crowbar 书写的代码中的字符串字面量在编译时需要转换为宽字符串。 2. fgets() 函数读取的字符串需要由多字节字符串转换为宽字符串。 3. 调用 print()、fputs() 等输出函数的时候，需要由宽字符串转换为多字节字符串。 4.	因为 C 代码中使用 GB2312（EUC-CN）嵌入错误信息，所以在组装错误信息时需
要转换为宽字符串（信息在显示的时候，需要根据规则 3 再次进行转换）。 5. 在接收命令行参数 ARGS 的时候，需要转换为宽字符串。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 5 8 第 5 章　中文支持和 Unicode
5.3.3 关于区域设置
在 5.3.1 节中说道： 先 假 设 crowbar 的 处 理 器 中 的 C 代 码 和 用 crowbar 书 写 的 代 码 以 及 fgets() 等读取输入输出文件的函数，全部使用了统一的编码方式。 可 是， 编 码 方 式 究 竟 是 什 么 呢？ 简 单 地 说， 就 是 环 境 默 认 的 字 符 编 码。 Windows 是 GB2312，Linux 是 EUC-CN 或 者 UTF-8。UNIX 可 以 根 据 环 境 变 量 LANG 进行切换。 那么，实际上使用 mbtowc() 系列函数将多字节字符串转换为宽字符串，想 要为转换函数群指定默认区域设置必须调用下面的函数。
setlocale(LC_CTYPE, "")
在 crowbar 中，需要在 main() 函数中执行上面的语句。.  setlocale() 函数的详细设计在这里不再赘述，请参考（C 语言标准库的） 手册等资料。
5.3.4 解决 0x5C 问题
在 5.1.1 节中提到，当前的 crowbar 由于运行在 GB2312 环境下，字符串字面 量中不能使用例如“昞”这样的字符。.
即使可以使用 mbtowc() 系列函数正确地处理 GB2312，还必须在一开始就 用 lex 解释字符串字面量，这还不算完，为了解决这个问题还要在 crowbar.l 中添 加代码。.
GB2312 的汉字，第 1 个字节定义在 0xA1-0xF7 之间，第 2 个字节定义在 0xA1-0xFE 之间。因此，如果只支持 GB2312 的话，要在 crowbar.l 中添加下面 4 行代码。
（之前省略） <STRING_LITERAL_STATE>[\xa1-\xf7][\xa1-\xfe] {
crb_add_string_literal(yytext[0]); crb_add_string_literal(yytext[1]); } （之后省略）
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

5.3　crowbar book_ver.0.3 的实现 1 5 9

为了在编译时能区分源文件的编码，在解释器中保存一个标识。.

/* 保存编码方式的枚举类型 */

typeof enum {

GB_2312_ENCODING=1, /* GB2312 */

UTF_8_ENCODING

/* UTF-8 */

} Encoding;

struct CRB_Interpreter_tag { ( 中间省略 ) /* 在 CRB_Interpreter 结构体中保存 crowbar 代码的编码方式 */ Encoding source_encoding;
};
在此基础上，在 lex 的启动条件中添加 GB_2312_2ND_CHAR（GB2312 的
第 2 个字节），代码在读取到了 GB2312 的第 1 个字节时跳转到 GB_2312_2ND_
CHAR 执行。

<STRING_LITERAL_STATE>.

{

/* 从解释器中取得编码方式 */

Encoding enc = crb_get_current_interpreter()->source_encoding;

/* 先将字符添加到字符串字面量中 */

crb_add_string_literal(yytext[0]);

/* 如果代码运行在 GB2312 环境下，

再判断这个字符，如果是 GB2312 的第 1 个字节，

跳转到 GB_2312_2ND_CHAR 执行 */

if (enc == GB_2312_ENCODING

&& ((unsigned char*)yytext)[0] >= 0xa1)

&& ((unsigned char*)yytext)[0] <= 0xf7)) {

BEGIN GB_2312_2ND_CHAR;

}

}

<GB_2312_2ND_CHAR>. { /* 添加 GB2312 的第 2 个字节 */ crb_add_string_literal(yytext[0]); BEGIN STRING_LITERAL_STATE;
}
增加 CRB_Interpreter 的 source_encoding 成员，是因为在创建 CRB_ Interpreter 的内存空间时，不能使用 #ifdef 进行分割（请参考 interface.c 的函数 CRB_Interpreter()）。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 6 0 第 5 章　中文支持和 Unicode
  补充知识    失败的 #ifdef
如前面所述，在执行解释器的处理器中，用 #ifdef 来切换语言的（默认）设定 （GB2312、GBK 或者是 UTF-8）。在最初的 crowbar 中，就是使用 #ifdef 进行对应处
理器的切换。 在一些 C 的入门书中都有这样一句话：为了提高移植性而适当地使用 #ifdef。以
我的理解，“适当地使用”其实就是“尽量别用”的意思。因此，这次我（在处理器切 换时）使用了 #ifdef，这对我来说也是一次失败。
根据处理器不同而使用 #ifdef 选择不同代码片段的话，会使代码变得很难理解。 另外，像这样分散的代码通常很难进行充分的测试。在理想状态下，所有 #ifdef 的组合可 以伴随着每日构建进行自动化测试，这感觉还不错，但是我认为这在实际中很难实现。
如果是为了提高移植性，那么也可以不使用 #ifdef 来处理各种分支，只要写一个 尽可能适应各种处理器的代码不是就行了吗？
编程方面的著作《程序设计实践》[5] 中有以下记载。 如果我们对于条件编译持否定态度，那么就会由此发生一些问题。先不说 最 麻 烦 的。 条 件 编 译 基 本 上 都 不 可 能 进 行 测 试。（ 中 间 省 略 ） 在 对 其 中 一 个 #ifdef 代码块进行测试的同时，如果想测试另外的 #ifdef 代码块，除 非改变环境使另一个 #ifdef 代码块生效，否则无法进行验证。 （中间省略） 由此我们得知，让我们感兴趣的是，在所有目标环境中都可以运行的共通性功能。
5.3.5 应该是什么样子
5.3.1 节决定了 crowbar 不处理合成字符和 UCS2 范围以外的字符。. 如果只是为了对应中文的话，这样的设计（指 5.3.1 节中提到的设计方式）就 没问题了。但如果想要完美地实现，恐怕就需要考虑以下几点（以 Unicode 为前提）。 1. 内部表现也要使用 UTF-8 如果考虑合成字符的话，就不可能让字符有固定长度。如果想要取得字符串 的第 n 个字符，每次都必须从字符串的开头扫描，所以还是算了吧。 2. 不使用 mbtowc() 系列函数，自己实现全部的转换 如果自己保存转码表，就要根据不同的情况使用不同的转码表。比如，在需 要和 Java 兼容的时候要使用 Java 的转码表，如果要在 Windows 对话框中显示一 个字符串的时候又要使用 Windows 的转码表等。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

5.3　crowbar book_ver.0.3 的实现 1 6 1
 mbtowc() 系列函数不仅意味着“在所有的处理器中，总是可以返回所期望 结果”，还表示“如果自己保存转码表的话，所有转换都要自己进行”。.
作为一个还算现实 的 做 法 （ 只 要 能 处 理 好 中 文 就 可 以 了 ）， 我 制 作 的 这 个 语 言 处 理 器 ， 正 好 解 决 了 所 有的问题。如果一味追求结果而不能实现也是没有 意义的。
  补充知识    还可以是别的样子——Code Set Independent 
在 5.3.5 节中介绍了自己保存转码表和将内部编码变为 UTF-8 这两种方法。 在 UTF-8 这种方法中，首先让内部的编码方式使用 Unicode，在正常的情况下，不 论是从外部输入的字符编码还是向外部输出的字符编码都是 Unicode。 除 此 之 外 还 有 另 外 一 种 方 式， 即 内 部 编 码 不 固 定。 这 种 方 式 称 为 Code Set Independent（CSI）。 若将内部编码固定为 Unicode，那么在 UNIX 的 EUC 环境中，是绝对不可能使用 EUC 以外的编码方式的。在这种情况下，每次发生读写时都要使用转码表在其中转换。 暂且不说效率低下的问题，更重要的是，如果想要表示在 Unicode 中没有的字符，或 者要把在 Unicode 中认为是一样的字符当做不同的字符处理，这些情况使用 Unicode 都是不能处理的。 实际上，Ruby1.9 就采用了 CSI 方式。在 Ruby 中，每个字符串都会保存着自己的 编码方式。 例如在输出文件的情况下，只要 Ruby 知道转换方法，就可以将要输出的编码方式 （外部编码方式）和字符串的编码方式（内部编码方式）进行转换。 具体来说，比如在 Ruby 支持的编码方式中有 Emacs-Mule，这种编码方式没有采 用像 Unicode 一样将中文汉字分配统一编码的方式，它基于 ISO-2022 为各国（但是没 有国籍限制）语言分配了不同的编码 A。在处理以这种方式编码（同时存在多种语种的文 字）的文件时，如果像 crowbar 那样限定内部字符编码为 Unicode 的编码方式，那么 在转换为内部表现时就会产生不可逆的（无法恢复到原来状态的）信息丢失。 CSI 既有优点也有缺点。 当有 N 种外部编码方式时，Unicode 正常的处理方法是准备输入和输出的编码方式 转换器（共 2N 种）。与此相对，CSI 只需要（N-1）种。另外，在程序中进行比较和连 接字符串的时候也会受到限制。 现在，为了方便实现而优先将内部编码限定为 Unicode，这实际上还是有些问题 的，这就是我坚持 CSI 的原因。 这是一个哲学或者说是价值观的问题。两种方式都有它们的合理性，在使用的时候 应该在平衡利弊的基础上再做出决定。
A　只是处理了不同的语种，但不是按国家划分的编码。——译者注
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

第6章
制作静态类型的语言 Diksam
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 6 4 第 6 章　制作静态类型的语言 Diksam

6.1 制作 Diksam Ver 0.1 语言的基本部分
此 前 的 章 节 中， 我 们 已 经 制 作 了 一 个 无 变 量 类 型、 通 过 分 析 树 执 行 的 语 言 crowbar。从本章开始，我们来制作一个静态类型并通过字节码执行的语言 Diksam。
Diksam 这个名字的由来可不是“像 Perl 一样”的双关语，而是我钟爱的一种 红茶的名字。既然有了咖啡语言 Java，再来一个红茶语言也无伤大雅吧。Diksam 是一种口味浓郁的阿萨姆红茶，一般都用来做成奶茶。我很喜欢直接去感受它的 那份浓郁。

6.1.1 Diksam 的运行状态

前面已经提到，Diksam 是通过字节码执行的语言。

* 虽然现在可能基本上都
以 JIT（Just In Time）
的方式运行，但是本书
中不考虑这种情况。

说起通过字节码执行的语言，以 Java 为例再合适不过了 *。在编写 Java 代码 时，要先编写源程序，再通过 javac 编译成保存着字节码的 class 文件 。
Diksam 语言不会生成像 class 文件那样的字节码文件。编译器解析源代码并

生成分析树后，直接在内存中生成字节码。这些在内存中生成的字节码，会由

Diksam 的虚拟机 DVM（Diksam.Virtual.Machine）运行。.

Diksam 不生成字节码文件的做法，免去了考虑文件格式和文件编码的麻烦。

当然，除了我的个人考量外，对于用户来说也省去了逐个编译源文件的工夫。这

种做法在代码量非常巨大的情况下，每次启动程序时花费在编译上的时间都会让

你等得不耐烦。当然，程序不是很大的时候还是很方便的。

另外，在实现中，DVM 将完全信任编译器生成的字节码。所谓“完全信任”

就是说，即使是含有恶意代码的字节码 DVM 也会加载执行，不过这可能会使

DVM 崩溃。

Diksam 是一种静态类型语言，在编译时就已经决定了所有变量和表达式的数

据类型。因此，在运行时就不需要再检查变量的数据类型了。比如，为了在堆中

存储一个字符串，s tring 型变量会（间接的）保存指向该字符串的指针，但如果存

储的整数型局部变量被当作 string 型引用时，DVM 就会因为找不到正确的引用地

址而崩溃。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

6.1　制作 Diksam Ver 0.1 语言的基本部分 1 6 5

但也是有相应对策的，比如在网页中运行的 Java.Applet，由于必须执行来 自外部的（不能被信任的）字节码，因此绝对不允许发生上述情况。所以 Java 在加载字节码的时候会执行 验证器（   verifier）程序，以验证加载的字节码是否 正确。
但是，制作验证器非常复杂，而 Diksam 还只是直接在内存中执行字节码的 语言，所以……不好意思，这里我要跳过啦。

6.1.2 什么是 Diksam

代码清单 6-1 fizzbuzz_0_1.dkm

首先，我们制作的 Diksam 是 Diksam.book_ver.0.1 版本，实例请参考代码清 单 6-1。
int print(string str);

int i;

for(i = 1; i <= 100; i++){

 if(i % 15 == 0){



print("FizzBuzz\n");

 }elsif(i % 3 == 0){



print("Fizz\n");

 }elsif(i % 5 == 0){



print("Buzz\n");

 }else{



print("" + i + "\n");

 }

}

6.1.3 程序结构
与 crowbar 相同，Diksam 中也有顶层结构，并且允许在函数外编写代码。程 序从顶层结构的开头开始执行。
Diksam 用下面的方式定义函数。与 C 语言基本相同。
int func(int a, double b){ int local_varible;// 声明局部变量
local_varible = a + b;

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 6 6 第 6 章　制作静态类型的语言 Diksam

print("local_varible.." + local_varible + "\n");
return local_varible; }

6.1.4 数据类型

Diksam.book_ver.0.1 可以使用以下四种数据类型。

●● boolean（布尔）型。可以赋 true 或 false 值。

●● int（数字）型。

●● double（浮点）型。int 和 double 混合进行运算时，参与运算的 int 类型会自

动扩展为 double 类型。

●● string（字符串）型。当字符串在 + 号左边时，右边的部分会自动转换为 string 型。

. 

double 这个关键字在 C 语言中的意思是 双精度 浮点数，这里的 double

以 float（单精度浮点数）的存在为前提。但是，Diksam 中并没有 float，尽

管它叫作 double 型，也纯粹是为了照顾 C 和 Java 语言的使用者而已。

6.1.5 变量
如前所述，Diksam 是静态类型的语言，变量必须事先声明，声明方式和 C 语言一样，如下所示：.
int a;
在函数内声明的局部变量只可以在声明变量的程序块内引用，函数外声明的 变量是全局变量 A。.
现阶段在 Diksam 中变量声明也是一种语句，可以写语句的地方就可以声明 变量。
在 C 语言中变量必须声明在程序块的开头部分，C++ 和 Java 取消了这个限 制。虽然这被大多数人认为是个改进，而且 Diksam 也是这么做的，但是老实说 我不喜欢这个改进。我认为，在代码的任意位置都可以声明变量会使一个函数渐

A　程序块内外都可引用。——译者注

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

6.1　制作 Diksam Ver 0.1 语言的基本部分 1 6 7
渐变得冗长。因此，也许可以趁现在 A 改正过来。. Diksam 中声明变量的方式和 C 等语言相同，采用类型 变量名 ; 的形式。这
种形式对于处理数组和函数类型的变量来说很麻烦。如果引入预声明关键字 var， 那么像下面这样把数据类型写在后面的语法（Pascal、Ada、ActionScript 都是这 种方式）处理起来会简单一点。
var a:int;
但是，习惯了 C 或者 Java 语言的程序员肯定会说，还是类型 变量名 ; 这样 的方式写着更顺手。为了照顾大家，Diksam 还是采用了大家比较习惯的方式。实 际上，在拙著《征服 C 指针》（人民邮电出版社，吴雅明译）中，整本书都在表 达对 C 语言变量声明语法结构的不满。在那本书中写了那么多不满，现在却变成 了墙头草，肯定要被嘲笑了。
言归正传，类型 变量名 ; 形式的语法如果包含了数组和类（class），制作语 法分析器的时候就会出现各种问题，幸亏 Diksam 在语法规则上花了不少功夫才 避免了这些问题。这个话题我们在后面的章节中详细说明。
变量 初始化语句（ . initializer）的方式也与 C 语言相同。.
int a = 10;
6.1.6 语句和流程控制
流程控制语句有：if（ elseif、else）、while、for、break、continue、 return。
含义和 crowbar 相同，花括号也不可以省略。另外，break 和 continue 也 可以使用标签（和 Java 一样）。
6.1.7 表达式
Diksam 中可以使用的运算符及其优先级，如表 6-1 所示。
A　制作 Diksam 语言的机会。——译者注
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 6 8 第 6 章　制作静态类型的语言 Diksam

表 6-1

 运算符 

在 Diksam 中可以使用 的运算符

++ -- ()

（单目）-

* / %

+ -

< <= > >=

== !=

&&

||
= += -= *= /= %= ,

 含义  自增、自减、函数调用 符号反转 乘法、除法、模 加法、减法 比较大小。字符串也可以比较大小（以 strcmp( ) 为基准） 等值比较。字符串也可以进行比较（比较的不是引用而是值） 逻辑与（AND）运算符。短路运算符，在表达式 a && b 中，如 果 a 为真，b 就不判断了 逻辑或（OR）运算符。短路运算符，在表达式 a || b 中，如果 a 为真， b 就不判断了 赋值运算符。与 C 语言中的含义相同 逗号运算符。从左到右的顺序计算表达式，返回右边表达式的值

函数调用被定义为运算符，说明函数也是一种表达式。 这就意味着，在 crowbar 中可以像 C 语言的函数指针那样把函数赋值给变量， 但是，实际上 crowbar 并不能声明保存函数的变量，因此也就没办法把函数赋值 给变量。

6.1.8 内建函数

Diksam 在一开始就准备了内建函数。Diksam.book_ver.0.1 中的内建函数一览 表如下所示。

int print (string arg)

显示 arg。返回值为 0（因为还没有 void 类型）

完毕！ 只有一行的一览表，很糗是吧。

6.1.9 其他
注释可以使用 C 风格的 /*~*/，也可以使用 C++ 从 // 开始到本行结束的 风格。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

6.2　什么是静态的 / 执行字节码的语言 1 6 9
6.2 什么是静态的 / 执行字节码的语言
6.2.1 静态类型的语言
如前所述，Diksam 是静态类型的执行字节码的语言。这样的语言有以下 优点。 1. 能够高速执行（通常情况下）
理由会在之后详述。对于静态类型的执行字节码的语言来说，如果能够朴素 地实现这两个方面的话，会比无类型并通过分析树执行的语言拥有更快的速度。 2. 编译阶段和执行阶段分离
例如在 Java 中，事先使用 javac 把源代码生成为 class 文件，这样在执行时就 不需要再编译了。
实 际 上 crowbar 由 源 代 码 生 成 分 析 树 的 处 理 并 不 耗 时，（Diksam 要 想 比 crowbar 强的话）速度上没有什么可期待的。相反，如果想要在不发布源代码的 情况下运行程序倒还是有希望的。.话虽如此，实际上因为现在的 Diksam 是在内 存上构建字节码并执行的，结果还是必须要发布源代码。 3. 相比之下使用静态类型的语言编写的代码更易读
静态类型的语言通常要将变量和类型一起声明（比如 int a;）。也许会有人 觉得这样很麻烦（这就是为什么无类型的 LL 语言这么有人气的原因），实际上也 不是很费事，因为还是把变量类型明确化以提高源代码的可读性更为重要。至少 我是这么想的，但这句话是一个泥潭，还是赶快结束这个话题吧。
6.2.2 什么是字节码
字节码是在被称为 虚拟机（  Virtual.Machine）的虚拟 CPU 上执行的机器语言。 机器语言直接通过 CPU 执行，而字节码通过虚拟机执行。
字节码和机器语言一样，实际上都是数字的序列（这点也和机器语言一样）。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 7 0 第 6 章　制作静态类型的语言 Diksam

为了让大家更好的理解，各个命令将以一种被称为 助记符（   mnemonic）的字符串 形式表现出来。
比如在 Java 虚拟机（JVM）中运行的字节码就是下面这个样子。（再来回看 一下代码清单 1-4）

0: bipush 10

2: istore_1

3: iload_1

4: bipush 10

6: if_icmpne

20

9: getstatic

12: ldc

14: invokevirtual

17: goto 28

20: getstatic

23: ldc

25: invokevirtual

可能有人会认为，就算是为了让读者能够更好地理解才使用了字符串的表现 方式，可这种根本就不知所云的东西如果想要从源代码生成出来，简直就是做 梦，更不要说作一个可以生成字节码的编译器了。但实际上并没有那么难，具体 步骤请见下节。

6.2.3 将表达式转换为字节码
crowbar 从 ver.0.2 版本开始把计算过程中的值存入栈中（为了确保 GC 可以 追踪指针）。在这种情况下，执行字节码的语言也会进行大致同样的实现。关于 此事，4.2.3 节的最后部分中有如下记载。
这种做法与 JVM 堆栈机运行字节码时的栈动作相同。如此一来，我们就向 字节码解释器又迈进了一步。
具体来说，分析树优先从最深层次开始遍历，从而生成下面这样的代码。
1. 常量/变量类会直接把值保存到栈中。 2.	双目运算符以先左后右的顺序保存到栈上，从栈顶端的两个元素开始计算，并将
结果保存到栈中。
比如：
1 + 2 * 3 - 4

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

6.2　什么是静态的 / 执行字节码的语言 1 7 1

图 6-1 分析树

这个表达式会展开成图 6-1 所示的分析树。
-

+

4

1

*

2

3

这个分析树以自上而下的顺序遍历，同时，常量的节点会生成字节码 push. 值，运算符节点生成代表运算符的字节码，生成的字节码如下所示。（下面的代 码只是用作说明的模拟代码。这些字节码既不是 Java 的，也不是 Diksam 的。）

1: push 1 2: push 2 3: push 3 4: mul 5: add 6: push 4 7: sub

# 将 [1] 入栈 # 将 [2] 入栈 # 将 [3] 入栈 # 将栈顶的两个元素进行乘法运算，并将结果入栈。 # 将栈顶的两个元素进行加法运算，并将结果入栈。 # 将 [4] 入栈 # 将栈顶的两个元素进行减法运算，并将结果入栈。

此时栈的动作如图 6-2 所示。

图 6-2 执行字节码时的栈动作

将这两个

在步骤 5 时将这

3

元素相乘

两个元素相加

2

2

6

1

1

1

1

1. 将 [1] 入栈 7

2. 将 [2] 入栈
4 7

3. 将 [3] 入栈
这两个元素进行 减法运算
3

4. 将栈顶的两个元素 进行乘法运算，并 将结果入栈。

5. 将栈顶的两个元素 进行加法运算，并 将结果入栈。

6. 将 [4] 入栈

7. 将栈顶的两个元素 进行减法运算，并 将结果入栈。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 7 2 第 6 章　制作静态类型的语言 Diksam

在表达式中不止有上例中的双目运算符，还有单目运算符，而且它们的思路

是一样的。比如单目运算符的减号，在栈中执行的操作是“将栈顶的值取出，反

转符号再存入栈中”。

但是，上述例子中只处理了整数。在实际的编程语言中还必须要处理实数，

也有可能会出现“整数和实数相加”这样的混合运算。在这种情况下，必须要将

* 有些语言使用 +，有些 使用 . 作为运算符。顺 便 说 一 下， 在 crowbar 和 Diksam 中 使 用 的 都 是 +。

参与运算的整数转换为实数再进行加法运算。在有些语言中，字符串和整数也 可以进行加法运算 *。接下来的操作就变成了将整数转换为字符串然后再将其 连接。.
在执行这样的操作时，有两种方法。 第一种是在向栈中保存值的时候就加入能够区分类型的标识，在运行时再进

行判断。crowbar 使用的就是这个方法。CRB_Value 结构体的成员 type 保存的

就是类型的标识，在运行时根据这个标识进行转型和运算。

另外一种方法是，在编译时进行类型判断。

如果有必要转型的话，类型转换处理将在编译时进行。那么，像图 6-3 这样

一个分析树就能够实现类型的转换了。

图 6-3 类型转换的分析树

实数间 相加

将整数转换 为实数

插入这个节点

2.5

3

这个分析树生成的字节码如下。

1: push_double 2.5

2: push_int

3

3: cast_int_to_double

4: add_double

第三行的 cast_int_to_double 命令将栈顶的 int 值转换为 double。 在这种方法中，如果是加法运算，究竟要如何区分是整数之间相加，还是实 数之间相加或者是字符串连接呢？在编译完成之后就完全清楚了。因此，在执行

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

6.2　什么是静态的 / 执行字节码的语言 1 7 3

时无需加入多余的判断，也可以加快执行速度。

但是这样一来，在编译时就必须要知道变量的类型，因此必须要让用户进行

* 静态类型的函数式语
言， 即 使 不 声 明 类 型，
编译器也可以根据类型
推论 推测出来。

带变量类型的 声明 *。
6.2.4 将控制结构转换为字节码

像 if 和 while 之类的控制结构，在字节码中使用 goto 这样的跳转（jump） 命令实现。
比如下面这段 if 语句。

if (a == 10) { 条件成立时的处理 条件成立时的处理
} 后续的处理

将这段代码用字节码来表示。

1: push 变量 a 的值

2: push_int

10

3: eq_int

# 栈顶的两个 int 之间进行比较（==），并将结果入栈

4: jump_if_false 7 # 栈顶的值如果是 false 就跳转到第 7 行

5: 条件成立时的处理

6: 条件成立时的处理

7: 后续的处理

# 从第 4 行跳转到本行

在 crowbar 中，控制结构也是用分析树来表现的。程序在执行的同时对分 析树进行递归，为了实现 break 和 continue 这样的语句，程序必须要从 递 归 的 最 深 层 开 始 （ 使 用 特 殊 的 返 回 值 ）。 在 执 行 字 节 码 的 语 言 中 可 以 更 简 单地实现 break 和 continue，（如果必要的话）goto 也可以简单地实现 （递归）。.

6.2.5 函数的实现
在 C 等语言中，通常情况下函数的调用也是用栈来实现的。 这种情况在拙著《征服 C 指针》中有详细的介绍，请各位读者参考。其 中大致说明了在 C 的情况下，（简单实现的话）函数的调用遵循以下步骤（如

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 7 4 第 6 章　制作静态类型的语言 Diksam

图 6-4 语言中的函数调用

图 6-4）。
1. 将参数（从后面开始）入栈 2. 将返回地址等返回信息入栈 3. 将局部变量所占内存区域入栈
调用函数 func(1,2,3) 增长方向

base

func() 中的运算 所使用的栈

局部变量 1 局部变量 2 局部变量 3 返回信息 （返回地址等）
1 2 3

参数
函数调用者 在运算时使 用的栈

C 语言的参数从后面开始入栈是为了实现像 printf() 这样可变长参数的函

数。这次制作的 Diksam 语言中没有可变长参数，因此没有必要特意从后面开始

（向栈内）保存参数（实际上 Diksam 是从前面开始保存参数的）。

所谓返回地址，和字面意思一样，指向了函数终结时返回的地址。当函数从

（栈的）某处开始调用之后，如果不将返回地址保存到栈中，在函数结束时就不

知道要返回到哪里去了。

当所有局部变量保存到栈中的时候，栈的顶部就在图中 base 箭头所指的位

* 另外，在机器语言中保 存着以 base 为起点的 偏移量引用地址的 寄存 器（  register）， 我 们 称 其为 基址寄存器（  寄存 器在机器语言中类似变 量 ）。 本 书 并 不 是 关 于 机器语言的书，因此以 后都用 base 来表示。

置。利用以 base 为基准的偏移量，可以指定局部变量或者参数 *。 在之前的 if 语句字节码的例子中，如果把中文“push 变量 a 的值”写成
字节码的话，应该像下面这样（当 a 是局部变量的情况下）。

push_stack_int

0 # 0 是变量 a 基于 base 的偏移量

在需要声明变量的语言中，全局变量也要在编译时全部决定下来，因此不能 为这些全局变量指定偏移量的编号。比如 int 型的全局变量的值向栈中保存的字

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

6.3　Diksam ver.0.1 的实现——编译篇 1 7 5

节码应该是下面这样。.

push_static_int

0 # 0 是这个全局变量的索引

6.3 Diksam ver.0.1 的实现——编译篇

6.3.1 目录结构
Diksam 为了使编译器与执行器（DVM）分离，使用了以下的目录（directory）结构。
●  compiler  包含 Diksam 的编译器代码。函数名等的前缀为 DKC，main() 函数暂时放在这里面。
●●  dvm  包含 Diksam 的执行器（DVM）代码。函数名等的前缀为 DVM。
●●  share  包含 compiler、dvm 两个模块共享的代码。函数名等的前缀为 dvm。 严格来说，这里打破了命名规则，这是因为考虑到是否要给只在编译器和 DVM 中使用的代码加一个公共的前缀，还有编译器也是依赖 DVM 的。
●●  include  包含在多个目录中被引用的头文件。
●●  memory  在介绍 crowbar 的时候，在 3.2.2 节中制作的内存管理的库。函数名等的前缀 为 MEM。
●●  debug  在介绍 crowbar 的时候，在 3.2.2 节中制作的用于调试的库。函数名等的前缀 为 DBG。
在表 6-2 中描述了 include 中包含的头文件。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 7 6 第 6 章　制作静态类型的语言 Diksam

表 6-2 头文件一览表

 头文件名  DKC.h DVM.h DVM_code.h
DVM_dev.h share.h DBG.h MEM.h

 说明  Diksam 编 译 器 库 的 公 用 头 文 件。 用 到 了 Diksam 编 译 器 的 用 户 程 序 需 要 #include Diksam 虚拟机的公用头文件。用到了 Diksam 执行器的用户程序需要 #include 由 Diksam 编译生成的字节码对象。定义了 DVM_Executable 结构体的头文 件。Diksam 编译器和 DVM 都会使用到这个文件 头文件中定义了用于 Diksam 的编译器生成字节码的结构体 DVM_Executable。Diksam 的编译器和 DVM 都会使用这个文件 编译器和 DVM 的共享模块 share.o 的公用头文件 用于调试的模块 DBG 的公用头文件 内存管理模块 MEM 的公用头文件

6.3.2 编译的概要
编译按照下面的顺序进行。
1. 构建分析树 在 create.c 中实现。
2. 修正分析树 在这个阶段中进行的操作有，为表达式分析树中的各节点加入类型，如果存在不同 类型间的运算时加入转换节点，将表达式中用到的变量与其声明绑定。 上述操作会尽量在构建分析树的同时完成，实在不行的话也会在其他阶段中进行。 此阶段（也就是所谓的“语义分析”阶段）会在 fix_tree.c 中执行。
3. 生成字节码 以自上而下的顺序遍历分析树生成字节码。在 generate.c 中实现。

6.3.3 构建分析树（create.c）
构建分析树其实跟 crowbar 相比没有什么变化。如果一定要说有什么不同的 地方，也只能讲讲“程序块”的处理了。
Diksam 局部变量的作用域在它声明的程序块中。 比如，表达式中使用了叫作 a 的变量时，编译器会首先探测最内层的程序块 中是否声明了 a，如果没有，再逐个探测外层的程序块。为了实现这种处理方式，

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

6.3　Diksam ver.0.1 的实现——编译篇 1 7 7

在程序块的结构体中包含了 outer_block 成员。.

typedef struct Block_tag {

BlockType

type;

struct Block_tag *outer_block; ←这个

StatementList

*statement_list;

DeclarationList

*declaration_list;

union {

StatementBlockInfo statement;

FunctionBlockInfo function;

} parent;

} Block;

outer_block 保存了外层程序块的指针。

为了设定 outer_block，在 Block 结构体创建实例的同时，必须要知道哪 个是当前程序块（新创建的程序块的外层程序块）。因此，在编译器本体（DKC_ Compiler）中保存了 current_block。

struct DKC_Compiler_tag {

MEM_Storage

compile_storage;

FunctionDefinition *function_list;

int

function_count;

DeclarationList

*declaration_list;

StatementList

*statement_list;

int

current_line_number;

Block

*current_block;

←这个

DKC_InputMode Encoding };

input_mode; source_encoding;

设 定 这 个 current_block 的 时 机 是 在 程 序 块 开 始 的 时 候（解 释 器 读 取 到 { 的时候）。
比如在 crowbar 中 crowbar.y 有如下代码。

block

: LC statement_list RC {
$$ = crb_create_block($2); } | LC RC {
$$ = crb_create_block(NULL); } ;

这个方法在程序块结束的时候没有任何动作。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 7 8 第 6 章　制作静态类型的语言 Diksam

为了能够设置 current_block，我们要在 diksam.y 里的规则中插入 动作。

/* 总之还是想要实现 "LC statement_list RC" */ block
: LC {
$$ = dkc_open_block(); }
statement_list RC {
$$ = dkc_close_block($<block>2, $3); } 还是有 "LC RC" 的规则，这里省略了。
这样的动作被称为 嵌入动作 。
yacc 在处理嵌入动作的时候，会嵌入一个虚拟的目标。嵌入动作将被作为这
个虚拟目标的动作进行处理。即为：.

block

: LC { 嵌入动作 } statement_list RC {
程序块结束时触发的动作。 } ;

上面这段代码，等同于下面的代码。

block : LC dummy_target statement_list RC { 程序块结束时触发的动作。 } ;
dummy_target : { 嵌入动作 } ;
虚拟目标部分并没有声明类型，（如果想要使用的话）嵌入动作中向 $$ 设定
的值，记作 $< 类型 > 序号。前面写到的 diksam.y 中向 dkc_close_block() 传
递 的 参 数 $<block>2, $3， 其 中 $<block>2 就 是 嵌 入 动 作 中 向 $$ 设 定 的

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

6.3　Diksam ver.0.1 的实现——编译篇 1 7 9

值，statement_list 就变成 $3 了（由于加入了嵌入动作，向后移动了一个 A）。

6.3.4 修正分析树（ﬁx_tree.c）

在 fix_tree.c 中将会扫描 create.c 生成的分析树，并进行错误检查、添加数据 类型、将表达式中的标识符与声明绑定这些操作。
下面的项目将要说明的是这些操作的具体内容。

■■  常量表达式的包装  这个操作在 crowbar 中已经存在了，Diksam 表达式中的常量表达式（像 24
* 60 这样的表达式）在编译时就会被包装为常量。 在现在的 Diksam 中，以数值的加减乘除和模、+ 进行的字符串连接、单目
减号、比较、单目！为对象。

■■  为表达式添加类型  在 Diksam 表达式的分析树中，每个节点都保存着自己的类型。在 Diksam 编
译器中定义了用来表示表达式的结构体（见下面代码，diksamc.h）。.

struct Expression_tag { TypeSpecifier *type; ←这里保存类型

ExpressionKind kind; ←用 kind 表示表达式的类别

int line_number; union {

←以联合体的形式保存类别对应的值

DVM_Boolean int double DVM_Char IdentifierExpression CommaExpression AssignExpression BinaryExpression Expression Expression FunctionCallExpression IncrementOrDecrement CastExpression

boolean_value; int_value; double_value; *string_value; identifier; comma; assign_expression; binary_expression; *minus_expression; *logical_not; function_call_expression; int_dec; cast;

A　原来是 $2。——译者注

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 8 0 第 6 章　制作静态类型的语言 Diksam

} u; };
比如 3 这样的整数值节点被定为 int 型，int 型变量的类型也被定为 int. 型，但是像 (1 + 0.5) 这样的表达式就要同时分析表达式左边和右边的情况来 适当地扩展类型。
看了 Expression 结构体的定义可能就会明白，这个结构体的 type 成员保 存了表达式的类型，它所指向的结构体 TypeSpecifier 的定义如下（定义在 / include/DVM/DVM_code.h 中）。
struct TypeSpecifier_tag { DVM_BasicType basic_type; TypeDerive *derive;
};
. 枚举类型 DVM_BasicType 的定义如下所示。 这个枚举类型能够表示所有“基本类型”。
typedef enum { DVM_BOOLEAN_TYPE, DVM_INT_TYPE, DVM_DOUBLE_TYPE, DVM_STRING_TYPE
} DVM_BasicType;
另外一个成员 derive 以“派生类型”的方式表示，相关的定义如下（类型 定义保存在 diksamc.h 中，但是在 DVM_code.h 中也有与其相似的定义，两者之 间的关系将在后面的章节中介绍）。
typedef enum { FUNCTION_DERIVE
} DeriveTag;

typedef struct { ParameterList
} FunctionDerive;

*parameter_list;

typedef struct TypeDerive_tag { DeriveTag tag; union { FunctionDerive function_d; } u; struct TypeDerive_tag *next;
} TypeDerive;

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

6.3　Diksam ver.0.1 的实现——编译篇 1 8 1

struct TypeSpecifier_tag { DVM_BasicType basic_type; TypeDerive *derive;
};

枚举类型 DeriveTag 是一种派生类型的表现。在现在的 Diksam 中还没有

数组之类的类型，目前存在的派生类型只有函数类型（FUNCTION_DERIVE）。

函数（派生类型）的定义保存在 FunctionDerive 中，具体来说就是参数的类

型信息。

到底什么是派生类型？这个话题在《征服 C 指针》中已经举例做了大致地说

* 在《 征服数组和指针》 一书中也做了介绍，可 以访问下面的网址阅读。 http://avnpc.com/ pages/devlang#pointer
* 在 C 语言的情况下，函 数名在表达式中会被转 换为“指向函数的指针”， 但是在 Diksam 中没有做 这种费力不讨好的事。

明 *。比如 Diksam 的 print() 函数，它的定义就成了下面这样。
int print(string str);
此时，被称为 print 的标识符的类型就是“返回 int 的函数（参数为 string 类 型）”*。在应用了函数调用运算符 () 后，可以把“函数（参数为 string 类型）”这 部分看作是 int 型。.
因为 TypeDerive 包含了成员 next，所以这个派生类型可以用链表形式链 接。因此，可以表示为“返回‘返回 int 的函数（参数为 string 类型）’的函

* 但是，现在还没有这样 的语法结构支持这种类 型的声明，所以无法使 用。Diksam 最 终 会 引 入 delegate 类型，但 与函数的派生无关。

数（无参数）”*。如果把数组也看作是派生类型的一种，那么可以表示为“返回 ‘int 的数组的数组’的函数（参数为 string 类型）”。
说起来，现在还不能声明“函数型的变量”，也没有数组。因此，现阶段函 数调用的语法规则如果像下面这样定义的话，就没有必要表现为派生类型了。但

是因为在下一个版本中考虑到要引入数组，所以进行了如下实现。

primary_expression : IDENTIFIER LP parameter_list RP ;
. ■■ 增加转换节点 
在为表达式添加类型的过程中，会加入如 6.2.3 节中说明的转换节点。当前
编译时默认执行的类型转换如下所示。

●  双 目运算中的类型转换  int 和 double 在运算时会将 int 转换为 double。 还有，左边是 string 类型的运算时，会把右边转换为 string。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 8 2 第 6 章　制作静态类型的语言 Diksam

●●  赋 值时的类型转换  赋值时，会根据左边调整右边的类型（+= 之类的赋值运算符也是一样）。 对于函数的实际参数以及参数的返回值在赋值时也进行同样的转换处理。

■■函数内的变量声明  在处理 int a; 这样的声明语句时，在 create.c 的阶段会创建 Declaration 结
构体，其定义如下。

typedef struct { char TypeSpecifier Expression int DVM_Boolean
} Declaration;

*name; *type; *initializer; variable_index; is_local;

在 create.c 的阶段，Declaration 结构体中设置了变量名（name）、类型 （type）以及构造函数（initializer）。
由 于 声 明 是 语 句 的 一 种， 在 Declaration 结 构 体 中 以 成 员 方 式 保 存 着 Statement 结构体的联合体，但是在 fix_tree.c 中就另当别论了。fix_tree.c 中 将 Declaration 结构体链接成了一个链表。

/* 将 Declaration 结构体连成链表的结构体 */ typedef struct DeclarationList_tag {
Declaration *declaration; struct DeclarationList_tag *next; } DeclarationList;

在函数以外的变量声明通过链表 DeclarationList 保存在 DKC_Compiler 中。 与此相对，在函数内声明的变量的作用范围是程序块，因此 DeclarationList 保 存在程序块（即 Block）中。
在 6.3.3 节 中 讲 过， 表 示 程 序 块 的 Block 结 构 体 的 声 明， 在 其 中 的 declaration_list 中保存了当前程序块中的声明。
函数的形式参数由于可以被当做函数内的局部变量来使用，因此这些变量的 声明被设置在了函数最外层的程序块中。接下来要加入的是局部变量。
与 此 同 时， 将 对 Declaration 结 构 体 中 还 没 有 设 置 的 variable_ index 和 is_local 进行设置。  is_local 用来表示是否有局部变量的标识，在函数内声明变量的同时设置

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

6.3　Diksam ver.0.1 的实现——编译篇 1 8 3

 图 6-5 Diksam 的栈

其值，variable_index 为函数内声明的局部变量分配编号（最初的形式参数 为 0）。
局部变量（包括参数）在栈中被创建，栈中的变量可以使用基于 base 的偏 移量进行引用，具体请见 6.2.5 节。variable_index 就是这个“偏移量”，但 是这里稍微有点复杂。
接下来我们看一下 Diksam 的栈，它实现了 DVM_Value 类型的数组，并且 这个数组可以继续增大下标进行扩展。Diksam 此时的状态如图 6-5。

调用 func(1,2,3) variable_index 的值

base
运行时的偏 移量从这里 开始偏移

[0]

1

[1]

2

[2]

3

返回信息 （返回地址等）

[3] 局部变量 1 [4] 局部变量 2 [5] 局部变量 3

函数调用者 运算时使用 的栈
参数

func() 中的运算 所使用的栈

增长方向
在现阶段的编译器实现中，variable_index 从第一个形式参数开始顺序 增长，其中并没有将返回信息考虑进去。因此，variable_index 和运行时的 偏移量只能直接偏移到返回信息下面的局部变量。
当然，因为已知返回信息的字节大小，所以对于局部变量来说，加上它的大 小后继续编号并非难事。但是，返回信息的字节大小依赖于 DVM 的实现，因此 我想尽力避免将依赖于返回信息的值嵌入到字节码中。
最重要的是，现在的字节码只生成在内存中，并没有以文件等形式保存起 来，因此即使嵌入了（返回信息的值），实际上也没有什么坏处。但如果将来要 生成与 Java 的 class 文件类似的产出物时，可能就会出现问题。随着 DVM 版本 升级，返回信息的字节大小也会随之发生变化，会出现之前编译的文件在新版

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 8 4 第 6 章　制作静态类型的语言 Diksam

DVM 中不能运行的困扰。 于是，Diksam 编译器姑且先生成连续的编号，在执行前（加载 DVM 之后）
再进行转换（请参考 6.4.1 节的小标题 3）。 话说回来，因为 Diksam 中变量的作用域是程序块，因此在下面这段代码
生成字节码的时候，a 和 b 如果分配的是同一个内存空间（同一个 variable_ index）的话，就可以节约栈空间了，因此在 Diksam 中的这种情况下会为它们单 独生成索引。
if (a == 10) { int a; …
}else { double b; …
}
Diksam 会为没有初始化的局部变量决定取值，不会出现像 C 那样的不定值。 在调用函数的时候，处理器会用 0 或者 null 之类的值为变量初始化。此时，虽 然 a 和 b 都处于同一内存空间，但是由于类型不同，因此它们不能够用同样的位 模型进行初始化。.

■■标识符和声明的绑定  在表达式中保存变量或者函数名的，是保存在 Expression 结构体中的联
合体成员 IdentifierExpression 结构体。

typedef struct {

char

*name;

DVM_Boolean is_function;

union {

FunctionDefinition *function;

Declaration

*declaration;

} u;

} IdentifierExpression;

这里的 function 或者 declaration 中存放的是函数定义或者变量声明。 在搜索局部变量的时候，会在与“当前程序块”相互连接的 Declaration 结 构体中搜索，因此，ifx_xxx 系列的函数会把当前程序块作为参数传递进来。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

6.3　Diksam ver.0.1 的实现——编译篇 1 8 5

6.3.5 Diksam 的运行形式——DVM_Executable

虽然总算能通过 fix_tree.c 生成字节码了，但是对于程序的运行来说不只需要 字节码，还需要全局变量列表等必不可少的信息。在 Diksam 中定义了名为 DVM_ Executable 的结构体用来保存字节码和刚才提到的那些相关信息，generate.c 的全部使命就是创建 DVM_Executable 结构体。
因 此， 首 先 要 用 下 面 这 段 代 码 来 说 明 一 下 DVM_Executable 结 构 体 （DVM_code.h）。

struct DVM_Executable_tag {

int

constant_pool_count;

DVM_ConstantPool *constant_pool;

int

global_variable_count;

DVM_Variable

*global_variable;

int

function_count;

DVM_Function

*function;

int

code_size;

DVM_Byte

*code;

int

line_number_size;

DVM_LineNumber

*line_number;

int

need_stack_size;

};

. 如代码所示，利用可变长数组保存以下信息。

1. 常量池（ constant_pool ） 保存常量的内存空间。

2. 全局变量（ global_variable ） 保存全局变量列表。

3. 函数（ function ） 保存函数定义。将函数里要执行的语句的字节码保存在其内部（DVM_Function 结 构体）。

4. 顶层结构的代码（ code ） 因为 Diksam 可以在顶层结构中书写代码，此成员用来保存这些代码生成的字节码。

5. 行号对应表（ line_number ） 保存字节码和与之对应的源代码的行号。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 8 6 第 6 章　制作静态类型的语言 Diksam
6. 栈的需要量（ need_stack_size ） 保存顶层结构的代码对栈的需要量。 每个函数对栈的需要量都保存在各自的 DVM_Function 中。
6.3.6 常量池
保存常量的内存空间被称为“常量池”。 比如，将 double 值 2.5 入栈的时候，Diksam 的字节码表示为：
push_double 2.5
在实际输出字节码的时候，命令 push_double 应该会被分配到某个代号 （编号）。在 DVM 中会分配到十进制的 6，因此，6 被作为一个字节输出到字节码
中。那么 2.5 该怎么办呢？在我的环境中 double 占 8 个字节，因此在 6 后面应 该紧接着输出这 8 个字节。
老 实 说， 因 为 现 在 的 Diksam 只 在 内 存 中 保 存 字 节 码， 编 译 器 环 境 中 double 型的字节表现可以直接输出到字节码中。但是，如果将字节码输出到 文件的时候就会出问题了。这是因为执行字节码的机器和编译字节码的机器可能 会用不同的形式表示 double 型数据 A。.
“字节码中以某种正规化的表现方式进行保存，读取的时候再进行转换。”在 进行这个处理的时候，如果字节码中间突然出来一个要转换的 2.5，那么处理起 来会很麻烦。另外，不止是实数，字符串也是一样，如果在字节码中突然出现了 一个嵌入的“hello,.world\n”，这在普通的程序员看来也没那么美观吧。
因此我们在这里使用了常量池。常量池数组中的各个元素组成了下面的结 构体。
typedef enum { DVM_CONSTANT_INT, DVM_CONSTANT_DOUBLE, DVM_CONSTANT_STRING
} DVM_ConstantPoolTag;
typedef struct { DVM_ConstantPoolTag tag; union {
A　从而导致解释字节码的方式也不同。——译者注
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

6.3　Diksam ver.0.1 的实现——编译篇 1 8 7

int

c_int;

double c_double;

DVM_Char *c_string;

} u;

} DVM_ConstantPool;

如上面代码所示，把保存 int、double 或者字符串的成员定义为一个联合体。 在 Diksam 的字节码中，下列常量不会被嵌入到其中，而是保存到常量池。 字节码中只保存常量池中对应的索引值。

●● 负数或者 65536 以上的整数 ●● 0 或者 1 以外的实数 ●● 字符串

1~2 字节的整数以及实数 0 或者 1 使用下列命令进行处理。
● push_int_1byte 在字节码上用这个命令将其后的 1 个字节作为整数保存。
●● push_int_2byte 在字节码上用这个命令将其后的两个字节作为整数并以大尾序保存。
●● push_double_0 实数运算中出现 0 的时候使用此命令（这里效仿了 JVM）。
●● push_double_1 实数运算中出现 1 的时候使用此命令（这里也效仿了 JVM）。

前面提到过字节码中只保存着常量池中用来引用常量的索引值，因为 1 个 字节存不下这个索引值，所以现在 Diksam 在实现时使用了两个字节，如果使 用 push_double 这样的命令会将其后的两个字节的整数值以大尾序保存起 来。可是，两个字节是否就够用了呢？这是最大的悬念。实际上这里也是在效仿 JVM，我想可能修正一下这里会更好。
另外，相同的常量在程序中多次出现的时候，虽然在常量池上分配同样的入 口可以节约常量池的内存空间，但是现在的 Diksam 没有这么做。这里照例只是 偷了个懒而已。

  补充知识    YARV 的情况 
Diksam 将一部分常量的值保存到了常量池中。这个结构体实际上是效仿 JVM，但 是在 Ruby 的 VM，也就是 YARV（Yet Another Ruby VM）中，就把常量值嵌入到了字

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 8 8 第 6 章　制作静态类型的语言 Diksam

* Java 当初的使用方法被
假设为是从网络下载的
小应用程序，因此字节
码是个必然的选择。

节码中。 这么做的理由是，像常量池这样把常量值保存在其他地方并通过配置索引指定操作
数的方法，可能会对性能产生不利的影响 [6（] 因为是间接访问）。 还有，在 YARV 中的指令不止 1 字节，在处理器中为其分配了 1 个 int 的大小
（这意味着 YARV 的指令不是一个严格的“字节码”）。虽然可惜了这些内存，但是对速 度还是非常有利的。
Diksam 如果真的考虑性能的话，也许应该向 YARV 学习一下 *。
6.3.7 全局变量

 DVM_Executable 结 构 体 的 global_variable 成 员， 就 如 同 其 字 面 的 含义表示的是全局变量。从字节码引用全局变量的时候，就会使用到这个 DVM_ Variable 型的数组的索引。
比 如， 将 整 数 型 的 全 局 变 量 的 值 push 到 栈 中 的 命 令 是 push_static_ int。
使用上述命令，将其后的两个字节以大尾序存入数组中并延续索引编号。  DVM_Variable 的定义如下。

typedef struct { char DVM_TypeSpecifier
} DVM_Variable;

*name; *type;

一目了然，这里表示的是全局变量的名称和类型。 全局变量的类型是为了在开始运行的时候进行初始化以及垃圾回收时使 用的。 变量名到目前为止还没有用到。前面也提到过，利用索引从字节码中引用全 局变量。但是我想，在实现调试器的时候，变量名是一个必要的信息。 另外，使用 DVM_TypeSpecifier 结构体来保存全局变量的类型。在编 译时类型信息被保存到类型信息 TypeSpecifier 结构 体中。也就是说，在 generate.c 中实现从 TypeSpecifier 结构体到 DVM_TypeSpecifier 结构体的 复制。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

6.3　Diksam ver.0.1 的实现——编译篇 1 8 9

6.3.8 函数

表示函数的结构体 DVM_Function，其定义如下所示。

typedef struct { DVM_TypeSpecifier char int DVM_LocalVariable DVM_Boolean int DVM_LocalVariable int DVM_Byte int DVM_LineNumber int
} DVM_Function;

*type; *name; parameter_count; *parameter; is_implemented; local_variable_count; *local_variable; code_size; *code; line_number_size; *line_number; need_stack_size;

 type 是返回值的类型，.name 是函数名。parameter 和 local_variable 用 下面给出的结构体保存名称和类型。类型是在初始化局部变量时使用的，但是现 在还没有用到。

typedef struct { char DVM_TypeSpecifier
} DVM_LocalVariable;

*name; *type;

在 DVM_Function 中的 is_implemented 是一个标志。它表示“这个函 数是否在这个 DVM_Executable 中实现”。
比 如 print() 函 数 由 原 生 函 数 组 成， 使 用 者 编 写 的 Diksam 程 序 中 并 没 有 对 其 进 行 过 定 义， 因 此， 这 个 函 数 对 应 的 DVM_Function 的 is_ implemented 为 false。即使是这样的函数也要被登记到 DVM_Function 的对 应表中，因为在函数调用的时候必须要通过 DVM_Function 对应表中的索引值。  DVM_Function 结构体的成员，指针 code 指向该函数对应的字节码。.

6.3.9 顶层结构的字节码
 DVM_Executable 结构体的成员，指针 code 指向顶层结构对应的字节码。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 9 0 第 6 章　制作静态类型的语言 Diksam
关于如何生成字节码将在 6.3.12 节中作介绍。.
6.3.10 行号对应表
对于执行字节码的语言来说，发生错误时，如果不能提示发生的错误在源 文件中的行号，对于使用者来说就太不友好了。因此，DVM_Executable 的成 员 line_number 保存了字节码上的位置对应的源文件的行号。
这种对应关系的类型用 DVM_LineNumber 结构体表示，定义如下。.
typedef struct { int line_number;/* 源代码的行号 */ int start_pc;/* 字节码的开始位置 */ int pc_count;/* 从 start_pc 开始，接下来有几个字节的指令对应着同一 line_number */
} DVM_LineNumber;
上述信息，在 generate.c 的 generate_code() 函数中与字节码同时生成。 因为 1 行源代码通常会生成多个指令，所以在为同一行源代码生成编码时，不增 加 DVM_LineNumber 对应表的元素，只增加 pc_count。
这里只保存了顶层结构的行号对应表，函数内的行号保存在各自的 DVM_ Function 对应表中。
6.3.11 栈的需要量
在 crowbar 中，在每次进行入栈操作时，都会检查栈的空间。只要空间不足 就会用 realloc() 进行扩展。
但是，Diksam 是执行字节码的语言，因此我们对它的执行速度还是有所期待 的，所以我们在这里要避免“每次都进行栈空间检查”的做法。
因此，在 DVM_Executable 的成员 need_stack_size 中保存了顶层结构 所需的栈空间大小。各函数需要的栈空间大小保存在 DVM_Function 对应表中。
这里的重点是：不论是顶层结构还是函数，它们所需要的栈空间大小都是在 编译时决定的。
虽然在前面已经提到过，但是在这里还要再说一下，DVM 将完全信任编译 器生成的字节码。另外，Diksam 的编译器绝对不会生成下例这样的字节码。.
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

6.3　Diksam ver.0.1 的实现——编译篇 1 9 1
10 push_int_1byte 5 12 jump 10
在这个例子中，会无限循环地将 5 入栈，直到内存溢出。但是，Diksam 从语 法上就杜绝了编写这种（能生成类似于上述例子中字节码的）源代码的可能。因 此，扫描全部 push 系列的指令，并计算出 push 所需内存总量，用此方法就可以 计算出顶层结构或者各函数所需的栈空间的大小了（在现在的实现中，并没有把 出栈的内存计算在内，因此这个值会略大一些，但是多一些的空间并不会造成问 题，所以就保持现状了）。各个指令消耗的栈空间量将会保存在 dvm_opcode_ info 数组中（请参考 6.3.12 节）。
基于上述做法，检查栈大小有以下两个最佳时机。. ●● 程序开始执行时，检查栈空间是否能满足顶层结构的需要。 ●● 函数开始执行时，检查栈空间是否能满足这个函数的需要。在出现深层递归需要消
耗大量栈空间的情况下，会数度进行检查，对栈空间的需求也会迅速地增长。
6.3.12 生成字节码（generate.c）
对于生成字节码来说，大部分麻烦事已经在 fix_tree.c 中做完了，因此 generate.c 要做的事情，大概就只剩下“按照自上而下的顺序遍历分析树然后吐出字节 码”了。
下面我们就来看一下到底要“吐出”的是什么样的字节码。 ■■ 字节码的结构 
在这个小节我将整理出至此为止一直没有明确的字节码的结构。 字节码由 命令（   指令，instruction）和 操作数（   operand）.组成。 操作数可以想成是 C 等语言中函数的参数。比如在例子 push_int 10 中. push_int 指令处理了一个操作数，这个指令的操作数是常量池中的索引值，这 个值是 10。 Diksam 的字节码以字节为单位（否则就不能叫“字节码”了）。指令也用一 个字节来表示。 还是以上面的例子来说，push_int 对应的值是 3。这里用枚举类型 DVM_ Opcode 来表示（DVM_code.h）。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 9 2 第 6 章　制作静态类型的语言 Diksam

typedef enum {

DVM_PUSH_INT_1BYTE = 1,

DVM_PUSH_INT_2BYTE,

DVM_PUSH_INT,

←这个是 push_int（也就是 3）

DVM_PUSH_DOUBLE_0, DVM_PUSH_DOUBLE_1, DVM_PUSH_DOUBLE, DVM_PUSH_STRING （中间省略） } DVM_Opcode;

操作数有以下三种。

●● 1 个字节的整数。直接保存跟在指令后面的操作数。 ●● 两个字节的整数。把跟在指令后面的操作数作为大尾序保存。 ●● 常量池的索引值。该值现在是两个字节，把跟在指令后面的索引值作为大尾序保存。

什么样的命令处理什么样的操作数都定义在了 /share/opcode.c 中。
OpcodeInfo dvm_opcode_info[] = { {"dummy", "", 0}, {"push_int_1byte", "b", 1}, {"push_int_2byte", "s", 1}, {"push_int", "p", 1}, {"push_double_0", "", 1}, {"push_double_1", "", 1}, {"push_double", "p", 1}, {"push_string", "p", 1},
（以下省略）
这个数组用于调试时反编译功能（disassemble.c）之外的必须顺序分析字节 码的情况。
这里的 b 代表 1 个字节的整数，s 代表两个字节的整数，p 代表常量池的索 引值。在表示字符串的时候，必须要使用取得多个操作数的指令。接下来的 0 和 1 的数值就是它们指令本身所需的栈空间。请参考 6.3.11 节。

■■ 生成字节码  为了生成字节码，在 generate.c 中包含了以下函数。
static void generate_code(OpcodeBuf *ob, int line_number, DVM_Opcode code, ...)
这个函数在获取指令和行号的同时，采用可变长参数来传递操作数。使用的 例子如下。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

6.3　Diksam ver.0.1 的实现——编译篇 1 9 3

/* 生成 push_int 的代码。 * cp_idx 是常量池的索引值。 */ generate_code(ob, expr->line_number, DVM_PUSH_INT, cp_idx);

6.3.13 生成实际的编码

本节将要介绍 Diksam 源代码的组成元素实际会转换成什么样的字节码。.

■■ 标识符  标识符有以下几种。
●● 局部变量 ●● 全局变量 ●● 函数

局部变量（是左值的情况下）将会生成如表 6-3 的字节码。操作数全部用两 个字节的整数、栈上的索引值（基于 base 的偏移量）表示。

表 6-3 局部变量相关的指令 

 指令  push_stack_int push_stack_double push_stack_string

 含义  将 int 类型的局部变量值保存到栈中 将 double 类型的局部变量值保存到栈中 将 string 类型的局部变量值保存到栈中

这三个指令只是针对不同的类型，但做的事情都一样。在枚举类型 DVM_ Opcode 中，指令以 int、double、string 的顺序排列，因此生成字节码的操作 可以用如下的方式进行。

* 实际上在现在的实现 中，局部变量保存在栈 中， 栈 的 实 体 是 DVM_ Value 联 合 体 的 数 组， 因此这种指令本身没有 必要根据类型区别使 用。但是，考虑到要以 字节为单位计算局部变 量的地址，为了在实现 上 节 省 内 存 空 间， 在 Diksam 中 还 是 分 开 变 成了多个指令。

/* push_stack_int */ generate_code(ob, expr->line_number,
DVM_PUSH_STACK_INT + get_opcode_type_offset(expr->u.identifier
.u.declaration ->type->basic_type), expr->u.identifier.u.declaration->variable_index);
 get_opcode_type_offset() 函数，如果参数是 boolean 或者 int 则
返回 0。如果是 double 则返回 1，string 则返回 2*。 当 参 数 是 boolean 的 时 候 也 返 回 0， 这 是 因 为 虽 然 在 Diksam 语 言 中
有 boolean 类型，但是 DVM 中并没有 boolean 类型，所以用 int 代替。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 9 4 第 6 章　制作静态类型的语言 Diksam

在全局变量中使用 push_( 类型名 )_static 指令代替 push_( 类型名 )_ stack 指令。操作数是全局变量的索引值。
在函数的情况下，根据 push_function 的索引（DVM_Function 数组的 下标）入栈，但是在执行时被改写成了别的方式。详细请参考 6.4.1 节。

表 6-4 双目运算符的指令

■■ 双目运算符 

双目运算符生成的指令如表 6-4 所示。表中 ( 类型 ) 的部分，请看作是 int、.

double 或者 string，但是 string 只有相加和比较的运算。

 运算符  + * / % == != < <= > >= && ||

 指令  add_( 类型 ) sub_( 类型 ) mul_( 类型 ) div_( 类型 ) mod_( 类型 ) eq_( 类型 ) ne_( 类型 ) gt_( 类型 ) ge_( 类型 ) lt_( 类型 ) le_( 类型 ) logical_and logical_or

 含义  加法运算 减法运算 乘法运算 除法运算 模运算 等值比较 不等值比较 小于 小于等于 大于 大于等于 逻辑 AND 逻辑 OR

这些指令没有操作数。

表 6-5 单目运算符的指令 

■■ 单目运算符 

单目运算符有单目的减号和逻辑非（!）。也可以把类型转换看作是一种单目 运算符（目前会由编译器自动插入）。
单目运算符的指令如表 6-5 所示。

 指令  minus_( 类型 ) logical_not cast_int_to_double cast_double_to_int cast_boolean_to_string cast_int_to_string cast_double_to_string

 含义  符号反转 逻辑 NOT 将 int 转换为 double 将 double 转换为 int 将 boolean 转换为 string 将 int 转换为 string 将 double 转换为 string

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

6.3　Diksam ver.0.1 的实现——编译篇 1 9 5

图 6-6 函数调用时的栈

■■ 赋值  现阶段的 Diksam 中还没有数组和对象的成员，因此赋值必然是以“ 变量名
= 表达式 ; ”的形式。 所以，我们首先计算右边，其结果值可以从栈中取得后，使用 pop_stack_
xxx 或者 pop_static_xxx 让变量出栈。 与 C 语言相同，Diksam 的赋值本身也是在获取表达式的值（因此也有可能
出现像 a = b = c; 这样的赋值方式）。也就是说，在赋值结束后，栈上肯定会 留下一个值。计算右边的值，在出栈赋给变量后栈上就没有值了，因此需要使 用 duplicate 指令复制栈顶的值并将其入栈。
但是，实际上很少有人会写 a = b = c; 这样的赋值语句（也可以说是因 人而异吧），大部分的情况没有必要特意使用 duplicate 复制栈上的值。
因此，生成赋值表达式的时候，要把“这个表达式是否是表达式语句的顶级 表达式”作为标识进行传递，如果（当前表达式）是表达式语句的顶级就不需要 使用 duplicate 了。

■■ 函数调用 

再看一下图 6-5 中的例子，Diksam 中函数调用时，栈会像图 6-6 所示进行增长。 首先，按照从前向后的顺序对参数进行计算，并将其入栈（Diksam 中没有可 变长参数，因此没有必要像 C 语言一样从后面开始入栈）。

调用 func(1,2,3) variable_index 的值

base
运行时的偏 移量从这里 开始偏移

[0]

1

[1]

2

[2]

3

返回信息

（返回地址等）

[3] 局部变量 1 [4] 局部变量 2 [5] 局部变量 3

函数调用者 运算时使用 的栈
参数

func() 中的运算 所使用的栈

增长方向

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 9 6 第 6 章　制作静态类型的语言 Diksam

接着，将“函数”入栈（这个“函数”其实是 DVM_VirtualMachine 结 构体中 Function 的索引值。详细请参考 6.4.1 节）。正如前面写到的，Diksam 中 调 用 函 数 使 用 () 运 算 符， 函 数 名 本 身 就 是 一 个 表 达 式。 使 用 push_ function 将这个表达式的值入栈。
然后，执行 invoke，从而执行被调用的函数。invoke 将保存着 push_ function 的值从栈中移出，创建承载着返回信息的局部变量的内存空间，并让 开始函数执行其一系列动作。
详细请参考 6.4.3 节.。

■■ 控制结构  如 6.2.4 节中所述，像 if 语句这样的控制结构在字节码中是使用跳转命令来
实现的。 为 了 实 现 跳 转， 就 必 须 要 知 道 跳 转 目 标 的 地 址。 这 里 说 的“地 址 ” 是 指
在 DVM_Executable 中的每个函数，或者是保存在顶层结构中的字节码的数组 （DVM_Byte *code）的下标。
比如有下面这样一段代码。

int a; if (a == 0) {
a = 1; } else {
a = 5; }
编译后生成如下字节码。

0 push_static_int 0 # 将变量 a 的值入栈

3 push_int_1byte 0 # 将 0 入栈

5 eq_int

# 比较

6 jump_if_false 17 # 如果不相等则跳转到 17

9 push_int_1byte 1 # 为了赋值将 1 入栈

11 pop_static_int 0 # 将 1 出栈赋值给 a

14 jump 22

# 跳到 22（这段代码的末尾）

17 push_int_1byte 5 # 为了赋值将 5 入栈

19 pop_static_int 0 # 将 5 出栈赋值给 a

这段代码中，最左边的数字就是“地址”。为了迎合机器语言中的说法，某 些特定的地址使用“地址码 XX”的说法表示。
在上面的例子中，a 和 0 比较后，在地址码 6 的地方判断如果相等就跳转到地

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

6.4　Diksam 虚拟机 1 9 7

址码 17。但是问题在于，在地址码 6 的 jump_if_false 命令生成的时候，还 不知道要跳转的目标就是“地址码 17”。
因此，Diksam 的编译器采用了以下的方法。
1. 跳转命令等在必须使用地址的时候，使用get_label()函数取得一个“标签”。 这里取得的“标签”是指，标签对应表的下标。
2. 字节码生成的最初阶段，在要写入跳转目标地址的地方写入暂定的标签。 3.	确定下来标签要代替的位置的地址后，使用set_label()函数，将地址存入标签
对应表。 4.	字节码全部生成后，根据标签对应表，将写入暂定的标签的地方替换成真正的
地址。

6.4 Diksam 虚拟机

编译（生成字节码）完成以后，就要放到 Diksam 虚拟机（DVM ：Diksam. Virtual.Machine）中执行了。.
DVM 在实现上使用D VM_VirtualMachine 结构体来表示（dvm_pri.h）。.

struct DVM_VirtualMachine_tag {

Stack

stack;

Heap

heap;

Static

static_v;

int

pc;

Function *function;

int

function_count;

DVM_Executable *executable;

};

结构体的前三个成员保存了 DVM 运行时的记忆空间。如代码所示，DVM 具 有以下三个记忆空间。

1. 栈 前面已经说过，需要在栈上创建空间的有局部变量、函数的参数或函数返回
的返回信息等。  DVM_VirtualMachine 结构体的成员 stack，它的类型 Stack 如下所示。

typedef struct {

int

alloc_size;

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

1 9 8 第 6 章　制作静态类型的语言 Diksam

int

stack_pointer;

DVM_Value *stack;

DVM_Boolean *pointer_flags;

} Stack;

一目了然，栈的实体就是 DVM_Value 类型的数组。  DVM_Value 相 当 于 crowbar 中 的 CRB_Value， 是 一 个 能 够 保 存 所 有（在 Diksam 中可以使用的）类型的联合体（DVM.h）。

typedef union {

int

int_value;

double

double_value;

DVM_Object *object;

} DVM_Value;

 DVM_Value 与 CRB_Value 不同，不会根据类型打上不同标记。静态语言中 类型是可以被识别的，因此不再需要标记类型了。
但是，在垃圾回收的时候，仅依靠静态的信息判断栈上的值是否是指针还是 有些困难的，但也可以通过函数定义取得局部变量或者参数的类型。同样是保存 在栈上，计算过程中的值的类型却很难弄清楚。
因 此，Stack 结 构 体 的 pointer_flags 数 组 保 存 着 栈 上 的 值 是 否 是 指 针。pointer_flags 数组和 stack 的大小相同，可以使用同一个下标进行引用。  Stack 结构体的成员 stack_pointer 是 栈指示器（   stack.pointer），它保存 着栈顶的索引值。
栈指示器所指的是下次要入栈的元素的索引值。实际上已入栈元素的索引值 是一个小于栈指示器 -1 的值。

2. 堆 堆是一个通过引用进行访问的内存区域。现在的 Diksam 中并不存在类和对
象，因此现在的堆中只保存字符串。 和 crowbar 一样，堆上的对象以链表形式保存。.

/* 保存对象的结构体 */

struct DVM_Object_tag {

ObjectType type;

unsigned int

marked:1;

union {

DVM_String

string;

} u;

struct DVM_Object_tag *prev;

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

6.4　Diksam 虚拟机 1 9 9

struct DVM_Object_tag *next; };

/* 堆的结构体 */

typedef struct {

int

current_heap_size;

int

current_threshold;

DVM_Object *header;

} Heap;

3. 静态（static）空间  DVM_VirtualMachine 的 static_v 成 员 用 来 保 存 全 局 变 量（因 为 static 和 C 语言的关键字冲突，所以成员的名字用 static_v 表示）。  Static 结构体的定义如下。

typedef struct {

int

variable_count;

DVM_Value *variable;

} Static;

如代码所示，结构体中保存着 DVM_Value 的数组。 在使用 push_static_int 等指令引用全局变量时，作为操作数传递给指 令的就是这个数组的下标。 另外，在 DVM_VirtualMachine 内用于嵌入到字节码中的值只能来自同 一个数组的下标，也就是说，在现在的 Diksam 语言中，一个 DVM 只能对应一 个 DVM_Executable。 但是很明显，在 DVM_VirtualMachine 内不只保存了一个 DVM_Executable。为了解决这个问题，有必要在多个源文件链接并执行的时候进行纠正（请 参考 8.1.5 节）。  DVM_VirtualMachine 还有一个属性 pc 用来表示 程序计数器（   program. counter）。 程序计数器在字节码中起到保存当前正在执行的指令地址的作用（这里说的 “地址”是指保存着字节码的数组的下标）。 因此，在使用跳转命令时，只需要把程序计数器改写为要跳转的目标就可以 了。但是，实际上 DVM_VirtualMachine 结构体的成员 pc 在程序开始执行后 立刻就被复制到了局部变量，但在之后却并没有被回写回来，所以现在这个成员 派不上什么用场。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 0 0 第 6 章　制作静态类型的语言 Diksam

其余的两个成员 function 和 executable 将在后面的章节中进行介绍。

6.4.1 加载 / 链接 DVM_Executable 到 DVM

在程序执行前，首先必须要为 DVM_VirtualMachine 绑定 DVM_Executable， 用 方 法 DVM_add_executable() 来 完 成 这 项 工 作。 由 于 一 个 DVM_ VirtualMachine 只能对应一个 DVM_Executable，因此这个函数的名字有点 挂羊头卖狗肉的意思。
在 DVM_add_executable() 中会进行以下几个处理。.

1. 将函数添加到 DVM_VirtualMachine 中 在 这 里 我 要 重 申 一 下， 一 个 DVM_VirtualMachine 只 对 应 一 个 DVM_
Executable。但是，像 print() 这样的原生函数储存在了别的地方（即 DVM_ Executable 以外的地方），因此有必要将函数以某种方式进行链接。  DVM_VirtualMachine 结构体的 function 数组正是为此而存在的对 应表。
其类型 Function 的定义如下所示。
/* 将 Function 进行分类的标签 */ typedef enum {
NATIVE_FUNCTION, DIKSAM_FUNCTION } FunctionKind;

/* 保存 print() 之类的原生函数 */ typedef struct {
DVM_NativeFunctionProc *proc; int arg_count; } NativeFunction;

/* 引用在 Diksam 中定义的函数 */

typedef struct {

DVM_Executable *executable;

int

index;/* 上层 executable 内（译注：与本函数对应的）DVM_

Function 的下标 */

} DiksamFunction;

/* Function 结构体本身 */ typedef struct {

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

6.4　Diksam 虚拟机 2 0 1

char

*name;

FunctionKind kind;

union {

NativeFunction native_f;

DiksamFunction diksam_f;

} u;

} Function;

 DVM_Executable 中保存的函数在执行时使用对应表进行引用。 这个引用表中同样登记着像 print() 这样的原生函数，因此利用这个对应
表的索引，不论是 Diksam 中定义的函数还是原生函数，全部可以引用到。 在 字 节 码 中 调 用 函 数 的 时 候， 使 用 push_function 指 令 将 函 数 对 应
的索引值入栈， 这个被嵌入的值，就是在编译时 DVM_Executable 内 DVM_ Function 数组的下标。  DVM_Function 数 组 中 不 包 含 当 前 源 代 码 中 使 用 的 原 生 函 数， 因 此 Function 数组和索引值就会出现差异。下一步就是要修正这个问题。

2. 替换函数的索引 如前面所述，在编译阶段函数的索引对于当前 DVM_Executable 来说是局
部的，在执行时会被汇总到一个数组中，因此必须要将索引进行转换。 这个操作会直接替换字节码中的操作数。 但是，如果直接调整成与某个 DVM_VirtualMachine 匹配的字节码的话，
当一个 DVM_Executable 对应多个 DVM_VirtualMachine 时就会出现问题。 这个问题将在 9.3.4 节中修正。.

3. 修正局部变量的索引值 在进行上述操作的同时，也会修正局部变量的索引值。 如图 6-5 所示，引用局部变量时，索引与参数之间隔着返回信息。但是，编
译器并不知道返回信息的大小（其实是可以知道的，但是为了信息保密而使编译 器不能获取到返回信息的大小），因此在编译时，参数的索引会接着引用后面的 索引值。  DVM_add_executable() 中 会 使 用 push_stack_xxx 和 pop_stack_ xxx 指令对此进行修正。.

4. 将全局变量添加到 DVM_VirtualMachine 中 只 是 用 DVM_Executable 结 构 体 的 global_variable 数 组 的 个 数 创

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 0 2 第 6 章　制作静态类型的语言 Diksam

代码清单 6-2 execute()

建 DVM_VirtualMachine 结构体的 static_v.variable 数组，并初始化数 组的值。

6.4.2 执行——巨大的 switch case

接下来就要开始执行了。 DVM 是一个将编译器生成的字节码逐个执行的虚拟机。也就是说，只要循 环地执行一个与字节码的指令种类一样多的巨大 switch case 就可以了。 关于这个话题，可能直接看代码会更形象（代码清单 6-2）。

static DVM_Value

execute(DVM_VirtualMachine *dvm, Function *func,



DVM_Byte *code, int code_size)

{

 int

pc;

 int

base;

 DVM_Value

ret;

 DVM_Value

*stack;

 DVM_Executable *exe;

 stack = dvm->stack.stack;  exe = dvm->executable;

 for (pc = dvm->pc; pc < code_size; ) {



switch (code[pc]) {



case DVM_PUSH_INT_1BYTE:



STI_WRITE(dvm, 0, code[pc+1]);



dvm->stack.stack_pointer++;



pc += 2;



break;



case DVM_PUSH_INT_2BYTE:



STI_WRITE(dvm, 0, GET_2BYTE_INT(&code[pc+1]));



dvm->stack.stack_pointer++;



pc += 3;



break;



case DVM_PUSH_INT:



STI_WRITE(dvm, 0, 



exe->constant_pool|[GET_2BYTE_INT(&code[pc+1])].u.c_int);



dvm->stack.stack_pointer++;



pc += 3;



break;



case DVM_PUSH_DOUBLE_0:



STD_WRITE(dvm, 0, 0.0);

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

6.4　Diksam 虚拟机 2 0 3



dvm->stack.stack_pointer++;



pc++;



break;



case DVM_PUSH_DOUBLE_1:



STD_WRITE(dvm, 0, 1.0);



dvm->stack.stack_pointer++;



pc++;



break;



case DVM_PUSH_DOUBLE:



STD_WRITE(dvm, 0, 



exe->constant_pool|[GET_2BYTE_INT(&code[pc+1])].u.c_double);



dvm->stack.stack_pointer++;



pc += 3;



break;



case DVM_PUSH_STRING:



STO_WRITE(dvm, 0, 



dvm_literal_to_dvm_string_i(dvm,

exe->constant_pool



[GET_2BYTE_INT(&code[pc+1])]



.u.c_string));



dvm->stack.stack_pointer++;



pc += 3;



break;

  （ 之后省略）

现在这个函数（execute.c 的 execute() 函数）就已经有 400 多行了，并且 还会不断增加。如果有“一个函数必须少于 XX 行”等这样机械的编码规约的话， 那么在实际工程中程序员们肯定会违反这个规则。
但我觉得把一个函数分割开并没有让它变得更易读。即使是规定了“一个 函数必须少于 XX 行”这样机械的编码规约，也不能说编程本身是一项机械的 工作。
更重要的是，由于这个函数的内部引用了栈，因此用到了以下这些宏。

● STI(dvm, sp), STD(dvm, sp), STO(dvm, sp) 以当前栈指针加上 sp 为索引值，返回栈上对应元素值。主要用于四则运算等， 也用于双目 / 单目运算符操作栈顶附近的值。 STI 用于 int，STD 用于 double，STO 用于 string（对象）。下述三个方法同理。

●● STI_I(dvm, sp), STD_I(dvm, sp), STO_I(dvm, sp) 直接以 sp 为索引值，取得栈上对应元素值。使用了 push_stack_xxx、pop_ stack_xxx 系列的指令。 这些指令不是用来引用栈顶附近的值的，而是用来引用以 base 为起点的索引值

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 0 4 第 6 章　制作静态类型的语言 Diksam
对应的栈元素的。 ●● STI_WRITE(dvm, sp, r), STD_WRITE(dvm, sp, r), STO_WRITE(dvm, sp, r)
用与 STI() 等相同的方法来指定栈上的元素，并在对应元素的位置写入 r。因为 使用了 STI() 等宏命令，所以可以用 STI(dvm, 0) == xxx 的形式进行赋值。 但是，由于必须要根据类型是否为指针来设定栈的 pointer_flag，因此特意制 作了用来写入的宏。 ●● STI_WRITE_I(dvm, sp, r), STD_WRITE_I(dvm, sp, r), STO_ WRITE_I(dvm, sp, r) 直接以 sp 为索引值的 STx_WRITE()。
6.4.3 函数调用
作为程序的起始点，execute() 函数确实是一个巨大的函数，逐个地执行 每个指令绝对不是几行代码就能解决的。
这里将要说明的是一个稍微复杂一些的话题——函数调用。 函数调用按照以下的顺序执行。. 1. 将参数以从前向后的顺序入栈。 2. 使用push_function将函数的索引值入栈。 上述操作执行后，栈的状态如图 6-7 所示。.. 然后执行 invoke 指令。.. 3. 执行invoke，调用栈顶的函数。 如果被调用的函数是一个原生函数，那么上述操作就会实际地执行这个原生 函数。 Diksam 原生函数的调用形式如下（以 print() 为例）。
static DVM_Value nv_print_proc(DVM_VirtualMachine *dvm,
int arg_count, DVM_Value *args) {
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

6.4　Diksam 虚拟机 2 0 5

图 6-7 函数调用（1）

1 2 3 函数的索引值

函数调用 者运算时 使用的栈
参数

增长方向
这里把 DVM_Value 的数组作为参数传递给了 nv_print_proc 函数，但其 实，参数在栈上正好是按顺序排列的，因此这里也可以只传第一个参数的指针。
如果要调用 Diksam 的函数，要进行以下操作。
4. 将返回信息入栈。 5. 设置base的值。 6. 初始化局部变量。 7. 替换执行中的executable和函数。 8. 将程序计数器置为0并开始执行。

使用 CallInfo 结构体来表示之前一直在说的返回信息的实体。.

typedef struct {

Function *caller;

int

caller_address;

int

base;

} CallInfo;

 caller 指向当前函数的调用者（也是函数），caller_address 指向函数 内字节码上的地址。base 指向调用者的 base 值（引用参数或者局部变量的 起点）。
在 函 数 被 调 用 的 时 候， 因 为 栈 中 还 保 存 着 很 多 运 算 过 程 中 的 值， 所 以 如 果 CallInfo 中不保存 base 的话，函数结束后就无法返回了（因为不知道返回 到哪里）。
对于 CallInfo 结构体来说，首先要被覆盖设置调用函数的索引（由 push_ function 入栈的）。之后设置新 base，创建局部变量的内存区域。在被调用的函数 开始执行时，栈的状态如图 6-8 所示。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 0 6 第 6 章　制作静态类型的语言 Diksam

图 6-8 函数调用（2）
图 6-9 函数调用（3）

base

1 2 3 返回信息 （返回地址等） 局部变量 1 局部变量 2 局部变量 3
增长方向

函数调用 者运算时 使用的栈 参数
被调用的函数 在之后运算中 使用的栈

被调用的函数在达到这个状态后就可以开始执行了。

反过来，从函数中 return 的时候是怎样操作的呢？函数在最后结束之前要

先执行 return，因此函数在结束时必须在局部变量的下一个位置中保存返回值

（如图 6-9）。

将参数、CallInfo、局部变量全部移除后，将返回值移动到栈顶。这样做，

即使函数是在表达式的计算过程中被调用的，也可以让它正确地使用函数的返回

值（如图 6-10）。

1 2 3 返回信息 （返回地址等） 局部变量 1 局部变量 2 局部变量 3 返回值

函数调用 者运算时 使用的栈
参数

图 6-10 函数调用（4）

　......................................

返回值

函数调用 者运算时 使用的栈

增长方向

增长方向

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

第7章
为 Diksam 引入数组
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 0 8 第 7 章　为 Diksam 引入数组

7.1 Diksam 中数组的设计
由于 Diksam.book_ver.0.1 不能使用数组，因此让人感觉不太实用，所以在 book_ver.0.2 中我们将引入数组的概念。啊，这个开场白好像和 4.1 节的一样呢。

7.1.1 声明数组类型的变量

Diksam 中数组的设计与 Java 大致相同。 首先，在 Diksam 中变量必须要进行声明，当然数组类型的变量也不例外， 需要用 Java 的风格进行声明。
int[] a;// 声明 int 类型的数组
创建数组时的语法也和 Java 一样。
// 创建了一个可以访问到 a[2][4] 的数组 a = new int[3][5];
与 crowbar 和 Java 一样，Diksam 的数组也是引用类型。因此，下面的代码会 输出 a[1]..10。
int[] a = {1, 2, 3}; int[] b = a;// a 和 b 指向同一个数组

// 因此，改变 b[1] 的话 a[1] 也会跟着改变 b[1] = 10; print("a[1].." + a[1] + "\n");

因为数组 a 和数组 b 指向了同一个数组，所以输出这样的结果也是理所当然 的（如图 7-1）。

图 7-1

a

两个变量同时引用一个

Diksam 的数组

b

1 10 3

另外，（看上去是）多维数组实际上是数组的数组。 总之，在 a = new int[3][5]; 这段代码中，a 最后得到的是“int 数组 （3 个元素）的数组（5 个元素）”。关于数组元素的引用形式，如图 7-2 所示。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

图 7-2

a

Diksam 的多维数组

7.1　Diksam 中数组的设计 2 0 9
int 数组（3 个元素）

……的数组（5 个元素）
7.1.2 数组字面量
在 Java 中，数组类型变量只有在声明的同时进行初始化，才可以用如下 方式。
int[] a = {1, 2, 3};
其他情况下，数组字面量必须使用以下方式声明。
a = new int[]{1, 2, 3};
虽然知道在 Java（或 Diksam）这样的静态类型语言中必须明确地指定类型， 但是总觉得 new int[] 这部分太冗长了，另外对于初学者来说，初始化和其他 情况不同也容易造成混乱。更重要的是我（从语言实现者的角度出发）不支持一 种常量有两种声明方式。
因此在 Diksam 中，数组字面量的类型由“最初的元素的类型”决定（这里 模仿的是 D 语言）。
总 之， 下 面 这 段 代 码 中 第 2 个 和 第 3 个 元 素 会 被 转 换 成 double， 以 double 型数组 {1.0, 2.0, 3.0} 的形式赋值给 a。
double[] a = {1.0, 2, 3}
第 2 和 第 3 个 元 素 会 被 转 换 为 double， 被 赋 值 给 a 的 是 一 个 由 {1.0, 2.0, 3.0} 组成的 double 数组。
在 Diksam 中（与 Java 相同），还没有决定元素值的数组，写作 a = new int[5][3];，这段代码创建了一个访问范围是从 a[0][0] 到 a[4][2] 的数组。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 1 0 第 7 章　为 Diksam 引入数组
  补充知识    D 语言的数组 
D 语言是 Digital Mars 公司作为 C 语言的后继开发出来的编程语言。 在 D 语言中，如果想要创建一个访问范围从 a[0][0] 到 a[4][2] 的数组，就要写 成 int[3][5];。而且，并不是堆中而是作为静态或者局部变量时数组的声明语法。如 果要使用 new 进行动态分配时就要写成 new int[3][5] 了。 与 C 和 Java 一样，D 语言的数组下标也是从 0 开始，下标的上限和数组的大小相 差 1。这点虽然很好，但是可以访问到 a[4][2] 的数组声明方式却是 int[3][5];， 肯定有人会怀疑是不是把顺序搞错了。确实，在 C 语言中可以访问到 a[4][2] 的数组 声明方式是 int[5][3];，Java 在 new 数组的时候也是 int[5][3];。 但是，在 Java（或者是 Diksam）中，new int[5][3]; 得到的是 int 的数组（3 个元素）的数组（5 个元素）。Java（或者是 Diksam）的语法不可以从左边开始读，这 点在 D 语言中正好相反。 虽然是这样，但是 Java 语言比 D 语言使用范围更广泛，这部分的语法 C# 和 Java 也是相同的，更重要的是，已经习惯了这样（Java）的写法突然改变的话，会变得混乱 （我自己也会），因此在数组声明方式上，Diksam 是迎合了 Java 的做法。 虽然如此，D 语言是美国人开发出来的语言，在他们看来 D 语言这样的顺序可能 更自然一点。
7.2 修改编译器
7.2.1 数组的语法规则
这次增加的语法规则如下所示。 1. 扩展类型标识符（type_specifier）以声明数组类型的变量 2. 使用new创建数组的语法（array_creation） 3. 数组字面量（array_literal） 4. 使用下标运算符（如a[10]）引用数组元素的语法
第 1 点，原来的类型标识符是下面这样的。
type_specifier : BOOLEAN_T | INT_T
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

7.2　修改编译器 2 1 1

| DOUBLE_T | STRING_T ;
现 在， 像 boolean 或 者 int 这 样 的 基 本 类 型 都 将 被 作 为 basic_type_ specifier，如下所示。

type_specifier : basic_type_specifier | type_specifier LB RB ;

* 因为数组的下标是从 0
开始的，所以这里用一
般的计数方法取得的应
该是第 6 个元素。

 LB 和 RB 是 Left.Bracket 和 Right.Bracket 的简称，代表 [ 和 ]。  type_specifier 可以包含 [] 本身。这样一来不论加几个 [] 都可以（例 如 int[][][]）。
第 2 点，使用 new 创建数组的语法看上去好像挺麻烦的。 比如在 Java 中代码 new int[10] 会得到 int 数组（10 个元素）。 在此基础上如果加上下标 [5]，就变成了 new int[10][5]。这行代码会 取得 new int[10] 的第 5 个元素 * 是不可能的，这当然是创建二维数组的意思。 总之，下标运算符 [] 除了必须要适用于普通的表达式之外，还要适用基 于 new 的数组创建（array_creation）语法。 在 Diksam.book_ver.0.1 中组成表达式的最小元素是 primary_expression（运 算符优先顺序最高的块），因此“基于 new 创建数组”被当作“例外情况”来 处理。

primary_expression : primary_no_new_array /* 基于 new 创建数组之外的表达式 */ | array_creation /* 使用 new 创建数组的表达式 */ ;
引用数组元素的语法规则如下所示。下标运算符 [] 不被局限于使用 new 来
创建数组。

primary_no_new_array /* 可以使用 [] 的只有 primary_no_new_array */ : primary_no_new_array LB expression RB
（之后省略）

……这是一段多么了不起的代码啊。可这不是我写的，我只不过是照搬了 Java 的语法规则而已 [7]。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 1 2 第 7 章　为 Diksam 引入数组

7.2.2 TypeSpeciﬁer 结构体

在 Diksam 的编译器中，使用 TypeSpecifier 结构体保存数据类型。

关于 TypeSpecifier 结构体请参考 6.3.4 节。

要点在于，要使用保存基础类型（DVM_BasicType）的 TypeSpecifier.

结构体和链表连接起来的派生类型（TypeDerive）来表示所有数据类型。

这部分的代码如代码清单 7-1 所示。

代码清单 7-1 TypeSpecifier（Diksam book_ver.0.2 版）

typedef enum {  FUNCTION_DERIVE,  ARRAY_DERIVE } DeriveTag;

typedef struct {  ParameterList } FunctionDerive;

*parameter_list;

typedef struct {  int dummy; /* make compiler happy */ } ArrayDerive;

typedef struct TypeDerive_tag {

 DeriveTag tag;

 union {



FunctionDerive function_d;



ArrayDerive

array_d;

 } u;

 struct TypeDerive_tag *next;

} TypeDerive;

struct TypeSpecifier_tag {  DVM_BasicType basic_type;  TypeDerive *derive; };
之前的派生类型只有“函数类型”，这次增加了数组的派生（在 TypeDerive. 的 tag 中加入了 ARRAY_DERIVE）。
在 fix_tree.c 中，表达式的各个节点中也要附加对应地 TypeSpecifier 结 构体。比如，使用 int[][] a; 声明变量 a，在附加 TypeSpecifier 的时候， 首先给 basic_type 赋值为 DVM_INT_TYPE，在此基础上给进行了数组派生 的 TypeDerive 累加上两个链表。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

7.3　修改 DVM 2 1 3

于是，使用下标运算符进行引用（如 a[10]）的时候，移除 TypeDerive 链 表的第一个元素后剩下的就是表达式的类型了。同理，如果是 a[10][3] 的话， 把两个都移除后，表达式的类型就是 int 了（如图 7-3）。

 图 7-3 含有数组的分析树的 类型

[]

int

3

[]

int

数组

10

a

int

数组 数组

TypeSpecifier TypeDerive
在图 7-3 中，圆形中间带有 [] 的符号表示下标运算符 IndexExpression。 它是 Expression 结构体中的一种联合体，数组和下标的表达式保存在下面的 结构体中。
typedef struct { Expression *array; /* 数组的表达式 */ Expression *index; /* 下标的表达式 */
} IndexExpression;

7.3 修改 DVM

7.3.1 增加指令

* 请参考附录 C 中的范例
阅读本表。

由于这次引入了数组，因此在 DVM 中也要增加相应的指令，增加的指令如 表 7-1* 所示。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 1 4 第 7 章　为 Diksam 引入数组

表 7-1 随着引入数组增加的 指令

 指令 

 操作数类型 

push_array_int

push_array_double
push_array_object

pop_array_int

pop_array_double
pop_array_object

 含义 

 栈 

根据栈顶的数组和下标，取 得数组的元素（int 型）并 将其入栈

[ a r r a y i n t ] → [int]

根据栈顶的数组和下标，取 得数组的元素（double 型） 并将其入栈

[ a r r a y i n t ] → [double]

根据栈顶的数组和下标，取 得数组的元素（object 型） 并将其入栈

[ a r r a y i n t ] → [object]

将栈顶的值（int1）赋值给 与数组（array）下标 int2 对应的元素

[ i n t 1 a r r a y int2]→[]

将 栈 顶 的 值（double） 赋 值 给 与 数 组（array） 下 标 int 对应的元素

[ d o u b l e a r r a y int]→[]

将栈顶的值（object）赋值 给与数组（array）下标 int 对应的元素

[ o b j e c t a r r a y int]→[]

new_array

byte、 short

创建以操作数 byte 指定维 数，以 short 指定类型的数组， 在栈中创建指定大小的空间并 将数组入栈

[ s i z e1 s i z e2 ...]→[array]

new_array_litshort
eral_int

使用已经入栈的操作数作为 int 型元素（操作数用来指 定元素个数）创建数组并将 数组入栈

[int1 int2 int3 ...]→[array]

new_array_litshort
eral_double new_array_lit-
short eral_object

使用给定数量的已经入栈的 操作数作为 double 型元素 创建数组并将其入栈
使用给定数量的已经入栈的 操作数作为 object 型元素 创建数组并将其入栈

[ d o u b l e1 d o u b l e2 d o u b l e 3 ...]→[array]
[ o b j e c t 1 o b ject2 object3 ...]→[array]

在指令中出现了“object 型”的概念。它是在之前只包含了字符串的引用 类型的基础上又增加了数组，是由字符串和数组组成的类型。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

7.3　修改 DVM 2 1 5

代码清单 7-2 DVM_Executable （book_ver.0.2） 

随 着 上 述 改 变， 除 了 专 门 处 理 字 符 串 的 操 作（如 字 符 串 比 较 等 ）， 之 前 的 push_static_string 等指令都要重命名为 push_static_object 等了。
表 7-1 的指令中，我想必须要特别说明一下 new_array。 在表 7-1 中提到了“操作数 short 代表的类型”，这个操作数是指这次在 DVM_ Executable 中新增的 DVM_TypeSpecifier 数组的下标（代码清单 7-2）。

struct DVM_Executable_tag {

 int

constant_pool_count;

 DVM_ConstantPool *constant_pool;

 int

global_variable_count;

 DVM_Variable

*global_variable;

 int

function_count;

 DVM_Function int

*function; type_specifier_count; ←新增

DVM_TypeSpecifier *type_specifier;

←新增

int

code_size;

DVM_Byte

*code;

int

line_number_size;

DVM_LineNumber

*line_number;

int

need_stack_size;

};

 DVM_TypeSpecifier 结 构 体 在 book_ver.0.1 时 就 已 经 存 在 了， 它 和 TypeSpecifier 结构体保存着同样的信息。
例如，使用 new int[5][3] 创建一个数组，new_array 的操作数将被指 定为保存着 int[][] 类型信息的 DVM_TypeSpecifier 的下标。
这样一来，只要知道对应的 TypeSpecifier 就能够知道数组的维数，int[] [] 型的数组也可以像 new int[5][] 这样，在代码运行过程中再创建另外一 维。实际创建的维数（这里是 1）使用另外一个 byte 型操作数传递指令。另外， 使用代码 a = new int[5][]; 创建的数组和 Java 一样，a[0]~a[4] 被初始 化为 null。.

  补充知识    创建 Java 的数组字面量 
如表 7-1 所示，在 DVM 中，new_array_literal_int 等创建常量的指令，会 先将组成数组的值入栈，再利用已经在栈上的值创建数组。但是，JVM 就没有与此对 应的指令。那么，Java 中是如何通过构造函数创建的数组或者使用 new int {1,2, 3} 这样的代码创建数组的呢？让我们使用 javap 来看一下。
最初的代码：

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 1 6 第 7 章　为 Diksam 引入数组

class Test {

 public static void main(String[] args){



int[] a = {1, 2, 3, 4, 5};

 }

}

javap 的结果（只截取了指令部分）： 

0: iconst_5 1: newarray int 3: dup 4: iconst_0 5: iconst_1 6: iastore 7: dup 8: iconst_1 9: iconst_2 10: iastore 11: dup 12: iconst_2 13: iconst_3 14: iastore 15: dup 16: iconst_3 17: iconst_4 18: iastore 19: dup 20: iconst_4 21: iconst_5 22: iastore 23: astore_1 24: return
也就是说，相当于下面这段代码。
int[] a = new int[5];

a[0] = 1; a[1] = 2; a[2] = 3; a[3] = 4; a[4] = 5;
在我看来，生成字节码的体积太大了。在 Java 中，与一个方法对应的字节码是有 大小限制的（Diksam 也一样），所以自动生成代码的时候（也许还有其他情况）可能会 引起问题。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

7.3　修改 DVM 2 1 7

  补充知识    C 语言中数组的初始化 
Diksam 也好，Java 也好，数组字面量以及利用构造函数创建的数组，它们的内容 都是在“运行时”决定的。所以，在下面这段代码中：
int[] a = {b * 10, func()};
从这段初始化的程序可以看出，数组元素可能只在运行时才能决定其值的表达式。 对此，在 C 中利用初始化程序初始化数组的时候，元素的内容必须是常量表达式。 因为有了这个限制，在编译时可以预先创建数组的内存映像，static 变量开始执 行、自动变量 A 进入函数时，可以利用事先创建的内存映像进行初始化。

7.3.2 对象

在 book_ver.0.1 中可以称为对象的只有字符串，现在在 DVM_Object 中增加 了数组成员，以对应这次新增的数组概念。
struct DVM_Object_tag { ObjectType type; unsigned int marked:1; union { DVM_String string; DVM_Array array; ←新增 } u; struct DVM_Object_tag *prev; struct DVM_Object_tag *next;
};
 DVM_Array 的内容如下所示。
typedef enum { INT_ARRAY = 1, DOUBLE_ARRAY, OBJECT_ARRAY,
} ArrayType;

struct DVM_Array_tag {

ArrayType type;

int

size;

int

alloc_size;

union {

A　一般情况下可以看作是局部变量。——译者注

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 1 8 第 7 章　为 Diksam 引入数组

int

*int_array;

double

*double_array;

DVM_Object **object;

} u;

};

在 crowbar 中，数组是“CRB_Value 的数组 A”。这次也一样，因为有 DVM_

Value 联合体，数组也可以表现为数组。但是，由于 Diksam 是静态语言，因此

数组的类型是静态决定的。绝对不可能把 double 加入到 int 的数组中。.

这么说的话，int 的数组使用“sizeof(int)× 元素数”就可以毫无浪费

地创建内存空间，即使是传递给 C 的内置例程处理起来也很舒适。因此，枚举类

型 ArrayType 中的每个对象都表示不同数组元素的类型。ArrayType 没有必

要对应 Diksam 中的所有类型。例如字符串的数组，或者是数组的数组，这些都

是 OBJECT_ARRAY。数组的类型在编译时决定，因此运行时在这里没有必要保存

严格的类型。现在的情况是，数组的类型信息只有 GC 用到了。.

  补充知识    ArrayStoreException 
前面写到，在 Diksam 中既有字符串数组也有数组的数组，数组的对象中只保存了 “OBJECT_ARRAY”这一个信息。与此相对，在 Java 中，数组对象中保存着完整的类型 信息。这样的区别是基于以下两点原因。
●●Diksam 中还不存在类和继承，但是在 Java 中存在。 ●●在 Java 中，当 A 是 B的子类时，A[]也自动地成为了 B[]的子类。
例如有一个表示图形的类 Shape，有两个继承它的子类 Line 和 Circle。这时在 Java 中，可以把 Line 的数组赋值给 Shape[] 型的变量。这种设计乍看是挺方便的， 实际上问题重重。请思考如下这个代码片段。
1: Line[] lines = new Line[10]; 2: Shape[] shapes = lines; 3: shapes[3] = new Circle(); 4: lines[3].startPoint = new Point(x, y);
第 1 行当然是合法的。第 2 行也一样，Line[] 是 Shape[] 的子类，因此在 Java 中也是合法的。第 3 行，因为 Circle 也是 Shape 的子类，所以 Java 在编译时并不会报 错（更确切地说是报不出错）。
接下来的第 4 行就悲剧了。shapes 和 lines 指向同一个数组，因此 lines[3] 也 就是 shapes[3]，它在第 3 行被赋了一个 Circle 对象的值。但是，在第 4 行的时 候 又 要 引 用 Line 的 起 点（startPoint），Circle 中 并 没 有 startPoint， 因 此

A　这个数组值必须是双向链表。——译者注

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

7.3　修改 DVM 2 1 9
这行代码不能被执行。但是，编译器却始终认为 line[3] 肯定是 Line，因此编译时 不会出现报错。 正因如此，在 Java 中，执行到第 3 行代码时会发生运行时的异常， ArrayStoreException。
只 有 在 运 行 时 掌 握“这 个 数 组 在 变 量 声 明 上 是 Shape[]， 但 是 它 实 际 上 却 是 Line[]”，才能在实现时抛出上述异常。因此，在 Java 中，必须将完整的类型信息 保存在数组的对象中。
我认为这是一个不良的设计。既然是静态语言，就应该在编译时完成类型检查，在 运行时抛出异常不是很奇怪的吗？总之，我认为 Java 的“A 是 B 的子类时，A[] 也自动 地成为了 B[] 的子类”这个规则是错误的。
Diksam 将在下一章引入类的概念，但是没有建立上述规则，因此也没有必要在数 组中保存严格的类型信息。
7.3.3 增加 null
由于数组和字符串都是引用类型，因此增加了 null。 随之改变的是，以前字符串变量的初始值是空字符串，现在变成了 null。 关于 null 的规则如下所示。 1. 字符串类型、数组类型的变量可以赋值为null。 2. 字符串类型与值为null的变量用+连接的话，null会转换为字符串"null"。 3. 字符串类型与字面量null用+连接的话，null会转换为字符串"null"。 4. 字符串类型与数组类型可以和null进行比较。
7.3.4 哎！还缺点什么吧？
这次引入了数组的概念，如果是了解当今编程语言的人肯定在期待着下面这 些功能。既然引入了数组的概念，怎么能没有它们呢？.
●● 没有知道数组大小的（array.size() 或者 array.length 等）方法吗？ ●● 没有动态增加数组元素（例如 array.add(5)）的方法吗？ ●● 不能把数组内容直接输出（例如 print("array.." + array)）吗？ 这些大概在当今的编程语言中都能实现（有些语言会把数组理所当然地输出 为地址或者哈希值），说起来在 crowbar 中也实现了，但是这次却搁置起来了。这 是因为考虑到这些功能最终都归结为“方法”，因此还是和类一起制作更为恰当。 所以，下一章将要对类进行处理。.
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

第8章
将类引入 Diksam
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 2 2 第 8 章　将类引入 Diksam
8.1 分割源文件
本章的标题是“将类引入 Diksam”，在现在的 Diksam 中源代码不能分散地 写在多个文件中。即使在编程语言中引入了类的概念，如果必须把所有代码都写 在一个源文件中，那么这个语言又能有多大用处呢？
因此，首先要实现对源文件的分割。
8.1.1 包和分割源代码
分割源代码的方法，最简单的就是和 C 语言里面的 #include 一样，嵌入 来自于其他源文件的代码。这个方法既简单又直接，非常实用。
但是，使用这个方法嵌入多个库文件时，函数名、变量名等很可能发生冲 突。因此，在分割源代码的同时，加入相当于 Java 的包或者 C++ 和 C# 的命名空 间的功能。
Diksam 的包的设计方式如下所示。 1. require
一些源文件如果需要其他源文件提供的功能时，应在该源文件的开头加入如 下代码。
require hoge;
在这个例子中，编译器会在编译时搜索文件名为 hoge.dkh 的文件。和 Java 的 import 一样，require 也只能写在代码的开头。另外，require 读取的文 件必须以 .dkh 为后缀，它是与 C 语言的头文件相似的文件。
搜索源文件的目录配置在环境变量 DKM_REQUIRE_SEARCH_PATH 中，多个 搜索目录之间在 UNIX 中用冒号、在 Windows 中用分号分割。如果没有配置这个 环境变量的话，将在当前目录（.）中进行搜索。这里的设计方式基本上和 Java 的 CLASSPATH 相同。
被 require 的文件有可能还要 require 其他文件，这时不会对同一个文件 进行重复读取。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

8.1　分割源文件 2 2 3
2. 动态加载 对于 require 的文件来说，虽然也可以把必要的函数的源代码全都写在里
面，但是函数只要像下面这样进行 签名声明 也可以编译通过。.
int print(string str);
如果是像 print() 这样的原生函数，签名声明后就可以直接使用了。 如果不是原生函数的话，只有在函数 被调用的时候 才会加载对应的源代码。 这种方式称为 动态加载（  dynamic.load）。因为程序中总有些功能是不常用的，使 用了动态加载后相信能够实现高速化启动。 如果在 hoge.dkh 中进行了签名声明，那么在函数被调用的时候会对 hoge.dkm 进行搜索。在创建库文件时，.dkm 实现了 .dkh 中定义的设计。 动 态 加 载 时 搜 索 的 目 录 并 不 配 置 在 环 境 变 量 DKM_REQUIRE_SEARCH_ PATH 中，而是从 DKM_LOAD_SEARCH_PATH 中获取。在这里，特意使用两个不 同的物理路径来区分库文件的设计和实现。另外，也可以使用“在测试过程中将 实现文件作为存根”的方法。 实际上，.dkh 文件作为设计公开的大小与其实现（.dkm 文件）后的大小相 差悬殊，.dkh 和 .dkm 的对应关系应该是 1∶n 的样子，但是这样一来，在动态加 载时就需要另外指定搜索源代码的方法了，因此这里先让它们保持 1∶1 的状态。 我认为动态加载是能够使用 Diksam 编写大程序的一个先决条件。 3. 包 在 Diksam 中，一个源文件就对应着一个包（在 .dkh 和 .dkm 分开编写的情况 下，它们两个的代码要在一个包中）。 像 Java 那样在每个源文件的开头都要逐个对包进行声明是非常麻烦的，通常 情况下，Java 的目录层级和包的层级一致，也就是把同样的信息体现在了两个地 方。这样一来，在修改时就会出现问题（尤其是 Java 的包名，使用起来像是互联 网的域名）。既然如此，单纯地使用源文件名和包名的组合可能更简单。 Diksam 的包名使用点（.）进行分割，根据包名就可以简单地分清层级。.
require hoge.piyo.foo.bar;
上面这段代码，会以 DKM_LOAD_SEARCH_PATH 中设置的目录为起点，以 包名的最后一个名字之外的部分（即上述例子中的“hoge/piyo/foo”）为目录进行 搜索。总之和 Java 一样，Diksam 的包层级也要和目录层级一致。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 2 4 第 8 章　将类引入 Diksam
另外，在 C++ 或者 C# 中，一个源文件可以对应多个 namespace，但是一般 情况下都不会这么做。我觉得在这种事情上节省没有任何意义。相反，一个包可 能希望由多个源文件构成。我想就像前面说到的，这是能够使用 Diksam 编写大 程序的一个先决条件，也正因如此，我们才需要用最简单的办法来解决眼前实现 和使用上的问题。
另 外， 像 print() 这 样 标 准 的 程 序 库 被 收 录 在 了 diksam.lang 中。 在 这次要制作的 Diksam 的版本（Diksam.book_ver.0.3）中，使用者必须要手动进 行 require。 4. rename
在进行 require 时，如果引入了多个包中的同名函数时会发生命名冲突。 在 Java 中，可以通过指定 全限定类名（   FQCN，Fully.Qualified.Class.Name） 避免这个冲突（如 java.util.List 和 java.awt.List）。但是，这样编写代 码时会很麻烦，而且编写出来的代码也会显得杂乱无章。 因 此， 在 Diksam 中 没 有 指 定 FQCN 的 方 法。 解 决 冲 突 的 方 法 是 利 用 rename 进行如下操作。
rename com.kmaebashi.util.print myprint;
上面这段代码将 com.kmaebashi.util 包的 print 函数改名为 myprint。  rename 必须写在源代码的开头和 require 之后。还有，rename 的有效 范围仅在当前源文件中，即使在被 require 的文件中使用了 rename，也不会影 响到进行 require 的文件。这是因为，被改名后的名字只在当前源文件内可见， 这样做的目的是为了可以让每个源文件都能识别出函数的真正身份。 5. 开始执行
在现在的 Diksam 中，如果执行下面这段代码，程序将从 hoge.dkm 的顶层结 构开始执行。
% diksam hoge.dkm
即使引入了 require，这个设计仍然没有改变。总之，程序总是会从指定源 代码的顶层结构开始执行。一旦程序开始执行，就可以调用被 require 的源代 码中的函数了。即使被 require 的文件有顶层结构，也是不会执行的。
可以把 Diksam 的顶层结构看作是 Java 中的 main() 方法。main() 方法在
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

8.1　分割源文件 2 2 5

程序库中大多是充当测试驱动的角色吧 A。
6. 关于全局变量 在 Diksam 中，全局变量是在函数外（顶层结构中）声明的变量，但是其他
源文件是引用不到这个全局变量的。也就是说，如果只有在多个源文件中能够被 任意引用的变量才可以称为全局变量的话，那么 Diksam 中就不存在全局变量。
但是，多个源文件之间可以进行函数调用，因此使用 get_xxx()、set_ xxx() 也是可以访问全局变量的。一般来说，应该尽可能不使用全局变量，因此 我认为这种方式再适合不过了。.

* gcc 好像采用了另外的
方式输出。

  补充知识    #include、文件名、行号 
虽然和本节的主题无关，但这里还是要提一下，在 8.1.1 节的开头写道：
分割源代码的方法，最简单的就是和 C 语言里面的 #include 一样，嵌入来 自于其他源文件的代码。这个方法既简单又直接，非常实用。
这个方法非常实用，那么这个方法就是个好方法吗？你可能会认为，像 C 语言的 预处理那样，如果事先进行了处理，编译器就无需在执行时再进行校正了。实际却不是 这样的。值得注意的一点就是，必须要通过某种方法知道被 require 的文件的文件名 和行号。
使用 #include 将其他文件嵌入进来的话，行号自然会发生变化。在出现报错信 息的时候，将变化后的行号输出给使用者的行为是很不友好的（JSP，即 Java Server Pages，它就是这样，会将自动生成的 Java 代码的行号直接输出）。
例如，C 语言的预处理会通过下面的形式，将行号和文件名传递给预处理后的文件 *。
#line 2 "hello.c"

8.1.2 DVM_ExecutableList
一个 Diksam 编译器和一个源文件会生成出一个 DVM_Executable。在之后 可能会对一个源文件进行分割，因此编译后也可能生成多个 DVM_Executable。
为了管理这些 DVM_Executable，我们引入了 DVM_ExecutableList 结 构体（DVM_code.h）。
typedef struct DVM_ExecutableItem_tag {
A　这也就说明了为什么被 require的程序不执行其顶层结构的原因。——译者注

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 2 6 第 8 章　将类引入 Diksam

DVM_Executable *executable; struct DVM_ExecutableItem_tag *next; } DVM_ExecutableItem;

struct DVM_ExecutableList_tag {

DVM_Executable

*top_level;

DVM_ExecutableItem *list;

};

这 是 一 个 通 过 DVM_ExecutableItem 保 存 DVM_Executable 的 链 表 的 类。成员 top_level 在通过 list 保存了 DVM_Executable 的同时，也保存 了顶层结构（编译器启动时设定的）。

8.1.3 ExecutableEntry

如前面所述，Diksam 中没有跨文件的全局变量。函数外声明的变量被保存在 独立的命名空间中，没有进行链接。
在 以 前 的 数 据 结 构 中， 全 局 变 量 运 行 时 的 内 存 空 间 保 存 在 DVM_ VirtualMachine 中，如下所示。

typedef struct {

int

variable_count;

DVM_Value *variable;

} Static;

struct DVM_VirtualMachine_tag { （中间省略）

Static

static_v;

（中间省略）

};

但是，正因为没有进行链接，所以对于 DVM 来说（全局变量）没有必要保 存为一个数组。一个 DVM_Executable 中保存一个数组就可以了。
在和编译器共用的 DVM_Executable 中，不能只保存运行时使用的数据， 因此引入了 ExecutableEntry 结构体，如下所示（dvm_pri.h）。

struct ExecutableEntry_tag {

DVM_Executable *executable;

Static

static_v; ←函数外声明的变量所使用的内存空间

struct ExecutableEntry_tag *next; };

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

8.1　分割源文件 2 2 7

运行时，只为每个 DVM_Executable 分配一个 ExecutableEntry 数据 结构。如上所述，其中保存着之前在 DVM_VirtualMachine 中保存的全局变量 （函数外声明的变量）的内存空间。

8.1.4 分开编译源代码

* 使用 bison 等语法解析
器时可以使用递归。

接下来要解决的问题是，在一个源文件使用 require 请求了其他源文件的 情况下，如何进行编译比较好？
比较直接的想法，我想是在解析器发现 require 的时候递归调用编译器。 但是，因为在 yacc/lex 的内部使用了很多全局变量，所以不能使用递归。也就是 说，在解析一个文件的中途不能再去解析其他文件 *。
Diksam 的 编 译 顺 序 是， 在 一 个 源 文 件 完 成 编 译 后， 再 按 顺 序 编 译 被 require 的源文件。  DKC_Compiler 结构体作为 Diksam 编译的核心，其内部保存着顶层结构的 语句列表和函数（FunctionDefinition）的列表等。在编译的最后阶段，会根 据这个结构体生成 DVM_Executable。从结构上来说，DKC_Compiler 和 DVM_ Executable 是 1:1 的关系，因此在源文件中编译被 require.的源文件时，会为 其创建一个新的 DKC_Compiler 结构体。
编译 Diksam 的代码时，应用程序会调用 DKC_Compile() 函数。这个函数 会调用 do_compile() 方法，如下所示。.

yyin = fp; /* 将源代码 fg（作为起点）赋值到 yyin 中 */ /* 生成空的 DVM_ExecutableList */ list = MEM_malloc(sizeof(DVM_ExecutableList)); list->list=NULL;

代码清单 8-1 do_compile() 

/* 调用 do_compile()。第三个参数为源文件的路径，但在这个层级不适用。 */ exe = do_compile(compile, list, NULL, DVM_FALSE);

 do_compile() 的内容如代码清单 8-1 所示（节选）。

1: static DVM_Executable *

2: do_compile(DKC_Compiler *compiler, DVM_ExecutableList *list,

3:

char *path, DVM_Boolean is_required)

4: {

5:  （ 省略局部变量的声明部分）

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 2 8 第 8 章　将类引入 Diksam

6: 7: 8: 9: 10: 11: 12: 13: 14: 15: 16: 17: 18: 19: 20: 21: 22: 23: 24: 25: 26: 27: 28: 29: 30: 31: 32: 33: 34: 35: 36: 37: 38: 39: 40: 41: 42: 43: 44: 45: 46: 47: 48: 49: 50:}

/* 在 C 的栈中回避当前编译器 */ compiler_backup = dkc_get_current_compiler(); dkc_set_current_compiler(compiler);
/* 执行解析 */ if (yyparse()) {
fprintf(stderr, "Error!Error!Error!\n"); exit(1); }
/* 遍历所有被 require 的源文件 */ for (req_pos = compiler->require_list; req_pos;
req_pos = req_pos->next) { /* 检查正在编译的源文件是否有相应的编译器 */ req_comp = search_compiler(st_compiler_list, req_pos->package_name); if (req_comp) {
compiler->required_list = add_compiler_to_list(compiler->required_list, req_comp);
countinue; } /* 如果没有，创建一个新的编译器并进行编译 */ req_comp = DKC_create_compiler();
（中间省略。这里将搜索到的源文件路径设置到 found_path 中。） req_exe = do_compile(req_comp, list, found_path, DVM_TRUE);
}
dkc_fix_tree(compiler); exe = dkc_generate(compiler); if (path) {
exe->path = MEM_strdup(path); } else {
exe->path = NULL; }
exe->is_required = is_required; if (!add_exe_to_list(exe, list)) {
dvm_dispose_executable(exe); }
/* 从备份中恢复当前编译器 */ dkc_set_current_compiler(compiler_backup);
return exe;

在函数中，yyin 的值被设置为源文件的文件指针，并在第 11~14 行解析这个

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

8.1　分割源文件 2 2 9

文件。之后，按照顺序循环地编译从第 17 行开始的代码。 前 面 已 经 提 到 过， 当 前 版 本 的 Diksam 会 为 每 个 源 文 件 生 成 一 个 编 译
器（DKC_Compiler）。 然 后， 执 行 过 一 次 编 译 的 编 译 器 被 保 存 在 名 为 st_ compiler_list 的 static 的 链 表 中。 在 第 20 行 被 调 用 的 函 数 search_ compiler() 是为了在第 1 个参数 st_compiler_list 中搜索是否有编译过当 前包的编译器。DKC_Compiler 保存着包名，如果包已经被编译过，将对应的编 译器添加到正在编译的编译器的 require_list 中（第 22~23 行）。这个结构很 像树结构，但是这个结构是为了共享同一个被多次 require 的源文件，因此实 际上它并不是树结构，而是 DAG（有向无循环图，Directed.Acyclic.Graph）结构。
如果有没有编译过源文件的话，从第 27 行开始的代码会创建一个新的编译 器并进行编译。.
并且，第一次启动时，s t_compiler_list 的生命周期是从第一次编译结束 到开始运行之前。因此，在动态加载的时候同样的源代码会被再次编译。详细请 参考 8.1.5 节的补充知识。
第 29 行中间省略了通过 DKM_REQUIRE_SEARCH_PATH 搜索被 require 的源 文件并返回文件指针等一连串的处理。之后将返回的文件指针作为参数，递归调 用 do_compile() 函数（第 30 行）。
所有的子文件都编译过后，将使用 dkc_generate() 创建 DVM_Executable，然后将其注册到 DVM_ExecutableList 中（第 42 行）。
最终状态的 DKC_Compiler 的结构如图 8-1 所示。.

图 8-1 编译器编译后的结构

根据起点源文件的 require 创建 编译器，并以 DAG（有向无循环图） 方式保存

首先，创建与作为起点 的源文件对应的编译器

DKC_Compiler 创建
DVM_Executable

DKC_Compiler 创建
DVM_Executable

DKC_Compiler 创建
DVM_Executable

编译器将逐个（为每个源文件） 创建 DVM_Executable

共享被多个源文件 require 的源文件
DKC_Compiler 创建
DVM_Executable
经 过 编 译，创 建 的 所 有 DVM_Executable 都被存储到一个 DVM_ ExecutableList 中

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 3 0 第 8 章　将类引入 Diksam
8.1.5 加载和再链接
由 于 编 译 是 以 源 文 件 为 单 位 进 行 的， 因 此 完 成 编 译 之 后， 还 需 要 进 行 链 接。 链接 是指把不同源文件中出现的同名函数进行对应的操作。本节是继续 6.4.1 节的内容作介绍。
在 C 等语言中，全局变量也必须进行链接，但是在 Diksam 中并没有可以跨 源文件的全局变量，因此有必要和其他源文件进行链接的就只有函数了（虽然后 面会出现类的概念）。
现在，“函数”的数据保存在以下三个地方。 1.  DKC_Compiler 中的 FunctionDefinition 列表
这个对应表中保存了在当前源文件中定义的原型声明函数。如果只是签名声 明的话，指向实现程序块的成员 block 应为 NULL。
这其中并不保存被 require 的 .dkh 文件中声明的函数。这些函数将保存在自 己所在 .dkh 文件对应的编译器中，因此，在搜索函数的工具函数 dkc_search_ function() 中，为了搜索参数指定的函数，需要递归地遍历所有子编译器（util.c）。 2.  DVM_Executable 中的 DVM_Function 数组  DVM_Executable 的 DVM_Function 数组中，保存着当前源文件中出现的 所有函数。
假设在源文件 a.dkh 中 require 了 b.dkh，并且调用了 b.dkh 中声明的函数 b_ func()。此时，b_func() 并没有保存在 a.dkh 的 FunctionDefinition 中， 而是保存在 DVM_Executable 中。
就像 6.4.1 节中介绍过的那样，在完成编译时，指令 push_function 指定 的函数的索引值就是这个数组的下标。因此，一般情况下所有需要被调用的函数 都会保存在这个对应表中。
至 于 索 引 值， 加 载 时 会 在 字 节 码 中 直 接 替 换 为 DVM_VirtualMachine. 中 Function 数组的下标（请参考 6.4.1 节）。 3. DVM_VirtualMachine 中的 Function 数组  DVM_VirtualMachine 中的 Function 数组保存着链接后的函数，每个 DVM 中只有一个该数组。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

8.1　分割源文件 2 3 1

因为 Diksam 是动态加载的，所以这个对应表中保存的函数还是没有实现的 状态。此时，成员 is_implemented 都是 false。
并 且， 这 个 数 组 在 以 前 的 版 本 中 以 可 变 长 数 组 的 形 式 保 存 在 了 DVM_ VirtualMachine 结构体中，但是，现在变成了“指针的可变长数组”。后面将 会说到，基于动态加载，这个数组会使用 realloc() 进行扩展。之前的结构如 果使用了 realloc() 会使 Function 结构体的地址发生变化。因此，我们需要 一个即使扩展了数组的元素地址也不会改变的结构（如图 8-2）。

图 8-2 修改为即使使用了 realloc() 元素，地址 也不会改变的结构

以前的保存方法 DKC_VirtualMachine

想要使用指针指 向数组内特定的 Function，可 是不太方便。

Function
realloc() 数组时， 将改变各 Function 的地址

修改后的保存方法
DKC_VirtualMachine
变为指针数组的话，即 使 使 用 realloc()， 各 Function 的 地 址 也不会改变
因此，可以更便捷 地指定某个特定的 Function

Function

具体的实例请参考以下三段源代码（hoge.dkm，piyo.dkh，piyo.dkm）。 hoge.dkm:

require piyo;

int hoge_func() { piyo_func();
}

hoge_func();
piyo.dkh:
int piyo_func();
piyo.dkm:
require diksam.lang;

int piyo_func() { print("piyo piyo\n");
}
各个源文件在对应表中的注册状态如图 8-3 所示。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 3 2 第 8 章　将类引入 Diksam

图 8-3 函数在对应表中注册的 状态 
DKC_Compiler DVM_Executable
FunctionDefinition DVM_Function piyo_func(未实现) piyo_func(未实现)

require

被动态加载

DKC_Compiler DVM_Executable

FunctionDefinition DVM_Function

print 原生

print 原生

require

DKC_Compiler DVM_Executable

FunctionDefinition DVM_Function

hoge_func

hoge_func

piyo_func( 未实现 )

DKC_Compiler DVM_Executable

FunctionDefinition DVM_Function

piyo_func

piyo_func

print(未实现 )

开始执行时没有 读取的范围

向 FunctionDefinition 中注册源文件中定义或者 声明的函数

DVM_Function 中 一般情况下只注册被 调动了的函数

启动时的 DVM

DKC_VirtualMachine Function
print 原生 hoge_func piyo_func(未实现 )

由于在 hoge.dkh 中仅定义或者签名声明了函数 hoge_func()，因此 FunctionDefinition 也 只 注 册 了 一 个 函 数。 但 是，DVM_Executable 的 DVM_ Function 中只注册了被调用的 piyo_func() 函数。push_function 指令创 建不了的函数不会注册到这里。
hoge.dkm 中 被 require 的 piyo.dkh 也 会 被 同 时 编 译。 在 这 里 被 声 明 的 piyo_func() 会 同 时 注 册 到 piyo.dkh 的 FunctionDefinition 和 DVM_ Executable 两个地方。
在 执 行 开 始 时 只 编 译 了 这 两 个 文 件。 在 这 个 状 态 中， 会 根 据 DVM_ VirtualMachine 的 Function 创建对应表，并将经常以原生函数形式出现 的 print()、hoge_func() 和 piyo_func() 注册进来。但是，虽然 piyo.dkm 描述了实现但还没有被加载，因此还没有实现 piyo_func()。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

8.2　设计 Diksam 中的类 2 3 3

一旦 piyo_func() 被调用，就会进行动态加载。动态加载功能首先新创建 一个 piyo.dkm 的编译器，然后再创建一个被 require 的 lang.dkh 的编译器，最 后将创建出来的 DVM_Executable 链接到 DVM_VirtualMachine 中，并开始 执行 piyo_func()。.
  补充知识    动态加载时的编译器 
只需一次编译，就可以让同一个文件在任何地方都能被 require，与此相对，只 创 建 一 个 DKC_Compiler 就 可 以 了。 在 代 码 清 单 8-1 中 说 明 了 其 实 现 方 法， 即 使 用 static 的变量 st_compiler_list 保存所有编译器。
但是，也会发生这样的情况，在 a.dkm 中 require 了 b.dkh，b.dkh 中动态加载 的 b.dkm 又调用了 a.dkm 中的函数。在现在的实现中，只会为 a.dkm 创建一个 DVM_ Executable， 但 是 却 会 多 次 创 建 DKC_Compiler。a.dkm 的 DKC_Compiler 在 第 一 次 编 译 后 将 被 销 毁， 但 编 译 b.dkm 时 又 必 须 使 用 a.dkm 的 编 译 器。 在 b.dkm 的 FunctionDefinition 中只注册了 a.dkm 中被调用的函数，但请记住它是会搜索 子编译器的。
同一个源文件被编译多次确实很浪费，但是现在的 Diksam 还不能把字节码保存在 文件中，因此在执行时必须要有源代码。考虑到这样的情况，虽然很浪费但也没有什么 坏处，在实用性上也不会有问题。
等到日后字节码可以保存到文件中的时候，只需使用 DVM_Executable 中包含 的 DVM_Function 等信息就可以完成源代码的编译了。

8.2 设计 Diksam 中的类
在成功将源文件分割后，接下来就要考虑类的设计了。.

8.2.1 超简单的面向对象入门

设计类一定会考虑到数组（array）。但是，考虑到本书的目标读者是掌握 C

语言，并具有一定代码阅读能力的程序员，因此，我觉得这里突然开始类和面向对

* 例如 Java 中的“超类”
在 C++ 中 被 称 为“ 基
类”。

象的话题好像不太合适。另外，面向对象的相关用语在不同语言中也不尽相同 *， 因此，本节将要讲解的是包含用语含义在内的一些简单的面向对象概念。.
Diksam 的 面 向对象与 Java、C++ 和 C# 相同，都是 基于类的面向对象 。 类 .

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 3 4 第 8 章　将类引入 Diksam
（class）近似于 C 中的结构体类型，但是与其关联的动作（函数）可以保存在类 中，被称为 方法（  method），数据成员被称为字段（field）。
class Point { double x; double y; // 定义 Point 的方法 print() void print() { println("(x, y)..(" + this.x + ", " + this.y + ")"); }
}
方法以 p.print() 的形式调用。如果是 C 语言的话，第 1 个参数要传入指 向 Point 的指针。但是，在面向对象的语言中，每个类都拥有不同的命名空间， 其优势在于（与 C 语言相比）无需特别注意命名。
之前说到了类“近似于 C 中的结构体”，在 C 语言中声明结构体的类型时， 并不会为其创建内存空间。与此相同，Diksam 中也需要使用 new 来创建内存空 间，相当于 C 语言中的 malloc() 操作。被 new 创建出来的叫作 对象（ . object） 或者 实例（   instance）。.
Point p = new Point();
Diksam 中的类全部属于引用类型，因此上面代码中的 p 相当于 C 语言中的 指针。但是，如果要引用字段或者方法，不是使用 -> 而是使用 .（和 Java 等语 言相同）。
在 Diksam 这样的面向对象语言中，可以使用 继承（  inheritance）的方式为类 添加字段或者方法。. 例如，在制作一个二维图形绘制工具时，要定义一个代表 图形的类 Shape。在 Shape 中保存着“颜色”等所有图形都共有的属性。又如， “开始和结束坐标”是直线（Line）中特有的数据。因此，如果在定义 Line 的时 候继承 Shape，那么 Line 将既具有 Shape 的“颜色”属性，又具有自己特有的 “开始和结束坐标”属性。
与 此 相 似，crowbar 和 Diksam 的 源 代 码 中， 在 Expression 结 构 体 和 Statement 结构体中的实现方法是“使用枚举类型区分不同种类（数据类 型），将每个种类的数据保存在联合体中”。可见，在 C 语言中想要实现这个功 能，必须在程序员的层面“约定”，但是，对于面向对象的语言来说，它本身就 能够显式地提供此功能。
如 此 一 来， 在 Line 继 承 Shape 的 时 候，Shape 被 称 为 Line 的 超
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

8.2　设计 Diksam 中的类 2 3 5
类，Line 被称为 Shape 的子类。根据不同语言超类也叫作 父类（   parent.class） 和 基类（   base.class），子类也叫作 孩子类（ . child.class）和 派生类（ . derived.class）。 另外也有“把类沿着超类方向追溯到的所有类称为 祖先（   ancestor），并把子类方 向的所有类称为 子孙（ . descendant）”的说法。
子 类 的 引 用 通 常 可 以 赋 值 给 类 型 为 父 类 的 变 量， 也 就 是 说 Line 或 者 Circle（圆）可以赋值给 Shape。例如，有一个 Shape 类型的数据，其中可 以保存 Line、Circle、Rectangle（矩形）等图形。
然后，为了描述数组中的所有图形，为 Shape 添加 draw() 方法（可以不 实现）。
// abstract 和 virtual 的话题将在后面叙述 abstract class Shape {
（中间省略） // 声明没有实现的 draw() 方法 abstract virtual void draw();
}
在每个子类中 覆盖（  override）这个方法。
// 继承了 Shape 的 Line 类的定义 class Line : Shape {
（中间省略） override void draw() { //Line 的描绘处理 }
}
基于上面这些代码，数组中保存的 Shape 将以如下方式依次调用 draw() 方 法， 如 果 是 Line 的 话 调 用 Line 的 描 绘 方 法， 如 果 是 Circle 的 话 则 调 用 Circle 的描绘方法。这种特性被称为 多态（ . polymorphism）。
Shape[] shape_array; // 假设已经设置过 shape_array 的值了 for (i = 0; i < shape_array.size(); i++) {
shape.draw(); }
与在 crowbar 和 Diksam 中的做法相似，C 语言中如果也使用枚举类型和联 合体实现“模拟继承”的话，就必须进行“根据枚举类型用 switch.case 判断分 支”的处理了（比如 Diksam 的 fix_expression 就包含一个巨大的 switch case）。 编 写 switch case 本 身 倒 是 不 成 问 题， 问 题 在 于 当 枚 举 类 型 的 种
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 3 6 第 8 章　将类引入 Diksam

* 因 为 Diksam 并 没 有 将
字节码保存为文件，所
以不论如何都要重新
编译。

类增加的时候，就不得不去修改分散于各处的 swith case。特别是 Shape， 当 增 加 图 形 种 类 的 需 求 越 来 越 强 烈 的 时 候， 这 个 问 题 就 变 得 尤 为 突 出 了。 在 使 用 了 多 态 后， 即 使 图 形 的 种 类 增 加 了， 在 上 述 示 例 代 码 中 也 没 有 必 要 修 改 Shape 的 draw() 方法的调用位置，也就不必再次进行编译了 *。.
就像上面说到的，子类的引用通常可以赋值给类型为超类的变量（此处发生 的自动类型转换被称为 向上转型 ，即 up.cast），但是这并不意味着超类的引用能 够赋值给子类的变量。Line 必然是 Shape，但 Shape 不一定是 Line（说不定 是 Circle 或 Rectangle 呢）。然而，在 Diksam、Java、C#、C++ 中都有强制 将 Shape 转换（即 向下转换 ，down.cast）为 Line 的手段（在向下转换时有可 能会发生错误）。
在 Diksam、Java 和 C# 中，除了类之外，还有 接口（  interface）的概念。它类 似于只有方法的声明的类。
例如，Line 和 Circle 可能会有在调试时显示坐标等信息的需求。如果只考 虑 Shape 的话，为 Shape 添加 print() 方法并由各图形进行覆盖就可以达到 目的了，但是如果考虑到下面的情况呢？

想要制作一个 void debug_write (Printable obj) 函数以便控制程序“只在调试模式时 输出”。 传递给这个函数的参数对象也许和 Shape 之间并没有任何继承关系。

这种情况下就可以使用接口了。

interface Printable { void print();
}
有了上面的接口后，各个类都可以对其进行实现，每个类都会有“print 自 己的内容”这个功能的通用接口（实际的编写方法请参考 8.2.4 节）。
Diksam 中的类只能进行单继承（single.inheritance），即一个类只能对应一个 超类。这种方式在 Java 和 C# 中相同。但是，在 C++ 中是允许 多继承（   multiple. inheritance）的。
关于接口，Diksam 是允许多继承的。这一点也和 Java、C# 相同（C++ 允许 类的多继承，因此一般情况下不会出现接口）。
基于类的面向对象大概就介绍到这里，没有介绍到的部分请大家参考市面上 其他的参考书吧。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

8.2　设计 Diksam 中的类 2 3 7

代码清单 8-2 Point 类的定义 

8.2.2 类的定义和实例创建

Diksam 中类的设计基本上采用了 C++、Java、C# 的方式，虽然更像是由 C++ 派生出的类型的语言，但是也有意地改变了一些地方。
作为类定义的典型例子，首先让我们考虑一下在二维坐标上保存一个点的 类 Point（代码清单 8-2）。

1: require diksam.lang;

2: 

3: public class Point {

4:

private double x;

5:

private double y;

6: 

7:

double get_x() {

8:

return this.x;

9:

}

10:

void set_x(double x) {

11:

this.x = x;

12:

}

13:

// 由于篇幅限制，省略 get_y()，set_y()

14:

15:

void print() {

16:

println("x.." + this.x + ",y.." +this.y);

17:

}

18:

// 默认的构造函数的名称是“initialize”

19:

constructor initialize(double x, double y) {

20:

this.x = x;

21:

this.y = y;

22:

}

23: }

24:

25: // 创建 Point 的实例

26: Point p = new Point(10, 20);

27:

28: // 显示 p 的内容

29: p.print();

虽然看上去和 Java 等语言的类差不多，但是 Diksam 的类有以下这些不同点。

1. 引用成员时必须使用 this. 看了第 8 行应该能明白，作为返回值返回成员变量（字段）x 时写作 this.
x。在 Java 等语言中虽然可以用这种写法，但如果只写 x 也可以引用到这个字段。 可是在 Diksam 中，不显式地写上 this. 的话就不能引用属于类自身的字段和方

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 3 8 第 8 章　将类引入 Diksam

法。这里是有意为之。 类是多个方法的集合体，有时候也可能会制作一个相当巨大的类。虽然在
Java 等语言中的做法是为了能够简单地引用到字段，但是随着类的增大，字段会 慢慢呈现出全局变量的样子。
例如。java.awt.Component 的源代码大约有 8500 行（JDK5.0），在其中 能够自由地引用像 x、y 这么短名字的属性，这对我来说简直就是自杀行为。
因此在 Diksam 中，即使是在类内部引用类的成员，也必须使用 this.。 这里采用了和 Python 一样的语法，可能有些人讨厌这样，但是我挺喜欢的。

2. 成员的访问修饰符只有 public 和 private ，没有 protected 在 Diksam 中 public 是从包外部可以访问的意思。第 3 行的 class 前面附
加的 public 就是这个意思。第 4~5 行为成员设定的 private 是不能从本类 以外访问的意思。如果同时加上 public 和 private 的话，就只有当前包内可 以引用。
而 且， 通 过 代 码 清 单 8-2 就 应 该 能 理 解， 在 Diksam 中 类 的 访 问 修 饰 符 protected 是不存在的。这样做的原因将在后面详细介绍，但是基本的思路 是，不要让因为别人有可能会制作子类，成为放松访问限制的借口。

3. 构造方法要使用 constructor 修饰符

构造方法（.. constructor）是在创建类的实例时调用的方法，通常会在里面编写

类的初始化处理。

Java、C++、C# 等 语 言 的 构 造 方 法 必 须 和 类 名 相 同， 可 以 使 用 方 法 重

载（   method.overload）实现多个构造方法。方法重载就是多个方法名称相同，但参

* 重载很容易和重写混 淆，它们是两个完全不 同的概念。
* 如 果 遇 到 了 int 升 级 为 double（ 译 注： 构 造方法在同一位置上的 参 数 既 有 int 型 参 数 的 也有 double 型参数的） 或 者 继 承 ① 的 情 况， 就 不能简单地决定到底使 用哪个方法了。

数的数量和类型不同，内部处理也不同（但编程语言会认为它们是一个函数）*。 但是，方法重载是混乱的根源 *，毕竟不是什么都能用重载来解决的。例如，
在代码清单 8-2 的 Point 类中，将直角坐标系的 x,y 传递给构造方法。但是 如果是使用极坐标的应用程序，恐怕就要给构造函数传入 θ（偏角）和 ρ（极径） 了。但不论是直角坐标系的 x,y，还是极坐标的 θ、ρ，都是两个 double 的组 合，因此在方法重载上无法区分（这个例子中指出了后面将要介绍的 OOSC[8] 的问题）。总之，“构造方法要和类的名字相同”这种设计本身，我认为是不合 理的。

A　构造方法在同一位置上的参数既有子类型的参数也有父类型参数。——译者注

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

8.2　设计 Diksam 中的类 2 3 9

因此在 Diksam 中为构造方法加上了 constructor 关键字，在 new 的时候 可以指定任意的构造方法。.
代码清单 8-2 的第 26 行省略了方法名。这种情况下，会直接调用默认构造方 法 initialize()（第 19 行）。如果第 26 行写成下面这样：
Point p = new Point.myinit(x, y);
就会直接调用被指定的 myinit() 方法代替原来的 initialize() 方法。 在定义类的时候，如果没有定义任何的构造方法的话，编译器会自动添加一 个默认构造方法（default.constructor），如下所示：
public virtual override constructor initialize() { super.initialize(); ←只有在有超类的时候才有这行语句
}
4. 没有 static 的字段和方法 在 Java、C++ 和 C# 中，使用 static 关键字可以定义一个与实例无关的字
段或者方法。与实例无关的意思就是，除了访问域的问题外，其他方面与全局变 量或者函数完全相同。在 Diksam 中一般都会写成全局变量或者函数，因此抛弃 了 static 的字段或者方法。

8.2.3 继承

代码清单 8-3 Diksam 中的继承 

说 起 类 当 然 会 提 到 继 承。 代 码 清 单 8-3 就 是 Diksam 中 继 承 的 示 例 代 码。Point2 继承了 Point1 并重写了 print() 方法。.

1: require diksam.lang;

2: 

3: // 不使用 abstract 关键字的类不能被继承

4: abstract class Point1 {

5:

double x;

6:

double y;

7:

8:

// 不使用 virtual 关键字的方法不能被重写

9:

virtual void print() {

10:

println("x.." + this.x + ", y.." + this.y);

11:

}

12:

// 构造方法不使用 virtual 也不能被重写

13:

virtual constructor initialize(double x, double y) {

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 4 0 第 8 章　将类引入 Diksam

14:

this.x = x;

15:

this.y = y;

16:

}

17: }

18:

19: // 继承时没有使用 Java 的 extends 关键字，而是使用了 C++/C# 的 ":"

20: class Point2 : Point1 {

21:

// 进行重写的时候要使用 override 关键字

22:

override void print() {

23:

println("override: x.." + this.x + ", y.." + this.y);

24:

}

25:

// 构造方法也可以被继承和重写

26:

override constructor initialize(double x, double y) {

27:

this.x = x + 10;

28:

this.y = y + 10;

29:

}

30: }

31:

32: // 给 Point1 的变量 p 赋值为 Point2 的实例

33: Point1 p = new Point2(5, 10);

34:

35: // 由于方法被重写了，所以调用的是

36: // Point2 的 print() 方法

37: p.print();

代码清单 8-3 的执行结果如下：

overrided: x..15.000000, y..20.000000
通过这样一个结果，能看出如下特征：

1. 方法默认为 non virtual 在第 8 行为想要被重写的 print() 方法添加了 virtual 关键字。在 Diksam 中
类会被默认定义为不可被继承（在 Java 中为 final）的，只有显式地添加关键字 virtual，方法才可以被继承。这里的设计和 C++、C# 一致。
关于这点我想还存在很多异议，详细内容我会在后面的章节中说明。

2. 重写时必须使用 override 关键字 第 21 行，Point2 重写 Point1 的 print() 方法时在前面添加了 override 关键
字（与 C# 相似）。如果不加 override，又定义了和超类同名的方法的话，就会发 生错误。
这点的根据是“重写必须显式进行”的原则，还得到了一个附带的好处，就 是如果误定义了函数名，会发生编译错误。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

8.2　设计 Diksam 中的类 2 4 1

3. 使用 ：继承 在第 18 行中定义了继承 Point1 的 Point2 类。之所以没有使用 Java 的关键
字 extends，是因为不想让继承的关键字太长，因此使用了 C++/C# 的“:”。

* 实际在 Eiffel 中构造方
法也是可以重写的。

4. 构造方法也可以被继承和重写 在 Java、C++、C# 中，构造方法都是与类名相同的，因此构造方法不能被
继承（但是可以通过 super() 调用）。另外，从语法角度讲也不可能重写构造 方法。
但是，在 Diksam 中可以任意决定构造方法的名字，我认为能够重写构造方 法也不是坏事 *。因此，在 Diksam 中构造方法也可以被继承和重写。基于这个设 计，就可以把在超类中定义的构造方法看作是默认实现。.

5. 只有 abstract 的类可以被继承 第 4 行，为类 Point1 添加了 abstract 关键字。添加了 abstract 的类
（抽象类）只是为了被继承而存在的类，抽象类本身不能被实例化。 因此，在 Diksam 中抽象类以外的类（ 具象类 ，concrete.class）不能被继承。 对于这个限制，可能大多数人会持否定的态度。但是，这个设计并不是为了
让实现起来更简单而妥协的结果，是有意为之。至于为什么要这么做，我会在后 面的章节中说明。

代码清单 8-4 接口的定义 

8.2.4 关于接口

与 Java、C# 一样，Diksam 的类也只能单继承。能够多继承的只有接口（代 码清单 8-4）。

1: require diksam.lang;

2: 

3: interface Printable {

4:

void print();

5: }

6: 

7: class Point : Printable {

8:

double x;

9:

double y;

10: 

11:

override void print() {

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 4 2 第 8 章　将类引入 Diksam

12:

println("x.." + this.x + ", y.." + this.y);

13:

}

14:

constructor initialize(double x, double y) {

15:

this.x = x;

16:

this.y = y;

17:

}

18: }

19: 

20: Printable printable = new Point(10, 20);

21: 

22: printable.print();

在这个例子中，定义了一个具有 print() 方法的接口 Printable，并且 在 Point 类中对其进行了实现。
在多继承的时候，使用逗号分隔多个接口名。此处的设计和 C# 一样（其 实，除了没有 implements 关键字之，其他的和 Java 都差不多），没有什么特 别的创新。
但是，在 Diksam 中，接口是不能继承接口的。因为接口间的继承通过在实 现类中继承多个接口就能达到一样的效果，所以这在现阶段还不是必须要做的 事情。

代码清单 8-5 classsub.dkh 

8.2.5 编译与接口

在 Diksam 中，如果 require 了只有某个函数签名声明的 .dkh 文件，那么 也可以编译通过。接下来，在函数执行的时候会加载定义了其实现的 .dkm 文件， 并通过动态编译功能进行编译。
对于类的方法来说，并没有特别地提供这种机制，但是使用接口也可以实现 设计和实现的分离。
首先，在 .dkh 文件中实现定义接口和返回接口对象的函数（代码清单 8-5）。

1: // 在 .dkh 文件中定义接口

2: public interface ClassSub {

3:

public void print();

4: }

5:

6: // 定义实现接口的返回接口对象的函数

7: ClassSub create_class_sub();

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

8.2　设计 Diksam 中的类 2 4 3
然 后， 在 对 应 的 .dkm 文 件 中， 定 义 实 现 接 口 的 类 以 及 返 回 类 实 例（通 过 new）的函数（实现在 .dkh 文件中的所有签名声明）。
这样一来，在调用 create_class_sub() 函数的时候就会发生动态加载。 在此之前，classsub.dkm 都不会被加载。
8.2.6 Diksam 怎么会设计成这样？
本节将介绍 Diksam 的面向对象为什么会设计成现在这样。如果只想了解实 现方法的人可以跳过本节。
C++ 为我们提供了以下这些不错的参考。. C++ 的方法默认为 non virtual。这是一个略微提升效率却牺牲了类扩展性的万恶设计。 在 C++ 中创建一个类时要尽量在方法前面加上 protected virtual。 面向对象的圣经之作 Object-Oritented Software Construction（简称 OOSC[8]）中 对 C++ 作了如下评价：. 在进行声明的时候是否必须使用 virtual 的意思就是，必须要有明确的约束策略（静 态约束还是动态约束）。而这个策略违反了开放 / 闭锁原则。（中间省略） C2（不明确标示 "virtual" 的时候，默认使用静态约束）更加恶劣，很难看出这种 做法在语言设计上的正当性。正如上面说到的，让静态约束和动态约束拥有不同的含 义，这个选择本身就是错误的，在此基础上还要进行默认选择，更是错上加错了。 真是个灾难。 在 C++ 之 后 问 世 的 Java 改 成 了 默 认 virtual（在 non.virtual 的 时 候 要 使 用 final）。 然而，在 Java 之后出现的 C# 中又改回了默认 non.virtual。关于这点，我 （通过网络等途径）也听过不少严厉的批评，但 C# 的作者 Anders.Hejlsberg 作出 了如下回应： There are two schools of thought about virtual methods. The academic school of thought says,“Everything should be virtual, because I might want to override it someday.”The pragmatic school of thought, which comes from building real applications that run in the real world, says,“We’ve got to be real careful about what we make virtual.”
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 4 4 第 8 章　将类引入 Diksam
翻译： 在 virtual 方法的问题上存在两派。学术派主张“任何事物都应该是 virtual 的。因为 有一天我可能需要重写它”。与此相对，实用派主张构建在真实世界中运行真实的应用， 他们认为“在进行 virtual 的时候，本来就应该引起注意”。 说到这里我想起来，《OOSC》的作者 Bertrand.Meyer 是大学教授。 方法的重写，替换了一部分在超类中实现的行为。如果不是从一开始就决定 了要替换的目标方法，而是随意地重写方法的话，那么在之后超类进行升级等改 变时，就无法保证子类的正常运行。总而言之，应该慎重对待这种随便给别人的 类打补丁的行为。 基于以上这些，更进一步地让我有了“一般情况下，类应该默认为不可继 承”的想法。 下面我要介绍一下在这个问题上“实用派”的一些想法。 《Effective.Java 中文版（第 2 版）》[9] 第 15 章中“要么专门为继承而设计并给 出说明文档，要么禁止继承”说道： 这 不 仅 仅 是 理 论 性 的 问 题， 如 果 不 是 专 门 为 继 承 而 设 计 并 给 出 相 应 文 档， 又 非 final 的具象类，一旦修改了内部，就要承受与其所有子类关联的地方都有可能 发生 bug 的后果。 这个问题的最佳解决方案是，对于那些并非为了安全地进行子类化而设计和编写文档 的类，禁止其子类化。  《设计模式：可复用面向对象软件的基础》[10] 日文第 1 版 p.31 继 承 使 子 类 获 得 了 父 类 里 实 现 的 详 细 内 容， 因 此 说“ 继 承 破 坏 了 封 装 性 的 概 念”[Syn86]。子类的实现和父类的实现有着紧密的联系，因此改变父类的实现会对子 类产生非常强烈的影响。 （中间省略） 对于这点有一个挽救的方法，就是只继承抽象类。 对于“只继承抽象类”这个方法，其实在 Diksam 中已经实现了。 举个例子，在 UNIX 的经典 GUI 工具包 Motif 的类层级中，.PushButton（常 被称为 GUI 的按钮）是 Label 的子类。Label 具有显示一个字符串的功能，在定 义了继承 Label 的 PushButton 时，可以复用 Label 中的一些实现。 但是，后来出现的 Java 的 AWT 中，Label 和 Button 之间就不存在继承关 系了。并且，在 Swing 中作为 JButton、JMenuItem、JToggleButton 的超类 都引入了 AbstractButton 抽象类。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

8.2　设计 Diksam 中的类 2 4 5

* 具 体 来 说 就 是 MFC （Microsoft Foundation Class）。
* 在 Template Method 模式中经常会用到，为 了 显 式 地 表 现 出“ 这 里有需要在子类中修 改的地方”从而使 用 protected， 但 如 果只是用在这种用途 上， 我 觉 得 还 不 如 使 用 public。在使用设计 模式的时候，一般情况 下必须要有设计文档。

这样虽然会减少复用，却让随意地继承 Label（像 Motif）的方式成为了过 去。如果有通用的部分，就明确地定义抽象类，这种做法可以说是非常现代化的 方式。
从我的自身经验来讲，从零开始设计的部分，我从来没有想过要它继承具象 类。实际上在使用现存的 C++ 类库 * 时，会有“这个方法如果是 virtual 的就要 重写”的想法。这样一来，（对头文件来说）直接参考源代码去研究重写的时候， 会在不经意间陷入程序库的实现中。这与“把字段写成 public”的想法一样， 属于不健康的想法。
顺着这个思路，那么“仅子类可以访问”这个访问修饰符 protected 也可 以不需要。
至少在 C++、Java 和 C# 的思路中，访问修饰符是为了对自己（或自己的团 队）之外的开发人员隐藏实现而使用的（应该可以作为佐证的是，如果是同一个 类，那么即使是不同的实例，也可以相互引用 private 成员）。如果是这样的 话，也就没有理由减弱子类的访问限制了。但如果是自己创建的子类的话，可以 在包范围内进行访问（与 Java 一样，Diksam 也将包范围作为默认项）。如果想要 别人也可以创建子类的话，那就必须要公开了 *。
本节虽然介绍了不少内容，但仅代表我个人观点。而且我一直认为自由地决 定设计方案是语言作者的特权，因此大家在将来制作属于自己的编程语言时，也 可以采用你们自己认为最好的方式。
8.2.7 数组和字符串的方法

在 7.3.4 节中介绍过，在 Diksam.book_ver.0.2 中没有取得数组大小和字符串

长度的方法（method）。在引入了类的概念后，现在我们来实现这个方法。

要实现的方法如表 8-1 所示。

表中的 T 表示数组元素的类型，也就是说，可以使用 insert() 插入使用代

码 double[] a; 声明的数组，但只能是 double 型（这是当然的啦）。

表 8-1 数组和字符串的方法 

 目标  数组 数组 数组

 返回值类型  int void void

 方法名称和参数  size() resize(int new_size) insert(int pos, T item)

 功能  取得数组的元素数量 改变数组的大小 向数组中间插入元素

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 4 6 第 8 章　将类引入 Diksam

 目标  数组 数组 字符串
字符串

 返回值类型  void void int
string

 方法名称和参数  remove(int pos) add(T item) length()
substr(int pos, int len)

（续）
 功能  删除数组的元素 向数组末尾添加元素 取得字符串长度 截取从 pos 开始长度为 len 的 字符串

但由于在 Diksam 中数组和字符串并不是类，因此不能创建出继承它们的类。

8.2.8 检查类的类型
Diksam 和 Java 一样使用 instanceof 运算符。  instanceof 运算符用于判断某个实例是否属于某个类。
例如，继承了 Shape 的 Line 和 Circle。
Shape shape = new Line();
上 面 的 语 句 给 shape 赋 值 了 Line 的 实 例， 此 时 shape instanceof Line 返回真。当然，shape instanceof Circle 返回假。
但 是， 虽 然 shape instanceof Line 返 回 真， 但 是 返 回 真 的 也 不 仅 限 于 Line 的 实 例。 假 设 Line 存 在 子 类 ArrowLine， 并 且 shape 实 际 也 指 向 了 ArrowLine 的 话，shape instanceof Line 还 是 会 返 回 真。 这 就 是 instanceof 运算符“判断某个实例是否属于某个类”的含义。
instanceof 也可以用于判断实例是否实现了某个接口。obj instanceof Printable 如果为真，说明 obj 实现了 Printable。

8.2.9 向下转型
Diksam 可以将类向下转型。 Java、C# 等语言也可以向下转型，像下面这段代码。
Shape shape = new Line(); … Line line = (Line)shape;
只是，前置这种转换运算符的书写方式，在成员、数组、方法调用堆叠了很

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

8.3　关于类的实现——继承和多态 2 4 7

多层的时候，如果要进行转换，视线必须要回到左边。另外，在转型后如果要再 次引用其转型后的结果的话，外面必须要加上括号。.

// 取得 [piyo.foo[i].bar.fuga[j].getObj()] 的对象， // 向下转型为 Bazz， // 并取出其成员 hoge。 Hoge hoge = ((Bazz)piyo.foo[i].bar.fuga[j].getObj()).hoge;
C# 中存在后置转型运算符 as，但是由于优先级低，因此还是要使用括号。 由于这点不是很方便，因此在 Diksam 中使用了后置的转型运算符。书写方 式为 :: 类型名 :>。上面的例子在 Diksam 中写成了如下代码。

Hoge hoge = piyo.foo[i].bar.fuga[j].get_obj()::Hoge:>.hoge;

* 因 此， 在 例 如 Java 的 编程语言设计中，不叫 作“向下转换”而叫作 “缩小转换”（narrowing cast）。但是鉴于大家比 较习惯说“向下转换”， 因 此 Diksam 还 是 采 用 了这个说法。

另外，也可以实现从接口向下转型到接口。下面的例子中，Hoge 在实现 了 Serializable 的情况下可以成功转型。
Printable p = new Hoge(); Serializable s = p::Serializable:>;
这种做法在类的继承关系上并不存在“向下”转换。而且这个例子叫作“向 下转换”是否贴切也是个问题 *。

8.3 关于类的实现——继承和多态
实现类最应该关心的不就是继承和多态的实现方法吗？——不管别人是不是 这么想，至少我是。
因此，先把其他细节的话题放在一边，本章我们就来介绍一下 Diksam 中继 承和多态的实现。.
8.3.1 字段的内存布局
首先要考虑的是，在继承了其他类的情况下，字段在内存中的布局。 典型的例子就是，考虑创建类型 Line 和 Circle，并继承表示二维的“图形” 的类 Shape。Shape 中保存着“颜色”等图形的通用属性。在 Line 和 Circle 中， 也保存着表示各自图形的必备信息。图 8-4 中记载了这些类（图中对方法也进行

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 4 8 第 8 章　将类引入 Diksam

了描述，具体会在介绍多态时进行说明）。.

图 8-4 “图形”的继承结构 

Shape color:int get_color():int set_color(color:int) draw()

图 8-5 字段的存储方式

Line start_x:double start_y:double end_x:double end_y:double draw()

Circle center_x:double center_y:double radius:double draw()

图 8-4 中，Shape 中保存了用 int 型的“颜色编码”，Line 中保存了直线

的起点和终点。我想聪明的读者一眼就能看明白，start_x、start_y 是起点坐

标，end_x、end_y 是终点坐标，Circle 的 center_x、cengter_y 是原点坐

标，radius 是半径。

此时，字段数据的保存方式如图 8-5 所示，超类字段的后面紧跟着子类中增

加的字段。

Line 的字段 Circle 的字段

Shape 的部分 Line 增加的部分

color start..x start..y end..x end..y

color center..x center..y radius

Circle 增加的部分

使 用 这 种 存 储 方 式 的 好 处 在 于， 在 引 用 Shape 类 型 变 量 shape 的 字 段 shape.color 时，具体的对象实际上无论是 Line 也好，Circle 也好，它 们在引用 color 时的偏移量都是相同的。
如果出现了多继承的话情况就变得复杂了，但是由于 Diksam 的类只能单继 承，因此字段的储存也可以使用这种方式实现。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

8.3　关于类的实现——继承和多态 2 4 9

8.3.2 多态——以单继承为前提

继承，不仅要能引用字段，还必须要实现多态。回到图 8-4，Shape 中定义 了 get_color()、.set_color() 和 draw() 三个方法。其中 draw() 是 abstract 方 法，并且会在 Line 和 Circle 中重写。因此，只需编写代码就可以了。

shape.draw();

* 这里也不一定非要是 C 语言中所说的指针（内 存地址）。在 Diksam 中 就 是 DVM_VirtualMachine 中 保 存 着 的 Function 表的下标。

此时 shape 不论是 Line 还是 Circle，都会执行 draw() 方法。 限制为单继承的好处就在于容易实现。只需要让类的实例中保存着指向方 法实现的指针 * 数组即可。这里说的数组恐怕是原来的 C++ 用语，一般被称为 vtable（virtual.method.table 的简称）。 vtable 与类相对存在，同一类的实例指向同一个 vtable，并在 new 的时候将 vtable 传递给实例。由于 Shape 包含了三个方法，因此我们通过下面的列表来调 用 Shape 的方法。

●● get_color() 在 vtable 上的下标为 0 ●● set_color() 在 vtable 上的下标为 1 ●● draw() 在 vtable 上的下标为 2

原则是子类的 vtable 首先要具有和超类同样的内容。但在方法重写的情况下

会替换原有的位置，而在子类中增加方法的时候，子类的 vtable 也会变得比超类

的长（图 8-6）。

图 8-6 在单继承的情况下的 多态

Line 的实例
color start..x start..y end..x end..y

Shape 的 vtable

通常会复制同样的内容

Line 的 vtable

重写的时候会替换 原有的位置

Circle 的实例

Circle 的 vtable

color center..x center..y radius

如果在子类中增加方法， vtable 也会随之扩展

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 5 0 第 8 章　将类引入 Diksam

使用这个处理方式，缺点在于每次调用方法时都要引用 vtable，所以多少会 有些延迟。而优点在于不论类的继承关系有多深，或者类中的方法有多多，方法 调用的开销都是基本相同的。
C++ 只要在不使用多继承的时候，通常都是用这种处理方式实现继承的。 但 C 语言就不 可 能 用 这 个 处 理 方 式 实 现 继 承 和 多 态 了（GTK+、X-Window. Toolkit 等）。
Diksam 的类只能单继承，但是可以多继承接口。因此，对于字段来说是以单 继承为前提的，但是对于方法的调用来说，就不得不考虑多继承的情况。在多继 承时，vtable 的下标就失去了唯一性，也就无法用这种处理方式来应对了。.

8.3.3 多继承——C++

代码清单 8-6 C++ 的指针转换 

我们以 C++ 为例，看一下它是如何实现多继承的。. 细节的地方因处理器而 异，比如有继承了类 A 和 B 的类 C，首先 A 和 C 如果是“主要继承关系”的话， 那么不论是字段还是方法，都可以使用和单继承时相同的处理方式，但问题在于 C 的对象在被当做 B 引用（将 C 向上转型为 B）的时候。C++ 在此时会将指针本 身转换为 B 的 vtable 对应的地址。
这个现象可以在代码清单 8-6 中得到验证。.

1: #include <stdio.h>

2: 

3: class A {

4:

public:

5:

int a;

6:

virtual void a_method() {}

7: };

8: 

9: class B {

10:

public:

11:

int b;

12:

virtual void b_method() {}

13: };

14: 

15: // 继承了类 A 和类 B 的类 C

16: class C : public A, public B {

17:

public:

18:

int c;

19:

void a_method() {}

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

8.3　关于类的实现——继承和多态 2 5 1

 图 8-7 C++ 的多继承

20:

void b_method() {}

21: };

22: 

23: int main(void)

24: {

25:

C *c = new C();

26: 

27:

// 显示 new 过的变量 c 的指针

28:

printf("c..%p\n", b);

29:

30:

// 将其赋值到 B* 型的变量中，并显示

31:

B *b = c;

32:

printf("c as B..%p\n", b);

33:

34:

// 显示 A, B, C 各类中的成员变量（字段）的地址

35:

printf("&A->a..%p\n", &c->a);

36:

printf("&B->b..%p\n", &c->b);

37:

printf("&C->d..%p\n", &c->c);

38:

39:

return 0;

40: }

在我的环境中，输出结果如下（我的环境 int 和指针都是 4 个字节）。

c..0x804a008 c as B..0x804a010 &A->a..0x804a00c &B->b..0x804a014 &C->d..0x804a018

内存结构如图 8-7 所示。在将指针赋值给 B* 型的变量时，指针所指向的地

址发生了改变。可以确认在 A 的字段 a 和 B 的字段 b 之间存在着 B 的 vtable 占用的

内存空间。.

c 作为 A 或者 C 被 引用时的指针

0x804a008

c 作为 A 或者 C 被引用时的 vtable

被向上转型为 B 的时 候指针指向了这里

0x804a00c A 的字段 a 0x804a010

c 作为 B 被引用时的 vtable

0x804a014 B 的字段 b

0x804a018 C 的字段 c

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 5 2 第 8 章　将类引入 Diksam

在 C++ 中， 只 有 这 样 的（自 动 的 ） 转 换 才 可 能 改 变 指 针 的 值，C 像 是 通 过 void* 保存了对象，给人的感觉非常不好——其实我也有过这样的经历，当 然这是题外话。
如果在向上转型（通常向上转型是自动进行的）为 B 的时候移动指针，不但可 以用普通的方式引用到 B 的字段，由于 vtable 也是各自保存的，因此就实现了多态。
只是在 Diksam 中，如果移动了指针的话会给 GC 的实现带来困难。现在的 Diksam，指向堆的指针类型是 DVM_Object*，但如果像 C++ 一样移动指针的话， 就会由于没有指向最初的 DVM_Object 而给 GC 的标记阶段造成麻烦。另外，由 于 Diksam 不能多继承字段，如果使用 C++ 的处理方式就显得有点过度设计了。.

8.3.4 Diksam 的多继承

在 Diksam 中采用了如下的处理方式。

●● 不是在对象的开头部分保存 vtable，而是在引用了对象的值中。这样既保存了指向 对象本身的引用，同时也保存了指向 vtable 的引用。
●● 在向上或者是向下转型时，替换引用值中的 vtable 就可以了。

在 Diksam 中， 值 被 保 存 在 DVM_Object 联 合 体 中， 并 且 使 用 DVM_ ObjectRef 结构体引用其中的对象。.

typedef union { int double DVM_ObjectRef
} DVM_Value;

int_value; double_value; object;

 DVM_ObjectRef 定义如下。

/* 值为整数时 */ /* 值为实数时 */ /* 值为对象时 */

typedef struct { DVM_VTable *v_table; /* vtable 的指针 */ DVM_Object *data; /* 数据本身 */
} DVM_ObjectRef;
在 8.3.2 节中介绍了在 Diksam 中类继承的处理方式——使用 vtable 实现多 态，并且在转型为接口的时候替换引用值中的 vtable（DVM_ObjectRef 的 v_ table 成员）。
当然，基于上面的处理方式也会出现对象不知道自己原本是什么类型的情

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

8.3　关于类的实现——继承和多态 2 5 3

图 8-8 Diksam 的多继承

况，因此在 vtable 中保存了指向对象原本类型的指针。.

struct DVM_VTable_tag {

ExecClass *exec_class; /* 指向类的指针 */

int

table_size; /* vtable 的元素数 */

VTableItem *table;

/* vtable 本身 */

};

其中叫作 ExecClass 的类型就是保存类在运行时信息的类型，每个类只对 应一个，在 DVM_VirtualMachine 中以数组的方式保存（这个数组的创建时机 请参考 8.4.7 节）。.

typedef struct ExecClass_tag {

DVM_Class

*dvm_class;

ExecutableEntry

*executable;

char

*package_name;

char

*name;

DVM_Boolean

is_implemented;

int

class_index;

struct ExecClass_tag *super_class;

DVM_VTable

*class_table;

int

interface_count; ←请注意这个地方

struct ExecClass_tag **interface;

←和这个地方

DVM_VTable int DVM_TypeSpecifier } ExecClass;

**interface_v_table; field_count; **field_type;

如图 8-8 所示（在图中省略了接口的 ExecClass）。

DVM_Value 值本身保存着 指 向 vtable 的指针和指向 数据的指针

VTable

vtable 本身

ExecClass

字段的数据

指向接口 vtable 的数组
类实现了多少，接口就 要保存多少 vtable。在 向上转型的时候将这个 数组的下标作为操作数， 用于替换 DVM_Value 中 的 vtable

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 5 4 第 8 章　将类引入 Diksam

如此一来，在向上转型的时候，要找到相应的 vtable 并替换 DVM_Value 中 的（DVM_ObjectRef 的）v_table 成员。在使用 up_cast 指令（将在后面的 章节介绍）时，这个接口的数组下标将会作为操作数进行传递。

* 由于 Java 的 class 文件中
成员名字是字符串，因
此发生在加载 / 链接时。

  补充知识    无类型语言中的继承 
作为像 Diksam 和 C++ 这样的静态类型的语言，不论是引用字段的时候还是调用 方法的时候，都能够一下子引用到在编译时 * 就已经决定的索引值。多继承的情况则 更加复杂，但不论怎样都可以使用“固定的开销”引用到字段或者方法，这点是没有变 化的。
与此相对，在像 Ruby 这样没有变量类型的语言中，a.hoge 语句（单纯的实现） 由于在编译时并不知道 a 的类型，没有办法一下子就访问到索引值，因此必须要利用成 员名字进行搜索。也就是说，根据成员数量不同，检索需要的时间也不同，所以引用成 员时就不是“固定的开销”了。
尽管如此，如果使用二分法检索（假如有 1000 个成员的话，用 10 次以内的循环 就可以完成）的话，也可以看作是“固定的开销”。

8.3.5 重写的条件

重写是在调用超类的方法时，实际被调用的是（也许是）子类的方法。从调

用者看上去好像调用的是超类的方法，但是实际上调用的却是子类的方法，而这

个子类的方法说不定会让调用者吓一跳。

例如，子类方法的返回值类型要比超类的“窄”（被称为 共变 ，covariant）。

当超类有以下方法时，如果子类要对其进行重写的话，子类的 getShape() 方

* 当然，null 是个例外。

法不能返回 Shape 以外的类型 *。

Shape getShape();

子 类 的 返 回 类 型 只 要 是 比 超 类“窄 ” 就 算 合 法。 也 就 是 说， 像 下 面 这 样 将 Shape 的子类作为返回值的重写是合法的。

// Circle 如果是 Shape 的子类的话，这个方法就是合法的 Circle getShape();

这种情况下，子类的 getShape() 方法一定只能返回 Circle 类型。但是在调 用者，期待的是比 Circle 更“宽”的 Shape 类型，这是没有问题的。相反，如果 期待的是 Circle，返回的却是其他 Shape（Line 或者 Rectangle）的话，真的

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

8.3　关于类的实现——继承和多态 2 5 5
会被吓一跳吧。 像 这 样 将 返 回 值 共 变 的 好 处 有 很 多， 比 如 限 制 了 Java 中 Object 类
的 clone() 方法的返回值，以减少不必要的转型。Java 从 JDK1.5 开始具备这个 功能。
在 Diksam 中，参数的情况却是相反的。子类方法的参数类型要比超类的 “宽”（被称为 反变 ，contravariant）。在超类中有如下方法时：
void drawShape(Circle circle);
在子类中可以合法地定义如下方法：
void drawShape(Shape shape);
子类的 drawShape() 能接受的参数，超类的 drawShape() 应该也能接 受，这样的话调用者就不会被吓一跳了。
至于访问修饰符，子类的方法必须要比超类的“宽松”。public 的方法不能 被重写为 private 的，反之则合法。
9.2.3 节会为 Diksam 引入异常的概念，Diksam 的异常处理属于 Java 风格的 异常检查（把方法中可能抛出的异常全部用 throws 列出，并由编译器检查）。 这种情况下，子类的方法不能比超类抛出更多的异常。
让我们再说回参数，Diksam 在编译器进行静态检查时允许反变是非常方便的 设计，但是在实际应用中，有时也需要同时允许共变的存在。假设 Shape 有设 置样式的 setStyle(Style style) 方法，Line 和 Circle 需要的样式也应该 是根据不同图形定制的 Style 的子类——但是，如果实现了这项功能的话，一 定要在调用 Shape 的 setStyle() 时进行一些运行时检查。
相似的话题在 7.3.2 节的补充知识中已经作过介绍，在 Java 中假设存在超 类 Shape 和子类 Circle，那么 Circle 的数组会自动成为 Shape 数组的子类。 这个设计可能会引发叫作 ArrayStoreException 的运行时错误。
如果将 Shape[] 和 Circle[] 看作是类的话，就应该能看出来它们是共变 参数的一种。
// 将“Shape 数组”看作是类 class ShapeArray {
// 取得数组元素的方法 Shape get(int index); // 设置数组元素的方法 void set(int index, Shape shape);
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 5 6 第 8 章　将类引入 Diksam
} // CircleArray 是 ShapeArray 的子类 class CircleArray extends ShapeArray {
// 返回值的共变 → 没问题 Circle get(int index); // 参数类型的共变 → 必须进行运行时检查 void set(int index, Circle circle); }
8.4 关于类的实现
本节将要介绍的是在类的实现中除了继承和多态的部分。
8.4.1 语法规则
Diksam 在声明变量的时候和 Java 相同，形式如下所述：
类型 变量名 ;
我们在 6.1.5 节中曾提到，有些语言是将类型写在后面的。
// 以 ActionScript 为例 var a:int;
将类型写在后面的语法结构在制作语法分析器时会非常轻松，但是在 Diksam 中，使用了 C 和 Java 程序员习惯的语法结构，即将类型写在前面——这么做了才 知道，这是一条坎坷的路。
如果以“类型 变量名；”的语法进行声明，在一开始就能得到“类型”，从 而一下子就可以知道这是一条声明语句，但也只有 int 和 double 可以作为保留 字，Point 之类的类名字就不能够成为保留字了。因此，只看这个是不能知道类 名字的。yacc 虽然会预读一个符号，但是，例如下面这样的数组声明，
Point[] p;
即使是预读了 Point 后面“[ ”也不能搞清以下两点： ●● 是数组型变量 Point 要通过 [] 引用元素？ ●● 还是要声明 Point 类的数组？
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

8.4　关于类的实现 2 5 7
在 C 中，要想使用类型 Point，就必须要在使用的地方前面声明这个类型。 在这种语言中使用的处理方式是：在声明的时侯把类型由解析器传递给词法分析 器，词法分析器随后把它登记为标识符，之后的 Point 就会被当做类型名称来处 理。但是，作为一门当下的编程语言来说似乎不太雅致。在 C 语言中，为了表现 诸如 Husband 引用了 Wife，Wife 又引用了 Husband 这样的相互引用，不得不 使用“预先声明结构体标签”的怪异方法。
因此，Diksam 的语法规则如下：
declaration_statement : type_specifier IDENTIFIER SEMICOLON ←省略了初始化等操作 ;
type_specifier : basic_type_specifier ←表示 int、boule 等基本类型 | array_type_specifier | class_type_specifier ←表示类名 ;
array_type_specifier : basic_type_specifier LB RB | IDENTIFIER LB RB | array_type_specifier LB RB ;
class_type_specifier : IDENTIFIER ;
看了上面这段代码，可能有人会想了：. 等等。刚才不是说即使预读了 Point 后面的一个符号也搞不清楚它到底是变量名还 是类名吗？但是在这个规则中不是很明显地告诉你如果只有一个 IDENTIFIER 的话 就是 class_type_specifier 吗？
这个语法规则的重点在于引入了 array_type_specifier。如 7.2.1 节中 所述，在引入类之前，数组声明语法如下：
type_specifier : basic_type_specifier | type_specifier LB RB ;
在引入了类之后，我认为与 basic_type_specifier 一起处理会更好。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 5 8 第 8 章　将类引入 Diksam

type_specifier

: basic_type_specifier

| IDENTIFIER

←增加了这行代码

| type_specifier LB RB ;

但是，还是像前面说的，在预读了 IDENTIFIER 后的“[ ”后，yacc 就会因 为不知道是把它当做要引用数组元素继续 shift 好，还是当做 type_specifier 进 行 reduce 好而发生错误。顺带提一下，引用数组元素的规则如下：

primary_no_new_array : primary_no_new_array LB expression RB | IDENTIFIER LB expression RB ;

不过，引入了 array_type_specifier 后，即使预读到了“[ ”也不会 进行归约，因而也不会进行归约 / 归约冲突和移进 / 归约冲突。当然，现在还是 搞不清楚到底是在 array_type_specifier 中，还是在 primary_no_new_ array 中。在看到了代码清单 2-5 的 y.output 的后半部分中一并记载了多个规则 就能明白，yacc 的状态可以跨越多个规则，并不会引发问题。.

8.4.2 编译时的数据结构

函 数 在 编 译 时 被 保 存 在 FunctionDefinition 结 构 体 中， 然 后 被 复 制 到 DVM_Executable 中的 DVM_Function 结构体。类保存在编译时的数据类 型 ClassDefinition 和 DVM_Executable 的 DVM_Class 中。
对于从开头一直读到这里的读者，我想就没有必要太过详细地介绍了，还是 一笔带过吧。
首先是编译时的数据结构 ClassDefinition。

struct ClassDefinition_tag {

DVM_Boolean is_abstract;

DVM_AccessModifier access_modifier;

DVM_ClassOrInterface class_or_interface;

PackageName *package_name;

char *name;

ExtendsList *extends;

←fix 之前的临时数据结构

ClassDefinition *super_class; ExtendsList *interface_list;

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

8.4　关于类的实现 2 5 9

MemberDeclaration *member; ←成员 int line_number; struct ClassDefinition_tag * next; };
这个结构体中值得注意的地方是，成员 extends 是一个在 create.c 中被构 建后，又在 fix_tree.c 中被抛弃的临时数据结构。在 Diksam 中，继承类和接口 时，没有使用 Java 的 extends 和 implements 风格，而是使用了 C++ 和 C# 的 冒号，因此（一开始）无法区分类和接口。这里先姑且加入一个 extends 成 员， 之 后 将 在 fix_tree.c 中 分 为 super_class 和 interface_list（fix_ extends() 函数）。  member 保 存 了 类 的 成 员。 类 成 员 的 字 段 和 方 法 以 联 合 体 的 形 式 被 保 存 在 MemberDeclaration 结构体中。

struct MemberDeclaration_tag { MemberKind kind; DVM_AccessModifier access_modifier; union { MethodMember method; FieldMember field; } u; int line_number; struct MemberDeclaration_tag *next;
};
先看一下字段的定义。

typedef struct { char TypeSpecifier int
} FieldMember;

*name; *type; field_index;

 name 和 type 表示字段的名称和类型。 这里要稍稍介绍一下 field_index。在 DVM 中，各个对象的字段的数据都
以 DVM_Value 数组的形式保存。这里的 field_index 就是这个数组的下标， 在 fix_tree.c 中进行设置。
继承类的时候，超类的字段会由子类继续持有（如图 8-5）。MemberDeclaration 结构体的列表只含有当前类的成员，并不包含超类的成员，但 field_ index 却和超类的字段含有的通用的编号。
在 Diksam 中就是像这样，在编译时指定字段索引值。这是因为 Diksam 中并

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 6 0 第 8 章　将类引入 Diksam

没有相当于 Java 的 class 文件这样的产出物。如果字节码保存在文件中的话，类 中的字段增加，索引值也可以在文件中随之增加，但是却做不到上面的方法。在 Java 的字节码中指定的并不是字段的索引值，而是字段的名称。.
接下来是方法。

typedef struct { DVM_Boolean DVM_Boolean DVM_Boolean DVM_Boolean FunctionDefinition int
} MethodMember;

is_constructor; is_abstract; is_virtual; is_override; *function_definition; method_index;

首先 method_index 和 field_index 一样，是一个包含了超类方法的通用 编号。但是，在实现了接口方法的时候，这个方法的 method_index 只在接口 之间通用。换句话说，它就是 vtable 的下标（如图 8-8）。
另外，如代码所见，MethodMember 中包含了指向 FunctionDefinition. 的指针。就是说，对于 Diksam 来说，方法也不过就是函数（稍有不同），它被注 册在 FunctionDefinition 中的同时也会创建 DVM_Function。  FunctionDefinition 中增加了从方法能够追溯到类的 ClassDefinition. 的指针。如果这个成员为 NULL 的话，就说明它不是方法而只是普通的函数。

struct FunctionDefinition_tag { ···前面省略··· ClassDefinition *class_definition; ←指向类的指针
···后面省略··· };

8.4.3 DVM_Executable 中的数据结构

编译完成后就要生成 DVM_Executable 了，这里使用了 DVM_Class 结构 体来保存 DVM_Executable 中的类。

 DVM_Class 在 DVM_Executable 中以下面这种可变长数组的形式保存。

struct DVM_Executable_tag { ... 前面省略 ...

int

class_count;

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

8.4　关于类的实现 2 6 1

DVM_Class *class_definition; ··· 后面省略 ··· };

DVM_Class 结构体的定义如下所示。

typedef struct { DVM_Boolean DVM_AccessModifier DVM_ClassOrInterface char char DVM_Boolean DVM_ClassIdentifier int DVM_ClassIdentifier int DVM_Field int DVM_Method
} DVM_Class;

is_abstract; access_modifier; class_or_interface; *package_name; *name; is_implemented; *super_class; interface_count; *interface_; field_count; *field; method_count; *method;

上面的代码中出现了 DVM_ClassIdentifier，它是由包名和类名组成的类 型。这个类型可以保存超类和（实现了的）接口。
字段和方法都是以可变长数组的方式保存的。DVM_Class 中保存的只有当 前类中的定义，并不包含超类的部分。
保存字段的 DVM_Field 的定义如下。其中成员所表示的含义都显而易见。

typedef struct { DVM_AccessModifier char DVM_TypeSpecifier
} DVM_Field;
方法也是一样。

access_modifier; *name; *type;

typedef struct { DVM_AccessModifier DVM_Boolean DVM_Boolean DVM_Boolean char
} DVM_Method;

access_modifier; is_abstract; is_virtual; is_override; *name;

并且，方法“差不多”是普通的函数，只是在动作上有细微的不同，因此 在 DVM_Function 中保存了它是不是方法的标识符（下面的 is_method）。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 6 2 第 8 章　将类引入 Diksam

typedef struct { DVM_TypeSpecifier char char int DVM_LocalVariable DVM_Boolean DVM_Boolean
· · · 后面省略 · · · } DVM_Function;

*type; *package_name; *name; parameter_count; *parameter; is_implemented; is_method; ←增加了这个成员

方法的函数名以 类名 # 方法名 的方式保存在 DVM_Function 的 name 成员 中。例如 Point 类的 print() 方法，在 DVM_Executable 的时候也可以看作 是名称为 Point#print、is_method 为 true 的普通函数。当然，解析器是不 允许函数名中包含 # 的，因此，使用者即使自己写了名为 Point#print() 的函 数，也不能在自己的程序中通过 Point#print() 的方式调用。.

8.4.4 与类有关的指令

随着引入了类的概念，DVM 中也增加了相关的指令，如表 8-2 所示。下面 的 object 型为字符串、数组、类对象的总称（在表 7-1 中为字符串和数组的总 称，这次增加了类的对象）。
表 8-2 随着引入类而增加的指令

 指令 

 操作数类型   含义 

 栈动作 

push_field_int

short

根据操作数（即索引值）取得栈顶对象 的属性（int 型）值，并将其入栈

[object]→[int]

push_field_double short

根据操作数（即索引值）取得栈顶对象 的属性（double 型）值，并将其入栈

[object]→[double]

push_field_object short

根据操作数（即索引值）取得栈顶对象 的属性（object 型）值，并将其入栈

[object]→[object]

pop_field_int

short

用栈顶的值（int）赋值给栈顶的对象中 与操作数（即索引值）对应的属性

[int object]→[]

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

8.4　关于类的实现 2 6 3

 指令 

 操作数类型   含义 

 栈动作 

（续）

pop_field_double

short

用栈顶的值（double）赋值给栈顶的对 [double object]→[]
象中与操作数（即索引值）对应的属性

pop_field_object

short

push_method

short

new

short

用 栈 顶 的 值（object1） 给 栈 顶 的 对 象中与操作数（object2）对应的属性 赋值

[object1 object2] →[]

根 据 操 作 数（ 即 索 引 值 ） 取 得 栈 顶 对 象 的方法的索引值，并将其入栈（请参考 8.4.5 节）

[object]→[object int]

创建与操作数（即索引值）对应的类的 实例，并将它的引用入栈。此时并不会 调用构造方法，因此接下来会另外创建 构造方法的调用代码

[]→[object]

up_cast

short

将栈中的对象引用的 vtable 替换为操作 数指定的接口（请参考 8.3.4 节）

[object]→[object]

down_cast

short

检 查 栈 上 的 对 象 引 用 是 否 能 向 下 转 型， 并在此基础上将它的 vtable 替换为操作 数指定的接口的 vtable（请参考 8.4.9 节）

[object]→[object]

duplicate_offset super instanceof

short short

从栈顶取得操作数指定个数的元素，将 []→[object]
其复制并入栈 将栈顶的对象引用的 vtable 替换成其父类的 [object]→[object] 返回栈顶的对象是否属于操作数（即索
[object]→[boolean] 引值）指定的类型

访问字段的指令，把字段的索引值作为操作数传递就可以了。这里的字段值 指的是保存在 FieldMember 结构体中的 field_index。
除此之外的指令将在后面的章节中介绍。

  补充知识    方法调用、括号和方法指针 
在 Diksam 中调用方法或函数的时候，会像 p.get_x() 这样使用括号。即使方法 中一个参数都没有，括号也不能省略。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 6 4 第 8 章　将类引入 Diksam

* 在 Ruby 中即使有参数
也可以省略括号。

但是，根据语言的不同，有的括号也是可以省略的。例如在 Eiffel 的语言中一个参 数都没有的时候就可以省略掉括号 *。这种做法的优点只是单纯地改善了外观问题，节 约了录入量。
在 Java 和 C++ 中，为了实现封装，普遍的做法是将字段设置为 private，然后 再像下面这样编写访问器（accessor）。
public double get_x() {  return x; }
这里将来可能会发生变化，例如也许不会把 x 单单作为字段保存，而是将计算后的 结果返回去。考虑到这种情况，创建访问器的方法比起把字段设置为 public 公开出去 要好。但是，编写访问器是一件非常麻烦的事。
在这点上 Eiffel 的做法是，最初的字段是公开的，如果中途想要修改为在计算后再 返回结果的话，此时可以定义一个名字为 x 的方法替换掉最初公开的字段。不论是字段 还是方法，从使用者的角度来看都是 p.x，这种做法达到了在不影响使用者的前提下将 字段替换为方法的目的。
说起替换 x，在 Eiffel 中默认是不能使用 p.x 为其赋值（使用“.”对字段进行引用 时不能作为左值）。因此，每个字段的访问器都是在一开始就强制创建的。我很同意这 种做法，从外部改变字段的值是件大事，因此必须编写方法来实现 A。
我认为这是一个不错的主意，但在 Diksam 中并没有使用。原因是，采用了这种方 式的话方法本身就不能再作为值被处理了。
// set_on_click方法中传递了对象o的方法作为参数。 button.set_on_click(o.method);
上面的代码注册了一个事件，在按下 GUI 的按钮时相当于调用了 o.method()。 设想一下，如果把方法指针用作事件句柄或者回调方法的话，会发现调用 o.method 方 法是件困难的事情（因为要向 set_on_click 传递 o.method() 的执行结果）。
将方法自身作为值处理的功能，将在 9.5.4 节中实现。

8.4.5 方法调用
Diksam 中 push_method 指令用于在考虑了多态的情况下，决定被调用的 方法。  push_method 与 push_function 把函数入栈的功能相似，是把方法入栈。 实际上被推入栈中的也和函数一样，是 DVM_VirtualMachine 中 Function 类
A　意思是让编程人员知道自己开放了哪些字段是可以从外部赋值的。——译者注

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

图 8-9 方法调用

8.4　关于类的实现 2 6 5

型 的 对 应 表 的 索 引 值。 作 为 操 作 数 的 索 引 值， 跟 字 段 的 情 况 差 不 多， 是. MethodMember 结构体的 method_index。push_method 会根据栈中的对象 和 method_index，在考虑到多态的情况下选择适当的函数。  push_method 在选择了适当的方法之后就要进行调用了，这个动作与调用 普通的函数基本相同，使用的指令也都是 invoke。
Diksam 的函数调用已经在 6.4.3 节中介绍过了。 但是，在调用方法的时候，必须要将目标对象传递给方法。在被调用的方法 中这个对象将被作为 this 进行引用。 在 Diksam 中 this 作为最后一个参数传递给方法。如图 8-9 所示。

base
因为增加了 this，局部 变量中以 base 为基准 的偏移量也增加了 1

1 2 3 this 返回信息 （返回地址等） 局部变量 1 局部变量 2 局部变量 3

函数调用者在运算 时使用的栈
参数
this 作为最后一个 参数被传递给方法

增长方向
在 Diksam 中，参数按照从前往后的顺序入栈，此时 this 是最后一个参数， 成为了栈的顶端。因此，push_method 的时候可以引用 this 选择方法。
另外，如图 8-9 中所示。局部变量的偏移量也因为增加了 this 而增加了 1。 这个调整在加载时进行（请参考 load.c 的 convert_code() 函数）。
在 new 时调用的构造方法多少会有些不同，操作步骤如下：
1. 首先，创建对象并将其引用入栈。 2. 将构造方法的参数按照从前到后的顺序入栈。 3. 使用duplicate_index指令将1.中创建的对象引用复制到栈的顶端。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 6 6 第 8 章　将类引入 Diksam
4. 使用invoke指令调用方法。 5. 最后，在栈中只留下了1.中入栈的对象引用。
8.4.6 super
Diksam 和 Java 一样，有 super 关键字。使用它可以调用到 this 的超类的 方法。
在 Diksam 中 super 的实现非常简单，只将 this 指向的 DVM_ObjectRef 的 vtable 替换成超类即可。
但是，并没有把让 super 保存在其他变量中的使用方法考虑在内（如“p = super;”）。因此，除了 super.方法名 () 以外的形式，其他在编译时都会报错。
并且，在 Diksam 中超类的构造方法并不能通过 super() 的形式调用，而是 必须要使用 super.initialize() 的形式。在 Diksam 中，不显式地指定构造 方法名称的话，就不能知道调用的是哪个构造方法。
8.4.7 类的链接
类与函数相同，也会引用多个文件，因此必须要进行链接。 这里的结构和函数的基本相同。下面进行简单地介绍。 在 8.4.3 节中提到过，DVM_Executable 中保存着 DVM_Class 的数组。new 指令以操作数的形式保存着类的索引值，这个索引值就是 DVM_Executable 中 DVM_ Class 的下标。因此，即使没有在当前代码中定义，只是单纯被使用到的类也会被 注册到 DVM_Class 数组中，而且这样的类，它的 is_implemented 为 false（请 参考 8.4.3 节）。 将 DVM_Executable 加载到 DVM 的时候，push_function 的操作数将 会替换为 DVM 内的下标（请参考 6.4.1 节）。类的话，new 的操作数将会被替换 为 DVM 内的下标（load.c 的 convert_code() 函数）。 这里说的“DVM 内的下标”是指 DVM_VirtualMachine 中 ExecClass 数 组 的 下 标。ExecClass 创 建 于 加 载 包 含 类 的 源 文 件 的 时 候， 同 时 也 会 扩 展 ExecClass 数组（load.c 的 add_classed() 函数）。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

8.4　关于类的实现 2 6 7
 is_implemented 为 false 的 DVM_Class 会在此时嵌入方法的实现。.
8.4.8 实现数组和字符串的方法
如同在 8.2.7 节中写到的，Diksam 的数组和字符串有不少内建方法。 不 论 是 数 组 还 是 字 符 串 在 创 建 对 象 的 时 候， 都 在 引 用 对 象 的 DVM_ ObjectRef 中以保存硬编码 vtable 的方式实现。在这个 vtable 中注册了数组或 者字符串方法的（原生方法）实现。 这样就可以在运行时调用方法了，但在编译时必须要进行参数检查。最麻烦 的是，例如确定数组的 insert() 方法中第 2 个参数（要插入的数组元素）的类 型。int 数组第二个参数必须是 int，Point 类的数组则必须是 Point。 认真考虑这个问题的话，就会想到 Java 的泛型（Generics）和 C++ 的模板 这些功能。但是，现在没有必要只是为了数组使用这么复杂的处理方式，用 下面的方式也可以解决（保存一个包含了内建方法参数的类型信息的数组） （ fix_tree.c）。
/* 参数的类型和数量保存在 static 的数组中 * DVM_BASE_TYPE 表示数组元素的类型。 */
static DVM_BasicType st_array_size_arg[] = {}; static DVM_BasicType st_array_resize_arg[] = {DVM_INT_TYPE}; static DVM_BasicType st_array_insert_arg[] = {DVM_INT_TYPE, DVM_BASE_TYPE}; static DVM_BasicType st_array_remove_arg[] = {DVM_INT_TYPE};
虽然我觉得这么做不太优雅，但还是在 DVM_BasicType 中加入了奇怪的元 素（DVM_BASE_TYPE）。
8.4.9 类型检查和向下转型
类的类型检查（instanceof）和向下转型其实是两个相似的功能。向下转 型在执行时也会进行和 instanceof 相同的类型检查。
因此，instanceof 和 向 下 转 型 可 以 看 作 是 编 译 时 进 行 的 检 查。 首 先， Diksam 中存在着类和接口，在 A instanceof B 的时候，会出现以下几种 情况。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 6 8 第 8 章　将类引入 Diksam

 A  类 接口 类 接口

 B  类 类 接口 接口

只有在 A 和 B 为同一类，或 A 是 B 的超类时，才有可能返回真。 只有在 B 实现了 A 的情况下，才有可能返回真。 在 A 的子孙中只要有实现了 B 的，通常会返回真。 对象实现了 A 和 B 两个接口的时候，通常会返回真。

也就是说，instanceof 的右边指定了类的时候，编译时会因为绝对不会为 真的 instanceof 而导致错误。向下转型时也是一样，如果类之间没有继承关 系的话也不可能进行向下转型。
更为重要的是，在 Diksam 中，绝对为真的 instanceof（同类之间的和与 超类进行的 instanceof）、向超类的转型也会导致编译错误。我认为，没用的 代码最后会导致 bug，在编译时应该阻止这种情况发生。
运行时的检查，将在 ExecClass 结构体中遍历所有超类和接口（因此，速 度不是很快）。
向下转型的时候，在进行了和 instanceof 同样的检查后，如果转型目标 是类，就将引用中保存着的 vtable 替换为目标类的 vtable。如果转型目标是接口 的话，就用目标接口的 vtable 替换。

  补充知识    对象终结器（finalizer）和析构函数（destructor） 

* 这里采用了 Java 的说法。

在 Java、C++、C# 等语言中，类对象销毁时可以通过用户程序得知。具体来说， 在对象销毁时，Java 会使用终结器，C++ 和 C# 则会调用被称为析构函数的方法。
但是，Diksam 中没有这个功能。姑且不论必须完全由编程人员控制对象寿命的 C++，和可以预测对象销毁时机的 Python（使用基本的引用计数器类型 GC，在不创建 循环引用的前提下），Diksam 这样的语言中即使创建了对象终结器 * 也没有什么作用。
对象终结器的用途，比如说用来关闭在 C 中 fopen() 返回文件的指针。因为能够 打开的文件数（译注：文件句柄）在进程中是有上限的，所以使用 fopen() 打开的文 件在用完后应该立即关闭。但是这个处理如果要交给对象终结器的话，它也不知道要何 时进行哪些操作（特别是 Java 中连有没有进行动作都不知道）。说不定在处理开始前， 所有的文件句柄就已经用光了。所以说这种做法不保险。
如果像上面说的那样，我想还是不要定义对象终结器。如果能够简单地实现对象终 结器的话，也许效果会更好。但是，实际上想要优雅地实现对象终结器并非易事。
也许有人会想，“嗯？释放对象空间之前，不是只会调用 finalize() 方法吗？” 如果在对象终结器中把 this 赋值给了全局变量或者其他东西的话怎么办？
垃圾回收器会根据“不能被追溯到的对象”这一原则来判断对象是否不被需要。但

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

8.4　关于类的实现 2 6 9 是，在对象终结器中将 this 赋值给了全局变量的话，此时这个对象就可以从全局变量 中被追溯到，以至于不能被释放了。
Java 的 GC 也不得不面对这个问题。目前已知的是如果使用了对象，终结器会使 GC 的效率大幅下降。
另外，crowbar 和 Diksam（book_ver.0.4）中，对于指向原生指针类型的对象来 说，可以使用原生函数实现对象终结器。编写原生函数多少会包含一些危险的处理，因 此不得不考虑到，如果对在原生函数中悄悄地把对象释放了，然后又被其他程序引用的 话就会导致崩溃，那么只能后果自负了。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

第9章
应用篇
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 7 2 第 9 章　应用篇
9.1 为 crowbar 引入对象和闭包
在第 8 章中为 Diksam 引入了类，但是目前的 crowbar 还不支持面向对象 功能。
而在当今的编程语言中，大有如果不支持面向对象就不会被认可的架势，因 此也要让 crowbar 支持面向对象。
但是，crowbar 的面向对象与 Diksam、C++、Java、C# 等相比会有一些不同。 它没有类的概念。
本节将要介绍的，就是 crowbar 的面向对象具体是怎样设计和实现的。.
9.1.1 crowbar 的对象
像前面提到的，crowbar 中没有类的概念。因此，创建对象的时候也不需要 指定类和使用 new 指令，只是单纯地调用原生函数 new_object() 即可。.
o = new_object();
crowbar 中的对象与 C 对象的结构体相同，也可以保存 成员 。但是，由于没 有类声明也没有结构体声明，因此成员将在运行时以赋值的方式增加。
p = new_object(); p.x = 10; p.y = 20; print("p..(" + p.x + "," + p.y + ")\n");
肯定有人会说（我必须承认我也是其中一员）：“没有类型声明感觉真是别 扭。”但起码这个方式实现了类似 C 的结构体的功能。
并 且， 与 Diksam、Java 一 样， 这 个 对 象 也 是 引 用 类 型 的， 使 用 new_ object() 返回了一个指向对象的引用。因此，下面的代码将输出 20。
o1 = new_object(); o1.hoge = 10; o2 = o1; o2.hoge = 20; print(o1.hoge);
上面这段代码的内存映像如图 9-1 所示。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

9.1　为 crowbar 引入对象和闭包 2 7 3

图 9-1

o1

crowbar 的对象是引用

类型

o2

hoge 20

9.1.2 对象实现

首先，关于“对象”这个词无论是在 crowbar 中还是在 Diksam 中，都是指

“在堆中被创建的”字符串、数组、类的“对象”。像 crowbar 的 CRB_Object、

Diksam 的 DVM_Object 结构体，这些都是通过联合体保存的“在堆中被创建的

对象”。

在 Diksam 中，堆中类的实例的对象被称为“类对象”或者“类的实例”。但

是，crowbar 中并没有类的概念。

对于使用者来说，应该把数组叫作数组，把字符串叫作字符串才对吧。因

此，new_object() 函 数 返 回 的 也 应 该 叫 作“对 象 ”。 但 是， 从 crowbar 的 实

现上来看，由于已经引入了叫作 CRB_Object 的结构体，因此不得不给 new_

object() 返回的东西起一个其他的名字。

这里把这个东西叫作 assoc。assoc 是 关联数组（   associative.array）的简称。

* 在 Perl 的 ver.4 中 还 是 叫 作“ 关 联 数 组 ”， 但 从 ver.5 开始就叫作“哈 希”了。我认为哈希只 不 过 是 一 个 实 现 方 式， 因 此 还 是“ 关 联 数 组 ” 的名字更为贴切。
* 现在作为键的字符串 还 不 能 使 用 变 量， 因 此还不能作为关联数 组投入使用。顺便提一 下，JavaScript 中 可 以 使用 [] 访问数组元素， 因此可以作为关联数组 使用。

之所以被称为关联数组（最近不知道为什么有很多语言叫它“哈希”*），是 因为它是可以以字符串（等）为键从中取出值来的数组。正是由于可以以字符串 为键取值这点，crowbar 的对象最终使用了关联数组的方式 *。
assoc 的结构体定义如下（crowbar.h）。

typedef struct {

char

*name;

CRB_Value value;

CRB_Boolean is_final; ←现阶段不需要在意它。

} AssocMember;

struct CRB_Assoc_tag {

int

member_count;

AssocMember *member;

};

assoc 的成员是名称和值的组合，因此 assoc 中只保存了 AssocMember 的可 变长数组。AssocMember 中的 is_final 是个谜一样的成员，因为它是一个不 能赋值的局部变量，所以现阶段不需要在意它。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 7 4 第 9 章　应用篇

在现在的实现中，每次增加成员都会使用 realloc() 来扩展可变长数组， 并且以线性的方式搜索。当然它的速度不快，这时候只要拿出富翁式编程的免死 金牌来就好了。
因为要引用 assoc，所以要修改 CRB_Object。

typedef enum { ARRAY_OBJECT = 1, STRING_OBJECT, ASSOC_OBJECT,

←增加了这行代码

SCOPE_CHAIN_OBJECT, ←将在后面说明

NATIVE_POINTER_OBJECT, OBJECT_TYPE_COUNT_PLUS_1 } ObjectType;

struct CRB_Object_tag {

ObjectType type;

unsigned int

marked:1;

union {

CRB_Array

array;

CRB_String

string;

CRB_Assoc

assoc;

←增加了这行代码

ScopeChain

scope_chain; ←将在后面说明

NativePointer native_pointer; } u; struct CRB_Object_tag *prev; struct CRB_Object_tag *next; };

与此同时还增加了 ScopeChain 和 NativePointer 这两个怪东西，还是留 在后面介绍吧。

9.1.3 闭包
对于对象来说不能够只有数据成员，还得有方法吧？我好像听见有人问我：“方 法怎么着了？”但是，我还是要把这些急脾气的人放在一边，先讨论一下别的话题。
在 crowbar 中可以使用 闭包（  closure）功能。所谓闭包，就是可以在表达式中 定义函数。.
# 创建闭包 c = closure(a) {

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

9.1　为 crowbar 引入对象和闭包 2 7 5

print("a.." + a); };

# 调用闭包 c(10);
 closure 是创建闭包的关键字。通过在后面的括号内定义形式参数、在程序 块中编写代码来创建闭包。上面的代码中把创建的闭包赋值给了变量 c。
利用代码 c(10) 可以调用闭包。因此，这段代码会输出 a..10。 C 语言的程序员看了这个可能会想，“什么嘛！这不就是函数指针吗？”（当 然，闭包可以在表达式中任意编写，比函数指针容易上手）。闭包确实有与函数 指针相似的一面，实际上使用方法也是一样的。 但是，决定性的区别在于，闭包可以引用到闭包声明所在位置的局部变量。 举一个关于 foreach 的例子。在 crowbar 中循环数组的全部元素时需要编 写如下代码：

for (i = 0; i < array.size(); i++) { # 处理
}
这种编码方式依赖于数组概念的实现。如果此时改变设计思路，不用数组而 改用链表了，那么与之相关的所有地方都要进行修改。这是一件很烦人的事，因 此在 C# 中出现了一个叫作 foreach 的语法。

foreach (Object o in hogeCollection) {
// 处理 }

Java 从 J2SE5.0 开始也增加了同样的语法。. 有了这个语法确实方便了不少，

虽说方便了但是还是要考虑如何把它调整为语法规则。

* 但 是， 在 crowbar 的
标 准 中， 并 不 是 引
入 foreach 函 数， 而
是引入 foreach 语法。

但是，在可以使用闭包的语言中，是可以把代码写成下面这样的 *。
foreach(hoge_collection, closure(o){ # 处理
});

这里的 foreach 并不是关键字，而是单纯程序库的函数。第 1 个参数是集合 对象，第 2 个参数可以接收闭包。foreach 函数将第 1 个参数（集合对象）中的 元素依次取出，并以此为参数调用第 2 个参数（闭包）。
如果只是满足调用 foreach 函数时的这个功能的话，那么 C 的函数指针也

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 7 6 第 9 章　应用篇

是可以实现的。但是，在通过这种方式使用闭包的时候，如果可以从循环的内部 引用外部的变量的话，就是一件不寻常的事情了。.
fp = fopen("hoge.txt", "w"); foreach(hoge_collection, closure(o) {
fputs(o.name, fp); # 引用循环外部的变量 fp });
闭包使这种调用方式成为可能。这就是闭包与 C 语言的函数指针之间决定性 的不同。

9.1.4 方法

代码清单 9-1 Point.crb（之一） 

对象和闭包组合起来，就变成了下面这段代码（代码清单 9-1）。

1: # 创建“点”的函数（构件方法）

2: function create_point(x, y) {

3:

this = new_object();

4:

this.x = x;

5:

this.y = y;

6:

7:

# 定义输出坐标的方法 print()

8:

this.print = closure() {

9:

print("(" + this.x + ", " + this.y + ")\n");

10:

};

11:

# 定义移动坐标的方法 move()

12:

this.move = closure(x_vec, y_vec) {

13:

this.x = this.x + x_vec;

14:

this.y = this.y + y_vec;

15:

};

16:

return this;

17: }

18:

19: # 创建对象

20: p = create_point(10, 20);

21:

22: # 调用 move() 方法

23: p.move(5, 3);

24:

25: # 调用 print() 方法

26: p.print();

由于 crowbar 中没有专门的“方法”功能，因此通过上面的方式让对象的成 员持有闭包，也就实现了与 Diksam、Java、C++ 等语言类似的方法功能。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

9.1　为 crowbar 引入对象和闭包 2 7 7

代码清单 9-1 的第 3 行出现的 this 也不是关键字，其实只是取什么名字 都可以的局部变量，只不过使用 this 的话，对于习惯了 C++ 或 Java 的人来 说 比 较 容 易 理 解。 重 点 在 于， 从 闭 包 内 部 可 以 访 问 到 外 部 的 局 部 变 量， 因 此 在 print() 和 move() 的内部可以引用到 this。
如果想要继承或者多态的话，只需要在调用 create_point() 的基础上增 加新的方法覆盖原有的方法就可以了。.

代码清单 9-2 Point.crb（子类） 

1: # 生成“子类”

2: function create_extended_point(x, y) {

3:

this = create_point(x, y);

4:

5:

# 重写 print()

6:

this.print = closure() {

7:

print("**override** (" + this.x + ", " + this.y + ")\n");

8:

};

9:

10:

return this;

11: }

另外，现在的 create_point() 方法外面如果书写代码 p.x 的话是可以引 用到 x 的。也就是说，p 的成员 x、y 的默认是 public 的。如果实在是不喜欢这 种方式，也可以不在 this 中保存 x 和 y，而是使用代码清单 9-3 的方式增加访问 器就可以了。.

代码清单 9-3 Point.crb（封装版） 

1: # 创建“点”的函数（构件方法）

2: function create_point(x, y) {

3:

this = new_object();

4:

5:

this.print = closure() {

6:

print("(" + x + ", " + y + ")\n"); # ←即使不是 this.x 也可以引用

7:

};

8:

this.move = closure(x_vec, y_vec) {

9:

x = x + x_vec;

10:

y = y + y_vec;

11:

};

12:

# 增加访问器（省略了 get_y()）

13:

this.get_x = closure() {

14:

return x;

15:

};

16:

return this;

17: }

在 create_point() 内 创 建 的 闭 包 拥 有 可 以 引 用 参 数（或 者 说 局 部 变

量）x 和 y 的特性。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 7 8 第 9 章　应用篇
上面这些就是基于 crowbar 的面向对象。
9.1.5 闭包的实现
看了前一节的代码，可能有人会有下面这样的疑问。. 如果 this、x、y 都是局部变量的话，在函数 create_point() 退出的时候不是就 该被释放了吗？就算是在闭包中可以引用到外部的局部变量，但如果被释放了的话不 是就不能引用了吗？ 真是一个不错的问题，但上面的担心并不会发生，这才是闭包有趣的地方。 在 C 语言中，进入函数的时候会在栈上创建局部变量的内存空间，函数退出 的时候会被释放。此时，被创建 / 释放的单块内存被称为 帧（   frame）。 在 crowbar 中，到 book_ver.0.3 为止，本质上都是相同的（只不过帧不是在 栈上被创建的而是在堆上）。然而在上述示例中的 print() 和 move() 方法， 在 create_point() 结束后才被调用，而且在方法里面还能引用到 this。如 果使用“函数退出时帧也会被释放”这个老规则，是不能满足这种变量访问方 式的。 在现在的 crowbar 中，创建帧的时机和往常一样，但是释放的时机却不是 “函数退出的时候”，而是“帧不再被引用的时候”。也就是说，帧的释放是通过 GC 进行的。 但是，请思考一下实际的实现方式。 首先，帧是某一次函数调用时保存局部变量的地方，对于局部变量（群）来 说，由于存在着多个变量名和值的组合，因此使用 assoc 再适合不过了。也就是 说，在调用函数的时候创建一个 assoc，并将局部变量保存在其中就可以了。 接下来就是闭包了。像之前所说的，闭包具有如下特性。 1.	闭包是一个值，可以像C的函数指针一样赋值给变量，并且在之后可以通过函数调 用的方式投入使用。 2. 可以引用创建其位置的局部变量。 首先，先来介绍一下第一个特征。 由 于 闭 包 是 一 个 值， 必 然 可 以 保 存 在 CRB_Value 中， 因 此， 在 CRB_ Value 的联合体定义中需要增加 CRB_Closure（代码清单 9-4）
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

9.1　为 crowbar 引入对象和闭包 2 7 9

代码清单 9-4 CRB_Closure 结构体 

typedef enum {

 CRB_BOOLEAN_VALUE = 1,

 CRB_INT_VALUE,

 CRB_DOUBLE_VALUE,

 CRB_STRING_VALUE,

 CRB_NATIVE_POINTER_VALUE,

 CRB_NULL_VALUE,

 CRB_ARRAY_VALUE,

 CRB_ASSOC_VALUE,

CRB_CLOSURE_VALUE,

←新增

CRB_FAKE_METHOD_VALUE, ←将在后面的章节中介绍

CRB_SCOPE_CHAIN_VALUE

} CRB_ValueType;

·

·

·

typedef struct {

CRB_ValueType type;

union {

CRB_Boolean

boolean_value;

int

int_value;

double

double_value;

CRB_Object

*object;

CRB_Closure

closure;

←新增

CRB_FakeMethod fake_method; ←将在后面的章节中介绍

} u;

} CRB_Value;

这里增加了 FAKE_METHOD，我会在后面的章节中介绍（抱歉，要在后面介 绍的内容太多了）。
然后是第二个特性。闭包虽然与函数指针相似，但是它拥有可以引用创建其 位置的局部变量的特性（对于这点，也有闭包保存了其创建位置的环境 A 的说法）。 局部变量被保存在 assoc 中，因此，我想 CRB_Closure 结构体可以定义成下面 这样。

typedf struct {

CRB_FuntionDefinition *function;

CRB_Object

*environment; /* 指向帧的 assoc */

} CRB_Closure;

成 员 function 指 向 了 函 数 定 义 的 实 体 CRB_FunctionDefinition，. environment 则指向了创建闭包的位置的帧。

A　环境：environment。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 8 0 第 9 章　应用篇

图 9-2 作用链

但是，这里有一个必须要注意的地方，就是闭包是可以嵌套的。
下面这段代码中，在注释的位置肯定可以同时引用到 a 和 b。.
function f() { a = 10; c1 = closure() { b = 20; c2 = closure() { # 这里可以同时引用到 a 和 b print("a.." + a + "\n"); print("b.." + b + "\n"); }; c2(); }; return c1;
}
虽说闭包是一个函数，但又不同于函数，因此它既可以访问保存了 a 的帧
（函数 f() 的帧），又可以访问保存 b 了的帧（闭包 c1 的帧）。因此可以看出，
闭包要保存的帧不止一个。 于是，引入了 作用链（ . scope.chain）这个概念。作用链是以链表方式管理的
帧的 assoc（图 9-2）。
ScopeChain 对象

Assoc 对象
为了构建这个链表，我们引入了 ScopeChain 结构体。ScopeChain 作为 GC 的目标，也因此成为了 CRB_Object 的联合体的成员（这个是前面写到的要 在后面章节中做介绍的内容之一）。  ScopeChain 结构体的定义如下。
typedef struct { CRB_Object *frame; /* 指向 CRB_Assoc */
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

9.1　为 crowbar 引入对象和闭包 2 8 1

CRB_Object *next; /* 指向 ScopeChain */ } ScopeChain;

但 是，CRB_Closure 并 没 有 直 接 指 向 代 表 帧 的 assoc， 而 是 指 向 了 ScopeChain。

typedef struct {

CRB_FunctionDefinition *function;

CRB_Object

*environment; /* 指向 ScopeChain */

} CRB_Closure;

* 说到这里，各位一定会
羡慕能够使用继承的语
言吧。

不好意思各位，结果最后都是 CRB_Object，除了被注释的内容之外没有任 何改变 *。
另 外，LocalEnvironment 结 构 体 中 也 同 样 没 有 指 向 assoc， 而 是 指 向 了 ScopeChain。
至于具体怎么去使用上面定义的这些结构体，我想在跟踪程序实际执行时考 虑的话，可能会更容易理解。.

9.1.6 试着跟踪程序实际执行时的轨迹

* 在crowbar 中，LocalEnvironment 被 创 建 在 堆 中，但实际上链表是在 栈中实现的，因此在这 里认为是创建在栈上的。
代码清单 9-5 试着追踪闭包执行的 轨迹 

在 crowbar 中，调用函数、创建闭包、调用闭包，都要进行以下动作。

[ 规则 1]　在调用函数的时候，会创建新的 LocalEnvironment 并将其入栈为栈顶 *。 在这个 LocalEnvironment 中，为了保存在当前函数中声明的局部变量， 创建并分配（元素被作为一个作用链）了一个新的 assoc。
[ 规则 2] 　在创建闭包的时候，这个闭包保存着栈顶 LocalEnvironment 中的作用链。 [ 规则 3]　在调用闭包的时候，会在规则 1 中创建新的作用链之后，再将其链接到保存
着闭包的作用链上。

这些规则在实际上是怎样操作的，请参考代码清单 9-5。

1: function f() {

2:

a = 10;

3:

c1 = closure() {

4:

b = 20;

5:

c2 = closure() {

6:

# 这里可以同时引用到 a 和 b

7:

print("a.." + a + "\n");

8:

print("b.." + b + "\n");

9:

};

10:

c2();

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 8 2 第 9 章　应用篇

图 9-3 普通的函数调用

11:

};

12:

return c1;

13: }

14:

15: c = f();

16: c();

1. 普通的函数调用

首先，在第 15 行调用 f() 的时候，会根据规则 1 创建一个 LocalEnvironment，

并生成第一个帧。在第 2 行的赋值语句中，声明了 a 并保存在新创建的帧中。之后

的动作就跟调用一般的函数一样了（图 9-3）。. 另外，为了更清楚地描述这个过

程，图中没有出现 ScopeChain 结构体，而是画得好像代表帧的 assoc 可以单独

构建链表一样。

帧

LocalEnvironment

a

图 9-4 创建闭包

2. 创建闭包 第 3~11 行创建了闭包。 根据规则 2，闭包在创建的时候保存了指向保存了 LocalEnvironment 的
作用链的引用。

c1

帧

LocalEnvironment

a

并且，c1 本身就是一个局部变量，因此与 a 保存在了同一个帧中，图中为 了使表达更为简单所以把这部分省略了。
这里的“创建闭包”是指，执行用关键字 closure 创建闭包的处理的时候。 第 3 行中创建了闭包并赋值给了变量 c1，但是并没有马上调用闭包 c1，在第 5 行 生成另外一个闭包的时候也没有执行，直到调用了 f() 将其返回，闭包 c1 一直 都没有被调用。
3. 调用闭包 调用 f() 返回之后，在第 16 行调用了闭包 c1。 此时也会根据规则 1 新建一个 LocalEnvironment 和帧，并且根据规则 3，

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

9.1　为 crowbar 引入对象和闭包 2 8 3

图 9-5 调用闭包 
图 9-6 调用闭包
图 9-7 调用嵌套闭包

在新建了帧之后，再将其链接上保存着闭包的作用链（图 9-5）。

c1

链接引用了闭包的作用链

为了调用 c1 而新建的 LocalEnvironment

新的帧

帧

b

a

在 c1 中创建 b 的空间
在搜索局部变量的时候，会对 LocalEnvironment 引用的作用链依次进行 搜索。因此，在 c1 中是可以引用到局部变量 a 的。
4. 创建闭包中的闭包 在开始执行赋值给 c1 的闭包时，首先会执行第 4 行为 b 的赋值。b 是一个
单纯的局部变量，因此会在 LocalEnvironment 直接指向的帧中创建空间。 在接下来的第 5~9 行中创建第二个闭包 c2。 此时，根据规则 2，创建闭包 c2 时保存了指向 LocalEnvironment 保存
着的作用链。因此，c2 保存的作用链中链接着存有 b 的帧和存有 a 的帧（图 9-6）。

c2

为了调用 c1 而新建的 LocalEnvironment

帧

帧

b

a

5. 调用嵌套闭包 在第 10 行调用了 c2 的时候，根据规则 3，c2 引用的作用链链接到了新
的 LocalEnvironment 上，因此，c2 中应该可以同时引用 a 和 b。
c2

为了调用 c2 而新建的 LocalEnvironment
为了调用 c1 而新建的 LocalEnvironment

新的帧

帧

帧

b

a

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 8 4 第 9 章　应用篇
9.1.7 闭包的语法规则
创建闭包的语言规则如下所示：
closure_definition : CLOSURE IDENTIFIER LP parameter_list RP block | CLOSURE IDENTIFIER LP RP block | CLOSURE LP parameter_list RP block | CLOSURE LP RP block ;
在 closure_definition 被 reduce 的时候，在 create.c 中会创建如下结构 体（想象一下就能知道，它是 Expression 结构体的联合体成员）。
typedef struct { CRB_FunctionDefinition *function_definition;
} ClosureExpression;
由于闭包也是函数，因此为闭包表达式构建了 CRB_FunctionDefinition。但 是这个 CRB_FunctionDefinition 仅可以由分析树中的 ClosureExpression 引 用，并不会添加到 CRB_Interpreter.的 function_list 里面。
另外，在上面的四个语法规则中，有两个在关键字 closure 后面加入了标 识符（IDENTIFIER）。这种语法规则在创建 命名闭包 时使用。
在目前为止出现的例子中，闭包都是没有名字的。但如果想要在闭包中递归 调用自己的话，给闭包起个名字就会方便很多。
至于实现上，在调用命名闭包时，首先要为其创建新的帧，此时将闭包自身 作为指定名称的局部变量登录进来就可以了。
9.1.8 普通函数
到 book_ver.0.3 为止，crowbar 的函数调用语法规则如下所示。
primary_expression : IDENTIFIER LP argument_list RP | IDENTIFIER LP RP ;
为了可以使用闭包，函数调用运算符 () 的左边不仅可以是 IDENTIFIER， 还可以是任意的表达式。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

9.1　为 crowbar 引入对象和闭包 2 8 5

因此，普通函数也发生了变化，.函数名用来返回“表示函数的值”（C 语言中 的函数指针）.。函数的实体也变成了 ClosureExpression。
例如，调用函数 print("hello\n") 时的形式为，返回 print. 标识符对 应的“函数”，然后再调用它。此时，print 返回的 ClosureExpression 中，. environment 成员为 NULL。
当然也可以通过下面的方法将普通函数赋值给变量。
p = print; p("hello,world\n");

9.1.9 模拟方法（修改版）

在 crowbar 的数组中有例如 size() 这样的“方法”。 book_ver.0.2 的实现方式在 4.4.2 节中已经介绍过了，但是在这次的修改中， 函数将作为“值”被处理。因此，像下面这样一段代码必须能够输出 array 的 大小。

a = array.size; · · · print("array.size.." + a());
想要实现它，就必须要让 a.size 返回 C 语言中的函数指针——不仅如此， 如果没有地方保存指向 array 的引用，也不可能返回数组的大小。
因 此， 在 CRB_Value 联 合 体 中， 增 加 了专 门 用 来“模 拟 方 法 ” 的 CRB_ FakeMethod 成员（这也是前面说过的会在后面章节中介绍的内容之一）。.

typedef struct {

char

*method_name;

CRB_Object *object;

} CRB_FakeMethod;

/* 方法名 */ /* 相当于 this 的对象 */

 CRB_FakeMethod 结构体保存了前面所说的指向 array 的引用。在知道了 这些引用和方法名之后，处理器就可以调用模拟方法了。.

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 8 6 第 9 章　应用篇
9.1.10 基于原型的面向对象
实际上，crowbar 的设计方式多多少少参考了 JavaScript。 像 JavaScript 和 crowbar 这样没有类的概念、每个实例都包含不同字段和 方法的语言，被称为 基于原型的面向对象语言（   prototype.based.object.oriented. language）。与此相对，Java、C# 和 Diksam 等具有类的概念的面向对象被称为 基 于类的面向对象语言（   class.based.object.oriented.language）。 但是，一般被称为“基于原型的面向对象”时，多数情况会包含如下特性： ●● 可以通过复制（克隆）现有对象来创建新的对象。 ●● 当调用了对象的某个方法之后，如果对象中不存在这个方法，则自动将该方法的调
用传递给其他对象 A（ 原型链 ，prototype chain）。 虽然在 JavaScript 中具有原型链功能，但是在 crowbar 中却没有。这也就意味 着，crowbar 算不上是基于原型的面向对象语言。但是，基于原型的面向对象也 被称为是“基于实例的”或者是“基于对象的”，从这两个方面去看 crowbar，也 许还能够跟它们归为一类。.
9.2 异常处理机制
在现在的语言中，当程序运行过程中发生了预期之外的情况时，一般会发 生 异常（   exception）。在 C 语言中，多数情况下会通过返回值不停地给调用者返 回“错误状态”。这种做法不仅很麻烦，还会使代码由于嵌入了异常处理程序而 变得难以阅读。
因此，我考虑在 crowbar 和 Diksam 中引入异常的概念。.
9.2.1 为 crowbar 引入异常
在 crowbar 中引入了与 Java 相同的 try~catch~finally 处理方式。
A　当然这两个对象要具有原型继承关系。——译者注
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

9.2　异常处理机制 2 8 7

在 Java 和 C# 的 catch 子句中虽然可以对应不同的异常类型并进行处理，但 是因为 crowbar 中本来就没有类型，所以也就只写一个 catch 子句。具体的示例 请参考代码清单 9-6。

代码清单 9-6 crowbar 的异常处理 示例 

1: try {

2:

zero = 0;

3:

a = 3 / zero;

4: } catch (e) {

5:

# 通过 child_of 方法判断异常种类

6:

if(e.child_of(DivisionByZeroException)) {

7:

print(" 不能被 0 除。\n");

8:

} else {

9:

throw e;

10:

}

11: }

代码清单 9-6 的第 3 行试图用 3 除以 0，这样做会发生被 0 除的异常（这里 特意使用变量 zero 的原因是，如果直接使用 3/0 的话在编译时会出现错误）。
第 4 行的 catch 子句捕捉了这个异常。 第 6 行中，通过调用捕获异常对象的 child_of() 方法来检查异常的类型。 这段代码里检查了异常是否是 DivisionByZeroException 类型，如果是则输 出错误信息。 如 果 不 是 处 理 器 定 义 的 异 常， 而 是 自 己 认 为 发 生 了 异 常 情 况， 可 以 使 用 throw 抛出自定义异常。.

e = new_exception(" 错误信息 "); throw e;

 new_exception() 是一个原生函数。返回值为异常对象，是一个 assoc。 调用 new_exception() 时，会在返回值中保存 栈轨迹（   stacktrace）。这个异常 如果没有被 catch 的话，会一直传播到顶层结构。处理器会记录栈轨迹，也可 以通过 print_stack_trace() 方法从程序中输出栈轨迹。
像 被 0 除 这 种 在 处 理 器 中 发 生 的 异 常 通 常 都 会 有 父 子 关 系， 例 如 DivisionByZeroException 就 是 ArithmeticException 的 子 类。 因 此， 在 代 码 清 单 9-6 的 第 6 行 可 以 将 DivisionByZeroException 替 换 为 ArithmeticException，child_of() 方法仍然会返回真。
通过在各“异常类”中保存父异常的方式来实现这种父子关系。另外，当然 无 论 是 ArithmeticException 还 是 DivisionByZeroException 都 不 是

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 8 8 第 9 章　应用篇

代码清单 9-7 “异常类”的实现 

关键字，只是全局变量而已。说了这么多，还是快点来看一段代码吧（代码清单 9-7）。

1: function create_exception_class(parent) {

2:

this = new_object();

3:

this.parent = parent;

4:

this.create = closure(message) {

5:

e = new_exception(message);

6:

e.stack_trace.remove(0);

7:

e.child_of = this.child_of;

8:

return e;

9:

};

10:

this.child_of = closure(o) {

11:

for (p = this; p != null; p = p.parent) {

12:

if (p == o) {

13:

return true;

14:

}

15:

}

16:

return false;

17:

};

18:

return this;

19: }

20: 

21: RootException = create_exception_class(null);

22: BugException = create_exception_class(RootException);

23: RuntimeException = create_exception_class(RootException);

24: ArithmeticException = create_exception_class(RuntimeException);

25: VariableNotFoundException = create_exception_class(BugException);

  （ 之后省略）

代码清单 9-7 的源文件在 buitin 目录下的 builtin.crb 中。具体是如何加载它的 将在 9.3 节中介绍。
从第 1 行开始的 create_exception_class() 函数是“异常类”的构造 函数。各种异常类型从第 21 行开始被定义为全局变量。异常类对于程序来说只 存在一个，可以通过调用异常类的 create() 方法来创建这个异常类的实例。
父异常通过“异常类”的构造函数接收的参数 parent 被保存起来。因此， 第 10 行的 child_of() 方法可以检查异常的层级。只是，由于 child_of() 是 “异常类”的方法，因此在创建异常的实例时要把它设置到异常的实例中（第 7 行）。异常实例中的 parent 成员即使什么都没有，也可以调用 child_of() 方 法，这就是闭包的魔力。
另外，第 6 行移除了栈轨迹的第一个元素，这样做是为了不让栈轨迹中包含

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

9.2　异常处理机制 2 8 9

代码清单 9-8 exception.crb 

调用 create() 方法的痕迹。 在 crowbar 中，异常的栈轨迹以下面的格式输出。.

不能被 0 除。 func at 6 func at 3 func at 3 func at 3 top_level at 9

上面这段输出来自代码清单 9-8。在递归调用 func() 时，DivisionByZero Exception 异常会发生在程序的深处。

1: function func(count) {

2:

if (count < 3) {

3:

func(count + 1);

4:

}

5:

zero = 0;

6:

a = 3 / zero;

7: }

8: 

9: func(0);

9.2.2 setjmp()/longjmp()
crowbar 的程序是一边递归分析树一边执行的。因此，在发生异常的时候， 会一下子追溯到 C 语言的调用层级中。
crowbar 的 控 制 结 构 return、break、continue 有 着 同 样 的 问 题， 在 使 用 上 述 控 制 结 构 时， 会 通 过 返 回 值 将 各 种 状 态 返 回 给 调 用 者。 但 是， 相 对 于 return 和 break 只 会 发 生 在“语 句 ” 级 别， 异 常 有 可 能 发 生 在“表 达 式 ” 的 深 处， 因 此 要 将 它 对 应 返 回 值 会 比 较 麻 烦。 这 种 情 况 下， 我 们 可 以 使 用 setjmp()/longjmp()。
普通的 C 语言使用者可能大多数还不太熟悉 setjmp()/longjmp()。更确 切地说，有的人认为“它是一个比 goto 还要邪恶的，可以跨越函数界限进行长 距离（long）跳转（jmp）的可怕函数！”
但是，无论什么事情，无论是好是坏，都要好好的研究一下才能下结论。如 果自己连用都没用过就说“这个不好用”，那这人也实在是荒唐。
所以，以下我们先简单地看一下 setjmp()/longjmp()。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 9 0 第 9 章　应用篇
●● setjmp() 的参数是 jmp_buf 类型的变量，调用函数时在参数中保存程序的上下文。 ●● longjmp() 用于返回到使用 setjmp() 保存的位置。 即使通过多次函数调用进行到了很深的级别，也可以瞬间返回。. 从 longjmp() 这 个 名 字 就 可 以 看 出 来， 它 可 以 跨 越 函 数 界 限 随 意 跳 转 到 任 何 位 置。 但 实 际 上， 它 只 能“返 回 ” 到 使 用 setjmp() 标 记 过 的 位 置。 在 longjmp() 看来，setjmp() 标记的必须是“调用者”。在 longjmp() 的时 候，被 setjmp() 标记了的函数在没有返回的情况下会从栈中删除。基于以上操 作，我觉得这个方法叫 longjmp() 有点不太合适，应该叫 longreturn() 才 更加贴切。 更 重 要 的 是，setjmp() 在 保 存 程 序 上 下 文 的 时 候 返 回 0。 在 使 用 longjmp() 返回时，longjmp() 的第 2 个参数也会跟着返回。根据第 2 个 参数返回的值，可以判断出当前执行的程序是从哪个 longjmp() 返回的。 使用这两个函数编写下面这段代码的时候，可以从深层的函数调用中瞬间返 回回来。 /* 为了保存调用者的程序上下文，声明了一个变量 */ jmp_buf recovery_environment;
if (setjmp(recovery_environment) == 0) { /* setjmp() 在第一次调用的时候返回 0，进入这个分支 * 在这个分支中进行正常情况下的处理 * 在这里调用了 longjmp() 后，会执行下面的 else 子句。 * 对于 longjmp() 的调用，在这里即使进行了 * 深层次的函数调用，其结果也不会改变。 */ long_jmp(recovery_environment, 1);
} else { /* 执行了 longjmp() 之后会进入这个分支进行处理 */
}
作为参数被传入 setjmp() 的 jmp_buf 类型变量中保存着“当前程序的上 下文”。“当前程序的上下文”中包含了当前寄存器的值等很多东西，但首当其冲 要记录的我认为就是 setjmp() 被调用的地点。再把这个 jmp_buf 当做参数传 递给 longjmp() 的话，就应该能返回到 jmp_buf 记录的地点了。
另外，可能有人会有这样的疑问：“setjmp() 的参数并没有加上 & 传递，为 什么还能保存程序的上下文呢？ C 的参数不是按值传递的吗？”这是因为 jmp_
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

9.2　异常处理机制 2 9 1

代码清单 9-9 execute_try_statement() 函数 

buf 类型被 typedef 成了数组。请务必检查您环境的头文件。我觉得这是一个 会招致混乱的设计。
实际上 crowbar 的异常处理在代码清单 9-9 中进行了实现（execute.c）。

1: static StatementResult

2: execute_try_statement(CRB_Intercepter *inter, CRB_LocalEnvironment *env,

3:

 Statement *statement)

4: {  

5:

StatementResult result;

6:

int stack_pointer_backup;

7:

RecoveryEnvironment env_backup;

8:  

9:

/* 备份 crowbar 栈的栈指针和 jmp_buf */

10:

stack_pointer_backup = crb_get_stack_pointer(inter);

11:

env_backup = inter->current_recovery_environment;

12:

if (setjmp(inter->current_recovery_environment.environment) == 0) {

13:

/* 执行 try 子句 */

14:

result = crb_execute_statement_list(inter, env,

15:

statement->u.try_s.try_block

16:

->statement_list);

17:

} else {

18:

/* 发生异常时的处理。首先恢复 crowbar 的栈和 jmp_buf */

19:

crb_set_stack_pointer(inter, stack_pointer_backup);

20:

inter->current_recovery_environment = env_backup;

21:

22:

if (statement->u.try_s.catch_block) {

23:

/* 执行 catch 子句 */

24:

CRB_Value ex_value;

25:

26:

ex_value = inter->current_exception;

27:

CRB_push_value(inter, &ex_value);

28:

inter->current_exception. type = CRB_NULL_VALUE

29:

30:

assign_to_variable(inter, env, statement->line_number,

31:

statement->u.try_s.exception, &ex_value);

32:

33:

result = crb_execute_statement_list(inter, env,

34:

statement->u.try_s.catch_block

35:

->statement_list);

36:

CRB_shrink_stack(inter, 1);

37:

}

38:

}

39:

inter->current_recovery_environment = env_backup;

40:

if (statement->u.try_s.finally_block) {

41:

/* 执行 finally 子句 */

42:

crb_execute_statement_list(inter, env,

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 9 2 第 9 章　应用篇

43: 44: 45: 46: 47: 48: 49: 50: 51: 52: 53: }

statement->u.try_s.finally_block ->statement_list); } if (!statement->u.try_s.catch_block && inter->current_exception.type != CRB_NULL_VALUE) { /* 如果没有 catch 子句的话，创建新的 throw 直接抛出异常 */ longjmp(env_backup.environment, LONGJMP_ARG); }
return result;

crowbar 使用自己的栈计算表达式，在第 10 行备份了这个栈。因为如果表达 式执行到深处时发生了异常的话，就必须要抛弃那个时候的栈。
另 外， 在 第 11 行 使 用 变 量 evn_backup 进 行 了 备 份， 这 个 变 量 的 类 型 是 RecoveryEnvironment，因此它的实体只包含了一个 jmp_buf 的结构体 （这里特意声明了一个结构体以备将来扩展）。
这两个用于备份的局部变量被放在了 C 的栈上。因此，没有 catch 子句或 从 catch 子句中再 throw 后，无论返回到任何阶段（第 49 行），都需要依次从 C 栈上的备份中恢复这两个变量。
并且，无论从 try 子句中调用什么阶段的函数，如果在深层发生异常，是不 能瞬间返回到 catch 中，而是顺着函数调用的顺序返回的。因此，在调用 crowbar 函数的时候也会执行 setjmp()。这样做的前提是 CRB_LocalEnvironment 在 必要的时候能够开放（基于 eval.c 的 eval_function_call_expression()）。

stack_pointer_backup = crb_get_stack_pointer(inter); env_backup = inter->current_recovery_environment; if (setjmp(inter->current_recovery_environment.environment) == 0) {
do_function_call(inter, local_env, env, expr, func); } else {
/* 如果在函数内发生异常的话，抛弃 LocalEnvironment */ dispose_local_environment(inter); crb_set_stack_pointer(inter, stack_pointer_backup); /* 紧接着调用 longjmp() */ longjmp(env_backup.environment, LONGJMP_ARG); } inter->current_recovery_environment = env_backup; dispose_local_environment(inter);

另外，在代码清单 9-9 的第 47 行检查了 inter->current_exception. type，这样做是为了保证它保存的是“当前的异常”，以便在 throw 的时候进行

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

9.2　异常处理机制 2 9 3
设置。因此，它会在 catch 子句中被抛弃（第 28 行），并在 catch 子句执行（第 33~35 行）并且发生异常的时候被重新设置。
再来说说 finally 子句，一旦进入了 try 子句就“必须”要执行 finally. 子句。例如在下面这段代码中使用 break 跳出了 for 语句，即使是在这种情况 下，在跳出循环之前也必须要执行 finally 子句。
for (;;) { try { break;
 } finally { # 即使进行了 break，这里的代码也会执行
} }
在 crowbar 中出现了 break 等跳转语句时，将把语句的执行结果（CRB_ StatementResult）作为返回值返回给调用者（请参考 3.3.6 节）。在代码清 单 9-9 中，无论 try 子句得到怎样的执行结果都会执行 finally 子句，以保证 “必须执行 finally”。但是，另一方面，如果 try 子句中进行了 break 的话， 在 finally 执行结束后还是要执行 break。还有，如果在 try 中 return 3;、 在 finally 中有 return 5; 的时候，到底要返回哪个才对呢？在 Java 中，如果 在 finally 子句中写了 return、break 等控制语句的话，javac 会发出警告。 C# 中则会直接发生编译错误。
在 crowbar 中，try 语句最终执行结果的原则是，无论 finally 中是什么结果 都会被忽略，要优先使用 try 或者 catch 子句的执行结果。
  补充知识    Java 和 C# 异常处理的不同 
关于 Java 和 C# 异常处理的不同点，通过搜索引擎搜索“Java C# 异常 不同”这 样的关键字就能得到“有无检查异常”的相关资料。
这点会在 9.2.6 节的补充知识中做介绍。除此之外，C# 的异常和 Java 的异常还 有很多区别，Java 的程序员如果使用 C# 的话会很容易上手（反过来就不一定了）。
首先，在 Java 中，异常的栈轨迹创建于“异常 new 出来的时候”。比如下面这段 程序中，异常一被 new 出来后马上就输出栈轨迹，此时可以把当前的栈轨迹完全输出 出来。
Exception e = new Exception(); e.printStackTrace(); 多 数 人 可 能 会 在 调 试 的 时 候 编 写 这 样 的 代 码。 与 此 相 对 在 C# 中， 栈 轨 迹 在
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 9 4 第 9 章　应用篇

“throw 之后返回到方法调用的层级的时候”被依次组装起来的。可以通过代码清单 9-10 的示例代码来确认这个问题。

代码清单 9-10 C# 的异常

1: using System;

2: using System.Collections.Generic;

3: using System.Text;

4: 

5: namespace ExceptionTest

6: {

7:

class Program

8:

{

9:

static void Sub(int count)

10:

{

11:

if (count == 0)

12:

{

13:

throw new Exception();

14:

}

15:

try

16:

{

17:

Sub(count - 1);

18:

}

19:

catch (Exception e)

20:

{

21:

// 进行递归调用使异常发生在较深的层级

22:

// 每一个层级 catch 到异常后，再继续 throw。

23:

// 在每次 catch 的时候，栈轨迹都会随之增长，从这点就可以看出

24:

// C# 中异常的栈轨迹，是在返回到调用者的层级后

25:

// 再进行组装的。

26:

Console.WriteLine("********** count.." + count + "*********");

27:

Console.Write(e.ToString());

28:

throw;

29:

}

30:

}

31:

32:

static void main (string[] args)

33:

{

34:

try

35:

{

36:

Sub(10);

37:

}

38:

catch (Exception e)

39:

{

40:

Console.WriteLine("********** final *********");

41:

Console.Write(e.ToString());

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

9.2　异常处理机制 2 9 5

42:

}

43:

}

44:

}

45: }

说到这样做的理由，比如创建异常在某个工具类中的时候，如果栈轨迹中只包含了 这个工具类的方法的话，就会让调试人员摸不着头脑。实际上，crowbar 也采用 Java 的方式（见代码清单 9-7），为了从栈轨迹中删除第 4 行的 create() 方法，不得不在 第 6 行做那样奇怪的事情。
在 C# 中，调试时如果想看一下栈轨迹的话，可以使用 Environment.StackTrace。
另外，在 Java 中被 catch 到的异常如果想再次抛出的话，要编写下面这段代码：

} catch(HogeException e) {

 

··· 

 throw e;

}

但是，在 C# 中 throw 的时候，会重新设置 e 中的栈轨迹，从而在 C# 中只需要这 样写就可以了：

throw;

C# 中增加了“将在 catch 子句中捕获的异常直接抛出”的语法。 在 crowbar 中既然采用了 Java 的方式，那么在 Diksam 中让我们来试试看 C# 的 方式。具体的实现方式将在下一节中介绍。

9.2.3 为 Diksam 引入异常

* 实际上是可以做出相似 的异常层级结构的，即 使使用 crowbar 的功能 做出了这样一个层级结 构，从语言的设计层次 来讲并没有特别支持这 种方式，而对我本人来 说也很抗拒这种上下相 逆的事情。

说完了 crowbar，本节就要为 Diksam 引入异常的概念了。
下面就为 Diksam 引入与 Java 和 C# 相同的异常处理机制。
try { /* try 子句 */
} catch (HogeException e) { /* 与 HogeException 对应的 catch 子句 */
} catch (PiyoException e) { /* 与 PiyoException 对应的 catch 子句 */
} finally { /* finally 子句，这里的代码必然会执行 */
}
由于 crowbar 中没有类的概念 *，因此只能编写一个 catch 子句。但是在

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 9 6 第 9 章　应用篇

Diksam 中与 Java 相同，可以编写与各种异常类对应的 catch 子句。. 另外，和 Java、C# 等相同的地方是，也可以通过 throw 抛出异常。.

throw e; // throw 异常 e

crowbar 使 用 了 Java 的 风 格， 即 在 new 异 常 的 时 候 创 建 栈 轨 迹， 因 此 在

Diksam 中要使用 C# 的风格，即在 throw 的时候创建栈轨迹（请参考 9.2.2 节的

补充知识）。所以，在 catch 子句中抛出异常的时候可以只写 throw;。

另外，和 Java、C# 等相同的可以被 throw 和 catch 的只有 Exception 的

* 由 于 Exception 是 在
Diksam 中 创 建 的 类，
这里果然还是做了“上
下相逆”的事情。

子类 *。   补充知识    catch 的编写方法 

如前面所述，在 crowbar 中只能编写一个 catch 子句，但是在 Diksam 中就可以 编写与各种异常类对应的 catch 子句。“可以编写”看上去是一个很方便的功能，但是 实际使用起来就不是那么方便了。
例如，异常 A 和异常 B 想要进行同样的处理，但是这种时候根据 Java 的风格，就 只能把同样的 catch 子句编写多次了。这样一来就违反了“同样的代码不能在多个位 置编写”的编码大原则。
当然，如果异常 A 和异常 B 用同样的超类的话，可以通过 catch 超类的方式达到目 的，但是异常的层级通常都是从提供异常类的角度、而不是从异常使用者的角度出发的。
假设“想要对异常 A 和异常 B 进行同样的处理”的时候，就必须要简单地描述 OR 条件，只有这样才可以考虑在 catch 子句中用逗号分隔的方式指定要处理的类（先忽 略如何将异常赋值给变量的事情）。还有一种情况，那就是“异常 A 和异常 B 使用同 样的处理方式，异常 C 使用另外的处理方式，但无论是什么样的异常，都会有输出日 志的通用处理”。基于上面这些考虑，我想还是像下面这样，在一个 catch 子句中使 用 if 语句来判断可能更好。

try{  ··· } catch (Exception e) {  // 通用处理
if (e instanceof A || e instanceof B) { // 处理异常A或者是异常B
} elsif (e instanceof C) { // 处理异常C
} else { // 预想外的异常向上throw throw;
} }

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

9.2　异常处理机制 2 9 7

但这个方法要想处理发生的意料之外的异常，就必须要在 if 语句的 else 子句中 继续 throw 异常。这段代码非常容易被忘记。
更重要的是，使用者既可以像 Java 那样编写多个 catch 子句，也可以像上面的代 码那样编写一个 catch 子句，但如果只写一个 catch 子句的话，编码方式就不能像 Java 一样了。这意味着给了使用者更多的选择，在这点上 Diksam 和 Java 是一致的。

9.2.4 异常的数据结构

try 语句中包含了 try、catch 和 finally 三个子句。用 DVM_Try 结构体 表示的话如下所示。

/* catch 子句 */

typedef struct {

int class_index; /* 使用了 catch 的类的索引值 */

int start_pc; /* catch 开始位置的 PC（程序计数器） */

int end_pc;

/* catch 结束位置的 PC */

} DVM_CatchClause;

/* try 语句 */

typedef struct {

int

try_start_pc; /* try 开始位置的 PC */

int

try_end_pc; /* try 结束位置的 PC */

int

catch_count; /* catch 子句的数量 */

DVM_CatchClause *catch_clause; /* catch 子句的可变长数组 */

int

finally_start_pc; /* finally 开始位置的 PC */

int

finally_end_pc; /* finally 结束位置的 PC */

} DVM_Try;

在 DVM_Try 结构体的可变长数组中可以添加顶层结构和 DVM_Function。 另外，由于顶层结构和函数（的程序块）增加了一些附加信息，因此这次把“程 序块”也作为结构体抽取了出来。

typedef struct { int DVM_Byte int DVM_LineNumber int DVM_Try int
} DVM_CodeBlock;

code_size;

*code;

line_number_size;

*line_number;

try_size; /* try 子句的数量 */

*try;

/* try 子句的可变长数组 */

need_stack_size;

虽 然 除 了 新 增 的 try 子 句 的 相 关 成 员 外， 其 他 成 员 都 在 以 前 的 DVM_

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

2 9 8 第 9 章　应用篇

代码清单 9-11 发生异常时的处理

Executable（顶层结构部分）和 DVM_Function（各函数部分）中出现过了， 但这里还是应该把它作为单 独 的 结 构 体 区 分 出 来。. DVM_Try 中 的 数 组（在 generate.c 中）在后续遍历（post-order. traversal）分析树时，每当遇到 try 语 句 的 时 候 就 在 数 组 末 尾 增 加 元 素（ generate_try_statement()）。 因 此， 这个数组是按照程序层级的深度来排列 try 语句的（越深层级的 try 就越被排 在前面）。
在发生异常的时候，首先将这个异常设置到 DVM_VirtualMachine 结构体 的 current_exception 成员（新增）中，再将 DVM 设置为“异常状态”。
基于以上介绍，我们以从 0 开始按顺序扫描 DVM_Try 的数组，寻找包含这 个位置的程序计数器的 try 语句。结果有以下几种情况。
1. 异常发生在try语句的try子句中 在这种情况下，首先要寻找捕捉已发生异常的catch子句，如果发现了，就解除 异常状态并将控制权移交给相应的catch子句。 如果没有与异常对应的catch子句，就把控制权移交给finally子句。
2. 异常发生在try语句的catch子句中 在这种情况中，不解除异常状态并将控制权移交给finally子句。
3. 异常发生在try语句的finally子句中 在这种情况中，和4.的处理方式相同。
4. 异常发生在try语句之外 强制从当前函数中返回，并试图从基于当前位置的DVM_Try中寻找包含当前程序 计数器的try语句，以此方式修正异常。

Diksam 的编译为了处理起来简单，不论 try 语句中是否有 finally 子句， 都将为它创建一个 finally。这个将在后面介绍。
这 个 处 理 的 代 码 如 代 码 清 单 9-11 所 示。 第 14 行 调 用 的 函 数 throw_in_ try()，会在上述 1、2 的情况下返回真。

1: static DVM_Boolean

2: do_throw(DVM_VirtualMachine *dvm,

3:

Function **func_p, DVM_Byte **code_p, int *code_size_p,

int *pc_p,

4:

int *base_p, ExecutableEntry **ee_p, DVM_Executable

**exe_p,

5:

DVM_ObjectRef *exception)

6: {

7:

DVM_Boolean in_try;

8: 

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

9.2　异常处理机制 2 9 9

9: 10:  11: 12: 13: 14: 15: 16: 17: 18: 19: 20: 21: 22: 23: 24: 25: 26: 27: 28: 29: 30: 31: 32: 33: 34: 35: 36: 37: 38: 39: 40: 41: 42: 43: }

dvm->current_exception = *exception;
for (;;) { /* 当异常发生在 try 语句的 try 子句或 catch 子句的时候， throw_in_try 函数会将设置跳转地址并返回真。*/ in_try = throw_in_try(dvm, *exe_p, *ee_p, *func_p, pc_p, &dvm->stack.stack_pointer, *base_p); if (in_try) break;
if (*func_p) { /* 当异常发生在 finally 子句或者 try 语句外的时候， 把发生异常的位置记录到栈轨迹中并强制返回。 在返回之后，将再次使用 throw_in_try 进行修复。*/ add_stack_trace(dvm, *exe_p, *func_p, *pc_p); /* do_return 在要程序返回原生函数时返回真，这里不做详细说明。*/ if(do_return(dvm, func_p, code_p, code_size_p, pc_p, base_p, ee_p, exe_p)){ return DVM_TRUE; }
} else { /* 在返回到顶层结构的时候将栈轨迹输出并终止程序的执行。 */ int func_index = dvm_search_function(dvm, DVM_DIKSAM_DEFAULT_T_PACKAGE, DIKSAM_PRINT_STACK_TRACE_FUNC); add_stack_trace(dvm, *exe_p, *func_p, *pc_p);
invoke_diksam_function_from_native(dvm, dvm->function[func_index], dvm->current_exception, NULL);
exit(1); } } return DVM_FALSE;

9.2.5 异常处理时生成的字节码
首先，在使用者编写了像 throw e; 这样的代码在抛出异常的时候，这里将 会创建 throw 指令。编译器会将眼前的 e 入栈，因此这个指令会抛出保存在栈 顶的异常。
Diksam 的异常与 C# 风格相似，只需要写 throw; 就可以将当前 catch 的 异常抛出去（请参考 9.2.2 节的补充知识）。在这个时候会创建指令 rethrow，但

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3 0 0 第 9 章　应用篇

是在 rethrow 指令中依旧不变地抛出保存在栈顶的异常（编译器会悄悄地把 在 catch 子句中定义的变量入栈）。和 throw 动作不同的只是不会重新设置栈 轨迹。  try 子句通常会生成下面这样的字节码（为了方便说明，使用了仿真代码， 并在左边添加了行号）。

1: # 在这里加入 try 子句的指令 2: go_finally 14 3: jump 16 4: # 第一个 catch 子句 5: pop_stack_object n # 将异常赋值给变量 6: # 这里插入 catch 子句的指令 7: go_finally 14 8: jump 16 9: # 第二个 catch 子句 10: pop_stack_object n # 将异常赋值给变量 11: # 这里插入 catch 子句的指令 12: go_finally 14 13: jump 16 14: # 这里插入 finally 子句的指令 15: finally_end 16: # 之后的处理
首先，请看一下每个 catch 子句开头的 pop_stack_object。这是为了在
下面这种情况时，把异常的引用赋值给变量 e。

} catch (HogeException e) { …
}

也就是说，DVM 将异常入栈为栈顶并将控制权移交给各 catch 子句。当

* 这 个 机 制 模 仿 了 JVM 的指令 jsr、return， 但 是 在 现 在 的 Java 中 并 没 有 使 用， 而 是 将 finally 子 句 的 代 码完全展开。 在 Sun 的 错 误 数 据 库 （Bug Database） 中 的 4381996 号 错 误① 使 用 原来的方式时，即使是 正确的代码，验证器也 会报错。

然，e 作为函数外的变量被 pop_static_object 创建。 在 try 子句、catch 子句的末尾都要生成 go_finally 指令。这意味着通
过在一个函数内部调用子例程的方式来调用 finally*。 乍 看 之 下， 我 认 为 不 需 要 特 意 增 加 这 个 指 令， 只 要 跳 转 到 第 14 行 就 可
以 了。 但 是， 正 如 9.2.2 节 中 写 到 的， 即 使 在 try 子 句 中 进 行 了 break 或 者 return，finally 子 句 也 必 然 会 执 行。 因 此， 如 果 try 子 句 中 包 含 了 break，编译器也会在 break 前面输出 go_finally 指令。执行 finally 子 句后，如果没有异常状态的话，就会执行 finally_end 指令返回到原来的位

A　地址：http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4381996。——译者注

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

9.2　异常处理机制 3 0 1
置。如果调用了 finally_end 后不能返回到原来的位置的话，就会执行和再次 抛出异常时同样的动作。  go_finally 会将返回的目的地的 pc 入栈。之所以必须要使用栈是因为 在 finally 中也可以编写 try 语句。
9.2.6 受查异常
Java 具有 受查异常 的功能。这是一种在方法声明时对方法可能抛出的异常 进行声明的功能（下面这段代码就表明了“这个方法有抛出 HogeException. 和 PiyoException 的可能”）。
void hoge() throws HogeException, PiyoException { …
}
这样一来，在调用上面的 hoge() 方法的时候，对于该方法的调用者来说， 要么 catch 所有已经被声明的异常，要么自己也通过 throws 抛出这些异常， 将处理异常的任务交给自己的调用者。如果你什么都不做，就会在编译时报错 （除非是 Error 或者 RuntimeException 的子类）。Java 利用这个功能保证应 该处理的异常已经全都被处理掉（至少是以此为目标）。
正如后面会介绍到的，对于这个功能也有一些异议，但我认为这是一个重要 的功能，因此在 Diksam 中也进行了实现。
Diksam 中受查异常的设计和 Java 相同。 首先，要让函数和方法能够描述 throws 子句。
// 为函数添加 throws void func() throws HogeException, PiyoException {
… }
在上述例子中，由于 func() 已经声明了它可能会发生 HogeException 和 PiyoException，这时候如果在函数内发生了上述两个异常之外的异常，并且 又没有 catch 的话，就会发生编译错误。
但 是， 像 NullPointerException 这 样 的 在 程 序 各 处 都 会 发 生 的 异 常 应 该 被 另 行 处 理。 在 Diksam 中 异 常 的 层 级 有 三 个， 它 们 分 别 是 BugExce
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3 0 2 第 9 章　应用篇

ption、RuntimeException 和 ApplicationException。 其 中， 只 有 ApplicationException 是受查异常检查的对象（图 9-8）。

 图 9-8 Diksam 的异常层级

Exception

BugException RuntimeException ApplicationException

只要没有程序错误 程序不能预期的异常 应该被程序预期到的异常 就不会发生的异常

* 我本来想把内存不足之 类的情况也加入到异 常 中， 但 是 在 现 在 的 Diksam 实 现 中， 只 有 在 MEM_malloc() 中 进 行 exit() 的 时 候 才 会 抛 出 异 常，MEM_ malloc() 本身并不会 发生异常。
* 不可思议的是，Java 把 这 个 异 常 归 类 为 RuntimeException。

例如，引用了 null 的时候会发生 NullPointerException，或者当访问 的元素超出了数组的返回时会发生 ArrayIndexOutOfBoundsException，这 些异常在 Diksam 中都被归类为 BugException。这是因为这些异常在调试结束后 的正式应用程序中是不应该发生的（我是这么认为的）。因此，BugException 不 应该被 catch。因为如果这么做就相当于在“掩盖程序错误”。
与此相对，即使没有程序错误也可能发生 RuntimeException，这是由于 在写程序的时候只考虑了一般的情况，没有考虑周全，从而发生了（我是这么认 为的）异常。在 Diksam 中，整数被 0 除也被归为这类异常 *。这样的异常应该在 调用的层级上被 catch 并进行适当地处理。  ApplicationException 的 发 生 是 被 充 分 预 期 的。 在 Diksam 中， 像. NumberFormatException 这样的异常被归入此类 *。像这样的异常一般会在 发生的地方立即由应用程序做适当地处理。
话说回来，由于在 Diksam 中 BugException“不应该被 catch”，因此， 还是“一旦 catch 了 BugException 就会发生编译错误”容易一点。但是现在之 所以没有这么做，是因为考虑到了像 Servlet 和 Applet 之类的在浏览器中运行的程 序，即使其中一个 Servlet 或者 Applet 中出现了程序错误也不应该导致整个程序的 崩溃。但是，在将来也可能会引入像 pragma 这样的功能，也许到了那个时候，除 了特殊的程序之外，再 catch 了 BugException 的话，编译就要报错了。
受查异常的实现在 fix_tree.c 中进行。 Diksam 编 译 器（在 fix_tree.c 中 ） 会 对 递 归 分 析 树“确 认 ”（请 参 考 6.3.4 节）。与此同时，也会进行受查异常的检查。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

9.2　异常处理机制 3 0 3

在递归扫描分析树的时候，在递归的路径上（也就是越深越优先）会创建语

句或表达式下级可能会发生的异常列表。此时，在 try 子句中发生的异常，除了

* 详细来说就是，这里涵 盖 了 在 catch 子 句 或 finally 子句中发生的 异 常（ 含 通 过 throw; 再次抛出的 Exception）。

会被 catch 子句捕捉之外，剩下的都会被当做是 try 语句发生的异常 *。这样 一来，在函数内发生异常的时候，没有声明 throws 的就会导致编译错误。.
  补充知识    受查异常的是与非 

在 Java 中有受查异常，但是在 C# 中没有。C# 是晚于 Java 面世的编程语言，因 此很多地方都模仿了 Java，所以可以断定这个功能是有意被剔除的。关于这点，C# 的 作者安德斯·海尔斯伯格（Anders Hejlsberg）例举了下面两个理由（应笔者邀请）。
The Trouble with Checked Exceptions[11] ●● 方法升级的时候 throws 子句中的异常可能也会随之增加，这样就会影响所有的使 用者。实际上，在很多情况下，调用者并不会关心异常的种类，也不会对它们做个 别处理。 ●● 在扩展性上存在问题。受查异常在很小的程序中可以顺利运行，但是在构建有 4 个 到 5 个子系统的系统时，每个子系统又返回 4~10 种异常的话，在多个子系统集成 的时候就不得不在 throws 后面写上很多的异常。

另外，在下一页中，在上面这些理由的基础上又追加了以下理由（这里也是应笔者 邀请）。 《Java 理论与实践：关于异常的争论 要检查，还是不要检查》[12]
●● throws 子句暴露了实现的详细内容。如果在“搜索用户”方法的 throws 中有一 个 SQLException，这可不是一件好事。
●（●  只要是有受查异常）使用者编写了空的 catch 子句，异常也会被当做处理掉了。

* 在 [12] 中也举出了诸如
“异常过度包装”之类
的缺点，也算是表达了
对这个功能的不满。

上面说了这么多的问题，其实可以通过异常包装的方式来应对。以“搜索用户方 法”为例，应该抛出像 NoSuchUserException 这样的、对于当前方法层级有意义的 异常。从而，如果发生异常的原因是 SQLException 的话，应该抛出一个以成员形式 保存了 SQLException 的 NoSuchUserException。
这个机制，在 Java1.4 中被引入，C# 一开始也有这样的功能。以此为前提的话， 我认为受查异常也不是特别“坏”的功能 *。
另外，在受查异常中最让人反感的就是，所有方法都只写一句 throws Exception。对于这点，虽然编程语言支持这么做，但是在不需要使用受查异常的时候还是 不用为好。至于在 Diksam 中如何使用，就交给使用者来选择了。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3 0 4 第 9 章　应用篇

  补充知识    异常处理本身的是与非 

既然说到了受查异常的是与非，让我们再来看看关于异常处理的两派的论调。 在一本叫作 Joel on Software（很有名）的书中，作者 Joel Spolsky 关于异常的论 述如下（拙译）：
Exceptions [13] ●●在源代码中很难看到异常。因为不知道哪里会发生异常，所以即使很缜密地检查
了代码，还是很难发现其中的错误。 ●●异常赋予了程序多个“出口”。在编写正确的代码中，程序一定能够掌握执行的
路径，但是加入了异常后这件事就办不到了。
Windows 的开发者 Raymond Chen 把异常和早先在返回值中返回错误编码的方式 做了比较，请见表 9-1 和表 9-2[14（] 拙译）。

表 9-1 错误编码和异常的比较 1

 很简单 
●使用错误编码编写出不好 的代码
●使用异常编写出不好的代码

 难 
●使用错误编码编写出良好 的代码

 很难  ●使用异常编写出良好的代码

表 9-2 错误编码和异常的比较 2

 很简单 

 难 

 很难 

●认识到使用错误编码编写 出了晦涩难懂的代码
●使用错误编码编写的，能 够分辨出不好的代码和良 好的代码

●认识到使用错误编码编写 出了通顺易懂的代码

●认识到使用异常编写出了 晦涩难懂的代码
●使用异常编写出来的，能 够分辨出不好的代码和良 好的代码
●认识到使用异常编写出了 通顺易懂的代码

下面就举一个实际的例子。
1: NotifyIcon CreateNotifyIcon() 2: { 3: NotifyIcon icon = new NotifyIcon(); 4: icon.Text = "Blah blah blah"; 5: icon.Visible = true; 6: icon.Icon = new Icon(GetType(), "cool.ico");

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

9.3　构建脚本 3 0 5

* 实际试一下的话，在我 的环境中没有发生什么 特别的问题。
* 这 里 假 设 node.children 的值为 null。
* 不管怎么说，利用返回 值进行手工处理的方式 是行不通的。之所以这 么 说 是 因 为， 我 不 相 信人类（当然包括我自 己）。

7: return icon; 8: }
这段程序本来应该将第 5 行和第 6 行反过来写。这是因为在图标创建失败的时候， 第 6 行会发生异常，此时就没有必要把 icon.Visible 设置为 true 了 *。
可能上述这个 Windows 编程的经验之谈不太好理解，我再（要举的话还有很多 呢）举一个其他的例子。在构建树结构的时候，给父增加子的代码。
node.children = new Node[5]; for (i = 0; i < 5; i++) {  node.children[i] = new Node(); }
在这段代码中，如果前三次循环都正常地执行、第四次的时候发生了异常的话，数 组 node.children 就会从中间开始变成 null。从数据结构上讲，这种情况大多是不 被允许的。在这种情况下，即便是在上层的某处捕获到了异常也很难修复这个错误。为 了避免这种情况的发生，应该像下面这样编写代码 *。
Node[] nodeArray = new Node[5]; for (i = 0; i < 5; i++) {  nodeArray[i] = new Node(); } node.children = nodeArray;
但是，如何能够在程序的所有地方都防止这样的错误发生呢？ 结果，话题还是回到是不是应该存在异常处理机制的问题上。当然，完美的异常处 理是非常困难的。但是，现实中在对信任关系的要求没有那么严格，使用异常处理还可 以准确地将错误传递给上层的情况下，我认为异常处理机制还是有必要的 *。
对于编写一个将许多数据搜集起来并每日打印一次的小脚本来说，异常可真是 个好东西，它可以忽略掉所有会引起问题的地方。我非常喜欢做的就是，利用 try/catch 整理程序，并在发生异常的时候将问题通过邮件发给我。但是异 常只适合一些粗略的工作或者脚本，并不适合关键性的任务和与维持生命相关 的程序。假如在操作系统、核能发电或者心脏手术中使用的高速旋转骨锯的控 制软件中使用异常的话，是相当危险的事情。
——Joel Spolsky《软件随想录：程序员部落酋长 Joel 谈软件》[15]

9.3 构建脚本
在 3.3.5 节中我们已经接触过了，我认为编程语言的处理器应该尽可能让程 序通过一个可执行文件就可以运行。任何一种语言，在其制作的初期都是个不成

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3 0 6 第 9 章　应用篇
熟的语言，因此不可能在一开始安装的时候就让人有所期待。另外，在别人试用 语言的时候，要花费很多时间进行高门槛的安装过程可不是一个好主意。
在代码清单 9-7 中例举的异常类程序，在 crowbar 中编写的话就非常简单了， 但是要在 C 语言中编写的话我想可能要花不少的功夫。因此，我们需要一种用 crowbar 编写源代码，将 crowbar 本身打包为可执行文件的方法。
另外，虽然 Diksam 中以外部文件的形式保存着现在的 diksam.lang 包的 源代码，但我还是想要把它打包到可执行文件中去。
在这里让我们研究一下这个方法。
9.3.1 基本思路
首 先 先 来 研 究 一 下 crowbar。. 想 法 很 简 单， 比 如 下 面 这 段 crowbar 代 码 builtin.crb ：
function create_exception_class(parent) { this = new_object(); this.parent = parent; this.create = closure(message) {
（之后省略）
基于上面这段代码，生成了下面的 C 代码。也就是说，crowbar 的代码被作 为 C 语言的字符串保存起来。
#include <stdio.h> #include "CRB.h"
static char *st_builtin_src[] = { "function create_exception_class(parent) {\n", " this = new_object();\n", " this.parent = parent;\n", " this.create = closure(message) {\n",
（之后省略）
之后再进行编译、链接、执行的时候，在加载使用者指定的 crowbar 源代码 之前，先编译这段字符串就可以了。
另外，将 builtin.crb 转换成为 C 语言代码的程序是在 crowbar 中编写的。 当然，这段程序必须要在编译 crowbar 的过程中。为了在编译 crowbar 的过 程中能让 crowbar 运行起来，我又制作了没有组建构建脚本状态的“minicrowbar”
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

9.3　构建脚本 3 0 7
可执行文件，并且利用 minicrowbar 来完成转换工作。 也不是特意要做这样细致的工作，而是我觉得用 C 语言写这种字符串转换程
序不太好。在我的意识中，crowbar 作为一门以 Perl 为目标的语言，确实还是应 该在 crowbar 中进行字符串处理。这也是为什么我要尝试着去这么做的原因。.
9.3.2 YY_INPUT
保存在 C 语言字符串字面量中的 crowbar 代码，会在使用者编写的程序之前 进行编译。
制作 crowbar 的时候，编译采用了 yacc 和 lex 协同作业的方式。因此，最先 加载源代码的是 lex（生成的程序）。lex（生成的程序）在默认状态下将从全局变 量 yyin 的文件指针中加载源代码（如代码清单 2-2）。
但是，这次不是从文件中加载，而是加载内存中的字符串。在这种情况下， flex 会使用宏 YY_INPUT（但是，这个宏的移植性未必很高）。
像下面这样，通过替换 YY_INPUT 的定义，可将 fle 的标准的输入例程替换 为单独的输入例程。
/* crowbar.l 的开头 */ #undef YY_INPUT #define YY_INPUT(buf, result, max_size)(result = my_yyinput(buf, max_size))
输入例程要接收缓冲和缓冲大小（fgets() 流）两个参数，缓冲中存入字 符串并返回该字符串的字数。缓冲必须以“\0”结尾。
crowbar 的 my_yyinput() 引用了当前解释器的“输入模式”，在有 CRB_ FILE_INPUT_MODE 的情况下从文件中输入，在有 CRB_STRING_INPUT_MODE 的 情况下从字符串输入。这个“输入模式”保存在 CRB_Interpreter 中。
构建脚本将在创建 CRB_Interpreter 的时候进行编译。在这之后，将使 用同一个解释器编译用户程序，此时为了能够让用户程序发生错误时显示正确的 行号，解释器中保存的行号会被重置为 1。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3 0 8 第 9 章　应用篇
9.3.3 Diksam 的构建脚本
在 Diksam 的 book_ver.0.3 中，diksam.lang 是以外部文件的形式存在的， 单独的可执行文件没办法运行。这对于构建脚本来说的确不太方便。
虽然 Diksam 的程序可以由多个文件组成，但是基本思路还是和 crowbar 一样。
构建脚本并没有在文件系统中保存源文件的实体，因此，会在源文件的搜索 路径 DKM_REQUIRE_SEARCH_PATH、DKM_LOAD_SEARCH_PATH 的开头默认添 加上。
另 外， 和 这 个 修 改 一 并 完 成 的， 还 有 使 用 者 即 使 不 显 式 require 标 准 包 diksam.lang，它也会被默认 require 进来。
9.3.4 三次加载 / 链接
在之前的 Diksam 中，push_function、new 等指令的操作数是函数和类的 索引值，它们通过以下方法取值 A（在 8.1.5 节中已经介绍过）。
●● 在编译的时候，将每个 DVM_Executable 中固有的索引值作为操作数。 ●● 在向 DVM 中加载的时候，将字节码中的对应位置替换为 DVM_VirtualMachine 中
固有的索引值。 在这种方法中，一个 DVM_Executable 被特化到一个 DVM 中，因此在多 个 DVM 中不能共享 DVM_Executable。 可能有人会问了：“当初为什么要创建多个 DVM 呢？”例如，在 Web 应用中， 一台服务器上很可能运行着多个应用程序，在这种情况下，不是应该为每个应用 程序分别分配不同的 DVM 吗？再举一个其他的例子，在用 Diksam 编写 Diksam 的集成开发环境（IDE）的情况下，驱动 IDE 的 DVM 和在 IDE 的菜单上选择 “执行”而启动起来的 DVM，也应该是两个不同的 DVM。 因此，这次我们引入了间接引用对照表，通过它就可以不用再替换字节码中 函数和类的索引值了。间接引用对照表保存在 ExecutableEntry 中，在加载的
A　在不同的阶段中取值也不同。——译者注
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

9.4　为 crowbar 引入鬼车 3 0 9

时候创建。.

struct ExecutableEntry_tag {

DVM_Executable *executable;

int

*function_table; ←函数的间接引用对照表

int

*class_table;

←类的间接引用对照表

int

*enum_table;

←枚举的间接引用对照表

int

*constant_table; ←常量的间接引用对照表

Static

static_v;

struct ExecutableEntry_tag *next;

};

并且，按说在加载时局部变量的偏移量也要进行字节码的替换，但是这次并 没有修改。这里说的替换通常在同样的机器上运行的 DVM 中，也会出现相同的 结果。.

9.4 为 crowbar 引入鬼车
crowbar 名字是由“像 Perl 一样的语言”而来的。 近些年来，Perl 被应用在了各个领域中，但是早期的 Perl 只是用来处理文本 文件的。说起处理文本文件，最方便的莫过于正则表达式了。 但是想要从零开始制作一个正则表达式引擎的话太困难了，因此我们引入现 有的正则表达式程序库“鬼车”。.
9.4.1 关于“鬼车”
“鬼车”是小迫先生开发的正则表达式程序库。 官方网站（英语）： http://www.geocities.jp/kosako3/oniguruma/ 在写作本书的时候最新版本为 5.9.1A，UNIX（含 Mac 操作系统）和 Windows 都可以安装。许可类型为 BSD 许可，标明著作权、许可条文和免责条款后，可以
A　现在最新版本是 5.9.4。——译者注

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3 1 0 第 9 章　应用篇
在自制软件中（可以不开放源代码）自由使用。. 因为使用了这个程序库，所以可以简单地将正则表达式引入到 crowbar 中。
在这里要感谢开发者小迫先生。 具体的安装方法和程序库的使用方法，考虑到很有可能会发生变化，请大家
直接参考网站的内容。 http://avnpc.com/pages/devlang#oniguruma
9.4.2 正则表达式常量
在编程语言中处理正则表达式的时候，问题在于要将正则表达式特化到什么 程度。
在 Perl 的 语 言 设 计 上， 专 门 针 对 正 则 表 达 式 进 行 了 优 化。 无 论 s///、m/// 还是 s///g 亦或 =~，这些在我看来都太僵化了。对于在 AWK 级别中对文本处理进行特化的语言来说，这样也许很好，但是我不想让 crowbar 变成这样。
反之在 Java 和 PHP 中并没有直接支持正则表达式，而是用程序库的方式支 持正则表达式。也许有人会想，这么做也还行吧。在这种情况下，如果只使用单 纯的字符串来表现正则表达式的话，在字符串字面量中可能会含有特殊含义的字 符，因此不得不进行编码处理。字符串字面量包含的特殊含义的字符，很有可能 在正则表达式中也具有特殊的含义。为了使用这样的字符，在正在表达式中还要 进行编码，即必须要进行双重编码。因此，例如 Java 中匹配 \ 的正则表达式必须 要写成 \\\\。这让人感觉很愚蠢。
不知道是不是为了解决这个问题，在 Python 中引入了 raw.string 的概念。在 Python 中，
r" 字符串 "
这样在字符串前面加上 r 的话，在这个字符串中像 \ 这样的字符将不再具有 特殊含义。如此一来，匹配 \ 的正则表达式只要写成 \\ 就可以了。在 C# 中加 上了 @ 的字符串（逐字字符串：verbatim.string.literal）能达到同样的效果。
但是，如果 \ 没有特殊含义的话，字符串字面量中出现了 " 的时候该怎么办呢？ Python 的使用手册 [16] 中写道：
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

9.4　为 crowbar 引入鬼车 3 1 1
引 号 可 以 用 反 斜 杠 进 行 编 码， 但 是 这 样 一 来 反 斜 杠 本 身 就 成 了 遗 留 问 题。 例 如， r"\"" 是正确的字符串字面量，说明由反斜杠和双引号组成了一个字符串，而 r"\" 则 是错误的字符串字面量（raw 字符串不能以反斜杠和连续奇数个字符串结尾）。 严格地 说，（因为反斜杠会编码跟在它后面的引号）**raw 字符串不能以单个反斜杠结束 **。 在我看来，这是一种招致混乱的设计（顺便说一下，C# 的逐字字符串采用了 两个双引号写在一起代表一个双引号的设计，这种设计与 Pascal 相似）。 另外，如果想要高效地解释正则表达式，就必须要进行事先编译。但是，对 于使用者（crowbar 程序员）来说，每次都编译十分麻烦。在大多数的程序中， 正则表达式都不是在运行时组合而成的，因此可以在编译源代码的同时编译正则 表达式。这样一来，作为一门编程语言来说，它就需要一种表现“正则表达式字 面量”的格式。 在 Ruby 中，通过 %! 字符串！的方式可以实现跟 Python 的 raw.string 一样 的效果。与 Python 不同的是，! 可以是任意字符串。这种方法中，只要使用字 符串字面量中没有的字符把字符串包起来即可，也很好地回避了 Python 中出现 的问题。另外，在 Ruby 中通过 %r! 正则表达式！的方式可以表示一个正则表达 式字面量，使用这种方式定义的字面量，可以在编译时先编译正则表达式。但在 crowbar 中，% 会被当做模运算符来使用，也充分考虑到了（运算符左右两边不需 要输入空格）像 a%r+3 这样的程序。 从而在 crowbar 中，采用了 %%r" 正则表达式 " 的格式。和 Ruby 一样，%%r 后 面可以是任意的字符。也就是说，%%r"hoge" 和 %%r!hoge! 两种写法达到的效 果是相同的。 但是实际上，这样的语法一旦用多了，就会出现各种各样的符号（用来定义 正则表达式），看上去就不那么美观了。
9.4.3 正则表达式的相关函数
crowbar 中与正则表达式相关的函数如下所示。.
●● reg_match(regexp, subject, region); 对字符串 subject 使用正则表达式 regexp 进行匹配，如果匹配返回 true， 不匹配则返回 false。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3 1 2 第 9 章　应用篇
可以省略 region，也可以传入一个使用 new_object() 创建的对象。 在 region 中 会 返 回 string、begin、end 三 个 数 组 成 员。 例 如 正 则 表 达 式 "hoge(.*)piyo"，string[0] 中 保 存 着 与 表 达 式 全 部 匹 配 的 字 符 串，string[1] 中保存着与“\1”（也就是正则表达式的 (.*) 部分）匹配的字符 串。start、end 返回 string[n] 开始和结束位置 +1（这个设计是照搬鬼车的）。 ●● reg_replace(regexp, replacement, subject); 在 字 符 串 subject 中， 将 匹 配 正 则 表 达 式 regexp 的 部 分 替 换 为 字 符 串 replacement，并返回替换后的字符串。如果有多个位置匹配，则替换第一 个匹配的位置。 ●● reg_replace_all(regexp, replacement, subject); 在 字 符 串 subject 中， 将 匹 配 正 则 表 达 式 regexp 的 部 分 替 换 为 字 符 串 replacement，并返回替换后的字符串。替换针对所有匹配的位置进行。 包括 reg_replace() 在内，在 replacement 中可以使用回  溯引用，  replacement 的类型只能是字符串。但我想，给 reg_replace() 传递的 \1 是不是必须要写 成 \\1 呢？实际上在 crowbar 中，含有 \n（换行符）和 \t（制表符）的字符串字面 量需要特殊处理，因为在 crowbar 中没有将 \025、和 \x5c 之类的八进制或者十六进 制的数值嵌入到字符串中（C 语言中有）的功能，所以将 \1 写为 \1 也是没有问题的（看 到这肯定会有人问我：“那前面那节的讨论还有什么意义呢？”）。 ——虽然可能有人会认为以后使用这种设计比较好，但是我认为现在这样也没什 么问题。 ●● reg_split(regexp, subject); 用 regexp 分割字符串 subject，返回分割后的字符串数组。
9.5 其他
9.5.1 foreach 和迭代器（crowbar）
在 9.1.3 节的注解中写道：“但是，在 crowbar 的标准中，并不是引入 foreach. 函 数， 而 是 引 入 foreach 语 法。” 如 前 面 所 述， 有 了 闭 包， 即 使 语 言 本 身 不 支 持， 也 可 以 进 行 类 似 foreach 的 实 现。 但 在 crowbar 的 闭 包 中， 不 能 使
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

9.5　其他 3 1 3

* 如果使用 Java 提出的闭
包 unrestricted closure，
就 可 以 实 现 break 或
者 continue。

用 break、continue、while 等语句 *，因此，crowbar 中支持了 foreach。 crowbar 的 foreach 的使用方法如下所示。
a = {1, 2, 3, 4, 5, 6};

foreach(v : a) { print("(" + v + ")");
}

foreach 的语法根据语言而异，比如在 C# 中是这样的。

foreach (Object o in hogeCollection) {
// 处理 }

Java 中虽然没有 foreach，但是对 for 语句进行了扩展，使用方法如下。

for (Object o : hogeCollection){ // 使用 o 进行处理
}

crowbar 中的 foreach 结合了上面两种语言的特点。这么做的原因，首先是

如果没有 foreach 语句的话，那么程序员之间就没办法在交流的时候说“这里

用 foreach 转一下”。可话虽如此，但是像 C# 这样将 in 之类的又短又经常会

被用到的单词作为关键字，总觉得有一些不安。

在上面的例子中，使用 foreach 轮询了一个数组，这是因为数组具有迭代

器（iterator）的所有方法。

* GoF 是“Gang of Four” 的 简 称。《 面 向 对 象 的 设计模式》的四位作者 组成了四人组，被业界 称为“四人帮”。他们的 书也被称为 GoF 的书。

crowbar 中的迭代器采用了 GoF* 的风格，具有以下这些方法。 ● first()
返回迭代器中的第一个元素。 ●● next()

将迭代器的指向向后移动一个。

●● is_done() 迭代器移动到超出最后一个元素的位置时返回 true，否则返回 false。

●● current_item() 返回迭代器中当前的元素。

习惯了 Java 的人可能会觉得这样的设计和记忆中的不太一致，这是因为 Java 的迭代器指向数组的元素和元素之间。调用 next() 的时候，迭代器移动到下一

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3 1 4 第 9 章　应用篇
个“元素和元素之间”，此时返回的是它跨过的那个元素。 与此相对，crowbar 的迭代器（GoF 风格）是直接指向元素的。因此，使
用 current_item() 方法可以取得当前元素，只要不调用 next()，无论调用 几次 current_item()，返回的都是同样的元素。
至于哪种设计方式更好，肯定会有各种不同的意见。但是我觉得 Java 设计对 于我来说很不好用（只是“看一下”这个元素，迭代器就移动到下一个元素了）， 因此，这里使用了 GoF 风格的设计方式。
——虽然是这么说，但取得数组的迭代器的方法如果是 GoF 风格的话，本应 叫作 CreateIterator()，可这个名字实在是太长了，因此叫作 iterator() 了。 只有这点可以说是使用了 Java 的风格，没有与 GoF 风格统一。
数组迭代器的实现如下所示。_ _create_array_iterator() 是创建迭代 器用的隐藏函数，被记录在构建脚本中。数组的 iterator() 方法所返回的迭 代器就是调用这个函数取得的。.
function _ _create_array_iterator(array) { this = new_object(); index = 0; this.first = closure() { index = 0; }; this.next = closure() { index++; }; this.is_done = closure() { return index >= array.size(); }; this.current_item = closure() { return array[index]; }; return this;
}
9.5.2 switch case（Diksam）
本节将为 Diksam 引入 switch case。  switch case 语句在 C、Java、C# 等语言中都存在，但是 C 中的 switch case 却很不像话，里面并不能写 break 语句，也就是说，switch case 每次
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

9.5　其他 3 1 5

* 如果在 case 后面没有
任 何 语 句（ 只 有 case
语句）的情况下，可以
省略 break。

都要从上至下一直执行到结束。Java 在这点上也是一样。C# 的语法结构看上去 和 C 一样，但是如果在 case 的末尾不加上 break 的话就会发生编译错误。这 种设计方式正好解决了这个问题 *。此处贯彻了让习惯了 C 和 Java 的程序员容易 上手的宗旨，在这点上 Diksam 做了很多妥协。但是在这个问题上如果去迎合 C 语言的话，就不太符合我的审美观了。话说回来，Diksam 中是这样进行 switch case 的。.

switch(a) case 1 {
// a 等于 1 时执行 } case 2,3 {
// a 等于 2 或 3 时执行 } case 4 {
// a 等于 4 时执行 } default {
// a 不等于上面的 1、2、3、4 时执行 }

并且，Diksam 的 switch case 在原则上只要是能通过 == 进行比较的，就 都可以通过 switch 表达式（上例中的 a）和 case 表达式（区别在于在 == 的时 候会发生类型转换，switch 的时候不会发生）。因此，字符串等类型也可以使 用 switch case。.

9.5.3 enum（Diksam）
Diksam 中也同样引入了 枚举类型（   enumerated.type）。.
enum Fruits { APPLE, ORANGE, BANANA
}
有了上面的定义，就可以使用 Fruits.APPLE、Fruits.ORANGE、Fruits. BANANA 的 枚举（   enumerator）了。
Diksam 的枚举类型内部保存的是从 0 开始顺序编号的 int，但是并不能作为 int 类型进行四则运算、赋值给 int 类型以及与 int 类型进行比较运算，只能够 在同一枚举类之间比较（这些功能可能经常会被用到，因此这里策略性地破坏了

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3 1 6 第 9 章　应用篇
美感，但可以比较大小）。 另外，在用 + 连接左边的字符串时，枚举类型会转换为字符串类型。.
Fruits f = Fruits.ORANGE; println("f.." + f); // 输出 "f..ORANGE"
如果没有这个设计的话，枚举在编译的时候就可以转换为整数类型了（现在 的 Diksam 还不能将字节码保存为文件）。为了将枚举作为字符串输出，必须要把 对应的字符串保存在 DVM_Executable 中。另外，还必须要和其他源文件进行 链接。为了达到这个目的，在 ExecutableEntry 中与函数和类一样保存了一 份转换对应表（请参考 9.3.4 节）。.
9.5.4 delegate（Diksam）
在 Diksam 的语法规则中，函数调用是下面这样的。
primary_expression LP argument_list RP
也就是说，函数调用表达式是在表达式后面加上括号并且里面括着参数。如 果要把语法规则变成下面这样的话，实际上简单了不少。
IDENTIFIER LP argument_list RP
如果变成了上面这样，当然，是为了实现在类似于 C 的语言中所说的函数指 针。例如为 GUI 的按钮分配处理的时候，在 Java 中要创建一个实现了特定接口 的类的实例（事件监听器），并将它设置到按钮中。这种方法存在以下的问题：
●● 需要为此特意去定义一个类，不仅麻烦也会使代码变得冗长。 ●● 按下按钮时，处理会被编写在别的类里面，对于这个类来说等于放宽了类的封装。
虽然使用内部类可以解决这个问题，但也因此又带来了内部类的使用问题。（对于 实现语言的人来说）这个方法太麻烦了，而且对于初学者来说也不太容易掌握。 ●● 在按下按钮的时候，事件也可以由承载了按钮的类（JFrame 等）接收。如果使用 了这种处理方式，在这个类中有两个按钮的话，就无法为它们分配单独的动作。 因为只是“想要执行按下按钮时的处理”，所以很自然地就会想到，如果能 只登录描述了处理的函数就好了（可能不得不使用闭包，但是在 Diksam 中却不 能使用）。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

9.5　其他 3 1 7

为了能够达到上述效果，就需要为静态类型的语言 Diksam 引入“函数类型” （在 C 语言中的话就是指向函数的指针型）。
如果想要声明一个“接收 int 参数，返回 double 函数”的类型，肯定不能 像 C 语言这样编写代码。

double (*func)(int);
说到 Java，从 Java7 开始就有了要引入闭包的说法，当初设想的是下面这样 的代码。

double(int) func;
但是在 Java（Diksam）中存在检查异常，如果把 throws 也作为方法必要的 信息，就要写成下面这样。

double(int) throws HogeException, PiyoException func;
上面的写法是因为在语法上存在不确定性，所以需要改为下面这样的写法。

double(int) throws HogeException | PiyoException func;
相反也可以试着像下面这样定义。

{ int => double } func;

* 很明显，在 Java7 中并
没有加入这个功能。

从 2009 年 5 月到现在，就连是否要引入（闭包）这个问题本身都还没有得 出结论 *。说句题外话，无论哪种写法我都觉得太长了（使用起来至少也要像 C 语言中的 typeof 那样）。
因此，在 Diksam 中，引入了 C# 风格的关键字 delegate。

delegate double Func(int value) throws HogeException, PiyoException;
根据这个描述，Func 被定义为“接受 int 型参数，返回 double，可能会 抛出 HogeException 和 PiyoException 的函数”的类型。
基于上面的定义，就可以声明 Func 类型的变量，参数中也可以接收 Func. 类型了。
// 定义 Func delegate double Func(int value) throws HogeException, PiyoException;

// 定义函数 double func(int value) throws HogeException, PiyoException{
… }

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3 1 8 第 9 章　应用篇

// 将 func 赋值给 Func 型的变量 f Func f = func;

// 通过 f 调用 func f(5);

* C# 从 2.0 开 始 也 不 需
要 new 了。

与 C# 的 delegate 不同，Diksam 的 delegate 类型并不是类的对象。因 此，没有必要使用 new*，也可以说不能 new。另外，不能将多个函数赋值到一 个 delegate 中。
另外，在给 delegate 类型的变量赋值的时候，和方法重写时一样，返回值 必须共变，参数必须反变。
方法也可以赋值给 delegate 类型的变量，此时，方法所在对象的引用也会 被保存到变量中。因此，方法在作为事件句柄被调用的时候，也可以和平常一样 使用 this 引用。
在实现上，delegate 类型的值作为 DVM_Object 的联合体之一保存在堆 中。delegate 型变量如果保存的是方法的话，就必须要同时保存方法所在对象 的引用，因此，需要保存的信息如下所示。

/* 保存 delegate 信息的结构体 */

typedef struct {

/* 如果保存的是方法，那么这个成员保存的是方法所在对象的引用。如果是函数则为 null */

DVM_ObjectRef

object;

/* 函数或者方法的索引值 */

int

index;

} Delegate;

/* 在 DVM_Object 结构体中通过联合体保存上述结构体 */

struct DVM_Object_tag {

ObjectType type;

unsigned int

marked:1;

union {

DVM_String

string;

DVM_Array

array;

DVM_ClassObject class_object;

NativePointer native_pointer;

Delegate

delegate; ←这个

} u; struct DVM_Object_tag *prev; struct DVM_Object_tag *next; };

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

9.5　其他 3 1 9
那么，关于 delegate 对象的创建时机，从语言实现的角度讲，无论是函 数还是方法，让调用总是通过 delegate 对象的话比较容易实现。无论是调 用 print("hello"); 这样的函数，还是调用 obj.method() 这样的方法，在 它们对 print、obj.methodA 进行计算的时候就会创建 delegate。但是，向堆 中保存对象是一项开销很大的处理，大多数情况下，print 也不会赋值给其他变 量，而是立即调用。为了不因个别情况而影响整体的效率，delegate 对象在以 下时机被创建。
1. 在函数的情况下，当函数赋值给delegate变量的时候。 2. 在方法的情况下，通过非立即调用的形式进行了（表达式）计算的时候。
另外，delegate 对象在指向方法的时候也引用了对应的对象，这样做会导 致这个对象不能成为 GC 的目标。因此也需要对 GC 进行修改。
9.5.5 ﬁnal、const（Diksam）
crowbar 想要定义常量的时候，要使用 final（Java 风格）。
final HOGE = 10;
在变量声明时如果加了 final 的话，在赋了初始值之后，就不能再对其进 行赋值了。并且，必须要在声明的同时完成赋初始值的动作。final 也可以用于 局部变量。
在 Diksam 中，同样使用了 final。
final int HOGE = 10;
在 Diksam 中函数的形式参数、catch 子句中接收异常的变量，都默认为 是 final 的。这样做的目的在于，不让从被调用的位置或者异常发生的源头获得 的重要信息被稀里糊涂地覆盖掉。
在 Diksam 中允许分割编译，并且不存在跨源文件的全局变量。为了不出现 乱用全局变量的情况，我认为最好的方式是通过 get_xxx() 和 set_xxx() 函 数。但是在大规模的程序中，可能需要被所有程序引用的全局常量。
但是，我认为，与其抛弃“不存在跨源文件的全局变量”等（和其他语言相
A　这两行代码在被 ()调用前，会被当做表达式。——译者注
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3 2 0 第 9 章　应用篇
比有些特别）的设计，直接允许使用全局变量，不如声明加了 final 的全局常 量可能更好一些。但实际上并没有这么简单。Diksam 具有顶层结构，顶层结构 是由被执行的语句组成的。因此，即使在函数外声明了变量（如果是 C 语言的 话，就是声明全局变量），在声明语句被执行前是得不到初始值的。这样一来， 因为 require 了的其他文件源代码的顶层结构（在编译时）是绝对不会执行的，. 所以即使用 final 声明的常量可以被其他源文件 require。但是在编译时来看， 它并没有被赋值，因此达不到预期的效果。
因此，在 Diksam 中配合着 final 引入了 const 这个关键字。const 的使 用方法如下所示。
const HOGE = 10;
因为通过初始值可以判断类型，所以 const 无需指定类型。 const 与函数定义、枚举、delegate 的声明一样，不能写在函数内。另 外，可以从其他源文件中被引用。 在为 const 指定的常量设置值的时候，需要考虑以下的情况。 1. 与C语言的预处理相同，在编译前就要置换常量。 2. 在编译时置换常量。 3. 编译时与变量采取同样的实例，在开始执行时再将值代入。 1、2 在编译前和编译时进行替换的方法在执行效率方面具有优势，但是对于 使用者来说，会由于不能定义如下形式的常量而困扰。.
const HOURS_IN_DAY = 24;// 一天 24 小时 const MINUTES_IN_DAY = HOURS_IN_DAY * 60;// 1 天 = 24 × 60 分
如果要在编译时或者编译前置换常量，那么这些表达式在编译时就必须要全 部执行。如“数组大小”等被作为常量表达式处理的话，就需要（在编译时）调 用数组的 size() 方法。这样的做法太困难了，因此 Diksam 还是采用了方法 3。
所 有 包 含 有 代 码 的 const 常 量 的 初 始 值 都 将 作 为 字 节 码 保 存 在 DVM_ Executable 中，在编译 / 加载源代码的时候再去执行它们。初始值中可以书写 任意的表达式，既可以使用 new 分配对象，也可以使用原生函数分配特定的系统 资源（例如 stdin、stdout、stderr 文件指针等）。
因 为 const 常 量 会 被 其 他 文 件 链 接， 所 以 与 函 数、 类、 枚 举 一 样 在. ExecutableEntry 中保存了转换对应表。.
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

 附录
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

附录 A

crowbar 语言的设计
. 本 章 将 要 说 明 在 本 书 中 crowbar 的 最 终 版 本（book_ver.0.4） 的 设 计。.
但是，本章中的内容既不是定稿版的文档，也不是很严谨。因为如果想要严谨地 描述一门语言的设计需要相当的篇幅。.

A.1 程序结构

构成程序的要素
crowbar 的程序由以下要素构成。 1. 顶层结构
顶层结构（toplevel）由 语句（   statement）组成。crowbar 的程序由处理器指 定的源文件的顶层结构开始执行。. 2. 函数定义 
函数定义（. function.definition）是定义可以（可能）从其他位置调用的函数。 在顶层结构的语句按顺序执行的时候会忽略函数定义。因为函数允许回溯引用， 所以其定义的位置既可以在调用的位置之前，也可以在调用的位置之后。.
A.2 文字语法规则

A.2.1 源文件的编码
crowbar 的源文件使用与处理器相同的字符编码。当前确定的是在 UNIX 环 境中为 EUC 和 UTF-8，在 Windows 环境中为 GB2312。除了写注释和定义字符串

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

A.2　文字语法规则 3 2 3
字面量之外的情况，都不能使用非 ASCII 字符。
A.2.2 关键字
下面这些单词作为 crowbar 的关键字，不能作为变量名、函数名使用。
break catch closure continue else elseif false final finally for foreach function global if null return throw true try while
A.2.3 空白字符的处理
空格（ASCII 码的 0x20）、制表符和换行符在源文件中除了区分不同的标识 符外没有其他含义。
A.2.4 注释
在 crowbar 中从 # 开始到本行结束都会被作为注释。
A.2.5 标识符
被当做变量名、函数名、类名等使用的标识符，需要遵从以下规则。 ●● 第一个字符必须是英文字母（A~Z，a~z）或者是下划线。 ●● 从第二个字符开始可以是英文字母、下划线或数字（0~9）。 crowbar 的标识符中不允许使用中文等 ASCII 字符集中不包含的字符。
A.2.6 字面量
1. 真假值字面量 真假值字面量只有 true（真）和 false（假）。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3 2 4 附录 A　crowbar 语言的设计
2. 整数字面量 整数字面量由 0 或者“1~9 后面跟着 0 个或以上的 0~9”组成。 目前为止还不支持八进制和十六进制的表示方式。.
3. 实数字面量 实数字面量由“1 个以上 0~9 的组合、点、1 个以上 0~9 的组合”组成。
 .5 或者 1. 都不是实数字面量。 4. 字符串字面量
字符串字面量是由双引号括起来的字符串。在字符串字面量中 \n 表示换 行，\t 表示制表符，\\ 表示 \。 5. null 字面量  null 字面量用来表示引用类型没有指向任何值。 6. 数组字面量
在花括号 {} 中将元素用逗号分开，并初始化元素就创建了数组字面量。数 组字面量的详细内容请参考 A.3.3 节。
在最后一个元素的后面有没有逗号都可以。 7. 正则表达式字面量
由 %%r 和任意一个将正则表达式括起来的字符组成正则表达式字面量。 【例】
%%r"[a-z]*" %%r!hoge(.)a\1! ←用括号括起来的部分可以在 \1 的位置被回溯引用
A.2.7 运算符
以下这些字符（也许只是一部分）会被当做 运算符（   operator）解释。
, && || = == != > >= < <= + - * / % += -= *= /=%= ++ -- ! . () []
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

A.3　数据类型 3 2 5
A.2.8 分隔符
以下的字符会被解释为 分隔符（  punctuator）。
() {} ; : ,
A.3 数据类型
A.3.1 类型一览
在 crowbar 中存在以下 类型（  type）。 逻辑类型 ：true 或者 false。 整数类型 ：能够表达的范围与处理器编译的 C 语言环境中的 int 类型一致。 实数类型 ：能够表达的范围与处理器编译的 C 语言环境中的 double 类型一致。 字符串类型 ：字符串类型的详细内容请参考 A.3.2 节。 数组类型 ：数组类型的详细内容请参考 A.3.3 节。 对象类型 ：对象类型的详细内容请参考 A.3.4 节。 函数类型 ：函数类型的详细内容请参考 A.3.5 节。 原生指针类型 ：原生指针类型的详细内容请参考 A.3.6 节。.
A.3.2 字符串类型
crowbar 的字符串类型属于引用类型。但是因为字符串本身不能改变（immutable），所以使用者没有必要意识到它是一个引用类型。
crowbar 的字符串类型的内部表现形式为，处理器编译的 C 语言环境中的宽 字符串。
字符串具有以下的 模拟方法（  fake.method），通过方法调用的形式取得字符串 的相应信息。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3 2 6 附录 A　crowbar 语言的设计

使用范例  len = s.length();
s2 = s.substr(3, 5);

含义  取得字符串的长度 截取字符串，并返回包含截取内容的新字符串。第 1 个参 数指定截取开始的位置（第 1 个字符是 0），第 2 个参数指 定要截取的长度

A.3.3 数组类型

crowbar 是非静态类型的语言，因此数组中可以保存所有的类型，不仅如此， 各种数据类型可以同时被装在一个数组里面。
crowbar 的数组类型可以通过数组字面量和 new_array() 函数创建。
# 创建以整数、字符串、实数、数组为元素的数组 a1 = {1, "abc", 10.0, {1, 2, 3}};

# 创建有 10 个元素的数组（元素的初始值为 null） a2 = new_array(10);
取得数组元素和为元素赋值都需要使用 [] 运算符。数组下标从 0 开始。
# 取得数组的元素 print("a[3].." + a[3]);

# 为数组元素赋值 a[5] = 10;

crowbar 的数组是引用类型。 数组具有以下的模拟方法，通过方法调用的形式操作数组。

使用范例  a.add(3); size = a.size();
a.resize(new_size);

含义  向数组的末尾添加元素 取得数组的元素个数 改变数组的元素个数。如果新指定的大小小于当前数组的元素个数， 则根据新的大小舍弃数组后面的元素。如果大于当前元素个数，则 增加元素并把这些元素设置为 null

a.insert(2, 3); a.remove(3); ite = a.iterator();

在第 1 个参数指定的下标的元素前，插入第 2 个参数中指定的值
删除参数指定的下标的元素，并将后面的元素向前移动一个下标。 结果是数组的元素个数减少 1 取得数组的迭代器。关于迭代器请参考 A.3.7 节

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

A.3　数据类型 3 2 7
A.3.4 对象类型
对象类型是由多个 成员 组成的类型。数组通过下标指定元素，对象则是通过 成员名称指定。
对象通过 new_object() 函数创建。创建的对象通过对指定的成员名称赋 值的形式，为对象添加成员。.
# 创建空的对象 o = new_object(); # 添加对象的成员 o.x = 10; o.y = 20; # 引用对象的成员 print("o.x.." + o.x + ", o.y.." + o.y + "\n");
对象类型是引用类型。
A.3.5 函数类型
不仅可以通过函数名赋值给其他变量，还可以通过 () 进行调用。
function a() { print("hello!\n");
} c = a; # 将函数 a 代入 c c(); # ←输出 "hello!"
可以使用关键字 closure 在表达式中定义一个无名的函数。这种方式被称 为 闭包（ . closure）。
c = closure() { print("hello!\n");
}; c(); ←输出 "hello!"
从闭包内部可以引用到创建闭包所在位置的局部变量。即使在闭包调用的时 候，创建闭包的函数已经结束的情况下也是一样。.
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3 2 8 附录 A　crowbar 语言的设计
A.3.6 原生指针类型
原生指针类型是保存在原生函数内部使用的值（如文件指针，FILE*）的类 型。在原生函数外的原生指针类型只能够进行复制和等值比较。
现在的原生指针类型只在文件指针和正则表达式中使用。 原生指针类型可以由原生函数定义 终结器（ . finalizer）。终结器是在 GC 要释 放原生指针类型所指向的对象时执行的函数。但是，因为终结器的执行时机不能 被应用程序预测，所以有关重要资源的释放不应该依赖终结器。
A.3.7 迭代器
迭代器（.. iterator）是表现循环的类型。 迭代器是一个设置了一些闭包方法（method）的对象，并不是处理器中定义 的特殊类型。因此，在用户程序中也可以定义迭代器。 迭代器是具有以下方法的对象。 first() ：返回迭代器中的第一个元素。  next().：将迭代器游标向后移动一个。  is_done().：迭代器移动到超出最后一个元素的位置时返回 true，否则返 回 false。  current_item().：返回迭代器中当前的元素。 crowbar 的数组可以通过 iterator() 方法得到数组的迭代器。另外，在使 用 foreach 语法的时候，就是基于迭代器循环的。
A.3.8 异常
在 crowbar 中，异常是被设置了一些闭包作为方法的对象。可以使用原生函 数 new_exception() 来创建异常。
使用者在创建“异常”的时候，需要使用内建函数 create_exception_ class()。这个函数以“父类”为参数创建一个新的异常类。通过调用这个类 的 create() 方法，创建属于这个类的实例。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

A.4　表达式 3 2 9

# 在构建脚本中对 ArithmeticException 定义的描述 ArithmeticException = create_exception_class(RuntimeException);
# 通过 create() 方法生成实例。 e = ArithmeticException.create();
异常实例中的 child_of() 方法用于检查异常的类型。在上面的例子中， ArithmeticException 是 RuntimeException 的 子 类，e 是 ArithmeticException 的 实 例，因此如果调用 e.child_of(RuntimeException) 的话，传入上面两个类 都会返回 true。

A.4 表达式
所谓 表达式（  expression），就是通过运算符将字面量或者标识符关联起来。

A.4.1 类型转换
在 crowbar 中 使 用 双 目 运 算 符（+、-、*、/、%） 和 比 较 运 算 符 （==、!=、>、>=、<、<=）时，如果两边的类型不同的话，crowbar 会基于下面的规
则对类型进行扩展。 1.	不论左边还是右边，只要其中一边是整数，另外一边是实数的时候，整数会转换 为实数。 2.	在左边是字符串右边是逻辑类型、整数类型或者实数类型的时候，右边会转换为 字符串。 上述类型转换，在算术赋值运算符（+=、-=、*=、/=、%=）的情况下同样适用。

A.4.2 运算符一览

crowbar 的运算符一览如下所示（优先顺序由高至低）。

运算符  ++ -- () [] .

含义  自增、自减、函数调用、引用数组元素、引用对象的成员

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3 3 0 附录 A　crowbar 语言的设计

运算符  （单目）- ! * / % + < <= > >= == != &&
||
= += -= *= /= %=
,

（续）
含义  符号反转、逻辑非 乘法、除法、模 加法、减法。加法运算符可以连接字符串 比较大小。字符串也可以比较大小（设计以 C 语言的 strcmp() 为基准） 等值比较。字符串也可以进行比较（比较的不是引用而是值） 逻辑与（AND）运算符。短路运算符在表达式 a && b 中，如果 a 为假的话，b 就不做判断了 逻辑或（OR）运算符。短路运算符在表达式 a || b 中，如果 a 为真的话，b 就不做判断了 赋值运算符。在 crowbar 中会通过最初的赋值创建变量。另外， 如果在赋值表达式前面加上 final 的话，就会变成不能再次赋值 的常量定义 逗号运算符。以从左到右的顺序计算表达式，返回右边表达式的值

在 crowbar 中，只存在后置的自增和自减运算符。并且，其动作与 C 等语言 中的前置运算符效果相同（不会等到最后，而是立刻自增表达式的值）。

A.5 语句

A.5.1 表达式语句
所谓 表达式语句（   expression.statement），就是在表达式后面加上分号。.
# 调用 print() 函数的表达式，后面加上分号 print("hello,world\n");
# 自增表达式后面加上分号 i++;
# 无副作用的表达式也可以成为表达式语句，但没有任何意义 5;

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

A.5　语句 3 3 1
A.5.2 if 语句
 if 语句是根据条件进行判断并进行分支处理的语句。
if ( 条件表达式 1) { # 条件表达式 1 为真时执行的处理。
} elseif ( 条件表达式 2) { # 条件表达式 1 不为真，且条件表达式 2 为真时执行的处理。
} else { # 所有条件表达式都不为真时执行的处理。
}
elsif 子 句 和 else 子 句 都 是 可 以 省 略 的。 另 外， 可 以 编 写 任 意 多 个 elsif 子句。
与 C 等语言不同的是，即使只包含一行语句，也不能省略花括号（{}）。
A.5.3 while 语句
 while 语句是进行循环操作的语句。
标识符 : while ( 条件表达式 ) {
# 在条件表达式为真的情况下，此处的代码会反复执行。 }
“标识符 :”的部分被称为 标签（ . label）。标签可以省略。 与 if 语句相同，即使只包含一行语句，也不能省略花括号（{}）。
A.5.4 for 语句
for 语句是进行循环操作的语句。
标识符 : for（第 1 表达式 ; 第 2 表达式 ; 第 3 表达式） {
# 在第 2 表达式为真的情况下，此处的代码会反复执行。 }
“标识符 :”的部分被称为 标签（ . label）。标签可以省略。 让我们先看一段 for 语句的代码：
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3 3 2 附录 A　crowbar 语言的设计
# 创建一个数组 a = new_array(10);
# 循环取得数组的每个元素 for(i = 0; i < a.size(); i++){
# 输出每个元素 print("a[" + i + "].." + a[i]); }
基于上面这段代码，其中的第 1 表达式、第 2 表达式、第 3 表达式也有其他 的叫法。
第 1 表达式通常的作用是对判断循环是否需要继续的变量进行初始化，因此 也叫作初始化表达式。
第 2 表达式通常的作用是根据初始化表达式中创建的变量，以此判断是否需 要继续循环，因此也叫作判断表达式。
第 3 表达式通常的作用是重新设置循环的判断条件（一般都是 ++ 或者 --）， 因此也叫作增量表达式。
上述 for 语句中，除了在 continue 时会执行第 3 表达式之外，其他与下 面的 while 语句效果相同。
第 1 表达式 ; while ( 第 2 表达式 ) {
# 语句 第 3 表达式 ; }
第 1 表达式、第 2 表达式、第 3 表达式都是可以省略的。在省略了第 2 表达 式时意味着永远返回真。
A.5.5 foreach 语句
foreach 语句是利用迭代器进行循环操作的语句。
标识符 : foreach ( 变量 : 集合 ) {
# 语句 }
“标识符 :”的部分被称为 标签（ . label）。标签可以省略。上述 foreach 语句
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

A.5　语句 3 3 3
等同于下面的 for 语句。
for (ite = 集合 .iterator(); !ite.is_done(); ite.next()) { 变量 = ite.current_item(); # 语句
}
但 是， 实 际 上 在 foreach 语 句 中 引 用 不 到 迭 代 器， 在 上 述 例 子 中 变 量 ite 并不存在。
A.5.6 return 语句
 return 语句是从函数中跳出的语句。
return 表达式 ;
在省略表达式的时候，该函数返回 null。
A.5.7 break 语句
 break 语句是用于跳出循环的语句。
break 标识符 ;
标识符可以省略。在省略的情况下，跳出最内侧的循环。 在指定了标识符的情况下，跳出持有同样标识符的循环。
A.5.8 continue 语句
 continue 语句用于跳转到循环的末尾。.
continue 标识符 ;
标识符可以省略。在省略的情况下，以最内侧的循环为对象。 在指定了标识符的情况下，以持有同样标识符的循环为对象。 在以 for 为对象进行 continue 的时候，continue 后会紧接着计算 for. 语句的第 3 表达式。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3 3 4 附录 A　crowbar 语言的设计
A.5.9 try 语句
 try 语句是用于执行异常处理的语句。.
try{ # 语句
} catch ( 变量名 ) { # 语句
} finally { # 语句
}
在 try 子句中如果发生了异常就会执行 catch 子句。发生的异常会被设置 到 catch 子句声明的变量中。catch 子句和 finally 子句只要存在其中的任何 一个，另外一个就可以被省略。
无论异常是否发生，无论是否存在 catch 子句，finally 子句都一定会执 行。在 try 子句或者 catch 子句中，如果执行了 break、continue、return 来 中 断 处 理， 那 么 也 会 执 行 finally 子 句。 如 果 使 用 break、.continue、. return. 来中断 finally 子句的话，相比 finally 的执行结果，try 子句或 者 catch 子句中语句的执行结果会更优先。例如，try 子句内执行了 return 5;，在返回前执行了 finally 子句中的 return 3;，在这种情况下，最终被作 为返回值返回的是 5。
A.5.10 throw 语句
 throw 语句是用于抛出异常的语句。.
throw e;
 e 在通常情况下会使用通过 new_exception() 创建的异常对象，但是整数 类型等其他所有类型都可以被 throw。
在 try 子 句 内 发 生 的 异 常，（如 果 有 的 话 ） 会 在 catch 子 句 中 被 捕 捉。 当 catch 子 句 不 存 在 或 者 异 常 发 生 在 try 语 句 之 外 的 时 候， 会 终 止 当 前 正 在 执 行 的 函 数 并 返 回 到 调 用 者（或 者 叫 上 一 层 ） 的 处 理 中。 如 果 调 用 者 也 没 有 catch 这个异常的话，则会沿着调用层级回溯，直到顶层结构。如果顶层结 构中也没有捕捉这个异常，就会输出 栈轨迹（   stack.trace）并终止处理。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

A.6　函数 3 3 5
crowbar 中的栈轨迹在调用 new_exception() 的时候就被创建了。.
A.5.11 global 语句
 global 语句是为了在函数内引用全局变量而使用的语句。在 crowbar 中， 如果不使用 global 语句进行声明的话，在函数内就访问不到全局变量。.
# 引用了 STDIN，STDOUT 两个全局变量 global STDIN,STDOUT;
A.6 函数
A.6.1 函数定义
函数使用以下形式定义。
function 函数名 ( 参数 ) { # 语句
}
请参考下面的示例。
# 接收两个参数并返回它们的和的函数 function sum (a, b) {
return a + b; }
A.6.2 局部变量
在函数内声明的变量就是 局部变量（   local.variable）。 局部变量的作用域只在当前函数内。与 C 语言不同的是，函数内的程序块并 不会形成作用域 A
A　也就是说，局部变量的作用域是当前函数，而不是当前程序块。——译者注
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

附录 B

Diksam 语言的设计

以下将要介绍的是在本书中 Diksam 最终版本（book_ver.0.4）的设计。与附 录 A 一样，内容并不是很严谨。.

B.1 程序结构

B.1.1 构成程序的要素
Diksam 的程序由以下要素构成。
1. 声明部分 声明部分.由 require 声明和 rename 声明组成。声明部分必须在源文件的
开头，但也可以省略。
2. 顶层结构 顶层结构（toplevel）由 语句（   statement）组成。Diksam 的程序从处理器中指
定的源文件的顶层结构开始执行。
3. 函数定义或声明 函数定义（.. function.definition）定义可以（可能）从其他位置调用的函数。在
顶层结构的语句顺序执行时会忽略函数定义。因为函数允许回溯引用，所以其定 义的位置既可以在调用的位置之前，也可以在调用的位置之后。
函数声明（function.declaration）只声明了函数的 签名（   signature）。对于函数 声明来说，必须存在与其对应的定义。
4. 类型定义 类型定义包括 类定义（  class.definition）、 接口定义（  interface.definition）、 枚举
类 型 定 义（  enumerated.type.definition） 和 delegate 类 型 定 义（  delegate.type.definition）。
类型定义是为了定义可能在其他位置使用的数据类型。与函数一样，会在顶

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

B.1　程序结构 3 3 7
层结构的语句执行时被忽略，并且允许回溯引用。 下面是几个示例。 仅由顶层结构组成的 Diksam 程序：.
println("hello, world.");
开头含有声明部分的 Diksam 程序：.
// 将标准函数 println 改名为 print_line rename diksam.lang.println print_line;
print_line("hello, world.");
包含函数定义的 Diksam 程序：.
// 函数定义 void func() {
println("hello, world."); }
// 调用定义的函数 func();
包含类定义的 Diksam 程序：.
public class Point { private double x; private double y; void print() { println("x.." + this.x + ", y.." + this.y); } constructor initialize(double x, double y){ this.x = x; this.y = y; }
}
// 创建 Point 类的实例 Point p = new Point(10, 20); // 输出 p 的内容 p.print();
B.1.2 分割编译
通过声明部分的 require 声明指定的包（package），达到能够使用在其他
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3 3 8 附录 B　Diksam 语言的设计
源文件中定义的函数和类的目的。 在 Diksam 中， 包 由 一 个 源 文 件（扩 展 名 .dkh） 或 者 两 个 源 文 件（扩 展
名 .dkh 和 .dkm）的组合组成。 下面的例子通过 require 了 hoge.piyo.fuga 包，达到了可以使用 fuga.
dkh 中定义的类和函数的目的。.
require hoge.piyo.fuga;
在 .dkh 文件中描述了只有在函数的签名声明的情况下，实际调用函数的时候 处理器才会对 fuga.dkh 对应的实现文件 fuga.dkm 进行搜索并编译 / 加载。这 种机制被称为 动态加载（   dynamic.load）。
被 require 文件的搜索路径，即环境变量 DKM_REQUIRE_SEARCH_PATH， 在 UNIX 环境中使用逗号分隔，在 Windows 环境中使用分号分隔。因为 Diksam 的包名和文件路径的层级是一致的，所以只需要指定搜索路径就可以以此为起 点，通过包名的层级搜索文件了。
在没有设定 DKM_REQUIRE_SEARCH_PATH 的情况下，当前目录将成为唯一 的搜索路径。
另 外， 动 态 加 载 时 的 搜 索 路 径 可 以 通 过 环 境 变 量 DKM_LOAD_SEARCH_ PATH 取得。  diksam.lang 包 已 经 默 认 为 require， 因 此 使 用 者 无 需 自 己 再 进 行 require。
被 require 的源文件中，顶层结构将被忽略，不会执行。
B.1.3 解决命名冲突
在 require 了多个包的时候，很可能会发生类名、函数名的命名冲突。在 这个时候，可以通过声明部分的 rename 声明为标识符改名，以此方法来回避命 名冲突。
下面是将 diksam.lang 包下面的 print 函数改名为 myprint 的例子。
rename diksam.lang.print myprint;
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

B.2　语法规则 3 3 9
B.1.4 关于全局变量的链接
在顶层结构中声明的变量（全局变量）相对于源文件独立的，不能进行链 接。如果想要让某个包的全局变量被其他的包访问的话，就必须要声明 get_ xxx()、set_xxx() 这样的函数。
B.2 语法规则
B.2.1 源文件的字符编码
Diksam 的源文件使用与处理器相同的字符编码。当前确定的是在 UNIX 环境 中为 EUC 和 UTF-8，在 Windows 环境中为 GB2312。除了写注释和定义字符串字 面量，其他情况下不能使用非 ASCII 字符。
B.2.2 关键字
下面这些单词作为 Diksam 的关键字，不能作为变量名、函数名、类名等 使用。
abstract boolean break case catch class const constructor continue default delegate do double else elsif enum false final finally for foreach if instanceof int interface native_pointer new null override private public rename require return string super switch this throw throws true try virtual void while
（注）foreach 是为将来准备的关键字，现在并没有使用。.
B.2.3 空白字符的处理
空格（ASCII 码的 0x20）、制表符和换行符在源文件中除了区分不同的标识
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3 4 0 附录 B　Diksam 语言的设计
符外没有其他含义。
B.2.4 注释
在 Diksam 中可以使用以下两种注释方式。 ●● 以 /* 开始以 */ 结束的注释，这种注释不能嵌套使用。 ●● 以 // 开始直到本行结束的注释
B.2.5 标识符
被当做变量名、函数名、类名等使用的标识符，需要遵从下面的规则。 ●● 第一个字符必须是英文字母（A~Z，a~z）或者是下划线。 ●● 从第二个文字开始可以是英文字母、下划线或数字（0~9）。 Diksam 的标识符中不允许使用中文等未被 ASCII 字符集涵盖的字符。
B.2.6 字面量
1. 真假值字面量 真假值字面量只有 true（真）和 false（假）。
2. 整数字面量 整数字面量由“0”或者“1~9 后面跟着 0 个或以上的 0~9”组成。 如果在前面加上“0x”或者“0X”前缀的话，可以表示十六进制整数。 目前为止还不支持八进制表示方式。.
3. 实数字面量 实数字面量由“1 个以上的 0~9 的组合、点、1 个以上的 0~9 的组合”组成。
 .5 或者 1. 都不是实数字面量。 4. 字符串字面量
字符串字面量是由双引号括起来的字符串。在字符串字面量中 \n 表示换
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

B.3　数据类型 3 4 1
行，\t.表示制表符，\\ 表示 \。 5. null 字面量  null 字面量用来表示引用类型没有指向任何值。 6. 数组字面量
在花括号 {} 中将元素用逗号分开并对元素进行初始化就创建了数组字面量。 数组类型为该字面量中第一个元素的类型的数组。. 最后一个元素的后面有没有逗 号都可以。
B.3 数据类型
B.3.1 基础类型
Diksam 存在以下 基础类型 。 1.  void 类型（ void ）  void 类型表示函数是没有返回值的特殊类型。只能作为函数或者方法的返 回值使用。 2. 逻辑类型（ boolean ）
可以是 true 或者 false。 3. 整数类型（ int ）
表示整数的类型。能够表达的范围与编译器以及编译 VM 的 C 语言环境 的 int 类型一致。 4. 实数类型（ double ）
表示实数的类型。能够表达的范围与编译器以及编译 VM 的 C 语言环境 的 double 类型一致。 5. 字符串类型（ string ）
表示字符串的类型。其内部表现形式为编译器以及编译 VM 时 C 语言环
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3 4 2 附录 B　Diksam 语言的设计
境下的宽字符串。. 字符串类型属于引用类型。但是，因为字符串本身不能改变 （immutable），所以使用者没有必要意识到它是一个引用类型。.
B.3.2 类 / 接口
类和接口都属于用户自定义类型。 关于类定义和接口定义的详细内容请参考 B.7 节。 类和接口都是引用类型。.
B.3.3 派生类
派生类型是由基础类型、类、接口派生出来的类型。 存在以下两种派生类型。 1. 数组类型 Diksam 的数组类型，其元素数无须在声明时决定，是可以动态创建的引用 类型。 2. 函数类型 函 数 和 方 法 都 是 函 数 类 型。 函 数 类 型 不 存 在 变 量， 并 可 以 赋 值 给 适 当 的 delegate 类型。 数组类型可以使用递归。 int 类型数组的数组： 
int[][] a;
函数类型通过 delegate 类型可以实现“函数的数组”、“返回函数的函 数”等。
B.3.4 枚举类型
枚举类型通过下面的方式定义。在最后一个元素后面有没有逗号都可以。
enum 枚举类型名称 {
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

B.3　数据类型 3 4 3
枚举名称 , 枚举名称 , 枚举名称 , … }
枚举类型的值（枚举）如下所示，使用枚举类型名称 . 枚举名称的形式表示。
Fruits.ORANGE
枚举类型在参与加法运算（使用 + 运算符）时，如果左边是字符串（枚举类 型在右边）的话，枚举类型会转换为字符串。
枚举类型可以使用比较运算符（==、!=、>、>=、<、<=）和 switch 判断 分支。
B.3.5 delegate 类型
 delegate 类型是指向函数的引用类型。通过在关键字 delegate 后面加上 与函数签名相同的形式定义。
下面的实例以一个 Window、两个 int 以及一个 MouseButton 枚举为参 数，返回值为 void 的 delegate 类型（在后述 Windows 版的 Diksam 中会被实际使 用到）。
// 在 Window 按下鼠标的事件 delegate void MouseButtonDownProc(Window window, int x, int y,
MouseButton button);
通过上述类型定义，就可以像下面这样声明 delegate 类型的变量了。
MouseButtonDownProc mouse_button_handler;
也可以定义把 delegate 类型作为参数或者函数类型的返回值。 在表达式中，通过单独的函数名就可以创建函数类型的值。函数类型的值可 以赋值给与其具有互换性的 delegate 类型的变量，还可以像函数的实际参数那 样，作为参数进行传递。.
void mouse_button_func(Window window, int x, int y, MouseButton button){ …
}
// 在 Window 对象中按下鼠标的时候调用
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3 4 4 附录 B　Diksam 语言的设计

// 为了处理这个事件将 mouse_button_func 作为参数传递进去 window.set_mouse_button_down_proc(mouse_button_func);
 delegate 类 型 的 变 量 不 仅 可 以 赋 函 数， 还 可 以 赋 方 法。 在 赋 方 法 的 时 候，delegate 类型的变量会将方法对应的类实例一并保存起来。
给 delegate 类型的变量赋值，需要满足以下条件。
1. 赋值的函数或者方法，必须与被赋值的 delegate 类型的参数数量一致。 2.	赋值的函数或者方法的参数类型（相对应地），必须与被赋值的 delegate 的参数
类型一致，或者是 delegate 的参数类型的父类。 3.	赋值的函数或者方法的返回值类型，必须与被赋值的 delegate 的返回值类型一
致，或者是 delegate 返回值类型的子类。 4.	赋值的方法在 throws 中列出的异常范围要比被赋值的 delegate 在 throws 中
列出的范围小。

B.3.6 内建方法

在数组和字符串类型中，拥有一些内建方法。 数组的内建方法如下所示。

形式  void add(T value); int size();

含义  向数组的末尾增加元素。T 的类型必须是可以赋值 给数组元素的类型 获取数组的元素个数

void resize(int new_size);

改变数组的元素个数。如果新指定的大小小于当前 数组的元素个数，则根据新的大小舍弃数组后面的 元素。如果比当前大小大，则增加元素并把这些元 素设置为该类型的默认值

void insert(int pos, T value);

在指定下标（pos）的元素前面插入 value 指定的值。 T 的类型必须是可以赋值给数组元素的类型

void remove(int pos);

删除指定下标（pos）的元素，并将后面的元素向前 移动一个下标。结果是数组的元素个数减少了 1 个

字符串的内建方法如下所示。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

B.4　表达式 3 4 5

形式  int length();
string substr(int pos, int len);

含义  获取字符串的长度 截取字符串，并返回包含截取内容的新字符串。 第 1 个参数指定开始截取的位置（第 1 个字符是 0），第 2 个参数指定要截取的长度

B.4 表达式
表达式（.. expression）是由运算符连接起来的单目表达式。
B.4.1 单目表达式
单目表达式有以下几种。 ●● 字面量。 ●● 标识符。虽然变量名、常量名、函数名是单目表达式，但类名等类型的名称不是表达式。 ●● this。表示在类的方法内指向当前实例的引用。 ●● super。在类的方法内，调用超类的方法时使用。 ●● new 表达式。具体的使用方法请参考 B.7.6 节。 ●● 枚举。
B.4.2 类型转换
在 Diksam 中，具备了以下条件时会进行自动转型。 ■■ 双目运算符的类型转换 
双目算数运算符（+、-、*、/、%）以及比较运算符（==、!=、>、>=、<、<=）在 两边类型不一致的时候，会根据以下规则进行类型扩展。
1.	无论左边还是右边，只要其中一边是整数（int），另外一边是实数（double）的 时候，整数（int）会转换为实数（double）。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3 4 6 附录 B　Diksam 语言的设计

2.	在左边是字符串（string）的情况下，仅限于加法运算（运算符为 +）的时候，右 边会转换为字符串。
上述类型转换，在算术赋值运算符（+=、-=、*=、/=、%=）的情况下同样适用。
■■ 赋值时的类型转换  1.	把类赋值给类的时候，当左边是右边的超类或者被实现的接口时，会进行 向上转 型（  up cast）。 2. 右边是 int 类型，左边是 double 类型的时候，右边会转换为 double 类型。 3. 右边是 double 类型，左边是 int 类型的时候，右边会转换为 int 类型。

B.4.3 运算符一览

Diksam 的运算符一览如下所示（优先顺序从高至低）。

运算符 
++ -- () [] . instanceof :: 类型 : （单目）- !
* / % + < <= > >=
== !=
&&
|| = += -= *= = %= ,

含义 
自增、自减、函数调用、引用数组元素、引用对象 的成员、类的类型检查（与 Java 的设计相同）、向 下转型 符号反转、逻辑非 乘法、除法、模 加法、减法。加法运算符可以用于连接字符串 比较大小。字符串也可以比较大小（设计以 C 语言 的 strcmp() 为基准） 等值比较。字符串也可以进行比较（比较的不是引 用而是值） 逻辑与（AND）运算符。短路运算符在表达式 a && b 中，如果 a 为真，b 就不做判断了 逻辑或（OR）运算符。短路运算符，在表达式 a || b 中，如果 a 为真，b 就不做判断了 赋值运算符。含义与 C 语言中的相同 逗号运算符。按照从左到右的顺序计算表达式，返 回右边表达式的值

在 Diksam 中，只存在后置的自增和自减运算符。并且，其动作与 C 等语言 中前置的运算符效果相同（不会等到最后，而是立刻自增表达式的值）。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

B.5　语句 3 4 7
B.5 语句
B.5.1 声明语句
声明语句（.. declaration.statement）是进行变量声明的语句。 声明语句为
类型 变量名 ;
或者
类型 变量名 = 初始化表达式 ;
这样的形式（“=.初始化表达式”的部分被称为 初始化（   initializer））。 为声明语句加上 final，可以防止对应变量的初始值被覆盖（禁止再次 赋值）。
final int a = 10;
在 final 的声明语句中，如果不进行初始化就会发生编译错误。 使用 const 关键字声明常量。
const HOURS_IN_DAY = 24;// 一天 24 小时 const MINUTES_IN_DAY = HOURS_IN_DAY * 60;// 1 天 24 × 60 分
在常量的声明中，因为通过初始值可以判断类型，所以 const 无需指定类型。
B.5.2 表达式语句
所谓 表达式语句（ . expression.statement）就是在表达式后面加上分号。.
// 调用 print() 函数的表达式后面加上分号 print("hello,world."); // 自增表达式后面加上分号 i++; // 无副作用的表达式也可以成为表达式语句，但没有任何意义 5;
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3 4 8 附录 B　Diksam 语言的设计
B.5.3 if 语句
 if 语句是根据条件判断并处理分支的语句。
if ( 条件表达式 1) { // 条件表达式 1 为真时执行的处理。
} elsif ( 条件表达式 2) { // 条件表达式 1 不为真，且条件表达式 2 为真时执行的处理。
} else { // 所有条件表达式都不为真时执行的处理。
}
elsif 子 句 和 else 子 句 都 是 可 以 省 略 的。 另 外， 可 以 编 写 任 意 多 个 elsif 子句。与 C 等语言不同的是，只包含一行语句也不能省略花括号（{}）。
B.5.4 switch 语句
 switch 语句是进行多分支处理的语句。
switch(a) case 1 {
// a 等于 1 时执行 } case 2,3 {
// a 等于 2 或 3 时执行 } default {
// a 不等于上面的 1、2、3 时执行 }
Diksam 的 switch 语句与 C 语言的 fall.through 不同。在匹配了一个 case 之 后， 即 使 没 有 在 分 支 中 写 break， 也 不 会 交 由 下 一 个 case 处 理。 另 外， 各 case 子句必须使用花括号（{}）括起来。
在针对多个值进行相同处理的时候，值之间以逗号分隔。 如果没有匹配任何一个 case 子句的话，就会执行 default 子句。 各 case 子句在以下代码成立时就会执行。
switch 中描述的表达式 == case 中描述的表达式
虽然只能使用 == 运算符，但是表达式的类型没有限制。然而，在 == 两边为
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

B.5　语句 3 4 9
了匹配类型会进行类型转换，在 switch 中却不会进行类型转换。
B.5.5 while 语句
 while 语句是进行循环操作的语句。
标识符 : while ( 条件表达式 ) {
// 在条件表达式为真的情况下，此处的代码会反复执行。 }
“标识符 :”的部分被称为 标签（  label）。标签可以省略。 与 if 语句相同，即使只包含一行语句也不能省略花括号（{}）。
B.5.6 do while 语句
 do while 语句是进行后判断型的循环操作语句。
标识符 : do {
// 这个位置的代码最初必须执行一次， // 之后，在条件表达式为真的情况下，此处的代码会反复执行。 } while ( 条件表达式 );
“标识符 :”的部分被称为 标签（   label）。标签可以省略。 与 if 语句相同，即使只包含一行语句也不能省略花括号（{}）。
B.5.7 for 语句
for 语句是进行循环操作的语句。
标识符 : for（第 1 表达式 ; 第 2 表达式 ; 第 3 表达式） {
// 在第 2 表达式为真的情况下，此处的代码会反复执行。 }
“标识符 :”的部分被称为 标签（   label）。标签可以省略。.上述 for 语句，除 了在 continue 时会执行第 3 表达式之外，其他与下面的 while 语句效果相同。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3 5 0 附录 B　Diksam 语言的设计
第 1 表达式 ; while ( 第 2 表达式 ) {
# 语句 第 3 表达式 ; }
第 1 表达式、第 2 表达式、第 3 表达式都是可以省略的。在省略了第 2 表达 式时，意味着永远返回真。
B.5.8 return 语句
 return 语句是从函数中跳出的语句。
return 表达式 ;
在函数为 void 类型的时候，如果写了 return 表达式的话会报错。
B.5.9 break 语句
 break 语句是用于跳出循环的语句。
break 标识符 ;
标识符可以省略。在省略的情况下，跳出最内侧的循环。 在指定了标识符的情况下，跳出持有同样标识符的循环。
B.5.10 continue 语句
 continue 语句用于跳转到循环的末尾。.
continue 标识符 ;
标识符可以省略。在省略的情况下，以最内侧的循环为对象。 在指定了标识符的情况下，以持有同样标识符的循环为对象。 在以 for 为对象进行 continue 的时候，continue 后会紧接着对 for 语 句的第 3 表达式进行计算。 在以 do while 为对象进行 continue 的时候，会对下一次的条件表达式
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

B.5　语句 3 5 1
进行计算，如果结果为假则终止循环。
B.5.11 try 语句
 try 语句是用于执行异常处理的语句。.
try { // 语句
} catch ( 异常类型 变量名 ) { // 语句
} catch ( 异常类型 变量名 ) { // 语句
} finally { // 语句
}
在 try 子句中如果发生了异常，就会执行 catch 子句，会在 catch 子句 中按照从上到下的顺序搜索与发生的异常类匹配的 catch 子句。如果有匹配 的 catch 子句，则会转移处理位置（抛给上一层或者终止处理）。发生的异常 会被设置到 catch 子句声明的变量中。这个变量默认为 final，不可以再次 赋值。 finally 子句无论异常是否发生，也不论是否有匹配的 catch 子句，都一定会 执行。在 try 子句或者 catch 子句中即使是执行了 break、continue、return 来 中断处理，也会执行 finally 子句。如果使用 break、continue、return 来中 断 finally 子句的话，就会发生编译错误。
B.5.12 throw 语句
 throw 语句是用于抛出异常的语句。 在通常情况下，可以像下面这样显式地为表达式指定异常。
throw e;
在 try 子 句 内 发 生 的 异 常， 如 果 存 在 与 其 对 应 的 catch 子 句 的 话， 就 会 被 catch 子 句 捕 获。 如 果 不 存 在 与 其 对 应 的 catch 子 句， 或 者 异 常 发 生 在 try 语句之外的时候，会终止当前正在执行的函数并返回到调用者（或者叫
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3 5 2 附录 B　Diksam 语言的设计
上一层）的处理中。如果调用者也没有 catch 这个异常的话，则会沿着调用层 级回溯直到顶层结构。如果顶层结果中也没有捕捉这个异常的话，就会输出 栈轨 迹（   stack.trace）并终止处理。
Diksam 的栈轨迹在异常 throw 的时候会被清空，并在返回到调用函数的层 级或者中断顶层结构执行的时候被再次设置。
因此，在 catch 子句中直接再次抛出捕获的异常时，如果不想清除当前的 栈轨迹，可以像下面这样单独使用 throw;。
throw;
B.6 函数
B.6.1 函数定义
函数通过如下的形式进行定义。
类型 函数名 ( 参数序列 ) throws 子句 { 语句
}
 throws 子句可以省略。throws 描述了在这个函数中有可能会发生的异常， 用逗号分隔并一一列出。
如下例所示。
// 接收两个整数型参数并返回它们的和的函数 int sum (int a, int b) {
return a + b; } // 以数组和索引值为参数， // 返回指定位置的元素的函数。 int get_at(int[] array, int index)
throws ArrayIndexOfBoundsException { return array[index];
}
函数的形式参数与已经赋值的 final 局部变量的使用方法一致。因此，不
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

B.6　函数 3 5 3
能赋值给形式参数。
B.6.2 函数的签名声明
当函数被定义在其他源文件中的时候，就要像下面这样，以描述 签名声明 的 方式，让调用了这个函数的表达式可以顺利编译。
int func(bouble x);
与 C 语言的原型声明不同，在 Diksam 中不能省略形式参数的名称（上面 的 x）。另外，形式参数的名称也属于这个类型的一部分，在与函数定义不一致的 时候就会发生错误。
例如下面的签名声明。
void draw_line(double x1, double y1, double x2, double y2);
与此相对，就不允许像下面这样的函数定义。
void draw_line(double x1, double x2, double y1, double y2);
B.6.3 局部变量
在函数内声明的变量就是 局部变量（  local.variable）。 局部变量的作用范围是满足下面两个条件的范围（现在，局部变量的作用范 围不受程序块的影响）。 ●● 在声明之后 ●● 在包含其声明的程序块内 局部变量的生命周期随着它所在函数的退出而终止。.
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3 5 4 附录 B　Diksam 语言的设计
B.7 类 / 接口的定义
B.7.1 类定义
类通过以下的形式进行定义。
类修饰符 class 类名 : 超类，要实现的接口（多个） { 字段、方法、构造方法的定义
}
类修饰符有以下两种。 ●●  访 问修饰符（  access modifier）。可以指定为 public 或者不指定。 ●●  abstract 修饰符 。可以指定或者不指定。 访问修饰符与 abstract 修饰符的顺序不同。 当访问修饰符指定了 public 的时候，这个类就可以被别的包使用了。如果 不指定的话，就只能在当前包中使用。 指定了 abstract 的类被视为 抽象类（   abstract.class）。抽象类不能通过 new 将 其实例化。相反，没有指定 abstract 的类被称为 具象类（ . concrete.class），其中 不能包含 abstract 方法。 超类和要实现的接口与 C++、C# 相同，在冒号后面以逗号分隔并一一列出 （顺序不同）。在不需要继承的情况下，可以省略冒号。 在 Diksam 中对于类来说只能单继承。另外，在 Diksam 中不能继承具象类。 接口可以被多继承。
B.7.2 接口定义
接口通过以下的形式定义。
访问修饰符 interface 接口名 { // 方法定义
}
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

B.7　类 / 接口的定义 3 5 5
接口除了只能记录 abstract 方法外，其他的功能与类相同。 访 问 修 饰 符 与 类 相 同， 可 以 指 定 或 者 不 指 定 public。 接 口 一 定 要 加 上 abstract，如果不指定 abstract 就会发生编译错误。 在 Diksam 中，接口不能继承其他接口。
B.7.3 字段定义
字段通过以下的形式定义。.
访问修饰符 final 修饰符 类型 字段名 初始化语句（表达式）;
针 对 字 段 的 访 问 修 饰 符 有 public、private 和 不 指 定。 它 们 拥 有 不 同 的 含 义，public 可 以 在 其 他 包 中 使 用， 不 指 定 的 话 可 以 在 本 包 内 被 使 用，private 只能在当前类内被使用。
如果指定 final 修饰符，这个字段就不能被赋值了。
B.7.4 方法定义
方法通过以下的方式定义。
方法修饰符 类型 方法名（参数，可以是多个） throws 子句 { 语句
}
与函数定义一样，throws 子句可以省略。另外，在加上了 abstract 修饰 符后，可以不描述方法体（包含了语句的代码块）。
方法修饰符有以下几种。 ●●  访问修饰符 。public、private、不指定。 ●●  abstract 修饰符 。可以指定或者不指定。 ●●  virtual 修饰符 、 override 修饰符 。 没有指定 virtual 修饰符的方法不能重写。另外，如果要重写方法的话， 必须指定 override 修饰符。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3 5 6 附录 B　Diksam 语言的设计
B.7.5 方法重写
在 子 类 中 定 义 与 父 类 或 者 所 继 承 接 口 的 方 法 同 名 的 方 法 被 称 为 方 法 重 写（   method.override）。方法重写必须满足以下条件。
1. 重写与被重写的方法，参数个数必须一致。 2.	进行重写的方法的参数类型（相对应地），必须与被重写方法的参数类型一致，或
者是被重写方法的参数类型的父类。 3.	进行重写的方法的返回值类型，必须与被重写方法的返回值类型一致，或者是被
重写方法的返回值类型的子类。 4.	进行重写的方法在 throws 中列出的异常的范围要比被重写方法在 throws 中列
出的范围小。 5. 进行重写的方法的访问修饰符，要比被重写方法的访问修饰符的限制宽松许多。
B.7.6 构造器
构造器是在实例创建时自动调用的方法。 在 Diksam 中，构造器的定义需要使用 constructor 修饰符。
public constructor initialize(){ // 记录构造器的处理
}
上面的例子用 constructor 修饰符描述了与类型名名称相同的构造方法， 因此必须要在方法前加上 public 和 virtual 方法修饰符，以便在之后进行 重写。
与 Java、C++、C# 不同，在 Diksam 中可以给构造器任意起名字。在 new 实 例的时候，使用以下的形式指定构造器。
// myinit() 是用户自定义的构造器 Point p = new Point.myinit(x, y);
如果不指定方法名，只写成 new Point(x, y); 的话，会调用名为 initialize. 的构造器。另外，在类定义的时候，如果一个构造器也没有定义的话，编译器会 自动创建如下的 默认构造器（ . default.constructor）。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

B.8　程序库 3 5 7
public virtual constructor initialize(){ super.initialize(); ←仅限于存在超类的情况
}
Diksam 的构造器可以在子类中进行重写。但是，构造器并不会进行 B.7.5 节 中写到的参数和返回值的检查。
另外，构造器仅限于在创建实例的时候使用，在实例被创建以后，构造器并 不能像普通方法那样被调用。
B.8 程序库
在这里收录了 Diksam 标准程序库（library）中具有代表性的函数和类。
B.8.1 函数
 void print(string str); 向标准输出中输出作为参数接收的字符串。
 void println(string str); 向标准输出中输出作为参数接收的字符串，并在结尾处加上换行符。
 File fopen(string file_name, string mode); 打开文件。参数的设计以 C 语言的 fopen() 为基准。
 string fgets(File file); 从 file 指定的文件中读取一行，并作为返回值返回。
 void fputs(string str, File file); 向 file 指定的文件中输出 str。
 void fclose(File file); 关闭参数 file 指定的文件。
 double to_double(int int_value); 将 int 转换为 double。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3 5 8 附录 B　Diksam 语言的设计
 int to_int(double double_value); 将 double 转换为 int。
B.8.2 内建类
■■ File  File 类相当于 C 语言的 File* 类型。其内部以 native_pointer 类型保 存了 C 语言的 File*，因此并没有存在特别的方法等内容。 ■■ Exception  Exception 类是所有异常类的类层级的顶端。
它具有以下的字段和方法。  public string message;
保存了异常信息的字段。  public StackTrace[] stack_trace;
保存了栈轨迹的字段。  void print_stack_trace();
输出栈轨迹的方法。 另外，StackTrace 类的定义如下所示。
class StackTrace { int line_number; string file_name; string function_name;
}
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

附录 C

Diksam Virtual Machine 指令集

* 在语言的设计中似乎列
出了一些不支持的指令，
请把它们看作是不能保证
执行正确性的隐藏功能。

本章将要展示 Diksam.VM（DVM）的指令集一览表 *。.

C.1 范例

指令  DVM 指令的助记符。
操作数的类型   byte 为一个字节的正整数，short 为两个字节的正整数（大尾序），cp 指 的是常量池的索引值，实际和 short 相同。
含义  表示当前指令的含义。
栈  表示指令执行时栈的变化。[] 内表示参与操作的栈顶值的类型。右端是
操作后的栈顶。在 DVM 中没有 boolean 和 function 类型，实际上它们都 是 int 值，只不过为了容易理解而写成了 boolean、function。
在没有给出运算符的一侧（箭头的左侧），顺序是有意义的，因此 [int1 int2] 的运算结果会被描述为 [(int1 / int2)]。结果的类型以 C 语言的运算 符为基准，例如 [(int1 > int2)] 的类型为 boolean。
since  表示指令对应的是哪个版本。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3 6 0 附录 C　Diksam Virtual Machine 指令集

C.2 指令一览表

指令 push_int_1byte
push_int_2byte push_int push_double_0 push_double_1 push_double push_string push_null push_stack_int
push_stack_double
push_stack_string
push_stack_object
pop_stack_int
pop_stack_double
pop_stack_string
pop_stack_object

操作数类型 byte short cp
cp cp
short short short short short short short short

含义
将操作数指定的一个字节的整数 入栈
将操作数指定的两个字节的整数 入栈
将常量池中的 int 常量入栈
将 double 常量 0 入栈
将 double 常量 1 入栈
将常量池中的 double 常量入栈
将常量池中的 string 常量入栈
将 null 入栈
将栈中以 base 为基准以操作数 为偏移量的位置的 int 值入栈
将栈中以 base 为基准以操作数为 偏移量的位置的 double 值入栈
将栈中以 base 为基准以操作数为 偏移量的位置的 string 值入栈
将栈中以 base 为基准以操作数为 偏移量的位置的 object 值入栈
将栈中以 base 为基准以操作数 为偏移量的位置的 int 值出栈
将栈中以 base 为基准以操作数为 偏移量的位置的 double 值出栈
将栈中以 base 为基准以操作数为 偏移量的位置的 string 值出栈
将栈中以 base 为基准以操作数为 偏移量的位置的 object 值出栈

栈 [] → [int]
[] → [int] [] → [int] [] → [double] [] → [double] [] → [double] [] → [string] [] → [object] [] → [int]
[] → [double]
[] → [string]
[] → [object]
[int] → []
[double] → []
[string] → []
[object] → []

since 0.1
0.1 0.1 0.1 0.1 0.1 0.1 0.2 0.1
0.1
仅 0.1
0.2
0.1
0.1
仅 0.1
0.2

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

C.2　指令一览表 3 6 1

指令 push_static_int push_static_double push_static_string push_static_object pop_static_int pop_static_double pop_static_string pop_static_object push_constant_int push_constant_double push_constant_object pop_constant_int pop_constant_double pop_constant_object push_array_int

操作数类型 short short short short short short short short short short short short short short

含义
以 操 作 数 为 索 引 值， 将 对 应 的 int 型静态变量入栈
以 操 作 数 为 索 引 值， 将 对 应 的 double 型静态变量入栈
以 操 作 数 为 索 引 值， 将 对 应 的 string 型静态变量入栈
以 操 作 数 为 索 引 值， 将 对 应 的 object 型静态变量入栈
将栈顶的值出栈保存为 int 型静 态变量，其索引值由操作数指定
将栈顶的值出栈保存为 double 型 静态变量，其索引值由操作数指定
将栈顶的值出栈保存为 string 型 静态变量，其索引值由操作数指定
将栈顶的值出栈保存为 object 型 静态变量，其索引值由操作数指定
将操作数指定索引值的 int 型常 量入栈
将操作数指定索引值的 double 型 常量入栈
将操作数指定索引值的 object 型 常量入栈
将栈顶的值出栈保存为 int 型常 量，其索引值由操作数指定
将 栈 顶 的 值 出 栈 保 存 为 double 型常量，其索引值由操作数指定
将栈顶的值出栈保存为 object 型常量，其索引值由操作数指定
根据栈中的数组和下标获取数组中 的元素（int 型），并将其入栈

栈 [] → [int] [] → [double] [] → [string] [] → [object] [int] → [] [double] → [] [string] → [] [object] → [] [] → [int] [] → [double] [] → [object] [int] → [] [double] → [] [object] → [] [array int] → [int]

（续） since 0.1 0.1 仅 0.1 0.2 0.1 0.1 仅 0.1 0.2 0.4 0.4 0.4 0.4 0.4 0.4 0.2

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3 6 2 附录 C　Diksam Virtual Machine 指令集

指令 push_array_double push_array_object

（续）

操作数类型 含义

栈

since

根据栈中的数组和下标获取数组

[array int] →

中的元素（double 型），并将其

0.2

[double]

入栈

根据栈中的数组和下标获取数组

[array int] → [ob-

中的元素（object 型），并将其

0.2

ject]

入栈

pop_array_int

将栈上的值（int1）赋值给数组 [int1 array int2]

0.2

array 中下标为 int2 的元素

→ []

pop_array_double

将栈上的值（double）赋值给数 [double array int]

0.2

组 array 中下标为 int 的元素

→ []

pop_array_object

将栈上的值（object）赋值给数 [object array int]

0.2

组 array 中下标为 int 的元素

→ []

push_character_in_ string

从栈顶获取索引值，并取得栈中 排在第二个位置的字符串，将字 [string int] →
0.4 符串中与索引值对应（从 0 开始） [int] 的字符的字符编码入栈

push_field_int push_field_double push_field_object pop_field_int pop_field_double

short short short short short

从栈中对象的字段中（由操作数

指定索引值）取得 int 型的值并 [object] → [int]

0.3

将其入栈

从栈中对象的字段中（由操作数

[object] → [dou-

指定索引值）取得 double 型的

0.3

ble]

值并将其入栈

从栈中对象的字段中（由操作数

[object] → [ob-

指定索引值）取得 object 型的

0.3

ject]

值并将其入栈

将栈中 int 型的值出栈，并赋值 给栈中指定对象的字段（由操作 [int object] → [] 0.3 数指定索引值）

将栈中 double 型的值出栈，并

[double object] →

赋值给栈中指定对象的字段（由

0.3

[]

操作数指定索引值）

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

C.2　指令一览表 3 6 3

指令 pop_field_object add_int add_double add_string sub_int sub_double mul_int mul_double div_int div_double mod_int mod_double

（续）

操作数类型 含义

栈

short

将栈中 object 型的值（object1） 出 栈， 并 赋 值 给 栈 中 指 定 对 象 （object2）的字段（由操作数指 定索引值）

[object1 object2] → []

进行 int 间的加法运算，并将结 果入栈

[int int] → [int]

进行 double 间的加法运算，并 将结果入栈

[double double] → [double]

since 0.3 0.1 0.1

[string1 string2]

进行 string 间的加法运算，并

→ [(string1 +

0.1

将结果入栈

string2)]

进行 int 间的减法运算，并将结 [int1 int2] →

0.1

果入栈

[(int1 - int2)]

[double1 double2] 进行 double 间的减法运算，并
→ [(double1 - dou- 0.1 将结果入栈
ble2)]

进行 int 间的乘法运算，并将结 [int int] → [int] 0.1
果入栈

进行 double 间的乘法运算，并 [double double] →

0.1

将结果入栈

[double]

进行 int 间的除法运算，并将结 [int1 int2] →

0.1

果入栈

[(int1 / int2)]

[double1 double2]

进行 double 间的除法运算，并

→ [(double1 /

0.1

将结果入栈

double2)]

进行 int 间的模运算，并将结果 [int1 int2] →

0.1

入栈

[(int1 % int2)]

[double1 double2] 进行 double 间的模运算，并将
→ [(fmod(double1, 0.1 结果入栈
double2))]

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3 6 4 附录 C　Diksam Virtual Machine 指令集

指令 bit_and
bit_or
bit_xor minus_int minus_double
bit_not increment decrement cast_int_to_double cast_double_to_int cast_boolean_to_string cast_int_to_string cast_double_to_string cast_enum_to_string up_cast
down_cast
eq_int
eq_double

（续）

操作数类型 含义

栈

since

按位进行与运算（int 之间），并 [int int] → [int] 0.4
将结果入栈

按位进行或运算（int 之间），并 [int int] → [int] 0.4
将结果入栈

按位进行异或运算（int 之间）， [int int] → [int] 0.4
并将结果入栈

反转栈顶 int 值的符号

[int] → [int]

0.1

反转栈顶 double 值的符号

[double] → [dou0.1
ble]

按位进行非运算，并将结果入栈。

[int] → [int]

0.4

（将栈顶的 int 值按位取反）

自增栈顶的 int 值

[int] → [int]

0.1

自减栈顶的 int 值

[int] → [int]

0.1

将栈顶的 int 值转换为 double [int] → [double]

0.1

将栈顶的 double 值转换为 int [double] → [int]

0.1

将栈顶的 boolean 值转换为字符 [boolean] →

0.1

串（true 或者 false）

[string]

将栈顶的 int 值转换为字符串

[int] → [string]

0.1

[double] →

将栈顶的 double 值转换为字符串

0.1

[string]

将栈顶的 enum 值转换为字符串

[enum] → [string] 0.4

short

将栈顶指向对象的引用向上转型 [object] → [ob-

0.3

为操作数指定的类或者接口

ject]

short

将栈顶指向对象的引用向下转型 [object] → [ob-

0.3

为操作数指定的类或者接口

ject]

进行 int 间的比较（==）并将结 [int int] → [bool-

0.1

果入栈

ean]

进行 double 间的比较（==）并 [double double] →

0.1

将结果入栈

[boolean]

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

指令 eq_object eq_string gt_int gt_double
gt_string ge_int ge_double
ge_string lt_int lt_double
lt_string

C.2　指令一览表 3 6 5

操作数类型 含义

栈

进行 object 间的比较（==）并 将结果入栈

[object object] → [boolean]

进行 string 间的比较（==）并 将结果入栈

[string string] → [boolean]

进 行 int 间 的 比 较（>） 并 将 结 果入栈

[int1 int2] → [(int1 > int2)]

进行 double 间的比较（>）并将 结果入栈

[double1 double2] → [(double1 > double2)]

进行字符串间的比较（>/ 字典顺 序）并将结果入栈

[string1 string2] → [(wcscmp(string1, string2) > 0)]

进行 int 间的比较（>=）并将结 果入栈

[int1 int2] → [(int1 >= int2)]

进行 double 间的比较（>=）并 将结果入栈

[double1 double2] → [(double1 >= double2)]

进行字符串间的比较（>=/ 字典 顺序）并将结果入栈

[string1 string2] → [(wcscmp(string1, string2) >= 0)]

进 行 int 间 的 比 较（<） 并 将 结 果入栈

[int1 int2] → [(int1 < int2)]

进行 double 间的比较（<）并将 结果入栈

[double1 double2] → [(double1 < double2)]

进行字符串间的比较（</ 字典顺 序）并将结果入栈

[string1 string2] → [(wcscmp(string1, string2) < 0)]

（续） since 0.2 0.1 0.1 0.1
0.1 0.1 0.1
0.1 0.1 0.1
0.1

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3 6 6 附录 C　Diksam Virtual Machine 指令集

指令 le_int
le_double
le_string
ne_int ne_double ne_object ne_string logical_and logical_or logical_not pop duplicate duplicate_offset jump jump_if_true

（续）

操作数类型

含义
进行 int 间的比较（<=）并将结 果入栈

栈
[int1 int2] → [(int1 <= int2)]

since 0.1

[double1 double2]

进行 double 间的比较（<=）并

→ [(double1 <=

0.1

将结果入栈

double2)]

[string1

进行字符串间的比较（<=/ 字典 string2] →

0.1

顺序）并将结果入栈

[(wcscmp(string1,

string2) <= 0)]

进行 int 间的比较（内容比较时 [int int] → [bool-

0.1

使用 !=）并将结果入栈

ean]

进行 double 间的比较（内容比 [double double] →

0.1

较时使用 !=）并将结果入栈

[boolean]

进行 object 间的比较（内容比 [object object] →

0.2

较时使用 !=）并将结果入栈

[boolean]

进行 string 间的比较（内容比 [string string] →

0.1

较时使用 !=）并将结果入栈

[boolean]

将逻辑与（AND）的结果入栈

[boolean boolean] 0.1
→ [boolean]

将逻辑或（OR）的结果入栈

[boolean boolean] 0.1
→ [boolean]

将栈顶的值取逻辑反（NOT） 舍弃栈顶的一个值 复制栈顶的一个值

[boolean] → [bool0.1
ean]

[T] → []

0.1

[T] → [T T]

0.1

复制距离栈顶的第 n（操作数）个

short

[] → [object]

0.3

元素并将其入栈

short

跳转到操作数指定的地址

[] → []

0.1

如果栈顶的值为 true，则跳转到

short

[boolean] → []

0.1

操作数指定的地址

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

C.2　指令一览表 3 6 7

指令 jump_if_false

操作数类型 short

含义
如果栈顶的值为 false，则 跳 转 到操作数指定的地址

栈 [boolean] → []

（续） since 0.1

push_function

short

将操作数指定的函数的索引值入栈 [] → [function]

0.1

push_method

short

创建栈中对象中以操作数为索引 [object] → [object

0.3

值的方法入栈

int]

push_delegate

通过函数的索引值创建 delegate

short

[] → [object]

0.4

并将其入栈

push_method_delegate

short

创建栈中对象中以操作数为索引

[object] → [ob-

值的方法的 delegate，并将其

0.4

ject]

入栈

invoke

调用栈顶的函数

[function] → [xx] 0.1

invoke_delegate

调用栈顶的 delegate

[object] → [xx]

0.4

return

以栈顶的值作为返回值并将函数

[ 返回值 ] → [xx]

0.1

return

对操作数 short 指定的索引值的

new

short

[] → [object]

0.3

类进行 new 操作

new_array

创建以操作数 short 所示类型组

[size1 size2 ...]

byte,short 成 的 byte 维 数 组（ 用 栈 中 指 定

0.2

→ [array]

个数的元素），并将其入栈

new_array_literal_ short
int

以已经入栈的给定数量的 int 类

[int1 int2 int3

型的操作数为元素创建数组，并

0.2

...] → [array]

将其入栈

new_array_literal_ short
double

以已经入栈的给定数量的 double [double1 double2

类 型 的 操 作 数 为 元 素 创 建 数 组， double3 ...] →

0.2

并将其入栈

[array]

new_array_literal_ short
object

以已经入栈的给定数量的 object [object1 object2

类 型 的 操 作 数 为 元 素 创 建 数 组， object3 ...] →

0.2

并将其入栈

[array]

super

将栈顶的对象引用的 vtable 转换 [object] → [ob-

0.3

为它父类的

ject]

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3 6 8 附录 C　Diksam Virtual Machine 指令集

指令 instanceof throw rethrow go_finally
finally_end

操作数类型 含义

栈

short

返回栈顶的对象是否属于操作数 [object] → [bool-

的索引值所对应类的实例

ean]

抛出栈顶的异常。同时清除栈轨 迹

[object] → [xx]

抛出栈顶的异常

[object] → [xx]

short

把当前的程序计数器入栈，并跳 转到操作数所示的地址

[] → [pc]

在异常状态下 throw 捕获的异常。 在非异常状态的时候，返回到通 过 go_finally 跳转过来的位置 （从栈中恢复程序计数器）

[pc] → []

（续） since 0.3 0.4 0.4 0.4
0.4

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

编程语言实用化指南——写在最后

.
* Visual Basic 的 名 字 虽 然 继 承 了 Basic， 但 其 实是完全不同的另一种 语言。

在本书中，我们一起制作了 crowbar 和 Diksam 两种编程语言。让我感到欣慰 的是，书中的示例程序不只是停留在入门级别，而是达到了实用语言的水准。
亲爱的读者朋友们，希望你们也能尝试制作属于自己的编程语言。不过说出 来你们可能会大跌眼镜， 编程语言的魅力基本上是由它的程序库来决定的 ，而这 是不容争辩的事实。
例如，Perl 由于正则表达式等强有力的字符串处理功能得到了广泛的应用。 在 Perl4 的时候，作为编程语言，Perl 既没有引用，也不能创建数据结构，可以 说很难用。但是，因为它处理文本文件十分方便，所以得到了广泛使用。同样， PHP 也因为提供了很多面向网页应用的功能而得到了普及。语言是否实用，是否 能够普及，实际上和语言的设计本身没有太大关系。
因此，我在发明了 crowbar 和 Diksam 两种语言后，为它们加载了各自的程 序库。
首先，我为 crowbar 加载了鬼车，使它具有用正则表达式处理文本的能力。 在 Diksam 中我用 crowbar 来处理文本。在 文本处理这个领域里已经有了 Perl、Ruby 等语言，因此就算是为此特地制作一门语言也不会得到广泛普及。用 来开发 Web 应用的编程语言更是琳琅满目，比如 PHP、Perl、Ruby、Java、ASP、 ASP.NET 等，在这个领域中还充斥着各种框架，可以说是一个大杂烩。租赁服务 器更是让人头疼，好不容易做的网页应用，有可能会因为服务器不能支持而不能 使用。就这点来说，已经很让人沮丧了。 因此，我考虑让 Diksam 定位为“让初学者可以制作简单游戏的语言”。 在很早之前，我自己就是这样走上了编程的道路。 那个时候（1980 年左右）的个人电脑，大多将 BASIC 作为标准配置。那个 时候的编程语言没有 IF 语句中 begin~end 或者 {} 之类的程序块的概念，选 择分支的时候必须使用 GOTO  行号的方式进行跳转。也没有循环结构的 FOR 语 句。要在循环外面记录循环计数器后，再使用 GOTO 进行跳转。虽然可以使 用 GOSUB 制作子程序，但是不能定义局部变量，所有变量都要当做全局变量来 处理。此外，变量名字不看到第 2 个字符，是区分不出来的 *。当然，这是时代 的选择，不过，当时的 BASIC 作为编程语言来说还真是不怎么样。 即使如此，我当时只用了几十行代码就可以写一款射击游戏（用字符“┴”

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3 7 0 编程语言实用化指南——写在最后

* 从 HSP3 开始可以通过 函数实现。
* 这种情况仅限于 Windows 平台。

当做炮台来击落用字符“-o-”做成的飞碟）。我觉得这个过程十分有趣，这也是 我踏上编程学习道路的第一步。
但是对于现在的年轻人来说，却不知道怎么去实现一款简单的游戏。 现在这些 PC 的性能与当时相比可以说有了飞跃性的提高，也出现了各种各 样的编程语言和免费的处理器。但是，比如在 C 语言中，使用不依赖处理器的标 准 C，就连窗体都打不开。即便只是在 Windows 中能够运行起来的程序，C 语言 也要通过 Windows 的 API 来创建窗口，如此复杂的程序初学者根本应付不来。 我觉得在现在 C 语言的入门书中，多半从“hello,world.”开始介绍许多 命令行程序。但是，我在中学时代，从最开始就能写出和“hello,world.”差 不多的程序，接着就编了猜数字游戏，然后就想着要做一款打飞碟的游戏了。当 今，计算机已经十分先进，但人们在这个方面反而退化了。 当 然， 现 在 不 仅 可 以 使 用 C 语 言， 也 考 虑 使 用 Java。Java 中 的 GUI 可 以 不依赖于处理器，因此也可以把游戏做成 Applet 发布在网站上，在朋友面前炫 耀一把。但这样一来，在创建类的时候就需要继承一种叫作 java.applet. Applet 的类，并重写它的 init() 和 paint() 之类的方法。这里突然出现了很 多面向对象的知识，初学者一时之间很难接受。也许有人会觉得我又在这里老调 重弹了，但是仔细想想，为了从 GUI 接收输入，就必须要创建事件监听器、实现 特定的接口，除此之外还需要使用内部类和匿名类。这些还没完，因为制作的是 实时游戏，为了实现动画效果还需要使用多线程进行异步处理。这些对于一个新 手来说简直是个噩梦。 再者，制作“打飞碟”这样一款游戏对于 JavaScript 来说也不是很容易。可 以制作 FLASH 的语言 ActionScript，它的标准处理器又不是免费的。 HSP（Hot.Soup.Processor）语言是我在中学时代玩过的类似于 BASIC 的语 言。不过，很对不起这门语言的 fans，这门语言本身和与它同时代的 BASIC 如出 一辙，因此对于刚开始学习编程的人来说非常不推荐。它甚至没有 GOSUB*。 因此，我在 Diksam 中加载了可以让“打飞碟”游戏实现起来更为简单的程 序库 *。 因为要制作的游戏非常简单，所以无须特意想着面向对象和事件驱动的概 念。例如“打飞碟”游戏可以写成下面这样。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

编程语言实用化指南——写在最后 3 7 1

代码清单 1-4 “打飞碟”游戏的程序 （ufo.dkm） 

1: require diksam.window; 2:  3: // 创建设置窗体属性的 WindowAttribute 对象。
4: WindowAttribute attr = create_window_attribute(); 5: // 设置背景色为黑色。 6: attr.background = create_solid_brush(0, 0, 0); 7: 8: // 创建窗体。如果使用默认设置就可以， 9: // 那么不创建 attr 传入 null 即可。 10: Window w = create_window(“UFO 游戏”, 800, 600, attr); 11: 12: // 使用 x 键终止程序。 13: w.set_destroy_proc(window_destroy_and_exit); 14: // 显示窗体。 15: w.show(); 16: 17: // 为了描绘窗体取得 Graphics 接口。 18: Graphic g = w.get_graphics(); 19: // 将字符的背景色设置为黑色。 20: g.set_background_color(new Color(0, 0, 0)); 21: 22: // 战车、激光、UFO 的颜色设置。 23: Color tank_color = new Color(60, 255, 100); 24: Color ufo_color = new Color(60, 255, 255); 25: Color beam_color = new Color(255, 255, 100); 26: // 生成字体。详细的设置（FontAttribute） 27: // 与 WindowAttribute 相同，当前默认为 null。 28: Font font = create_font(25, null); 29: 30: // 随机数的初始化 31: randomize(); 32: 33: // 游戏结束后再开始使用的循环 34: for(;;){ 35: // 设定炮台（tank）、ufo 的坐标。将 tank_x，ufo_x，ufo_y 的 36: // 当前坐标赋值给 prev，作为前一次绘制的坐标（消除时使用）。 37: // ufo_next_x,y 作为 ufo 的移动目标的坐标。 38: // ufo 将在 ufo_next_x,y 的附近移动， 39: // 但如果两次坐标基本相同，则重新设定 ufo_next_x,y。 40: int tank_x = 0; 41: int ufo_x = 0; 42: int ufo_y = 0; 43: int ufo_prev_x = ufo_x; 44: int ufo_prev_y = ufo_y; 45: int ufo_next_x = random(700); 46: int ufo_next_y = random(450); 47: // 是否存在炮台发射的激光的标识和激光坐标

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3 7 2 编程语言实用化指南——写在最后

48: boolean beam_flag = false;

49: int beam_prev_y;

50: int beam_x;

51: int beam_y;

52:

53: // 游戏的主循环

54: for(;;){

55:

// 消除前一次画出来的 UFO。

56:

g.draw_string(font, ufo_color, ufo_prev_x, ufp_prev_y," ");

57:

// 绘制 UFO。

58:

g.draw_string(font, ufo_color, ufo_x, ufp_y," ├ O ┤ ");

59:

// 为了再次消除，保存本次绘制的坐标。

60:

ufo_prev_x = ufo_x;

61:

ufo_prev_y = ufo_y;

62:

// 绘制炮台。

63:

g.draw_string(font, ufo_color, tank_x, 540," / ┴ \ ");

64:

// 发射了激光的话……

65:

if(beam_flag){

66:

// 消除前面的激光，重画新的激光。

67:

g.draw_string(font, ufo_color, ufo_prev_x, ufp_prev_y," ");

68:

g.draw_string(font, ufo_color, ufo_x, ufp_y,"|");

69:

beam_prev_y = beam_y;

70:

71:

// 碰撞判断。可能很幼稚。

72:

if(beam_x >= ufo_x && beam_x < ufo_x + 80

73:

&& beam_y >= ufo_y && beam_y < ufo_y +60){

74:

// 被激光打中后跳出循环。

75:

break;

76:

}

77:

}

78:

79:

// 通过判断键盘输入移动炮台。

80:

if(is_key_pressed(KeyCode.LEFT) && tank_x > 0){

81:

tank_x -= 10;

82:

} elseif(is_key_pressed(KeyCode.RIGHT) && tank_x < 700){

83:

tank_x += 10;

84:

}

85:

if(is_key_pressed(KeyCode.SPACE) && !beam_flag){

86:

beam_flag = true;

87:

beam_x = tank_x + 40;

88:

beam_y = beam_prev_y = 480;

89:

}

90:

// UFO 的移动。在 ufo_next_x,y 的附近移动。

91:

if(ufo_x < ufo_next_x -10){

92:

ufo_x += 10;

93:

} elseif(ufo_x > ufo_next_x + 10){

94:

ufo_x -= 10;

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

编程语言实用化指南——写在最后 3 7 3

95: 96: 97: 98: 99: 100: 101: 102: 103: 104: 105: 106: 107: 108: 109: 110: 111: 112: 113: 114: 115: 116: 117: 118: 119: 120: 121: 122: 123: 124: 125: 126: 127: 128: 129: 130: 131: 132: 133: 134: 135: 136: }

} else { // 如果两次坐标基本相同，则重新设定目标坐标。 ufo_next_x = random(700);
} if(ufo_y < ufo_next_y - 10) {
ufo_y += 10; } elseif (ufo_y > ufo_next_y + 10) {
ufo_y -= 10; } else {
ufo_next_y = random(450); } // 激光的移动 if(beam_flag) {
if(beam_y < -20){ beam_flag = false;
} beam_y -= 20; } // 定时消息循环。无论有没有 // 鼠标或者键盘事件，都等待 20 毫秒。 timed_message_loop(w, 20); }
// 被激光打中后跳出循环，执行这里。 for(;;){
// 显示爆炸效果 Color explosion_color = new Color(255, 0, 0); g.draw_string(font, explosion_color, ufo_x, ufo_y, "***"); timed_message_loop(w, 100); g.draw_string(font, explosion_color, ufo_x, ufo_y, "###"); timed_message_loop(w, 100); // 按 N 重启游戏，按 Q 退出。 if(is_key_pressed(KeyCode.N)){
Brush b = create_solic_brush(0, 0, 0); g.fill_rectangle(b, 0, 0, 800, 600); b.dispose(); break; } elsif (is_key_pressed(KeyCode.Q)) { exit(0); } }

游戏的截屏如下所示。

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3 7 4 编程语言实用化指南——写在最后

* 当 然， 在 Diksam 中 也
可以很简单地使用图标
来表示 UFO。

这是个跟我同时代的人都会怀念的画面吧 *。 Diksam 在这个领域的进化旅程才刚开始，谁也不知道它在未来会变成什么样 子。但是，在代码清单“ufo.dkm”的程序中，只能有一架 UFO，在同一时间炮 台只能发射一发激光（因为表示 UFO 和激光位置的变量只有一组）。如果觉得这 样没意思的话，就必须要使用数组了。x 坐标和 y 坐标要是都使用数组来管理的 话，肯定会很不方便，如果有类的话感觉就会方便很多。同样，即使不同时出现 多个飞碟，如果想要各种各样的敌人轮番登场，就要使用继承和多态了……一门 语言因为追寻着这样的思路而具有了面向对象的概念，真让人兴奋。 各位读者朋友，你们想让自己的编程语言向哪个方向发展呢？希望本书能给 各位带来一些启发。.

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

参考文献
■■书中引用到的文献  [1] 情報処理シリーズ７ コンパイラ 英文版：Principles of Compiler DesignA
[2].プログラミング言語 C 英文版：The C Programming Language 中文版：《C 程序设计语言》（机械工业出版社） [3].The.Problem.with.Integer.Division. http://python-history.blogspot.com/2009/03/problem-with-integer-division.html. [4].文字符号の歴史——欧米と日本編 中文译名：《文字符号的历史——欧美与日本篇》 作者：安冈孝一.安冈素子 出版社：共立出版社，2006 年. [5].プログラミング作法 英文版：The Practice of Programming 中文版：《程序设计实践》（.. 机械工业出版社） [6].YARV アーキテクチャ 英文版：YARV Architecture http://www.atdot.net/yarv/yarvarch.en.html. [7].The.Java®.Language.Specification http://docs.oracle.com/javase/specs/jls/se7/html/index.html.
A　P rinciples of Compiler Design 的封面是一名骑士和一只恐龙，因此被人称为“龙书”，但因为那 条龙是绿色的，所以称为“绿龙书”。9 年后（1986 年），原来的两位作者加上 Ravi Sethi, 升级 了这本书，书名改为 Compilers: Principles, Techniques and Tools，封面依然沿用骑士和恐龙， 那头龙是红色的，因此被叫作“龙书二”或者是“红龙书”。——译者注
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3 7 6 参考文献
[8].オブジェクト指向入門 第 2 版 原則 · コンセプト 英文版：Object-Oriented Software Construction,Second Edition [9].Effective.Java.プログラミング言語ガイド 英文版：Effective Java 中文版：《Effective.Java 中文版（第 2 版）》（. 机械工业出版社） [10].オブジェクト指向における再利用のためのデザインパターン 英文版：Design Patterns: Elements of Reusable Object-Oriented Software 中文版：《设计模式：可复用面向对象软件的基础》（. 机械工业出版社） [11].The.Trouble.with.Checked.Exceptions http://www.artima.com/intv/handcuffs.html [12].Java の理論と実践： 例外をめぐる議論 チェックすべきか、チャックせ ずにおくべきか 中文译名：Java.理论与实践：关于异常的争论.要检查，还是不要检查？ http://www.ibm.com/developerworks/cn/java/j-jtp05254/. [13].Exceptions http://joelonsoftware.com/items/2003/10/13.html [14].Cleaner,.more.elegant,.and.harder.to.recognize http://blogs.msdn.com/b/oldnewthing/archive/2005/01/14/352949.aspx [15].More Joel On Software 中文版：《软件随想录：程序员部落酋长 Joel 谈软件》（. 人民邮电出版社） [16].Python リファレンスマニュアル 2.4.1. 文字列リテラル 英文版：The Python Language Reference 2.4.1. String literals http://docs.python.org/2/reference/lexical_analysis.html#literals
■■其他推荐的书  关于制作编程语言的书虽然经常会出，但是多数由于出版量不大而慢慢地绝
版了……（希望本书不会这样）
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

参考文献 3 7 7
因此我将以前学习过的书作一个介绍（说句题外话，近藤嘉雪老师的“yacc による C コンパイラプログラミング”（《使用 yacc 开发 C 语言编译器》）一书在 日本亚马逊网站上卖到了 245.000 日元 A，即使是这样我仍然觉得这本书很值得）， 在这里只介绍一些价格合适并且在市面上可以买到的书。
下面列出的是本书出版时（2009 年 4 月）的参考书籍。.
●.新コンピュータサイエンス講義 コンパイラ 中文译名：《新计算机科学讲座：编译器》 作者：田中育男 出版社：Ohmsha 出版社，1995 日本编译器第一人田中育男先生的书。 田中先生的这本书以理论为主，难点很多。书中记录了类似于 Pascal 的语言 处理“PL/0”的全部代码，很有实用价值。PL/0 是一个递归下降语法分析器，因 此本书可以为不想使用 yacc 来制作编程语言的人提供参考。
●.lex.&.yacc.プログラミング 英文版：lex & yacc 中文版：《lex 与 yacc》（机械工业出版社.已绝版）. O’Reilly 的动物系列图书。我认为就凭它在这个系列中，这本书就值得信 赖。它的出版时间较早，但可以作为 yacc/lex 的参考手册，是一本非常有实用价 值的书。 下面这些书是我目前正在学习的。
●.コンパイラⅠ－原理 · 技法 · ツール 英文版：Compilers: Principles, Techniques, and Tools (2nd Edition) 中文版：《编译原理》（. 机械工业出版社） 可以说是编译器制作方面的圣经之著。因为封面上印有龙的图案所以被叫作 “龙书”（确切地说应该是“红龙书”）（第 4 章中译者也引用了这本书中的内容）。 本书是原版的第一卷。现在，第二卷已经很难见到了（即便是作者这样的资 深人士也没有机会收藏）。 本书内容不太容易理解（例如在不使用 yacc 的情况下制作 LR 解析器），但
A　相当于人民币 15 000 元左右。——译者注
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

3 7 8 参考文献 我觉得这是本不可不读的好书。 ●.コンパイラの構成と最適化. 中文译名：《编译器的结构与优化》 作者：田中育男 出版社：朝仓书店，1999 又是田中先生的书。其中对“优化”的.讲解占到了本书一半以上的篇幅。 如果你想要了解现在的商业化编译器是怎样做的，这本书再合适不过了。 ●.Garbage Collection: Algorithms for Automatic Dynamic Memory Management 作者：Richar.Jones,Rafael.Lins 出版社：John.Wiley.&.Sons，1996 尚无译本。本书中不仅介绍了标记 - 清除 GC 和 Copying.GC 等算法，还讲解 了通过简单地实现来解决问题的方法（分代式 GC、增量 GC、并发 GC 等）。
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权





፡ਠԧ

ইຎ఍੒๜ԡٖ਻ํወᳯ҅‫ݎݢ‬ᮒկᛗFRQWDFW#WXULQJERRNFRP҅տํᖫᬋ౲֢ ᦲᘏ‫ۗܐ‬ᒼወ̶Ԟ‫ᦢݢ‬ᳯࢶᅎᐒ‫݇҅܄‬Ө๜ԡᦎᦞ̶
ইຎฎํ‫ى‬ኪৼԡጱୌᦓ౲ᳯ᷌҅᧗ᘶᔮӫአਮ๐ᮒᓟ HERRN#WXULQJERRNFRP̶
ࣁᬯ‫ݢ‬զತ‫ک‬౯ժ
ங‫ܗ‬#ࢶᅎරᙙঅԡ̵ၚۖྯ෭ඎಸ  ங‫ܗ‬#ࢶᅎᐒ‫܄‬ኪৼԡ޾অ෈ᒍጱၾ௳  ங‫ܗ‬#ࢶᅎෛᎣࢶᅎරᙙጱᑀฦੜᕟ  ங‫ࢶמ‬ᅎᦢ᧨LWXULQJBLQWHUYLHZ҅ᦖᬿᎱ١ᔜ୸Ոኞ  ங‫ࢶמ‬ᅎරᙙWXULQJERRNV
图灵社区会员 leezom(superjavaman.zhangli@gmail.com) 专享 尊重版权

