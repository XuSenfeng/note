鸟哥的 Linux 私房菜：基础学习篇 第四版

目錄

鸟哥的Linux私房菜：基础学习篇 第四版

0

目录及概述

1

第零章、计算机概论

2

0.1 电脑：辅助人脑的好工具

2.1

0.2 个人电脑架构与相关设备元件

2.2

0.3 数据表示方式

2.3

0.4 软件程序运行

2.4

0.5 重点回顾

2.5

0.6 本章习题

2.6

0.7 参考资料与延伸阅读

2.7

第一章、Linux是什么与如何学习

3

1.1 Linux是什么

3.1

1.2 Torvalds的Linux发展

3.2

1.3 Linux当前应用的角色

3.3

1.4 Linux 该如何学习

3.4

1.5 重点回顾

3.5

1.6 本章习题

3.6

1.7 参考资料与延伸阅读

3.7

第二章、主机规划与磁盘分区

4

2.1 Linux与硬件的搭配

4.1

2.2 磁盘分区

4.2

2.3 安装Linux前的规划

4.3

2.4 重点回顾

4.4

2.5 本章习题

4.5

2.6 参考资料与延伸阅读

4.6

第三章、安装 CentOS7.x

5

3.1 本练习机的规划--尤其是分区参数

5.1

3.2 开始安装CentOS 7

5.2

3.3 多重开机安装流程与管理（Option）

5.3

3.4 重点回顾

5.4

2

鸟哥的 Linux 私房菜：基础学习篇 第四版

3.5 本章习题

5.5

3.6 参考资料与延伸阅读

5.6

第四章、首次登陆与线上求助

6

4.1 首次登陆系统

6.1

4.2 文字模式下指令的下达

6.2

4.3 Linux系统的线上求助man page与info page

6.3

4.4 超简单文书编辑器： nano

6.4

4.5 正确的关机方法

6.5

4.6 重点回顾

6.6

4.7 本章习题

6.7

4.8 参考资料与延伸阅读

6.8

第五章、Linux 的文件权限与目录配置

7

5.1 使用者与群组

7.1

5.2 Linux 文件权限概念

7.2

5.3 Linux目录配置

7.3

5.4 重点回顾

7.4

5.5 本章练习

7.5

5.6 参考资料与延伸阅读

7.6

第六章、Linux 文件与目录管理

8

6.1 目录与路径

8.1

6.2 文件与目录管理

8.2

6.3 文件内容查阅

8.3

6.4 文件与目录的默认权限与隐藏权限

8.4

6.5 指令与文件的搜寻

8.5

6.6 极重要的复习！权限与指令间的关系

8.6

6.7 重点回顾

8.7

6.8 本章习题：

8.8

6.9 参考资料与延伸阅读

8.9

第七章、Linux 磁盘与文件系统管理

9

7.1 认识 Linux 文件系统

9.1

7.2 文件系统的简单操作

9.2

7.3 磁盘的分区、格式化、检验与挂载

9.3

7.4 设置开机挂载

9.4

7.5 内存交换空间（swap）之创建

9.5

3

鸟哥的 Linux 私房菜：基础学习篇 第四版
7.6 文件系统的特殊观察与操作 7.7 重点回顾 7.8 本章习题 - 第一题一定要做 7.9 参考资料与延伸阅读 第八章、文件与文件系统的压缩,打包与备份 8.1 压缩文件的用途与技术 8.2 Linux 系统常见的压缩指令 8.3 打包指令： tar 8.4 XFS 文件系统的备份与还原 8.5 光盘写入工具 8.6 其他常见的压缩与备份工具 8.7 重点回顾 8.8 本章习题 8.9 参考资料与延伸阅读 第九章、vim 程序编辑器 9.1 vi 与 vim 9.2 vi 的使用 9.3 vim 的额外功能 9.4 其他 vim 使用注意事项 9.5 重点回顾 9.6 本章练习 9.7 参考资料与延伸阅读 第十章、认识与学习BASH 10.1 认识 BASH 这个 Shell 10.2 Shell 的变量功能 10.3 命令别名与历史命令 10.4 Bash Shell 的操作环境： 10.5 数据流重导向 10.6 管线命令 （pipe） 10.7 重点回顾 10.8 本章习题 10.9 参考资料与延伸阅读 第十一章、正则表达式与文件格式化处理

9.6 9.7 9.8 9.9 10 10.1 10.2 10.3 10.4 10.5 10.6 10.7 10.8 10.9 11 11.1 11.2 11.3 11.4 11.5 11.6 11.7 12 12.1 12.2 12.3 12.4 12.5 12.6 12.7 12.8 12.9 13
4

鸟哥的 Linux 私房菜：基础学习篇 第四版
11.1 开始之前：什么是正则表达式 11.2 基础正则表达式 11.3 延伸正则表达式 11.4 文件的格式化与相关处理 11.5 重点回顾 11.6 本章习题 11.7 参考资料与延伸阅读 第十二章、学习 Shell Scripts 12.1 什么是 Shell scripts 12.2 简单的 shell script 练习 12.3 善用判断式 12.4 条件判断式 12.5 循环 （loop） 12.6 shell script 的追踪与 debug 12.7 重点回顾 12.8 本章习题 第十三章、Linux 帐号管理与 ACL 权限设置 13.1 Linux 的帐号与群组 13.2 帐号管理 13.3 主机的细部权限规划：ACL 的使用 13.4 使用者身份切换 13.5 使用者的特殊 shell 与 PAM 模块 13.6 Linux 主机上的使用者讯息传递 13.7 CentOS 7 环境下大量创建帐号的方法 13.8 重点回顾 13.9 本章习题 13.10 参考资料与延伸阅读 第十四章、磁盘配额（Quota）与进阶文件系统管理 14.1 磁盘配额 （Quota） 的应用与实作 14.2 软件磁盘阵列 （Software RAID） 14.3 逻辑卷轴管理员 （Logical Volume Manager） 14.4 重点回顾 14.5 本章习题 14.6 参考资料与延伸阅读

13.1 13.2 13.3 13.4 13.5 13.6 13.7
14 14.1 14.2 14.3 14.4 14.5 14.6 14.7 14.8
15 15.1 15.2 15.3 15.4 15.5 15.6 15.7 15.8 15.9 15.10
16 16.1 16.2 16.3 16.4 16.5 16.6
5

鸟哥的 Linux 私房菜：基础学习篇 第四版
第十五章、例行性工作调度（crontab） 15.1 什么是例行性工作调度 15.2 仅执行一次的工作调度 15.3 循环执行的例行性工作调度 15.4 可唤醒停机期间的工作任务 15.5 重点回顾 15.6 本章习题
第十六章、程序管理与 SELinux 初探 16.1 什么是程序 （process） 16.2 工作管理 （job control） 16.3 程序管理 16.4 特殊文件与程序 16.5 SELinux 初探 16.6 重点回顾 16.7 本章习题 16.8 参考资料与延伸阅读
第十七章、认识系统服务 （daemons） 17.1 什么是 daemon 与服务 （service） 17.2 通过 systemctl 管理服务 17.3 systemctl 针对 service 类型的配置文件 17.4 systemctl 针对 timer 的配置文件 17.5 CentOS 7.x 默认启动的服务简易说明 17.6 重点回顾 17.7 本章习题 17.8 参考资料与延伸阅读
第十八章、认识与分析登录文件 18.1 什么是登录文件 18.2 rsyslog.service ：记录登录文件的服务 18.3 登录文件的轮替（logrotate） 18.4 systemd-journald.service 简介 18.5 分析登录文件 18.6 重点回顾 18.7 本章习题

17 17.1 17.2 17.3 17.4 17.5 17.6
18 18.1 18.2 18.3 18.4 18.5 18.6 18.7 18.8
19 19.1 19.2 19.3 19.4 19.5 19.6 19.7 19.8
20 20.1 20.2 20.3 20.4 20.5 20.6 20.7
6

鸟哥的 Linux 私房菜：基础学习篇 第四版
18.8 参考资料与延伸阅读 第十九章、开机流程、模块管理与 Loader
19.1 Linux 的开机流程分析 19.2 核心与核心模块 19.3 Boot Loader: Grub2 19.4 开机过程的问题解决 19.5 重点回顾 19.6 本章习题 19.7 参考资料与延伸阅读 第二十章、基础系统设置与备份策略 20.1 系统基本设置 20.2 服务器硬件数据的收集 20.3 备份要点 20.4 备份的种类、频率与工具的选择 20.5 鸟哥的备份策略 20.6 灾难复原的考虑 20.7 重点回顾 20.8 本章习题 20.9 参考资料与延伸阅读 第二十一章、软件安装：源代码与 Tarball 20.1 开放源码的软件安装与升级简介 21.2 使用传统程序语言进行编译的简单范例 21.3 用 make 进行宏编译 21.4 Tarball 的管理与建议 21.5 函数库管理 21.6 检验软件正确性 21.7 重点回顾 21.8 本章习题 21.9 参考资料与延伸阅读 第二十二章、软件安装 RPM, SRPM 与 YUM 22.1 软件管理员简介 22.2 RPM 软件管理程序： rpm 22.3 YUM 线上升级机制 22.4 SRPM 的使用 ： rpmbuild （Optional）

20.8 21
21.1 21.2 21.3 21.4 21.5 21.6 21.7
22 22.1 22.2 22.3 22.4 22.5 22.6 22.7 22.8 22.9
23 23.1 23.2 23.3 23.4 23.5 23.6 23.7 23.8 23.9
24 24.1 24.2 24.3 24.4
7

鸟哥的 Linux 私房菜：基础学习篇 第四版

22.5 重点回顾

24.5

22.6 本章习题

24.6

22.7 参考资料与延伸阅读

24.7

第二十三章、X Window 设置介绍

25

23.1 什么是 X Window System

25.1

23.2 X Server 配置文件解析与设置

25.2

23.3 显卡驱动程序安装范例

25.3

23.4 重点回顾

25.4

23.5 本章习题

25.5

23.6 参考资料与延伸阅读

25.6

第二十四章、Linux 核心编译与管理

26

24.1 编译前的任务：认识核心与取得核心源代码

26.1

24.2 核心编译的前处理与核心功能选择

26.2

24.3 核心的编译与安装

26.3

24.4 额外（单一）核心模块编译

26.4

24.5 以最新核心版本编译 CentOS 7.x 的核心

26.5

24.6 重点回顾

26.6

24.7 本章习题

26.7

24.8 参考资料与延伸阅读

26.8

8

鸟哥的 Linux 私房菜：基础学习篇 第四版
鸟哥的Linux私房菜：基础学习篇 第四版
来源：鳥哥的 Linux 私房菜 - 基礎學習篇

鸟哥的Linux私房菜：基础学习篇 第四版

9

鸟哥的 Linux 私房菜：基础学习篇 第四版

目录及概述

这本书的所有内容是学习Linux的基础，这些内容是基础中的基础，如果您能将其中的文字都 看完并且消化过，那么未来在管理 Linux主机以及架设网站方面，就能够达到“事半功倍”的成 效，请不要忽略这些内容了！否则，再怎么讨论都是枉然的啦！^_^。 Linux的资料非常的 多，每份资料彼此的相关性都很强，要单独的一项一项讲解并不容易， 那么这本书件该怎么 看呢？建议先按照顺序将内容大致浏览过一次，看不懂的地方也可以先略过不要紧。 全部看 完之后，再从头开始“仔细”的实际操作过一遍，那应该就能够进入Linux的世界啰～
另外，每个章节下面的日期，指的是重大改版日期而非最新日期，最新日期请以该章节结束 部分的工作日志为主的喔！
Linux 的学习曲线，一个老人家的建议！
1. VBird 与 Linux 2. VBird 的 Linux 学习之路 3. 学习心态的分别 4. 基本的学习流程 5. 基本的建站流程表 6. 简易的安全防护

第一部份 Linux 的规划与安装
常常听到Linux具有非常优良的血统，所以具有相当良好的多用户多任务环境，可以方便程序 设计师来开发软件。 此外，Linux本身是不用钱的“自由软件”，使用上面并没有所谓的“盗 版”问题。但是，为什么Linux不用钱？ 随便修改或发布Linux为什么不会被罚？为什么Linux有 这么多的版本？包括Fedora, SuSE, CentOS, Debian等等？ 这个都是我们必须要来了解的部 分！了解这些部分，你才会对Linux有一个正确的理解，才能够跟你的同事、同学、 上司说 明，为什么使用Linux具有很多优点与好处！ ^_^
Linux并不好学习，鸟哥也是“重伤”过好几次才能对Linux有一些基础的认知。那么到底应该如 何学习Linux呢？关键在实作。 既然要实作就得要实际的安装一部Linux，那么Linux要安装前 需要熟悉哪些基础观念？计算机概论是非常重要的一环！ 因为Linux与硬件的关系还不小～此 外，打造一台Windows/Linux共存的主机也是很有用的， 至少对于需要多平台但又缺乏空间 与金钱的朋友来说，这样的处理是非常有用的！
在第一篇里面，我们会由计算机概论谈起，再讲到Linux的历史渊源与自由软件的关系，然后 重点在于如何规划硬件与Linux安装， 最后谈到如何登陆与使用Linux图形/命令行的环境。本 篇数据较多，第一次接触Linux的新朋友， 很多数据若看不懂可以先略过，等到后续文章都读 完了再回来看，才会有帮助喔！ ^_^

目录及概述

10

鸟哥的 Linux 私房菜：基础学习篇 第四版
第零章 计算机概论
鸟哥在大专院校的教学经验中发现到，由于对 Linux 有兴趣的朋友很多可能并非信息相关专 业出身， 因此对于计算机硬件及计算机方面的概念不熟。然而操作系统这种咚咚跟硬 件.....2015/04/16
0.1 电脑：辅助人脑的好工具 0.1.1 计算机硬件的五大单元 0.1.2 一切设计的起点：CPU 的架构, RISC与ARM, CISC与x86 0.1.3 其他单元的设备 0.1.4 运行流程 0.1.5 电脑按用途分类 0.1.6 电脑上面常用的计算单位 （容量、速度等）
0.2 个人电脑架构与相关设备元件 0.2.1 执行脑袋运算与判断的 CPU：CPU的工作频率,32位与64位,CPU等级, 超线程 0.2.2 内存：多通道, DRAM与SRAM, ROM 0.2.3 显卡：PCIe 规格 0.2.4 硬盘与储存设备：物理组成,盘片与扇区,传输接口（SATA,SAS,USB..）,SSD, 购买与运行 0.2.5 扩展卡与接口 0.2.6 主板 0.2.7 电源供应器 0.2.8 选购须知
0.3 数据表示方式 0.3.1 数字系统 0.3.2 文字编码系统
0.4 软件程序运行 0.4.1 机器程序与编译程序 0.4.2 操作系统 0.4.3 应用程序
0.5 重点回顾 0.6 本章习题 0.7 参考资料与延伸阅读
第一章 Linux是什么/如何学习
众所皆知的，Linux的核心原型是1991年由托瓦兹（Linus Torvalds）写出来的，但是托瓦兹 为何可以写出Linux这个操作系统？ 为什么他要选择386的计算机来开发？为什么Linux的发展 可以这么迅速？又为什么Linux是免费的？.....2015/04/23
1.1 Linux是什么

目录及概述

11

鸟哥的 Linux 私房菜：基础学习篇 第四版
1.1.1 Linux是什么？操作系统/应用程序？ 1.1.2 Linux之前，Unix的历史 1.1.3 关于GNU计划、自由软件与开放源代码 1.2 Torvalds的Linux发展 1.2.1 与Minix之间 1.2.2 对386硬件的多任务测试 1.2.3 初次释出Linux 0.02 1.2.4 Linux的发展：虚拟团队的产生 1.2.5 Linux 的核心版本 1.2.6 Linux distributions 1.3 Linux当前应用的角色 1.3.1 企业环境的利用 1.3.2 个人环境的使用 1.3.3 云端运用 1.4 Linux 该如何学习 1.4.1 从头学习Linux基础 1.4.2 选择一本易读的工具书 1.4.3 实作再实作 1.4.4 发生问题怎么处理啊？建议流程是这样... 1.4.5 鸟哥的建议（重点在solution的学习） 1.5 重点回顾 1.6 本章习题 1.7 参考资料与延伸阅读
第二章 主机规划与磁盘分区
事实上，要安装好一部Linux主机并不是那么简单的事情，你必须要针对distributions的特性、 服务器的软件能力、 未来的升级需求、硬件扩充性需求等等来考虑，还得要知道磁盘分区、 文件系统.....2015/04/28
2.1 Linux与硬件的搭配 2.1.1 认识计算机的硬件配备 2.1.2 选择与Linux搭配的主机配备： 硬件支持相关网站 2.1.3 各硬件设备在Linux中的文件名 2.1.4 使用虚拟机学习
2.2 磁盘分区
2.2.1 磁盘连接的方式与设备文件名的关系 2.2.2 MSDOS（MBR） 与 GPT 磁盘分区表（partition table） 2.2.3 开机流程中的 BIOS 与 UEFI 开机检测程序 2.2.4 Linux安装模式下，磁盘分区的选择（极重要）

目录及概述

12

鸟哥的 Linux 私房菜：基础学习篇 第四版
2.3 安装Linux前的规划
2.3.1 选择适当的distribution 2.3.2 主机的服务规划与硬件的关系 2.3.3 主机硬盘的主要规划（partition） 2.3.4 鸟哥的两个实际案例 2.4 重点回顾 2.5 本章习题 2.6 参考资料与延伸阅读
第三章 安装CentOS 7.x与多重开机技巧
Linux distributions越作越成熟，所以在安装方面也越来越简单！虽然安装非常的简单， 但是 刚刚前一章所谈到的基础认知还是需要了解的，包括MBR, partition, boot loader, mount, software的.....2015/05/06
3.1 本练习机的规划--尤其是分区参数 3.2 开始安装CentOS 7
3.2.1 调整开机媒体（BIOS）与虚拟机创建流程 3.2.2 选择安装模式与开机：inst.gpt 参数 3.2.3 在地设置之时区、语系与键盘配置 3.2.4 安装来源设置与软件选择 3.2.5 磁盘分区与文件系统设置 3.2.6 核心管理与网络设置 3.2.7 开始安装、设置 root 密码与新增可切换身份之一般用户 3.2.8 准备使用系统前的授权同意 3.2.9 其他功能：RAM testing, 安装笔记本电脑的核心参数（Option） 3.3 多重开机安装流程与管理（Option） 3.3.1 安装 CentOS 7.x + windows 7 的规划 3.3.2 进阶安装 CentOS 7.x 与 Windows 7 3.3.3 救援 MBR 内的开机管理程序与设置多重开机菜单 3.4 重点回顾 3.5 本章习题 3.6 参考资料与延伸阅读
第四章 首次登陆与线上求助 man page
终于可以开始使用Linux这个有趣的系统了！由于Linux系统使用了非同步的磁盘/内存数据传 输模式， 同时又是个多用户多任务的环境，所以你不能随便的不正常关机，关机有一定的程 序喔！错误的关机方法.....2015/06/02
4.1 首次登陆系统

目录及概述

13

鸟哥的 Linux 私房菜：基础学习篇 第四版
4.1.1 首次登陆CentOS 7.x图形接口 4.1.2 GNOME的操作与登出,应用程序,文件资源管理器,中文输入法,登出窗口,快速重 启 X 4.1.3 X Window与文字模式的切换, startx 4.1.4 在终端接口登陆linux 4.2 文字模式下指令的下达 4.2.1 开始下达指令, 语系的支持 4.2.2 基础指令的操作, cal, bc 4.2.3 重要的几个热键[Tab], [ctrl]-c, [ctrl]-d, [shift]+[UP/DOWN] 4.2.4 错误讯息的查看 4.3 Linux系统的线上求助man page与info page 4.3.1 指令的 --help 求助说明 4.3.2 man page, mandb/makewhatis 4.3.3 info page 4.3.4 其他有用的文件（documents） 4.4 超简单文书编辑器： nano 4.5 正确的关机方法: sync, shutdown, reboot, halt, poweroff, systemctl
4.6 重点回顾
4.7 本章习题 4.8 参考资料与延伸阅读
第二部分 Linux 文件、目录与磁盘格式
安装完了 Linux 之后，接着下来自然就是要使用他了！我们在 开机与关机及简易指令操作 稍 微说明了指令下达的方法，以及指令线上查询的方式， 因此您可以轻易的使用命令行界面来 进行诸多的动作与工作。那么接着下来呢？当然就是想要知道 Linux 里面有什么东西啰，所 以，在这一个部分当中，我们将介绍 Linux 最基本的文件权限概念， 与每个文件目录所带有 的意涵。
当然啰，要了解权限的概念，那么对于不同的“身份”就需要了解一下才行， 不同的身份的 人，所创建的或拥有的文件是否会相同呢？例如系统管理员与一般身份使用者的文件？ 当然 不太一样！除此之外，如果您的硬盘空间不足，需要增加硬盘时，应该要如何新增呢？ 还 有，内存不足的情况下，有没有增进虚拟内存容量的方法？在接下来的几个章节之中，我们 将介绍 Linux 主要的文件架构、以及磁盘在 Linux 当中该如何使用及挂载等问题。
第五章 Linux文件权限与目录配置

目录及概述

14

鸟哥的 Linux 私房菜：基础学习篇 第四版
Linux最优秀的地方之一，就在于他的多用户多任务的环境。而为了让各个使用者具有较保密 的文件数据， 因此文件的权限管理就变的很重要了。 Linux一般将文件可存取的身份分为三 个类别，分别是 owner/group/other， 且三种身份各有read/write/execute.....2015/06/03
5.1 使用者与群组
5.2 Linux文件权限概念
5.2.1 Linux文件属性, 改变语系的 locale 5.2.2 如何改变文件属性与权限：chgrp, chown, chmod 5.2.3 目录与文件之权限意义：, 数据夹与抽屉,各项动作所需最小权限 5.2.4 Linux文件种类与扩展名 5.3 Linux目录配置 5.3.1 Linux目录配置的依据--FHS：/, /usr, /var 5.3.2 目录树（directory tree） 5.3.3 绝对路径与相对路径 5.3.4 CentOS 的观察：lsb_release 5.4 重点回顾 5.5 本章练习 5.6 参考资料与延伸阅读
第六章 Linux文件与目录管理
在第五章我们认识了Linux系统下的文件权限概念以及目录的配置说明。 在这个章节当中， 我们就直接来进一步的操作与管理文件与目录吧！包括在不同的目录间变换、 创建与删除目 录、创建与删除文件， 还有寻找文件、查阅文件内容.....2015/06/16
6.1 目录与路径 6.1.1 相对路径与绝对路径 6.1.2 目录的相关操作： cd, pwd, mkdir, rmdir 6.1.3 关于可执行文件路径的变量： $PATH
6.2 文件与目录管理 6.2.1 文件与目录的检视： ls 6.2.2 复制、删除与移动： cp, mv 6.2.3 取得路径的文件名称与目录名称
6.3 文件内容查阅 6.3.1 直接检视文件内容： cat, tac, nl 6.3.2 可翻页检视： more, less 6.3.3 数据撷取： head, tail 6.3.4 非纯文本文件： od 6.3.5 修改文件时间与创建新文件： touch
6.4 文件与目录的默认权限与隐藏权限

目录及概述

15

鸟哥的 Linux 私房菜：基础学习篇 第四版

6.4.1 文件默认权限：umask 6.4.2 文件隐藏属性：chattr, lsattr
6.4.3 文件特殊权限：SUID, SGID,SBIT, 权限设置
6.4.4 观察文件类型：file
6.5 指令与文件的搜寻
6.5.1 指令文件名的搜寻：which 6.5.2 文件文件名的搜寻：whereis,locate / updatedb, find 6.6 极重要的复习！权限与指令间的关系 6.7 重点回顾 6.8 本章习题 6.9 参考资料与延伸阅读
第七章 Linux 磁盘与文件系统管理
系统管理员很重要的任务之一就是管理好自己的磁盘文件系统，每个分区不可太大也不能太 小，太大会造成磁盘容量的浪费， 太小则会产生文件无法储存的困扰。此外，我们在前面几 章谈到的文件权限与属性中， 这些权限与属性分别记录在.....2015/06/26
7.1 认识 Linux 文件系统 7.1.1 磁盘组成与分区的复习 7.1.2 文件系统特性： 索引式文件系统 7.1.3 Linux 的 EXT2 文件系统（inode）: data block, superblock,dumpe2fs 7.1.4 与目录树的关系 7.1.5 EXT2/EXT3 文件的存取与日志式文件系统的功能 7.1.6 Linux 文件系统的运行 7.1.7 挂载点的意义 （mount point） 7.1.8 其他 Linux 支持的文件系统与 VFS 7.1.9 XFS 文件系统简介： xfs_info
7.2 文件系统的简单操作 7.2.1 磁盘与目录的容量：df, du 7.2.2 实体链接与符号链接：ln
7.3 磁盘的分区、格式化、检验与挂载 7.3.1 观察磁盘分区状态：, parted 7.3.2 磁盘分区 gdisk/fdisk：gdisk, fdisk 7.3.3 磁盘格式化（创建文件系统）：mkfs.xfs, mkfs.xfs for raid,mkfs.ext4, mkfs 7.3.4 文件系统检验：xfs_repair, fsck.ext4 7.3.5 文件系统挂载与卸载： mount, umount 7.3.6 磁盘/文件系统参数修订： mknod, xfs_admin, tune2fs
7.4 设置开机挂载

目录及概述

16

鸟哥的 Linux 私房菜：基础学习篇 第四版
7.4.1 开机挂载 /etc/fstab 及 /etc/mtab 7.4.2 特殊设备 loop 挂载（镜像文件不烧录就挂载使用）： 挂载DVD,大型文件, dd 7.5 内存交换空间（swap）之创建 7.5.1 使用实体分区创建swap：mkswap, free, swapon, swapoff 7.5.2 使用文件创建swap 7.6 文件系统的特殊观察与操作 7.6.1 磁盘空间之浪费问题 7.6.2 利用 GNU 的 parted 进行分区行为 （Optional） 7.7 重点回顾 7.8 本章习题 - 第一题一定要做 7.9 参考资料与延伸阅读
第八章 文件的压缩与打包
在 Linux 下面有相当多的压缩指令可以运行喔！这些压缩指令可以让我们更方便从网络上面 下载大型的文件呢！ 此外，我们知道在 Linux 下面的扩展名是没有什么很特殊的意义的，不 过，针对这些压缩指令所做出来的压缩文件， 为了方便记忆.....2015/07/16
8.1 压缩文件的用途与技术 8.2 Linux 系统常见的压缩指令
8.2.1 gzip, zcat/zmore/zless/zgrep 8.2.2 bzip2, bzcat/bzmore/bzless/bzgrep 8.2.3 xz, xzcat/xzmore/xzless/xzgrep 8.3 打包指令:tar, 解压后的 SELinux 课题 8.4 XFS 文件系统的备份与还原 8.4.1 XFS 文件系统备份 xfsdump 8.4.2 XFS 文件系统还原 xfsrestore 8.5 光盘写入工具
8.5.1 mkisofs：创建镜像文件： isoinfo 8.5.2 cdrecord：光盘烧录工具 8.6 其他常见的压缩与备份工具 8.6.1 dd 8.6.2 cpio 8.7 重点回顾 8.8 本章习题 8.9 参考资料与延伸阅读
第三部分：学习 Shell 与 Shell scripts

目录及概述

17

鸟哥的 Linux 私房菜：基础学习篇 第四版

了解了基本的 Linux 文件属性与目录的配置之后，在进入更深入的 Linux 世界之前，有几个课 题还是一定要知道的，那就是我们所使用的这个文字模式接口，也就是所谓的“Shell”这个咚 咚。在 Linux 的世界中，使用的是 GNU 发展出来的强化的第二代 shell ，称为 BASH Shell ，他有什么特异功能呢？简单的说，我们之前下达的几个指令都是 bash 管理的，除此之外， 他还可以记录指令、文件或命令的补全功能、环境变量的使用等等，还有很多功能等着你去 发掘呢！
在知道了部分的 bash 功能后，在接着下来，我们还得了解一下什么是数据流重导向？还有常 规表达式等等的问题， 这都是未来我们系统管理员在管理主机上面，一个不可缺乏的利器！ 当然啰，要将这些功能整合起来运用的话， 就不能不学习一下所谓的脚本“ shell scripts ”，他 具有基础的程序能力（ Program ），当真是个管理系统的好帮手呢！
再来，在未来的建站设置当中，常会使用到文字编辑器来编辑参数配置文件，这个时候， 系 统管理员至少务必要熟悉一套命令行下的文书编辑软件，当然不限制哪一套软件啦，但是 vi 是最标准的 Unix-Like 的命令行之文书处理软件，所以，我们几乎一定可以在每部 Unix-Like 上面发现他的踪迹，所以，就来了解他一下吧，这也是挺重要的工作呢！
第九章 vim程序编辑器
系统管理员的重要工作就是得要修改与设置某些重要软件的配置文件， 因此至少得要学会一 种以上的命令行的文书编辑器。 在所有版本的 Linux 上头都会有的一套文书编辑器就是 vi ， 而且很多软件.....2015/07/07
9.1 vi 与 vim 9.1.1 为何要学 vim
9.2 vi 的使用 9.2.1 简易执行范例 9.2.2 按键说明 9.2.3 一个案例的练习 9.2.4 vim 的暂存盘、救援回复与打开时的警告讯息
9.3 vim 的额外功能 9.3.1 区块选择（Visual Block） 9.3.2 多文件编辑 9.3.3 多窗口功能 9.3.4 vim 的挑字补全功能 9.3.5 vim 环境设置与记录： ~/.vimrc, ~/.viminfo 9.3.6 vim 常用指令示意图
9.4 其他 vim 使用注意事项 9.4.1 中文编码的问题 9.4.2 DOS 与 Linux 的断行字符： dos2unix,unix2dos 9.4.3 语系编码转换： iconv
9.5 重点回顾

目录及概述

18

鸟哥的 Linux 私房菜：基础学习篇 第四版
9.6 本章习题 9.7 参考资料与延伸阅读
第十章 认识与学习 BASH
在 Linux 的环境下，如果你不懂 bash 是什么，那么其他的东西就不用学了！ 因为前面几章 我们使用终端机下达指令的方式， 就是通过 bash 的环境来处理的喔！ 所以说，他很重要 吧！bash 的东西非常的多，包括变量.....2015/07/09
10.1 认识 BASH 这个 Shell 10.1.1 硬件、核心与 Shell 10.1.2 为何要学命令行的 shell 10.1.3 系统的合法 shell 与 /etc/shells 功能 10.1.4 Bash shell 的功能 10.1.5 查询指令是否为 Bash shell 的内置命令： type 10.1.6 指令的下达与快速编辑按钮
10.2 Shell 的变量功能 10.2.1 什么是变量？ 10.2.2 变量的取用与设置：echo, 变量设置规则, unset 10.2.3 环境变量的功能：env 与常见环境变量说明, set, export 10.2.4 影响显示结果的语系变量 （locale） 10.2.5 变量的有效范围 10.2.6 变量键盘读取、阵列与宣告： read, declare, array 10.2.7 与文件系统及程序的限制关系： ulimit 10.2.8 变量内容的删除、取代与替换 （Optional）：删除与取代,测试与替换
10.3 命令别名与历史命令 10.3.1 命令别名设置： alias, unalias 10.3.2 历史命令： history, HISTSIZE
10.4 Bash shell 的操作环境 10.4.1 路径与指令搜寻顺序 10.4.2 bash 的进站与欢迎讯息： /etc/issue, /etc/motd 10.4.3 环境配置文件:login, non-login shell, /etc/profile, ~/.bash_profile, source, ~/.bashrc 10.4.4 终端机的环境设置： stty, set 10.4.5 万用字符与特殊符号
10.5 数据流重导向 （Redirection） 10.5.1 何谓数据流重导向？ 10.5.2 命令执行的判断依据： ; , &&, ||
10.6 管线命令 （pipe） 10.6.1 撷取命令：cut, grep 10.6.2 排序命令：sort, uniq, wc

目录及概述

19

鸟哥的 Linux 私房菜：基础学习篇 第四版
10.6.3 双向重导向：tee 10.6.4 字符转换命令：tr, col, join, expand 10.6.5 分区命令： split 10.6.6 参数代换： xargs 10.6.7 关于减号 - 的用途 10.7 重点回顾 10.8 本章习题 10.9 参考资料与延伸阅读
第十一章 正则表达式与文件格式化处理
正则表达式 （Regular Expression, RE, 或称为常规表达式）是通过一些特殊字符的排列， 用 以“搜寻/取代/删除”一列或多列文字字串， 简单的说， 正则表达式就是用在字串的处理上面的 一项“表示式”。正则表达式并.....2015/07/14
11.1 开始之前：什么是正则表达式 11.2 基础正则表达式
11.2.1 语系对正则表达式的影响 11.2.2 grep 的一些进阶选项 11.2.3 基础正则表达式练习 11.2.4 基础正则表达式字符汇整（characters） 11.2.5 sed 工具：行的新增/删除, 行的取代/显示,搜寻并取代, 直接改档 11.3 延伸正则表达式 11.4 文件的格式化与相关处理 11.4.1 printf： 格式化打印 11.4.2 awk：好用的数据处理工具 11.4.3 文件比对工具：, cmp, patch 11.4.4 文件打印准备工具： pr 11.5 重点回顾 11.6 本章习题 11.7 参考资料与延伸阅读
第十二章 学习 shell scripts
如果你真的很想要走信息这条路，并且想要好好的管理好属于你的主机，那么，别说鸟哥不 告诉你， 可以自动管理你的系统的好工具： Shell scripts 真的是得要好好学习学习的！ 基本 上， shell script 有点像是早期的批处理文件，亦即是.....2015/07/17
12.1 什么是 Shell Script 12.1.1 干嘛学习 shell scripts 12.1.2 第一支 script 的撰写与执行

目录及概述

20

鸟哥的 Linux 私房菜：基础学习篇 第四版
12.1.3 撰写 shell script 的良好习惯创建 12.2 简单的 shell script 练习
12.2.1 简单范例： 对谈式脚本, 随日期变化, 计算 pi 12.2.2 script 的执行方式差异 （source, sh script, ./script） 12.3 善用判断式 12.3.1 利用 test 指令的测试功能 12.3.2 利用判断符号 [ ] 12.3.3 Shell script 的默认变量（$0, $1...）： shift 12.4 条件判断式 12.4.1 利用 if .... then： 单层简单条件,多重复杂条件, 网络状态,退伍 12.4.2 利用 case ..... esac 判断 12.4.3 利用 function 功能 12.5 循环 （loop） 12.5.1 while...do...done, until...do...done （不定循环） 12.5.2 for...do...done （固定循环）： 帐号检查,网络状态 $（seq ） 12.5.3 for...do...done 的数值处理 12.5.4 搭配乱数与阵列的实验 12.6 shell script 的追踪与 debug 12.7 重点回顾 12.8 本章习题
第四部分：Linux 使用者管理
好了！终于要到了管理 Linux 帐号的时刻了！对于 Linux 有一定的熟悉度之后，再来就是要管 理连上 Linux 的帐号问题了！这个帐号的问题可大可小啦！大到可以限制他使用 Linux 主机的 各项资源，小到甚至一般帐号的密码订定规则都可以进行规定！端看您对于安全的需求啦！ 此外，如果站在资源平均分配的角度上，那么 Linux 主机上面有限的资源当然是平均分配给 大家比较好！这个时候就得来规定一下“谁可以使用多少的硬盘空间？”那就是 Quota 喔！呵 呵！厉害吧！
在订定完了一些帐号的规则之后，那么我们就继续来管理一下主机的系统与程序的管理吧！ 这个包括了观察每个程序 （Process） 与工作调度及工作管理 （ jobs control ），这些也都 是很重要的工作呢！
第十三章 Linux 帐号管理与 ACL 权限控制
要登陆 Linux 系统一定要有帐号与密码才行，否则怎么登陆，您说是吧？不过， 不同的使用 者应该要拥有不同的权限才行吧？我们还可以通过 user/group 的特殊权限设置，来规范出不 同的群组开发专案呢.....2015/07/22
13.1 Linux 的帐号与群组

目录及概述

21

鸟哥的 Linux 私房菜：基础学习篇 第四版
13.1.1 使用者识别码： UID 与 GID 13.1.2 使用者帐号：/etc/passwd 文件结构, /etc/shadow 文件结构 13.1.3 关于群组： /etc/group 文件结构,有效与初始群组, groups, newgrp, /etc/gshadow 13.2 帐号管理 13.2.1 新增与移除使用者： useradd, useradd 参考档, passwd, chage, userdel 13.2.2 使用者功能：id, finger,chfn, chsh 13.2.3 新增与移除群组：groupadd, groupmod, groupdel,gpasswd 群组管理员 13.2.4 帐号管理实例 13.2.5 使用外部身份认证系统 13.3 主机的细部权限规划：ACL 的使用 13.3.1 什么是 ACL 与如何支持启动 ACL 13.3.2 ACL 的设置技巧：setfacl, getfacl,ACL 的设置（user, group mask, default） 13.4 使用者身份切换 13.4.1 su 13.4.2 sudo： sudo 指令, visudo （/etc/sudoers）（帐号, 限制指令, 别名, 配合 su） 13.5 使用者的特殊 shell 与 PAM 模块 13.5.1 特殊的 shell :/sbin/nologin, nologin.txt 13.5.2 PAM 模块简介 13.5.3 PAM 模块设置语法：验证类别（type）、控制标准（flag）、模块与参数 13.5.4 常用模块简介： securetty,nologin, pam_pwquality,login流程 13.5.5 其他相关文件： limits.conf 13.6 Linux 主机上的使用者讯息传递 13.6.1 查询使用者： w, who, last, lastlog 13.6.2 使用者对谈： write, mesg, wall 13.6.3 使用者邮件信箱： mail 13.7 CentOS 7 环境下大量创建帐号的方法 13.7.1 一些帐号相关的检查工具：pwck, pwconv, chpasswd 13.7.2 大量创建帐号范本（适用 passwd --stdin 选项） 13.8 重点回顾 13.9 本章习题 13.10 参考资料与延伸阅读
第十四章 磁盘配额（Quota）与进阶文件系统管理
如果您的 Linux 服务器有多个用户经常存取数据时，为了维护所有使用者在硬盘容量的公平 使用，磁盘配额 （Quota） 就是一项非常有用的工具！另外，如果你的用户常常抱怨磁盘容 量不够用，那么更进阶的文件系统就得要学习学习.....2015/07/28
14.1 磁盘配额 （Quota） 的应用与实作

目录及概述

22

鸟哥的 Linux 私房菜：基础学习篇 第四版
14.1.1 什么是 Quota：一般用途, 限制, 规范 （inode/block, soft/hard, grace time） 14.1.2 一个 XFS 文件系统的 Quota 的实作范例 14.1.3 实作 Quota 流程-1：文件系统的支持与观察（/etc/fstab, /etc/mtab） 14.1.4 实作 Quota 流程-2：观察 Quota 报告数据（xfs_quota,print, df, report, state） 14.1.5 实作 Quota 流程-3：限制值设置方式 （limit, grace_time） 14.1.6 实作 Quota 流程-4：project 的限制 （针对目录限制） （Optional） 14.1.7 XFS quota 的管理与额外指令对照表 14.1.8 不更动既有系统的 Quota 实例 14.2 软件磁盘阵列 （Software RAID） 14.2.1 什么是 RAID： RAID-0, RAID-1,RAID1+0, Spare disk 14.2.2 software, hardware RAID 14.2.3 软件磁盘阵列的设置： mdadm --create 14.2.4 仿真 RAID 错误的救援模式： mdadm --manage 14.2.5 开机自动启动 RAID 并自动挂载 14.2.6 关闭软件 RAID（重要！） 14.3 逻辑卷轴管理员 （Logical Volume Manager） 14.3.1 什么是 LVM： PV, PE, VG, LV 的意义 14.3.2 LVM 实作流程： PV 阶段, VG 阶段,LV 阶段, 文件系统阶段 14.3.3 放大 LV 容量： xfs_growfs 14.3.4 使用 LVM thin Volume 让 LVM 动态自动调整磁盘使用率 14.3.5 LVM 的磁盘快照： 创建传统快照, 以快照还原,用于测试环境 14.3.6 LVM 相关指令汇整与 LVM 的关闭 14.4 重点回顾 14.5 本章习题 14.6 参考资料与延伸阅读
第十五章 例行性工作调度 （crontab）
学习了基础篇也一阵子了，你会发现到为什么系统常常会主动的进行一些任务？ 这些任务到 底是谁在设置工作的？ 如果你想要让自己设计的备份程序可以自动的在系统下面执 行，.....2015/07/31
15.1 什么是例行性工作调度 15.1.1 Linux 工作调度的种类： at, crontab 15.1.2 CentOS Linux 系统上常见的例行性工作
15.2 仅执行一次的工作调度 15.2.1 atd 的启动与 at 运行的方式： /etc/at.deny 15.2.2 实际运行单一工作调度： at,atq & atrm, batch
15.3 循环执行的例行性工作调度 15.3.1 使用者的设置： /etc/cron.deny, crontab

目录及概述

23

鸟哥的 Linux 私房菜：基础学习篇 第四版
15.3.2 系统的配置文件： /etc/crontab, /etc/cron.d/* 15.3.3 一些注意事项 15.4 可唤醒停机期间的工作任务 15.4.1 什么是 anacron 15.4.2 anacron 与 /etc/anacrontab 15.5 重点回顾 15.6 本章习题
第十六章 程序管理与 SELinux 初探
一个程序被载入到内存当中运行，那么在内存内的那个数据就被称为程序（process）。程序 是操作系统上非常重要的概念， 所有系统上面跑的数据都会以程序的型态存在。那么系统的 程序有哪些状态.....2015/08/08
16.1 什么是程序 （Process） 16.1.1 程序与程序 （process & program）：子程序与父程序, fork-and-exec,系统服 务 16.1.2 Linux 的多用户多任务环境
16.2 工作管理 （job control） 16.2.1 什么是工作管理 16.2.2 job control 的管理：&, [ctrl]-z, jobs, kill 16.2.3 离线管理问题： nohup
16.3 程序管理 16.3.1 程序的观察： ps -l,ps aux, top,pstree 16.3.2 程序的管理： signal, kill, killall 16.3.3 关于程序的执行顺序： priority, nice, renice 16.3.4 系统资源的观察： free, uname, uptime, netstat, vmstat
16.4 特殊文件与程序 16.4.1 具有 SUID/SGID 权限的指令执行状态 16.4.2 /proc/* 代表的意义 16.4.3 查询已打开文件或已执行程序打开之文件： fuser, lsof, pidof
16.5 SELinux 初探 16.5.1 什么是 SELinux： 目标, DAC,MAC 16.5.2 SELinux 的运行模式： 元件, 安全性本文,domain/type 16.5.3 SELinux 三种模式的启动、关闭与观察： getenforce,sestatus, setenforce 16.5.4 SELinux 政策内的规则管理： getsebool, seinfo, sesearch, setsebool 16.5.5 SELinux 安全本文的修改：chcon, restorecon,semanage 16.5.6 一个网络服务案例及登录文件协助：所需服务, FTP 实例, 匿名者范例, 一般用 户主文件夹, 非正规目录, 非正规 port
16.6 重点回顾 16.7 本章习题

目录及概述

24

鸟哥的 Linux 私房菜：基础学习篇 第四版
16.8 参考资料与延伸阅读
第五部分：Linux 系统管理员
嗯！终于来到系统管理员 （ root ） 要注意的工作事项之篇幅了！各位准系统管理员心理准备 好了吗？ 我们要管理机器啰，呵呵！那么管理员的工作是什么？看报喝茶？！没错！管理员 最大的享受就是看报喝茶了。 一个好的系统管理员，平时不会希望挂载网站上面一再不断的 查询、检查漏洞等等的， 因为果真如此的话，那么就表示“机器一定有问题了！”。为了让我 们的 Linux 机器跑得更稳更顺畅，好让我这个管理员有更多的时间去看报喝茶，哈哈！ 更深 入的了解系统是需要的！所以，这一篇我们由开机关机的整体流程谈起，好了解一下 Linux 在开机的过程中到底做了哪些事情，这样才能知道我们在什么时候应该做什么事情呐！
此外，由于“没有一个套件是永远安全的！”，所以套件管理是相当重要的一部份，这里我们以 RPM 与 Tarball 来介绍一下如何管理你系统上面的套件。再来，你知道你的系统上面跑了多 少数据吗？ 虽然知道什么是 ps 来查询程序，但是总是得知道我的系统有哪些服务吧！嘿嘿！ 来看看先?不但如此，还得针对登录文件进行解析，以及对于系统进行备份。呵呵！ 管理员的 工作还真多那。不止不止，还要进行核心的管理呢！哇！果然是忙毙了！无论如何， 还是得 要了解呐！
第十七章 认识系统服务（daemon）
在 Unix-Like 的系统中，你常常听到 daemon 这个字眼！那么什么是传说中的 daemon 呢？ 这些 daemon 放在什么地方？他的功能是什么？该如何启动这些 daemon ？又如何有效的将 这些 daemon 管理妥当.....2015/08/14
17.1 什么是 daemon 与服务 （service） 17.1.1 早期 Systemp V 的 init 管理行为中 daemon 的主要分类 17.1.2 systemd 使用的 unit 分类
17.2 通过 systemctl 管理服务 17.2.1 通过 systemctl 管理单一服务 （service unit） 的启动/开机启动与观察状态 17.2.2 通过 systemctl 观察系统上所有的服务 17.2.3 通过 systemctl 管理不同的操作环境 （target unit） 17.2.4 通过 systemctl 分析各服务之间的相依性 17.2.5 与 systemd 的 daemon 运行过程相关的目录简介：/etc/services 17.2.6 关闭网络服务
17.3 systemctl 针对 service 类型的配置文件 17.3.1 systemctl 配置文件相关目录简介 17.3.2 systemctl 配置文件的设置项目简介 17.3.3 两个 vsftpd 运行的实例 17.3.4 多重的重复设置方式：以 getty 为例 17.3.5 自己的服务自己作

目录及概述

25

鸟哥的 Linux 私房菜：基础学习篇 第四版
17.4 systemctl 针对 timer 的配置文件
17.5 CentOS 7.x 默认启动的服务简易说明
17.6 重点回顾 17.7 本章习题 17.8 参考资料与延伸阅读
第十八章 认识与分析登录文件
当你的 Linux 系统出现不明原因的问题时，很多人都告诉你，你要查阅一下登录文件才能够 知道系统出了什么问题了， 所以说，了解登录文件是很重要的事情呢。登录文件可以记录系 统在什么时间、哪个主机、哪个服务.....2015/08/20
18.1 什么是登录文件： 18.1.1 CentOS 7 登录文件简易说明：重要性, 常见文件名,服务与程序,systemdjournald 18.1.2 登录文件内容的一般格式
18.2 rsyslog.service ：记录登录文件的服务 18.2.1 rsyslog.service 的配置文件： /etc/rsyslog.conf, 默认的 rsyslog.conf 内容 18.2.2 登录文件的安全性设置 18.2.3 登录文件服务器的设置
18.3 登录文件的轮替 （logrotate） 18.3.1 logrotate 的配置文件 18.3.2 实际测试 logrotate 的动作 18.3.3 自订登录文件的轮替功能
18.4 systemd-journald.service 简介： 18.4.1 使用 journalctl 观察登录信息 18.4.2 logger 指令的应用 18.4.3 保存 journal 的方式
18.5 分析登录文件 18.5.1 CentOS 默认提供的 logwatch 18.5.2 鸟哥自己写的登录文件分析工具：
18.6 重点回顾 18.7 本章习题练习 18.8 参考资料与延伸阅读
第十九章 开机流程、模块管理与 loader
系统开机其实是一项非常复杂的程序，因为核心得要侦测硬件并载入适当的驱动程序后， 接 下来则必须要调用程序来准备好系统运行的环境，以让使用者能够顺利的操作整部主机系 统。 如果你能够理解开机的原理.....2015/08/31

目录及概述

26

鸟哥的 Linux 私房菜：基础学习篇 第四版
19.1 Linux 的开机流程分析 19.1.1 开机流程一览 19.1.2 BIOS, boot loader 与 kernel 载入：lsinitrd 19.1.3 第一支程序 systemd 及使用 default.target 进入开机程序分析 19.1.4 systemd 执行 sysinit.target 初始化系统、basic.target 准备系统 19.1.5 systemd 启动 multi-user.target 下的服务：相容的 rc.local,getty.target 启动 19.1.6 systemd 启动 graphical.target 下面的服务 19.1.7 开机过程会用到的主要配置文件
19.2 核心与核心模块 19.2.1 核心模块与相依性： depmod 19.2.2 核心模块的观察： lsmod, modinfo 19.2.3 核心模块的载入与移除：insmod, modprobe, rmmod 19.2.4 核心模块的额外参数设置：/etc/modprobe.d/*conf
19.3 Boot loader: Grub2 19.3.1 boot loader 的两个 stage 19.3.2 grub2 的配置文件 /boot/grub2/grub.cfg 初探： 磁盘代号, grub.cfg 19.3.3 grub2 配置文件维护 /etc/default/grub 与 /etc/grub.d：grub,40_custom 19.3.4 initramfs 的重要性与创建新 initramfs 文件： dracut/mkinitrd 19.3.5 测试与安装 grub2： grub2-install 19.3.6 开机前的额外功能修改 19.3.7 关于开机画面与终端机画面的图形显示方式 19.3.8 为个别菜单加上密码： grub2-mkpasswd-pbkdf2
19.4 开机过程的问题解决 19.4.1 忘记 root 密码的解决之道 19.4.2 直接开机就以 root 执行 bash 的方法 19.4.3 因文件系统错误而无法开机
19.5 重点回顾 19.6 本章习题 19.7 参考资料与延伸阅读
第二十章 网络设置与备份策略
新的 CentOS 7 有针对不同的服务提供了相当大量的命令行设置模式，因此过去那个 setup 似乎没有什么用了！ 取而代之的是许多加入了 bash-complete 提供了不少参数补全的设置工 具！甚至包括网络设置也是通过这个机制哩！ 我们这个小章.....2015/09/03
20.1 系统基本设置 20.1.1 网络设置 （手动设置与DHCP自动取得）：手动,自动,改主机名称 20.1.2 日期与时间设置 20.1.3 语系设置 20.1.4 防火墙简易设置

目录及概述

27

鸟哥的 Linux 私房菜：基础学习篇 第四版
20.2 服务器硬件数据的收集 20.2.1 以系统内置 dmidecode 解析硬件配备 20.2.2 硬件资源的收集与分析： lspci, lsusb,iostat... 20.2.3 了解磁盘的健康状态
20.3 备份要点 20.3.1 备份数据的考虑 20.3.2 哪些 Linux 数据具有备份的意义 20.3.3 备份用储存媒体的选择
20.4 备份的种类、频率与工具的选择 20.4.1 完整备份之累积备份 （Incremental backup）,使用软件 20.4.2 完整备份之差异备份 （Differential backup） 20.4.3 关键数据备份
20.5 VBird 的备份策略与 scripts 20.5.1 每周系统备份的 script 20.5.2 每日备份数据的 script 20.5.3 远端备援的 script
20.6 灾难复原的考虑 20.7 重点回顾 20.8 本章习题 20.9 参考资料与延伸阅读
第二十一章 软件安装：源代码与 Tarball
我们在第一章、Linux是什么当中提到了 GNU 计划与 GPL 授权所产生的自由软件与开放源码 等咚咚。 不过，前面的章节都还没有提到真正的开放源码是什么的讯息！在这一章当中，我 们将借由 Linux 操作系统里面的可执行文件.....2015/09/06
21.1 开放源码的软件安装与升级简介 21.1.1 什么是开放源码、编译器与可可执行文件 21.1.2 什么是函数库 21.1.3 什么是 make 与 configure 21.1.4 什么是 Tarball 的软件 21.1.5 如何安装与升级软件
21.2 使用传统程序语言进行编译的简单范例 21.2.1 单一程序：印出 Hello World 21.2.2 主、副程序链接：副程序的编译 21.2.3 调用外部函数库：加入链接的函数库 21.2.4 gcc 的简易用法 （编译、参数与链结）
21.3 用 make 进行宏编译 21.3.1 为什么要用 make 21.3.2 makefile 的基本语法与变量

目录及概述

28

鸟哥的 Linux 私房菜：基础学习篇 第四版
21.4 Tarball 的管理与建议 21.4.1 使用源代码管理软件所需要的基础软件 21.4.2 Tarball 安装的基本步骤 21.4.3 一般 Tarball 软件安装的建议事项 （如何移除？升级？） 21.4.4 一个简单的范例、利用 ntp 来示范 21.4.5 利用 patch 更新源代码
21.5 函数库管理 21.5.1 动态与静态函数库 21.5.2 ldconfig 与 /etc/ld.so.conf 21.5.3 程序的动态函数库解析： ldd
21.6 检验软件的正确性 21.6.1 md5sum / sha1sum / sha256sum
21.7 重点回顾 21.8 课后练习 21.9 参考资料与延伸阅读
第二十二章 软件安装：RPM, SRPM 与 YUM 功能
虽然使用源代码进行编译可以进行客制化的设置，但对于 Linux distribution 的原本发布商来 说， 则有软件管理不易的问题， 毕竟不是每个人都会进行源代码编译的。 如果能够将软件预 先在相同的硬件与操作系统上面编译好才发布的话.....2015/09/09
22.1 软件管理员简介 22.1.1 Linux 界的两大主流: RPM 与 DPKG 22.1.2 什么是 RPM 与 SRPM 22.1.3 什么是 i386, i586, i686, noarch, x86_64 22.1.4 RPM 的优点 22.1.5 RPM 属性相依的克服方式： YUM 线上升级
22.2 RPM 软件管理程序： rpm 22.2.1 RPM 默认安装的路径 22.2.2 RPM 安装 （install） 22.2.3 RPM 升级与更新 （upgrade/freshen） 22.2.4 RPM 查询 （query） 22.2.5 RPM 验证与数码签章 （Verify/signature） 22.2.6 RPM 反安装与重建数据库 （erase/rebuilddb）
22.3 YUM 线上升级机制 22.3.1 利用 yum 进行查询、安装、升级与移除功能 22.3.2 yum 的配置文件 22.3.3 yum 的软件群组功能 22.3.4 EPEL/ELRepo 外挂软件以及自订配置文件 22.3.5 全系统自动升级

目录及概述

29

鸟哥的 Linux 私房菜：基础学习篇 第四版
22.3.6 管理的抉择：RPM 还是 Tarball 22.3.7 基础服务管理：以 Apache 为例 22.4 SRPM 的使用： rpmbuild （Optional） 22.4.1 利用默认值安装 SRPM 文件 （--rebuid/--recompile） 22.4.2 SRPM 使用的路径与需要的软件 22.4.3 配置文件的主要内容 （*.spec） 22.4.4 SRPM 的编译指令 （-ba/-bb） 22.4.5 一个打包自己软件的范例 22.5 重点回顾 22.6 本章习题 22.7 参考资料与延伸阅读
第二十三章 X Window 设置介绍
在 Linux 上头的图形接口我们称之为 X Window System，简称为 X 或 X11 啰！为何称之为系 统呢？这是因为 X 窗口系统又分为 X server 与 X client ，既然是 Server/Client （主从架构） 这就表示其实 X 窗口系统是可以跨网络且跨平台的.....2015/09/19
23.1 什么是 X Window System 23.1.1 X Window 的发展简史 23.1.2 主要元件： X Server/X Client/Window Manager/Display Manager 23.1.3 X Window 的启动流程：startx, xinit 23.1.4 X 启动流程测试 23.1.5 我是否需要启用 X Window System
23.2 X Server 配置文件解析与设置 23.2.1 解析 xorg.conf 设置 23.2.2 字体管理 23.2.3 显示器参数微调
23.3 显卡驱动程序安装范例 23.3.1 NVidia 23.3.2 AMD （ATI） 23.3.3 Intel
23.4 重点回顾 23.5 本章习题 23.6 参考资料与延伸阅读
第二十四章 核心编译
我们说的 Linux 其实指的就是核心 （kernel） 而已。这个核心控制你主机的所有硬件并提供 系统所有的功能， 所以说，他重不重要啊！我们开机的时候其实就是利用开机管理程序载入 这个核心文件来侦测硬件， 在核心载入适当的驱动程序后.....2015/10/20

目录及概述

30

鸟哥的 Linux 私房菜：基础学习篇 第四版
24.1 编译前的任务：认识核心与取得核心源代码 24.1.1 什么是核心 （Kernel） 24.1.2 更新核心的目的 24.1.3 核心的版本 24.1.4 核心源代码的取得方式：distributions 默认、最新、patch 21.1.5 核心源代码的解压缩/安装/观察
24.2 核心编译的前处理与核心功能选择 24.2.1 硬件环境检视与核心功能要求 24.2.2 保持干净源代码： make mrproper 24.2.3 开始挑选核心功能： make XXconfig 24.2.4 核心功能细项选择 1. 一般设置（General setup）：附加版本名称、IPC 通讯、程序相关等 2. 核心模块与 block layer 支持 3. CPU 的类型与功能选择（含虚拟化技术） 4. 电源管理功能 5. 核心的网络功能 6. 各项设备的驱动程序 7. 文件系统的支持 8. 虚拟化与函数库
24.3 核心的编译与安装 24.3.1 编译核心与核心模块 24.3.2 实际安装模块 24.3.3 开始安装新核心与多重核心菜单 （grub）
24.4 额外（单一）核心模块编译 24.4.1 编译前注意事项 24.4.2 单一模块编译 24.4.3 核心模块管理
24.5 以最新核心版本编译 CentOS 7.x 的核心 24.6 重点回顾 24.7 本章习题 24.8 参考资料与延伸阅读

目录及概述

31

鸟哥的 Linux 私房菜：基础学习篇 第四版
第零章、计算机概论
最近更新日期：20// 由过去的经验当中，鸟哥发现到因为兴趣或生活所逼而必须要接触 Linux 的朋友，很多可能 并非信息相关专业出身， 因此对于电脑软/硬件方面的概念不熟。然而操作系统这种咚咚跟硬 件有相当程度的关连性， 所以，如果不了解一下计算机概论，要很快的了解 Linux 的概念是 有点难度的。因此，鸟哥就自作聪明的新增一个小章节来谈谈计概啰！ 因为鸟哥也不是信息 相关学科出身，所以，写的不好的地方请大家多多指教啊！^_^

第零章、计算机概论

32

鸟哥的 Linux 私房菜：基础学习篇 第四版
0.1 电脑：辅助人脑的好工具
现在的人们几乎无时无刻都会碰电脑！不管是桌面电脑（台式机）、笔记本电脑（笔记 本）、平板电脑、智能手机等等，这些东西都算是电脑。 虽然接触的这么多，但是，你了解 电脑里面的元件有什么吗？以台式机来说，电脑的机箱里面含有什么元件？不同的电脑可以 应用在哪些工作？ 你生活周遭有哪些电器用品内部是含有电脑相关元件的？下面我们就来谈 一谈这些东西呢！ 所谓的电脑就是一种计算机，而计算机其实是：“接受使用者输入指令与数据，经由中央处理 器的数学与逻辑单元运算处理后， 以产生或储存成有用的信息”。因此，只要有输入设备 （不 管是键盘还是触摸屏） 及输出设备 （例如电脑屏幕或直接由打印机打印出来），让你可以输 入数据使该机器产生信息的， 那就是一部计算机了。
Tips 电脑可以协助人们进行大量的运算！以前如果要计算化学反应式都得要算个老半天，有 了电脑仿真软件后，就有不一样的情况发生了！ 以下图为例，鸟哥的工作中，有一项是需要 将人们排放的空气污染物带入电脑模式进行仿真后，计算出可能产生的空气污染并得到空气 品质状态，最后经过分析软件得到各式各样的图表。 经过这些图表的解析，就可以让人们知 道什么样的污染排放来源可能会产生什么样的空气品质变化啰。

图0.1.1、计算器的功能
好了，根据这个定义你知道哪些东西是计算机了吗？其实包括一般商店用的简易型加减乘除 计算器、打电话用的手机、开车用的卫星定位系统 （GPS）、提款用的提款机 （ATM）、你 上课会使用的桌上型个人电脑、外出可能会带的笔记本电脑 （包括 notebook 与 netbook）， 还有近几年 （2015前后） 非常热门的平板电脑与智能手机， 甚至是未来可能会大流行的单 版电脑 （Xapple pi, banana pi, Raspberry pi, [1]） 与智能手表，甚至于更多的智能穿戴式电 脑[2]等等，这些都是计算机喔！
那么计算机主要的组成元件是什么呢？下面我们以常见的个人电脑主机或服务器工作站主机 来作为说明好了。

0.1 电脑：辅助人脑的好工具

33

鸟哥的 Linux 私房菜：基础学习篇 第四版
0.1.1 计算机硬件的五大单元
关于电脑的硬件组成部分，其实你可以观察你的台式机来分析一下，依外观来说这家伙主要 可分为三部分，分别是：
输入单元：包括键盘、鼠标、读卡机、扫描仪、手写板、触摸屏等等一堆； 主机部分：这个就是系统单元，被主机机箱保护住了，里面含有一堆板子、CPU 与内存 等； 输出单元：例如屏幕、打印机等等
我们主要通过输入设备如鼠标与键盘来将一些数据输入到主机里面，然后再由主机的功能处 理成为图表或文章等信息后， 将结果传输到输出设备，如屏幕或打印机上面。那主机里面含 有什么元件呢？如果你曾经拆开过电脑主机机箱 （包括拆开你的智能手机也一样喔！）， 会 发现其实主机里面最重要的就是一块主板，上面安插了中央处理器 （CPU） 以及内存、硬盘 （或记忆卡） 还有一些适配卡设备而已。 当然大部分智能手机是将这些元件直接焊接在主板 上面而不是插卡啦！
整部主机的重点在于中央处理器 （Central Processing Unit, CPU），CPU 为一个具有特定功 能的芯片， 里头含有微指令集，如果你想要让主机进行什么特异的功能，就得要参考这颗 CPU 是否有相关内置的微指令集才可以。 由于 CPU 的工作主要在于管理与运算，因此在 CPU 内又可分为两个主要的单元，分别是： 算数逻辑单元与控制单元。[3] 其中算数逻辑单 元主要负责程序运算与逻辑判断，控制单元则主要在协调各周边元件与各单元间的工作。 既然 CPU 的重点是在进行运算与判断，那么要被运算与判断的数据是从哪里来的？ CPU 读 取的数据都是从内存来的！ 内存内的数据则是从输入单元所传输进来！而 CPU 处理完毕的 数据也必须要先写回内存中，最后数据才从内存传输到输出单元。
Tips 为什么我们都会说，要加快系统性能，通常将内存容量加大就可以获得相当好的成效？ 如同下图以及上面的说明，因为所有的数据都要经过内存的传输， 所以内存的容量如果太 小，数据高速缓存就不足～影响性能相当大啊！尤其针对 Linux 作为服务器的环境下！这点 要特别记忆喔！
综合上面所说的，我们会知道其实电脑是由几个单元所组成的，包括输入单元、 输出单元、 CPU 内部的控制单元、算数逻辑单元与内存五大部分。 这几个东西的相关性如下所示：

0.1 电脑：辅助人脑的好工具

34

鸟哥的 Linux 私房菜：基础学习篇 第四版

五大单元[4]

图0.1.2、电脑的

上面图示中的“系统单元”其实指的就是电脑机箱内的主要元件，而重点在于 CPU 与内存。 特 别要看的是实线部分的传输方向，基本上数据都是流经过内存再转出去的！ 至于数据会流进/ 流出内存则是 CPU 所发布的控制命令！而 CPU 实际要处理的数据则完全来自于内存 （不管 是程序还是一般文件数据）！这是个很重要的概念喔！ 这也是为什么当你的内存不足时，系 统的性能就很糟糕！也是为什么现在人们买智能手机时，对于可用内存的要求都很高的原 因！

而由上面的图示我们也能知道，所有的单元都是由 CPU 内部的控制单元来负责协调的，因此 CPU 是整个电脑系统的最重要部分！ 那么目前世界上有哪些主流的 CPU 呢？是否刚刚我们 谈到的硬件内全部都是相同的 CPU 架构呢？下面我们就来谈一谈。

0.1.2 一切设计的起点： CPU 的架构
如前面说过的，CPU 其实内部已经含有一些微指令，我们所使用的软件都要经过 CPU 内部 的微指令集来达成才行。 那这些指令集的设计主要又被分为两种设计理念，这就是目前世界 上常见到的两种主要 CPU 架构， 分别是：精简指令集 （RISC） 与复杂指令集 （CISC） 系 统。下面我们就来谈谈这两种不同 CPU 架构的差异啰！
精简指令集 （Reduced Instruction Set Computer, RISC）：[5]
这种 CPU 的设计中，微指令集较为精简，每个指令的执行时间都很短，完成的动作也很单 纯，指令的执行性能较佳； 但是若要做复杂的事情，就要由多个指令来完成。常见的 RISC 微指令集 CPU 主要例如甲骨文 （Oracle） 公司的 SPARC 系列、 IBM 公司的 Power Architecture （包括 PowerPC） 系列、与安谋公司 （ARM Holdings） 的 ARM CPU 系列 等。

0.1 电脑：辅助人脑的好工具

35

鸟哥的 Linux 私房菜：基础学习篇 第四版
在应用方面，SPARC CPU 的电脑常用于学术领域的大型工作站中，包括银行金融体系的主 要服务器也都有这类的电脑架构； 至于PowerPC架构的应用上，例如索尼（Sony）公司出产 的Play Station 3（PS3）就是使用PowerPC架构的Cell处理器； 那安谋的 ARM 呢？你常使 用的各厂牌手机、PDA、导航系统、网络设备（交换器、路由器等）等，几乎都是使用 ARM 架构的 CPU 喔！ 老实说，目前世界上使用范围最广的 CPU 可能就是 ARM 这种架构的呢！ [6]
复杂指令集（Complex Instruction Set Computer, CISC）：[7]
与RISC不同的，CISC在微指令集的每个小指令可以执行一些较低阶的硬件操作，指令数目多 而且复杂， 每条指令的长度并不相同。因为指令执行较为复杂所以每条指令花费的时间较 长， 但每条个别指令可以处理的工作较为丰富。常见的CISC微指令集CPU主要有AMD、 Intel、VIA等的x86架构的CPU。
由于AMD、Intel、VIA所开发出来的x86架构CPU被大量使用于个人电脑（Personal computer）用途上面， 因此，个人电脑常被称为x86架构的电脑！那为何称为x86架构[8]呢？ 这是因为最早的那颗Intel发展出来的CPU代号称为8086，后来依此架构又开发出80286, 80386...， 因此这种架构的CPU就被称为x86架构了。
在2003年以前由Intel所开发的x86架构CPU由8位升级到16、32位，后来AMD依此架构修改新 一代的CPU为64位， 为了区别两者的差异，因此64位的个人电脑CPU又被统称为x86_64的 架构喔！

Tips 所谓的位指的是CPU一次数据读取的最大量！64位CPU代表CPU一次可以读写64bits这 么多的数据，32位CPU则是CPU一次只能读取32位的意思。 因为CPU读取数据量有限制，因 此能够从内存中读写的数据也就有所限制。所以，一般32位的CPU所能读写的最大数据量， 大概就是4GB左右。
那么不同的x86架构的CPU有什么差异呢？除了CPU的整体结构（如第二层高速缓存、每次运 行可执行的指令数等）之外， 主要是在于微指令集的不同。新的x86的CPU大多含有很先进 的微指令集， 这些微指令集可以加速多媒体程序的运行，也能够加强虚拟化的性能，而且某 些微指令集更能够增加能源效率， 让CPU耗电量降低呢！由于电费越来越高，购买电脑时， 除了整体的性能之外， 节能省电的CPU特色也可以考虑喔！
例题：最新的Intel/AMD的x86架构中，请查询出多媒体、虚拟化、省电功能各有哪些重要的 微指令集？（仅供参考）答：
多媒体微指令集：MMX, SSE, SSE2, SSE3, SSE4, AMD-3DNow! 虚拟化微指令集：Intel-VT, AMD-SVM

0.1 电脑：辅助人脑的好工具

36

鸟哥的 Linux 私房菜：基础学习篇 第四版
省电功能：Intel-SpeedStep, AMD-PowerNow! 64/32位相容技术：AMD-AMD64, Intel-EM64T
0.1.3 其他单元的设备
五大单元中最重要的控制、算术逻辑被整合到 CPU 的封装中，但系统当然不可能只有 CPU 啊！那其他三个重要电脑单元的设备还有哪些呢？ 其实在主机机箱内的设备大多是通过主板 （main board） 连接在一块，主板上面有个链接沟通所有设备的芯片组，这个芯片组可以将 所有单元的设备链接起来， 好让 CPU 可以对这些设备下达命令。其他单元的重要设备主要 有：
系统单元：如图 0.1.2 所示，系统单元包括 CPU 与内存及主板相关元件。而主板上头其 实还有很多的连接接口与相关的适配卡，包括鸟哥近期常使用的 PCI-E 10G 网卡、 磁盘 阵列卡、还有显卡等等。尤其是显卡，这东西对于玩3D游戏来说是非常重要的一环，他 与显示的精致度、色彩与分辨率都有关系。
存储单元：包括内存 （main memory, RAM） 与辅助内存，其中辅助内存其实就是大家 常听到的“储存设备”啰！包括硬盘、软盘、光盘、磁带等等的。
输入、输出单元：同时涵盖输入输出的设备最常见的大概就是触摸屏了。至于单纯的输 入设备包括前面提到的键盘鼠标之外，目前的体感设备也是重要的输入设备喔！ 至于输 出设备方面，除了屏幕外，打印机、音效喇叭、HDMI电视、投影机、蓝牙耳机等等，都 算喔！
更详细的各项主机与周边设备我们将在下个小节进行介绍！在这里我们先来了解一下各元件 的关系啰！那就是，电脑是如何运行的呢？
0.1.4 运行流程
如果不是很了解电脑的运行流程的话，鸟哥拿个简单的想法来思考好了～假设电脑是一个人 体，那么每个元件对应到那个地方呢？可以这样思考：

0.1 电脑：辅助人脑的好工具

37

鸟哥的 Linux 私房菜：基础学习篇 第四版

图0.1.3、各元件运 行
CPU=脑袋瓜子：每个人会作的事情都不一样（微指令集的差异），但主要都是通过脑袋 瓜子来进行判断与控制身体各部分的活动；
内存=脑袋中放置正在被思考的数据的区块：在实际活动过程中，我们的脑袋瓜子需要有 外界刺激的数据 （例如光线、环境、语言等） 来分析，那这些互动数据暂时存放的地方 就是内存，主要是用来提供给脑袋瓜子判断用的信息。
硬盘=脑袋中放置回忆的记忆区块：跟刚刚的内存不同，内存是提供脑袋目前要思考与处 理的信息，但是有些生活琐事或其他没有要立刻处理的事情， 就当成回忆先放置到脑袋 的记忆深处吧！那就是硬盘！主要目的是将重要的数据记录起来，以便未来将这些重要 的经验再次的使用；
主板=神经系统：好像人类的神经一样，将所有重要的元件连接起来，包括手脚的活动都 是脑袋瓜子发布命令后， 通过神经（主板）传导给手脚来进行活动啊！
各项周边设备=人体与外界沟通的手、脚、皮肤、眼睛等：就好像手脚一般，是人体与外 界互动的重要关键！
显卡=脑袋中的影像：将来自眼睛的刺激转成影像后在脑袋中呈现，所以显卡所产生的数 据来源也是CPU控制的。
电源供应器 （Power）=心脏：所有的元件要能运行得要有足够的电力供给才行！这电力 供给就好像心脏一样，如果心脏不够力， 那么全身也就无法动弹的！心脏不稳定呢？那 你的身体当然可能断断续续的～不稳定！

0.1 电脑：辅助人脑的好工具

38

鸟哥的 Linux 私房菜：基础学习篇 第四版
由这样的关系图当中，我们知道整个活动中最重要的就是脑袋瓜子！ 而脑袋瓜子当中与现在 正在进行的工作有关的就是CPU与内存！任何外界的接触都必须要由脑袋瓜子中的内存记录 下来， 然后给脑袋中的CPU依据这些数据进行判断后，再发布命令给各个周边设备！如果需 要用到过去的经验， 就得由过去的经验（硬盘）当中读取啰！
也就是说，整个人体最重要的地方就是脑袋瓜子，同样的，整部主机当中最重要的就是CPU 与内存， 而CPU的数据来源通通来自于内存，如果要由过去的经验来判断事情时， 也要将经 验（硬盘）挪到目前的记忆（内存）当中，再交由CPU来判断喔！这点得要再次的强调啊！ 下个章节当中，我们就对目前常见的个人电脑各个元件来进行说明啰！
0.1.5 电脑按用途分类
知道了电脑的基本组成与周边设备，也知道其实电脑的CPU种类非常的多，再来我们想要了 解的是，电脑如何分类？ 电脑的分类非常多种，如果以电脑的复杂度与运算能力进行分类的 话，主要可以分为这几类：
超级计算机（Supercomputer） 超级计算机是运行速度最快的电脑，但是他的维护、操 作费用也最高！主要是用于需要有高速计算的计划中。 例如：国防军事、气象预测、太 空科技，用在仿真的领域较多。详情也可以参考： 国家高速网络与计算中心 http://www.nchc.org.tw的介绍！ 至于全世界最快速的前500大超级计算机，则请参 考：http://www.top500.org。
大型计算机（Mainframe Computer） 大型计算机通常也具有数个高速的CPU，功能上虽 不及超级计算机，但也可用来处理大量数据与复杂的运算。 例如大型企业的主机、全国 性的证券交易所等每天需要处理数百万笔数据的企业机构， 或者是大型企业的数据库服 务器等等。
迷你电脑（Minicomputer） 迷你电脑仍保有大型计算机同时支持多使用者的特性，但是 主机可以放在一般作业场所， 不必像前两个大型计算机需要特殊的空调场所。通常用来 作为科学研究、工程分析与工厂的流程管理等。
工作站（Workstation） 工作站的价格又比迷你电脑便宜许多，是针对特殊用途而设计的 电脑。在个人电脑的性能还没有提升到目前的状况之前， 工作站电脑的性能/价格比是所 有电脑当中较佳的，因此在学术研究与工程分析方面相当常见。
微电脑（Microcomputer） 个人电脑就属于这部份的电脑分类，也是我们本章主要探讨的 目标！体积最小，价格最低，但功能还是五脏俱全的！ 大致又可分为桌上型、笔记型等 等。
若光以性能来说，目前的个人电脑性能已经够快了，甚至已经比工作站等级以上的电脑运算 速度还要快！ 但是工作站电脑强调的是稳定不死机，并且运算过程要完全正确，因此工作站 以上等级的电脑在设计时的考虑与个人电脑并不相同啦！ 这也是为啥工作站等级以上的电脑 售价较贵的原因。

0.1 电脑：辅助人脑的好工具

39

鸟哥的 Linux 私房菜：基础学习篇 第四版

0.1.6 电脑上面常用的计算单位 （容量、速度等）

电脑的运算能力除了 CPU 微指令集设计的优劣之外，但主要还是由速度来决定的。至于存放 在电脑储存设备当中的数据容量也是有单位的。
容量单位
电脑对数据的判断主要依据有没有通电来记录信息，所以理论上对于每一个纪录单位而言， 它只认识 0 与 1 而已。0/1 这个二进制的的单位我们称为 bit。 但 bit 实在太小了，所以在储 存数据时每份简单的数据都会使用到 8 个 bits 的大小来记录，因此定义出 Byte 这个单位，他 们的关系为：

1 Byte = 8 bits
不过同样的，Byte 还是太小了，在较大的容量情况下，使用 Byte 相当不容易判断数据的大 小，举例来说，1000000 Bytes 这样的显示方式你能够看得出有几个零吗？所以后来就有一 些常见的简化单位表达式，例如 K 代表 1024Byte，M 代表 1024K 等。 而这些单位在不同的 进位制下有不同的数值表示，下面就列出常见的单位与进位制对应：

进位制 二进制 十进制

Kilo 1024 1000

Mega 1024K 1000K

Giga 1024M 1000M

Tera 1024G 1000G

Peta 1024T 1000T

Exa 1024P 1000P

Zetta 1024E 1000E

一般来说，文件大小使用的是二进制的方式，所以 1GBytes 的文件大小实际上为： 1024x1024x1024Bytes 这么大！ 速度单位则常使用十进制，例如 1GHz 就是 1000x1000x1000Hz 的意思。

Tips 那么什么是“进位”呢？以人类最常用的十进制为例，每个“位置”上面最多仅能有一个数 值，这个数值不可以比 9 还要大！那比 9 还大怎办？ 就用“第二个位置来装一个新的 1 ”！所 以， 9 还是只有一个位置， 10 则是用了两个位置了。好了那如果是 16 进位怎办？由于每个 位置只能出现一个数值， 但是数字仅有 0~9 而已啊！因此 16 进位中，就以 A 代表 10 的意 思，以 B 代表 11 的意思，所以 16 进位就是 0~9, a, b, c, d, e, f，有没有看到， “每个位置最 多还是只有一个数值而已”喔！好了，那回来谈谈二进制。因为每个位置只能有 0, 1 而已，不 能出现 2 （逢 2 进一位） 啦！这样了解乎？
速度单位

0.1 电脑：辅助人脑的好工具

40

鸟哥的 Linux 私房菜：基础学习篇 第四版
CPU的运算速度常使用 MHz 或者是 GHz 之类的单位，这个 Hz 其实就是秒分之一。而在网 络传输方面，由于网络使用的是 bit 为单位，因此网络常使用的单位为 Mbps 是 Mbits per second，亦即是每秒多少 Mbit。举例来说，大家常听到的 20M/5M 光世代传输速度，如果转 成文件大小的 Byte 时，其实理论最大传输值为：每秒 2.5MByte/ 每秒625KByte的下载/上传 速度喔！
例题：假设你今天购买了500GB的硬盘一颗，但是格式化完毕后却只剩下460GB左右的容 量，这是什么原因？答：因为一般硬盘制造商会使用十进制的单位，所以500GByte代表为 50010001000*1000Byte之意。 转成文件的容量单位时使用二进制（1024为底），所以就成 为466GB左右的容量了。
硬盘厂商并非要骗人，只是因为硬盘的最小物理量为512Bytes，最小的组成单位为扇区 （sector）， 通常硬盘容量的计算采用“多少个sector”，所以才会使用十进制来处理的。相关 的硬盘信息在这一章后面会提到的！

0.1 电脑：辅助人脑的好工具

41

鸟哥的 Linux 私房菜：基础学习篇 第四版
0.2 个人电脑架构与相关设备元件
一般消费者常说的电脑通常指的就是x86的个人电脑架构，因此我们有必要来了解一下这个架 构的各个元件。事实上，Linux最早在发展的时候，就是依据个人电脑的架构来发展的， 所以 真的得要了解一下呢！另外，早期两大主流x86开发商（Intel, AMD）的CPU架构与设计理念 都有些许差异。不过互相学习对方长处的结果，就是两者间的架构已经比较类似了。 由于目 前市场占有率还是以 Intel 为大宗，因此下面以目前（2015）相对较新的 Intel 主板架构来谈 谈：

图 0.2.1、Intel芯片架构
由于主板是链接各元件的一个重要项目，因此在主板上面沟通各部元件的芯片组设计优劣， 就会影响性能不少喔！早期的芯片组通常分为两个桥接器来控制各元件的沟通， 分别是： （1）北桥：负责链接速度较快的CPU、内存与显卡接口等元件；（2）南桥：负责连接速度 较慢的设备接口， 包括硬盘、USB、网卡等等。（芯片组的南北桥与三国的大小乔没有关系 @_@）。不过由于北桥最重要的就是 CPU 与内存之间的桥接，因此目前的主流架构中， 大 多将北桥内存控制器整合到 CPU 封装当中了。所以上图你只会看到 CPU 而没有看到以往的 北桥芯片喔！

0.2 个人电脑架构与相关设备元件

42

鸟哥的 Linux 私房菜：基础学习篇 第四版

Tips 早期芯片组分南北桥，北桥可以连接 CPU、内存与显卡。只是 CPU 要读写到内存的动 作，还需要北桥的支持，也就是 CPU 与内存的交流， 会瓜分掉北桥的总可用带宽，真浪 费！因此目前将内存控制器整合到 CPU 后，CPU与内存之间的沟通是直接交流，速度较快之 外，也不会消耗更多的带宽！
毕竟目前世界上x86的CPU主要供应商为Intel，所以下面鸟哥将以Intel的主板架构说明各元件 啰！ 我们以华硕公司出的主板，型号：Asus Z97-AR 作为一个说明的范例，搭配着主板芯片 组逻辑图 0.2.1 的说明，主板各元件如下所示：
图 0.2.2、ASUS 主板 （图片为华硕公司所有）
上述的图片中，主板上面设计的插槽主要有 CPU （Intel LGA 1150 Socket）、内存 （DDR3 3200 support）、显卡接口 （PCIe3.0）、SATA 磁盘插槽 （SATA express）等等。 下面的 元件在解说的时候，请参考上述两张图示来印证喔！
0.2.1 执行脑袋运算与判断的 CPU
如同华硕主板示意图上半部的中央部分，那就是CPU插槽。 由于CPU负责大量运算，因此 CPU通常是具有相当高发热量的元件。所以如果你曾经拆开过主板， 应该就会看到CPU上头 通常会安插一颗风扇来主动散热的。
x86个人电脑的CPU主要供应商为Intel与AMD，目前（2015）主流的CPU都是双核以上的架 构了！ 原本的单核心CPU仅有一个运算单元，所谓的多核心则是在一颗CPU封装当中嵌入了 两个以上的运算核心， 简单的说，就是一个实体的CPU外壳中，含有两个以上的CPU单元就 是了。
不同的CPU型号大多具有不同的脚位（CPU上面的插脚），能够搭配的主板芯片组也不同， 所以当你想要将你的主机升级时，不能只考虑CPU，你还得要留意你的主板上面所支持的 CPU型号喔！ 不然买了最新的CPU也不能够安插在你的旧主板上头的！目前主流的CPU有 Intel的 i3/i5/i7 系列产品中，甚至先后期出厂的类似型号的脚位也不同， 例如 i7-2600 使用 LGA1155 脚位而 i7-4790 则使用 FCLGA1150 脚位，挑选时必须要很小心喔！
我们前面谈到CPU内部含有微指令集，不同的微指令集会导致CPU工作效率的优劣。除了这 点之外， CPU性能的比较还有什么呢？那就是CPU的频率了！什么是频率呢？简单的说， 频 率就是CPU每秒钟可以进行的工作次数。 所以频率越高表示这颗CPU单位时间内可以作更多 的事情。举例来说，Intel的 i7-4790 CPU频率为3.6GHz， 表示这颗CPU在一秒内可以进行 3.6x109次工作，每次工作都可以进行少数的指令运行之意。

0.2 个人电脑架构与相关设备元件

43

鸟哥的 Linux 私房菜：基础学习篇 第四版

Tips 注意，不同的CPU之间不能单纯的以频率来判断运算性能喔！这是因为每颗CPU的微指 令集不相同，架构也不见得一样，可使用的第二层高速缓存及其计算机制可能也不同， 加上 每次频率能够进行的工作指令数也不同！所以，频率目前仅能用来比较同款CPU的速度！
CPU的工作频率：外频与倍频
早期的 CPU 架构主要通过北桥来链接系统最重要的 CPU、内存与显卡设备。因为所有的设 备都得通过北桥来链接，因此每个设备的工作频率应该要相同。 于是就有所谓的前端总线 （FSB） 这个东西的产生。但因为 CPU 的运算速度比其他的设备都要来的快，又为了要满足 FSB 的频率，因此厂商就在 CPU 内部再进行加速， 于是就有所谓的外频与倍频了。
总结来说，在早期的 CPU 设计中，所谓的外频指的是CPU与外部元件进行数据传输时的速 度，倍频则是 CPU 内部用来加速工作性能的一个倍数， 两者相乘才是CPU的频率速度。例 如 Intel Core 2 E8400 的内频为 3.0GHz，而外频是333MHz，因此倍频就是9倍啰！ （3.0G=333Mx9, 其中1G=1000M）

Tips 很多计算机硬件玩家很喜欢玩“超频”，所谓的超频指的是： 将CPU的倍频或者是外频通 过主板的设置功能更改成较高频率的一种方式。但因为CPU的倍频通常在出厂时已经被锁定 而无法修改， 因此较常被超频的为外频。 举例来说，像上述3.0GHz的CPU如果想要超频， 可以将他的外频333MHz调整成为400MHz，但如此一来整个主板的各个元件的运行频率可能 都会被增加成原本的1.333倍（4/3）， 虽然CPU可能可以到达3.6GHz，但却因为频率并非正 常速度，故可能会造成死机等问题。
但如此一来所有的数据都被北桥卡死了，北桥又不可能比 CPU 更快，因此这家伙常常是系统 性能的瓶颈。为了解决这个问题，新的 CPU 设计中， 已经将内存控制器整合到 CPU 内部， 而链接 CPU 与内存、显卡的控制器的设计，在Intel部份使用 QPI （Quick Path Interconnect） 与 DMI 技术，而 AMD 部份则使用 Hyper Transport 了，这些技术都可以让 CPU 直接与内存、显卡等设备分别进行沟通，而不需要通过外部的链接芯片了。
因为现在没有所谓的北桥了 （整合到 CPU 内），因此，CPU 的频率设计就无须考虑得要同 步的外频，只需要考虑整体的频率即可。 所以，如果你经常有查阅自己 CPU 频率的习惯， 当使用 cpu-z [9] 这个软件时，应该会很惊讶的发现到，怎么外频变成 100MHz 而倍频可以到 达 30 以上！相当有趣呢！

0.2 个人电脑架构与相关设备元件

44

鸟哥的 Linux 私房菜：基础学习篇 第四版

Tips 现在 Intel 的 CPU 会主动帮你超频喔！例如 i7-4790 这颗 CPU 的规格 [10] 中，基本频 率为 3.6GHz，但是最高可自动超频到 4GHz 喔！ 通过的是 Intel 的 turbo 技术。同时，如果 你没有大量的运算需求，该 CPU 频率会降到 1.xGHz 而已，借此达到节能省电的目的！所 以，各位好朋友， 不需要自己手动超频了！Intel 已经自动帮你进行超频了...所以，如果你用 cpu-z 观察 CPU 频率，发现该频率会一直自动变动，很正常！你的系统没坏掉！
32位与64位的CPU与总线“宽度”
从前面的简易说明中，我们知道 CPU 的各项数据通通得要来自于内存。因此，如果内存能提 供给 CPU 的数据量越大的话，当然整体系统的性能应该也会比较快！ 那如何知道内存能提 供的数据量呢？此时还是得要借由 CPU 内的内存控制芯片与内存间的传输速度“前端总线速 度（Front Side Bus, FSB） 来说明。
与 CPU 的频率类似的，内存也是有其工作的频率，这个频率限制还是来自于 CPU 内的内存 控制器所决定的。以图0.2.1 为例， CPU 内置的内存控制芯片对内存的工作频率最高可达到 1600MHz。这只是工作频率（每秒几次）。一般来说，每次频率能够传输的数据量，大多为 64 位，这个 64 位就是所谓的“宽度”了！ 因此，在图0.2.1 这个系统中，CPU可以从内存中取 得的最快带宽就是 1600MHz 64bit = 1600MHz 8 Bytes = 12.8GByte/s。
与总线宽度相似的，CPU每次能够处理的数据量称为字组大小（word size）， 字组大小依据 CPU的设计而有32位与64位。我们现在所称的电脑是32或64位主要是依据这个 CPU解析的 字组大小而来的！早期的32位CPU中，因为CPU每次能够解析的数据量有限， 因此由内存传 来的数据量就有所限制了。这也导致32位的CPU最多只能支持最大到4GBytes的内存。

Tips 得利于北桥整合到 CPU 内部的设计，CPU 得以“个别”跟各个元件进行沟通！因此，每 种元件与 CPU 的沟通具有很多不同的方式！例如内存使用系统总线带宽来与 CPU 沟通。而 显卡则通过PCI-E的序列信道设计来与CPU沟通喔！详细说明我们在本章稍后的主板部份再来 谈谈。
CPU等级
由于x86架构的CPU在Intel的Pentium系列（1993年）后就有不统一的脚位与设计，为了将不 同种类的CPU规范等级， 所以就有i386,i586,i686等名词出现了。基本上，在Intel Pentium MMX与AMD K6年代的CPU称为i586等级， 而Intel Celeron与AMD Athlon（K7）年代之后的

0.2 个人电脑架构与相关设备元件

45

鸟哥的 Linux 私房菜：基础学习篇 第四版

32位CPU就称为i686等级。 至于目前的64位CPU则统称为x86_64等级。
目前很多的程序都有对CPU做最优化的设计，万一哪天你发现一些程序是注明给x86_64的 CPU使用时， 就不要将他安装在686以下等级的电脑中，否则可是会无法执行该软件的！ 不 过，在x86_64的硬件下倒是可以安装386的软件喔！也就是说，这些东西具有向下相容的能 力啦！
超线程 （Hyper-Threading, HT）
我们知道现在的 CPU 至少都是两个核心以上的多核心 CPU 了，但是 Intel 还有个很怪的东 西，叫做 CPU 的超线程 （Hyper-Threading） 功能！ 那个是啥鬼东西？我们知道现在的 CPU 运算速度都太快了，因此运算核心经常处于闲置状态下。而我们也知道现在的系统大多 都是多任务的系统， 同时间有很多的程序会让 CPU 来执行。因此，若 CPU 可以假象的同时 执行两个程序，不就可以让系统性能增加了吗？反正 CPU 的运算能力还是没有用完啊！
那是怎么达成的啊这个 HT 功能？强者鸟哥的同事蔡董大大用个简单的说明来解释。在每一个 CPU 内部将重要的寄存器 （register） 分成两群， 而让程序分别使用这两群寄存器。也就是 说，可以有两个程序“同时竞争 CPU 的运算单元”，而非通过操作系统的多任务切换！ 这一过 程就会让 CPU 好像“同时有两个核心”的模样！因此，虽然大部分 i7 等级的 CPU 其实只有四 个实体核心，但通过 HT 的机制， 则操作系统可以抓到八个核心！并且让每个核心逻辑上分 离，就可以同时运行八个程序了。
虽然很多研究与测试中，大多发现 HT 虽然可以提升性能，不过，有些情况下却可能导致性能 降低喔！因为，实际上明明就仅有一个运算单元嘛！ 不过在鸟哥使用数值模式的情况下，因 为鸟哥操作的数值模式主要为平行运算功能，且运算通常无法达到 100% 的 CPU 使用率，通 常仅有大约60%运算量而已。 因此在鸟哥的实作过程中，这个 HT 确实提升相当多的性能！ 至少应该可以节省鸟哥大约30%~50%的等待时间喔！不过网络上大家的研究中， 大多说这个 是 case by case，而且使用的软件影响很大！所以，在鸟哥的例子是启用 HT 帮助很大！您 的案例就得要自行研究啰！
0.2.2 内存
如同图0.2.2、华硕主板示意图中的右上方部分的那四根插槽，那就是内存的插槽了。 内存插 槽中间通常有个突起物将整个插槽稍微切分成为两个不等长的距离， 这样的设计可以让使用 者在安装内存时，不至于前后脚位安插错误，是一种防呆的设计喔。
前面提到CPU所使用的数据都是来自于内存（main memory），不论是软件程序还是数据， 都必须要读入内存后CPU才能利用。 个人电脑的内存主要元件为动态随机存取内存 （Dynamic Random Access Memory, DRAM）， 随机存取内存只有在通电时才能记录与使 用，断电后数据就消失了。因此我们也称这种RAM为挥发性内存。
DRAM根据技术的更新又分好几代，而使用上较广泛的有所谓的SDRAM与DDR SDRAM两 种。 这两种内存的差别除了在于脚位与工作电压上的不同之外，DDR是所谓的双倍数据传送 速度（Double Data Rate）， 他可以在一次工作周期中进行两次数据的传送，感觉上就好像

0.2 个人电脑架构与相关设备元件

46

鸟哥的 Linux 私房菜：基础学习篇 第四版

是CPU的倍频啦！ 所以传输频率方面比SDRAM还要好。新一代的PC大多使用DDR内存了。 下表列出SDRAM与DDR SDRAM的型号与频率及带宽之间的关系。[11]

SDRAM/DDR 型号

SDRAM SDRAM DDR DDR DDR DDR

PC100
PC133
DDR266
DDR400
DDR2800
DDR31600

数据宽度 （bit） 64 64 64
64
64
64

内部频率 （MHz） 100 133 133
200
200
200

频率 速度 100 133
266

带宽（频率x宽 度）
800MBytes/sec 1064MBytes/sec
2.1GBytes/sec

400

3.2GBytes/sec

800

6.4GBytes/sec

1600 12.8GBytes/sec

DDR SDRAM又依据技术的发展，有DDR, DDR2, DDR3, DDR4等等，其中，DDR2 的频率 倍数则是 4 倍而DDR3 则是 8 倍喔！ 目前鸟哥用到服务器等级的内存，已经到 DDR4 了耶！ 超快超快！

Tips 在图 0.2.1 中，内存的规格内提到 DDR3/DDR3L 同时支持，我们知道 DDR3 了，那 DDR3L 是啥鬼？ 为了节省更多的电力，新的制程中降低了内存的操作电压，因此 DDR3 标 准电压为 1.5V，但 DDR3L 则仅须 1.35V 喔！通常可以用在耗电量需求更低的笔记本中！ 但 并非所有的系统都同步支持！这就得要看主板的支持规格啰！否则你买了 DDR3L 安插在不支 持的主板上，DDR3L 内存是可能会烧毁的喔！
内存除了频率/带宽与型号需要考虑之外，内存的容量也是很重要的喔！ 因为所有的数据都得 要载入内存当中才能够被CPU判读，如果内存容量不够大的话将会导致某些大容量数据无法 被完整的载入， 此时已存在内存当中但暂时没有被使用到的数据必须要先被释放，使得可用 内存容量大于该数据，那份新数据才能够被载入呢！ 所以，通常越大的内存代表越快速的系 统，这是因为系统不用常常释放一些内存内部的数据。 以服务器来说，内存的容量有时比 CPU的速度还要来的重要的！
多通道设计
由于所有的数据都必须要存放在内存，所以内存的数据宽度当然是越大越好。 但传统的总线 宽度一般大约仅达64位，为了要加大这个宽度，因此芯片组厂商就将两个内存汇整在一起， 如果一支内存可达64位，两支内存就可以达到128位了，这就是双通道的设计理念。

0.2 个人电脑架构与相关设备元件

47

鸟哥的 Linux 私房菜：基础学习篇 第四版
如上所述，要启用双通道的功能你必须要安插两支（或四支）内存，这两支内存最好连型号 都一模一样比较好， 这是因为启动双通道内存功能时，数据是同步写入/读出这一对内存中， 如此才能够提升整体的带宽啊！ 所以当然除了容量大小要一致之外，型号也最好相同啦！ 你有没有发现图 0.2.2、华硕主板示意图上那四根内存插槽的颜色呢？是否分为两种颜色，且 两两成对？ 为什么要这样设计？答出来了吗？是啦！这种颜色的设计就是为了双通道来的！ 要启动双通道的功能时， 你必须要将两根容量相同的内存插在相同颜色的插槽当中喔！
Tips 服务器所需要的速度更快！因此，除了双通道之外，中阶服务器也经常提供三信道，甚 至四信道的内存环境！ 例如 2014 年推出的服务器用 E5-2650 v3 的 Intel CPU 中，它可以接 受的最大信道数就是四信道且为 DDR4 喔！
DRAM与SRAM 除了内存条之外，事实上整部个人电脑当中还有许许多多的内存存在喔！最为我们所知的就 是CPU内的第二层高速缓存内存。 我们现在知道CPU的数据都是由内存提供，但CPU到内存 之间还是得要通过内存控制器啊！ 如果某些很常用的程序或数据可以放置到CPU内部的话， 那么CPU数据的读取就不需要跑到内存重新读取了！ 这对于性能来说不就可以大大的提升 了？这就是第二层高速缓存的设计概念。第二层高速缓存与内存及CPU的关系如下图所示：

图0.2.3、内存相关性
因为第二层高速缓存（L2 cache）整合到CPU内部，因此这个L2内存的速度必须要CPU频率 相同。 使用DRAM是无法达到这个频率速度的，此时就需要静态随机存取内存（Static Random Access Memory, SRAM）的帮忙了。 SRAM在设计上使用的电晶体数量较多，价格 较高，且不易做成大容量，不过由于其速度快， 因此整合到CPU内成为高速缓存内存以加快 数据的存取是个不错的方式喔！新一代的CPU都有内置容量不等的L2高速缓存在CPU内部， 以加快CPU的运行性能。
只读存储器（ROM）
主板上面的元件是非常多的，而每个元件的参数又具有可调整性。举例来说，CPU与内存的 频率是可调整的； 而主板上面如果有内置的网卡或者是显卡时，该功能是否要启动与该功能 的各项参数， 是被记录到主板上头的一个称为CMOS的芯片上，这个芯片需要借着额外的电

0.2 个人电脑架构与相关设备元件

48

鸟哥的 Linux 私房菜：基础学习篇 第四版
源来发挥记录功能， 这也是为什么你的主板上面会有一颗电池的缘故。
那CMOS内的数据如何读取与更新呢？还记得你的电脑在开机的时候可以按下[Del]按键来进 入一个名为BIOS的画面吧？ BIOS（Basic Input Output System）是一套程序，这套程序是写 死到主板上面的一个内存芯片中， 这个内存芯片在没有通电时也能够将数据记录下来，那就 是只读存储器（Read Only Memory, ROM）。 ROM是一种非挥发性的内存。另外，BIOS对 于个人电脑来说是非常重要的， 因为他是系统在开机的时候首先会去读取的一个小程序喔！
另外，固件（firmware）[12]很多也是使用ROM来进行软件的写入的。 固件像软件一样也是 一个被电脑所执行的程序，然而他是对于硬件内部而言更加重要的部分。例如BIOS就是一个 固件， BIOS虽然对于我们日常操作电脑系统没有什么太大的关系，但是他却控制着开机时各 项硬件参数的取得！ 所以我们会知道很多的硬件上头都会有ROM来写入固件这个软件。
BIOS 对电脑系统来讲是非常重要的，因为他掌握了系统硬件的详细信息与开机设备的选择等 等。但是电脑发展的速度太快了， 因此 BIOS 程序码也可能需要作适度的修改才行，所以你 才会在很多主板官网找到 BIOS 的更新程序啊！但是 BIOS 原本使用的是无法改写的 ROM ， 因此根本无法修正 BIOS 程序码！为此，现在的 BIOS 通常是写入类似闪存 （flash） 或 EEPROM [13] 中。[14]

Tips 很多硬件上面都会有固件喔！例如鸟哥常用的磁盘阵列卡、 10G 的网卡、交换器设备等 等！你可以简单的这么想！固件就是绑在硬件上面的控制软件！
0.2.3 显卡
显卡插槽如同图 0.2.2、华硕主板示意图所示，在中左方有个 PCIe 3.0 的项目， 这张主板中 提供了两个显卡插槽喔！
显卡又称为VGA（Video Graphics Array），他对于图形影像的显示扮演相当关键的角色。 一 般对于图形影像的显示重点在于分辨率与色彩深度，因为每个图像显示的颜色会占用掉内 存， 因此显卡上面会有一个内存的容量，这个显存容量将会影响到你的屏幕分辨率与色彩深 度的喔！
除了显存之外，现在由于三度空间游戏（3D game）与一些3D动画的流行，因此显卡的“运算 能力”越来越重要。 一些3D的运算早期是交给CPU去运行的，但是CPU并非完全针对这些3D 来进行设计的，而且CPU平时已经非常忙碌了呢！ 所以后来显卡厂商直接在显卡上面嵌入一 个3D加速的芯片，这就是所谓的GPU称谓的由来。

0.2 个人电脑架构与相关设备元件

49

鸟哥的 Linux 私房菜：基础学习篇 第四版

显卡主要也是通过CPU的控制芯片来与CPU、内存等沟通。如前面提到的，对于图形影像 （尤其是3D游戏）来说， 显卡也是需要高速运算的一个元件，所以数据的传输也是越快越 好！因此显卡的规格由早期的PCI导向AGP， 近期AGP又被PCI-Express规格所取代了。如前 面华硕主板图示当中看到的就是PCI-Express的插槽。 这些插槽最大的差异就是在数据传输的 带宽了！如下所示：

规格 PCI PCI 2.2 PCI-X AGP 4x AGP 8x PCIe 1.0 x1 PCIe 1.0 x8 PCIe 1.0 x16

宽度 32 bits 64 bits 64 bits 32 bits 32 bits 无 无 无

速度 33 MHz 66 MHz 133 MHz 66x4 MHz 66x8 MHz 无 无 无

带宽 133 MBytes/s 533 MBytes/s 1064 MBytes/s 1066 MBytes/s 2133 MBytes/s 250 MBytes/s 2 GBytes/s 4 GBytes/s

比较特殊的是，PCIe（PCI-Express）使用的是类似管线的概念来处理，在 PCIe 第一版 （PCIe 1.0） 中，每条管线可以具有250MBytes/s的带宽性能， 管线越多（通常设计到 x16 管线）则总带宽越高！另外，为了提升更多的带宽，因此 PCIe 还有进阶版本，目前主要的版 本为第三版，相关的带宽如下：[15]

规格 PCIe 1.0 PCIe 2.0 PCIe 3.0 PCIe 4.0

1x带宽 250MByte/s 500MByte/s ~1GByte/s ~2GByte/s

16x带宽 4GByte/s 8GByte/s ~16GByte/s ~32GByte/s

若以图0.2.2的主板为例，它使用的是 PCIe 3.0 的 16x，因此最大带宽就可以到达接近 32GBytes/s 的传输量！ 比起AGP是快很多的！好可怕的传输量....
如果你的主机是用来打3D游戏的，那么显卡的选购是非常重要喔！如果你的主机是用来做为 网络服务器的， 那么简单的入门级显卡对你的主机来说就非常够用了！因为网络服务器很少 用到3D与图形影像功能。
例题：假设你的桌面使用1024x768分辨率，且使用全彩（每个像素占用3Bytes的容量），请 问你的显卡至少需要多少内存才能使用这样的彩度？答：因为1024x768分辨率中会有786432 个像素，每个像素占用3Bytes，所以总共需要2.25MBytes以上才行！ 但如果考虑屏幕的更新 率（每秒钟屏幕的更新次数），显卡的内存还是越大越好！

0.2 个人电脑架构与相关设备元件

50

鸟哥的 Linux 私房菜：基础学习篇 第四版
除了显卡与主板的连接接口需要知道外，那么显卡是通过什么格式与电脑屏幕 （或电视） 连 接的呢？目前主要的连接接口有：
D-Sub （VGA端子）：为较早之前的连接接口，主要为 15 针的连接，为模拟讯号的传 输，当初设计是针对传统图像管屏幕而来。 主要的规格有标准的 640x350px @70Hz、 1280x1024px @85Hz 及 2048x1536px @85Hz 等。 DVI：共有四种以上的接头，不过台湾市面上比较常见的为仅提供数码讯号的 DVI-D，以 及整合数码与模拟讯号的 DVI-I 两种。DVI 常见于液晶屏幕的链接， 标准规格主要有： 1920x1200px @60Hz、 2560x1600px @60Hz 等。 HDMI：相对于 D-sub 与 DVI 仅能传送影像数据，HDMI 可以同时传送影像与声音，因此 被广泛的使用于电视屏幕中！电脑屏幕目前也经常都有支持 HDMI 格式！ Display port：与 HDMI 相似的，可以同时传输声音与影像。不过这种接口目前在台湾还 是比较少屏幕的支持！
0.2.4 硬盘与储存设备
电脑总是需要记录与读取数据的，而这些数据当然不可能每次都由使用者经过键盘来打字！ 所以就需要有储存设备咯。 电脑系统上面的储存设备包括有：硬盘、软盘、MO、CD、 DVD、磁带机、U盘（闪存）、还有新一代的蓝光光驱等， 乃至于大型机器的区域网络储存 设备（SAN, NAS）等等，都是可以用来储存数据的。而其中最常见的应该就是硬盘了吧！
硬盘的物理组成
大家应该都看过硬盘吧！硬盘依据台式机与笔记本电脑而有分为3.5英寸及2.5英寸的大小。我 们以3.5英寸的台式机使用硬盘来说明。 在硬盘盒里面其实是由许许多多的圆形盘片、机械手 臂、 磁头与主轴马达所组成的，整个内部如同下图所示：

科）

图0.2.4、硬盘物理构造（图片取自维基百

实际的数据都是写在具有磁性物质的盘片上头，而读写主要是通过在机械手臂上的磁头 （head）来达成。 实际运行时， 主轴马达让盘片转动，然后机械手臂可伸展让磁头在盘片上 头进行读写的动作。 另外，由于单一盘片的容量有限，因此有的硬盘内部会有两个以上的盘 片喔！

0.2 个人电脑架构与相关设备元件

51

鸟哥的 Linux 私房菜：基础学习篇 第四版
盘片上的数据 既然数据都是写入盘片上头，那么盘片上头的数据又是如何写入的呢？其实盘片上头的数据 有点像下面的图示所示：

式（图片取自维基百科）

图0.2.5、盘片上的数据格

由于盘片是圆的，并且通过机器手臂去读写数据，盘片要转动才能够让机器手臂读写。因 此，通常数据写入当然就是以圆圈转圈的方式读写啰！ 所以，当初设计就是在类似盘片同心 圆上面切出一个一个的小区块，这些小区块整合成一个圆形，让机器手臂上的磁头去存取。 这个小区块就是磁盘的最小物理储存单位，称之为扇区 （sector），那同一个同心圆的扇区 组合成的圆就是所谓的磁道（track）。 由于磁盘里面可能会有多个盘片，因此在所有盘片上 面的同一个磁道可以组合成所谓的柱面 （cylinder）。

我们知道同心圆外圈的圆比较大，占用的面积比内圈多啊！所以，为了善用这些空间，因此 外围的圆会具有更多的扇区[16]！ 就如同图 0.2.5 的示意一般。此外，当盘片转一圈时，外圈 的扇区数量比较多，因此如果数据写入在外圈，转一圈能够读写的数据量当然比内圈还要 多！ 因此通常数据的读写会由外圈开始往内写的喔！这是默认值啊！

另外，原本硬盘的扇区都是设计成 512Byte 的容量，但因为近期以来硬盘的容量越来越大， 为了减少数据量的拆解，所以新的大容量硬盘已经有 4KByte 的扇区设计！ 购买的时候也需 要注意一下。也因为这个扇区的设计不同了，因此在磁盘的分区方面，目前有旧式的 MSDOS 相容模式，以及较新的 GPT 模式喔！ 在较新的 GPT 模式下，磁盘的分区通常使用 扇区号码来设计，跟过去旧的 MSDOS 是通过柱面号码来分区的情况不同喔！相关的说明我 们谈到磁盘管理 （第七章） 再来聊！

0.2 个人电脑架构与相关设备元件

52

鸟哥的 Linux 私房菜：基础学习篇 第四版
传输接口
为了要提升磁盘的传输速度，磁盘与主板的连接接口也经过多次的改版，因此有许多不同的 接口喔！传统磁盘接口包括有 SATA, SAS, IDE 与 SCSI 等等。 若考虑外接式磁盘，那就还 包括了 USB, eSATA 等等接口喔！不过目前 IDE 已经被 SATA 取代，而 SCSI 则被 SAS 取 代，因此我们下面将仅介绍 SATA, USB 与 SAS 接口而已。
SATA接口
如同华硕主板图示右下方所示为SATA硬盘的连接接口插槽。这种插槽所使用的排线比较窄 小， 而且每个设备需要使用掉一条SATA线。因为SATA线比较窄小之故，所以对于安装与机 箱内的通风都比较好！因此原本的IDE粗排线接口就被SATA取代了！ SATA的插槽示意图如下 所示：

线 （图示取自 Seagate 网站）

图0.2.6、SATA 接口的排

由于SATA一条排线仅接一颗硬盘，所以你不需要调整跳针。不过一张主板上面SATA插槽的数 量并不是固定的， 且每个插槽都有编号，在连接SATA硬盘与主板的时候，还是需要留意一 下。此外，目前的 SATA 版本已经到了第三代 [17]， 每一代之间的传输速度如下所示，而且 重点是，每一代都可以向下相容喔！只是速度上会差很多就是了。目前主流都是使用 SATA3 这个接口速度可达 600MByte/s 的接口！

版本 SATA 1.0 SATA 2.0 SATA 3.0

带宽 （Gbit/s） 1.5 3 6

速度 （MByte/s） 150 300 600

因为 SATA 传输接口传输时，通过的数据演算法的关系，当传输 10 位编码时，仅有 8 位为数 据，其余 2 位为检验之用。因此带宽的计算上面， 使用的换算 （bit 转 Byte） 为 1:10 而不 是 1Byte=8bits 喔！上表的对应要稍微注意一下。另外，虽然这个 SATA3 接口理论上可达 600MBytes/s 的传输速度， 不过目前传统的硬盘由于其物理组成的限制，一般极限速度大约 在 150~200MByte/s 而已啦！所以厂商们才要发展固态硬盘啊！ ^_^

0.2 个人电脑架构与相关设备元件

53

鸟哥的 Linux 私房菜：基础学习篇 第四版

SAS接口
早期工作站或大型大脑上面，为了读写速度与稳定性，因此在这样的机器上面，大多使用的 是 SCSI 这种高阶的连接接口。 不过这种接口的速度后来被 SATA 打败了！但是 SCSI 有其 值得开发的功能，因此后来就有串行式 SCSI （Serial Attached SCSI, SAS） 的发展。这种 接口的速度比 SATA 来的快，而且连接的 SAS 硬盘的盘片转速与传输的速度也都比 SATA 硬 盘好！ 只是...好贵喔！而且一般个人电脑的主板上面通常没有内置 SAS 连接接口，得要通过 外接卡才能够支持。因此一般个人电脑主机还是以 SATA 接口为主要的磁盘连接接口啰。

版本 SAS 1 SAS 2 SAS 3

带宽 （Gbit/s） 3 6 12

300 600 1200

速度 （MByte/s）

因为这种接口的速度确实比较快喔！而且还支持例如热拔插等功能，因此，许多的设备连接 会以这种接口来链接！ 例如我们经常会听到的磁盘阵列卡的连接插槽，就是利用这种 SAS 接 口开发出来的支持的 SFF-8087 设备等等的 [18]。
USB接口

如果你的磁盘是外接式的接口，那么很可能跟主板链接的就是 USB 这种接口了！这也是目前 （2015） 最常见到的外接式磁盘接口了。 不过传统的 USB 速度挺慢的，即使是比较慢的传 统硬盘，其传输率大概兜还有 80~120MBytes/s ，但传统的 USB 2.0 仅有大约 60MBytes/s 的理论传输率， 通常实做在主板上面的连接口，竟然都仅有 30~40 MByte/s 而已呢！实在发 挥不出磁盘的性能啊！

为了改善 USB 的传输率，因此新一代的 USB 3.0 速度就快很多了！据说还有更新的 USB 3.1 正在发展中！这几代版本的带宽与速度制表如下 [19]：

版本 USB 1.0 USB 2.0 USB 3.0 USB 3.1

带宽 （Mbit/s） 12 480 5G 10G

速度 （MByte/s） 1.5 60 500 1000

跟 SATA 接口一样，不是理论速度到达该数值，实际上就可以跑到这么高！USB 3.0 虽然速 度很快，但如果你去市面上面买 USB 的传统磁盘或闪存盘， 其实他的读写速度还是差不多在 100MBytes/s 而已啦！不过这样就超级快了！因为一般 USB2.0 的闪存盘读写速度大约是 40MBytes/10MBytes 左右而已说。 在购买这方面的外接式磁盘时，要特别考虑喔！
固态硬盘 （Solid State Disk, SSD）

0.2 个人电脑架构与相关设备元件

54

鸟哥的 Linux 私房菜：基础学习篇 第四版
传统硬盘有个很致命的问题，就是需要驱动马达去转动盘片～这会造成很严重的磁盘读取延 迟！想想看，你得要知道数据在哪个扇区上面，然后再命令马达开始转， 之后再让磁头去读 取正确的数据。另外，如果数据放置的比较离散（扇区分佈比较广又不连续），那么读写的 速度就会延迟更明显！速度快不起来。因此， 后来就有厂商拿闪存去制作成大容量的设备， 这些设备的连接接口也是通过 SATA 或 SAS，而且外型还做的跟传统磁盘一样！所以， 虽然 这类的设备已经不能称为是磁盘 （因为没有磁头与盘片啊！都是内存！）。但是为了方便大 家称呼，所以还是称为磁盘！只是跟传统磁盘 （Hard Disk Drive, HDD） 不同， 就称为固态 硬盘 （Solid State Disk 或 Solid State Driver, SSD）。
固态硬盘最大的好处是，它没有马达不需要转动，而是通过内存直接读写的特性，因此除了 没数据延迟且快速之外，还很省电！ 不过早期的 SSD 有个很重要的致命伤，就是这些闪存 有“写入次数的限制”，因此通常 SSD 的寿命大概两年就顶天了！所以数据存放时， 需要考虑 到备份或者是可能要使用 RAID 的机制来防止 SSD 的损毁[20]！

Tips SSD 真的好快！鸟哥曾经买过 Intel 较顶级的 SSD 来做过服务器的读取系统盘，然后使 用类似 dd 的指令去看看读写的速度，竟然真的如同 intel 自己官网说的， 极速可以到达 500MBytes/s 哩！几乎就是 SATA3.0 的理论极限速度了！所以，近来在需要大量读取的环境 中，鸟哥都是使用 SSD 阵列来处理！
其实我们在读写磁盘时，通常没有连续读写，大部分的情况下都是读写一大堆小文件，因 此，你不要妄想传统磁盘一直转很少圈就可以读到所有的数据！ 通常很多小文件的读写，会 很耗硬盘，因为盘片要转好多圈！这也很花人类的时间啊！SSD 就没有这个问题！也因为如 此，近年来在测试磁盘的性能时， 有个很特殊的单位，称为每秒读写操作次数 （Input/Output Operations Per Second, IOPS）！这个数值越大，代表可操作次数较高，当 然性能好的很！
选购与运行须知
如果你想要增加一颗硬盘在你的主机里头时，除了需要考虑你的主板可接受的插槽接口 （SATA/SAS）之外，还有什么要注意的呢？
HDD 或 SSD 毕竟 HDD 与 SSD 的价格与容量真的差很多！不过，速度也差很多就是 了！因此，目前大家的使用方式大多是这样的，使用 SSD 作为系统盘， 然后数据储存大 多放置在 HDD 上面！这样系统运行快速 （SSD），而数据储存量也大 （HDD）。
容量 毕竟目前数据量越来越大，所以购买磁盘通常首先要考虑的就是容量的问题！目前 （2015）主流市场HDD容量已经到达 2TB以上， 甚至有的厂商已经生产高达 8TB 的产 品呢！硬盘可能可以算是一种消耗品，要注意重要数据还是得常常备份出来喔！ 至于 SSD 方面，目前的容量大概还是在 128~256GB 之间吧！

0.2 个人电脑架构与相关设备元件

55

鸟哥的 Linux 私房菜：基础学习篇 第四版
缓冲内存 硬盘上头含有一个缓冲内存，这个内存主要可以将硬盘内常使用的数据高速缓 存起来，以加速系统的读取性能。 通常这个缓冲内存越大越好，因为缓冲内存的速度要 比数据从硬盘盘中被找出来要快的多了！ 目前主流的产品可达64MB左右的内存大小喔。
转速 因为硬盘主要是利用主轴马达转动盘片来存取，因此转速的快慢会影响到性能。 主 流的台式机硬盘为每分钟7200转，笔记本电脑则是5400转。有的厂商也有推出高达 10000转的硬盘， 若有高性能的数据存取需求，可以考虑购买高转速硬盘。
运行须知 由于硬盘内部机械手臂上的磁头与硬盘盘的接触是很细微的空间， 如果有抖动 或者是脏污在磁头与硬盘盘之间就会造成数据的损毁或者是实体硬盘整个损毁～ 因此， 正确的使用电脑的方式，应该是在电脑通电之后，就绝对不要移动主机，并免抖动到硬 盘， 而导致整个硬盘数据发生问题啊！另外，也不要随便将插头拔掉就以为是顺利关 机！因为机械手臂必须要归回原位， 所以使用操作系统的正常关机方式，才能够有比较 好的硬盘保养啊！因为他会让硬盘的机械手臂归回原位啊！

Tips 可能因为环境的关系，电脑内部的风扇常常会卡灰尘而造成一些声响。很多朋友只要听 到这种声响都是二话不说的 “用力拍几下机箱”就没有声音了～现在你知道了，这么做的后果 常常就是你的硬盘容易坏掉！ 下次千万不要再这样做啰！
0.2.5 扩展卡与接口
你的服务器可能因为某些特殊的需求，因此需要使用主板之外的其他适配卡。所以主板上面 通常会预留多个扩充接口的插槽， 这些插槽依据历史沿革，包括 PCI/AGP/PCI-X/PCIe 等 等，但是由于 PCIe 速度快到太好用了，因此几乎所有的卡都以 PCIe 来设计了！ 但是有些比 较老旧的卡可能还需要使用啊，因此一般主板大多还是会保留一两个 PCI 插槽，其他的则是 以 PCIe 来设计。
由于各元件的价格直直落，现在主板上面通常已经整合了相当多的设备元件了！ 常见整合到 主板的元件包括声卡、网卡、USB控制卡、显卡、磁盘阵列卡等等。 你可以在主板上面发现 很多方形的芯片，那通常是一些个别的设备芯片喔。
不过，因为某些特殊的需求，有时你可能还是需要增加额外的扩展卡的。举例来说，我们如 果需要一部个人电脑连接多个网域时（Linux 服务器用途）， 恐怕就得要有多个网卡。当你 想要买网卡时，大卖场上面有好多耶！而且速度一样都是 giga 网卡 （Gbit/s），但价格差很 多耶！ 观察规格，主要有 PCIe x1 以及 PCI 接口的！你要买哪种接口呢？

0.2 个人电脑架构与相关设备元件

56

鸟哥的 Linux 私房菜：基础学习篇 第四版
观察一下 0.2.3 显卡的章节内，你会发现到 PCI 接口的理论传输率最高指到 133MBytes/s 而 已，而 PCIe 2.0 x1 就高达 500MBytes/s 的速度！ 鸟哥实测的结果也发现，PCI 接口的 giga 网卡极限速度大约只到 60MBytes/s 而已，而 PCIe 2.0 x1 的 giga 网卡确实可以到达大约 110MBytes/s 的速度！ 所以，购买设备时，还是要查清楚连接接口才行啦！
在 0.2.3 节也谈到 PCIe 有不同的信道数，基本上常见的就是 x1, x4, x8, x16 等，个人电脑主 板常见是 x16 的，一般中阶服务器则大多有多个 x8 的接口， x16 反而比较少见。这些接口 在主板上面的设计，主要是以插槽的长度来看的，例如华硕主板示意图中，左侧有 2 个 PCI 接口， 其他的则是 3 个 x16 的插槽，以及 2 个 x1 的插槽，看长度就知道了。
多信道卡 （例如 x8 的卡） 安装在少信道插槽 （例如 x4 的插槽） 的可用性
再回头看看图 0.2.1 的示意图，你可以发现 CPU 最多最多仅能支持 16 个 PCIe 3.0 的信道 数，因此在图示当中就明白的告诉你， 你可以设计（1）一个 x16 （2）或者是两个 x8 ， （3）或者是两个 x4 加上一个 x8 的方式来增加扩展卡！这是可以直接链接到 CPU 的信道！ 咦！ 那为何图 0.2.2 可以有 3 个 x16 的插槽呢？原因是前两个属于 CPU 支持的，后面两个 可能就是南桥提供的 PCIe 2.0 的接口了！ 那明明最多仅能支持一个 x16 的接口，怎么可能设 计 3 个 x16 呢？
因为要让所有的扩展卡都可以安插在主板上面，所以在比较中高阶的主板上面，他们都会做 出 x16 的插槽，但是该插槽内其实只有 x8 或 x4 的信道有用！ 其他的都是空的没有金手指 （电路的意思）～咦！那如果我的 x16 的卡安装在 x16 的插槽，但是这个插槽仅有 x4 的电 路设计，那我这张卡可以运行吗？ 当然可以！这就是 PCIe 的好处了！它可以让你这张卡仅 使用 x4 的电路来传送数据，而不会无法使用！只是...你的这张卡的极限性能，就会只剩下 4/16 = 1/4 啰！
因为一般服务器惯用的扩展卡，大多数都使用 PCIe x8 的接口 （因为也没有什么设备可以将 PCIe 3.0 的 x8 速度用完啊！）， 为了增加扩展卡的数量，因此服务器级的主板才会大多使 用到 x8 的插槽说！反正，要发挥扩展卡的能力，就得要搭配相对应的插槽才行啦！

Tips 鸟哥近年来在搞小型云教室，为了加速需要有 10G 的网卡，这些网卡标准的接口为 PCIe 2.0 x8 的接口。有部主机上面需要安插这样的卡三张才行， 结果该主机上面仅有一个 x16，一个 x8 以及一个 x4 的 PCIe 接口，其中 x4 的那个接口使用的是 x8 的插槽，所以好佳 在三张卡都可以安装在主板上面，且都可以运行！ 只是在极速运行时，实测的性能结果发 现，那个安插在 x4 接口的网卡性能降很多！所以才会发现这些问题！提供给大家参考参考！
0.2.6 主板

0.2 个人电脑架构与相关设备元件

57

鸟哥的 Linux 私房菜：基础学习篇 第四版
这个小节我们特别再将主板拿出来说明一下，特别要讲的就是芯片组与扩展卡之间的关系 了！
发挥扩展卡性能须考虑的插槽位置
如同图 0.2.1 所示，其实系统上面可能会有多个 x8 的插槽，那么到底你的卡插在哪个插槽上 面性能最好？ 我们以该图来说，如果你是安插在左上方跟 CPU 直接连线的那几个插槽，那 性能最佳！如果你是安插在左侧由上往下数的第五个 PCIe 2.0 x8 的插槽呢？ 那个插槽是与 南桥连接，所以你的扩展卡数据需要先进入南桥跟大家抢带宽，之后要传向 CPU 时，还得要 通过 CPU 与南桥的沟通管道， 那条管道称为 DMI 2.0。
根据 Intel 方面的数据来看，DMI 2.0 的传输率是 4GT/s，换算成文件传输量时，大约仅有 2GByte/s 的速度， 要知道，PCIe 2.0 x8 的理论速度已经达到 4GByte/s 了，但是与 CPU 的 信道竟然仅有 2GB，性能的瓶颈就这样发生在 CPU 与南桥的沟通上面！ 因此，卡安装在哪 个插槽上面，对性能而言也是影响很大的！所以插卡时，请详细阅读您主板上面的逻辑图示 啊 （类似本章的 Intel 芯片示意图）！ 尤其 CPU 与南桥沟通的带宽方面，特别重要喔！

Tips 因为鸟哥的 Linux 服务器，目前很多都需要执行一些虚拟化技术等会大量读写数据的服 务，所以需要额外的磁盘阵列卡来提供数据的存放！ 同时得要提供 10G 网络让内部的多部服 务器互相通过网络链接。过去没有这方面的经验时，扩展卡都随意乱插，反正能动就好！但 实际分析过性能之后， 哇！现在都不敢随便乱插了！性能差太多！每次在选购新的系统时， 也都会优先去查看芯片逻辑图～确认性能瓶颈不会卡住在主板上，这才下手去购买！ 惨痛的 经验产生惨痛的 $$ 飞走事件，所以，这里特别提出来跟大家分享的啦！
设备I/O位址与IRQ中断信道
主板是负责各个电脑元件之间的沟通，但是电脑元件实在太多了，有输出/输入/不同的储存设 备等等， 主板芯片组怎么知道如何负责沟通呐？这个时候就需要用到所谓的I/O位址与IRQ 啰！
I/O位址有点类似每个设备的门牌号码，每个设备都有他自己的位址，一般来说，不能有两个 设备使用同一个I/O位址， 否则系统就会不晓得该如何运行这两个设备了。而除了I/O位址之 外，还有个IRQ中断（Interrupt）这个咚咚。
如果I/O位址想成是各设备的门牌号码的话，那么IRQ就可以想成是各个门牌连接到邮件中心 （CPU）的专门路径啰！ 各设备可以通过IRQ中断信道来告知CPU该设备的工作情况，以方 便CPU进行工作分配的任务。 老式的主板芯片组IRQ只有15个，如果你的周边接口太多时可 能就会不够用， 这个时候你可以选择将一些没有用到的周边接口关掉，以空出一些IRQ来给 真正需要使用的接口喔！ 当然，也有所谓的sharing IRQ的技术就是了！

0.2 个人电脑架构与相关设备元件

58

鸟哥的 Linux 私房菜：基础学习篇 第四版
CMOS与BIOS
前面内存的地方我们有提过CMOS与BIOS的功能，在这里我们再来强调一下： CMOS主要的 功能为记录主板上面的重要参数， 包括系统时间、CPU电压与频率、各项设备的I/O位址与 IRQ等，由于这些数据的记录要花费电力，因此主板上面才有电池。 BIOS为写入到主板上某 一块 flash 或 EEPROM 的程序，他可以在开机的时候执行，以载入CMOS当中的参数， 并尝 试调用储存设备中的开机程序，进一步进入操作系统当中。BIOS程序也可以修改CMOS中的 数据， 每种主板调用BIOS设置程序的按键都不同，一般台式机常见的是使用[del]按键进入 BIOS设置画面。
连接周边设备的接口
主板与各项输出/输入设备的链接主要都是在主机机箱的后方，主要有：
PS/2接口：这原本是常见的键盘与鼠标的接口，不过目前渐渐被USB接口取代，甚至较 新的主板可能就不再提供 PS/2 接口了； USB接口：通常只剩下 USB 2.0 与 USB 3.0，为了方便区分，USB 3.0 为蓝色的插槽颜 色喔！ 声音输出、输入与麦克风：这个是一些圆形的插孔，而必须你的主板上面有内置音效芯 片时，才会有这三个东西； RJ-45网络头：如果有内置网络芯片的话，那么就会有这种接头出现。 这种接头有点类 似电话接头，不过内部有八蕊线喔！接上网络线后在这个接头上会有灯号亮起才对！ HDMI：如果有内置显示芯片的话，可能就会提供这个与屏幕连接的接口了！这种接口可 以同时传输声音与影像， 目前也是电视机屏幕的主流连接接口喔！
我们以华硕主板的链接接口来看的话，主要有这些：

图0.2.7、连接周边接 口
0.2.7 电源供应器
除了上面这些元件之外，其实还有一个很重要的元件也要来谈一谈，那就是电源供应器 （Power）。 在你的机箱内，有个大大的铁盒子，上头有很多电源线会跑出来，那就是电源 供应器了。 我们的CPU/RAM/主板/硬盘等等都需要用电，而近来的电脑元件耗电量越来越

0.2 个人电脑架构与相关设备元件

59

鸟哥的 Linux 私房菜：基础学习篇 第四版
高，以前很古早的230W电源已经不够用了， 有的系统甚至得要有500W以上的电源才能够运 行～真可怕～
电源供应器的价差非常大！贵一点的300W可以到4000 NT，便宜一点的300W只要500 NT不 到！ 怎么差这么多？没错～因为Power的用料不同，电源供应的稳定性也会差很多。如前所 述，电源供应器相当于你的心脏， 心脏差的话，活动力就会不足了！所以， 稳定性差的电源 供应器甚至是造成电脑不稳定的元凶呢！所以，尽量不要使用太差的电源供应器喔！
能源转换率
电源供应器本身也会吃掉一部份的电力的！如果你的主机系统需要 300W 的电力时，因为电 源供应器本身也会消耗掉一部份的电力， 因此你最好要挑选400W以上的电源供应器。电源供 应器出厂前会有一些测试数据，最好挑选高转换率的电源供应器。 所谓的高转换率指的是“输 出的功率/输入的功率”。意思是说，假如你的主板用电量为250W， 但是电源供应器其实已经 使用掉320W的电力，则转换率为：250/320=0.78的意思。 这个数值越高表示被电源供应 器“玩掉”的电力越少，那就符合能源效益了！^_^
0.2.8 选购须知
在购买主机时应该需要进行整体的考虑，很难依照某一项标准来选购的。 老实说，如果你的 公司需要一部服务器的话，建议不要自行组装，买品牌电脑的服务器比较好！ 这是因为自行 组装的电脑虽然比较便宜，但是每项设备之间的适合性是否完美则有待自行检测。
另外，在性能方面并非仅考虑CPU的能力而已，速度的快慢与“整体系统的最慢的那个设备有 关！”，如果你是使用最快速的Intel i7 系列产品，使用最快的 DDR3-1600 内存， 但是配上一 个慢慢的过时显卡，那么整体的3D速度性能将会卡在那个显卡上面喔！所以，在购买整套系 统时， 请特别留意需要全部的接口都考虑进去喔！尤其是当您想要升级时，要特别注意这个 问题， 并非所有的旧的设备都适合继续使用的。
例题：你的系统使用 i7 的 4790 CPU，使用了 DDR3-1600 内存，使用了 PCIe 2.0 x8 的磁盘 阵列卡，这张卡上面安装了 8 颗 3TB 的理论速度可达 200MByte/s 的硬盘 （假设为可加总速 度的 RAID0 配置）， 是安插在 CPU 控制芯片相连的插槽中。网络使用 giga 网卡，安插在 PCIe 2.0 x1 的接口上。在这样的设备中，上述的哪个环节速度可能是你的瓶颈？答：
DDR3-1600 的带宽可达：12.8GBytes/s 磁盘阵列卡理论传输率： PCIe 2.0 x8 为 4GBytes/s 磁盘每颗 200MBytes/s，共八颗，总效率为： 200MBytes*8 ~ 1.6GBytes/s 网络接口使用 PCIe 2.0 1x 所以接口速度可达 500MBytes/s，但是 Giga 网络最高为 125MBytes/s
通过上述分析，我们知道，速度最慢的为网络的 125MBytes/s ！所以，如果想要让整体性能 提升，网络恐怕就是需要克服的一环！
系统不稳定的可能原因

0.2 个人电脑架构与相关设备元件

60

鸟哥的 Linux 私房菜：基础学习篇 第四版
除此之外，到底那个元件特别容易造成系统的不稳定呢？有几个常见的系统不稳定的状态 是：
系统超频：这个行为很不好！不要这么做！ 电源供应器不稳： 这也是个很严重的问题，当您测试完所有的元件都没有啥大问题时， 记得测试一下电源供应器的稳定性！ 内存无法负荷：现在的内存品质差很多，差一点的内存，可能会造成您的主机在忙碌的 工作时， 产生不稳定或死机的现象喔！ 系统过热：“热”是造成电子零件运行不良的主因之一，如果您的主机在夏天容易死机， 冬天却还好，那么考虑一下加几个风扇吧！有助于机箱内的散热，系统会比较稳定喔！ “ 这个问题也是很常见的系统死机的元凶！”（PS1:鸟哥之前的一台服务器老是容易死机， 后来拆开机箱研究后才发现原来是北桥上面的小风扇坏掉了，导致北桥温度太高。后来 换掉风扇就稳定多了。 PS2:还有一次整个实验室的网络都停了！检查了好久，才发现原 来是网络交换器 switch 在夏天热到死机！后来只好用小电风扇一直吹他...）
Tips 事实上，要了解每个硬件的详细架构与构造是很难的！这里鸟哥仅是列出一些比较基本 的概念而已。 另外，要知道某个硬件的制造商是哪间公司时，可以看该硬件上面的信息。 举 例来说，主板上面都会列出这个主板的开发商与主板的型号，知道这两个信息就可以找到驱 动程序了。 另外，显卡上面有个小小的芯片，上面也会列出显卡厂商与芯片信息喔。

0.2 个人电脑架构与相关设备元件

61

鸟哥的 Linux 私房菜：基础学习篇 第四版
0.3 数据表示方式
事实上我们的电脑只认识0与1，记录的数据也是只能记录0与1而已，所以电脑常用的数据是 二进制的。 但是我们人类常用的数值运算是十进制，文字方面则有非常多的语言，台湾常用 的语言就有英文、中文（又分正体与简体中文）、日文等。 那么电脑如何记录与显示这些数 值/文字呢？就得要通过一系列的转换才可以啦！下面我们就来谈谈数值与文字的编码系统 啰！
0.3.1 数字系统
早期的电脑使用的是利用通电与否的特性的真空管，如果通电就是1，没有通电就是0， 后来 沿用至今，我们称这种只有0/1的环境为二进制制，英文称为binary的哩。所谓的十进制指的 是逢十进一位， 因此在个位数归为零而十位数写成1。所以所谓的二进制，就是逢二就前进一 位的意思。 那二进制怎么用呢？我们先以十进制来解释好了。如果以十进制来说，3456的意义为： 3456 = 3x103 + 4x102 + 5x101 + 6x100 特别注意：“任何数值的零次方为1”所以100的结果就是1啰。 同样的，将这个原理带入二进制 的环境中，我们来解释一下1101010的数值转为十进制的话，结果如下： 1101010=1x26 + 1x25 + 0x24 + 1x23 + 0x22 + 1x21 + 0x20 = 64 + 32 + 0x16 + 8 + 0x4 + 2 + 0x1 = 106 这样你了解二进制的意义了吗？二进制是电脑基础中的基础喔！了解了二进制后，八进位、 十六进制就依此类推啦！ 那么知道二进制转成十进制后，那如果有十进制数值转为二进制的 环境时，该如何计算？ 刚刚是乘法，现在则是除法就对了！我们同样的使用十进制的106转 成二进制来测试一下好了：

图0.3.1、十进制转二进制的方法 最后的写法就如同上面的红色箭头，由最后的数字向上写，因此可得到1101010的数字啰！ 这些数字的转换系统是非常重要的，因为电脑的加减乘除都是使用这些机制来处理的！ 有兴 趣的朋友可以再参考一下其他计算计概论的书籍中，关于1的补数/2的补数等运算方式喔！
0.3.2 文字编码系统

0.3 数据表示方式

62

鸟哥的 Linux 私房菜：基础学习篇 第四版
既然电脑都只有记录0/1而已，甚至记录的数据都是使用Byte/bit等单位来记录的，那么文字该 如何记录啊？ 事实上文字文件也是被记录为0与1而已，而这个文件的内容要被取出来查阅 时，必须要经过一个编码系统的处理才行。 所谓的“编码系统”可以想成是一个“字码对照表”， 他的概念有点像下面的图示：
图0.3.2、数据参考编码表的示意图 当我们要写入文件的文字数据时，该文字数据会由编码对照表将该文字转成数字后，再存入 文件当中。 同样的，当我们要将文件内容的数据读出时，也会经过编码对照表将该数字转成 对应的文字后，再显示到屏幕上。 现在你知道为何浏览器上面如果编码写错时，会出现乱码 了吗？这是因为编码对照表写错， 导致对照的文字产生误差之故啦！ 常用的英文编码表为ASCII系统，这个编码系统中， 每个符号（英文、数字或符号等）都会占 用1Bytes的记录， 因此总共会有28=256种变化。至于中文字当中的编码系统早期最常用的就 是big5这个编码表了。 每个中文字会占用2Bytes，理论上最多可以有216=65536，亦即最多 可达6万多个中文字。 但是因为big5编码系统并非将所有的位都拿来运用成为对照，所以并非 可达这么多的中文字码的。 目前big5仅定义了一万三千多个中文字，很多中文利用big5是无 法成功显示的～所以才会有造字程序说。 big5码的中文字编码对于某些数据库系统来说是很有问题的，某些字码例如“许、盖、功”等 字， 由于这几个字的内部编码会被误判为单/双引号，在写入还不成问题，在读出数据的对照 表时， 常常就会变成乱码。不只中文字，其他非英语系国家也常常会有这样的问题出现啊！ 为了解决这个问题，由国际组织ISO/IEC跳出来制订了所谓的Unicode编码系统， 我们常常称 呼的UTF8或万国码的编码就是这个咚咚。因为这个编码系统打破了所有国家的不同编码， 因 此目前网际网络社会大多朝向这个编码系统在走，所以各位亲爱的朋友啊，记得将你的编码 系统修订一下喔！

0.3 数据表示方式

63

鸟哥的 Linux 私房菜：基础学习篇 第四版
0.4 软件程序运行
鸟哥在上课时常常会开玩笑的问：“我们知道没有插电的电脑是一堆废铁，那么插了电的电脑 是什么？” 答案是：“一堆会电人的废铁”！这是因为没有软件的运行，电脑的功能就无从发挥 之故。 就好像没有了灵魂的躯体也不过就是行尸走肉，重点在于软件/灵魂啰！所以下面咱们 就得要了解一下“软件”是什么。
一般来说，目前的电脑系统将软件分为两大类，一个是系统软件，一个是应用程序。但鸟哥 认为我们还是得要了解一下什么是程序， 尤其是机器程序，了解了之后再来探讨一下为什么 现今的电脑系统需要“操作系统”这玩意儿呢！
0.4.1 机器程序与编译程序
我们前面谈到电脑只认识0与1而已，而且电脑最重要的运算与逻辑判断是在CPU内部， 而 CPU其实是具有微指令集的。因此，我们需要CPU帮忙工作时，就得要参考微指令集的内 容， 然后撰写让CPU读的懂的指令码给CPU执行，这样就能够让CPU运行了。
不过这样的流程有几个很麻烦的地方，包括：
需要了解机器语言：机器只认识0与1，因此你必须要学习直接写给机器看的语言！ 这个 地方相当的难呢！
需要了解所有硬件的相关功能函数：因为你的程序必须要写给机器看， 当然你就得要参 考机器本身的功能，然后针对该功能去撰写程序码。例如，你要让DVD影片能够放映， 那就得要参考DVD光驱的硬件信息才行。万一你的系统有比较冷门的硬件，光是参考技 术手册可能会昏倒～
程序不具有可携性：每个CPU都有独特的微指令集，同样的，每个硬件都有其功能函 数。 因此，你为A电脑写的程序，理论上是没有办法在B电脑上面运行的！而且程序码的 修改非常困难！ 因为是机器码，并不是人类看的懂得程序语言啊！
程序具有专一性：因为这样的程序必须要针对硬件功能函数来撰写， 如果已经开发了一 支浏览器程序，想要再开发文件管理程序时，还是得从头再参考硬件的功能函数来继续 撰写， 每天都在和“硬件”挑战！可能需要天天喝蛮牛了！@_@
那怎么解决啊？为了解决这个问题，电脑科学家设计出一种让人类看的懂得程序语言， 然后 创造一种“编译器”来将这些人类能够写的程序语言转译成为机器能看懂得机器码， 如此一来 我们修改与撰写程序就变的容易多了！目前常见的编译器有C, C++, Java, Fortran等等。 机器 语言与高阶程序语言的差别如下所示：

0.4 软件程序运行

64

鸟哥的 Linux 私房菜：基础学习篇 第四版

图 0.4.1、编译器的角色
从上面的图示我们可以看到高阶程序语言的程序码是很容易察看的！鸟哥已经将程序码（英 文）写成中文说～ 这样比较好理解啦！所以这样已经将程序的修改问题处理完毕了。 问题 是，在这样的环境下面我们还是得要考虑整体的硬件系统来设计程序喔！
举例来说，当你需要将运行的数据写入内存中，你就得要自行分配一个内存区块出来让自己 的数据能够填上去， 所以你还得要了解到内存的位址是如何定位的，啊！眼泪还是不知不觉 的流了下来... 怎么写程序这么麻烦啊！
为了要克服硬件方面老是需要重复撰写控制码的问题，所以就有操作系统（Operating System, OS）的出现了！ 什么是操作系统呢？下面就来谈一谈先！
0.4.2 操作系统
如同前面提到的，在早期想要让电脑执行程序就得要参考一堆硬件功能函数，并且学习机器 语言才能够撰写程序。 同时每次写程序时都必须要重新改写，因为硬件与软件功能不见得都 一致之故。那如果我能够将所有的硬件都驱动， 并且提供一个发展软件的参考接口来给工程 师开发软件的话，那发展软件不就变的非常的简单了？那就是操作系统啦！
操作系统核心（Kernel）
操作系统（Operating System, OS）其实也是一组程序， 这组程序的重点在于管理电脑的所 有活动以及驱动系统中的所有硬件。 我们刚刚谈到电脑没有软件只是一堆废铁，那么操作系 统的功能就是让CPU可以开始判断逻辑与运算数值、 让内存可以开始载入/读出数据与程序 码、让硬盘可以开始被存取、让网卡可以开始传输数据、 让所有周边可以开始运行等等。总 之，硬件的所有动作都必须要通过这个操作系统来达成就是了。

0.4 软件程序运行

65

鸟哥的 Linux 私房菜：基础学习篇 第四版
上述的功能就是操作系统的核心（Kernel）了！你的电脑能不能做到某些事情，都与核心有 关！ 只有核心有提供的功能，你的电脑系统才能帮你完成！举例来说，你的核心并不支持 TCP/IP的网络协定， 那么无论你购买了什么样的网卡，这个核心都无法提供网络能力的！ 但是单有核心我们使用者也不知道能作啥事的～因为核心主要在管控硬件与提供相关的能力 （例如存取硬盘、网络功能、CPU资源取得等）， 这些管理的动作是非常的重要的，如果使 用者能够直接使用到核心的话，万一使用者不小心将核心程序停止或破坏， 将会导致整个系 统的崩溃！因此核心程序所放置到内存当中的区块是受保护的！ 并且开机后就一直常驻在内 存当中。
Tips 所以整部系统只有核心的话，我们就只能看着已经准备好运行（Ready）的电脑系统， 但无法操作他！ 好像有点望梅止渴的那种感觉啦！这个时候就需要软件的帮忙了！
系统调用（System Call） 既然我的硬件都是由核心管理，那么如果我想要开发软件的话，自然就得要去参考这个核心 的相关功能！ 唔！如此一来不是从原本的参考硬件函数变成参考核心功能，还是很麻烦啊！ 有没有更简单的方法啊！ 为了解决这个问题，操作系统通常会提供一整组的开发接口给工程师来开发软件！ 工程师只 要遵守该开发接口那就很容易开发软件了！举例来说，我们学习C程序语言只要参考C程序语 言的函数即可， 不需要再去考虑其他核心的相关功能，因为核心的系统调用接口会主动的将 C程序语言的相关语法转成核心可以了解的任务函数， 那核心自然就能够顺利运行该程序 了！ 如果我们将整个电脑系统的相关软/硬件绘制成图的话，他的关系有点像这样：

0.4 软件程序运行

图0.4.2、操作系统的角色 66

鸟哥的 Linux 私房菜：基础学习篇 第四版
电脑系统主要由硬件构成，然后核心程序主要在管理硬件，提供合理的电脑系统资源分配 （包括CPU资源、内存使用资源等等）， 因此只要硬件不同（如x86架构与RISC架构的 CPU），核心就得要进行修改才行。 而由于核心只会进行电脑系统的资源分配，所以在上头 还需要有应用程序的提供，使用者才能够操作系统的。
为了保护核心，并且让程序设计师比较容易开发软件，因此操作系统除了核心程序之外，通 常还会提供一整组开发接口， 那就是系统调用层。软件开发工程师只要遵循公认的系统调用 参数来开发软件，该软件就能够在该核心上头运行。 所以你可以发现，软件与核心有比较大 的关系，与硬件关系则不大！硬件也与核心有比较大的关系！ 至于与使用者有关的，那就是 应用程序啦！

Tips 在定义上，只要能够让计算机硬件正确无误的运行，那就算是操作系统了。所以说， 操 作系统其实就是核心与其提供的接口工具，不过就如同上面讲的，因为最阳春的核心缺乏了 与使用者沟通的友好接口， 所以在目前，一般我们提到的“操作系统”都会包含核心与相关的 使用者应用软件呢！
简单的说，上面的图示可以带给我们下面的概念：
操作系统的核心层直接参考硬件规格写成， 所以同一个操作系统程序不能够在不一样的 硬件架构下运行。举例来说，个人电脑版的Windows 8.1 不能直接在 ARM 架构 （手机 与平板硬件） 的电脑下运行。
操作系统只是在管理整个硬件资源，包括CPU、内存、输入输出设备及文件系统文件。 如果没有其他的应用程序辅助，操作系统只能让电脑主机准备妥当（Ready）而已！并无 法运行其他功能。 所以你现在知道为何Windows上面要达成网页影像的运行还需要类似 PhotoImpact或Photoshop之类的软件安装了吧？
应用程序的开发都是参考操作系统提供的开发接口， 所以该应用程序只能在该操作系统 上面运行而已，不可以在其他操作系统上面运行的。 现在您知道为何去购买线上游戏的 光盘时，光盘上面会明明白白的写着该软件适合用于哪一种操作系统上了吧？ 也该知道 某些游戏为何不能够在Linux上面安装了吧？
核心功能
既然核心主要是在负责整个电脑系统相关的资源分配与管理，那我们知道其实整部电脑系统 最重要的就是CPU与内存， 因此，核心至少也要有这些功能的：
系统调用接口（System call interface） 刚刚谈过了，这是为了方便程序开发者可以轻易 的通过与核心的沟通，将硬件的资源进一步的利用， 于是需要有这个简易的接口来方便 程序开发者。

0.4 软件程序运行

67

鸟哥的 Linux 私房菜：基础学习篇 第四版
程序管理（Process control） 总有听过所谓的“多任务环境”吧？一部电脑可能同时间有很 多的工作跑到CPU等待运算处理， 核心这个时候必须要能够控制这些工作，让CPU的资 源作有效的分配才行！另外， 良好的CPU调度机制（就是CPU先运行那个工作的排列顺 序）将会有效的加快整体系统性能呢！
内存管理（Memory management） 控制整个系统的内存管理，这个内存控制是非常重 要的，因为系统所有的程序码与数据都必须要先存放在内存当中。 通常核心会提供虚拟 内存的功能，当内存不足时可以提供内存交换（swap）的功能哩。 文件系统管理（Filesystem management） 文件系统的管理，例如数据的输入输出 （I/O）等等的工作啦！还有不同文件格式的支持啦等等， 如果你的核心不认识某个文件 系统，那么您将无法使用该文件格式的文件啰！例如：Windows 98就不认识NTFS文件 格式的硬盘； 设备的驱动（Device drivers） 就如同上面提到的，硬件的管理是核心的主要工作之一， 当然啰，设备的驱动程序就是核心需要做的事情啦！ 好在目前都有所谓的“可载入模 块”功能，可以将驱动程序编辑成模块，就不需要重新的编译核心啦！ 这个也会在后续的 第十九章当中提到的！
Tips 事实上，驱动程序的提供应该是硬件厂商的事情！硬件厂商要推出硬件时，应该要自行 参考操作系统的驱动程序开发接口， 开发完毕后将该驱动程序连同硬件一同贩卖给使用者才 对！举例来说，当你购买显卡时， 显卡包装盒都会附上一片光盘，让你可以在进入Windows 之后进行驱动程序的安装啊！
操作系统与驱动程序
老实说，驱动程序可以说是操作系统里面相当重要的一环了！不过，硬件可是持续在进步当 中的！ 包括主板、显卡、硬盘等等。那么比较晚推出的较新的硬件，例如显卡，我们的操作 系统当然就不认识啰！ 那操作系统该如何驱动这块新的显卡？为了克服这个问题，操作系统 通常会提供一个开发接口给硬件开发商， 让他们可以根据这个接口设计可以驱动他们硬件 的“驱动程序”，如此一来，只要使用者安装驱动程序后， 自然就可以在他们的操作系统上面 驱动这块显卡了。

0.4 软件程序运行

68

鸟哥的 Linux 私房菜：基础学习篇 第四版

图0.4.3、驱动程序与操作系统的关 系
由上图我们可以得到几个小重点：
操作系统必须要能够驱动硬件，如此应用程序才能够使用该硬件功能； 一般来说，操作系统会提供开发接口，让开发商制作他们的驱动程序； 要使用新硬件功能，必须要安装厂商提供的驱动程序才行； 驱动程序是由厂商提供的，与操作系统开发者无关。
所以，如果你想要在某个操作系统上面安装一张新的显卡，那么请要求该硬件厂商提供适当 的驱动程序吧！ ^_^！ 为什么要强调“适当的驱动程序”呢？ 因为驱动程序仍然是依据操作系 统而开发的， 所以，给Windows用的驱动程序当然不能使用于Linux的环境下了。
0.4.3 应用程序
应用程序是参考操作系统提供的开发接口所开发出来软件，这些软件可以让使用者操作，以 达到某些电脑的功能利用。 举例来说，办公室软件（Office）主要是用来让使用者办公用的； 影像处理软件主要是让使用者用来处理影音数据的； 浏览器软件主要是让使用者用来上网浏 览用的等等。
需要注意的是，应用程序是与操作系统有关系的，如同上面的图示当中的说明喔。因此，如 果你想要购买新软件， 请务必参考软件上面的说明，看看该软件是否能够支持你的操作系统 啊！举例来说，如果你想要购买线上游戏光盘， 务必参考一下该光盘是否支持你的操作系 统，例如是否支持Windows XP/Windows Vista/MAC/Linux等等。 不要购买了才发现该软件无 法安装在你的操作系统上喔！
我们拿常见的微软公司的产品来说明。你知道Windows 8.1, Office 2013之间的关系了吗？
Windows 8.1 是一套操作系统，他必须先安装到个人电脑上面，否则电脑无法开机运 行； Windows 7 与Windows 8.1 是两套不同的操作系统，所以能在Win 7上安装的软件不见得 可在Win 8.1上安装； Windows 8.1安装好后，就只能拥有很少的功能，并没有办公室软件； Office 2013是一套应用程序，要安装前必须要了解他能在哪些操作系统上面运行。

0.4 软件程序运行

69

鸟哥的 Linux 私房菜：基础学习篇 第四版

0.4 软件程序运行

70

鸟哥的 Linux 私房菜：基础学习篇 第四版

0.5 重点回顾
计算机的定义为：“接受使用者输入指令与数据，经由中央处理器的数学与逻辑单元运算 处理后，以产生或储存成有用的信息”； 电脑的五大单元包括：输入单元、输出单元、控制单元、算数逻辑单元、存储单元五大 部分。其中CPU占有控制、算术逻辑单元，存储单元又包含内存与辅助内存； 数据会流进/流出内存是CPU所发布的控制命令，而CPU实际要处理的数据则完全来自于 内存； CPU依设计理念主要分为：精简指令集（RISC）与复杂指令集（CISC）系统； 关于CPU的频率部分：外频指的是CPU与外部元件进行数据传输时的速度，倍频则是 CPU内部用来加速工作性能的一个倍数， 两者相乘才是CPU的频率速度； 新的 CPU 设计中，已经将北桥的内存控制芯片整合到 CPU 内，而 CPU 与内存、显卡 沟通的总线通常称为系统总线。 南桥就是所谓的输入输出（I/O）总线，主要在联系硬 盘、USB、网卡等周边设备； CPU每次能够处理的数据量称为字组大小（word size），字组大小依据CPU的设计而有 32位与64位。 我们现在所称的电脑是32或64位主要是依据这个 CPU解析的字组大小而 来的！ 个人电脑的内存主要元件为动态随机存取内存（Dynamic Random Access Memory, DRAM）， 至于CPU内部的第二层高速缓存则使用静态随机存取内存（Static Random Access Memory, SRAM）； BIOS（Basic Input Output System）是一套程序，这套程序是写死到主板上面的一个内 存芯片中， 这个内存芯片在没有通电时也能够将数据记录下来，那就是只读存储器 （Read Only Memory, ROM）； 目前主流的外接卡接口大多为 PCIe 接口，且最新为 PCIe 3.0，单信道速度高达 1GBytes/s 常见的显卡连接到屏幕的接口有 HDMI/DVI/D-Sub/Display port 等等。HDMI 可同时传送 影像与声音。 传统硬盘的组成为：圆形盘片、机械手臂、 磁头与主轴马达所组成的，其中盘片的组成 为扇区、磁道与柱面； 磁盘连接到主板的接口大多为 SATA 或 SAS，目前台式机主流为 SATA 3.0，理论极速可 达 600MBytes/s。 常见的文字编码为 ASCII，繁体中文编码主要有 Big5 及 UTF8 两种，目前主流为 UTF8 操作系统（Operating System, OS）其实也是一组程序， 这组程序的重点在于管理电脑 的所有活动以及驱动系统中的所有硬件。 电脑主要以二进制作为单位，常用的磁盘容量单位为Bytes，其单位换算为1 Byte = 8bits。 最阳春的操作系统仅在驱动与管理硬件，而要使用硬件时，就得需要通过应用软件或者 是壳程序（shell）的功能， 来调用操作系统操纵硬件工作。目前称为操作系统的，除了 上述功能外，通常已经包含了日常工作所需要的应用软件在内了。

0.5 重点回顾

71

鸟哥的 Linux 私房菜：基础学习篇 第四版

0.5 重点回顾

72

鸟哥的 Linux 私房菜：基础学习篇 第四版
0.6 本章习题
根据本章内文的说明，请找出目前全世界跑的最快的超级计算机的：（1）系统名称 （2）所在位置 （3）使用的 CPU 型号与规格 （4）总共使用的 CPU 数量 （5）全功率 操作 1 天时，可能耗用的电费 （请上台电网站查询相关电价来计算）。
动动手实作题：假设你不知道你的主机内部的各项元件数据，请拆开你的主机机箱，并 将内部所有的元件拆开，并且依序列出：
CPU的厂牌、型号、最高频率； 内存的容量、接口 （DDR/DDR2/DDR3 等）； 显卡的接口 （AGP/PCIe/内置） 与容量 主板的厂牌、南北桥的芯片型号、BIOS的厂牌、有无内置的网卡或声卡等 硬盘的连接接口 （SATA/SAS等）、硬盘容量、转速、缓冲内存容量等。然后再将 他组装回去。注意，拆装前务必先取得你主板的说明书，因此你可能必须要上网查 询上述的各项数据。 利用软件：假设你不想要拆开主机机箱，但想了解你的主机内部各元件的信息时，该如 何是好？ 如果使用的是Windows操作系统，可使用CPUZ（http://www.cpuid.com/cpuz.php）这套软件，如果是Linux环境下，可以使用“cat /proc/cpuinfo” 及使用“lspci”来查阅各项元件的型号；
如本章图0.2.1所示，找出第四代 Intel i7 4790 CPU 的： （1）与南桥沟通的 DMI 带宽有 多大？ （2）第二层高速缓存的容量多大？ （3）最大 PCIe 信道数量有多少？并据以说 明主板上面 PCIe 插槽的数量限制。（请 google 此 CPU 相关数据即可发现）
由 google 查询 Intel SSD 520 固态硬盘相关的功能表，了解 （1）连接接口、（2）最大 读写速度及 （3）最大随机读写数据 （IOPS） 的数据。

0.6 本章习题

73

鸟哥的 Linux 私房菜：基础学习篇 第四版

0.7 参考资料与延伸阅读
[1]名片型电脑，或单版电脑： 香蕉派台湾官网：http://tw.bananapi.org/ Xapple pi 粉丝团：https://www.facebook.com/roseapplepi
[2]可穿戴式电脑：http://en.wikipedia.org/wiki/Wearable_computer [3]对于CPU的原理有兴趣的读者，可以参考维基百科的说明： 英文 CPU（http://en.wikipedia.org/wiki/CPU） 中文CPU（http://zh.wikipedia.org/wiki/中央处 理器）。 [4]图片参考： Wiki book: http://en.wikibooks.org/wiki/IB/Group_4/Computer_Science/Computer_Organisation 作 者：陈锦辉，“计算机概论-探索未来2008”，金禾信息，2007出版 [5]更详细的RISC架构可以参考维基百科： http://zh.wikipedia.org/w/index.php?title=精简 指令集&variant=zh-cn 相关的 CPU 种类可以参考： Oracle SPARC: http://en.wikipedia.org/wiki/SPARC IBM Power CPU: http://en.wikipedia.org/wiki/IBM_POWER_microprocessors [6]关于ARM架构的说明，可以参考维基百科： http://zh.wikipedia.org/w/index.php? title=ARM架构&variant=zh-cn [7]更详细的CISC架构可参考维基百科： http://zh.wikipedia.org/w/index.php? title=CISC&variant=zh-cn [8]更详细的x86架构发展史可以参考维基百科： http://zh.wikipedia.org/w/index.php? title=X86&variant=zh-cn [9]用来观察 CPU 相关信息的 CPU-Z 软件网站： http://www.cpuid.com/softwares/cpuz.html [10]Intel i7 4790 CPU 的详细规格介绍 http://ark.intel.com/zh-cn/products/80806/IntelCore-i7-4790-Processor-8M-Cache-up-to-4_00-GHz [11]DDR 内存的详细规格介绍 http://zh.wikipedia.org/wiki/DDR_SDRAM [12]相关的固件说明可参考维基百科： http://zh.wikipedia.org/w/index.php?title=固件 &variant=zh-hant [13]相关 EEPROM 可以参考维基百科： http://zh.wikipedia.org/w/index.php? title=EEPROM&variant=zh-cn [14]相关 BIOS 的说明可以参考维基百科： http://zh.wikipedia.org/w/index.php? title=BIOS&variant=zh-cn [15]相关 PCIe 的说明可以参考维基百科： http://en.wikipedia.org/wiki/PCI_Express [16]关于盘片数据的说明：Zone bit recording ： http://en.wikipedia.org/wiki/Zone_bit_recording [17]关于 SATA 磁盘接口的 wiki 说明 ： http://zh.wikipedia.org/wiki/SATA [18]关于 SAS 磁盘接口的 wiki 说明 ： http://en.wikipedia.org/wiki/SCSI#SCSIEXPRESS http://en.wikipedia.org/wiki/Serial_attached_SCSI

0.7 参考资料与延伸阅读

74

鸟哥的 Linux 私房菜：基础学习篇 第四版
[19]关于 USB 接口的 wiki 说明 ： http://en.wikipedia.org/wiki/USB [20]关于 SSD 的 wiki 说明 ： http://en.wikipedia.org/wiki/Solid-state_drive 感谢：本章当中出现很多图示，很多是从Tom's Hardware（http://www.tomshardware.com/）网站取得的，在此特别感谢！
2008/07/22：利用暑假期间足足写了快要两个星期这篇才写完！好多图示都不知道如何呈现 比较漂亮～@_@ 2008/07/29：又加入了SATA/IDE的连线排线，还有一些额外的图示。 2009/08/03：加入电源供应器是心脏一词的说明 2009/08/03：更正原本 BIOS 只放于 ROM 的数据，新的 BIOS 通常放于 EEPROM 或 Flash 内存中。 2010/10/19：感谢讨论区网友 186003415a 兄的回报，发现 DDR II 的外频写错了！是 200MHz 才对喔！ 2015/04/16：旧 版针对 CentOS5 时所作的旧版文章：旧的计概内容 2015/04/16：删除了一些较旧的数据， 如 IDE，增加了不少新的东西！并感谢讨论区 littlebat 兄的意见，修改了不少的磁盘数据

0.7 参考资料与延伸阅读

75

鸟哥的 Linux 私房菜：基础学习篇 第四版
第一章、Linux是什么与如何学习
最近更新日期：20// 众所皆知的，Linux的核心原型是1991年由托瓦兹（Linus Torvalds）写出来的，但是托瓦兹 为何可以写出Linux这个操作系统？ 为什么他要选择386的计算机来开发？为什么Linux的发展 可以这么迅速？又为什么Linux是免费且可以自由学习的？ 以及目前为何有这么多的Linux套 件版本（distributions）呢？了解这些东西后，才能够知道为何Linux可以免除专利软件之争， 并且了解到Linux为何可以同时在个人计算机与大型主机上面大放异彩！ 所以，在实际进入 Linux的世界前，就让我们来谈一谈这些有趣的历史故事吧！ ^_^

第一章、Linux是什么与如何学习

76

鸟哥的 Linux 私房菜：基础学习篇 第四版
1.1 Linux是什么
我们知道Linux这玩意儿是在计算机上面运行的，所以说Linux就是一组软件。问题是这个软件 是操作系统还是应用程序？ 且Linux可以在哪些种类的计算机硬件上面运行？而Linux源自哪 里？为什么 Linux 还不用钱？这些我们都得来谈一谈先！免得下次人家问你， 为什么复制软 件不会违法时，你会答不出来啊！^_^
1.1.1 Linux是什么？操作系统/应用程序？
我们在第零章、计算机概论里面有提到过整个计算机系统的概念， 计算机主机是由一堆硬件 所组成的，为了有效率的控制这些硬件资源，于是乎就有操作系统的产生了。 操作系统除了 有效率的控制这些硬件资源的分配，并提供计算机运行所需要的功能（如网络功能）之外， 为了要提供程序设计师更容易开发软件的环境，所以操作系统也会提供一整组系统调用接口 来给软件设计师开发用喔！ 知道为什么要讲这些了吗？嘿嘿！没错，因为Linux就是一套操作系统！如同下图所示， Linux就是核心与系统调用接口那两层。至于应用程序算不算Linux呢？当然不算啦！这点要特 别注意喔！

图1.1.1、操作系统的角色
由上图中我们可以看到其实核心与硬件的关系非常的强烈。早期的Linux是针对386来开发 的， 由于Linux只是一套操作系统并不含有其他的应用程序，因此很多工程师在下载了 Linux 核心并且实际安装之后，就只能看着计算机开始运行了！接下来这些高级工程师为了自己的 需求，再在Linux上面安装他们所需要的软件就是了。

1.1 Linux是什么

77

鸟哥的 Linux 私房菜：基础学习篇 第四版
Tips Torvalds先生在 1991 年写出Linux 核心的时候，其实该核心仅能“驱动386所有的硬件”而 已， 所谓的“让386计算机开始运行，并且等待使用者指令输入”而已，事实上，当时能够在 Linux上面跑的软件还很少呢！
由于不同的硬件他的功能函数并不相同，例如IBM的Power CPU与Intel的x86架构就是不一 样！ 所以同一套操作系统是无法在不同的硬件平台上面运行的！举例来说，如果你想要让x86 上面跑的那套操作系统也能够在Power CPU上运行时，就得要将该操作系统进行修改才行。 如果能够参考硬件的功能函数并据以修改你的操作系统程序码， 那经过改版后的操作系统就 能够在另一个硬件平台上面运行了。 这个动作我们通常就称为“软件移植”了！
例题：请问Windows操作系统能否在苹果公司的MAC计算机上面安装与运行？答：由上面的 说明中，我们知道硬件是由“核心”来控制的，而每种操作系统都有他自己的核心。 在2006年 以前的苹果计算机公司是请IBM公司帮忙开发硬件（所谓的Power CPU）， 而苹果计算机公 司则在该硬件架构上发展自家的操作系统（就是俗称的MAC是也）。Windows则是开发在x86 架构上的操作系统之一， 因此Windows是没有办法安装到MAC计算机硬件上面的。
不过，在2006年以后，苹果计算机转而请Intel设计其硬件架构，亦即其硬件架构已经转为x86 系统， 因此在2006年以后的苹果计算机若使用x86架构时，其硬件则“可能”可以安装Windows 操作系统了。 不过，你可能需要自己想些方式来处理该硬件的兼容性啰！

Tips Windows操作系统本来就是针对个人计算机x86架构的硬件去设计的，所以他当然只能 在x86的个人计算机上面运行， 在不同的硬件平台当然就无法运行了。也就是说，每种操作系 统都是在他专门的硬件机器上面运行的喔！这点得要先了解。 不过，Linux由于是Open Source的操作系统，所以他的程序码可以被修改成适合在各种机器上面运行的， 也就是说， Linux是具有“可移植性”，这可是很重要的一个功能喔！ ^_^
Linux提供了一个完整的操作系统当中最底层的硬件控制与资源管理的完整架构， 这个架构是 沿袭Unix良好的传统来的，所以相当的稳定而功能强大！此外， 由于这个优良的架构可以在 目前的个人计算机（x86系统）上面跑， 所以很多的软件开发者渐渐的将他们的工作心血移转 到这个架构上面，所以 Linux 操作系统也有很多的应用软件啦！
虽然Linux仅是其核心与核心提供的工具，不过由于核心、核心工具与这些软件开发者提供的 软件的整合， 使得Linux成为一个更完整的、功能强大的操作系统啰！约略了解Linux是何物 之后，接下来，我们要谈一谈， “为什么说Linux是很稳定的操作系统呢？他是如何来的？”
1.1.2 Linux之前，Unix的历史

1.1 Linux是什么

78

鸟哥的 Linux 私房菜：基础学习篇 第四版
早在Linux出现之前的二十年（大约在1970 年代），就有一个相当稳定而成熟的操作系统存在 了！ 那就是Linux的老大哥“Unix”是也！怎么这么说呢？他们这两个家伙有什么关系呀？这里 就给他说一说啰！
众所皆知的，Linux的核心是由Linus Torvalds在1991年的时候给他开发出来的， 并且丢到网 络上提供大家下载，后来大家觉得这个小东西（Linux Kernel）相当的小而精巧， 所以慢慢的 就有相当多的朋友投入这个小东西的研究领域里面去了！ 但是为什么这个小东西这么棒呢？ 又为什么大家都可以免费的下载这个东西呢？ 嗯！等鸟哥慢慢的唬xx....喔不！听我慢慢的道 来！
1969年以前：一个伟大的梦想--Bell,MIT与GE的“Multics”系统
早期的计算机并不像现在的个人计算机一样普遍，他可不是一般人碰的起的呢～ 除非是军事 或者是高科技用途，或者是学术单位的前瞻性研究，否则真的很难接触到。 非但如此，早期 的计算机架构还很难使用，除了运算速度并不快之外，操作接口也很困扰的！ 因为那个时候 的输入设备只有读卡机、输出设备只有打印机， 使用者也无法与操作系统互动（批次型操作 系统）。
在那个时候，写程序是件很可怜的事情，因为程序设计者，必须要将程序相关的信息在读卡 纸上面打洞， 然后再将读卡纸插入读卡机来将信息读入主机中运算。光是这样就很麻烦了， 如果程序有个小地方写错， 哈哈！光是重新打卡就很惨，加上主机少，使用者众多，光是等 待，就耗去很多的时间了！
在那之后，由于硬件与操作系统的改良，使得后来可以使用键盘来进行信息的输入。 不过， 在一间学校里面，主机毕竟可能只有一部，如果多人等待使用，那怎么办？大家还是得要等 待啊！ 好在1960年代初期麻省理工学院（MIT）发展了所谓的： “相容分时系统（Compatible Time-Sharing System, CTSS）”， 它可以让大型主机通过提供数个终端机（terminal）以连 线进入主机，来利用主机的资源进行运算工作。 架构有点像这样：

性图示 1.1 Linux是什么

图1.1.2、早期主机与终端机的相关 79

鸟哥的 Linux 私房菜：基础学习篇 第四版
Tips 这个相容分时系统可以说是近代操作系统的始祖呢！他可以让多个使用者在某一段时间 内分别使用CPU的资源， 感觉上你会觉得大家是同时使用该主机的资源！事实上，是CPU在 每个使用者的工作之间进行切换， 在当时，这可是个划时代的技术喔！
如此一来，无论主机在哪里，只要在终端机前面进行输入输出的作业，就可利用主机提供的 功能了。 不过，需要注意的是，此时终端机只具有输入/输出的功能，本身完全不具任何运算 或者软件安装的能力。 而且，比较先进的主机大概也只能提供30个不到的终端机而已。
为了更加强化大型主机的功能，以让主机的资源可以提供更多使用者来利用，所以在1965年 前后， 由贝尔实验室（Bell）、麻省理工学院（MIT）及奇异公司（GE, 或称为通用电器）共 同发起了Multics的计划 [1]， Multics计划的目的是想要让大型主机可以达成提供300个以上的 终端机连线使用的目标。 不过，到了1969年前后，计划进度落后，资金也短缺，所以该计划 虽然继续在研究，但贝尔实验室还是退出了该计划的研究工作。 （Multics有复杂、多数的意 思存在。）

Tips 最终Multics还是有成功的发展出他们的系统，完整的历史说明可以参考： http://www.multicians.org/网站内容。 Multics计划虽然后来没有受到很大的重视，但是他培养 出来的人材是相当优秀的！ ^_^
1969年：Ken Thompson的小型file server system
在认为Multics计划不可能成功之后，贝尔研究室就退出该计划。不过，原本参与Multics计划 的人员中，已经从该计划当中获得一些点子， Ken Thompson [2] 就是其中一位！
Thompson因为自己的需要，希望开发一个小小的操作系统以提供自己的需求。 在开发时， 有一部DEC （Digital Equipment Corporation）公司推出的PDP-7刚好没人使用， 于是他就准 备针对这部主机进行操作系统核心程序的撰写。本来Thompson应该是没时间的（有家有小孩 的宿命？）， 无巧不巧的是，在1969年八月份左右，刚好Thompson的妻儿去了美西探亲， 于是他有了额外的一个月的时间好好的待在家将一些构想实现出来！
经过四个星期的奋斗，他终于以组合语言（Assembler）写出了一组核心程序，同时包括一些 核心工具程序， 以及一个小小的文件系统。那个系统就是Unix的原型！ 当时Thompson将 Multics庞大的复杂系统简化了不少，于是同实验室的朋友都戏称这个系统为：Unics。（当时 尚未有Unix的名称）
Thompson 的这个文件系统有两个重要的概念，分别是：
所有的程序或系统设备都是文件 不管建构编辑器还是附属文件，所写的程序只有一个目的，且要有效的完成目标。

1.1 Linux是什么

80

鸟哥的 Linux 私房菜：基础学习篇 第四版 这些概念在后来对于Linux的发展有相当重要的影响喔！

Tips 套一句常听到的广告词：“科技始终来自于人性”，当初Thompson会写这套Unix核心程 序， 却是想要移植一套名为“太空旅游”的游戏呢！ ^_^
1973年：Unix的正式诞生，Ritchie等人以C语言写出第一个正式Unix核心
由于Thompson写的那个操作系统实在太好用了，所以在贝尔实验室内部广为流传，并且数度 经过改版。 但是因为Unics本来是以组合语言写成的，而如第零章计算机概论谈到的， 组合 语言具有专一性，加上当时的计算机机器架构都不太相同，所以每次要安装到不同的机器都 得要重新编写组合语言，真不方便！
后来Thompson与Ritchie合作想将Unics改以高阶程序语言来撰写。当时现成的高阶程序语言 有B语言。 但是由B语言所编译出来的核心性能不是很好。后来Dennis Ritchie [3] 将B语言重 新改写成C语言，再以C语言重新改写与编译Unics的核心， 最后正名与发行出Unix的正式版 本！

Tips 这群高级骇客实在很厉害！因为自己的需求来开发出这么多好用的工具！ C程序语言开 发成功后，甚至一直沿用至今呢！你说厉不厉害啊！这个故事也告诉我们，不要小看自己的 潜能喔！ 你想作的，但是现实生活中没有的，就动手自己搞一个来玩玩吧！
由于贝尔实验室是隶属于美国电信大厂AT&T公司的， 只是AT&T当时忙于其他商业活动，对 于Unix并不支持也不排斥。此外，Unix在这个时期的发展者都是贝尔实验室的工程师， 这些 工程师对于程序当然相当有研究，所以，Unix在此时当然是不容易被一般人所接受的！不过 对于学术界的学者来说， 这个 Unix 真是学者们进行研究的福音！因为程序码可改写并且可作 为学术研究之用嘛！
需要特别强调的是，由于Unix是以较高阶的C语言写的，相对于组合语言需要与硬件有密切的 配合， 高阶的C语言与硬件的相关性就没有这么大了！所以，这个改变也使得Unix很容易被 移植到不同的机器上面喔！
1977年：重要的Unix分支--BSD的诞生

1.1 Linux是什么

81

鸟哥的 Linux 私房菜：基础学习篇 第四版
虽然贝尔属于AT&T，但是AT&T此时对于Unix是采取较开放的态度，此外，Unix是以高阶的C 语言写成的， 理论上是具有可移植性的！亦即只要取得Unix的源代码，并且针对大型主机的 特性加以修订原有的源代码（Source Code）， 就可能将Unix移植到另一部不同的主机上头 了。所以在1973年以后，Unix便得以与学术界合作开发！ 最重要的接触就是与加州柏克莱 （Berkeley）大学的合作了。
柏克莱大学的Bill Joy [4]在取得了Unix的核心源代码后，着手修改成适合自己机器的版本， 并 且同时增加了很多工具软件与编译程序，最终将它命名为Berkeley Software Distribution （BSD）。这个BSD是Unix很重要的一个分支，Bill Joy也是Unix业者“Sun（升阳）”这家公司 的创办者！ Sun公司即是以BSD发展的核心进行自己的商业Unix版本的发展的。 （后来可以 安装在x86硬件架构上面FreeBSD即是BSD改版而来！）
1979年：重要的 System V 架构与版权宣告
由于Unix的高度可移植性与强大的性能，加上当时并没有版权的纠纷， 所以让很多商业公司 开始了Unix操作系统的发展，例如AT&T自家的System V、IBM的AIX以及HP与DEC等公司， 都有推出自家的主机搭配自己的Unix操作系统。
但是，如同我们前面提到的，操作系统的核心（Kernel）必须要跟硬件配合， 以提供及控制 硬件的资源进行良好的工作！而在早期每一家生产计算机硬件的公司还没有所谓的“协定”的概 念， 所以每一个计算机公司出产的硬件自然就不相同啰！因此他们必须要为自己的计算机硬 件开发合适的Unix系统。 例如在学术机构相当有名的Sun、Cray与HP就是这一种情况。 他们 开发出来的Unix操作系统以及内含的相关软件并没有办法在其他的硬件架构下工作的！ 另 外，由于没有厂商针对个人计算机设计Unix系统，因此，在早期并没有支持个人计算机的 Unix操作系统的出现。

Tips 如同相容分时系统的功能一般，Unix强调的是多用户多任务的环境！ 但早期的286个人 计算机架构下的CPU是没有能力达到多任务的作业，因此，并没有人对移植Unix到x86的计算 机上有兴趣。
每一家公司自己出的Unix虽然在架构上面大同小异，但是却真的仅能支持自身的硬件， 所以 啰，早先的Unix只能与服务器（Server）或者是大型工作站（Workstation）划上等号！ 但到 了 1979 年时，AT&T推出 System V 第七版 Unix 后，这个情况就有点改善了。 这一版最重要 的特色是可以支持x86架构的个人计算机系统，也就是说 System V 可以在个人计算机上面安 装与运行了。
不过因为AT&T由于商业的考虑，以及在当时现实环境下的思考，于是想将Unix的版权收回 去。因此， AT&T在1979年发行的第七版Unix中，特别提到了 “不可对学生提供源代码”的严格 限制！ 同时，也造成Unix业界之间的紧张气氛，并且也引爆了很多的商业纠纷～

1.1 Linux是什么

82

鸟哥的 Linux 私房菜：基础学习篇 第四版

Tips 目前被称为纯种的Unix指的就是System V以及BSD这两套啰！
1984年之一：x86架构的Minix操作系统开始撰写并于两年后诞生
关于1979年的版权声明中，影响最大的当然就是学校教Unix核心源代码相关学问的教授了！ 想一想，如果没有核心源代码，那么如何教导学生认识Unix呢？这问题对于 Andrew Tanenbaum （谭宁邦, [5]）教授来说，实在是很伤脑筋的！不过，学校的课程还是得继续 啊！那怎么办？
既然1979年的Unix第七版可以在Intel的x86架构上面进行移植， 那么是否意味着可以将Unix 改写并移植到x86上面了呢？在这个想法上， 谭宁邦教授于是乎自己动手写了Minix这个Unix Like的核心程序！ 在撰写的过程中，为了避免版权纠纷，谭宁邦完全不看Unix核心源代码！ 并且强调他的Minix必须能够与Unix相容才行！谭宁邦在1984年开始撰写核心程序， 到了 1986年终于完成，并于次年出版Minix相关书籍，同时与新闻群组（BBS及News）相结合～

Tips 之所以称为Minix的原因，是因为他是个Mini （微小的） 的Unix系统啰！^_^
这个Minix版本比较有趣的地方是，他并不是完全免费的，无法在网络上提供下载！ 必须要通 过磁片/磁带购买才行！虽然真的很便宜～不过，毕竟因为没有在网络上流传， 所以Minix的传 递速度并没有很快速！此外，购买时，随磁片还会附上Minix的源代码！ 这意味着使用者可以 学习Minix的核心程序设计概念喔！ （这个特色对于Linux的启始开发阶段，可是有很大的关 系喔！）
此外，Minix操作系统的开发者仅有谭宁邦教授，因为学者很忙啊 （鸟哥当了老师之后，才发 现，真的忙...）！加上谭宁邦始终认为Minix主要用在教育用途上面， 所以对于Minix是点到为 止！没错，Minix是很受欢迎，不过，使用者的要求/需求的声音可能就比较没有办法上升到比 较高的地方了！ 这样说，你明白吧？^_^
1984年之二：GNU计划与FSF基金会的成立
Richard Mathew Stallman（史托曼）在1984年发起的GNU计划，对于现今的自由软件风潮， 真有不可磨灭的地位！目前我们所使用的很多自由软件或开源软件，几乎均直接或间接受益 于GNU这个计划呢！ 那么史托曼是何许人也？为何他会发起这个GNU计划呢？
一个分享的环境：

1.1 Linux是什么

83

鸟哥的 Linux 私房菜：基础学习篇 第四版
Richard Mathew Stallman（生于1953年， 网络上自称的ID为RMS, [6]）从小就很聪明！他在 1971年的时候，进入骇客圈中相当出名的人工智能实验室（AI Lab.）， 这个时候的骇客专指 计算机功力很强的人，而非破坏计算机的怪客（cracker）喔！
当时的骇客圈对于软件的着眼点几乎都是在“分享”，骇客们都认为互相学习对方的程序码，这 样才是产生更优秀的程序码的最佳方式！ 所以 AI 实验室的骇客们通常会将自己的程序码公布 出来跟大家讨论喔！这个特色对于史托曼的影响很大！
不过，后来由于管理阶层以及骇客群们自己的生涯规划等问题，导致实验室的优秀骇客离开 该实验室， 并且进入其他商业公司继续发展优秀的软件。但史托曼并不服输，仍然持续在原 来的实验室开发新的程序与软件。 后来，他发现到，自己一个人并无法完成所有的工作，于 是想要成立一个开放的团体来共同努力！
使用Unix开发阶段：
1983年以后，因为实验室硬件的更换，使得史托曼无法继续以原有的硬件与操作系统继续自 由程序的撰写～ 而且他进一步发现到，过去他所使用的Lisp操作系统，是麻省理工学院的专 利软件， 是无法共享的，这对于想要成立一个开放团体的史托曼是个阻碍。于是他便放弃了 Lisp这个系统。 后来，他接触到Unix这个系统，并且发现，Unix在理论与实际上，都可以在 不同的机器间进行移植。虽然 Unix 依旧是专利软件， 但至少 Unix 架构上还是比较开放的！ 于是他开始转而使用Unix系统。
因为Lisp与Unix是不同的系统，所以，他原本已经撰写完毕的软件是无法在Unix上面运行的！ 为此， 他就开始将软件移植到Unix上面。并且，为了让软件可以在不同的平台上运行， 因 此，史托曼将他发展的软件均撰写成可以移植的型态！也就是他都会将程序的源代码公布出 来！
GNU计划的推展[7]：
1984年，史托曼开始GNU计划， 这个计划的目的是：创建一个自由、开放的Unix操作系统 （Free Unix）。 但是创建一个操作系统谈何容易啊！而且在当时的GNU是仅有自己一个人单 打独斗的史托曼～ 这实在太麻烦，但又不想放弃这个计划，那可怎么办啊？
聪明的史托曼干脆反其道而行～“既然操作系统太复杂，我就先写可以在Unix上面运行的小程 序，这总可以了吧？”在这个想法上， 史托曼开始参考Unix上面现有的软件，并依据这些软件 的作用开发出功能相同的软件，且开发期间史托曼绝不看其他软件的源代码， 以避免吃上官 司。后来一堆人知道免费的GNU软件，并且实际使用后发现与原有的专利软件也差不了太 多，于是便转而使用GNU软件， 于是GNU计划逐渐打开知名度。
虽然GNU计划渐渐打开知名度，但是能见度还是不够。这时史托曼又想：不论是什么软件， 都得要进行编译成为二进制文件（binary program）后才能够执行，如果能够写出一个不错的 编译器，那不就是大家都需要的软件了吗？ 因此他便开始撰写C语言的编译器，那就是现在

1.1 Linux是什么

84

鸟哥的 Linux 私房菜：基础学习篇 第四版
相当有名的GNU C Compiler（gcc）！ 这个点相当的重要！这是因为C语言编译器版本众 多，但都是专利软件， 如果他写的C编译器够棒，性能够佳，那么将会大大的让GNU计划出 现在众人眼前！如果忘记啥是编译器， 请回到第零章去瞧瞧编译程序吧！
但开始撰写GCC时并不顺利，为此，他先转而将他原先就已经写过的Emacs编辑器写成可以 在Unix上面跑的软件，并公布源代码。 Emacs是一种程序编辑器，他可以在使用者撰写程序 的过程中就进行程序语法的检验，此一功能可以减少程序设计师除错的时间！ 因为Emacs太 优秀了，因此，很多人便直接向他购买。
此时网际网络尚未流行，所以，史托曼便借着Emacs以磁带（tape）出售，赚了一点钱 ，进 而开始全力撰写其他软件。并且成立自由软件基金会（FSF, Free Software Foundation），请 更多工程师与志工撰写软件。终于还是完成了GCC，这比Emacs还更有帮助！ 此外，他还撰 写了更多可以被调用的C函数库（GNU C library），以及可以被使用来操作操作系统的基本 接口BASH shell！ 这些都在1990年左右完成了！

Tips 如果纯粹使用文字编辑器来编辑程序的话，那么程序语法如果写错时，只能利用编译时 发生的错误讯息来修订了，这样实在很没有效率。 Emacs则是一个很棒的编辑器！注意！是 编辑（editor）而非编译（compiler）！ 他可以很快的立刻显示出你写入的语法可能有错误的 地方，这对于程序设计师来说， 实在是一个好到不能再好的工具了！所以才会这么的受到欢 迎啊！
GNU的通用公共许可证：
到了1985年，为了避免GNU所开发的自由软件被其他人所利用而成为专利软件， 所以他与律 师草拟了有名的通用公共许可证（General Public License, GPL）， 并且称呼他为 copyleft（相对于专利软件的copyright！）。 关于GPL的相关内容我们在下一个小节继续谈 论，在这里，必须要说明的是， 由于有GNU所开发的几个重要软件，如：
Emacs GNU C （GCC） GNU C Library （glibc） Bash shell
造成后来很多的软件开发者可以借由这些基础的工具来进行程序开发！ 进一步壮大了自由软 件团体！这是很重要的！不过，对于GNU的最初构想 “创建一个自由的Unix操作系统”来说， 有这些优秀的程序是仍无法满足， 因为，当下并没有“自由的Unix核心”存在...所以这些软件仍 只能在那些有专利的 Unix平台上工作～～一直到Linux的出现...更多的FSF开发的软件可以参 考如下网页：

1.1 Linux是什么

85

鸟哥的 Linux 私房菜：基础学习篇 第四版 https://www.fsf.org/resources

Tips 事实上，GNU 自己开发的核心称为 hurd， 是一个架构相当先进的核心。不过由于开发 者在开发的过程中对于系统的要求太过于严谨，因此推出的时程一再延后，所以才有后来 Linux 的开发！
1988年：图形接口XFree86计划
有鉴于图形使用者接口（Graphical User Interface, GUI） 的需求日益加重，在1984年由MIT 与其他协力厂商首次发表了X Window System ，并且更在1988年成立了非营利性质的 XFree86这个组织。所谓的XFree86其实是 X Window System + Free + x86的整合名称呢！ 而这个XFree86的GUI接口更在Linux的核心1.0版于1994年释出时，整合于Linux操作系统当 中！

Tips 为什么称图形使用者接口为X呢？因为由英文单字来看，Window的W接的就是X啦！意 指Window的下一版就是了！ 需注意的是，X Window并不是X Windows喔！
1991年：芬兰大学生Linus Torvalds的一则简讯
到了1991年，芬兰的赫尔辛基大学的Linus Torvalds在BBS上面贴了一则消息， 宣称他以 bash, gcc等 GNU 的工具写了一个小小的核心程序，该核心程序单纯是个玩具，不像 GNU 那 么专业。 不过该核心程序可以在Intel的386机器上面运行就是了。这让很多人很感兴趣！从此 开始了Linux不平凡的路程！
1.1.3 关于GNU计划、自由软件与开放源代码
GNU计划对于整个自由软件与开放源代码软件来说是占有非常重要的角色！下面我们就来谈 谈这咚咚吧！
自由软件的活动：
1984年创立GNU计划与FSF基金会的Stallman先生认为，写程序最大的快乐就是让自己发展 的良好的软件让大家来使用了！ 另外，如果使用方撰写程序的能力比自己强，那么当对方修 改完自己的程序并且回传修改后的程序码给自己，那自己的程序撰写功力无形中就更往上爬 了！ 这就是最早之前 AI 实验室的骇客风格！

1.1 Linux是什么

86

鸟哥的 Linux 私房菜：基础学习篇 第四版
而既然程序是想要分享给大家使用的，不过，每个人所使用的计算机软硬件并不相同， 既然 如此的话，那么该程序的源代码（Source code）就应该要同时释出， 这样才能方便大家修改 而适用于每个人的计算机中呢！这个将源代码连同软件程序释出的举动，在 GNU 计划的范畴 之内就称为自由软件（Free Software）运动！
此外，史托曼同时认为，如果你将你程序的Source code分享出来时，若该程序是很优秀的， 那么将会有很多人使用， 而每个人对于该程序都可以查阅source code，无形之中，就会有一 票人帮你除错啰！ 你的这支程序将会越来越壮大！越来越优秀呢！
自由软件的版权GNU GPL：
而为了避免自己的开发出来的Open source自由软件被拿去做成专利软件， 于是Stallman同时 将GNU与FSF发展出来的软件，都挂上GPL的版权宣告～ 这个FSF的核心观念是“版权制度是 促进社会进步的手段， 版权本身不是自然权力。”对于FSF有兴趣或者对于GNU想要更深入的 了解时，请参考朝阳科技大学洪朝贵教授的网站 http://people.ofset.org/~ckhung/a/c_83.php，或直接到GNU去： http://www.gnu.org 里面有 更为深入的解说！

Tips 为什么要称为GNU呢？其实GNU是GNU's Not Unix的缩写，意思是说，GNU并不是 Unix啊！那么GNU又是什么呢？ 就是GNU's Not Unix嘛！.....如果你写过程序就会知道，这个 GNU = GNU's Not Unix可是无穷循环啊！忙碌～
另外，什么是Open Source呢？所谓的source code是程序发展者写出的原始程序码， Open Source就是，软件在发布时，同时将作者的源代码一起公布的意思！
自由（Free）的真谛：
那么这个GPL（GNU General Public License, GPL）是什么玩意儿？ 为什么要将自由软件挂 上GPL的“版权宣告”呢？这个版权宣告对于作者有何好处？ 首先，Stallman对GPL一直是强调 Free的，这个Free的意思是这样的：
"Free software" is a matter of liberty, not price. To understand the concept, you should think of "free speech", not "free beer". "Free software" refers to the users' freedom to run, copy, distribute, study, change, and improve the software
大意是说，Free Software（自由软件）是一种自由的权力，并非是“价格！” 举例来说，你可 以拥有自由呼吸的权力、你拥有自由发表言论的权力， 但是，这并不代表你可以到处喝“免费 的啤酒！（free beer）”，也就是说， 自由软件的重点并不是指“免费”的，而是指具有“自由度, freedom”的软件， 史托曼进一步说明了自由度的意义是： 使用者可以自由的执行、复制、再 发行、学习、修改与强化自由软件。

1.1 Linux是什么

87

鸟哥的 Linux 私房菜：基础学习篇 第四版
这无疑是个好消息！因为如此一来，你所拿到的软件可能原先只能在Unix上面跑， 但是经过 源代码的修改之后，你将可以拿他在Linux或者是Windows上面来跑！总之， 一个软件挂上了 GPL版权宣告之后，他自然就成了自由软件！这个软件就具有下面的特色：
取得软件与源代码：你可以根据自己的需求来执行这个自由软件； 复制：你可以自由的复制该软件； 修改：你可以将取得的源代码进行程序修改工作，使之适合你的工作； 再发行：你可以将你修改过的程序，再度的自由发行，而不会与原先的撰写者冲突； 回馈：你应该将你修改过的程序码回馈于社群！
但请特别留意，你所修改的任何一个自由软件都不应该也不能这样：
修改授权：你不能将一个GPL授权的自由软件，在你修改后而将他取消GPL授权～ 单纯贩卖：你不能单纯的贩卖自由软件。
也就是说，既然GPL是站在互助互利的角度上去开发的，你自然不应该将大家的成果占为己 有， 对吧！因此你当然不可以将一个GPL软件的授权取消，即使你已经对该软件进行大幅度 的修改！ 那么自由软件也不能贩卖吗？当然不是！还记得上一个小节里面， 我们提到史托曼 借由贩卖Emacs取得一些经费，让自己生活不至于匮乏吧？是的！ 自由软件是可以贩售的， 不过，不可仅贩售该软件，应同时搭配售后服务与相关手册～ 这些可就需要工本费了呢！
自由软件与商业行为：
很多人还是有疑问，目前不是有很多Linux开发商吗？为何他们可以贩售Linux这个GPL授权的 软件？ 原因很简单，因为他们大多都是贩售“售后服务！”所以，他们所使用的自由软件， 都 可以在他们的网站上面下载！（当然，每个厂商他们自己开发的工具软件就不是GPL的授权 软件了！） 但是，你可以购买他们的Linux光盘，如果你购买了光盘，他们会提供相关的手册 说明文档， 同时也会提供你数年不等的谘询、售后服务、软件升级与其他协力工作等等的附 加价值！
所以说，目前自由软件工作者，他们所赖以维生的，几乎都是在“服务”这个领域呢！ 毕竟自 由软件并不是每个人都会撰写，有人有需要你的自由软件时，他就会请求你的协助， 此时， 你就可以通过服务来收费了！这样来说， 自由软件确实还是具有商业空间的喔！

Tips 很多人对于GPL授权一直很疑惑，对于GPL的商业行为更是无法接受！ 关于这一点，鸟 哥在这里还是要再次的申明，GPL是可以从事商业行为的！ 而很多的作者也是借由这些商业 行为来得以取得生活所需，更进一步去发展更优秀的自由软件！ 千万不要听到“商业”就排 斥！这对于发展优良软件的朋友来说，是不礼貌的！

1.1 Linux是什么

88

鸟哥的 Linux 私房菜：基础学习篇 第四版
上面提到的大多是与使用者有关的项目，那么 GPL 对于自由软件的作者有何优点呢？大致的 优点有这些：
软件安全性较佳； 软件执行性能较佳； 软件除错时间较短； 贡献的源代码永远都存在。
这是因为既然是提供源代码的自由软件，那么你的程序码将会有很多人帮你查阅， 如此一 来，程序的漏洞与程序的优化将会进展的很快！所以，在安全性与性能上面， 自由软件一点 都不输给商业软件喔！此外，因为GPL授权当中，修改者并不能修改授权， 因此，你如果曾 经贡献过程序码，嘿嘿！你将名留青史呢！不错吧！ ^_^
对于程序开发者来说，GPL实在是一个非常好的授权，因为大家可以互相学习对方的程序撰 写技巧， 而且自己写的程序也有人可以帮忙除错。那你会问啊，对于我们这些广大的终端用 户，GPL有没有什么好处啊？有啊！当然有！ 虽然终端用户或许不会自己编译程序码或者是 帮人家除错，但是终端用户使用的软件绝大部分就是GPL的软件， 全世界有一大票的工程师 在帮你维护你的系统，这难道不是一件非常棒的事吗？ ^_^

Tips 就跟人类社会的科技会进步一样，授权也会进步喔！因应源代码分区与重组的问题，与 其他开源软件的授权包容性，以及最重要的数码版权管理 （Digital Rights Management, DRM） 等问题，GPL 目前已经出到第三版 GPLv3。但是，目前使用最广泛的，还是 GPLv2 喔！包括 Linux 核心就还是使用 GPLv2 的说！
开放源代码：
由于自由软件使用的英文为 free software，这个 free 在英文是有两种以上不同的意义，除了 自由之外，免费也是这个单字！ 因为有这些额外的联想，因此许多的商业公司对于投入自由 软件方面确实是有些疑虑存在的！许多人对于这个情况总是有些担心～
为了解决这个困扰，1998 年成立的“开放源代码促进会 （Open Source Initiative）”提出了开 放源代码 （Open Source，亦可简称开源软件） 这一名词！ 另外，并非软件可以被读取源代 码就可以被称为开源软件喔！该软件的授权必须要符合下面的基本需求，才可以算是 open source 的软件哩！[8]
公布源代码且用户具有修改权：用户可以任意的修改与编译程序码，这点与自由软件差 异不大； 任意的再散佈：该程序码全部或部份可以被贩售，且程序码可成为其他软件的元件之 一，作者不该宣称具有拥有权或收取其他额外费用。

1.1 Linux是什么

89

鸟哥的 Linux 私房菜：基础学习篇 第四版
必须允许修改或衍生的作品，且可让再发布的软件使用相似的授权来发表即可。 承上，用户可使用与原本软件不同的名称或编号来散佈。 不可限制某些个人或团体的使用权 不可限制某些领域的应用：例如不可限制不能用于商业行为或者是学术行为等特殊领域 等等 不可限制在某些产品当中，亦即程序码可以应用于多种不同产品中。 不可具有排他条款，例如不可限制本程序码不能用于教育类的研究中，诸如此类。
根据上面的定义，GPL 自由软件也可以算是开源软件的一个，只是对于商业应用的限止稍微 多一些而已。 与 GPL 自由软件相比，其他开源软件的授权可能比较轻松喔！比较轻松的部份 包括：再发布的授权可以跟原本的软件不同； 另外，开源软件的全部或部份可作为其他软件 的一部分，且其他软件无须使用与开源软件相同的授权来发布！这跟GPL自由软件差异就大 了！ 自由软件的GPL授权规定，任何软件只要用了GPL的全部或部份程序码，那么该软件就 得要使用GPL的授权！这对于自由软件的保障相当大！ 但对于想要保有商业公司自己的商业 机密的专属软件来说，要使用GPL授权还是怕怕的！这也是后来商业公司拥抱其他 open source 开源软件授权的缘故！因为可以用于商业行为啰！更多的差异或许可以参考一下开源 促进会的说明。
另外，Open source 这个名词只是一个指引，而实际上并不是先有 open source 才有相关的 授权。早在 open source 出来之前就有些开源软件的授权存在了 （例如 GPL 啊！）！ 不过 有 open source 这个名词之后，大家才更了解到开源软件授权的意义就是了。那常见的开放 源代码授权有哪些呢？
Apache License 2.0 BSD 3-Clause "New" or "Revised" license BSD 2-Clause "Simplified" or "FreeBSD" license GNU General Public License （GPL） GNU Library or "Lesser" General Public License （LGPL） MIT license Mozilla Public License 2.0 Common Development and Distribution License
鸟哥也不是软件授权的高手！每个授权详细的内容也可以参考 OSI 协会的介绍啦[9]。

Tips 如前所述，GPL 也是合乎 Open source 所定义的授权之一，只是它更着重于保护自由软 件本身的学习与发展就是了！那如果你想要开发开源软件时， 到底使用哪种授权比较好呢？ 其实跟你对这个软件的未来走向的定义有关啦！简单的来说，如果你的软件未来你允许它用

1.1 Linux是什么

90

鸟哥的 Linux 私房菜：基础学习篇 第四版
于商业活动中， 可以考虑 BSD 之类的授权，如果你的软件希望少一些商业色彩，GPLv2 大 概是不二选择啰！那如果你的软件允许分支开发， 甚至可以考虑分成两种版本分别授权哩！ ^_^
专属软件/专利软件 （close source）
相对于Open Source的软件会释出源代码，Close source的程序则仅推出可执行的二进制程序 （binary program）而已。 这种软件的优点是有专人维护，你不需要去更动他；缺点则是灵 活度大打折扣，使用者无法变更该程序成为自己想要的样式！ 此外，若有木马程序或者安全 漏洞，将会花上相当长的一段时间来除错！这也是所谓专利软件（copyright）常见的软件出 售方式。
虽然专利软件常常代表就是需要花钱去购买，不过有些专利软件还是可以“免费”提供福斯使用 的！免费的专利软件代表的授权模式有：
Freeware： http://en.wikipedia.org/wiki/Freeware 不同于Free software，Freeware为“免 费软件”而非“自由软件！”虽然它是免费的软件，但是不见得要公布其源代码， 端看释出 者的意见啰！这个东西与Open Source毕竟是不太相同的东西喔！此外，目前很多标榜免 费软件的程序很多都有小问题！ 例如假藉免费软件的名义，实施使用者数据窃取的目 的！ 所以“来路不明的软件请勿安装！”
Shareware： http://en.wikipedia.org/wiki/Shareware 共享软件这个名词就有趣了！与免 费软件有点类似的是，Shareware在使用初期，它也是免费的，但是， 到了所谓的“试用 期限”之后，你就必须要选择“付费后继续使用”或者“将它移除”的宿命～ 通常，这些共享 软件都会自行撰写失效程序，让你在试用期限之后就无法使用该软件。

1.1 Linux是什么

91

鸟哥的 Linux 私房菜：基础学习篇 第四版
1.2 Torvalds的Linux发展
我们前面一节当中，提到了Unix的历史，也提到了Linux是由Torvalds这个芬兰人所发明的。 那么为何托瓦兹可以发明Linux呢？ 凭空想像而来的？还是有什么渊源？这里我们就来谈一谈 啰！
1.2.1 与Minix之间
Linus Torvalds（托瓦兹, 1969年出生, [10]）的外祖父是赫尔辛基大学的统计学家， 他的外祖 父为了让自己的小孙子能够学点东西，所以从小就将托瓦兹带到身边来管理一些微计算机。 在这个时期，托瓦兹接触了组合语言（Assembly Language），那是一种直接与芯片对谈的 程序语言，也就是所谓的低阶语言。 必须要很了解硬件的架构，否则很难以组合语言撰写程 序的。
在1988年间，托瓦兹顺利的进入了赫尔辛基大学，并选读了计算机科学系。在就学期间，因 为学业的需要与自己的兴趣， 托瓦兹接触到了Unix这个操作系统。当时整个赫尔辛基只有一 部最新的Unix系统，同时仅提供16个终端机（terminal）。 还记得我们上一节刚刚提过的， 早期的计算机仅有主机具有运算功能，terminal仅负责提供Input/Output而已。在这种情况 下， 实在很难满足托瓦兹的需求，因为.....光是等待使用Unix的时间，就很耗时～为此，他不 禁想到： “我何不自己搞一部Unix来玩？”不过，就如同Stallman当初的GNU计划一样，要写 核心程序，谈何容易～
不过，幸运之神并未背离托瓦兹，因为不久之后，他就知道有一个类似Unix的系统， 并且与 Unix完全相容，还可以在Intel 386机器上面跑的操作系统， 那就是我们上一节提过的，谭宁 邦教授为了教育需要而撰写的Minix系统！ 他在购买了最新的Intel 386的个人计算机后，就立 即安装了Minix这个操作系统。 另外，上个小节当中也谈到，Minix这个操作系统是有附上源 代码的， 所以托瓦兹也经由这个源代码学习到了很多的核心程序设计的设计概念喔！
1.2.2 对386硬件的多任务测试
事实上，托瓦兹对于个人计算机的CPU其实并不满意，因为他之前碰的计算机都是工作站型 的计算机， 这类计算机的CPU特色就是可以进行“多任务处理”的能力。什么是多任务呢？理 论上， 一个CPU在一个时间内仅能进行一个程序， 那如果有两个以上的程序同时出现到系统 中呢？举例来说， 你可以在现今的计算机中同时打开两个以上的办公软件，例如电子试算表 与文书处理软件。 这个同时打开的动作代表着这两个程序同时要交给CPU来处理～
啊！CPU一个时间点内仅能处理一个程序，那怎么办？没关系，这个时候如果具有多任务能 力的CPU就会在不同的程序间切换～ 还记得前一章谈到的CPU频率吧？假设CPU频率为 1GHz的话，那表示CPU一秒钟可以进行109次工作。 假设CPU对每个程序都只进行1000次

1.2 Torvalds的Linux发展

92

鸟哥的 Linux 私房菜：基础学习篇 第四版
运行周期，然后就得要切换到下个程序的话，那么CPU一秒钟就能够切换106次呢！ （当然 啦，切换工作这件事情也会花去一些CPU时间，不过这里暂不讨论）。这么快的处理速度 下，你会发现， 两个程序感觉上几乎是同步在进行啦！
Tips 为什么有的时候我同时开两个文件（假设为A, B文件）所花的时间， 要比开完A再去开B 文件的时间还要多？现在是否稍微可以理解？ 因为如果同时打开的话，CPU就必须要在两个 工作之间不停的切换～ 而切换的动作还是会耗去一些CPU时间的！所以啰，同时启用两个以 上的工作在一个CPU上， 要比一个一个的执行还要耗时一点。这也是为何现在CPU开发商要 整合多个CPU于一个芯片中！ 也是为何在运行情况比较复杂的服务器上，需要比较多的CPU 负责的原因！ 早期Intel x86架构计算机不是很受重视的原因，就是因为x86的芯片对于多任务的处理不佳， CPU在不同的工作之间切换不是很顺畅。但是这个情况在386计算机推出后，有很大的改善。 托瓦兹在得知新的386芯片的相关信息后，他认为，以性能价格比的观点来看， Intel的386相 当的便宜，所以在性能上也就稍微可以将就将就 ^_^。最终他就贷款去买了一部Intel的386来 玩。
早期的计算机性能没有现在这么好，所以压榨计算机性能就成了工程师的一项癖好！ 托瓦兹 本人早期是玩组合语言的，组合语言对于硬件有很密切的关系，托瓦兹自己也说：“我始终是 个性能癖”^^。 为了彻底发挥386的性能，于是托瓦兹花了不少时间在测试386机器上！ 他的 重要测试就是在测试386的多功性能。首先，他写了三个小程序，一个程序会持续输出A、一 个会持续输出B， 最后一个会将两个程序进行切换。他将三个程序同时执行，结果，他看到 屏幕上很顺利的一直出现ABABAB...... 他知道，他成功了！ ^^

测试 1.2 Torvalds的Linux发展

图1.2.1、386计算机的多任务 93

鸟哥的 Linux 私房菜：基础学习篇 第四版
Tips 要达到多工（multitasking）的环境，除了硬件（主要是CPU）需要能够具有多任务的特 性外，操作系统也需要支持这个功能喔！ 一些不具有多任务特性的操作系统，想要同时执行 两个程序是不可能的。除非先被执行的程序执行完毕，否则， 后面的程序不可能被主动执 行。
至于多任务的操作系统中，每个程序被执行时，都会有一个最大CPU使用时间，若该工作运 行的时间超过这个CPU使用时间时， 该工作就会先被丢出CPU的运行中，而再度的进入核心 工作调度中等待下一次被CPU取用来运行。
这有点像在开记者会啦，主持人（CPU）会问“谁要发问”？一群记者（工作程序） 就会举手 （看谁的工作重要！），先举手的自然就被允许发问，问完之后， 主持人又会问一次谁要发 问，当然，所有人（包括刚刚那个记者）都可以举手！ 如此一次一次的将工作给他完成啊！ ^_^ 多任务的环境对于复杂的工作情况，帮助很大喔！
1.2.3 初次释出Linux 0.02
探索完386的硬件性能之后，终于拿到Minix并且安装在托瓦兹的386计算机上之后，托瓦兹跟 BBS上面一堆工程师一样， 他发现Minix虽然真的很棒，但是谭宁邦教授就是不愿意进行功能 的加强，导致一堆工程师在操作系统功能上面的欲求不满！ 这个时候年轻的托瓦兹就想：“既 然如此，那我何不自己来改写一个我想要的操作系统？” 于是他就开始了核心程序的撰写了。
撰写程序需要什么呢？首先需要的是能够进行工作的环境，再来则是可以将源代码编译成为 可可执行文件的编译器。 好在有GNU计划提供的bash工作环境软件以及gcc编译器等自由软 件， 让托瓦兹得以顺利的撰写核心程序。他参考Minix的设计理念与书上的程序码，然后仔细 研究出386个人计算机的性能最优化， 然后使用GNU的自由软件将核心程序码与386紧紧的结 合在一起，最终写出他所需要的核心程序。 而这个小玩意竟然真的可以在386上面顺利的跑 起来～还可以读取Minix的文件系统。 真是太好了！不过还不够，他希望这个程序可以获得大 家的一些修改建议， 于是他便将这个核心放置在网络上提供大家下载，同时在BBS上面贴了 一则消息：
Hello everybody out there using minixI'm doing a （free） operation system （just a hobby, won't be big and professional like gnu） for 386（486） AT clones.
I've currently ported bash （1.08） and gcc （1.40）, and things seem to work. This implies that i'll get something practical within a few months, and I'd like to know what features most people want. Any suggestions are welcome, but I won't promise I'll implement them :-）
他说，他完成了一个小小的操作系统，这个核心是用在386机器上的， 同时，他真的仅是好 玩，并不是想要做一个跟GNU一样大的计划！ 另外，他希望能够得到更多人的建议与回馈来 发展这个操作系统！这个概念跟Minix刚好背道而驰呢！ 这则新闻引起很多人的注意，他们也

1.2 Torvalds的Linux发展

94

鸟哥的 Linux 私房菜：基础学习篇 第四版
去托瓦兹提供的网站上下载了这个核心来安装。 有趣的是，因为托瓦兹放置核心的那个FTP 网站的目录为：Linux， 从此，大家便称这个核心为Linux了。（请注意，此时的Linux就是那 个kernel喔！ 另外，托瓦兹所丢到该目录下的第一个核心版本为0.02呢！）
同时，为了让自己的Linux能够相容于Unix系统，于是托瓦兹开始将一些能够在Unix上面运行 的软件拿来在Linux上面跑。 不过，他发现到有很多的软件无法在Linux这个核心上运行。这 个时候他有两种作法， 一种是修改软件，让该软件可以在Linux上跑， 另一种则是修改 Linux，让Linux符合软件能够运行的规范！ 由于Linux希望能够相容于Unix，于是托瓦兹选择 了第二个作法“修改Linux”！ 为了让所有的软件都可以在Linux上执行，于是托瓦兹开始参考标 准的POSIX规范。

Tips POSIX是可携式操作系统接口（Portable Operating System Interface）的缩写，重点在 规范核心与应用程序之间的接口， 这是由美国电器与电子工程师学会（IEEE）所发布的一项 标准喔！
这个正确的决定让Linux在起步的时候体质就比别人优良～因为POSIX标准主要是针对Unix与 一些软件运行时候的标准规范， 只要依据这些标准规范来设计的核心与软件，理论上，就可 以搭配在一起执行了。 而Linux的发展就是依据这个POSIX的标准规范，Unix上面的软件也是 遵循这个规范来设计的， 如此一来，让Linux很容易就与Unix相容共享互有的软件了！同时， 因为Linux直接放置在网络下，提供大家下载， 所以在流通的速度上相当的快！导致Linux的 使用率大增！这些都是造成Linux大受欢迎的几个重要因素呢！

Tips 其实托瓦兹有意无意之间常常会透露他自己是个只喜欢玩 （Just for Fun） 的怪人！ Linux 一开始也只是托瓦兹的一个作业发展出来的玩具而已。 他也说，如果 Minix 或 hurd 这 两个中的任何一个系统可以提早开发出他想要的功能与环境，也许他根本不会想要自己开发 一个 Linux 哩！ 哇！人类智慧真是没有极限！各位啊： 1）要先有基础知识与技能、2）有了 第一点后，要勇于挑战权威、3）把你们的玩具发扬光大吧！ ^_^
1.2.4 Linux 的发展：虚拟团队的产生
Linux能够成功除了托瓦兹个人的理念与力量之外，其实还有个最重要的团队！
单一个人维护阶段

1.2 Torvalds的Linux发展

95

鸟哥的 Linux 私房菜：基础学习篇 第四版
Linux虽然是托瓦兹发明的，而且内容还绝不会涉及专利软件的版权问题。不过，如果单靠托 瓦兹自己一个人的话，那么Linux要茁壮实在很困难～ 因为一个人的力量是很有限的。好在托 瓦兹选择Linux的开发方式相当的务实！首先，他将释出的Linux核心放置在FTP上面，并请告 知大家新的版本信息， 等到使用者下载了这个核心并且安装之后，如果发生问题，或者是由 于特殊需求亟需某些硬件的驱动程序，那么这些使用者就会主动回报给托瓦兹。 在托瓦兹能 够解决的问题范围内，他都能很快速的进行Linux核心的更新与除错。
广大骇客志工加入阶段
不过，托瓦兹总是有些硬件无法取得的啊，那么他当然无法帮助进行驱动程序的撰写与相关 软件的改良。 这个时候，就会有些志工跳出来说：“这个硬件我有，我来帮忙写相关的驱动程 序。” 因为Linux的核心是Open Source的，骇客志工们很容易就能够跟随Linux的原本设计架 构， 并且写出相容的驱动程序或者软件。志工们写完的驱动程序与软件托瓦兹是如何看待的 呢？ 首先，他将该驱动程序/软件带入核心中，并且加以测试。 只要测试可以运行，并且没有 什么主要的大问题，那么他就会很乐意的将志工们写的程序码加入核心中！
总之，托瓦兹是个很务实的人，对于Linux核心所欠缺的项目，他总是“先求有且能跑， 再求 进一步改良”的心态！这让Linux使用者与志工得到相当大的鼓励！ 因为Linux的进步太快了！ 使用者要求虚拟内存，结果不到一个星期推出的新版Linux就有了！ 这不得不让人佩服啊！
另外，为因应这种随时都有程序码加入的状况，于是Linux便逐渐发展成具有模块的功能！ 亦 即是将某些功能独立出于核心外，在需要的时候才载入到核心中。如此一来， 如果有新的硬 件驱动程序或者其他协定的程序码进来时，就可以模块化， 大大的增加了Linux核心的可维护 能力！

Tips 核心是一组程序，如果这组程序每次加入新的功能都得要重新编译与改版的话会变成如 何？ 想像一下，如果你只是换了显卡就得要重新安装新的Windows操作系统，会不会傻眼？ 模块化之后，原本的核心程序不需要更动，你可以直接将他想成是“驱动程序”即可！ ^_^
核心功能细部分工发展阶段
后来，因为Linux核心加入了太多的功能，光靠托瓦兹一个人进行核心的实际测试并加入核心 原始程序实在太费力～ 结果，就有很多的朋友跳出来帮忙这个前置作业！例如考克斯（Alan Cox）、与崔迪（Stephen Tweedie）等等， 这些重要的副手会先将来自志工们的修补程序或 者新功能的程序码进行测试， 并且结果上传给托瓦兹看，让托瓦兹作最后核心加入的源代码 的选择与整并！ 这个分层负责的结果，让Linux的发展更加的容易！

1.2 Torvalds的Linux发展

96

鸟哥的 Linux 私房菜：基础学习篇 第四版
特别值得注意的是，这些托瓦兹的Linux发展副手，以及自愿传送修补程序的骇客志工， 其实 都没有见过面，而且彼此在地球的各个角落，大家群策群力的共同发展出现今的Linux， 我们 称这群人为虚拟团队！而为了虚拟团队数据的传输，于是Linux便成立的核心网站： http://www.kernel.org！
而这群素未谋面的虚拟团队们，在1994年终于完成的Linux的核心正式版！version 1.0。 这一 版同时还加入了X Window System的支持呢！且于1996年完成了2.0版、2011 年释出 3.0 版，更于 2015 年 4 月释出了 4.0 版哩！ 发展相当迅速喔！此外，托瓦兹指明了企鹅为Linux 的吉祥物。

Tips 奇怪的是，托瓦兹是因为小时候去动物园被企鹅咬了一口念念不忘， 而正式的2.0推出 时，大家要他想一个吉祥物。他在想也想不到什么动物的情况下， 就将这个念念不忘的企鹅 当成了Linux的吉祥物了......
Linux由于托瓦兹是针对386写的，跟386硬件的相关性很强，所以， 早期的Linux确实是不具 有移植性的。不过，大家知道Open source的好处就是， 可以修改程序码去适合作业的环 境。因此，在1994年以后，Linux便被开发到很多的硬件上面去了！ 目前除了x86之外， IBM、HP等等公司出的硬件也都有被Linux所支持呢！甚至于小型单板计算机 （树莓派/香蕉 派等） 与手持设备 （智能手机、平板电脑） 的 ARM 架构系统，大多也是使用 Linux 核心 喔！
1.2.5 Linux的核心版本
Linux的核心版本编号有点类似如下的样子：
3.10.0-123.el7.x86_64 主版本.次版本.释出版本-修改版本
虽然编号就是如上的方式来编的，不过依据 Linux 核心的发展期程，核心版本的定义有点不 太相同喔！
奇数、偶数版本分类
在 2.6.x 版本以前，托瓦兹将核心的发展趋势分为两股，并根据这两股核心的发展分别给予不 同的核心编号，那就是：
主、次版本为奇数：发展中版本（development） 如2.5.xx，这种核心版本主要用在测试 与发展新功能，所以通常这种版本仅有核心开发工程师会使用。 如果有新增的核心程序 码，会加到这种版本当中，等到众多工程师测试没问题后，才加入下一版的稳定核心

1.2 Torvalds的Linux发展

97

鸟哥的 Linux 私房菜：基础学习篇 第四版
中；
主、次版本为偶数：稳定版本（stable） 如2.6.xx，等到核心功能发展成熟后会加到这类 的版本中，主要用在一般家用计算机以及企业版本中。 重点在于提供使用者一个相对稳 定的Linux作业环境平台。
至于释出版本则是在主、次版本架构不变的情况下，新增的功能累积到一定的程度后所新释 出的核心版本。 而由于Linux核心是使用GPL的授权，因此大家都能够进行核心程序码的修 改。因此，如果你有针对某个版本的核心修改过部分的程序码， 那么那个被修改过的新的核 心版本就可以加上所谓的修改版本了。
主线版本、长期维护版本（longterm version）
不过，这种奇数、偶数的编号格式在 3.0 推出之后就失效了。从 3.0 版开始，核心主要依据主 线版本 （MainLine） 来开发，开发完毕后会往下一个主线版本进行。 例如 3.10 就是在 3.9 的架构下继续开发出来的新的主线版本。通常新一版的主线版本大约在 2~3 个月会被提出 喔！ 之所以会有新的主线版本，是因为有加入新功能之故。现在 （2015/04） 最新的主线版 本已经来到 4.0 版了喔！好快！
而旧的版本在新的主线版本出现之后，会有两种机制来处理，一种机制为结束开发 （End of Live, EOL），亦即该程序码已经结束，不会有继续维护的状态。 另外一种机制为保持该版本 的持续维护，亦即为长期维护版本 （Longterm）！例如 3.10 即为一个长期维护版本，这个 版本的程序码会被持续维护，若程序码有 bug 或其他问题， 核心维护者会持续进行程序码的 更新维护喔！
所以啰，如果你想要使用 Linux 核心来开发你的系统，那么当然要选择长期支持的版本才 行！要判断你的 Linux 核心是否为长期支持的版本， 可以使用“ uname -r ”来查阅核心版本， 然后对照下列链接来了解其对应值喔！
https://www.kernel.org/releases.html
Linux 核心版本与 Linux 发布商版本
Linux核心版本与distribution （下个小节会谈到） 的版本并不相同，很多朋友常常上网问 到：“我的Linux是7.x版，请问....”之类的留言， 这是不对的提问方式，因为所谓的Linux版本 指的应该是核心版本， 而目前最新的核心版本应该是4.0.0（2015/04） 才对，并不会有7.x的 版本出现的。
你常用的Linux系统则应该说明为distribution才对！因此，如果以CentOS这个distribution来 说， 你应该说：“我用的Linux是CentOS这个 distribution，版本为7.x 版，请问....”才对喔！

1.2 Torvalds的Linux发展

98

鸟哥的 Linux 私房菜：基础学习篇 第四版
Tips 当你有任何问题想要在Linux论坛发言时，请务必仔细的说明你的distribution版本， 因为 虽然各家distributions使用的都是Linux核心，不过每家distributions所选用的软件以及他们自 己发展的工具并不相同， 多少还是有点差异，所以留言时得要先声明distribution的版本才行 喔！ ^_^
1.2.6 Linux distributions
好了，经过上面的说明，我们知道了Linux其实就是一个操作系统最底层的核心及其提供的核 心工具。 他是GNU GPL授权模式，所以，任何人均可取得源代码与可执行这个核心程序，并 且可以修改。 此外，因为Linux参考POSIX设计规范，于是相容于Unix操作系统，故亦可称之 为Unix Like的一种。

Tips 鸟哥曾在上课的时候问过同学：“什么是Unix Like啊”？可爱的同学们回答的答案是：“就 是很喜欢（like）Unix啦！” 囧rz...那个like是“很像”啦！所以Unix like是“很像Unix的操作系 统”哩！
可完整安装的Linux发布套件
Linux的出现让GNU计划放下了心里的一块大石头，因为GNU一直以来就是缺乏了核心程序， 导致他们的GNU自由软件只能在其他的Unix上面跑。既然目前有Linux出现了，且 Linux也用 了很多的GNU相关软件，所以Stallman认为Linux的全名应该称之为GNU/Linux呢！ 不管怎么 说，Linux实在很不错，让GNU软件大多以Linux为主要操作系统来进行开发， 此外，很多其 他的自由软件团队，例如postfix, vsftpd, apache等等也都有以Linux 为开发测试平台的计划出 现！如此一来，Linux除了主要的核心程序外，可以在Linux 上面运行的软件也越来越多，如 果有心，就能够将一个完整的Linux操作系统搞定了！
虽然由Torvalds负责开发的Linux仅具有Kernel与Kernel提供的工具， 不过，如上所述，很多 的软件已经可以在Linux上面运行了，因此， “Linux + 各种软件”就可以完成一个相当完整的操 作系统了。 不过，要完成这样的操作系统......还真难～ 因为Linux早期都是由骇客工程师所开 发维护的，他们并没有考虑到一般使用者的能力......
为了让使用者能够接触到Linux，于是很多的商业公司或非营利团体， 就将Linux Kernel（含 tools）与可运行的软件整合起来，加上自己具有创意的工具程序， 这个工具程序可以让使用 者以光盘/DVD或者通过网络直接安装/管理Linux系统。 这个“Kernel + Softwares + Tools + 可 完整安装程序”的咚咚，我们称之为Linux distribution， 一般中文翻译成可完整安装套件，或 者Linux发布商套件等。

1.2 Torvalds的Linux发展

99

鸟哥的 Linux 私房菜：基础学习篇 第四版

图1.2.2、Linux可完整安装发布

套件
Tips 由于Linux核心是由骇客工程师写的，要由源代码安装到x86计算机上面成为可以执行的 binary文件， 这个过程可不是人人都会的～所以早期确实只有工程师对Linux有兴趣。 一直到 一些社群与商业公司将Linux核心配合自由软件，并提供完整的安装程序， 且制成光盘/DVD 后，对于一般使用者来说，Linux才越来越具有吸引力！ 因为只要一直“下一步”就可以将Linux 安装完成啊！ ^_^
由于GNU的GPL授权并非不能从事商业行为，于是很多商业公司便成立来贩售Linux distribution。 而由于Linux的GPL版权宣告，因此，商业公司所贩售的Linux distributions通常 也都可以从Internet上面来下载的！ 此外，如果你想要其他商业公司的服务，那么直接向该公 司购买光盘来安装，也是一个很不错的方式的！
各大Linux Distributions的主要异同：支持标准！
不过，由于发展Linux distributions的社群与公司实在太多了，例如在台湾有名的Red Hat, SuSE, Ubuntu, Fedora, Debian等等，所以很多人都很担心，如此一来每个distribution是否都 不相同呢？ 这就不需要担心了，因为每个Linux distributions使用的kernel都 是http://www.kernel.org所释出的，而他们所选择的软件，几乎都是目前很知名的软件，重复 性相当的高， 例如网页服务器的Apache，电子邮件服务器的Postfix/sendmail，文件服务器 的Samba等等。
此外，为了让所有的Linux distributions开发不致于差异太大，且让这些开发商在开发的时候 有所依据，还有Linux Standard Base （LSB）等标准来规范开发者，以及目录架构的File system Hierarchy Standard （FHS）标准规范！ 唯一差别的，可能就是该开发者自家所开发 出来的管理工具，以及套件管理的模式吧！ 所以说，基本上，每个Linux distributions除了架 构的严谨度与选择的套件内容外， 其实差异并不太大啦！ ^_^ 。大家可以选择自己喜好的 distribution来安装即可！
FHS: http://www.pathname.com/fhs/ LSB: http://www.linuxbase.org/

1.2 Torvalds的Linux发展

100

