# YOLO部署

## V5

## 训练

使用`python train.py --data=./data/my_dest.yaml`进行训练

### 导出

导出的时候需要更改一下模型的样式

使用下面的函数代替原本的forward函数在`yolov5/models/yolo.py`文件里面(只有导出的时候使用, 记得改回去), 原本的函数会在这个函数里面处理模型输出到实际的图片坐标转换, 这里不使用

```python
# RKNN 使用的forward
def forward(self, x):
    z = []
    for i in range(self.nl):
        # 只使用一个激活函数 sigmoid, 对每一个输出通道使用相同的激活函数
        # 直接获取预测结果
        # 输出 (bs, na*ny*nx, no) 的“原始预测值”（还没乘 grid、没乘 anchor、没算 xywh 到像素坐标）
        x[i] = torch.sigmoid(self.m[i](x[i]))
    return x
```

使用`python export.py --opset=12`, 如此即可获取到beat.onnx模型

可以使用工具再次简化模型

```bash
python -m onnxsim weights/best.onnx weights/best-sim.onnx
```

导出的模型记录在best-sim.onnx

## 模型转换

使用的工具是[airockchip/rknn_model_zoo](https://github.com/airockchip/rknn_model_zoo/)

手册在[rknn_model_zoo/examples/yolov5 at main · airockchip/rknn_model_zoo](https://github.com/airockchip/rknn_model_zoo/tree/main/examples/yolov5)

```bash
cd model
./download_model.sh
```

可以使用这个下载默认的模型, 使用的模型是`yolov5s_relu.onnx` 

```python
python convert.py ../model/yolov5s_relu.onnx rk3566
```

> 使用自己模型的时候量化使用的图片文件要改一下
>
> ```python
> DATASET_PATH = '../../../datasets/mydataset/dataset.txt'
> DEFAULT_RKNN_PATH = '../model/yolov5_my.rknn'
> DEFAULT_QUANT = True
> ```
>
> 在`examples/yolov5/python/convert.py`文件里面, 这个txt文件里面记录的一系列的图片目录

模型转换, 自己的模型使用的时候需要自己转换

使用的编译工具是`aarch64-linux-gnu-gcc`, 直接使用apt-get安装即可`sudo apt install -y gcc-aarch64-linux-gnu g++-aarch64-linux-gnu`

```python
export GCC_COMPILER=/usr/bin/aarch64-linux-gnu
./build-linux.sh -t rk3566 -a aarch64 -d yolov5
```

输出的文件在`./install/rk356x_linux_aarch64/rknn_yolov5_demo/`

### 板级文件

examples/yolov5/cpp/postprocess.cc这个文件里面有加载的label文件

```cpp
#define LABEL_NALE_TXT_PATH "./model/coco_80_labels_list.txt"
```

修改cpp代码`examples/yolov5/cpp/postprocess.h`里面的实际的分类的类型

```cpp
#define OBJ_NAME_MAX_SIZE 64
#define OBJ_NUMB_MAX_SIZE 128
#define OBJ_CLASS_NUM 3 // 你实际使用的类型数量
#define NMS_THRESH 0.45
#define BOX_THRESH 0.25
#define PROP_BOX_SIZE (5 + OBJ_CLASS_NUM)
```

默认的CMake复制的文件是coco的分类

```cmake
install(FILES ${CMAKE_CURRENT_SOURCE_DIR}/../model/coco_80_labels_list.txt DESTINATION ./model)
```

可以改成自己的分类文件

## 使用gcc11

需要更改buildroot系统

```
-> Toolchain
	-> GCC compiler Version (<choice> [=y])
```

![image-20251225184819507](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202512251848625.png)

```bash
./build.sh rootfs
./mkfirmware.sh
./build.sh updateimg
```



## 编译使用的参数

```bash
BUILD_DEMO_NAME=yolov5
BUILD_DEMO_PATH=examples/yolov5/cpp
TARGET_SOC=rk356x
TARGET_ARCH=aarch64
BUILD_TYPE=Release
ENABLE_ASAN=OFF
DISABLE_RGA=OFF
DISABLE_LIBJPEG=OFF
INSTALL_DIR=/home/jiao/sknn/rknn_model_zoo/install/rk356x_linux_aarch64/rknn_yolov5_demo
BUILD_DIR=/home/jiao/sknn/rknn_model_zoo/build/build_rknn_yolov5_demo_rk356x_linux_aarch64_Release
CC=aarch64-linux-gnu-gcc
CXX=aarch64-linux-gnu-g++
```

```bash
cd ${BUILD_DIR}
cmake ../../${BUILD_DEMO_PATH} \
    -DTARGET_SOC=rk356x \
    -DCMAKE_SYSTEM_NAME=Linux \
    -DCMAKE_SYSTEM_PROCESSOR=aarch64 \
    -DCMAKE_BUILD_TYPE=Release \
    -DENABLE_ASAN=OFF \
    -DDISABLE_RGA=OFF \
    -DDISABLE_LIBJPEG=OFF \
    -DCMAKE_INSTALL_PREFIX=输出的
make -j4
make install
```

