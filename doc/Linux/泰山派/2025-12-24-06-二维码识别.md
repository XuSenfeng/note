# 二维码识别

```bash

sudo apt update && sudo apt install libopencv-dev
sudo apt-get install libzbar-dev
```



```cpp
#include <zbar.h>
#include <opencv2/opencv.hpp>
#include <string>
#include <vector>
#include <iostream>  // 补充iostream头文件（cerr/cout需要）

using namespace cv;
using namespace std;
using namespace zbar;

int main()
{
    // 1. 读取图像（替换为你的图片路径）
    Mat img = imread("test.jpg");
    if (img.empty()) {
        cerr << "错误：无法读取图片 test.jpg，请检查路径！" << endl;
        return -1;
    }

    // 2. 转换为灰度图
    Mat Gray;
    cvtColor(img, Gray, COLOR_BGR2GRAY);

    // 3. 准备ZBar图像数据
    int width = Gray.cols;
    int height = Gray.rows;
    uchar* raw_data = Gray.data;
    Image image(width, height, "Y800", raw_data, width * height);

    // 4. 初始化扫描器
    ImageScanner scanner;
    scanner.set_config(ZBAR_NONE, ZBAR_CFG_ENABLE, 1);

    // 5. 扫描条码/二维码
    int scan_result = scanner.scan(image);
    if (scan_result < 0) {
        cerr << "错误：扫描图像过程中发生错误！" << endl;
        return -1;
    } else if (scan_result == 0) {
        cout << "提示：未识别到任何条码/二维码！" << endl;
        return 0;
    }

    // 6. 定义结果结构体
    struct Result {
        string type;
        string content;
        vector<Point2f> points;
    };
    vector<Result> results;

    // 7. 遍历识别结果
    for (Image::SymbolIterator symbol = image.symbol_begin(); 
         symbol != image.symbol_end(); 
         ++symbol) {
        Result res;
        res.type = symbol->get_type_name();
        res.content = symbol->get_data();
        for (int i = 0; i < symbol->get_location_size(); i++) {
            res.points.push_back(Point2f(
                symbol->get_location_x(i),
                symbol->get_location_y(i)
            ));
        }
        results.push_back(res);
    }

    // 8. 仅控制台输出结果（移除图形界面）
    for (size_t i = 0; i < results.size(); i++) {
        cout << "========== 识别结果 " << i+1 << " ==========" << endl;
        cout << "类型：" << results[i].type << endl;
        cout << "内容：" << results[i].content << endl;
        cout << "顶点坐标：" << endl;
        for (size_t j = 0; j < results[i].points.size(); j++) {
            cout << "  点" << j+1 << "：(" << results[i].points[j].x << ", " << results[i].points[j].y << ")" << endl;
        }
    }

    // 9. 释放ZBar资源
    image.set_data(nullptr, 0);

    return 0;
}

```

使用findpackage的前提是包在安装时提供了一个名为`findXXX.cmake`或者`xxxconfig.cmake`的文件且加到环境变量中。
但zbar等以下轻量库并没有提供这个文件，是一个后缀为`.pc`的文件。`pkgconfig`是linux下的一个包管理器，与cmake类似，它通过`.pc`后缀文件来去管理包，获取包的相关信息。因此我们可以通过cmake调用`pkgconfig`来找到zbar的相关信息

```cmake
cmake_minimum_required(VERSION 3.5.1)

project(ZbarTest)
find_package(OpenCV REQUIRED)

find_package(PkgConfig REQUIRED)    # 找到pkgconfig
pkg_search_module(ZBAR REQUIRED zbar) # 通过pkgconfig查找zbar，然后就可以使用ZBAR_INCLUDE_DIRS和ZBAR_LIBRARIES变量了

add_executable(main test.cpp)
target_include_directories(main PRIVATE ${OpenCV_INCLUDE_DIRS} ${ZBAR_INCLUDE_DIRS})
target_link_libraries(main PRIVATE ${OpenCV_LIBS} ${ZBAR_LIBRARIES})
```

