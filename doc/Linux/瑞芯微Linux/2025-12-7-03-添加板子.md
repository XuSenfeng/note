# 添加板子

## mk文件

从build.sh文件里面可以获取到

```bash
	RK_TARGET_BOARD_ARRAY=($(
		cd ${TARGET_PRODUCT_DIR}/
		ls BoardConfig_*/BoardConfig*.mk | sort
	))
```

他会获取这个文件夹下面的所有文件

![image-20251207223158783](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202512072231867.png)

在函数`choose_target_board`里面进行实际的开发板选择, 以及选择使用的存储媒介, 使用的根文件系统, 最终根据使用的配置获取到上面的板子文件

最终这个文件被链接到./.BoardConfig.mk文件上面

```bash
jiao@jiao-virtual-machine:~/rv/echo-mate/Echo-Mate/SDK/rv1106-sdk$ ls ./.BoardConfig.mk -l
lrwxrwxrwx 1 jiao jiao 87 12月  4 17:42 ./.BoardConfig.mk -> project/cfg/BoardConfig_IPC/BoardConfig-SPI_NAND-Buildroot-RV1106_Echo_Mate-DeskMate.mk
```

### 文件内容

所有的配置可以在`project/cfg-all-items-introduction.txt`里面看到

这个文件里面配置开发板实际使用的配置

+ 芯片: rv1106
+ 使用的设备树: rv1106g-echo-mate.dts
+ 使用的uboot默认配置: echo_rv1106_uboot_defconfig
+ 内核基础配置: echo_rv1106_linux_defconfig
+ 使用Wifi

## build.sh脚本

传入的命令解析

```bash
num=$#
option=""
# 遍历所有的命令
while [ $# -ne 0 ]; do
	case $1 in
	DEBUG) export RK_BUILD_VERSION_TYPE=DEBUG ;;
	all) option=build_all ;;
	save) option=build_save ;;
	allsave) option=build_allsave ;;
	check) option=build_check ;;
	clean)
		option="build_clean $2"
		break # 后面的参数忽略
		;;
	firmware) option=build_firmware ;;
	ota) option=build_ota ;;
	updateimg) option=build_updateimg ;;
	unpackimg) option=build_unpack_updateimg ;;
	factory) option=build_factory ;;
	recovery) option=build_recovery ;;
	env) option=build_env ;;
	meta) option=build_meta ;;
	driver) option=build_driver ;;
	sysdrv) option=build_sysdrv ;;
	uboot) option=build_uboot ;;
	kernel) option=build_kernel ;;
	rootfs) option=build_rootfs ;;
	media) option=build_media ;;
	app) option=build_app ;;
	info) option=build_info ;;
	tool) option=build_tool ;;
	buildrootconfig) option=buildroot_config ;;
	kernelconfig) option=kernel_config ;;
	*) option=usage ;;
	esac
	if [ $((num)) -gt 0 ]; then
		# shift 会将参数列表左移一位，每次处理完 $1 后
		# 下一个参数变成新的 $1
		shift
	fi
done
# 如果 option 非空（已匹配到有效参数），则使用 option 的值；
# 如果 option 为空（如仅传 DEBUG、或未传任何参数），则使用默认值 build_allsave。
eval "${option:-build_allsave}"
```

默认执行的是build_allsave

```bash
function build_allsave() {
	# rm -rf ${RK_PROJECT_OUTPUT_IMAGE} ${RK_PROJECT_OUTPUT}
	build_all
	build_save

	build_check_power_domain

	finish_build
}
```

### build_recovery升级分区

| 特性        | update.img                                                   | update_ota.tar                                               |
| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 核心定位    | 瑞芯微标准全量系统镜像包                                     | OTA（空中升级）专用压缩包                                    |
| 格式 / 结构 | 瑞芯微定制的镜像格式（含分区表、烧录引导信息、所有分区镜像） | 标准 tar 压缩包（仅含升级必需的镜像 + 脚本）                 |
| 生成逻辑    | 由 `build_updateimg` 生成，整合 `uboot.img`/`boot.img`/ `rootfs.img`/`recovery.img`/ `oem.img`/`userdata.img` 等**所有分区镜像**，是系统的 “完整备份” | 由 `build_ota` 生成，仅打包升级必需的镜像（默认 `uboot.img`/`boot.img`/ `rootfs.img`，或自定义 `RK_OTA_RESOURCE`）+ `RK_OTA_update.sh` 升级脚本，是 “最小升级集” |
| 依赖条件    | 无需依赖设备现有系统（裸机 / 砖机均可烧录）                  | 依赖设备已启用 `Recovery` 模式（需 `recovery.img` 正常运行） |
| 体积        | 大（包含全部分区，通常数百 MB~ 数 GB）                       | 小（仅含核心升级镜像，可按需精简）                           |

[Rockchip_Developer_Guide_Linux_Recovery_CN.pdf](https://lo01.g77k.com/aeb/docs/cn/Linux/Recovery/Rockchip_Developer_Guide_Linux_Recovery_CN.pdf)

这个脚本是**瑞芯微（RK）嵌入式平台下 Recovery 镜像（recovery.img）的完整构建流程**，Recovery 是嵌入式系统的 “恢复模式”（用于系统升级、分区修复、出厂恢复等），脚本的核心目标是编译 Recovery 依赖组件、生成配套的操作脚本、打包根文件系统，并最终生成可烧录的 recovery.img

用于进行OTA升级, 需要在配置文件里面加入RK_ENABLE_RECOVERY(未使用)

![image-20251208100103532](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202512081001646.png)

> 官方的编译示例
>
> rootfs 需要打开update 的支持，configs 文件配置 BR2_PACKAGE_UPDATE=y
>
> ```bash
> source envsetup.sh
>  #choose a combo number to build rootfs according to platform chip
> make menuconfig
> 
> Target packages  --->
>      [*] Rockchip BSP packages  --->
>          [*]  Rockchip OTA update for linux
> ```
>
> buildroot/configs/rockchip/recovery.config 中已经将不同平台的recovery配置抽取出来 了。 只需系统根目录下执行
>
> ```bash
>  ./build.sh recovery
> ```
>
> 成功后，会生成文件  buildroot/output/rockchip_rkxxxx_recovery/images/recovery.img 
>
> ```bash
>  ./mkfirmware.sh
> ```
>
> 会将生成的固件拷贝至 rockdev/目录下
>
> + 升级固件
>
> 修改  tools/linux/Linux_Pack_Firmware/rockdev/package-file ，根据需要升级的分区配置，修改 该文件, 可以指定实际需要升级的分区而不是所有的分区
>
> ```bash
> ./build.sh updateimg
> ```
>
> 命令执行成功后，会将package-file指定的分区镜像打包生成update.img 升级固件，放在 rockdev/目录下。 使用该update.img 升级
>
> + 实际的升级
>
> 将升级固件 update.img 放在 SD 卡或 U 盘根目录或者设备的/userdata 目录下
>
> Normal 系统下执行升级程序  update ota /xxx/update.img，设备将会进入 recovery 模式，并进 行升级。
>
> > U 盘的挂载路径： /udisk sdcard 的挂载路径： /mnt/sdcard/ 或/sdcard flash 的挂载路径： /userdata/
> >
> > 放在/userdata分区的升级的时候, 这个分区不要打包在update.img文件里面
>
> 查看脚本有RkLunch-recovery.sh脚本可以用于使用使用update_ota.tar升级, 但未找到相关资料
>
> + 恢复出厂设置
>
> 我们把可以读写的配置文件保存在 userdata 分区，出厂固件会默认一些配置参数，用户使用一 段时间后 会生成或修改配置文件，有时用户需要清除这些数据，我们就需要恢复到出厂配置。直接运行 update 后面不加任何参数或者加  factory/reset 参数均可进入 recovery 后恢复出厂配置

Recovery 依赖精简版内核和 Busybox（嵌入式基础命令集，如 `dd`/`sh`/`flash_eraseall` 等）, 所以需要编译出来

```bash
# 创建必要目录
mkdir -p $RK_PROJECT_PATH_RAMDISK_TINY_ROOTFS $RK_PROJECT_PATH_RAMDISK
# 清理旧的Busybox编译产物 → 编译Busybox+内核 → 再次清理临时产物
make busybox_clean -C ${SDK_SYSDRV_DIR}
make -C ${SDK_SYSDRV_DIR} \
    OUTPUT_SYSDRV_RAMDISK_TINY_ROOTFS_DIR=$RK_PROJECT_PATH_RAMDISK_TINY_ROOTFS \
    OUTPUT_SYSDRV_RAMDISK_DIR=$RK_PROJECT_PATH_RAMDISK \
    busybox kernel
make busybox_clean -C ${SDK_SYSDRV_DIR}
```

初始化一系列的变量

```bash
# 内核镜像路径（按架构区分zImage/Image）
local kernel_image          
# 设备树文件（.dts编译后生成.dtb）
local kernel_dtb_file="$RK_PROJECT_PATH_RAMDISK/${RK_KERNEL_DTS/%.dts/.dtb}"  
# OTA升级脚本路径
local ota_script="$OTA_SCRIPT_PATH/RK_OTA_update.sh"  
# 擦除misc分区脚本
local erase_misc_script="$RK_PROJECT_PATH_RAMDISK_TINY_ROOTFS/usr/bin/RK_OTA_erase_misc.sh"  
# 根文件系统默认打包格式（cpio）
local ramdisk_file="rootfs.cpio"  
```

Recovery 依赖精简版内核和 Busybox, 需要编译出来

```bash
# 创建必要目录
mkdir -p $RK_PROJECT_PATH_RAMDISK_TINY_ROOTFS $RK_PROJECT_PATH_RAMDISK
# 清理旧的Busybox编译产物 → 编译Busybox+内核 → 再次清理临时产物
make busybox_clean -C ${SDK_SYSDRV_DIR}
make -C ${SDK_SYSDRV_DIR} \
OUTPUT_SYSDRV_RAMDISK_TINY_ROOTFS_DIR=$RK_PROJECT_PATH_RAMDISK_TINY_ROOTFS \
    OUTPUT_SYSDRV_RAMDISK_DIR=$RK_PROJECT_PATH_RAMDISK \
    busybox kernel
make busybox_clean -C ${SDK_SYSDRV_DIR}
```

+ `DK_SYSDRV_DIR`：平台系统驱动 / 基础组件的编译目录；
+ 编译产物输出到 `RK_PROJECT_PATH_RAMDISK`（Recovery 根文件系统目录）。

之后就是在生成的根文件系统里面生成使用的脚本

### build_sysdrv

> `build_all` 没有直接调用 `build_kernel`，而是通过调用 `build_sysdrv`，由 `build_sysdrv` 执行 `${SDK_SYSDRV_DIR}` 目录下的 `Makefile`，间接触发内核编译
>
> 实际的编译文件是sysdrv/Makefile

这段脚本是**Luckfox（瑞芯微）SDK 中「系统驱动 / 基础组件（sysdrv）」的构建核心流程**，核心目标是完成 sysdrv 组件编译，并将编译生成的根文件系统（rootfs）压缩包解压到指定输出目录，同时给出自定义文件的添加指引，最终完成整个 sysdrv 构建阶段

```bash
mkdir -p ${RK_PROJECT_OUTPUT_IMAGE}
# 实际的编译命令sysdrv, 在这个文件夹里面执行make命令
make -C ${SDK_SYSDRV_DIR}
# output/out/sysdrv_out/rootfs_uclibc_rv1106.tar
rootfs_tarball="$RK_PROJECT_PATH_SYSDRV/rootfs_${RK_LIBC_TPYE}_${RK_CHIP}.tar"
# output/out/rootfs_uclibc_rv1106
rootfs_out_dir="$RK_PROJECT_OUTPUT/rootfs_${RK_LIBC_TPYE}_${RK_CHIP}"
# 创建文件夹
if ! [ -d $RK_PROJECT_OUTPUT ]; then
    mkdir -p $RK_PROJECT_OUTPUT
fi
# 解压文件
if [ -f $rootfs_tarball ]; then
    if [ -d $rootfs_out_dir ]; then
        rm -rf $rootfs_out_dir
    fi
    tar xf $rootfs_tarball -C $RK_PROJECT_OUTPUT
else
    msg_error "Not found rootfs tarball: $rootfs_tarball"
    exit 1
fi

msg_info "If you need to add custom files, please upload them to <Luckfox Sdk>/output/out/rootfs_${RK_LIBC_TPYE}_${RK_CHIP}."
# 打印一行提示返回
finish_build
```

编译 sysdrv 下的所有组件（包括内核驱动、精简版根文件系统 rootfs、Busybox 等基础工具），编译完成后会自动生成 rootfs 的 tar 压缩包（后续要解压的文件）

### build_media

在media文件夹下面执行make命令

### build_app

 **Luckfox / 瑞芯微（RK）嵌入式平台应用层（App）构建流程的核心片段**，主要包含两大核心逻辑：**WiFi 自动连接配置生成（可选）** 和 **应用层代码编译**，整体服务于 “定制化配置 + 应用编译” 的完整流程，适配嵌入式设备的应用开发场景

```bash
# 配置使用WIFI
if [ "$RK_ENABLE_WIFI" = "y" ]; then
    echo "Set Wifi SSID and PASSWD"
    # 检查 LF_WIFI_PSK（WiFi密码）、
    # LF_WIFI_SSID（WiFi名称）配置项是否定义，未定义则退出
    check_config LF_WIFI_PSK LF_WIFI_SSID || return 0
    touch $WIFI_NEW_CONF
    # 写入wpa_supplicant格式的WiFi配置
    # （嵌入式WiFi连接核心配置）
    cat >$WIFI_NEW_CONF <<EOF
ctrl_interface=/var/run/wpa_supplicant
ap_scan=1
update_config=1

network={
	ssid="$LF_WIFI_SSID"
	psk="$LF_WIFI_PSK"
	key_mgmt=WPA-PSK
}
EOF
    # 将临时配置文件移动到正式的WiFi配置路径（覆盖/替换原有配置）
    # /wifi_app/wpa_supplicant.conf
    mv $WIFI_NEW_CONF $WIFI_CONF
fi
# 查看应用的类型, 设置设置的是RKIPC_RV1106
check_config RK_APP_TYPE || return 0

echo "============Start building app============"
echo "TARGET_APP_CONFIG=$RK_APP_DEFCONFIG $RK_APP_DEFCONFIG_FRAGMENT $RK_APP_TYPE"
echo "========================================="
# 导出meta层头文件（供应用编译依赖，比如硬件抽象层、系统接口的头文件）
build_meta --export # export meta header files
#build_meta --export --media_dir $RK_PROJECT_PATH_MEDIA # for rtl8723bs
# 检查应用代码目录是否存在，存在则进入目录执行make编译
test -d ${SDK_APP_DIR} && make -C ${SDK_APP_DIR}
```

在 Luckfox/RK 嵌入式平台中，“meta” 是设备的「核心元数据组件」，常见用途包括：

1. 存储设备硬件信息（芯片型号、内存大小、外设配置）；
2. 定义系统分区表（比如 boot/rootfs/recovery/meta 分区的大小、偏移）；
3. 保存系统版本号、出厂配置、加密密钥等；
4. 为应用层 / 驱动层提供统一的配置接口（比如之前应用编译时 `build_meta --export` 就是导出 meta 的头文件，让应用能读取这些配置）。

```bash
function build_meta() {
	msg_info "============Start building meta============"
	if [ -n "$RK_META_SIZE" ]; then
		# 查看这个文件是不是存在(判断失败返回)
		if [ -d "${RK_PROJECT_TOP_DIR}/make_meta" ]; then
			${RK_PROJECT_TOP_DIR}/make_meta/build_meta.sh $@
		fi
	fi
	finish_build
}
```

> 实际这个文件不存在

### build_firmware

```bash
# 查看分区表配置是不是有效
#"256K(env),256K@256K(idblock),512K(uboot),4M(boot),30M(oem),10M(userdata),210M(rootfs)"
check_config RK_PARTITION_CMD_IN_ENV || return 0
# 构建环境变量镜像（env.img，存储uboot/env参数、系统启动配置）
build_env
# 没有使用
build_meta

mkdir -p ${RK_PROJECT_OUTPUT_IMAGE}
# 启用Rercovery升级的话
if [ "$RK_ENABLE_RECOVERY" = "y" -a -f $PROJECT_TOP_DIR/scripts/${RK_MISC:=recovery-misc.img} ]; then
    cp -fv $PROJECT_TOP_DIR/scripts/$RK_MISC ${RK_PROJECT_OUTPUT_IMAGE}/misc.img
fi
# 打包根文件系统（rootfs）：将解压后的rootfs目录打包为镜像/压缩包
# 在这个函数里面写入一些配置文件
__PACKAGE_ROOTFS
# 打包OEM分区：OEM分区用于存储厂商自定义配置、应用、资源文件
__PACKAGE_OEM
# 生成“核心转储（coredump）启用脚本”：方便调试程序崩溃问题
__BUILD_ENABLE_COREDUMP_SCRIPT
# 执行OEM打包前的自定义脚本：支持厂商在OEM打包前插入定制逻辑（如修改配置、添加文件）
__RUN_PRE_BUILD_OEM_SCRIPT
# 是否将应用打包到独立 OEM 分区
if [ "$RK_BUILD_APP_TO_OEM_PARTITION" = "y" ]; then
	# 将应用单独打包到OEM镜像（OEM分区独立）
    rm -rf $RK_PROJECT_PACKAGE_ROOTFS_DIR/oem/*
    mkdir -p $RK_PROJECT_PACKAGE_ROOTFS_DIR/oem
    build_mkimg $GLOBAL_OEM_NAME $RK_PROJECT_PACKAGE_OEM_DIR
else
	# 将OEM文件合并到rootfs的oem目录（无独立OEM分区）
    mkdir -p $RK_PROJECT_PACKAGE_ROOTFS_DIR/oem
    __COPY_FILES $RK_PROJECT_PACKAGE_OEM_DIR $RK_PROJECT_PACKAGE_ROOTFS_DIR/oem
    rm -rf $RK_PROJECT_PACKAGE_OEM_DIR
fi
# 执行打包后的自定义脚本：如修改镜像权限、添加校验、清理临时文件
__RUN_POST_BUILD_SCRIPT
#  叠加自定义配置/文件：将SDK中“overlay目录”的自定义文件覆盖到镜像中（无需修改原始rootfs）
post_overlay
# 启用INITRAMFS启动（内存根文件系统）→ 打包boot.img
if [ -n "$GLOBAL_INITRAMFS_BOOT_NAME" ]; then
    build_mkimg boot $RK_PROJECT_PACKAGE_ROOTFS_DIR
fi
# 根据Fastboot配置选择打包目标
if [ "$RK_ENABLE_FASTBOOT" = "y" ]; then
	# Fastboot模式打包boot.img
    build_mkimg boot $RK_PROJECT_PACKAGE_ROOTFS_DIR
else
	# 普通模式打包rootfs.img
    build_mkimg $GLOBAL_ROOT_FILESYSTEM_NAME $RK_PROJECT_PACKAGE_ROOTFS_DIR
fi

# package a empty userdata parition image
# 打包空的 userdata 分区镜像
mkdir -p $RK_PROJECT_PACKAGE_USERDATA_DIR
build_mkimg userdata $RK_PROJECT_PACKAGE_USERDATA_DIR
# 构建TFTP/SD卡升级包：支持通过TFTP（网络）或SD卡刷机
build_tftp_sd_update
# 启用Recovery/OTA时，构建OTA升级包
[ "$RK_ENABLE_RECOVERY" = "y" -o "$RK_ENABLE_OTA" = "y" ] && build_ota
# 构建统一更新镜像（update.img）：瑞芯微标准刷机镜像，支持RKDevTool工具烧录
build_updateimg

# Spi_nand mklink
# SPI NAND 是嵌入式常用的闪存介质，其镜像格式 / 路径有特殊要求
if [ "${RK_BOOT_MEDIUM}" == "spi_nand" ]; then
    msg_info "MEDIUM SPI_NAND relink Image"
    files=("${RK_PROJECT_OUTPUT_IMAGE}/oem.img"
        "${RK_PROJECT_OUTPUT_IMAGE}/rootfs.img"
        "${RK_PROJECT_OUTPUT_IMAGE}/userdata.img")
    for file in "${files[@]}"; do
        if [ -e "$file" ]; then
        	# 获取镜像的实际路径（可能是软链接）
            filename=$(basename "$file")
            target=$(readlink -f "$file")
             # 删除原软链接
            rm "$file"
            # 将实际文件移到输出目录
            mv "$target" "$RK_PROJECT_OUTPUT_IMAGE/$filename"
        fi
    done
    # 删除所有.ubi格式文件（SPI NAND不使用UBI镜像，清理冗余）
    find "${RK_PROJECT_OUTPUT_IMAGE}" -type f -name "*.ubi" -exec rm {} +
fi
finish_build
```

###  build_ota

这段脚本是 **Luckfox / 瑞芯微（RK）嵌入式平台中「OTA 升级包（update_ota.tar）的构建逻辑」**，核心作用是：仅当启用 Recovery 或 OTA 功能时，将系统升级所需的核心镜像（如 uboot/boot/rootfs.img）和 Recovery 模式下的 OTA 升级脚本打包成 `update_ota.tar` 压缩包 —— 该包是设备 OTA 升级的核心载体，Recovery 模式下解压此包并执行脚本即可完成系统升级。

```bash
check_config RK_ENABLE_RECOVERY || check_config RK_ENABLE_OTA || return 0
# update_img：存储要打包到 OTA 包中的镜像列表（如 uboot.img、boot.img）；
# update_script：存储要打包的 OTA 升级脚本（RK_OTA_update.sh）；
# tar_cmd：存储最终执行的 tar 打包命令。
local update_img update_script tar_cmd

if [ -z "$RK_OTA_RESOURCE" ]; then
	# 使用默认镜像（uboot.img/boot.img/rootfs.img）
    for img in uboot.img boot.img rootfs.img; do
        if [ -f "$RK_PROJECT_OUTPUT_IMAGE/$img" ]; then
            update_img="$update_img $img"
        else
            msg_warn "Not found $img, check again!!!"
        fi
    done
else
	# 自定义了OTA镜像列表（RK_OTA_RESOURCE）→ 使用自定义列表
    update_img="$RK_OTA_RESOURCE"
fi

[[ "$RK_ENABLE_RECOVERY" = "y" ]] && update_script="-C $OTA_SCRIPT_PATH RK_OTA_update.sh"

tar_cmd="tar -cvhf  $RK_PROJECT_OUTPUT_IMAGE/update_ota.tar \
             -C $RK_PROJECT_OUTPUT_IMAGE $update_img \
             $update_script"
eval $tar_cmd

finish_build
```

tar命令参数说明：

- `-c`：创建新的 tar 包；
- `-v`：可视化输出打包过程（打印包含的文件）；
- `-h`：跟随软链接（打包软链接指向的实际文件，避免打包空链接）；
- `-f`：指定输出的 tar 包文件名（update_ota.tar）；
- `-C $RK_PROJECT_OUTPUT_IMAGE`：先进入镜像输出目录，再打包 `$update_img`（确保 tar 包内镜像无绝对路径）。

- `eval $tar_cmd`：执行构造的 tar 命令，最终在 `${RK_PROJECT_OUTPUT_IMAGE}` 目录生成 `update_ota.tar`。

## 编译脚本

所有文件的编译文件是sysdrv/Makefile

核心目标是自动化编译、打包嵌入式系统所需的 UBoot、Linux 内核、根文件系统（rootfs）、UBoot 环境配置等核心组件，同时提供灵活的配置适配和清理 / 调试辅助功能。

1. **环境与参数初始化**
    - 定义基础路径（`SYSDRV_DIR`为当前目录）、编译环境（强制 C 语言环境、指定 bash shell）、构建版本（RELEASE/DEBUG）、交叉编译工具链（支持外部传入`RK_TOOLCHAIN_CROSS`覆盖）、C 库类型（默认 glibc）。
    - 支持**外部参数覆盖默认配置**（如`RK_BOOT_MEDIUM`指定启动介质、`RK_KERNEL_DTS`指定内核设备树、`RK_ROOTFS_FS_TYPE`指定根文件系统格式），适配不同硬件 / 构建需求。
    - 配置启动介质（默认 emmc，支持 spi_nor/spi_nand/sd_card 等）、分区信息（通过脚本`get_part_info.sh`获取 rootfs/env 分区的大小 / 编号）。
2. **输出目录与工具配置**
    - 划分清晰的输出目录结构：`out/`下分镜像（image）、板端工具（board）、PC 端工具（pc）、根文件系统（rootfs）子目录，区分 PC / 板端产物。
    - 关联镜像制作工具（如`mkfs_ext4.sh`/`mkfs_ubi.sh`）、分区解析脚本，适配 ext4/ubi/jffs2/squashfs/erofs 等根文件系统格式。

编译的目标

```makefile
all: uboot kernel rootfs env
```

在使用buildroot的时候rootfs依赖于

```makefile
ROOTFS_BUILD_ENV := rootfs_prepare pctools buildroot boardtools drv
```

### 编译uboot

> 可以使用./build.sh info查看使用的参数

```makefile
uboot: prepare
	@echo -e "$(C_GREEN) ==sysdrv== build uboot  $(C_NORMAL)"
	# 根据配置文件生成配置文件
	# make -C $(UBOOT_DIR)echo_rv1106_uboot_defconfig rk-sfc.config
	@$(MAKE) -C $(UBOOT_DIR) $(UBOOT_CFG) $(UBOOT_CFG_FRAGMENT)
	# 切换目录, 同时把目录名压栈, 之后执行实际的编译命令
	# 执行结束返回
	pushd $(UBOOT_DIR);$(UBOOT_COMPILE_MAKE) $(UBOOT_COMPILE_MAKE_OPTS) CROSS_COMPILE=$(CROSS_COMPILE);popd
	# 编译成功的时候输出uboot.img到输出目录里面
	$(AT)test ! -f $(UBOOT_DIR)/uboot.img || cp -fv $(UBOOT_DIR)/uboot.img $(SYSDRV_DIR_OUT_IMAGE)
	# 复制BOOT 目录下的原始 IDBLOCK 文件为idblock.img
	$(AT)cp -fv $(UBOOT_DIR)/$(IDBLOCK_SRC_BIN) $(SYSDRV_DIR_OUT_IMAGE)/$(IDBLOCK_IMG)
	# download.bin
	$(AT)cp -fv $(UBOOT_DIR)/$(DOWNLOAD_SRC_BIN) $(SYSDRV_DIR_OUT_IMAGE)/$(DOWNLOAD_BIN)
	# 批量拷贝
	$(call MAROC_COPY_PKG_TO_SYSDRV_OUTPUT, $(OUTPUT_IMAGE_PATH), \
		$(SYSDRV_DIR_OUT_IMAGE)/$(IDBLOCK_IMG) \
		$(SYSDRV_DIR_OUT_IMAGE)/uboot.img \
		$(SYSDRV_DIR_OUT_IMAGE)/$(DOWNLOAD_BIN))

```

```bash
cd /home/jiao/rv/echo-mate/Echo-Mate/SDK/rv1106-sdk/sysdrv/source/uboot/u-boot
make echo_rv1106_uboot_defconfig rk-sfc.config
./make.sh --spl-new CROSS_COMPILE=arm-rockchip830-linux-uclibcgnueabihf- 
cp -fv ./*_idblock_v*.img idblock.img 
cp -fv ./*_download_v*.bin download.bin
```

### 编译kernel

```makefile
kernel: prepare
	@echo -e "$(C_GREEN) ==sysdrv== build kernel  $(C_NORMAL)"
ifeq ($(RK_ENABLE_FASTBOOT), y)
	# fastboot 模式下需确保驱动模块完整
	$(call MACRO_CHK_DRIVER_MODULE, $(SYSDRV_DIR)/drv_ko/rockit/, rockit-ko)
	$(call MACRO_CHK_DRIVER_MODULE, $(SYSDRV_DIR)/drv_ko/kmpp/, kmpp)
endif
	# 删除旧的 DTB 文件（设备树）
	@rm -rf $(KERNEL_DTB)
	# 生成.config文件
	$(MAKE) -C $(KERNEL_DIR) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) $(KERNEL_CFG) $(KERNEL_CFG_FRAGMENT)
	# 编译内核, 设备树(img后缀), 指定 U-Boot 的镜像描述文件（ITS）
	# 用于打包内核镜像为 U-Boot 可识别的格式
	$(MAKE) -C $(KERNEL_DIR) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) $(KERNEL_DTS:dts=img) BOOT_ITS=boot.its -j$(SYSDRV_JOBS)
ifeq ($(RK_ENABLE_FASTBOOT), y)
	$(call MACRO_CLEAN_DRIVER_MODULE, rockit-ko)
	$(call MACRO_CLEAN_DRIVER_MODULE, kmpp)
endif
	# 复制vmlinux镜像
	cp -fv $(KERNEL_DIR)/vmlinux $(SYSDRV_DIR_OUT_BOARD)
	# RK 平台自定义脚本，修改 DTB 文件中的内核启动参数
	update_dtb_bootargs.sh --cmdline '$(KERNEL_CMDLINE_FRAGMENT)' --dtb $(KERNEL_DTB) --output $(KERNEL_DTB)
ifneq ($(RK_ENABLE_FASTBOOT), y)
	# 将修改后的 DTB重新整合到resource.img/boot.img中
	# 手动修改 DTB 后，DTB 的时间戳更新，但 Makefile 无法关联 “DTB 更新→需要重新打包 img”
	$(MAKE) -C $(KERNEL_DIR) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) $(KERNEL_DTS:dts=img) BOOT_ITS=boot.its -j$(SYSDRV_JOBS)
endif
ifneq ($(KERNEL_DTB),)
	# 有dtb的时候, 复制dtb
	cp -fv $(KERNEL_DTB) $(SYSDRV_DIR_OUT_BOARD)
endif
	# Start install kernel drivers
	# 分场景拷贝内核产物
ifeq ($(SYSDRV_BUILD_RAMDISK_FLAG),YES)
	$(call MAROC_COPY_PKG_TO_SYSDRV_OUTPUT, $(OUTPUT_SYSDRV_RAMDISK_DIR), \
		$(KERNEL_DIR)/arch/$(ARCH)/boot/Image* \
		$(KERNEL_DTB) \
		$(KERNEL_DIR)/arch/$(ARCH)/boot/zImage \
		$(KERNEL_DIR)/resource.img)
else
ifneq ($(RK_ENABLE_FASTBOOT), y)
	cp -fv $(KERNEL_DIR)/boot.img $(SYSDRV_DIR_OUT_IMAGE)/boot.img
endif
ifneq ($(OUTPUT_FASTBOOT_IMAGE_PATH),)
	$(call MAROC_COPY_PKG_TO_SYSDRV_OUTPUT, $(OUTPUT_FASTBOOT_IMAGE_PATH), $(KERNEL_DIR)/arch/$(ARCH)/boot/Image)
	$(call MAROC_COPY_PKG_TO_SYSDRV_OUTPUT, $(OUTPUT_FASTBOOT_IMAGE_PATH), $(KERNEL_DIR)/resource.img)
	$(call MAROC_COPY_PKG_TO_SYSDRV_OUTPUT, $(OUTPUT_FASTBOOT_IMAGE_PATH), $(KERNEL_DTB))
endif
	$(call MAROC_COPY_PKG_TO_SYSDRV_OUTPUT, $(OUTPUT_IMAGE_PATH), $(SYSDRV_DIR_OUT_IMAGE)/boot.img)
	$(call MAROC_COPY_PKG_TO_SYSDRV_OUTPUT, $(OUTPUT_BOARD_BIN_PATH), \
		$(SYSDRV_DIR_OUT_BOARD)/$(KERNEL_DTS:dts=dtb) $(SYSDRV_DIR_OUT_BOARD)/vmlinux)
endif
```

```bash
cd /home/jiao/rv/echo-mate/Echo-Mate/SDK/rv1106-sdk/sysdrv/source/kernel
make ARCH=arm CROSS_COMPILE=arm-rockchip830-linux-uclibcgnueabihf- echo_rv1106_linux_defconfig 
make ARCH=arm CROSS_COMPILE=arm-rockchip830-linux-uclibcgnueabihf- BOOT_ITS=boot.its rv1106g-echo-mate.img -j15
```

### rootfs

```bash
rootfs: $(ROOTFS_BUILD_ENV)
	@echo -e "$(C_GREEN) ==sysdrv== build rootfs  $(C_NORMAL)"
	# make strip裁剪二进制文件(可执行程序、.so 库)的符号表,调试信息
	make -C $(SYSDRV_DIR) strip
	# 切换到 sysdrv/out 目录
	# 将 rootfs 目录打包为单个 tar 包, 返回
	pushd $(SYSDRV_DIR)/out;tar cf $(OUT_ROOTFS).tar $(OUT_ROOTFS);popd
	@# RK_PARTITION_FS_TYPE_CFG is defined outside of sysdrv,
	@# so if defined RK_PARTITION_FS_TYPE_CFG, we ignore SYSDRV_ROOTFS_BUILD_TARGET
	@test "$(ROOTFS_PART_SIZE)" = "FAIL" || \
		test "$(RK_PARTITION_FS_TYPE_CFG)x" != "x" || \
		make -C $(SYSDRV_DIR) $(SYSDRV_ROOTFS_BUILD_TARGET)
	$(call MAROC_COPY_PKG_TO_SYSDRV_OUTPUT, $(OUTPUT_ROOTFS_SOURCE_DIR), $(SYSDRV_DIR)/out/$(OUT_ROOTFS).tar )
	$(call MAROC_COPY_PKG_TO_SYSDRV_OUTPUT, $(OUTPUT_ROOTFS_TOOLS_DIR), $(SYSDRV_DIR)/out/bin )
	@echo -e "$(C_GREEN) ==sysdrv== finish sysdrv build  $(C_NORMAL)"
```

#### prepare

```makefile
rootfs_prepare: prepare
	@echo -e "$(C_GREEN) ==sysdrv== prepare rootfs   $(C_NORMAL)"
	rm -rf $(SYSDRV_DIR_OUT_ROOTFS)
	mkdir -p $(SYSDRV_DIR_OUT_ROOTFS)
	# 解压 rootfs 基础脚本 / 配置, 解压到指定的 rootfs 目录
	# sysdrv/out/rootfs_uclibc_rv1106, 里面是一个基础的rootfs框架
	tar xf $(SYSDRV_DIR)/tools/board/rootfs_script.tar -C $(SYSDRV_DIR_OUT_ROOTFS)
	# 解压交叉编译器运行时库
	tar xjf $(TOOLCHAIN_DIR)/$(TOOLCHAIN_RUNTIME_LIB)/$(TOOLCHAIN_RUNTIME_LIB_C) -C $(SYSDRV_DIR_OUT_ROOTFS)
	# 这些调试库体积大且量产时无用，迁移到SYSDRV_DIR_OUT_BOARD(板级调试目录)
	pushd $(SYSDRV_DIR_OUT_ROOTFS)/lib/ ; mv -fv \
		libasan_preinit.o \
		libasan.so* \
		libtsan.so* \
		libubsan.so* \
		libSegFault.so \
		libmemusage.so* \
		libpcprofile.so* \
		libthread_db*.so* \
		libBrokenLocale* \
		libinproctrace.so \
		$(SYSDRV_DIR_OUT_BOARD); \
	popd
```

实际的rootfs_script.tar里面的结构如下

```bash
.
├── bin
├── data -> userdata
├── dev
├── etc
│   ├── fstab
│   ├── group
│   ├── hostname
│   ├── hosts
│   ├── init.d
│   │   ├── rcK
│   │   ├── rcS
│   │   └── S20urandom
│   ├── inittab
│   ├── mtab -> ../proc/self/mounts
│   ├── network
│   │   ├── if-down.d
│   │   ├── if-post-down.d
│   │   ├── if-pre-up.d
│   │   │   └── wait_iface
│   │   ├── if-up.d
│   │   └── interfaces
│   ├── nsswitch.conf
│   ├── os-release -> ../usr/lib/os-release
│   ├── passwd
│   ├── profile
│   ├── profile.d
│   │   ├── RkEnv.sh
│   │   └── umask.sh
│   ├── protocols
│   ├── resolv.conf -> ../tmp/resolv.conf
│   ├── services
│   └── shadow
├── lib
├── lib32 -> lib
├── lib64 -> lib
├── media
├── mnt
│   └── sdcard
├── oem
├── opt
├── proc
├── root
├── run
├── sbin
├── sys
├── tmp
├── userdata
├── usr
│   ├── bin
│   ├── lib
│   ├── lib32 -> lib
│   ├── lib64 -> lib
│   ├── sbin
│   └── share
│       └── udhcpc
│           ├── default.script
│           └── default.script.d
└── var
    ├── cache -> ../tmp
    ├── lib
    │   └── misc -> ../../tmp
    ├── lock -> ../tmp
    ├── log -> ../tmp
    ├── run -> ../run
    ├── spool -> ../tmp
    ├── tmp -> ../tmp
    └── www
```

| 库名               | 作用（为什么迁移）                                           |
| ------------------ | ------------------------------------------------------------ |
| libasan/tsan/ubsan | 内存 / 线程 / 未定义行为检测的调试库（ASAN/TSAN/UBSAN），仅调试用，量产无需 |
| libSegFault.so     | 段错误调试库（打印段错误堆栈），量产不需要                   |
| libmemusage.so     | 内存使用分析库，调试性能用                                   |
| libpcprofile.so    | 性能分析库，调试用                                           |
| libthread_db*.so   | 线程调试库（gdb 调试线程用），量产无需                       |
| libBrokenLocale    | 兼容旧字符集的库，嵌入式系统通常不用                         |
| libinproctrace.so  | 进程跟踪调试库，调试用                                       |

#### pctools

实际是给out/bin/pc下面的文件执行权限

#### buildroot

条件化初始化 Buildroot 环境（解压源码 + 定制配置 / 补丁）→ 配置 Buildroot（适配开发板）→ 优化镜像源（加速下载）→ 下载依赖源码 → 多核编译 Buildroot

```makefile
buildroot: prepare
	@echo -e "$(C_GREEN) ==sysdrv== build buildroot   $(C_NORMAL)"
	# 目录不存在才执行
	test -d $(BUILDROOT_DIR)/$(BUILDROOT_VER) || (\
		# 创建对应的buildroot目录
		mkdir -p $(BUILDROOT_DIR) ;\ 
		# 解压指定版本的 Buildroot 源码包到 Buildroot 根目录
		tar xzf $(SYSDRV_DIR)/tools/board/buildroot/$(BUILDROOT_VER).tar.gz -C $(BUILDROOT_DIR) ;\
		# 拷贝 Luckfox Pico/W 开发板的定制配置到 Buildroot 的 configs 目录
		cp $(SYSDRV_DIR)/tools/board/buildroot/luckfox_pico_defconfig $(BUILDROOT_DIR)/$(BUILDROOT_VER)/configs/ ;\
		cp $(SYSDRV_DIR)/tools/board/buildroot/luckfox_pico_w_defconfig $(BUILDROOT_DIR)/$(BUILDROOT_VER)/configs/ ;\
		# 替换 Buildroot 默认的 Busybox 配置，定制嵌入式工具集
		cp $(SYSDRV_DIR)/tools/board/buildroot/busybox.config $(BUILDROOT_DIR)/$(BUILDROOT_VER)/package/busybox/ ;\
		# 拷贝蓝牙工具（bluez5_utils）的编译修复补丁
		# 解决原版 Buildroot 中 bluez5 编译报错的问题
		cp ${HCITOOL_TOOL_PATH}/0001-Fixed-header-file-errors.patch $(BUILDROOT_DIR)/$(BUILDROOT_VER)/package/bluez5_utils/ ;\
		cp ${HCITOOL_TOOL_PATH}/0002-Fix-build-errors.patch $(BUILDROOT_DIR)/$(BUILDROOT_VER)/package/bluez5_utils/ ;\
		cp ${HCITOOL_TOOL_PATH}/0003-fix-compat-wordexp.patch $(BUILDROOT_DIR)/$(BUILDROOT_VER)/package/bluez5_utils/ ;\
		# 拷贝 MPV 播放器的编译补丁（调整编译线程数为 1，避免多核编译冲突）
		cp ${MPV_PATCH_PATH}/0002-change-j1.patch $(BUILDROOT_DIR)/$(BUILDROOT_VER)/package/mpv/ ;\
	);
	# 加载编译的配置文件
	$(MAKE) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) $(BUILDROOT_DEFCONFIG) -C $(BUILDROOT_DIR)/$(BUILDROOT_VER) 
	# 核心功能是修改.config文件中的下载源
	# (如将http://ftp.gnu.org替换为国内镜像站, 如清华/阿里源)
	$(SYSDRV_DIR)/tools/board/mirror_select/buildroot_mirror_select.sh $(BUILDROOT_DIR)/$(BUILDROOT_VER)/.config
	# 下载所有依赖包的源码
	$(MAKE) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) source -C $(BUILDROOT_DIR)/$(BUILDROOT_VER) 
	# 多核编译 Buildroot
	$(MAKE) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) -j$(SYSDRV_JOBS) -C $(BUILDROOT_DIR)/$(BUILDROOT_VER) 

```

####  boardtools

```bash
boardtools: tools_board-builds
	@echo -e "$(C_GREEN) ==sysdrv== build tools which run on board   $(C_NORMAL)"
```

```makefile
tools_board-builds: \
		board-build-toolkits \
		board-build-gdb \
		board-build-eudev \
		board-build-rndis \
		board-build-adbd \
		board-build-rk_ota \
		board-build-rockchip_test \
		board-build-e2fsprogs \
		board-build-sysstat \
		board-build-mtd_utils
	@echo "build tools board done"
	
board-build-toolkits:
	$(MAKE) -C $(SYSDRV_DIR)/tools/board/toolkits

board-build-gdb:
ifeq ($(ENABLE_GDB),y)
	$(MAKE) -C $(SYSDRV_DIR)/tools/board/gdb;
endif
```

编译使用的工作, 在文件sysdrv/tools/board/Makefile.tools.board.mk里面

#### drv

**嵌入式系统中「内核驱动（.ko 模块）」构建与部署的 Makefile 核心脚本**（目标`drv`），核心逻辑是：清理旧驱动文件 → 编译并安装内核原生驱动（裁剪符号表精简体积）→ 收集所有`.ko`文件到统一目录 → 编译自定义驱动 → 最终将驱动模块分发到根文件系统源码目录

```makefile
drv: prepare
	@echo -e "$(C_GREEN) ==sysdrv== build drv $(C_NORMAL)"
	# 清除之前的编译
	@-rm -rf $(SYSDRV_KERNEL_MOD_PATH) $(KERNEL_DIR_DRV_KO)
	# 创建输出目录
	@-mkdir -p $(SYSDRV_KERNEL_MOD_PATH)
	# modules_install：内核 Makefile 的专属目标
	# 作用是编译所有已配置的内核驱动(CONFIG_XXX=m的模块)，并安装到指定目录
	# INSTALL_MOD_STRIP=1：核心优化—— 裁剪.ko文件的符号表 / 调试信息
	# 指定驱动安装的临时目录
	$(MAKE) -C $(KERNEL_DIR) ARCH=$(ARCH) CROSS_COMPILE=$(CROSS_COMPILE) -j$(SYSDRV_JOBS) \
		modules_install INSTALL_MOD_STRIP=1 \
		INSTALL_MOD_PATH=$(KERNEL_DIR_DRV_KO)
	# 递归查找临时安装目录下所有.ko（内核驱动模块）文件
	# 将分散在临时目录中的驱动模块（按内核子系统分类存放，如
	# drivers/net/drivers/usb）集中到SYSDRV_KERNEL_MOD_PATH
	$(AT)find $(KERNEL_DIR_DRV_KO)/lib/modules/*/kernel \
		-name "*.ko" -type f -exec cp -fav {} $(SYSDRV_KERNEL_MOD_PATH) \;
    # 如果drv_ko目录存在，则执行括号内的编译操作
	@test ! -d drv_ko || ($(MAKE) -C $(SYSDRV_DIR)/drv_ko KERNEL_DRV_KO_INSTALL_PATH=$(SYSDRV_KERNEL_MOD_PATH))
	$(call MAROC_COPY_PKG_TO_SYSDRV_OUTPUT, $(OUTPUT_ROOTFS_SOURCE_DIR), $(SYSDRV_KERNEL_MOD_PATH), SELF)
```



## 输出文件

```
out
├── bin
│   ├── board_xxx ---------------- 运行在单板端的文件
│   └── pc ----------------------- 运行在PC服务器端的工具
├── image_xxx -------------------- 生成的烧录固件
│   ├── download.bin ------------- 烧录工具升级通讯的设备端程序，只会下载到板子内存
│   ├── env.img ------------------ 包含分区表和启动参数
│   ├── idblock.img -------------- loader镜像
│   ├── uboot.img ---------------- uboot镜像
│   ├── boot.img ----------------- kernel镜像
│   └── rootfs_base.img ---------- rootfs镜像
│
├── rootfs_xxx ------------------- 生成的根文件系统目录
└── rootfs_xxx.tar --------------- 生成的根文件系统目录的tar文件包
```



| env.img      | UBOOT 配置文件         | BIOS 设置（启动项、串口）    | 256KB   |
| ------------ | ---------------------- | ---------------------------- | ------- |
| idblock.img  | RK 芯片启动钥匙        | 主板 BIOS 固件（底层初始化） | 181KB   |
| uboot.img    | 第一阶段引导程序       | BIOS/UEFI（硬件初始化）      | 256KB   |
| boot.img     | 内核 + 设备树          | Windows 内核（ntoskrnl.exe） | 3.08MB  |
| oem.img      | 厂商定制内容           | 品牌机预装软件 / 驱动        | 20MB    |
| userdata.img | 用户数据区             | 我的文档 / 桌面              | 1.875MB |
| rootfs.img   | 根文件系统（用户空间） | Windows C 盘（系统文件）     | 78MB    |

+ env.img

存储 UBOOT 的「环境变量配置」，是 UBOOT 的 “配置文件”, UBOOT 启动时会先读取该分区，按配置执行后续流程（如加载 uboot.img、boot.img）

+ idblock.img

瑞芯微平台专属的「底层启动块」，是芯片启动的 “钥匙”, 芯片底层初始化代码（SPI NAND 控制器、DDR、时钟等硬件的最基础配置）, 签名 / 校验信息（RK 芯片启动时验证，防止非法镜像）

+ uboot.img

嵌入式系统的「第一阶段引导程序」，是连接硬件和内核的桥梁, 初始化核心硬件（DDR、串口、网口、SPI NAND 等）

+ boot.img：内核 + 设备树镜像

包含 Linux 内核(Image/zImage)+ 设备树(DTB), 部分场景含 ramdisk(内存根文件系统)

+ oem.img：OEM 定制分区镜像

存储「厂商定制化内容」，非系统核心但影响设备功能, 设备型号配置、出厂校准数据(如屏幕、摄像头参数), OEM专属驱动、应用(如厂商自研的控制程序)

+ userdata.img：用户数据分区镜像

存储「用户动态数据」，是系统运行的 “可写分区”，包含

+ rootfs.img：根文件系统镜像