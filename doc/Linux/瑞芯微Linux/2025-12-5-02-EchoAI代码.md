# EchoAI代码

## 文件

+ AIChat_demo: 对话相关
+ assets
+ DeskBot_demo: 桌面控制
+ + bin: 输出文件
    + build: 中间文件
    + common: 控制组件
    + + event_manager: 
        + gpio_manager: 引脚控制
        + sys_manager: 
        + 

## 唤醒词

[Snowboy Personal Wake Word](https://snowboy.hahack.com/)

可以在这个网页生成.pmdl文件, 使用的是Snowboy

```c
void IdleState::Run(Application* app) {
    USER_LOG_INFO("Idle state run.");
    SnowboyDetect* detector = SnowboyDetectConstructor("third_party/snowboy/resources/common.res",
                                                     "third_party/snowboy/resources/models/echo.pmdl");
    SnowboyDetectSetSensitivity(detector, "0.5");
    SnowboyDetectSetAudioGain(detector, 1);
    SnowboyDetectApplyFrontend(detector, false);
    std::vector<int16_t> data;
    while (state_running_.load() == true) {
        if(app->audio_processor_.recordedQueueIsEmpty() == false) {
            app->audio_processor_.getRecordedAudio(data);
            // 检测唤醒词
            int result = SnowboyDetectRunDetection(detector, data.data(), data.size(), false);
            if (result > 0) {
                // 发生唤醒事件
                USER_LOG_INFO("Wake detected.");
                app->eventQueue_.Enqueue(static_cast<int>(AppEvent::wake_detected));
                break;
            }
        }
    }
    SnowboyDetectDestructor(detector);
}
```

Snowboy 是一个基于深度神经网络（DNN）的唤醒词检测引擎，最初由 Kitt.AI 开发，旨在为语音激活应用提供高效的解决方案。它允许设备在检测到特定唤醒词（如“Hey Siri”或“OK Google”）时启动语音处理，而无需依赖云端服务

Snowboy 提供了多种语言的 SDK，包括 Python、C++、Java 等

> [snowboy/README_ZH_CN.md at master · Kitt-AI/snowboy](https://github.com/Kitt-AI/snowboy/blob/master/README_ZH_CN.md)

这里使用的是他的树莓派的库文件

```bash
jiao@jiao-virtual-machine:~/rv/echo-mate/Echo-Mate/Demo$ file AIChat_demo/Client/third_party/snowboy/lib/rpi/libsnowboy-detect.a 
AIChat_demo/Client/third_party/snowboy/lib/rpi/libsnowboy-detect.a: current ar archive
jiao@jiao-virtual-machine:~/rv/echo-mate/Echo-Mate/Demo$ file *.o | head -1
afe-stream.o: ELF 32-bit LSB relocatable, ARM, EABI5 version 1 (SYSV), not stripped
```

- **ARMv8**（64位）：通常**不兼容** ARMv6/ARMv7 的二进制
- **ARMv8**（32位模式/AArch32）：可以运行 ARMv7 编译的程序
- **ARMv7**：通常**兼容** ARMv6（但某些特性可能缺失）
- **ARMv6**：**不能**在 ARMv7/ARMv8 上保证运行（如果编译时用了更高版本特性）

- **32位 ARM 架构**（不是 64 位）

RV1106 是基于 **Cortex-A7** 的 SoC，特性包括：

- **ARMv7-A** 架构
- 支持 **32位** 和 **Thumb-2** 指令集
- 支持 **VFPv4** 浮点单元
- 支持 **NEON** SIMD 扩展

## 引脚控制

通过 sysfs 方式控制 GPIO，先访问 /sys/class/gpio 目录，向 export 文件写入 GPIO 编号，使得该 GPIO 的操作接口从内核空间暴露到用户空间，GPIO 的操作接口包括 direction 和 value 等，direction 控制 GPIO 方向，而 value 可控制 GPIO 输出或获得 GPIO 输入

这个功能需要在内核里面使能

```bash
Device Drivers -> 
        GPIO Support ->
                /sys/class/gpio/… (sysfs interface)
```

1、gpio_operation 通过 /sys/ 文件接口操作 IO 端口 GPIO 到文件系统的映射。
2、控制 GPIO 的目录位于 /sys/class/gpio。
3、/sys/class/gpio/export 文件用于通知系统需要导出控制的 GPIO 引脚编号。
4、/sys/class/gpio/unexport 用于通知系统取消导出。
5、/sys/class/gpio/gpiochipX 目录保存系统中 GPIO 寄存器的信息，包括每个寄存器控制引脚的起始编号 base，寄存器名称，引脚总数。

在使用的时候可以使用`calculate_gpio_pin`计算实际的引脚的位置

```c
int calculate_gpio_pin(int bank, int group, int x) {
    return bank * 32 + (group * 8 + x);
}
#define LED_BLUE     calculate_gpio_pin(0, 0, 4)  // GPIO0_A4
```

## 系统控制

### 背光

控制的文件是`/sys/class/backlight/backlight/brightness`

### 音量

+ 打开一个混音器, 绑定到对应的声卡
+ 注册混音器元素类
+ 加载指定声卡上的所有混音器控件
+ 使用控件的标号以及名字获取控制句柄
+ 使用控制句柄设置实际的属性

### 设置以及获取时间

在Linux系统中，settimeofday函数用于设置系统时间。这个函数可以精确到微秒，允许用户根据需要调整系统时间, 一般需要是root权限的用户

### 查看网络是不是连通

使用连接8.8.8.8服务器的方式进行

```c
bool is_internet_reachable(void) {
    int sockfd;
    struct sockaddr_in servaddr;

    // 创建socket
    if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) {
        perror("Socket creation failed");
        return false;
    }

    // 设置socket为非阻塞
    int flags = fcntl(sockfd, F_GETFL, 0);
    if (fcntl(sockfd, F_SETFL, flags | O_NONBLOCK) == -1) {
        perror("Failed to set socket as non-blocking");
        close(sockfd);
        return false;
    }

    servaddr.sin_family = AF_INET;
    servaddr.sin_port = htons(53); // Google DNS服务端口
    servaddr.sin_addr.s_addr = inet_addr("8.8.8.8"); // Google Public DNS IP地址

    // 尝试连接, 非阻塞的模式一般极少数时候出现直接连接成功
    if (connect(sockfd, (struct sockaddr*)&servaddr, sizeof(servaddr)) < 0) {
        if (errno != EINPROGRESS) {
            close(sockfd);
            return false;
        }
        // 后台在连接

        // 使用select等待连接完成或超时
        // 写文件描述符集合。TCP 连接完成时，socket 会变为「可写」状态
        fd_set writefds;
        FD_ZERO(&writefds);
        FD_SET(sockfd, &writefds); // 把sockfd加入集合

        struct timeval timeout;
        timeout.tv_sec = 2; // 超时时间为2秒
        timeout.tv_usec = 0;
        // 使用多路IO检测函数查看IO可写状态
        int ret = select(sockfd + 1, NULL, &writefds, NULL, &timeout);
        if (ret == 0) { // 超时
            fprintf(stderr, "Connection timed out\n");
            close(sockfd);
            return false;
        } else if (ret < 0) { // 错误发生
            perror("Select failed");
            close(sockfd);
            return false;
        }

        // 检查是否成功连接
        // select 检测到 socket 可写，不代表连接成功（比如对方拒绝连接时，socket 也会可写），必须通过 getsockopt 检查具体的错误码
        int so_error;
        socklen_t len = sizeof(so_error);
        // 获取 socket 的选项，这里取 SO_ERROR（socket 错误状态）
        if (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &so_error, &len) < 0 || so_error != 0) {
            if (so_error != 0) {
                errno = so_error;
            }
            perror("Connect failed");
            close(sockfd);
            return false;
        }
    }

    close(sockfd);
    return true;
}
```

### 获取ip地址

使用的是库libcurl「easy 接口」, 是 C 语言的跨平台网络传输库，支持几乎所有主流网络协议

easy 句柄（`CURL*`）**非线程安全**，一个句柄只能在一个线程中使用；若需多线程并发，建议用 libcurl 的 multi 接口（`curl_multi_*`）

#### libcurl库

[libcurl - curl_easy_setopt()](https://curl.se/libcurl/c/curl_easy_setopt.html)

+ API

```c
// 创建句柄
curl_easy_init()
// 设置参数
CURLcode curl_easy_setopt(CURL *handle, CURLoption option, ...);
```

libcurl 预定义的配置选项宏（数百个），覆盖网络请求的所有维度，比如：

- `CURLOPT_URL`：设置请求的 URL（核心选项）；
- `CURLOPT_TIMEOUT`：设置请求超时时间（秒）；
- `CURLOPT_HTTPGET`/`CURLOPT_POST`：指定 HTTP 请求方法；
- `CURLOPT_WRITEFUNCTION`：设置响应数据的回调函数；
- `CURLOPT_SSL_VERIFYPEER`：是否验证服务器 SSL 证书（测试时可设为 0 跳过）；
- `CURLOPT_PROXY`：设置代理地址。

下面是一个简单的使用流程

```c
#include <curl/curl.h>
#include <stdio.h>

int main() {
    // 1. 初始化 easy 句柄
    CURL *curl = curl_easy_init();
    if (!curl) {
        fprintf(stderr, "curl_easy_init failed\n");
        return 1;
    }

    // 2. 核心：通过 curl_easy_setopt 配置参数
    // 2.1 设置请求 URL
    curl_easy_setopt(curl, CURLOPT_URL, "https://www.baidu.com");
    // 2.2 设置超时时间（10 秒）
    curl_easy_setopt(curl, CURLOPT_TIMEOUT, 10L);
    // 2.3 跳过 SSL 证书验证（仅测试用，生产环境禁用）
    curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);

    // 3. 执行请求
    CURLcode res = curl_easy_perform(curl);
    if (res != CURLE_OK) {
        fprintf(stderr, "curl_easy_perform failed: %s\n", curl_easy_strerror(res));
    }

    // 4. 清理句柄
    curl_easy_cleanup(curl);
    return 0;
}
```

+ 使用POST请求

```c
// POST 数据
const char *post_data = "username=test&password=123456";
curl_easy_setopt(curl, CURLOPT_POST, 1L);                // 启用 POST 方法
curl_easy_setopt(curl, CURLOPT_POSTFIELDS, post_data);   // 设置 POST 数据
curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, strlen(post_data)); // 数据长度
```

+ libcurl 会把响应数据打印到 stdout，通过回调可自定义处理（比如写入内存 / 文件）

```c
// 回调函数：接收响应数据（size*nmemb 是数据长度，ptr 是数据指针，userdata 是自定义参数）
size_t write_callback(char *ptr, size_t size, size_t nmemb, void *userdata) {
    // userdata 传入的是字符串缓冲区，拼接数据
    char *buffer = (char*)userdata;
    strcat(buffer, ptr);
    return size * nmemb; // 必须返回实际处理的字节数，否则 libcurl 会认为出错
}

// 配置回调
char response[1024] = {0};
curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback); // 设置回调函数
curl_easy_setopt(curl, CURLOPT_WRITEDATA, response);           // 传给回调的自定义参数
```

+ 设置头

```c
// 构造请求头（比如指定 User-Agent、Content-Type）
struct curl_slist *headers = NULL;
headers = curl_slist_append(headers, "User-Agent: MyCurl/1.0");
headers = curl_slist_append(headers, "Content-Type: application/json");
curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers); // 设置请求头

// 注意：请求结束后要释放 headers
curl_slist_free_all(headers);
```

#### json-c库

- Debian/Ubuntu：`sudo apt install libjson-c-dev`
- CentOS/RHEL：`sudo yum install json-c-devel`

```c
#include <json-c/json.h>
#include <stdio.h>

int main() {
    // 创建 JSON 对象
    json_object *obj = json_object_new_object();
    json_object_object_add(obj, "name", json_object_new_string("json-c"));
    json_object_object_add(obj, "version", json_object_new_string("0.17"));
    
    // 序列化为字符串并打印
    const char *json_str = json_object_to_json_string(obj);
    printf("JSON: %s\n", json_str);
    
    // 释放内存
    json_object_put(obj);
    return 0;
}
```

解析实例

```c
#include <stdio.h>
#include <stdlib.h>
// 引入 json-c 核心头文件（新版本路径）
#include <json-c/json.h>

int main() {
    // 1. 定义待解析的 JSON 字符串（标准格式，键必须用双引号）
    const char *json_str = "{\"name\":\"张三\",\"age\":25,\"is_student\":false}";
    printf("原始 JSON 字符串：%s\n\n", json_str);

    // 2. 解析 JSON 字符串为 json_object 对象（核心步骤）
    struct json_object *root_obj = json_tokener_parse(json_str);
    // 检查解析是否失败（比如 JSON 格式错误）
    if (root_obj == NULL) {
        fprintf(stderr, "JSON 解析失败！请检查字符串格式\n");
        return 1;
    }

    // 3. 提取字段（按类型分别处理，避免类型不匹配出错）
    // 3.1 提取字符串类型字段：name
    struct json_object *name_obj;
    // 从根对象中获取 "name" 对应的 value
    if (json_object_object_get_ex(root_obj, "name", &name_obj)) {
        // 转为 C 语言字符串
        const char *name = json_object_get_string(name_obj);
        printf("姓名：%s\n", name);
    } else {
        fprintf(stderr, "未找到 name 字段\n");
    }

    // 3.2 提取整数类型字段：age
    struct json_object *age_obj;
    if (json_object_object_get_ex(root_obj, "age", &age_obj)) {
        // 转为 C 语言整数
        int age = json_object_get_int(age_obj);
        printf("年龄：%d\n", age);
    } else {
        fprintf(stderr, "未找到 age 字段\n");
    }

    // 3.3 提取布尔类型字段：is_student
    struct json_object *is_student_obj;
    if (json_object_object_get_ex(root_obj, "is_student", &is_student_obj)) {
        // 转为 C 语言布尔值（json-c 中 0 为 false，1 为 true）
        int is_student = json_object_get_boolean(is_student_obj);
        printf("是否学生：%s\n", is_student ? "是" : "否");
    } else {
        fprintf(stderr, "未找到 is_student 字段\n");
    }

    // 4. 释放内存（关键！避免内存泄漏）
    json_object_put(root_obj);

    return 0;
}
```

#### 实际使用

```c
// 回调函数用于处理CURL接收到的数据
size_t WriteCallback(void* contents, size_t size, size_t nmemb, void* userp) {
    size_t realsize = size * nmemb;
    char** response_string = (char**)userp;
	// 重新拓展一下字符串
    char* new_string = realloc(*response_string, realsize + 1);
    if(new_string == NULL) {
        // 内存分配失败
        fprintf(stderr, "Failed to allocate memory\n");
        return 0;
    }

    *response_string = new_string;
    memcpy(*response_string + strlen(*response_string), contents, realsize);
    (*response_string)[realsize] = '\0';

    return realsize;
}

// 使用高德地图API根据IP地址获取自动定位信息
int sys_get_auto_location_by_ip(LocationInfo_t* location, const char *api_key) {
    CURL* curl_handle;
    CURLcode res;
    char url[256];
    snprintf(url, sizeof(url), "https://restapi.amap.com/v3/ip?key=%s", api_key);

    char* response_string = malloc(1); // 初始化为空字符串
    if (!response_string) {
        fprintf(stderr, "Failed to allocate memory\n");
        return -1;
    }
    response_string[0] = '\0';

    curl_global_init(CURL_GLOBAL_ALL);
    curl_handle = curl_easy_init();

    if (!curl_handle) {
        fprintf(stderr, "Failed to initialize CURL\n");
        free(response_string);
        curl_global_cleanup();
        return -1;
    }

    curl_easy_setopt(curl_handle, CURLOPT_URL, url);
    // 设置回调函数
    curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, WriteCallback);
    curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, &response_string);
    // 指定使用的证书, HTTPS证书文件
    curl_easy_setopt(curl_handle, CURLOPT_CAINFO, "cacert.pem");

    // 设置超时时间为5秒
    curl_easy_setopt(curl_handle, CURLOPT_TIMEOUT, 5L);
	// 实际的执行
    res = curl_easy_perform(curl_handle);

    if(res != CURLE_OK) {
        fprintf(stderr, "curl_easy_perform() failed: %s\n", curl_easy_strerror(res));
        free(response_string);
        curl_easy_cleanup(curl_handle);
        curl_global_cleanup();
        return -1;
    }
	// 解析json字符串
    struct json_object *parsed_json = json_tokener_parse(response_string);
    if (!parsed_json) {
        printf("Failed to parse JSON\n");
        free(response_string);
        curl_easy_cleanup(curl_handle);
        curl_global_cleanup();
        return -1;
    }

    struct json_object *province_obj, *city_obj, *adcode_obj;
    json_object_object_get_ex(parsed_json, "province", &province_obj);
    json_object_object_get_ex(parsed_json, "city", &city_obj);
    json_object_object_get_ex(parsed_json, "adcode", &adcode_obj);

    // 检查province, city, adcode是否为空数组
    if(json_object_is_type(province_obj, json_type_array) && json_object_array_length(province_obj) == 0 &&
       json_object_is_type(city_obj, json_type_array) && json_object_array_length(city_obj) == 0 &&
       json_object_is_type(adcode_obj, json_type_array) && json_object_array_length(adcode_obj) == 0) {
        printf("Location information is empty. This might be due to an invalid or foreign IP address.\n");
        json_object_put(parsed_json); // 释放JSON对象
        free(response_string);
        curl_easy_cleanup(curl_handle);
        curl_global_cleanup();
        return -2; // 自定义错误码表示位置信息为空
    }
	// 记录信息
    strncpy(location->city, json_object_get_string(city_obj), sizeof(location->city) - 1);
    location->city[sizeof(location->city) - 1] = '\0'; // 确保字符串以null结尾
    strncpy(location->adcode, json_object_get_string(adcode_obj), sizeof(location->adcode) - 1);
    location->adcode[sizeof(location->adcode) - 1] = '\0'; // 确保字符串以null结尾

    printf("City: %s\n", location->city);
    printf("Adcode: %s\n", location->adcode);

    json_object_put(parsed_json); // 释放JSON对象

    free(response_string);
    curl_easy_cleanup(curl_handle);
    curl_global_cleanup();

    return 0;
}
```

#### 加载配置文件

## 页面管理



