# Linux 编译脚本

使用下面的命令进行编译

```bash
#!/bin/sh 
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distclean 
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- imx_v7_defconfig 
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig 
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- all -j16 
```

编译以后, zImage文件记录在`arch/arm/boot/zImage`

设备树文件记录在`arch/arm/boot/dts/xxx_.dtb`

## 文件

![image-20251030214012497](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510302140562.png)

![image-20251030214024413](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510302140471.png)

需要关注的文件有

+ `arch/arm/boot/dts`里面有设备树文件
+ `Documentation/devicetree/bindings`设备树绑定相关的文件
+ `arch/arm/configs` 目录是不同平台的默认配置

## Makefile

和uboot的顶层Makefile文件比较类似

起始的时候是版本号, 命令输出的是否缩减, 静默输出, 代码检查, 输出的目录, 模块编译, 引用文件, 设置交叉编译器等变量

初始化一下使用的头文件

```c
# Use USERINCLUDE when you must reference the UAPI directories only.
USERINCLUDE    := \
		-I$(srctree)/arch/$(hdr-arch)/include/uapi \
		-Iarch/$(hdr-arch)/include/generated/uapi \
		-I$(srctree)/include/uapi \
		-Iinclude/generated/uapi \
                -include $(srctree)/include/linux/kconfig.h

# Use LINUXINCLUDE when you must reference the include/ directory.
# Needed to be compatible with the O= option
LINUXINCLUDE    := \
		-I$(srctree)/arch/$(hdr-arch)/include \
		-Iarch/$(hdr-arch)/include/generated/uapi \
		-Iarch/$(hdr-arch)/include/generated \
		$(if $(KBUILD_SRC), -I$(srctree)/include) \
		-Iinclude \
		$(USERINCLUDE)
// 展开以后是下面的文件
USERINCLUDE    := \ 
  -I./arch/arm/include/uapi \ 
  -Iarch/arm/include/generated/uapi \ 
  -I./include/uapi \ 
  -Iinclude/generated/uapi \ 
        -include ./include/linux/kconfig.h 
 
LINUXINCLUDE    := \ 
  -I./arch/arm/include \ 
  -Iarch/arm/include/generated/uapi \ 
  -Iarch/arm/include/generated \ 
  -Iinclude \ 
  -I./arch/arm/include/uapi \ 
  -Iarch/arm/include/generated/uapi \ 
  -I./include/uapi \ 
  -Iinclude/generated/uapi \ 
        -include ./include/linux/kconfig.h 
```

经过判断可以获取到这三个变量的值

```c
config-targets= 1 
mixed-targets= 0 
dot-config= 1 
```

> - config-targets：是否请求了“配置类”目标的标志。为 1 表示本次 make 目标中含有 config/%config（如 menuconfig、oldconfig、defconfig 等）；否则为 0。用于把“仅配置流程”分支到 scripts/kconfig 执行。
>
> - mixed-targets：是否“混合目标”标志。为 1 表示本次命令同时包含配置目标和普通构建目标（例如 make oldconfig all）；此时会逐个目标顺序调用，避免在处理 *config 时误读 .config。
>
> - dot-config：是否需要读取配置文件的标志。初始为 1；若本次目标只属于 no-dot-config-targets（如 clean、help、headers_* 等），则置 0，从而跳过包含 include/config/auto.conf，避免在这些场景强依赖 .config。

因为config-targets=1，引用arch/arm/Makefile这个文 件，这个文件很重要，因为zImage、uImage等这些文件就是由arch/arm/Makefile来生成的

## make xxx_defconfig

```makefile
%config: scripts_basic outputmakefile FORCE
	$(Q)$(MAKE) $(build)=scripts/kconfig $@
	
# 这个编译命令如下
	@make -f ./scripts/Makefile.build obj=scripts/kconfig xxx_defconfig
```

可以获取到以下的参数

```c
src= scripts/kconfig 
kbuild-dir = ./scripts/kconfig 
kbuild-file = ./scripts/kconfig/Makefile 
include ./scripts/kconfig/Makefile
```

加载`scripts/kconfig/Makefile`获取到实际的可以对应的编译命令

```makefile
%_defconfig: $(obj)/conf
	$(Q)$< $(silent) --defconfig=arch/$(SRCARCH)/configs/$@ $(Kconfig)
# 展开获得
%_defconfig: scripts/kconfig/conf 
	@ scripts/kconfig/conf  --defconfig=arch/arm/configs/%_defconfig  Kconfig
```

软件`scripts/kconfig/conf`会将%_defconfig中的配置输出到.config文件中，最终生成Linux kernel根目录下 的.config文件

### scripts_basic

依赖的文件编译如下

```makefile
scripts_basic:
	$(Q)$(MAKE) $(build)=scripts/basic
	$(Q)rm -f .tmp_quiet_recordmcount
	
# 实际执行的命令是
	@make -f ./scripts/Makefile.build obj=scripts/basic
```

在执行的时候根据obj可以获取到两个参数]

```makefile
kbuild-dir=./scripts/basic
kbuild-file= ./scripts/basic/Makefile 
```

使用include引用后面的这个文件进行下面的编译, 由于没有指定实际编译的文件, 所以在这里运行默认的编译命令

```makefile
__build: $(if $(KBUILD_BUILTIN),$(builtin-target) $(lib-target) $(extra-y)) \
	 $(if $(KBUILD_MODULES),$(obj-m) $(modorder-target)) \
	 $(subdir-ym) $(always)
	@:
# 展开以后是
__build:$(builtin-target) $(lib-target) $(extra-y)) $(subdir-ym) $(always) 
 	@:
```

只有always不为空, `always = scripts/basic/fixdep scripts/basic/bin2c`

> scripts_basic目标的作用就是编译出`scripts/basic/fixdep`和`scripts/basic/bin2c`这 两个软件

## make

可以使用`make`或者`make all`编译内核

```makefile
# That's our default target when none is given on the command line
PHONY := _all
_all
```

```makefile
PHONY += all
ifeq ($(KBUILD_EXTMOD),)
_all: all  # 运行的这个依赖
else
_all: modules
endif
```

```makefile
# The all: target is the default when no target is given on the
# command line.
# This allow a user to issue only 'make' to build a kernel including modules
# Defaults to vmlinux, but the arch makefile usually adds further targets
all: vmlinux
```

```makefile
# Include targets which we want to
# execute if the rest of the kernel build went well.
vmlinux: scripts/link-vmlinux.sh $(vmlinux-deps) FORCE
ifdef CONFIG_HEADERS_CHECK
	$(Q)$(MAKE) -f $(srctree)/Makefile headers_check
endif
ifdef CONFIG_SAMPLES
	$(Q)$(MAKE) $(build)=samples
endif
ifdef CONFIG_BUILD_DOCSRC
	$(Q)$(MAKE) $(build)=Documentation
endif
ifdef CONFIG_GDB_SCRIPTS
	$(Q)ln -fsn `cd $(srctree) && /bin/pwd`/scripts/gdb/vmlinux-gdb.py
endif
	+$(call if_changed,link-vmlinux) # 运行这一个, 依赖文件
```

> `vmlinux-deps= $(KBUILD_LDS) $(KBUILD_VMLINUX_INIT) $(KBUILD_VMLINUX_MAIN)`
>
> + `KBUILD_LDS= arch/$(SRCARCH)/kernel/vmlinux.lds`
> + `KBUILD_VMLINUX_INIT= $(head-y) $(init-y)`
> + `KBUILD_VMLINUX_MAIN = $(core-y) $(libs-y) $(drivers-y) $(net-y)`
>
> ```makefile
> head-y = arch/arm/kernel/head.o
> init-y = init/built-in.o 
> drivers-y = drivers/built-in.o  sound/built-in.o  firmware/built-in.o 
> net-y = net/built-in.o 
> libs-y = arch/arm/lib/lib.a  lib/lib.a  arch/arm/lib/built-in.o  lib/built-in.o
> ```
>
> core-y: 依据不同的宏定义添加不同的模块
>
> ```makefile
> core-y =  usr/built-in.o     arch/arm/vfp/built-in.o \ 
>     arch/arm/vdso/built-in.o   arch/arm/kernel/built-in.o \ 
>     arch/arm/mm/built-in.o    arch/arm/common/built-in.o \ 
>     arch/arm/probes/built-in.o  arch/arm/net/built-in.o \ 
>     arch/arm/crypto/built-in.o   arch/arm/firmware/built-in.o \ 
>     arch/arm/mach-imx/built-in.o  kernel/built-in.o\ 
>     mm/built-in.o     fs/built-in.o \ 
>     ipc/built-in.o      security/built-in.o \ 
>     crypto/built-in.o     block/built-in.o 
> ```
>
> 最终将这些built-in.o和.a文 件进行链接即可形成ELF格式的可执行文件，也就是vmlinux, `arch/arm/kernel/vmlinux.lds`就是整个Linux的链接脚本

`$(call if_changed,link-vmlinux)`是调用函数`if_changed`，`link-vmlinux`是函数`if_changed`的参数， 函数`if_changed`定义在文件`scripts/Kbuild.include`

```makefile
# Execute command if command has changed or prerequisite(s) are updated.
#
if_changed = $(if $(strip $(any-prereq) $(arg-check)),                       \
	@set -e;                                                             \ # 结果不对直接退出
	$(echo-cmd) $(cmd_$(1));                                             \
	printf '%s\n' 'cmd_$@ := $(make-cmd)' > $(dot-target).cmd)
```

> `any-prereq`用于检查依赖文件是否有变化，如果依赖文件有变化那么`any-prereq`就不为空，否则就为空。`arg-check`用于检查参数是否有变化，如果没有变化那么`arg-check`就为空
>
> `$(echo-cmd)`用于打印命令执行过程, `$(cmd_$(1)`表示执行`cmd_link-vmlinux`的内容
>
> ```makefile
> # Final link of vmlinux
>       cmd_link-vmlinux = $(CONFIG_SHELL) $< $(LD) $(LDFLAGS) $(LDFLAGS_vmlinux)
> quiet_cmd_link-vmlinux = LINK    $@
> 
> # 展开以后是
> cmd_link-vmlinux = /bin/bash scripts/link-vmlinux.sh arm-linux-gnueabihf-ld -EL -p --no-u
>  ndefined -X --pic-veneer --build-id
> ```
>
> ```bash
> # Link of vmlinux
> # ${1} - optional extra .o files
> # ${2} - output file
> vmlinux_link()
> {
> 	local lds="${objtree}/${KBUILD_LDS}"
> 
> 	if [ "${SRCARCH}" != "um" ]; then
> 		${LD} ${LDFLAGS} ${LDFLAGS_vmlinux} -o ${2}                  \
> 			-T ${lds} ${KBUILD_VMLINUX_INIT}                     \
> 			--start-group ${KBUILD_VMLINUX_MAIN} --end-group ${1}
> 	else
> 		${CC} ${CFLAGS_vmlinux} -o ${2}                              \
> 			-Wl,-T,${lds} ${KBUILD_VMLINUX_INIT}                 \
> 			-Wl,--start-group                                    \
> 				 ${KBUILD_VMLINUX_MAIN}                      \
> 			-Wl,--end-group                                      \
> 			-lutil ${1}
> 		rm -f linux
> 	fi
> }
> ```
>
> 运行的是前面的半段, `lds= ./arch/arm/kernel/v mlinux.lds`

### built-in.o文件

`$(sort $(vmlinux-deps)): $(vmlinux-dirs) ;`: `vmlinux-deps`里面的文件是依赖于vmlinux-dirs的, 同时可以并且去掉重复的单词

```makefile
vmlinux-dirs	:= $(patsubst %/,%,$(filter %/, $(init-y) $(init-m) \
		     $(core-y) $(core-m) $(drivers-y) $(drivers-m) \
		     $(net-y) $(net-m) $(libs-y) $(libs-m)))

 # 展开
 vmlinux-dirs = init    usr      arch/arm/vfp \ 
    arch/arm/vdso  arch/arm/kernel   arch/arm/mm \ 
    arch/arm/common arch/arm/probes   arch/arm/net \ 
    arch/arm/crypto  arch/arm/firmware  arch/arm/mach-imx\ 
    kernel    mm     fs \ 
    ipc     security    crypto \ 
    block    drivers     sound \ 
    firmware   net      arch/arm/lib \ 
	lib 
```

```c
$(vmlinux-dirs): prepare scripts
	$(Q)$(MAKE) $(build)=$@
```

> `build = "-f ./scripts/Makefile.build obj"`, 所以实际是替换为`@ make -f ./scripts/Makefile.build obj=$@`
>
> 会运行比如`@ make -f ./scripts/Makefile.build obj=init `的代码

使用的还是默认目标, __build

默认的目标可以简化为

```makefile
__build: $(builtin-target) $(lib-target) $(extra-y)) $(subdir-ym) $(always) 
  @: 
```

> 主要需要关注的是buildin-target, 把一系列的文件打包成一个.o文件
>
> ```makefile
> builtin-target := $(obj)/built-in.o
> 
> cmd_link_o_target = $(if $(strip $(obj-y)),\
> 		      $(LD) $(ld_flags) -r -o $@ $(filter $(obj-y), $^) \
> 		      $(cmd_secanalysis),\
> 		      rm -f $@; $(AR) rcs$(KBUILD_ARFLAGS) $@)
> 
> $(builtin-target): $(obj-y) FORCE
> 	$(call if_changed,link_o_target)
> ```
>
> 这里的obj-y来自于使用kbuild-file引用进来的对应文件夹下面的Makefile文件

## zImage文件

vmlinux是ELF格式的文件，但是在实际中我们不会使用vmlinux，而是使用zImage或uImage这样的Linux内核镜像文件

+ vmlinux: 是编译出来的最原始的内核文件，是未压缩的
+ Image: 是使 用objcopy 取消掉 vmlinux 中的一些其他信息，比如符号表什么的。但是Image 是没有压缩过 的，Image保存在arch/arm/boot 目录下
+ zImage 是经过gzip压缩后的Image
+ uImage 是老版本 uboot 专用的镜像文件，uImag 是在 zImage 前面加了一个长度为 64 字节的“头”，这个头信息描述了该镜像文件的类型、加载位置、生成时间、大小等信息。但是 新的uboot已经支持了zImage启动

在arch/arm/Makefile 中有`BOOT_TARGETS = zImage Image xipImage bootpImage uImage `

```makefile
$(BOOT_TARGETS): vmlinux
	$(Q)$(MAKE) $(build)=$(boot) MACHINE=$(MACHINE) $(boot)/$@
	
# zImage使用的
@ make -f ./scripts/Makefile.build obj=arch/arm/boot MACHINE=arch/arm/boot/zImage
```

