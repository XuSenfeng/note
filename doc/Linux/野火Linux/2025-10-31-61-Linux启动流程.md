# Linux启动流程

## 汇编启动阶段

Linux内核的连接脚本文件arch/arm/kernel/vmlinux.lds

```
OUTPUT_ARCH(arm)
ENTRY(stext)
jiffies = jiffies_64;
```

ENTRY指明了了Linux内核入口，入口为stext，stext定义在文件arch/arm/ke rnel/head.S

在启动的时候, linux需要解压缩, 这个函数实际是解压缩以后才会调用的

```c
/*
 * Kernel startup entry point.
 * ---------------------------
 *
 * This is normally called from the decompressor code.  The requirements
 * are: MMU = off, D-cache = off, I-cache = dont care, r0 = 0,
 * r1 = machine nr, r2 = atags or dtb pointer. 需要设置为以上的状态, r2记录设备树
 *
 * This code is mostly position independent, so if you link the kernel at
 * 0xc0008000, you call this at __pa(0xc0008000).
 *
 * See linux/arch/arm/tools/mach-types for the complete list of machine
 * numbers for r1.
 *
 * We're trying to keep crap to a minimum; DO NOT add any machine specific
 * crap here - that's what the boot loader (or in extreme, well justified
 * circumstances, zImage) is for.
 */
```

```assembly
	.arm

	__HEAD
ENTRY(stext)
 ARM_BE8(setend	be )			@ ensure we are in BE8 mode

 THUMB(	adr	r9, BSYM(1f)	)	@ Kernel is always entered in ARM.
 THUMB(	bx	r9		)	@ If this is a Thumb-2 kernel,
 THUMB(	.thumb			)	@ switch to Thumb now.
 THUMB(1:			)

#ifdef CONFIG_ARM_VIRT_EXT
	bl	__hyp_stub_install
#endif
	@ ensure svc mode and all interrupts masked, 设置模式以及中断关闭
	safe_svcmode_maskall r9

	mrc	p15, 0, r9, c0, c0		@ get processor id 获取处理器ID记录在c9
	# 查找处理器类型, 判断是不是支持, 记录在一个代码段里面, 是proc_info_list类型的结构体
	bl	__lookup_processor_type		@ r5=procinfo r9=cpuid 
	movs	r10, r5				@ invalid processor (r5=0)?
 THUMB( it	eq )		@ force fixup-able long branch encoding
	beq	__error_p			@ yes, error 'p'

#ifdef CONFIG_ARM_LPAE
	mrc	p15, 0, r3, c0, c1, 4		@ read ID_MMFR0
	and	r3, r3, #0xf			@ extract VMSA support
	cmp	r3, #5				@ long-descriptor translation table format?
 THUMB( it	lo )				@ force fixup-able long branch encoding
	blo	__error_lpae			@ only classic page table format
#endif

#ifndef CONFIG_XIP_KERNEL
	adr	r3, 2f
	ldmia	r3, {r4, r8}
	sub	r4, r3, r4			@ (PHYS_OFFSET - PAGE_OFFSET)
	add	r8, r8, r4			@ PHYS_OFFSET
#else
	ldr	r8, =PLAT_PHYS_OFFSET		@ always constant in this case
#endif

	/*
	 * r1 = machine no, r2 = atags or dtb,
	 * r8 = phys_offset, r9 = cpuid, r10 = procinfo
	 * 当前的寄存器记录的信息
	 */
	bl	__vet_atags # 验证一下dtb是不是有效的
#ifdef CONFIG_SMP_ON_UP
	bl	__fixup_smp # 多核处理
#endif
#ifdef CONFIG_ARM_PATCH_PHYS_VIRT
	bl	__fixup_pv_table
#endif
	bl	__create_page_tables # 创建页表

	/*
	 * The following calls CPU specific code in a position independent
	 * manner.  See arch/arm/mm/proc-*.S for details.  r10 = base of
	 * xxx_proc_info structure selected by __lookup_processor_type
	 * above.  On return, the CPU will be ready for the MMU to be
	 * turned on, and r0 will hold the CPU control register value.
	 */
	 # 记录返回地址, 这个函数进行清BSS等, 最后使用start_kernel函数进入内核
	ldr	r13, =__mmap_switched		@ address to jump to after
						@ mmu has been enabled
	adr	lr, BSYM(1f)			@ return (PIC) address
	mov	r8, r4				@ set TTBR1 to swapper_pg_dir
	ldr	r12, [r10, #PROCINFO_INITFUNC]
	add	r12, r12, r10
	ret	r12
1:	b	__enable_mmu # 使能mmu, 最终会使用r3里面记录的那个函数
ENDPROC(stext)
	.ltorg
#ifndef CONFIG_XIP_KERNEL
2:	.long	.
	.long	PAGE_OFFSET
#endif
```

`start_kernel`在init/main.c文件里面已经是C语言了

## C代码

### start_kernel

在这函数里面进行了大量的初始化代码

```c
asmlinkage __visible void __init start_kernel(void) 
{ 
    char *command_line; 
    char *after_dashes; 
 
    lockdep_init(); /* lockdep是死锁检测模块，此函数会初始化
                     * 两个hash表。此函数要求尽可能早的执行！            
                     */ 
set_task_stack_end_magic(&init_task);/* 设置任务栈结束魔术数， 
*用于栈溢出检测  
*/ 
    smp_setup_processor_id();   /* 跟SMP有关(多核处理器)，设置处理器ID。 
                                      * 有很多资料说ARM架构下此函数为空函数，那是因 
                                      * 为他们用的老版本Linux，而那时候ARM还没有多 
                                      * 核处理器。 
*/ 
    debug_objects_early_init();  /* 做一些和debug有关的初始化 */ 
    boot_init_stack_canary();    /* 栈溢出检测初始化 */ 
    cgroup_init_early();  /* cgroup初始化，cgroup用于控制Linux系统资源*/ 
    local_irq_disable(); /* 关闭当前CPU中断 */ 
    early_boot_irqs_disabled = true; 
 
    /* 
     * 中断关闭期间做一些重要的操作，然后打开中断 
     */ 
    boot_cpu_init();             /* 跟CPU有关的初始化 */ 
    page_address_init();         /* 页地址相关的初始化 */ 
    pr_notice("%s", linux_banner);/* 打印Linux版本号、编译时间等信息 */ 
    setup_arch(&command_line);  /* 架构相关的初始化，此函数会解析传递进来的  
                                      * ATAGS或者设备树(DTB)文件。会根据设备树里面 
                                      * 的model和compatible这两个属性值来查找 
                                      * Linux是否支持这个单板。此函数也会获取设备树 
                                      * 中chosen节点下的bootargs属性值来得到命令 
                                      * 行参数，也就是uboot中的bootargs环境变量的 
                                        * 值，获取到的命令行参数会保存到 
                                        *command_line中。 
                                      */  
    mm_init_cpumask(&init_mm);  /* 看名字，应该是和内存有关的初始化 */ 
    setup_command_line(command_line);   /* 好像是存储命令行参数 */ 
    setup_nr_cpu_ids();             /* 如果只是SMP(多核CPU)的话，此函数用于获取 
                                         * CPU核心数量，CPU数量保存在变量 
                                         * nr_cpu_ids中。 
*/ 
    setup_per_cpu_areas(); /* 在SMP系统中有用，设置每个CPU的per-cpu数据 */ 
    smp_prepare_boot_cpu();      
 
    build_all_zonelists(NULL, NULL);  /* 建立系统内存页区(zone)链表 */ 
    page_alloc_init();             /* 处理用于热插拔CPU的页 */ 
/* 打印命令行信息 */     
pr_notice("Kernel command line: %s\n", boot_command_line);  
    parse_early_param();            /* 解析命令行中的console参数 */ 
    after_dashes = parse_args("Booting kernel", 
                  static_command_line, __start___param, 
                  __stop___param - __start___param, 
                  -1, -1, &unknown_bootoption); 
    if (!IS_ERR_OR_NULL(after_dashes)) 
        parse_args("Setting init args", after_dashes, NULL, 0, -1, -1, 
               set_init_arg); 
 
    jump_label_init(); 
 
    setup_log_buf(0);   /* 设置log使用的缓冲区*/ 
    pidhash_init();           /* 构建PID哈希表，Linux中每个进程都有一个ID, 
                                  * 这个ID叫做PID。通过构建哈希表可以快速搜索进程 
                                  * 信息结构体。 
                                  */ 
vfs_caches_init_early();    /* 预先初始化vfs(虚拟文件系统)的目录项和 
* 索引节点缓存  
*/ 
    sort_main_extable();         /* 定义内核异常列表 */ 
    trap_init();                 /* 完成对系统保留中断向量的初始化 */ 
    mm_init();                   /* 内存管理初始化 */ 
 
    sched_init();                /* 初始化调度器，主要是初始化一些结构体 */ 
    preempt_disable();           /* 关闭优先级抢占 */ 
    if (WARN(!irqs_disabled(),   /* 检查中断是否关闭，如果没有的话就关闭中断 */ 
         "Interrupts were enabled *very* early, fixing it\n")) 
        local_irq_disable(); 
    idr_init_cache();            /* IDR初始化，IDR是Linux内核的整数管理机 
                                       * 制，也就是将一个整数ID与一个指针关联起来。 
                                       */  
    rcu_init();    /* 初始化RCU，RCU全称为Read Copy Update(读-拷贝修改) */ 
    trace_init(); /* 跟踪调试相关初始化 */ 
 
    context_tracking_init();     
    radix_tree_init();     /* 基数树相关数据结构初始化 */ 
    early_irq_init();       /* 初始中断相关初始化,主要是注册irq_desc结构体变 
                                  * 量，因为Linux内核使用irq_desc来描述一个中断。 
                                  */ 
    init_IRQ();                 /* 中断初始化 */ 
    tick_init();                /* tick初始化 */
    rcu_init_nohz();             
    init_timers();              /* 初始化定时器 */ 
    hrtimers_init();            /* 初始化高精度定时器 */ 
    softirq_init();             /* 软中断初始化 */ 
    timekeeping_init();          
    time_init();                 /* 初始化系统时间 */ 
    sched_clock_postinit();      
    perf_event_init(); 
    profile_init(); 
    call_function_init(); 
    WARN(!irqs_disabled(), "Interrupts were enabled early\n"); 
    early_boot_irqs_disabled = false; 
    local_irq_enable();      /* 使能中断 */ 
 
    kmem_cache_init_late(); /* slab初始化，slab是Linux内存分配器  */ 
    console_init();          /* 初始化控制台，之前printk打印的信息都存放 
                                   * 缓冲区中，并没有打印出来。只有调用此函数 
                                   * 初始化控制台以后才能在控制台上打印信息。 
                                   */ 
    if (panic_later)             
        panic("Too many boot %s vars at `%s'", panic_later, 
              panic_param); 
 
    lockdep_info();/* 如果定义了宏CONFIG_LOCKDEP，那么此函数打印一些信息。*/ 
 
    locking_selftest()  /* 锁自测 */      
    ...... 
    page_ext_init();         
    debug_objects_mem_init(); 
    kmemleak_init();        /* kmemleak初始化，kmemleak用于检查内存泄漏 */ 
    setup_per_cpu_pageset();     
    numa_policy_init(); 
    if (late_time_init) 
        late_time_init(); 
    sched_clock_init();          
    calibrate_delay(); /* 测定BogoMIPS值，可以通过BogoMIPS来判断CPU的性能 
                            * BogoMIPS设置越大，说明CPU性能越好。 
                            */ 
    pidmap_init();      /* PID位图初始化 */ 
    anon_vma_init();     /* 生成anon_vma slab缓存 */          
    acpi_early_init(); 
    ...... 
    thread_info_cache_init();  
    cred_init();          /* 为对象的每个用于赋予资格(凭证)  */ 
    fork_init();          /* 初始化一些结构体以使用fork函数  */ 
    proc_caches_init();  /* 给各种资源管理结构分配缓存   */ 
    buffer_init();        /* 初始化缓冲缓存      */ 
    key_init();            /* 初始化密钥       */ 
    security_init();      /* 安全相关初始化      */ 
    dbg_late_init(); 
    vfs_caches_init(totalram_pages); /* 为VFS创建缓存  */ 
    signals_init();                /* 初始化信号   */ 
 
    page_writeback_init();         /* 页回写初始化   */ 
    proc_root_init();              /* 注册并挂载proc文件系统 */ 
    nsfs_init();                 
    cpuset_init();        /* 初始化cpuset，cpuset是将CPU和内存资源以逻辑性 
                               * 和层次性集成的一种机制，是cgroup使用的子系统之一 
                               */ 
    cgroup_init();         /* 初始化cgroup */ 
    taskstats_init_early();      /* 进程状态初始化 */ 
    delayacct_init(); 
 
    check_bugs();                /* 检查写缓冲一致性 */ 
 
    acpi_subsystem_init();       
    sfi_init_late(); 
 
    if (efi_enabled(EFI_RUNTIME_SERVICES)) { 
        efi_late_init(); 
        efi_free_boot_services(); 
    } 
 
    ftrace_init(); 
 
    rest_init();                 /* rest_init函数 */ 
}
```

### reset_init

```c
static noinline void __init_refok rest_init(void)
{
	int pid;

	rcu_scheduler_starting();
	smpboot_thread_init();
	/*
	 * We need to spawn init first so that it obtains pid 1, however
	 * the init task will end up wanting to create kthreads, which, if
	 * we schedule it before we create kthreadd, will OOPS.
	 */
	kernel_thread(kernel_init, NULL, CLONE_FS); // 创建init进程, PID是1
	numa_default_policy();
	pid = kernel_thread(kthreadd, NULL, CLONE_FS | CLONE_FILES);
	rcu_read_lock();
	kthreadd_task = find_task_by_pid_ns(pid, &init_pid_ns);
	rcu_read_unlock();
	complete(&kthreadd_done);

	/*
	 * The boot idle thread must execute schedule()
	 * at least once to get things moving:
	 */
	init_idle_bootup_task(current);
	schedule_preempt_disabled();
	/* Call into cpu_idle with preempt disabled */
	cpu_startup_entry(CPUHP_ONLINE);
}
```

> init进程的PID为1。init进程一开始是内核进程(也就是运行在内核态)，后面init进程会在根 文件系统中查找名为“init”这个程序，这个“init”程序处于用户态，通过运行这个“init”程 序，init进程就会实现从内核态到用户态的转变。实际运行的是`kernel_init`
>
> `kthreadd` 内核进程，此内核进程的PID为2。kthre add进程负责所有内核进程的调度和管理
>
> `cpu_startup_entry`会调用`cpu _idle_loop`，cpu_idle_loop是个while循环，也就是idle进程代码。idle进程的PID为0，idle进 程叫做空闲进程, 它是有主进程演变 而来的

#### kernel_init

init进程具体做的工作，定义在文件init/main.c

```c
static int __ref kernel_init(void *unused)
{
	int ret;

	kernel_init_freeable();
	/* need to finish all async __init code before freeing the memory */
	async_synchronize_full();
	free_initmem();
	mark_rodata_ro();
	system_state = SYSTEM_RUNNING;
	numa_default_policy();

	flush_delayed_fput();

	if (ramdisk_execute_command) { // 这个变量是"/init", 也可以在uboot里面使用rdinit=xxx设置
		ret = run_init_process(ramdisk_execute_command);
		if (!ret)
			return 0;
		pr_err("Failed to execute %s (error %d)\n",
		       ramdisk_execute_command, ret);
	}

	/*
	 * We try each of these until one succeeds.
	 *
	 * The Bourne shell can be used instead of init if we are
	 * trying to recover a really broken machine.
	 */
	if (execute_command) {// execute_command的值是通过uboot传递，使用init=xxxx
		ret = run_init_process(execute_command);
		if (!ret)
			return 0;
		panic("Requested init %s failed (error %d).",
		      execute_command, ret);
	}
    // 一次尝试运行下面
	if (!try_to_run_init_process("/sbin/init") ||
	    !try_to_run_init_process("/etc/init") ||
	    !try_to_run_init_process("/bin/init") ||
	    !try_to_run_init_process("/bin/sh"))
		return 0;

	panic("No working init found.  Try passing init= option to kernel. "
	      "See Linux Documentation/init.txt for guidance.");
}
```

> init进程的主要任务是启动其他系统服务和用户交互界面。它会执行用户态的init程序（如*/sbin/init*），并启动各种服务，如登录进程（getty）、命令行进程和shell进程。所有用户进程都直接或间接派生自init进程。

```c
static noinline void __init kernel_init_freeable(void)
{
	/*
	 * Wait until kthreadd is all set-up.
	 */
	wait_for_completion(&kthreadd_done);

	/* Now the scheduler is fully set up and can do blocking allocations */
	gfp_allowed_mask = __GFP_BITS_MASK;

	/*
	 * init can allocate pages on any node
	 */
	set_mems_allowed(node_states[N_MEMORY]);
	/*
	 * init can run on any cpu.
	 */
	set_cpus_allowed_ptr(current, cpu_all_mask);

	cad_pid = task_pid(current);

	smp_prepare_cpus(setup_max_cpus);

	do_pre_smp_initcalls();
	lockup_detector_init();

	smp_init();
	sched_init_smp();

	do_basic_setup(); // 完成Linux下设备驱动初始化工作

	/* Open the /dev/console on the rootfs, this should never fail */
    // 打开这个串口作为默认stdin(0)
	if (sys_open((const char __user *) "/dev/console", O_RDWR, 0) < 0)
		pr_err("Warning: unable to open an initial console.\n");

	(void) sys_dup(0); // 文件描述符1, 标准输出
	(void) sys_dup(0); // 文件描述符2标准错误
	/*
	 * check if there is an early userspace init.  If yes, let it do all
	 * the work
	 */

	if (!ramdisk_execute_command)
		ramdisk_execute_command = "/init";

	if (sys_access((const char __user *) ramdisk_execute_command, 0) != 0) {
		ramdisk_execute_command = NULL;
		prepare_namespace(); // 挂载根文件系统
	}

	/*
	 * Ok, we have completed the initial bootup, and
	 * we're essentially up and running. Get rid of the
	 * initmem segments and start the user-mode stuff..
	 *
	 * rootfs is available now, try loading the public keys
	 * and default modules
	 */

	integrity_load_keys();
	load_default_modules();
}
```

