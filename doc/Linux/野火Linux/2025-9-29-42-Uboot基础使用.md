# Uboot

不仅支持嵌入式Linux系统的引导，还支持NetBSD,VxWorks, QNX, RTEMS, ARTOS, LynxOS, Android 等嵌入式操作系统的引导

一般来说BootLoader必须提供系统上电时的初始化代码，在系统上电时初始化相关环境后，Boot Loader 需要引导完整的操作系统，然后将控制器交给操作系统。简单来说BootLoader是一段小 程序，它在系统上电时执行，通过这段小程序可以将硬件设备进行初始化，如CPU、SDRAM、 Flash、串口、网络等，初始化完毕后调用操作系统内核。

## 基础使用

### 编译

```bash
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- distclean 
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- mx6ull_14x14_ddr512_emmc_defconfig 
make V=1 ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- -j12
```

### 进入

启动的时候随意按一个按键即可进入boot

> **Uboot里面的数字都是16进制的**

### 基础命令

在没有命令名冲突的情况下可以使用命令的前几个字母作为命令的输入

![image-20250929205522833](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509292055963.png)

+ bdinfo: 查看板子的内存基础配置以及网络等信息
+ nm: 修改内存里面的信息 `nm[.b .w .l] address`, 修改以后地址不会进行自增
+ mm: 同上, 地址自增
+ mw: 使用一个数值进行一段内存地址的填充`mw[.b .w .l] address value [count]`
+ cp: 复制一段地址`cp [.b, .w, .l] source target count`
+ cmp: 比较两段地址 `cmp [.b, .w, .l] addr1 addr2 count `

#### mmc命令

![image-20250929205629354](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509292056405.png)

![image-20250929205856104](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509292058140.png)

uboot 能够对ext2/3/4 以及 fat 文件系统设备进行访问，可使用fstype命令判断存储介质分区使用 的是什么类型的文件系统。

![image-20250929205945430](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509292059455.png)

```bash
=> ? mmc   
mmc - MMC sub system

Usage:
mmc info - display info of the current MMC device
mmc read addr blk# cnt
mmc write addr blk# cnt
mmc erase blk# cnt
mmc rescan
mmc part - lists available partition on current mmc device
mmc dev [dev] [part] - show or set current mmc device [partition]
mmc list - lists available devices
mmc hwpartition [args...] - does hardware partitioning
  arguments (sizes in 512-byte blocks):
    [user [enh start cnt] [wrrel {on|off}]] - sets user data area attributes
    [gp1|gp2|gp3|gp4 cnt [enh] [wrrel {on|off}]] - general purpose partition
    [check|set|complete] - mode, complete set partitioning completed
  WARNING: Partitioning is a write-once setting once it is set to complete.
  Power cycling is required to initialize partitions after set to complete.
mmc bootbus dev boot_bus_width reset_boot_bus_width boot_mode
 - Set the BOOT_BUS_WIDTH field of the specified device
mmc bootpart-resize <dev> <boot part size MB> <RPMB part size MB>
 - Change sizes of boot and RPMB partitions of specified device
mmc partconf dev boot_ack boot_partition partition_access
 - Change the bits of the PARTITION_CONFIG field of the specified device
mmc rst-function dev value
 - Change the RST_n_FUNCTION field of the specified device
   WARNING: This is a write-once field and 0 / 1 / 2 are the only valid values.
mmc setdsr <value> - set DSR register value
```

+ `mmc dev 1 0`: 切换分区到设备1的分区0
+ `mmc read 80800000 600 10`从0x600块读取0x10个块
+ `mmc write 80800000 80800000 2 32E`可以使用这个命令配合tftp进行Uboot升级

#### 文件系统

可以使用`fstype`查看一个分区的格式`fs mmc 0:1`

![image-20250929210407759](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509292104794.png)

+ `fatinfo mmc 0:1`查看SD卡第一个分区, 里面有dtb以及zImage文件
+ fatmkdir：创建目录
+ fatrm：删除文件
+ `fatwrite mmc 1:1 80800000 zImage 6788f8`: 把内存上的数据存储到FAT分区的一个文件里
+ `fatload mmc 1:1 80800000 zImage`

![image-20250929210818807](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509292108840.png)

#### 网络

+ ping: ping一个ip查看是不是可以连接
+ dhcp: 自动分配ip地址
+ nfs: 使用nfs下载文件, 需要设置一下serverip的环境变量,  `nfs 0x80800000 192.168.106.173:/home/jiao/nfs/test.txt`(失败)
+ tftp: 

```bash
sudo apt-get install tftp-hpa tftpd-hpa 
sudo apt-get install xinetd
mkdir /home/zuozhongkai/linux/tftpboot 
chmod 777 /home/zuozhongkai/linux/tftpboot 
```

设置两个文件

```bash
jiao@jiao-virtual-machine:~$  cat /etc/xinetd.d/tftp
server tftp
{
    socket_type         = dgram
    protocol            = udp
    wait                = yes
    user                = root
    server              = /usr/sbin/in.tftp.d
    server_args         = -s /home/jiao/tftp
    disable             = no
    per_source          = 11
    cps                 = 100 2
    flags               = IPv4


}

sudo service tftpd-hpa start 

jiao@jiao-virtual-machine:~$ cat  /etc/default/tftpd-hpa
# /etc/default/tftpd-hpa

TFTP_USERNAME="tftp"
TFTP_DIRECTORY="/home/jiao/tftp"
TFTP_ADDRESS=":69"
TFTP_OPTIONS="-l -c -s"

sudo service tftpd-hpa restart 
```

#### 其他

+ go: 去指定位置运行bin文件
+ reboot: 重启
+ run: 运行一个命令的字符串, 可以设置为环境变量
+ mtest: 测试内存
+ 

## 启动过程

### 命令

#### bootz启动内核

bootz: 将zImage镜像以及dtb设备树复制到DRAM里面, bootz命令用于启动zImage镜像文件

```bash
bootz [addr [initrd[:size]] [fdt]] 
```

addr是Linux镜像文件在DRAM中的位置，initrd是initrd文件在 DRAM中的地址，如果不使用initrd的话使用‘-’代替即可，fdt就是设备树文件在DRAM中 的地址。

+ 从网络启动

```bash
=> ping 192.168.106.173                                       
Using FEC1 device
error frame: 0x9ef547c0 0x00000804
host 192.168.106.173 is alive
=> tftp 80800000 zImage
Using FEC1 device
TFTP from server 192.168.106.173; our IP address is 192.168.137.168; sending through gateway 192.168.137.1
Filename 'zImage'.
Load address: 0x80800000
Loading: #################################################################
         #################################################################
         #################################################################
         #################################################################
         #################################################################
         #################################################################
         #################################################################
         ########
         831.1 KiB/s
done
Bytes transferred = 6792144 (67a3d0 hex)
=> tftp 83000000 imx6ull-14x14-emmc-7-1024x600-c.dtb
Using FEC1 device
TFTP from server 192.168.106.173; our IP address is 192.168.137.168; sending through gateway 192.168.137.1
Filename 'imx6ull-14x14-emmc-7-1024x600-c.dtb'.
Load address: 0x83000000
Loading: ###
         7.8 KiB/s
done
Bytes transferred = 40381 (9dbd hex)
=> bootz 80800000 - 83000000      
Kernel image @ 0x80800000 [ 0x000000 - 0x67a3d0 ]
## Flattened Device Tree blob at 83000000
   Booting using the fdt blob at 0x83000000
   Using Device Tree in place at 83000000, end 8300cdbc

Starting kernel ...
```

+ 从EMMC启动

```bash
=> fatls mmc 1:1
  6792136   zimage 
    40381   imx6ull-14x14-emmc-4.3-480x272-c.dtb 
    40381   imx6ull-14x14-emmc-4.3-800x480-c.dtb 
    40381   imx6ull-14x14-emmc-7-800x480-c.dtb 
    40381   imx6ull-14x14-emmc-7-1024x600-c.dtb 
    40381   imx6ull-14x14-emmc-10.1-1280x800-c.dtb 
    41217   imx6ull-14x14-emmc-hdmi.dtb 
    41125   imx6ull-14x14-emmc-vga.dtb 

8 file(s), 0 dir(s)

=> fatload mmc 1:1 80800000 zimage
reading zimage
6792136 bytes read in 223 ms (29 MiB/s)
=> fatload mmc 1:1 83000000 imx6ull-14x14-emmc-7-1024x600-c.dtb 
reading imx6ull-14x14-emmc-7-1024x600-c.dtb
40381 bytes read in 24 ms (1.6 MiB/s)
=> bootz 80800000 - 83000000                                   
Kernel image @ 0x80800000 [ 0x000000 - 0x67a3c8 ]
## Flattened Device Tree blob at 83000000
   Booting using the fdt blob at 0x83000000
   Using Device Tree in place at 83000000, end 8300cdbc

Starting kernel ...
```

#### bootm

bootm 和bootz 功能类似，但是bootm用于启动uImage镜像文件。

`bootm [addr [initrd[:size]] [fdt]] `

#### boot

boot 命令也是用来启动Linux系统的，只是boot会读取环境变量bootcmd来启动Linux系统

bootcmd与bootargs可以说是uboot最重要的两个环境参数，uboot执行完毕之后，如果没有按下 回车，则会自动执行bootcmd命环境参数里的内容，而bootargs则是传递给内核的启动参数

> 参数的配置可以从include/configs/mx6ullfire.h文件里面查看

```
=> printenv bootcmd
bootcmd=run distro_bootcmd
=> printenv distro_bootcmd
distro_bootcmd=for target in ${boot_targets}; do run bootcmd_${target}; done
=> printenv boot_targets  
boot_targets=mmc0 mmc1 
```

> mmc0表示的sd卡的存储设备，mmc1表示的emmc设备, 当sd卡插在板子时， 若sd卡装有系统则会优先从sd卡内启动

bootcmd_mmc0与bootcmd_mmc1均设置各自devtype、mmcdev、bootpart、rootfpart环境参数 的值，最后运行boot环境参数

```
=> printenv bootcmd_mmc0
bootcmd_mmc0=if test -n "${SDBOOT}"; then setenv devtype mmc; setenv mmcdev 0; setenv bootpart 0:1 ; setenv rootfpart 0:2 ; run boot; fi
=> printenv bootcmd_mmc1
bootcmd_mmc1=setenv devtype mmc; setenv mmcdev 1; setenv bootpart 1:1 ; setenv rootfpart 1:2 ; run boot
```

最后执行的boot命令如下

```python
	"boot=mmc check;${devtype} dev ${mmcdev};mmc rescan; " \
		"echo loading [${devtype} ${bootpart}] /uEnv.txt ...; "\
		"if run loaduEnv; then " \ # 加载uEnv.txt文件的配置
			"run importbootenv;" \ # 运行importbootenv，从内存地址中导入环境参数
			"if test ${second_flash} = emmc; then " \ # 判断启动的介质设置dtb、storage、init环境参数
					"setenv dtb ${mmc_dtb};"  \
					"setenv storage_media init=/opt/scripts/tools/eMMC/init-eMMC-flasher-v3.sh;"  \
				"else " \
					"setenv dtb ${nand_dtb};"  \
					"setenv storage_media init=/opt/scripts/tools/Nand/init-Nand-flasher-v1.sh;"  \
				"fi; " \
			"if test -n ${flash_firmware}; then "  \
					"echo setting flash firmware...;"  \
					"setenv flashtype ${storage_media};"  \
			"fi;" \
			"run args_mmc_old;" \ # args_mmc_old 的作用主要用于设置bootargs环境参数
			"echo loading vmlinuz-${uname_r} ...; "\
            # 将kernel内核加载到内存地址0x80800000
			"load ${devtype} ${bootpart} 0x80800000 /kernel/vmlinuz-${uname_r};"\ 
			"echo loading ${dtb} ...; "\
            # 将主设备树加载到内存地址0x83000000处
			"load ${devtype} ${rootfpart} 0x83000000 /usr/lib/linux-image-${uname_r}/${dtb};"\ 
            # ，将设备树插件的内容解析合成到主设备树上，dtfile命令并不是原来uboot就有的，
		   # 为了方便用户使用/boot/uEnv.txt 文件使用设备树插件而添加的，有兴趣的读者可自行查看相关源码。
			"dtfile 0x83000000 0x87000000  /uEnv.txt ${loadaddr};"   \
            # 将虚拟文件系统加载到0x88000000中
			"load ${devtype} ${bootpart} 0x88000000 /kernel/initrd.img-${uname_r};"\
			"echo debug: [${bootargs}] ... ;" \
			"echo debug: [bootz] ...  ;" \
		   # 启动linux内核
			"bootz 0x80800000 0x88000000:${filesize} 0x83000000;"	\
		"fi;\0" \
```

这里面的loaduEnv是` loaduEnv=load${devtype} ${bootpart} ${loadaddr} /uEnv.txt;`, 加载一下这个文件

```c
"args_mmc_old=setenv bootargs console=ttymxc0 " \
    "root=/dev/mmcblk${mmcdev}p2 rw " \
    "rootfstype=ext4 " \
    "rootwait ${cmdline} ${flashtype}\0" \
```

## 环境参数

uboot 中环境参数为我们提供一种不修改uboot源码的情况下，能够修改kernel启动倒计时、ip地 址、以及向内核传递不同的参数等

默认情况下使用`setenv`命令修改环境参数重启后就会消失，若想要掉电保存需要执行`saveenv`将环境参数保存到存储介质。

> [The U-Boot Documentation — Das U-Boot unknown version documentation](https://docs.u-boot.org/en/latest/)

## 编译

![image-20250929215934240](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509292159312.png)

野火提供的imx6ulluboot分为nand版本和emmc版本，以编译emmc版本为例

```bash
 sudo make distclean
 # 编译 emmc 版本 uboot, 加载板级配置文件，具体的板级配置文件在uboot根目录下的configs目录下
 sudo make ARCH=arm CROSS_COMPILE=arm-none-eabi- mx6ull_fire_mmc_defconfig
 # 编译 uboot
 sudo make ARCH=arm CROSS_COMPILE=arm-none-eabi-
```

#### 生成的文件

+ u-boot：初步链接后得到的uboot文件
+ u-boot-nodtb.bin：是在u-boot的基础上，经过objcopy去除符号表信息之后的可执行程序， 具体代码如下
+ u-boot.dtb：uboot的设备树，是由arm-none-eabi-gcc和dtc编译出来的，详细的可以分析编 译过程，这里就不展开分析了
+ u-boot.bin：是在u-boot-nodtb.bin后追加了u-boot.dtb形成的
+ u-boot-dtb.imx：是u-boot.bin添加了3KB头部信息和尾部信息(结尾添加了1298字节的 00,00实际没什么作用)组成的镜像

编译生成的u-boot-dtb.imx 文件就是我们想要文件

## 烧录

### Windows

MFGTool 工具是 NXP 官方推荐的一个使用USBOTG来升级镜像的软件工具，它是NXP针对 i.MX 系列处理器专门使用的烧录工具

可以用来升级linux，单独烧录某一系统分区，独立地烧 录spi flash、nor flash、sd card、nand flash，emmc 等

MFGtool工具的烧录步骤分为两个阶段：BurnStarp和Updater。第一阶段是烧录前的准 备工作，配置设备USB的vid和pid，来选择烧录的设备。第二阶段是MFGtools开始烧录到结束 烧录的过程，这个阶段的烧录过程是严格根据ucl2.xml文件来处理的，实际上是将bootloader加 载到ram，然后在运行时将编译好的文件系统和镜像文件烧录到开发板上，烧录的位置由用户指 定，可以是sdcard、nandflash，emmc等

入到mfgtool 目录中的`mfgtools-release\Profiles\Linux\OS Firmware\release` 目录将相应文 件替换即

将mfgtools-release\Profiles\Linux\OS Firmware 目录下的 ucl2.xml 替换

“cfg.ini”文件默认为EMMC的烧写配置文件，若想要烧写NAND版本镜像，将cfg.ini 重命名为cfg-emmc.ini，并将cfg-nand.ini 文件重命名为cfg.ini 即可

emmc 版本：将1/4/5/7打到ON档，其他拨码开关打到OFF档。

>  也可以选择通过按键方式进入烧录模式，按键法可以不用拨码，拨码状态在之前的EMMC 或者NAND都可以
>
> 1. 上电 
> 2. 按下MODE按键
> 3. 按下复位(RESET)按键
> 4. 松开复位(RESET)按键
> 5. 松开MODE按键

### Ubuntu

1. 将sd卡通过读卡器连接到虚拟机前，使用lsblk命令查看当前磁盘设备
2. 将sd卡通过读卡器连接到电脑上，并选择连接到虚拟机上
3. 再次使用lsblk命令插件磁盘设备，如下所示
4. 执行以下烧录命令，将u-boot-dtb.imx烧写到/dev/sdb中

```bash
sudo dd iflag=dsync oflag=dsync if=u-boot-dtb.imx of=/dev/sdb seek=2
```

将sd卡插到开发板上将拨码开关设置sd卡启动打开电源即可启动uboot。

## 图形化配置界面

### 安装

menuconfig 是一套图形化的配置工具，需要ncurses库支持。ncurses 库提供了一系列的API函数供调用 者生成基于文本的图形界面

```c
sudo apt-get install build-essential 
sudo apt-get install libncurses5-dev
```

menuconfig 重点会用到两个文件：.config 和 Kconfig，.config 文件前面已经说了，这个文 件保存着uboot的配置项，使用menuconfig配置完uboot以后肯定要更新.config文件。Kconfig 文件是图形界面的描述文件，也就是描述界面应该有什么内容，很多目录下都会有Kconfig文 件。

在打开图形化配置界面之前，要先使用`make xxx_defconfig`对 uboot进行一次默认配置， 只需要一次即可。如果使用`make clean`清理了工程的话就那就需要重新使用`make xxx_d efconfig`再对 uboot 进行一次配置

## 使用

使用`make menuconfig`即可打开

> 可以在这个文件里面进行使能, 也可以在板子的.h文件里面进行使能, 在这个文件里面使能的命令是识别不了的, 因为它使用的是.config文件里面的配置

可以通过这个页面使能一下DNS命令, 使能的命令在使用时候还需要设置参数`setenv dnsip 114.114.114.114`

页面最下面的Save进行保存, 一般记录为.config文件, 可以复制一份, 之后直接使用Load加载 