# 裸机汇编开发

## 汇编指令

### 基础指令

GNU汇编语法适用于所有的架构，并不是ARM独享的，GNU汇编由一系列的语句组成， 每行一条语句，每条语句有三个可选部分

```c
label：instruction @ comment
```

+ **label** 即标号，表示地址位置，有些指令前面可能会有标号，这样就可以通过这个标号得到 指令的地址，标号也可以用来表示数据地址。注意label后面的“：”，任何以“：”结尾的标识 符都会被识别为一个标号
+ **instruction** 即指令，也就是汇编指令或伪指令。
+ @符号，表示后面的是注释

### 段

用户可以使用.section伪操作来定义一个段，汇编系统预定义了一些段名：  

+ .text 表示代码段
+ .data 初始化的数据段。 
+ .bss 未初始化的数据段。  
+ .rodata 只读数据段。

`.section .testsection @定义一个testsetcion段`

汇编程序的默认入口标号是_start，不过我们也可以在链接脚本中使用ENTRY来指明其它 的入口点

```assembly
.global _start   
 
_start: 
 ldr r0, =0x12 @r0=0x12 
```

### 伪指令

+ .byte 定义单字节数据，比如.byte 0x12。  
+ .short 定义双字节数据，比如.short 0x1234。  
+ .long 定义一个4字节数据，比如.long 0x12345678。  
+ .equ  赋值语句，格式为：.equ 变量名，表达式，比如.equ num, 0x12，表示num=0x1 2。  
+ .align  数据字节对齐，比如：.align 4表示4字节对齐。  
+ .end  表示源文件结束。  
+ .global  定义一个全局符号，格式为：.global symbol，比如：.global _start。

### 函数

```bash
函数名: 
 函数体 
 返回语句
```

```assembly
/* SVC中断 */ 
SVC_Handler: 
    ldr r0, =SVC_Handler 
    bx r0
```

### 常用指令

#### 处理器内部数据传输

![image-20251012092932952](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510120929002.png)

#### 存储器访问

![image-20251012093914518](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510120939565.png)

```assembly
LDR R0, =0X0209C004 @将寄存器地址0X0209C004加载到R0中，即R0=0X0209C004 
LDR R1, [R0]          @读取地址0X0209C004中的数据到R1寄存器中
```

#### 栈

![image-20251012094024647](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510120940686.png)

#### 跳转

![image-20251012094154703](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510120941754.png)

#### 运算

![image-20251012094220778](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510120942821.png)

#### 逻辑运算

![image-20251012094249892](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510120942937.png)

## 裸机运行

6ULL有内部128K(0x0090 0000~0x0091 FFFF)以及外部的DDR

I.MX6U-ALPHA开发板的DDR容量有两种：512MB和256MB，起 始地址都为0X80000000，只不过512MB的终止地址为0X9FFFFFFF，而 256MB容量的终止地 址为0X8FFFFFFF

所以使用的链接地址是0x8780 0000 也是UBoot的起始地址

> IM6ULL运行的时候不可以直接运行bin文件, 需要添加一个头部, 这个头部里面添加了DDR的初始化参数, 所以可以直接使用DDR进行代码的运行, 同时会自动进行bin文件的拷贝

## 编译

```bash
arm-linux-gnueabihf-gcc -g -c led.s -o led.o
arm-linux-gnueabihf-ld -Ttext 0X87800000 led.o -o led.elf
# “-O”选项指定以什么格式输出，后面的“binary”表示以二进制格式输出，
# 选项“-S”表示不要复制源文件中的重定位信息和符号信息，“-g”表示不复制源文件中的调试信息。
arm-linux-gnueabihf-objcopy -O binary -S -g led.elf led.bin
# 反汇编
arm-linux-gnueabihf-objdump -D led.elf  >  led.dis 
```

下载的时候需要添加头部以及烧录到对应的SD卡里面, 这里使用的方式是利用正点原子的软件

## 使用C语言

1. 配置为SVC模式, 设置CPSR状态寄存器的0-4位10011, Supervisor是系统的权限等级
2. 设置SP指针, 可以使内部的RAM, 也可以使用DDR(0x8000 0000 - 0x9fff ffff)
3. 跳转C语言里面的函数
