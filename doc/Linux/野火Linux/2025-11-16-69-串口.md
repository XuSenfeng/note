# 串口

Linux 下通常通过串口和其他设备或传感器进行通信，根据电平的不同，串口分为TTL和RS232。不管是什么样的接口电平，其驱动程序都是一样的，通过外接RS485这样的芯片就可以将串口转换为 RS485信号

同 I2C、SPI一样，Linux也提供了串口驱动框架，我们只需要按照相应的串口框架编写驱动程序即可, 默认厂商会实现这一部分代码

```c
struct uart_driver {
	struct module		*owner;
	const char		*driver_name;
	const char		*dev_name;
	int			 major;
	int			 minor;
	int			 nr;
	struct console		*cons;

	/*
	 * these are private; the low level driver should not
	 * touch these; they should be initialised to NULL
	 */
	struct uart_state	*state;
	struct tty_driver	*tty_driver;
};
```

在驱动里面需要实现并注册这个玩意

使用另一个结构体`uart_port`描述一个具体的串口的接口定义在 include/linux/serial_core.h 文件

可以使用这个函数给driver添加一个port

```c
int uart_add_one_port(struct uart_driver *drv,
struct uart_port *uport)
```

uart_port里面记录有ops, 保存相关的操作函数, 保存针对一个端口使用的所有操作, 实际记录的是`imx_pops`, Linux系统收发数据最终调用的都是ops中的函数

```c
static struct uart_ops imx_pops = {
	.tx_empty	= imx_tx_empty,
	.set_mctrl	= imx_set_mctrl,
	.get_mctrl	= imx_get_mctrl,
	.stop_tx	= imx_stop_tx,
	.start_tx	= imx_start_tx,
	.stop_rx	= imx_stop_rx,
	.enable_ms	= imx_enable_ms,
	.break_ctl	= imx_break_ctl,
	.startup	= imx_startup,
	.shutdown	= imx_shutdown,
	.flush_buffer	= imx_flush_buffer,
	.set_termios	= imx_set_termios,
	.type		= imx_type,
	.config_port	= imx_config_port,
	.verify_port	= imx_verify_port,
#if defined(CONFIG_CONSOLE_POLL)
	.poll_init      = imx_poll_init,
	.poll_get_char  = imx_poll_get_char,
	.poll_put_char  = imx_poll_put_char,
#endif
};
```

串口使用中断处理收发的数据, 接受数据以后, 把数据使用`tty_insert_filp_char`把数据给tty

## 串口协议

| 特性         | UART (TTL)          | RS-232               | RS-485                     |
| :----------- | :------------------ | :------------------- | :------------------------- |
| **本质**     | **协议** (数据格式) | **电气与物理标准**   | **电气标准**               |
| **信号类型** | 单端 (对GND)        | 单端 (对GND)，负逻辑 | **差分** (A-B线)           |
| **电平**     | 0V & 3.3V/5V        | **±3V ~ ±15V**       | **±1.5V ~ ±5V** (差分电压) |
| **通信方式** | 全双工              | 全双工               | **半双工** (主流)          |
| **传输距离** | 极短 (板级)         | 短 (<15m)            | **长 (<1200m)**            |
| **节点数量** | 1对1                | 1对1                 | **1对多 (最多32/256)**     |
| **抗干扰性** | 弱                  | 一般                 | **强**                     |
| **常见应用** | 芯片间通信          | PC串口、设备调试     | 工业总线、楼宇自动化       |

### 485

| 引脚 | 名称 | 功能                              |
| ---- | ---- | --------------------------------- |
| 1    | RO   | 接收器输出----接RX                |
| 2    | RE   | 接收器输出使能（低电平-接收使能） |
| 3    | DE   | 驱动器输出使能（高电平-发送使能） |
| 4    | DI   | 驱动器输入----接TX                |
| 5    | GND  | 接地                              |
| 6    | A    | 驱动器输出/接收器输入（同相）     |
| 7    | B    | 驱动器输出/接收器输入（反相）     |
| 8    | VCC  | 芯片供电+3.3V                     |

![img](https://pica.zhimg.com/v2-28e9b74fc39ac713813640be5c6a6be8_1440w.jpg)

-   **RS485_EN 为高电平**，逻辑为1，发送使能，接收禁止。
-   **RS485_EN 为低电平**，逻辑为0，发送禁止，接收使能

>   -   在**发送数据前**，给RS485_EN 置高电平。
>   -   在**发送数据后**，给RS485_EN 置低电平。

### 232

接收端有效的RS-232信号电平介于+3V至+15V之间，或者-3V至-15V之间。具体的讲，输出端当电压介于+5V至15V之间时，驱动器输出为逻辑0，当电压介于-5V至-15V之间，驱动器的输出逻辑是1

## 设备树

```json
&uart3 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_uart3>;
	status = "okay";
};
```

```c
  pinctrl_uart3: uart3grp {
    fsl,pins = <
      MX6UL_PAD_UART3_RX_DATA__UART3_DCE_RX	0x1b0b1
      MX6UL_PAD_UART3_TX_DATA__UART3_DCE_TX	0x1b0b1
    >;
  };
```

## 使用

一般是直接移植com控制软件

也可以自己写一个操控

```c
/**
 * serial_port.c - Linux串口通信程序
 * 编译: gcc -o serial_port serial_port.c
 * 使用: ./serial_port /dev/ttyUSB0 115200
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <termios.h>
#include <errno.h>
#include <sys/ioctl.h>
#include <signal.h>
#include <time.h>

#define BUFFER_SIZE 256

// 全局变量
int serial_fd = -1;
volatile int keep_running = 1;

// 信号处理函数，用于优雅退出
void signal_handler(int sig) {
    keep_running = 0;
    printf("\n程序退出中...\n");
}

// 打印使用说明
void print_usage(const char *program_name) {
    printf("使用方法: %s <设备文件> <波特率>\n", program_name);
    printf("示例: %s /dev/ttyUSB0 115200\n", program_name);
    printf("示例: %s /dev/ttyS0 9600\n", program_name);
}

// 配置串口
int configure_serial_port(int fd, int baud_rate) {
    struct termios options;
    
    // 获取当前串口配置
    if (tcgetattr(fd, &options) != 0) {
        perror("tcgetattr失败");
        return -1;
    }
    
    // 设置输入输出波特率
    speed_t speed;
    switch (baud_rate) {
        case 9600:   speed = B9600; break;
        case 19200:  speed = B19200; break;
        case 38400:  speed = B38400; break;
        case 57600:  speed = B57600; break;
        case 115200: speed = B115200; break;
        case 230400: speed = B230400; break;
        default:
            fprintf(stderr, "不支持的波特率: %d\n", baud_rate);
            return -1;
    }
    cfsetispeed(&options, speed);
    cfsetospeed(&options, speed);
    
    // 设置串口参数
    options.c_cflag |= (CLOCAL | CREAD);  // 本地连接，启用接收
    options.c_cflag &= ~CSIZE;            // 清除数据位掩码
    options.c_cflag |= CS8;               // 8位数据位
    options.c_cflag &= ~PARENB;           // 无奇偶校验
    options.c_cflag &= ~CSTOPB;           // 1位停止位
    options.c_cflag &= ~CRTSCTS;          // 无硬件流控制
    
    // 设置输入模式
    options.c_iflag &= ~(IXON | IXOFF | IXANY);  // 关闭软件流控制
    options.c_iflag &= ~(INLCR | ICRNL);         // 禁止特殊字符处理
    
    // 设置输出模式
    options.c_oflag &= ~OPOST;  // 原始输出
    
    // 设置本地模式
    options.c_lflag &= ~(ICANON | ECHO | ECHOE | ISIG);  // 非规范模式，关闭回显
    
    // 设置超时和最小字符数
    options.c_cc[VMIN] = 1;   // 读取至少1个字符
    options.c_cc[VTIME] = 10; // 超时时间（单位：0.1秒）
    
    // 应用配置
    if (tcsetattr(fd, TCSANOW, &options) != 0) {
        perror("tcsetattr失败");
        return -1;
    }
    
    // 清空缓冲区
    tcflush(fd, TCIOFLUSH);
    
    return 0;
}

// 打开串口
int open_serial_port(const char *device_path) {
    int fd = open(device_path, O_RDWR | O_NOCTTY | O_SYNC);
    if (fd < 0) {
        perror("打开串口失败");
        return -1;
    }
    
    // 检查是否为tty设备
    if (!isatty(fd)) {
        fprintf(stderr, "%s 不是tty设备\n", device_path);
        close(fd);
        return -1;
    }
    
    return fd;
}

// 发送数据
int send_data(int fd, const unsigned char *data, size_t length) {
    ssize_t bytes_written = write(fd, data, length);
    if (bytes_written < 0) {
        perror("写入串口失败");
        return -1;
    }
    
    // 等待所有数据发送完成
    tcdrain(fd);
    
    return bytes_written;
}

// 接收数据（阻塞模式）
int receive_data(int fd, unsigned char *buffer, size_t buffer_size) {
    fd_set read_fds;
    struct timeval timeout;
    int ret;
    
    // 设置文件描述符集合
    FD_ZERO(&read_fds);
    FD_SET(fd, &read_fds);
    
    // 设置超时时间（5秒）
    timeout.tv_sec = 5;
    timeout.tv_usec = 0;
    
    // 等待数据可读
    ret = select(fd + 1, &read_fds, NULL, NULL, &timeout);
    
    if (ret < 0) {
        perror("select失败");
        return -1;
    } else if (ret == 0) {
        printf("接收超时\n");
        return 0;
    }
    
    // 读取数据
    if (FD_ISSET(fd, &read_fds)) {
        ssize_t bytes_read = read(fd, buffer, buffer_size - 1);
        if (bytes_read < 0) {
            perror("读取串口失败");
            return -1;
        }
        buffer[bytes_read] = '\0';  // 添加字符串结束符
        return bytes_read;
    }
    
    return 0;
}

// 交互式串口终端
void interactive_terminal(int fd) {
    unsigned char tx_buffer[BUFFER_SIZE];
    unsigned char rx_buffer[BUFFER_SIZE];
    
    printf("进入交互模式。输入 'quit' 退出，'hex' 切换十六进制模式。\n");
    
    int hex_mode = 0;
    
    while (keep_running) {
        printf("发送> ");
        fflush(stdout);
        
        // 读取用户输入
        if (fgets((char*)tx_buffer, BUFFER_SIZE, stdin) == NULL) {
            break;
        }
        
        // 处理特殊命令
        if (strncmp((char*)tx_buffer, "quit", 4) == 0) {
            break;
        }
        
        if (strncmp((char*)tx_buffer, "hex", 3) == 0) {
            hex_mode = !hex_mode;
            printf("十六进制模式: %s\n", hex_mode ? "开启" : "关闭");
            continue;
        }
        
        size_t input_length = strlen((char*)tx_buffer);
        if (input_length > 0 && tx_buffer[input_length - 1] == '\n') {
            tx_buffer[input_length - 1] = '\r';  // 将换行符替换为回车符
            tx_buffer[input_length] = '\n';      // 添加换行符
            input_length++;
        }
        
        // 发送数据
        int bytes_sent = send_data(fd, tx_buffer, input_length);
        if (bytes_sent > 0) {
            printf("已发送 %d 字节\n", bytes_sent);
        }
        
        // 接收数据
        int bytes_received = receive_data(fd, rx_buffer, BUFFER_SIZE);
        if (bytes_received > 0) {
            printf("接收到 %d 字节: ", bytes_received);
            
            if (hex_mode) {
                // 十六进制显示
                for (int i = 0; i < bytes_received; i++) {
                    printf("%02X ", rx_buffer[i]);
                }
                printf("\n");
            } else {
                // 文本显示
                for (int i = 0; i < bytes_received; i++) {
                    if (rx_buffer[i] >= 32 && rx_buffer[i] <= 126) {
                        putchar(rx_buffer[i]);
                    } else {
                        printf("\\x%02X", rx_buffer[i]);
                    }
                }
                printf("\n");
            }
        }
    }
}

int main(int argc, char *argv[]) {
    if (argc != 3) {
        print_usage(argv[0]);
        return 1;
    }
    
    const char *device_path = argv[1];
    int baud_rate = atoi(argv[2]);
    
    // 注册信号处理函数
    signal(SIGINT, signal_handler);
    signal(SIGTERM, signal_handler);
    
    // 打开串口
    serial_fd = open_serial_port(device_path);
    if (serial_fd < 0) {
        return 1;
    }
    
    printf("成功打开串口: %s\n", device_path);
    
    // 配置串口
    if (configure_serial_port(serial_fd, baud_rate) != 0) {
        close(serial_fd);
        return 1;
    }
    
    printf("串口配置成功: %d 波特\n", baud_rate);
    
    // 进入交互模式
    interactive_terminal(serial_fd);
    
    // 关闭串口
    close(serial_fd);
    printf("串口已关闭\n");
    
    return 0;
}
```

