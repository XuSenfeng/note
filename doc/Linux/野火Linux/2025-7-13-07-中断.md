# 通用中断处理器GIC

GIC用于处理单核或者多核的芯片中的处理资源, 可以类比于stm32的NVIC

- ARM公司开发了4 个版本GIC规范 ，V1~V4, 板子使用的是V2
- ARMv7-A内核搭配GIC-400使用

ARM会根据GIC版本的不同研发出不 同的IP核，那些半导体厂商直接购买对应的IP核即可，比如ARM针对GIC V2就开发出了G IC400 这个中断控制器IP核。当GIC接收到外部中断信号以后就会报给ARM内核，但是AR M内核只提供了四个信号给GIC来汇报中断情况：VFIQ、VIRQ、FIQ和IRQ

![image-20251014145854420](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510141458481.png)

+ VFIQ:虚拟快速FIQ。  
+ VIRQ:虚拟外部IRQ。  
+ FIQ:快速中断IRQ。  
+ IRQ:外部中断IRQ。

VFIQ 和VIRQ是针对虚拟化的，我们不讨论虚拟化，剩下的就是FIQ和IRQ了，我们前 面都讲了很多次了。本教程我们只使用IRQ，所以相当于GIC最终向ARM内核就上报一个IRQ信号

![image-20251014150417790](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510141504849.png)

左侧部分就是中断源，中间部分就是GIC控制器，最右侧就是中断控制器向 处理器内核发送中断信息。我们重点要看的肯定是中间的GIC部分，GIC将众多的中断源分为 分为三类

1. SPI(Shared Peripheral Interrupt),共享中断，顾名思义，所有Core 共享的中断，这个是 最常见的，那些外部中断都属于SPI中断(注意！不是SPI总线那个中断) 。比如按键中断、串 口中断等等，这些中断所有的Core都可以处理，不限定特定Core
2. PPI(Private Peripheral Interrupt)，私有中断，我们说了 GIC 是支持多核的，每个核肯 定有自己独有的中断。这些独有的中断肯定是要指定的核心处理，因此这些中断就叫做私有中 断。
3. SGI(Software-generated Interrupt)，软件中断，由软件触发引起的中断，通过向寄存 器GICD_SGIR 写入数据来触发，系统会使用SGI中断来完成多核之间的通信

> 中断源有很多，为了区分这些不同的中断源肯定要给他们分配一个唯一ID，这些ID就是 中断ID。每一个CPU最多支持1020个中断ID，中断ID号为ID0~ID1019。这1020个ID包 含了PPI、SPI和SGI

+ ID0~ID15：这 16个ID分配给SGI。
+ ID16~ID31：这16个ID分配给PPI
+ ID32~ID1019：这988个ID分配给SPI，像GPIO中断、串口中断等这些外部中断 ，至于 具体到某个ID对应哪个中断那就由半导体厂商根据实际情况去定义了

I.MX6U的总共 使用了128个中断ID，加上前面属于PPI和SGI的32个ID，I.MX6U的中断源共有128+32=160个

![image-20251014151046100](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510141510151.png)

## GIC结构

GIC官方手册：ARM® Generic Interrupt Controller  

- V2最多支持 8 个内核
- 三类信号源：

    - 软件中断：用于多核通信，ID0~ID15
    - 私有中断：内核独有的中断，ID16~ID31
    - 共享中断：所有内核共享的中断，ID32~ID1019, 使用的比较多的

### 分发器Distributor

+ 将优先级最高的中断事件发送到CPU接口端

1. 全局中断使能控制。  
2. 控制每一个中断的使能或者关闭。  
3. 设置每个中断的优先级。  
4. 设置每个中断的目标处理器列表。  
5. 设置每个外部中断的触发模式：电平触发或边沿触发。  
6. 设置每个中断属于组0还是组1。

#### 相关寄存器

- 中断数量：GICD_TYPER

- 中断清除： GICD_ ICENABLERn
- 中断使能：GICD_ISACTIVERn
- 中断优先级设置：GICD_IPRIORITYR

### cpu接口单元CPU Interface

1. 使能或者关闭发送到CPU Core的中断请求信号。  
2. 应答中断。  
3. 通知中断处理完成。  
4. 设置优先级掩码，通过掩码来设置哪些中断不需要上报给CPU Core。  
5. 定义抢占策略。  
6. 当多个中断到来的时候，选择优先级最高的中断通知给CPU Core

#### 相关寄存器

- 中断优先级数量：GICC_PMR
- 抢占优先级和子优先级设置： GICC_BPR
- 保存中断ID：GICC_IAR 
- 通知cpu中断完成：GICC_EOIR

### 读取GIC基地址

#### 方法一

![image-20250713161938224](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507131619320.png)

#### 方法二：查询cp15协处理器

> CP15可以被配置为很多不同的寄存器, 用于不同的功能, 比如读取数据, 设置cache, mmu, 预测分支等
>
> 在中断里面的时候需要关闭MMU, cache以及分支预测等功能
>
> 1. SCTTLR: 关闭cache, mmu, 控制对齐, 分支预测
> 2. VBAR: 设置一下终端向量表的偏移位置

共有16个：c0~c15。**每个协处理器本身有多种含义，需逐步配置**, 实际就是另一种配置寄存器的方式

```assembly
//设置并读协处理器
MRC {cond} p15, <opc1>, <Rn>, <CRn>, <CRm>, <opc2>
//设置并写协处理器
MCR {cond} p15, <opc1>, <Rn>, <CRn>, <CRm>, <opc2> 
```

- cond：执行条件，一般省略
- opc1：第一层设置
- Rn：通用寄存器
- CRn：要设置的协处理器
- CRm：第二层设置
- opc2：第三层设置

![image-20250713163559275](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507131635370.png)

> 可以使用命令`mrc p15,0,r0,c1,c0,0`读取的SCTLR(系统控制寄存器)

#####  CBAR寄存器

- GIC的地址

```
MRC p15, 4, r1, c15, c0, 0 ;获取 GIC 基地址
```

CRn=c15，opc1=4，CRm=c0，opc2=0, 使用这个命令可以把c15设置为CBAR寄存器, 同时使用r1读取GIC的基地址

![image-20250713164736843](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507131647939.png)

##### SCTLR寄存器

![image-20250713170056574](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507131700626.png)

使用bit13记录中断向量表的基地址

![image-20250713170128727](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507131701790.png)

#### VABR寄存器

 CRn=c12，opc1=0，CRm=c0，opc2=0

- bit5~31：中断向量表偏移地址

```
MRC p15, 0, <Rt>, c12, c0, 0 ;读取 VBAR 寄存器，数据保存到 Rt 中。
MCR p15, 0, <Rt>, c12, c0, 0 ;将 Rt 中的数据写到 VBAR寄存器中。
```

## 开关中断

cpsid i  禁止IRQ中断。

cpsie i   使能IRQ中断。  

cpsid f  禁止FIQ中断。  

cpsie f  使能FIQ中断。

## 优先级

GICC_PMR寄存器 只有低8位有效，这8位最多可以设置256个优先级

GICC_BPR 只有低 3 位有效，其值不同，抢占优先级和子优先级占用的位数也不 同

![image-20251015094734781](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510150947034.png)

某个中断ID的中断优先级设置由寄存器D_IPRIO RITYR 来完成

## 中断向量表

V7-A会使用两级查表

### 一级查表

自动跳转基址+偏移的方式, 这个表的起始位置一般在代码的起始位置, 基址为0, 获取的是终端的类型, 一般使用的是IRQ

Cortex-A内核CPU的所有外部中 断都属于这个IRQ中断，当任意一个外部中断发生的时候都会触发IRQ中断。在IRQ中断服 务函数里面就可以读取指定的寄存器来判断发生的具体是什么中断，进而根据具体的中断做出 相应的处理

| addr | TYPE                   | FUNCTION                                                     | MODE   |
| ---- | ---------------------- | ------------------------------------------------------------ | ------ |
| 0x00 | Reset                  | 复位中断, 上电以后的处理                                     | SVC    |
| 0x04 | Undefined instructions | 未定义指令中断                                               | Undef  |
| 0x08 | Supervisor Call        | 软中断, 由 SWI 指令引起的中断，Linux的系统调用会用SW I 指令来引起软中断，通过软中断来陷入到内核空间 | SYC    |
| 0x0C | Prefetch abort         | 指令预取中止中断                                             | ABT    |
| 0x10 | Data abort             | 数据访问中止中断                                             | ABT    |
| 0x14 | RESERVED               | 未使用                                                       | 未使用 |
| 0x18 | IRQ interrupt          | IRQ 中断, 芯片内部的外设中断都会引起此 中断的发生            | IRQ    |
| 0x1C | FIQ interrupt          | FIQ 中断, 如果需要快速处理中断的话就可以使用此中断           | FIQ    |

![image-20250713173722466](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507131737521.png)

### 二级查表

可以在官方芯片手册里面获取到, 这里的终端是共享中断, 需要有32位的偏移

![image-20250713174059043](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507131740116.png)

![image-20250713174219138](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507131742200.png)

```c
 void SystemIrqHandler(uint32_t giccIar)
{

  uint32_t intNum = giccIar & 0x3FFUL;

 
  /* j检查中断号是否合法 */
  if ((intNum == 1023) || (intNum >= NUMBER_OF_INT_VECTORS))
  {
    return;
  }

  /*如果对应的中断函数不为空，则调用该中断函数*/
  if(NULL != irqTable[intNum].irqHandler)
      irqTable[intNum].irqHandler(giccIar, irqTable[intNum].userParam);

  return;
}
```



### 代码实现

```assembly
.global _start

_start:

    ldr     pc, =Reset_Handler           /* Reset                  */
    ldr     pc, =Undefined_Handler       /* Undefined instructions */
    ldr     pc, =SVC_Handler             /* Supervisor Call        */
    ldr     pc, =PrefAbort_Handler       /* Prefetch abort         */
    ldr     pc, =DataAbort_Handler       /* Data abort             */
    .word   0                            /* RESERVED               */
    ldr     pc, =IRQ_Handler             /* IRQ interrupt          */
    ldr     pc, =FIQ_Handler             /* FIQ interrupt          */

Reset_Handler:
    @ 禁止 IRQ 中断
    cpsid   i 

    @ 定义IRQ模式的栈地址, cps可以控制cpsr寄存器, 控制状态为IRQ模式
    cps     #0x12                
    ldr     sp, =0x9FF00000

#if 0
    mrs r0, cpsr
    bic r0, r0, #0x1f @将 r0 的低 5 位清零，也就是 cpsr 的 M0~M4 
    orr r0, r0, #0x12 @r0 或上 0x12,表示使用 IRQ 模式 
    msr cpsr, r0 @将 r0 的数据写入到 cpsr 中 
    ldr sp, =0x80600000 @IRQ 模式栈首地址为 0X80600000,大小为 2MB 
#endif


	@ 设置栈地址为64M,0X80000000~0XA0000000(512MB), 进入SVC模式
	cps     #0x13
    ldr sp, =0x84000000

	@ 打开全局中断 
	cpsie i				

	@重定位data段 
	bl copy_data

	@清除bss段 
	bl clean_bss

	@ 跳转main函数
    b main 

IRQ_Handler:
	push {r0-r12, lr}		  @保存r0-r2，lr寄存器 
	mrs r0, spsr				 @读取spsr寄存器 
	push {r0}						@保存spsr寄存器 

	mrc p15, 4, r1, c15, c0, 0   @从CP15的C0寄存器内的值到R1寄存器中, 获取CBAR寄存器, 是GIC寄存器首地址
	add r1, r1, #0X2000			@ GIC基地址加0X2000，也就是GIC的CPU接口端基地址
	ldr r0, [r1, #0XC]			@ GIC的CPU接口端基地址加0X0C就是GICC_IAR寄存器，GICC_IAR寄存器保存这当前发生中断的中断号
	push {r0, r1}				 			@保存r0,r1 
	
	bl SystemIrqHandler			@ 运行C语言中断处理函数，带有一个参数，保存在R0寄存器中 

	pop {r0, r1}				
	str r0, [r1, #0X10]					@ 中断执行完成，通知cpu

	pop {r0}						
	msr spsr_cxsf, r0				  @ 恢复spsr, 清除中断

	pop {r0-r12, lr} 			@恢复r0-r2，lr寄存器 
	subs pc, lr, #4				 @将lr-4赋给pc 

 FIQ_Handler:
	ldr r0, =FIQ_Handler	
	bx r0	
 
 Undefined_Handler:
	ldr r0, =Undefined_Handler
	bx r0

SVC_Handler:
	ldr r0, =SVC_Handler
	bx r0

PrefAbort_Handler:
	ldr r0, =PrefAbort_Handler	
	bx r0

DataAbort_Handler:
	ldr r0, =DataAbort_Handler
	bx r0

NotUsed_Handler:
	ldr r0, =NotUsed_Handler
	bx r0

copy_data:
	ldr r1, =data_load_addr  @ data段的加载地址
	ldr r2, =data_start  @data段重定位地址
	ldr r3, =data_end  @data段结束地址

	loop:
	ldrb r4, [r1] @从r1读到r4 
	strb r4, [r2] @r4存放到r2 
	add r1, r1, #1@复制下1个字节
	add r2, r2, #1 
	cmp r2, r3 @ r2 、r3比较 
	bne loop  @ 如果没拷贝完则重复拷贝 

	mov pc, lr

clean_bss:
	ldr r1, =__bss_start  @将链接脚本变量__bss_start变量保存于r1
    ldr r2, =__bss_end  @将链接脚本变量__bss_end变量保存于r2
	mov r3, #0

clean:
	strb r3, [r1]  @将当前地址下的数据清零
	add r1, r1, #1  @将r1内存储的地址+4
	cmp r1, r2  @相等：清零操作结束；否则继续执行clean函数清零bss段
	bne clean

	mov pc, lr
```

> ### 1. `mrc p15, 4, r1, c15, c0, 0` 的作用
>
> armasm
>
> ```
> mrc p15, 4, r1, c15, c0, 0   @ 关键指令
> ```
>
> - **功能**：从CP15协处理器的寄存器中读取GIC的**分发器(Distributor)基地址**。
> - **寄存器说明**：
>     - `p15`：协处理器编号
>     - `opc1=4`：操作码1
>     - `CRn=c15, CRm=c0`：指定协处理器寄存器
>     - `opc2=0`：操作码2
> - **返回值**：ARM内核通过此操作将**GIC分发器的物理基地址**存入`r1`寄存器。这是由硬件确定的固定地址。
>
> ### 2. `add r1, r1, #0X2000` 的作用
>
> armasm
>
> ```
> add r1, r1, #0X2000  @ 地址转换
> ```
>
> - **功能**：将分发器基地址偏移`0x2000`，得到**CPU接口(CPU Interface)的基地址**。
> - **GIC架构划分**：
>     - `GIC Distributor` (基地址 + `0x0000`)：全局中断管理（优先级/路由等）
>     - `GIC CPU Interface` (基地址 + `0x2000`)：CPU核心相关的中断控制（应答/完成等）
> - **为何偏移0x2000**：这是ARM GICv2架构的标准偏移量，代表从分发器到CPU接口的固定地址距离。
>
> ------
>
> ### 地址使用详解
>
> armasm
>
> ```
> ldr r0, [r1, #0XC]    @ r1 + 0x0C → GICC_IAR
> str r0, [r1, #0X10]   @ r1 + 0x10 → GICC_EOIR
> ```
>
> - **GICC_IAR (0x0C)**：中断应答寄存器
>     - 读取后返回当前中断号（如0x42代表SPI#34）
>     - 自动标记该中断为"处理中"
> - **GICC_EOIR (0x10)**：中断结束寄存器
>     - 写入相同中断号通知GIC中断处理完成
>     - 清除"处理中"状态，允许新中断
>
> ------
>
> ### 完整流程总结
>
> 1. **保存现场**：压栈寄存器及`spsr`
> 2. **获取GIC地址**：
>     - 读CP15 → **GIC Distributor基地址** (e.g., `0xA0020000`)
>     - 加`0x2000` → **CPU Interface基地址** (e.g., `0xA0022000`)
> 3. **处理中断**：
>     - 读`GICC_IAR`获取中断号 → `r0`
>     - 调用C函数`SystemIrqHandler(r0)`
>     - 写`GICC_EOIR`通知完成
> 4. **恢复现场**：弹栈并返回`lr-4`（ARM流水线修正）
>
> > - 取指令（pc）
> > - 译指令
> > - 执行指令
> >
> > ```
> > lr = pc = 当前执行指令+8
> > 当前执行指令的下一条：lr-4
> > ```
> >
>
> > **关键点**：CP15返回的是GIC Distributor的硬件固定地址，通过`+0x2000`偏移转换到CPU Interface地址空间，这是GICv2标准设计。所有后续操作（中断号获取/完成通知）都基于CPU Interface地址进行。

## 初始化中断

```c
/*中断初始化*/
void irq_init()
{
    GIC_Init();
   
    for(int i = 0; i < NUMBER_OF_INT_VECTORS; i++)
	{
		system_register_irqhandler((IRQn_Type)i, NULL, NULL);
	}
	// 设置终端向量表的位置
     __set_VBAR((uint32_t)0x80002000);
}
```

初始化的函数在库函数里面

```c
/* For simplicity, we only use group0 of GIC */
FORCEDINLINE __STATIC_INLINE void GIC_Init(void)
{
  uint32_t i;
  uint32_t irqRegs;
  /*获取GIC地址*/
  GIC_Type *gic = (GIC_Type *)(__get_CBAR() & 0xFFFF0000UL);
  /*支持共享中断数量*/
  irqRegs = (gic->D_TYPER & 0x1FUL) + 1;

  /* On POR, all SPI is in group 0, level-sensitive and using 1-N model */

  /* Disable all PPI, SGI and SPI */
  for (i = 0; i < irqRegs; i++)
    gic->D_ICENABLER[i] = 0xFFFFFFFFUL;

  /* Make all interrupts have higher priority */
  /*设置中断优先级数为32*/
  gic->C_PMR = (0xFFUL << (8 - __GIC_PRIO_BITS)) & 0xFFUL;

  /* No subpriority, all priority level allows preemption */
  /*设置5级抢占优先级，3级子优先级*/
  gic->C_BPR = 7 - __GIC_PRIO_BITS;

  /* Enable group0 distribution */
  /*使能第0组中断*/
  gic->D_CTLR = 1UL;

  /* Enable group0 signaling */
  gic->C_CTLR = 1UL;
}
```

> #### GIC相关寄存器
>
> - 分发器
>
>     - 中断数量：GICD_TYPER
>     - 中断清除： GICD_ ICENABLERn
>     - 中断使能：GICD_ISACTIVERn
>     - 中断优先级设置：GICD_IPRIORITYR
>
>     详见GIC官方手册
>
>     **4.3 Distributor register descriptions**  
>
> - cpu接口单元
>
>     - 中断优先级数量：GICC_PMR
>     - 抢占优先级和子优先级设置： GICC_BPR
>     - 保存中断ID：GICC_IAR 
>     - 通知cpu中断完成：GICC_EOIR
>
>     详见GIC官方手册
>
>     **4.4 CPU interface register descriptions**  
>
> #### GPIO中断相关寄存器
>
> - gpio中断触发类型:高/低电平、上升/下降沿
>
>     - GPIO5_ICR1(0~15)
>
>     - GPIO5_ICR2(16~31)
>
> - gpio中断屏蔽
>
>     - GPIO5_IMR
>
> - gpio中断状态寄存器
>
>     - GPIO5_ISR
>
> - gpio双边缘触发
>
>     - GPIO5_EDGE_SEL
>
>     详见芯片数据手册
>
>     **28.5 GPIO Memory Map/Register Definition** 

```c
FORCEDINLINE __STATIC_INLINE uint32_t __get_CBAR(void)
{
  return __MRC(15, 4, 15, 0, 0);
}


#define __STRINGIFY(x) #x
/* C语言实现写cp15协处理器 */
#define __MCR(coproc, opcode_1, src, CRn, CRm, opcode_2)                          \
    __ASM volatile ("MCR " __STRINGIFY(p##coproc) ", " __STRINGIFY(opcode_1) ", " \
                    "%0, " __STRINGIFY(c##CRn) ", " __STRINGIFY(c##CRm) ", "      \
                    __STRINGIFY(opcode_2)                                         \
                    : : "r" (src) )

/* C语言实现读cp15协处理器 */                    
#define __MRC(coproc, opcode_1, CRn, CRm, opcode_2)                               \
  ({                                                                              \
    uint32_t __dst;                                                               \
    __ASM volatile ("MRC " __STRINGIFY(p##coproc) ", " __STRINGIFY(opcode_1) ", " \
                    "%0, " __STRINGIFY(c##CRn) ", " __STRINGIFY(c##CRm) ", "      \
                    __STRINGIFY(opcode_2)                                         \
                    : "=r" (__dst) );                                             \
    __dst;                                                                        \
  })
```

> C语言读写cp15协处理器
>
> `__ASM ( code     : 输出操作数列表    : 输入操作数列表  );`
>
> - code
>
>     - 具体操作指令(字符串表示)
>
>     - #是把宏参数变为一个字符串
>
>     - ##是把两个参数连接在一起
>
>     __STRINGIFY(p##coproc) ", ->"p15"
>
> - 操作数
>
>     通过%加数字引用，比如%0 引用第一个操作数，%1 引用第二个操作数
>
>     r：将变量放入通用寄存器, 实际是把返回值放入__dst这个参数里面
>
> 处理以后得是``

## 位置无关码和重定位

位置无关的代码可以在任意的合法内存里面运行, 位置相关的代码是需要放到对应的位置里面

一般访问的.bss, .data, .rodata段里面的数据是位置无关的, 还有一部分特殊的.text代码, 比如进行绝对地址的跳转
