# DTS设备树

由于platform的driver文件过多

- DTS(device tree source)：设备树源文件，ASCII 格式
- DTC(device tree compiler)：设备树编译工具

- DTB(device tree blob)：二进制设备树, Lniux实际可以使用的文件

> 在没有使用设备树之前, 在 Linux 内核源码中大量的 arch/arm/mach-xxx和 arch/arm/plat-xxx文件夹，这些文件夹里面的文件就是对应平台下的板级信息, 各种配置信息记录在C文件里面

![image-20250720103047027](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507201030111.png)

## 设备树使用

uboot负责加载到内存固定位置，内核解析使用

### 设备树源文件

`ebf-buster-linux/arch/arm/boot/dts/imx6ull-seeed-npi.dts`

### 二进制设备树

pc：`ebf-buster-linux/arch/arm/boot/dts/imx6ull-seeed-npi.dtb`编译的结果一般在同一个目录下面

开发板：`/boot/dtbs/4.19.71-imx-r1/imx6ull-seeed-npi.dtb`, 启动的时候自动加载, 需要在这个文件夹下面进行替换

| 特性维度           | `/boot/dtbs/4.19.71-imx-r1/`       | `/usr/lib/linux-image-4.19.71-imx-r1/`           |
| :----------------- | :--------------------------------- | :----------------------------------------------- |
| **主要用途**       | Bootloader**实际使用**的设备树文件 | 软件包管理系统（如dpkg）**存放**的设备树文件     |
| **启动阶段**       | 系统启动初期由Bootloader读取       | 通常不直接参与启动，作为系统文件的一部分         |
| **更新影响**       | 直接影响下次启动的硬件配置         | 主要用于软件包管理，**替换系统镜像时可能被使用** |
| **文件性质**       | 通常是**活动**的设备树文件         | 可能是软件包安装的副本                           |
| **修改建议**       | ✅ **推荐手动更新此目录下的文件**   | 通常由系统包管理器维护，**不建议手动修改**       |
| **在系统中的作用** | 关键的启动配置文件                 | 系统文件的组成部分                               |

### 设备树编译

内核编译, 在内核的根目录下面执行这个命令

```makefile
//进行内核配置需要在内核的根目录下面进行, 生成一个.config文件
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- npi_v7_defconfig

//编译dts
make ARCH=arm -j4 CROSS_COMPILE=arm-linux-gnueabihf- dtbs
```

手工编译

```bash
./scripts/dtc/dtc -I dts -O dtb -o xxx.dtb arch/arm/boot/dts/xxx.dts // 编译 dts 为 dtb
./scripts/dtc/dtc -I dtb -O dts -o xxx.dts arch/arm/boot/dts/xxx.dtb // 反编译 dtb 为 dts
```

- -I：指定输入格式
- -O：指定输出格式
- -o：指定输出文件

## 设备树框架

- 从上到下
    - 头文件
    - 主体
    - 子节点追加内容

- 从外到内
    - 属性
    - 其他子节点
        - 属性
        - 其他子节点
        - ...

### linux系统中查看设备树

```
ls /sys/firmware/devicetree/base
```

或者

```
ls /proc/device-tree
```

- 以目录的形式体现设备树结构

### 添加子节点

```json
test_led{
	#address-cells = <1>;
	#size-cells = <1>;

	rgb_led_red@0x0209C000{
			compatible = "fire,rgb_led_red";
			reg = <0x0209C000 0x00000020>;
			status = "okay";
	};
};
```

可以直接使用文件替换重启的方式进行更新, 更新文件以后`sync`命令写入磁盘同步一下

## 属性读取API

![image-20250720154031156](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507201540217.png)

- 查属性所在的节点
- 查节点的属性值

> 有compatible属性的节点才会被转换, 可以使用的API函数记录在文件`include/linux/of.h`里面

### 节点

/include/linux/of.h

```c
struct device_node {
    const char *name;  //节点名
    const char *type;  //设备类型, 使用的比较少
    phandle phandle;
    const char *full_name; //完整名字
    struct fwnode_handle fwnode;
   
    struct  property *properties; //属性
    struct  property *deadprops; 
    struct  device_node *parent; //父节点
    struct  device_node *child;  //子节点
    struct  device_node *sibling;
#if defined(CONFIG_OF_KOBJ)
    struct  kobject kobj;
#endif
    unsigned long _flags;
    void    *data;
#if defined(CONFIG_SPARC)
    const char *path_component_name;
    unsigned int unique_id;
    struct of_irq_controller *irq_trans;
#endif
};
```

#### 查节点

- 路径/类型/名字/compatible

 incldue/linux/of.h

##### 路径

根据路径找到节点

```c
struct device_node *of_find_node_by_path(struct device_node *from,const char *path);
```

参数：

- from：开始查找的节点，NULL表示从根节点开始查找
- path：查找的节点名

返回值：

成功：device_node表示的节点

失败：NULL

##### 名字

根据"name"属性来查找节点

```c
struct device_node *of_find_node_by_name(struct device_node *from,const char *name);
```

from是起始的位置, NULL的时候设置的是根节点

##### 类型

```c
struct device_node *of_find_node_by_type(struct device_node *from, const char *type)
```

查找的节点对应的 type字符串，也就是 device_type属性值

##### 类型和compatible属性

```c
struct device_node *of_find_compatible_node(struct device_node *from,const char *type, const char *compat);
```

参数：

- from：开始查找的节点，NULL表示从根节点开始查找
- type：指定 device_type 属性值可以为NULL，表示忽略掉device_type属性
- compat：指定 compatible 属性值

返回值：

成功：device_node表示的节点

失败：NULL

##### compatible属性列表

```c
struct device_node *of_find_matching_node_and_match(struct device_node *from,
					const struct of_device_id *matches,
					const struct of_device_id **match)
```

+ **from**：开始查找的节点，如果为 NULL表示从根节点开始查找整个设备树。
+ **matches**：of_device_id匹配表，也就是在此匹配表里面查找节点。
+ **match**：找到的匹配的 of_device_id。

使用的mactches示例如下

```c
static const struct of_device_id versatile_reboot_of_match[] = {
	{
		.compatible = "arm,core-module-integrator",
		.data = (void *)INTEGRATOR_REBOOT_CM
	},
	{
		.compatible = "arm,realview-eb-syscon",
		.data = (void *)REALVIEW_REBOOT_EB,
	},
	{
		.compatible = "arm,realview-pb1176-syscon",
		.data = (void *)REALVIEW_REBOOT_PB1176,
	},
	{
		.compatible = "arm,realview-pb11mp-syscon",
		.data = (void *)REALVIEW_REBOOT_PB11MP,
	},
	{
		.compatible = "arm,realview-pba8-syscon",
		.data = (void *)REALVIEW_REBOOT_PBA8,
	},
	{
		.compatible = "arm,realview-pbx-syscon",
		.data = (void *)REALVIEW_REBOOT_PBX,
	},
	{},
};
```

可以使用里面的data判断实际获取的是哪个设备

#### 父子节点

##### 父节点

```c
struct device_node *of_get_parent(const struct device_node *node)
```

##### 子节点

```c
struct device_node *of_get_next_child(const struct device_node *node,struct device_node *prev)
```

函数用迭代的方式查找子节点, prev是前一个子节点，也就是从哪一个子节点开始迭代的查找下一个子节点。可以设置为NULL，表示从第一个子节点开始

### 属性

 incldue/linux/of.h

```c
struct property {
    char    *name;  	//属性名
    int     length;     //属性长度
    void    *value; 	//属性值
    struct property *next; //下一个属性
#if defined(CONFIG_OF_DYNAMIC) || defined(CONFIG_SPARC)
    unsigned long _flags;
#endif
#if defined(CONFIG_OF_PROMTREE)
    unsigned int unique_id;
#endif
#if defined(CONFIG_OF_KOBJ)
    struct bin_attribute attr;
#endif
};
```

#### 名字查找

- 节点+属性名

查找节点中的属性, 通过名字以及名字的长度

```c
struct property *of_find_property(const struct device_node *np,const char *name,int *lenp);
```

参数：

- np：device_node表示的节点
- name：查找的属性名字
- lenp：属性值的字节数, 返回参数

返回值：

成功：property表示的属性

失败：NULL

+ 案例：

```c
test_property {
	test_name = “hello”;
};
```

name：“hello”

lenp = 6

#### 整形

读取一个32位无符号整数

```c
static inline int of_property_read_u32(const struct device_node *np,const char *propname, u32 *out_value);
```

参数：

- np：device_node表示的节点
- propname：查找的属性名字
- out_value：属性值的整数值

返回值：

成功：0

失败：负值

```c
int of_property_read_u8(const struct device_node *np,
const char *propname,u8 *out_value)
int of_property_read_u16(const struct device_node *np,
const char *propname,u16 *out_value)
int of_property_read_u64(const struct device_node *np,
const char *propname,u64 *out_value)
```

#### 数组

读取32位无符号整数数组

```c
int of_property_read_u32_array(const struct device_node *np,const char *propname,u32 *out_values,size_t sz)
```

- np：device_node表示的节点
- name：查找的属性名字
- out_value：读取到的数组值
- sz：要读取的数组元素数量

类似的函数有

```c
int of_property_read_u8_array(const struct device_node *np, const char *propname,u8 *out_values, size_t sz)
int of_property_read_u16_array(const struct device_node *np, const char *propname, u16 *out_values, size_t sz)
int of_property_read_u64_array(const struct device_node *np, const char *propname, u64 *out_values, size_t sz)
```

#### 字符串

读字符串

```c
int of_property_read_string(struct device_node *np,const char *propname,const char **out_string)
```

参数：

- np：device_node表示的节点
- proname：查找的属性名字
- out_string：读取到的字符串值

返回值：

成功：0

失败：负值

#### 数组长度

```c
int of_property_count_elems_of_size(const struct device_node *np,
const char *propname, int elem_size)
```

获取属性中元素的数量，比如 reg 属性值是一个数组，那么使用此函数可以获取到这个数组的大小

#### 数组中一个

```c
int of_property_read_u32_index(const struct device_node *np,const char *propname, u32 index,u32 *out_value)
```

#### #address-cell和#size-cells

```c
int of_n_addr_cells(struct device_node *np)
int of_n_size_cells(struct device_node *np)
```

### 其他常用

#### 比较compatible

```c
int of_device_is_compatible(const struct device_node *device, const char *compat)
```

查看节点的 compatible 属性是否有包含 compat 指定的字符串，也就是检查设备节点的兼容性

#### 地址相关属性

```c
const __be32 *of_get_address(struct device_node *dev,
int index, u64 *size, unsigned int *flags)
```

获取地址相关属性

+ **dev**：设备节点。
+ **index**：要读取的地址标号。
+ **size**：地址长度。
+ **flags**：参数，比如 IORESOURCE_IO、IORESOURCE_MEM等

#### 地址资源获取

Linux里面使用的resource描述地址, 记录在reg里面

```c
/*
 * Resources are tree-like, allowing
 * nesting etc..
 */
struct resource {
	resource_size_t start;
	resource_size_t end;
	const char *name;
	unsigned long flags; // 资源的描述
	struct resource *parent, *sibling, *child;
};
```

常见的资源标志就是 IORESOURCE_MEM、IORESOURCE_REG和IORESOURCE_IRQ等

```c
int of_address_to_resource(struct device_node *dev, int index, struct resource *r)
```

可以直接使用函数进行地址的映射

```c
#include <linux/io.h>

void __iomem *devm_ioremap_resource(struct device *dev,  const struct resource *res);
```

#### reg属性内存映射

将reg属性值的物理地址转化为虚拟地址

```c
void __iomem *of_iomap(struct device_node *np,
int index)
```

参数：

- np：device_node表示的节点
- index：通常情况下reg属性包含多段，index 用于指定映射那一段，标号从0开始。

## 节点使用示例

```c
test_led{
	#address-cells = <1>;
	#size-cells = <1>;

	rgb_led_red@0x0209C000{
			compatible = "fire,rgb_led_red";
			reg = <0x0209C000 0x00000020>;
			status = "okay";
	};
};
```

```c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>

#include <linux/types.h>
#include <linux/kernel.h>
#include <linux/delay.h>
#include <linux/ide.h>
#include <linux/errno.h>
#include <linux/gpio.h>
#include <asm/mach/map.h>
#include <asm/io.h>

#include <linux/of.h>
#include <linux/of_address.h>


#define DEV_NAME            "get_dts_info"
#define DEV_CNT                 (1)
//定义字符设备的设备号
static dev_t led_devno;
//定义字符设备结构体chr_dev
static struct cdev led_chr_dev;
//创建类
struct class *led_chrdev_class;


struct device_node	*led_device_node; //led的设备树节点
struct device_node  *rgb_led_red_device_node; //rgb_led_red 红灯节点
struct property     *rgb_led_red_property;    //定义属性结构体指针
int size = 0 ;
unsigned int out_values[18];  //保存读取得到的REG 属性值

/*.open 函数*/
static int led_chr_dev_open(struct inode *inode, struct file *filp)
{
    int error_status = -1;

    printk("\n open form device \n");

    /*获取DTS属性信息*/
    led_device_node = of_find_node_by_path("/test_led");
    if(led_device_node == NULL)
    {
        printk(KERN_ALERT "\n get led_device_node failed ! \n");
        return -1;
    }
    /*根据 led_device_node 设备节点结构体输出节点的基本信息*/
    printk(KERN_ALERT "name: %s",led_device_node->name); //输出节点名
    printk(KERN_ALERT "child name: %s",led_device_node->child->name);  //输出子节点的节点名


    /*获取 rgb_led_red_device_node 的子节点*/ 
    rgb_led_red_device_node = of_get_next_child(led_device_node,NULL); 
    if(rgb_led_red_device_node == NULL)
    {
        printk(KERN_ALERT "\n get rgb_led_red_device_node failed ! \n");
        return -1;
    }
    printk(KERN_ALERT "name: %s",rgb_led_red_device_node->name); //输出节点名
    printk(KERN_ALERT "parent name: %s",rgb_led_red_device_node->parent->name);  //输出父节点的节点名


    /*获取 rgb_led_red_device_node 节点  的"compatible" 属性 */ 
    rgb_led_red_property = of_find_property(rgb_led_red_device_node,"compatible",&size);
    if(rgb_led_red_property == NULL)
    {
        printk(KERN_ALERT "\n get rgb_led_red_property failed ! \n");
        return -1;
    }
    printk(KERN_ALERT "size = : %d",size);                      //实际读取得到的长度
    printk(KERN_ALERT "name: %s",rgb_led_red_property->name);   //输出属性名
    printk(KERN_ALERT "length: %d",rgb_led_red_property->length);        //输出属性长度
    printk(KERN_ALERT "value : %s",(char*)rgb_led_red_property->value);  //属性值


    /*获取 reg 地址属性*/
    error_status = of_property_read_u32_array(rgb_led_red_device_node,"reg",out_values, 2);
    if(error_status != 0)
    {
        printk(KERN_ALERT "\n get out_values failed ! \n");
        return -1;
    }
    printk(KERN_ALERT"0x%08X ", out_values[0]);
    printk(KERN_ALERT"0x%08X ", out_values[1]);

    return 0;
}

/*.release 函数*/
static int led_chr_dev_release(struct inode *inode, struct file *filp)
{
    printk("\nrelease\n");
    return 0;
}


/*字符设备操作函数集*/
static struct file_operations  led_chr_dev_fops = 
{
    .owner = THIS_MODULE,
    .open = led_chr_dev_open,
    .release = led_chr_dev_release,
};

/*
*驱动初始化函数
*/
static int __init led_chrdev_init(void)
{
    int ret = 0;
    printk("led chrdev init\n");
    //第一步
    //采用动态分配的方式，获取设备编号，次设备号为0，
    //设备名称为EmbedCharDev，可通过命令cat  /proc/devices查看
    //DEV_CNT为1，当前只申请一个设备编号
    ret = alloc_chrdev_region(&led_devno, 0, DEV_CNT, DEV_NAME);
    if(ret < 0){
        printk("fail to alloc led_devno\n");
        goto alloc_err;
    }

    led_chrdev_class = class_create(THIS_MODULE, "led_chrdev");
    //第二步
    //关联字符设备结构体cdev与文件操作结构体file_operations
    cdev_init(&led_chr_dev, &led_chr_dev_fops);
    //第三步
    //添加设备至cdev_map散列表中
    ret = cdev_add(&led_chr_dev, led_devno, DEV_CNT);
    if(ret < 0)
    {
        printk("fail to add cdev\n");
        goto add_err;
    }

    //创建设备
    device_create(led_chrdev_class, NULL, led_devno, NULL,
			      DEV_NAME);
    return 0;

add_err:
    //添加设备失败时，需要注销设备号
    unregister_chrdev_region(led_devno, DEV_CNT);
alloc_err:
    return ret;
}

/*
*驱动注销函数
*/

static void __exit led_chrdev_exit(void)
{
    printk("chrdev exit\n");
   
    device_destroy(led_chrdev_class, led_devno);   //清除设备
    cdev_del(&led_chr_dev);                        //清除设备号
    unregister_chrdev_region(led_devno, DEV_CNT);  //取消注册字符设备
    class_destroy(led_chrdev_class);               //清除类
}


module_init(led_chrdev_init);
module_exit(led_chrdev_exit);

MODULE_LICENSE("GPL");
```

## 设备树驱动GPIO示例

![image-20250720171557489](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507201715587.png)

> 信息记录在platform_device继承的device结构体里面

#### 设备树添加节点信息

- RGB灯的相关寄存器

```json
/*
*CCM_CCGR1                         0x020C406C
*IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO04  0x020E006C
*IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO04  0x020E02F8
*GPIO1_GD                          0x0209C000
*GPIO1_GDIR                        0x0209C004
*/


/*
*CCM_CCGR3                         0x020C4074
*IOMUXC_SW_MUX_CTL_PAD_CSI_HSYNC   0x020E01E0
*IOMUXC_SW_PAD_CTL_PAD_CSI_HSYNC   0x020E046C
*GPIO4_GD                          0x020A8000
*GPIO4_GDIR                        0x020A8004
*/


/*
*CCM_CCGR3                         0x020C4074
*IOMUXC_SW_MUX_CTL_PAD_CSI_VSYNC   0x020E01DC
*IOMUXC_SW_PAD_CTL_PAD_CSI_VSYNC   0x020E0468
*GPIO4_GD                          0x020A8000
*GPIO4_GDIR                        0x020A8004
*/
	/*添加led节点*/
	rgb_led{
		#address-cells = <1>;
		#size-cells = <1>;
		compatible = "fire,rgb_led";

		/*红灯节点*/
		ranges;
		rgb_led_red@0x020C406C{
			reg = <0x020C406C 0x00000004
			       0x020E006C 0x00000004
			       0x020E02F8 0x00000004
				   0x0209C000 0x00000004
			       0x0209C004 0x00000004>;
			status = "okay";
		};

		/*绿灯节点*/
		rgb_led_green@0x020C4074{
			reg = <0x020C4074 0x00000004
			       0x020E01E0 0x00000004
			       0x020E046C 0x00000004
				   0x020A8000 0x00000004
			       0x020A8004 0x00000004>;
			status = "okay";
		};

		/*蓝灯节点*/
		rgb_led_blue@0x020C4074{
			reg = <0x020C4074 0x00000004
			       0x020E01DC 0x00000004
			       0x020E0468 0x00000004
				   0x020A8000 0x00000004
			       0x020A8004 0x00000004>;
			status = "okay";
		};
	};
```



### 代码使用

```c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/string.h>
#include <linux/types.h>
#include <linux/kernel.h>
#include <linux/delay.h>
#include <linux/ide.h>
#include <linux/errno.h>
#include <linux/gpio.h>
#include <asm/mach/map.h>
#include <linux/of.h>
#include <linux/of_address.h>
#include <linux/of_gpio.h>
#include <asm/io.h>
#include <linux/device.h>

#include <linux/platform_device.h>

/*------------------字符设备内容----------------------*/
#define DEV_NAME "rgb_led"
#define DEV_CNT (1)

/*定义 led 资源结构体，保存获取得到的节点信息以及转换后的虚拟寄存器地址*/
struct led_resource
{
	struct device_node *device_node; //rgb_led_red的设备树节点
	void __iomem *virtual_CCM_CCGR;
	void __iomem *virtual_IOMUXC_SW_MUX_CTL_PAD;
	void __iomem *virtual_IOMUXC_SW_PAD_CTL_PAD;
	void __iomem *virtual_DR;
	void __iomem *virtual_GDIR;
};

static dev_t led_devno;					 //定义字符设备的设备号
static struct cdev led_chr_dev;			 //定义字符设备结构体chr_dev
struct class *class_led;				 //保存创建的类
struct device *device;					 // 保存创建的设备
struct device_node *rgb_led_device_node; //rgb_led的设备树节点结构体

/*定义 R G B 三个灯的led_resource 结构体，保存获取得到的节点信息*/
struct led_resource led_red;
struct led_resource led_green;
struct led_resource led_blue;

/*字符设备操作函数集，open函数*/
static int led_chr_dev_open(struct inode *inode, struct file *filp)
{
	printk("\n open form driver \n");
	return 0;
}

/*字符设备操作函数集，write函数*/
static ssize_t led_chr_dev_write(struct file *filp, const char __user *buf, size_t cnt, loff_t *offt)
{

	int ret,error;
	unsigned int register_data = 0; //暂存读取得到的寄存器数据
	unsigned char receive_data[10]; //用于保存接收到的数据
	unsigned int write_data; //用于保存接收到的数据

	if(cnt>10)
			cnt =10;

	error = copy_from_user(receive_data, buf, cnt);
	if (error < 0)
	{
		return -1;
	}

	ret = kstrtoint(receive_data, 16, &write_data);
	if (ret) {
		return -1;
        }

	/*设置 GPIO1_04 输出电平*/
	if (write_data & 0x04)
	{
		register_data = ioread32(led_red.virtual_DR);
		register_data &= ~(0x01 << 4);
		iowrite32(register_data, led_red.virtual_DR); // GPIO1_04引脚输出低电平，红灯亮
	}
	else
	{
		register_data = ioread32(led_red.virtual_DR);
		register_data |= (0x01 << 4);
		iowrite32(register_data, led_red.virtual_DR); // GPIO1_04引脚输出高电平，红灯灭
	}

	/*设置 GPIO4_20 输出电平*/
	if (write_data & 0x02)
	{
		register_data = ioread32(led_green.virtual_DR);
		register_data &= ~(0x01 << 20);
		iowrite32(register_data, led_green.virtual_DR); // GPIO4_20引脚输出低电平，绿灯亮
	}
	else
	{
		register_data = ioread32(led_green.virtual_DR);
		register_data |= (0x01 << 20);
		iowrite32(register_data, led_green.virtual_DR); // GPIO4_20引脚输出高电平，绿灯灭
	}

	/*设置 GPIO4_19 输出电平*/
	if (write_data & 0x01)
	{
		register_data = ioread32(led_blue.virtual_DR);
		register_data &= ~(0x01 << 19);
		iowrite32(register_data, led_blue.virtual_DR); //GPIO4_19引脚输出低电平，蓝灯亮
	}
	else
	{
		register_data = ioread32(led_blue.virtual_DR);
		register_data |= (0x01 << 19);
		iowrite32(register_data, led_blue.virtual_DR); //GPIO4_19引脚输出高电平，蓝灯灭
	}

	return cnt;
}

/*字符设备操作函数集*/
static struct file_operations led_chr_dev_fops =
	{
		.owner = THIS_MODULE,
		.open = led_chr_dev_open,
		.write = led_chr_dev_write,
};

/*----------------平台驱动函数集-----------------*/
static int led_probe(struct platform_device *pdv)
{

	int ret = -1; //保存错误状态码
	unsigned int register_data = 0;

	printk(KERN_ALERT "\t  match successed  \n");

	/*获取rgb_led的设备树节点*/
	rgb_led_device_node = of_find_node_by_path("/rgb_led");
	if (rgb_led_device_node == NULL)
	{
		printk(KERN_ERR "\t  get rgb_led failed!  \n");
		return -1;
	}

	/*获取rgb_led节点的红灯子节点*/
	led_red.device_node = of_find_node_by_name(rgb_led_device_node,"rgb_led_red");
	if (led_red.device_node == NULL)
	{
		printk(KERN_ERR "\n get rgb_led_red_device_node failed ! \n");
		return -1;
	}


	/*获取 reg 属性并转化为虚拟地址*/
	led_red.virtual_CCM_CCGR = of_iomap(led_red.device_node, 0);
	led_red.virtual_IOMUXC_SW_MUX_CTL_PAD = of_iomap(led_red.device_node, 1);
	led_red.virtual_IOMUXC_SW_PAD_CTL_PAD = of_iomap(led_red.device_node, 2);
	led_red.virtual_DR = of_iomap(led_red.device_node, 3);
	led_red.virtual_GDIR = of_iomap(led_red.device_node, 4);

	/*初始化红灯*/
	register_data = ioread32(led_red.virtual_CCM_CCGR);
	register_data |= (0x03 << 26);
	iowrite32(register_data, led_red.virtual_CCM_CCGR); //开启时钟

	register_data = ioread32(led_red.virtual_IOMUXC_SW_MUX_CTL_PAD);
	register_data &= ~(0xf << 0);
	register_data |= (0x05 << 0);
	iowrite32(register_data, led_red.virtual_IOMUXC_SW_MUX_CTL_PAD); //设置复用功能

	register_data = ioread32(led_red.virtual_IOMUXC_SW_PAD_CTL_PAD);
	register_data = (0x10B0);
	iowrite32(register_data, led_red.virtual_IOMUXC_SW_PAD_CTL_PAD); //设置PAD 属性

	register_data = ioread32(led_red.virtual_GDIR);
	register_data |= (0x01 << 4);
	iowrite32(register_data, led_red.virtual_GDIR); //设置GPIO1_04 为输出模式

	register_data = ioread32(led_red.virtual_DR);
	register_data |= (0x01 << 4);
	iowrite32(register_data, led_red.virtual_DR); //设置 GPIO1_04 默认输出高电平


	/*获取rgb_led节点的绿灯子节点*/
	led_green.device_node = of_find_node_by_name(rgb_led_device_node,"rgb_led_green");
	if (led_green.device_node == NULL)
	{
		printk(KERN_ERR "\n get rgb_led_green_device_node failed ! \n");
		return -1;
	}

	/*获取 reg 属性并转化为虚拟地址*/
	led_green.virtual_CCM_CCGR = of_iomap(led_green.device_node, 0);
	led_green.virtual_IOMUXC_SW_MUX_CTL_PAD = of_iomap(led_green.device_node, 1);
	led_green.virtual_IOMUXC_SW_PAD_CTL_PAD = of_iomap(led_green.device_node, 2);
	led_green.virtual_DR = of_iomap(led_green.device_node, 3);
	led_green.virtual_GDIR = of_iomap(led_green.device_node, 4);

	/*初始化绿灯*/
	register_data = ioread32(led_green.virtual_CCM_CCGR);
	register_data |= (0x03 << 12);
	iowrite32(register_data, led_green.virtual_CCM_CCGR); //开启时钟

	register_data = ioread32(led_green.virtual_IOMUXC_SW_MUX_CTL_PAD);
	register_data &= ~(0xf << 0);
	register_data |= (0x05 << 0);
	iowrite32(register_data, led_green.virtual_IOMUXC_SW_MUX_CTL_PAD); //设置复用功能

	register_data = ioread32(led_green.virtual_IOMUXC_SW_PAD_CTL_PAD);
	register_data = (0x10B0);
	iowrite32(register_data, led_green.virtual_IOMUXC_SW_PAD_CTL_PAD); //设置PAD 属性

	register_data = ioread32(led_green.virtual_GDIR);
	register_data |= (0x01 << 20);
	iowrite32(register_data, led_green.virtual_GDIR); //设置GPIO4_IO20 为输出模式

	register_data = ioread32(led_green.virtual_DR);
	register_data |= (0x01 << 20);
	iowrite32(register_data, led_green.virtual_DR); //设置 GPIO4_IO20 默认输出高电平


	/*获取rgb_led节点的蓝灯子节点*/
	led_blue.device_node = of_find_node_by_name(rgb_led_device_node,"rgb_led_blue");
	if (led_blue.device_node == NULL)
	{
		printk(KERN_ERR "\n get rgb_led_blue_device_node failed ! \n");
		return -1;
	}

	/*获取 reg 属性并转化为虚拟地址*/
	led_blue.virtual_CCM_CCGR = of_iomap(led_blue.device_node, 0);
	led_blue.virtual_IOMUXC_SW_MUX_CTL_PAD = of_iomap(led_blue.device_node, 1);
	led_blue.virtual_IOMUXC_SW_PAD_CTL_PAD = of_iomap(led_blue.device_node, 2);
	led_blue.virtual_DR = of_iomap(led_blue.device_node, 3);
	led_blue.virtual_GDIR = of_iomap(led_blue.device_node, 4);

	... // 寄存器设置



	/*---------------------注册 字符设备部分-----------------*/

	//第一步
	//采用动态分配的方式，获取设备编号，次设备号为0，
	//设备名称为rgb-leds，可通过命令cat  /proc/devices查看
	//DEV_CNT为1，当前只申请一个设备编号
	ret = alloc_chrdev_region(&led_devno, 0, DEV_CNT, DEV_NAME);
	if (ret < 0)
	{
		printk("fail to alloc led_devno\n");
		goto alloc_err;
	}
	//第二步
	//关联字符设备结构体cdev与文件操作结构体file_operations
	led_chr_dev.owner = THIS_MODULE;
	cdev_init(&led_chr_dev, &led_chr_dev_fops);
	//第三步
	//添加设备至cdev_map散列表中
	ret = cdev_add(&led_chr_dev, led_devno, DEV_CNT);
	if (ret < 0)
	{
		printk("fail to add cdev\n");
		goto add_err;
	}

	//第四步
	/*创建类 */
	class_led = class_create(THIS_MODULE, DEV_NAME);

	/*创建设备*/
	device = device_create(class_led, NULL, led_devno, NULL, DEV_NAME);

	return 0;

add_err:
	//添加设备失败时，需要注销设备号
	unregister_chrdev_region(led_devno, DEV_CNT);
	printk("\n error! \n");
alloc_err:

	return -1;
}

static const struct of_device_id rgb_led[] = {
	{.compatible = "fire,rgb_led"}, // 实际匹配
	{/* sentinel */}};

/*定义平台设备结构体*/
struct platform_driver led_platform_driver = {
	.probe = led_probe,
	.driver = {
		.name = "rgb-leds-platform",
		.owner = THIS_MODULE,
		.of_match_table = rgb_led,
	}};

/*
*驱动初始化函数
*/
static int __init led_platform_driver_init(void)
{
	int DriverState;
	DriverState = platform_driver_register(&led_platform_driver);
	printk(KERN_ALERT "\tDriverState is %d\n", DriverState);
	return 0;
}

/*
*驱动注销函数
*/
static void __exit led_platform_driver_exit(void)
{
	/*取消物理地址映射到虚拟地址*/
	iounmap(led_green.virtual_CCM_CCGR);
	iounmap(led_green.virtual_IOMUXC_SW_MUX_CTL_PAD);
	iounmap(led_green.virtual_IOMUXC_SW_PAD_CTL_PAD);
	iounmap(led_green.virtual_DR);
	iounmap(led_green.virtual_GDIR);

	iounmap(led_red.virtual_CCM_CCGR);
	iounmap(led_red.virtual_IOMUXC_SW_MUX_CTL_PAD);
	iounmap(led_red.virtual_IOMUXC_SW_PAD_CTL_PAD);
	iounmap(led_red.virtual_DR);
	iounmap(led_red.virtual_GDIR);

	iounmap(led_blue.virtual_CCM_CCGR);
	iounmap(led_blue.virtual_IOMUXC_SW_MUX_CTL_PAD);
	iounmap(led_blue.virtual_IOMUXC_SW_PAD_CTL_PAD);
	iounmap(led_blue.virtual_DR);
	iounmap(led_blue.virtual_GDIR);

	/*删除设备*/
	device_destroy(class_led, led_devno);		  //清除设备
	class_destroy(class_led);					  //清除类
	cdev_del(&led_chr_dev);						  //清除设备号
	unregister_chrdev_region(led_devno, DEV_CNT); //取消注册字符设备

	/*注销字符设备*/
	platform_driver_unregister(&led_platform_driver);

	printk(KERN_ALERT "led_platform_driver exit!\n");
}

module_init(led_platform_driver_init);
module_exit(led_platform_driver_exit);

MODULE_LICENSE("GPL");

/**/

```

## 原理拓展

### 设备树的匹配

在没有使用设备树以前，uboot会向Linux内核传递一个叫做machine id的值，machine id也就是设备 ID，告诉 Linux 内核自己是个什么设备，看看 Linux 内核是否支持, 每一个开发板对应的是一个.c文件

如在文件arch/arm/mach-imx/mach-mx35_3ds.c里面会设置`static const struct machine_desc __mach_desc_MX35_3DS`里面的`.nr = MACH_TYPE_MX35_3DS`, MACH_TYPE_MX35_3DS定义在文件include/generated/mach-types.h中

> 这个是使用宏定义MACHINE_START和 MACHINE_END 来声明一个开发板

在使用设备树以后, 对应的nr设置为~0说明引入设备树以后不会再根据 machine id来检查Linux内核是否支持某个设备了

> 使用DT_MACHINE_START。DT_MACHINE_START 来定义一个板子

文件arch/arm/mach-imx/mach-imx6ul.c

```c
static const char *imx6ul_dt_compat[] __initconst = {
	"fsl,imx6ul",
	"fsl,imx6ull",
	NULL,
};
```

这个就是匹配设备树的, imx6ull-alientek-emmc.dts中根节点的compatible属性值

```json
compatible = "fsl,imx6ull-14x14-evk", "fsl,imx6ull";
```

![image-20251108113527346](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/mac-picture/image-20251108113527346.png)

### 根节点下内容

+ cpus: 节点用于描述SOC内部的所有CPU
+ soc: 像 uart，iic控制器等等这些都属于 SOC内部外设，因此一般会创建一个叫做 soc的父节点来管理这些SOC内部外设的子节点
+ **ocram**: 记录内部RAM的地址信息
+ **aips1**、**aips2** 和 **aips3**: 分管不同的外设控制器

![image-20251108114018258](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/mac-picture/image-20251108114018258.png)

### Linux解析设备树

![image-20251108114152913](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/mac-picture/image-20251108114152913.png)

### 添加设备相关文档

在 Linux 内核源码中有详细的.txt 文档描述了如何添加节点，这些.txt 文档叫做绑定文档，路径为：Linux源码目录`/Documentation/devicetree/bindings`
