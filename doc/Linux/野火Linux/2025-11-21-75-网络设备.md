# 网络设备

嵌入式网络硬件分为两部分：MAC 和 PHY，大家都是通过看数据手册来判断一款SOC是否支持网络，如果一款芯片数据手册说自己支持网络，一般都是说的这款 SOC 内置 MAC，MAC 类似 I2C 控制器、SPI 控制器一样的外设。但是光有 MAC还不能直接驱动网络，还需要另外一个芯片：PHY，因此对于内置 MAC的 SOC，其外部必须搭配一个PHY芯片。但是有些 SOC内部没有 MAC，那也就没法搭配PHY芯片了

+   不支持的联网

我们一般说某个 SOC 不支持网络，说的就是它没有网络 MAC。那么这个芯片就不能上网了吗？显然不是的，既然没有内部 MAC，那么可以找个外置的 MAC芯片啊，不过一般这种外置的网络芯片都是 MAC+PHY 一体的。比如三星 linux 开发板里面用的最多的 DM9000，因为三星的芯片基本没有内部MAC(比如 S3C2440、S5PV210，4412等)，所以三星的开发板都是通过外置的DM9000来完成有线网络功能的，DM9000对 SOC提供了一个 SRAM接口，SOC会以 SRAM的方式操作DM9000

有些外置的网络芯片更强大，内部甚至集成了硬件 TCP/IP 协议栈，对外提供一个 SPI 接口，比如 W5500。优点就是让不支持网络的 SOC能够另辟蹊径，实现网络功能，但是缺点就是网络效率不高，因为一般芯片内置的 MAC会有网络加速引擎，比如网络专用DMA，网络处理效率会很高。而且此类芯片网速都不快

![image-20251121222544496](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/mac-picture/image-20251121222544496.png)

+   支持的联网

我们一般说某个 SOC支持网络，说的就是他内部集成网络MAC外设，此时我们还需要外接一个网络PHY芯片

一般常见的通用 SOC 都会集成网络 MAC 外设，比如 STM32F4/F7/H7 系列、NXP 的 I.MX系列，内部集成网络MAC的优点如下：

1.   内部MAC外设会有专用的加速模块，比如专用的DMA，加速网速数据的处理。
2.   网速快，可以支持 10/100/1000M网速。
3.   外接PHY可选择性多，成本低

内部的MAC外设会通过MII或者RMII接口来连接外部的 PHY芯片， MII/RMII接口用来传输网络数据。另外主控需要配置或读取 PHY芯片，也就是读写PHY的内部寄存器，所以还需要一个控制接口，叫做MIDO，MDIO很类似 IIC，也是两根线

![image-20251121222749054](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/mac-picture/image-20251121222749054.png)

## 通信协议

### **MII/RMII** 接口

#### MII

MII全称是Media Independent Interface，直译过来就是介质独立接口，它是 IEEE-802.3定义的以太网标准接口，MII接口用于以太网 MAC 连接 PHY 芯片

![image-20251121223102079](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/mac-picture/image-20251121223102079.png)

MII接口一共有 16根信号线，含义如下：

+   **TX_CLK**：发送时钟，如果网速为 100M的话时钟频率为 25MHz，10M网速的话时钟频率为 2.5MHz，此时钟由 PHY产生并发送给MAC。
+   **TX_EN**：发送使能信号。
+   **TX_ER**：发送错误信号，高电平有效，表示 TX_ER有效期内传输的数据无效。10Mpbs网速下TX_ER不起作用。
+   **TXD[3:0]**：发送数据信号线，一共 4根。
+   **RXD[3:0]**：接收数据信号线，一共 4根。
+   **RX_CLK**：接收时钟信号，如果网速为 100M的话时钟频率为25MHz，10M网速的话时钟频率为2.5MHz，RX_CLK也是由PHY产生的。
+   **RX_ER**：接收错误信号，高电平有效，表示RX_ER有效期内传输的数据无效。10Mpbs网速下RX_ER不起作用。
+   **RX_DV**：接收数据有效，作用类似TX_EN。
+   **CRS**：载波侦听信号。
+   **COL**：冲突检测信号。

MII 接口的缺点就是所需信号线太多

#### RMII 

全称是 Reduced Media Independent Interface，翻译过来就是精简的介质独立接口

![image-20251121223228703](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/mac-picture/image-20251121223228703.png)

+   **TX_EN**：发送使能信号。
+   **TXD[1:0]**：发送数据信号线，一共 2根。
+   **RXD[1:0]**：接收数据信号线，一共 2根。
+   **CRS_DV**：相当于 MII接口中的RX_DV和 CRS这两个信号的混合
+   **REF_CLK**：参考时钟，由外部时钟源提供， 频率为50MHz。这里与 MII不同，MII的接收和发送时钟是独立分开的，而且都是由PHY芯片提供的。

### **MDIO** 接口

MDIO全称是Management Data Input/Output，直译过来就是管理数据输入输出接口，是一个简单的两线串行接口，一根 MDIO数据线，一根MDC时钟线。驱动程序可以通过 MDIO和MDC 这两根线访问 PHY 芯片的任意一个寄存器。

MDIO 接口支持多达 32 个 PHY。同一时刻内只能对一个PHY进行操作，那么如何区分这 32个PHY芯片呢？和IIC一样，使用器件地址即可。同一 MDIO 接口下的所有 PHY 芯片，其器件地址不能冲突，必须保证唯一

### **RJ45** 接口

网络设备是通过网线连接起来的，插入网线的叫做RJ45座

RJ45 座要与 PHY 芯片连接在一起，但是中间需要一个网络变压器，网络变压器用于隔离以及滤波等，网络变压器也是一个芯片, 现在很多RJ45座子内部已经集成了网络变压器

RJ45 座子上一般有两个灯，一个黄色(橙色)，一个绿色，绿色亮的话表示网络连接正常黄色闪烁的话说明当前正在进行网络通信。这两个灯由 PHY 芯片控制，PHY 芯片会有两个引脚来连接 RJ45 座上的这两个灯。内部 MAC+外部 PHY+RJ45 座(内置网络变压器)就组成了一个完整的嵌入式网络接口硬件

![image-20251121223620264](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/mac-picture/image-20251121223620264.png)

## IMX6ULL ENet

I.MX6ULL有两个网络接口，也就是两个 10/100Mbit/S的MAC外设, 符合IEEE802.3-2002标准, 实际我们不需要关注太多

我们需要关注的是PHY芯片的连接部分

## PHY芯片

PHY是IEEE 802.3规定的一个标准模块，前面说了，SOC可以对PHY进行配置或者读取PHY相关状态，这个就需要 PHY内部寄存器去实现了。PHY芯片寄存器地址空间为 5位，地址 0~31共 32个寄存器，IEEE定义了0~15这 16个寄存器的功能，16~31这16个寄存器由厂商自行实现。也就是说不管你用的哪个厂家的 PHY 芯片，其中 0~15 这 16 个寄存器是一模一样的。仅靠这16个寄存器是完全可以驱动起 PHY芯片的，至少能保证基本的网络数据通信

着现在的 PHY 芯片性能越来越强大，32 个寄存器可能满足不了厂商的需求，因此很多厂商采用分页技术来扩展寄存器地址空间，以求定义更多的寄存器, 这个时候就需要 PHY厂商提供相应的驱动源码了，所以大家也会在 Linux内核里面看到很多具体的PHY芯片驱动源码。

![image-20251121225233117](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/mac-picture/image-20251121225233117.png)

### LAN8720

低功耗的 10/100M 单以太网 PHY 层芯片, 合 IEEE802.3-2005标准, 支持RMII

LAN8720A 可以通过自协商的方式选择与目的主机最佳的连接方式(速度和双工模式)

LAN8720A通过设置 RXER/PHYAD0引脚来设置其PHY地址，默认情况下为 0

![image-20251121225906463](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/mac-picture/image-20251121225906463.png)

## Linux网络驱动

### 数据结构

#### net_device

Linux内核使用 net_device结构体表示一个具体的网络设备，net_device是整个网络驱动的灵魂。网络驱动的核心就是初始化 net_device 结构体中的各个成员变量

需要关注的变量:

+   etdev_ops 是网络设备的操作集函数，包含了一系列的网络设备操作回调函数，类似字符设备中的file_operations，稍后会讲解 netdev_ops结构体。
+   ethtool_ops是网络管理工具相关函数集，用户空间网络管理工具会调用此结构体中的相关函数获取网卡状态或者配置网卡
+   header_ops是头部的相关操作函数集，比如创建、解析、缓冲等

#### 操作函数

```c
#define alloc_netdev(sizeof_priv, name, name_assign_type, setup) \
	alloc_netdev_mqs(sizeof_priv, name, name_assign_type, setup, 1, 1)

struct net_device * alloc_netdev_mqs ( int sizeof_priv,
                const char *name,
                void (*setup) (struct net_device *))
                unsigned int txqs,
                unsigned int rxqs);
```

+   **sizeof_priv**：私有数据块大小。
+   **name**：设备名字。
+   **setup**：回调函数，初始化设备的设备后调用此函数。
+   **txqs**：分配的发送队列数量。
+   **rxqs**：分配的接收队列数量。

Linux 内核内核支持的网络接口有很多，比如光纤分布式数据接口(FDDI)、以太网设备(Ethernet)、红外数据接口(InDA)、高性能并行接口(HPPI)、CAN 网络等。内核针对不同的网络设备在 alloc_netdev 的基础上提供了一层封装

针对以太网封装的 net_device申请函数是 alloc_etherdev

```c
#define alloc_etherdev(sizeof_priv) alloc_etherdev_mq(sizeof_priv, 1)
#define alloc_etherdev_mq(sizeof_priv, count) alloc_etherdev_mqs(sizeo
f_priv, count, count)
```

实际是对`alloc_netdev_mqs`的进一步封装设置网卡的名字为“eth%d”，这是格式化字符串，大家进入开发板的 linux系统以后看到的“eth0”、“eth1”这样的网卡名字就是从这里来的

这里设置了以太网的 setup 函数为 ether_setup，不同的网络设备其 setup函数不同, 这个函数里面实现了对于net_dev里面参数的设置

```c
void free_netdev(struct net_device *dev);
int register_netdev(struct net_device *dev);
void unregister_netdev(struct net_device *dev);
```

#### net_device_ops

网络设备的操作集。net_device_ops 结构体定义在 include/linux/netdevice.h 文件中, 需要网络驱动编写人员去实现

+   ndo_open函数，打开网络设备的时候此函数会执行，网络驱动程序需要实现此函数，非常重要！以NXP的 I.MX系列 SOC网络驱动为例，会在此函数中做如下工作：

1.   使能网络外设时钟。
2.   申请网络所使用的环形缓冲区。
3.   初始化MAC外设。
4.   绑定接口对应的 PHY。
5.   如果使用NAPI的话要使能NAPI模块，通过 napi_enable函数来使能。
6.   开启PHY。
7.   调用netif_tx_start_all_queues来使能传输队列，也可能调用netif_start_queue函数。

+   ndo_stop 函数，关闭网络设备的时候此函数会执行
+   ndo_start_xmit函数，当需要发送数据的时候此函数就会执行，此函数有一个参数为 sk_buff结构体指针，sk_buff结构体在Linux的网络驱动中非常重要，sk_buff保存了上层传递给网络驱动层的数据。也就是说，要发送出去的数据都存在了sk_buff中
+   ndo_select_queue函数，当设备支持多传输队列的时候选择使用哪个队列
+   ndo_tx_timeout函数，当发送超时的时候函数会执行，一般都是网络出问题了导致发送超时。一般可能会重启 MAC和PHY，重新开始数据发送等

#### **sk_buff** 结构体

网络是分层的，对于应用层而言不用关心具体的底层是如何工作的，只需要按照协议将要发送或接收的数据打包好即可。打包好以后都通过dev_queue_xmit函数将数据发送出去，接收数据的话使用netif_rx函数即可

+   tstamp表示数据包接收时或准备发送时的时间戳
+   sk表示当前 sk_buff所属的Socket
+   dev表示当前 sk_buff从哪个设备接收到或者发出的
+   cb为控制缓冲区，不管哪个层都可以自由使用此缓冲区，用于放置私有数据
+   destructor函数，当释放缓冲区的时候可以在此函数里面完成某些动作
+   len 为实际的数据长度，包括主缓冲区中数据长度和分片中的数据长度。data_len为数据长度，只计算分片中数据的长度
+   mac_len为连接层头部长度，也就是MAC头的长度
+   protocol协议
+   transport_header为传输层头部
+   network_header为网络层头部
+   mac_header为链接层头部
+   tail指向实际数据的尾部
+   end指向缓冲区的尾部
+   head 指向缓冲区的头部，data 指向实际数据的头部。data 和 tail 指向实际数据的头部和尾部，head和 end指向缓冲区的头部和尾部

![image-20251121233122232](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/mac-picture/image-20251121233122232.png)



##### dev_queue_xmit应用层发送

```c
static inline int dev_queue_xmit(struct sk_buff *skb)
```

**skb**：要发送的数据，这是一个sk_buff结构体指针，sk_buff是Linux网络驱动中一个非常重要的结构体，网络数据就是以 sk_buff 保存的，各个协议层在 sk_buff 中添加自己的协议头，最终由底层驱动将 sk_buff中的数据发送出去。网络数据的接收过程恰好相反，网络底层驱动将接收到的原始数据打包成 sk_buff，然后发送给上层协议，上层会取掉相应的头部，然后将最终的数据发送给用户。

最终是通过 net_device_ops 操作集里面的 ndo_start_xmit 函数来完成最终发送

![image-20251121232718400](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/mac-picture/image-20251121232718400.png)

##### netif_rx驱动层接收

```c
int netif_rx(struct sk_buff *skb);
```

##### 其他API

```c
// 申请
static inline struct sk_buff *alloc_skb(unsigned int size, gfp_t priority);
```

+ **size**：要分配的大小，也就是skb数据段大小。
+ **priority**：为GFP MASK宏，比如GFP_KERNEL、GFP_ATOMIC等。
+ 返回值：分配成功的话就返回申请到的 sk_buff首地址，失败的话就返回 NULL。

```c
static inline struct sk_buff *netdev_alloc_skb(struct net_device *dev,unsigned int length)
```

在网络设备驱动中常常使用 netdev_alloc_skb 来为某个设备申请一个用于接收的 skb_buff

```c
// 释放
void kfree_skb(struct sk_buff *skb)
```

+   缓冲区相关

```c
unsigned char *skb_put(struct sk_buff *skb, unsigned int len);
```

![image-20251122101050213](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/mac-picture/image-20251122101050213.png)

```c
unsigned char *skb_push(struct sk_buff *skb, unsigned int len)
```

![image-20251122101119154](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/mac-picture/image-20251122101119154.png)

```c
unsigned char *skb_pull(struct sk_buff *skb, unsigned int len)
```

![image-20251122101153939](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/mac-picture/image-20251122101153939.png)

```c
static inline void skb_reserve(struct sk_buff *skb, int len)
```

将skb_buff的data和tail同时后移 n个字节即可

### NAPI机制

收数据有两种方法：轮询或中断。Linux在这两个处理方式的基础上提出了另外一种网络数据接收的处理方法：NAPI(New API)，NAPI是一种高效的网络处理技术。NAPI的核心思想就是不全部采用中断来读取网络数据，而是采用中断来唤醒数据接收服务程序，在接收服务程序中采用 POLL的方法来轮询处理数据

#### API函数

```c
/*
初始化一个 napi_struct 实例
napi：要初始化的 NAPI实例
poll： NAPI所使用的轮询函数，非常重要，一般在此轮询函数中完成网络数据接收的工作
NAPI默认权重(weight)，一般为NAPI_POLL_WEIGHT
*/
void netif_napi_add(struct net_device *dev,
          struct napi_struct *napi,
          int (*poll)(struct napi_struct *, int),
          int weight);
void netif_napi_del(struct napi_struct *napi);
inline void napi_enable(struct napi_struct *n);
void napi_disable(struct napi_struct *n);
// 查看是不是可以调度
inline bool napi_schedule_prep(struct napi_struct *n);
// 完成一次调度
void __napi_schedule(struct napi_struct *n)
// 可以使用 napi_schedule 函数来一次完成 napi_schedule_prep 和__napi_schedule
```

#### 简单示例

```c
#include <linux/netdevice.h>
#include <linux/interrupt.h>

struct my_private {
    struct napi_struct napi;
    struct net_device *dev;
    void __iomem *mmio;
    // 其他驱动私有数据
};

/* NAPI 轮询函数 */
int my_poll(struct napi_struct *napi, int budget)
{
    struct my_private *priv = container_of(napi, struct my_private, napi);
    struct net_device *dev = priv->dev;
    int work_done = 0;
    
    /* 处理接收的数据包，最多处理 budget 个 */
    work_done = process_receive_packets(priv, budget);
    
    if (work_done < budget) {
        /* 所有数据包处理完毕，退出轮询模式 */
        napi_complete_done(napi, work_done);
        
        /* 重新启用接收中断 */
        enable_rx_interrupt(priv);
    }
    
    return work_done;
}

/* 中断处理函数 */
irqreturn_t my_interrupt(int irq, void *dev_id)
{
    struct net_device *dev = dev_id;
    struct my_private *priv = netdev_priv(dev);
    u32 status;
    
    status = readl(priv->mmio + INT_STATUS);
    
    /* 如果是接收中断且NAPI可调度 */
    if ((status & RX_INT) && napi_schedule_prep(&priv->napi)) {
        /* 禁用硬件中断 */
        writel(0, priv->mmio + INT_ENABLE);
        
        /* 调度NAPI轮询 */
        __napi_schedule(&priv->napi);
    }
    
    /* 清除中断标志 */
    writel(status, priv->mmio + INT_STATUS);
    
    return IRQ_HANDLED;
}

/* 设备初始化 */
int my_dev_init(struct net_device *dev)
{
    struct my_private *priv = netdev_priv(dev);
    
    /* 初始化NAPI结构 */
    netif_napi_add(dev, &priv->napi, my_poll, 64); // budget=64
    
    return 0;
}
```

## 设备树

XP的 I.MX系列SOC网络绑定文档为 Documentation/devicetree/bindings/net/fsl-fec.txt

```json
fec1: ethernet@02188000 {
    compatible = "fsl,imx6ul-fec", "fsl,imx6q-fec";
    reg = <0x02188000 0x4000>;
    interrupts = <GIC_SPI 118 IRQ_TYPE_LEVEL_HIGH>,
           <GIC_SPI 119 IRQ_TYPE_LEVEL_HIGH>;
    clocks = <&clks IMX6UL_CLK_ENET>,
       <&clks IMX6UL_CLK_ENET_AHB>,
       <&clks IMX6UL_CLK_ENET_PTP>,
       <&clks IMX6UL_CLK_ENET_REF>,
       <&clks IMX6UL_CLK_ENET_REF>;
    clock-names = "ipg", "ahb", "ptp",
            "enet_clk_ref", "enet_out";
    stop-mode = <&gpr 0x10 3>;
    fsl,num-tx-queues=<1>;
    fsl,num-rx-queues=<1>;
    fsl,magic-packet;
    fsl,wakeup_irq = <0>;
    status = "disabled";
};

&fec2 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_enet2
		     &pinctrl_fec2_reset>;
	phy-mode = "rmii";
	phy-handle = <&ethphy1>;
	phy-reset-gpios = <&gpio5 8 GPIO_ACTIVE_LOW>;
	phy-reset-duration = <200>;
	status = "okay";

	mdio {
		#address-cells = <1>;
		#size-cells = <0>;

		ethphy0: ethernet-phy@2 {
			compatible = "ethernet-phy-ieee802.3-c22";
			reg = <0>;
		};

		ethphy1: ethernet-phy@1 {
			compatible = "ethernet-phy-ieee802.3-c22";
			reg = <1>;
		};
	};
};
```

>   必要属性
>
>   +   **compatible**：这个肯定是必须的，一般是“fsl,<soc>-fec”，比如I.MX6ULL的 compatible属性就是"fsl,imx6ul-fec",和"fsl,imx6q-fec"。
>   +   **reg**：SOC网络外设寄存器地址范围。
>   +   **interrupts**：网络中断。
>   +   **phy-mode**：网络所使用的PHY接口模式，是 MII还是RMII。
>
>   可选
>
>   +   **phy-reset-gpios**：PHY芯片的复位引脚。
>   +   **phy-reset-duration**：PHY复位引脚复位持续时间，单位为毫秒。只有当设置了 phy-reset-gpios属性此属性才会有效，如果不设置此属性的话PHY芯片复位引脚的复位持续时间默认为1毫秒，数值不能大于 1000毫秒，大于1000毫秒的话就会强制设置为1毫秒。
>   +   **phy-supply**：PHY芯片的电源调节。
>   +   **phy-handle**：连接到此网络设备的 PHY芯片句柄。
>   +   **fsl,num-tx-queues**：此属性指定发送队列的数量，如果不指定的话默认为 1。
>   +   **fsl,num-rx-queues**：此属性指定接收队列的数量，如果不指定的话默认为 2。
>   +   **fsl,magic-packet**：此属性不用设置具体的值，直接将此属性名字写到设备树里面即可，表示支持硬件魔术帧唤醒。
>   +   **fsl,wakeup_irq**：此属性设置唤醒中断索引。
>   +   **stop-mode**：如果此属性存在的话表明 SOC需要设置GPR位来请求停止模式。
>
>   可选节点
>
>   +   mdio：可以设置名为“mdio”的子节点，此子节点用于指定网络外设所使用的 MDIO总线，主要作为 PHY 节点的容器，也就是在 mdio 子节点下指定 PHY 相关的属性信息，具体信息可以参考PHY的绑定文档Documentation/devicetree/bindings/net/phy.txt。
>
>   +   PHY节点相关属性内容如下：
>   +   +   **interrupts**：中断属性，可以不需要。
>       +   **interrupt-parent**：中断控制器句柄，可以不需要。
>       +   **reg**：PHY芯片地址，必须的！
>       +   **compatible**：兼容性列表，一般为`ethernet-phy-ieee802.3-c22`或`ethernet-phy-ieee802.3-c45`，分别对应IEEE802.3 的22簇和45簇，默认是 22簇。也可以设置为其他值，如果 PHY的 ID不知道的话可以 compatible属性可以设置为`ethernet-phy-idAAAA.BBBB`，AAAA和BBBB的含义如下：
>       +   +   AAAA：PHY的16位 ID寄存器1值，也就是 OUI的bit3~18，16进制格式。
>       +   +   BBBB：PHY的 16位 ID寄存器2值，也就是 OUI的bit19~24，16进制格式。
>       +   **max-speed**：PHY支持的最高速度，比如 10、100或1000。

## 网络驱动

### fec_probe

I.MX6ULL 而言网络驱动主要分两部分：I.MX6ULL 网络外设驱动以及 PHY 芯片驱动，网络外设驱动是NXP编写的，PHY芯片有通用驱动文件, 在文件drivers/net/ethernet/freescale/fec_main.c里面

+   请求一个net_device结构, 实际请求的时候后面有添加自己的私有数据
+   初始化各种变量, 寄存器地址, 处理各种配置信息
+   初始化`net_device`的`netdev_ops`和`ethtool_ops`成员为`fec_netdev_ops`以及`fec_enet_ethtool_ops`
+   初始化NAPI, 使用`fec_enet_rx_napi`进行轮训
+   完成 MII/RMII 接口的初始化, 记录`mii_bus`的操作函数read/write为 `fec_enet_mdio_read`和`fec_enet_mdio_write`
+   从设备树中获取 mdio节点，如果节点存在的话就会通过 of_mdiobus_register 来向内核注册 MDIO 总线

### **MDIO** 总线

fec_probe 函数会调用 fec_enet_mii_init函数完成 MII接口的初始化，其中就包括初始化mii_bus下的read和write这两个函数。最终通过 of_mdiobus_register或者 mdiobus_register 函数将初始化以后的 mii_bus 注册到 Linux 内核

调用的 mdiobus_register 函数来完成 mii_bus 注册, 调用of_mdiobus_register_phy函数向 Linux内核注册 phy

```c
struct mii_bus {
	const char *name;
	char id[MII_BUS_ID_SIZE];
	void *priv;
	int (*read)(struct mii_bus *bus, int phy_id, int regnum);
	int (*write)(struct mii_bus *bus, int phy_id, int regnum, u16 val);
	int (*reset)(struct mii_bus *bus);

	/*
	 * A lock to ensure that only one thing can read/write
	 * the MDIO bus at a time
	 */
	struct mutex mdio_lock;

	struct device *parent;
	enum {
		MDIOBUS_ALLOCATED = 1,
		MDIOBUS_REGISTERED,
		MDIOBUS_UNREGISTERED,
		MDIOBUS_RELEASED,
	} state;
	struct device dev;

	/* list of all PHYs on bus */
	struct phy_device *phy_map[PHY_MAX_ADDR];

	/* PHY addresses to be ignored when probing */
	u32 phy_mask;

	/*
	 * Pointer to an array of interrupts, each PHY's
	 * interrupt at the index matching its address
	 */
	int *irq;
};
```

![image-20251122113447040](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/mac-picture/image-20251122113447040.png)

### PHY驱动

通用 PHY 驱动名字为“Generic PHY”，打开drivers/net/phy/phy_device.c，phy_init函数

行会调用 phy_drivers_register函数向内核直接注册一个通用 PHY 驱动：genphy_driver，也就是通用 PHY 驱动

## 使用LAN8720A

```
-> Device Drivers
  -> Network device support
    -> PHY Device support and infrastructure
      -> Drivers for SMSC PHYs
```

