# Uboot移植

需要关注mx6ull_14x14_evk_emmc_defconfig 和 mx6ull_1 4x14_evk_nand_defconfig 这两个配置文件, 这两个是官方的启动文件

默认的时候, uboot是可以运行的, 但是屏幕的显示以及网络的连接是不可使用的

一般来说要可以使用SD卡, DRAM, 串口, EMMC, NAND等

## 默认配置文件

复制一下mx6ull_14x14_evk_emmc_defconfig 这个文件, 

```c
CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ullevk/imximage.cfg,MX6ULL_EVK_EMMC_REWORK"
CONFIG_ARM=y
CONFIG_ARCH_MX6=y
CONFIG_TARGET_MX6ULL_ALIENTEK_EMMC=y
CONFIG_CMD_GPIO=y
```

第一行使用的这个文件是镜像的头部的信息, 里面有DDR初始化之类的内容, 所以需要复制这个文件所在的文件夹, 改为自己的板子, 下面的板子选项也改一下

```c
CONFIG_SYS_EXTRA_OPTIONS="IMX_CONFIG=board/freescale/mx6ullevk/imximage-ddr512.cfg,MX6ULL_EVK_EMMC_REWORK"
CONFIG_ARM=y
CONFIG_ARCH_MX6=y
CONFIG_TARGET_MX6ULL_14X14_EVK=y
CONFIG_CMD_GPIO=y
```

## 对应的头文件

在目录`include/configs`下添加I.MX6ULL-ALPHA开发板对应的头文件，复制`include/configs/mx6ullevk.h`，并重命名为`mx6ull_alientek_emmc.h`

主要功能就是配置或者裁剪uboot。如果需 要某个功能的话就在里面添加这个功能对应的CONFIG_XXX宏即可，如果不需要某个功能的 话就删除掉对应的宏即可

这个文件引用了mx6_common.h文件

## 板级文件夹

所有板级文件夹都存放在`board/freescale`目录下, 复制mx6ullevk，将其重命名为mx6ull_alientek_emmc

### c文件

mx6ull_alientek_emmc目录中，将其中的`mx6ullevk.c`文件重命名为`mx6ull_alientek_emmc.c`

### Makefile

修改一下Makefile里面的配置, 设置为编译自己板子的.o文件

### cfg文件

将imximage.cfg中的下面一句：

`PLUGIN board/freescale/mx6ullevk/plugin.bin 0x00907000`  改为：  `PLUGIN board/freescale/mx6ull_alientek_emmc /plugin.bin 0x00907000 `

### Kconfig文件

使用` if TARGET_MX6ULL_ALIENTEK_EMMC`

```c
if TARGET_MX6ULL_14X14_EVK || TARGET_MX6ULL_9X9_EVK

config SYS_BOARD
	default "mx6ull_alientek_emmc"

config SYS_VENDOR
	default "freescale"

config SYS_CONFIG_NAME
	default "mx6ull_alientek_emmc"

endif
```

### MAINTAINERS

```
MX6ULL_ALIENTEK_EMMC BOARD 
M:    Peng Fan <peng.fan@nxp.com> 
S:    Maintained 
F:    board/freescale/mx6ull_alientek_emmc/ 
F:    include/configs/mx6ull_alientek_emmc.h 
```

## 图形配置文件

修改文件`arch/arm/cpu/armv7/mx6/Kconfig`, 配置的是开始时候的config文件里面的板子名字00

```
config TARGET_MX6ULL_ALIENTEK_EMMC 
    bool "Support mx6ull_alientek_emmc" 
    select MX6ULL 
    select DM 
    select DM_THERMAL 
```

在最后一行的endif的前一行添加`source "board/freescale/mx6ull_alientek_emmc/Kconfig" `

## 驱动

主要需要关注的文件是在`board/freescale/mx6ullevk/`路径下面的.c文件以及在`include/configs`的.h文件

### 显示

lcd_pads: 记录所有的 引脚使用的配置, 复用以及电器属性, 这部分不需要修改, 使用和官方一样的

```c
struct display_info_t const displays[] = {
       {
	.bus = MX6UL_LCDIF1_BASE_ADDR, // 外设寄存器的首地址
	.addr = 0,
	.pixfmt = 24,
	.detect = NULL,
	.enable	= do_enable_parallel_lcd,
	.mode	= {
		.name           = "ATK-LCD-10.1-1280x800",
		.xres           = 1280,
		.yres           = 800,
		.pixclock       = 27123, // 是一个分频pixclock,51.2MHz的计算是pixclock=(1/51200000)*10^12=19531
		.left_margin    = 70,
		.right_margin   = 80,
		.upper_margin   = 10,
		.lower_margin   = 10,
		.hsync_len      = 10,
		.vsync_len      = 3,
		.sync           = 0,
		.vmode          = FB_VMODE_NONINTERLACED
               }
       },
	... 

};
```

> 这个结构体里面记录的一系列的屏幕的配置信息, 记录的是一系列的屏幕的参数, 改了以后烧录启动
>
> 这个驱动需要和屏幕进行匹配, 设备的名字记录在环境变量里面, 需要把`panel`改为屏幕设置的名字, 可以在.h文件里面配置默认的环境变量

### 网络

I.MX6UL/ULL 内部有个以太网MAC外设，也就是ENET，需要外接一个PHY芯片来实 现网络通信功能, 通信的速度比较快

在一些没有内部MAC的CPU中，比如三星的2440，4412等，就会采用DM9000来实 现联网功能。DM9000提供了一个类似SRAM的访问接口，主控CPU通过这个接口即可与DM9000进行通信, DM9000就是一个MAC+PHY芯片。

I.MX6UL/ULL 有两个网络接口ENET1和ENET2，正点原子的I.MX6U-ALPHA开发板提供了这两个网络接口，其中ENET1和ENET2都使用LAN8720A作为PHY芯片

LAN8720A 内部是有寄存器的，I.MX6ULL 会读取 LAN8720 内部寄存器来判断当前的物 理链接状态、连接速度(10M还是100M)和双工状态(半双工还是全双工)。I.MX6ULL通过`MDIO`接口来读取PHY芯片的内部寄存器，`MDIO`接口有两个引脚，`ENET_MDC和ENET_MDIO`， `ENET_MDC`提供时钟，`ENET_MDIO`进行数据传输。一个MDIO接口可以管理32个PHY 芯片，同一个MDIO接口下的这些PHY使用不同的器件地址来做区分，MIDO接口通过不同的器件地址即可访问到相应的PHY芯片

I.MX6U-ALPHA开发板ENET1上连接的LAN8720A器件地址为0X0, 另一个是0x1

还需要处理的是两个芯片使用的复位引脚和原来的开发板不同

![image-20251028200957916](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510282010061.png)

`ENET1`复位引脚 `ENET1_RST` 接到了I.M6ULL的`SNVS_TAMPER7`这个引脚, `ENET2`的复位引脚`ENET2_RST`接到了 I.MX6ULL 的`SNVS_TAMPER8`上

> 默认PHY芯片的前16位寄存器是一样的, 所以可以使用通用的驱动

+ 更改一下使用的开发板的网络地址

```c
#define CONFIG_FEC_ENET_DEV		1		// 使用ENET2

#if (CONFIG_FEC_ENET_DEV == 0)
#define IMX_FEC_BASE			ENET_BASE_ADDR
#define CONFIG_FEC_MXC_PHYADDR          0x2
/* alientek imx6ull alpha board version <= 2.2, mini board <= 1.8, CONFIG_FEC_MXC_PHYADDR = 0x0 */
/* #define CONFIG_FEC_MXC_PHYADDR          0x0 */
#define CONFIG_FEC_XCV_TYPE             RMII
#elif (CONFIG_FEC_ENET_DEV == 1)
#define IMX_FEC_BASE			ENET2_BASE_ADDR
#define CONFIG_FEC_MXC_PHYADDR		0x1 // 使用这个网卡, 这里的数字是1 
#define CONFIG_FEC_XCV_TYPE		RMII
#endif
#define CONFIG_ETHPRIME			"FEC"

#define CONFIG_PHYLIB
#define CONFIG_PHY_REALTEK
#define CONFIG_PHY_SMSC
#endif
```

原厂的板子使用74LV595拓展引脚, 这里删除

```c
#define IOX_SDI  IMX_GPIO_NR(5, 10) 
#define IOX_STCP  IMX_GPIO_NR(5, 7) 
#define IOX_SHCP  IMX_GPIO_NR(5, 11) 
#define IOX_OE  IMX_GPIO_NR(5, 8) 
```

添加使用的复位引脚

```c
#define ENET1_RESET IMX_GPIO_NR(5, 7)
#define ENET2_RESET IMX_GPIO_NR(5, 8)
```

> 使用这两个设备引脚的位置

同时把iox74lv_init相关的代码删除, 在函数setup_iomux_fec里面进行复位, 使用控制引脚的方式进行

uboot中的LAN8720A驱动有点问题，打开文件drivers/ net/phy/phy.c，找到函数genphy_update_link，这是个通用PHY驱动函数，此函数用于更新PHY的连接状态和速度。

在函数`genphy_update_link`添加一个软件复位

```c
#ifdef CONFIG_PHY_SMSC 
    static int lan8720_flag = 0; 
    int bmcr_reg = 0; 
    if (lan8720_flag == 0) { 
        bmcr_reg = phy_read(phydev, MDIO_DEVAD_NONE, MII_BMCR);  // 获取一下寄存器   
        phy_write(phydev, MDIO_DEVAD_NONE, MII_BMCR, BMCR_RESET);   // 软件复位 
        while(phy_read(phydev, MDIO_DEVAD_NONE, MII_BMCR) & 0X8000) { // 判断是否成功
            udelay(100);             
        } 
        phy_write(phydev, MDIO_DEVAD_NONE, MII_BMCR, bmcr_reg);     // 写回去之前的数值
        lan8720_flag = 1; 
    } 
#endif 
```

### DDR

u-boot.imx会被添加镜像头, 在这部分进行DDR的初始化

使用的是./tool/mkimage的文件, 使用board/freescale/mu6ullevk/imximage.cfg.cfgtmp + u-boot.bin生成, 从而获取u-boot.imx文件

实际是根据`uboot\board\freescale\mx6ullevk\imximage.cfg`进行生成的, 使用NXP的DDR测试工具可以获取到DDR的校准参数

## 其他

### 板子的名字

在板子的.c文件里面, checkboard返回的是板子的名字

## .h配置文件

可以在这个文件里面添加宏定义以及删除宏定义达到功能配置的作用, 同时还有配置一部分板子配置的作用

## 配置项

+ CONFIG_DISPLAY_CPUINFO: 显示CPU的信息
+ PHYS_SDRAM_SIZE: 配置DDRAM的大小
+ CONFIG_DISPLAY_BOARDINFO: 输出板子信息
+ CONFIG_SYS_MALLOC_LEN: 内存池的大小
+ CONFIG_BOARD_EARLY_INIT_F: 会调用`board_early_init_f`函数
+ CONFIG_BOARD_LATE_INIT: 调用`board_late_init`函数
+ CONFIG_MFG_ENV_SETTINGS: 使用Mfgtool烧录的时候使用的
+ CONFIG_SYS_LOAD_ADDR: linux加载时候的地址
+ CONFIG_SYS_HZ: 系统时钟的频率
+ CONFIG_STACKSIZE: 栈大小
+ CONFIG_SYS_MMC_ENV_DEV: 默认的MMC设备
+ CONFIG_MMCROOT: 根文件系统在的分区
+ CONFIG_ENV_SIZE: 环境变量的大小
+ CONFIG_ENV_OFFSET: 环境变量的地址, 这个位置默认是啥也没有的, 在使用saveenv以后才记录在这里
+ CONFIG_VIDEO: 开启LCD
+ CONFIG _VIDEO_LOGO: 使能LOGO显示
+ CONFIG_CMD_BMP: 使能BMP图片显示指令

### 环境变量

在.h文件里面可以设置板子的环境变量, `CONFIG_EXTRA_ENV_SETTINGS`这个变量定义默认的环境变量, 从SD卡或者EMMC之类的设备没有读取到的时候, 使用这个默认的环境变量

这部分会被记录在default_environment这个结构体里面

倒计时结束以后使用命令bootcmd

#### bootcmd

> ```
> Only needed when CONFIG_BOOTDELAY is enabled;
> define a command string that is automatically executed
> when no character is read on the console interface
> within "Boot Delay" after reset.
> ```

```c
#define CONFIG_BOOTCOMMAND \
	   "run findfdt;" \
	   "mmc dev ${mmcdev};" \				// 切换emmc1
	   "mmc dev ${mmcdev}; if mmc rescan; then " \	// 扫描判断设备是不是存在
		   "if run loadbootscript; then " \ // 运行这里加载一下boot.src文件失败
			   "run bootscript; " \	
		   "else " \
			   "if run loadimage; then " \
				   "run mmcboot; " \
			   "else run netboot; " \
			   "fi; " \
		   "fi; " \
	   "else run netboot; fi" // 使用网络启动
#endif
```

```c
"findfdt="\
    "if test $fdt_file = undefined; then " \
        "if test $board_name = EVK && test $board_rev = 9X9; then " \
        	"setenv fdt_file imx6ull-9x9-evk.dtb; fi; " \
        "if test $board_name = EVK && test $board_rev = 14X14; then " \
        	"setenv fdt_file imx6ull-14x14-evk.dtb; fi; " \
        "if test $fdt_file = undefined; then " \
        	"echo WARNING: Could not determine dtb to use; fi; " \
    "fi;\0" \
```

根据板子的设置配置一下fdt_file设备树文件的名字, 如果board_name为EVK并且board_rev=14x14的话fdt_file就设置为imx6ull-14x14-evk.dtb

```c
"loadbootscript=" \
    "fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\0" \
```

> mmcdev=1，mmcpart=1，loadaddr=0x80800000，script= boot.scr, 所以这个命令是`loadbootscript=fatload mmc 1:1 0x80800000 boot.scr; `, 因为boot.src文件不存在，所以bootscript也就不会运行

此后运行

```c
"loadimage=fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}\0" \
```

> `loadimage=fatload mmc 1:1 0x80800000 zImage`加载设备的镜像文件

```c
	"mmcboot=echo Booting from mmc ...; " \
		"run mmcargs; " \
		"if test ${boot_fdt} = yes || test ${boot_fdt} = try; then " \
			"if run loadfdt; then " \
				"bootz ${loadaddr} - ${fdt_addr}; " \ // 运行这里
			"else " \
				"if test ${boot_fdt} = try; then " \
					"bootz; " \
				"else " \
					"echo WARN: Cannot load the DT; " \
				"fi; " \
			"fi; " \
		"else " \
			"bootz; " \
		"fi;\0" \
```

```c
"mmcargs=setenv bootargs console=${console},${baudrate} " \
    CONFIG_BOOTARGS_CMA_SIZE \
    CONFIG_MFG_NAND_PARTITION \
    "root=${mmcroot}\0" \
```

> 设置bootargs, 设置之后启动以后Linux使用的设备

```c
"loadfdt=fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\0" \
```

> `loadfdt=fatload mmc 1:1 0x83000000 imx6ull-14x14-evk.dtb`加载设备树文件

#### bootargs

bootargs 保存着uboot传递给 Linux 内核的参数，在上一小节讲解bootcmd的时候说过，bootargs环境变量是由mmcargs设置的

```c
"mmcargs=setenv bootargs console=${console},${baudrate} " \
    CONFIG_BOOTARGS_CMA_SIZE \
    CONFIG_MFG_NAND_PARTITION \
    "root=${mmcroot}\0" \
```

````c
"mmcargs=setenv bootargs console=ttymxc0,115200" \
    "" \
    "" \
    "root=/dev/mmcblk1p2 rootwait rw\0" \
````

> console: 用来设置linux终端(或者叫控制台)，也就是通过什么设备来和Linux进行交互, 是串口还是LCD屏幕, 设置ttymxc0(串口1)作为Linux的终端，并且串口波特率设置为115200
>
> root: 根文件系统存放在mmcblk1设备的分区2中
>
> rootwait 表示等待 mmc设备初始化完成以后再挂载，否则的话 mmc设备还没初始化完成就挂载根文件系统会出错的。rw表示根文件系统是可以读写的
>
> rootfstype: 于指定根文件系统类型，如果根文件系统为e xt 格式的话此选项无所谓。如果根文件系统是yaffs、jffs或ubifs的话就需要设置此选项
