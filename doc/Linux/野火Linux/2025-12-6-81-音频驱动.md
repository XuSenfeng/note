# 音频驱动

[(82 封私信 / 80 条消息) 正点原子linux应用编程——提高篇4 - 知乎](https://zhuanlan.zhihu.com/p/670785159)

ALSA是Advanced Linux Sound Architecture(高级的Linux声音体系)的缩写，目前已经成为了 linux 下的主流音频体系架构，提供了音频和MIDI的支持，替代了原先旧版本中的OSS(开发声音系统)

ALSA提供了一套标准的API，应用程序只需要调用这些API就可完成对底层音频硬 件设备的控制，譬如播放、录音等

![image-20251206145644930](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202512061456094.png)

#### 1. 声卡（Sound Card）—— 物理载体

- **本质**：电脑的音频硬件（内置 / 外置），核心功能是完成**数模转换（DAC，数字音频→模拟声波）** 和**模数转换（ADC，麦克风输入→数字音频）**，是所有音频操作的物理基础。
- 系统标识：Linux/ALSA 中用 `hw:0`、`hw:1` 区分（0 是第一块声卡，1 是第二块，以此类推），对应代码里的 `const char *card = "hw:0"`。
- 核心作用：所有音频的输入 / 输出最终都通过声卡完成，混音器、控件都是围绕声卡的功能展开的。

#### 2. 混音器（Mixer）—— 声卡的 “调音台模块”

- 本质

    声卡硬件内置的一个功能模块（也有软件模拟的混音器），核心作用是

    管理多个音频流的混合、音量调节、路由选择

    比如：把音乐、系统提示音、游戏音效等多个数字音频流混合成一个信号，调整各自音量后，再通过 DAC 输出到音箱；也能管理麦克风输入的音量、是否静音等。

- 软件抽象：ALSA 中用 `snd_mixer_t` 结构体（代码里的 `handle`）表示混音器，它是应用程序操作声卡混音功能的 “入口句柄”。

- 核心特点：

    - 一个声卡对应**一个核心混音器**（你可以理解为 “一块声卡只有一个调音台”）；
    - 要操作声卡的音频参数，必须先打开并关联该声卡的混音器（代码里的 `snd_mixer_open` + `snd_mixer_attach`）。

#### 3. 控件（Control Element/Selem）—— 混音器的 “旋钮 / 开关”

- **本质**：混音器的最小可操作单元，每个控件对应混音器的一个具体功能（比如调节某一路音频的音量、开关静音、选择音频输入源等）。
- 软件抽象：ALSA 中用 `snd_mixer_elem_t` 结构体（代码里的 `elem`）表示控件，通过 `snd_mixer_selem_id_t`（`sid`）定位具体控件（名称 + 索引）。
- 常见控件类型（对应不同 “旋钮 / 开关”）：
    - 音量控件：`Master`（主音量）、`PCM`（数字音频音量）、`DAC LINEOUT`（DAC 输出音量，代码里的控件名）、`Speaker`（扬声器音量）；
    - 开关控件：`Master Playback Switch`（主音量静音开关）；
    - 枚举控件：`Input Source`（选择麦克风 / 线路输入等音频源）。
- 核心特点：
    - 一个混音器包含**多个控件**（调音台上有多个旋钮 / 开关，各自管不同功能）；
    - 不同声卡的混音器控件名称 / 数量不同（比如有的声卡叫 `Master`，有的工业声卡叫 `DAC LINEOUT`）。

## alas-lib

**alsa-lib是一套Linux应用层的C语言函数库**，为音频应用程序开发提供了一套**统一、标准的接口，应用程序只需调用这一套API即可完成对底层声卡设备的操控**，譬如播放与录音。

主要涉及三个模块：PCM Interface、Error Interface以及Mixer Interface

- PCM Interface：提供了PCM设备相关的操作接口，譬如打开/关闭PCM设备、配置PCM设备硬件或软件参数、控制PCM设备(启动、暂停、恢复、写入/读取数据)；
- Error Interface：提供了关于错误处理相关的接口；
- Mixer Interface：提供了关于混音器相关的一系列操作接口。

一般在使用的时候需要移植一个alsa-utils用于测试以及配置

alsa-utils提供了一些用于测试、配置声卡的工具，譬如[aplay](https://zhida.zhihu.com/search?content_id=237193447&content_type=Article&match_order=1&q=aplay&zhida_source=entity)、[arecord](https://zhida.zhihu.com/search?content_id=237193447&content_type=Article&match_order=1&q=arecord&zhida_source=entity)、alsactl、alsaloop、[alsamixer](https://zhida.zhihu.com/search?content_id=237193447&content_type=Article&match_order=1&q=alsamixer&zhida_source=entity)、amixer等，在开发板出厂系统上可以直接使用这些工具，这些应用程序也都是基于alsa-lib编写的。

- aplay：用于测试音频播放功能程序，可以使用aplay播放wav格式的音频文件；aplay只能解析wav格式音频文件；
- alsamixer：用于配置声卡的混音器，它是一个字符图形化的配置工具，直接在开发板串口终端运行alsamixer命令，就打开图形化配置界面；
- alsactl：将当前声卡配置保存，默认文件是/var/lib/alsa/asound.state，可通过如下命令保存与加载：

alsactl -f /var/lib/alsa/asound.state store alsactl -f /var/lib/alsa/asound.state restore

- amixer：声卡配置工具，但是是基于命令行操作的。
- arecord：用于录音测试的应用程序。

## 设备节点

在Linux内核设备驱动层，**基于ALSA音频驱动框架注册的sound设备会在/dev/snd目录下生成相应的设备节点文件**。

- controlC0：用于声卡控制的设备节点，譬如通道选择、混音器、麦克风的控制等，C0表示声卡0(card0)；
- pcmC0D0p：用于播放(或叫放音、回放)的PCM设备节点。其中C0表示card0，也就是声卡0；而D0表示device 0，也就是设备0；最后一个字母p是playback的缩写，表示播放；所以pcmC0D0p便是系统的声卡0中的播放设备0
- pcmC0D1c：用于录音的PCM设备节点。对应系统的声卡0中的录音设备1；
- pcmC0D2c：用于录音的PCM设备节点。对应系统的声卡0中的录音设备2；
- timer：定时器。

在Linux系统的/proc/asound目录下，有很多的 文件，这些文件记录了系统中声卡相关的信息：

- cards：通过"cat /proc/asound/cards"命令，查看cards文件的内容，可列出系统中可用的、注册的声卡；系统中注册的所有声卡都会在/proc/asound/目录下存在一个相应的目录，该目录的命名方式为cardX(X表示声卡的编号)；
- devices：通过"cat /proc/asound/devices"命令，查看系统中所有声卡注册的设备，包括control、pcm、timer、seq等等；
- pcm：通过"cat /proc/asound/pcm"命令，查看系统中所有PCM设备，包括playback和capture。

## 应用

### 基础概念

- 样本长度(Sample)：采样位数，也称为位深度，是指数字声音信号的二进制位数；
- 声道数(channel)：分为单声道和双声道；
- 帧(frame)：记录一个声音单元，长度为样本长度与声道数乘积；
- 采样率(Sample rate)：每秒采样次数；
- 交错模式(interleaved)：音频数据的记录方式，分为交错模式和非交错模式；交错模式下，数据以连续帧形式存放；非交错模式下则是先记录一个周期内所有帧左声道再记录右声道；
- 周期(period)：音频设备处理数据的单位；
- 缓冲区(buffer)：一个缓冲区包含若干周期。

- PCM播放

在播放情况下，buffer中存放了需要播放的PCM音频数据，由应用程序向buffer中写入音频数据，buffer中的音频数据由DMA传输给音频设备进行播放，所以应用程序向buffer写入数据、音频设备从buffer读取数据，这就是buffer中数据的传输情况。

这里是有读指针和写指针，在缓冲区没有数据时均指向buffer起始位置，每次读写到末尾后会回到buffer起始位置。

- PCM录音

buffer中存放了音频设备采集到的音频数据(外界模拟声音通过ADC转为数字声音)，由音频设备向buffer中写入音频数据(DMA搬运)，而应用程序从buffer中读取数据，所以音频设备向buffer写入数据、应用程序从buffer读取数据。

- Over and Under Run

当一个声卡处于工作状态时，环形缓冲区buffer中的数据总是连续地在音频设备和应用程序缓存区间传输，如下图所示：

![image-20251206152133716](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202512061521790.png)

在录音例子中，如果应用程序读取数据不够快，环形缓冲区buffer中的数据已经被音频设备写满了、而应用程序还未来得及读走，那么数据将会被覆盖；这种**数据的丢失被称为overrun**。在播放例子中，如果应用程序写入数据到环形缓冲区buffer中的速度不够快，**缓存区将会“饿死”(缓冲区中无数据可播放)，这样的错误被称为underrun(欠载)**。**在ALSA 文档中，将这两种情形统称为"XRUN"**，适当地设计应用程序可以最小化XRUN并且可以从中恢复过来

### 相关API

#### 打开关闭

```c
int snd_pcm_open(snd_pcm_t **pcmp, const char *name, snd_pcm_stream_t stream, int mode);
int snd_pcm_close(snd_pcm_t *pcm);
```

- pcmp(返回参数)：snd_pcm_t用于描述一个PCM设备，所以一个snd_pcm_t对象表示一个PCM设备；snd_pcm_open函数会打开参数name所指定的设备，实例化snd_pcm_t对象，并将对象的指针(也就是PCM设备的句柄)通过pcmp返回出来；
- name：指定PCM设备名字，命名方式为"hw:i,j"，i表示声卡的卡号，j则表示这块声卡上的设备号；
- stream：指定流类型，SND_PCM_STREAM_PLAYBACK表示播放，SND_PCM_STREAM_CAPTURE则表示采集；
- mode：指定了open模式，通常情况下会将其设置为0，表示默认打开模式，使用阻塞方式打开设备；也可将其设置为SND_PCM_NONBLOCK，表示以非阻塞方式打开设备。

#### 设置

对采样率、声道数、格式、访问类型、period周期大小、buffer大小等进行配置

- 实例化snd_pcm_hw_params_t对象

使用snd_pcm_hw_params_malloc或snd_pcm_hw_params_alloca()来实例化一个snd_pcm_hw_params_t对象, snd_pcm_hw_params_free()函数用于释放snd_pcm_hw_params_t对象占用的内存空间

```c
snd_pcm_hw_params_t *hwparams = NULL;
snd_pcm_hw_params_malloc(&hwparams);
snd_pcm_hw_params_alloca(&hwparams);

void snd_pcm_hw_params_free(snd_pcm_hw_params_t *obj);
```

- 初始化snd_pcm_hw_params_t对象

调用snd_pcm_hw_params_any()对snd_pcm_hw_params_t对象进行初始化操作，调用该函数会使用PCM设备当前的配置参数去初始化snd_pcm_hw_params_t对象

```c
snd_pcm_hw_params_any(pcm_handle, hwparams);
```

第一个参数为PCM设备的句柄，第二个参数传入snd_pcm_hw_params_t对象的指针

- 硬件参数设置

alsa-lib提供了一系列的snd_pcm_hw_params_set_xxx函数用于设置PCM设备的硬件参数，同样也提供了一系列的snd_pcm_hw_params_get_xxx函数用于获取硬件参数。

调用snd_pcm_hw_params_set_access**设置访问类型**

```c
int snd_pcm_hw_params_set_access(snd_pcm_t *pcm,
        snd_pcm_hw_params_t * params,
        snd_pcm_access_t access 
);
```

参数access指定设备的访问类型，是一个snd_pcm_access_t类型常量，通常将访问类型设置为SND_PCM_ACCESS_RW_INTERLEAVED，交错访问模式，通过snd_pcm_readi/snd_pcm_writei对PCM设备进行读/写操作

函数调用成功返回0，失败返回小于0的错误码，可通过snd_strerror()函数获取错误信息。

调用snd_pcm_hw_params_set_format()函数**设置PCM设备的数据格式**，函数原型如下所示：

```c
int snd_pcm_hw_params_set_format(snd_pcm_t *pcm,
        snd_pcm_hw_params_t *params,
        snd_pcm_format_t format
);
```

参数format指定数据格式，该参数是一个snd_pcm_format_t类型常量，用的最多的格式是SND_PCM_FORMAT_S16_LE，有符号16位、小端模式。当然，可能不支持这个格式，可以调用snd_pcm_hw_params_test_format()函数测试PCM设备是否支持某种格式，如下所示：

```c
if (snd_pcm_hw_params_test_format(pcm_handle, hwparams, SND_PCM_FORMAT_S16_LE)) {
    // 返回一个非零值 表示不支持该格式
}
else {
    // 返回 0 表示支持
}
```

调用snd_pcm_hw_params_set_channels()函数**设置PCM设备的声道数**，函数原型如下所示：

```c
int snd_pcm_hw_params_set_channels(snd_pcm_t *pcm,
        snd_pcm_hw_params_t *params,
        unsigned int val
);
```

参数val指定声道数量，val=2表示双声道，也就是立体声。函数调用成功返回0，失败返回小于0的错误码。

调用snd_pcm_hw_params_set_rate()**设置采样率大小**，其函数原型如下所示：

```c
int snd_pcm_hw_params_set_rate(snd_pcm_t *pcm,
        snd_pcm_hw_params_t *params,
        unsigned int val,
        int dir 
);
```

参数val指定采样率大小，譬如44100；参数dir用于控制方向，若dir=-1，则实际采样率小于参数val指定的值；dir=0表示实际采样率等于参数val；dir=1表示实际采样率大于参数val。函数调用成功返回0；失败将返回小于0的错误码。

调用snd_pcm_hw_params_set_period_size()函数**设置周期大小**，其函数原型如下所示：

```c
int snd_pcm_hw_params_set_period_size(snd_pcm_t *pcm,
        snd_pcm_hw_params_t *params,
        snd_pcm_uframes_t val,
        int dir
);
```

alsa-lib使用snd_pcm_uframes_t类型表示帧的数量；参数dir与snd_pcm_hw_params_set_rate()函数的dir参数意义相同。

调用snd_pcm_hw_params_set_buffer_size()函数**设置buffer的大小**，其函数原型如下所示：

```c
int snd_pcm_hw_params_set_buffer_size(snd_pcm_t *pcm,
        snd_pcm_hw_params_t *params,
        snd_pcm_uframes_t val
);
```

参数val指定buffer的大小，以帧为单位，通常buffer的大小是周期大小的整数倍；但函数snd_pcm_hw_params_set_buffer_size()是以帧为单位来表示buffer的大小，所以需要转换一下。函数调用成功返回0；失败返回一个小于0的错误码。

还可以调用snd_pcm_hw_params_set_periods()函数设置buffer大小，其函数原型如下所示：

```c
int snd_pcm_hw_params_set_periods(snd_pcm_t *pcm,
        snd_pcm_hw_params_t *params,
        unsigned int val,
        int dir
);
```

参数val指定了buffer的大小，该大小以周期为单位、并不是以帧为单位，注意区分！参数dir与snd_pcm_hw_params_set_rate()函数的dir参数意义相同。函数调用成功返回0；失败将返回一个小于0的错误码。

调用snd_pcm_hw_params()加载/安装配置、**将配置参数写入硬件使其生效**，其函数原型如下所示：

```c
int snd_pcm_hw_params(snd_pcm_t *pcm, snd_pcm_hw_params_t *params);
```

函数调用成功返回0，失败将返回一个小于0的错误码。

函数snd_pcm_hw_params()调用之后，其内部 会自动调用snd_pcm_prepare()函数，PCM设备的状态被更改为SND_PCM_STATE_PREPARED。

#### 读写数据

如果是PCM播放，则调用snd_pcm_writei()函数向播放缓冲区buffer中写入音频数据；如果是PCM录音，则调用snd_pcm_readi()函数从录音缓冲区buffer中读取数据，它们的函数原型如下所示：

```c
snd_pcm_sframes_t snd_pcm_writei(snd_pcm_t *pcm,
        const void *buffer,
        snd_pcm_uframes_t size
);

snd_pcm_sframes_t snd_pcm_readi(snd_pcm_t *pcm,
        void *buffer,
        snd_pcm_uframes_t size
);
```

参数pcm为PCM设备的句柄；参数size指定写入数据的大小，以帧为单位。通常情况下，两个函数都是读/写一个周期。

要注意的是，这里的buffer是应用程序的缓冲区，会通过函数与驱动层的环形buffer进行交互

snd_pcm_readi/snd_pcm_writei调用成功，返回实际读取/写入的帧数；调用失败将返回一个负数错误码。即使调用成功，实际读取/写入的帧数不一定等于参数size所指定的帧数，仅当发生信号或XRUN时，返回的帧数可能会小于参数size。

调用snd_pcm_open()打开设备时，若指定为阻塞方式，则调用snd_pcm_readi/snd_pcm_writei以阻塞方 式进行读/写。若**调用snd_pcm_open()打开设备时，指定为非阻塞方式**，则调用snd_pcm_readi/snd_pcm_writei以非阻 塞方式进行读/写。对于PCM录音来说，当buffer缓冲区中无数据可读时，**调用snd_pcm_readi()不会阻塞、而是立即以错误形式返回**；同理，对于PCM播放来说，当buffer缓冲区中的数据满时，**调用snd_pcm_writei()函数也不会阻塞、而是立即以错误形式返回**。

**snd_pcm_readi/snd_pcm_writei适用于交错模式(interleaved)读/写数据**，如果用户设置的访问类型并不是交错模式，而是**非交错模式(non interleaved)**，此时便不可再使用snd_pcm_readi/snd_pcm_writei进行读写操作了，**而需要使用snd_pcm_readn和snd_pcm_writen进行读写**。

## 混音器设置

混音器相关的接口在alsa-lib的Mixer Interface模块中有介绍。控制音频路由和音量

### 打开混音器

调用snd_mixer_open()函数打开一个空的混音器，其函数原型如下所示：

```c
int snd_mixer_open(snd_mixer_t **mixerp, int mode);
```

snd_mixer_t数据结构描述混音器，调用snd_mixer_open()函数会实例化一个snd_mixer_t对象，并将对象的指针(混音器的句柄)通过mixerp返回出来。参数mode指定了打开模式，通常设置为0使用默认模式即可。函数调用成功返回0；失败返回一个小于0的错误码。

### Attach关联设备

调用snd_mixer_attach()函数进行关联声卡控制设备，其函数原型如下所示：

```c
int snd_mixer_attach(snd_mixer_t *mixer, const char *name);
```

参数mixer对应的是混音器的句柄，参数name指定了声卡控制设备的名字，同样这里使用的也是逻辑设备名，而非设备节点的名字，命名方式为"hw:i"，i表示声卡的卡号，通常一个声卡对应一个控制设备。函数调用成功返回0；失败返回一个小于0的错误码。

- 可通过 `cat /proc/asound/cards` 查看系统声卡列表

### 注册

调用snd_mixer_selem_register()函数注册混音器，其函数原型如下所示：

```c
int snd_mixer_selem_register(
    snd_mixer_t *mixer,
    struct snd_mixer_selem_regopt *options,
    snd_mixer_class_t **classp);
```

参数options和参数classp直接设置为NULL即可。函数调用成功返回0；失败返回一个小于0的错误码。

### 加载

最后需要加载混音器，调用snd_mixer_load()函数完成加载，函数原型如下所示：

```c
int snd_mixer_load(snd_mixer_t * mixer);
```

函数调用成功返回0；失败返回小于0的错误码。

### 查找元素

alsa-lib中把混音器的配置项称为元素(element)。

alsa-lib使用数据结构snd_mixer_elem_t来描述一个元素。混音器有很多的元素(很多配置项)，通过snd_mixer_first_elem()函数可以找到混音器的第一个元素，其函数原型如下所示：

```c
snd_mixer_elem_t *snd_mixer_first_elem(snd_mixer_t *mixer);
```

通过snd_mixer_last_elem()函数可找到混音器的最后一个元素，如下：

```c
snd_mixer_elem_t *snd_mixer_last_elem(snd_mixer_t *mixer);
```

调用snd_mixer_elem_next()和snd_mixer_elem_prev()函数可获取指定元素的下一个元素和上一个元素：

```c
snd_mixer_elem_t *snd_mixer_elem_next(snd_mixer_elem_t *elem);
snd_mixer_elem_t *snd_mixer_elem_prev(snd_mixer_elem_t *elem);
```

遍历如下所示：

```c
snd_mixer_elem_t *elem = NULL;

elem = snd_mixer_first_elem(mixer);//找到第一个元素
while (elem) {
    ......
    ......
    snd_mixer_elem_next(elem); //找到下一个元素
}
```

调用snd_mixer_selem_get_name()函数可获取指定元素的名字，如下所示：

```c
const char *snd_mixer_selem_get_name(snd_mixer_elem_t *elem);
```

### 获取/更改元素

有两种配置值：第一种它的配置值是在一个范围内的数值，譬如音量大小的调节；另一种则是bool类型，用于控制开启或关闭，譬如0表示关闭配置、1表示使能配置。

可以调用snd_mixer_selem_has_playback_volume或snd_mixer_selem_has_capture_volume函数来判断一个指定元素的配置值是否是volume类型，也就是上文的第一种类型。函数原型如下所示：

```c
int snd_mixer_selem_has_playback_volume(snd_mixer_elem_t *elem);
int snd_mixer_selem_has_capture_volume(snd_mixer_elem_t *elem);
```

函数返回0表示不是volume类型；返回1表示是volume类型。

调用snd_mixer_selem_has_playback_switch和snd_mixer_selem_has_capture_switch函数判断一个指定元素的配置值是否是switch类型，也就是上面说的第二种情况。函数原型如下所示：

```c
int snd_mixer_selem_has_playback_switch(snd_mixer_elem_t *elem);
int snd_mixer_selem_has_capture_switch(snd_mixer_elem_t *elem);
```

函数返回0表示不是switch类型；返回1表示是switch类型。

通过snd_mixer_selem_has_playback_channel或snd_mixer_selem_has_capture_channel函数可判断指定元素是否包含指定通道，其函数原型如下所示：

```c
int snd_mixer_selem_has_playback_channel(
    snd_mixer_elem_t *elem,
    snd_mixer_selem_channel_id_t channel
);
int snd_mixer_selem_has_capture_channel(
    snd_mixer_elem_t *elem,
    snd_mixer_selem_channel_id_t channel
);
```

参数channel用于指定一个通道，snd_mixer_selem_channel_id_t是一个枚举类型。如果元素是双声道元素，通常只包含左前(SND_MIXER_SCHN_FRONT_LEFT)和右前(SND_MIXER_SCHN_FRONT_RIGHT)两个声道。如果是单声道设备，通常只包含SND_MIXER_SCHN_MONO，其数值等于SND_MIXER_SCHN_FRONT_LEFT。

可以调用snd_mixer_selem_is_playback_mono或snd_mixer_selem_is_capture_mono函数判断一个指定的元素是否是单声道元素，其函数原型如下所示：

```c
int snd_mixer_selem_is_playback_mono(snd_mixer_elem_t *elem);
int snd_mixer_selem_is_capture_mono(snd_mixer_elem_t *elem);
```

调用snd_mixer_selem_get_playback_volume或snd_mixer_selem_get_capture_volume获取指定元素的音量大小，其函数原型如下所示：

```c
int snd_mixer_selem_get_playback_volume(
    snd_mixer_elem_t *elem,
    snd_mixer_selem_channel_id_t channel,
    long *value
);
int snd_mixer_selem_get_capture_volume(
    snd_mixer_elem_t *elem,
    snd_mixer_selem_channel_id_t channel,
    long *value
);
```

参数elem指定对应的元素，参数channel指定该元素的某个声道。调用snd_mixer_selem_get_playback_volume()函数可获取elem元素的channel声道对应的音量大小，并将获取到的音量值通过value返回出来。函数调用成功返回0，失败返回一个小于0的错误码。

调用snd_mixer_selem_set_playback_volume或snd_mixer_selem_set_capture_volume设置指定元素的音量值，其函数原型如下所示：

```c
int snd_mixer_selem_set_playback_volume(
    snd_mixer_elem_t *elem,
    snd_mixer_selem_channel_id_t channel,
    long value
);
int snd_mixer_selem_set_capture_volume(
    snd_mixer_elem_t *elem,
    snd_mixer_selem_channel_id_t channel,
    long value
);
```

参数elem指定元素、参数channel指定该元素的某个声道，参数value指定音量值。

调用snd_mixer_selem_set_playback_volume_all或snd_mixer_selem_set_capture_volume_all可一次性设置指定元素所有声道的音量，函数原型如下所示：

```c
int snd_mixer_selem_set_playback_volume_all(
    snd_mixer_elem_t *elem,
    long value 
);
int snd_mixer_selem_set_capture_volume_all(
    snd_mixer_elem_t *elem,
    long value 
);
```

调用snd_mixer_selem_get_playback_volume_range或snd_mixer_selem_get_capture_volume_range获取指定元素的音量范围，其函数原型如下所示：

```c
int snd_mixer_selem_get_playback_volume_range(
    snd_mixer_elem_t *elem,
    long *min,
    long *max
);
int snd_mixer_selem_get_capture_volume_range(
    snd_mixer_elem_t *elem,
    long *min,
    long *max
);
```

## 示例

### 设置音量

打开混音器→定位声卡→查找音量控件→设置音量

```c
// 设置音量
int sys_set_volume(int level) {
    if (level < 0 || level > 100) return -1; // 音量级别应在0到100之间
    // 这里可以添加实际设置硬件音量的代码
#if LV_USE_SIMULATOR == 0
    const char *card = "hw:0";       // 声卡名称
    // selem_name 必须与声卡实际的控件名一致，
    // 可通过 amixer 命令查看（如 amixer -c 0 scontrols 
    // 查看第 0 块声卡的所有控件名）
    const char *selem_name = "DAC LINEOUT"; // 控件名称
    snd_mixer_t *handle;
    snd_mixer_selem_id_t *sid;
    snd_mixer_elem_t *elem;
    long min, max, mapped_volume;

    // 打开混音器
    if (snd_mixer_open(&handle, 0) < 0) {
        fprintf(stderr, "Error: Unable to open mixer.\n");
        return -1;
    }

    // 加载指定声卡
    if (snd_mixer_attach(handle, card) < 0) {
        fprintf(stderr, "Error: Unable to attach to card '%s'.\n", card);
        snd_mixer_close(handle);
        return -1;
    }

    // 注册元素类, 是加载控件的前置步骤
    if (snd_mixer_selem_register(handle, NULL, NULL) < 0) {
        fprintf(stderr, "Error: Unable to register mixer.\n");
        snd_mixer_close(handle);
        return -1;
    }

    // 加载混音器元素
    // 加载指定声卡上的所有混音器控件（如音量、静音、声道等控件）
    // 到内存，供后续查找和操作
    if (snd_mixer_load(handle) < 0) {
        fprintf(stderr, "Error: Unable to load mixer.\n");
        snd_mixer_close(handle);
        return -1;
    }

    // 创建混音器元素 ID
    snd_mixer_selem_id_alloca(&sid); // 分配元素ID结构体
    // 设置属性索引以及名字
    snd_mixer_selem_id_set_index(sid, 0); // 默认索引为 0
    snd_mixer_selem_id_set_name(sid, selem_name);

    // 查找对应元素, 使用刚才设置的两个属性
    elem = snd_mixer_find_selem(handle, sid);
    if (!elem) {
        fprintf(stderr, "Error: Unable to find element '%s'.\n", selem_name);
        snd_mixer_close(handle);
        return -1;
    }

    // 获取音量范围
    snd_mixer_selem_get_playback_volume_range(elem, &min, &max);
    printf("Volume range: %ld to %ld\n", min, max);

    // 映射音量值到实际范围
    mapped_volume = min + (long)((double)(max - min) * level / 100.0);

    // 设置音量
    if (snd_mixer_selem_set_playback_volume_all(elem, mapped_volume) < 0) {
        fprintf(stderr, "Error: Unable to set volume.\n");
        snd_mixer_close(handle);
        return -1;
    }

    printf("Set '%s' volume to %ld (mapped from %d%%)\n", selem_name, mapped_volume, level);

    // 关闭混音器
    snd_mixer_close(handle);
#endif
    return 0;
}
```

