# Linux移植

默认的配置文件记录在`/arch/arm/configs`文件夹下面, 官方使用的是`imx_v7_mfg_defconfig`这个文件, 这个文件是适配了官方烧录工具的

可以直接使用官方的文件进行编译获取到zImage文件, 以及/arch/arm/boot/dts/imx6ulll-14-14-evk-emmc.dtb文件进行启动

在实际启动之前需要设置一下bootargs这个参数

```bash
console=ttymxc0,115200 root=/dev/mmcblk1p2 rootwait rw 
```

## 移植

在移植的时候, 把配置文件以及设备树文件复制一份

配置文件里面的`CONFIG_ARCH_MULTI_V6=y`删除, 因为这个板子使用的ARMV7

在`/arch/arm/boot/dts/Makefile`文件里面添加自己使用的设备树文件

### 设置CPU频率

目录/sys/bus/cpu/devices/cpu0/cpufreq可以查看CPU的各项属性

+ cpuinfo_cur_freq：当前 cpu 工作频率，从CPU寄存器读取到的工作频率。  

+ cpuinfo_max_freq：处理器所能运行的最高工作频率(单位: KHz）。 

+ cpuinfo_min_freq ：处理器所能运行的最低工作频率(单位: KHz）。  

+ cpuinfo_transition_latency：处理器切换频率所需要的时间(单位:ns)。  

+ scaling_available_frequencies：处理器支持的主频率列表(单位: KHz）。  

+ scaling_available_governors：当前内核中支持的所有governor(调频)类型。  

+ scaling_cur_freq：保存着 cpufreq 模块缓存的当前 CPU 频率，不会对 CPU 硬件寄存器进 行检查。 

+ scaling_driver：该文件保存当前CPU所使用的调频驱动。  

+ scaling_governor：governor(调频)策略，Linux 内核一共有 5中调频策略， 

> ①、Performance，最高性能，直接用最高频率，不考虑耗电。   ②、Interactive，一开始直接用最高频率，然后根据CPU负载慢慢降低。   ③、Powersave，省电模式，通常以最低频率运行，系统性能会受影响，一般不会用这个！ ④、Userspace，可以在用户空间手动调节频率。   ⑤、Ondemand，定时检查负载，然后根据负载来调节频率。负载低的时候降低CPU频率， 这样省电，负载高的时候提高CPU频率，增加性能。
>
> 这几种策略可以在配置文件里面进行使能, 使能以后才可以使用, 也可以设置默认的模式

+  scaling_max_freq：governor(调频)可以调节的最高频率。  

+  cpuinfo_min_freq：governor(调频)可以调节的最低频率。

​    可以在图形化界面的`CPU Power Management -> CPU Frequency scaling`里面进行配置

    ### 8线EMMC

驱动里面EMMC默认是4线模式的，4线模式肯定没有8线模式的速度快，所 以本节我们将EMMC的驱动修改为8线模式

```json
&usdhc2 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_usdhc2>;
	non-removable;
	no-1-8-v;
	status = "okay";
};
```

使用的引脚配置是

```json
pinctrl_usdhc2: usdhc2grp {
    fsl,pins = <
        MX6UL_PAD_NAND_RE_B__USDHC2_CLK     0x10069
        MX6UL_PAD_NAND_WE_B__USDHC2_CMD     0x17059
        MX6UL_PAD_NAND_DATA00__USDHC2_DATA0 0x17059
        MX6UL_PAD_NAND_DATA01__USDHC2_DATA1 0x17059
        MX6UL_PAD_NAND_DATA02__USDHC2_DATA2 0x17059
        MX6UL_PAD_NAND_DATA03__USDHC2_DATA3 0x17059
    >;
};
```

改为设置

```json
&usdhc2 {
    pinctrl-names = "default", "state_100mhz", "state_200mhz";
    pinctrl-0 = <&pinctrl_usdhc2_8bit>;
    pinctrl-1 = <&pinctrl_usdhc2_8bit_100mhz>;
    pinctrl-2 = <&pinctrl_usdhc2_8bit_200mhz>;
    bus-width = <8>;
    non-removable;
    status = "okay";
};
```

由于之前的节点里面有`no-1-8-v; `所以实际还是不会使用1.8v进行驱动的

### 网络驱动

引脚的属性设置为

```json
pinctrl_spi4: spi4grp {
        fsl,pins = <
                MX6ULL_PAD_BOOT_MODE0__GPIO5_IO10        0x70a1
                MX6ULL_PAD_BOOT_MODE1__GPIO5_IO11        0x70a1
                MX6ULL_PAD_SNVS_TAMPER7__GPIO5_IO07      0x70a1
                MX6ULL_PAD_SNVS_TAMPER8__GPIO5_IO08      0x80000000
        >;
};
```

需要GPIO5_IO07和GPIO5_IO08分别作为ENET1和ENET2的复位引脚，而不 是SPI4的功能引脚, 删除下面的两个设置

```json
spi4 {
    compatible = "spi-gpio";
    pinctrl-names = "default";
    pinctrl-0 = <&pinctrl_spi4>;
    pinctrl-assert-gpios = <&gpio5 8 GPIO_ACTIVE_LOW>;
    status = "disabled";
    gpio-sck = <&gpio5 11 0>;
    gpio-mosi = <&gpio5 10 0>;
    cs-gpios = <&gpio5 7 0>;
    num-chipselects = <1>;
    #address-cells = <1>;
    #size-cells = <0>;

    gpio_spi: gpio_spi@0 {
        compatible = "fairchild,74hc595";
        gpio-controller;
        #gpio-cells = <2>;
        reg = <0>;
        registers-number = <1>;
        registers-default = /bits/ 8 <0x57>;
        spi-max-frequency = <100000>;
    };
};
```

这里面使用这两个引脚的配置也要删除

设置为

```json
pinctrl_fec1_reset: fec1_resetgrp {
    fsl,pins = <
        MX6ULL_PAD_SNVS_TAMPER7__GPIO5_IO07	0x79
    >;
};

pinctrl_fec2_reset: fec2_resetgrp {
    fsl,pins = <
        MX6ULL_PAD_SNVS_TAMPER8__GPIO5_IO08	0x79
    >;
};
```

设置一下时钟引脚的配置

```json
pinctrl_enet1: enet1grp {
    fsl,pins = <
        MX6UL_PAD_ENET1_RX_EN__ENET1_RX_EN	0x1b0b0
        MX6UL_PAD_ENET1_RX_ER__ENET1_RX_ER	0x1b0b0
        MX6UL_PAD_ENET1_RX_DATA0__ENET1_RDATA00	0x1b0b0
        MX6UL_PAD_ENET1_RX_DATA1__ENET1_RDATA01	0x1b0b0
        MX6UL_PAD_ENET1_TX_EN__ENET1_TX_EN	0x1b0b0
        MX6UL_PAD_ENET1_TX_DATA0__ENET1_TDATA00	0x1b0b0
        MX6UL_PAD_ENET1_TX_DATA1__ENET1_TDATA01	0x1b0b0
        MX6UL_PAD_ENET1_TX_CLK__ENET1_REF_CLK1	0x4001B009
    >;
};

pinctrl_enet2: enet2grp {
    fsl,pins = <
        MX6UL_PAD_GPIO1_IO07__ENET2_MDC		0x1b0b0
        MX6UL_PAD_GPIO1_IO06__ENET2_MDIO	0x1b0b0
        MX6UL_PAD_ENET2_RX_EN__ENET2_RX_EN	0x1b0b0
        MX6UL_PAD_ENET2_RX_ER__ENET2_RX_ER	0x1b0b0
        MX6UL_PAD_ENET2_RX_DATA0__ENET2_RDATA00	0x1b0b0
        MX6UL_PAD_ENET2_RX_DATA1__ENET2_RDATA01	0x1b0b0
        MX6UL_PAD_ENET2_TX_EN__ENET2_TX_EN	0x1b0b0
        MX6UL_PAD_ENET2_TX_DATA0__ENET2_TDATA00	0x1b0b0
        MX6UL_PAD_ENET2_TX_DATA1__ENET2_TDATA01	0x1b0b0
        MX6UL_PAD_ENET2_TX_CLK__ENET2_REF_CLK2	0x4001B009
    >;
};
```

这两个属性放在`fec1`和`fec2`里面

```json
&fec2 {
	pinctrl-names = "default";
	pinctrl-0 = <&pinctrl_enet2
		     &pinctrl_fec2_reset>;
	phy-mode = "rmii";
	phy-handle = <&ethphy1>;
	phy-reset-gpios = <&gpio5 8 GPIO_ACTIVE_LOW>;
	phy-reset-duration = <200>;
	status = "okay";

	mdio {
		#address-cells = <1>;
		#size-cells = <0>;

		ethphy0: ethernet-phy@2 {
			compatible = "ethernet-phy-ieee802.3-c22";
			reg = <2>;
		};

		ethphy1: ethernet-phy@1 {
			compatible = "ethernet-phy-ieee802.3-c22";
			reg = <1>; 
		};
	};
};
```

使用mdio记录的是ENET1 和ENET2的PHY地址信息, ethernet-phy@后面的数字是PHY地址, 修改以后通用的驱动已经是可以使用的了, 但是为了稳定, 需要设置以下的 内容

修改驱动文件`drivers/net/ethernet/freescale/fec_main.c`

在函数`fec_probe`里面添加

```c
IMX6U_ENET1_TX_CLK = ioremap(0x020E00DC, 4);
writel(0x14, IMX6U_ENET1_TX_CLK);

IMX6U_ENET2_TX_CLK = ioremap(0x020E00FC, 4);
writel(0x14, IMX6U_ENET2_TX_CLK);
```

这两个设置引脚复位寄存器的SION位为1

在图形界面里面把`Device Drivers => Network device support => PHY Device support and infrastructure => Device for SMSC PHYs`

SMSC是我们使用的芯片的生产厂商
