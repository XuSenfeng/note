# Systemd

历史上，[Linux 的启动](http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html)一直采用[`init`](https://en.wikipedia.org/wiki/Init)进程。

下面的命令用来启动服务。

> ```bash
> $ sudo /etc/init.d/apache2 start
> # 或者
> $ service apache2 start
> ```

这种方法有两个缺点。

一是启动时间长。`init`进程是串行启动，只有前一个进程启动完，才会启动下一个进程。

二是启动脚本复杂。`init`进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。

systemd 不是一个命令，而是一组命令的集合，提供了一个系统和服务管理器，运行为PID1并负 责启动其它程序

> 提高系统启动速度、简化服务管理，并提供更多功能
>
> 根据 Linux 惯例，字母`d`是守护进程（daemon）的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。使用了 Systemd，就不需要再用`init`了。Systemd 取代了`initd`，成为系统的第一个进程（PID 等于 1）

![image-20251002112100504](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510021121582.png)

systemd 功能包括：

+ 支持并行化任务；
+ 同时采用socket式与D-Bus总线式激活服务；
+ 按需启动守 护进程（daemon）；
+ 利用Linux 的 cgroups 监视进程；
+ 支持快照和系统恢复；
+ 维护挂载点和自动 挂载点；
+ 各服务间基于依赖关系进行精密控制。
+ systemd支持SysV和LSB初始脚本，可以替代 sysvinit。
+ 日志进程、控制基础系统配置，维护登陆用户列表以及系统账户、 运行时目录和设置，可以运行容器和虚拟机，可以简单的管理网络配置、网络时间同步、日志转 发和名称解析等。

## 常用命令

### 常用命令使用示例

**服务管理**：

```bash
# 启动服务
systemctl start nginx.service

# 停止服务
systemctl stop nginx.service

# 重启服务
systemctl restart nginx.service

# 查看服务状态
systemctl status nginx.service
```

**启动项管理**：

```bash
# 开机自动启动
systemctl enable nginx.service

# 禁止开机启动
systemctl disable nginx.service

# 查看服务是否开机自启
systemctl is-enabled nginx.service
```

**查看系统状态**：

```bash
# 查看所有运行的服务
systemctl list-units --type=service

# 查看当前的启动目标
systemctl get-default

# 设置启动目标为多用户模式
systemctl set-default multi-user.target
```

**日志管理**：

```bash
# 查看系统日志
journalctl

# 查看特定服务日志
journalctl -u nginx.service

# 按时间范围查看日志
journalctl --since "2025-01-01" --until "2025-01-14"
```

### systemctl

`systemctl`是 Systemd 的主命令，用于管理系统。

> ```bash
> #输出激活的单元
> $ systemctl
> 
> # 显示系统状态
> $ systemctl status -l
> 
> # 输出运行失败的单元
> $ systemctl--failed
> 
> # 重启系统
> $ sudo systemctl reboot
> 
> # 关闭系统，切断电源
> $ sudo systemctl poweroff
> 
> # CPU停止工作
> $ sudo systemctl halt
> 
> # 暂停系统
> $ sudo systemctl suspend
> 
> # 让系统进入冬眠状态
> $ sudo systemctl hibernate
> 
> # 让系统进入交互式休眠状态
> $ sudo systemctl hybrid-sleep
> 
> # 启动进入救援状态（单用户状态）
> $ sudo systemctl rescue
> ```

### systemd-analyze

`systemd-analyze`命令用于查看启动耗时。

> ```bash
> # 查看启动耗时
> $ systemd-analyze                                                                                 
> 
> # 查看每个服务的启动耗时
> $ systemd-analyze blame
> 
> # 显示瀑布状的启动过程流
> $ systemd-analyze critical-chain
> 
> # 显示指定服务的启动流
> $ systemd-analyze critical-chain atd.service
> ```

### hostnamectl

`hostnamectl`命令用于查看当前主机的信息。

> ```bash
> # 显示当前主机的信息
> $ hostnamectl
> 
> # 设置主机名。
> $ sudo hostnamectl set-hostname rhel7
> ```

### localectl

`localectl`命令用于查看本地化设置。

通过与systemd localed.service(8)通信来修改例如/etc/locale.conf与/etc/vconsole.conf之类的配置文件。本地化设 置控制着用户界面的语言、字符类型与字符编码、日期时间与货币符号的表达方式等许多细节

> ```bash
> # 查看本地化设置
> $ localectl
> 
> # 设置本地化参数。
> $ sudo localectl set-locale LANG=en_GB.utf8
> $ sudo localectl set-keymap en_GB
> ```

### timedatectl

`timedatectl`命令用于查看当前时区设置。

> ```bash
> # 查看当前时区设置
> $ timedatectl
> 
> # 显示所有可用的时区
> $ timedatectl list-timezones                                                                                   
> 
> # 设置当前时区
> $ sudo timedatectl set-timezone America/New_York
> $ sudo timedatectl set-time YYYY-MM-DD
> $ sudo timedatectl set-time HH:MM:SS
> 
> 
> # 关闭网络时间同步
> timedatectl set-ntp no
> # 开启网络时间同步
> timedatectl set-ntp yes
> # 设置时间和日期
> timedatectl set-time 9:40:20
> timedatectl set-time 2021-4-16
> ```

### loginctl

`loginctl`命令用于查看当前登录的用户。

> ```bash
> # 列出当前session
> $ loginctl list-sessions
> 
> # 列出当前登录用户
> $ loginctl list-users
> 
> # 列出显示指定用户的信息
> $ loginctl show-user ruanyf
> 
> 
> # 显示所有会话及属性
> loginctl-a
>  # 显示会话配置消息
> loginctl show-session
>  # 列出显示指定用户的信息
> loginctl show-user root
> ```

## 核心概念

### unit

#### 简介

单元，单元文件是ini风格的纯文本文件，Systemd可以管理所有系统资源，不同的资源统称为 Unit（单位）。其封装了12种对象的信息：服务(service)、套接字(socket)、设备(device)、挂载点 (mount)、自动挂载点(automount)、启动目标(target)、交换分区或交换文件(swap)、被监视的路径 (path)、任务计划(timer)、资源控制组(slice)、一组外部创建的进程(scope)、快照(snapshot)

+  **service**：一个后台服务进程，其封装了守护进程的启动、停止、重启与重载等操作。
+  **socket**：此类配置单元封装系统和互联网中的一个套接字。当下，systemd支持流式，数据 报和连续包的AF_INET，AF_INET6，AF_UNIX socket。每个套接字配置单元都有一个相应 的服务配置单元，相应的服务在第一个“连接”进入套接字时就会启动（例如：nscd.socket 在有新连接后便启动nscd.service），监控系统或者网络的数据信息。
+ **device**：此类配置单元封装一个存在于Linux设备树中的设备。每个使用udev规则标记的 设备都将会在systemd中作为一个设备配置单元出现，定义设备之间的依赖关系
+ **mount**：此类配置单元封装文件系统结构层次中的一个挂载点。systemd将对这个挂载点进 行监控和管理。比如，可以在启动时自动将其挂载，可以在某些条件下自动卸载。systemd 会将/etc/fstab 中的条目都转换为挂载点，并在开机时处理。
+ **automount**：此类配置单元封装系统结构层次中的一个自挂载点。每个自挂载配置单元对应 一个挂载配置单元，当该自动挂载点被访问时，systemd执行挂载点中定义的挂载行为
+ **Swap**：和挂载配置单元类似，交换配置单元用来管理交换分区。用户可以用交换配置单元 来定义系统中的交换分区，可以让这些交换分区在启动时被激活
+ **target**：此类配置单元为其他配置单元进行逻辑分组。它们本身实际上并不做什么，只是引 用其他配置单元而已，这样便可以对配置单元做一个统一的控制，就可以实现大家都非常 熟悉的运行级别的概念。比如，想让系统进入图形化模式，需要运行许多服务和配置命令， 这些操作都由一个个的配置单元表示，将所有的这些配置单元组合为一个目标（target）， 就表示需要将这些配置单元全部执行一遍，以便进入目标所代表的系统运行状态
+  **timer**：定时器配置单元用来定时触发用户定义的操作。这类配置单元取代了atd，crond等 传统的定时服务。
+ **snapshot**：与 target 配置单元相似，快照是一组配置单元，它保存了系统当前的运行状态
+ **slice**：表示一个CGroup的树。
+ **path**：监控指定目录或文件的变化，并触发其它Unit的运行。
+ **scope**：它用于描述一些系统服务的分组信息。

每个配置单元都有一个对应的配置文件，比如一个 avahi-daemon 服务对应一个 avahi daemon.service 文件。这种配置文件的语法非常简单，用户不需要再编写和维护复杂的 sysv 脚 本

#### 查询命令

```bash
# 列出正在运行的 Unit
systemctl list-units
# 列出所有 Unit，包括没有找到配置文件的或者启动失败的
systemctl list-units--all
# 列出所有没有运行的 Unit
systemctl list-units--all--state=inactive
# 列出所有加载失败的 Unit
systemctl list-units--failed
# 列出所有正在运行的、类型为 service 的 Unit
systemctl list-units--type=service
# 显示某个 Unit 是否正在运行
systemctl is-active systemd-timesyncd.service
#显示某个Unit服务是否建立了启动链接
systemctlis-enabledsystemd-timesyncd.service
```

#### 管理命令

```bash
#立即启动一个服务
$ sudo systemctl startbootlogo.service
#立即停止一个服务
$ sudo systemctl stopbootlogo.service
#重启一个服务
$ sudo systemctl restartbootlogo.service
#杀死一个服务的所有子进程
$ sudo systemctl killbootlogo.service
#重新加载一个服务的配置文件
$ sudo systemctl reloadbootlogo.service
#重载所有修改过的配置文件
$ sudo systemctl daemon-reload
#显示某个Unit的所有底层参数
$ systemctlshow httpd.service
# 显示某个 Unit 的指定属性的值
$ systemctl show-p CPUShares avahi-daemon.service
# 设置某个 Unit 的指定属性
$ sudo systemctl set-property avahi-daemon.service CPUShares=500
```

#### 依赖

存在一些任务，它 们之间存在天生的依赖关系，不能用“套接字激活”（socketactivation）,D-Busactivation和autofs 三大方法来解除依赖

systemd的配置单元之间可以彼此定义依赖关系。比 如，unit Q 依赖unit W，可以在unitW的定义中用“requireQ”来表示，这样systemd就会保证 先启动Q再启动W。systemd能保证事务完整性。

若存在循环依赖，那么systemd将无法启 动任意一个服务。此时，systemd将会尝试解决这个问题，因为配置单元之间的依赖关系有两种： `requireds` 为强依赖，`wants` 为弱依赖，systemd 将去掉wants 关键字指定的依赖看看是否能打破循环。如果无法修复，systemd会报错。systemd能够自动检测和修复这类配置错误，极大地减轻了 管理员的拔锚负担

```bash
# 命令列出一个 Unit 的所有依赖
$ systemctl list-dependencies avahi-daemon.service
# 命令列出一个 Unit 的所有依赖，并展开显示 Target 依赖类型
$ systemctl list-dependencies--all avahi-daemon.service
```

#### 配置文件

systemd 的配置文件默认会存放于文件系统中的/etc/systemd/system 或/usr/lib/systemd/system 目录下

初始化 过程中systemd只执行/etc/systemd/system 目录里面的配置文件。当你安装完systemd程序之后，他 会自动的在/lib/systemd/system 目录下生成一个与该程序对应的配置文件。

你可以使用“systemctl enable xxx.service”的方式来建立一个服务软链接，若设置了开机启动，则“systemctlenable”相当 于使能开机启动，而“systemctldisable”命令与之相反，他会断开软链接，所以开机就不会启动

+ ssh的server文件, /etc/systemd/system/sshd.service

```
[Unit]
Description=OpenBSD Secure Shell server
After=network.target auditd.service
ConditionPathExists=!/etc/ssh/sshd_not_to_be_run

[Service]
EnvironmentFile=-/etc/default/ssh
ExecStartPre=/usr/sbin/sshd -t
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/usr/sbin/sshd -t
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure
RestartPreventExitStatus=255
Type=notify
RuntimeDirectory=sshd
RuntimeDirectoryMode=0755

[Install]
WantedBy=multi-user.target
Alias=sshd.service
```

+ Unit

+ + **Description **描述了当前服务
    + **After** 字段，它指定了服务的启动顺序，但是不涉及依赖关系, 表示的是当前服务需要在network.target及auditd.service 两个服 务之后启动。而Wants和Requires字段只涉及依赖关系，他与启动顺序是无关的，默认为同时启 动。如果想要设置服务之间的依赖关系，及使用Wants和Requires字段即可，Wants为“弱依赖”， Requires 为“强依赖”。
    + **ConditionPathExists**: 条件检查，如果存在 `/etc/ssh/sshd_not_to_be_run` 文件，则不运行此服务（用于临时禁用 SSH）

+ [Service]

+ + **EnvironmentFile**: 从 `/etc/default/ssh` 文件加载环境变量（`-` 表示文件不存在时不报错）
    + **ExecStartPre**: 服务启动前执行的命令，`sshd -t` 用于测试配置文件语法
    + **ExecStart**: 主服务启动命令，`-D` 表示前台运行，`$SSHD_OPTS` 来自环境变量文件, 其中的变量 $SSHD_OPTS 就是来自于EnvironmentFile 字段所指定的环境参数文件
    + **ExecReload**: 有两个重载命令：
        - 先执行 `sshd -t` 测试配置语法
        - 然后向主进程发送 HUP 信号重新加载配置
    + **KillMode=process**: 只杀死主进程，不杀死整个进程组
    + **Restart=on-failure**: 服务失败时自动重启

    > + no（默认值）：退出后不会重启
    > + on-success：只有正常退出时（退出状态码为0），才会重启
    > + on-failure：非正常退出时（退出状态码非0），包括被信号终止和超时，才会重启
    > + on-abnormal：只有被信号终止和超时，才会重启
    > + on-abort：只有在收到没有捕捉到的信号终止时，才会重启
    > + on-watchdog：超时退出，才会重启
    > + always：不管是什么退出原因，总是重启

    + **RestartPreventExitStatus=255**: 退出状态为 255 时不重启
    + **Type=notify**: 服务启动完成后会通知 systemd
    + **RuntimeDirectory**: 在 `/run` 下创建 sshd 运行时目录
    + **RuntimeDirectoryMode**: 设置运行时目录权限为 755

+ [Install]

+ + **WantedBy**: 表示当前服务所在的 Target,Target 表示的是服务组, 它是一组服务的集合，用于定义系统的特定状态, 指定该服务在 multi-user.target 启动时自动启用

    > | Target                | 对应运行级别 | 描述                           |
    > | :-------------------- | :----------- | :----------------------------- |
    > | **graphical.target**  | 运行级别 5   | 图形界面模式                   |
    > | **rescue.target**     | 运行级别 1   | 单用户救援模式                 |
    > | **emergency.target**  | 运行级别 0   | 紧急模式                       |
    > | **poweroff.target**   | -            | 关机                           |
    > | **reboot.target**     | -            | 重启                           |
    > | **multi-user.target** | 运行级别 3   | 多用户命令行模式（非图形界面） |
    >
    > 依赖关系: local-fs.target → swap.target → sysinit.target → basic.target → multi-user.target → graphical.target
    >
    > ```bash
    > # 设置默认 Target（重启后生效）
    > sudo systemctl set-default multi-user.target
    > 
    > # 立即切换到另一个 Target（不重启）
    > sudo systemctl isolate multi-user.target
    > ```
    >
    > 

    + **Alias**: 服务别名，可以通过 `sshd.service` 名称引用

| 执行阶段                      | 命令示例                                            | 作用                                                         | 设计考量                                                     |
| :---------------------------- | :-------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **启动前检查** (ExecStartPre) | `/usr/sbin/sshd -t`                                 | **语法检查**：解析并验证`sshd_config`等配置文件的语法是否正确，但不真正启动服务。 | 提前发现配置错误，避免因配置有误导致服务启动失败。           |
| **主进程启动** (ExecStart)    | `/usr/sbin/sshd -D $SSHD_OPTS`                      | **启动服务**： • `-D`：让`sshd`在前台运行，便于systemd监控。 • `$SSHD_OPTS`：来自`/etc/default/ssh`环境文件，用于传递额外启动参数。 | 前台运行是使用systemd管理服务的推荐方式。服务类型为`notify`，意味着服务启动完成后需要通知systemd。 |
| **配置重载** (ExecReload)     | 1. `/usr/sbin/sshd -t` 2. `/bin/kill -HUP $MAINPID` | **安全重载**： 1. **再次语法检查**，防止错误配置被加载。 2. 向主进程发送`HUP`信号，使其重新加载配置文件。 | 先检查后重载，确保服务配置的每一次变更都是安全且有效的。     |

> 如果我们修改了配置文件，就需要重新加载配置文件，然后重启该服务
>
> ```bash
> # 重新加载配置文件
> $ sudo systemctl daemon-reload
>  # 重启相关服务
> $ sudo systemctl restart ssh
> ```

##### 自定义示例

+ 一个简单的python示例

```c
[Unit]
Description=My Python Service
After=network.target

[Service]
Type=simple
User=www-data
Group=www-data
WorkingDirectory=/path/to/your/python/code
ExecStart=/usr/bin/python3 /path/to/your/python/code/app.py
Restart=always
RestartSec=5
Environment=PYTHONPATH=/path/to/your/python/code
Environment=PYTHONUNBUFFERED=1

[Install]
WantedBy=multi-user.target
```

```bash
sudo chmod 644 /etc/systemd/system/my_python_service.service
sudo systemctl daemon-reload
sudo systemctl start my_python_service
sudo systemctl enable my_python_service  # 开机自启
# 日志
sudo systemctl status my_python_service
sudo journalctl -u my_python_service -f  # 实时日志
```

+ 脚本

创建一个脚本文件

```bash
#!/bin/bash
while true
do
    echo Hello Embedfire >> /tmp/hello.log
    sleep 3
done
```

`sudo chmod 0755 hello.sh`

创建配置文件

```
[Unit]
Description = hello daemon
[Service]
ExecStart = /opt/scripts/boot/hello.sh
Restart = always
Type = simple
[Install]
WantedBy = multi-user.target
```

```bash
sudo systemctl enable hello
sudo systemctl start hello
```

#### 系统配置

```bash
# 重启系统（异步操作）
$ systemctl reboot
# 关闭系统，切断电源（异步操作）
$ systemctl poweroff
 # 仅 CPU 停止工作，其他硬件仍处于开机状态（异步操作）
$ systemctl halt
 # 暂停系统（异步操作），执行 suspend.target
 $ systemctl suspend
 # 使系统进入冬眠状态（异步操作），执行 hibernate.target
 $ systemctl hibernate
```

#### 日志文件

可以只用`journalctl`一个命令，查看所 有日志（内核日志和应用日志）

日志配置文件位于/etc/systemd/journald.conf，其保存目录为/var/log/journal/ 默认情况下日志最大限 制为所在文件系统容量的10%，可通过/etc/systemd/journald.conf 中的 SystemMaxUse 字段来指定 日志最大限制

```bash
 # 指定日志文件占据的最大空间
$ sudo journalctl--vacuum-size=8M
```

