# RTC

RTC设备驱动是一个标准的字符设备驱动，应用程序通过 open、release、read、write和ioctl等函数完成对RTC设备的操作

Linux内核将 RTC设备抽象为`rtc_device`结构体，因此 RTC设备驱动就是申请并初始化`rtc_device`

这个记录在设备树的snvs节点里面

```json

snvs_rtc: snvs-rtc-lp {
  compatible = "fsl,sec-v4.0-mon-rtc-lp";
  regmap = <&snvs>;
  offset = <0x34>;
  interrupts = <GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>, <GIC_SPI 20 IRQ_TYPE_LEVEL_HIGH>;
};
```

这个lp指的是指的是掉电以后还是有效的

根据这个配置可以找到对应的文件是`drivers/rtc/rtc-snvs.c`

## 驱动

关键的结构体是`rtc_device`, 这个结构体里面记录欧帕斯的变量是需要关注的重点, rtc_class_ops

```c
struct rtc_class_ops {
	int (*open)(struct device *);
	void (*release)(struct device *);
	int (*ioctl)(struct device *, unsigned int, unsigned long);
	int (*read_time)(struct device *, struct rtc_time *);
	int (*set_time)(struct device *, struct rtc_time *);
	int (*read_alarm)(struct device *, struct rtc_wkalrm *);
	int (*set_alarm)(struct device *, struct rtc_wkalrm *);
	int (*proc)(struct device *, struct seq_file *);
	int (*set_mmss64)(struct device *, time64_t secs);
	int (*set_mmss)(struct device *, unsigned long secs);
	int (*read_callback)(struct device *, int data);
	int (*alarm_irq_enable)(struct device *, unsigned int enabled);
};
```

初始化以后使用rtc_device_register函数进行注册这个结构体, 实际这侧的操作函数是`snvs_rtc_ops`结构体

```c
static const struct rtc_class_ops snvs_rtc_ops = {
	.read_time = snvs_rtc_read_time,
	.set_time = snvs_rtc_set_time,
	.read_alarm = snvs_rtc_read_alarm,
	.set_alarm = snvs_rtc_set_alarm,
	.alarm_irq_enable = snvs_rtc_alarm_irq_enable,
};
```

这部分的函数不是fileops直接控制的函数

这部分的调用在文件的`rtc_dev.c`文件里面, 所有RTC设备共用 file_operations函数操作集

![image-20251115172252707](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/mac-picture/image-20251115172252707.png)

rtc_dev_ioctl操作接口里面提供很多的操控命令, 相关的命令记录在`include/uapi/linux/rtc.h`文件里面

## 使用

可以使用`data`命令进行获取时间以及设置等操作, 使用`data -s`进行设置, 设置以后使用`hwclock -w`把时间记录在rtc芯片里面

