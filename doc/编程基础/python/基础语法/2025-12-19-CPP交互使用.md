# 调用CPP库

## CPP使用python代码

```python
def add(a: int, b: int):
    res = a + b
    return res

def sub(a: int, b: int):
    return a - b
```



```cpp
#include <Python.h>
#include <cstdint>
#include <iostream>

int32_t add_from_python(int32_t a, int32_t b, int32_t& res)
{
    // 获取使用的python文件
    PyObject* pModuleName = PyUnicode_FromString("py_math");
    if (!pModuleName)
    {
        PyErr_Print();
        return -1;
    }
    // 导入模块
    PyObject* pModule = PyImport_Import(pModuleName);
    if (!pModule)
    {
        PyErr_Print();
        Py_DECREF(pModuleName);
        return -1;
    }

    /* great_module.great_function */
    PyObject* pFunc = PyObject_GetAttrString(pModule, "add");
    if (!pFunc || !PyCallable_Check(pFunc))
    {
        PyErr_Print();
        Py_DECREF(pModule);
        Py_DECREF(pModuleName);
        return -1;
    }

    // 设置参数
    PyObject* pArgs = PyTuple_Pack(
        2, 
        PyLong_FromLong(a), 
        PyLong_FromLong(b)
    );
    if (!pArgs)
    {
        PyErr_Print();
        Py_DECREF(pFunc);
        Py_DECREF(pModule);
        Py_DECREF(pModuleName);
        return -1;
    }

    // 调用函数
    PyObject* pValue = PyObject_CallObject(pFunc, pArgs);
    if (!pValue)
    {
        PyErr_Print();
        Py_DECREF(pFunc);
        Py_DECREF(pModule);
        Py_DECREF(pModuleName);
        return -1;
    }

    // 获取结果
    res = PyLong_AsLong(pValue);
    Py_DECREF(pValue);
    Py_DECREF(pFunc);
    Py_DECREF(pModule);
    Py_DECREF(pModuleName);
    return 0;
}

int main()
{
    // 1. 初始化 Python 解释器
    Py_Initialize();
    // 2. 调用 Python 代码
    int32_t result = 0;
    auto ret = add_from_python(3, 2, result);
    if (ret < 0)
    {
        std::cerr << "add_from_python error ret:" << ret << std::endl;
    }
    else
    {
        std::cout << "3 + 2 = " << result << std::endl;
    }
    // 3. 结束 Python 解释器
    Py_Finalize();
    return 0;
}
```

### 编译文件

```bash
g++ -g cpp_call_python.cpp \
  -o cpp_call_python \
  -I/Users/jiao/miniconda3/include/python3.9 \
  -L/Users/jiao/miniconda3/lib \
  -Wl,-rpath,/Users/jiao/miniconda3/lib \
  -lpython3.9
```

由于使用的文件是在.目录下面的, 所以需要设置环境变量

```bash
export PYTHONPATH=.:$PYTHONPATH
```

-   `-I/Users/jiao/miniconda3/include/python3.9`
    把这个目录加入“头文件搜索路径”。
    这样 `#include <Python.h>` 时，编译器会在这个目录里找到 `Python.h`。
-   `-L/Users/jiao/miniconda3/lib`
    把这个目录加入“库文件搜索路径”。
    链接 `-lpython3.9` 时，会在这里寻找 `libpython3.9.dylib` / `libpython3.9.a`。
-   `-Wl,-rpath,/Users/jiao/miniconda3/lib`
    `-Wl,` 表示“把后面的选项传给链接器（ld）”。
    `-rpath,/Users/jiao/miniconda3/lib` 指定运行时库搜索路径（runtime library search path）。
    也就是把 [lib](vscode-file://vscode-app/Applications/Visual Studio Code.app/Contents/Resources/app/out/vs/code/electron-browser/workbench/workbench.html) 写进可执行文件里，程序运行时 dyld 会在这个目录里找 `libpython3.9.dylib`，解决你之前的 “Library not loaded: @rpath/libpython3.9.dylib” 问题。
-   `-lpython3.9`
    链接名为 `libpython3.9.*` 的库文件（`lib` 前缀和 `.dylib/.a` 后缀省略）。
    这是把 Python 解释器“嵌入”进你的 C++ 程序

## python调用CPP

```python
from cpp_math import add

print("3 + 2 =", add(3, 2))
```

```cpp
#include <Python.h>
#include <cstdint>
#include <iostream>

int32_t add(int32_t a, int32_t b)
{
    return a + b;
}

static PyObject* _add(PyObject* self, PyObject* args)
{
    int32_t _a;
    int32_t _b;
    int32_t res;

    // 将Python的参数转换为C++的参数
    if (!PyArg_ParseTuple(args, "ii", &_a, &_b))
        return NULL;
    // 调用add函数
    res = add(_a, _b);
    // 将C++的返回值转换为Python的返回值
    return PyLong_FromLong(res);
}

static PyMethodDef MathModuleMethods[] = { { "add", _add, METH_VARARGS, "" },
                                           { NULL, NULL, 0, NULL } };

static struct PyModuleDef MathModule = { PyModuleDef_HEAD_INIT,
 "cpp_math", // 模块名称
 NULL,       // 模块文档
 -1,         // 模块状态
 MathModuleMethods };

// (C扩展)模块初始化
PyMODINIT_FUNC PyInit_cpp_math(void)
{
    // 创建模块对象
    return PyModule_Create(&MathModule);
}
```

### 编译

```bash
g++ -std=c++11 -fPIC -shared cpp_math.cpp -o cpp_math.so \
  -I/Users/jiao/miniconda3/include/python3.9 \
  -undefined dynamic_lookup
```

-   `g++`使用 C++ 编译器（和 `gcc` 相比，自动按 C++ 规则编译、链接 C++ 标准库）。
-   `-std=c++11`选择 C++ 语言标准（可换成 `c++14`、`c++17` 等，不加也通常能编，但推荐写清楚）。
-   `-fPIC`生成“位置无关代码”（Position Independent Code），这是做共享库/动态库时必须的，否则 `.so` 被加载时会有问题。
-   `-shared`告诉编译器“生成共享库”，而不是普通可执行文件。
    结果就是一个可以被 Python `import` 或 `ctypes.CDLL` 加载的cpp_math.so。
-   `-I/Users/jiao/miniconda3/include/python3.9`
    把 Python 头文件目录加入“头文件搜索路径”，这样 `#include <Python.h>` 时能找到头文件。如果你的 C++ 代码里完全没用到 `<Python.h>`，这项是可选的。
-   `-undefined dynamic_lookup`（macOS 特有，做 Python 扩展时很常用）允许链接时保留“未解析的符号”，等到模块被 Python 加载时，再从 Python 解释器里解析这些符号。