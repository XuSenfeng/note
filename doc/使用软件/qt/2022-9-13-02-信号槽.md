---
layout: post
title: "信号槽" 
date:   2022-9-13 15:39:08 +0800
tags: qt
---

# 信号槽

​				**发送者**\==> **信号**\==> **接收者**\==>**槽**(执行的动作)

槽(Slot)就是一个函数，一般和信号(Signal)函数相关联， 信号发生的时候槽函数会被执行

优势: 松散耦合

信号的发送接收本来没有关系, 使用函数`QObject::connect(sender, SIGNAL(signal()), receiver, SLOT(slot())); `进行连接

> connect() 是 QObject 类的一个静态函数，而 QObject 是所有 Qt 类的基类，在实际调用 时可以忽略前面的限定符

信号只用声明不用定义，但是槽需要定义, SIGNAL 和 SLOT 是 Qt 的宏，用于指明信号和槽，并将它们的参数转换为相应的字符串。

当信号和槽函数带有参数时，在 connect()函数里，要写明参数的类型，但可以不写参数名称, 严格的情况下，信号与槽的参数个数和类型需要一致，至少信号的参数不能少于槽的参数。 如果不匹配，会出现编译错误或运行错误

> 在使用信号与槽的类中，必须在类的定义中加入宏 Q_OBJECT

当一个信号被发射时，与其关联的槽函数通常被立即执行，就像正常调用一个函数一样。 只有当信号关联的所有槽函数执行完毕后，才会执行发射信号处后面的代码

断开连接可以使用`bool QObject::disconnect(const QObject *sender, const char *signal, const QObject *receiver, const  char *method) `

> 这个函数的参数传0表示这个参数可以填的所有对象全部断开

一个**信号**可以连接**多个槽**， 一个**槽**可以连接**多个信号**， 一个**信号**可以连接**另一个信号**

```c++
button =new QPushButton(this);
button->setText("我是傻逼");
button->setGeometry(50, 50, 50, 25);
this->resize(1024, 600);
```

>   设置按钮， 设置窗口

```c++
void (Teacher:: *teacherSignal)(QString) = &Teacher::hungry;
void (Student:: *studentSignal)(QString) = &Student::treat;
connect(zt, teacherSignal, st, studentSignal);
```

>   使用函数的重载的时候调用的函数, 使用函数指针进行重载, 槽函数和信号函数的参数类型是需要进行匹配, 信号参数的数量需要比槽函数的数量多

信号连接亦可以断开

```c
disconnect()
```

>   参数和上面一样

## 使用

### 图形界面

![image-20251229195704649](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202512291957792.png)

![image-20251229195803617](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202512291958659.png)

也可以使用连线的方式创建

![image-20251229195954081](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202512291959128.png)

![image-20251229200053730](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202512292000783.png)

> 退出是点击编辑控件的按钮, 在进入槽的左边

### 图形自定义槽函数

右键=>转到槽

![image-20251229200451091](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202512292004145.png)

```cpp
void MainWindow::on_pushButton_clicked()
{
    qDebug()  << "hello world" << Qt::endl;
}
```

> 自动生成的文件在`#include "ui_mainwindow.h"`里面, 实际是定义了一个`class Ui_MainWindow`, 里面定义setupUi进行界面的初始化,最后交给UI命名空间里面的MainWindow
>
> ```cpp
> namespace Ui {
>     class MainWindow: public Ui_MainWindow {};
> } // namespace Ui
> ```
>
> 所以可以使用ui对象进行引用界面里面创建的

### 代码连接

可以使用的槽函数可以在手册里面查找

![image-20251229203047312](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202512292030391.png)

```cpp
connect(ui->pushButton, SIGNAL(clicked()), this, SLOT(close()));
```

这个是使用代码的方式进行连接

### 代码自定义

![image-20251229204127525](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202512292041620.png)

![image-20251229204209009](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202512292042082.png)

+   信号

```c++
#include <QObject>

class School : public QObject
{
    Q_OBJECT
public:
    explicit School(QObject *parent = nullptr);

signals:    //信号关键字, 自定义的信号写在这里
    //信号, 没有返回值, 只需要声明不需要实现, 可以有参数, 可以重载
    void send_messages();	
};
```

+   槽

```c++
class Student : public QObject
{
    Q_OBJECT
public:
    explicit Student(QObject *parent = nullptr);

signals:
//槽的关键字, 早期的版本必须写在这里, 现在可以写在public
public slots:
    //槽实现函数, 返回值是void, 可以有参数, 可以发生重载
    void comeBackToClass();
};
```

+   注册以及发送信号

```c++
//这里使用的是Qt4的连接方法, 连接的是没有参数的两个函数, 编译器不会进行检查
connect(school, SIGNAL(send_messages()), student, SLOT(comeBackToClass()));

//实际上就是传递函数的地址
//connect(myBtn, &QPushButton::clicked, this, &myVidget::close);

emit school->send_messages();	//实际产生信号
```

>   四个参数就是上面的四个结构

在实际打印的时候由于`QString`类型的参数会打印出一个双引号, 所以需要进行一个类型的装换, 转换为char *

```c++
foodName.toUtf8().data()
```

>   首先转换为QByteArray类型, 之后再次转换

