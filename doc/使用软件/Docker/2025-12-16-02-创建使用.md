# 创建使用

## 标准可复现方法

1.   创建一个Dockerfile
2.   使用Dockerfile创建镜像
3.   使用镜像创建运行容器

### Dockerfile

是一个文本文件, 告诉docker如何创建镜像, 一般有操作系统, 运行时候的环境, 应用的环境, 应用程序的配置文件

```dockerfile
FROM python:3.11
COPY ./main.py /app/main.py
WORKDIR /app
CMD ["python", "main.py"]
```

使用命令创建镜像

```bash
docker build -t hellodocker .
```

+   -t: 指定名字
+   .: 上下文路径，是指 docker 在构建镜像，有时候想要使用到本机的文件（比如复制），docker build 命令得知这个路径后，会将路径下的所有内容打包。

>   **解析**：由于 docker 的运行模式是 C/S。我们本机是 C，docker 引擎是 S。实际的构建过程是在 docker 引擎下完成的，所以这个时候无法用到我们本机的文件。这就需要把我们本机的指定目录下的文件一起打包提供给 docker 引擎使用。
>
>   如果未说明最后一个参数，那么默认上下文路径就是 Dockerfile 所在的位置。
>
>   **注意**：上下文路径下不要放无用的文件，因为会一起打包发送给 docker 引擎，如果文件过多会造成过程缓慢。

```bash
docker images # 查看所有的镜像
docker run hellodocker
```

运行创建的镜像

![image-20251216144621584](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/mac-picture/image-20251216144621584.png)

### 常用属性

| Dockerfile 指令 | 说明                                                         |
| :-------------- | :----------------------------------------------------------- |
| FROM            | 指定基础镜像，用于后续的指令构建。                           |
| MAINTAINER      | 指定Dockerfile的作者/维护者。（已弃用，推荐使用LABEL指令）   |
| LABEL           | 添加镜像的元数据，使用键值对的形式。                         |
| RUN             | 在构建过程中在镜像中执行命令。                               |
| CMD             | 指定容器创建时的默认命令。（可以被覆盖）                     |
| ENTRYPOINT      | 设置容器创建时的主要命令。（不可被覆盖）                     |
| EXPOSE          | 声明容器运行时监听的特定网络端口。                           |
| ENV             | 在容器内部设置环境变量。                                     |
| ADD             | 将文件、目录或远程URL复制到镜像中。                          |
| COPY            | 将文件或目录复制到镜像中。                                   |
| VOLUME          | 为容器创建挂载点或声明卷。                                   |
| WORKDIR         | 设置后续指令的工作目录。                                     |
| USER            | 指定后续指令的用户上下文。                                   |
| ARG             | 定义在构建过程中传递给构建器的变量，可使用 "docker build" 命令设置。 |
| ONBUILD         | 当该镜像被用作另一个构建过程的基础时，添加触发器。           |
| STOPSIGNAL      | 设置发送给容器以退出的系统调用信号。                         |
| HEALTHCHECK     | 定义周期性检查容器健康状态的命令。                           |
| SHELL           | 覆盖Docker中默认的shell，用于RUN、CMD和ENTRYPOINT指令。      |

#### FROM

使用的容器的名字, 可以在https://hub.docker.com/查找可以使用的docker

#### RUN

运行命令, 可以直接跟命令, 也可以使用字符串数组的形式

>   Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大。例如
>
>   ```dockerfile
>   FROM centos
>   RUN yum -y install wget
>   RUN wget -O redis.tar.gz "http://download.redis.io/releases/redis-5.0.3.tar.gz"
>   RUN tar -xvf redis.tar.gz
>   ```
>
>   以上执行会创建 3 层镜像。可简化为以下格式
>
>   ```dockerfile
>   FROM centos
>   RUN yum -y install wget \
>       && wget -O redis.tar.gz "http://download.redis.io/releases/redis-5.0.3.tar.gz" \
>       && tar -xvf redis.tar.gz
>   ```

#### COPY

````dockerfile
COPY [--chown=<user>:<group>] <源路径1>...  <目标路径>
COPY [--chown=<user>:<group>] ["<源路径1>",...  "<目标路径>"]
````

**[--chown=<user>:<group>]**：可选参数，用户改变复制到容器内文件的拥有者和属组。

#### ADD自动解压的COPY

ADD 指令和 COPY 的使用格类似（同样需求下，官方推荐使用 COPY）。功能也类似，不同之处如下：

-   ADD 的优点：在执行 <源文件> 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 <目标路径>。
-   ADD 的缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定

#### CMD

类似于 RUN 指令，用于运行程序，但二者运行的时间点不同:

-   CMD 在docker run 时运行。
-   RUN 是在 docker build。

**作用**：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。

**注意**：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效

```dockerfile
CMD <shell 命令> 
CMD ["<可执行文件或命令>","<param1>","<param2>",...] 
CMD ["<param1>","<param2>",...]  # 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数
```

可以使用`docker run -c "xxx"`来覆盖CMD参数

#### ENTRYPOINT定参

使用实际的CMD作为这个命令的参数进行传递, 实际运行的是`ENTRYPOINT CMD`

>   如果运行 docker run 时使用了 --entrypoint 选项，将覆盖 ENTRYPOINT 指令指定的程序。

**优点**：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。

**注意**：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。

格式：

```dockerfile
ENTRYPOINT ["<executeable>","<param1>","<param2>",...]
```

可以搭配 CMD 命令使用：一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参，以下示例会提到。

示例：

假设已通过 Dockerfile 构建了 nginx:test 镜像：

```
FROM nginx

ENTRYPOINT ["nginx", "-c"] # 定参
CMD ["/etc/nginx/nginx.conf"] # 变参 
```

1、不传参运行

```
$ docker run  nginx:test
```

容器内会默认运行以下命令，启动主进程。

```
nginx -c /etc/nginx/nginx.conf
```

2、传参运行

```
$ docker run  nginx:test -c /etc/nginx/new.conf
```

容器内会默认运行以下命令，启动主进程(/etc/nginx/new.conf:假设容器内已有此文件)

```
nginx -c /etc/nginx/new.conf
```

#### ENV

设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量

```dockerfile
ENV <key> <value>
ENV <key1>=<value1> <key2>=<value2>...
```

示例

```dockerfile
ENV NODE_VERSION 7.2.0

RUN curl -SLO "https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.tar.xz" \
  && curl -SLO "https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc"
```

#### ARG

构建参数，与 ENV 作用一致。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量

构建命令 docker build 中可以用 --build-arg <参数名>=<值> 来覆盖

```dockerfile
ARG <参数名>[=<默认值>]
```

#### VOLUME

**为容器定义持久化的挂载点**，将容器内指定目录与 Docker 管理的卷（Volume）绑定, VOLUME 指令默认创建「匿名卷」（卷名是随机 UUID），宿主机路径为 `/var/lib/docker/volumes/<随机ID>/_data`

**命名卷**：VOLUME 本身无法指定卷名，需在 `docker run` 时通过 `-v` 覆盖

作用：

1.  **数据持久化**：容器删除 / 重启时，VOLUME 目录的数据不会丢失（存储在宿主机的 Docker 卷目录中）；
2.  **数据共享**：多个容器可挂载同一个卷，实现数据互通；
3.  **镜像解耦**：避免镜像包含动态数据（如日志、数据库文件），保证镜像的可移植性；
4.  **避免权限问题**：Docker 自动管理卷的权限，无需手动调整宿主机目录权限。

```dockerfile
# 1. JSON 数组格式（推荐）
VOLUME ["/path/1", "/path/2"]

# 2. Shell 格式（多个路径用空格分隔）
VOLUME /path/1 /path/2
```

使用示例

```dockerfile
FROM nginx:alpine
# 定义两个匿名卷：日志目录、网页根目录
VOLUME ["/var/log/nginx", "/usr/share/nginx/html"]
CMD ["nginx", "-g", "daemon off;"]

# 用命名卷覆盖 Dockerfile 中的 VOLUME 挂载
docker run -v my-nginx-log:/var/log/nginx -v my-nginx-html:/usr/share/nginx/html nginx:alpine
```

如果 Dockerfile 构建时，VOLUME 指定的目录已有数据（如镜像自带的 `index.html`），容器启动时：

-   Docker 会先将镜像中该目录的**原有数据复制到卷中**，再挂载卷到容器；
-   若运行容器时用 `-v 宿主机路径:/容器路径`（绑定挂载），则**不会自动复制**镜像数据到宿主机路径（需手动复制）。

`docker run -v /host/log:/var/log/nginx nginx:alpine`

#### EXPOSE

EXPOSE 是 Dockerfile 的元数据类指令，用于**声明容器运行时预期监听的网络端口**，仅作为镜像的 “说明文档”，告知使用者容器会使用哪些端口，**不会自动将端口映射到宿主机**

1.  **元数据声明**：为镜像添加端口使用的元数据，通过 `docker inspect <镜像/容器>` 可查看，方便开发者 / 运维人员了解容器的网络端口规划；
2.  **端口协议说明**：可声明端口使用的协议（TCP/UDP），默认 TCP；
3.  **配合端口映射**：`docker run` 时可通过 `-P`（大写）自动映射所有 EXPOSE 声明的端口到宿主机随机端口。

```dockerfile
# 1. 声明单个端口（默认 TCP）
EXPOSE <端口号>

# 2. 声明单个端口并指定协议（TCP/UDP）
EXPOSE <端口号>/<协议>

# 3. 声明多个端口（支持混合协议）
EXPOSE <端口1> <端口2>/udp <端口3>/tcp
```

```bash
# 仅启动容器，EXPOSE 80 但未映射，宿主机无法访问
docker run -d --name nginx1 nginx:alpine

# 通过 -p 手动映射 80 端口，宿主机可访问 http://localhost:8080
docker run -d --name nginx2 -p 8080:80 nginx:alpine

# 通过 -P 自动映射所有 EXPOSE 端口，宿主机可通过随机端口访问
docker run -d --name nginx3 -P nginx:alpine
# 查看自动映射的端口：docker port nginx3
```

启动容器时，可通过 `--expose` 参数补充或取消 EXPOSE 声明, 同一 Docker 网络内的容器，无需端口映射即可通过 “容器名 / IP + EXPOSE 端口” 通信（EXPOSE 不影响容器间通信，仅影响外部访问）

```bash
# 创建自定义网络
docker network create my-net
# 启动 nginx 容器（未映射端口）
docker run -d --name nginx-net --network my-net nginx:alpine
# 启动 busybox 容器，可直接访问 nginx-net:80
docker run --rm --network my-net busybox wget -O - nginx-net:80
```

#### WORKDIR

指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录

#### USER

用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前已经存在）。

## commit方法

+   基于容器修改后提交（`docker commit`）

这是最基础的手动构建方式，通过修改运行中的容器（如安装软件、配置文件），再将容器的文件系统状态 “快照” 为新镜像。

操作步骤：

1.  启动基础容器（以 ubuntu 为例）：

    ```bash
    docker run -it --name temp-container ubuntu:22.04 /bin/bash
    ```

2.  在容器内修改（如安装 nginx）：

    ```bash
    # 容器内执行
    apt update && apt install -y nginx
    exit  # 修改完成后退出容器
    ```

3.  提交容器为新镜像

    ```bash
    docker commit [选项] 容器名/容器ID 新镜像名:标签
    # 示例：提交 temp-container 为 my-nginx:v1
    docker commit --author "Your Name <your@email.com>" --message "install nginx" temp-container my-nginx:v1
    ```

4.  验证镜像

    ```bash
    docker images  # 查看新镜像
    docker run -d my-nginx:v1 nginx -g "daemon off;"  # 启动镜像测试
    ```

-   **-m:** 提交的描述信息
-   **-a:** 指定镜像作者

缺点: 

-   不可复现（无配置文件，其他人无法复刻相同镜像）；
-   层冗余（容器内的所有操作都会生成冗余层，镜像体积大）；
-   无标准化（无法追溯修改内容，维护成本高）



