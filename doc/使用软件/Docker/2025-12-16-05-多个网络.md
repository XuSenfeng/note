## DockerCompose

运行多个独立但是之间有联系的服务的时候, 需要相互配合, 使用docker-compose.yml实现管理所有的服务

使用`docker compose up`即可启动

## Compose文件

可以使用 YML 文件来配置应用程序需要的所有服务。

Compose 使用的三个步骤：

-   使用 Dockerfile 定义应用程序的环境。
-   使用 docker-compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。
-   最后，执行 docker-compose up 命令来启动并运行整个应用程序。

### 使用示例

## 使用

1、准备

创建一个测试目录：

```
$ mkdir composetest
$ cd composetest
```

在测试目录中创建一个名为 app.py 的文件，并复制粘贴以下内容

```python
import time

import redis
from flask import Flask

app = Flask(__name__)
cache = redis.Redis(host='redis', port=6379)


def get_hit_count():
  retries = 5
  while True:
    try:
      return cache.incr('hits')
    except redis.exceptions.ConnectionError as exc:
      if retries == 0:
        raise exc
      retries -= 1
      time.sleep(0.5)

@app.route('/')
def hello():
  count = get_hit_count()
  return 'Hello World! I have been seen {} times.\n'.format(count)
```

在此示例中，redis 是应用程序网络上的 redis 容器的主机名，该主机使用的端口为 6379。

在 composetest 目录中创建另一个名为 **requirements.txt** 的文件，内容如下：

```
flask
redis
```

2、创建 Dockerfile 文件

在 composetest 目录中，创建一个名为 **Dockerfile** 的文件，内容如下：

```dockerfile
FROM python:3.7-alpine
WORKDIR /code
ENV FLASK_APP app.py
ENV FLASK_RUN_HOST 0.0.0.0
RUN apk add --no-cache gcc musl-dev linux-headers
COPY requirements.txt requirements.txt
RUN pip install -r requirements.txt
COPY . .
CMD ["flask", "run"]
```

**Dockerfile 内容解释：**

-   **FROM python:3.7-alpine**: 从 Python 3.7 映像开始构建镜像。

-   **WORKDIR /code**: 将工作目录设置为 /code。

-   ```dockerfile
    ENV FLASK_APP app.py
    ENV FLASK_RUN_HOST 0.0.0.0
    ```

    设置 flask 命令使用的环境变量。

-   **RUN apk add --no-cache gcc musl-dev linux-headers**: 安装 gcc，以便诸如 MarkupSafe 和 SQLAlchemy 之类的 Python 包可以编译加速。

-   ```dockerfile
    COPY requirements.txt requirements.txt
    RUN pip install -r requirements.txt
    ```

    复制 requirements.txt 并安装 Python 依赖项。

-   **COPY . .**: 将 . 项目中的当前目录复制到 . 镜像中的工作目录。

-   **CMD ["flask", "run"]**: 容器提供默认的执行命令为：flask run。

3、创建 docker-compose.yml

在测试目录中创建一个名为 docker-compose.yml 的文件，然后粘贴以下内容：

docker-compose.yml 配置文件

```yaml
version: '3'
services:
 web:
  build: .
  ports:
   - "5000:5000"
 redis:
  image: "redis:alpine"
```

该 Compose 文件定义了两个服务：web 和 redis。

-   **web**：该 web 服务使用从 Dockerfile 当前目录中构建的镜像。然后，它将容器和主机绑定到暴露的端口 5000。此示例服务使用 Flask Web 服务器的默认端口 5000 。
-   **redis**：该 redis 服务使用 Docker Hub 的公共 Redis 映像。

### 基本参数

#### version基于的版本

#### build镜像构建的目录

作为具有在上下文指定的路径的对象，以及可选的 Dockerfile 和 args

```yaml
version: "3.7"
services:
  webapp:
    build: ./dir
```

```yaml
version: "3.7"
services:
  webapp:
    build:
      context: ./dir
      dockerfile: Dockerfile-alternate
      args:
        buildno: 1
      labels:
        - "com.example.description=Accounting webapp"
        - "com.example.department=Finance"
        - "com.example.label-with-empty-value"
      target: prod
```

-   context：上下文路径。
-   dockerfile：指定构建镜像的 Dockerfile 文件名。
-   args：添加构建参数，这是只能在构建过程中访问的环境变量。
-   labels：设置构建镜像的标签。
-   target：多层构建，可以指定构建哪一层。

#### cap_add，cap_drop

添加或删除容器拥有的宿主机的内核功能。

```yaml
cap_add:
  - ALL # 开启全部权限

cap_drop:
  - SYS_PTRACE # 关闭 ptrace权限
```

#### cgroup_parent

为容器指定父 cgroup 组，意味着将继承该组的资源限制。

```yaml
cgroup_parent: m-executor-abcd
```

#### command

覆盖容器启动的默认命令。

```yaml
command: ["bundle", "exec", "thin", "-p", "3000"]
```

#### container_name

指定自定义容器名称，而不是生成的默认名称。

```yaml
container_name: my-web-container
```

#### depends_on

设置依赖关系。

```yaml
version: "3.7"
services:
  web:
    build: .
    depends_on:
      - db
      - redis
  redis:
    image: redis
  db:
    image: postgres
```

>   -   `docker-compose up` ：以依赖性顺序启动服务。在以下示例中，先启动 db 和 redis ，才会启动 web。
>   -   `docker-compose up SERVICE` ：自动包含 SERVICE 的依赖项。在以下示例中，`docker-compose up web` 还将创建并启动 db 和 redis。
>   -   `docker-compose stop` ：按依赖关系顺序停止服务。在以下示例中，web 在 db 和 redis 之前停止。

#### deploy

指定与服务的部署和运行有关的配置。只在 swarm 模式下才会有用

#### devices

指定设备映射列表。

```yaml
devices:
  - "/dev/ttyUSB0:/dev/ttyUSB0"
```

#### dns

自定义 DNS 服务器，可以是单个值或列表的多个值。

```yaml
dns: 8.8.8.8

dns:
  - 8.8.8.8
  - 9.9.9.9
```

#### env_file

从文件添加环境变量。可以是单个值或列表的多个值

```yaml
env_file:
  - ./common.env
  - ./apps/web.env
  - /opt/secrets.env
```

#### environment

添加环境变量。您可以使用数组或字典、任何布尔值，布尔值需要用引号引起来，以确保 YML 解析器不会将其转换为 True 或 False

```yaml
environment:
  RACK_ENV: development
  SHOW: 'true'
```

#### expose

暴露端口，但不映射到宿主机，只被连接的服务访问。

仅可以指定内部端口为参数：

```yaml
expose:
 - "3000"
 - "8000"
```

#### volumes

将主机的数据卷或者文件挂载到容器里

```yaml
version: "3.7"
services:
  db:
    image: postgres:latest
    volumes:
      - "/localhost/postgres.sock:/var/run/postgres/postgres.sock"
      - "/localhost/data:/var/lib/postgresql/data"
```

