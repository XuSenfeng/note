# 图层绘制

## 图层

默认情况下，LVGL会将新的Widgets绘制在旧的Widgets之上。

例如，假设我们在名为button1的父Widget上添加一个按钮，然后再添加另一个名为button2的按钮。那么，button1（及其子Widget）将处于背景中，并可能被button2及其子Widget覆盖。

- 使用`lv_obj_move_foreground(widget)`将Widget移至前景。 类似地，使用`lv_obj_move_background(widget)`将其移至背景。
- 使用`lv_obj_move_to_index(widget, idx)`将Widget移动到子节点顺序中的指定索引位置
- + `0`: 背景
    + `child_num - 1`: 前景
    + `< 0`: 从顶部开始计数，向前（上）移动，例如:`lv_obj_move_to_index(widget, lv_obj_get_index(widget) - 1)`
- 可以使用`lv_obj_swap(widget1, widget2)`交换图层
- 也可以使用`lv_obj_set_parent(widget, new_parent)`重新指定父对象

LVGL使用了两个特殊的层，分别是`layer_top`和`layer_sys`。这两个层在显示器的所有屏幕上都是可见且通用的。**但它们并不会在多个物理显示器之间共享。** `layer_top`始终位于默认屏幕`lv_screen_active()`之上，而``layer_sys``则位于``layer_top``之上

`layer_top`可供用户创建一些在所有地方都可见的内容。例如，一个菜单栏、弹出窗口等。如果启用了``click``属性，那么``layer_top``将吸收所有用户点击，并作为一个模态窗口。

```c
lv_obj_add_flag(lv_layer_top(), LV_OBJ_FLAG_CLICKABLE);
```

这些层的工作方式与其他Widget类似，这意味着它们可以设置样式、滚动，并且可以在其上创建任何类型的Widget

## Canvas画布

用户能够绘制任何内容。在这里，可以使用 LVGL 强大的绘图引擎绘制矩形、文本、图像、线条、弧线等等。

Canvas 需要一个缓冲区来存储绘制的图像。 要为 Canvas 分配缓冲区，请使用函数 `lv_canvas_set_buffer(canvas, buffer, width, height, LV_COLOR_FORMAT_...)` ， 其中参数 `buffer` 是一个静态缓冲区（不能是局部变量）来保存画布的图像

### 基础使用

要在画布上设置像素，请使用 `lv_canvas_set_px_color(canvas, x, y, color, opa)` 。 对于 `LV_COLOR_FORMAT_I1/2/4/8` 颜色索引需要像这样 `lv_color_from_int(13);` 传递，它将颜色索引 13 作为颜色传递。

`lv_canvas_fill_bg(canvas, lv_color_hex(0x00ff00), LV_OPA_50)` 将整个画布填充为蓝色，不透明度为 50%。 请注意，如果当前颜色格式不支持(例如 `LV_COLOR_FORMAT_A8`)，则该颜色将被忽略。同样，如果不支持不透明度(例如 `LV_COLOR_FORMAT_RGB565`)，不透明度将被忽略。

可以使用 `lv_canvas_copy_buf(canvas, buffer_to_copy, x, y, width, height) `将像素数组复制到画布。缓冲区和画布的颜色格式需要一致。

## 手动绘制

一些样式属性会让 LVGL 分配一个缓冲区，并首先在那里渲染一个控件及其子部件。 之后，该层将在应用一些转换或其他修改后，被合并到屏幕或其父层

```c
static void ui_canvas_event(lv_event_t * e)
{
    lv_event_code_t code = lv_event_get_code(e);

    static lv_coord_t last_x = -65535, last_y = -65535;

    if(code == LV_EVENT_PRESSING)
    {
        lv_indev_t * indev = lv_indev_active();
        if(indev == NULL)  return;
        lv_point_t point;
        lv_indev_get_point(indev, &point);

        if(last_x != -65535 && last_y != -65535)
        {
            // 初始化一个绘制层
            lv_layer_t layer;
            lv_canvas_init_layer(canvas, &layer);
            lv_draw_line_dsc_t dsc; // 线条描述符
            lv_draw_line_dsc_init(&dsc);   
            dsc.color = ui_Draw_para.line_color; 
            dsc.width = ui_Draw_para.line_width;
            dsc.round_end = 1;
            dsc.round_start = 1;
            dsc.p1.x = last_x;
            dsc.p1.y = last_y;
            dsc.p2.x = point.x;
            dsc.p2.y = point.y;
            lv_draw_line(&layer, &dsc);
            // 应用绘制层到画布
            lv_canvas_finish_layer(canvas, &layer); 
        }

        last_x = point.x;
        last_y = point.y;
    }
    else if(code == LV_EVENT_RELEASED)
    {
        last_x = -32768;
        last_y = -32768;
    }
}

```

