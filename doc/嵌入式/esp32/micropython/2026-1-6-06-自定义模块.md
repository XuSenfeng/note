# 自定义模块

## 编译

```bash
# 使用make
cd micropython/ports/rp2
make USER_C_MODULES=../../examples/usercmodule
# 使用cmake
cd micropython/ports/esp32
make USER_C_MODULES=../../examples/usercmodule/micropython.cmake
```

对应的文件分别是micropythonmk以及micropython.cmake

可以使用一个顶层 `micropython.cmake`（比如位于 `modules`）需通过 `include` 引入所有待启用的模块

```cmake
include(${CMAKE_CURRENT_LIST_DIR}/cexample/micropython.cmake)

# Add the CPP example.
include(${CMAKE_CURRENT_LIST_DIR}/cppexample/micropython.cmake)
```

编译的时候

```bash
make USER_C_MODULES=../../../../modules/micropython.cmake
```

所有通过 `USER_C_MODULES` 指定的模块（Make 从目录自动查找、CMake 从 `include` 引入）都会被编译，但只有启用的模块可被导入：

- 自定义模块通常默认启用（由模块开发者决定），此时只需按上述方式设置 `USER_C_MODULES` 即可；
- 若模块未默认启用，需手动开启对应的 C 预处理器宏：
    1. 在模块源码中找到 `MP_REGISTER_MODULE` 行（通常在主源码文件末尾），其外围会有 `#if X` / `#endif` 包裹，`X` 即为需启用的配置项；
    2. 通过 `CFLAGS_EXTRA` 设置 `X=1`，或在 `mpconfigport.h` / `mpconfigboard.h` 中添加 `#define X (1)`。

示例：若 `cexample` 模块默认禁用，源码中会有：

```c
#if MODULE_CEXAMPLE_ENABLED
MP_REGISTER_MODULE(MP_QSTR_cexample, example_user_cmodule);
#endif
```

启用方式：

```bash
# 编译时添加 CFLAGS_EXTRA
make CFLAGS_EXTRA=-DMODULE_CEXAMPLE_ENABLED=1
```

或在配置文件中添加：

```c
#define MODULE_CEXAMPLE_ENABLED (1)
```

## 函数

### 变量定义

```cpp
typedef mp_obj_t (*mp_fun_0_t)(void);
typedef mp_obj_t (*mp_fun_1_t)(mp_obj_t);
typedef mp_obj_t (*mp_fun_2_t)(mp_obj_t, mp_obj_t);
typedef mp_obj_t (*mp_fun_3_t)(mp_obj_t, mp_obj_t, mp_obj_t);
// 传入的位置参数个数, 数组里每个元素都是 mp_obj_t 类型的位置参数
typedef mp_obj_t (*mp_fun_var_t)(size_t n, const mp_obj_t *);
// mp_fun_kw_t takes mp_map_t* (and not const mp_map_t*) to ease passing
// this arg to mp_map_lookup().
// Note that the mp_obj_t* array will contain all arguments, positional and keyword, with the keyword
// ones starting at offset n, like: arg0 arg1 ... arg<n> key0 value0 key1 value1 ..., and the mp_map_t*
// gets those same keyword arguments but as a map for convenience; see fun_builtin_var_call.
// mp_obj_t：MicroPython 中所有对象的 “通用容器类型”（整数、字符串、列表、函数等都用这个类型表示）。
// mp_map_t：MicroPython 中用于存储键值对的映射结构（对应 Python 的字典，专门用来处理关键字参数）。
// mp_obj_t: 纯位置参数的个数, 前 n 个元素 = 位置参数（对应 Python 的 *args）
// 从 n 开始 = 关键字参数（键 - 值成对出现，如 key0, value0, key1, value1...）
// mp_map_t 关键字参数的映射表（简化查找，对应 Python 的 **kwargs）
typedef mp_obj_t (*mp_fun_kw_t)(size_t n, const mp_obj_t *, mp_map_t *);

// functions 使用下面的类型进行封装
typedef struct _mp_obj_fun_builtin_fixed_t {
    mp_obj_base_t base;
    union {
        mp_fun_0_t _0;
        mp_fun_1_t _1;
        mp_fun_2_t _2;
        mp_fun_3_t _3;
    } fun;
} mp_obj_fun_builtin_fixed_t;

typedef struct _mp_obj_fun_builtin_var_t {
    mp_obj_base_t base;
    uint32_t sig; // see MP_OBJ_FUN_MAKE_SIG
    union {
        mp_fun_var_t var;
        mp_fun_kw_t kw;
    } fun;
} mp_obj_fun_builtin_var_t;

// 使用的变量
#define MP_OBJ_FUN_ARGS_MAX (0xffff) // to set maximum value in n_args_max below
#define MP_OBJ_FUN_MAKE_SIG(n_args_min, n_args_max, takes_kw) ((uint32_t)((((uint32_t)(n_args_min)) << 17) | (((uint32_t)(n_args_max)) << 1) | ((takes_kw) ? 1 : 0)))


// 实际使用的注册宏定义
#define MP_DEFINE_CONST_FUN_OBJ_0(obj_name, fun_name) \
    const mp_obj_fun_builtin_fixed_t obj_name = \
    {.base = {.type = &mp_type_fun_builtin_0}, .fun = {._0 = fun_name}}
#define MP_DEFINE_CONST_FUN_OBJ_1(obj_name, fun_name) \
    const mp_obj_fun_builtin_fixed_t obj_name = \
    {.base = {.type = &mp_type_fun_builtin_1}, .fun = {._1 = fun_name}}
#define MP_DEFINE_CONST_FUN_OBJ_2(obj_name, fun_name) \
    const mp_obj_fun_builtin_fixed_t obj_name = \
    {.base = {.type = &mp_type_fun_builtin_2}, .fun = {._2 = fun_name}}
#define MP_DEFINE_CONST_FUN_OBJ_3(obj_name, fun_name) \
    const mp_obj_fun_builtin_fixed_t obj_name = \
    {.base = {.type = &mp_type_fun_builtin_3}, .fun = {._3 = fun_name}}
#define MP_DEFINE_CONST_FUN_OBJ_VAR(obj_name, n_args_min, fun_name) \
    const mp_obj_fun_builtin_var_t obj_name = \
    {.base = {.type = &mp_type_fun_builtin_var}, .sig = MP_OBJ_FUN_MAKE_SIG(n_args_min, MP_OBJ_FUN_ARGS_MAX, false), .fun = {.var = fun_name}}
#define MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(obj_name, n_args_min, n_args_max, fun_name) \
    const mp_obj_fun_builtin_var_t obj_name = \
    {.base = {.type = &mp_type_fun_builtin_var}, .sig = MP_OBJ_FUN_MAKE_SIG(n_args_min, n_args_max, false), .fun = {.var = fun_name}}
#define MP_DEFINE_CONST_FUN_OBJ_KW(obj_name, n_args_min, fun_name) \
    const mp_obj_fun_builtin_var_t obj_name = \
    {.base = {.type = &mp_type_fun_builtin_var}, .sig = MP_OBJ_FUN_MAKE_SIG(n_args_min, MP_OBJ_FUN_ARGS_MAX, true), .fun = {.kw = fun_name}}
```

可以使用的几种函数的类型

### 实际函数注册

```cpp
// This is the function which will be called from Python as cexample.add_ints(a, b).
static mp_obj_t example_add_ints(mp_obj_t a_obj, mp_obj_t b_obj) {
    // Extract the ints from the micropython input objects.
    int a = mp_obj_get_int(a_obj);
    int b = mp_obj_get_int(b_obj);

    // Calculate the addition and convert to MicroPython object.
    return mp_obj_new_int(a + b);
}
// Define a Python reference to the function above. 使用宏定义注册
static MP_DEFINE_CONST_FUN_OBJ_2(example_add_ints_obj, example_add_ints);
```

### 变参数函数注册

+ 第一个没有key

```cpp
#include "py/obj.h"
#include "py/runtime.h"

// 1. 实现核心函数（符合 mp_fun_var_t 签名）
// 功能：计算所有传入位置参数的和（仅支持整数）
static mp_obj_t sum_ints_var(size_t n_args, const mp_obj_t *args) {
    // 初始化求和结果为0
    long total = 0;
    
    // 遍历所有位置参数
    for (size_t i = 0; i < n_args; i++) {
        // 将 mp_obj_t 类型的参数转换为整数（MicroPython 内置API）
        total += mp_obj_get_int(args[i]);
    }
    
    // 将 C 语言的 long 转换为 mp_obj_t 并返回
    return mp_obj_new_int(total);
}

// 2. 定义函数对象（注册到 MicroPython 中）
static MP_DEFINE_CONST_FUN_OBJ_VAR(sum_ints_obj, 0, sum_ints_var);
// 解释：
// - MP_DEFINE_CONST_FUN_OBJ_VAR：宏，定义“可变位置参数函数对象”
// - sum_ints_obj：函数对象名
// - 0：函数最少需要的参数个数（0表示可选参数）
// - sum_ints_var：指向核心函数的指针

// 3. 注册模块（让 Python 能导入）MicroPython 的只读映射元素类型，专门用来定义 “字符串名称 ↔ C 对象” 的对应关系
// 核心是QSTR（Quick String）——MicroPython 为嵌入式场景优化的 “快速字符串”（避免重复存储相同字符串，节省内存）。
// 这行代码的作用是：把 “sum_ints” 这个字符串转换成 MicroPython 内部的 QSTR 类型，作为模块里的 “函数名”（对应 Python 中mymodule.sum_ints的sum_ints）
// ROM表示 “只读内存”，PTR是指针；这行是把之前定义的sum_ints_obj函数对象的地址，绑定到 “sum_ints” 这个名称上 —— 相当于告诉 MicroPython：“当用户调用mymodule.sum_ints时，执行的是 C 里的sum_ints_obj”。
static const mp_rom_map_elem_t mymodule_globals_table[] = {
    { MP_ROM_QSTR(MP_QSTR_sum_ints), MP_ROM_PTR(&sum_ints_obj) },
};
// 用来把上面的mp_rom_map_elem_t数组，转换成 MicroPython 的只读字典对象（mp_obj_dict_t类型）—— 这是 MicroPython 识别 “模块命名空间” 的核心结构
// Python 中import mymodule后，mymodule.__dict__对应的就是这个字典
static MP_DEFINE_CONST_DICT(mymodule_globals, mymodule_globals_table);
// MicroPython 的模块对象类型—— 所有能被import的模块，本质都是这个类型的实例
// 设置模块对象的 “基类型” 为mp_type_module（MicroPython 内置的 “模块类型”）
// 模块的核心字段，指向上面创建的字典对象（mymodule_globals）
const mp_obj_module_t mymodule_module = {
    .base = { &mp_type_module },
    .globals = (mp_obj_dict_t *)&mymodule_globals,
};
// 模块对象（mymodule_module）“上报” 给 MicroPython 系统
MP_REGISTER_MODULE(MP_QSTR_mymodule, mymodule_module);
```

```python
import mymodule
print(mymodule.sum_ints(1, 2, 3))  # 输出 6
print(mymodule.sum_ints(10, 20))   # 输出 30
print(mymodule.sum_ints())         # 输出 0（参数个数为0）
```

+ 有key的

```cpp
#include "py/obj.h"
#include "py/runtime.h"
#include "py/map.h"

// 1. 实现核心函数（符合 mp_fun_kw_t 签名）
// 功能：打印位置参数 + 关键字参数（支持指定分隔符 sep）
static mp_obj_t print_with_kw(size_t n_pos_args, const mp_obj_t *args, mp_map_t *kw_args) {
    // 定义默认分隔符：空格
    mp_obj_t sep_obj = mp_obj_new_str(" ", 1);
    
    // 步骤1：查找关键字参数 "sep"（MicroPython 内置API）
    mp_obj_t sep_key = mp_obj_new_str("sep", 3);
    mp_map_elem_t *elem = mp_map_lookup(kw_args, sep_key, MP_MAP_LOOKUP);
    if (elem != NULL) {
        // 如果传入了 sep 参数，替换默认值
        sep_obj = elem->value;
    }

    // 步骤2：打印所有位置参数（用 sep 分隔）
    for (size_t i = 0; i < n_pos_args; i++) {
        // 打印当前参数（MicroPython 内置打印API）
        mp_obj_print(args[i], PRINT_STR);
        // 不是最后一个参数时，打印分隔符
        if (i < n_pos_args - 1) {
            mp_obj_print(sep_obj, PRINT_STR);
        }
    }
    // 打印换行
    mp_printf(&mp_plat_print, "\n");

    // 返回 None（MicroPython 中 None 对应的常量）
    return mp_const_none;
}

// 2. 定义函数对象（注册关键字参数函数）
static MP_DEFINE_CONST_FUN_OBJ_KW(print_with_kw_obj, 0, print_with_kw);
// 解释：
// - MP_DEFINE_CONST_FUN_OBJ_KW：宏，定义“支持关键字参数的函数对象”
// - print_with_kw_obj：函数对象名
// - 0：最少位置参数个数
// - print_with_kw：核心函数指针

// 3. 注册到模块（复用上面的 mymodule 模块）
static const mp_rom_map_elem_t mymodule_globals_table[] = {
    { MP_ROM_QSTR(MP_QSTR_sum_ints), MP_ROM_PTR(&sum_ints_obj) },
    { MP_ROM_QSTR(MP_QSTR_print_with_kw), MP_ROM_PTR(&print_with_kw_obj) },
};
```

```python
import mymodule
mymodule.print_with_kw(1, 2, 3)                # 输出：1 2 3
mymodule.print_with_kw(1, 2, 3, sep="-")       # 输出：1-2-3
mymodule.print_with_kw("hello", "world", sep="!")  # 输出：hello!world
```

## 定义类

### 数据类型

```cpp
// This macros is used to define a object type in ROM.
// Invoke as MP_DEFINE_CONST_OBJ_TYPE(_typename, _name, _flags, [, slot, func]*)
// It uses the number of arguments to select which MP_DEFINE_CONST_OBJ_TYPE_*
// macro to use based on the number of arguments. It works by shifting the
// numeric values 12, 11, ... 0 by the number of arguments, such that the
// 29th argument ends up being the number to use. The _INV values are
// placeholders because the slot arguments come in pairs.
#define MP_DEFINE_CONST_OBJ_TYPE(...)  \
MP_DEFINE_CONST_OBJ_TYPE_EXPAND( \
	MP_DEFINE_CONST_OBJ_TYPE_NARGS(__VA_ARGS__, _INV, 12, _INV, 11, _INV, 10, \
    _INV, 9, _INV, 8, _INV, 7, _INV, 6, _INV, 5, _INV, 4, _INV, 3, _INV, 2, \
    _INV, 1, _INV, 0) \
    (mp_obj_type_t, __VA_ARGS__))
```

该宏用于在 ROM 中定义对象类型

MicroPython 中所有 “类型”（比如整数、字符串、自定义类、模块）的底层都是 `mp_obj_type_t` 结构体（类似 Python 的 `type` 对象）。这个结构体包含类型名称、标志位、以及一系列可选的 “槽位(slot)(比如`new`槽位对应构造函数, `print`槽位对应打印函数、`call` 槽位对应调用函数）

实际的调用形式如下

```cpp
MP_DEFINE_CONST_OBJ_TYPE(_typename, _name, _flags, [, slot, func]*)
```

- `_typename`：自定义的类型名（比如 `my_timer_type`）；
- `_name`：类型的 QSTR 名称（比如 `MP_QSTR_Timer`，对应 Python 中类型的 `__name__`）；
- `_flags`：类型标志位（比如 `MP_TYPE_FLAG_NONE`，控制类型的行为）；

`MP_DEFINE_CONST_OBJ_TYPE_NARGS`用于自动计算输入的键值对的个数

### `MP_DEFINE_CONST_OBJ_TYPE_EXPAND` —— 宏的二次展开

C 宏的展开有 “优先级问题”：直接嵌套的宏可能无法正确展开可变参数。`MP_DEFINE_CONST_OBJ_TYPE_EXPAND` 是一个 “空宏”（通常定义为 `#define MP_DEFINE_CONST_OBJ_TYPE_EXPAND(x) x`），作用是**触发编译器对宏的二次展开**，确保参数计数和结构体生成的逻辑能正确执行。

`(mp_obj_type_t, __VA_ARGS__)` —— 生成最终结构体

参数计数完成后，会调用对应的底层宏（比如 `MP_DEFINE_CONST_OBJ_TYPE_2`），并传入两个关键参数：

- `mp_obj_type_t`：要定义的结构体类型（MicroPython 所有对象类型的基类）；
- `__VA_ARGS__`：调用时传入的所有参数（类型名、名称、标志、槽位 - 函数对）。

### 定义类

```cpp
// This structure represents Timer instance objects.
// 表示 Timer 实例对象的结构体
typedef struct _example_Timer_obj_t {
    // All objects start with the base.
    mp_obj_base_t base;
    // Everything below can be thought of as instance attributes, but they
    // cannot be accessed by MicroPython code directly. In this example we
    // store the time at which the object was created.
    mp_uint_t start_time;
} example_Timer_obj_t;

// This is the Timer.time() method. After creating a Timer object, this
// can be called to get the time elapsed since creating the Timer.
// 方法的实现：返回实例创建后的耗时
static mp_obj_t example_Timer_time(mp_obj_t self_in) {
    // The first argument is self. It is cast to the *example_Timer_obj_t
    // type so we can read its attributes.
    example_Timer_obj_t *self = MP_OBJ_TO_PTR(self_in);

    // Get the elapsed time and return it as a MicroPython integer.
    mp_uint_t elapsed = mp_hal_ticks_ms() - self->start_time;
    return mp_obj_new_int_from_uint(elapsed);
}
static MP_DEFINE_CONST_FUN_OBJ_1(example_Timer_time_obj, example_Timer_time);

// This represents Timer.__new__ and Timer.__init__, which is called when
// the user instantiates a Timer object.
// Timer 类的 __new__/__init__ 方法：实例化时调用
static mp_obj_t example_Timer_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {
    // Allocates the new object and sets the type.
    example_Timer_obj_t *self = mp_obj_malloc(example_Timer_obj_t, type);

    // Initializes the time for this Timer instance.
    self->start_time = mp_hal_ticks_ms();

    // The make_new function always returns self.
    return MP_OBJ_FROM_PTR(self);
}

// This collects all methods and other static class attributes of the Timer.
// The table structure is similar to the module table, as detailed below.
// 存储 Timer 类的所有方法/静态属性（类似 Python 中类的 __dict__）
static const mp_rom_map_elem_t example_Timer_locals_dict_table[] = {
    { MP_ROM_QSTR(MP_QSTR_time), MP_ROM_PTR(&example_Timer_time_obj) },
};
// 将清单转换为 MicroPython 只读字典对象
static MP_DEFINE_CONST_DICT(example_Timer_locals_dict, example_Timer_locals_dict_table);

// This defines the type(Timer) object.
MP_DEFINE_CONST_OBJ_TYPE(
    example_type_Timer,
    MP_QSTR_Timer,
    MP_TYPE_FLAG_NONE,
    make_new, example_Timer_make_new, // // 构造函数槽位：关联 make_new 方法
    locals_dict, &example_Timer_locals_dict /// 本地字典槽位：关联类的方法清单
    );

// Define all attributes of the module.
// Table entries are key/value pairs of the attribute name (a string)
// and the MicroPython object reference.
// All identifiers and strings are written as MP_QSTR_xxx and will be
// optimized to word-sized integers by the build system (interned strings).
// 定义模块的全局属性清单（cexample 模块的 __dict__）
static const mp_rom_map_elem_t example_module_globals_table[] = {
    { MP_ROM_QSTR(MP_QSTR_Timer),    MP_ROM_PTR(&example_type_Timer) },
};
static MP_DEFINE_CONST_DICT(example_module_globals, example_module_globals_table);

// Define module object.
const mp_obj_module_t example_user_cmodule = {
    .base = { &mp_type_module },
    .globals = (mp_obj_dict_t *)&example_module_globals,
};

// Register the module to make it available in Python.
MP_REGISTER_MODULE(MP_QSTR_cexample, example_user_cmodule);
```

### 使用

```python
from cexample import Timer
from time import sleep_ms

watch = Timer()
sleep_ms(1000)
print(watch.time())
```

