# 参数

在ROS系统中，参数是以**全局字典**的形态存在的, 参数的特性非常丰富，比如某一个节点共享了一个参数，其他节点都可以访问，如果某一个节点对参数进行了修改，其他节点也有办法立刻知道，从而获取最新的数值。

参数是基于服务通信实现的, 但是直接使用服务的形式进行控制比较复杂

```bash
(base) jiao@jiao-virtual-machine:~$ ros2 service list -t | grep parameter
/turtlesim/describe_parameters [rcl_interfaces/srv/DescribeParameters]
/turtlesim/get_parameter_types [rcl_interfaces/srv/GetParameterTypes]
/turtlesim/get_parameters [rcl_interfaces/srv/GetParameters]
/turtlesim/list_parameters [rcl_interfaces/srv/ListParameters]
/turtlesim/set_parameters [rcl_interfaces/srv/SetParameters]
/turtlesim/set_parameters_atomically [rcl_interfaces/srv/SetParametersAtomically]
```

### 命令行

```bash
(base) jiao@jiao-virtual-machine:~/ros$ ros2 param list
/turtlesim:
  background_b
  background_g
  background_r
  qos_overrides./parameter_events.publisher.depth
  qos_overrides./parameter_events.publisher.durability
  qos_overrides./parameter_events.publisher.history
  qos_overrides./parameter_events.publisher.reliability
  use_sim_time
(base) jiao@jiao-virtual-machine:~/ros$ ros2 param describe /turtlesim background_b
Parameter name: background_b
  Type: integer
  Description: Blue channel of the background color
  Constraints:
    Min value: 0
    Max value: 255
    Step: 1
(base) jiao@jiao-virtual-machine:~/ros$ ros2 param get turtlesim background_b
Integer value is: 255
(base) jiao@jiao-virtual-machine:~/ros$ ros2 param set turtlesim background_b 200
Set parameter successful
(base) jiao@jiao-virtual-machine:~/ros$ ros2 param dump /turtlesim 
/turtlesim:
  ros__parameters:
    background_b: 200
    background_g: 86
    background_r: 69
    qos_overrides:
      /parameter_events:
        publisher:
          depth: 1000
          durability: volatile
          history: keep_last
          reliability: reliable
    use_sim_time: false
(base) jiao@jiao-virtual-machine:~/ros$ ros2 param dump /turtlesim >> turtlesim.yaml
(base) jiao@jiao-virtual-machine:~/ros$ ros2 param load /turtlesim turtlesim.yaml
# 使用配置文件
(base) jiao@jiao-virtual-machine:~/ros$ ros2 run turtlesim turtlesim_node --ros-args --params-file turtlesim.yaml
# 直接输入
(base) jiao@jiao-virtual-machine:~/ros$ ros2 run turtlesim turtlesim_node --ros-args -p model:=cnn
```

## 代码

### 参数设置

```python
import rclpy                                     # ROS2 Python接口库
from rclpy.node   import Node                    # ROS2 节点类

class ParameterNode(Node):
    def __init__(self, name):
        super().__init__(name)
        self.timer = self.create_timer(2, self.timer_callback)
        # 创建一个参数，并设置参数的默认值
        self.declare_parameter('robot_name', 'mbot')

    def timer_callback(self):
        # 从ROS2系统中读取参数的值
        robot_name_param = self.get_parameter('robot_name').get_parameter_value().string_value
        # 输出日志信息，打印读取到的参数值
        self.get_logger().info('Hello %s!' % robot_name_param)
        # 重新将参数值设置为指定值
        new_name_param = rclpy.parameter.Parameter('robot_name',
                            rclpy.Parameter.Type.STRING, 'mbot')
        all_new_parameters = [new_name_param]
        # 将重新创建的参数列表发送给ROS2系统
        self.set_parameters(all_new_parameters)

def main(args=None):
    rclpy.init(args=args)
    node = ParameterNode("param_declare")
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()
```



```python
import rclpy                      # ROS2 Python接口库
from rclpy.node import Node       # ROS2 节点类
from sensor_msgs.msg import Image # 图像消息类型
from cv_bridge import CvBridge    # ROS与OpenCV图像转换类
import cv2                        # Opencv图像处理库
import numpy as np                # Python数值计算库

lower_red = np.array([0, 90, 128])     # 红色的HSV阈值下限
upper_red = np.array([180, 255, 255])  # 红色的HSV阈值上限

"""
创建一个订阅者节点
"""
class ImageSubscriber(Node):
  def __init__(self, name):
    super().__init__(name)
    self.sub = self.create_subscription(Image,
                  'image_raw', self.listener_callback, 10) 
    # 创建一个图像转换对象，用于OpenCV图像与ROS的图像消息的互相转换
    self.cv_bridge = CvBridge()
    # 创建一个参数，表示阈值上限
    self.declare_parameter('red_h_upper', 0)
    # 创建一个参数，表示阈值下限
    self.declare_parameter('red_h_lower', 0)
    
  def object_detect(self, image):
    # 读取阈值上限的参数值
    upper_red[0] = self.get_parameter('red_h_upper').get_parameter_value().integer_value 
    # 读取阈值下限的参数值
    lower_red[0] = self.get_parameter('red_h_lower').get_parameter_value().integer_value 
    # 通过日志打印读取到的参数值
    self.get_logger().info('Get Red H Upper: %d, Lower: %d' % (upper_red[0], lower_red[0]))   
    # 图像从BGR颜色模型转换为HSV模型
    hsv_img = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
    # 图像二值化
    mask_red = cv2.inRange(hsv_img, lower_red, upper_red)
    # 图像中轮廓检测
    contours, hierarchy = cv2.findContours(mask_red, cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE)
    for cnt in contours:# 去除一些轮廓面积太小的噪声
        if cnt.shape[0] < 150:
            continue
        # 得到苹果所在轮廓的左上角xy像素坐标及轮廓范围的宽和高
        (x, y, w, h) = cv2.boundingRect(cnt)
        # 将苹果的轮廓勾勒出来
        cv2.drawContours(image, [cnt], -1, (0, 255, 0), 2)
        # 将苹果的图像中心点画出来
        cv2.circle(image, (int(x+w/2), int(y+h/2)), 5, (0, 255, 0), -1)
    # 使用OpenCV显示处理后的图像效果
    cv2.imshow("object", image)
    cv2.waitKey(50)
    
  def listener_callback(self, data):
    self.get_logger().info('Receiving video frame')
    image = self.cv_bridge.imgmsg_to_cv2(data, "bgr8")
    self.object_detect(image)
  
def main(args=None):
    rclpy.init(args=args)
    node = ImageSubscriber("param_object_detect")
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()
```

可以使用回调函数检测参数变化

```python
self.add_on_set_parameters_callback(call_back)
def call_back(paragrams):
    for paragram in paragrams:
        paragram.name   paragram.value
        
    
   	return SetParametersResult(successful=True)
    
```

### 跨节点设置参数

```python
import rclpy
from rclpy.node import Node
from rcl_interfaces.srv import SetParameters, GetParameters
from rcl_interfaces.msg import Parameter, ParameterType, ParameterValue

class CrossParamNode(Node):
    def __init__(self):
        super().__init__("cross_param_node")
        # 1. 创建参数客户端，指定目标节点名（即要修改参数的节点）
        self.param_client = self.create_client(SetParameters, "/turtlesim/set_parameters")
        while not self.param_client.wait_for_service(timeout_sec=1.0):
            self.get_logger().info("/turtlesim/set_parameters服务未就绪，正在等待...")
        self.get_logger().info("/turtlesim/set_parameters服务已连接")
        
        # 2. 准备要设置的目标节点参数
        request = SetParameters.Request()
        target_param = Parameter()
        target_param.name = "background_b"
        param_value = ParameterValue()
        param_value.type = ParameterType.PARAMETER_INTEGER
        param_value.integer_value = 200  # 设置蓝色背景值为200
        target_param.value = param_value
        request.parameters = [target_param]
        
        # 3. 异步设置其他节点的参数
        future = self.param_client.call_async(request)
        rclpy.spin_until_future_complete(self, future)
        
        # 4. 验证设置结果
        if future.result() is not None:
            self.get_logger().info(f"跨节点设置参数成功: {future.result()}")
            # 获取目标节点的参数值
            get_param_client = self.create_client(GetParameters, "/turtlesim/get_parameters")
            while not get_param_client.wait_for_service(timeout_sec=1.0):
                self.get_logger().info("/turtlesim/get_parameters服务未就绪，正在等待...")
            get_request = GetParameters.Request()
            get_request.names = ["background_b"]
            get_future = get_param_client.call_async(get_request)
            rclpy.spin_until_future_complete(self, get_future)
            if get_future.result() is not None:
                self.get_logger().info(f"目标节点参数background_b的新值为: {get_future.result().values[0].integer_value}")
        else:
            self.get_logger().error("跨节点设置参数失败")

def main(args=None):
    rclpy.init(args=args)
    # 注意：需先启动/turtlesim节点，再运行本节点
    node = CrossParamNode()
    node.destroy_node()
    rclpy.shutdown()

if __name__ == "__main__":
    main()
```

