# 自定义路径规划器

基于机器人的起始位姿, 目标位姿以及地图计算出来一个可以使用的路径

+ 位置

```bash
(base) jiao@jiao-virtual-machine:~/ros/learn_pluginlib$ ros2 interface show geometry_msgs/msg/PoseStamped 
# A Pose with reference coordinate frame and timestamp

std_msgs/Header header
        builtin_interfaces/Time stamp
                int32 sec
                uint32 nanosec
        string frame_id
Pose pose
        Point position
                float64 x
                float64 y
                float64 z
        Quaternion orientation
                float64 x 0
                float64 y 0
                float64 z 0
                float64 w 1
```

+ 地图, 这个数据是从左上角开始计算的

```bash
(base) jiao@jiao-virtual-machine:~/ros/learn_pluginlib$ ros2 interface show nav_msgs/msg/OccupancyGrid 
# This represents a 2-D grid map
std_msgs/Header header
        builtin_interfaces/Time stamp
                int32 sec
                uint32 nanosec
        string frame_id

# MetaData for the map
MapMetaData info
        builtin_interfaces/Time map_load_time
                int32 sec
                uint32 nanosec
        float32 resolution # 分辨率, 一个像素代表的距离
        uint32 width # 宽高
        uint32 height
        geometry_msgs/Pose origin # 原点坐标
                Point position
                        float64 x
                        float64 y
                        float64 z
                Quaternion orientation
                        float64 x 0
                        float64 y 0
                        float64 z 0
                        float64 w 1

# The map data, in row-major order, starting with (0,0).
# Cell (1, 0) will be listed second, representing the next cell in the x direction.
# Cell (0, 1) will be at the index equal to info.width, followed by (1, 1).
# The values inside are application dependent, but frequently,
# 0 represents unoccupied, 1 represents definitely occupied, and
# -1 represents unknown.
int8[] data
```

在实际使用的时候需要和ros里面的地图进行转换, 这里的origin是地图的起始位置的偏移

```python
row_index = (y - info.origin.y) / info.resolution
row_index = (x - info.origin.x) / info.resolution
occupied_state = data[row_index * map_width + col_index]
```

+ 路径:是一系列的点

```bash
(base) jiao@jiao-virtual-machine:~/ros/learn_pluginlib$ ros2 interface show nav_msgs/msg/Path 
# An array of poses that represents a Path for a robot to follow.

# Indicates the frame_id of the path.
std_msgs/Header header
        builtin_interfaces/Time stamp
                int32 sec
                uint32 nanosec
        string frame_id

# Array of poses to follow.
geometry_msgs/PoseStamped[] poses
        std_msgs/Header header
                builtin_interfaces/Time stamp
                        int32 sec
                        uint32 nanosec
                string frame_id
        Pose pose
                Point position
                        float64 x
                        float64 y
                        float64 z
                Quaternion orientation
                        float64 x 0
                        float64 y 0
                        float64 z 0
                        float64 w 1
```

## 创建自定义规划器

+ 创建目录以及功能包
+ 定义插件类, 插件继承于navigation2里面的一个基类nav2_core::GlobalPlanner
+ + 重写五个纯虚函数
    + + configure: 插件配置
        + cleanup: 插件清理
        + activate: 插件激活
        + deactivate: 插件停用
        + createPlan: 创建路径
+ 实现插件的逻辑
+ + 在configure方法里面初始化代价地图, 全局坐标等
+ 创建插件的描述文件

```cpp
#ifndef NAV2_CUSTOM_PLANNER__NAV2_CUSTOM_PLANNER_HPP_
#define NAV2_CUSTOM_PLANNER__NAV2_CUSTOM_PLANNER_HPP_
#include <memory>
#include <string>
// 消息接口头文件
#include "geometry_msgs/msg/point.hpp" 
#include "geometry_msgs/msg/pose_stamped.hpp" 
#include "nav_msgs/msg/path.hpp" 
#include "nav2_costmap_2d/costmap_2d_ros.hpp"

#include "rclcpp/rclcpp.hpp" 
// 基类头文件
#include "nav2_core/global_planner.hpp"
// rclcpp的生命周期节点头文件
#include "nav2_util/lifecycle_node.hpp"
// 常用工具头文件
#include "nav2_util/robot_utils.hpp"


namespace nav2_custom_planner {
// 自定义导航规划器类
class CustomPlanner : public nav2_core::GlobalPlanner {
public:
  CustomPlanner() = default;
  ~CustomPlanner() = default;
  // 插件配置方法
  void configure(
      const rclcpp_lifecycle::LifecycleNode::WeakPtr &parent, std::string name,
      std::shared_ptr<tf2_ros::Buffer> tf,
      std::shared_ptr<nav2_costmap_2d::Costmap2DROS> costmap_ros) override;
  // 插件清理方法
  void cleanup() override;
  // 插件激活方法
  void activate() override;
  // 插件停用方法
  void deactivate() override;
  // 为给定的起始和目标位姿创建路径的方法
  nav_msgs::msg::Path
  createPlan(const geometry_msgs::msg::PoseStamped &start,
             const geometry_msgs::msg::PoseStamped &goal) override;

private:
  // 坐标变换缓存指针，可用于查询坐标关系
  std::shared_ptr<tf2_ros::Buffer> tf_;
  // 节点指针, 传过来的参数
  nav2_util::LifecycleNode::SharedPtr node_;
  // 全局代价地图
  nav2_costmap_2d::Costmap2D *costmap_;
  // 全局代价地图的坐标系, 插件的名字
  std::string global_frame_, name_;
  // 插值分辨率
  double interpolation_resolution_;
};

} // namespace nav2_custom_planner

#endif // NAV2_CUSTOM_PLANNER__NAV2_CUSTOM_PLANNER_HPP_
```

基础的C文件实现

```cpp
#include "nav2_util/node_utils.hpp"
#include <cmath>
#include <memory>
#include <string>

#include "nav2_core/exceptions.hpp"
#include "nav2_custom_planner/nav2_custom_planner.hpp"

namespace nav2_custom_planner
{

    void CustomPlanner::configure(
        const rclcpp_lifecycle::LifecycleNode::WeakPtr &parent, std::string name,
        std::shared_ptr<tf2_ros::Buffer> tf,
        std::shared_ptr<nav2_costmap_2d::Costmap2DROS> costmap_ros)
    {
        tf_ = tf;
        node_ = parent.lock();
        name_ = name;
        costmap_ = costmap_ros->getCostmap();
        global_frame_ = costmap_ros->getGlobalFrameID();
        // 参数初始化
        nav2_util::declare_parameter_if_not_declared(
            node_, name_ + ".interpolation_resolution", rclcpp::ParameterValue(0.1));
        node_->get_parameter(name_ + ".interpolation_resolution",
                             interpolation_resolution_);
    }

    void CustomPlanner::cleanup()
    {
        RCLCPP_INFO(node_->get_logger(), "正在清理类型为 CustomPlanner 的插件 %s",
                    name_.c_str());
    }

    void CustomPlanner::activate()
    {
        RCLCPP_INFO(node_->get_logger(), "正在激活类型为 CustomPlanner 的插件 %s",
                    name_.c_str());
    }

    void CustomPlanner::deactivate()
    {
        RCLCPP_INFO(node_->get_logger(), "正在停用类型为 CustomPlanner 的插件 %s",
                    name_.c_str());
    }

    nav_msgs::msg::Path
    CustomPlanner::createPlan(const geometry_msgs::msg::PoseStamped &start,
                              const geometry_msgs::msg::PoseStamped &goal)
    {
        // 1.声明并初始化 global_path
        nav_msgs::msg::Path global_path;
        return global_path;
    }

} // namespace nav2_custom_planner

#include "pluginlib/class_list_macros.hpp"
PLUGINLIB_EXPORT_CLASS(nav2_custom_planner::CustomPlanner,
                       nav2_core::GlobalPlanner)
```

对应一个xml文件

```xml
<library path="nav2_custom_planner_plugin">
	<class name="nav2_custom_planner/CustomPlanner" type="nav2_custom_planner::CustomPlanner" base_class_type="nav2_core::GlobalPlanner">
	  <description>是一个自定义示例插件，用于生成自定义路径。</description>
	</class>
</library>
```

添加Cmake文件的配置

```cmake
# 包含头文件目录
include_directories(include)
# 定义库名称
set(library_name ${PROJECT_NAME}_plugin)
# 创建共享库
add_library(${library_name} SHARED  src/nav2_custom_planner.cpp)
# 指定库的依赖关系
ament_target_dependencies(${library_name} nav2_core pluginlib)
# 安装库文件到指定目录
install(TARGETS ${library_name}
  ARCHIVE DESTINATION lib
  LIBRARY DESTINATION lib
  RUNTIME DESTINATION lib/${PROJECT_NAME}
)
# 安装头文件到指定目录
install(DIRECTORY include/
  DESTINATION include/ )
# 导出插件描述文件
pluginlib_export_plugin_description_file(nav2_core custom_planner_plugin.xml)
```

对应的插件的描述需要放在配置文件的xml里面

```xml
  <export>
    <build_type>ament_cmake</build_type>
    <nav2_core plugin="${prefix}/custom_planner_plugin.xml" />
  </export>
</package>
```

### 直线算法

```cpp
nav_msgs::msg::Path
CustomPlanner::createPlan(const geometry_msgs::msg::PoseStamped &start,
                          const geometry_msgs::msg::PoseStamped &goal)
{
    // 1.声明并初始化 global_path
    nav_msgs::msg::Path global_path;
    global_path.poses.clear();
    global_path.header.stamp = node_->now();
    global_path.header.frame_id = global_frame_;

    // 2.检查目标和起始状态是否在全局坐标系中
    if (start.header.frame_id != global_frame_)
    {
        RCLCPP_ERROR(node_->get_logger(), "规划器仅接受来自 %s 坐标系的起始位置",
                     global_frame_.c_str());
        return global_path;
    }

    if (goal.header.frame_id != global_frame_)
    {
        RCLCPP_INFO(node_->get_logger(), "规划器仅接受来自 %s 坐标系的目标位置",
                    global_frame_.c_str());
        return global_path;
    }

    // 3.计算当前插值分辨率 interpolation_resolution_ 下的循环次数和步进值
    // 使用欧几里得距离计算起点到终点的距离，并据此计算需要多少个插值点
    int total_number_of_loop =
        std::hypot(goal.pose.position.x - start.pose.position.x,
                   goal.pose.position.y - start.pose.position.y) /
        interpolation_resolution_;
    // 计算每一步的增量
    double x_increment =
        (goal.pose.position.x - start.pose.position.x) / total_number_of_loop;
    double y_increment =
        (goal.pose.position.y - start.pose.position.y) / total_number_of_loop;

    // 4. 生成路径
    for (int i = 0; i < total_number_of_loop; ++i)
    {
        geometry_msgs::msg::PoseStamped pose; // 生成一个点
        pose.pose.position.x = start.pose.position.x + x_increment * i;
        pose.pose.position.y = start.pose.position.y + y_increment * i;
        pose.pose.position.z = 0.0;
        pose.header.stamp = node_->now();
        pose.header.frame_id = global_frame_;
        // 将该点放到路径中
        global_path.poses.push_back(pose);
    }

    // 5.使用 costmap 检查该条路径是否经过障碍物
    for (geometry_msgs::msg::PoseStamped pose : global_path.poses)
    {
        unsigned int mx, my; // 将点的坐标转换为栅格坐标
        if (costmap_->worldToMap(pose.pose.position.x, pose.pose.position.y, mx, my))
        {
            unsigned char cost = costmap_->getCost(mx, my); // 获取对应栅格的代价值
            // 如果存在致命障碍物则抛出异常
            if (cost == nav2_costmap_2d::LETHAL_OBSTACLE)
            {
                RCLCPP_WARN(node_->get_logger(),"在(%f,%f)检测到致命障碍物，规划失败。",
                    pose.pose.position.x, pose.pose.position.y);
                throw nav2_core::PlannerException(
                    "无法创建目标规划: " + std::to_string(goal.pose.position.x) + "," +
                    std::to_string(goal.pose.position.y));
            }
        }
    }

    // 6.收尾，将目标点作为路径的最后一个点并返回路径
    geometry_msgs::msg::PoseStamped goal_pose = goal;
    goal_pose.header.stamp = node_->now();
    goal_pose.header.frame_id = global_frame_;
    global_path.poses.push_back(goal_pose);
    return global_path;
}
```

## 使用插件

插件的使用是在planner_server里面的, 所以需要更改对应的配置

```yaml
planner_server:
  ros__parameters:
    expected_planner_frequency: 20.0
    use_sim_time: True
    planner_plugins: ["GridBased"]
    GridBased:
      plugin: "nav2_custom_planner/CustomPlanner"
      interpolation_resolution: 0.1
```





