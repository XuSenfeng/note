# 消息过滤器同步

`message_filters`是 ROS 提供的一套**消息处理工具集**，它封装了普通的话题订阅逻辑，解决了单纯`create_subscription`无法高效处理的场景 —— 比如 “同步多个话题的消息”“按条件过滤消息”“缓存消息供后续回溯” 等。普通订阅器是 “来一个消息处理一个”，而`message_filters`能让你对消息做 “筛选、排序、同步、缓存” 等精细化操作，是 ROS 开发中处理多传感器数据的核心工具。

+ Subscriber: 订阅者, 消息过滤器中的订阅者是基于ROS2里面的订阅者封装而来, 主要是配合时间同步器使用, 使用的时候可以为他注册单独的回调函数, 收到订阅消息的时候使用回调函数
+ Sync Policies: 同步策略, ROS2 里面提供多个同步策略的实现, 有严格的时间对齐, 大约时间对齐, 最新时间对齐
+ Synchronizer: 时间同步器, 我们把同步策略以及订阅者传递给时间同步器, 由他实现时间同步, 调用相关回调函数传递同步结果

严格时间同步: 只有当`Imu`消息和`Odometry`消息的`header.stamp`（时间戳）**精确到纳秒完全一致**时，才会触发同步回调。哪怕两个消息的时间戳差 1 纳秒，也会被判定为 “不同步”，消息会被缓存 / 丢弃，回调不触发。

近似时间同步: 不要求时间戳完全一致，只要`Imu`和`Odometry`消息的时间戳差值在你设定的`slop`（时间容忍度，单位：秒）范围内，就认为是 “同步的”，触发回调。

最新时间同步: 只要任意一个话题（比如 IMU）有新消息到达，就立刻取该话题的 “最新消息” + 其他话题（比如 Odometry）缓存中 “最新的消息”，组合起来触发一次回调。

## 实现

### python

```python
import rclpy
from rclpy.node import Node
from sensor_msgs.msg import Imu
from nav_msgs.msg import Odometry
from message_filters import Subscriber, ApproximateTimeSynchronizer

class TimeSyncTestNode(Node):
    def __init__(self):
        super().__init__('sync_node')
        # 1. 订阅 imu 话题并注册回调并打印时间戳
        self.imu_sub = Subscriber(self, Imu, 'imu')
        self.imu_sub.registerCallback(self.imu_callback)
        # 2. 订阅 odom 话题并注册回调函数打印时间戳
        self.odom_sub = Subscriber(self, Odometry, 'odom')
        self.odom_sub.registerCallback(self.odom_callback)
        # 3. 创建对应策略的同步器同步两个话题，并注册回调函数打印数据
        # 两个消息的时间戳小于0.01s的时候, 使用回调函数
        self.synchronizer = ApproximateTimeSynchronizer(
            [self.imu_sub, self.odom_sub], 10,
            slop=0.01,  # slop 表示时间窗口单位为秒
        )
        self.synchronizer.registerCallback(self.result_callback)

    def imu_callback(self, imu_msg):
        self.get_logger().info(
            f'imu({imu_msg.header.stamp.sec},{imu_msg.header.stamp.nanosec})')

    def odom_callback(self, odom_msg):
        self.get_logger().info(
            f'odom({odom_msg.header.stamp.sec},{odom_msg.header.stamp.nanosec})')

    def result_callback(self, imu_msg, odom_msg):
        self.get_logger().info(
            f'imu({imu_msg.header.stamp.sec},{imu_msg.header.stamp.nanosec}),odom({odom_msg.header.stamp.sec},{odom_msg.header.stamp.nanosec})')


def main(args=None):
    rclpy.init(args=args)
    node = TimeSyncTestNode()
    rclpy.spin(node)
    rclpy.shutdown()
```

### cpp

```cpp
#include "message_filters/subscriber.h"
#include "message_filters/sync_policies/approximate_time.h"
#include "message_filters/sync_policies/exact_time.h"
#include "message_filters/sync_policies/latest_time.h"
#include "message_filters/time_synchronizer.h"
#include "nav_msgs/msg/odometry.hpp"
#include "rclcpp/rclcpp.hpp"
#include "sensor_msgs/msg/imu.hpp"

using Imu = sensor_msgs::msg::Imu;
using Odometry = nav_msgs::msg::Odometry;
using namespace message_filters;

// 同步策略：严格时间对齐策略
// using MySyncPolicy = sync_policies::ExactTime<Imu, Odometry>;
// 同步策略：大约时间对齐策略
// using MySyncPolicy = sync_policies::ApproximateTime<Imu, Odometry>;
// 同步策略：最新时间对齐策略
using MySyncPolicy = sync_policies::LatestTime<Imu, Odometry>;


class TimeSyncTestNode : public rclcpp::Node {
public:
  TimeSyncTestNode() : Node("sync_node") {
    // 1.订阅 imu 话题并注册回调并打印时间戳
    imu_sub_ = std::make_shared<Subscriber<Imu>>(this, "imu");
    imu_sub_->registerCallback<Imu::SharedPtr>(
        [&](const Imu::SharedPtr &imu_msg) {
          RCLCPP_INFO(get_logger(), "imu(%u,%u)", imu_msg->header.stamp.sec,
                      imu_msg->header.stamp.nanosec);
        });
    // 2.订阅 odom 话题并注册回调函数打印时间戳
    odom_sub_ = std::make_shared<Subscriber<Odometry>>(this, "odom");
    odom_sub_->registerCallback<Odometry::SharedPtr>(
        [&](const Odometry::SharedPtr &odom_msg) {
          RCLCPP_INFO(get_logger(), "odom(%u,%u)", odom_msg->header.stamp.sec,
                      odom_msg->header.stamp.nanosec);
        });
    // 3.创建对应策略的同步器同步两个话题，并注册回调函数打印数据
    // synchronizer_ = std::make_shared<Synchronizer<MySyncPolicy>>(
    //     MySyncPolicy(10), *imu_sub_, *odom_sub_);
    
    // 3.创建对应策略的同步器同步两个话题，并注册回调函数打印数据
    synchronizer_ = std::make_shared<Synchronizer<MySyncPolicy>>(
        MySyncPolicy(), *imu_sub_, *odom_sub_);
    synchronizer_->registerCallback(
        std::bind(&TimeSyncTestNode::result_callback, this,
                  std::placeholders::_1, std::placeholders::_2));
  }

private:
  void result_callback(const Imu::ConstSharedPtr imu_msg,
                       const Odometry::ConstSharedPtr odom_msg) {
    RCLCPP_INFO(get_logger(), "imu(%u,%u),odom(%u,%u))",
                imu_msg->header.stamp.sec, imu_msg->header.stamp.nanosec,
                odom_msg->header.stamp.sec, odom_msg->header.stamp.nanosec);
  }

  std::shared_ptr<Subscriber<Imu>> imu_sub_;
  std::shared_ptr<Subscriber<Odometry>> odom_sub_;
  std::shared_ptr<Synchronizer<MySyncPolicy>> synchronizer_;
};

int main(int argc, char **argv) {
  rclcpp::init(argc, argv);
  auto node = std::make_shared<TimeSyncTestNode>();
  rclcpp::spin(node);
  rclcpp::shutdown();
  return 0;
}
```

