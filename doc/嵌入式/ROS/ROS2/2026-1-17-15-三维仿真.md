# 三维仿真

机器人三维物理仿真平台**Gazebo**是ROS系统中最为常用的**三维物理仿真平台**，支持动力学引擎，可以实现高质量的图形渲染，不仅可以模拟机器人及周边环境，还可以加入摩擦力、弹性系数等物理属性

```bash
sudo apt install ros-humble-gazebo-*
```

可以帮助我们验证机器人算法、优化机器人设计、测试机器人场景应用，为机器人开发提供更多可能。

```bash
export SVGA_VGPU=0 # 使用CPU
export LIBGL_ALWAYS_SOFTWARE=1
ros2 launch gazebo_ros gazebo.launch.py
```

## 模型

### XACRO

可以使用DRDF模型优化以后, 使用XACRO文件描述, XACRO文件加入了更多编程化的实现方法，可以让模型创建更友好。

- **宏定义**，一个小车有4个轮子，每个轮子都一样，我们就没必要创建4个一样的link，像函数定义一样，做一个可重复使用的模块就可以了。
- **文件包含**，复杂机器人的模型文件可能会很长，为了切分不同的模块，比如底盘、传感器，我们还可以把不同模块的模型放置在不同的文件中，然后再用一个总体文件做包含调用。
- **可编程接口**，比如在XACRO模型文件中，定义一些常量，描述机器人的尺寸，定义一些变量，在调用宏定义的时候传递数据，还可以在模型中做数据计算，甚至加入条件语句，比如你的机器人叫A，就有摄像头，如果叫B，就没有摄像头。

```bash
$ sudo apt install ros-humble-xacro
```

#### 常量

![image-20220528150321426](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601171633332.png)

`<xacro:property>`标签用来定义一些常量，比如这样定义一个PI的常量名为“M_PI”，值为“3.14159”，在调用的时候，通过$加大括号，里边就可以使用定义好的常量了

针对原本移动机器人的URDF文件，我们就可以把底盘的质量、尺寸，轮子的质量、尺寸、安装位置，这些不会变化的数据，都通过常量定义

![image-20220528150338969](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601171634534.png)

#### 数学计算

![image-20220528150430205](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601171634432.png)

如果需要做数学计算，同样是在“${}”中进行，比如某一个位置，我们可以通过这两个常量做运算得到，就加入了加法和除法运算

> 所有数学运算都会转换成浮点数进行，以保证运算精度

#### 宏定义

![image-20220528150542643](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601171635886.png)

定义方式是通过这个<xacro:macro>标签描述的，还可以像函数一样，设置里边会用到的一些参数，比如这里的A、B、C

#### 引用文件

![image-20220528150712684](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601171635325.png)

### 仿真配置参数

确保每一个link都有惯性参数和碰撞属性，因为Gazebo是物理仿真平台，必要的物理参数是一定需要的

+ 完善物理参数![image-20220528150842585](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601171638577.png)
+ 添加Gazebo标签渲染每一个link的颜色![image-20220528150931153](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601171640434.png)
+ 给运动的joint设置传动装置, 可以理解为仿真了一个电机![image-20220528150958309](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601171640206.png)
+ 添加控制器插件小车是差速控制的，那就添加差速控制器插件，这样在不同角度下两个电机的速度分配，就可以交给控制器插件来完成了![image-20220528151019063](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601171640100.png)

## 实战

### xacro文件

```xml
<?xml version="1.0"?>
<!-- 只有主文件里面使用name这个参数 -->
<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="first_robot">

    <xacro:macro name="base_link" params="length radius">
        <!-- 身体部分 -->
        <link name="base_link">
            <!-- 外观描述-->
            <visual>
                <!-- 描述沿着自己几何中心的位移以及旋转 -->
                <origin xyz="0.0 0.0 0.0" rpy="0.0 0.0 0.0"/>
                <!-- 形状描述, 单位 米 -->
                <geometry>
                    <cylinder radius="${radius}" length="${length}"/>
                </geometry> 
                <!-- 颜色描述 -->
                <material name="white">
                    <color rgba="1.0 1.0 1.0 0.5"/>
                </material>
            </visual>
        </link>
    </xacro:macro>

    <xacro:macro name="imu_link" params="name xyz">
        <!-- 机器人的IMU, 惯性测量传感器 -->
        <link name="${name}">
            <!-- 外观描述-->
            <visual>
                <!-- 描述沿着自己几何中心的位移以及旋转 -->
                <origin xyz="0.0 0.0 0.0" rpy="0.0 0.0 0.0"/>
                <!-- 形状描述, 单位 米 正方体 -->
                <geometry>
                    <box size="0.02 0.02 0.02"/>
                </geometry> 
                <!-- 颜色描述 -->
                <material name="black">
                    <color rgba="0.0 0.0 0.0 0.5"/>
                </material>
            </visual>
        </link>

        <!-- 连接身体和IMU的关节, 把IMU固定在身体上 -->
        <joint name="${name}_joint" type="fixed">
            <origin xyz="${xyz}" rpy="0.0 0.0 0.0"/>
            <parent link="base_link"/>
            <child link="${name}"/>
        </joint>
    </xacro:macro>

    <xacro:base_link length="0.12" radius="0.10">
    <xacro:imu_link name="imu_link" xyz="0.0 0.0 0.03">
    <xacro:imu_link name="imu_link_2" xyz="0.0 0.0 -0.03">
</robot>
```

### 预处理

需要把这个文件转为urdf文件

```bash
sudo apt-get install ros-$ROS_DISTRO-xacro
xacro first_robot.xacro # 直接输出转换后的文件
```

之后可以直接使用这个命令输入给描述生成launch

```python
import launch
import launch_ros
from ament_index_python.packages import get_package_share_directory
import os

def generate_launch_description():
    pkg_share = get_package_share_directory('bot_3D_desc')
    default_urdf_file_path = os.path.join(pkg_share, 'urdf', 'first_robot.xacro')
    default_rviz_config_path = os.path.join(pkg_share, 'config', 'display_robot.rviz')
    # 构建一个参数可以供外部传入URDF文件路径
    action_declear_arg_mode_path = launch.actions.DeclareLaunchArgument(
        name="model",
        default_value=default_urdf_file_path,
        description="Absolute path to robot urdf file"
    )
    # 读取文件的内容作为参数值
    command_result = launch.substitutions.Command(
        ['xacro ', launch.substitutions.LaunchConfiguration('model')]
    )
    robot_desc_value = launch_ros.parameter_descriptions.ParameterValue(
        command_result,
        value_type=str
    )
    # 节点：用于发布机器人状态信息
    action_robot_state_publisher = launch_ros.actions.Node(
        package='robot_state_publisher',
        executable='robot_state_publisher',
        name='robot_state_publisher',
        parameters=[{'robot_description': robot_desc_value}]
    )

    action_joint_state_publisher = launch_ros.actions.Node(
        package='joint_state_publisher',
        executable='joint_state_publisher',
        name='joint_state_publisher',
    )

    action_rviz_node = launch_ros.actions.Node(
        package='rviz2',
        executable='rviz2',
        name='rviz2',
        arguments=['-d', default_rviz_config_path],
    )


    return launch.LaunchDescription([
        action_declear_arg_mode_path,
        action_robot_state_publisher,
        action_joint_state_publisher,
        action_rviz_node
    ])
```

### 实际实现

#### 基座

```xml
<?xml version="1.0"?>
<robot xmlns:xacro="http://www.ros.org/wiki/xacro">

    <xacro:macro name="base_xacro" params="length radius">
        <!-- 地面投影, 无实际的显示 -->
        <link name="base_footprint"/>

        <!-- 身体部分 -->
        <link name="base_link">
            <!-- 外观描述-->
            <visual>
                <!-- 描述沿着自己几何中心的位移以及旋转 -->
                <origin xyz="0.0 0.0 0.0" rpy="0.0 0.0 0.0"/>
                <!-- 形状描述, 单位 米 -->
                <geometry>
                    <cylinder radius="${radius}" length="${length}"/>
                </geometry> 
                <!-- 颜色描述 -->
                <material name="white">
                    <color rgba="1.0 1.0 1.0 0.5"/>
                </material>
            </visual>
            <collision>
                <!-- 描述沿着自己几何中心的位移以及旋转 -->
                <origin xyz="0.0 0.0 0.0" rpy="0.0 0.0 0.0"/>
                <!-- 形状描述, 单位 米 -->
                <geometry>
                    <cylinder radius="${radius}" length="${length}"/>
                </geometry> 
                <!-- 颜色描述 -->
                <material name="white">
                    <color rgba="1.0 1.0 1.0 0.5"/>
                </material>
            </collision>
        </link>
        <!-- 绑定一个虚拟地面 -->
        <joint name="joint_name" type="fixed">
            <origin xyz="0.0 0.0 ${length/2 + 0.032 - 0.001}" rpy="0.0 0.0 0.0"/>
            <parent link="base_footprint"/>
            <child link="base_link"/>
        </joint>
    </xacro:macro>

</robot>
```

#### 传感器

雷达

```xml
<?xml version="1.0"?>
<robot xmlns:xacro="http://www.ros.org/wiki/xacro">
    <xacro:macro name="laser_xacro" params="xyz">
        <!-- 雷达支撑杆 -->
        <link name="laser_cylinder_link">
            <!-- 外观描述-->
            <visual>
                <!-- 描述沿着自己几何中心的位移以及旋转 -->
                <origin xyz="0.0 0.0 0.0" rpy="0.0 0.0 0.0"/>
                <!-- 形状描述, 单位 米 圆柱体 -->
                <geometry>
                    <cylinder radius="0.01" length="0.1"/>
                </geometry> 
                <!-- 颜色描述 -->
                <material name="black">
                    <color rgba="0.0 0.0 0.0 1.5"/>
                </material>
            </visual>
            <collision>
                <!-- 描述沿着自己几何中心的位移以及旋转 -->
                <origin xyz="0.0 0.0 0.0" rpy="0.0 0.0 0.0"/>
                <!-- 形状描述, 单位 米 圆柱体 -->
                <geometry>
                    <cylinder radius="0.01" length="0.1"/>
                </geometry> 
                <!-- 颜色描述 -->
                <material name="black">
                    <color rgba="0.0 0.0 0.0 1.5"/>
                </material>
            </collision>
        </link>

        <!-- 雷达传感器 -->
        <link name="laser_link">
            <!-- 外观描述-->
            <visual>
                <!-- 描述沿着自己几何中心的位移以及旋转 -->
                <origin xyz="0.0 0.0 0.0" rpy="0.0 0.0 0.0"/>
                <!-- 形状描述, 单位 米 圆柱体 -->
                <geometry>
                    <cylinder radius="0.02" length="0.02"/>
                </geometry> 
                <!-- 颜色描述 -->
                <material name="black">
                    <color rgba="0.0 0.0 0.0 1.0"/>
                </material>
            </visual>
        </link>

        <!-- 连接身体和激光传感器的关节, 把激光传感器固定在身体上 -->
        <joint name="laser_cylinder_joint" type="fixed">
            <origin xyz="0.0 0.0 0.05" rpy="0.0 0.0 0.0"/>
            <parent link="laser_cylinder_link"/>
            <child link="laser_link"/>
        </joint>
        <joint name="laser_joint" type="fixed">
            <origin xyz="${xyz}" rpy="0.0 0.0 0.0"/>
            <parent link="base_link"/>
            <child link="laser_cylinder_link"/>
        </joint>
    </xacro:macro>
</robot>
```

#### 执行器件

轮子

```xml
<?xml version="1.0"?>
<robot xmlns:xacro="http://www.ros.org/wiki/xacro">
    <xacro:macro name="wheel_xacro" params="wheel_name xyz">
        <!-- 机器人的驱动轮胎 -->
        <link name="${wheel_name}_link">
            <!-- 外观描述-->
            <visual>
                <!-- 描述沿着自己几何中心的位移以及旋转 -->
                <origin xyz="0.0 0.0 0.0" rpy="1.57079 0.0 0.0"/>
                <!-- 形状描述, 单位 米 圆柱体 -->
                <geometry>
                    <cylinder radius="0.032" length="0.04"/>
                </geometry> 
                <!-- 颜色描述 -->
                <material name="yellow">
                    <color rgba="1.0 1.0 0.0 0.8"/>
                </material>
            </visual>
            <collision>
                <!-- 描述沿着自己几何中心的位移以及旋转 -->
                <origin xyz="0.0 0.0 0.0" rpy="1.57079 0.0 0.0"/>
                <!-- 形状描述, 单位 米 圆柱体 -->
                <geometry>
                    <cylinder radius="0.032" length="0.04"/>
                </geometry> 
                <!-- 颜色描述 -->
                <material name="yellow">
                    <color rgba="1.0 1.0 0.0 0.8"/>
                </material>
            </collision>
        </link>

        <!-- 连接身体和IMU的关节, 把IMU固定在身体上 -->
        <joint name="${wheel_name}_joint" type="continuous">
            <origin xyz="${xyz}" rpy="0.0 0.0 0.0"/>
            <parent link="base_link"/>
            <child link="${wheel_name}_link"/>
            <!-- 绕 Y 轴旋转 -->
            <axis xyz="0.0 1.0 0.0"/>
        </joint>
    </xacro:macro>
</robot>
```

#### 合并

```xml
<?xml version="1.0"?>
<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="fishbot">

    <xacro:include filename="$(find bot_3D_desc)/urdf/fishbot/base.urdf.xacro"/>
    <xacro:include filename="$(find bot_3D_desc)/urdf/fishbot/sensor/imu.urdf.xacro"/>
    <xacro:include filename="$(find bot_3D_desc)/urdf/fishbot/sensor/camera.urdf.xacro"/>
    <xacro:include filename="$(find bot_3D_desc)/urdf/fishbot/sensor/laser.urdf.xacro"/>
    <xacro:include filename="$(find bot_3D_desc)/urdf/fishbot/actuator/wheel.urdf.xacro"/>
    <xacro:include filename="$(find bot_3D_desc)/urdf/fishbot/actuator/caster.urdf.xacro"/>

    <xacro:base_xacro length="0.12" radius="0.10"/>
    <xacro:imu_xacro xyz="0.0 0.0 0.02"/>
    <xacro:camera_xacro xyz="0.10 0.0 0.075"/>
    <xacro:laser_xacro xyz="0.0 0.0 0.10"/>
    <xacro:wheel_xacro wheel_name="left_wheel" xyz="0.0 0.10 -0.06"/>
    <xacro:wheel_xacro wheel_name="right_wheel" xyz="0.0 -0.10 -0.06"/>
    <xacro:caster_xacro caster_name="front_wheel" xyz="0.08 0.0 -0.076"/>
    <xacro:caster_xacro caster_name="back_wheel" xyz="-0.08 0.0 -0.076"/>
</robot>
```

![image-20260121155149069](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601211551237.png)

### 添加物理属性

机器人是有质量以及惯性的, 曹亮可以使用一个数字千克表示, 旋转惯性需要使用一个3x3的矩阵表示

![image-20260121185203662](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601211852795.png)

这里面有一部分的数字是重复的, 可以使用六个数字表示, 一般可以从建模软件里面获取, 

![image-20260121190617562](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601211906642.png)

可以直接使用下面的这几个公式进行计算

```xml
<?xml version="1.0"?>
<robot xmlns:xacro="http://ros.org/wiki/xacro">
    <xacro:macro name="box_inertia" params="m w h d">
        <inertial>
            <mass value="${m}" />
            <inertia ixx="${(m/12) * (h*h + d*d)}" ixy="0.0" ixz="0.0" iyy="${(m/12) * (w*w + d*d)}" iyz="0.0" izz="${(m/12) * (w*w + h*h)}" />
        </inertial>
    </xacro:macro>

    <xacro:macro name="cylinder_inertia" params="m r h">
        <inertial>
            <mass value="${m}" />
            <inertia ixx="${(m/12) * (3*r*r + h*h)}" ixy="0" ixz="0" iyy="${(m/12) * (3*r*r + h*h)}" iyz="0" izz="${(m/2) * (r*r)}" />
        </inertial>
    </xacro:macro>

    <xacro:macro name="sphere_inertia" params="m r">
        <inertial>
            <mass value="${m}" />
            <inertia ixx="${(2/5) * m * (r*r)}" ixy="0.0" ixz="0.0" iyy="${(2/5) * m * (r*r)}" iyz="0.0" izz="${(2/5) * m * (r*r)}" />
        </inertial>
    </xacro:macro>

</robot>
```

![image-20260121192133618](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601211921725.png)

![image-20260121193439175](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601211934306.png)
