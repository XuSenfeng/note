# 话题

实现节点之间的数据传输, 实现异步通信

## 实现

### 发布者

```python
import rclpy                                     # ROS2 Python接口库
from rclpy.node import Node                      # ROS2 节点类
from std_msgs.msg import String                  # 字符串消息类型

"""
创建一个发布者节点
"""
class PublisherNode(Node):
    
    def __init__(self, name):
        # ROS2节点父类初始化
        super().__init__(name)       
        # 创建发布者对象（消息类型、话题名、队列长度）
        self.pub = self.create_publisher(String, "chatter", 10)   
        # 创建一个定时器（单位为秒的周期，定时执行的回调函数）
        self.timer = self.create_timer(0.5, self.timer_callback)  
    # 创建定时器周期执行的回调函数
    def timer_callback(self):
        # 创建一个String类型的消息对象
        msg = String()
        # 填充消息对象中的消息数据
        msg.data = 'Hello World'
        # 发布话题消息
        self.pub.publish(msg)
        # 输出日志信息，提示已经完成话题发布
        self.get_logger().info('Publishing: "%s"' % msg.data)     
# ROS2节点主入口main函数
def main(args=None):
    # ROS2 Python接口初始化
    rclpy.init(args=args)                            
    # 创建ROS2节点对象并进行初始化
    node = PublisherNode("topic_helloworld_pub")     
    rclpy.spin(node)                                 # 循环等待ROS2退出
    node.destroy_node()                              # 销毁节点对象
    rclpy.shutdown()                                 # 关闭ROS2 Python接口
```

### 接受者

```python
import rclpy                                     # ROS2 Python接口库
from rclpy.node   import Node                    # ROS2 节点类
from std_msgs.msg import String                  # ROS2标准定义的String消息

"""
创建一个订阅者节点
"""
class SubscriberNode(Node):
    def __init__(self, name):
        super().__init__(name)
        # 创建订阅者对象（消息类型、话题名、订阅者回调函数、队列长度）
        self.sub = self.create_subscription(\
            String, "chatter", self.listener_callback, 10)        
	# 创建回调函数，执行收到话题消息后对数据的处理
    def listener_callback(self, msg):=
        # 输出日志信息，提示订阅收到的话题消息
        self.get_logger().info('I heard: "%s"' % msg.data)
        
# ROS2节点主入口main函数
def main(args=None):
    # ROS2 Python接口初始化
    rclpy.init(args=args)
    # 创建ROS2节点对象并进行初始化
    node = SubscriberNode("topic_helloworld_sub")    
    rclpy.spin(node)                                 # 循环等待ROS2退出
    node.destroy_node()                              # 销毁节点对象
    rclpy.shutdown()                                 # 关闭ROS2 Python接口
```

### 传输图像示例

```python
import rclpy                        # ROS2 Python接口库
from rclpy.node import Node         # ROS2 节点类
from sensor_msgs.msg import Image   # 图像消息类型
from cv_bridge import CvBridge      # ROS与OpenCV图像转换类
import cv2                          # Opencv图像处理库

"""
创建一个发布者节点
"""
class ImagePublisher(Node):

    def __init__(self, name):
        super().__init__(name)
        # 创建发布者对象（消息类型、话题名、队列长度）
        self.publisher_ = self.create_publisher(Image, 'image_raw', 10)  
        self.timer = self.create_timer(0.1, self.timer_callback)
        # 创建一个视频采集对象，驱动相机采集图像（相机设备号）
        self.cap = cv2.VideoCapture(0)
        # 创建一个图像转换对象，用于稍后将OpenCV的图像转换成ROS的图像消息
        self.cv_bridge = CvBridge()

    def timer_callback(self):
        ret, frame = self.cap.read()
        if ret == True:
            # 发布图像消息
            self.publisher_.publish(
                self.cv_bridge.cv2_to_imgmsg(frame, 'bgr8'))
        # 输出日志信息，提示已经完成图像话题发布
        self.get_logger().info('Publishing video frame')

def main(args=None):
    rclpy.init(args=args)
    node = ImagePublisher("topic_webcam_pub")
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()
```

```python
import rclpy                            # ROS2 Python接口库
from rclpy.node import Node             # ROS2 节点类
from sensor_msgs.msg import Image       # 图像消息类型
from cv_bridge import CvBridge          # ROS与OpenCV图像转换类
import cv2                              # Opencv图像处理库
import numpy as np                      # Python数值计算库

lower_red = np.array([0, 90, 128])      # 红色的HSV阈值下限
upper_red = np.array([180, 255, 255])   # 红色的HSV阈值上限

"""
创建一个订阅者节点
"""
class ImageSubscriber(Node):
    def __init__(self, name):
        # ROS2节点父类初始化
        super().__init__(name)
        # 创建订阅者对象（消息类型、话题名、订阅者回调函数、队列长度）
        self.sub = self.create_subscription(
            Image, 'image_raw', self.listener_callback, 10)
        # 创建一个图像转换对象，用于OpenCV图像与ROS的图像消息的互相转换
        self.cv_bridge = CvBridge()

    def object_detect(self, image):
        # 图像从BGR颜色模型转换为HSV模型
        hsv_img = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)
        # 图像二值化
        mask_red = cv2.inRange(hsv_img, lower_red, upper_red)
        # 图像中轮廓检测
        contours, hierarchy = cv2.findContours(
            mask_red, cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE)
		# 去除一些轮廓面积太小的噪声
        for cnt in contours:
            if cnt.shape[0] < 150:
                continue
			# 得到苹果所在轮廓的左上角xy像素坐标及轮廓范围的宽和高
            (x, y, w, h) = cv2.boundingRect(cnt)
            # 将苹果的轮廓勾勒出来
            cv2.drawContours(image, [cnt], -1, (0, 255, 0), 2)
            # 将苹果的图像中心点画出来
            cv2.circle(image, (int(x+w/2), int(y+h/2)), 5,
                       (0, 255, 0), -1)
		# 使用OpenCV显示处理后的图像效果
        cv2.imshow("object", image)                             
        cv2.waitKey(10)

    def listener_callback(self, data):
        # 输出日志信息，提示已进入回调函数
        self.get_logger().info('Receiving video frame')
        # 将ROS的图像消息转化成OpenCV图像
        image = self.cv_bridge.imgmsg_to_cv2(data, 'bgr8')
        # 苹果检测
        self.object_detect(image)

def main(args=None):                                        
    rclpy.init(args=args)                                   
    node = ImageSubscriber("topic_webcam_sub")              
    rclpy.spin(node)                                        
    node.destroy_node()
    rclpy.shutdown()
```

### 通用USB相机驱动

```bash
# 通用的相机驱动
$ sudo apt install ros-humble-usb-cam
# 发布摄像头在image_raw节点
$ ros2 run usb_cam usb_cam_node_exe
```

### cpp

```cpp
#include <chrono>
#include <functional>
#include <memory>
#include <string>

#include "rclcpp/rclcpp.hpp"          // ROS2 C++接口库
#include "std_msgs/msg/string.hpp"    // 字符串消息类型

using namespace std::chrono_literals;


class PublisherNode : public rclcpp::Node
{
    public:
        PublisherNode()
        : Node("topic_helloworld_pub") // ROS2节点父类初始化
        {
            // 创建发布者对象（消息类型、话题名、队列长度）
            publisher_ = this->create_publisher<std_msgs::msg::String>("chatter", 10); 
            // 创建一个定时器,定时执行回调函数
            timer_ = this->create_wall_timer(
                500ms, std::bind(&PublisherNode::timer_callback, this));
        }

    private:
        // 创建定时器周期执行的回调函数
        void timer_callback()
        {
          // 创建一个String类型的消息对象
          auto msg = std_msgs::msg::String();
          // 填充消息对象中的消息数据
          msg.data = "Hello World";
          // 发布话题消息
          RCLCPP_INFO(this->get_logger(), "Publishing: '%s'", msg.data.c_str());
          // 输出日志信息，提示已经完成话题发布   
          publisher_->publish(msg);
        }
        // 定时器指针
        rclcpp::TimerBase::SharedPtr timer_;
    	// 发布者指针
    	rclcpp::Publisher<std_msgs::msg::String>::SharedPtr publisher_;  
};

// ROS2节点主入口main函数
int main(int argc, char * argv[])                      
{
    // ROS2 C++接口初始化
    rclcpp::init(argc, argv);                
    // 创建ROS2节点对象并进行初始化          
    rclcpp::spin(std::make_shared<PublisherNode>());   
    // 关闭ROS2 C++接口
    rclcpp::shutdown();                                
    return 0;
}
```

