# 动作

实现一个完整的动作流程管理, 在运动过程中可以把控运动的进度以及随时取消

需要有一个反馈, 随时告知实际的运动状态

动作和服务类似，使用的也是客户端和服务器模型，客户端发送动作的目标，想让机器人干什么，服务器端执行动作过程， 控制机器人达到运动的目标，同时周期反馈动作执行过程中的状态

客户端发送一个运动的目标，想让机器人动起来，服务器端收到之后，就开始控制机器人运动，一边运动，一边反馈当前的状态，如果是一个导航动作，这个反馈可能是当前所处的坐标，如果是机械臂抓取，这个反馈可能又是机械臂的实时姿态。当运动执行结束后，服务器再反馈一个动作结束的信息。整个通信过程就此结束。

和服务一样，动作通信中的客户端可以有多个，大家都可以发送运动命令，但是服务器端只能有一个, 先执行完成一个动作，才能执行下一个动作。

![image8](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601151945488.gif)

使用两个服务以及一个Topic, 发送一个服务, 开启运动, 之后发送接受结束状态的服务, 同时订阅Topic, 动作完成之后获取到结束的服务返回

## 命令行

```bash
(base) jiao@jiao-virtual-machine:~/ros$ ros2 action list
/turtle1/rotate_absolute
(base) jiao@jiao-virtual-machine:~/ros$ ros2 action info /turtle1/rotate_absolute 
Action: /turtle1/rotate_absolute
Action clients: 0
Action servers: 1
    /turtlesim
(base) jiao@jiao-virtual-machine:~/ros$ ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute "{theta: 3.14}"
Waiting for an action server to become available...
Sending goal:
     theta: 3.14

Goal accepted with ID: 2415d93453014a59be77201b67aaea82

[INFO] [1768478139.297624195] [turtlesim]: Rotation goal completed successfully
Result:
    delta: -3.135999917984009

Goal finished with status: SUCCEEDED
(base) jiao@jiao-virtual-machine:~/ros$ ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute "{theta: 0}" --feedback
Waiting for an action server to become available...
Sending goal:
     theta: 0.0

Feedback:
    remaining: -3.135999917984009

Goal accepted with ID: b9796b29259c4c199f7e83a285fa0c0e

Feedback:
    remaining: -3.119999885559082

Feedback:
    remaining: -3.1040000915527344

...

[INFO] [1768478203.632885310] [turtlesim]: Rotation goal completed successfully
Feedback:
    remaining: -0.01600000075995922

Result:
    delta: 3.119999885559082

Goal finished with status: SUCCEEDED
```

## 代码实现

![image-20220528010217043](https://book.guyuehome.com/ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/image/2.7_%E5%8A%A8%E4%BD%9C/image-20220528010217043.png)

### action数据

```yaml
bool enable     # 定义动作的目标，表示动作开始的指令
---
bool finish     # 定义动作的结果，表示是否成功执行
---
int32 state     # 定义动作的反馈，表示当前执行到的位置
```

### Client

```python
import rclpy                                      # ROS2 Python接口库
from rclpy.node   import Node                     # ROS2 节点类
from rclpy.action import ActionClient             # ROS2 动作客户端类

from learning_interface.action import MoveCircle  # 自定义的圆周运动接口

class MoveCircleActionClient(Node):
    def __init__(self, name):
        super().__init__(name)
        # 创建动作客户端（接口类型、动作名）
        self._action_client = ActionClient(      
            self, MoveCircle, 'move_circle') 

    def send_goal(self, enable):
        # 创建一个动作目标的消息
        goal_msg = MoveCircle.Goal()             
        goal_msg.enable = enable
		# 等待动作的服务器端启动
        self._action_client.wait_for_server()
        # 异步方式发送动作的目标
        self._send_goal_future = self._action_client.send_goal_async(   
            goal_msg,
            feedback_callback=self.feedback_callback)
                          
        self._send_goal_future.add_done_callback(self.goal_response_callback) # 设置一个服务器收到目标之后反馈时的回调函数
	# 创建一个服务器收到目标之后反馈时的回调函数
    def goal_response_callback(self, future):
        # 接收动作的结果
        goal_handle = future.result()
        # 如果动作被拒绝执行
        if not goal_handle.accepted:
            self.get_logger().info('Goal rejected :(')
            return
		# 动作被顺利执行
        self.get_logger().info('Goal accepted :)')
        # 异步获取动作最终执行的结果反馈
        self._get_result_future = goal_handle.get_result_async()
        # 设置一个收到最终结果的回调函数
        self._get_result_future.add_done_callback(
            self.get_result_callback)

    def get_result_callback(self, future):
        # 读取动作执行的结果
        result = future.result().result
        self.get_logger().info('Result: {%d}' % result.finish)

    def feedback_callback(self, feedback_msg):
        # 读取反馈的数据
        feedback = feedback_msg.feedback
        self.get_logger().info('Received feedback: {%d}' % feedback.state) 

def main(args=None):
    rclpy.init(args=args)
    # 创建ROS2节点对象并进行初始化
    node = MoveCircleActionClient("action_move_client")
    # 发送动作目标
    node.send_goal(True)
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()
```

### Server

```python

import time

import rclpy                                      # ROS2 Python接口库
from rclpy.node   import Node                     # ROS2 节点类
from rclpy.action import ActionServer             # ROS2 动作服务器类
from learning_interface.action import MoveCircle  # 自定义的圆周运动接口

class MoveCircleActionServer(Node):
    def __init__(self, name):
        super().__init__(name)
        # 创建动作服务器（接口类型、动作名、回调函数）
        self._action_server = ActionServer(
            self,
            MoveCircle,
            'move_circle',
            self.execute_callback)
	# 执行收到动作目标之后的处理函数
    def execute_callback(self, goal_handle):            
        self.get_logger().info('Moving circle...')
        # 创建一个动作反馈信息的消息
        feedback_msg = MoveCircle.Feedback()
        # 从0到360度，执行圆周运动，并周期反馈信息
        for i in range(0, 360, 30):
            # 创建反馈信息，表示当前执行到的角度
            feedback_msg.state = i
            self.get_logger().info('Publishing feedback: %d' % feedback_msg.state)
            goal_handle.publish_feedback(feedback_msg)  # 发布反馈信息
            time.sleep(0.5)
        # 动作执行成功
        goal_handle.succeed()
        # 创建结果消息
        result = MoveCircle.Result()
        result.finish = True                          
        return result

def main(args=None):
    rclpy.init(args=args)
    node = MoveCircleActionServer("action_move_server")
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()

```

