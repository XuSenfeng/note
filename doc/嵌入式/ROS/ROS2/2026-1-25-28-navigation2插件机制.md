# 插件

在navigation2里面自定义插件实现路径的规划以及控制导航, 需要使用pluginlib, 这是一个用于在ros功能包里面动态加载卸载插件的c++库, 使用ClassLoader加载不同的动态链接库

所有的插件都是一个插件抽象类的子类

## 创建

```bash
ros2 pkg create motion_control_system_ --dependencies plunginlib
```

```bash
(base) jiao@jiao-virtual-machine:~/ros/learn_pluginlib/src$ tree
.
└── motion_control_system
    ├── CMakeLists.txt
    ├── include
    │   └── motion_control_system
    │       ├── motion_control_interface.hpp
    │       └── spin_motion_controller.hpp
    ├── package.xml
    ├── spin_motion_plugins.xml
    └── src
        └── spin_motion_controller.cpp

4 directories, 6 files
```



+ motion_control_interface.cpp 创建一个纯虚函数的基类

```cpp
#ifndef MOTION_CONTROL_INTERFACE_HPP
#define MOTION_CONTROL_INTERFACE_HPP

namespace motion_control_system {
    // 创建一个抽象类 MotionController，包含纯虚函数 start 和 stop
    class MotionController {
    public:
        virtual void start() = 0;
        virtual void stop() = 0;
    };
}

#endif
```

+ spin_motion_controller.hpp 基于这个基类创建实际的类实现

```cpp
#ifndef SPIN_MOTION_CONTROLLER_HPP
#define SPIN_MOTION_CONTROLLER_HPP
#include "motion_control_system/motion_control_interface.hpp"

namespace motion_control_system {
    // 创建一个抽象类 MotionController，包含纯虚函数 start 和 stop
    class SpinMotionController: public MotionController {
    public:
        void start() override;
        void stop() override;
    };
}

#endif
```

+ spin_motion_controller.cpp

```cpp
#include "iostream"
#include "motion_control_system/spin_motion_controller.hpp"

namespace motion_control_system
{
    void SpinMotionController::start()
    {
        // 实现旋转运动控制逻辑
        std::cout << "SpinMotionController::start" << std::endl;
    }
    void SpinMotionController::stop()
    {
        // 停止运动控制
        std::cout << "SpinMotionController::stop" << std::endl;
    }
} // namespace motion_control_system
#include "pluginlib/class_list_macros.hpp"
PLUGINLIB_EXPORT_CLASS(motion_control_system::SpinMotionController, motion_control_system::MotionController)
```

+ spin_motion_plugin.xml 描述文件, 描述使用的类以及基类

```xml
<library path="spin_motion_controller">
	<class name="motion_control_system/SpinMotionController" type="motion_control_system::SpinMotionController" base_class_type="motion_control_system::MotionController">
	 <description>Spin Motion Controller</description>
	</class>
</library>
```

+ CMake文件

```cmake
include_directories(include)
# 创建编译的库
add_library(spin_motion_controller SHARED src/spin_motion_controller.cpp)
ament_target_dependencies(spin_motion_controller  pluginlib )

install(TARGETS spin_motion_controller
  ARCHIVE DESTINATION lib
  LIBRARY DESTINATION lib
  RUNTIME DESTINATION bin
)
install(DIRECTORY include/
  DESTINATION include/
)
# 导出插件描述文件, 功能包的名字以及描述文件的名字
pluginlib_export_plugin_description_file(motion_control_system spin_motion_plugins.xml)
```

## 测试插件

```cpp
#include "motion_control_system/motion_control_interface.hpp"
#include <pluginlib/class_loader.hpp>

int main(int argc, char **argv) {
  // 判断参数数量是否合法
  if (argc != 2)
    return 0;
  // 通过命令行参数，选择要加载的插件,argv[0]是可执行文件名，argv[1]表示参数名
  std::string controller_name = argv[1];
  // 1.通过功能包名称和基类名称创建控制器加载器
  pluginlib::ClassLoader<motion_control_system::MotionController>
      controller_loader("motion_control_system",
                        "motion_control_system::MotionController");
  // 2.使用加载器加载指定名称的插件，返回的是指定插件类的对象的指针
  auto controller = controller_loader.createSharedInstance(controller_name);
  // 3.调用插件的方法
  controller->start();
  controller->stop();
  return 0;
}
```

在链接的时候不需要显式的链接某一个库

```cmake
add_executable(test_plugin src/test_plugin.cpp)
ament_target_dependencies(test_plugin pluginlib)
install(TARGETS test_plugin
    DESTINATION lib/${PROJECT_NAME}
)
```

运行时候指定使用的类的名字

```bash
(base) jiao@jiao-virtual-machine:~/ros/learn_pluginlib$ ros2 run motion_control_system test_plugin motion_control_system/SpinMotionController
SpinMotionController::start
SpinMotionController::stop
```

