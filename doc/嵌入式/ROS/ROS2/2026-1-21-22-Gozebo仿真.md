# Gozebo仿真

下载一下默认的模型

```bash
sudo apt install gazebo
mkdir -p ~/.gazebo/
git clone https://gitee.com/fishros/gazebo_models.git
mv gazebo_models/ models
rm -rf models/.git
gazebo
```

![image-20260122100643617](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601221006724.png)

![image-20260122100801249](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601221008378.png)

![image-20260122101127760](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601221011913.png)

这里使用的文件也是xml文件, 里面继承拓展urdf文件, 实际使用的是sdf格式的, 可以使用工具进行转化

```bash
sudo apt-get install ros-$ROS_DISTRO-gazebo-ros-pkgs
```

## 添加模型

在虚拟机里面运行的时候使用软件渲染

```bash
source /usr/share/gazebo-11/setup.bash
export GAZEBO_RESOURCE_PATH=/usr/share/gazebo-11:$GAZEBO_RESOURCE_PATH
# 强制使用软件渲染（虚拟机核心配置）
export LIBGL_ALWAYS_SOFTWARE=1
export GAZEBO_RENDERING_API=ogre
```

### launch文件

````python
import launch
import launch_ros
from ament_index_python.packages import get_package_share_directory
import os

def generate_launch_description():
    pkg_share = get_package_share_directory('bot_3D_desc')
    default_xacro_file_path = os.path.join(pkg_share, 'urdf', 'filshbot.urdf.xacro')
    default_gazebo_world_config_path = os.path.join(pkg_share, 'world', 'custom_room.world')
    # 构建一个参数可以供外部传入URDF文件路径
    action_declear_arg_mode_path = launch.actions.DeclareLaunchArgument(
        name="model",
        default_value=default_xacro_file_path,
        description="Absolute path to robot urdf file"
    )
    # 读取文件的内容作为参数值
    command_result = launch.substitutions.Command(
        ['xacro ', launch.substitutions.LaunchConfiguration('model')]
    )
    robot_desc_value = launch_ros.parameter_descriptions.ParameterValue(
        command_result,
        value_type=str
    )
    # 节点：用于发布机器人状态信息
    action_robot_state_publisher = launch_ros.actions.Node(
        package='robot_state_publisher',
        executable='robot_state_publisher',
        name='robot_state_publisher',
        parameters=[{'robot_description': robot_desc_value}]
    )

    # action_joint_state_publisher = launch_ros.actions.Node(
    #     package='joint_state_publisher',
    #     executable='joint_state_publisher',
    #     name='joint_state_publisher',
    # )

    # action_rviz_node = launch_ros.actions.Node(
    #     package='rviz2',
    #     executable='rviz2',
    #     name='rviz2',
    #     arguments=['-d', default_rviz_config_path],
    # )

    # ros2 launch gazebo_ros gazebo.launch.py world:=xxx
    action_launch_gazebo = launch.actions.IncludeLaunchDescription(
        launch.launch_description_sources.PythonLaunchDescriptionSource(
            os.path.join(
                get_package_share_directory('gazebo_ros'),
                'launch',
                'gazebo.launch.py'
            )
        ),
        launch_arguments={
            'world': default_gazebo_world_config_path,
            'verbose': 'true'
        }.items()
    )

    # 节点：用于将机器人模型生成到gazebo环境中
    action_spawn_entity = launch_ros.actions.Node(
        package='gazebo_ros',
        executable='spawn_entity.py',
        arguments=[
            '-topic', '/robot_description',
            '-entity', 'filshbot'
        ]
    )


    return launch.LaunchDescription([
        action_declear_arg_mode_path,
        action_robot_state_publisher,
        # action_joint_state_publisher,
        # action_rviz_node,
        action_launch_gazebo,
        action_spawn_entity
    ])
````

> 运行的时候需要退出conda环境

![image-20260122111737649](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601221117907.png)

默认的这个模型没有颜色, 需要添加新的标签

### gazebo标签

#### 颜色

描述的是仿真的配置, 需要添加gazebo专用的标签

```xml
<gazebo reference="laser_cylinder_link">
    <material>Gazebo/Black</material>
</gazebo>
<gazebo reference="laser_link">
    <material>Gazebo/Black</material>
</gazebo>
```

#### 物理属性

可以设置轮子的摩擦系数

```xml
<gazebo reference="${wheel_name}_link">
    <material>Gazebo/Yellow</material>
    <!-- mu1:切向摩擦系数 -->
    <!-- mu2:次切向摩擦系数 -->
    <!-- kp:弹簧刚度 -->
    <!-- kd:阻尼系数 -->
    <mu1 value="20.0"/>
    <mu2 value="20.0"/>
    <kp value="1000000000.0"/>
    <kd value="1.0"/>
</gazebo>
```

`mu2`是**次切向方向**的摩擦系数：针对轮子**次要运动方向**（比如机器人转弯时轮子的横向侧滑方向）。

通俗例子：轮子前进 / 后退是 mu1 方向，轮子左右侧滑（比如转弯时）是 mu2 方向。

+ 太小（<5）机器人转弯时侧滑严重，比如想转 90° 却滑出半米远汽车高速转弯时的侧滑
+ 适中（和 mu1 接近）转弯时侧滑轻微，机器人轨迹精准正常地面的转弯行为
+ 太大（>mu1）机器人转弯不灵活，甚至 “拐不过弯”，运动僵硬履带车的转弯特性（几乎无侧滑）

`kp`是接触点的弹簧刚度，意思是 “让接触点产生 1 米形变需要的力”—— 值越大，弹簧越 “硬”，形变越小。

通俗例子：钢弹簧的 kp≈1e9 N/m（硬，几乎不变形），海绵的 kp≈1e3 N/m（软，易变形）

+ 太小（<1e8）轮子 “陷进” 地面：视觉上机器人轮子一半埋在地面下，运动发飘，甚至无法前进轮子压在海绵 / 软泥地上
+ 适中（1e8~1e9）接触点几乎无形变，机器人平稳站在地面，符合 “刚体” 仿真需求（ROS 机器人默认都是刚体）轮子压在水泥 / 柏油地面
+ 太大（>1e10）Gazebo 物理计算不稳定：仿真卡顿、报错，甚至机器人 “弹飞”（数值计算爆炸）无对应真实场景（超出刚体合理范围）

阻尼系数（d）：阻尼力与运动速度成正比（Fd=−d×v），单位是 N・s/m（牛・秒 / 米）；阻尼的作用是**消耗运动能量**，模拟接触时的缓冲、减震、能量损耗（比如轮子碰到地面的 “减震” 效果）。

通俗例子：汽车减震器的 kd 大（平稳），没减震的玩具车 kd 小（颠簸）。

+ 太小（<0.1）轮子 “弹跳”：机器人启动 / 停止时轮子跳起来，甚至翻倒，仿真抖动严重无减震的小车在硬地面行驶
+ 适中（0.1~10）接触平稳，机器人启动 / 停止无弹跳，运动顺滑带减震的机器人轮子接触地面
+ 太大（>20）轮子 “发粘”：机器人启动缓慢，像在粘滞的地面（比如蜂蜜）上行驶，响应迟钝轮子粘在粘稠地面上

#### 插件

##### 运动控制插件

可以使用插件实现机器人的控制, 两轮差速控制插件可以实现小车的控制

```xml
<?xml version="1.0"?>
<robot xmlns:xacro="http://www.ros.org/wiki/xacro">
    <xacro:macro name="gazebo_control_plugin">
        <gazebo>
        <!-- 插件的名字以及使用的库 -->
            <plugin name='diff_drive' filename='libgazebo_ros_diff_drive.so'>
                <ros>
                    <!-- 命名空间, 重映射话题的名字, 这个插件会订阅cmd_vel话题并发布odom话题
                    这两个话题分别用于控制机器人运动和获取机器人位置信息 -->
                    <namespace>/</namespace>
                    <remapping>cmd_vel:=cmd_vel</remapping>
                    <remapping>odom:=odom</remapping>
                </ros>
                <!--  信息的更新频率 -->
                <update_rate>30</update_rate>
                <!-- wheels 轮子的关节名字 -->
                <left_joint>left_wheel_joint</left_joint>
                <right_joint>right_wheel_joint</right_joint>
                <!-- kinematics 轮子的间距和直径 -->
                <wheel_separation>0.2</wheel_separation>
                <wheel_diameter>0.064</wheel_diameter>
                <!-- limits 设置轮子的最大扭矩和最大加速度 -->
                <max_wheel_torque>20</max_wheel_torque>
                <max_wheel_acceleration>1.0</max_wheel_acceleration>
                <!-- output 是否发布里程计和相关TF的topic -->
                <publish_odom>true</publish_odom>
                <publish_odom_tf>true</publish_odom_tf>
                <publish_wheel_tf>true</publish_wheel_tf>
                <!--
                配置里程计和机器人基座框架的参数设置
                - odometry_frame: 设置里程计参考坐标系为 "odom"，用于发布机器人的速度和位置信息
                - robot_base_frame: 设置机器人基座坐标系为 "base_footprint"，作为机器人的中心参考点
                这些配置用于Gazebo仿真中的控制插件，以正确跟踪机器人在虚拟环境中的运动状态
                -->
                <odometry_frame>odom</odometry_frame>
                <robot_base_frame>base_footprint</robot_base_frame>
            </plugin>
        </gazebo>
   </xacro:macro>
</robot>
```

```xml
<xacro:include filename="$(find bot_3D_desc)/urdf/fishbot/plugins/gazebo_control_plugin.xacro"/>
<xacro:gazebo_control_plugin/>
```

![image-20260122115305748](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601221153827.png)

控制

```bash
ros2 run teleop_twist_keyboard teleop_twist_keyboard 
```

可以使用rqt进行查看坐标系之间的管子, 由于插件配置的基准坐标系是base_footprint, 这里导致两个轮子的坐标系不是在base_link下面的

![image-20260122121525444](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601221215551.png)

可以同时试一下Rviz查看小车的状态

![image-20260122122023195](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601221220332.png)

![image-20260122122158161](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601221221282.png)

![image-20260122122300844](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601221223937.png)

可以记录100组的运动数据

##### 激光雷达插件

实现对附近环境的探测

```xml
<?xml version="1.0"?>
<robot xmlns:xacro="http://www.ros.org/wiki/xacro">
    <xacro:macro name="gazebo_sensor_plugin">
        <gazebo reference="laser_link">
            <sensor name="laserscan" type="ray">
                <plugin name="laserscan" filename="libgazebo_ros_ray_sensor.so">
                    <ros>
                        <namespace>/</namespace>
                        <remapping>~/out:=scan</remapping>
                    </ros>
                    <output_type>sensor_msgs/LaserScan</output_type>
                    <frame_name>laser_link</frame_name>
                </plugin>
                <always_on>true</always_on>
                <visualize>true</visualize>
                <update_rate>5</update_rate>
                <pose>0 0 0 0 0 0</pose>
                <!-- 激光传感器配置 -->
                <ray>
                    <!-- 设置扫描范围 -->
                    <scan>
                        <horizontal>
                            <samples>360</samples>
                            <resolution>1.000000</resolution>
                            <min_angle>0.000000</min_angle>
                            <max_angle>6.280000</max_angle>
                        </horizontal>
                    </scan>
                    <!-- 设置扫描距离 -->
                    <range>
                        <min>0.120000</min>
                        <max>8.0</max>
                        <resolution>0.015000</resolution>
                    </range>
                    <!-- 设置噪声 -->
                    <noise>
                        <type>gaussian</type>
                        <mean>0.0</mean>
                        <stddev>0.01</stddev>
                    </noise>
                </ray>
            </sensor>
        </gazebo>
    </xacro:macro>
</robot>
```

可以在rviz2里面查看可以激光雷达的范围

![image-20260122141823223](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601221418408.png)

##### imu

获取机器的三轴角速度以及加速度

```xml
        <gazebo reference="imu_link">
            <sensor name="imu_sensor" type="imu">
                <plugin name="imu_plugin" filename="libgazebo_ros_imu_sensor.so">
                    <ros>
                        <namespace>/</namespace>
                        <remapping>~/out:=imu</remapping>
                    </ros>
                    <!-- 不使用初始化方向作为参考系 -->
                    <initial_orientation_as_reference>false</initial_orientation_as_reference>
                </plugin>
                <update_rate>100</update_rate>
                <always_on>true</always_on>
                <!-- 六轴噪声设置 -->
                <imu>
                    <!-- 角速度 -->
                    <angular_velocity>
                        <x>
                            <noise type="gaussian">
                                <mean>0.0</mean>
                                <stddev>2e-4</stddev>
                                <bias_mean>0.0000075</bias_mean>
                                <bias_stddev>0.0000008</bias_stddev>
                            </noise>
                        </x>
                        <y>
                            <noise type="gaussian">
                                <mean>0.0</mean>
                                <stddev>2e-4</stddev>
                                <bias_mean>0.0000075</bias_mean>
                                <bias_stddev>0.0000008</bias_stddev>
                            </noise>
                        </y>
                        <z>
                            <noise type="gaussian">
                                <mean>0.0</mean>
                                <stddev>2e-4</stddev>
                                <bias_mean>0.0000075</bias_mean>
                                <bias_stddev>0.0000008</bias_stddev>
                            </noise>
                        </z>
                    </angular_velocity>
                    <!-- 线加速度 -->
                    <linear_acceleration>
                        <x>
                            <noise type="gaussian">
                                <mean>0.0</mean>
                                <stddev>1.7e-2</stddev>
                                <bias_mean>0.1</bias_mean>
                                <bias_stddev>0.001</bias_stddev>
                            </noise>
                        </x>
                        <y>
                            <noise type="gaussian">
                                <mean>0.0</mean>
                                <stddev>1.7e-2</stddev>
                                <bias_mean>0.1</bias_mean>
                                <bias_stddev>0.001</bias_stddev>
                            </noise>
                        </y>
                        <z>
                            <noise type="gaussian">
                                <mean>0.0</mean>
                                <stddev>1.7e-2</stddev>
                                <bias_mean>0.1</bias_mean>
                                <bias_stddev>0.001</bias_stddev>
                            </noise>
                        </z>
                    </linear_acceleration>
                </imu>
            </sensor>
        </gazebo>
```

机器人打滑的时候, 里程计不准, 可以使用imu辅助进行判断

#### 深度相机

一种专门用于识别深度的相机, 一般和彩色相机一起使用, 默认前方是z轴

```xml
<link name="camera_optical_link">
</link>
<joint name="camera_optical_joint" type="fixed">
    <!-- 虚拟深度相机, 需要旋转, 把z轴指向前方 -->
    <origin xyz="0 0 0" rpy="${-pi/2} 0.0 ${-pi/2}"/>
    <parent link="camera_link"/>
    <child link="camera_optical_link"/>
</joint>
```

```xml
<!-- 使用的相机, 参考camera_link坐标系, 但是绑定在camera_optical_link -->
<gazebo reference="camera_link">
    <sensor type="depth" name="camera_sensor">
        <plugin name="depth_camera" filename="libgazebo_ros_camera.so">
            <frame_name>camera_optical_link</frame_name>
        </plugin>
        <always_on>true</always_on>
        <update_rate>10</update_rate>
        <camera name="camera">
            <!--视角是90°-->
            <horizontal_fov>1.5009831567</horizontal_fov>
            <image>
                <width>800</width>
                <height>600</height>
                <format>R8G8B8</format>
            </image>
            <!-- 图像的畸变, 中心坐标 -->
            <distortion>
                <k1>0.0</k1>
                <k2>0.0</k2>
                <k3>0.0</k3>
                <p1>0.0</p1>
                <p2>0.0</p2>
                <center>0.5 0.5</center>
            </distortion>
        </camera>
    </sensor>
</gazebo>
```

```bash
(base) jiao@jiao-virtual-machine:~$ ros2 topic list | grep camera
/camera_sensor/camera_info # 信息
/camera_sensor/depth/camera_info # 深度相机
/camera_sensor/depth/image_raw # 原始深度
/camera_sensor/image_raw # 彩色相机
/camera_sensor/points
```

**机器人本体坐标系（FLU 约定）**：`camera_link` 遵循机器人行业标准 ——**前 (Forward)-X、左 (Left)-Y、上 (Up)-Z**。这个 link 描述的是相机**物理硬件**在机器人上的安装位置，所以你能看到它有`visual`（外观）、`collision`（碰撞）、`inertia`（惯性）属性，对应真实的硬件物理特征。

**相机光学坐标系（FRD 约定）**：`camera_optical_link` 遵循计算机视觉 / ROS 视觉标准 ——**前 (Forward)-Z、右 (Right)-X、下 (Down)-Y**。这个 link 是**虚拟坐标系**（所以没有`visual`/`collision`），唯一作用是把机器人坐标系转换为视觉算法能识别的坐标系。

![image-20260122161346985](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601221613190.png)

![image-20260122161418018](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601221614193.png)

可以直接查看图片的效果

![image-20260122161639910](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601221616012.png)

![image-20260122161728533](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601221617689.png)