# 执行器组织多个节点

## 静态组合

可以把多个节点放在同一个进程里面, 从而实现更加方便的信息传输

### 官方示例

```bash
(base) jiao@jiao-virtual-machine:~$ ros2 run intra_process_demo two_node_pipeline 
Published message with value: 0, and address: 0x5BA9FEAFC9C0
 Received message with value: 0, and address: 0x5BA9FEAFC9C0
Published message with value: 1, and address: 0x5BA9FEAFC9C0
 Received message with value: 1, and address: 0x5BA9FEAFC9C0
```

可以看到内存是没有变化的, 所以传输的效率更高

### 代码实现

#### 类实现

```cpp
#ifndef LEARN_COMPOSE__TALKER_COMPONENT_HPP_
#define LEARN_COMPOSE__TALKER_COMPONENT_HPP_

#include "rclcpp/rclcpp.hpp"
#include "std_msgs/msg/int32.hpp"

namespace learn_compose {

class Talker : public rclcpp::Node {
public:
  explicit Talker(const rclcpp::NodeOptions &options);

private:
  int32_t count_;
  rclcpp::Publisher<std_msgs::msg::Int32>::SharedPtr pub_;
  rclcpp::TimerBase::SharedPtr timer_;
};

} // namespace learn_compose

#endif // LEARN_COMPOSE__TALKER_COMPONENT_HPP_
```

```cpp
#ifndef LEARN_COMPOSE__LISTENER_COMPONENT_HPP_
#define LEARN_COMPOSE__LISTENER_COMPONENT_HPP_

#include "rclcpp/rclcpp.hpp"
#include "std_msgs/msg/int32.hpp"

namespace learn_compose {

class Listener : public rclcpp::Node {
public:
  explicit Listener(const rclcpp::NodeOptions &options);

private:
  rclcpp::Subscription<std_msgs::msg::Int32>::SharedPtr sub_;
};

} // namespace learn_compose

#endif // LEARN_COMPOSE__LISTENER_COMPONENT_HPP_
```

```cpp
#include <chrono>
#include "learn_compose/talker.hpp"

namespace learn_compose {

using namespace std::chrono_literals;

Talker::Talker(const rclcpp::NodeOptions &options) : Node("talker", options) {
  pub_ = this->create_publisher<std_msgs::msg::Int32>("count", 10);
  auto callback = [&]() -> void {
    // unique_ptr 代表独占式所有权：一个 unique_ptr 实例独占它所指向的对象，
    // 同一时间只有一个 unique_ptr 能指向该对象，不允许拷贝（拷贝构造 / 赋值会编译报错），
    // 只能通过移动（move） 转移所有权。
    std_msgs::msg::Int32::UniquePtr msg(new std_msgs::msg::Int32());
    msg->data = count_++;
    RCLCPP_INFO(this->get_logger(), "发布数据:%d(0x%lX)", msg->data,
                reinterpret_cast<std::uintptr_t>(msg.get()));
    pub_->publish(std::move(msg));
  };
  timer_ = this->create_wall_timer(1s, callback);
}
} // namespace  learn_compose
```

```cpp
#include "learn_compose/listener.hpp"
#include <chrono>

namespace learn_compose {

using namespace std::chrono_literals;

Listener::Listener(const rclcpp::NodeOptions &options)
    : Node("listener", options) {
  sub_ = this->create_subscription<std_msgs::msg::Int32>(
      "count", 10, [&](const std_msgs::msg::Int32::UniquePtr msg) {
        RCLCPP_INFO(this->get_logger(), "收到数据:%d(0x%lX)", msg->data,
                    reinterpret_cast<std::uintptr_t>(msg.get()));
      });
}
} // namespace  learn_compose
```

**普通对象发布的问题**：如果直接创建普通消息对象（`std_msgs::msg::Int32 msg;`），调用`pub_->publish(msg)`时，ROS 2 会**拷贝整个消息对象**到发布队列中（相当于复制一份数据）。对于`Int32`这种小消息，拷贝开销可以忽略，但如果是大消息（比如图像`sensor_msgs::msg::Image`、激光雷达点云`sensor_msgs::msg::PointCloud2`），拷贝会消耗大量 CPU 和内存，严重影响性能。

**UniquePtr 发布的优势**：通过`std::move`转移`UniquePtr`的所有权，发布器直接使用你创建的消息内存，**无需任何拷贝**（零拷贝），发布效率大幅提升 —— 这也是 ROS 2 为所有消息类型内置`UniquePtr`别名（如`Int32::UniquePtr`）的核心目的。

```cpp
#include "learn_compose/listener.hpp"
#include <chrono>

namespace learn_compose {

using namespace std::chrono_literals;

Listener::Listener(const rclcpp::NodeOptions &options)
    : Node("listener", options) {
  sub_ = this->create_subscription<std_msgs::msg::Int32>(
      "count", 10, [&](const std_msgs::msg::Int32::UniquePtr msg) {
        RCLCPP_INFO(this->get_logger(), "收到数据:%d(0x%lX)", msg->data,
                    reinterpret_cast<std::uintptr_t>(msg.get()));
      });
}
} // namespace  learn_compose


#include "rclcpp_components/register_node_macro.hpp"
RCLCPP_COMPONENTS_REGISTER_NODE(learn_compose::Listener)
```

#### 实际使用

```cpp
#include "learn_compose/listener.hpp"
#include "learn_compose/talker.hpp"
#include "rclcpp/rclcpp.hpp"

int main(int argc, char *argv[]) {
  rclcpp::init(argc, argv);
  rclcpp::executors::SingleThreadedExecutor executor;

  rclcpp::NodeOptions options;           // 创建节点选项
  options.use_intra_process_comms(true); // 使用进程内通信
  auto talker = std::make_shared<learn_compose::Talker>(options);
  auto listener = std::make_shared<learn_compose::Listener>(options);

  executor.add_node(talker);
  executor.add_node(listener);
  executor.spin();

  rclcpp::shutdown();

  return 0;
}
```

## 组件动态加载

使用命令查看当前加载的组件

```bash
(base) jiao@jiao-virtual-machine:~$ ros2 component types
quality_of_service_demo_cpp
  quality_of_service_demo::MessageLostListener
  quality_of_service_demo::MessageLostTalker
  quality_of_service_demo::QosOverridesListener
  quality_of_service_demo::QosOverridesTalker
composition # 这是一个提供的示例组件
  composition::Talker
  composition::Listener
  composition::NodeLikeListener
  composition::Server
  composition::Client
...
# 创建容器
(base) jiao@jiao-virtual-machine:~$ ros2 run rclcpp_components component_container --ros-args -r __node:=compent_test
# 加载节点
(base) jiao@jiao-virtual-machine:~$ ros2 component load /compent_test composition composition::Talker 
Loaded component 1 into '/compent_test' container node as '/talker'
# 指定配置
(base) jiao@jiao-virtual-machine:~$ ros2 component load /compent_test composition composition::Talker --node-name talker2 --node-namespace /ns
Loaded component 2 into '/compent_test' container node as '/ns/talker2'
# 出现两个topic
(base) jiao@jiao-virtual-machine:~$ ros2 topic list
/chatter
/ns/chatter
(base) jiao@jiao-virtual-machine:~$ ros2 component load /compent_test composition composition::Listener 
Loaded component 3 into '/compent_test' container node as '/listener'
# 查看当前的node
(base) jiao@jiao-virtual-machine:~$ ros2 component list
/compent_test
  1  /talker
  2  /ns/talker2
  3  /listener
# 卸载
(base) jiao@jiao-virtual-machine:~$ ros2 component unload /compent_test 1 2 3
Unloaded component 1 from '/compent_test' container node
Unloaded component 2 from '/compent_test' container node
Unloaded component 3 from '/compent_test' container node
```

### 代码实现

使用一个宏进行注册

```cpp
#include "rclcpp_components/register_node_macro.hpp"
RCLCPP_COMPONENTS_REGISTER_NODE(learn_compose::Listener)
```

在cmake里面引用对应的库, 编译为库

```cmake
find_package(rclcpp_components REQUIRED)
include_directories(include)
add_executable(intra_process_pubsub 
    src/intra_process_pubsub.cpp
    src/talker.cpp
    src/listener.cpp
)
ament_target_dependencies(intra_process_pubsub std_msgs rclcpp rclcpp_components)


add_library(talker_component SHARED src/talker.cpp)
ament_target_dependencies(talker_component "std_msgs" "rclcpp" "rclcpp_components")
rclcpp_components_register_nodes(talker_component "learn_compose::Talker")

add_library(listener_component SHARED src/listener.cpp)
ament_target_dependencies(listener_component "std_msgs" "rclcpp" "rclcpp_components")
rclcpp_components_register_nodes(listener_component "learn_compose::Listener")

install(TARGETS talker_component listener_component
  ARCHIVE DESTINATION lib
  LIBRARY DESTINATION lib
  RUNTIME DESTINATION bin
)
```

在运行的时候如果使用进程间通信的话, 需要在加载节点的时候加上参数`-e use_intra_process_comms:=true`