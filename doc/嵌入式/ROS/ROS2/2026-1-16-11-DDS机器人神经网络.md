# DDS机器人神经网络

话题、服务、动作，他们底层通信的具体实现过程，都是靠DDS来完成的，它相当于是**ROS机器人系统中的神经网络**

DDS的核心是通信，能够实现通信的模型和软件框架非常多，这里我们列出常用的四种模型

![image-20260116160042569](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601161600695.png)

- 第一种，**点对点模型**，许多客户端连接到一个服务端，每次通信时，通信双方必须建立一条连接。当通信节点增多时，连接数也会增多。而且每个客户端都需要知道服务器的具体地址和所提供的服务，一旦服务器地址发生变化，所有客户端都会受到影响。
- 第二种，**Broker模型**，针对点对点模型进行了优化，由Broker集中处理所有人的请求，并进一步找到真正能响应该服务的角色。这样客户端就不用关心服务器的具体地址了。不过问题也很明显，Broker作为核心，它的处理速度会影响所有节点的效率，当系统规模增长到一定程度，Broker就会成为整个系统的性能瓶颈。更麻烦是，如果Broker发生异常，可能导致整个系统都无法正常运转。之前的ROS1系统，使用的就是类似这样的架构。
- 第三种，**广播模型**，所有节点都可以在通道上广播消息，并且节点都可以收到消息。这个模型解决了服务器地址的问题，而且通信双方也不用单独建立连接，但是广播通道上的消息太多了，所有节点都必须关心每条消息，其实很多是和自己没有关系的。
- 第四种，就是**以数据为中心的DDS模型**了，这种模型与广播模型有些类似，所有节点都可以在DataBus上发布和订阅消息。但它的先进之处在于，通信中包含了很多并行的通路，每个节点可以只关心自己感兴趣的消息，忽略不感兴趣的消息，有点像是一个旋转火锅，各种好吃的都在这个DataBus传送，我们只需要拿自己想吃的就行，其他的和我们没有关系。

DDS的全称是**Data Distribution Service**，也就是**数据分发服务**，2004年由**对象管理组织OMG**发布和维护，是一套专门为**实时系统**设计的**数据分发/订阅标准**, 强调**以数据为中心**，可以提供丰富的**服务质量策略**，以保障数据进行实时、高效、灵活地分发，可满足各种分布式实时通信应用需求。

> DDS在ROS2系统中的位置至关重要，所有上层建设都建立在DDS之上。在这个ROS2的架构图中，蓝色和红色部分就是DDS
>
> ![image-20260116160436332](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601161604381.png)
>
> DDS是一种通信的标准，就像4G、5G一样，既然是标准，那大家都可以按照这个标准来实现对应的功能，所以华为、高通都有很多5G的技术专利，DDS也是一样，**能够按照DDS标准实现的通信系统很多**，这里每一个红色模块，就是某一企业或组织实现的一种DDS系统

![image-20260116160541078](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601161605135.png)

DDS中另外一个重要特性就是**质量服务策略，QoS**。

QoS是一种网络传输策略，应用程序指定所需要的网络传输质量行为，QoS服务实现这种行为要求，尽可能地满足客户对通信质量的需求，可以理解为**数据提供者和接收者之间的合约**。

![image-20260116160631302](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601161606370.png)

- **DEADLINE**策略，表示通信数据必须要在每次截止时间内完成一次通信；
- **HISTORY**策略，表示针对历史数据的一个缓存大小；
- **RELIABILITY**策略，表示数据通信的模式，配置成BEST_EFFORT，就是尽力传输模式，网络情况不好的时候，也要保证数据流畅，此时可能会导致数据丢失，配置成RELIABLE，就是可信赖模式，可以在通信中尽量保证图像的完整性，我们可以根据应用功能场景选择合适的通信模式；
- **DURABILITY**策略，可以配置针对晚加入的节点，也保证有一定的历史数据发送过去，可以让新节点快速适应系统。

## 命令行控制

```bash
# 尽力传输数据, 数据可能丢失
$ ros2 topic pub /chatter std_msgs/msg/Int32 "data: 42" --qos-reliability best_effort 
# 订阅消息, 使用另一个模式, 如果不一样会报错
$ ros2 topic echo /chatter --qos-reliability reliable
$ ros2 topic echo /chatter --qos-reliability best_effort
# 查看一个话题的具体信息
$ ros2 topic info /chatter --verbose
```

## 代码控制

### 发布者

```python
import rclpy                                     # ROS2 Python接口库
from rclpy.node import Node                      # ROS2 节点类
from std_msgs.msg import String                  # 字符串消息类型
from rclpy.qos import QoSProfile, QoSReliabilityPolicy, QoSHistoryPolicy # ROS2 QoS类

"""
创建一个发布者节点
"""
class PublisherNode(Node):
    
    def __init__(self, name):
        super().__init__(name)
        # 创建一个QoS原则
        qos_profile = QoSProfile(
            # reliability=QoSReliabilityPolicy.BEST_EFFORT,
            reliability=QoSReliabilityPolicy.RELIABLE,
            history=QoSHistoryPolicy.KEEP_LAST,
            depth=1
        )
        # 创建发布者对象（消息类型、话题名、QoS原则）
        self.pub = self.create_publisher(String, "chatter", qos_profile)   
        self.timer = self.create_timer(0.5, self.timer_callback)
        
    def timer_callback(self):
        msg = String()
        msg.data = 'Hello World'
        self.pub.publish(msg)
        self.get_logger().info('Publishing: "%s"' % msg.data)
        
def main(args=None):
    rclpy.init(args=args)
    node = PublisherNode("qos_helloworld_pub")
    rclpy.spin(node)
    node.destroy_node(
    rclpy.shutdown()                                 # 关闭ROS2 Python接口
```

### 接收者

```python
import rclpy                                     # ROS2 Python接口库
from rclpy.node   import Node                    # ROS2 节点类
from std_msgs.msg import String                  # ROS2标准定义的String消息
from rclpy.qos import QoSProfile, QoSReliabilityPolicy, QoSHistoryPolicy

"""
创建一个订阅者节点
"""
class SubscriberNode(Node):
    def __init__(self, name):
        super().__init__(name)
        # 创建一个QoS原则
        qos_profile = QoSProfile(
            # reliability=QoSReliabilityPolicy.BEST_EFFORT,
            reliability=QoSReliabilityPolicy.RELIABLE,
            history=QoSHistoryPolicy.KEEP_LAST,
            depth=1
        )
        # 创建订阅者对象（消息类型、话题名、订阅者回调函数、QoS原则）
        self.sub = self.create_subscription(\
            String, "chatter", self.listener_callback, qos_profile) 

    def listener_callback(self, msg):
        self.get_logger().info('I heard: "%s"' % msg.data)
        
def main(args=None):
    rclpy.init(args=args)
    node = SubscriberNode("qos_helloworld_sub")
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()
```

