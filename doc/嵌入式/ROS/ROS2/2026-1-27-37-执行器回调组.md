# 执行器/回调组

ROS2里面的执行管理是使用执行器进行管理的, 执行器底层是一个或者多个线程来调用订阅、定时器、服务的回调函数, 以及响应收到的消息和事件

![image-20260127134805264](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601271348305.png)

![image-20260127134837579](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601271348612.png)

单线程的处理是依次判断执行的, 多线程的时候会自动开新的线程, 运行回调组织为一个组, 配合一个执行器进行使用

使用多线程的处理器, 但是使用的回调组是同一个, 并且不是可重入的, 实际使用的时候还是同一个线程里面进行处理, 多线程实际是一个线程池, 可以在初始化的时候配置线程池里面的线程数量

+  MutuallyExclusiveCallbackGroup（互斥回调组）同一回调组内的所有回调函数，同一时间只能有一个在运行，其他回调必须等待当前回调执行完毕后才能触发。无并发风险：因为串行执行，组内回调访问共享资源（如全局变量、硬件接口）时，无需额外加锁，天然保证线程安全。
+ ReentrantCallbackGroup（可重入回调组）同一回调组内的回调函数可以被多个线程同时执行，甚至同一个回调函数也能被 “重入” 调用（比如高频定时器回调还没执行完，下一次触发又到了）

## 回调组使用

### python

```python
import rclpy
from rclpy.node import Node
from rclpy.executors import MultiThreadedExecutor, SingleThreadedExecutor
from rclpy.callback_groups import MutuallyExclusiveCallbackGroup, ReentrantCallbackGroup
from std_msgs.msg import String
from example_interfaces.srv import AddTwoInts
import threading
import time


class LearnExecutorNode(Node):
    def __init__(self):
        super().__init__('learn_executor')
        self.publisher = self.create_publisher(String, 'string_topic', 10)
        # 创建一个时钟, 使用默认的回调组
        self.timer = self.create_timer(1.0, self.timer_callback)
        # 创建一个自己的回调组
        my_callback_group = ReentrantCallbackGroup()
        # 把一个server的回调函数放进去
        self.service = self.create_service(
            AddTwoInts, 'add_two_ints', self.add_two_ints_callback,
            callback_group=my_callback_group)
        # self.service = self.create_service(
        #     AddTwoInts, 'add_two_ints', self.add_two_ints_callback)

    def timer_callback(self):
        msg = String()
        msg.data = f'话题发布，线程ID:{threading.get_ident()} 线程总数:{threading.active_count()}'
        self.get_logger().info(msg.data)
        self.publisher.publish(msg)

    def add_two_ints_callback(self, request: AddTwoInts.Request, response: AddTwoInts.Response):
        self.get_logger().info(f'处理服务，线程ID:{threading.get_ident()}')
        time.sleep(10)  # 模拟处理延时
        response.sum = request.a + request.b
        self.get_logger().info(f'处理完成，线程ID:{threading.get_ident()}')
        return response


def main(args=None):
    rclpy.init(args=args)
    node = LearnExecutorNode()
    # executor = SingleThreadedExecutor() # 单线程的执行器
    executor = MultiThreadedExecutor(num_threads=4) # 多线程的执行器
    executor.add_node(node)
    executor.spin()
    rclpy.shutdown()
```

### cpp

```cpp
#include "example_interfaces/srv/add_two_ints.hpp"
#include "rclcpp/rclcpp.hpp"
#include "std_msgs/msg/string.hpp"
#include <sstream>

class LearnExecutorNode : public rclcpp::Node {
public:
  LearnExecutorNode() : Node("learn_executor") {
    // 发布者
    publisher_ =
        this->create_publisher<std_msgs::msg::String>("string_topic", 10);
    // 一个时钟
    timer_ = this->create_wall_timer(
        std::chrono::seconds(1),
        std::bind(&LearnExecutorNode::timer_callback, this));
    // 自定义一个回调组
    service_callback_group_ = this->create_callback_group(
        rclcpp::CallbackGroupType::MutuallyExclusive);  // 互斥回调组
    service_ = this->create_service<example_interfaces::srv::AddTwoInts>(
        "add_two_ints",
        std::bind(&LearnExecutorNode::add_two_ints_callback, this,
                  std::placeholders::_1, std::placeholders::_2),
        rmw_qos_profile_services_default, service_callback_group_);
  }

private:
  void timer_callback() {
    auto msg = std_msgs::msg::String();
    msg.data = "话题发布：" + thread_info();
    RCLCPP_INFO(this->get_logger(), msg.data.c_str());
    publisher_->publish(msg);
  }

  std::string thread_info() {
    std::ostringstream thread_str;
    thread_str << "线程ID：" << std::this_thread::get_id();
    return thread_str.str();
  }

  void add_two_ints_callback(
      const std::shared_ptr<example_interfaces::srv::AddTwoInts::Request>
          request,
      std::shared_ptr<example_interfaces::srv::AddTwoInts::Response> response) {
    RCLCPP_INFO(this->get_logger(), "服务开始处理：%s", thread_info().c_str());
    // 模拟一个长时间的处理
    std::this_thread::sleep_for(std::chrono::seconds(10));
    response->sum = request->a + request->b;
    RCLCPP_INFO(this->get_logger(), "服务处理完成：%s", thread_info().c_str());
  }

  rclcpp::Publisher<std_msgs::msg::String>::SharedPtr publisher_;
  rclcpp::TimerBase::SharedPtr timer_;
  rclcpp::Service<example_interfaces::srv::AddTwoInts>::SharedPtr service_;
  rclcpp::CallbackGroup::SharedPtr service_callback_group_;
};

int main(int argc, char *argv[]) {
  rclcpp::init(argc, argv);
  auto node = std::make_shared<LearnExecutorNode>();
  // 两种执行器
//   auto executor = rclcpp::executors::SingleThreadedExecutor();
  auto executor = rclcpp::executors::MultiThreadedExecutor();
  executor.add_node(node);
  executor.spin();
  rclcpp::shutdown();
  return 0;
}
```

