# 机器人建模

描述一个机器人的外观性能等属性, 机器人一般是由**硬件结构、驱动系统、传感器系统、控制系统**四大部分组成

- 硬件结构就是底盘、外壳、电机等实打实可以看到的设备；
- 驱动系统就是可以驱使这些设备正常使用的装置，比如电机的驱动器，电源管理系统等；
- 传感系统包括电机上的编码器、板载的IMU、安装的摄像头、雷达等等，便于机器人感知自己的状态和外部的环境；
- 控制系统就是我们开发过程的主要载体了，一般是树莓派、电脑等计算平台，以及里边的操作系统和应用软件。

机器人建模的过程，其实就是按照类似的思路，通过建模语言，把机器人每一个部分都描述清楚，再组合起来的过程

## URDF

ROS中的建模方法叫做**URDF**，全称是**统一机器人描述格式**，不仅可以清晰描述机器人自身的模型，还可以描述机器人的外部环境，比如桌子，也可以算作一个模型

![image-20260117154356642](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601171543699.png)

URDF模型文件使用的是**XML格式**, 都是由一系列尖括号包围的标签和其中的属性组合而成。

```xml
<?xml version="1.0"?>
<robot name="first_robot">
    <!-- XML 注释 -->
    <link name="base_link"></link>
</robot>
```

在建模中，大臂和小臂就类似机器人的这些独立的刚体部分，称为**连杆Link**，手肘就类似于机器人电机驱动部分，称为**关节joint**。

所以在URDF建模过程中，关键任务就是通过`<link>`和`<joint>`，理清楚每一个连杆和关节的描述信息。

![image-20220528144424329](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601171550527.png)

### **连杆**link

`<link>`标签用来描述机器人某个刚体部分的**外观和物理属性**，外观包括尺寸、颜色、形状，物理属性包括质量、惯性矩阵、碰撞参数等

![image-20260117154604123](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601171546169.png)

![image-20220528144549092](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601171550503.png)

+ visual: 描述的是机器人的外观, 使用一个3D模型的文件建模
+ + <geometry>表示**几何形状**，里边使用<mesh>调用了一个在三维软件中提前设计好的蓝色外观，就是这个stl文件，看上去和真实机器人是一致的
    + <origin>表示**坐标系相对初始位置的偏移**，分别是x、y、z方向上的平移，和roll、pitch、raw旋转，不需要偏移的话，就全为0。
+ collision: 描述的是机器人的物理属性, 描述**碰撞参数**, 可以和visual一样, 看起来和碰撞是一样的
+ + <visual>部分重在描述机器人碰撞体积的描述, 这里简化为一个长方体
    + <collision>部分则是描述机器人运动过程中的状态，比如机器人与外界如何接触算作碰撞

### Joint关节

机器人模型中的刚体最终要通过关节joint连接之后，才能产生相对运动, URDF中的关节有六种运动类型

![image-20220528144655899](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601171550490.png)

1. continuous，描述旋转运动，可以围绕某一个轴无限旋转，比如小车的轮子，就属于这种类型。
2. revolute，也是旋转关节，和continuous类型的区别在于不能无限旋转，而是带有角度限制，比如机械臂的两个连杆，就属于这种运动。
3. prismatic，是滑动关节，可以沿某一个轴平移，也带有位置的极限，一般直线电机就是这种运动方式。
4. fixed，固定关节，是唯一一种不允许运动的关节，不过使用还是比较频繁的，比如相机这个连杆，安装在机器人上，相对位置是不会变化的，此时使用的连接方式就是Fixed。
5. Floating是浮动关节，第六种planar是平面关节，这两种使用相对较少。

在URDF模型中，每一个link都使用这样一段xml内容描述，比如关节的名字叫什么，运动类型是哪一种

![image-20220528144729633](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601171550837.png)

- parent标签：描述父连杆；
- child标签：描述子连杆，子连杆会相对父连杆发生运动；
- origin：表示两个连杆坐标系之间的关系，也就是图中红色的向量，可以理解为这两个连杆该如何安装到一起；
- axis表示关节运动轴的单位向量，比如z等于1，就表示这个旋转运动是围绕z轴的正方向进行的；
- limit就表示运动的一些限制了，比如最小位置，最大位置，和最大速度等。

### robot

最终所有的link和joint标签完成了对机器人每个部分的描述和组合，全都放在一个robot标签中，就形成了完整的机器人模型

## 示例

```bash
ros2 launch learning_urdf display.launch.py
```

![image-20260117155544819](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601171555919.png)

### 启动文件

```python
from ament_index_python.packages import get_package_share_path

from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument
from launch.conditions import IfCondition, UnlessCondition
from launch.substitutions import Command, LaunchConfiguration

from launch_ros.actions import Node
from launch_ros.parameter_descriptions import ParameterValue

def generate_launch_description():
    urdf_tutorial_path = get_package_share_path('learning_urdf')
    default_model_path = urdf_tutorial_path / 'urdf/mbot_base.urdf'
    default_rviz_config_path = urdf_tutorial_path / 'rviz/urdf.rviz'

    gui_arg = DeclareLaunchArgument(name='gui', default_value='false', choices=['true', 'false'],
                                    description='Flag to enable joint_state_publisher_gui')
    model_arg = DeclareLaunchArgument(name='model', default_value=str(default_model_path),
                                      description='Absolute path to robot urdf file')
    rviz_arg = DeclareLaunchArgument(name='rvizconfig', default_value=str(default_rviz_config_path),
                                     description='Absolute path to rviz config file')

    robot_description = ParameterValue(Command(['xacro ', LaunchConfiguration('model')]),
                                       value_type=str)

    robot_state_publisher_node = Node(
        package='robot_state_publisher',
        executable='robot_state_publisher',
        parameters=[{'robot_description': robot_description}]
    )

    # Depending on gui parameter, either launch joint_state_publisher or joint_state_publisher_gui
    joint_state_publisher_node = Node(
        package='joint_state_publisher',
        executable='joint_state_publisher',
        condition=UnlessCondition(LaunchConfiguration('gui'))
    )

    joint_state_publisher_gui_node = Node(
        package='joint_state_publisher_gui',
        executable='joint_state_publisher_gui',
        condition=IfCondition(LaunchConfiguration('gui'))
    )

    rviz_node = Node(
        package='rviz2',
        executable='rviz2',
        name='rviz2',
        output='screen',
        arguments=['-d', LaunchConfiguration('rvizconfig')],
    )

    return LaunchDescription([
        gui_arg,
        model_arg,
        rviz_arg,
        joint_state_publisher_node,
        joint_state_publisher_gui_node,
        robot_state_publisher_node,
        rviz_node
    ])
```

### 模型描述

```xml
<?xml version="1.0" ?>
<robot name="mbot">

    <link name="base_link">
        <visual>
            <origin xyz=" 0 0 0" rpy="0 0 0" />
            <geometry>
                <cylinder length="0.16" radius="0.20"/>
            </geometry>
            <material name="yellow">
                <color rgba="1 0.4 0 1"/>
            </material>
        </visual>
    </link>

    <joint name="left_wheel_joint" type="continuous">
        <origin xyz="0 0.19 -0.05" rpy="0 0 0"/>
        <parent link="base_link"/>
        <child link="left_wheel_link"/>
        <axis xyz="0 1 0"/>
    </joint>

    <link name="left_wheel_link">
        <visual>
            <origin xyz="0 0 0" rpy="1.5707 0 0" />
            <geometry>
                <cylinder radius="0.06" length = "0.025"/>
            </geometry>
            <material name="white">
                <color rgba="1 1 1 0.9"/>
            </material>
        </visual>
    </link>

    <joint name="right_wheel_joint" type="continuous">
        <origin xyz="0 -0.19 -0.05" rpy="0 0 0"/>
        <parent link="base_link"/>
        <child link="right_wheel_link"/>
        <axis xyz="0 1 0"/>
    </joint>

    <link name="right_wheel_link">
        <visual>
            <origin xyz="0 0 0" rpy="1.5707 0 0" />
            <geometry>
                <cylinder radius="0.06" length = "0.025"/>
            </geometry>
            <material name="white">
                <color rgba="1 1 1 0.9"/>
            </material>
        </visual>
    </link>

    <joint name="front_caster_joint" type="continuous">
        <origin xyz="0.18 0 -0.095" rpy="0 0 0"/>
        <parent link="base_link"/>
        <child link="front_caster_link"/>
        <axis xyz="0 1 0"/>
    </joint>

    <link name="front_caster_link">
        <visual>
            <origin xyz="0 0 0" rpy="0 0 0"/>
            <geometry>
                <sphere radius="0.015" />
            </geometry>
            <material name="black">
                <color rgba="0 0 0 0.95"/>
            </material>
        </visual>
    </link>

    <joint name="back_caster_joint" type="continuous">
        <origin xyz="-0.18 0 -0.095" rpy="0 0 0"/>
        <parent link="base_link"/>
        <child link="back_caster_link"/>
        <axis xyz="0 1 0"/>
    </joint>

    <link name="back_caster_link">
        <visual>
            <origin xyz="0 0 0" rpy="0 0 0"/>
            <geometry>
                <sphere radius="0.015" />
            </geometry>
            <material name="black">
                <color rgba="0 0 0 0.95"/>
            </material>
        </visual>
    </link>

</robot>
```

这一使用工具辅助查看

```bash
urdf_to_graphiz mbot_base.urdf 
```

![image-20260117160938759](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601171609836.png)

## 自定义bot

```bash
ros2 pkg create bot_3D_desc --build-type ament_cmake
```

![image-20260121114509772](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601211145859.png)

```cmake
install(DIRECTORY launch urdf config
  DESTINATION share/${PROJECT_NAME}
)
```

### 机器人描述

```xml
<?xml version="1.0"?>
<robot name="first_robot">
    <!-- 身体部分 -->
    <link name="base_link">
        <!-- 外观描述-->
        <visual>
            <!-- 描述沿着自己几何中心的位移以及旋转 -->
            <origin xyz="0.0 0.0 0.0" rpy="0.0 0.0 0.0"/>
            <!-- 形状描述, 单位 米 -->
            <geometry>
                <cylinder radius="0.10" length="0.12"/>
            </geometry> 
            <!-- 颜色描述 -->
            <material name="white">
                <color rgba="1.0 1.0 1.0 0.5"/>
            </material>
        </visual>
    </link>

    <!-- 机器人的IMU, 惯性测量传感器 -->
    <link name="imu_link">
        <!-- 外观描述-->
        <visual>
            <!-- 描述沿着自己几何中心的位移以及旋转 -->
            <origin xyz="0.0 0.0 0.0" rpy="0.0 0.0 0.0"/>
            <!-- 形状描述, 单位 米 正方体 -->
            <geometry>
                <box size="0.02 0.02 0.02"/>
            </geometry> 
            <!-- 颜色描述 -->
            <material name="black">
                <color rgba="0.0 0.0 0.0 0.5"/>
            </material>
        </visual>
    </link>

    <!-- 连接身体和IMU的关节, 把IMU固定在身体上 -->
    <joint name="imu_joint" type="fixed">
        <origin xyz="0.0 0.0 0.3" rpy="0.0 0.0 0.0"/>
        <parent link="base_link"/>
        <child link="imu_link"/>
    </joint>

</robot>
```

### 生成

```bash
# 结构可视化pdf
urdf_to_graphviz bot_3D_desc/urdf/first_robot.urdf
```

![image-20260121114900192](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601211149274.png)

![image-20260121115218556](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601211152725.png)

![image-20260121115348640](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601211153699.png)

![image-20260121115509513](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601211155657.png)

### 添加位置描述

默认这个程序不解析配置文件里面的位置信息, 可以使用两个节点进行发布

```bash
sudo apt-get install ros-$ROS_DISTRO-joint-state-publisher
sudo apt-get install ros-$ROS_DISTRO-robot-state-publisher
```

```bash
import launch
import launch_ros
from ament_index_python.packages import get_package_share_directory
import os

def generate_launch_description():
    pkg_share = get_package_share_directory('bot_3D_desc')
    default_urdf_file_path = os.path.join(pkg_share, 'urdf', 'first_robot.urdf')
    default_rviz_config_path = os.path.join(pkg_share, 'config', 'display_robot.rviz')
    # 构建一个参数可以供外部传入URDF文件路径
    action_declear_arg_mode_path = launch.actions.DeclareLaunchArgument(
        name="model",
        default_value=default_urdf_file_path,
        description="Absolute path to robot urdf file"
    )
    # 读取文件的内容作为参数值
    command_result = launch.substitutions.Command(
        ['cat ', launch.substitutions.LaunchConfiguration('model')]
    )
    robot_desc_value = launch_ros.parameter_descriptions.ParameterValue(
        command_result,
        value_type=str
    )
    # 节点：用于发布机器人状态信息
    action_robot_state_publisher = launch_ros.actions.Node(
        package='robot_state_publisher',
        executable='robot_state_publisher',
        name='robot_state_publisher',
        parameters=[{'robot_description': robot_desc_value}]
    )

    action_joint_state_publisher = launch_ros.actions.Node(
        package='joint_state_publisher',
        executable='joint_state_publisher',
        name='joint_state_publisher',
    )

    action_rviz_node = launch_ros.actions.Node(
        package='rviz2',
        executable='rviz2',
        name='rviz2',
        arguments=['-d', default_rviz_config_path],
    )


    return launch.LaunchDescription([
        action_declear_arg_mode_path,
        action_robot_state_publisher,
        action_joint_state_publisher,
        action_rviz_node
    ])
```

```bash
ros2 launch bot_3D_desc display_robot.launch.py
```

![image-20260121122828182](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601211228316.png)

可以保存一下配置在config文件夹里面, 在参数里面设置加载