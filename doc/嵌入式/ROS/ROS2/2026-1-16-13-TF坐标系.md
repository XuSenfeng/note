# TF坐标系

## 示例

```bash
sudo apt install ros-humble-turtle-tf2-py ros-humble-tf2-tools
sudo pip3 install transforms3d
ros2 launch turtle_tf2_py turtle_tf2_demo.launch.py
ros2 run turtlesim turtle_teleop_key
# 查看坐标系结构
ros2 run tf2_tools view_frames 
# 查看坐标之间的关系
ros2 run tf2_ros tf2_echo turtle2 turtle1
# 可视化界面
ros2 run rviz2 rviz2 -d $(ros2 pkg prefix --share turtle_tf2_py)/rviz/turtle_rviz.rviz
```

![image-20260116212533125](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601162125208.png)

```bash
# 创建两个坐标系, 基础坐标以及雷达的坐标(静态)
ros2 run tf2_ros static_transform_publisher --x 0.1 --y 0.0 --z 0.2 --roll 0.0 --pitch 0.0 --yaw 0.0 --frame-id base_link --child-frame-id base_laser
# 创建墙的坐标基于雷达坐标
ros2 run tf2_ros static_transform_publisher --x 0.3 --y 0.0 --z 0.0 --roll 0.0 --pitch 0.0 --yaw 0.0 --frame-id base_laser --child-frame-id wall_point
# 获取相对坐标
(base) jiao@jiao-virtual-machine:~/ros/ros2_21_tutorials$ ros2 run tf2_ros tf2_echo base_link wall_point
[INFO] [1768898775.078954176] [tf2_echo]: Waiting for transform base_link ->  wall_point: Invalid frame ID "base_link" passed to canTransform argument target_frame - frame does not exist
At time 0.0
- Translation: [0.400, 0.000, 0.200] # 位移
- Rotation: in Quaternion (xyzw) [0.000, 0.000, 0.000, 1.000] # 旋转
- Rotation: in RPY (radian) [0.000, -0.000, 0.000]
- Rotation: in RPY (degree) [0.000, -0.000, 0.000]
- Matrix: # 旋转矩阵
  1.000  0.000  0.000  0.400
  0.000  1.000  0.000  0.000
  0.000  0.000  1.000  0.200
  0.000  0.000  0.000  1.000
# 查看坐标系结构框图
ros2 run tf2_tools view_frames 
```

可视化展示几种旋转的关系

```bash
sudo apt-get install mrpt-apps -y
3d-rotation-converter
```

![image-20260120165803321](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601201658588.png)

![image-20260120170003402](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601201700554.png)

实际的原理使用的是topic在发布消息

```bash
# 所有的节点
(base) jiao@jiao-virtual-machine:~$ ros2 topic list
/parameter_events
/rosout
/tf_static
# 发布节点的信息
(base) jiao@jiao-virtual-machine:~$ ros2 topic info /tf_static 
Type: tf2_msgs/msg/TFMessage
Publisher count: 2
Subscription count: 0
# 使用的数据类型, 实际是两个坐标系的相对位置发布
(base) jiao@jiao-virtual-machine:~$ ros2 interface show tf2_msgs/msg/TFMessage 
geometry_msgs/TransformStamped[] transforms
	#
	#
	std_msgs/Header header
		builtin_interfaces/Time stamp
			int32 sec
			uint32 nanosec
		string frame_id
	string child_frame_id
	Transform transform
		Vector3 translation
			float64 x
			float64 y
			float64 z
		Quaternion rotation
			float64 x 0
			float64 y 0
			float64 z 0
			float64 w 1
```

### 坐标广播

#### 静态坐标变化

坐标系的位置是不变的

```python
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import TransformStamped
import tf_transformations
from tf2_ros.static_transform_broadcaster import StaticTransformBroadcaster
class StaticTFBroadcaster(Node):
    def __init__(self, name):
        super().__init__(name)
        # 创建一个TF广播器对象
        self.tf_broadcaster = StaticTransformBroadcaster(self)
        # 创建一个坐标变换的消息对象
        static_transformStamped = TransformStamped()
        # 设置坐标变换消息的时间戳
        static_transformStamped.header.stamp = self.get_clock().now().to_msg()
        # 设置一个坐标变换的源坐标系
        static_transformStamped.header.frame_id = 'world'
        # 设置一个坐标变换的目标坐标系
        static_transformStamped.child_frame_id  = 'house'
        # 设置坐标变换中的X、Y、Z向的平移
        static_transformStamped.transform.translation.x = 10.0
        static_transformStamped.transform.translation.y = 5.0
        static_transformStamped.transform.translation.z = 0.0
        # 将欧拉角转换为四元数（roll, pitch, yaw）
        quat = tf_transformations.quaternion_from_euler(0.0, 0.0, 0.0)
        # 设置坐标变换中的X、Y、Z向的旋转（四元数）
        static_transformStamped.transform.rotation.x = quat[0]
        static_transformStamped.transform.rotation.y = quat[1]
        static_transformStamped.transform.rotation.z = quat[2]
        static_transformStamped.transform.rotation.w = quat[3]
        # 广播静态坐标变换，广播后两个坐标系的位置关系保持不变
        self.tf_broadcaster.sendTransform(static_transformStamped)

def main(args=None):
    rclpy.init(args=args)
    node = StaticTFBroadcaster("static_tf_broadcaster")
    rclpy.spin(node)
    node.destroy_node()
```

可以使用math进行弧度以及角度的变化

```python
math.radians(180)
```

#### 运动广播

```python
import rclpy                                       # ROS2 Python接口库
from rclpy.node import Node                        # ROS2 节点类
from geometry_msgs.msg import TransformStamped     # 坐标变换消息
import tf_transformations                          # TF坐标变换库
from tf2_ros import TransformBroadcaster           # TF坐标变换广播器
from turtlesim.msg import Pose                     # turtlesim小海龟位置消息

class TurtleTFBroadcaster(Node):

    def __init__(self, name):
        super().__init__(name)
		# 创建一个海龟名称的参数
        self.declare_parameter('turtlename', 'turtle')
        # 优先使用外部设置的参数值，否则用默认值
        self.turtlename = self.get_parameter(
            'turtlename').get_parameter_value().string_value
		# 创建一个TF坐标变换的广播对象并初始化
        self.tf_broadcaster = TransformBroadcaster(self)
		# 创建一个订阅者，订阅海龟的位置消息, 使用参数中获取到的海龟名称
        self.subscription = self.create_subscription(
            Pose,
            f'/{self.turtlename}/pose',                       
            self.turtle_pose_callback, 1)

    def turtle_pose_callback(self, msg):
        # 创建一个坐标变换的消息对象
        transform = TransformStamped()
        # 设置坐标变换消息的时间戳
        transform.header.stamp = self.get_clock().now().to_msg()
        # 设置一个坐标变换的源坐标系
        transform.header.frame_id = 'world'
        # 设置一个坐标变换的目标坐标系, 设置坐标变换中的X、Y、Z向的平移
        transform.child_frame_id = self.turtlename
        transform.transform.translation.x = msg.x
        transform.transform.translation.y = msg.y
        transform.transform.translation.z = 0.0
        # 将欧拉角转换为四元数（roll, pitch, yaw）
        q = tf_transformations.quaternion_from_euler(0, 0, msg.theta) 
        # 设置坐标变换中的X、Y、Z向的旋转（四元数）
        transform.transform.rotation.x = q[0]
        transform.transform.rotation.y = q[1]
        transform.transform.rotation.z = q[2]
        transform.transform.rotation.w = q[3]

        # Send the transformation
        self.tf_broadcaster.sendTransform(transform)

def main(args=None):
    rclpy.init(args=args)
    node = TurtleTFBroadcaster("turtle_tf_broadcaster")
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()
```

### 监听

```python
import rclpy
from rclpy.node import Node
import tf_transformations
from tf2_ros import TransformException
from tf2_ros.buffer import Buffer 
from tf2_ros.transform_listener import TransformListener

class TFListener(Node):

    def __init__(self, name):
        super().__init__(name)
        # 创建一个源坐标系名的参数, 如果外部（启动文件、命令行参数、参数服务器）已经为该参数设置了值 → 声明操作仅确认参数存在，不会覆盖外部值；
        self.declare_parameter('source_frame', 'world')
        # 优先使用外部设置的参数值，否则用默认值
        self.source_frame = self.get_parameter(
            'source_frame').get_parameter_value().string_value
		# 创建一个目标坐标系名的参数
        self.declare_parameter('target_frame', 'house')
        self.target_frame = self.get_parameter(
            'target_frame').get_parameter_value().string_value
		# 创建保存坐标变换信息的缓冲区
        self.tf_buffer = Buffer()
        # 创建坐标变换的监听器
        self.tf_listener = TransformListener(self.tf_buffer, self)
        self.timer = self.create_timer(1.0, self.on_timer)

    def on_timer(self):
        try:
            # 获取ROS系统的当前时间
            now = rclpy.time.Time()
            # 监听当前时刻源坐标系到目标坐标系的坐标变换, 获取标准数据
            # 可以输入两个时间, 查询的时间以及超时时间
            trans = self.tf_buffer.lookup_transform(
                self.target_frame,
                self.source_frame,
                now)
        # 如果坐标变换获取失败，进入异常报告
        except TransformException as ex:
            self.get_logger().info(
                f'Could not transform {self.target_frame} to {self.source_frame}: {ex}')
            return
        # 获取位置信息
        pos  = trans.transform.translation
        # 获取姿态信息（四元数）
        quat = trans.transform.rotation                             
        euler = tf_transformations.euler_from_quaternion([quat.x, quat.y, quat.z, quat.w])
        self.get_logger().info('Get %s --> %s transform: [%f, %f, %f] [%f, %f, %f]' % (self.source_frame, self.target_frame, pos.x, pos.y, pos.z, euler[0], euler[1], euler[2]))

def main(args=None):
    rclpy.init(args=args)
    node = TFListener("tf_listener")
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()
```

### 海龟跟踪示例

```python
import math
import rclpy
from rclpy.node import Node 
import tf_transformations
from tf2_ros import TransformException
from tf2_ros.buffer import Buffer
from tf2_ros.transform_listener import TransformListener
from geometry_msgs.msg import Twist
from turtlesim.srv import Spawn
class TurtleFollowing(Node):

    def __init__(self, name):
        super().__init__(name)
        self.declare_parameter('source_frame', 'turtle1')
        self.source_frame = self.get_parameter(
            'source_frame').get_parameter_value().string_value

        self.tf_buffer = Buffer()
        self.tf_listener = TransformListener(self.tf_buffer, self) 
		# 创建一个请求产生海龟的客户端
        self.spawner = self.create_client(Spawn, 'spawn')
        # 是否已经请求海龟生成服务的标志位
        self.turtle_spawning_service_ready = False 
        # 海龟是否产生成功的标志位
        self.turtle_spawned = False
		# 创建跟随运动海龟的速度话题
        self.publisher = self.create_publisher(Twist, 'turtle2/cmd_vel', 1) 
        self.timer = self.create_timer(1.0, self.on_timer)         

    def on_timer(self):
        from_frame_rel = self.source_frame
        # 目标坐标系
        to_frame_rel   = 'turtle2'
		# 如果已经请求海龟生成服务
        if self.turtle_spawning_service_ready:
            # 如果跟随海龟已经生成
            if self.turtle_spawned:
                try:
                    # 获取ROS系统的当前时间
                    now = rclpy.time.Time()
                    # 监听当前时刻源坐标系到目标坐标系的坐标变换
                    trans = self.tf_buffer.lookup_transform(
                        to_frame_rel,
                        from_frame_rel,
                        now)
                except TransformException as ex:
                    self.get_logger().info(
                        f'Could not transform {to_frame_rel} to {from_frame_rel}: {ex}')
                    return
			   # 创建速度控制消息
                msg = Twist()
                # 根据海龟角度，计算角速度
                scale_rotation_rate = 1.0
                msg.angular.z = scale_rotation_rate * math.atan2(
                    trans.transform.translation.y,
                    trans.transform.translation.x)
			   # 根据海龟距离，计算线速度
                scale_forward_speed = 0.5
                msg.linear.x = scale_forward_speed * math.sqrt(
                    trans.transform.translation.x ** 2 +
                    trans.transform.translation.y ** 2)
                # 发布速度指令，海龟跟随运动
                self.publisher.publish(msg)
            else:
                # 如果跟随海龟没有生成
                if self.result.done():
                    self.get_logger().info(
                        f'Successfully spawned {self.result.result().name}')
                    self.turtle_spawned = True
                # 依然没有生成跟随海龟
                else: 
                    self.get_logger().info('Spawn is not finished')
        else: 
            # 如果没有请求海龟生成服务, 如果海龟生成服务器已经准备就绪
            if self.spawner.service_is_ready():
                # 创建一个请求的数据
                request = Spawn.Request()
                # 设置请求数据的内容，包括海龟名、xy位置、姿态
                request.name = 'turtle2'
                request.x = float(4)
                request.y = float(2)
                request.theta = float(0)
			   # 发送服务请求
                self.result = self.spawner.call_async(request)     
                # 设置标志位，表示已经发送请求
                self.turtle_spawning_service_ready = True 
            else:
                # 海龟生成服务器还没准备就绪的提示
                self.get_logger().info('Service is not ready')     


def main(args=None):
    rclpy.init(args=args) 
    node = TurtleFollowing("turtle_following")
    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()
```

### 启动脚本

```python
from launch import LaunchDescription
from launch.actions import DeclareLaunchArgument
from launch.substitutions import LaunchConfiguration
from launch_ros.actions import Node


def generate_launch_description():
    return LaunchDescription([
        Node(
            package='turtlesim',
            executable='turtlesim_node',
            name='sim'
        ),
        Node(
            package='learning_tf',
            executable='turtle_tf_broadcaster',
            name='broadcaster1',
            parameters=[
                {'turtlename': 'turtle1'}
            ]
        ),
        DeclareLaunchArgument(
            'target_frame', default_value='turtle1',
            description='Target frame name.'
        ),
        Node(
            package='learning_tf',
            executable='turtle_tf_broadcaster',
            name='broadcaster2',
            parameters=[
                {'turtlename': 'turtle2'}
            ]
        ),
        Node(
            package='learning_tf',
            executable='turtle_following',
            name='listener',
            parameters=[
                {'target_frame': LaunchConfiguration('target_frame')}
            ]
        ), 
    ])
```

## 手眼坐标变换

通过机械臂以及摄像头的关系, 计算物品和机械臂的关系

```bash
sudo apt-get install ros-$ROS_DISTRO-tf-transformations
pip install transforms3d
ros2 pkg create demo_tf --build-type ament_python --dependencies rclpy geometry_msgs tf_ros tf_transformations
```

