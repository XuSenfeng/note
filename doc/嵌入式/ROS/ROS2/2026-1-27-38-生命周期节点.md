# 生命周期节点

普通 ROS 2 节点启动后会直接进入 “运行” 状态，只有 “启动” 和 “终止” 两种状态，缺少标准化的 “初始化→配置→运行→清理” 流程（比如机器人节点需要先加载参数、初始化硬件，再真正运行；出错后也没法优雅重置，只能重启整个节点）。

而**生命周期节点**的核心价值，就是给节点引入了**标准化的状态机管理机制**，把节点的运行过程拆分为多个可管控、可切换的状态，实现对节点行为的精细化控制。

![image-20260127155132120](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601271559045.png)

有一个示例程序

```bash
ros2 run lifecycle lifecycle_talker
```

相比于普通的节点多出来话题以及service

```bash
(base) jiao@jiao-virtual-machine:~$ ros2 service list
/lc_talker/change_state #
/lc_talker/describe_parameters
/lc_talker/get_available_states #
/lc_talker/get_available_transitions
/lc_talker/get_parameter_types
/lc_talker/get_parameters
/lc_talker/get_state # 
/lc_talker/get_transition_graph
/lc_talker/list_parameters
/lc_talker/set_parameters
/lc_talker/set_parameters_atomically
# 获取一下当前的状态
(base) jiao@jiao-virtual-machine:~$ ros2 service call /lc_talker/get_state lifecycle_msgs/srv/GetState 
waiting for service to become available...
requester: making request: lifecycle_msgs.srv.GetState_Request()

response:
lifecycle_msgs.srv.GetState_Response(current_state=lifecycle_msgs.msg.State(id=1, label='unconfigured'))
```

这个节点目前是未配置状态

可以配置的状态有

```bash
(base) jiao@jiao-virtual-machine:~$ ros2 lifecycle list /lc_talker 
- configure [1] # 进入配置激活
	Start: unconfigured
	Goal: configuring
- shutdown [5] # 关闭
	Start: unconfigured
	Goal: shuttingdown
(base) jiao@jiao-virtual-machine:~$ ros2 lifecycle set /lc_talker configure
Transitioning successful
# 进入配置状态
(base) jiao@jiao-virtual-machine:~$ ros2 lifecycle set /lc_talker configure
Transitioning successful
(base) jiao@jiao-virtual-machine:~$ ros2 service call /lc_talker/get_state lifecycle_msgs/srv/GetState 
waiting for service to become available...
requester: making request: lifecycle_msgs.srv.GetState_Request()

response:
lifecycle_msgs.srv.GetState_Response(current_state=lifecycle_msgs.msg.State(id=2, label='inactive'))
```

这时候可以看到一个新的话题`/lifecycle_chatter`, 但是没有发布的消息

```bash
(base) jiao@jiao-virtual-machine:~$ ros2 lifecycle set /lc_talker activate # 配置为激活
(base) jiao@jiao-virtual-machine:~$ ros2 topic echo /lifecycle_chatter 
data: 'Lifecycle HelloWorld #212'
---
data: 'Lifecycle HelloWorld #213'
---

```

```bash
ros2(base) jiao@jiao-virtual-machine:~$ ros2 topic list
/cmd_vel
/lc_talker/transition_event
/odom
/parameter_events
/rosout
(base) jiao@jiao-virtual-machine:~$ ros2 topic echo /lc_talker/transition_event # 查看日志
```

## 代码实现

### python

实际是一系列的函数, 在外部的状态变化的时候, 调用对应的函数

```python
import rclpy
from rclpy.lifecycle import LifecycleNode, TransitionCallbackReturn

class LearnLifeCycleNode(LifecycleNode):
    def __init__(self):
        super().__init__('lifecyclenode')
        self.timer_period = 0
        self.timer_ = None
        self.get_logger().info(f'{self.get_name()}:已创建')

    def timer_callback(self):
        self.get_logger().info('定时器打印进行中...')

    def on_configure(self, state):
        self.timer_period = 1.0  # 设置定时器周期
        self.get_logger().info('on_configure():配置周期 timer_period')
        return TransitionCallbackReturn.SUCCESS

    def on_activate(self, state):
        self.timer_ = self.create_timer(self.timer_period, self.timer_callback)
        self.get_logger().info('on_activate():处理激活指令，创建定时器')
        return TransitionCallbackReturn.SUCCESS

    def on_deactivate(self, state):
        self.destroy_timer(self.timer_) # 销毁定时器
        self.get_logger().info('on_deactivate():处理失活指令停止定时器')
        return TransitionCallbackReturn.SUCCESS

    def on_cleanup(self, state):
        self.timer_ = None
        self.timer_period = 0
        self.get_logger().info('on_cleanup():处理清理指令')
        return TransitionCallbackReturn.SUCCESS

    def on_shutdown(self, state):
        #  定时器未销毁则销毁
        if self.timer_: self.destroy_timer(self.timer_)
        self.get_logger().info('on_shutdown():处理关闭指令')
        return TransitionCallbackReturn.SUCCESS

    def on_error(self, state):
        # 直接调用父类处理
        return super().on_error(state)

def main():
    rclpy.init()
    node = LearnLifeCycleNode()
    rclpy.spin(node)
    rclpy.shutdown()
```

### cpp

```cpp
#include "rclcpp/rclcpp.hpp"
#include "rclcpp_lifecycle/lifecycle_node.hpp"

using CallbackReturn =
    rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn;

class LearnLifeCycleNode : public rclcpp_lifecycle::LifecycleNode {
public:
  LearnLifeCycleNode()
      : rclcpp_lifecycle::LifecycleNode("lifecyclenode") {
    timer_period_ = 1.0;
    timer_ = nullptr;
    RCLCPP_INFO(get_logger(), "%s: 已创建", get_name());
  }

  CallbackReturn on_configure(const rclcpp_lifecycle::State &state) override {
    (void)state;
    timer_period_ = 1.0;
    RCLCPP_INFO(get_logger(), "on_configure():配置周期 timer_period");
    return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::
        CallbackReturn::SUCCESS;
  }

  CallbackReturn on_activate(const rclcpp_lifecycle::State &state) override {
    (void)state;
    timer_ = create_wall_timer(
        std::chrono::seconds(static_cast<int>(timer_period_)),
        [this]() { RCLCPP_INFO(get_logger(), "定时器打印进行中..."); });
    RCLCPP_INFO(get_logger(), "on_activate():处理激活指令，创建定时器");
    return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::
        CallbackReturn::SUCCESS;
  }

  CallbackReturn on_deactivate(const rclcpp_lifecycle::State &state) override {
    (void)state;
    timer_.reset();
    RCLCPP_INFO(get_logger(), "on_deactivate():处理失活指令，停止定时器");
    return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::
        CallbackReturn::SUCCESS;
  }

  CallbackReturn on_shutdown(const rclcpp_lifecycle::State &state) override {
    (void)state;
    timer_.reset();
    RCLCPP_INFO(get_logger(), "on_shutdown():处理关闭指令");
    return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::
        CallbackReturn::SUCCESS;
  }

private:
  rclcpp::TimerBase::SharedPtr timer_;
  double timer_period_;
};

int main(int argc, char **argv) {
  rclcpp::init(argc, argv);
  auto node = std::make_shared<LearnLifeCycleNode>();
  rclcpp::spin(node->get_node_base_interface());
  rclcpp::shutdown();
  return 0;
}
```



