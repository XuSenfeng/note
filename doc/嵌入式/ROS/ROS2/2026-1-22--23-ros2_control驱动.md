# ros2_control驱动

`os2_control` 是 ROS 2 官方推出的硬件控制中间件，核心目标是**解耦机器人的「高层控制逻辑」和「底层硬件驱动」**：

- 对开发者：不用关心硬件的具体通信协议（比如串口、CAN、以太网），只需调用标准化接口就能控制电机 / 传感器；
- 对硬件：不同厂商的硬件（比如不同品牌的舵机、机械臂）只需适配 `ros2_control` 接口，就能无缝接入 ROS 2 生态；
- 对仿真：`ros2_control` 能让**仿真硬件（Gazebo 中的关节）** 和**真实硬件**使用完全相同的高层控制代码，实现「仿真与实机一键切换」。

简单说：`ros2_control` 是 ROS 2 中连接「算法（比如运动控制、路径规划）」和「硬件（或仿真硬件）」的 “翻译官”。

> **ROS2 Control 的核心价值：硬件抽象**
>
> 不管你是控制「Gazebo 仿真关节」还是「真实机器人的电机驱动板」，ROS2 Control 都把它们的接口标准化为：
>
> - `command_interface`（命令接口：如 effort/velocity）：接收控制指令；
>
> - `state_interface`（状态接口：如 position/velocity/effort）：反馈状态数据；
>
>     你不用关心 “Gazebo 怎么接收力矩指令” 或 “真实驱动板的通信协议”，只需要给控制器发标准化的 Topic 指令即可。

之前使用的插件进行设备的控制, 但是实际的使用时候没有真是的插件, 如果需要重新编写代码, 这个是重复造轮子

![image-20260122163045674](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601221630732.png)

需要统一的是通信的数据输入

![image-20260122163119290](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601221631343.png)

ros2_control把硬件分为三类

+ 传感器: 比如编码器、IMU、激光雷达
+ 系统: 另外两种的集合,比如整个机械臂、移动底盘，包含多个执行器 / 传感器
+ 执行器: 比如单个电机、舵机

```bash
sudo apt-get install ros-$ROS_DISTRO-ros2-control
```

1. 硬件组件层（Hardware Components）

这是直接对接硬件 / 仿真硬件的最底层，核心是实现 `read()` 和 `write()` 两个方法：

- `read()`：从硬件 / 仿真中读取状态（比如关节位置、速度、传感器数据）；
- `write()`：将控制指令（比如关节目标位置、力矩）发送到硬件 / 仿真。

2. 接口层（Standard Interfaces）

`ros2_control` 定义了**标准化的硬件接口**，让控制器和硬件组件之间能 “无缝通信”，常用的接口

![image-20260122181600640](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601221816705.png)

3. 控制器层（Controllers）

这是实现控制逻辑的核心层，`ros2_control` 提供了大量开箱即用的控制器（无需自己写），新手高频使用的：

- `joint_state_broadcaster`：广播关节状态（最基础，必须加载）；
- `joint_trajectory_controller`：关节轨迹控制器（控制多关节按预定轨迹运动）；
- `joint_position_controller`：单关节位置控制器；
- `joint_velocity_controller`：单关节速度控制器；
- `effort_controller`：单关节力矩控制器。

控制器支持**动态加载 / 卸载 / 切换**，比如可以先加载位置控制器，运行中切换为速度控制器。

4. 控制器管理器（Controller Manager）

相当于 `ros2_control` 的 “大脑”，负责：

- 加载 / 卸载控制器；
- 启动 / 停止控制器；
- 切换控制器的状态（活跃 / 非活跃）；
- 提供 ROS 2 服务 / 话题接口，让你能通过命令行或节点控制控制器。

## 使用

```bash
(base) jiao@jiao-virtual-machine:~$ ros2 control --help
usage: ros2 control [-h]
                    Call `ros2 control <command> -h` for more detailed usage.
                    ...

Various control related sub-commands

options:
  -h, --help            show this help message and exit

Commands:
  list_controller_types         Output the available controller types and their base classes
  list_controllers              Output the list of loaded controllers, their type and status
  list_hardware_components      Output the list of available hardware components
  list_hardware_interfaces      Output the list of available command and state interfaces
  load_controller               Load a controller in a controller manager
  reload_controller_libraries   Reload controller libraries
  set_controller_state          Adjust the state of the controller
  set_hardware_component_state  Adjust the state of the hardware component
  switch_controllers            Switch controllers in a controller manager
  unload_controller             Unload a controller in a controller manager
  view_controller_chains        Generates a diagram of the loaded chained controllers into /tmp/controller_diagram.gv.pdf

  Call `ros2 control <command> -h` for more detailed usage.
```

实际就是一些列的控制器接口的操作

![image-20260122163818951](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601221638030.png)

可以在depends里面查看提供的控制器

```bash
sudo apt install  ros-$ROS_DISTRO-ros2-controllers
```

![image-20260122170304556](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601221703615.png)

安装插件

```bash
sudo apt install  ros-$ROS_DISTRO-gazebo-ros2-control
```

### 配置gazebo的插件

```xml
<?xml version="1.0"?>
<robot xmlns:xacro="http://www.ros.org/wiki/xacro">
    <xacro:macro name="fishbot_ros2_control">
    <!-- ROS2 Control 插件配置 -->
    <ros2_control name="FishBotGazeboSystem" type="system">
            <!-- 设置一个硬件, 设置一个驱动库的名字 -->
            <hardware>
                <plugin>gazebo_ros2_control/GazeboSystem</plugin>
            </hardware>
            <!-- 定义机器人的关节和它们的接口 -->
            <joint name="left_wheel_joint">
                <!-- 配置一个关节的速度 -->
                <command_interface name="velocity">
                    <param name="min">-1</param>
                    <param name="max">1</param>
                </command_interface>
                <!-- 配置一个关节的力矩 -->
                <command_interface name="effort">
                    <param name="min">-0.1</param>
                    <param name="max">0.1</param>
                </command_interface>
                <!-- 配置一个关节的位置状态 -->
                <state_interface name="position" />
                <!-- 配置一个关节的速度状态 -->
                <state_interface name="velocity" />
                <!-- 配置一个关节的力矩状态 -->
                <state_interface name="effort" />
            </joint>
            <joint name="right_wheel_joint">
                <command_interface name="velocity">
                    <param name="min">-1</param>
                    <param name="max">1</param>
                </command_interface>
                <command_interface name="effort">
                    <param name="min">-0.1</param>
                    <param name="max">0.1</param>
                </command_interface>
                <state_interface name="position" />
                <state_interface name="velocity" />
                <state_interface name="effort" />
            </joint>
        </ros2_control>
        <gazebo>
        <plugin filename="libgazebo_ros2_control.so" name="gazebo_ros2_control">
            <!-- 参数配置文件 -->
            <parameters>$(find bot_3D_desc)/config/fishbot_ros2_controller.yaml</parameters>
        </plugin>
</gazebo>
    </xacro:macro>
</robot>
```

和之前的 ` <xacro:gazebo_control_plugin/>`这个控制标签的冲突的, 需要注释一下

加载一个yaml的配置文件

```yaml
controller_manager:
  ros__parameters:
    update_rate: 100  # Hz
    use_sim_time: true
```



### 控制

`ros2 control`实际是使用一系列的server进行控制

```bash
(base) jiao@jiao-virtual-machine:~$ ros2 service list | grep controller
/controller_manager/configure_controller
/controller_manager/describe_parameters
/controller_manager/get_parameter_types
/controller_manager/get_parameters
/controller_manager/list_controller_types
/controller_manager/list_controllers
/controller_manager/list_hardware_components
/controller_manager/list_hardware_interfaces
/controller_manager/list_parameters
/controller_manager/load_controller
/controller_manager/reload_controller_libraries
/controller_manager/set_hardware_component_state
/controller_manager/set_parameters
/controller_manager/set_parameters_atomically
/controller_manager/switch_controller
/controller_manager/unload_controller
# 可以直接拿来用的所有「控制器类型」
(base) jiao@jiao-virtual-machine:~/ros/dev_ws$ ros2 control list_controller_types 
[INFO] [1769078338.267571743] [_ros2cli_18134]: waiting for service /controller_manager/list_controller_types to become available...
controller_manager/test_controller                                     controller_interface::ControllerInterface
controller_manager/test_controller_failed_activate                     controller_interface::ControllerInterface
controller_manager/test_controller_failed_init                         
...
# 查看当前的硬件接口
(base) jiao@jiao-virtual-machine:~/ros/dev_ws$ ros2 control list_hardware_interfaces 
command interfaces
		# unclaimed未被占用
        left_wheel_joint/effort [available] [unclaimed]
        left_wheel_joint/velocity [available] [unclaimed]
        right_wheel_joint/effort [available] [unclaimed]
        right_wheel_joint/velocity [available] [unclaimed]
state interfaces
        left_wheel_joint/effort
        left_wheel_joint/position
        left_wheel_joint/velocity
        right_wheel_joint/effort
        right_wheel_joint/position
        right_wheel_joint/velocity
# 所有的硬件的组件
(base) jiao@jiao-virtual-machine:~/ros/dev_ws$ ros2 control list_hardware_components 
[INFO] [1769078781.066807208] [_ros2cli_18607]: waiting for service /controller_manager/list_hardware_components to become available...
Hardware Component 1
        name: FishBotGazeboSystem
        type: 
        plugin name: 
        state: id=3 label=active
        command interfaces
                left_wheel_joint/velocity [available] [unclaimed]
                left_wheel_joint/effort [available] [unclaimed]
                right_wheel_joint/velocity [available] [unclaimed]
                right_wheel_joint/effort [available] [unclaimed]
```

### 关节状态发布控制器

这个时候由于没有发布两个轮子的位置的节点, 所以轮子的位置是不对的, 可以使用一个controller进行发布

在配置文件里面添加一个controller配置

```yaml
controller_manager:
  ros__parameters:
    update_rate: 100  # Hz
    use_sim_time: true
    # 扫描所有的状态控制接口, 发布关节状态
    fishbot_joint_state_broadcaster:
      type: joint_state_broadcaster/JointStateBroadcaster
      publish_rate: 50  # Hz
```

这里只是配置, 还没有启动

> 广播器会连接到你 xacro 中定义的`left_wheel_joint`和`right_wheel_joint`硬件接口；
>
> 以 50Hz 的频率读取这两个关节的`position`（位置，车轮转动弧度）、`velocity`（速度，弧度 / 秒）、`effort`（力矩，牛米）；
>
> 将这些数据打包发布到`/joint_states`话题。

```bash
ros2 control load_controller fishbot_joint_state_broadcaster --set-state active
```

![image-20260122190423729](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601221904957.png)

可以使用launch文件一次性加载

```python
    # 自动加载关节状态控制器, 用于发布关节状态信息
    action_load_joint_state_controller = launch.actions.ExecuteProcess(
        cmd=['ros2', 'control', 'load_controller', '--set-state', 'active', 'fishbot_joint_state_broadcaster'],
        output='screen'
    )
    
    # 加载的时候是有时间的, 需要额外的配置
    launch.actions.RegisterEventHandler(
            event_handler=launch.event_handlers.OnProcessExit(
                target_action=action_spawn_entity,
                on_exit=[action_load_joint_state_controller],
            )
    ), # 在spawn_entity节点退出后加载控制
```



### 力度控制器

```yaml
controller_manager:
  ros__parameters:
    update_rate: 100  # Hz
    use_sim_time: true
    fishbot_joint_state_broadcaster:
      type: joint_state_broadcaster/JointStateBroadcaster
      publish_rate: 50  # Hz
    # 有这个controller
    fishbot_effort_controllers:
      type: effort_controllers/JointGroupEffortController
      
# 配制实际的参数
fishbot_effort_controllers:
  ros__parameters:
    # 可以控制的关节列表
    joints:
      - left_wheel_joint
      - right_wheel_joint
    # 控制接口类型
    command_interfaces:
      - effort
    # 状态接口类型
    state_interfaces:
      - position
      - velocity
      - effort
```

在配置文件的添加和上面类似

```bash
jiao@jiao-virtual-machine:~$ ros2 topic list -t | grep effort
/fishbot_effort_controllers/commands [std_msgs/msg/Float64MultiArray]
/fishbot_effort_controllers/transition_event [lifecycle_msgs/msg/TransitionEvent]
# 可以发布命令控制
jiao@jiao-virtual-machine:~$ ros2 topic pub /fishbot_effort_controllers/commands std_msgs/msg/Float64MultiArray "{data: [0.0001, 0.0001]}"
```

使用数组控制力

![image-20260123182219870](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601231822998.png)

### 两轮差速控制器

```yaml
controller_manager:
  ros__parameters:
    update_rate: 100  # Hz
    use_sim_time: true
    fishbot_joint_state_broadcaster:
      type: joint_state_broadcaster/JointStateBroadcaster
      publish_rate: 50  # Hz
    fishbot_effort_controllers:
      type: effort_controllers/JointGroupEffortController
    # 添加节点
    fishbot_diff_drive_controller:
      type: diff_drive_controller/DiffDriveController

# 使用的参数
fishbot_diff_drive_controller:
  ros__parameters:
  	# 关节的名字
    left_wheel_names: ["left_wheel_joint"]
    right_wheel_names: ["right_wheel_joint"]
	# 距离
    wheel_separation: 0.20
    # 同侧车轮数量
    #wheels_per_side: 1  # actually 2, but both are controlled by 1 signal
    # 半径, 用于转换 “车轮转速 ↔ 底盘线速度”
    wheel_radius: 0.032
	# 间距的倍数, 半径的倍数, 动态控制
	# 用于微调轮距 / 轮径（比如仿真 / 实际硬件的尺寸和理论值有偏差）
    wheel_separation_multiplier: 1.0
    left_wheel_radius_multiplier: 1.0
    right_wheel_radius_multiplier: 1.0
    
	# 里程计（Odom）发布配置（控制定位数据输出）
    publish_rate: 50.0
    odom_frame_id: odom # 里程计参考坐标系名
    base_frame_id: base_footprint # 机器人底盘坐标系名
    # 位置的噪声
    pose_covariance_diagonal : [0.001, 0.001, 0.0, 0.0, 0.0, 0.01]
    twist_covariance_diagonal: [0.001, 0.0, 0.0, 0.0, 0.0, 0.01]
    
	# 开环控制
	# true（开环）：控制器直接根据/cmd_vel计算车轮目标值
	# 不反馈实际车轮转速（仿真优先用，因为仿真无打滑 / 电机误差）；
	#false（闭环）：控制器读取车轮实际转速，和目标值对比做 PID 调节
	#（真实机器人优先用，补偿打滑 / 电机误差）。
    open_loop: true
    enable_odom_tf: true # 是否发布odom→base_footprint的TF变换

	# 如果控制器在 0.5 秒内没收到新的/cmd_vel指令，自动停止车轮运动
    cmd_vel_timeout: 0.5
    # 是否发布限速后的实际速度
    #publish_limited_velocity: true
    # 作用：是否使用带时间戳的速度指令
    use_stamped_vel: false
    # 速度平滑窗口大小, 取最近 10 次速度的平均值
    #velocity_rolling_window_size: 10
```

```python
(base) jiao@jiao-virtual-machine:~/ros/dev_ws$ ros2 topic list | grep diff
/fishbot_diff_drive_controller/cmd_vel_unstamped
/fishbot_diff_drive_controller/odom
/fishbot_diff_drive_controller/transition_event
```

**`/odom` 话题** 是机器人**里程计（Odometry）** 数据的主要发布通道。里面记录的信息如下

+ **`stamp`**: 数据发布时间，用于同步和滤波
+ **`frame_id`**：该位姿数据所在的坐标系名称
+ **`child_frame_id`**: 机器人底座坐标系
+ **`position`**: 位置, x, y, z
+ **`orientation`**: 朝向 (orientation), **四元数表示**：`(x, y, z, w)`，避免万向锁问题
+ **`Pose Covariance`**: 位姿协方差, **协方差矩阵是6×6的对称矩阵**，按行优先展开为36个元素的数组

| 索引 | 对应关系                     | 含义           | 当前值 |
| :--- | :--------------------------- | :------------- | :----- |
| 0    | pose.position.x 的方差       | X位置不确定性  | 0.001  |
| 7    | pose.position.y 的方差       | Y位置不确定性  | 0.001  |
| 14   | pose.position.z 的方差       | Z位置不确定性  | 0.0    |
| 21   | orientation.x (roll) 的方差  | 横滚角不确定性 | 0.0    |
| 28   | orientation.y (pitch) 的方差 | 俯仰角不确定性 | 0.0    |
| 35   | orientation.z (yaw) 的方差   | 偏航角不确定性 | 0.01   |

+ **`twist`**: 线速度以及角速度
+ **`Twist Covariance`**: 速度协方差

**`cmd_vel_unstamped`**是一个标准的速度控制的接口

可以重映射一下

```bash
<plugin filename="libgazebo_ros2_control.so" name="gazebo_ros2_control">
    <!-- 参数配置文件 -->
    <parameters>$(find bot_3D_desc)/config/fishbot_ros2_controller.yaml</parameters>
    <ros>
        <remapping>/fishbot_diff_drive_controller/odom:=/odom</remapping>
        <remapping>/fishbot_diff_drive_controller/cmd_vel_unstamped:=/cmd_vel</remapping>
    </ros>
</plugin>
```

之后可以使用之前的命令行控制工具了

```bash
ros2 run teleop_twist_keyboard teleop_twist_keyboard 
```

