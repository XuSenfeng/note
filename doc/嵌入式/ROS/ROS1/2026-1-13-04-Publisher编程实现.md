# Publisher

![image-20260113131637769](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601131316893.png)

## 实现

###创建功能包

```bash
catkin_create_pkg learning_topic roscpp rospy std_msgs geometry_msgs turtlesim
```

### cpp代码

+ 初始化ROS节点
+ 向ROS Master里面注册节点, 包括发布的话题以及消息的类型
+ 创建消息
+ 按照频率发送

```cpp
#include <ros/ros.h>
#include <geometry_msgs/Twist.h>

int main(int argc, char ** argv){
    // 初始化ROS节点
    ros::init(argc, argv, "velocity_publish");

    // 创建节点句柄
    ros::NodeHandle n;

    // 创建一个publisher 发布/turtle1/cmd_vel的topic, 消息类型是geometry_msgs::Twist, 长度为10(缓冲大小)
    // 缓冲区满了的时候默认去除最老的信息
    ros::Publisher turtle_val_pub = n.advertise<geometry_msgs::Twist>("/turtle1/cmd_vel", 10);

    ros::Rate loop_rate(10); // 循环的频率
    int count = 0;
    while(ros::ok()){
        //初始化Twist类型的消息
        geometry_msgs::Twist vel_msg;
        vel_msg.linear.x = 0.5;
        vel_msg.angular.z = 0.2;

        // 发布消息
        turtle_val_pub.publish(vel_msg);
        ROS_INFO("Publish command[%0.2f m/s, %0.2f rad/s]", vel_msg.linear.x, vel_msg.angular.z);
        
        loop_rate.sleep();
    }
    return 0;
}
```

> 1. 单独看`vel_msg.linear.x = 0.5`
>
> 机器人会**以 0.5 米 / 秒的速度沿自身正前方直线前进**（无转向），对应你的玩具机器人：两个驱动电机以相同速度正转，机器人直走，每秒前进 50 厘米。
>
> 2. 单独看`vel_msg.angular.z = 0.2`
>
> 机器人会**原地顺时针旋转**（无前进 / 后退），旋转速度是 0.2 弧度 / 秒。
>
> - 换算成直观的角度：1 弧度≈57.3°，所以 0.2rad/s ≈ 11.46°/ 秒（每秒转约 11.5 度）；
>
> - 旋转方向规则（ROS 右手定则）：右手竖起大拇指指向 Z 轴正方向（垂直地面向上），四指弯曲的方向就是旋转方向 ——
>
>     ```
>     angular.z
>     ```
>
>     为正数是顺时针转，负数是逆时针转。
>
>     对应你的玩具机器人：左侧电机正转、右侧电机反转（或左侧转速快于右侧），机器人在原地慢慢顺时针转，每秒转约 11.5 度。
>
> 3. 两者结合（核心）：`linear.x=0.5 + angular.z=0.2`
>
> 机器人会做 **“前进 + 顺时针转向” 的圆弧运动 **（不是直走，也不是原地转）：
>
> - 整体趋势：一边以 0.5m/s 向前走，一边以 11.5°/ 秒顺时针转向（也就是机器人向前的同时向右拐）；
>
> - 可计算转弯半径（量化理解）：
>
>     转弯半径 线速度角速度米意味着机器人会沿着半径 2.5 米的圆形轨迹，向前 + 顺时针移动（类似汽车打右方向慢速前进的效果）。
>
> 转弯半径 = 线速度 / 角速度
>
> 玩具机器人的实际表现
>
> 你的 3V 13 转的微型电机驱动轮式机器人，收到这个指令后：
>
> - 前进速度：0.5m/s（50cm / 秒），如果电机转速不够，ROS 会按比例调节电机占空比，尽量接近这个速度；
> - 转向效果：每秒向右转约 11.5 度，前进 50 厘米的同时，转向约 11.5 度，整体走一个平缓的右转弯圆弧。
>
> 只发一次指令无法实现持续的前进 + 右转效果，因为 ROS 速度指令是 “瞬时指令”，硬件需要持续信号才能维持运动；
>
> 循环以 10Hz 发布指令，本质是持续 “刷新” 运动指令，告诉机器人 “继续保持当前速度运动”；
>
> 对你的玩具机器人来说，只发一次指令电机只会抖一下，只有循环发布才能看到明显的前进 + 转弯效果。

添加CMake配置

```cmake
add_executable(velocity_publish src/velocity_publisher.cpp)
target_link_libraries(velocity_publish ${catkin_LIBRARIES})
```

编译使用

```bash
catkin_make 
source devel/setup.bash
roscore
rosrun turtlesim turtlesim_node
rosrun learning_topic velocity_publish
```

### python

```python
#!/usr/bin/env python
# -*- coding: utf-8 -*-

########################################################################
####          Copyright 2020 GuYueHome (www.guyuehome.com).          ###
########################################################################

# 该例程将发布turtle1/cmd_vel话题，消息类型geometry_msgs::Twist

import rospy
from geometry_msgs.msg import Twist

def velocity_publisher():
	# ROS节点初始化
    rospy.init_node('velocity_publisher', anonymous=True)

	# 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10
    turtle_vel_pub = rospy.Publisher('/turtle1/cmd_vel', Twist, queue_size=10)

	#设置循环的频率
    rate = rospy.Rate(10) 

    while not rospy.is_shutdown():
		# 初始化geometry_msgs::Twist类型的消息
        vel_msg = Twist()
        vel_msg.linear.x = 0.5
        vel_msg.angular.z = 0.2

		# 发布消息
        turtle_vel_pub.publish(vel_msg)
    	rospy.loginfo("Publsh turtle velocity command[%0.2f m/s, %0.2f rad/s]", 
				vel_msg.linear.x, vel_msg.angular.z)

		# 按照循环频率延时
        rate.sleep()

if __name__ == '__main__':
    try:
        velocity_publisher()
    except rospy.ROSInterruptException:
        pass
```

