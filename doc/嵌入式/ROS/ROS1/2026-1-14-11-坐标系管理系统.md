# 坐标系管理系统

## 坐标系转换

有两个坐标系, 希望知道一个坐标系里面的点另一个坐标系的表示

![image-20260114135749115](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601141357221.png)

![image-20260114140926375](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601141409444.png)

在实际的变化的时候, 首先转轴, 之后进行移轴, 在三维的时候, 旋转的时候是围绕其中一个轴进行旋转, 固定一个轴, 这个时候可以简化为一个二维的坐标轴旋转, 旋转变化实际就是一个旋转矩阵, 二维的旋转矩阵到三维的变化是使三维向量的对应不变的轴只有一个1

公式：![image-20260114141208261](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601141412295.png)

推导背景：笛卡尔坐标的 3 维矢量需要 “旋转矩阵 × 矢量 + 平移矢量” 两步计算，不便工程应用（比如多坐标系串联变换），因此引入**齐次坐标**（将 3 维矢量扩展为 4 维），用一个 4×4 矩阵整合旋转和平移

> 旋转的时候按照逆时针的角是正的

## TF工具包

用于方便计算坐标系相对于全局坐标的位置

<img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601141459859.png" alt="image-20260114145918792" style="zoom:50%;" />

记录十秒钟之内的所有坐标系的关系, 一个点对于不同的坐标系的位置

> 是一个广播监听的机制, 在启动ROS Master+ TF之后, 维护一个TF树, 所有的节点可以查询这个树获取

![image-20260114150236042](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601141502128.png)

### 效果演示

```bash
sudo apt-get install ros-noetic-turtle-tf
# 启动示例脚本
roslaunch turtle_tf turtle_tf_demo.launch
# 控制
rosrun turtlesim turtle_teleop_key
# 查看所有的坐标系关系, 生成一个pdf文件
(base) jiao@jiao:~/JHY/ros/catkin_ws$ rosrun tf view_frames 
WARNING: tf view_frames is deprecated. Use tf2_tools view_frames.py instead.
Listening to /tf for 5.0 seconds
Done Listening
frames.pdf generated
```

实际的效果是一个海龟跟随另一个在移动

![image-20260114151445204](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601141514246.png)

```bash
# 使用命令查看位置变化
(base) jiao@jiao:~/JHY/ros/catkin_ws$ rosrun tf tf_echo turtle1 turtle2
At time 1768375788.341
- Translation: [0.000, 0.000, 0.000]
- Rotation: in Quaternion [0.000, 0.000, 0.885, 0.465]
            in RPY (radian) [0.000, -0.000, 2.173]
            in RPY (degree) [0.000, -0.000, 124.516]
At time 1768375788.996
- Translation: [0.000, 0.000, 0.000]
- Rotation: in Quaternion [0.000, 0.000, 0.885, 0.465]
            in RPY (radian) [0.000, -0.000, 2.173]
            in RPY (degree) [0.000, -0.000, 124.516]
At time 1768375790.005
- Translation: [0.000, 0.000, 0.000]
- Rotation: in Quaternion [0.000, 0.000, 0.885, 0.465]
            in RPY (radian) [0.000, -0.000, 2.173]
            in RPY (degree) [0.000, -0.000, 124.516]
```

+ Translation: 平移
+ Rotation: 角度
+ + Quaternion: 四元数, 3D 旋转的数值稳定表示
    + RPY: 弧度以及角度的显示

> 你之前看到的`RPY (degree) [0.000, -0.000, 124.516]`就是欧拉角（横滚 Roll、俯仰 Pitch、偏航 Yaw），它把 3D 旋转拆成 “绕 x 轴转、绕 y 轴转、绕 z 轴转” 三步，虽然直观，但有致命缺陷：
>
> - **万向锁（Gimbal Lock）**：当俯仰角（Pitch）转到 90° 时，横滚（Roll）和偏航（Yaw）的旋转轴会重合，丢失一个旋转自由度（比如无人机俯仰 90° 后，无法区分横滚和偏航）。
> - 旋转顺序敏感：欧拉角的结果和 “先绕哪个轴转” 强相关（比如先绕 x 再绕 y，和先绕 y 再绕 x 结果不同），容易出错。
>
> 四元数的数学形式是：q=w+xi+yj+zk
>
> 也常写成向量形式（工程中更常用）：q=[w,x,y,z]（注意：不同库可能顺序不同，你看到的`[0.000, 0.000, 0.885, 0.465]`是`[x, y, z, w]`顺序）
>
> 四元数表示的旋转本质是 “**绕x, y, z 3D 轴旋转 w 角度**”（轴 - 角表示法）

可视化

```bash
export LIBGL_ALWAYS_SOFTWARE=1 
rosrun rviz rviz -d `rospack fimd turtle_tf` /
rviz/turtle_rviz.rviz
```

![image-20260114155621506](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601141556575.png)

![image-20260114155722866](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202601141557963.png)

## 代码使用

### 广播位置

```cpp
#include <ros/ros.h>
#include <tf/transform_broadcaster.h>
#include <turtlesim/Pose.h>

std::string turtle_name;

void poseCallback(const turtlesim::PoseConstPtr& msg)
{
	// 创建tf的广播器
	static tf::TransformBroadcaster br;

	// 初始化tf数据, 创建一个广播器
	tf::Transform transform;
	transform.setOrigin( tf::Vector3(msg->x, msg->y, 0.0) ); // 位移
	tf::Quaternion q;
    // 旋转, 这里三个参数是横滚, 俯仰, 偏航, 只设置一下偏航即可
    // 这一步把海龟的 2D 偏航角转换成了 TF 能识别的四元数旋转。
	q.setRPY(0, 0, msg->theta); 
	transform.setRotation(q);

	// 广播world与海龟坐标系之间的tf数据, 设置相对于world, 以及节点的名字
	br.sendTransform(tf::StampedTransform(transform, ros::Time::now(), "world", turtle_name));
}

int main(int argc, char** argv)
{
    // 初始化ROS节点
	ros::init(argc, argv, "my_tf_broadcaster");

	// 输入参数作为海龟的名字
	if (argc != 2)
	{
		ROS_ERROR("need turtle name as argument"); 
		return -1;
	}

	turtle_name = argv[1];

	// 订阅海龟的位姿话题
	ros::NodeHandle node;
	ros::Subscriber sub = node.subscribe(turtle_name+"/pose", 10, &poseCallback);

    // 循环等待回调函数
	ros::spin();

	return 0;
};
```

### 获取相对关系

```cpp
#include <ros/ros.h>
#include <tf/transform_listener.h>
#include <geometry_msgs/Twist.h>
#include <turtlesim/Spawn.h>

int main(int argc, char** argv)
{
	// 初始化ROS节点
	ros::init(argc, argv, "my_tf_listener");

    // 创建节点句柄
	ros::NodeHandle node;

	// 请求产生turtle2
	ros::service::waitForService("/spawn");
	ros::ServiceClient add_turtle = node.serviceClient<turtlesim::Spawn>("/spawn");
	turtlesim::Spawn srv;
	add_turtle.call(srv);

	// 创建发布turtle2速度控制指令的发布者
	ros::Publisher turtle_vel = node.advertise<geometry_msgs::Twist>("/turtle2/cmd_vel", 10);

	// 创建tf的监听器, 用于监听任意坐标系之间的tf数据
	tf::TransformListener listener;

	ros::Rate rate(10.0);
	while (node.ok())
	{
		// 获取turtle1与turtle2坐标系之间的tf数据
		tf::StampedTransform transform;
		try
		{
			// 等待有两个坐标系, 超时3秒
			listener.waitForTransform("/turtle2", "/turtle1", ros::Time(0), ros::Duration(3.0));
			// 获取两个坐标系之间的相对变换关系
			listener.lookupTransform("/turtle2", "/turtle1", ros::Time(0), transform);
		}
		catch (tf::TransformException &ex) 
		{
			ROS_ERROR("%s",ex.what());
			ros::Duration(1.0).sleep();
			continue;
		}

		// 根据turtle1与turtle2坐标系之间的位置关系，发布turtle2的速度控制指令
		// 
		geometry_msgs::Twist vel_msg; // ROS定义的速度消息类型
		// 角速度设置为与目标点的夹角的4倍
		// 线速度设置为与目标点距离的0.5倍
		// 这样可以让turtle2快速地转向turtle1，并且接近turtle1
		// atan2(y, x)：数学中的反正切函数，作用是计算 “从 x 轴正方向到点 (x,y) 
		// 的夹角”（单位：弧度），这个夹角就是turtle2需要旋转的角度
		vel_msg.angular.z = 4.0 * atan2(transform.getOrigin().y(),
				                        transform.getOrigin().x());
		vel_msg.linear.x = 0.5 * sqrt(pow(transform.getOrigin().x(), 2) +
				                      pow(transform.getOrigin().y(), 2));
		turtle_vel.publish(vel_msg);

		rate.sleep();
	}
	return 0;
};
```

测试命令

```bash
# 启动两个汇报, 为避免名字一样, 需要单独设置一下
rosrun learning_tf turtle_tf_broadcaster __name:=turtle1_tf_broadcaster /turtle1 &
rosrun learning_tf turtle_tf_broadcaster __name:=turtle2_tf_broadcaster /turtle2 &
# 启动一个监听
rosrun learning_tf turtle_tf_listener  &
rosrun turtlesim turtle_teleop_key 
```

### python版本

```python
import roslib
roslib.load_manifest('learning_tf')
import rospy

import tf
import turtlesim.msg

def handle_turtle_pose(msg, turtlename):
    br = tf.TransformBroadcaster()
    br.sendTransform((msg.x, msg.y, 0),
                     tf.transformations.quaternion_from_euler(0, 0, msg.theta),
                     rospy.Time.now(),
                     turtlename,
                     "world")

if __name__ == '__main__':
    rospy.init_node('turtle_tf_broadcaster')
    # 获取一个局部的变量, 名字是turtle, 在命令行里面设置
    turtlename = rospy.get_param('~turtle')
    rospy.Subscriber('/%s/pose' % turtlename,
                     turtlesim.msg.Pose,
                     handle_turtle_pose,
                     turtlename)
    rospy.spin()
```

```python
import roslib
roslib.load_manifest('learning_tf')
import rospy
import math
import tf
import geometry_msgs.msg
import turtlesim.srv

if __name__ == '__main__':
    rospy.init_node('turtle_tf_listener')

    listener = tf.TransformListener()
	# 监听一下创建海龟的server
    rospy.wait_for_service('spawn')
    spawner = rospy.ServiceProxy('spawn', turtlesim.srv.Spawn)
    spawner(4, 2, 0, 'turtle2')
	# 创建一个发布位置信息的
    turtle_vel = rospy.Publisher('turtle2/cmd_vel', geometry_msgs.msg.Twist,queue_size=1)

    rate = rospy.Rate(10.0)
    while not rospy.is_shutdown():
        try:
            # 查询当前的坐标位置关系
            (trans,rot) = listener.lookupTransform('/turtle2', '/turtle1', rospy.Time(0))
        except (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException):
            continue
		# 计算一下实际的速去
        angular = 4 * math.atan2(trans[1], trans[0])
        linear = 0.5 * math.sqrt(trans[0] ** 2 + trans[1] ** 2)
        cmd = geometry_msgs.msg.Twist()
        cmd.linear.x = linear
        cmd.angular.z = angular
        turtle_vel.publish(cmd)

        rate.sleep()
```

运行

```bash
python src/learning_tf/scripts/turtle_tf_broadcaster.py __name:=turtle_follower_2 _turtle:=turtle2 &
python src/learning_tf/scripts/turtle_tf_broadcaster.py __name:=turtle_follower_1 _turtle:=turtle1 &
python src/learning_tf/scripts/turtle_tf_listener.py 
rosrun turtlesim turtlesim_node &
python src/learning_tf/scripts/turtle_tf_listener.py 
```

### launch文件

```xml
<launch>

    <!-- Turtlesim Node-->
    <node pkg="turtlesim" type="turtlesim_node" name="sim"/>
    <node pkg="turtlesim" type="turtle_teleop_key" name="teleop" output="screen"/>

    <node pkg="learning_tf" type="turtle_tf_broadcaster" args="/turtle1" name="turtle1_tf_broadcaster" />
    <node pkg="learning_tf" type="turtle_tf_broadcaster" args="/turtle2" name="turtle2_tf_broadcaster" />

    <node pkg="learning_tf" type="turtle_tf_listener" name="listener" />

</launch>
```

