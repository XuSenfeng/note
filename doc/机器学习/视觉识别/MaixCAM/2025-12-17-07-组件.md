# 组件

## 自定义组件

组件：每个功能模块可以封装成一个组件，方便不同应用选择性地使用。

-   可以看到[examples/hello_world](https://vscode-remote+ssh-002dremote-002borb.vscode-resource.vscode-cdn.net/home/jiao/Maix/MaixCDK/docs/doc_zh/convention/examples/hello_world)中有个`main`组件，[components](https://vscode-remote+ssh-002dremote-002borb.vscode-resource.vscode-cdn.net/home/jiao/Maix/MaixCDK/docs/doc_zh/convention/components)中有很多组件，还可以自己添加组件，比如`hello_world/component1`或者`hello_world/compoents/component2`。
-   也可以设置环境变量`MAIXCDK_EXTRA_COMPONENTS_PATH`来指定其它额外的组件库。
-   每个组件包含一个`CMakeLists.txt`来描述组件内容，比如`list(APPEND ADD_INCLUDE "include")`来指定包含的头文件路径，`list(APPEND ADD_SRCS "src/hello.c")`来包含源文件，`list(APPEND ADD_REQUIREMENTS basic)`来依赖其它组件等。
-   另外，默认也会到 python `site-packages` 目录寻找，也就是说，如果你了解 python 库打包，你的组件包可以直接发布到 [pypi.org](https://pypi.org/), 这样用户通过`pip install maixcdk-xxx` 就可以快速安装你的组件包了！ 可以参考[examples/maixcdk-example](https://github.com/sipeed/MaixCDK/blob/main//examples/maixcdk-example)组件。

### 添加python组件

这里安装的是[examples/maixcdk-example](https://github.com/sipeed/MaixCDK/blob/main//examples/maixcdk-example)这个组件, 组件里面的CMake文件里面只有三行

```cmake
list(APPEND ADD_INCLUDE "include")
append_srcs_dir(ADD_SRCS "src")     # append source file in src dir to var ADD_SRCS
register_component()
```

```bash
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple maixcdk-example
```

安装以后可以在CMakelist.txt文件里面

```cmake
list(APPEND ADD_REQUIREMENTS basic maixcdk-example)
```

之后就可以引用头文件以及

## CMake文件

`register_component()` 宏 + 若干 Python 脚本」来自动发现、配置、筛选、排序并链接组件的。

**1. 组件的判定与发现**

-   判定一个目录是不是组件用`is_path_component()`
    -   必须是目录
    -   不能是隐藏目录（名字不以 `.` 开头）
    -   必须有 `CMakeLists.txt`
    -   `CMakeLists.txt` 里要包含字符串 `register_component`
-   扫描函数`find_components()`会在指定目录模式（比如${SDK_PATH}/components/*）下调用`is_path_component`，把符合条件的目录加入`components_dirs`，并顺带记录：
    -   若有 [Kconfig](vscode-file://vscode-app/Applications/Visual Studio Code.app/Contents/Resources/app/out/vs/code/electron-browser/workbench/workbench.html) 就记到 `components_kconfig_files`
    -   若有 `config_defaults.mk` 就记到 `kconfig_defaults_files_args`
    -   若目录名为 `main` 就标记 `found_main=1`
-   在`project(name)`宏里，依次调用find_components()扫描这些位置：
    -   `${SDK_PATH}/components/*`、`3rd_party/*`、`ext_devs/*`、`algo/*`
    -   `MAIXCDK_EXTRA_COMPONENTS_PATH`、`PY_PKG_COMPONENTS_PATH`、`PY_USR_PKG_COMPONENTS_PATH`
    -   `${PROJECT_SOURCE_DIR}/../components/*`
    -   `${PROJECT_SOURCE_DIR}/*` 和 `${PROJECT_SOURCE_DIR}/components/*`
-   如果最终没有发现名为 `main` 的组件目录，则直接 `FATAL_ERROR`。

**2. 组件内部如何注册 (`register_component`)**

每个组件自己的 `CMakeLists.txt` 最终会调用 `register_component()`，前面通常会设置一些变量，比如 `ADD_SRCS`、`ADD_INCLUDE` 等（这些在别处定义约定）：

-   根据参数是否包含DYNAMIC/SHARED 判断该组件生成动态库还是静态库：
    -   `add_library(${component_name} SHARED/STATIC ...)` 或 `INTERFACE`
    -   同时把库路径记录到全局缓存变量 `g_dynamic_libs` 等
-   处理源文件与包含路径：
    -   把 `ADD_SRCS` 转成绝对路径，并记录到 `g_srcs` 里（格式 `component+abs_path`）
    -   把 `ADD_INCLUDE`/`ADD_PRIVATE_INCLUDE` 目录加入 `target_include_directories`
    -   所有公共包含路径也同步记录进 `g_includes`
-   处理编译 / 链接选项和库路径：
    -   `ADD_DEFINITIONS*`、`ADD_LINK_DEFINITIONS*` -> 分别加到 `target_compile_options` / `target_link_options`
    -   `ADD_LINK_SEARCH_PATH` -> 校验存在性，转绝对路径，写入 `g_link_search_path`
    -   `ADD_STATIC_LIB`、`ADD_DYNAMIC_LIB` -> 做路径检查，必要时转绝对路径，然后 `target_link_libraries`，动态库信息也加入 `g_dynamic_libs`
    -   `ADD_DIST_LIB_IGNORE` -> 写入 `g_dist_ignore_libs`，后面会从 `g_dynamic_libs` 中剔除这些
-   组件依赖管理：
    -   调用 Python：`build.py get_requirements ... ${component_name} ${component_dir} ...`
        从该组件的 `component.py` 等信息里算出它依赖的其他组件名列表 `component_requires`
    -   把这些依赖加入 `ADD_REQUIREMENTS`，并 `target_link_libraries(${component_name} ${include_type} ${ADD_REQUIREMENTS})`
    -   调用 `components_depends.py append`，把「当前组件 -> 依赖组件列表」写入 `${CMAKE_BINARY_DIR}/config/components_depends.json`

**3. 启用 / 禁用组件与依赖裁剪**

在 `project(name)` 宏中，发现组件之后，会做几件关键事：

-   清空旧的依赖信息：
    `components_depends.py clear ${CMAKE_BINARY_DIR}/config/components_depends.json`
-   根据 Kconfig / 配置推断「允许使用的组件」：
    -   调用 `build.py get_valid_components ...` 得到 `component_valid`（只是“可用”的候选组件名列表）
-   排序组件：
    -   通过 `sort_components.py` 结合 `priority.conf` 进行排序，得到 `component_dirs_sorted`
-   实际添加子目录：
    -   对每个component_dir
        -   取目录名 `base_dir`，看是否在 `component_valid` 中
        -   在的话 `add_subdirectory(component_dir base_dir EXCLUDE_FROM_ALL)`，里面就会执行该组件的 `CMakeLists` 并调用 `register_component`
        -   若生成了目标 `TARGET base_dir`，则 `add_dependencies(base_dir update_build_info)`

然后根据 `components_depends.json` 再做「以 main 为根的依赖裁剪」：

-   `components_depends.py get ... main` 得到 `main` 依赖的所有组件列表 `main_depends`
-   `g_enabled_components = main_depends + main`
-   `update_global_var(var_name)` 函数会扫描之前累积的全局变量（例如 `g_includes`, `g_srcs`, `g_dynamic_libs`, `g_link_search_path` 等），把不在 `g_enabled_components` 中的条目全部过滤掉，只保留真正会参与 `main` 最终链接的组件相关信息。
-   再把 `g_dist_ignore_libs` 中的库从 `g_dynamic_libs` 里删除，确保某些库不会被打包/分发。

**4. 全局信息保存与最终链接**

-   调用 `save_global_vars.py` 把上述全局信息写进 `cmake_global_vars.json`，供工具链（包括文档生成等）使用。
-   根据 `g_link_search_path` 把库搜索路径和 `rpath` 加到 `CMAKE_C_LINK_FLAGS` / `CMAKE_CXX_LINK_FLAGS`。
-   为可执行程序创建一个占位源码exe_src.c使用add_executable(${name} exe_src)
    -   `target_link_libraries(${name} main)`，`main` 本身是一个组件库，定义应用入口。
-   最后再根据 `gen_binary.cmake` 生成打包镜像 / bin 文件等。

>   由于这个文件只是一个空文件, 所以在实际运行的时候会去查找到main模块里面的main函数

**可以简单理解为：**

1.  按目录约定自动发现所有组件目录。
2.  每个组件通过 `register_component()` 把自己的源文件、头文件、编译选项、静态/动态库和“组件依赖”注册到全局。
3.  通过 Python 脚本和 `component.py`、[Kconfig](vscode-file://vscode-app/Applications/Visual Studio Code.app/Contents/Resources/app/out/vs/code/electron-browser/workbench/workbench.html) 配置，先筛出“候选可用组件”，再以 `main` 为根做依赖闭包，只启用这条依赖链上的组件。
4.  只对启用的组件汇总 include、src、库路径等，全局存成 JSON，再用于链接最终可执行程序和生成文档/打包。
