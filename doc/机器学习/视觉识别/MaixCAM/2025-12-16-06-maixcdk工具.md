# Maixcdk工具

https://github.com/Neutree/c_cpp_project_framework使用的是这个基础框架封装

>   整个工作流程可以理解成：
>
>   -   `maixcdk build` 先用 Python 脚本生成这个极简的 `CMakeLists.txt`。
>
>   -   然后在build目录里调用
>
>       ```
>       cmake 参数 ..
>       ```
>
>       -   CMake 读到这个 `CMakeLists.txt`；
>       -   通过 `include(${SDK_PATH}/tools/cmake/compile.cmake)` 把 MaixCDK 的通用构建逻辑拉进来；
>       -   利用传入的 `PROJECT_PATH`、`PLATFORM`、组件 CMakeLists 等，生成完整的 Makefile。
>
>   -   再用 `cmake --build .` 真正去编译。

`tools/maixtool/maixtool/maixcdk.py`

这个文件实际的工作是查找一下CDK的根目录, 之后添加`tools/cmake`目录到搜索路径, 然后调用`/tools/cmake/project.py`里面的main函数, 参数是CDK的路径以及当前的路径

```python
def exec_project_py():
    # 1. get MaixCDK path
    sdk_path = get_sdk_path()
    print("-- SDK_PATH:{}".format(sdk_path))
    project_path = os.path.abspath(".")

    # 2. execute project script from SDK
    project_file_path = sdk_path+"/tools/cmake/project.py"
    sys.path.insert(0, os.path.dirname(project_file_path))
    from project import main
    main(sdk_path, project_path)
```

## project.py

### get_extra_cmds

从`tools/cmds`文件夹里面获取到所有有`parser`参数的工具

```python
def get_extra_cmds(sdk_path) -> tuple:
    '''
        return extra_tools
        {
            "run":
            {
                "obj": tool_object,
                "cmd": cmd,
                "parser": arg_parser
            }
        }
    '''
    # find extra tools
    tools_dir = os.path.join(sdk_path, "tools", "cmds")
    sys.path.insert(1, tools_dir)
    # find all .py files in tools dir
    extra_tools_names = []
    extra_tools = {}
    for name in os.listdir(tools_dir):
        if name.endswith(".py"):
            extra_tools_names.append(name[:-3])
    # import all tools
    for name in extra_tools_names:
        # import from tool file
        tool = __import__(name)
        if hasattr(tool, "parser"):
            extra_tools[tool.__name__] = {
                "obj": tool,
                "cmd": tool.parser.prog,
                "parser": tool.parser
            }
    return extra_tools
```

### parse_args参数解析器

```python
def parse_args(sdk_path, project_path, extra_tools):
  	# 创建一个project.py的解释器
    parser = argparse.ArgumentParser(description='build tool, e.g. `python project.py build`', prog="project.py")
    # 添加一个子解释器用于处理不同的命令, 比如build, clean等
    # 解析以后使用args.cmd获取使用的参数
    subparsers = parser.add_subparsers(help='command help', dest="cmd")
    # 为之前的额外的命令创建解释器
    for k,v in extra_tools.items():
        sub_parser = v["parser"]
        subparsers.add_parser(sub_parser.prog, parents=[sub_parser], help=sub_parser.description)

    # cmd build 添加build以及
    parser_build = subparsers.add_parser("build", help="start compile project, temp files in `build` dir, dist files in `dist` dir, build command by default always execute cmake to regenerate, to disable file change scan (cmake execute), use build2 command or add --no-gen option to only compile changed files, warning build2 will not detect file additions and deletions")
    parser_build2 = subparsers.add_parser("build2", help="same as `maixcdk build --no-gen`, compile project, not scan files additions and deletions, only compile changed files, so build faster but be attention you should use build again if you add new file or delete files")
    parser_build.add_argument("--no-gen", action="store_true", default=False, help="same as command build2, by default the build command do the same action as rebuild to avoid user can't understand rebuild, but if you don't want to re-execute cmake command, and only compile, use this option")
    # 这两个build都有的参数
    def add_build_args(parser_):
        parser_.add_argument('--config-file',
                                help='config file path, e.g. config_defaults.mk',
                                metavar='PATH',
                                default="{}/config_defaults.mk".format(project_path))
        parser_.add_argument('--verbose',
                                help='for build command, execute `cmake -build . --verbose` to compile',
                                action="store_true",
                                default=False)
        parser_.add_argument('-G', '--generator', default="", help="project type to generate, supported type on your platform see `cmake --help`")
        parser_.add_argument('--release', action="store_true", default=False, help="release mode, default is release mode")
        parser_.add_argument('--debug', action="store_true", default=False, help="debug mode, default is release mode")
        parser_.add_argument('--build-type', default=None, help="build type, [Debug, Release, MinRelSize, RelWithDebInfo], you can also set build type by CMAKE_BUILD_TYPE environment variable")
        parser_.add_argument('-p', "--platform", default="", help="device name, e.g. linux, maixcam, m2dock", choices=get_platforms(sdk_path))
        parser_.add_argument('--toolchain-id', default="", help="toolchain id, if platform has multiple toolchains, use this option to select one. Empty will let you select one interactively, 'default' means use the default toolchain defined in platform yaml file.")
    add_build_args(parser_build)
    add_build_args(parser_build2)

    # cmd menuconfig配置命令的解析参数添加
    parser_menuconfig = subparsers.add_parser("menuconfig", help="open menuconfig panel, a visual config panel")
    parser_menuconfig.add_argument('--config-file',
                            help='config file path, e.g. config_defaults.mk',
                            metavar='PATH',
                            default="{}/config_defaults.mk".format(project_path))
    parser_menuconfig.add_argument('-p', "--platform", default="", help="device name, e.g. linux, maixcam, m2dock", choices=get_platforms(sdk_path))

    # cmd clean
    subparsers.add_parser("clean", help="clean build files, won't clean configuration")

    # cmd distclean
    subparsers.add_parser("distclean", help="clean all generated files, including build files and configuration")
		# 实际的解析命令, 可以使用cmds.对应的名字获取实际的读取参数
    args = parser.parse_args()
    return args, parser
```

### 配置文件处理

在build/config/project_vars.json可以找到使用的配置文件, 里面记录了编译模式之类的信息

```json
{
    "PROJECT_ID": "hello_world",
    "SDK_PATH": "/home/jiao/Maix/MaixCDK",
    "PROJECT_PATH": "/home/jiao/Maix/MaixCDK/examples/hello_world",
    "MAIXCDK_EXTRA_COMPONENTS_PATH": "",
    "PY_PKG_COMPONENTS_PATH": "/home/jiao/miniconda3/envs/maix/lib/python3.11/site-packages",
    "PY_USR_PKG_COMPONENTS_PATH": "",
    "CMAKE_BUILD_TYPE": "MinSizeRel",
    "BUILD_TYPE": "Release",
    "PLATFORM": "linux",
    "CMAKE_GENERATOR": "Unix Makefiles",
    "TOOLCHAIN_ID": "",
    "DEFAULT_CONFIG_FILE": "",
    "PLATFORM_LINUX": 1
}
```

同时根据用户传入的信息生成一部分每次编译都要重新生成的配置信息

### 生成CMakeList.txt文件

在`check_project_cmakelists`函数里面查看文件目录下面的CMakeList.txt是不是存在

### 查找编译使用的工具

之后从`platforms/maixcam.yaml`查找实际使用的编译的配置

```yaml
toolchain:
  - name: MUSL toolchain optimize by t-head
    id: musl_t-head
    default: true
    url: https://github.com/sipeed/MaixCDK/releases/download/v0.0.0/host-tools-2025.7.28.tar.xz
    urls:
      - https://sophon-file.sophon.cn/sophon-prod-s3/drive/23/03/07/16/host-tools.tar.gz # old version
    sites:
      - https://github.com/sophgo/cvi_mmf_sdk
    sha256sum: 968b179a7faebfe8914e5163b2d85038b71824780fccde0b4b3ee9f67472d007
    filename: host-tools-2025.7.28.tar.xz
    path: toolchains/maixcam
    bin_path: toolchains/maixcam/host-tools/gcc/riscv64-linux-musl-x86_64/bin
    prefix: riscv64-unknown-linux-musl-
    c_flags: -mcpu=c906fdv -march=rv64imafdcv0p7xthead -mcmodel=medany -mabi=lp64d
    cxx_flags: -mcpu=c906fdv -march=rv64imafdcv0p7xthead -mcmodel=medany -mabi=lp64d
```

调用`tools/cmake/check_toolchain.py`文件里面的main函数

更具这个配置最后生成的配置文件`build/config/toolchain_config.cmake`

```cmake
set(CONFIG_TOOLCHAIN_PATH "/home/jiao/Maix/MaixCDK/dl/extracted/toolchains/maixcam/host-tools/gcc/riscv64-linux-musl-x86_64/bin")
set(CONFIG_TOOLCHAIN_PREFIX "riscv64-unknown-linux-musl-")
```

## 实际的编译

编译调用的是`tools/cmake/build.py`文件里面的rebuild函数

### get_all_components_dl_info

>   进行对依赖的组件进行下载

CDK里面的component配置实际是一个Cmake文件以及一个component.py的python文件, 里面记录下载这个组件使用的信息

使用get_components_files获取到所有的component.py里面记录的下载函数, 最后使用函数`download_extract_files`进行下载

```python
    '''
        @param confs kconfig vars, dict type
        @return list type, items is dict type
    '''
    version = "3.11.3"
    url = f"https://github.com/nlohmann/json/releases/download/v3.11.3/json.tar.xz"
    if version == "3.11.3":
        sha256sum = "d6c65aca6b1ed68e7a182f4757257b107ae403032760ed6ef121c9d55e81757d"
    else:
        raise Exception(f"version {version} not support")
    sites = ["https://github.com/nlohmann/json"]
    filename = f"json.tar.xz"
    path = f"json_srcs"
    check_file = 'json'
    rename = {
        f'json': 'json'
    }

    return [
        {
            'url': f'{url}',
            'urls': [],
            'sites': sites,
            'sha256sum': sha256sum,
            'filename': filename,
            'path': path,
            'check_files': [
                check_file
            ],
            'rename': rename
        }
    ]
```

下载的压缩包在`dl/pkgs/json_srcs`解压以后的文件在`dl/extracted/json_srcs/json`

#### find_valid_components

从所有能找到的组件里，只保留 `main` 以及被 `main` 直接或间接依赖到的那些组件

首先使用所有可以找到的组件构建一个依赖的表(从他们的component.py或CMakeList.txt文件里面查找依赖), 之后使用这个依赖的表实现, 由于这个表里面没有系统库, 所以只是检索已经有配置文件的组件

>   每次编译时会将所有需要下载的文件列表写入到`dl/pkgs_info.json`，用户有网速问题的可以到官方 QQ 群或者第三方提供的网盘手动下载放到`dl/pkgs`目录即可

```
main -> 
  basic ->
  	ini
  	yaml
  	ntp_client
```

#### 运行cmake命令

```bash
cmake -G Unix Makefiles -DPROJECT_ID=hello_world -DSDK_PATH=/home/jiao/Maix/MaixCDK -DPROJECT_PATH=/home/jiao/Maix/MaixCDK/examples/hello_world -DMAIXCDK_EXTRA_COMPONENTS_PATH= -DPY_PKG_COMPONENTS_PATH=/home/jiao/miniconda3/envs/maix/lib/python3.11/site-packages -DPY_USR_PKG_COMPONENTS_PATH= -DCMAKE_BUILD_TYPE=MinSizeRel -DBUILD_TYPE=Release -DPLATFORM=maixcam -DCMAKE_GENERATOR=Unix Makefiles -DTOOLCHAIN_ID=musl_t-head -DDEFAULT_CONFIG_FILE= -DPLATFORM_MAIXCAM=1 -DCMAKE_C_FLAGS=-mcpu=c906fdv -march=rv64imafdcv0p7xthead -mcmodel=medany -mabi=lp64d -DCMAKE_CXX_FLAGS=-mcpu=c906fdv -march=rv64imafdcv0p7xthead -mcmodel=medany -mabi=lp64d -DCMAKE_EXE_LINKER_FLAGS= -DCMAKE_C_LINK_FLAGS= -DCMAKE_CXX_LINK_FLAGS= ..
```

在当前 `build` 目录里，按指定参数为 `hello_world` 生成 Unix Makefiles 的工程，然后后续用 `cmake --build .` 真正编译

**把 “hello_world + MaixCDK + maixcam 平台 + 指定 toolchain/CPU 参数” 这一整套信息告诉 CMake，让它生成后续 `make` 要用的 Makefile**

#### build

```python
def build(build_path, configs, toolchain_info, verbose):
    if not os.path.exists(build_path):
        rebuild(build_path, configs, toolchain_info, verbose)
        return
    os.chdir(build_path)
    # 查看是不是使用详细输出
    if verbose:
        if configs["CMAKE_GENERATOR"] == "Unix Makefiles":
            res = subprocess.call(["cmake", "--build", ".", "--target", "all", "--", "VERBOSE=1"])
        elif configs["CMAKE_GENERATOR"] == "Ninja":
            res = subprocess.call(["cmake", "--build", ".", "--target", "all", "--", "-v"])
        else:
            res = subprocess.call(["cmake", "--build", ".", "--target", "all"])
    else:
      	# 实际运行的
        if configs["CMAKE_GENERATOR"] in ["Unix Makefiles", "Ninja"]:
            res = subprocess.call(["cmake", "--build", ".", "--target", "all", "--", "-j{}".format(thread_num)])
        else:
            res = subprocess.call(["cmake", "--build", ".", "--target", "all"])
    if res != 0:
        exit(1)
```

## CMake文件

```cmake
# !!! This file is auto generated by MaixCDK, don't modify it manually !!!

cmake_minimum_required(VERSION 3.13)
# 我自己加的
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
# cmake used vars defined in MaixCDK/tools/cmake/project.py's get_configs function

include(${SDK_PATH}/tools/cmake/compile.cmake)
project(${PROJECT_ID})
```

-   CMake 会去包含 `MaixCDK/tools/cmake/compile.cmake`。
-   这个脚本里完成了所有“真正的活”：
    -   读取 `build/config/global_config.cmake` 和 Kconfig 生成的各种配置；
    -   根据 `PROJECT_PATH` / `PLATFORM` 等变量扫描组件目录；
    -   处理各 `components/**/CMakeLists.txt` 里的 `ADD_SRCS` / `ADD_REQUIREMENTS` 等；
    -   定义目标（可执行文件 / 库）、添加 include 路径、编译选项、链接系统库等。

`project(${PROJECT_ID})`

-   `PROJECT_ID` 同样来自命令行：`-DPROJECT_ID=hello_world`。
-   这里告诉 CMake：当前工程名就叫 `hello_world`。
-   后续 `compile.cmake` 会用这个名字来给 target 命名、生成输出文件名等。

