---
layout: post
title: "stm32寄存器映射(GPIO实现)" 
date:   2022-8-23 15:39:08 +0800
tags: stm32
---

# GPIO

具体的每一个GPIO的数据, 以及功能查看数据手册, 第三章

![QQ图片20230119230334](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1082/202301192304821.png)

保护二极管: 保护的作用有限, 不能直接连接电机, 不能连接超过过大的电压, 链接电机需要专门的隔离模块

推挽输出: 对应的寄存器, 端口控制高(低)寄存器, 最大25mA, 用的最多![QQ图片20230119231038](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1082/202301192310164.png)

开漏输出: 只能输出低电平, 可以用于输出电压比较高的电压

![Screenshot_20230119_231427](https://xingqiu-tuchuang-1256524210.cos.ap-shanghai.myqcloud.com/1082/202301192315465.jpg)

输出数据寄存器: GPIO_ODR, 低十六位控制输出的电压的高低

位设置/位清除寄存器: GPIO_BSRR最后写入的还是ODR, 低十六位设置为1把ODR对应的位设置为1, 高十六位设置为1把对应的未进行清除, 同时设置的时候设置为0

端口位清除寄存器, 低十六位有效, 设置的时候相当于BSRR的高十六位

复用功能输出: 输出的数据来自其他的外设

输入数据寄存器: GPIO_IDR, 低十六位有效

上拉输入, 下拉输入: 配置的时候只用一个位, 实际上配置的是BSRR, 设置的软件的配置

肖特基触发器: 起到一门禁的功能, 高于2.8V为1, 低于1.2V的时候位0

## 实际使用

### 方法一

根据总线的基地址, 加上偏移得到实际的位置

+   头文件

```c
//用来进行存放寄存器映射的头文件

#define PERIPH_BASE				((unsigned int )0x40000000)
//总线
#define APB1_PERIPH_BASE		(PERIPH_BASE)
#define APB2_PERIPH_BASE		(PERIPH_BASE + 0x10000)
#define AHB_PERIPH_BASE			(PERIPH_BASE + 0x20000)

//实际的外设基地址

#define RCC_BASE 				(AHB_PERIPH_BASE + 0x1000)
#define GPIO2_BASE 				(APB2_PERIPH_BASE + 0x0c00)

//实际的寄存器
#define RCC_APB2_ENR 			*(unsigned int *)(RCC_BASE + 0x18)
#define GPIOB_CRL	 			*(unsigned int *)(GPIO2_BASE + 0x00)
#define GPIOB_CRH	 			*(unsigned int *)(GPIO2_BASE + 0x04)
#define GPIOB_ODR	 			*(unsigned int *)(GPIO2_BASE + 0x0c)
```

+   main函数

```c
int main(void)
{
	//设置时钟
	RCC_APB2_ENR |= ((1)<<3);
	//配置IO的模式, 设置为推挽输出
	GPIOB_CRL |= ((1)<<(0*4));
	//控制ODR
	GPIOB_ODR &= ~(1<<0);
	return 0;
}
```

### 方法二

使用结构体

```c
typedef struct {
	uint32_t CRL;			//模式控制
	uint32_t CRH;
	uint32_t IDR;			//读取状态
	uint32_t ODR;			//设置状态
	uint32_t BSRR;			//设置状态
	uint32_t BRR;			//设置状态
	uint32_t LCKR;			//锁

}GPIO_TypeDef;


#define GPIOB ((GPIO_TypeDef*)GPIO2_BASE)
```

```c
int main(void)
{
	//设置时钟
	RCC_APB2_ENR |= ((1)<<3);
	//配置IO的模式, 设置为推挽输出

	GPIOB->CRL &= ((0x0f)<<(0*4));
	GPIOB->CRL |= ((1)<<(0*4));
	GPIOB->ODR &= ~(1<<0);
	return 0;
}
```













