---
layout: post
title: "存储器" 
date:   2024-1-16 15:39:08 +0800
tags: Cotex-M3
---

# 存储器

## 映射

CM3的存储器只有一个单一的映射, 比如说NVIC和MPU都只有特定的位置, 方便移植

CM3有4GB的地址映射, 应用可以在内部SRAM, 外部SRAM以及代码区执行

![image-20240117144307309](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202401171443384.png)

+ 系统控制空间

![image-20240117144711075](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202401171447106.png)

+ AHB私有外设总线，只用于CM3内部的AHB外设，它们是：NVIC, FPB, DWT和ITM。
+ APB私有外设总线，既用于CM3内部的APB设备，也用于外部设备（这里的“外部”是对内核而言）。CM3允许器件制造商再添加一些片上APB外设到APB私有总线上，它们通过APB接口来访问

## 各内存属性

+ 可否缓冲
+ 可否缓存
+ 可否执行
+ 可否共享

> 使用MPU的时候可以分开配置不同位置的属性

1. 代码区（0x0000_0000- 0x1FFF_FFFF）。该区是可以执行指令的，缓存属性为WT（“写通”，Write Through），即不可以缓存。此区亦允许布设数据存储器。在此区上的数据操作是通过数据总线接口的（估计读数据使用D-Code，写数据使用System），且在此区上的写操作是缓冲的
2. SRAM区（0x2000_0000 – 0x3FFF_FFFF）。此区用于片内SRAM，写操作是缓冲的，并且可以选择WB -WA(Write Back, Write Allocated)缓存属性。此区亦可以执行指令，以允许把代码拷贝到内存中执行——常用于固件升级等维护工作。
3. 片上外设区(0x4000_0000 – 0x5FFF_FFFF)。该区用于片上外设，因此是不可缓存的，也不可以在此区执行指令（这也称为eXecute Never, XN。ARM的参考手册大量使用此术语）。
4. 外部RAM区的前半段（0x6000_0000 - 0x7FFF_FFFF）。该区可用于布设片上RAM或片外RAM，可缓存（缓存属性为WB -WA），并且可以执行指令。
5. 外部RAM区的后半段（0x8000_0000 – 0x9FFF_FFFF）。除了不可缓存(WT)外，同前半段。
6. 外部外设区的前半段(0xA000_0000 – 0xBFFF_FFFF)。用于片外外设的寄存器，也用于多核系统中的共享内存（需要严格按顺序操作，即不可缓冲）。该区也是个不可执行区。
7. 外部外设区的后半段(0xC000_0000 – 0xDFFF_FFFF)。目前与前半段的功能完全一致。
8. 系统区(0xE000_0000 – 0xFFFF_FFFF)。此区是私有外设和供应商指定功能区。此区不可执行代码。系统区涉及到很多关键部位，因此访问都是严格序列化的（不可缓存，不可缓冲）。而供应商指定功能区则是可以缓存和缓冲的。

![image-20240117145656757](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202401171456798.png)

> 1. 内存缓冲： 内存缓冲是指计算机中的一块高速内存，用于临时存储从较慢的存储设备（如硬盘或网络）读取的数据，以便提高数据访问的速度。它通常用在输入/输出操作中，可以减少对慢速设备的频繁访问。
> 2. 缓存： 缓存是指存储在计算机内存或者其他高速存储设备中的数据副本，以便快速访问和提高数据访问的性能。缓存可以用来存储经常访问或计算得到的数据，避免重复计算或频繁访问慢速存储设备。

## 默认许可

![image-20240117150032336](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202401171500386.png)

![image-20240117150050974](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202401171500012.png)

## 位带操作

### 实际映射

可以使用普通的加载/存储指令来对单一的比特进行读写

其中一个是SRAM区的最低1MB范围，第二个则是片内外设区的最低1MB范围。

![image-20240117150334038](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202401171503073.png)

![image-20240117150349646](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202401171503692.png)

![image-20240117150450654](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202401171504684.png)

![image-20240117151031728](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202401171510754.png)

### 使用优势

对于硬件I/O密集型的底层程序最有用

还可以简化比较某一位的跳转指令

在多任务的情况下, 实现访问任务的原子性(读-改-写=>写)

![image-20240117151610290](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202401171516336.png)

> 位带操作并不只限于以字为单位的传送。亦可以按半字和字节为单位传送, 但是不管用哪一个对子，都必须保证目标地址对齐到字的边界上

```c
#define BITBAND(addr,  bitnum)  ((addr & 0xF0000000)+0x2000000+((addr & 0xFFFFF)<<5)+(bitnum<<2)) //把该地址转换成一个指针
#define MEM_ADDR(addr) *((volatile unsigned long *) (adr))
```

> 当使用位带功能时，要访问的变量必须用volatile来定义。因为C编译器并不知道同一个比特可以有两个地址。所以就要通过volatile，使得编译器每次都如实地把新数值写入存储器，而不再会出于优化的考虑，在中途使用寄存器来操作数据的复本，直到最后才把复本写回——这会导致按不同的方式访问同一个位会得到不一致的结果

```c
volatile unsigned long bbVarAry[7] __attribute__(( at(0x20003014) ));
volatile unsigned long* const pbbaVar= (void*)(0x22000000+0x3014*8*4);

pbbaVar[136]=1;     //置位第136号比特
```

> 不直接定义pbbaVer为一个大数组是应为这样这个数组会被记录到应用的大小里面

## 非对齐数据传送

CM3支持在单一的访问中使用非（地址）对齐的传送，数据存储器的访问无需对齐。

非对齐的数据传送只发生在常规的数据传送指令中，如LDR/LDRH/LDRSH。其它指令则不支持

> 不支持的指令类型:
>
> 多个数据的加载/存储(LDM/STM)
>
> 堆栈操作PUSH/POP
>
> 互斥访问(LDREX/STREX)。如果非对齐会导致一个用法fault
>
> 位带操作。因为只有LSB有效，非对齐的访问会导致不可预料的结果。

## 互斥访问

在互斥访问操作下，允许互斥体所在的地址被其它总线master访问，也允许被其它运行在本机上的任务访问，但是CM3能够“驳回”有可能导致竞态条件的互斥写操作

互斥访问分为加载和存储，相应的指令对子为LDREX/STREX,  LDREXH/STREXH,  LDREXB/STREXB，分别对应于字/半字/字节。

```assembly
LDREX    Rxf,            [Rn,    #offset]   
STREX    Rd,      Rxf, [Rn,    #offset] 
```

> LDREX的语法同LDR相同，这里不再赘述。而STREX则不同。STREX指令的执行是可以被“驳回”的。当处理器同意执行STREX时，Rxf的值被存储到(Rn+offset)处，并且把Rd的值更新为0。但若处理器驳回了STREX的执行，则不会发生存储动作，并且把Rd的值更新为1。

当遇到STREX指令时，仅当在它之前执行过LDREX指令，且在最近的一条LDREX指令执行后，没有执行过其它的STR/STREX指令，才允许执行本条STREX指令——也就是说只有在LDREX执行后，从时间上与之距离最近的一条STREX才能成功执行。

其它情况下，驳回此STREX。包括：中途有其它的STR指令执行 中途有其它的STREX指令执行。

![image-20240117154520703](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202401171545753.png)

![image-20240117154947763](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202401171549792.png)

> LDREX/STREX的工作原理其实很简单。仍然以上一段程序为例：当执行了LDREX后，处理器会在内部标记出一段地址。原则上，这段地址从R0开始，范围由芯片制造商定义。技术手册推荐的范围是在4字节至4KB之间，但是很多粗线条的实现会标记整个4GB的地址。在标记以后，  对于第一个执行到的STR/STREX指令，只要其存储的地址落在标记范围内，就会清除此标记（对于整个4GB地址都被标记的情况，则任何存储指令都会清除此标记）。如果先后执行了两次LDREX，则以后一个LDREX标记的地址为准。

> 当使用互斥访问时，在CM3总线接口上的内部写缓冲会被旁路，即使是MPU规定此区是可以缓冲的也不行。这保证了互斥体的更新总能在第一时间内完成，从而保证数据在各个总线主机(master)之间是一致的

## 端模式

一般的单片机使用的都是小段模式, 但是也支持大端模式





