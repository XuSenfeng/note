---
layout: post
title: "互斥量" 
date:   2023-11-15 15:39:08 +0800
tags: FreeRTOS
---

# 互斥量

## 队列的使用FIFO

队列: 可以包含若干个数据, 有若干项, 数据大小固定, 创建的时候指定长度, 采用先进先出

相当于一个传送带

使用的时候有两种:

+ 拷贝: 把数据, 变量复制到队列里面
+ 引用: 把数据, 变量的地址复制到队列里面

![image-20231117195425622](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202311171954699.png)

![image-20231117195442317](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202311171954342.png)

任务读写的时候如果不成功就进入阻塞状态, 可以指定阻塞时间, 一旦有数据就会恢复就绪态

多个任务如果读取同一个队列, 都进入阻塞, 有数据的时候优先级比较高的任务进入就绪态, 优先级相同的时候等待时间最长的任务会进入就绪状态

当数据满了的时候也需要一个进入阻塞

### 实际实现

猜测: 有一个存储数据的部分, 一个链表保存要读取数据阻塞的任务, 一个链表保存写入数据的链表

```c
typedef struct QueuePointers
{
    int8_t * pcTail;     /*< Points to the byte at the end of the queue storage area.  Once more byte is allocated than necessary to store the queue items, this is used as a marker. 尾部*/
    int8_t * pcReadFrom; /*< Points to the last place that a queued item was read from when the structure is used as a queue. 读指针*/
} QueuePointers_t;

typedef struct QueueDefinition /* The old naming convention is used to prevent breaking kernel aware debuggers. */
{
    int8_t * pcHead;           /*< Points to the beginning of the queue storage area. 指向头部*/
    int8_t * pcWriteTo;        /*< Points to the free next place in the storage area. 读写指针*/

    union
    {
        QueuePointers_t xQueue;     /*< Data required exclusively when this structure is used as a queue. */
        SemaphoreData_t xSemaphore; /*< Data required exclusively when this structure is used as a semaphore. */
    } u;

    List_t xTasksWaitingToSend;             /*< List of tasks that are blocked waiting to post onto this queue.  Stored in priority order. */
    List_t xTasksWaitingToReceive;          /*< List of tasks that are blocked waiting to read from this queue.  Stored in priority order. 两组任务*/

    volatile UBaseType_t uxMessagesWaiting; /*< The number of items currently in the queue. 当前的数据数量*/
    UBaseType_t uxLength;                   /*< The length of the queue defined as the number of items it will hold, not the number of bytes. 保存的最大数量*/
    UBaseType_t uxItemSize;                 /*< The size of each items that the queue will hold. 一个单位的长度*/

    volatile int8_t cRxLock;                /*< Stores the number of items received from the queue (removed from the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
    volatile int8_t cTxLock;                /*< Stores the number of items transmitted to the queue (added to the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */

    #if ( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
        uint8_t ucStaticallyAllocated; /*< Set to pdTRUE if the memory used by the queue was statically allocated to ensure no attempt is made to free the memory. */
    #endif

    #if ( configUSE_QUEUE_SETS == 1 )
        struct QueueDefinition * pxQueueSetContainer;
    #endif

    #if ( configUSE_TRACE_FACILITY == 1 )
        UBaseType_t uxQueueNumber;
        uint8_t ucQueueType;
    #endif
} xQUEUE;
```

### 实际使用

+ 创建

```c
QueueHandle_t xQueueCreate( UBaseType_t uxQueueLength, UBaseType_t uxItemSize );
```

> 队列的长度以及队列一个项的大小(单位是字节), 返回值是一个队列的结构体

```c
QueueHandle_t xQueueCreateStatic(UBaseType_t uxQueueLength,
                                UBaseType_t uxItemSize,
                                uint8_t *pucQueueStorageBuffer,
                                StaticQueue_t *pxQueueBuffer
);
```

> 静态创建: 队列的长度, 队列一个单位的大小, 队列的数组, 队列的结构体, 返回指向结构体的句柄

+ 复位

```c
BaseType_t xQueueReset( QueueHandle_t pxQueue);
```

+ 删除

```c
void vQueueDelete( QueueHandle_t xQueue );
```

> 删除动态创建的队列, 释放内存

+ 写队列

```c
BaseType_t xQueueSend(QueueHandle_t xQueue,
                        const void *pvItemToQueue,
                        TickType_t xTicksToWait
);
```

> 向队列尾部写入数据, 等待的时间是xTicksToWait

````c
BaseType_t xQueueSendToBack(QueueHandle_t xQueue,
                            const void *pvItemToQueue,
                            TickType_t xTicksToWait
);
````

```c
BaseType_t xQueueSendToBackFromISR(QueueHandle_t xQueue,
                            const void *pvItemToQueue,
                            BaseType_t *pxHigherPriorityTaskWoken
);

```

> 可以在中断中使用

```c
BaseType_t xQueueSendToFront(QueueHandle_t xQueue,
                            const void *pvItemToQueue,
                            TickType_t xTicksToWait
);
```

> 向头部写入数据

```c
BaseType_t xQueueSendToFrontFromISR(QueueHandle_t xQueue,
                                    const void *pvItemToQueue,
                                    BaseType_t *pxHigherPriorityTaskWoken
);
```

> 头部写入, 不可阻塞, 中断中使用

![image-20231117201539734](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202311172015773.png)

> 可以使用portMAX_DELAY一直等待

+ 读取

```c
BaseType_t xQueueReceive( QueueHandle_t xQueue,
                            void * const pvBuffer,
                            TickType_t xTicksToWait 
);
BaseType_t xQueueReceiveFromISR(QueueHandle_t xQueue,
                                void *pvBuffer,
                                BaseType_t *pxTaskWoken
);
```

+ 查询

```c
/*
* 返回队列中可用数据的个数
*/
UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue );
/*
* 返回队列中可用空间的个数
*/
UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue );
```

+ 覆盖

```c
/* 覆盖队列
* xQueue: 写哪个队列
* pvItemToQueue: 数据地址
* 返回值: pdTRUE表示成功, pdFALSE表示失败
*/
BaseType_t xQueueOverwrite(
QueueHandle_t xQueue,
const void * pvItemToQueue
);
BaseType_t xQueueOverwriteFromISR(
QueueHandle_t xQueue,
const void * pvItemToQueue,
BaseType_t *pxHigherPriorityTaskWoken
);

```

> 队列长度为1的时候使用这一个函数对队列进行覆盖

+ 窥视

```c
/* 偷看队列
* xQueue: 偷看哪个队列
* pvItemToQueue: 数据地址, 用来保存复制出来的数据
* xTicksToWait: 没有数据的话阻塞一会
* 返回值: pdTRUE表示成功, pdFALSE表示失败
*/
BaseType_t xQueuePeek(
QueueHandle_t xQueue,
void * const pvBuffer,
TickType_t xTicksToWait
);
BaseType_t xQueuePeekFromISR(
QueueHandle_t xQueue,
void *pvBuffer,
);
```

> 读取一个数据, 但是不更改读指针的位置

### 实现一个锁

```c
int InitUARTLock(void)
{
    int val;
    xQueueUARTcHandle = xQueueCreat(1, sizeof(int));
    if(xQueueUARTcHandle==NULL)
    {
        printf("can not creat queue\r\n");
        return -1;
    }
    xQueueSend(xQueueUARTcHandle, &val, portMAX_DELAY);
}
void GetUARTLock(void)
{
    int val;
    xQueueReceive(xQueueUARTcHandle, &val, portMAX_DELAY);
}
void PutUARTLock(void)
{
    int val;
    xQueueSend(xQueueUARTcHandle, &val, portMAX_DELAY);
}
```

> 当队列里面有数据的时候表示空闲

```c
void  Task1Function( void * param){
    while(1){
        Task1Flog = 1;
        Task2Flog = 0;
        Task3Flog = 0;
        GetUARTLock();
        printf("This is task 1\r\n");
        PutUARTLock();
        vTaskDelay(1);	//保证另一个任务可以运行
    }
}
```

![image-20231117205600322](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202311172056352.png)

## 邮箱

![image-20231117215121960](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202311172151995.png)

## 队列集

从多个队列里面获取一个数据

比如需要同时获取鼠标, 键盘以及触摸屏的数据的时候可以使用这一个数据类型

1. 创建一个队列集
2. 队列集的长度是队列的handle长度
3. 使用的各个单独的队列都会有一个参数指向这一个队列集, 建立联系
4. 之后有数据的时候, 在写数据的时候会把数据写入队列里面, 并且把队列的handle写入队列集里面
5. 读取队列集的时候会返回一个handle, 之后用这一个handle读取队列

### 函数

```c
QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength );
```

> configUSE_QUEUE_SETS宏定义, 参数是监视的所有队列的长度之和

+ 添加/建立联系

```c
    BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore,
                               QueueSetHandle_t xQueueSet );
```

> 参数是队列和队列集

+ 获取

```c
    QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet,
                                                TickType_t const xTicksToWait );
```

### 示例

```c
xTaskCreate(Task1Function, "Task1", 100, NULL, 1, &xHandleTask1);
xTaskCreate(Task2Function, "Task2", 100, NULL, 1, &xHandleTask2);
xTaskCreate(Task3Function, "Task3", 100, NULL, 1, &xHandleTask3);
xTask1Queue = xQueueCreate(2, sizeof(int));    
xTask2Queue = xQueueCreate(2, sizeof(int));
xQueueSet = xQueueCreateSet(4);
xQueueAddToSet(xTask1Queue, xQueueSet);
xQueueAddToSet(xTask2Queue, xQueueSet);
```

```c
void  Task2Function( void * param){
    int i = -1;
    while(1){
        Task1Flog = 0;
        Task2Flog = 1;
        Task3Flog = 0;
        xQueueSend(xTask2Queue, &i, portMAX_DELAY);
        i--;
        vTaskDelay(10);

    }
}
void  Task1Function( void * param){
    int i = 0;
    while(1){
        Task1Flog = 1;
        Task2Flog = 0;
        Task3Flog = 0;
        xQueueSend(xTask1Queue, &i, portMAX_DELAY);
        i++;
        vTaskDelay(20);
    }
}

//钩子函数会在空闲任务里面执行
void  Task3Function( void * param){
    QueueSetMemberHandle_t handle;
    int i;
    while(1){
        Task1Flog = 0;
        Task2Flog = 0;
        Task3Flog = 1;
        handle = xQueueSelectFromSet(xQueueSet, portMAX_DELAY);
        xQueueReceive(handle, &i, 0);
        printf("%d\n", i);
    }
        //printf("3");
}
```

## 信号量

有一个计数值, 任务完成让信号量加一, 使用的时候使信号量减一

信号: 通知作用

量: 表示资源的数量

> 量没有限制的时候就是计数型信号量
>
> 只有0, 1两种的时候就是二进制信号量

支持的行为: 产生信号的时候give信号量加一, 处理事件的时候take, 信号量减一

访问的时候先take, 访问结束give

![image-20231119095715364](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202311190957504.png)

![image-20231119095745304](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202311190957343.png)

### 函数

+ 创建

![image-20231119095759865](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202311190957899.png)

```c
/* 创建一个二进制信号量，返回它的句柄。
* 此函数内部会分配信号量结构体
* 返回值: 返回句柄，非NULL表示成功
*/
SemaphoreHandle_t xSemaphoreCreateBinary( void );
/* 创建一个二进制信号量，返回它的句柄。
* 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针
* 返回值: 返回句柄，非NULL表示成功
*/
SemaphoreHandle_t xSemaphoreCreateBinaryStatic( StaticSemaphore_t
*pxSemaphoreBuffer );

```

```c
/* 创建一个计数型信号量，返回它的句柄。
* 此函数内部会分配信号量结构体
* uxMaxCount: 最大计数值
* uxInitialCount: 初始计数值
* 返回值: 返回句柄，非NULL表示成功
*/
SemaphoreHandle_t xSemaphoreCreateCounting(UBaseType_t uxMaxCount, UBaseType_t
uxInitialCount);
/* 创建一个计数型信号量，返回它的句柄。
* 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针
* uxMaxCount: 最大计数值
* uxInitialCount: 初始计数值
* pxSemaphoreBuffer: StaticSemaphore_t结构体指针
* 返回值: 返回句柄，非NULL表示成功
*/
SemaphoreHandle_t xSemaphoreCreateCountingStatic( UBaseType_t uxMaxCount,
UBaseType_t uxInitialCount,
StaticSemaphore_t
*pxSemaphoreBuffer );

```

> 他的本质还是一个队列, 使用队列结构体个uxMessagegsWaiting变量保存当前的总的资源的数量

+ 删除

```c
/*
* xSemaphore: 信号量句柄，你要删除哪个信号量
*/
void vSemaphoreDelete( SemaphoreHandle_t xSemaphore );

```

+ 使用

![image-20231119100135553](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202311191001587.png)

```c
BaseType_t xSemaphoreGive( SemaphoreHandle_t xSemaphore );
```

> 返回的是pdTRUE的时候表示成功, 如果超过最大值会返回失败

````c
BaseType_t xSemaphoreGiveFromISR(SemaphoreHandle_t xSemaphore,
						BaseType_t *pxHigherPriorityTaskWoken
);

````

> 第一个参数是要操作的信号量, 第二个参数是是否有高优先级的任务被唤醒, 有的话返回pdTRUE
>
> 返回值同上

```c
BaseType_t xSemaphoreTake(SemaphoreHandle_t xSemaphore,
					TickType_t xTicksToWait
);
```

> 使用这一个如果信号量为0的时候会阻塞

```c
BaseType_t xSemaphoreTakeFromISR(SemaphoreHandle_t xSemaphore,
					BaseType_t *pxHigherPriorityTaskWoken
);
```

> 信号量句柄, 高优先级任务是否被唤醒

### 实际使用

使用二进制信号量的时候由于最大只有1, 所以有多次提醒的时候有可能只会接收到一次, 可以使用一个缓冲区, 把所有数据放进去, 最后提取的时候使用一次性把所有的数据提取出来

## 互斥量

> **不要在中断里面使用!!!!**

相对于信号量有可能会在上锁以后进行任务切换, 切换以后在其他的任务里面对信号量进行解锁(不能实现由谁上锁就是谁来解锁)

互斥量也不能实现这一点, 但是可以解决优先级反转以及递归上锁解锁

> **没有解决的时候出现的问题: ** 优先级为1的任务使用一个资源进行上锁, 这时候优先级为2的任务开始运行, 然后又有优先级为3的任务开始运行, 优先级为三的任务也想使用, 进入阻塞, 这时候如果优先级为2的任务一直在运行, 优先级为1的任务就不能进行, 资源不能释放
>
> **结果:** 优先级为2的任务把优先级为3的任务抢占了
>
> **解决方法: **优先级继承, 在优先级为3进入休眠的时候会提高比较低的优先级任务的优先级, 等他释放的时候返回之前的优先级

> **二次上锁: **有一个任务多次获取同一个信号量, 由于自己阻塞了, 所以没有人可以进行释放, 就会进入死锁
>
> **解决方式: **递归锁, 在你持有这一个锁的时候可以递归上锁, 再次获取自己的锁

> **注意: **互斥量只实现了优先级继承, 递归锁是另一种特殊的互斥量

### 使用场景

在有多个任务访问同一个全局变量时候, 如果在任务一获取进行处理但是没有更新的时候任务二对这一个变量进行操作, 会导致操作结果不是预期的的问题

+ 问题原因

没有使用原子操作的变量(按照机器的位数进行使用变量), 比如在16位机器上使用32位的变量, 操作可能会被打断

函数不可重用(使用全局变量, 局部变量)

### 实际使用

+ 创建

```c
/* 创建一个互斥量，返回它的句柄。
* 此函数内部会分配互斥量结构体
* 返回值: 返回句柄，非NULL表示成功
*/
SemaphoreHandle_t xSemaphoreCreateMutex( void );
/* 创建一个互斥量，返回它的句柄。
* 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针
* 返回值: 返回句柄，非NULL表示成功
*/
SemaphoreHandle_t xSemaphoreCreateMutexStatic( StaticSemaphore_t *pxMutexBuffer
);

```

> 在创建的时候会把值设置为1

+ give/take**注意: 互斥量不能在中断中使用**

```c
/*
* xSemaphore: 信号量句柄，你要删除哪个信号量, 互斥量也是一种信号量
*/
void vSemaphoreDelete( SemaphoreHandle_t xSemaphore );
/* 释放 */
BaseType_t xSemaphoreGive( SemaphoreHandle_t xSemaphore );
/* 释放(ISR版本) */
BaseType_t xSemaphoreGiveFromISR(
SemaphoreHandle_t xSemaphore,
BaseType_t *pxHigherPriorityTaskWoken
);
/* 获得 */
BaseType_t xSemaphoreTake(
SemaphoreHandle_t xSemaphore,
    TickType_t xTicksToWait
);
/* 获得(ISR版本) */
xSemaphoreGiveFromISR(
SemaphoreHandle_t xSemaphore,
BaseType_t *pxHigherPriorityTaskWoken
);
```

### 缺陷以及递归锁

没有检测是否是本人在释放

可能会产生监守自盗的情况

```c
static void vGiveAndTakeTask( void *pvParameters )
{
	const TickType_t xTicksToWait = pdMS_TO_TICKS( 10UL );	
	BaseType_t xStatus;

	/* 尝试获得互斥量: 上锁 */
	xStatus = xSemaphoreTake(xMutex, 0);
	printf("Task2: at first, take the Mutex %s\r\n", \
		(xStatus == pdTRUE)? "Success" : "Failed");
	
	/* 如果失败则监守自盗: 开锁 */
	if (xStatus != pdTRUE)
	{
		xStatus = xSemaphoreGive(xMutex);
		printf("Task2: give Mutex %s\r\n", \
			(xStatus == pdTRUE)? "Success" : "Failed");
	}

	/* 最后成功获得互斥量 */
	xStatus = xSemaphoreTake(xMutex, portMAX_DELAY);
	printf("Task2: and then, take the Mutex %s\r\n", \
		(xStatus == pdTRUE)? "Success" : "Failed");
	
	/* 无限循环 */
	for( ;; )
	{	
		/* 什么都不做 */
		vTaskDelay(xTicksToWait);
	}
}
```

+ 解决

使用递归锁, 实现谁持有就有谁有放

![image-20231119114023325](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202311191140368.png)

```c
/* 创建一个递归锁，返回它的句柄。
* 此函数内部会分配互斥量结构体
* 返回值: 返回句柄，非NULL表示成功
*/
SemaphoreHandle_t xSemaphoreCreateRecursiveMutex( void );
/* 释放 */
BaseType_t xSemaphoreGiveRecursive( SemaphoreHandle_t xSemaphore );
/* 获得 */
BaseType_t xSemaphoreTakeRecursive(SemaphoreHandle_t xSemaphore,
	TickType_t xTicksToWait
);

```

# 事件组

之前介绍的手段都没有办法实现有多个事件的处理

可以认为是一个整数, 使用它的不同的位表述不同的事件

1表示事件发生, 0表示事件没有发生

事件组用一个整数表示, 高八位是给内核使用的

![image-20231119194438693](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202311191944900.png)

![image-20231119194507468](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202311191945507.png)

![image-20231119194533066](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202311191945113.png)

### 实现使用的函数

```c
typedef struct EventGroupDef_t
{
    EventBits_t uxEventBits;//一个整数, 每一位都是一个事件
    List_t xTasksWaitingForBits; /*< List of tasks waiting for a bit to be set. */

    #if ( configUSE_TRACE_FACILITY == 1 )
        UBaseType_t uxEventGroupNumber;
    #endif

    #if ( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
        uint8_t ucStaticallyAllocated; /*< Set to pdTRUE if the event group is statically allocated to ensure no attempt is made to free the memory. */
    #endif
} EventGroup_t;
```

+ 创建

```c
/* 创建一个事件组，返回它的句柄。
* 此函数内部会分配事件组结构体
* 返回值: 返回句柄，非NULL表示成功
*/
EventGroupHandle_t xEventGroupCreate( void );
/* 创建一个事件组，返回它的句柄。
* 此函数无需动态分配内存，所以需要先有一个StaticEventGroup_t结构体，并传入它的指针
* 返回值: 返回句柄，非NULL表示成功
*/
EventGroupHandle_t xEventGroupCreateStatic( StaticEventGroup_t *
pxEventGroupBuffer );
```

+ 删除

```c
/*
* xEventGroup: 事件组句柄，你要删除哪个事件组
*/
void vEventGroupDelete( EventGroupHandle_t xEventGroup )
```

+ 设置事件

```c
/* 设置事件组中的位
* xEventGroup: 哪个事件组
* uxBitsToSet: 设置哪些位?
* 如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1
* 可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0
* 返回值: 返回原来的事件值(没什么意义, 因为很可能已经被其他任务修改了)
*/
EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, 					const EventBits_t uxBitsToSet );
/* 设置事件组中的位
* xEventGroup: 哪个事件组
* uxBitsToSet: 设置哪些位?
* 如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1
* 可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0
* pxHigherPriorityTaskWoken: 有没有导致更高优先级的任务进入就绪态? pdTRUE-有,
pdFALSE-没有
* 返回值: pdPASS-成功, pdFALSE-失败
*/
BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup,
const EventBits_t uxBitsToSet,
BaseType_t * pxHigherPriorityTaskWoken );

```

> 设置事件组的时候有可能会有多个任务被唤醒, 这会带来很大的不确定性。所以 xEventGroupSetBitsFromISR 函数不是直接去设置事件组，而是给一个FreeRTOS后台任务(daemon task)发送队列数据，由这个任务来设置事件组。
>
> 如果后台任务的优先级比当前被中断的任务优先级高， xEventGroupSetBitsFromISR 会设置 *pxHigherPriorityTaskWoken 为pdTRUE。
>
> 如果daemon task成功地把队列数据发送给了后台任务，那么 xEventGroupSetBitsFromISR 的返回值 就是pdPASS。

+ 等待事件

```c
EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup,
                        const EventBits_t uxBitsToWaitFor,
                        const BaseType_t xClearOnExit,
                        const BaseType_t xWaitForAllBits,
                        TickType_t xTicksToWait );
```

> 参数是: 事件组, 等待哪些事件, 返回时候是否会清除, 是否等待所有时间(pdTRUE=都等待与, pdFALSE则是或), 等待的时间

+ 同步点

```c
EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup,
                        const EventBits_t uxBitsToSet,
                        const EventBits_t uxBitsToWaitFor,
                        TickType_t xTicksToWait );
```

> 当有多个任务协调控控制某一个事件的时候, 使用这一个函数设置一个位等待其他的事件





