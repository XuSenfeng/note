---
layout: post
title: "RT-Thread启动流程" 
date:   2024-1-26 15:39:08 +0800
tags: RT-Thread
---

# RT-Thread启动流程

<img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202401271231214.png" alt="image-20240127123137747" style="zoom:150%;" />

开始的时候rttread_startup()函数是RTThread的统一的入口, 一般的顺序是系统先从启动文件开始运行，然后进入 RT-Thread 的启动 rtthread_startup() ，最后进入用户入口 main()

![image-20240127123607178](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202401271236208.png)

![image-20240127133652325](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202401271336375.png)

![image-20240127133749303](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202401271337336.png)

## 实际的文件

![image-20240127134016114](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202401271340142.png)

```c
/**
 * @brief  This is the code that gets called when the processor first
 *          starts execution following a reset event. Only the absolutely
 *          necessary set is performed, after which the application
 *          supplied main() routine is called.
 * @param  None
 * @retval : None
*/

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:

/* Copy the data segment initializers from flash to SRAM
把数据段拷贝到SRAM*/
  movs r1, #0
  b LoopCopyDataInit

CopyDataInit:
  ldr r3, =_sidata
  ldr r3, [r3, r1]
  str r3, [r0, r1]
  adds r1, r1, #4

LoopCopyDataInit:
  ldr r0, =_sdata
  ldr r3, =_edata
  adds r2, r0, r1
  cmp r2, r3
  bcc CopyDataInit
  ldr r2, =_sbss
  b LoopFillZerobss
/* Zero fill the bss segment.
把BSS段清零*/
FillZerobss:
  movs r3, #0
  str r3, [r2], #4

LoopFillZerobss:
  ldr r3, = _ebss
  cmp r2, r3
  bcc FillZerobss

/* Call the clock system intitialization function.*/
    bl  SystemInit
/* Call static constructors */
    /* bl __libc_init_array */
/* Call the application's entry point.*/
  bl  entry
  bx lr
.size Reset_Handler, .-Reset_Handler
```



```c
/**
  * @brief  Setup the microcontroller system
  *         Initialize the Embedded Flash Interface, the PLL and update the 
  *         SystemCoreClock variable.
  主要是实现时钟的初始化
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
  /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
  /* Set HSION bit */
  RCC->CR |= 0x00000001U;

  /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
#if !defined(STM32F105xC) && !defined(STM32F107xC)
  RCC->CFGR &= 0xF8FF0000U;
#else
  RCC->CFGR &= 0xF0FF0000U;
#endif /* STM32F105xC */   
  
  /* Reset HSEON, CSSON and PLLON bits */
  RCC->CR &= 0xFEF6FFFFU;

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;

  /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
  RCC->CFGR &= 0xFF80FFFFU;

#if defined(STM32F105xC) || defined(STM32F107xC)
  /* Reset PLL2ON and PLL3ON bits */
  RCC->CR &= 0xEBFFFFFFU;

  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x00FF0000U;

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000U;
#elif defined(STM32F100xB) || defined(STM32F100xE)
  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000U;

  /* Reset CFGR2 register */
  RCC->CFGR2 = 0x00000000U;      
#else
  /* Disable all interrupts and clear pending bits  */
  RCC->CIR = 0x009F0000U;
#endif /* STM32F105xC */
    
#if defined(STM32F100xE) || defined(STM32F101xE) || defined(STM32F101xG) || defined(STM32F103xE) || defined(STM32F103xG)
  #ifdef DATA_IN_ExtSRAM
    SystemInit_ExtMemCtl(); 
  #endif /* DATA_IN_ExtSRAM */
#endif 

#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
#endif 
}
```

```c
int entry(void)
{
    rtthread_startup();
    return 0;
}
```

```c
//这是一个初始化函数
int rtthread_startup(void)
{
    //关中断
    rt_hw_interrupt_disable();

    /* board level initialization硬件的初始化
     * NOTE: please initialize heap inside board initialization.
     */
    rt_hw_board_init();

    /* show RT-Thread version */
    rt_show_version();

    /* timer system initialization */
    rt_system_timer_init();

    /* scheduler system initialization */
    rt_system_scheduler_init();

#ifdef RT_USING_SIGNALS
    /* signal system initialization 信号量的初始化*/
    rt_system_signal_init();
#endif

    /* create init_thread app的线程*/
    rt_application_init();

    /* timer thread initialization 定时器线程的初始化*/
    rt_system_timer_thread_init();

    /* idle thread initialization 空闲任务*/
    rt_thread_idle_init();

#ifdef RT_USING_SMP
    rt_hw_spin_lock(&_cpus_lock);
#endif /*RT_USING_SMP*/

    /* start scheduler 开启调度器*/
    rt_system_scheduler_start();

    /* never reach here */
    return 0;
}
```

```c
void rt_application_init(void)
{
    rt_thread_t tid;
//看看是否使用堆
#ifdef RT_USING_HEAP
    //一个叫做main的任务, 使用的函数是main_thread_entry, 没有参数, 栈大小2048, 优先级10, 时钟20
    tid = rt_thread_create("main", main_thread_entry, RT_NULL,
                           RT_MAIN_THREAD_STACK_SIZE, RT_MAIN_THREAD_PRIORITY, 20);
    RT_ASSERT(tid != RT_NULL);
#else
    rt_err_t result;

    tid = &main_thread;
    result = rt_thread_init(tid, "main", main_thread_entry, RT_NULL,
                            main_stack, sizeof(main_stack), RT_MAIN_THREAD_PRIORITY, 20);
    RT_ASSERT(result == RT_EOK);

    /* if not define RT_USING_HEAP, using to eliminate the warning */
    (void)result;
#endif
	//启动线程
    rt_thread_startup(tid);
}
```

```c
/* the system main thread */
void main_thread_entry(void *parameter)
{
    extern int main(void);
    extern int $Super$$main(void);
    
#ifdef RT_USING_COMPONENTS_INIT
    /* RT-Thread components initialization 各个组件的初始化*/
    rt_components_init();
#endif    
#ifdef RT_USING_SMP
    rt_hw_secondary_cpu_up();
#endif
    /* invoke system main function */
#if defined(__CC_ARM) || defined(__CLANG_ARM)
    $Super$$main(); /* for ARMCC. */
#elif defined(__ICCARM__) || defined(__GNUC__)
    //用户层的main函数的接口
    main();
#endif
}
```



