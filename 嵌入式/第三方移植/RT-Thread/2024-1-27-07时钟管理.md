---
layout: post
title: "RT-Thread时钟管理" 
date:   2024-1-26 15:39:08 +0800
tags: RT-Thread
---

# 时钟管理

操作系统需要一个时钟用来规范任务

## 时钟节拍

时钟节拍的长度可以根据 RT_TICK_PER_SECOND 的定义来调整

rtconfig.h配置文件中定义

```c
#define RT_TICK_PER_SECOND 1000
```

> 时钟是每秒1000次

```c
void SysTick_Handler(void)
{
    /* enter interrupt */
    rt_interrupt_enter();
	//更新时钟
    HAL_IncTick();
    rt_tick_increase();

    /* leave interrupt */
    rt_interrupt_leave();
}
```

```c
/**
 * This function will return current tick from operating system startup
 *
 * @return current tick
 */
rt_tick_t rt_tick_get(void)
```

> 获取时钟

## 定时器

从指定的时刻开始，经过一定的指定时间后触发一个事件

硬件定时器: 芯片本身提供的定时功能。一般是由外部晶振提供给芯片输入时钟，芯片向软件模块提供一组配置寄存器，接受控制输入，到达设定时间值后芯片中断控制器产生时钟中断。

软件定时器: 由操作系统提供的一类系统接口，它构建在硬件定时器基础之上，使系统能够提供不受数目限制的定时器服务。

RT-Thread操作系统提供软件实现的定时器，以时钟节拍（OS Tick）的时间长度为单位，即定时数值必须是OS Tick的整数倍

可以设置单次触发以及周期触发

根据定时器超时函数执行时所处的上下文环境，RT-Thread的定时器可以分为HARD_TIMER模式和SOFT_TIMER模式

HARD_TIMER模式：中断上下文

定时器超时函数的要求：执行时间应该尽量短，执行时不应导致当前上下文挂起、等待。例如在中断上下文中执行的超时函数它不应该试图去申请动态内存、释放动态内存等

SOFT_TIMER模式：线程上下文

该模式被启用后，系统会在初始化时创建一个 timer 线程，然后 SOFT_TIMER 模式的定时器超时函数在都会在timer线程的上下文环境中执行

> 这个是RT-Thread使用的

### 初始化

int rtthread_startup(void)里面有两个函数

```c
/**
 * @ingroup SystemInit
 *
 * This function will initialize system timer
 */
void rt_system_timer_init(void)
{
    int i;

    for (i = 0; i < sizeof(rt_timer_list) / sizeof(rt_timer_list[0]); i++)
    {
        rt_list_init(rt_timer_list + i);
    }
}
```

> 系统定时器的初始化, 注意就是一个列表, 这个数组的个数是一个, 这个是一个硬件定时器的列表

```c
void rt_system_timer_thread_init(void)
{
#ifdef RT_USING_TIMER_SOFT
    int i;

    for (i = 0;i < sizeof(rt_soft_timer_list) / sizeof(rt_soft_timer_list[0]);i++)
    {
        //这个只是一个链表头, 之后会使用定时器的时间顺序进行插入
        rt_list_init(rt_soft_timer_list + i);
    }

    /* start software timer thread */
    rt_thread_init(&timer_thread,
                   "timer",
                   rt_thread_timer_entry,
                   RT_NULL,
                   &timer_thread_stack[0],
                   sizeof(timer_thread_stack),
                   RT_TIMER_THREAD_PRIO,
                   10);

    /* startup */
    rt_thread_startup(&timer_thread);
#endif
}
```

### 机制

主要有两个列表

+ 当前系统经过的 tick 时间 rt_tick（当硬件定时器中断来临时，它将加 1） ；
+ 定时器链表 rt_timer_list。系统新创建并激活的定时器都会按照以超时时间排序的方式插入到rt_timer_list 链表中。

## 实际使用

### 创建

```c
//动态创建
/**
 * This function will create a timer
 *
 * @param name the name of timer
 * @param timeout the timeout function
 * @param parameter the parameter of timeout function
 * @param time the tick of timer
 * @param flag the flag of timer
 *
 * @return the created timer object
 */
rt_timer_t rt_timer_create(const char *name,
                           void (*timeout)(void *parameter),
                           void       *parameter,
                           rt_tick_t   time,
                           rt_uint8_t  flag)
```

> ```c
> #define RT_TIMER_FLAG_DEACTIVATED       0x0             /**< timer is deactive */
> #define RT_TIMER_FLAG_ACTIVATED         0x1             /**< timer is active */
> #define RT_TIMER_FLAG_ONE_SHOT          0x0             /**< one shot timer 一次性的*/
> #define RT_TIMER_FLAG_PERIODIC          0x2             /**< periodic timer 周期的*/
> 
> #define RT_TIMER_FLAG_HARD_TIMER        0x0             /**< hard timer,the timer's callback function will be called in tick isr. 硬件的, 这一个不会用到*/
> #define RT_TIMER_FLAG_SOFT_TIMER        0x4             /**< soft timer,the timer's callback function will be called in timer thread. 软件的, 这一个主要是插入不同的列表里面*/
> ```
>
> 调用该函数接口后，内核首先从动态内存堆中分配一个定时器控制块，然后对该控制块进行基本的初始化。
>
> 如果是硬件的会在SystemTick中断里面进行处理, 不然的话会在timer线程处理

```c
//静态创建
/**
 * This function will initialize a timer, normally this function is used to
 * initialize a static timer object.
 *
 * @param timer the static timer object
 * @param name the name of timer
 * @param timeout the timeout function
 * @param parameter the parameter of timeout function
 * @param time the tick of timer
 * @param flag the flag of timer
 */
void rt_timer_init(rt_timer_t  timer,
                   const char *name,
                   void (*timeout)(void *parameter),
                   void       *parameter,
                   rt_tick_t   time,
                   rt_uint8_t  flag)
{
    /* timer check */
    RT_ASSERT(timer != RT_NULL);

    /* timer object initialization */
    rt_object_init((rt_object_t)timer, RT_Object_Class_Timer, name);

    _rt_timer_init(timer, timeout, parameter, time, flag);
}
```

### 删除

```c
/**
 * This function will delete a timer and release timer memory
 *
 * @param timer the timer to be deleted
 *
 * @return the operation status, RT_EOK on OK; RT_ERROR on error
 */
rt_err_t rt_timer_delete(rt_timer_t timer)
```

```c
/**
 * This function will detach a timer from timer management.
 *
 * @param timer the static timer object
 *
 * @return the operation status, RT_EOK on OK; RT_ERROR on error
 */
rt_err_t rt_timer_detach(rt_timer_t timer)
```

### 开启

```c
/**
 * This function will start the timer
 *
 * @param timer the timer to be started
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_timer_start(rt_timer_t timer)
```

### 停止

```c
/**
 * This function will stop the timer
 *
 * @param timer the timer to be stopped
 *
 * @return the operation status, RT_EOK on OK, -RT_ERROR on error
 */
rt_err_t rt_timer_stop(rt_timer_t timer)
```



















