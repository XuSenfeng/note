---
layout: post
title: "问题处理" 
date:   2024-1-28 15:39:08 +0800
tags: RT-Thread
---

# 系统间同步

RTThread提供的方式有信号量, 互斥量以及事件集

## 信号量

每个信号量对象都有一个信号量值和一个线程等待队列，信号量的值对应了信号量对象的实例数目、资源数目，假如信号量值为 5，则表示共有 5 个信号量实例（资源）可以被使用，当信号量实例数目为零时，再申请该信号量的线程就会被挂起在该信号量的等待队列上，等待可用的信号量实例

```c
struct rt_semaphore
{
    struct rt_ipc_object parent;  /**< inherit from ipc_object  继承自ipc_object类*/

    rt_uint16_t          value;       /**< value of semaphore. */
    rt_uint16_t          reserved;    /**< reserved field 预留*/ 
};
typedef struct rt_semaphore *rt_sem_t;

```

![image-20240128135511326](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202401281355367.png)

## 实际使用

### 创建

```c
/**
 * This function will create a semaphore from system resource
 *
 * @param name the name of semaphore
 * @param value the initial value of semaphore
 * @param flag the flag of semaphore
 *
 * @return the created semaphore, RT_NULL on error happen
 *
 * @see rt_sem_init
 */
rt_sem_t rt_sem_create(const char *name, rt_uint32_t value, rt_uint8_t flag)
```

> ```c
> #define RT_IPC_FLAG_FIFO                0x00            /**< FIFOed IPC. @ref IPC. 按照先进先出的方式获取 */
> #define RT_IPC_FLAG_PRIO                0x01            /**< PRIOed IPC. @ref IPC. 按照线程优先级 */
> ```

```c
/**
 * This function will initialize a semaphore and put it under control of
 * resource management.
 *
 * @param sem the semaphore object
 * @param name the name of semaphore
 * @param value the initial value of semaphore
 * @param flag the flag of semaphore
 *
 * @return the operation status, RT_EOK on successful
 */
rt_err_t rt_sem_init(rt_sem_t    sem,
                     const char *name,
                     rt_uint32_t value,
                     rt_uint8_t  flag)
```



### 删除

```c
/**
 * This function will delete a semaphore object and release the memory
 *
 * @param sem the semaphore object
 *
 * @return the error code
 *
 * @see rt_sem_detach
 */
rt_err_t rt_sem_delete(rt_sem_t sem)
```

> 系统将删除这个信号量。如果删除该信号量时，有线程正在等待该信号量，那么删除操作会先唤醒等待在该信号量上的线程（等待线程的返回值是-RT_ERROR），然后再释放信号量的内存资源。

```c
/**
 * This function will detach a semaphore from resource management
 *
 * @param sem the semaphore object
 *
 * @return the operation status, RT_EOK on successful
 *
 * @see rt_sem_delete
 */
rt_err_t rt_sem_detach(rt_sem_t sem)
```

### 获取

```c
/**
 * This function will take a semaphore, if the semaphore is unavailable, the
 * thread shall wait for a specified time.
 *
 * @param sem the semaphore object
 * @param time the waiting time
 *
 * @return the error code
 */
rt_err_t rt_sem_take(rt_sem_t sem, rt_int32_t time)
/**
 * This function will try to take a semaphore and immediately return
 *
 * @param sem the semaphore object
 *
 * @return the error code
 */
rt_err_t rt_sem_trytake(rt_sem_t sem)
{
    return rt_sem_take(sem, 0);
}
```

### 释放

```c
/**
 * This function will release a semaphore, if there are threads suspended on
 * semaphore, it will be waked up.
 *
 * @param sem the semaphore object
 *
 * @return the error code
 */
rt_err_t rt_sem_release(rt_sem_t sem)
```

## 互斥量

拥有互斥量的线程拥有互斥量的所有权，互斥量支持递归访问且能防止线程优先级翻转；并且互斥量只能由持有线程释放，而信号量则可以由任何线程释放。

持有该互斥量的线程也能够再次获得这个锁而不被挂起

这个实现了优先级继承

![image-20240128143528805](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202401281435847.png)

### 创建

```c
/**
 * This function will create a mutex from system resource
 *
 * @param name the name of mutex
 * @param flag the flag of mutex
 *
 * @return the created mutex, RT_NULL on error happen
 *
 * @see rt_mutex_init
 */
rt_mutex_t rt_mutex_create(const char *name, rt_uint8_t flag)
```

```c
/**
 * This function will initialize a mutex and put it under control of resource
 * management.
 *
 * @param mutex the mutex object
 * @param name the name of mutex
 * @param flag the flag of mutex
 *
 * @return the operation status, RT_EOK on successful
 */
rt_err_t rt_mutex_init(rt_mutex_t mutex, const char *name, rt_uint8_t flag)
```

> flag可以是
>
> ```c
> #define RT_IPC_FLAG_FIFO                0x00            /**< FIFOed IPC. @ref IPC. 按照先进先出的方式获取 */
> #define RT_IPC_FLAG_PRIO                0x01            /**< PRIOed IPC. @ref IPC. 按照线程优先级 */
> ```

### 删除

```c
/**
 * This function will delete a mutex object and release the memory
 *
 * @param mutex the mutex object
 *
 * @return the error code
 *
 * @see rt_mutex_detach
 */
rt_err_t rt_mutex_delete(rt_mutex_t mutex)
/**
 * This function will detach a mutex from resource management
 *
 * @param mutex the mutex object
 *
 * @return the operation status, RT_EOK on successful
 *
 * @see rt_mutex_delete
 */
rt_err_t rt_mutex_detach(rt_mutex_t mutex)
```

> 会唤醒所有的睡眠的函数

### 获取

```c
 /*
 * This function will take a mutex, if the mutex is unavailable, the
 * thread shall wait for a specified time.
 *
 * @param mutex the mutex object
 * @param time the waiting time
 *
 * @return the error code
 */
rt_err_t rt_mutex_take(rt_mutex_t mutex, rt_int32_t time)
```

### 释放

```c
/**
 * This function will release a mutex, if there are threads suspended on mutex,
 * it will be waked up.
 *
 * @param mutex the mutex object
 *
 * @return the error code
 */
rt_err_t rt_mutex_release(rt_mutex_t mutex)
```

## 事件集

一个事件集可以包含多个事件，利用事件集可以完成一对多，多对多的线程间同步。

其中任意一个事件唤醒 线程，或几个事件都到达后唤醒线程，多个事件集合可以用一个32bit无符号整型变量来表示

+ 事件只与线程相关，事件间相互独立
+ 事件仅用于同步，不提供数据传输功能
+ 事件无排队性，即多次向线程发送同一事件(如果线程还未来得及读走)，其效果等同于只发送一次

![image-20240128155840632](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202401281558667.png)

```c
/*
 * event structure
 */
struct rt_event
{
    struct rt_ipc_object parent;      /**< inherit from ipc_object */

    rt_uint32_t          set;         /**< event set */
};
```

## 实际使用

### 创建和删除

```c
/**
 * This function will create an event object from system resource
 *
 * @param name the name of event
 * @param flag the flag of event RT_IPC_FLAG_FIFO RT_IPC_FLAG_PRIO
 *
 * @return the created event, RT_NULL on error happen
 */
rt_event_t rt_event_create(const char *name, rt_uint8_t flag)
/**
 * This function will delete an event object and release the memory
 *
 * @param event the event object
 *
 * @return the error code
 */
rt_err_t rt_event_delete(rt_event_t event)
/**
 * This function will initialize an event and put it under control of resource
 * management.
 *
 * @param event the event object
 * @param name the name of event
 * @param flag the flag of event
 *
 * @return the operation status, RT_EOK on successful
 */
rt_err_t rt_event_init(rt_event_t event, const char *name, rt_uint8_t flag)
/**
 * This function will detach an event object from resource management
 *
 * @param event the event object
 *
 * @return the operation status, RT_EOK on successful
 */
rt_err_t rt_event_detach(rt_event_t event)
```

### 发送事件

```c
/**
 * This function will send an event to the event object, if there are threads
 * suspended on event object, it will be waked up.
 *
 * @param event the event object
 * @param set the event set
 *
 * @return the error code
 */
rt_err_t rt_event_send(rt_event_t event, rt_uint32_t set)
```

### 接收事件集

```c
/**
 * This function will receive an event from event object, if the event is
 * unavailable, the thread shall wait for a specified time.
 *
 * @param event the fast event object
 * @param set the interested event set
 * @param option the receive option, either RT_EVENT_FLAG_AND or
 *        RT_EVENT_FLAG_OR should be set. RT_EVENT_FLAG_CLEAR 
 * @param timeout the waiting time  RT_WAITING_FOREVER RT_WAITING_NO
 * @param recved the received event, if you don't care, RT_NULL can be set.
 *
 * @return the error code
 */
rt_err_t rt_event_recv(rt_event_t   event,
                       rt_uint32_t  set,
                       rt_uint8_t   option,
                       rt_int32_t   timeout,
                       rt_uint32_t *recved)
```













