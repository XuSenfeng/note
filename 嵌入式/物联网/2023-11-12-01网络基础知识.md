---
layout: post
title: "网络基础知识" 
date:   2023-11-12 15:39:08 +0800
tags: 物联网 stm32
---

# 网络基础知识

在局域网里面可以很简单的控制设备, 但是不是在局域网的时候就需要引入服务器

在一个设备上面使用ip表示一个设备, 一个设备上不同的程序使用的不同的端口, 一般来说80端口是http端口, 22端口是ssh服务端口

IP和端口都很珍贵, 不是所有的设备都有公网的ip, 局域网的ip是192.168.x.x, 一般一个路由器有一个公网ip, 

一般一个设备在访问网络的时候, 把需求发送给路由器, 路由器记录以后, 路由器进行转发, 构造出一个新的数据包, 源被修改, 但是目的不变, 通过互联网进行发送, 在服务器接受以后返回数据的时候会给路由器, 路由器会再转发给设备

路由器在接受到来路不明的信息会进行屏蔽, 起到保护作用

所以在使用开发板进行上网的时候如果没有一个服务器进行中介, 接收到的路由器会对数据进行丢弃

![image-20231112214547242](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202311122145332.png)

解决方案

![image-20231112214625747](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202311122146814.png)

> 两个服务器都连接到服务器, 在发送数据以后由服务器进行传输数据, 服务器上面需要运行一些软件, 进行数据的传输, 一般使用的是MQTT(一种优化过的协议, 适合传输比较短的数据)
>
> 一般使用的软件是

## MQTT

[mqttclient/README_CN.md at master · jiejieTop/mqttclient (github.com)](https://github.com/jiejieTop/mqttclient/blob/master/README_CN.md)

* kawaii-mqtt源码：

    * 作者发布源码：https://github.com/jiejieTop/mqttclient
    * 大牛维护的：https://github.com/longtengmcu/kawaii-mqtt

* 博客

    * 作者博客：

        * [你不得不看的图文并茂的MQTT协议通信过程！！！](https://jiejie.blog.csdn.net/article/details/106737995?spm=1001.2014.3001.5502)
        * [MQTT协议简介及协议原理](https://jiejie.blog.csdn.net/article/details/106732811?spm=1001.2014.3001.5502)
        * [mqttclient设计与实现方式](https://blog.csdn.net/jiejiemcu/article/details/106773181?spm=1001.2014.3001.5501)
    * 大牛笔记：
        * [记一次解决MQTT软件包内存泄露的心路历程](https://python.iitter.com/other/90280.html)
* APP
    * https://mosquitto.org/download/
    * https://mqttx.app/zh

可以理解为一个中央电视台, 接受发布者的网络连接, 以及用户的网络连接, 记者会发布消息, 之后转发给订阅他的用户

记者和观众都是客户端

![image-20231112215659232](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202311122156268.png)

一般是服务器应用先运行, 之后建立连接, 选择订阅的栏目, 用户以及记者需要时不时ping一下中央电视台确保连接, 中央电视台发送ping说明自己还存在

开发板: 连接服务器, 订阅消息, 读MQTT包(有可能一直读不到, 需要有一个超时时间, 没有数据就返回, 在某种情况下发出ping包确认对方的存在), 处理收到的数据

## MQTT 数据包结构

- `固定头（Fixed header）`，存在于所有`MQTT`数据包中，表示数据包类型及数据包的分组类标识；
- `可变头（Variable header）`，存在于部分`MQTT`数据包中，数据包类型决定了可变头是否存在及其具体内容；
- `消息体（Payload）`，存在于部分`MQTT`数据包中，表示客户端收到的具体内容；

整体MQTT的消息格式如下图所示；

![img](https://pic3.zhimg.com/80/v2-861c089bea9570876bb13a031e6c3902_720w.webp)

### 2.1 `MQTT`固定头

`固定头`存在于所有`MQTT`数据包中，其结构如下：

![img](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202311122214812.webp)

下面简单分析一下固定头的消息格式；

### `MQTT`消息类型 / message type

**位置：**byte 1, bits 7-4。

4位的无符号值，类型如下：

| 名称 | 值   | 流方向 | 描述 |
| ---- | ---- | ------ | ---- |

### 标识位 / DUP

**位置：**byte 1, bits 3-0。

在不使用标识位的消息类型中，标识位被作为保留位。如果收到无效的标志时，接收端必须关闭网络连接：

| 数据包 | 标识位 | Bit 3 | Bit 2 | Bit 1 | Bit 0 |
| ------ | ------ | ----- | ----- | ----- | ----- |
|        |        |       |       |       |       |

- `DUP`：发布消息的副本。用来在保证消息的可靠传输，如果设置为 1，则在下面的变长中增加MessageId，并且需要回复确认，以保证消息传输完成，但不能用于检测消息重复发送。

- `QoS`发布消息的服务质量（前面已经做过介绍），即：保证消息传递的次数

- - `00`：最多一次，即：<=1
    - `01`：至少一次，即：>=1
    - `10`：一次，即：=1
    - `11`：预留

- `RETAIN`：发布保留标识，表示服务器要保留这次推送的信息，如果有新的订阅者出现，就把这消息推送给它，如果设有那么推送至当前订阅者后释放。

### 剩余长度（Remaining Length）

位置：byte 1。

固定头的第二字节用来保存变长头部和消息体的总大小的，但不是直接保存的。这一字节是可以扩展，其保存机制，前7位用于保存长度，后一部用做标识。当最后一位为 1时，表示长度不足，需要使用二个字节继续保存。例如：计算出后面的大小为0

### 2.2 `MQTT`可变头 / Variable header

`MQTT`数据包中包含一个可变头，它驻位于固定的头和负载之间。可变头的内容因数据包类型而不同，较常的应用是做为包的标识：

| Bit  | 7 — 0 |
| ---- | ----- |
|      |       |

很多类型数据包中都包括一个2字节的数据包标识字段，这些类型的包有：

PUBLISH (QoS > 0)、PUBACK、PUBREC、PUBREL、PUBCOMP、

SUBSCRIBE、SUBACK、UNSUBSCRIBE、UNSUBACK

### 2.3 `Payload`消息体

`Payload`消息体是`MQTT`数据包的第三部分，CONNECT、SUBSCRIBE、SUBACK、UNSUBSCRIBE四种类型的消息 有消息体：

- `CONNECT`，消息体内容主要是：客户端的ClientID、订阅的Topic、Message以及用户名和密码
- `SUBSCRIBE`，消息体内容是一系列的要订阅的主题以及`QoS`。
- `SUBACK`，消息体内容是服务器对于`SUBSCRIBE`所申请的主题及`QoS`进行确认和回复。
- `UNSUBSCRIBE`，消息体内容是要订阅的主题。

## 传输的数据

[通过案例理解 MQTT 主题与通配符 | EMQ (emqx.com)](https://www.emqx.com/zh/blog/advanced-features-of-mqtt-topics)

**主题**

MQTT 协议根据主题来转发消息。主题通过 `/` 来区分层级，类似于 URL 路径，例如：

```
chat/room/1

sensor/10/temperature

sensor/+/temperature
```

> [通过案例理解 MQTT 主题与通配符 | EMQ (emqx.com)](https://www.emqx.com/zh/blog/advanced-features-of-mqtt-topics)
>
> 不同于消息队列中的主题（比如 Kafka 和 Pulsar），MQTT 主题不需要提前创建。[MQTT 客户端](https://www.emqx.com/zh/blog/mqtt-client-tools)在订阅或发布时即自动的创建了主题，开发者无需再关心主题的创建，并且也不需要手动删除主题。
>
> MQTT 主题通配符包含单层通配符 `+` 及多层通配符 `#`，主要用于客户端一次订阅多个主题。
>
> > 只能用于订阅
>
> 加号 (“+” U+002B) 是用于单个主题层级匹配的通配符。在使用单层通配符时，单层通配符必须占据整个层级，例如：
>
> ```lsl
> + 有效
> sensor/+ 有效
> sensor/+/temperature 有效
> sensor+ 无效（没有占据整个层级）
> ```
>
> 井字符号（“#” U+0023）是用于匹配主题中任意层级的通配符。多层通配符表示它的父级和任意数量的子层级，在使用多层通配符时，它必须占据整个层级并且必须是主题的最后一个字符，例如：
>
> ```awk
> # 有效，匹配所有主题
> sensor/# 有效
> sensor/bedroom# 无效（没有占据整个层级）
> sensor/#/temperature 无效（不是主题最后一个字符）
> ```
>
> ### 系统主题
>
> 以 `$SYS/` 开头的主题为系统主题，系统主题主要用于获取 [MQTT 服务器](https://www.emqx.com/zh/mqtt/public-mqtt5-broker)自身运行状态、消息统计、客户端上下线事件等数据。目前，MQTT 协议暂未明确规定 `$SYS/` 主题标准，但大多数 MQTT 服务器都遵循该[标准建议](https://github.com/mqtt/mqtt.org/wiki/SYS-Topics)。
>
> | 主题                                 | 说明              |
> | ------------------------------------ | ----------------- |
> | $SYS/brokers                         | EMQX 集群节点列表 |
> | $SYS/brokers/emqx@127.0.0.1/version  | EMQX 版本         |
> | $SYS/brokers/emqx@127.0.0.1/uptime   | EMQX 运行时间     |
> | $SYS/brokers/emqx@127.0.0.1/datetime | EMQX 系统时间     |
> | $SYS/brokers/emqx@127.0.0.1/sysdescr | EMQX 系统信息     |
>
> EMQX 还支持客户端上下线事件、收发流量、消息收发、系统监控等丰富的系统主题，用户可通过订阅 `$SYS/#` 主题获取所有系统主题消息。详细请见：[EMQX 系统主题文档](https://www.emqx.io/docs/zh/v5.0/observability/mqtt-system-topics.html#客户端上下线事件)。
>
> ### 共享订阅
>
> 共享订阅是 [MQTT 5.0](https://www.emqx.com/zh/blog/introduction-to-mqtt-5) 引入的新特性，用于在多个订阅者之间实现订阅的负载均衡，MQTT 5.0 规定的共享订阅主题以 `$share` 开头。
>
> > 虽然 MQTT 协议在 5.0 版本才引入共享订阅，但是 EMQX 从 MQTT 3.1.1 版本开始就支持共享订阅。
>
> 下图中，3 个订阅者用共享订阅的方式订阅了同一个主题 `$share/g/topic`，其中`topic` 是它们订阅的真实主题名，而 `$share/g/` 是共享订阅前缀（`g/` 是群组名，可为任意 UTF-8 编码字符串）。

**QoS**

MQTT 提供了三种服务质量（QoS），在不同网络环境下保证消息的可靠性。

- QoS 0：消息最多传送一次。如果当前客户端不可用，它将丢失这条消息。
- QoS 1：消息至少传送一次。
- QoS 2：消息只传送一次。

关于 MQTT QoS 的更多详情，请参阅文章 [MQTT QoS 0, 1, 2 介绍](https://www.emqx.com/zh/blog/introduction-to-mqtt-qos)。

其中，使用 QoS 0 可能丢失消息，使用 QoS 1 可以保证收到消息，但消息可能重复，使用 QoS 2 可以保证消息既不丢失也不重复。QoS 等级从低到高，不仅意味着消息可靠性的提升，也意味着传输复杂程度的提升。

QoS 等级是由发布者在 PUBLISH 报文中指定的，大部分情况下 Broker 向订阅者转发消息时都会维持原始的 QoS 不变。不过也有一些例外的情况，根据订阅者的订阅要求，消息的 QoS 等级可能会在转发的时候发生降级。

## QoS 0 - 最多交付一次

QoS 0 是最低的 QoS 等级。QoS 0 消息即发即弃，不需要等待确认，不需要存储和重传，因此对于接收方来说，永远都不需要担心收到重复的消息。

![MQTT QoS 0](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202311122226132.png)

### 为什么 QoS 0 消息会丢失？

当我们使用 QoS 0 传递消息时，消息的可靠性完全依赖于底层的 TCP 协议。

而 TCP 只能保证在连接稳定不关闭的情况下消息的可靠到达，一旦出现连接关闭、重置，仍有可能丢失当前处于网络链路或操作系统底层缓冲区中的消息。这也是 QoS 0 消息最主要的丢失场景。

## QoS 1 - 至少交付一次

为了保证消息到达，QoS 1 加入了应答与重传机制，发送方只有在收到接收方的 PUBACK 报文以后，才能认为消息投递成功，在此之前，发送方需要存储该 PUBLISH 报文以便下次重传。

QoS 1 需要在 PUBLISH 报文中设置 Packet ID，而作为响应的 PUBACK 报文，则会使用与 PUBLISH 报文相同的 Packet ID，以便发送方收到后删除正确的 PUBLISH 报文缓存。

![MQTT QoS 1](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202311122226636.png)

### 为什么 QoS 1 消息会重复？

对于发送方来说，没收到 PUBACK 报文分为以下两种情况：

1. PUBLISH 未到达接收方
2. PUBLISH 已经到达接收方，接收方的 PUBACK 报文还未到达发送方

在第一种情况下，发送方虽然重传了 PUBLISH 报文，但是对于接收方来说，实际上仍然仅收到了一次消息。

但是在第二种情况下，在发送方重传时，接收方已经收到过了这个 PUBLISH 报文，这就导致接收方将收到重复的消息。

![MQTT QoS 1 重复消息](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202311122226867.png)

虽然重传时 PUBLISH 报文中的 DUP 标志会被设置为 1，用以表示这是一个重传的报文。但是接收方并不能因此假定自己曾经接收过这个消息，仍然需要将其视作一个全新的消息。

这是因为对于接收方来说，可能存在以下两种情况：

![MQTT QoS 1 重复消息](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202311122226888.png)

第一种情况，发送方由于没有收到 PUBACK 报文而重传了 PUBLISH 报文。此时，接收方收到的前后两个 PUBLISH 报文使用了相同的 Packet ID，并且第二个 PUBLISH 报文的 DUP 标志为 1，此时它确实是一个重复的消息。

第二种情况，第一个 PUBLISH 报文已经完成了投递，1024 这个 Packet ID 重新变为可用状态。发送方使用这个 Packet ID 发送了一个全新的 PUBLISH 报文，但这一次报文未能到达对端，所以发送方后续重传了这个 PUBLISH 报文。这就使得虽然接收方收到的第二个 PUBLISH 报文同样是相同的 Packet ID，并且 DUP 为 1，但确实是一个全新的消息。

由于我们无法区分这两种情况，所以只能让接收方将这些 PUBLISH 报文都当作全新的消息来处理。因此当我们使用 QoS 1 时，消息的重复在协议层面上是无法避免的。

甚至在比较极端的情况下，例如 Broker 从发布方收到了重复的 PUBLISH 报文，而在将这些报文转发给订阅方的过程中，再次发生重传，这将导致订阅方最终收到更多的重复消息。

在下图表示的例子中，虽然发布者的本意只是发布一条消息，但对接收方来说，最终却收到了三条相同的消息：

![MQTT QoS 1 重复消息](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202311122226881.png)

以上，就是 QoS 1 保证消息到达带来的副作用。

## QoS 2 - 只交付一次

QoS 2 解决了 QoS 0、1 消息可能丢失或者重复的问题，但相应地，它也带来了最复杂的交互流程和最高的开销。每一次的 QoS 2 消息投递，都要求发送方与接收方进行至少两次请求/响应流程。

![MQTT QoS 2](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202311122226785.png)

1. 首先，发送方存储并发送 QoS 为 2 的 PUBLISH 报文以启动一次 QoS 2 消息的传输，然后等待接收方回复 PUBREC 报文。这一部分与 QoS 1 基本一致，只是响应报文从 PUBACK 变成了 PUBREC。
2. 当发送方收到 PUBREC 报文，即可确认对端已经收到了 PUBLISH 报文，发送方将**不再需要重传**这个报文，并且也**不能再重传**这个报文。所以此时发送方可以删除本地存储的 PUBLISH 报文，然后发送一个 PUBREL 报文，通知对端自己准备将本次使用的 Packet ID 标记为可用了。与 PUBLISH 报文一样，我们需要确保 PUBREL 报文到达对端，所以也需要一个响应报文，并且这个 PUBREL 报文需要被存储下来以便后续重传。
3. 当接收方收到 PUBREL 报文，也可以确认在这一次的传输流程中不会再有重传的 PUBLISH 报文到达，因此回复 PUBCOMP 报文表示自己也准备好将当前的 Packet ID 用于新的消息了。
4. 当发送方收到 PUBCOMP 报文，这一次的 QoS 2 消息传输就算正式完成了。在这之后，发送方可以再次使用当前的 Packet ID 发送新的消息，而接收方再次收到使用这个 Packet ID 的 PUBLISH 报文时，也会将它视为一个全新的消息。

### 为什么 QoS 2 消息不会重复？

QoS 2 消息保证不会丢失的逻辑与 QoS 1 相同，所以这里我们就不再重复了。

与 QoS 1 相比，QoS 2 新增了 PUBREL 报文和 PUBCOMP 报文的流程，也正是这个新增的流程带来了消息不会重复的保证。

在我们更进一步之前，我们先快速回顾一下 QoS 1 消息无法避免重复的原因。

当我们使用 QoS 1 消息时，对接收方来说，回复完 PUBACK 这个响应报文以后 Packet ID 就重新可用了，也不管响应是否确实已经到达了发送方。所以就无法得知之后到达的，携带了相同 Packet ID 的 PUBLISH 报文，到底是发送方因为没有收到响应而重传的，还是发送方因为收到了响应所以重新使用了这个 Packet ID 发送了一个全新的消息。

![MQTT QoS 1 PUBACK](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202311122226725.png)

所以，消息去重的关键就在于，通信双方如何正确地同步释放 Packet ID，换句话说，不管发送方是重传消息还是发布新消息，一定是和对端达成共识了的。

而 QoS 2 中增加的 PUBREL 流程，正是提供了帮助通信双方协商 Packet ID 何时可以重用的能力。

![MQTT QoS 2 PUBREL](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202311122226384.png)

QoS 2 规定，发送方只有在收到 PUBREC 报文之前可以重传 PUBLISH 报文。一旦收到 PUBREC 报文并发出 PUBREL 报文，发送方就进入了 Packet ID 释放流程，不可以再使用当前 Packet ID 重传 PUBLISH 报文。同时，在收到对端回复的 PUBCOMP 报文确认双方都完成 Packet ID 释放之前，也不可以使用当前 Packet ID 发送新的消息。

![MQTT QoS 2 PUBREC](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202311122226417.png)

因此，对于接收方来说，能够以 PUBREL 报文为界限，凡是在 PUBREL 报文之前到达的 PUBLISH 报文，都必然是重复的消息；而凡是在 PUBREL 报文之后到达的 PUBLISH 报文，都必然是全新的消息。

一旦有了这个前提，我们就能够在协议层面完成 QoS 2 消息的去重。