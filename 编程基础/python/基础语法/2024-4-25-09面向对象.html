<!DOCTYPE html>

<html lang="zh-CN"  class="">


<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="keywords" content="">
    
    
    <meta name="description" content="">
    
    <meta name="generator" content="teedoc">
    <meta name="theme" content="teedoc-plugin-theme-default">
    
        
        <meta name="markdown-generator" content="teedoc-plugin-markdown-parser">
        
        <script>
MathJax = {"loader": {"load": ["output/svg"]}, "tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]]}, "svg": {"fontCache": "global"}};
</script>
        
        <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        
        <meta name="html-generator" content="teedoc-plugin-jupyter-notebook-parser">
        
        <script src="/note/static/js/theme_default/pre_main.js"></script>
        
        <link rel="stylesheet" href="/note/static/css/theme_default/prism.min.css" type="text/css"/>
        
        <link rel="stylesheet" href="/note/static/css/theme_default/viewer.min.css" type="text/css"/>
        
        <link rel="stylesheet" href="/note/static/css/theme_default/dark.css" type="text/css"/>
        
        <link rel="stylesheet" href="/note/static/css/theme_default/light.css" type="text/css"/>
        
        <script src="/note/static/js/theme_default/jquery.min.js"></script>
        
        <script src="/note/static/js/theme_default/split.js"></script>
        
        <link rel="stylesheet" href="/note/static/css/search/style.css" type="text/css"/>
        
        <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4d52982572d5512e9762879ebf063c86";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
        
        <meta name="blog-generator" content="teedoc-plugin-blog">
        
        <link rel="stylesheet" href="/note/static/css/gitalk/gitalk.css" type="text/css"/>
        
        <link rel="stylesheet" href="/note/static/css/gitalk/custom_gitalk.css" type="text/css"/>
        
        <link rel="stylesheet" href="/note/static/css/custom.css" type="text/css"/>
        
    
    
    <title>面向对象 - XvSenfeng's Note</title>
    
    <script type="text/javascript">js_vars = {"teedoc-plugin-ad-hint": {"type": "hint", "label": "☆", "content": "这是一个支持国际化的消息示例</br>喜欢项目请<a target=\"_blank\" href=\"https://github.com/teedoc/teedoc\">点下 ☆ star </a>哦~🦀🦀", "show_times": 2, "show_after_s": 432000, "date": "2021-11-16 14:40", "color": "#a0421d", "link_color": "#e53935", "link_bg_color": "#e6ae5c", "bg_color": "#ffcf89", "color_hover": "white", "bg_color_hover": "#f57c00", "close_color": "#eab971"}}</script>
    <script type="text/javascript">metadata = {"tags": ["python基础"], "date": "2026-02-05", "update": [], "ts": 1770297751, "author": "", "brief": "", "cover": "", "layout": "post"}</script>
</head>


<body class="type_doc">
    
    <div id="navbar">
        <div id="navbar_menu">
            <a class="site_title" href="/note/">
                
                    <img class="site_logo" src="/note/static/image/logo.png" alt="XvSenfeng logo">
                
                
                    <h2>XvSenfeng</h2>
                
        </a>
            <a id="navbar_menu_btn"></a>
        </div>
        <div id="navbar_items">
            <div>
                <ul id="nav_left">
<li class=""><a  href="/note/blog/">博客</a></li>
<li class=""><a  href="/note/Linux/">Linux</a></li>
<li class=""><a  href="/note/代码分析/">代码分析</a></li>
<li class=""><a  href="/note/使用软件/">使用软件</a></li>
<li class=""><a  href="/note/嵌入式/">嵌入式</a></li>
<li class=""><a  href="/note/手机安卓/">手机安卓</a></li>
<li class=""><a  href="/note/机器学习/">机器学习</a></li>
<li class="active"><a  href="/note/编程基础/">编程基础</a></li>
<li class=""><a  href="/note/网络/">网络</a></li>
</ul>

            </div>
            <div>
                <ul id="nav_right">
<li class=""><a target="_blank" href="https://github.com/XuSenfeng/note/">github</a></li>
</ul>

                <ul class="nav_plugins"><li><a id="google_translate_element"><img class="icon" src="/note/static/image/google_translate/translate.svg"/>Translate</a></li></ul><ul class="nav_plugins"><li><a id="themes" class="light"></a></li></ul><ul class="nav_plugins"><li><a id="search"><span class="icon"></span><span class="placeholder">搜索</span>
                            <div id="search_hints">
                                <span id="search_input_hint">输入关键词，多关键词空格隔开</span>
                                <span id="search_loading_hint">正在加载，请稍候。。。</span>
                                <span id="search_download_err_hint">下载文件失败，请刷新重试或检查网络</span>
                                <span id="search_other_docs_result_hint">来自其它文档的结果</span>
                                <span id="search_curr_doc_result_hint">当前文档搜索结果</span>
                            </div></a></li></ul>
            </div>
        </div>
    </div>
    
    <div id="wrapper">
        <div id="sidebar_wrapper">
            <div id="sidebar">
                <div id="sidebar_title">
                    
                </div>
                <ul class="show">
<li class="not_active with_link"><a href="/note/编程基础/index.html"><span class="label">README</span><span class=""></span></a></li>
<li class="not_active no_link"><a><span class="label">C#</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/编程基础/no_translate.html?ref=C.html&from=/编程基础/C.html"><span class="label">2023-6-24-1.C#</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">C和指针</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/编程基础/C和指针/2022-7-25-C语言环境.html"><span class="label">2022-7-25-C语言环境</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/C和指针/2022-7-25-字符串操作.html"><span class="label">2022-7-25-字符串操作</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/C和指针/2022-7-25-操作符和表达式.html"><span class="label">2022-7-25-操作符和表达式</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/C和指针/2022-7-25-数据.html"><span class="label">2022-7-25-数据</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/C和指针/2022-7-25-词法规则.html"><span class="label">2022-7-25-词法规则</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/C和指针/2022-7-25-语句.html"><span class="label">2022-7-25-语句</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/C和指针/2022-7-26-函数.html"><span class="label">2022-7-26-函数</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/C和指针/2022-7-26-指针.html"><span class="label">2022-7-26-指针</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/C和指针/2022-7-26-数组.html"><span class="label">2022-7-26-数组</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/C和指针/2022-7-26-表达式.html"><span class="label">2022-7-26-表达式</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/C和指针/2022-7-27-动态内存分配.html"><span class="label">2022-7-27-动态内存分配</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/C和指针/2022-7-27-字符串字符字节.html"><span class="label">2022-7-27-字符串字符字节</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/C和指针/2022-7-27-结构体和指针.html"><span class="label">2022-7-27-结构体和指针</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/C和指针/2022-7-27-结构和联合.html"><span class="label">2022-7-27-结构和联合</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/C和指针/2022-7-28-预处理器.html"><span class="label">2022-7-28-预处理器</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/C和指针/2022-7-28-高级指针.html"><span class="label">2022-7-28-高级指针</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/C和指针/2022-7-29-输入输出函数.html"><span class="label">2022-7-29-输入输出函数</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/C和指针/2022-7-30-标准库函数.html"><span class="label">2022-7-30-标准库函数</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/C和指针/2022-7-30-经典抽象数据类型.html"><span class="label">2022-7-30-经典抽象数据类型</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/C和指针/2022-7-31-运行时环境.html"><span class="label">2022-7-31-运行时环境</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">C陷阱与缺陷</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/编程基础/C陷阱与缺陷/2022-8-26-函数.html"><span class="label">2022-8-26-函数</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/C陷阱与缺陷/2022-8-27-语义陷阱.html"><span class="label">2022-8-27-语义陷阱</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">c</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/编程基础/c/2023-6-16-c监控.html"><span class="label">2023-6-16-c监控</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/c/2023-6-19-C语言程序设计.html"><span class="label">2023-6-19-C语言程序设计</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">cpp</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/编程基础/cpp/2025-1-1-01C++.html"><span class="label">2025-1-1-01C++</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/cpp/2025-1-1-02内存.html"><span class="label">2025-1-1-02内存</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/cpp/2025-1-22-其他扩展语法.html"><span class="label">2025-1-22-其他扩展语法</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/cpp/2025-1-26-多线程.html"><span class="label">2025-1-26-多线程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/cpp/2025-1-6-03模板和STL.html"><span class="label">2025-1-6-03模板和STL</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">go</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/编程基础/go/2022-8-26-函数.html"><span class="label">2022-8-26-函数</span><span class=""></span></a></li>
</ul>
</li>
<li class="active_parent no_link"><a><span class="label">python</span><span class="sub_indicator"></span></a><ul class="show">
<li class="active_parent no_link"><a><span class="label">基础语法</span><span class="sub_indicator"></span></a><ul class="show">
<li class="not_active with_link"><a href="/note/编程基础/python/基础语法/2023-6-15-修饰器.html"><span class="label">2023-6-15-修饰器</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/基础语法/2023-9-23-01基础运算.html"><span class="label">2023-9-23-01基础运算</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/基础语法/2023-9-24-02函数及变量.html"><span class="label">2023-9-24-02函数及变量</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/基础语法/2024-4-23-03虚拟环境.html"><span class="label">2024-4-23-03虚拟环境</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/基础语法/2024-4-23-04常用函数.html"><span class="label">2024-4-23-04常用函数</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/基础语法/2024-4-24-05程序获取参数.html"><span class="label">2024-4-24-05程序获取参数</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/基础语法/2024-4-25-06推导式和拆包.html"><span class="label">2024-4-25-06推导式和拆包</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/基础语法/2024-4-25-07引入.html"><span class="label">2024-4-25-07引入</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/基础语法/2024-4-25-08匿名函数.html"><span class="label">2024-4-25-08匿名函数</span><span class=""></span></a></li>
<li class="active with_link"><a href="/note/编程基础/python/基础语法/2024-4-25-09面向对象.html"><span class="label">2024-4-25-09面向对象</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/基础语法/2024-4-26-10文件基本操作.html"><span class="label">2024-4-26-10文件基本操作</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/基础语法/2024-4-27-11OS模块.html"><span class="label">2024-4-27-11OS模块</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/基础语法/2024-4-27-12迭代器.html"><span class="label">2024-4-27-12迭代器</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/基础语法/2024-4-27-13异常处理.html"><span class="label">2024-4-27-13异常处理</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/基础语法/2024-4-27-14生成器.html"><span class="label">2024-4-27-14生成器</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/基础语法/2024-4-28-15闭包.html"><span class="label">2024-4-28-15闭包</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/基础语法/2024-4-30-16深拷贝浅拷贝.html"><span class="label">2024-4-30-16深拷贝浅拷贝</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/基础语法/2024-5-1-17With和上下文管理器.html"><span class="label">2024-5-1-17With和上下文管理器</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/基础语法/2024-5-4-18GIL.html"><span class="label">2024-5-4-18GIL</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/基础语法/2024-5-4-19垃圾回收.html"><span class="label">2024-5-4-19垃圾回收</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/基础语法/2025-1-31-多任务.html"><span class="label">2025-1-31-多任务</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/基础语法/2025-12-19-CPP交互使用.html"><span class="label">2025-12-19-CPP交互使用</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/基础语法/2025-12-19-打包whl文件.html"><span class="label">2025-12-19-打包whl文件</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/基础语法/2025-2-25-yaml.html"><span class="label">2025-2-25-yaml</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/基础语法/2025-3-21-包导入.html"><span class="label">2025-3-21-包导入</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">进阶使用</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active no_link"><a><span class="label">C语言-Cpp接轨</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/编程基础/python/进阶使用/C语言-Cpp接轨/2025-12-10-01-struct.html"><span class="label">2025-12-10-01-struct</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">django</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/编程基础/python/进阶使用/django/2025-7-24-01-Django.html"><span class="label">2025-7-24-01-Django</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/进阶使用/django/2025-7-24-02-创建.html"><span class="label">2025-7-24-02-创建</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/进阶使用/django/2025-7-24-03-路由.html"><span class="label">2025-7-24-03-路由</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/进阶使用/django/2025-7-24-04-视图.html"><span class="label">2025-7-24-04-视图</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/进阶使用/django/2025-7-24-05-配置文件.html"><span class="label">2025-7-24-05-配置文件</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/进阶使用/django/2025-7-26-04-模版.html"><span class="label">2025-7-26-04-模版</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/进阶使用/django/2025-7-28-05-静态文件.html"><span class="label">2025-7-28-05-静态文件</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/进阶使用/django/2025-7-29-06-中间件.html"><span class="label">2025-7-29-06-中间件</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/进阶使用/django/2025-7-29-07-数据库.html"><span class="label">2025-7-29-07-数据库</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/进阶使用/django/2025-7-30-08-进阶数据查询.html"><span class="label">2025-7-30-08-进阶数据查询</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/进阶使用/django/2025-8-1-09-ORM优化.html"><span class="label">2025-8-1-09-ORM优化</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/进阶使用/django/2025-8-2-10-模型扩展.html"><span class="label">2025-8-2-10-模型扩展</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/进阶使用/django/2025-8-2-11-组件.html"><span class="label">2025-8-2-11-组件</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/进阶使用/django/2025-8-3-12-异步.html"><span class="label">2025-8-3-12-异步</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">pyQT</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/编程基础/python/进阶使用/pyQT/2024-5-11-08界面容器.html"><span class="label">2024-5-11-08界面容器</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/进阶使用/pyQT/2024-5-6-01介绍以及安装.html"><span class="label">2024-5-6-01介绍以及安装</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/进阶使用/pyQT/2024-5-6-02控件.html"><span class="label">2024-5-6-02控件</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/进阶使用/pyQT/2024-5-7-03布局.html"><span class="label">2024-5-7-03布局</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/进阶使用/pyQT/2024-5-7-04窗口.html"><span class="label">2024-5-7-04窗口</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/进阶使用/pyQT/2024-5-8-05信号与槽.html"><span class="label">2024-5-8-05信号与槽</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/进阶使用/pyQT/2024-5-8-06QTDesigner.html"><span class="label">2024-5-8-06QTDesigner</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/进阶使用/pyQT/2024-5-8-07线程.html"><span class="label">2024-5-8-07线程</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">简单模块使用</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/编程基础/python/进阶使用/简单模块使用/2024-5-4-01logging日志模块.html"><span class="label">2024-5-4-01logging日志模块</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/进阶使用/简单模块使用/2025-3-15-02fastapi.html"><span class="label">2025-3-15-02fastapi</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">线程</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/编程基础/python/进阶使用/线程/2024-5-10-01多任务.html"><span class="label">2024-5-10-01多任务</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/进阶使用/线程/2024-5-14-02队列.html"><span class="label">2024-5-14-02队列</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/进阶使用/线程/2025-2-20-async.html"><span class="label">2025-2-20-async</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">网络编程</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/编程基础/python/进阶使用/网络编程/2024-5-10-01网络编程.html"><span class="label">2024-5-10-01网络编程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/进阶使用/网络编程/2024-5-10-02Socket.html"><span class="label">2024-5-10-02Socket</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/进阶使用/网络编程/2024-5-12-03软件.html"><span class="label">2024-5-12-03软件</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/python/进阶使用/网络编程/2024-8-20-04MQTT.html"><span class="label">2024-8-20-04MQTT</span><span class=""></span></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">前端</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/编程基础/前端/2024-8-12-04CSS2.html"><span class="label">2024-8-12-04CSS2</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/前端/2024-8-5-01基础知识.html"><span class="label">2024-8-5-01基础知识</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/前端/2024-8-5-02HTML.html"><span class="label">2024-8-5-02HTML</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/前端/2024-8-6-03CSS.html"><span class="label">2024-8-6-03CSS</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">嵌入式C语言</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/编程基础/嵌入式C语言/2022-7-21-__attribute__.html"><span class="label">2022-7-21-__attribute__</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/嵌入式C语言/2022-7-21-内联函数内置内存函数.html"><span class="label">2022-7-21-内联函数内置内存函数</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/嵌入式C语言/2022-7-21-变量指针.html"><span class="label">2022-7-21-变量指针</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/嵌入式C语言/2022-7-21-大小端数据对齐size_t.html"><span class="label">2022-7-21-大小端数据对齐size_t</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/嵌入式C语言/2022-7-21-存储器.html"><span class="label">2022-7-21-存储器</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/嵌入式C语言/2022-7-21-语句表达式define.html"><span class="label">2022-7-21-语句表达式define</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/嵌入式C语言/2022-7-22-Linux中的面向对象思想-封装.html"><span class="label">2022-7-22-Linux中的面向对象思想-封装</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/嵌入式C语言/2022-7-22-main函数的参数.html"><span class="label">2022-7-22-main函数的参数</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/嵌入式C语言/2022-7-22-二级指针.html"><span class="label">2022-7-22-二级指针</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/嵌入式C语言/2022-7-22-代码复用分层思想.html"><span class="label">2022-7-22-代码复用分层思想</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/嵌入式C语言/2022-7-22-函数参数的本质.html"><span class="label">2022-7-22-函数参数的本质</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/嵌入式C语言/2022-7-22-函数指针.html"><span class="label">2022-7-22-函数指针</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/嵌入式C语言/2022-7-22-指针和数组.html"><span class="label">2022-7-22-指针和数组</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/嵌入式C语言/2022-7-22-面向对象编程基础.html"><span class="label">2022-7-22-面向对象编程基础</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/嵌入式C语言/2022-7-23-goto关键字.html"><span class="label">2022-7-23-goto关键字</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/嵌入式C语言/2022-7-23-可重入函数.html"><span class="label">2022-7-23-可重入函数</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/嵌入式C语言/2022-7-23-多任务.html"><span class="label">2022-7-23-多任务</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/嵌入式C语言/2022-7-23-头文件剖析.html"><span class="label">2022-7-23-头文件剖析</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/嵌入式C语言/2022-7-23-异步通信模式.html"><span class="label">2022-7-23-异步通信模式</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/嵌入式C语言/2022-7-23-操作系统基本原理.html"><span class="label">2022-7-23-操作系统基本原理</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/嵌入式C语言/2022-7-23-模块化编程.html"><span class="label">2022-7-23-模块化编程</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/嵌入式C语言/2022-7-23-模块进阶.html"><span class="label">2022-7-23-模块进阶</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/嵌入式C语言/2022-7-23-模块间通讯.html"><span class="label">2022-7-23-模块间通讯</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/嵌入式C语言/2022-7-24-MMU内存管理单元.html"><span class="label">2022-7-24-MMU内存管理单元</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/嵌入式C语言/2022-7-24-中断.html"><span class="label">2022-7-24-中断</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/嵌入式C语言/2022-7-24-寄存器操作.html"><span class="label">2022-7-24-寄存器操作</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/嵌入式C语言/2022-7-24-嵌入式启动.html"><span class="label">2022-7-24-嵌入式启动</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/嵌入式C语言/2022-7-24-文件系统.html"><span class="label">2022-7-24-文件系统</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/嵌入式C语言/2022-7-24-系统调用.html"><span class="label">2022-7-24-系统调用</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/嵌入式C语言/2022-7-24-进程线程协程.html"><span class="label">2022-7-24-进程线程协程</span><span class=""></span></a></li>
</ul>
</li>
<li class="not_active no_link"><a><span class="label">算法基础</span><span class="sub_indicator sub_indicator_collapsed"></span></a><ul class="">
<li class="not_active with_link"><a href="/note/编程基础/算法基础/2022-7-31-高级数据结构.html"><span class="label">2022-7-31-高级数据结构</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/算法基础/2024-12-31-01快速排序.html"><span class="label">2024-12-31-01快速排序</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/算法基础/2024-12-31-02哈希表.html"><span class="label">2024-12-31-02哈希表</span><span class=""></span></a></li>
<li class="not_active with_link"><a href="/note/编程基础/算法基础/2024-12-31-03贪心算法.html"><span class="label">2024-12-31-03贪心算法</span><span class=""></span></a></li>
</ul>
</li>
</ul>

            </div>
        </div>
        <div id="article">
            <div id="menu_wrapper">
                <div id="menu">
                </div>
            </div>
            <div id="content_wrapper">
                <div id="content_body">
                    <div id="article_head">
                        <div id="article_title">
                            
                            <h1>面向对象</h1>
                            
                        </div>
                        <div id="article_tags">
                            <ul>
                            
                                <li>python基础</li>
                            
                            </ul>
                        </div>
                        <div id="article_info">
                        <div id="article_info_left">
                            <span class="article_author">
                                
                            </span>
                            
                                <span class="article_date" title="最后修改日期： 2026-02-05">
                                    2026-02-05
                                </span>
                            
                        </div>
                        <div id="article_info_right">
                            
                            <div id="source_link">
                                <a href="https://github.com/XuSenfeng/note/tree/master/doc/编程基础/python/基础语法/2024-4-25-09面向对象.md" target="_blank">
                                    编辑本页
                                </a>
                            </div>
                            
                        </div>
                        </div>
                    </div>
                    <div id="article_tools">
                        <span></span>
                        <span id="toc_btn"></span>
                    </div>
                    <div id="update_history">
                        
                    </div>
                    <div id="article_content">
                        
                            <h1 id="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1">面向对象</h1>
<p>可以把数据以及功能打包为一个整体</p>
<p>类:</p>
<ul>
<li>名称</li>
<li>属性(数据)</li>
<li>方法</li>
</ul>

<pre class="language-python"><code class="language-python">class Person:
    def __init__(self, name, age):
        self.age = age
        self.name = name
    def print_info:
        print(self.name, self.age)
</code></pre>
<h2 id="%E5%AE%9A%E4%B9%89">定义</h2>

<pre class="language-python"><code class="language-python">#经典类
class Dog1:
    pass

# 新式类
class Dog2(object):
    pass
</code></pre>
<blockquote>
<p>在python3里面这都一样, 用于继承</p>
</blockquote>
<h3 id="self">self</h3>
<p>self指向当前的这一个对象自己, python会自动传递当前的对象</p>
<p>self的名字可以不叫self, 但是推荐使用self, 会使用类的方法的第一个参数</p>
<h3 id="%E5%B1%9E%E6%80%A7">属性</h3>

<pre class="language-python"><code class="language-python">class Dog1:
    def set_name(self, name):
        self.name = name
    def print_name(self):
        print(self.name)

class Dog2:
    pass

dog1 = Dog1()
# dog1.set_name('dog1')
dog1.print_name()
</code></pre>
<blockquote>
<p>这一个属性会在调用<code>dog1.set_name('dog1')</code>的时候才会创建, 不调用的时候使用这一个变量会出问题</p>
<p>也可以使用<code>dog1.name = &quot;dog1&quot;</code>来进行指定, 但是一般不使用这一个方式</p>
</blockquote>
<h4 id="%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7">私有属性</h4>
<p>普通的属性可以在外部进行修改, 这种方式一般是不希望出现的</p>
<p>可以在变量名前面加两个<code>__</code>进行设置</p>

<pre class="language-python"><code class="language-python">class Dog1:
    def __init__(self, name):
        self.__name = name
    def print_name(self):
        print(self.__name)

dog = Dog1(&quot;dog1&quot;)
print(dog.__name)
</code></pre>
<blockquote>

<pre class="language-bash"><code class="language-bash">PS E:\JHY\python\2024-4-22&gt; python -u &quot;e:\JHY\python\2024-4-22\main.py&quot;
Traceback (most recent call last):
  File &quot;e:\JHY\python\2024-4-22\main.py&quot;, line 9, in &lt;module&gt;
    print(dog.__name)
AttributeError: 'Dog1' object has no attribute '__name'
</code></pre>
</blockquote>

<pre class="language-python"><code class="language-python">dog = Dog1(&quot;dog1&quot;)
dog.__name = &quot;dog2&quot;
dog.print_name()
</code></pre>
<blockquote>
<p>这样实际也不能修改这一个变量, 打印的还是<code>dog1</code></p>
</blockquote>
<p>实际使用的时候可以通过_ClassName__name进行调用, 但是不建议使用</p>

<pre class="language-python"><code class="language-python">dog = Dog1(&quot;dog1&quot;)
dog._Dog1__name = &quot;dog2&quot;
dog.print_name()
</code></pre>
<blockquote>
<p>python实际是对这一个变量进行了一个重命名</p>
</blockquote>
<h3 id="%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95">私有方法</h3>
<p>外部不能直接调用的方法</p>
<p>在函数名的前面加一个<code>__</code></p>
<h2 id="%E7%BB%A7%E6%89%BF">继承</h2>
<p>一个新的类里面有之前的一个类里面的数据, 这时候可以使用继承的方式</p>

<pre class="language-python"><code class="language-python">class NewClass(OldClass1, OldClass2, ...):
    pass
</code></pre>
<blockquote>
<p>实际继承的时候可以有多个类</p>
</blockquote>
<p>继承获取的方法可以重写进行覆盖(方法的名字需要一样)</p>

<pre class="language-python"><code class="language-python">class Parent(object):
    x = 1

class son1(Parent):
    pass

class son2(Parent):
    pass

print(Parent.x, son1.x, son2.x)
son1.x = 2			# 这一个实际是一个定义
print(Parent.x, son1.x, son2.x)
Parent.x = 3
print(Parent.x, son1.x, son2.x)
</code></pre>
<blockquote>

<pre class="language-bash"><code class="language-bash">PS E:\JHY\python\2024-4-22&gt; python -u &quot;e:\JHY\python\2024-4-22\main.py&quot;
1 1 1
1 2 1
3 2 3
</code></pre>
<p>在类里面的变量是使用字典的方式进行记录的, 在当前的类里面没有找到的话会从祖先的类里面找, 子类里面重写会创建一个新的变量在他的里面记录这一个新的值, 不会影响父类里面的值</p>
</blockquote>
<h3 id="super">super</h3>
<p>有可能存在父类的方法不可以满足子类的需求, 但是不是需要全部重写, 而是加了一部分新的数据, 全部重写会出现代码的冗余</p>
<p>可以重写的时候调用一下父类的方法</p>

<pre class="language-python"><code class="language-python">class Chile(Father):
    def Father_func():
        super.Father_func()
        子类的新的处理
</code></pre>
<blockquote>
<p>也可以使用<code>Father.Father_func()</code>, 但是使用这一个方法的时候会导致多继承的时候可能有的函数会被多次调用, 如果没有相同的祖先, 这一个就不会出现问题</p>
</blockquote>

<pre class="language-python"><code class="language-python">class Father(object):
    def __init__(self, name):
        print(&quot;Father&quot;)
        self.name = name

class Son1(Father):
    def __init__(self, name):
        print(&quot;Son1 Begin&quot;)
        super().__init__(name)
        print(&quot;Son1 End&quot;)

class Son2(Father):
    def __init__(self, name):
        print(&quot;Son2 Begin&quot;)
        super().__init__(name)
        print(&quot;Son2 End&quot;)

class GrandSon(Son1, Son2):
    def __init__(self, name):
        print(&quot;GrandSon&quot;)
        super().__init__(name)
        print(&quot;GrandSon End&quot;)

grandson = GrandSon(&quot;Shi&quot;)
</code></pre>
<blockquote>

<pre class="language-bash"><code class="language-bash">PS E:\JHY\python\2024-4-22&gt; python -u &quot;e:\JHY\python\2024-4-22\main.py&quot;
GrandSon
Son1 Begin  
Son2 Begin  
Father      
Son2 End    
Son1 End    
GrandSon End
</code></pre>
<p>这一个调用的时候需要计算出来实际调用的是哪一个父类, python里面实际使用了一个C3算法</p>
<p>可以使用<code>print(GrandSon.__mro__)</code>查看实际调用的顺序, 每一次遇到一个super会进入下一层的函数里</p>
<p><code>(&lt;class '__main__.GrandSon'&gt;, &lt;class '__main__.Son1'&gt;, &lt;class '__main__.Son2'&gt;, &lt;class '__main__.Father'&gt;, &lt;class 'object'&gt;)</code></p>
<p>使用这一个的时候会出现一个问题: 多进程的时候传入的参数的个数的问题, 这一个的顺序是不一定的, 所以传递的时候需要把所有的参数都传递</p>
</blockquote>
<h2 id="%E5%A4%9A%E6%80%81">多态</h2>
<p>在python里面不是很明显</p>
<p>多态是指一类事物有多种形态，比如动物类，可以有猫，狗，猪等等。（一个抽象类有多个子类，因而多态的概念依赖于继承）</p>
<p>多态性是指具有不同功能的函数可以使用相同的函数名，这样就可以用一个函数名调用不同内容的函数。在面向对象方法中一般是这样表述多态性：向不同的对象发送同一条消息，不同的对象在接收时会产生不同的行为（即方法）。也就是说，每个对象可以用自己的方式去响应共同的消息。所谓消息，就是调用函数，不同的行为就是指不同的实现，即执行不同的函数。</p>
<blockquote>
<p>实际使用的时候可以传递一系列类过去, 这些类里面有一个相同名字的函数, 但是这一个函数的实际执行的任务不同, 传不同的类会使用不同的行为, 但是实际调用的时候看起来调用的都一样</p>
</blockquote>
<h2 id="%E7%89%B9%E6%AE%8A%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95">特殊属性方法</h2>
<h3 id="%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95">静态方法</h3>
<p>在class里面有一个函数, 实际不需要class这一个参数, 这一个方法就是一个静态方法, 实际使用的时候需要使用参数<code>@staticmethod</code>进行修饰</p>

<pre class="language-python"><code class="language-python">class Class(Object):
    @staticmethod
    def func():
        pass
</code></pre>
<blockquote>
<p>这一个静态方法可以直接使用类名进行调用</p>

<pre class="language-python"><code class="language-python">Class.func()
</code></pre>
</blockquote>
<h3 id="%E7%B1%BB%E5%B1%9E%E6%80%A7">类属性</h3>
<p>通过一个类创建的对象之间的数据是相互隔离的, 但是有的数据需要是共享的</p>
<p>在Class里面, 但是位于def外面的属性是一个类属性</p>

<pre class="language-python"><code class="language-python">class Class(object):
    类属性 = value
</code></pre>
<blockquote>
<p>实际调用的时候需要使用<code>类名.类属性</code>来调用这一个属性</p>
</blockquote>

<pre class="language-python"><code class="language-python">class Tools(object):
    num = 0
    def __init__(self):
        Tools.num += 1
</code></pre>
<blockquote>
<p>类里面的属性实际存储的时候使用的是字典里面的键值对, 所以实际去调用一个参数的时候传给属性拦截器的是一个字符串</p>
</blockquote>
<h3 id="%E7%B1%BB%E6%96%B9%E6%B3%95">类方法</h3>
<p>专门用于对类属性操作的方法, 使用<code>@classmethod</code>, 这个时候传递的参数是<code>cls</code></p>

<pre class="language-python"><code class="language-python">class Tools(object):
    num = 0
    @classmethod
    def add_1(cls):
        cls.num += 1 
    def __init__(self):
        self.add1()
</code></pre>
<blockquote>
<p>实际调用的时候可以使用<code>实例对象.类方法</code>或者<code>类名.类方法</code></p>
<p>记录的时候实际也是一个属性, 指向一个代码段</p>
</blockquote>
<p>可以直接使用<code>实例或者类.名字 = 方法</code>这种方式进行动态添加一个一个方法, 但是这一种方式不会自动传入self参数, 可以使用types进行动态添加方法</p>
<ul>
<li>实例方法</li>
</ul>

<pre class="language-python"><code class="language-python">import types

class Person (object):
    def __init__(self, name=None, age=None):
        self.name = name
        self.age = age

p = Person(&quot;jiao&quot;, 21)

def show_info(self):
    print(&quot;----info----&quot;)

p.show_info = types.MethodType(show_info, p) # 自动把这一个参数传进去
p.show_info()
</code></pre>
<ul>
<li>类方法/静态方法</li>
</ul>
<p>这两个可以直接在加了修饰器以后添加</p>
<h3 id="%E7%B1%BB%E5%AF%B9%E8%B1%A1">类对象</h3>
<p>在python里面定义class的时候这一个定义也是一个对象, 这一个对象里面有类属性等信息, 还有各种方法的代码</p>
<p>创建的实例里面有一个参数<code>__class__</code>, 这一个参数指向这个类对象</p>
<p>实例调用方法的时候会使用这一个类对象, 用于节省空间, 避免代码重复</p>
<blockquote>
<p>可以使用<code>dir(实例对象)</code>查看有哪一些方法, 属性</p>
<p><strong>dir()</strong> 函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表。如果参数包含方法__dir__()，该方法将被调用。如果参数不包含__dir__()，该方法将最大限度地收集参数信息。</p>
</blockquote>
<h2 id="%E5%8F%98%E9%87%8F%E7%89%B9%E6%AE%8A%E5%91%BD%E5%90%8D%E6%96%B9%E6%B3%95">变量特殊命名方法</h2>
<p><code>xx</code>: 共有变量</p>
<p><code>_xx</code>:私有化属性和方法, 使用<code>from module import *</code>禁止导入, 类对象和子类可以使用</p>
<p><code>__xx</code>: 无法在外部直接访问, 私有属性</p>
<p><code>__xx__</code>用户名名空间的魔法对象和属性</p>
<p><code>xx_</code>: 用于避免和python关键字冲突</p>
<h2 id="property%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE">property动态数据</h2>
<p>使用<code>实例对象.属性 = xxx</code>的时候会自动调用一个方法, 一个属性使用的时候是动态生成的, 需要在使用的时候通过一个函数进行生成</p>
<p>在使用=进行赋值的时候也可以使用这一个函数进行数据的检查</p>
<h3 id="%E8%A3%85%E9%A5%B0%E5%99%A8%E4%BD%BF%E7%94%A8">装饰器使用</h3>

<pre class="language-python"><code class="language-python">class Foo(object):
    def func(self):
        print(&quot;fun running...&quot;)

    @property
    def prop(self):
        print(&quot;prop running...&quot;)

foo_boj = Foo()
foo_boj.func()
foo_boj.prop			#这一个调用的时候没有()但是会执行这一个函数
</code></pre>
<p>这一个函数的返回值会作为最后的结果, 可以使用这一个进行产生动态的数据</p>
<h3 id="%E6%96%B0%E5%BC%8F%E7%B1%BB">新式类</h3>

<pre class="language-python"><code class="language-python">class Foo(object):
    def __init__(self) -&gt; None:
        self.aaa = 1

    @property
    def prop(self):
        print(&quot;prop running...&quot;)

    @prop.setter
    def prop(self, value):
        print(&quot;prop setting...&quot;)
        self._prop = value

    @prop.getter
    def prop(self):
        print(&quot;prop getting...&quot;)
        return self._prop

    @prop.deleter
    def prop(self):
        print(&quot;prop deleting...&quot;)
        del self._prop


foo_boj = Foo()

foo_boj.prop = 2
print(foo_boj.prop)
del foo_boj.prop
</code></pre>
<blockquote>

<pre class="language-python"><code class="language-python">PS E:\JHY\python\2024-4-22&gt; python -u &quot;e:\JHY\python\2024-4-22\main.py&quot;
prop setting...
prop getting...
2
prop deleting...
</code></pre>
<p><code>@prop.getter</code>没有定义的时候会使用<code>@property</code>的返回值, 后面两个必须在<code>@property</code>后面使用, 这一个属性是必须有的</p>
</blockquote>
<h3 id="%E5%8F%A6%E4%B8%80%E7%A7%8D%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F">另一种调用方式</h3>

<pre class="language-python"><code class="language-python">class Foo(object):
    def __init__(self):
        self.bar = &quot;jiao&quot;
    def get_bar(self):
        return self.bar

    def set_bar(self, value):
        self.bar = value

    BAR = property(get_bar, set_bar, None, &quot;This is a bar&quot;)

obj = Foo()
result = obj.BAR
print(result) 
obj.BAR = &quot;haoyang&quot;
print(obj.BAR)
print(Foo.BAR.__doc__)
</code></pre>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202405031126476.png" alt="image-20240503112644197" /></p>
<p>第四个参数是一个字符串, 使用<code>类名.属性.__doc__</code>可以获取</p>
<blockquote>

<pre class="language-bash"><code class="language-bash">PS E:\JHY\python\2024-4-22&gt; python -u &quot;e:\JHY\python\2024-4-22\main.py&quot;
jiao
haoyang
This is a bar
</code></pre>
<p>这一个使用<code>+=</code>进行赋值的时候相当于<code>obj.BAR = obj.BAR + value</code>, 所以实际调用的时候会使用一次获取以及一次写入</p>
</blockquote>
<ul>
<li>实际使用实例</li>
</ul>
<p>Django框架里面的property里面属性使用的就是这一个</p>
<h3 id="%E4%B8%8D%E8%B6%B3">不足</h3>
<p>如果有多个属性需要设置的时候, 这里面需要实现很多的函数</p>
<h2 id="%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%E9%9B%86%E5%90%88">内建函数集合</h2>
<h3 id="%3Ccode%3E__init__%3C/code%3E%E5%BC%95%E5%85%A5"><code>__init__</code>引入</h3>
<p>创建的时候会调用的函数</p>

<pre class="language-python"><code class="language-python">class Person:
    def __init__(self, name, age):
        self.age = age
        self.name = name
    def print_info:
        print(self.name, self.age)
</code></pre>
<h3 id="%3Ccode%3E__str__%3C/code%3E%E6%89%93%E5%8D%B0"><code>__str__</code>打印</h3>
<p>这一个函数的返回值是使用print函数打印这一个类的时候结果</p>
<h3 id="%3Ccode%3E__call__%3C/code%3E"><code>__call__</code></h3>
<p>如果使用一个类创建了一个对象, 直接使用这一个对象当函数调用会执行这一个函数</p>
<h3 id="%3Ccode%3E__slots__%3C/code%3E%E9%9D%99%E6%80%81"><code>__slots__</code>静态</h3>
<p>添加这一个属性可以使得这一个类不能在运行的时候进行添加属性, 只可以使用声明了的属性</p>

<pre class="language-python"><code class="language-python">class Person(object):
    __slots__ = (&quot;name&quot;, &quot;age&quot;)

p = Person()
p.name = &quot;John&quot;
p.age = 20
print(p.name, p.age)
p.address = &quot;henan&quot;
print(p.address)
</code></pre>
<blockquote>

<pre class="language-bash"><code class="language-bash">PS E:\JHY\python\2024-4-22&gt; python -u &quot;e:\JHY\python\2024-4-22\main.py&quot;
John 20
Traceback (most recent call last):
File &quot;e:\JHY\python\2024-4-22\main.py&quot;, line 8, in &lt;module&gt;
 p.address = &quot;henan&quot;
AttributeError: 'Person' object has no attribute 'address'
</code></pre>
<p>这一个效果只在定义他的类里面有效, 不会进行继承</p>
</blockquote>

<pre class="language-python"><code class="language-python">import math

class Person:
    # 初始化
    def __init__(self, name, age):
        self.age = age
        self.name = name

    def print_info(self):
        print(self.name, self.age)
    
    # print直接打印的时候
    def __str__(self):
        return f'{self.name} is {self.age} years old'

    def __repr__(self):
        return f'Person({self.name}, {self.age})'

    def __eq__(self, other):
        return self.age == other.age

    def __lt__(self, other):
        return self.age &lt; other.age

    def __gt__(self, other):
        return self.age &gt; other.age

    def __le__(self, other):
        return self.age &lt;= other.age

    def __ge__(self, other):
        return self.age &gt;= other.age

    def __ne__(self, other):
        return self.age != other.age

    def __add__(self, other):
        return self.age + other.age

    def __sub__(self, other):
        return self.age - other.age

    def __mul__(self, other):
        return self.age * other.age

    def __truediv__(self, other):
        return self.age / other.age

    def __floordiv__(self, other):
        return self.age // other.age

    def __mod__(self, other):
        return self.age % other.age

    def __pow__(self, other):
        return self.age ** other.age

    def __and__(self, other):
        return self.age &amp; other.age

    def __or__(self, other):    
        return self.age | other.age

    def __xor__(self, other):
        return self.age ^ other.age

    def __lshift__(self, other):
        return self.age &lt;&lt; other.age

    def __rshift__(self, other):
        return self.age &gt;&gt; other.age

    def __neg__(self):
        return -self.age

    def __pos__(self):
        return +self.age

    def __abs__(self):
        return abs(self.age)

    def __invert__(self):
        return ~self.age

    def __round__(self, n=0):
        return round(self.age, n)

    def __floor__(self):
        return math.floor(self.age)

    def __ceil__(self):
        return math.ceil(self.age)

    def __trunc__(self):
        return math.trunc(self.age)

    def __index__(self):
        return self.age

    def __len__(self):
        return len(self.name)

    def __contains__(self, item):
        return item in self.name

    def __getitem__(self, key):
        return self.name[key]

    def __setitem__(self, key, value):
        self.name[key] = value

    def __delitem__(self, key):
        del self.name[key]

    def __iter__(self):
        return iter(self.name)

    def __reversed__(self):
        return reversed(self.name)

    def __next__(self):
        return next(self.name)

    def __hash__(self):
        return hash(self.name)

    def __call__(self):
        return self.print_info()

    def __enter__(self):
        print('Entering')

    def __exit__(self, exc_type, exc_value, traceback):
        print('Exiting')

    def __del__(self):
        print('Deleting')

p1 = Person('John', 30)
p2 = Person('Jane', 25)

p1.print_info()

print(p1 == p2)
print(p1 &lt; p2)
print(p1 &gt; p2)
print(p1 &lt;= p2)
print(p1 &gt;= p2)
print(p1 != p2)
print(p1 + p2)
print(p1 - p2)
print(p1 * p2)
print(p1 / p2)
print(p1 // p2)
print(p1 % p2)
print(p1 ** p2)
print(p1 &amp; p2)
print(p1 | p2)
print(p1 ^ p2)
print(p1 &lt;&lt; p2)
print(p1 &gt;&gt; p2)
print(-p1)
print(+p1)
print(abs(p1))
print(~p1)
print(round(p1, 1))
print(math.floor(p1))
print(math.ceil(p1))
print(math.trunc(p1))
print(hash(p1))
p1()
with p1:
    pass
del p1
</code></pre>

<pre class="language-bash"><code class="language-bash">John 30
False
False
True
False
True
True
55
5
750
1.2
1
5
8472886094430000000000000000000000000
24
31
7
1006632960
0
-30
30
30
-31
30
30
30
30
2252686827583093840
John 30
Entering
Exiting
Deleting
Deleting
</code></pre>
<table>
<thead>
<tr>
  <th style="text-align:center">常用的属性</th>
  <th style="text-align:center">说明</th>
  <th style="text-align:center">触发</th>
</tr>
</thead>
<tbody>
<tr>
  <td style="text-align:center"><code>__init__</code></td>
  <td style="text-align:center">构建初始化的时候</td>
  <td style="text-align:center">初见实际赋值的时候调用, 初始化new创建的实例</td>
</tr>
<tr>
  <td style="text-align:center"><code>__new__</code></td>
  <td style="text-align:center">生成的实例时候</td>
  <td style="text-align:center">创建实际时, 最先调用, 返回实例</td>
</tr>
<tr>
  <td style="text-align:center"><code>__class__</code></td>
  <td style="text-align:center">实例所在的类</td>
  <td style="text-align:center"><code>实例.__class__</code></td>
</tr>
<tr>
  <td style="text-align:center"><code>__str__</code></td>
  <td style="text-align:center">实例的字符串显示, 可读性</td>
  <td style="text-align:center">print打印的时候显示</td>
</tr>
<tr>
  <td style="text-align:center"><code>__repr__</code></td>
  <td style="text-align:center">实例的字符串显示, 准确性</td>
  <td style="text-align:center">print(repr(实例类))或print直接调用, 优先级比较高</td>
</tr>
<tr>
  <td style="text-align:center"><code>__del__</code></td>
  <td style="text-align:center">析构(删除的时候执行)</td>
  <td style="text-align:center">del实例</td>
</tr>
<tr>
  <td style="text-align:center"><code>__dict__</code></td>
  <td style="text-align:center">实例的自定义属性</td>
  <td style="text-align:center"><code>vars(实例.__dict__)</code>, <code>类.__dict__</code>的时候只打印实例属性</td>
</tr>
<tr>
  <td style="text-align:center"><code>__doc__</code></td>
  <td style="text-align:center">类文档, 子类不会继承</td>
  <td style="text-align:center">help(类或实例), 函数会打印他的描述</td>
</tr>
<tr>
  <td style="text-align:center"><code>__getattribute__</code></td>
  <td style="text-align:center">属性访问拦截器</td>
  <td style="text-align:center">访问实例属性的时候, 传入的参数是这一个参数的字符串</td>
</tr>
<tr>
  <td style="text-align:center"><code>__bases__</code></td>
  <td style="text-align:center">类的所有的父类构成的元素</td>
  <td style="text-align:center"><code>print(类名.__bases__)</code></td>
</tr>
</tbody>
</table>
<h3 id="%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7">常用属性</h3>
<ul>
<li><code>__module__</code>: 查看他所在的模块(文件)</li>
<li><code>__class__</code>: 这一个实例使用的类</li>
</ul>
<h3 id="%E7%B1%BB%E5%AD%97%E5%85%B8%E5%AE%9E%E7%8E%B0">类字典实现</h3>
<ul>
<li><code>__getitem__, __setitem__, __delitem__</code>: 使用<code>实例[索引]</code>和的时候会调用这三个</li>
</ul>

<pre class="language-python"><code class="language-python">class Foo(object):
    def __getitem__(self, key):
        print(&quot;__getitem__&quot;, key)

    def __setitem__(self, key, value):
        print(&quot;__setitem__&quot;, key, value)

    def __delitem__(self, key):
        print(&quot;__delitem__&quot;, key)

foo = Foo()
foo[&quot;bar&quot;] = &quot;baz&quot;
del foo[&quot;bar&quot;]
foo[&quot;bar&quot;]
</code></pre>
<blockquote>

<pre class="language-bash"><code class="language-bash">PS E:\JHY\python\2024-4-22&gt; python -u &quot;e:\JHY\python\2024-4-22\main.py&quot;
__setitem__ bar baz
__delitem__ bar
__getitem__ bar
</code></pre>
<p>传递的时候是一个字符串</p>
</blockquote>
<ul>
<li><code>__getslice__, __setslice__, __delslice__</code>: 在python2里面的实现切片</li>
</ul>
<h2 id="%E5%85%83%E7%B1%BB">元类</h2>
<p>一个特殊的类, 用于定义其他的类</p>
<p>元类(type)--&gt;类(类对象)--&gt;实例对象</p>
<p>类的创建也可以使用类似于闭包的方式</p>

<pre class="language-python"><code class="language-python">def choice_class(name):
    if name == &quot;foo&quot;:
        class Foo(object):
            pass
        return Foo
    else:
        class Bar(object):
            pass
        return Bar
</code></pre>
<h3 id="%E4%BD%BF%E7%94%A8type%E5%88%9B%E5%BB%BA%E7%B1%BB">使用type创建类</h3>
<p>type实际有两个功能, 一个是测试类型, 另一个是创建一个类</p>

<pre class="language-python"><code class="language-python">type(类名, 父类的名称组成的元组(可以为空), 包含属性的字典(名称和值))
</code></pre>

<pre class="language-python"><code class="language-python">c_j = type(&quot;JIAO&quot;, (object,), {&quot;name&quot;:&quot;jiao&quot;, &quot;age&quot;:18})
print(type(c_j))

obj_j = c_j()
print(obj_j.name)
print(obj_j.age)
</code></pre>
<blockquote>

<pre class="language-bash"><code class="language-bash">PS E:\JHY\python\2024-4-22&gt; python -u &quot;e:\JHY\python\2024-4-22\main.py&quot;
&lt;class 'type'&gt;
jiao
18
</code></pre>
</blockquote>
<h3 id="%E5%85%83%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89">元类的定义</h3>
<p>函数type实际上就是一个元类, 是python里面用于创建所有类的元类, Python里面的所有的类都是一个对象</p>

<pre class="language-python"><code class="language-python">JIAO = type(&quot;JIAO&quot;, (), {})
print(dir(JIAO))
print(JIAO.__dict__)
print(JIAO.__bases__) # 查看这一个对象继承的类
print(JIAO.__class__) # 查看它构建这一个实例使用的类
</code></pre>
<blockquote>

<pre class="language-bash"><code class="language-bash">PS E:\JHY\python\2024-4-22&gt; python -u &quot;e:\JHY\python\2024-4-22\main.py&quot;
['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 
'__weakref__']
{'__module__': '__main__', '__dict__': &lt;attribute '__dict__' of 'JIAO' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'JIAO' objects&gt;, '__doc__': None}        
(&lt;class 'object'&gt;,)
&lt;class 'type'&gt;
</code></pre>
<p>str, int这一些数据实际使用也是一个type类生成的对象, type这一个类的父类是object</p>
</blockquote>
<h3 id="%E8%87%AA%E5%B7%B1%E5%88%9B%E5%BB%BA%E5%85%83%E7%B1%BB">自己创建元类</h3>

<pre class="language-python"><code class="language-python">class Foo(object, metaclass=xxxxx):
</code></pre>
<blockquote>
<p>在定义一个类的时候没有指定这一个metaclass, 会默认使用type进行创建, 否则使用这一个参数指定的那一个函数进行创建</p>
</blockquote>

<pre class="language-python"><code class="language-python">class UperAttrMetaClass(type):
    #
    def __new__(cls, clsname, bases, dct):
        new_attr = {}
        for name, value in dct.items():
            if not name.startswith('__'):
                new_attr[name.upper()] = value
            else:
                new_attr[name] = value
        return type(clsname, bases, new_attr)


class Foo(metaclass=UperAttrMetaClass):
    bar = 'bip'

print(hasattr(Foo, 'bar'))
print(hasattr(Foo, 'BAR'))

f = Foo()
print(f.BAR)
</code></pre>
<blockquote>

<pre class="language-bash"><code class="language-bash">PS E:\JHY\python\2024-4-22&gt; python -u &quot;e:\JHY\python\2024-4-22\main.py&quot;
False
True
bip
</code></pre>
<p>创建这一个类里面的属性的时候都使用大写</p>
</blockquote>

<pre class="language-python"><code class="language-python">class UperAttrMetaClass(type):
    # 这一个函数会在类被创建的时候被调用
    # clsname: 类的名字
    # bases: 类的基类
    # dct: 类的属性
    # 默认的实现是返回一个新的类
    # 这个新的类会将属性名转换为大写
    def __new__(cls, clsname, bases, dct):
        new_attr = {}
        for name, value in dct.items():
            if not name.startswith('__'):
                new_attr[name.upper()] = value
            else:
                new_attr[name] = value
        return type(clsname, bases, new_attr)


class Foo(metaclass=UperAttrMetaClass):
    bar = 'bip'

print(hasattr(Foo, 'bar'))
print(hasattr(Foo, 'BAR'))

f = Foo()
print(f.BAR)
</code></pre>
<h2 id="%E7%B1%BB%E5%AE%9A%E4%B9%89%E7%9A%84%E8%BF%87%E7%A8%8B">类定义的过程</h2>
<p>python解释器遇到一个类的时候实际会进行一次调用, 为了知道实际有的属性以及方法, 之后把这些方法属性传递到元类type里面, 创建一个对象, 这个就是类对象</p>
<p>如果类里面有放在外面代码的话, 这些代码会执行</p>
<h2 id="%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%AF%B9%E8%B1%A1">描述符对象</h2>
<p>property的实现, <code>@classmethod</code>等的实现都可以使用描述符</p>
<p>在大型的项目里面对MySQL数据库的操作的传媒也可以使用这一个进行实现</p>
<h3 id="%3Ccode%3E__getattr__%3C/code%3E"><code>__getattr__</code></h3>
<p>这一个是在调用一个不存在的属性的时候调用, 访问的属性存在的时候不会调用这一个方法</p>

<pre class="language-python"><code class="language-python">class A:
    def __init__(self, name):
        self.name = name
    # def __getattribute__(self, item):
    #     if item == &quot;name&quot;:
    #         return &quot;haha&quot;
    #     else:
    #         return super().__getattribute__(item)
    def __getattr__(self, item):
        print(&quot;error item %s&quot; % item)

a = A(&quot;jiao&quot;)
print(a.age) # 默认访问这一个的时候会报错, 现在不会
</code></pre>
<blockquote>

<pre class="language-bash"><code class="language-bash">PS E:\JHY\python\2024-4-22&gt; python -u &quot;e:\JHY\python\2024-4-22\main.py&quot;
error item age
None
</code></pre>
<p>默认这一个会产生一个异常</p>
</blockquote>
<h3 id="%3Ccode%3E__getattribute__%3C/code%3E"><code>__getattribute__</code></h3>
<p>访问一个对象的时候会调用这一个函数, 实际使用的时候可以使用这一个函数进行拦截</p>

<pre class="language-python"><code class="language-python">class A:
    def __init__(self, name):
        self.name = name
    def __getattribute__(self, item):
        if item == &quot;name&quot;:
            return &quot;haha&quot;
        else:
            return super().__getattribute__(item)

a = A(&quot;jiao&quot;)
print(a.name)
</code></pre>
<blockquote>

<pre class="language-bash"><code class="language-bash">PS E:\JHY\python\2024-4-22&gt; python -u &quot;e:\JHY\python\2024-4-22\main.py&quot;
haha
</code></pre>
</blockquote>
<blockquote>
<p><strong>注: </strong>这两个同时出现的时候会调用<code>__getattribute__</code></p>
</blockquote>
<h3 id="%E6%8F%8F%E8%BF%B0%E7%AC%A6">描述符</h3>
<p>之前使用的<code>@property</code>这一个属性会使得一个函数的方法属于的类从<code>function</code>变为<code>property</code></p>
<p>这个property实际就是一个描述符, 严格来说, 如果一个类里面有<code>__get__, __set__, __delete__</code>这三个属性里面的任意一个, 那么这一个类实际就是一个描述符对象</p>
<p>如果有一个类, 这一个类里面有类属性对应的是上面的描述符对象创建的实例对象, 这一个类属性就是一个描述符</p>

<pre class="language-python"><code class="language-python">class A:
    def __get__(self, instance, owner):
        print(&quot;---get---&quot;)

    def __set__(self, instance, value):
        print(&quot;---set---&quot;)

    def __delete__(self, instance):
        print(&quot;---delete---&quot;)

class B:
    a = A()     # 这一个是一个描述符

b = B()
print(b.a)      # 调用__get__方法, b为instance, B是owner
b.a = 100       # 调用__set__方法, b为instance, 100是value
del b.a         # 调用__delete__方法
</code></pre>
<blockquote>

<pre class="language-bash"><code class="language-bash">PS E:\JHY\python\2024-4-22&gt; python -u &quot;e:\JHY\python\2024-4-22\main.py&quot;
---get---
None        
---set---   
---delete---
</code></pre>
<p>实际property就是这一个方式实现的</p>
<p>如果直接使用B.a进行调用的时候, instance这一个是None, owner还是B</p>
</blockquote>
<h3 id="%E4%BD%BF%E7%94%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E5%8E%9F%E5%9B%A0">使用描述符的原因</h3>
<p>python里面没有属性, 所以可以使用这一个进行类型检测, 使用的时候比</p>
<h3 id="%E5%AE%9E%E9%99%85%E4%BD%BF%E7%94%A8">实际使用</h3>
<h4 id="%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9B%91%E6%B5%8B">实现数据监测</h4>

<pre class="language-python"><code class="language-python">class NonNegative(object):
    def __init__(self, default):
        self.default = default # 没有某一个参数的时候返回值
        self.data = dict()

    def __get__(self, instance, owner):
        return self.data.get(instance, self.default)

    def __set__(self, instance, value):
        if value &lt; 0:
            raise ValueError('value must be non-negative')
        self.data[instance] = value

class Order(object):
    price = NonNegative(0)
    quantity = NonNegative(1)

    def __init__(self, name, price, quantity):
        self.name = name
        self.price = price
        self.quantity = quantity

    def total(self):
        return self.price * self.quantity


order = Order('apple', 1, 10)
print(order.total())
order.price = 10
print(order.total())
order.price = -10 # ValueError: value must be non-negative
</code></pre>
<h4 id="%E5%AE%9E%E7%8E%B0classmethed">实现classmethed</h4>

<pre class="language-python"><code class="language-python">class classmethed_new(object):
    def __init__(self, func):
        self.func = func

    def __get__(self, instance, owner):
        def new_func(*args, **kwargs):
            return self.func(owner, *args, **kwargs)
        return new_func # 这是一个闭包, 返回实际调用的函数

class A(object):
    M = 100
    def a(self):
        print('A.a')

    @classmethed_new
    def b(cls):		# 这里实际为b = classmethed_new(b)
        print('A.b')
        print(cls.M)


obj = A()
obj.a()
print('-'*20)
obj.b()   # 从b获取一个函数, 之后执行这一个函数, 这时候的参数会给new_func, 之后new_func调用self.func
</code></pre>
<h4 id="%E5%AE%9E%E7%8E%B0%E6%83%B0%E6%80%A7%E8%AE%A1%E7%AE%97">实现惰性计算</h4>
<p>惰性计算就是需要一个值, 这一个值不是提前准备的, 是啥时候需要啥时候计算的</p>

<pre class="language-python"><code class="language-python">class LazyPropety(object):
    def __init__(self, fun) -&gt; None:
        self.fun = fun

    def __get__(self, instance, owner):
        print(&quot;Calling __get__&quot;)
        if instance is None:
            return self
        value = self.fun(instance)
        # setattr(instance, area, value) 把这一个函数的名字指向的对象改为这一个计算值
        setattr(instance, self.fun.__name__, value)
        return value


class ReadOnlyNumber(object):
    def __init__(self, value) -&gt; None:
        self.value = value

    def __get__(self, instance, owner):
        return self.value

    def __set__(self, instance, value):
        raise AttributeError(&quot;Can't set attribute&quot;)


class Circle(object):
    pi = ReadOnlyNumber(3.14)

    def __init__(self, radius):
        self.radius = radius
    # 初始的时候area这一个类保存的是一个描述符
    @LazyPropety
    def area(self):
        print(&quot;Calculating area&quot;)
        return self.pi * self.radius * self.radius


print(&quot;1.----&quot;)
a = Circle(4)
print(&quot;2.----&quot;)
print(a.area)
print(&quot;3.----&quot;)
print(a.area)
print(&quot;4.----&quot;)
</code></pre>
<p><img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202405042026731.png" alt="image-20240504202648657" /></p>
<h3 id="%3Ccode%3E__dict__%3C/code%3E%E4%BD%9C%E7%94%A8"><code>__dict__</code>作用</h3>
<p>使用这一个可是查看一个类里面的已经定义的属性</p>
<p>在python里面所有的属性以及方式使用的都是字典的方式进行存储的, 实力对象里面只有这一个对象的私有属性, 方法以及类的文档在类属性里面</p>
<p>这一个实际调用<code>print(对象.__dict__)</code>, 也可以使用<code>vars(对象)</code>这一个函数进行替代</p>
<p>数据在调用的时候找到的是一个普通的属性的时候会直接调用, 如果这一个属性是一个描述符则会调用他的<code>__get__</code>方法</p>
<p>在获取数据的时候会首先从自己的字典里面获取数据, 没有这一个数据的话查找父类的字典</p>

<pre class="language-python"><code class="language-python">class M:
    def __init__(self) -&gt; None:
        self.x = 1

    def __get__(self, instance, owner):
        print('get')
        return self.x

    def __set__(self, instance, value):
        print('set')
        self.x = value

class AA:
    m = M()
    n = 2
    def __init__(self, score) -&gt; None:
        self.score = score


a = AA(3)
print(a.m)
print(&quot;-&quot; * 20)
print(type(a).__dict__[&quot;m&quot;].__get__(a, AA)) # 这个和上面的那一个等价
</code></pre>
<h3 id="%E6%95%B0%E6%8D%AE%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%92%8C%E9%9D%9E%E6%95%B0%E6%8D%AE%E6%8F%8F%E8%BF%B0%E7%AC%A6">数据描述符和非数据描述符</h3>
<p>同时有<code>__get__</code>和<code>__set__</code>的时候这是一个数据描述符</p>
<p>只有一个<code>__get__</code>的时候是一个非数据的描述符</p>
<p>这两个区别是:</p>
<p>属性名和描述符的名字一样的时候, 访问这一个属性的时候, 如果这一个描述符是数据描述符, 就会优先访问这一个描述符, 不是的话访问这一个属性</p>

<pre class="language-python"><code class="language-python">class M:
    def __init__(self) -&gt; None:
        self.x = 1

    def __get__(self, instance, owner):
        return self.x

    def __set__(self, instance, value):
        self.x = value

class N:
    def __init__(self) -&gt; None:
        self.x = 1

    def __get__(self, instance, owner):
        return self.x

class AA(object):
    m = M()     # 资料描述符
    n = N()     # 非资料描述符

    def __init__(self, m, n) -&gt; None:
        self.m = m # 属性m和描述符m同名, 调用的时候会发生冲突
        # 数据描述符优先级高, 不会创建一个新的m, 会给m描述符赋值
        self.n = n # 属性n和描述符n同名, 这一个会创建一个新的属性

aa = AA(2, 3)
print('-'*20)
print(aa.__dict__)
print(AA.__dict__)
print('-'*20)
print(aa.n)     # 这俩是不一样的, 这个调用属性
print(AA.n)	    # 描述符
print('-'*20)
print(aa.m)     # 这俩是一样的, 都是用的描述符     
print(AA.m)
</code></pre>
<blockquote>

<pre class="language-python"><code class="language-python">PS E:\JHY\python\2024-4-22&gt; python -u &quot;e:\JHY\python\2024-4-22\main.py&quot;
--------------------
{'n': 3}
{'__module__': '__main__', 'm': &lt;__main__.M object at 0x0000015CB8287FD0&gt;, 'n': &lt;__main__.N object at 0x0000015CB8287CD0&gt;, '__init__': &lt;function AA.__init__ at 0x0000015CB82AB0A0&gt;, '__dict__': &lt;attribute '__dict__' of 'AA' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'AA' objects&gt;, '__doc__': None}
--------------------
3
1
--------------------
2
2
</code></pre>
</blockquote>
<h3 id="%E5%8F%AA%E8%AF%BB%E6%8F%8F%E8%BF%B0%E7%AC%A6">只读描述符</h3>
<p>同时定义两个属性, 但是在调用<code>__set__</code>的时候会触发一个AttributeError, 引发一个异常</p>
<h3 id="%E5%AE%9E%E9%99%85%E8%B0%83%E7%94%A8%E7%9A%84%E7%BB%86%E8%8A%82">实际调用的细节</h3>
<p>使用默认的<code>__getattribute__</code>的时候访问一个属性的时候会使用<code>hasattr</code>进行判断是不是有一个属性<code>__get__</code>如果有的话会使用这一个函数的返回值</p>
<p>如果重新这一个函数会使得描述符失效</p>
<p>没有这一个属性的时候调用<code>__getattr__</code></p>
<h3 id="%E6%B3%A8%E6%84%8F">注意</h3>
<ol>
<li>使用描述符的时候这一个必须是一个类属性, 不能是实例属性, 否则的话这一个属性调用的时候不会调用这一个属性的方法</li>
<li>由于使用的是类属性, 所以这一个描述符在实现的时候需要区分不同的实例, 这个时候可以使用instance做一个字典的key</li>
</ol>

                        
                    </div>
                </div>
                <div id="previous_next">
                    <div id="previous">
                        
                        <a href="/note/编程基础/python/基础语法/2024-4-25-08匿名函数.html">
                            <span class="icon"></span>
                            <span class="label">2024-4-25-08匿名函数</span>
                        </a>
                        
                    </div>
                    <div id="next">
                        
                        <a href="/note/编程基础/python/基础语法/2024-4-26-10文件基本操作.html">
                            <span class="label">2024-4-26-10文件基本操作</span>
                            <span class="icon"></span>
                        </a>
                        
                    </div>
                </div>
                <div id="comments-container"></div>
            </div>
            <div id="toc_wrapper">
                <div id="toc">
                    <div id="toc_content">
                            
                    </div>
                </div>
            </div>
        </div>
    </div>
    <a id="to_top" href="#"></a>
    <div id="doc_footer">
        <div id="footer">
            <div id="footer_top">
                <ul>
<li><a>链接</a><ul><li><a target="_blank" href="https://teedoc.neucrack.com">网站使用 teedoc 生成</a></li>
<li><a target="_blank" href="https://neucrack.com">Copyright © 2021 Neucrack</a></li>
<li><a  href="/note/sitemap.xml">网站地图</a></li>
</ul>
</li>
<li><a>源码</a><ul><li><a target="_blank" href="https://github.com/XuSenfeng/note/">github</a></li>
<li><a target="_blank" href="https://github.com/teedoc/teedoc">本网站源文件</a></li>
</ul>
</li>
</ul>

            </div>
            <div id="footer_bottom">
                <ul>
<li><a target="_blank" href="https://beian.miit.gov.cn">渝ICP备19015320号</a></li>
<li><a target="_blank" href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44030602004109">粤公网安备44030602004109号</a></li>
</ul>

            </div>
        </div>
    </div>
    
        <script src="/note/teedoc-plugin-markdown-parser/mermaid.min.js"></script>
    
        <script>mermaid.initialize({startOnLoad:true});</script>
    
        <script type="text/javascript">
                var transLoaded = false;
                var loading = false;
                var domain = "translate.google.com";
                var domainDefault = domain;
                var storeDomain = localStorage.getItem("googleTransDomain");
                if(storeDomain){
                    domain = storeDomain;
                    console.log("load google translate domain from local storage:" + domain);
                }
                function getUrl(domain){
                    if(domain == "/")
                        return "/static/js/google_translate/element.js?cb=googleTranslateElementInit";
                    else
                        return "https://" + domain + "/translate_a/element.js?cb=googleTranslateElementInit";
                }
                var url = getUrl(domain);
                console.log("google translate domain:" + domain + ", url: " + url);
                function googleTranslateElementInit() {
                    new google.translate.TranslateElement({pageLanguage: "auto", layout: google.translate.TranslateElement.InlineLayout.SIMPLE}, 'google_translate_element');
                }
                function loadJS( url, callback ){
                    var script = document.createElement('script');
                    fn = callback || function(){ };
                    script.type = 'text/javascript';
                    if(script.readyState){
                        script.onreadystatechange = function(){
                            if( script.readyState == 'loaded' || script.readyState == 'complete' ){
                                script.onreadystatechange = null;
                                fn();
                            }
                        };
                    }else{
                        script.onload = function(){
                            fn();
                        };
                    }
                    script.src = url;
                    document.getElementsByTagName('head')[0].appendChild(script);
                }
                function removeHint(){
                    var hint = document.getElementById("loadingTranslate");
                    if(hint){
                        hint.remove();
                    }
                }
                var btn = document.getElementById("google_translate_element");
                btn.onclick = function(){
                    if(transLoaded) return;
                    if(loading){
                        var flag = confirm("loading from " + domain + ", please wait, or change domain?");
                        if(flag){
                            newDomain = prompt("domain, default: " + domainDefault + ", now: " + domain);
                            if(newDomain){
                                domain = newDomain;
                                console.log(domain);
                                url = getUrl(domain);
                                loadJS(url, function(){
                                    localStorage.setItem("googleTransDomain", domain);
                                    removeHint()
                                    transLoaded = true;
                                });
                            }
                        }
                        return;
                    }
                    btn.innerHTML = '<span id="loadingTranslate"><img class="icon" src="/note/static/image/google_translate/translate.svg"/>Loading ...</span>';
                    loading = true;
                    loadJS(url, function(){
                        localStorage.setItem("googleTransDomain", domain);
                        removeHint()
                        transLoaded = true;
                    });
                }
                </script>
            
    
        <script src="/note/static/js/theme_default/tocbot.min.js"></script>
    
        <script src="/note/static/js/theme_default/main.js"></script>
    
        <script src="/note/static/js/theme_default/viewer.min.js"></script>
    
        <script src="/note/static/css/theme_default/prism.min.js"></script>
    
        <script src="/note/static/js/search/search_main.js"></script>
    
        <script src="/note/static/js/plugin_blog/main.js"></script>
    
        <link rel="stylesheet" href="/note/static/js/add_hint/style.css" type="text/css"/>
    
        <script src="/note/static/js/add_hint/main.js"></script>
    
        <script src="/note/static/js/gitalk/gitalk.min.js"></script>
    
        <script src="/note/static/js/gitalk/main.js"></script>
    
        <script src="/note/static/js/custom.js"></script>
    
</body>

</html>