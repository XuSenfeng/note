# 束搜索

> 我们使用数学符号定义搜索问题。在任意时间步t′，解码器输 出yt′的概率取决于时间y~t′~之前的输出子序列y~1~,...,y~t′−1~ 和对输入序列的信息进行编码得到的上下文变 量c。为了量化计算代价，用Y表示输出词表，其中包含“\<eos\>”，所以这个词汇集合的基数|Y|就是词表 的大小。我们还将输出序列的最大词元数指定为T′。因此，我们的目标是从所有O(|Y|^T′^)个可能的输出序列 中寻找理想的输出。当然，对于所有输出序列，在“\<eos\>”之后的部分（非本句）将在实际输出中丢弃。

## 贪心搜索

在之前的计算里面使用的是贪心搜索, 使用上一个输出里面概率最大的词进行输出, 但是贪心算法一般不是最优的(当前最优不一定是整个句子最优的)

![image-20250211150622335](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/picture/202502111506401.png)

![image-20250211151035616](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/picture/202502111510677.png)

> 由于时间步3所基于的时间步1和2处的输出子序列已从“A”和“B”改变为“A”和“C”，因此时间步3处的每个词元的条件概率也改变

## 穷举搜索

如果目标是获得最优序列，我们可以考虑使用穷举搜索（exhaustivesearch）：穷举地列举所有可能的输出序 列及其条件概率，然后计算输出条件概率最高的一个。

虽然我们可以使用穷举搜索来获得最优序列，但其计算量O(|Y|^T′^)可能高的惊人。例如，当|Y|=10000和T′ = 10时，我们需要评估10000^10^ = 10^40^序列

## 束搜索

束搜索（beamsearch）是贪心搜索的一个改进版本。它有一个超参数，名为束宽（beamsize）k。在时间 步1，我们选择具有最高条件概率的k个词元。在后面的计算里面保留最好的K个候选, 每一个时刻的每一个候选添加一项(n个可能), 在kn里面选取最好的k个

![image-20250211151505510](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/picture/202502111515558.png)

> 束搜索过程（束宽：2，输出序列的最大长度：3）。候选输出序列是A、C、AB、CE、ABD和CED

时间复杂度是O(knT)

![image-20250211152638110](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/picture/202502111526160.png)

> 这里的L是在比较长的句子计算的时候给一个补偿, 这里的计算结果是一个负数