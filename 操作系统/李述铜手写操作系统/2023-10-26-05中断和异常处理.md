---
layout: post
title: "中断和异常处理" 
date:   2023-10-26 15:39:08 +0800
tags: 李述铜
---

# 中断和异常处理

## 创建GDT表

![image-20231026191938627](E:\a学习\笔记\img\image-20231026191938627.png)

> 分段存储

Global Descriptor Table是一个结构体数组, 有一定的格式

> A segment descriptor is a data structure in a GDT or LDT that provides the processor with the size and location of  a segment, as well as access control and status information. Segment descriptors are typically created by  compilers, linkers, loaders, or the operating system or executive, but not application programs. Figure 3-8 illustrates the general descriptor format for all types of segment descriptors.
>
> ![image-20231026192405708](E:\a学习\笔记\img\image-20231026192405708.png)
>
> + Base: 指明段的地址
> + limit: 段的长度
> + S: 0的时候是系统段, TSS/LDT等, 1的时候表示这一段是数据段或者代码段
> + DPL: 段的访问权限, 0-3
> + P: 这一个段是否有效
> + D/B: 代码段的时候制定了操作数和地址是32位还是16位, 栈的时候指定了栈是32位还是16位
> + G: 指定limit的单位是byte还是4KB
> + L: 64位下面使用
> + AVL: 保留
> + type: 段的类型
> + ![image-20230911170239279](E:\a学习\笔记\img\image-20230911170239279.png)

### 内存查找方式

32位的CPU存储架构有两种, 首先是分段机制, 还有一个分页机制

+ 分段机制

将线性的地址空间转换为多个段

每一个段有保护机制

有多种类型的段, 数据, 代码, 门, tss

使用的地址为逻辑地址: 段选择子+偏移

+ 分页机制

将线性的地址转换为逻辑地址

在较小的内存上面实现较大的虚拟内存

按需加载等功能

![image-20231029194028686](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202310291940743.png)

> 也就是说，在没有开启分页机制时，由程序员给出的**逻辑地址**，需要先通过分段机制转换成物理地址。但在开启分页机制后，逻辑地址仍然要先通过分段机制进行转换，只不过转换后不再是最终的物理地址，而是**线性地址**，然后再通过一次分页机制转换，得到最终的物理地址。

![image-20231029194446670](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202310291944713.png)

> CS: 代码段, 指定执行代码的空间
>
> SS: 栈段, 指定的栈的空间, 访问的时候使用的是SS:ESP
>
> DS/ES/FS/GS: 数据指定数据段的控制

![image-20231029194858297](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202310291948331.png)

![image-20231029194913978](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202310291949010.png)

> Intel给出的建议使用方法

>  逻辑地址比如0x8:1234会从GDT表项里1中基地址为0x10000, 则线性地址为0x11234

![image-20231029195444801](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202310291954836.png)

> If paging is not used, the processor maps the linear address directly to a physical address (that is, the linear  address goes out on the processor’s address bus). If the linear address space is paged, a second level of address  translation is used to translate the linear address into a physical address.

![image-20231029195713941](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202310291957973.png)

> 在查询GDP表的时候最下面的三位实际用作其他的作用, 所以查询的时候需要乘8, bit0, 1是设置特权级的
>
>  (Bits 0 and 1) — Specifies the privilege level of the selector. The privilege level can range from 0 to  3, with 0 being the most privileged level. See Section 5.5, “Privilege Levels”, for a description of the  relationship of the RPL to the CPL of the executing program (or task) and the descriptor privilege  level (DPL) of the descriptor the segment selector points to.
>
> bit2用来确定是什么表
>
> (Bit 2) — Specifies the descriptor table to use: clearing this flag selects the GDT; setting this flag  selects the current LDT.

### 总结

首先取线性地址, 查找GDT表项, 在取表项的基地址, 加上偏移, 没有分页机制的时候就是物理地址

### 实际设置

初始化GDT表项, 之后进行一个远跳转, 加载CS寄存器

![image-20231030220730961](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202310302207028.png)

![image-20231030220811261](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202310302208300.png)

```c
static segment_desc_t gdt_table_s[GDT_TABLE_SIZE];

//参数1选择表项, 基地址, 界限
void segment_desc_set (int selector, uint32_t base, uint32_t limit, uint16_t attr)
{
    segment_desc_t * desc = gdt_table_s + selector  / sizeof(segment_desc_t);
    if(limit>0xfffff){
        //这时候的界限是4KB的
        limit/=0x1000;
        attr |= SEG_G;
    }
    desc->limit15_0 = limit & 0xffff;
	desc->base15_0 = base & 0xffff;
	desc->base23_16 = (base >> 16) & 0xff;
	desc->attr = attr | (((limit >> 16) & 0xf) << 8);
	desc->base31_24 = (base >> 24) & 0xff;

}
void init_gdt(void){
    int i;
    for(i=0;i<GDT_TABLE_SIZE;i++){
        segment_desc_set(i<<3, 0, 0, 0);
    }
    //设置代码段
    segment_desc_set(KERNEL_SELECTOR_CS, 0, 0xffffffff, 
    (SEG_P_PRESENT | SEG_DPL_0 | SEG_D | SEG_S_NORMAL| SEG_TYPE_CODE | SEG_TYPE_RW));
    //数据段
    segment_desc_set(KERNEL_SELECTOR_DS, 0, 0xffffffff, 
    (SEG_P_PRESENT | SEG_DPL_0 | SEG_D | SEG_S_NORMAL| SEG_TYPE_DATA | SEG_TYPE_RW));

    //重新加载
    lgdt((uint32_t)gdt_table_s, sizeof(gdt_table_s));
}

void cpu_init(void){
    init_gdt();
    
}
```

## 触发异常与异常简介

异常: 由于CPU内部的事件所引起的中断, 比如程序出错(非法指令, 地址越界, 除0等), 通常是由于执行了现行指令引起的

中断: 外部事件所引起的中断, 通常的有磁盘中断, 打印机中断, 通常与现行的指令无关

![image-20231030223740916](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202310302237977.png)

![image-20231030223755594](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202310302237642.png)

使用一个数字除以0会产生一个异常, 这时候qemu由于在保护模式, 还没有配置中断系统, 中断处理出问题就会重启

### 中断向量门

<img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202310302243622.png" alt="image-20231026191938627" style="zoom:150%;" />

也是有一个寄存器指向(IDTR)

![image-20231030224609387](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202310302246424.png)

![image-20231030224830271](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202310302248317.png)

有任务门, 中断门, 陷阱门 

> Segment Selector 这里记录是段选择子, 指向GDT表的某一个段, 这里应该是代码段
>
> Offset 偏移, 具体的处理函数所在的位置
>
> D 表示是否是32位
>
> P 存在的标志位

![image-20231030225110654](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202310302251700.png)

### 实际设置

首先需要把段设置为之前保存的代码段的选择子, offset设置为偏移

```c
void irq_init(void){
    for(int i=0;i<IDE_TABLE_NR;i++)
    {
        gate_desc_set(idt_table+i, KERNEL_SELECTOR_CS, (uint32_t)exception_handler_unknow, (GATE_P_PERSENT | GATE_DPL0 | GATE_TYPE_INT));
    }
    //gate_desc_set()
    lidt((uint32_t)idt_table, sizeof(idt_table));
}
```

![image-20231101102620987](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202311011026111.png)

> 这两种分别是有没有特权级变换的时候保存到栈里面额寄存器

![image-20231101225740682](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202311012257739.png)

### 解析异常栈信息

通过栈里面保存的EIP寄存器的数值可以获取到具体发生问题的位置

![image-20231101230902900](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202311012309949.png)

![image-20231101230931408](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202311012309463.png)

> 中断自动压入
>
> + EFLAGS
> + CS
> + IP
> + 错误码
>
> pusha
>
> + EAX
> + ECX
> + EDX
> + EBX
> + ESP
> + EBP
> + ESI
> + EDI
>
> push
>
> + DS
> + ES
> + FS
> + GS
>
> CALL
>
> + 返回地址

C语言在进行参数传递的时候会把参数放在返回值前面, 这时候的这个函数可以理解为

```c
void do_handler_unknown(gs, fs, es, ds, edi, esi, ebp, esp, ebx, edx, ecx, ea, err, eip, cs, eflags)
```

可以把上面的结构定义为一个结构体, 之后再call之间压入一个指针, 使用的时候直接使用那一个指针进行操控寄存器信息

```assembly
//中断处理函数
exception_handler_unknow:
    pusha
    push %ds
    push %es
    push %fs
    push %gs
    push %esp
    call do_handler_unknow
    add %(1*4), %esp
    pop %gs
    pop %fs
    pop %es
    pop %ds
    popa
    
    iret
```

```c
typedef struct _exception_frame_t {
    uint32_t gs, fs, es, ds;
    uint32_t edi, esi, ebp, esp, ebx, edx, ecx, eax;
    uint32_t eip, cs, eflags;
}exception_frame_t;
```

![image-20231102191656764](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202311021916911.png)

### 使用宏定义重用中断处理函数

```assembly
//这是一个宏, 用来进行中断函数的重用,可以给出参数,名字,第几个,是否会传入错误码 
.macro exception_handler name num  with_err_code
    .text
    .extern do_handler_\name
    .global exception_handler_\name
//中断处理函数
exception_handler_\name:
    //传入一些参数
    .if \with_err_code==0
        push 0
    .endif
    push $\num

    pusha
    push %ds
    push %es
    push %fs
    push %gs
    push %esp
    call do_handler_\name
    //还原传入的数字
    add $(1*4), %esp
    pop %gs
    pop %fs
    pop %es
    pop %ds
    popa
    //在弹出的时候由于不会处理errcode所以手动进行弹出
    add $(2*4), %esp
    iret
.endm

exception_handler unknown, -1, 0
```

![image-20231102202340876](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202311022023039.png)
