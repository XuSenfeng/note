# 内核

## 下载

1.下载linux内核源码

​	github:

```
git clone https://github.com/Embedfire/ebf-buster-linux.git
```

​	gitee:

```
git clone https://gitee.com/Embedfire/ebf-buster-linux.git
```

2.安装必要环境工具库

```
sudo apt install make gcc-arm-linux-gnueabihf gcc bison flex libssl-dev dpkg-dev lzop
```

3.一键编译内核

```
sudo ./make_deb.sh
```

## 内核模块

这是为了处理Linnux内核的可拓展性以及维护性比较差

### 内核派系

宏内核：关键功能和服务功能均在内核空间提供, 服务是可以裁剪的

 - 运行效率高
 - 扩展性较差

微内核：内核空间只提供关键功能，服务功能在用户空间提供

- 运行效率较低
- 安全性、扩展性较高

![image-20250715095014631](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507150950753.png)

#### 内核模块加载/卸载

- 使用`insmod`命令加载
- 使用`rmmod`命令卸载
- `lsmod` 查看当前的所有模块

#### 内核模块入口/出口

- `module_init()`：加载模块式该函数自动执行，进行初始化操作
- `module_exit()`：卸载模块时函数自动执行，进行清理操作

#### 内核模块信息声明

- `MODULE_LICENSE()`：表示模块代码接受的软件许可协议，Linux内核遵循GPL V2开源协议，内核模块与linux内核保持一致即可。
- `MODULE_AUTHOR()`：描述模块的作者信息
- `MODULE_DESCRIPTION()`：对模块的简单介绍
- `MODULE_ALIAS()`：给模块设置一个别名

#### 内核模块头文件

- `#include <linux/module.h>`：包含内核模块信息声明的相关函数
- `#include <linux/init.h>`：包含了 module_init()和 module_exit()函数的声明
- `#include <linux/kernel.h>`：包含内核提供的各种函数，如printk

#### 内核模块打印函数

- printf：glibc实现的打印函数，工作于用户空间

- printk：内核模块无法使用glibc库函数，内核自身实现的一个类printf函数，但是需要指定打印等级。
    - \#define KERN_EMERG 	"<0>" 通常是系统崩溃前的信息
    - #define KERN_ALERT          "<1>" 需要立即处理的消息
    - #define KERN_CRIT             "<2>" 严重情况
    - #define KERN_ERR              "<3>" 错误情况
    - #define KERN_WARNING   "<4>" 有问题的情况
    - #define KERN_NOTICE       "<5>" 注意信息
    - #define KERN_INFO            "<6>" 普通消息
    - #define KERN_DEBUG        "<7>" 调试信息

查看当前系统printk打印等级：`cat /proc/sys/kernel/printk`

- 当前控制台日志级别
- 默认消息日志级别
- 最小的控制台级别
- 默认控制台日志级别

打印内核所有打印信息：dmesg

- 内核log缓冲区大小有限制，缓冲区数据可能被冲掉

#### Makefile分析

- `KERNEL_DIR`：指向linux内核具体路径
- `export`：导出变量给子Makefile使用 
- `obj-m` := <模块名>.o：定义要生成的模块
- `$(MAKE)`：Makefile的默认变量，值为make

- `选项”-C”`：让make工具跳转到linux内核目录下读取顶层Makefile

- `M=`：表示内核模块源码目录
- `$(CURDIR)`：Makefile默认变量，值为当前目录所在路径

- `make modules`：执行Linux顶层Makefile的伪目标，它实现内核模块的源码读取并编译为.ko文件

#### 编译内核模块

```makefile
KERNEL_DIR=/home/jiao/yh-linux/driver/kernel/ebf-buster-linux-master/build_image/build

ARCH=arm
CROSS_COMPILE=arm-linux-gnueabihf-
export  ARCH  CROSS_COMPILE

obj-m := helloworld.o
all:
	$(MAKE) -C $(KERNEL_DIR) M=$(CURDIR) modules

.PHONE:clean copy

clean:
	$(MAKE) -C $(KERNEL_DIR) M=$(CURDIR) clean	

copy:
	sudo  cp  *.ko  /home/embedfire/workdir
```

## 示例

```c
#include <linux/module.h>
#include <linux/init.h>
#include <linux/kernel.h>

static int __init hello_init(void)
 {
printk(KERN_EMERG "[ KERN_EMERG ]  Hello World Module Init\n");
printk( "[ default ]  Hello World Module Init\n");
 return 0;
}

static void __exit hello_exit(void)
{
 printk("[ default ]   goodbye\n");
}

module_init(hello_init);
module_exit(hello_exit);

MODULE_LICENSE("GPL2");
MODULE_AUTHOR("embedfire ");
MODULE_DESCRIPTION("hello world module");
MODULE_ALIAS("test_module");
```

> 在Linux内核模块编程中，`__init`和`__exit`宏用于优化内存管理，具体作用如下：
>
> 1. `__init` 宏
>
> - **作用**：标记模块初始化函数（如`hello_init`），表示该函数仅在**模块加载时运行一次**。
> - **内存优化**：
>     内核会将标记为`__init`的函数代码放在特殊的内存区域（`.init.text`段）。初始化完成后，**内核会自动释放这部分内存**，减少长期内存占用。
> - **使用场景**：
>     只执行一次的函数（如资源分配、硬件初始化）。
>
> 2. `__exit` 宏
>
> - **作用**：标记模块退出函数（如`hello_exit`），表示该函数仅在**模块卸载时运行**。
> - **内存优化**：
>     函数代码会被放在`.exit.text`段。对于**动态加载的模块**（非编译进内核），卸载时会释放这部分内存。
>     **注意**：若模块编译进内核（非动态加载），`__exit`函数会被直接丢弃（因为永不卸载）。
> - **使用场景**：
>     清理函数（如释放资源、关闭设备）。

```makefile
KERNEL_DIR=/home/pi/build

ARCH=arm
CROSS_COMPILE=arm-linux-gnueabihf-
export  ARCH  CROSS_COMPILE

obj-m := helloworld.o
all:
	# -C内核的目录, 找到他的Makefile, 使用他的伪目标modules, M是当前的模块的位置
	$(MAKE) -C $(KERNEL_DIR) M=$(CURDIR) modules

.PHONE:clean copy

clean:
	$(MAKE) -C $(KERNEL_DIR) M=$(CURDIR) clean	

copy:
	sudo  cp  *.ko  /home/embedfire/workdir
```

- KERNEL_DIR：指向linux内核具体路径
- export：导出变量给子Makefile使用 
- obj-m := <模块名>.o：定义要生成的模块
- $(MAKE)：Makefile的默认变量，值为make

- 选项”-C”：让make工具跳转到linux内核目录下读取顶层Makefile

- M=：表示内核模块源码目录
- $(CURDIR)：Makefile默认变量，值为当前目录所在路径

- make modules：执行Linux顶层Makefile的伪目标，它实现内核模块的源码读取并编译为.ko文件

## 使用参数

#### 模块参数

根据不同应用场合给内核模块传递不同参数，提高内核模块灵活性, 可以在加载模型的时候直接进行赋值

- 定义一个常见变量
- 使用module_param宏把传参值赋给变量

```c
module_param(name, type, perm)
```

- name：参数名
- type：参数类型，如int、byte、bool、charp...
- perm：读写权限
    - 不允许设置可执行权限
    - 在“/sys/module/模块名/parameters”目录下，会生成该参数对应的文件名

#### 符号共享

内核模块可以共享导出的符号表, 在其他的模块里面可以使用这部分的符号, 使用的时候需要加一个声明(函数声明和使用extern声明变量)

- 变量共享
- 函数共享

```
EXPORT_SYMBOL(sym)
```

- sym：变量名或者函数名

##### 查看符号表

```bash
cat /proc/kallsyms | grep xxx
```

##### Makefile修改

- 有依赖关系的模块，放在一起进行编译
- clean伪目标增加清除共享文件夹指令

##### 模块手动加载

- 加载时，必须先加载相关依赖模块
- 卸载时，顺序相反

##### 依赖模块自动加载

模块之间有依赖的时候加载以及卸载是比较复杂的

- 所有内核模块统一放到"/lib/modules/内核版本"目录下, 可以使用`uname -r`查看版本

    ```
    cp *.ko /lib/modules/内核版本
    ```

- 建立模块依赖关系, 会自动查看前面的目录下面的ko文件：

    ```
    depmod -a 
    ```

- 查看模块依赖关系

    ```
    cat /lib/modules/内核版本/modules.dep
    ```

- 加载模块及其依赖模块

    ```
    modprobe xxx
    ```

- 卸载模块及其依赖模块

    ```
    modprobe -r xxx
    ```


### 代码实现

```c
#include <linux/module.h>
#include <linux/init.h>
#include <linux/kernel.h>

static int itype=0;
module_param(itype,int,0);

static bool btype=0;
module_param(btype,bool,0644);

static char ctype=0;
module_param(ctype,byte,0);

static char  *stype=0;
module_param(stype,charp,0644);

static int __init param_init(void)
 {
 printk(KERN_ALERT "param init!\n");
 printk(KERN_ALERT "itype=%d\n",itype);
 printk(KERN_ALERT "btype=%d\n",btype);
 printk(KERN_ALERT "ctype=%d\n",ctype);
 printk(KERN_ALERT "stype=%s\n",stype);
 return 0;
}

static void __exit param_exit(void)
{
 printk(KERN_ALERT "module exit!\n");
}
// 导出几个符号, 可以在其他的文件里面使用
EXPORT_SYMBOL(itype);

int my_add(int a, int b)
{
   return a+b;
}

EXPORT_SYMBOL(my_add);

int my_sub(int a, int b)
{
   return a-b;
}

EXPORT_SYMBOL(my_sub);

module_init(param_init);
module_exit(param_exit);

MODULE_LICENSE("GPL2");
MODULE_AUTHOR("jiao");
MODULE_DESCRIPTION("module_param");
MODULE_ALIAS("module_param");
```

![image-20250715143634777](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507151436854.png)

> 加载时候赋值

#### 其他文件使用

在头文件里面声明

```h
#ifndef __CALCULATION_H__
#define __CALCULATION_H__

extern int itype;


int my_add(int a, int b);
int my_sub(int a, int b);

#endif
```



```c
#include <linux/module.h>
#include <linux/init.h>
#include <linux/kernel.h>

#include "calculation.h"

static int __init calculation_init(void)
 {
    itype = 1;
    printk(KERN_ALERT "calculation  init!\n");
    printk(KERN_ALERT "itype+1 = %d, itype-1 = %d\n", my_add(itype,1), my_sub(itype,1));    
    return 0;
 }

 static void __exit calculation_exit(void)
{
 printk(KERN_ALERT "calculation  exit!\n");
}


module_init(calculation_init);
module_exit(calculation_exit);

MODULE_LICENSE("GPL2");
MODULE_AUTHOR("embedfire ");
MODULE_DESCRIPTION("calculation module");
MODULE_ALIAS("calculation_module");
```

