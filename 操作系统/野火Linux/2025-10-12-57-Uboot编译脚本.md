# U-boot编译

## 各种文件

+ `.config`: 文件配置Makefile里面的实际编译的文件
+ `*.cmd`: Makefile里面使用的命令
+ `Kconfig`: 配置界面的配置
+ `System.map`: 内存映射表
+ `u-boot`: elf文件
+ `u-boot.bin`: 压缩以后的二进制文件
+ `u-boot.imx`添加头以后的文件
+ `u-boot.sym`: 符号文件

## 基础知识

### 子目录调用

make 是支持递归调用的，也就是在 Makefile 中使用“make”命令来执行其他的 Makefile 文件，一般都是子目录中的Makefile文件。假如在当前目录下存在一个“subdir”子目录，这个 子目录中又有其对应的Makefile文件，那么这个工程在编译的时候其主目录中的Makefile就可 以调用子目录中的Makefile，以此来完成所有子目录的编译

```makefile
$(MAKE) -C subdir
```

有时候我们需要向子 make 传递变量， 这个时候使用“export”来导出要传递给子make的变量即可，如果不希望哪个变量传递给子m ake 的话就使用“unexport”来声明不导出

```makefile
export VARIABLE……   //导出变量给子make 。 
unexport VARIABLE……  //不导出变量给子make。 
```

有两个特殊的变量：`SHELL`和`MAKEFLAGS`，这两个变量除非使用“unexport”声 明，否则的话在整个make的执行过程中，它们的值始终自动的传递给子make

## 顶层Makefile

### 版本号

```bash
VERSION = 2016
PATCHLEVEL = 03 
SUBLEVEL = 
EXTRAVERSION = 
NAME =
```

VERSION 是主版本号，PATCHLEVEL是补丁版本号，SUBLEVEL是次版本号，这三个一 起构成了uboot的版本号

EXTRAVERSION附加信息, NAME名字一般不使用

### 各种配置参数

#### 输出命令

uboot 默认编译是不会在终端中显示完整的命令，都是短命令

可以使用参数`V=1`输出完整的命令

```makefile
ifeq ("$(origin V)", "command line")
  KBUILD_VERBOSE = $(V)
endif
ifndef KBUILD_VERBOSE
  KBUILD_VERBOSE = 0
endif

ifeq ($(KBUILD_VERBOSE),1)
  quiet =
  Q =
else
  quiet=quiet_
  Q = @
endif
```

> origin函数可以判断参数的来源, 使用这一句可以使得判断出来输入是在命令行里面, 之后就是两个判断赋值

之后在使用的时候会有如下的语句

```bash
$(Q)$(MAKE) $(build)=tools
```

如果V=0的话上述命令展开就是`@ make $(build)=tools`， make在执行的时候默认会在 终端输出命令，但是在命令前面加上“@”就不会在终端输出命令了。当V=1 的时候 Q就为 空，上述命令就是`make $(build)=tools`，因此在make执行的过程，命令会被完整的输出在终 端上。

```bash
quiet_cmd_sym ?= SYM     $@ 
cmd_sym ?= $(OBJDUMP) -t $< > $@
```

有些命令会有两个版本

`quiet_cmd_xxx` 命令输出信息少，也就是短命令， 而`cmd_xxx`命令输出信息多，也就是完整的命令。  如果变量quiet为空的话，整个命令都会输出。  如果变量quiet为`quiet_`的话，仅输出短版本。  如果变量quiet为`silent_`的话，整个命令都不会输出。

> 可以使用`make -s`完全不输出`

这部分的参数最后会被export, 被子项目调用

#### 输出目录

可以使用`O=目录`的形式把输出放在这个文件, 变量KBUILD_OUTPUT就是输出目录

#### 代码检查

`C=1`使能代码检查，检查那些需要重新编译的文件, `C=2`检查所有的源码文件

#### 模块编译

使用`M=dir`单独编译一个模块

#### 获取架构

变量`HOSTARCH`，用于保存主机架构,变量`HOSTOS`，此变量用于保存主机OS的值, 这里是Linux, 使用uname命令进行获取

#### 架构以及交叉编译器

设置 `ARCH` 和 `CROSS_COMPILE` 两个参数, 记录ARM以及使用的交叉编译器前缀

#### 添加参数文件

文件`scripts/Kbuild.include`，此文件里面定义了 很多变量

#### 配置文件加载

在文件config.mk文件里面进行各种`CONFIG_`开头的参数的配置

` ARCH := $(CONFIG_SYS_ARCH:"%"=%) `这里是从`CONFIG_SYS_ARCH="arm"`这个宏里面匹配`arm`

```makefile
# If .config is newer than include/config/auto.conf, someone tinkered
# with it and forgot to run make oldconfig.
# if auto.conf.cmd is missing then we are probably in a cleaned tree so
# we execute the config step to be sure to catch updated Kconfig files
include/config/%.conf: $(KCONFIG_CONFIG) include/config/auto.conf.cmd
	$(Q)$(MAKE) -f $(srctree)/Makefile silentoldconfig
	@# If the following part fails, include/config/auto.conf should be
	@# deleted so "make silentoldconfig" will be re-run on the next build.
	$(Q)$(MAKE) -f $(srctree)/scripts/Makefile.autoconf || \
		{ rm -f include/config/auto.conf; false; }
	@# include/config.h has been updated after "make silentoldconfig".
	@# We need to touch include/config/auto.conf so it gets newer
	@# than include/config.h.
	@# Otherwise, 'make silentoldconfig' would be invoked twice.
	$(Q)touch include/config/auto.conf
```

这一段会自动判`KCONFIG_CONFIG(.config)`文件是不是比include/config/%.conf所有这些文件更新, 如果是的话, 更新一下这部分文件, 使用`scripts/Makefile.autoconf`, 这个文件里面会引用`.config`文件, 更新失败的话删除auto.conf文件, 保证下一次一定执行, 最后使用`touch include/config/auto.conf`更新时间戳

所以 `auto.conf` 本质上是一个**配置转换器**，让内核的配置系统能够驱动构建系统，是连接 Kconfig 和 Makefile 的关键桥梁, 里面的是Makefile文件可以直接读取的参数

## 处理`make xxx_config`

实际是把这个配置文件里面的信息输入到.config文件里面

![image-20251023223556587](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510232235660.png)

```makefile
%config: scripts_basic outputmakefile FORCE
	$(Q)$(MAKE) $(build)=scripts/kconfig $@
```

进行配置文件的时候会匹配这个

### 依赖文件

#### scripts_basic

```makefile
scripts_basic:
	$(Q)$(MAKE) $(build)=scripts/basic
	$(Q)rm -f .tmp_quiet_recordmcount
```

第一个命令展开以后是`@make -f ./scripts/Makefile.build obj=scripts/basic`

`build`是在`scripts/Kbuild.include`中定义为`build := -f $(srctree)/scripts/Makefile.build obj` = `build := -f ./scripts/Makefile.build obj`

#### outputmakefile

```makefile
ifneq ($(KBUILD_SRC),)
	$(Q)ln -fsn $(srctree) source
	$(Q)$(CONFIG_SHELL) $(srctree)/scripts/mkmakefile \
	    $(srctree) $(objtree) $(VERSION) $(PATCHLEVEL)
endif
```

`KBUILD_SRC`是一个make输入的变量, 但是不是用户使用的, 为空, 这部分不执行, 所以这个依赖是空的

#### FORCE

FORCE是没有规则和依赖的，所以每次都会重新生成FORCE。当FORCE作为 其他目标的依赖时，由于FORCE总是被更新过的，因此依赖所在的规则总是会执行的

### 实际执行命令

+ 依赖里面的`@make -f ./scripts/Makefile.build obj=scripts/basic`
+ 以及`make xxxconfig`对应的`@make -f ./scripts/Makefile.build obj=scripts/kconfig xxx_defconfig`

#### ./scripts/Makefile.build

这个文件负责根据不同的obj加载对应文件夹下面的Makefile之后编译对应的目标

```makefile
# Modified for U-Boot
prefix := tpl
src := $(patsubst $(prefix)/%,%,$(obj))
ifeq ($(obj),$(src))
prefix := spl
src := $(patsubst $(prefix)/%,%,$(obj))
ifeq ($(obj),$(src))
prefix := .
endif
endif
```

开始的时候定义变量`src=scripts/basic`和传入的obj进行比较获取到`prefix=.`

```makefile
kbuild-dir := $(if $(filter /%,$(src)),$(src),$(srctree)/$(src))
kbuild-file := $(if $(wildcard $(kbuild-dir)/Kbuild),$(kbuild-dir)/Kbuild,$(kbuild-dir)/Makefile)
```

定义`kbuild-dir`为`kbuild-dir=./scripts/basic`以及`kbuild-file`为`./scripts/basic/Makefile`这个文件会被include进来

```make
__build: $(if $(KBUILD_BUILTIN),$(builtin-target) $(lib-target) $(extra-y)) \
	 $(if $(KBUILD_MODULES),$(obj-m) $(modorder-target)) \
	 $(subdir-ym) $(always)
	@:
```

这个命令是默认的命令, 所以会执行, KBUILD_BUILTIN为1，KBUILD_MODULES为0, 所以实际执行的是

```makefile
__build:$(builtin-target) $(lib-target) $(extra-y)) $(subdir-ym) $(always) 
	@: 
```

这里面的参数只有always有效为`scripts/basic/fixdep`这个依赖的是一个软件

#### xxx_defconfig

obj变了, 所以`src=scripts/kconfig`,`kbuild-dir=./scripts/kconfig `, `kbuild-file=./scripts/kconfig/Makefile `, 引用后面的文件

在这个文件里面, 有一个命令可以进行匹配

```makefile
%_defconfig: $(obj)/conf
	$(Q)$< $(silent) --defconfig=arch/$(SRCARCH)/configs/$@ $(Kconfig)
```

依赖的文件是`scripts/kconfig/conf`这也是一个软件

下面的命令`@ scripts/kconfig/conf --defconfig=arch/../configs/xxx_defconfig Kconfig `

这里会将 mx6ull_alientek_emmc_defconfig 中的配置输出到.config 文件中，最终生成 uboot 根目录下的.confi g 文件

## 编译命令

![image-20251025160820220](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510251608274.png)

在输入`make`没有参数的时候执行的是默认的目标

```make
# That's our default target when none is given on the command line
PHONY := _all
_all:
```

默认的`all_`是依赖于`all`的, `all`依赖于`$(ALL-y)`

```makefile
# Always append ALL so that arch config.mk's can add custom ones
ALL-y += u-boot.srec u-boot.bin u-boot.sym System.map u-boot.cfg binary_size_check
```

之后就是根据各种的配置选项进行文件的添加

![image-20251025155013492](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510251550053.png)

我们主要需要关注的是u-boot.bin文件

```bash
ifeq ($(CONFIG_OF_SEPARATE),y)
u-boot-dtb.bin: u-boot-nodtb.bin dts/dt.dtb FORCE
	$(call if_changed,cat)

u-boot.bin: u-boot-dtb.bin FORCE
	$(call if_changed,copy)
else
u-boot.bin: u-boot-nodtb.bin FORCE
	$(call if_changed,copy)
endif
```

实际是下面的那一个分支

```bash
u-boot-nodtb.bin: u-boot FORCE
	$(call if_changed,objcopy)
	$(call DO_STATIC_RELA,$<,$@,$(CONFIG_SYS_TEXT_BASE))
	$(BOARD_SIZE_CHECK)
```

```bash
u-boot:	$(u-boot-init) $(u-boot-main) u-boot.lds FORCE
	$(call if_changed,u-boot__)
ifeq ($(CONFIG_KALLSYMS),y)
	$(call cmd,smap)
	$(call cmd,u-boot__) common/system_map.o
endif
```

这两个依赖的变量是

```bash
u-boot-init := $(head-y)
u-boot-main := $(libs-y)
```

`$(head-y)`跟CPU架构有关，我们使用的是ARM芯片，所以`head-y`在arch/arm/Makefile中 被指定`head-y := arch/arm/cpu/$(CPU)/start.o`实际是`arch/arm/cpu/armv7/start.o`

`$(libs-y)`在顶层Makefile中被定义为uboot所有子目录下build-in.o的集合, 记录所有的子目录, 最后面添加上`build-in.o`文件

> 实际处理的工作就是把start.o以及所有的build-in.o柑橘u-boot.lds文件链接在一起, 所有的build-in.o在进行链接的时候, 使用参数-r,  产生可重定向的输出, 所以实际的链接文件可以再一次被链接

u-boot的链接首地址是0x87800000位置
