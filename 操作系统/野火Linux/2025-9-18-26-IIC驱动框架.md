## IIC驱动框架简介

#### iic物理总线

- SCL：时钟线，数据收发同步
- SDA：数据线，具体数据

支持一主多从，各设备地址独立，标准模式传输速率为100kbit/s，快速模式为400kbit/s

##### 常见iic设备

- eeprom

- 触摸芯片

- 温湿度传感器

- mpu6050

    ...

#### 框架图

![image-20200901213737995](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509181548628.png)

- I2C核心

    提供I2C总线驱动和设备驱动的注册方法、注销方法、I2C通信硬件无关代码

- I2C适配器

    不同的I2C设备可能使用不同的配置, Algorithm里面记录实际的操作函数

- I2C 总线驱动

    主要包含I2C硬件体系结构中适配器(iic控制器)的控制，用于I2C 读写时序

    主要数据结构：I2C_adapter、i2c_algorithm

- I2C设备驱动

    通过I2C适配器与CPU交换数据

    主要数据结构：i2c_driver和i2c_client

#### 核心数据结构

##### i2c_adapter

include/linux/i2c.h I2C适配器, 抽象表示一个控制器

```c
struct i2c_adapter {
	struct module *owner;
	unsigned int class;		  /* classes to allow probing for */
	const struct i2c_algorithm *algo; /* the algorithm to access the bus */
	void *algo_data;

	...
};
```

- 对应一个IIC控制器

- 相关API

    - `int i2c_add_adapter(struct i2c_adapter *adapter)`

        注册一个i2c_adapter ，系统分配编号

    - `int i2c_add_numbered_adapter(struct i2c_adapter *adapter)`

        注册一个i2c_adapter ，自己指定编号

    - `void i2c_del_adapter(struct i2c_adapter * adap)`

        注销一个i2c_adapter 

> imx默认已经实现了这部分功能, 所以可以不用处理这部分的工作

#####  i2c_algorithm

记录一系列的函数指针

include/linux/i2c.h

```c
struct i2c_algorithm {
	int (*master_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs,
			   int num);
	int (*smbus_xfer) (struct i2c_adapter *adap, u16 addr,
			   unsigned short flags, char read_write,
			   u8 command, int size, union i2c_smbus_data *data);

	/* To determine what the adapter supports */
	u32 (*functionality) (struct i2c_adapter *);

#if IS_ENABLED(CONFIG_I2C_SLAVE)
	int (*reg_slave)(struct i2c_client *client);
	int (*unreg_slave)(struct i2c_client *client);
#endif
};
```

- 对应一套具体的通信方法

- master_xfer：产生I2C通信时序

##### struct i2c_client

表示一个I2C设备, 从设备树里面加载数据

include/linux/i2c.h

```c
struct i2c_client {
	unsigned short flags;		/* div., see below		*/
	unsigned short addr;		/* chip address - NOTE: 7bit	设备地址 */

	char name[I2C_NAME_SIZE];
	struct i2c_adapter *adapter;	/* the adapter we sit on	*/
	struct device dev;		/* the device structure		*/
	int init_irq;			/* irq set at initialization	*/
	int irq;			/* irq issued by device		*/
	struct list_head detected;
#if IS_ENABLED(CONFIG_I2C_SLAVE)
	i2c_slave_cb_t slave_cb;	/* callback for slave mode	*/
#endif
};
```

- addr：i2c设备地址

> 设备树节点自动生成注册

##### struct i2c_driver

include/linux/i2c.h

```c
struct i2c_driver {
	unsigned int class;

	/* Standard driver model interfaces */
	int (*probe)(struct i2c_client *, const struct i2c_device_id *);
	int (*remove)(struct i2c_client *);
	...
	struct device_driver driver;
	const struct i2c_device_id *id_table;
	...
}
```

- id_table：i2c总线传统匹配方式

- probe：i2c设备和i2c驱动匹配后，回调该函数指针

- 相关API

    - `int i2c_add_driver (struct i2c_driver *driver)`

        注册一个i2c_driver

    - `void i2c_del_driver(struct i2c_driver *driver)`

        注销一个i2c_driver

#### I2C 总线驱动分析

##### i2c总线注册

这部分代码是Linux内核自动处理的

drivers/i2c/i2c-core-base.c

```c
static int __init i2c_init(void)
{
	int retval;
	...
     // 注册一个总线
	retval = bus_register(&i2c_bus_type);
	if (retval)
		return retval;

	is_registered = true;
	...
    // 添加i2c设备
	retval = i2c_add_driver(&dummy_driver);
	if (retval)
		goto class_err;

	if (IS_ENABLED(CONFIG_OF_DYNAMIC))
		WARN_ON(of_reconfig_notifier_register(&i2c_of_notifier));
	if (IS_ENABLED(CONFIG_ACPI))
		WARN_ON(acpi_reconfig_notifier_register(&i2c_acpi_notifier));

	return 0;
	...
}
```

##### i2c总线定义

```c
struct bus_type i2c_bus_type = {
	.name		= "i2c",
	.match		= i2c_device_match,
	.probe		= i2c_device_probe,
	.remove		= i2c_device_remove,
	.shutdown	= i2c_device_shutdown,
};
```

##### i2c设备和i2c驱动匹配规则

处理不同的匹配规则

```c
static int i2c_device_match(struct device *dev, struct device_driver *drv)
{
	struct i2c_client	*client = i2c_verify_client(dev);
	struct i2c_driver	*driver;


	/* Attempt an OF style match */
	if (i2c_of_match_device(drv->of_match_table, client))
		return 1;

	/* Then ACPI style match */
	if (acpi_driver_match_device(dev, drv))
		return 1;

	driver = to_i2c_driver(drv);

	/* Finally an I2C match */
	if (i2c_match_id(driver->id_table, client))
		return 1;

	return 0;
}
```

- `of_driver_match_device`：设备树匹配方式
    - 比较 I2C 设备节点的 compatible 属性和 of_device_id 中的 compatible 属性

- `acpi_driver_match_device `： ACPI 匹配方式
- `i2c_match_id`：i2c总线传统匹配方式
    - 比较 I2C设备名字和 i2c驱动的id_table->name 字段是否相等

##### 设备树节点

arch/arm/boot/dts/imx6ull.dtsi

```json
i2c1: i2c@21a0000 {
				#address-cells = <1>;
				#size-cells = <0>;
				compatible = "fsl,imx6ul-i2c", "fsl,imx21-i2c";
				reg = <0x21a0000 0x4000>;
				interrupts = <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>;
				clocks = <&clks IMX6UL_CLK_I2C1>;
				status = "disabled";
			};
```

实际匹配的位置在这里

```c
static int __init i2c_adap_imx_init(void)
{
	return platform_driver_register(&i2c_imx_driver);
}
```

注册一个平台驱动, 首先使用一个platform的封装

##### i2c_imx_probe()函数

drivers/i2c/busses/i2c-imx.c

这个是platform匹配以后得执行函数, 注册实际的i2cbus

```c
static int i2c_imx_probe(struct platform_device *pdev)
{
	const struct of_device_id *of_id = of_match_device(i2c_imx_dt_ids,
							   &pdev->dev);
	struct imx_i2c_struct *i2c_imx;
	struct resource *res;
	struct imxi2c_platform_data *pdata = dev_get_platdata(&pdev->dev);
	void __iomem *base;
	int irq, ret;
	dma_addr_t phy_addr;
	...
	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
	base = devm_ioremap_resource(&pdev->dev, res); // 地址的映射
	
	phy_addr = (dma_addr_t)res->start; // 记录物理地址
	i2c_imx = devm_kzalloc(&pdev->dev, sizeof(*i2c_imx), GFP_KERNEL);
	...
	i2c_imx->adapter.algo		= &i2c_imx_algo; // i2c_adapter里面的i2c_algorithm变量
	...
	i2c_imx->base			= base; // 记录虚拟地址
	...
	ret = i2c_add_numbered_adapter(&i2c_imx->adapter); // 注册一个设备号
	...
}
```

#### i2c_imx_algo结构体变量

drivers/i2c/busses/i2c-imx.c

```c
static const struct i2c_algorithm i2c_imx_algo = {
	.master_xfer	= i2c_imx_xfer, // 产生i2c时序进行数据收发的
	.functionality	= i2c_imx_func,
};
```

- i2c_imx_xfer：iic通信函数
- i2c_imx_func：查询iic通信协议类型

#### i2c_imx_func()函数

drivers/i2c/busses/i2c-imx.c

返回支持的IIC格式

```c
static u32 i2c_imx_func(struct i2c_adapter *adapter)
{
	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL
		| I2C_FUNC_SMBUS_READ_BLOCK_DATA; // 几种不同的通信协议
}
```

#### i2c_imx_xfer()函数

drivers/i2c/busses/i2c-imx.c

实际的发送函数

```c
static int i2c_imx_xfer(struct i2c_adapter *adapter,
						struct i2c_msg *msgs, int num)
{
	unsigned int i, temp;
	int result;
	bool is_lastmsg = false;
	bool enable_runtime_pm = false;
	struct imx_i2c_struct *i2c_imx = i2c_get_adapdata(adapter);
	...
    // 启动信号
	result = i2c_imx_start(i2c_imx);
	...
		for (i = 0; i < num; i++) {
		if (i == num - 1)
			is_lastmsg = true;

		if (i) {
			dev_dbg(&i2c_imx->adapter.dev,
				"<%s> repeated start\n", __func__);
			temp = imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR);
			temp |= I2CR_RSTA;
			imx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR);
            // 判断是不是忙碌
			result = i2c_imx_bus_busy(i2c_imx, 1);
			if (result)
				goto fail0;
		}
	...
		if (msgs[i].flags & I2C_M_RD)
            // 处理读
			result = i2c_imx_read(i2c_imx, &msgs[i], is_lastmsg);
		else {
            
			if (i2c_imx->dma && msgs[i].len >= DMA_THRESHOLD)
				result = i2c_imx_dma_write(i2c_imx, &msgs[i]);
			else
				result = i2c_imx_write(i2c_imx, &msgs[i]);
		}
		if (result)
			goto fail0;
	}

fail0:
	/* Stop I2C transfer */
	i2c_imx_stop(i2c_imx);
	...
}
	
```

## IIC核心函数与“万能”驱动

#### i2c_add_adapter()函数

drivers/i2c/i2c-core-base.c

注册一个i2c适配器, 这部分是自动处理的

```c
int i2c_add_adapter(struct i2c_adapter *adapter) // 自动设置适配器编号
int i2c_add_numbered_adapter(struct i2c_adapter *adapter)
```

adapter->nr：适配器的编号

参数：

- adapter：i2c物理控制器对应的适配器

返回值：

- 成功：0
- 失败：负数

#### i2c_add_driver()宏

include/linux/i2c.h

注册一个i2c驱动, 实际是使用另一个函数

```c
#define i2c_add_driver(driver)  i2c_register_driver(THIS_MODULE, driver)
```

#### i2c_register_driver()函数

drivers/i2c/i2c-core-base.c

注册一个i2c驱动

````c
int i2c_register_driver(struct module *owner, struct i2c_driver *driver)
````

参数：

- owner： ：一般为 THIS_MODULE
- driver：要注册的 i2c_driver.

返回值：

- 成功：0
- 失败：负数

#### i2c_transfer()函数

drivers/i2c/i2c-core-base.c

收发iic消息

```c
int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num)
```

参数：

- adap ：所使用的 I2C 适配器，i2c_client 会保存其对应的 i2c_adapter
- msgs：I2C 要发送的一个或多个消息
- num ：消息数量，也就是 msgs 的数量

返回值：

- 成功：发送的msgs 的数量
- 失败：负数

#### i2c_msg结构体

include/uapi/linux/i2c.h

描述一个iic消息

```c
struct i2c_msg {
	__u16 addr;	/* slave address			*/
	__u16 flags;
#define I2C_M_RD		0x0001	/* read data, from slave to master */
					/* I2C_M_RD is guaranteed to be 0x0001! */
#define I2C_M_TEN		0x0010	/* this is a ten bit chip address */
#define I2C_M_DMA_SAFE		0x0200	/* the buffer of this message is DMA safe */
					/* makes only sense in kernelspace */
					/* userspace buffers are copied anyway */
#define I2C_M_RECV_LEN		0x0400	/* length will be first received byte */
#define I2C_M_NO_RD_ACK		0x0800	/* if I2C_FUNC_PROTOCOL_MANGLING */
#define I2C_M_IGNORE_NAK	0x1000	/* if I2C_FUNC_PROTOCOL_MANGLING */
#define I2C_M_REV_DIR_ADDR	0x2000	/* if I2C_FUNC_PROTOCOL_MANGLING */
#define I2C_M_NOSTART		0x4000	/* if I2C_FUNC_NOSTART */
#define I2C_M_STOP		0x8000	/* if I2C_FUNC_PROTOCOL_MANGLING */
	__u16 len;		/* msg length				*/
	__u8 *buf;		/* pointer to msg data			*/
};

```

- addr：iic设备地址
- flags：消息传输方向和特性。
    - I2C_M_RD：表示读取消息
    - 0：表示发送消息

- len：消息数据的长度
- buf：消息缓冲区

#### i2c_master_send()函数

include/linux/i2c.h

发送一个i2c消息, 对之前的函数再次封装, i2c_add_driver的prob函数可以获取到i2c_client

```c
static inline int i2c_master_send(const struct i2c_client *client,
				  const char *buf, int count)
{
	return i2c_transfer_buffer_flags(client, (char *)buf, count, 0);
};
```

#### i2c_master_recv()函数

include/linux/i2c.h

```c
static inline int i2c_master_recv(const struct i2c_client *client,
				  char *buf, int count)
{
	return i2c_transfer_buffer_flags(client, buf, count, I2C_M_RD);
};
```

#### i2c_transfer_buffer_flags()函数

drivers/i2c/i2c-core-base.c

发送一个i2c消息

```c
int i2c_transfer_buffer_flags(const struct i2c_client *client, char *buf,
			      int count, u16 flags)
{
	int ret;
	struct i2c_msg msg = {
		.addr = client->addr,
		.flags = flags | (client->flags & I2C_M_TEN),
		.len = count,
		.buf = buf,
	};

	ret = i2c_transfer(client->adapter, &msg, 1);

	/*
	 * If everything went ok (i.e. 1 msg transferred), return #bytes
	 * transferred, else error code.
	 */
	return (ret == 1) ? count : ret;
}
```



#### "万能"的i2c驱动--i2c-dev.c分析

drivers/i2c/i2c-dev.c

- 内核集成i2c_dev驱动模块，开机自动加载
- 为每个i2c_adapter生成一个设备文件，通过该设备文件间接使用IIC核心函数收发数据
- 注册i2c总线的通知函数，解决加载顺序问题

#### i2c_dev_init()函数

drivers/i2c/i2c-dev.c

```c
static int __init i2c_dev_init(void)
{
	int res;

	printk(KERN_INFO "i2c /dev entries driver\n");
	// 请求一个设备号, 89号, 最大的次设备号
	res = register_chrdev_region(MKDEV(I2C_MAJOR, 0), I2C_MINORS, "i2c");
	if (res)
		goto out;
	// 注册一个类
	i2c_dev_class = class_create(THIS_MODULE, "i2c-dev");
	if (IS_ERR(i2c_dev_class)) {
		res = PTR_ERR(i2c_dev_class);
		goto out_unreg_chrdev;
	}
	...
    // 注册一个通知
	res = bus_register_notifier(&i2c_bus_type, &i2cdev_notifier);
	if (res)
		goto out_unreg_class;

	/* Bind to already existing adapters right away */
    // 第二个参数就是处理添加事件的函数
	i2c_for_each_dev(NULL, i2cdev_attach_adapter);

	return 0;

out_unreg_class:
	class_destroy(i2c_dev_class);
out_unreg_chrdev:
	unregister_chrdev_region(MKDEV(I2C_MAJOR, 0), I2C_MINORS);
out:
	printk(KERN_ERR "%s: Driver Initialisation failed\n", __FILE__);
	return res;
}
```

#### i2cdev_notifier定义

```c
static struct notifier_block i2cdev_notifier = {
	.notifier_call = i2cdev_notifier_call, // 通知的回调函数
};
```

#### i2cdev_notifier_call()函数

处理一下各种不同的通知

```c
static int i2cdev_notifier_call(struct notifier_block *nb, unsigned long action,
			 void *data)
{
	struct device *dev = data;

	switch (action) {
	case BUS_NOTIFY_ADD_DEVICE:
         // 处理添加设备
		return i2cdev_attach_adapter(dev, NULL);
	case BUS_NOTIFY_DEL_DEVICE:
         // 处理删除设备
		return i2cdev_detach_adapter(dev, NULL);
	}

	return 0;
}
```

#### I2C_MAJOR

include/linux/i2c-dev.h

```c
#define I2C_MAJOR	89		/* Device major number		*/
```

#### I2C_MINORS

drivers/i2c/i2c-dev.c

```c
#define MINORBITS	20
#define MINORMASK	((1U << MINORBITS) - 1)
#define I2C_MINORS	MINORMASK
```

#### i2c_for_each_dev()函数

drivers/i2c/i2c-core-base.c

```c
int i2c_for_each_dev(void *data, int (*fn)(struct device *, void *))
{
	int res;

	mutex_lock(&core_lock);
	res = bus_for_each_dev(&i2c_bus_type, NULL, data, fn);
	mutex_unlock(&core_lock);

	return res;
}
```

#### bus_for_each_dev()函数

drivers/base/bus.c

```c
int bus_for_each_dev(struct bus_type *bus, struct device *start,
		     void *data, int (*fn)(struct device *, void *))
{
	struct klist_iter i;
	struct device *dev;
	int error = 0;

	if (!bus || !bus->p)
		return -EINVAL;

	klist_iter_init_node(&bus->p->klist_devices, &i,
			     (start ? &start->p->knode_bus : NULL));
	while (!error && (dev = next_device(&i)))
		error = fn(dev, data);
	klist_iter_exit(&i);
	return error;
}
```

#### i2cdev_attach_adapter()函数

drivers/i2c/i2c-dev.c

```c
static int i2cdev_attach_adapter(struct device *dev, void *dummy)
{
	struct i2c_adapter *adap;
	struct i2c_dev *i2c_dev;
	int res;
    // 看一下是不是i2c适配器
	if (dev->type != &i2c_adapter_type)
		return 0;
    // 获取i2c适配器
	adap = to_i2c_adapter(dev);
	// 分配内存以及记录adap
	i2c_dev = get_free_i2c_dev(adap);
	if (IS_ERR(i2c_dev))
		return PTR_ERR(i2c_dev);
	// 添加一个cdev
	cdev_init(&i2c_dev->cdev, &i2cdev_fops);
	i2c_dev->cdev.owner = THIS_MODULE;
    // 设定设备号
	res = cdev_add(&i2c_dev->cdev, MKDEV(I2C_MAJOR, adap->nr), 1);
	if (res)
		goto error_cdev;

	/* register this i2c device with the driver core */
    // 添加/dev下面的文件
	i2c_dev->dev = device_create(i2c_dev_class, &adap->dev,
				     MKDEV(I2C_MAJOR, adap->nr), NULL,
				     "i2c-%d", adap->nr);
	if (IS_ERR(i2c_dev->dev)) {
		res = PTR_ERR(i2c_dev->dev);
		goto error;
	}

	pr_debug("i2c-dev: adapter [%s] registered as minor %d\n",
		 adap->name, adap->nr);
	return 0;
error:
	cdev_del(&i2c_dev->cdev);
error_cdev:
	put_i2c_dev(i2c_dev);
	return res;
}
```

#### i2cdev_fops定义

drivers/i2c/i2c-dev.c

实际使用的操作函数

```c
static const struct file_operations i2cdev_fops = {
	.owner		= THIS_MODULE,
	.llseek		= no_llseek,
	.read		= i2cdev_read,
	.write		= i2cdev_write,
	.unlocked_ioctl	= i2cdev_ioctl,
	.compat_ioctl	= compat_i2cdev_ioctl,
	.open		= i2cdev_open,
	.release	= i2cdev_release,
};
```

#### i2cdev_open()函数

drivers/i2c/i2c-dev.c

```c
static int i2cdev_open(struct inode *inode, struct file *file)
{
    // 获取一下文件的次设备号
	unsigned int minor = iminor(inode);
	struct i2c_client *client;
	struct i2c_adapter *adap;
	// 依据子设备号获取实际的i2c_adapter
	adap = i2c_get_adapter(minor);
	if (!adap)
		return -ENODEV;

	client = kzalloc(sizeof(*client), GFP_KERNEL);
	if (!client) {
		i2c_put_adapter(adap);
		return -ENOMEM;
	}
	snprintf(client->name, I2C_NAME_SIZE, "i2c-dev %d", adap->nr);

	client->adapter = adap;
	file->private_data = client; // 记录在文件指针里面

	return 0;
}
```

#### i2cdev_read()函数

drivers/i2c/i2c-dev.c

```c
static ssize_t i2cdev_read(struct file *file, char __user *buf, size_t count,
		loff_t *offset)
{
	char *tmp;
	int ret;

	struct i2c_client *client = file->private_data;

	if (count > 8192)
		count = 8192;

	tmp = kmalloc(count, GFP_KERNEL);
	if (tmp == NULL)
		return -ENOMEM;

	pr_debug("i2c-dev: i2c-%d reading %zu bytes.\n",
		iminor(file_inode(file)), count);

	ret = i2c_master_recv(client, tmp, count);
	if (ret >= 0)
		ret = copy_to_user(buf, tmp, count) ? -EFAULT : ret;
	kfree(tmp);
	return ret;
}
```

#### i2cdev_write()函数

drivers/i2c/i2c-dev.c

```c
static ssize_t i2cdev_write(struct file *file, const char __user *buf,
		size_t count, loff_t *offset)
{
	int ret;
	char *tmp;
	struct i2c_client *client = file->private_data;

	if (count > 8192)
		count = 8192;

	tmp = memdup_user(buf, count);
	if (IS_ERR(tmp))
		return PTR_ERR(tmp);

	pr_debug("i2c-dev: i2c-%d writing %zu bytes.\n",
		iminor(file_inode(file)), count);

	ret = i2c_master_send(client, tmp, count);
	kfree(tmp);
	return ret;
}
```

