# Uboot启动(下)

## _main

![image-20251025185745925](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510251857975.png)

它在arch/arm/lib/crt0.S中有定义, 主要是初始化c语言的运行环境, 实现把uboot重定位以及初始化全局变量

```assembly
/*
 * entry point of crt0 sequence
 */

ENTRY(_main)

/*
 * Set up initial C runtime environment and call board_init_f(0).
 */

#if defined(CONFIG_TPL_BUILD) && defined(CONFIG_TPL_NEEDS_SEPARATE_STACK)
	ldr	r0, =(CONFIG_TPL_STACK)
#elif defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_STACK)
	ldr	r0, =(CONFIG_SPL_STACK)
#else
	ldr	r0, =(CONFIG_SYS_INIT_SP_ADDR) # 加载CONFIG_SYS_INIT_SP_ADDR到r0寄存器0x0091ff00
#endif
	bic	r0, r0, #7	/* 8-byte alignment for ABI compliance */
	mov	sp, r0 # 将堆栈指针指向r0寄存器的值，由于r0本就是对齐的，所以sp=0x0091ff00
	/*
		该函数有一个参数 top，根据 ARM 函数调
        用规则，top=r0=0x0091ff00，该函数主要作用是保留早期 malloc 区域有0x400，且为 GD（全局数
        据区）留出空间，函数返回值也是r0，r0保存着预留早期malloc区域和GD后的地址
	*/
	bl	board_init_f_alloc_reserve
	mov	sp, r0
	/* set up gd here, outside any C code ，gd 是 GD 地址为 0x0091fa00
    一个保存在 ARM 的 r9 寄存器中的 gd_t 结构体的指针 当使用 gd_t 前要用 
    DECLARE_GLOBAL_DATA_PTR 来声明，以指定占用 r9 寄存器避免编译器把
	r9 分配给其它的变量
    */
	mov	r9, r0
	# 将GD区域清零，返回最初malloc区域的地址，即0x0091fb00=0x0091fa00+0x100
	bl	board_init_f_init_reserve

#if defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_EARLY_BSS)
	CLEAR_BSS
#endif

	mov	r0, #0
	/*
		1. 设置dg的标志为0
		2. 标记dg的have_console为0，表示我们还没有初始化串口
		3. 调用initcall_run_list（）初始化 uboot 的前半段
			遍历执行函数指针数组init_sequence[]里面放的所有函数
	*/
	bl	board_init_f

#if ! defined(CONFIG_SPL_BUILD)

/*
 * Set up intermediate environment (new sp and gd) and call
 * relocate_code(addr_moni). Trick here is that we'll return
 * 'here' but relocated.
 */
	# 重新设置环境(sp和gd)、获取gd->start_addr_sp的值赋给sp，
	# 在函数board_init_f 中会初始化gd的所有成员变量，其中gd->start_addr_sp=0X9EF44E90
	ldr	r0, [r9, #GD_START_ADDR_SP]	/* sp = gd->start_addr_sp */
	bic	r0, r0, #7	/* 8-byte alignment for ABI compliance */
	mov	sp, r0
	# 获取gd->bd的地址赋给r9，此时r9存放的是老的gd，这里通过获取gd->bd的
	# 地址来计算出新的gd的位置。GD_BD=0
	ldr	r9, [r9, #GD_NEW_GD]		/* r9 <- gd->new_gd */
	
	# 设置lr寄存器为here, 函数返回的时候到这个位置
	adr	lr, here
	# 读取gd->reloc_off 的值复制给r0寄存器, 计算重定位以后的程序的位置
	ldr	r0, [r9, #GD_RELOC_OFF]		/* r0 = gd->reloc_off */
	add	lr, lr, r0
#if defined(CONFIG_CPU_V7M)
	orr	lr, #1				/* As required by Thumb-only */
#endif
	ldr	r0, [r9, #GD_RELOCADDR]		/* r0 = gd->relocaddr */
	# 重定位函数
	b	relocate_code
here:
/*
 * now relocate vectors
 */
	# 重定位中断向量表
	bl	relocate_vectors

/* Set up final (full) environment */
	
	bl	c_runtime_cpu_setup	/* we still call old routine here */
#endif
#if !defined(CONFIG_SPL_BUILD) || CONFIG_IS_ENABLED(FRAMEWORK)

#if !defined(CONFIG_SPL_BUILD) || !defined(CONFIG_SPL_EARLY_BSS)
	# 清除BSS段
	CLEAR_BSS
#endif

# ifdef CONFIG_SPL_BUILD
	/* Use a DRAM stack for the rest of SPL, if requested */
	bl	spl_relocate_stack_gd
	cmp	r0, #0
	movne	sp, r0
	movne	r9, r0
# endif

#if ! defined(CONFIG_SPL_BUILD)
	bl coloured_LED_init
	bl red_led_on
#endif
	/* call board_init_r(gd_t *id, ulong dest_addr) */
	# 记录函数的参数
	mov     r0, r9                  /* gd_t */
	ldr	r1, [r9, #GD_RELOCADDR]	/* dest_addr */
	/* call board_init_r */
#if CONFIG_IS_ENABLED(SYS_THUMB_BUILD)
	ldr	lr, =board_init_r	/* this is auto-relocated! */
	bx	lr
#else
	ldr	pc, =board_init_r	/* this is auto-relocated! */
#endif
	/* we should not return here. */
#endif

ENDPROC(_main)
```

> 因为并没有定 义整个全局结构体变量，编译器没有给该结构体存放区域，所以需要自己手动分配gd_t结构体的存储地址区域, 记录在r9里面，可以说gd_t结构体几乎包含了u-boot中用到的所有全局变量，gd_t和bd_t都 u-boot 中两个重要的数据结构在初始化操作很多都要靠这两个数据结构来保存或传递
>
> ```c
> #define DECLARE_GLOBAL_DATA_PTR		register volatile gd_t *gd asm ("r9")
> ```
>
> ```c
>typedef struct global_data {
> bd_t *bd;/* board_info 结构体指针，用来保存板子信息，如波特率、ip 地址、启动参数等 */
> unsigned long flags; /* 用于指示的标志，如板子是否已初始化、串口是否打开 */
>   unsigned int baudrate; /* 串口波特率 */
>   unsigned long cpu_clk; /* cpu 时钟频率 */
>   unsigned long bus_clk; /* 总线时钟频率 */
>   /* We cannot bracket this with CONFIG_PCI due to mpc5xxx */
>   unsigned long pci_clk;	/* pci 时钟频率 */
>   unsigned long mem_clk;	/* 内存时钟频率 */
>   #if defined(CONFIG_LCD) || defined(CONFIG_VIDEO)
>   unsigned long fb_base;      /* 如果定义了 CONFIG_LCD 或 CONFIG_VIDEO，
>   则此变量保存 frameBuffer 内存的基地址 */
>   
>  #endif
> #if defined(CONFIG_POST)
>   unsigned long post_log_word;	/* Record POST activities */
>   unsigned long post_log_res;	 /* success of POST test */
>   unsigned long post_init_f_time; /* When post_init_f started */
>   #endif
>   #ifdef CONFIG_BOARD_TYPES
>   unsigned long board_type; /* 板子类型 */
>   #endif
>   unsigned long have_console; /* 用于记录串口是否已初始化 */
>   #if CONFIG_IS_ENABLED(PRE_CONSOLE_BUFFER)
>   unsigned long precon_buf_idx; /* 串口未初始化前用于保存要打印数据的缓冲区索引 */
>   #endif
>   unsigned long env_addr; /* 环境参数地址 */
>   unsigned long env_valid; /* 环境参数 CRC 校验是否有效标志 */
>   unsigned long env_has_init;
>   /* Bitmask of boolean of struct env_location offsets */
>   int env_load_prio; /* 加载环境的优先级 */
>   unsigned long ram_base; /* U-Boot 所占用 RAM 的基地址 */
>   unsigned long ram_top; /* Top address of RAM used by U-Boot */
>   
>   unsigned long relocaddr; /* u-boot 占用 RAM 的起始地址 */
> phys_size_t ram_size;      /* RAM 的大小 */
>   
>   unsigned long mon_len;      /* monitor len */
> unsigned long irq_sp;      /* irq 栈指针 */
>   unsigned long start_addr_sp;      /* 栈指针起始地址 */
>   unsigned long reloc_off; /* 重定位偏移，就是实际定向的位置与编译连接时指定的位置之差，一般为 0 */
>   struct global_data *new_gd; /* 新分配的全局数据区指针 */
>   #ifdef CONFIG_DM
>   struct udevice      *dm_root; /* Root instance for Driver Model */
>   struct udevice     *dm_root_f; /* Pre-relocation root instance */
>   struct list_head uclass_root;  /* Head of core tree */
>   #endif
>   #ifdef CONFIG_TIMER
> struct udevice *timer; /* Timer instance for Driver Model */
> #endif
>   
> const void *fdt_blob; /* 设备树 */
> void *new_fdt; /* Relocated FDT */
>   unsigned long fdt_size; /* Space reserved for relocated FDT */
>   #ifdef CONFIG_OF_LIVE
>   struct device_node *of_root;
> #endif
>   #if CONFIG_IS_ENABLED(MULTI_DTB_FIT)
> const void *multi_dtb_fit; /* uncompressed multi-dtb FIT image */
> #endif
>   struct jt_funcs *jt; /* jump table */
> char env_buf[32]; /* buffer for env_get() before reloc. */
>   #ifdef CONFIG_TRACE
>   void *trace_buff;  /* The trace buffer */
> #endif
>   #if defined(CONFIG_SYS_I2C)
> int cur_i2c_bus;  /* 当前使用的 i2c 总线 */
> #endif
>   #ifdef CONFIG_SYS_I2C_MXC
> void *srdata[10];
> #endif
>   unsigned int timebase_h;
> unsigned int timebase_l;
>   #if CONFIG_VAL(SYS_MALLOC_F_LEN)
>   unsigned long malloc_base; /* 早期 malloc() 的基地址 */
> unsigned long malloc_limit; /* limit address */
>   unsigned long malloc_ptr; /* current address */
>   #endif
>   #ifdef CONFIG_PCI
> 	...
> ```

```c
void board_init_f_init_reserve(ulong base)
{
	struct global_data *gd_ptr;
#ifndef _USE_MEMCPY
	int *ptr;
#endif

	/*
	 * clear GD entirely and set it up.
	 * Use gd_ptr, as gd may not be properly set yet.
	 */

	gd_ptr = (struct global_data *)base;
	/* zero the area 清空gd_t结构体*/
#ifdef _USE_MEMCPY
	memset(gd_ptr, '\0', sizeof(*gd));
#else
	for (ptr = (int *)gd_ptr; ptr < (int *)(gd_ptr + 1); )
		*ptr++ = 0;
#endif
	/* set GD unless architecture did it already */
#if !defined(CONFIG_ARM)
	arch_setup_gd(gd_ptr);
#endif
	/* next alloc will be higher by one GD plus 16-byte alignment */
    // 计算一下malloc区域的地址, 同时16字节对齐
	base += roundup(sizeof(struct global_data), 16); 

	/*
	 * record early malloc arena start.
	 * Use gd as it is now properly set for all architectures.
	 */

#if defined(CONFIG_SYS_MALLOC_F)
	/* go down one 'early malloc arena' */
	gd->malloc_base = base; //记录malloc的地址
	/* next alloc will be higher by one 'early malloc arena' size */
	base += CONFIG_SYS_MALLOC_F_LEN;
#endif
}
```

### board_init_f

![image-20251025215126781](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510252151835.png)

初始化一系列外设，比如串口、定时器，或者打印一些消息

初始化gd的各个成员变量，uboot会将自己重定位到DRAM最后面的地址区域，也就 是将自己拷贝到DRAM最后面的内存区域中。这么做的目的是给Linux腾出空间，防止Linux kernel覆盖掉uboot，将DRAM前面的区域完整的空出来。在拷贝之前肯定要给uboot各部分 分配好内存位置和大小

这个函数会调用init_sequence里面的一系列函数

> **init_sequence**
>
> ```c
> staticconst init_fnc_tinit_sequence_f[] = {
> 	setup_mon_len, /*设置gd->mon_len为编译出来的u-boot.bin+bss段的大小*/
> 	fdtdec_setup, /*和设备树有关*/
> 	initf_malloc, /*初始化并设置内存池, 记录malloc_limit为0x400, malloc_ptr=0*/
> 	log_init, /* log初始化*/
> 	initf_bootstage, /*用于记录board_init_f()的引导阶段*/
> 	setup_spl_handoff,
> 	initf_console_record, /*平台信息记录初始化*/
> 	arch_cpu_init, /*空函数*/
> 	mach_cpu_init, /*空函数*/
> 	initf_dm, /*驱动模型初始化*/
> 	arch_cpu_init_dm, /*空函数*/
> 	board_early_init_f, /*设置时钟和GPIO*/
> 	timer_init, /*定时器初始化*/
> 	env_init, /*找到最适合存放环境变量的地址，并初始化*/
> 	init_baud_rate, /*波特率初始化*/
> 	serial_init, /*串口初始化*/
> 	console_init_f, /*使能在重定位之前用的串口功能gd->have_console= 1 */
> 	display_options, /*显示banner，如u-boot版本、编译时间等信息*/
> 	display_text_info, /*显示调试信息*/
> 	print_cpuinfo, /*显示cpu信息，如cpu速度*/
> 	show_board_info, /*显示板子信息 对应的设备树文件为arch/arm/dts/imx6ull14x14-evk.dts，
> 					文件中有关于板子model信息的描述*/
> 	announce_dram_init, /*准备显示DRAM大小，在u-boot启动时可以看到DRAM大小的信息*/
> 	dram_init, /*DRAM初始化，对于本imx6ull设置dg->ram_size=512 MiB */
> 	setup_dest_addr, /*设置重定位地址，gd->relocaddr=gd->ram_top 映射到0x80000000位置
> 					RAM顶端地址gd->ram_top=gd->relocaddr=0xa0000000*/
> 	reserve_round_4k, /* 4字节对齐，将内存指针调到下一个4kB*/
> 	reserve_mmu, /*为mmu区域腾出空间是预留出4kB空间来存放mmu的TLB页表*/
> 	reserve_video, /*预留video显示内存*/
> 	reserve_trace,
> 	reserve_uboot, /*预留U-Boot代码、data和bss区 预留出949kB给u-Boot，同时做4kB对齐*/
> 	reserve_malloc, /*预留malloc区16M, 以及CONFIG_ENV_SIZE=8KB, 使用start_addr_sp指向分配*/
> 	reserve_board, /*预留存放板子信息区, bd_t结构体的大小 80*/
> 	setup_machine, /*板子ID，这里没有用到, 未使用设备树的时候使用的*/
> 	reserve_global_data, /*预留GD区域，栈gd->start_addr_sp指向gd段基地址248*/
>        reserve_fdt, /* 预留设备树区域 */
>        reserve_bootstage, 
>        reserve_bloblist,
>        reserve_arch, /* 架构相关预留区 */
>        reserve_stacks,  /* 预留栈区，gd->start_addr_sp 指向栈底基地址 */
>        dram_init_banksize,  /* DRAM 的大小初始化 */
>        show_dram_config, /* 显示 DRAM 的配置 */
>        display_new_sp, /* 显示新的栈地址 */
>        reloc_fdt,/* 和设备树有关, 复制到新地址  */
>        reloc_bootstage,/* 和 u-boot 阶段有关 */
>        reloc_bloblist,/* 和 blob 列表有关 */
>        setup_reloc, /* 重定位, 把gd表复制到新的地址里面, 计算一下偏移 */
>        NULL,
> };
> ```
>
> 
>
> + setup_mon_len 根据.lds 文件中 `__bss_end` 与 `__bss_end` 计算出 u-boot 本身的大，赋给gd->mon_len
> + fdtdec_setup 检查gd->fdt_blob 处是否存在dtb设备树
> + env_init 标记已经初始化环境变量, 将默认环境 变量default_environment的地址赋值给全局变量gd->env_addr，该数组在include/env_default.h 如bootargs、bootcmd、bootdelay等 标记环境变量有效，gd->env_valid=ENV_VALID=1。
> + init_baud_rate 调用env_get_ulong 函数获取环境变量中波特率的参数, 设置gd->flags，表示串口已经准备好了, get_current()->start()返回一个指向当前被选择的串口的指针
> + console_init_f
> + display_options 
> + spl_relocate_stack_gd 

![image-20251009223537937](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510092235002.png)

### relocate_code

重定位代码, 在使用这个函数之前, 使用r0记录gd->relocaddr地址, 由于代码的位置是变化的, 所以函数的话, 绝对变量的使用会出现问题=>使用位置无关码(链接的时候使用-pie选项), 使用rel.dyn段, .rel.dyn段是存放.text段中需要重定位地址的集合

在位置无关码的代码里面, 使用一些label记录变量的绝对地址, 重定位以后, 需要把这些label更新, 加上偏移

这个字段里面的数据是两个一组, 高字节是0x17, 低字节是一个label的数据所在的地址, 需要对这个地址的label进行更新

![image-20251025234755578](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510252348365.png)

```assembly
/*
 * void relocate_code(addr_moni)
 *
 * This function relocates the monitor code.
 *
 * NOTE:
 * To prevent the code below from containing references with an R_ARM_ABS32
 * relocation record type, we never refer to linker-defined symbols directly.
 * Instead, we declare literals which contain their relative location with
 * respect to relocate_code, and at run time, add relocate_code back to them.
 */

ENTRY(relocate_code)
	ldr	r1, =__image_copy_start	/* r1 <- SRC &__image_copy_start 获取镜像的起始地址 */
	subs	r4, r0, r1		/* r4 <- relocation offset 计算一下偏移在r4 */
	beq	relocate_done		/* skip relocation偏移地址和起始地址相同的时候直接结束  */
	ldr	r2, =__image_copy_end	/* r2 <- SRC &__image_copy_end记录结束地址 */

copy_loop:
	ldmia	r1!, {r10-r11}	/* copy from source address [r1] 从r1位置记录两个数据到r10-r11同时r1++  */
	stmia	r0!, {r10-r11}	/* copy to   target address [r0] 复制到r0位置里面 */
	cmp	r1, r2			/* until source end address [r2]    */
	blo	copy_loop

	/*
	 * fix .rel.dyn relocations
	 */
	ldr	r2, =__rel_dyn_start	/* r2 <- SRC &__rel_dyn_start */
	ldr	r3, =__rel_dyn_end	/* r3 <- SRC &__rel_dyn_end */
fixloop:
	# 每次读取两个4字节的数据存放到r0和r1寄存器
	ldmia	r2!, {r0-r1}		/* (r0,r1) <- (SRC location,fixup) */
	and	r1, r1, #0xff
	cmp	r1, #23			/* relative fixup? 判断是不是标志位 */
	bne	fixnext

	/* relative fix: increase location by offset */
	add	r0, r0, r4 # 增加偏移, 获取重定位以后的记录label的地址
	ldr	r1, [r0]	# 加载这个数字
	add	r1, r1, r4	# 计算这个label对应数字的更新值
	str	r1, [r0] # 重定位后的变量地址写入到重定位后的Label中
fixnext:
	cmp	r2, r3
	blo	fixloop

relocate_done:

#ifdef __XSCALE__
	/*
	 * On xscale, icache must be invalidated and write buffers drained,
	 * even with cache disabled - 4.2.7 of xscale core developer's manual
	 */
	mcr	p15, 0, r0, c7, c7, 0	/* invalidate icache */
	mcr	p15, 0, r0, c7, c10, 4	/* drain write buffer */
#endif

	/* ARMv4- don't know bx lr but the assembler fails to see that */

#ifdef __ARM_ARCH_4__
	mov	pc, lr
#else
	bx	lr
#endif

ENDPROC(relocate_code)
```

### relocate_vectors

重定位中断向量表

```assembly
/*
 * Default/weak exception vectors relocation routine
 *
 * This routine covers the standard ARM cases: normal (0x00000000),
 * high (0xffff0000) and VBAR. SoCs which do not comply with any of
 * the standard cases must provide their own, strong, version.
 */

	.section	.text.relocate_vectors,"ax",%progbits
	.weak		relocate_vectors

ENTRY(relocate_vectors)

#ifdef CONFIG_CPU_V7M
	/*
	 * On ARMv7-M we only have to write the new vector address
	 * to VTOR register. 不执行
	 */
	ldr	r0, [r9, #GD_RELOCADDR]	/* r0 = gd->relocaddr */
	ldr	r1, =V7M_SCB_BASE
	str	r0, [r1, V7M_SCB_VTOR]
#else
#ifdef CONFIG_HAS_VBAR
	/*
	 * If the ARM processor has the security extensions,
	 * use VBAR to relocate the exception vectors. 这里, 使用协处理器重新设置
	 */
	ldr	r0, [r9, #GD_RELOCADDR]	/* r0 = gd->relocaddr */
	mcr     p15, 0, r0, c12, c0, 0  /* Set VBAR */
#else
	/*
	 * Copy the relocated exception vectors to the
	 * correct address
	 * CP15 c1 V bit gives us the location of the vectors:
	 * 0x00000000 or 0xFFFF0000.
	 */
	ldr	r0, [r9, #GD_RELOCADDR]	/* r0 = gd->relocaddr */
	mrc	p15, 0, r2, c1, c0, 0	/* V bit (bit[13]) in CP15 c1 */
	ands	r2, r2, #(1 << 13)
	ldreq	r1, =0x00000000		/* If V=0 */
	ldrne	r1, =0xFFFF0000		/* If V=1 */
	ldmia	r0!, {r2-r8,r10}
	stmia	r1!, {r2-r8,r10}
	ldmia	r0!, {r2-r8,r10}
	stmia	r1!, {r2-r8,r10}
#endif
#endif
	bx	lr

ENDPROC(relocate_vectors)
```

#### board_init_r

和之前的board_init_r比较类似

```c
void board_init_r(gd_t *new_gd, ulong dest_addr)
{
#ifdef CONFIG_NEEDS_MANUAL_RELOC
	int i;
#endif

#ifdef CONFIG_AVR32
	mmu_init_r(dest_addr);
#endif

#if !defined(CONFIG_X86) && !defined(CONFIG_ARM) && !defined(CONFIG_ARM64)
	gd = new_gd;
#endif

#ifdef CONFIG_NEEDS_MANUAL_RELOC
	for (i = 0; i < ARRAY_SIZE(init_sequence_r); i++)
		init_sequence_r[i] += gd->reloc_off;
#endif

	if (initcall_run_list(init_sequence_r))
		hang();

	/* NOTREACHED - run_main_loop() does not return */
	hang();
}
```

执行初始化序列init_sequence_r

```c
init_fnc_t init_sequence_r[] = { 
      initr_trace,           // 调试跟踪                              
      initr_reloc,           // 标记一下重定位成功                        
      initr_caches,          // 使能cache               
      initr_reloc_global_data,  // 初始化重定位以后gd里面的一些变量                          
      initr_barrier,         // 未使用
      initr_malloc,          // 初始化malloc                          
      initr_console_record,  // 初始化控制台, 未使用                                  
      bootstage_relocate,    // 启动状态重定位                              
      initr_bootstage,                                         
      board_init, /* Setup chipselects板级初始化 */                      
      stdio_init_tables,     // stdio相关                                  
      initr_serial,          // 串口                      
      initr_announce,        // 调试                       
      INIT_FUNC_WATCHDOG_RESET 
      INIT_FUNC_WATCHDOG_RESET 
      INIT_FUNC_WATCHDOG_RESET 
      power_init_board,      // 初始化电源芯片                                
      initr_flash,           // 未使用                  
      INIT_FUNC_WATCHDOG_RESET    
      initr_nand,            // 初始化NAND                      
      initr_mmc,             // 初始化emmc                  
      initr_env,             // 初始化环境变量                      
      INIT_FUNC_WATCHDOG_RESET 
      initr_secondary_cpu,   // 初始化其他的CPU核心, 未使用                                
      INIT_FUNC_WATCHDOG_RESET 
      stdio_add_devices,     // 各种输入输出设备      
      initr_jumptable,       // 初始化跳转表                
      console_init_r,     /* fully init console as a device 控制台初始化 */         
      INIT_FUNC_WATCHDOG_RESET             
      interrupt_init,                                          
      initr_enable_interrupts,                                     
      initr_ethaddr,          // 初始化网络地址, 获取MAC                                 
      board_late_init,        // 后续初始化         
      INIT_FUNC_WATCHDOG_RESET     
      INIT_FUNC_WATCHDOG_RESET 
      INIT_FUNC_WATCHDOG_RESET 
      initr_net,              // 初始化网络
      INIT_FUNC_WATCHDOG_RESET 
      run_main_loop,          // 主循环                 
}; 
```

