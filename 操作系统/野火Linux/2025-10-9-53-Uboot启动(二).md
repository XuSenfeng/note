# Uboot启动(下)



##### _main

它在arch/arm/lib/crt0.S中有定义, 主要是初始化c语言的运行环境, 实现把uboot重定位以及初始化全局变量

```assembly
/*
 * entry point of crt0 sequence
 */

ENTRY(_main)

/*
 * Set up initial C runtime environment and call board_init_f(0).
 */

#if defined(CONFIG_TPL_BUILD) && defined(CONFIG_TPL_NEEDS_SEPARATE_STACK)
	ldr	r0, =(CONFIG_TPL_STACK)
#elif defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_STACK)
	ldr	r0, =(CONFIG_SPL_STACK)
#else
	ldr	r0, =(CONFIG_SYS_INIT_SP_ADDR) # 加载CONFIG_SYS_INIT_SP_ADDR到r0寄存器0x0091ff00
#endif
	bic	r0, r0, #7	/* 8-byte alignment for ABI compliance */
	mov	sp, r0 # 将堆栈指针指向r0寄存器的值，由于r0本就是对齐的，所以sp=0x0091ff00
	/*
		该函数有一个参数 top，根据 ARM 函数调
        用规则，top=r0=0x0091ff00，该函数主要作用是保留早期 malloc 区域，且为 GD（全局数
        据区）留出空间，函数返回值也是r0，r0保存着预留早期malloc区域和GD后的地址
	*/
	bl	board_init_f_alloc_reserve
	mov	sp, r0
	/* set up gd here, outside any C code ，gd 是 GD 地址为 0x0091fa00
    一个保存在 ARM 的 r9 寄存器中的 gd_t 结构体的指针 当使用 gd_t 前要用 
    DECLARE_GLOBAL_DATA_PTR 来声明，以指定占用 r9 寄存器避免编译器把
	r9 分配给其它的变量
    */
	mov	r9, r0
	# 将GD区域清零，返回最初malloc区域的地址，即0x0091fb00=0x0091fa00+0x100
	bl	board_init_f_init_reserve

#if defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_EARLY_BSS)
	CLEAR_BSS
#endif

	mov	r0, #0
	/*
		1. 设置dg的标志为0
		2. 标记dg的have_console为0，表示我们还没有初始化串口
		3. 调用initcall_run_list（）初始化 uboot 的前半段
			遍历执行函数指针数组init_sequence[]里面放的所有函数
	*/
	bl	board_init_f

#if ! defined(CONFIG_SPL_BUILD)

/*
 * Set up intermediate environment (new sp and gd) and call
 * relocate_code(addr_moni). Trick here is that we'll return
 * 'here' but relocated.
 */

	ldr	r0, [r9, #GD_START_ADDR_SP]	/* sp = gd->start_addr_sp */
	bic	r0, r0, #7	/* 8-byte alignment for ABI compliance */
	mov	sp, r0
	ldr	r9, [r9, #GD_NEW_GD]		/* r9 <- gd->new_gd */

	adr	lr, here
	ldr	r0, [r9, #GD_RELOC_OFF]		/* r0 = gd->reloc_off */
	add	lr, lr, r0
#if defined(CONFIG_CPU_V7M)
	orr	lr, #1				/* As required by Thumb-only */
#endif
	ldr	r0, [r9, #GD_RELOCADDR]		/* r0 = gd->relocaddr */
	b	relocate_code
here:
/*
 * now relocate vectors
 */

	bl	relocate_vectors

/* Set up final (full) environment */

	bl	c_runtime_cpu_setup	/* we still call old routine here */
#endif
#if !defined(CONFIG_SPL_BUILD) || CONFIG_IS_ENABLED(FRAMEWORK)

#if !defined(CONFIG_SPL_BUILD) || !defined(CONFIG_SPL_EARLY_BSS)
	CLEAR_BSS
#endif

# ifdef CONFIG_SPL_BUILD
	/* Use a DRAM stack for the rest of SPL, if requested */
	bl	spl_relocate_stack_gd
	cmp	r0, #0
	movne	sp, r0
	movne	r9, r0
# endif

#if ! defined(CONFIG_SPL_BUILD)
	bl coloured_LED_init
	bl red_led_on
#endif
	/* call board_init_r(gd_t *id, ulong dest_addr) */
	mov     r0, r9                  /* gd_t */
	ldr	r1, [r9, #GD_RELOCADDR]	/* dest_addr */
	/* call board_init_r */
#if CONFIG_IS_ENABLED(SYS_THUMB_BUILD)
	ldr	lr, =board_init_r	/* this is auto-relocated! */
	bx	lr
#else
	ldr	pc, =board_init_r	/* this is auto-relocated! */
#endif
	/* we should not return here. */
#endif

ENDPROC(_main)
```

> 因为并没有定 义整个全局结构体变量，编译器没有给该结构体存放区域，所以需要自己手动分配gd_t结构体 的存储地址区域，可以说gd_t结构体几乎包含了u-boot中用到的所有全局变量，gd_t和bd_t都 u-boot 中两个重要的数据结构在初始化操作很多都要靠这两个数据结构来保存或传递
>
> ![image-20251009223537937](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510092235002.png)
>
> ```c
>  typedef struct global_data {
>      bd_t *bd;/* board_info 结构体指针，用来保存板子信息，如波特率、ip 地址、启动参数等 */
>      unsigned long flags; /* 用于指示的标志，如板子是否已初始化、串口是否打开 */
>      unsigned int baudrate; /* 串口波特率 */
>      unsigned long cpu_clk; /* cpu 时钟频率 */
>      unsigned long bus_clk; /* 总线时钟频率 */
>      /* We cannot bracket this with CONFIG_PCI due to mpc5xxx */
>      unsigned long pci_clk;	/* pci 时钟频率 */
>      unsigned long mem_clk;	/* 内存时钟频率 */
>      #if defined(CONFIG_LCD) || defined(CONFIG_VIDEO)
>      unsigned long fb_base;      /* 如果定义了 CONFIG_LCD 或 CONFIG_VIDEO，
>     则此变量保存 frameBuffer 内存的基地址 */
> 
>      #endif
>      #if defined(CONFIG_POST)
>      unsigned long post_log_word;	/* Record POST activities */
>      unsigned long post_log_res;	 /* success of POST test */
>      unsigned long post_init_f_time; /* When post_init_f started */
>      #endif
>      #ifdef CONFIG_BOARD_TYPES
>      unsigned long board_type; /* 板子类型 */
>      #endif
>      unsigned long have_console; /* 用于记录串口是否已初始化 */
>      #if CONFIG_IS_ENABLED(PRE_CONSOLE_BUFFER)
>      unsigned long precon_buf_idx; /* 串口未初始化前用于保存要打印数据的缓冲区索引 */
>      #endif
>      unsigned long env_addr; /* 环境参数地址 */
>      unsigned long env_valid; /* 环境参数 CRC 校验是否有效标志 */
>      unsigned long env_has_init;
>      /* Bitmask of boolean of struct env_location offsets */
>      int env_load_prio; /* 加载环境的优先级 */
>      unsigned long ram_base; /* U-Boot 所占用 RAM 的基地址 */
>      unsigned long ram_top; /* Top address of RAM used by U-Boot */
>      
>      unsigned long relocaddr; /* u-boot 占用 RAM 的起始地址 */
>      phys_size_t ram_size;      /* RAM 的大小 */
> 
>      unsigned long mon_len;      /* monitor len */
>      unsigned long irq_sp;      /* irq 栈指针 */
>      unsigned long start_addr_sp;      /* 栈指针起始地址 */
>      unsigned long reloc_off; /* 重定位偏移，就是实际定向的位置与编译连接时指定的位置之差，一般为 0 */
>      struct global_data *new_gd; /* 新分配的全局数据区指针 */
>      #ifdef CONFIG_DM
>      struct udevice      *dm_root; /* Root instance for Driver Model */
>      struct udevice     *dm_root_f; /* Pre-relocation root instance */
>      struct list_head uclass_root;  /* Head of core tree */
>  #endif
>  #ifdef CONFIG_TIMER
>      struct udevice *timer; /* Timer instance for Driver Model */
> #endif
>      
>      const void *fdt_blob; /* 设备树 */
>      void *new_fdt; /* Relocated FDT */
>      unsigned long fdt_size; /* Space reserved for relocated FDT */
> #ifdef CONFIG_OF_LIVE
>      struct device_node *of_root;
> #endif
> #if CONFIG_IS_ENABLED(MULTI_DTB_FIT)
>      const void *multi_dtb_fit; /* uncompressed multi-dtb FIT image */
> #endif
>      struct jt_funcs *jt; /* jump table */
>      char env_buf[32]; /* buffer for env_get() before reloc. */
> #ifdef CONFIG_TRACE
>      void *trace_buff;  /* The trace buffer */
> #endif
> #if defined(CONFIG_SYS_I2C)
>      int cur_i2c_bus;  /* 当前使用的 i2c 总线 */
> #endif
> #ifdef CONFIG_SYS_I2C_MXC
>      void *srdata[10];
> #endif
>      unsigned int timebase_h;
>      unsigned int timebase_l;
> #if CONFIG_VAL(SYS_MALLOC_F_LEN)
>      unsigned long malloc_base; /* 早期 malloc() 的基地址 */
>      unsigned long malloc_limit; /* limit address */
>      unsigned long malloc_ptr; /* current address */
>  #endif
>  #ifdef CONFIG_PCI
>      	...
> ```

> **init_sequence**
>
> ```c
> staticconst init_fnc_tinit_sequence_f[] = {
> 	setup_mon_len, /*设置gd->mon_len为编译出来的u-boot.bin+bss段的大小*/
> 	fdtdec_setup, /*和设备树有关*/
> 	initf_malloc, /*初始化并设置内存池*/
> 	log_init, /* log初始化*/
> 	initf_bootstage, /*用于记录board_init_f()的引导阶段*/
> 	setup_spl_handoff,
> 	initf_console_record, /*平台信息记录初始化*/
> 	arch_cpu_init, /*空函数*/
> 	mach_cpu_init, /*空函数*/
> 	initf_dm, /*驱动模型初始化*/
> 	arch_cpu_init_dm, /*空函数*/
> 	board_early_init_f, /*设置时钟和GPIO*/
> 	timer_init, /*定时器初始化*/
> 	env_init, /*找到最适合存放环境变量的地址，并初始化*/
> 	init_baud_rate, /*波特率初始化*/
> 	serial_init, /*串口初始化*/
> 	console_init_f, /*使能在重定位之前用的串口功能gd->have_console= 1 */
> 	display_options, /*显示banner，如u-boot版本、编译时间等信息*/
> 	display_text_info, /*显示调试信息*/
> 	print_cpuinfo, /*显示cpu信息，如cpu速度*/
> 	show_board_info, /*显示板子信息 对应的设备树文件为arch/arm/dts/imx6ull14x14-evk.dts，
> 					文件中有关于板子model信息的描述*/
> 	announce_dram_init, /*准备显示DRAM大小，在u-boot启动时可以看到DRAM大小的信息*/
> 	dram_init, /*DRAM初始化，对于本imx6ull设置dg->ram_size=512 MiB */
> 	setup_dest_addr, /*设置重定位地址，gd->relocaddr=gd->ram_top 映射到0x80000000位置
> 					RAM顶端地址gd->ram_top=gd->relocaddr=0xa0000000*/
> 	reserve_round_4k, /* 4字节对齐，将内存指针调到下一个4kB*/
> 	reserve_mmu, /*为mmu区域腾出空间是预留出4kB空间来存放mmu的TLB页表*/
> 	reserve_video, /*预留video显示内存*/
> 	reserve_trace,
> 	reserve_uboot, /*预留U-Boot代码、data和bss区 预留出949kB给u-Boot，同时做4kB对齐*/
> 	reserve_malloc, /*预留malloc区*/
> 	reserve_board, /*预留存放板子信息区*/
> 	setup_machine, /*板子ID，这里没有用到*/
> 	reserve_global_data, /*预留GD区域，栈gd->start_addr_sp指向gd段基地址*/
>       reserve_fdt, /* 预留设备树区域 */
>       reserve_bootstage, 
>       reserve_bloblist,
>       reserve_arch, /* 架构相关预留区 */
>       reserve_stacks,  /* 预留栈区，gd->start_addr_sp 指向栈底基地址 */
>       dram_init_banksize,  /* DRAM 的大小初始化 */
>       show_dram_config, /* 显示 DRAM 的配置 */
>       display_new_sp, /* 显示新的栈地址 */
>       reloc_fdt,/* 和设备树有关, 复制到新地址  */
>       reloc_bootstage,/* 和 u-boot 阶段有关 */
>       reloc_bloblist,/* 和 blob 列表有关 */
>       setup_reloc, /* 重定位 */
>       NULL,
> };
> ```
>
> 
>
> + setup_mon_len 根据.lds 文件中 `__bss_end` 与 `__bss_end` 计算出 u-boot 本身的大，赋给gd->mon_len
> + fdtdec_setup 检查gd->fdt_blob 处是否存在dtb设备树
> + env_init 标记已经初始化环境变量, 将默认环境 变量default_environment的地址赋值给全局变量gd->env_addr，该数组在include/env_default.h 如bootargs、bootcmd、bootdelay等 标记环境变量有效，gd->env_valid=ENV_VALID=1。
> + init_baud_rate 调用env_get_ulong 函数获取环境变量中波特率的参数, 设置gd->flags，表示串口已经准备好了, get_current()->start()返回一个指向当前被选择的串口的指针
> + console_init_f
> + display_options 
> + spl_relocate_stack_gd 