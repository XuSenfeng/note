# 阻塞和非阻塞IO

## 使用

+ 定义并初始化一个等待队列使用`init_waitqueue_head`或者使用`DECLARE_WAIT_QUEUE_HEAD(name, tsk)`一次性初始化以及定义
+ 初始化等待队列项`DECLARE_WAITQUEUE(name, tsk)`使用`add_wait_queue`进行等待
+ 或者添加`wait_event`进行等待事件
+ 获取到相应的资源以后唤醒`wake_up`
+ 被唤醒的资源需要处理是否为信号的判断

#### IO操作

- 数据读取/发送

#### 两个阶段

- 用户空间<=>内核空间
- 内核空间<=>file_operation

#### 阻塞操作

请求的资源没有准备好，进程/线程睡眠等待，直到数据准备完毕

![image-20200904164240430](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509251452576.png)

#### 非阻塞操作

请求的资源没有准备好，直接返回错误信息

![image-20200904164346909](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509251452336.png)

#### O_NONBLOCK

open函数的非阻塞标志

## 非阻塞实际使用

```c
/*字符设备操作函数集，open函数*/
static int led_chr_dev_open(struct inode *inode, struct file *filp)
{
	if(filp->f_flags &O_NONBLOCK)
	{
		if(down_trylock(&sem))
		{
			return -EBUSY;
		}
	}
	else
		down(&sem);
	printk("\n open form driver \n");
	return 0;
}
```

## 设备驱动的阻塞IO：等待队列

请求数据没有准备好时，让该进程睡眠直到数据准备好为止

#### 等待队列头

 include/linux/wait.h

```c
struct wait_queue_head {
	spinlock_t		lock;
	struct list_head	head;
};
typedef struct wait_queue_head wait_queue_head_t;
```

#### 初始化等待队列头

##### init_waitqueue_head()

 include/linux/wait.h

```c
#define init_waitqueue_head(wq_head)						   \
	do {													\
		static struct lock_class_key __key;				   	    \
															\
		__init_waitqueue_head((wq_head), #wq_head, &__key);		 \
	} while (0)
```

##### 静态定义并初始化

一个函数实现以上的内容

```
#define DECLARE_WAIT_QUEUE_HEAD(name) \
	struct wait_queue_head name = __WAIT_QUEUE_HEAD_INITIALIZER(name)
```

#### 等待队列元素

 include/linux/wait.h

```c
struct wait_queue_entry {
	unsigned int		flags;
	void			*private;
	wait_queue_func_t	func;
	struct list_head	entry; // 使用这个节点进行连接
};
typedef struct wait_queue_entry wait_queue_entry_t
```

#### 初始化静态队列

##### 静态定义并初始化

include/linux/wait.h

```c
#define DECLARE_WAITQUEUE(name, tsk)						\
	struct wait_queue_entry name = __WAITQUEUE_INITIALIZER(name, tsk)
```

>   tsk表示这个等待队列项属于哪个任务(进程)，一般设置为`current`，在 Linux内核中 `current` 相当于一个全局变量，表示当前进程

#### 添加等待队列

add_wait_queue()函数, 可以和wait_event函数二选一

kernel/sched/wait.c

```c
void add_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry);
```

参数：

- q ：等待队列项要加入的等待队列头。

- wq_entry：要加入的等待队列项。

返回值：无

> 在这个函数调用之后可以使用`__set_current_state(TASK_INTERRUPTIBLE)`设置这个任务可以被信号打断, 之后使用`schedule()`切换任务下面在运行的都是唤醒以后的, 需要处理运行到这了的原因
>
> 示例:
>
> ```c
> __set_current_state(TASK_RUNNING);
> remove_wait_queue(&port->delta_msr_wait, &wait);  
> /* see if a signal did it 判断是不是被信号打断 */
> if (signal_pending(current)) {
>     ret = -ERESTARTSYS;
>     return ret;
> }
> ```

#### 移除等待队列

remove_wait_queue()函数

kernel/sched/wait.c

```c
void remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry);
```

参数：

- q ：等待队列项要加入的等待队列头。

- wq_entry：要删除的等待队列项。

返回值：无

#### 等待事件

include/linux/wait.h

```c
wait_event(wq_head, condition)  // 进入睡眠 屏蔽信号
wait_event_interruptible(wq_head, condition) // 可以被信号唤醒
wait_event_timeout(wq_head, condition, timeout)	
```

参数：

- wq_head ：等待队列项要加入的等待队列头。

- condition：唤醒条件, 是一个bool条件, 在被wakeup的时候会判断这个变量
- timeout：超时时间

#### 等待唤醒

kernel/sched/wait.c

唤醒, 同时需要保证之前的condition为1

```c
void wake_up(wait_queue_head_t *q)
void wake_up_interruptible(wait_queue_head_t *q)
```

参数：

- q 就是要唤醒的等待队列头

返回值：无

## 实际使用

```c
wait_queue_head_t wait_queue;
unsigned int write_data; //用于保存接收到的数据

/*字符设备操作函数集，open函数*/
static int led_chr_dev_open(struct inode *inode, struct file *filp)
{

	printk("\n open form driver \n");
	return 0;
}

/*字符设备操作函数集，write函数*/
static ssize_t led_chr_dev_write(struct file *filp, const char __user *buf, size_t cnt, loff_t *offt)
{

	int ret,error;
	unsigned char receive_data[10]; //用于保存接收到的数据
	

	if(cnt>10)
			cnt =10;

	error = copy_from_user(receive_data, buf, cnt);
	if (error < 0)
	{
		return -1;
	}
	// 获取的数据转换为int类型
	ret = kstrtoint(receive_data, 16, &write_data);
	if (ret) {
		return -1;
  }

	if(write_data)
	{
    // 不是1的时候唤醒
		wake_up(&wait_queue);
		return cnt;
	}
	else
	{
        // 是0的时候所有的进入睡眠 
		wait_event(wait_queue,write_data);	
	}
	

	/*设置 GPIO1_04 输出电平*/
	if (write_data )
	{
		gpio_set_value(rgb_led_red,0);
	}

	return cnt;
}
```
