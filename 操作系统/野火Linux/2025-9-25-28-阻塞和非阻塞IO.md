# 阻塞和非阻塞IO

#### IO操作

- 数据读取/发送

#### 两个阶段

- 用户空间<=>内核空间
- 内核空间<=>file_operation

#### 阻塞操作

请求的资源没有准备好，进程/线程睡眠等待，直到数据准备完毕

![image-20200904164240430](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509251452576.png)

#### 非阻塞操作

请求的资源没有准备好，直接返回错误信息

![image-20200904164346909](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509251452336.png)

#### O_NONBLOCK

open函数的非阻塞标志

## 实际使用

```c
/*字符设备操作函数集，open函数*/
static int led_chr_dev_open(struct inode *inode, struct file *filp)
{
	if(filp->f_flags &O_NONBLOCK)
	{
		if(down_trylock(&sem))
		{
			return -EBUSY;
		}
	}
	else
		down(&sem);
	printk("\n open form driver \n");
	return 0;
}
```

## 设备驱动的阻塞IO：等待队列

请求数据没有准备好时，让该进程睡眠直到数据准备好为止

#### 等待队列头

 include/linux/wait.h

```c
struct wait_queue_head {
	spinlock_t		lock;
	struct list_head	head;
};
typedef struct wait_queue_head wait_queue_head_t;
```

#### 初始化等待队列头

##### init_waitqueue_head()

 include/linux/wait.h

```c
#define init_waitqueue_head(wq_head)						   \
	do {													\
		static struct lock_class_key __key;				   	    \
															\
		__init_waitqueue_head((wq_head), #wq_head, &__key);		 \
	} while (0)
```

##### 静态定义并初始化

一个函数实现以上的内容

```
#define DECLARE_WAIT_QUEUE_HEAD(name) \
	struct wait_queue_head name = __WAIT_QUEUE_HEAD_INITIALIZER(name)
```

#### 等待队列元素

 include/linux/wait.h

```c
struct wait_queue_entry {
	unsigned int		flags;
	void			*private;
	wait_queue_func_t	func;
	struct list_head	entry; // 使用这个节点进行连接
};
typedef struct wait_queue_entry wait_queue_entry_t
```

#### 初始化静态队列

##### 静态定义并初始化

include/linux/wait.h

```
#define DECLARE_WAITQUEUE(name, tsk)						\
	struct wait_queue_entry name = __WAITQUEUE_INITIALIZER(name, tsk)
```

#### 添加等待队列

add_wait_queue()函数

kernel/sched/wait.c

```c
void add_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry);
```

参数：

- q ：等待队列项要加入的等待队列头。

- wq_entry：要加入的等待队列项。

返回值：无

#### 移除等待队列

remove_wait_queue()函数

kernel/sched/wait.c

```c
void remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry);
```

参数：

- q ：等待队列项要加入的等待队列头。

- wq_entry：要删除的等待队列项。

返回值：无

#### 等待事件

include/linux/wait.h

```c
wait_event(wq_head, condition)  // 进入睡眠 屏蔽信号
wait_event_interruptible(wq_head, condition)
wait_event_timeout(wq_head, condition, timeout)	
```

参数：

- wq_head ：等待队列项要加入的等待队列头。

- condition：唤醒条件, 是一个bool条件
- timeout：超时时间

#### 等待唤醒

kernel/sched/wait.c

唤醒, 同时需要保证之前的condition为1

```c
void wake_up(wait_queue_head_t *q)
void wake_up_interruptible(wait_queue_head_t *q)
```

参数：

- q 就是要唤醒的等待队列头

返回值：无

## 实际使用

```c
wait_queue_head_t wait_queue;
unsigned int write_data; //用于保存接收到的数据

/*字符设备操作函数集，open函数*/
static int led_chr_dev_open(struct inode *inode, struct file *filp)
{

	printk("\n open form driver \n");
	return 0;
}

/*字符设备操作函数集，write函数*/
static ssize_t led_chr_dev_write(struct file *filp, const char __user *buf, size_t cnt, loff_t *offt)
{

	int ret,error;
	unsigned char receive_data[10]; //用于保存接收到的数据
	

	if(cnt>10)
			cnt =10;

	error = copy_from_user(receive_data, buf, cnt);
	if (error < 0)
	{
		return -1;
	}
	// 获取的数据转换为int类型
	ret = kstrtoint(receive_data, 16, &write_data);
	if (ret) {
		return -1;
        }

	if(write_data)
	{
        // 不是1的时候唤醒
		wake_up(&wait_queue);
		return cnt;
	}
	else
	{
        // 是0的时候所有的进入睡眠 
		wait_event(wait_queue,write_data);	
	}
	

	/*设置 GPIO1_04 输出电平*/
	if (write_data )
	{
		gpio_set_value(rgb_led_red,0);
	}

	return cnt;
}
```

