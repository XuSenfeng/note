# pinctrl子系统

## iomux节点

- 汇总所需引脚的配置信息
- pinctrl子系统预存iomux节点信息

#### iomuxc节点

- **imx6ull.dtsi**

    ```json
    iomuxc: iomuxc@20e0000 {
    				compatible = "fsl,imx6ul-iomuxc";
    				reg = <0x20e0000 0x4000>;
    			};
    ```

    - compatible：与pinctrl子系统的平台驱动做匹配
    - reg：引脚配置寄存器的基地址

    > 这个文件里面是最基础的属性

- **imx6ull-seeed-npi.dts**

    ```json
    &iomuxc {
    	pinctrl-names = "default"，"init","sleep";
    	pinctrl-0 = <&pinctrl_hog_1>;
    	pinctrl-1 =<&xxx>;
    	pinctrl-2 =<&yyy>;
    	
    	pinctrl_hog_1: hoggrp-1 {
    		fsl,pins = <
    			MX6UL_PAD_UART1_RTS_B__GPIO1_IO19	0x17059 /* SD1 CD */
    			MX6UL_PAD_GPIO1_IO05__USDHC1_VSELECT	0x17059 /* SD1 VSELECT */
    			MX6UL_PAD_GPIO1_IO09__GPIO1_IO09        0x17059 /* SD1 RESET */
    		>;
    	};
    ...
    	pinctrl_uart1: uart1grp {
    		fsl,pins = <
    			MX6UL_PAD_UART1_TX_DATA__UART1_DCE_TX 0x1b0b1
    			MX6UL_PAD_UART1_RX_DATA__UART1_DCE_RX 0x1b0b1
    		>;
    	};
    ...
    }
    ```

> 进行属性的追加

- **`pinctrl-names`**: 定义了三个状态的名称列表。
    - `"default"`: **默认状态**。当设备被正常启用时（例如 `probe` 函数中），内核会自动将此状态应用到硬件上。
    - `"init"`: **初始化状态**。可能用于设备初始化过程中某个特殊阶段，需要由驱动代码显式调用。
    - `"sleep"`: **睡眠状态**。当设备挂起或系统进入低功耗模式时，内核会自动切换到此状态。通常用于将引脚配置为漏电最小的状态（如上拉、下拉或高阻态）以省电。
- **`pinctrl-0`**, **`pinctrl-1`**, **`pinctrl-2`**:
    这些属性将状态名称**映射**到具体的引脚配置组（`phandle`）。
    - `pinctrl-0` 对应 `pinctrl-names` 中的第一个名字 `"default"`，它引用了 `&pinctrl_hog_1` 这个配置组。
    - `pinctrl-1` 对应 `"init"`，引用一个名为 `xxx` 的配置组（示例中未完整给出）。
    - `pinctrl-2` 对应 `"sleep"`，引用一个名为 `yyy` 的配置组（示例中未完整给出）。

**注意**：`pinctrl_hog_1` 通常用于那些在系统生命周期内**永远不需要改变功能**的引脚（例如，始终作为 GPIO 驱动一个 LED，或者被硬件固定了功能），这些引脚在系统启动早期就被配置好，之后就不再变动，俗称“钉死的”（Hogged）引脚。



这部分定义了一个名为 `pinctrl_uart1` 的引脚配置组，它的标签（label）是 `uart1grp`。这个组描述了一组引脚应该如何配置，以实现某个特定功能（这里是 UART1）。

- **`pinctrl_uart1`**: 这是该节点的**句柄（handle）**，可以被其他节点（如 `&pinctrl-0`）或串口设备节点引用。`uart1grp` 是节点名，方便阅读。
- **`fsl,pins`**: 这是 NXP/Freescale i.MX 平台特有的属性，用于列出该配置组中所有引脚的设置。它是一个由多个 `<宏定义 电气属性值>` 组成的列表。
    - **宏定义 (例如 `MX6UL_PAD_UART1_TX_DATA__UART1_DCE_TX`)**:
        这是一个在头文件（如 `imx6ul-pinfunc.h``）中定义好的宏，它唯一地确定了：
        1. **哪个物理引脚**（例如：`MX6UL_PAD_UART1_TX_DATA`）
        2. **复用为何种功能**（例如：`__UART1_DCE_TX`，即作为 UART1 的设备（DCE）发送引脚）
            **DCE** 指的是数据通信设备（如调制解调器），在 i.MX 上下文中，通常用于区分 TX/RX 方向。`DCE_TX` 意味着这个引脚是 UART 的**输出**脚。
    - **电气属性值 (例如 `0x1b0b1`)**:
        这是一个十六进制数，配置了该引脚除功能复用之外的**所有电气特性**。它代表了芯片参考手册中 **IOMUXC 寄存器**的配置值。每一位的含义通常包括：
        - **速度** (Slew Rate)
        - **驱动强度** (Drive Strength)
        - **上拉/下拉电阻** (Pull-up / Pull-down)
        - ** hysteresis** (施密特触发器使能)
        - **开漏** (Open Drain)
            值 `0x1b0b1` 是一组经过验证的、适用于中低速外设（如 UART）的稳定配置，通常保证了适当的驱动能力和上拉。

#### 节点配置信息记录

- **fsl,pins**

    - 结合imx6ull的pinctrl子系统驱动使用
    - 以该属性来标识引脚的配置信息

- **fsl,pins属性值**

    一个宏+一个十六进制数

    ```
    MX6UL_PAD_UART1_TX_DATA__UART1_DCE_TX 0x1b0b1
    ```

- **宏定义原型**

    imx6ull.dtsi ->#include "imx6ull-pinfunc.h"->\#include "imx6ul-pinfunc.h"

    ```
    #define MX6UL_PAD_UART1_TX_DATA__UART1_DCE_TX 0x0084 0x0310 0x0000 0 0
    ```

- **宏值含义**

    ```
    <mux_reg conf_reg input_reg mux_mode input_val>
     0x0084    0x0310    0x0000     0x0      0x0
    ```

    - mux_reg：引脚复用设置寄存器

        ![image-20200821153238037](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509041642615.png)

    - conf_reg：引脚属性设置寄存器

        ![image-20200821153304942](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509041709436.png)

    - input_reg：引脚输入设置寄存器

    - 引脚需要输入功能时设置

    - mux_mode：复用寄存器设置值, 设置引脚复用

    - input_value：输入寄存器设置值

        - 设置引脚输入特性

- **十六进制数**

    属性寄存器设置值conf_reg

    - 特性复杂，独立设置

## imx_pinctrl和pinctrl_dev

pinctrl子系统预先确定引脚的数量和名字

- 为每个引脚的配置信息分配内存, 解析所有的数据 以后会记录这部分信息在内存里面
- 管理每个引脚的使用状态

#### imx6ul_pinctrl_probe()函数

drivers/pinctrl/freescale/pinctrl-imx6ul.c

```c
static const struct imx_pinctrl_soc_info imx6ul_pinctrl_info = {
	.pins = imx6ul_pinctrl_pads, // 赋的值是一个结构体数组, 实际是所有芯片引脚的名字以及编号
	.npins = ARRAY_SIZE(imx6ul_pinctrl_pads),
	.gpr_compatible = "fsl,imx6ul-iomuxc-gpr",
};

static int imx6ul_pinctrl_probe(struct platform_device *pdev)
{
	const struct imx_pinctrl_soc_info *pinctrl_info;
	const struct of_device_id *match;
	// 从设备树中获取匹配的设备数据(未使用)
	pinctrl_info = of_device_get_match_data(&pdev->dev);
	if (!pinctrl_info)
		return -ENODEV;
	// 判断一下这两个是不是匹配
	match = of_match_device(imx6ul_pinctrl_of_match, &pdev->dev);

	if (!match)
		return -ENODEV;
	// 获取到imx6ul_pinctrl_of_match里面的对应的项imx6ul_pinctrl_info
	pinctrl_info = (struct imx_pinctrl_soc_info *) match->data;

	return imx_pinctrl_probe(pdev, pinctrl_info);
}
```

```c
// pin对应的结构
struct pinctrl_pin_desc {
	unsigned number;
	const char *name;
	void *drv_data;
};

struct imx_pinctrl_soc_info {
	const struct pinctrl_pin_desc *pins;
	unsigned int npins;
	unsigned int flags;
	const char *gpr_compatible;
	...
	}

165~295
```

#### of_device_get_match_data()函数

drivers/of/device.c

```c
const void *of_device_get_match_data(const struct device *dev)
{
	const struct of_device_id *match;

	match = of_match_device(dev->driver->of_match_table, dev);
	if (!match)
		return NULL;

	return match->data;
}
```

#### of_match_device()函数

```c
const struct of_device_id *of_match_device(const struct of_device_id *matches,
					   const struct device *dev)
{
	if ((!matches) || (!dev->of_node))
		return NULL;
	return of_match_node(matches, dev->of_node);
}
```



#### imx6ul_pinctrl_pads

- 引脚的编号和名字表

##### IMX_PINCTRL_PIN宏

drivers/pinctrl/freescale/pinctrl-imx.h

```
#define IMX_PINCTRL_PIN(pin) PINCTRL_PIN(pin, #pin)
```

##### PINCTRL_PIN宏

include/linux/pinctrl/pinctrl.h

```
#define PINCTRL_PIN(a, b) { .number = a, .name = b }
```

##### 引脚编号与复用寄存器的关系

pin.num = mux/4

#### imx_pinctrl：存储引脚的名字和编号原始表

##### imx_pinctrl_probe()函数

```
int imx_pinctrl_probe(struct platform_device *pdev,
		      const struct imx_pinctrl_soc_info *info)
{
	struct imx_pinctrl *ipctl;
	struct pinctrl_desc *imx_pinctrl_desc;
	...
	ipctl = devm_kzalloc(&pdev->dev, sizeof(*ipctl), GFP_KERNEL);
	...
	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
	ipctl->base = devm_ioremap_resource(&pdev->dev, res);
	...
	imx_pinctrl_desc = devm_kzalloc(&pdev->dev, sizeof(*imx_pinctrl_desc),GFP_KERNEL);
	...
	imx_pinctrl_desc->name = dev_name(&pdev->dev);
	imx_pinctrl_desc->pins = info->pins;
	imx_pinctrl_desc->npins = info->npins;
	imx_pinctrl_desc->pctlops = &imx_pctrl_ops;
	imx_pinctrl_desc->pmxops = &imx_pmx_ops;
	imx_pinctrl_desc->confops = &imx_pinconf_ops;
	imx_pinctrl_desc->owner = THIS_MODULE;
	...
	ipctl->info = info;
	ipctl->dev = &pdev->dev;
	platform_set_drvdata(pdev, ipctl);
	...
	ret = devm_pinctrl_register_and_init(&pdev->dev,
					     imx_pinctrl_desc, ipctl,
					     &ipctl->pctl);
	...
	ret = imx_pinctrl_probe_dt(pdev, ipctl);
	...
	return pinctrl_enable(ipctl->pctl);
	...
	return ret;
}
	
```

#### pinctrl_desc：以基数树的方式存储引脚的名字，记录引脚的使用状态

##### devm_pinctrl_register_and_init()函数

drivers/pinctrl/core.c

```
int pinctrl_register_and_init(struct pinctrl_desc *pctldesc,
			      struct device *dev, void *driver_data,
			      struct pinctrl_dev **pctldev)
{
	struct pinctrl_dev *p;

	p = pinctrl_init_controller(pctldesc, dev, driver_data);
	if (IS_ERR(p))
		return PTR_ERR(p);

	*pctldev = p;

	return 0;
}
```

##### pinctrl_init_controller()函数

drivers/pinctrl/core.c

```
static struct pinctrl_dev *
pinctrl_init_controller(struct pinctrl_desc *pctldesc, struct device *dev,
			void *driver_data)
{
	struct pinctrl_dev *pctldev;
	...
	pctldev = kzalloc(sizeof(*pctldev), GFP_KERNEL);
	...
	pctldev->owner = pctldesc->owner;
	pctldev->desc = pctldesc;
	pctldev->driver_data = driver_data;
	/*初始化基数树*/
	INIT_RADIX_TREE(&pctldev->pin_desc_tree, GFP_KERNEL);
	...
	pctldev->dev = dev;
	...
	ret = pinctrl_register_pins(pctldev, pctldesc->pins, pctldesc->npins);
	...
	return pctldev;
	...
}
```

##### pinctrl_register_pins()函数

drivers/pinctrl/core.c

```
static int pinctrl_register_pins(struct pinctrl_dev *pctldev,
				 const struct pinctrl_pin_desc *pins,
				 unsigned num_descs)
{
	unsigned i;
	int ret = 0;

	for (i = 0; i < num_descs; i++) {
		ret = pinctrl_register_one_pin(pctldev, &pins[i]);
		if (ret)
			return ret;
	}

	return 0;
}
```

##### pinctrl_register_one_pin()函数

drivers/pinctrl/core.c

```
static int pinctrl_register_one_pin(struct pinctrl_dev *pctldev,
				    const struct pinctrl_pin_desc *pin)
{
	struct pin_desc *pindesc;

	pindesc = pin_desc_get(pctldev, pin->number);
	if (pindesc) {
		dev_err(pctldev->dev, "pin %d already registered\n",
			pin->number);
		return -EINVAL;
	}

	pindesc = kzalloc(sizeof(*pindesc), GFP_KERNEL);
	...
	pindesc->pctldev = pctldev;
	...
	if (pin->name) {
		pindesc->name = pin->name;
	} else {
		pindesc->name = kasprintf(GFP_KERNEL, "PIN%u", pin->number);
		if (!pindesc->name) {
			kfree(pindesc);
			return -ENOMEM;
		}
		pindesc->dynamic_name = true;
	}
	...
	radix_tree_insert(&pctldev->pin_desc_tree, pin->number, pindesc);
	...
	return 0;
}
```

