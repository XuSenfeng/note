# Uboot启动

## 第二阶段

![image-20251009223704936](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510092237979.png)

### board_init_r函数

运行init_sequence_r里面的成员函数

```c
staticinit_fnc_t init_sequence_r[]= {
    initr_trace, /*初始化与跟踪调试相关部分*/
    initr_reloc, /*标记重定位完成*/
    initr_caches, /*使能cache*/
    initr_reloc_global_data, /*初始化重定位后的gd成员*/
    initr_barrier, /*imx6ull未用到*/
    initr_malloc, /*初始化malloc*/
    log_init, /*log初始化*/
    initr_bootstage, /*Needsmalloc() buthasitsowntimer*/
    initr_console_record, /*初始化控台*/
    bootstage_relocate,
    initr_dm, /*设备模型初始化, 加载设备树, 
    		绑定根节点到 gd->dm_root 中
    		获取soc下面的clocks节点以及firmware节点*/
    board_init, /*板级初始化*/
    efi_memory_init, /*efi_memory初始化*/
	stdio_init_tables, /*标准输入输出及标准错误等初始化*/
	initr_serial, /*串口初始化*/
	initr_announce, /*跟调试相关*/
	power_init_board, /*电源芯片初始化*/
	initr_nand, /*nandflash初始化*/
	initr_mmc, /*mmc初始化*/
	initr_env, /*环境变量初始化 => env_relocate => env_load*/
	initr_secondary_cpu, /*其他cpu初始化，由于imx6ull为单核cpu故忽略*/
	stdio_add_devices, /*输入输出设备初始化*/
	initr_jumptable, /*初始化跳转表*/
	console_init_r, /*控制台初始化*/
	interrupt_init, /*中断初始化*/
	initr_enable_interrupts, /*中断使能*/
	/* PPC has audelay(20)here datingfrom2002.Why?*/
	initr_ethaddr, /*网络初始化*/
	board_late_init, /*板子后续初始化*/
	initr_fastboot_setup,
	initr_net, /*网络初始化*/
	initr_check_fastboot,
	run_main_loop, /*运行主循环*/
};
```

run_main_loop => main_loop

> uboot 启动以后会进入 3 秒倒计时，如果在3秒倒计时结束之前按下按下回车键，那么就 会进入uboot的命令模式，如果倒计时结束以后都没有按下回车键，那么就会自动启动Linux内 核，这个功能就是由run_main_loop函数来完成的
>
> ```c
> /* We come here after U-Boot is initialised and ready to process commands */
> void main_loop(void)
> {
> 	const char *s;
> 
> 	bootstage_mark_name(BOOTSTAGE_ID_MAIN_LOOP, "main_loop");
> 
> #ifndef CONFIG_SYS_GENERIC_BOARD
> 	puts("Warning: Your board does not use generic board. Please read\n");
> 	puts("doc/README.generic-board and take action. Boards not\n");
> 	puts("upgraded by the late 2014 may break or be removed.\n");
> #endif
> 
> #ifdef CONFIG_VERSION_VARIABLE
> 	setenv("ver", version_string);  /* set version variable */
> #endif /* CONFIG_VERSION_VARIABLE */
> 
> 	cli_init(); // 初始化hush_shell, 用于处理命令
> 	// 获取环境变量 perboot 的内容，perboot 是一些预启动命令，一般不使用这个环境变量
> 	run_preboot_environment_command();
> 
> #if defined(CONFIG_UPDATE_TFTP)
> 	update_tftp(0UL, NULL, NULL);
> #endif /* CONFIG_UPDATE_TFTP */
> 	// 此函数会读取环境变量 bootdelay 和 bootcmd 的内容，
> 	// 然后将bootdelay 的值赋值给全局变量stored_bootdelay，返回值为环境变量bootcmd
> 	s = bootdelay_process();
> 	if (cli_process_fdt(&s)) // cli_process_fdt函数返回值为false
> 		cli_secure_boot_cmd(s);
> 
> 	autoboot_command(s);
> 
> 	cli_loop();
> }
> ```
>
> 

#### bootdelay_process

环境变量中搜索bootdelay这个环境变量（字符串形式），如果有配置该环境变量则会将字符串转换成长整型数值

从环境变量中获取bootcmd

若stored_bootdelay!=-1，且bootcmd有值，同时在启动过程中没有检测到任何 打断启动过程的输入，则运行启动命令列表`run_command_list`中的一系列命令,即默认的 `bootcmd`命令，其中`stored_bootdelay`会在`abortboot`函数主每过一秒钟减1

如果我们在启动倒计时bootdelay减为0之前 按下了按键打断其自启动过程，就会进入cli_loop函数，此函数负责不断循环检测并处理 用户输入的命令

#### autoboot_command

处理倒计时, 没有按键的时候进入命令行处理

```c
void autoboot_command(const char *s)
{
	debug("### main_loop: bootcmd=\"%s\"\n", s ? s : "<UNDEFINED>");

	if (stored_bootdelay != -1 && s && !abortboot(stored_bootdelay)) {
#if defined(CONFIG_AUTOBOOT_KEYED) && !defined(CONFIG_AUTOBOOT_KEYED_CTRLC)
		int prev = disable_ctrlc(1);	/* disable Control C checking */
#endif

		run_command_list(s, -1, 0); // 实际只有这个命令在执行

#if defined(CONFIG_AUTOBOOT_KEYED) && !defined(CONFIG_AUTOBOOT_KEYED_CTRLC)
		disable_ctrlc(prev);	/* restore Control C checking */
#endif
	}

#ifdef CONFIG_MENUKEY
	if (menukey == CONFIG_MENUKEY) {
		s = getenv("menucmd");
		if (s)
			run_command_list(s, -1, 0);
	}
#endif /* CONFIG_MENUKEY */
}
```

abortboot: 处理倒计时

```c
static int abortboot(int bootdelay)
{
#ifdef CONFIG_AUTOBOOT_KEYED
	return abortboot_keyed(bootdelay);
#else
	return abortboot_normal(bootdelay); // 实际运行的函数
#endif
}

```

```c
static int abortboot_normal(int bootdelay)
{
	int abort = 0;
	unsigned long ts;

#ifdef CONFIG_MENUPROMPT
	printf(CONFIG_MENUPROMPT);
#else
	if (bootdelay >= 0)
		printf("Hit any key to stop autoboot: %2d ", bootdelay);
#endif

#if defined CONFIG_ZERO_BOOTDELAY_CHECK
	/*
	 * Check if key already pressed
	 * Don't check if bootdelay < 0
	 */
	if (bootdelay >= 0) {
		if (tstc()) {	/* we got a key press	*/
			(void) getc();  /* consume input	*/
			puts("\b\b\b 0");
			abort = 1;	/* don't auto boot	*/
		}
	}
#endif

	while ((bootdelay > 0) && (!abort)) {
		--bootdelay;
		/* delay 1000 ms */
		ts = get_timer(0);
		do {
			if (tstc()) {	/* we got a key press	*/
				abort  = 1;	/* don't auto boot	*/
				bootdelay = 0;	/* no more delay	*/
# ifdef CONFIG_MENUKEY
				menukey = getc();
# else
				(void) getc();  /* consume input	*/
# endif
				break;
			}
			udelay(10000);
		} while (!abort && get_timer(ts) < 1000);

		printf("\b\b\b%2d ", bootdelay);
	}

	putc('\n');

#ifdef CONFIG_SILENT_CONSOLE
	if (abort)
		gd->flags &= ~GD_FLG_SILENT;
#endif

	return abort;
}
```

#### cli_loop

命令行处理函数

```c
void cli_loop(void)
{
#ifdef CONFIG_SYS_HUSH_PARSER
	parse_file_outer(); // 运行这个
	/* This point is never reached */
	for (;;);
#else
	cli_simple_loop();
#endif /*CONFIG_SYS_HUSH_PARSER*/
}
```

```c
int parse_file_outer(void)
#endif
{
	int rcode;
	struct in_str input;
#ifndef __U_BOOT__
	setup_file_in_str(&input, f);
#else
	setup_file_in_str(&input); //这里, 初始化变量input的成员变量
#endif
	rcode = parse_stream_outer(&input, FLAG_PARSE_SEMICOLON); //hush shell的命令解释器
	return rcode;
}
```

```c
/* most recursion does not come through here, the exeception is
 * from builtin_source() */
static int parse_stream_outer(struct in_str *inp, int flag)
{

	struct p_context ctx;
	o_string temp=NULL_O_STRING;
	int rcode;
#ifdef __U_BOOT__
	int code = 1;
#endif
	do {
        // 处理输入命令
		ctx.type = flag;
		initialize_context(&ctx);
		update_ifs_map();
		if (!(flag & FLAG_PARSE_SEMICOLON) || (flag & FLAG_REPARSING)) mapset((uchar *)";$&|", 0);
		inp->promptmode=1;
		rcode = parse_stream(&temp, &ctx, inp,
				     flag & FLAG_CONT_ON_NEWLINE ? -1 : '\n'); // 命令解析
#ifdef __U_BOOT__
		if (rcode == 1) flag_repeat = 0;
#endif
		if (rcode != 1 && ctx.old_flag != 0) {
			syntax();
#ifdef __U_BOOT__
			flag_repeat = 0;
#endif
		}
		if (rcode != 1 && ctx.old_flag == 0) {
			done_word(&temp, &ctx);
			done_pipe(&ctx,PIPE_SEQ);
#ifndef __U_BOOT__
			run_list(ctx.list_head); // 执行解析出来的命令, 最终通过调用cmd_process函数来处理命令
#else
			code = run_list(ctx.list_head);
			if (code == -2) {	/* exit */
				b_free(&temp);
				code = 0;
				/* XXX hackish way to not allow exit from main loop */
				if (inp->peek == file_peek) {
					printf("exit not allowed from main input shell.\n");
					continue;
				}
				break;
			}
			if (code == -1)
			    flag_repeat = 0;
#endif
		} else {
			if (ctx.old_flag != 0) {
				free(ctx.stack);
				b_reset(&temp);
			}
#ifdef __U_BOOT__
			if (inp->__promptme == 0) printf("<INTERRUPT>\n");
			inp->__promptme = 1;
#endif
			temp.nonnull = 0;
			temp.quote = 0;
			inp->p = NULL;
			free_pipe_list(ctx.list_head,0);
		}
		b_free(&temp);
	/* loop on syntax errors, return on EOF */
	} while (rcode != -1 && !(flag & FLAG_EXIT_FROM_LOOP) &&
		(inp->peek != static_peek || b_peek(inp)));
#ifndef __U_BOOT__
	return 0;
#else
	return (code != 0) ? 1 : 0;
#endif /* __U_BOOT__ */
}
```

最后的处理命令的函数是run_list=>run_list_real=>run_pipe_real=>cmd_process

##### cmd_process

uboot里面的命令存储使用的是一个宏定义的形式使用的是`U_BOOT_CMD`

```c
#define ll_entry_declare(_type, _name, _list)				\
	_type _u_boot_list_2_##_list##_2_##_name __aligned(4)		\
			__attribute__((unused,				\
			section(".u_boot_list_2_"#_list"_2_"#_name)))

#define U_BOOT_CMD_MKENT_COMPLETE(_name, _maxargs, _rep, _cmd,		\
				_usage, _help, _comp)			\
		{ #_name, _maxargs, _rep, _cmd, _usage,			\
			_CMD_HELP(_help) _CMD_COMPLETE(_comp) }

#define U_BOOT_CMD_MKENT(_name, _maxargs, _rep, _cmd, _usage, _help)	\
	U_BOOT_CMD_MKENT_COMPLETE(_name, _maxargs, _rep, _cmd,		\
					_usage, _help, NULL)

#define U_BOOT_CMD_COMPLETE(_name, _maxargs, _rep, _cmd, _usage, _help, _comp) \
	ll_entry_declare(cmd_tbl_t, _name, cmd) =			\
		U_BOOT_CMD_MKENT_COMPLETE(_name, _maxargs, _rep, _cmd,	\
						_usage, _help, _comp);

#define U_BOOT_CMD(_name, _maxargs, _rep, _cmd, _usage, _help)		\
	U_BOOT_CMD_COMPLETE(_name, _maxargs, _rep, _cmd, _usage, _help, NULL)
```

依次展开以后

```c
U_BOOT_CMD( 
    dhcp,   3,  1,  do_dhcp, 
    "boot image via network using DHCP/TFTP protocol", 
    "[loadAddress] [[hostIPaddr:]bootfilename]" 
);

U_BOOT_CMD_COMPLETE(dhcp, 3, 1, do_dhcp,  
                    "boot image via network using DHCP/TFTP protocol", 
                    "[loadAddress] [[hostIPaddr:]bootfilename]",  
                    NULL) 
    
ll_entry_declare(cmd_tbl_t, dhcp, cmd) =           \ 
U_BOOT_CMD_MKENT_COMPLETE(dhcp, 3, 1, do_dhcp,  \ 
                 "boot image via network using DHCP/TFTP protocol", \ 
                 "[loadAddress] [[hostIPaddr:]bootfilename]", \ 
                 NULL);


cmd_tbl_t _u_boot_list_2_cmd_2_dhcp __aligned(4)       \ 
            __attribute__((unused,section(.u_boot_list_2_cmd_2_dhcp))) \  
               
        { "dhcp", 3, 1, do_dhcp,  \ 
          "boot image via network using DHCP/TFTP protocol", \ 
          "[loadAddress] [[hostIPaddr:]bootfilename]",\  
          NULL} 
```

+ 定义了一个cmd_tbl_t类型的变量，变量名为_u_boot_list_2_cmd_2_dhcp，此变量4 字节对齐。
+ 使用`__attribute__`关键字设置变量`_u_boot_list_2_cmd_2_dhcp`存储在`.u_boot_list_2_cmd_2_dhcp`段中。u-boot.lds链接脚本中有一个名为`.u_boot_list`的段，所有.u_boot_list开 头的段都存放到.u_boot.list

```c
struct cmd_tbl_s {
	char		*name;		/* Command Name			*/
	int		maxargs;	/* maximum number of arguments	*/
	int		repeatable;	/* autorepeat allowed?		*/
					/* Implementation function	*/
	int		(*cmd)(struct cmd_tbl_s *, int, int, char * const []); // 处理函数
	char		*usage;		/* Usage message	(short)	*/
#ifdef	CONFIG_SYS_LONGHELP
	char		*help;		/* Help  message	(long)	*/
#endif
#ifdef CONFIG_AUTO_COMPLETE
	/* do auto completion on the arguments */
	int		(*complete)(int argc, char * const argv[], char last_char, int maxv, char *cmdv[]);
#endif
};
```

```c
enum command_ret_t cmd_process(int flag, int argc, char * const argv[],
			       int *repeatable, ulong *ticks)
{
	enum command_ret_t rc = CMD_RET_SUCCESS;
	cmd_tbl_t *cmdtp;

	/* Look up command in command table */
	cmdtp = find_cmd(argv[0]); // 从段里面查找这个命令
	if (cmdtp == NULL) {
		printf("Unknown command '%s' - try 'help'\n", argv[0]);
		return 1;
	}

	/* found - check max args */
	if (argc > cmdtp->maxargs)
		rc = CMD_RET_USAGE;

#if defined(CONFIG_CMD_BOOTD)
	/* avoid "bootd" recursion */
	else if (cmdtp->cmd == do_bootd) {
		if (flag & CMD_FLAG_BOOTD) {
			puts("'bootd' recursion detected\n");
			rc = CMD_RET_FAILURE;
		} else {
			flag |= CMD_FLAG_BOOTD;
		}
	}
#endif

	/* If OK so far, then do the command */
	if (!rc) {
		if (ticks)
			*ticks = get_timer(0);
		rc = cmd_call(cmdtp, flag, argc, argv); // 在这个函数直接调用处理函数
		if (ticks)
			*ticks = get_timer(*ticks);
		*repeatable &= cmdtp->repeatable;
	}
	if (rc == CMD_RET_USAGE)
		rc = cmd_usage(cmdtp);
	return rc;
}
```

## 加载内核

![image-20251028163225915](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510281632086.png)

因为内核是要运行在 DDR中的，因此就要将内核重定位到DDR中。前面我们讲了很多环境变量、设备树等，这些都 要传递给linux内核，Linux会读取这些参数，并且根据这些参数进行配置

对于linux内核而言， 这就不一样了，他需要u-boot帮他搭建好内核运行所必须的环境，配置各种寄存器，和硬件紧密 联系的是u-boot，而Linux地重定位也是由u-boot完成

是u-boot可以 从3个地方获取linux内核，如NAND启动/EMMC启动、SD卡启动、USB启动等。我们开发板 上板载了启动方式选择地拨码开关，根据下面表格设置拨码开关就可以实现从不同介质中加载 Linux 内核到DDR中运行, ，imx6ull在启动内核前会判断启动引脚地电平状态，根据启动引脚地电平状态选择不同的启动方式

不管是那种启动方式，最终都要将内核镜像加载到DDR中运行，当使用网络（tftp与nfs）启动时，还应该在u-boot的命令终端上配置相应的环境变量，如本机ip、服务器ip、网关、子网掩码等，特别提示：需要设置板子ip与服务器ip在同一个网段上才可以实现网络数据访问

当u-boot执行bootcmd的命令后，最终会调用do_bootz函数启动Linux内核

不管是bootz还是bootm命令，在启动Linux内核的时候都会用到一个重要的全局变量：images，images在文件cmd/bootm.c

```c
/*
 * Legacy and FIT format headers used by do_bootm() and do_bootm_<os>()
 * routines.
 */
typedef struct bootm_headers {
	/*
	 * Legacy os image header, if it is a multi component image
	 * then boot_get_ramdisk() and get_fdt() will attempt to get
	 * data from second and third component accordingly.
	 */
	image_header_t	*legacy_hdr_os;		/* image header pointer */
	image_header_t	legacy_hdr_os_copy;	/* header copy */
	ulong		legacy_hdr_valid;

#if defined(CONFIG_FIT)
	const char	*fit_uname_cfg;	/* configuration node unit name */

	void		*fit_hdr_os;	/* os FIT image header */
	const char	*fit_uname_os;	/* os subimage node unit name */
	int		fit_noffset_os;	/* os subimage node offset */

	void		*fit_hdr_rd;	/* init ramdisk FIT image header */
	const char	*fit_uname_rd;	/* init ramdisk subimage node unit name */
	int		fit_noffset_rd;	/* init ramdisk subimage node offset */

	void		*fit_hdr_fdt;	/* FDT blob FIT image header */
	const char	*fit_uname_fdt;	/* FDT blob subimage node unit name */
	int		fit_noffset_fdt;/* FDT blob subimage node offset */

	void		*fit_hdr_setup;	/* x86 setup FIT image header */
	const char	*fit_uname_setup; /* x86 setup subimage node name */
	int		fit_noffset_setup;/* x86 setup subimage node offset */
#endif

#ifndef USE_HOSTCC
	image_info_t	os;		/* os image info 为系统镜像信息 */
	ulong		ep;		/* entry point of OS OS入口点 */

	ulong		rd_start, rd_end;/* ramdisk start/end */

	char		*ft_addr;	/* flat dev tree address 设备树地址 */
	ulong		ft_len;		/* length of flat device tree 设备树长度 */

	ulong		initrd_start;
	ulong		initrd_end;
	ulong		cmdline_start;
	ulong		cmdline_end;
	bd_t		*kbd;
#endif

	int		verify;		/* getenv("verify")[0] != 'n' */
// 定义表示BOOT的不同阶段
#define	BOOTM_STATE_START	(0x00000001) // 引导过程开始
#define	BOOTM_STATE_FINDOS	(0x00000002) // 查找操作系统镜像
#define	BOOTM_STATE_FINDOTHER	(0x00000004)// 查找其他组件（设备树、ramdisk等）
#define	BOOTM_STATE_LOADOS	(0x00000008)// 加载操作系统到内存
#define	BOOTM_STATE_RAMDISK	(0x00000010)// 处理RAM磁盘（initrd/initramfs）
#define	BOOTM_STATE_FDT		(0x00000020)// 处理设备树（Flattened Device Tree）
#define	BOOTM_STATE_OS_CMDLINE	(0x00000040)// 准备内核命令行参数
#define	BOOTM_STATE_OS_BD_T	(0x00000080)// 准备板级信息表
#define	BOOTM_STATE_OS_PREP	(0x00000100)// 操作系统启动前准备
#define	BOOTM_STATE_OS_FAKE_GO	(0x00000200)	/* 模拟运行OS 'Almost' run the OS */
#define	BOOTM_STATE_OS_GO	(0x00000400)// 实际跳转到操作系统入口点
	int		state;

#ifdef CONFIG_LMB
	struct lmb	lmb;		/* for memory mgmt */
#endif
} bootm_headers_t;
```

```c
typedef struct image_info {
	ulong		start, end;		/* start/end of blob  blob开始和结束位置 */
	ulong		image_start, image_len; /* start of image within blob, len of image 
									镜像起始地址(包括blob)和长度 */
	ulong		load;			/* load addr for the image 系统镜像加载地址 */
	uint8_t		comp, type, os;		/* compression, type of image, os type 镜像压缩、类型，OS类型 */
	uint8_t		arch;			/* CPU architecture CPU架构 */
} image_info_t;
```

### bootz

启动命令是bootz, `bootz 80800000 - 83000000`, 第一个是镜像的加载地址, 第二个是设备树的地址

```c
int do_bootz(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	int ret;

	/* Consume 'bootz' */
	argc--; argv++;

	if (bootz_start(cmdtp, flag, argc, argv, &images))
		return 1;

	/*
	 * We are doing the BOOTM_STATE_LOADOS state ourselves, so must
	 * disable interrupts ourselves
	 */
	bootm_disable_interrupts(); // 关闭中断

	images.os.os = IH_OS_LINUX; // 设置images.os.os为IH_OS_LINUX，也就是设置系统镜像为Linux
    // 
	ret = do_bootm_states(cmdtp, flag, argc, argv,
			      BOOTM_STATE_OS_PREP | BOOTM_STATE_OS_FAKE_GO |
			      BOOTM_STATE_OS_GO,
			      &images, 1); // 调用函数do_bootm_states来执行不同的BOOT阶段
    				//BOOTM_STATE_OS_PREP 、BOOTM_STATE_OS_FAKE_GO和BOOTM_STATE_OS_GO

	return ret;
}
```

#### bootz_start

```c
/*
 * zImage booting support
 */
static int bootz_start(cmd_tbl_t *cmdtp, int flag, int argc,
			char * const argv[], bootm_headers_t *images)
{
	int ret;
	ulong zi_start, zi_end;
	// 处理状态实际运行bootm_start, 对全局变量images清零
	ret = do_bootm_states(cmdtp, flag, argc, argv, BOOTM_STATE_START,
			      images, 1); 

	/* Setup Linux kernel zImage entry point */
	if (!argc) {
		images->ep = load_addr;
		debug("*  kernel: default image load address = 0x%08lx\n",
				load_addr);
	} else {
        // 设置images的ep成员变量，也就是系统镜像的入口点, 0x87800000
		images->ep = simple_strtoul(argv[0], NULL, 16);
		debug("*  kernel: cmdline image address = 0x%08lx\n",
			images->ep);
	}
	//判断当前的系统镜像文件是否为Linux的镜像文件
    // 判断一下zi_image的zimage是不是0x016f2818, 从zImage文件的第37位开始
	ret = bootz_setup(images->ep, &zi_start, &zi_end);
	if (ret != 0)
		return 1;

	lmb_reserve(&images->lmb, images->ep, zi_end - zi_start);

	/*
	 * Handle the BOOTM_STATE_FINDOTHER state ourselves as we do not
	 * have a header that provide this informaiton.
	 * 在这里仅仅用于查找设备树(dtb)文件, 我们没有用到ramdisk, boot_get_fdt
	 * 初始化images的ft_addr以及ft_len, images.ft_addr=0X83000000，长度根据具体的设备树文件而定
	 */
	if (bootm_find_images(flag, argc, argv))
		return 1;

#ifdef CONFIG_SECURE_BOOT
	extern uint32_t authenticate_image(
			uint32_t ddr_start, uint32_t image_size);
	if (authenticate_image(images->ep, zi_end - zi_start) == 0) {
		printf("Authenticate zImage Fail, Please check\n");
		return 1;
	}
#endif
	return 0;
}
```

##### bootz_setup

```c
struct zimage_header {
	uint32_t	code[9];
	uint32_t	zi_magic;
	uint32_t	zi_start;
	uint32_t	zi_end;
};

#define	LINUX_ARM_ZIMAGE_MAGIC	0x016f2818

int bootz_setup(ulong image, ulong *start, ulong *end)
{
	struct zimage_header *zi;

	zi = (struct zimage_header *)map_sysmem(image, 0);
	if (zi->zi_magic != LINUX_ARM_ZIMAGE_MAGIC) { // 判断幻数
		puts("Bad Linux ARM zImage magic!\n");
		return 1;
	}

	*start = zi->zi_start; // 记录zImage的大小
	*end = zi->zi_end;

	printf("Kernel image @ %#08lx [ %#08lx - %#08lx ]\n", image, *start,
	      *end);

	return 0;
}
```

### do_bootm_states 

处理不同的启动启动状态, 进行不同的处理

使用到下面的几种状态

```c
BOOTM_STATE_OS_PREP 
BOOTM_STATE_OS_FAKE_GO 
BOOTM_STATE_OS_GO 
BOOTM_STATE_START
```

```c
int do_bootm_states(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[],
		    int states, bootm_headers_t *images, int boot_progress)
{
	boot_os_fn *boot_fn;
	ulong iflag = 0;
	int ret = 0, need_boot_fn;

	images->state |= states;

	/*
	 * Work through the states and see how far we get. We stop on
	 * any error.
	 */
	if (states & BOOTM_STATE_START)
		ret = bootm_start(cmdtp, flag, argc, argv);
    
    	/* From now on, we need the OS boot function */
	if (ret)
		return ret;
	boot_fn = bootm_os_get_boot_func(images->os.os); // 获取到os的内核启动函数do_bootm_linux
	need_boot_fn = states & (BOOTM_STATE_OS_CMDLINE |
			BOOTM_STATE_OS_BD_T | BOOTM_STATE_OS_PREP |
			BOOTM_STATE_OS_FAKE_GO | BOOTM_STATE_OS_GO);
	if (boot_fn == NULL && need_boot_fn) {
		if (iflag)
			enable_interrupts();
		printf("ERROR: booting os '%s' (%d) is not supported\n",
		       genimg_get_os_name(images->os.os), images->os.os);
		bootstage_error(BOOTSTAGE_ID_CHECK_BOOT_OS);
		return 1;
	}

	/* Call various other states that are not generally used */
	if (!ret && (states & BOOTM_STATE_OS_PREP))
        // 运行查找到的do_bootm_linux, 之后调用函数boot_prep_linux
        // 实际是把boot_args传递给内核, 通过设备树, 添加一个子节点
		ret = boot_fn(BOOTM_STATE_OS_PREP, argc, argv, images);

#ifdef CONFIG_TRACE
	/* Pretend to run the OS, then run a user command */
	if (!ret && (states & BOOTM_STATE_OS_FAKE_GO)) {
		char *cmd_list = getenv("fakegocmd");

		ret = boot_selected_os(argc, argv, BOOTM_STATE_OS_FAKE_GO,
				images, boot_fn);
		if (!ret && cmd_list)
			ret = run_command_list(cmd_list, -1, flag);
	}
#endif

	/* Check for unsupported subcommand. */
	if (ret) {
		puts("subcommand not supported\n");
		return ret;
	}

	/* Now run the OS! We hope this doesn't return 开始运行OS还是使用do_bootm_linux */
	if (!ret && (states & BOOTM_STATE_OS_GO))
		ret = boot_selected_os(argc, argv, BOOTM_STATE_OS_GO,
				images, boot_fn);

	/* Deal with any fallout */
err:
	if (iflag)
		enable_interrupts();

	if (ret == BOOTM_ERR_UNIMPLEMENTED)
		bootstage_error(BOOTSTAGE_ID_DECOMP_UNIMPL);
	else if (ret == BOOTM_ERR_RESET)
		do_reset(cmdtp, flag, argc, argv);

	return ret;
}
```

#### do_bootm_linux

```c
int do_bootm_linux(int flag, int argc, char * const argv[],
		   bootm_headers_t *images)
{
	/* No need for those on ARM */
	if (flag & BOOTM_STATE_OS_BD_T || flag & BOOTM_STATE_OS_CMDLINE)
		return -1;

	if (flag & BOOTM_STATE_OS_PREP) {
		boot_prep_linux(images);
		return 0;
	}

	if (flag & (BOOTM_STATE_OS_GO | BOOTM_STATE_OS_FAKE_GO)) {
		boot_jump_linux(images, flag);
		return 0;
	}

	boot_prep_linux(images);
	boot_jump_linux(images, flag);
	return 0;
}
```

```c
/* Subcommand: GO */
static void boot_jump_linux(bootm_headers_t *images, int flag)
{
	unsigned long machid = gd->bd->bi_arch_number; // 老版本使用
	char *s;
	void (*kernel_entry)(int zero, int arch, uint params);
	unsigned long r2;
	int fake = (flag & BOOTM_STATE_OS_FAKE_GO);

	kernel_entry = (void (*)(int, int, uint))images->ep; // 之前记录的0x80800000 zImage位置

	s = getenv("machid");
	if (s) {
		if (strict_strtoul(s, 16, &machid) < 0) {
			debug("strict_strtoul failed!\n");
			return;
		}
		printf("Using machid 0x%lx from environment\n", machid);
	}

	debug("## Transferring control to Linux (at address %08lx)" \
		"...\n", (ulong) kernel_entry);
	bootstage_mark(BOOTSTAGE_ID_RUN_OS);
	announce_and_cleanup(fake); // 输出最后一句话

	if (IMAGE_ENABLE_OF_LIBFDT && images->ft_len)
		r2 = (unsigned long)images->ft_addr; // 记录设备树的起始地址
	else
		r2 = gd->bd->bi_boot_params;

	if (!fake) {
#ifdef CONFIG_ARMV7_NONSEC
		if (armv7_boot_nonsec()) {
			armv7_init_nonsec();
			secure_ram_addr(_do_nonsec_entry)(kernel_entry,
							  0, machid, r2);
		} else
#endif
			kernel_entry(0, machid, r2); // 运行内核
	}
}
```

