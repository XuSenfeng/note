# POLL机制

## POLL机制基本概念

- 应用空间里面poll()函数
- 实际调用的是file_operations->poll

#### 应用层poll()函数

异步阻塞型IO

- 同步阻塞：阻塞在一个文件的读写操作上(read\write)，自己设备驱动唤醒自己

- 异步阻塞：阻塞在**多个**文件的轮询操作上(poll)，可被多个设备驱动唤醒

## 文件I/O事件 

- 可读、可写、异常...

##### poll函数

\#include <poll.h>

监视多个文件描述符的指定事件，事件发生时(驱动唤醒)，把发生的具体事件通知给用户程序

```c
int poll(struct pollfd *fds,nfds_t nfds,int timeout)
```

参数：

- fds ：一个struct pollfd类型的**数组**

    ```c
    struct pollfd {
        int fd; /* 文件描述符 */
        short events; /* 请求的事件类型 */
        short revents; /* 返回的事件类型 */
    };
    ```

    - fd：要监视的文件描述符

    - events 是要监视的事件

        - `POLLIN`：系统内核通知应用层指定数据已经备好，读数据不会被阻塞
        - `POLLPRI` ：有紧急的数据需要读取
        - `POLLOUT` ：系统内核通知应用层IO缓冲区已准备好，写数据不会被阻塞

        - `POLLERR` ：指定的文件描述符发生错误
        - `POLLNVAL`：无效的请求
        - ...

    - `revents`是返回事件，内核设置具体的返回事件

- nfds：pollfd数组的元素个数，要监控的文件描述符数量

- timeout：超时时间(ms)

返回值：

- 成功：发生事件的文件数量，超时返回0
- 失败：-1

## 使用

```c
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <poll.h>
int main(int argc, char *argv[])
{
   struct pollfd fds ={0};
   fds.fd =0; // 标准输入
   fds.events=POLLIN;

   int ret = poll(&fds,1,5000);

   if(ret == -1)
        printf("poll error!\r\n");
    else if(ret)
        printf("data is ready!\r\n");
    else if(ret ==0)
        printf("time out!/r/n");
}
```

## POLL底层机制剖析

#### 系统调用接口sys_poll

fs/select.c

这个宏定义会把这个函数的名字设置为sys_poll

```c
SYSCALL_DEFINE3(poll, struct pollfd __user *, ufds, unsigned int, nfds,int, timeout_msecs)
{
	struct timespec64 end_time, *to = NULL;	// 实现一个时间相关的时间的结构体
	int ret;

	if (timeout_msecs >= 0) {
		to = &end_time;
		poll_select_set_timeout(to, timeout_msecs / MSEC_PER_SEC,
			NSEC_PER_MSEC * (timeout_msecs % MSEC_PER_SEC));
	}
	// 实际使用的函数
	ret = do_sys_poll(ufds, nfds, to);
	...
	return ret;
}
```

#### SYSCALL_DEFINE3()宏

```
#define SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__)
```

#### SYSCALL_DEFINEx()宏

```c
#define SYSCALL_DEFINEx(x, sname, ...)				\
	SYSCALL_METADATA(sname, x, __VA_ARGS__)			\
	__SYSCALL_DEFINEx(x, sname, __VA_ARGS__)
```

#### __SYSCALL_DEFINEx()宏

```c
#ifndef __SYSCALL_DEFINEx
#define __SYSCALL_DEFINEx(x, name, ...)					\
	
	asmlinkage long sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))	\
		__attribute__((alias(__stringify(__se_sys##name))));	\
	...
#endif /* __SYSCALL_DEFINEx */
```

#### timespec64结构体

include/linux/time64.h

Linux里面用于记录时间的结构体

```c
struct timespec64 {
	time64_t	tv_sec;			/* seconds */
	long		tv_nsec;		/* nanoseconds */
};
```

#### do_sys_poll()函数

fs/select.c

- 复制用户空间pollfd数组到内核空间
    - 分配静态数组内存(一个poll_list结构体）
    - 动态分配内存（一组poll_list结构体）
- 调用do_poll函数
- 返回修改后的pollfd数组到用户空间
    - 主要是返回修改后revents值

![image-20250925161310271](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509251613340.png)

![image-20250925163522058](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509251635150.png)

```c
static int do_sys_poll(struct pollfd __user *ufds, unsigned int nfds,struct timespec64 *end_time)
{
	struct poll_wqueues table;
 	int err = -EFAULT, fdcount, len, size;
 	long stack_pps[POLL_STACK_ALLOC/sizeof(long)]; // 一共是256字节
	struct poll_list *const head = (struct poll_list *)stack_pps;
 	struct poll_list *walk = head;
 	unsigned long todo = nfds; // 记录元素的个数
 	...
 	//获取静态分配的数组大小
 	len = min_t(unsigned int, nfds, N_STACK_PPS); // 取输入和分配的最小值
	for (;;) {
		walk->next = NULL;
		walk->len = len;
		if (!len)
			break;
		// 复制数据到内核态, 分配的大小不足时候分多次
		if (copy_from_user(walk->entries, ufds + nfds-todo,
					sizeof(struct pollfd) * walk->len))
			goto out_fds;

		todo -= walk->len;
		if (!todo)
			break;
		//计算剩下的文件描述符所需空间大小，最大为一个页
		len = min(todo, POLLFD_PER_PAGE);
		size = sizeof(struct poll_list) + sizeof(struct pollfd) * len;
		walk = walk->next = kmalloc(size, GFP_KERNEL);
		if (!walk) {
			err = -ENOMEM;
			goto out_fds;
		}
	}
 	
 	poll_initwait(&table);
	fdcount = do_poll(head, &table, end_time);
	poll_freewait(&table);

	for (walk = head; walk; walk = walk->next) {
        // 遍历数组查看一下发生的事件
		struct pollfd *fds = walk->entries;
		int j;

		for (j = 0; j < walk->len; j++, ufds++)
			if (__put_user(fds[j].revents, &ufds->revents))
				goto out_fds;
  	}
	...
}
```

##### 相关宏定义

```c
#define FRONTEND_STACK_ALLOC	256
#define POLL_STACK_ALLOC	FRONTEND_STACK_ALLOC
#define N_STACK_PPS ((sizeof(stack_pps) - sizeof(struct poll_list))  / \
			sizeof(struct pollfd))
```

#### poll_initwait()函数

fs/select.c

```c
void poll_initwait(struct poll_wqueues *pwq)
{
	init_poll_funcptr(&pwq->pt, __pollwait);
	...
}
```

#### init_poll_funcptr()函数

include/linux/poll.h

```c
static inline void init_poll_funcptr(poll_table *pt, poll_queue_proc qproc)
{
	pt->_qproc = qproc; // __pollwait, 一个函数的指针
	pt->_key   = ~(__poll_t)0; /* all events enabled */
}
```

#### __pollwait()函数

fs/select.c

- **注册等待队列**：将当前进程注册到指定的等待队列中
- **非阻塞检查**：本身不会阻塞，只是设置唤醒机制
- **事件通知**：当设备就绪时，通过等待队列唤醒等待的进程

```c
static void __pollwait(struct file *filp, wait_queue_head_t *wait_address,
				poll_table *p)
{
    // 获取到poll_wqueues
	struct poll_wqueues *pwq = container_of(p, struct poll_wqueues,pt);
	struct poll_table_entry *entry = poll_get_entry(pwq);
	if (!entry)
		return;
	entry->filp = get_file(filp);
	entry->wait_address = wait_address;
	entry->key = p->_key;
	init_waitqueue_func_entry(&entry->wait, pollwake);
	entry->wait.private = pwq;
    // 加入等待队列
	add_wait_queue(wait_address, &entry->wait);
}
```

#### poll_get_entry()函数

fs/select.c

```c
static struct poll_table_entry *poll_get_entry(struct poll_wqueues *p)
{
	struct poll_table_page *table = p->table;
	// 返回一个可以使用的等待队列元素wait_queue_entry
	if (p->inline_index < N_INLINE_POLL_ENTRIES)
		return p->inline_entries + p->inline_index++;
	// 不够用的话重新分配
	if (!table || POLL_TABLE_FULL(table)) {
		struct poll_table_page *new_table;

		new_table = (struct poll_table_page *) __get_free_page(GFP_KERNEL);
		if (!new_table) {
			p->error = -ENOMEM;
			return NULL;
		}
		new_table->entry = new_table->entries;
		new_table->next = table;
		p->table = new_table;
		table = new_table;
	}

	return table->entry++;
}
```

#### do_poll()函数

fs/select.c

- 第一重for：确保线程/进程被唤醒后，继续执行一次循环体内容
- 第二重for：遍历一组poll_list
- 第二重for：遍历每个poll_list中的一组pollfd

```c
static int do_poll(struct poll_list *list, struct poll_wqueues *wait,
		   struct timespec64 *end_time)
{
	poll_table* pt = &wait->pt;
	ktime_t expire, *to = NULL;
	int timed_out = 0, count = 0;
	u64 slack = 0;
	__poll_t busy_flag = net_busy_loop_on() ? POLL_BUSY_LOOP : 0;
	unsigned long busy_start = 0;
	...
	for (;;) {
		struct poll_list *walk;
		bool can_busy_loop = false;

		for (walk = list; walk != NULL; walk = walk->next) {
            // 遍历所有的poll_list结构体
			struct pollfd * pfd, * pfd_end;

			pfd = walk->entries;
			pfd_end = pfd + walk->len;
			for (; pfd != pfd_end; pfd++) {
                // 遍历list数组里面的所有的选项
				if (do_pollfd(pfd, pt, &can_busy_loop,
					      busy_flag)) {
					count++; // 发生事件的文件数量
					pt->_qproc = NULL;
					/* found something, stop busy polling */
					busy_flag = 0;
					can_busy_loop = false;
				}
			}
		}
		pt->_qproc = NULL;
		if (!count) {
			count = wait->error;
			//检查是否有信号处理
			if (signal_pending(current))
				count = -EINTR;
		}
		if (count || timed_out)
			break;
		...
         // 休眠函数
		if (!poll_schedule_timeout(wait, TASK_INTERRUPTIBLE, to, slack))
			timed_out = 1;
	}
	return count;
}
```

#### do_pollfd()函数

fs/select.c

实际处理一个文件的函数, 返回的值是非零的时候, 表示发生事件

```c
static inline __poll_t do_pollfd(struct pollfd *pollfd, poll_table *pwait,
				     bool *can_busy_poll,
				     __poll_t busy_flag)
{
	int fd = pollfd->fd;
	__poll_t mask = 0, filter;
	struct fd f;

	if (fd < 0)
		goto out;
	...
    // 在这里处理
	mask = vfs_poll(f.file, pwait);
	...
}
```

#### vfs_poll()函数

include/linux/poll.h

```c
tatic inline __poll_t vfs_poll(struct file *file, struct poll_table_struct *pt)
{
	if (unlikely(!file->f_op->poll))
		return DEFAULT_POLLMASK;
	return file->f_op->poll(file, pt); // 底层驱动里面的
}
```

#### 驱动层poll底层接口

include/linux/fs.h

```c
__poll_t (*poll) (struct file *, struct poll_table_struct *);
```

参数：

- filp ：要打开的设备文件
- wait ：结构体 poll_table_struct 类型指针

返回值：

- 文件可用事件类型



##### poll驱动模板

实现得时候必须调用一下poll_wait函数

```c
static __poll_t xxx_poll(struct file *filp, struct poll_table_struct *wait)
{
	unsigned int mask = 0;

	poll_wait(filp, &yyy, wait);

	if(...)
	{
		mask |= POLLOUT | ...;
	}
	return mask;
}
```

#### poll_wait()函数

include/linux/poll.h

wait_address是等待队列的头

```c
static inline void poll_wait(struct file * filp, wait_queue_head_t * wait_address, poll_table *p)
{
	if (p && p->_qproc && wait_address)
		p->_qproc(filp, wait_address, p); // __pollwait函数
}
```

## 实际使用

### 简单示例

```c
#include <linux/poll.h>
#include <linux/wait.h>

struct my_device {
    wait_queue_head_t readq;
    wait_queue_head_t writeq;
    int data_ready;
    int space_available;
};

static unsigned int my_poll(struct file *filp, poll_table *wait)
{
    struct my_device *dev = filp->private_data;
    unsigned int mask = 0;
    
    // 注册到等待队列
    poll_wait(filp, &dev->readq, wait);
    poll_wait(filp, &dev->writeq, wait);
    
    // 检查当前状态
    spin_lock(&dev->lock);
    if (dev->data_ready)
        mask |= POLLIN | POLLRDNORM;
    if (dev->space_available)
        mask |= POLLOUT | POLLWRNORM;
    spin_unlock(&dev->lock);
    
    return mask;
}

// 数据到达时的处理
static void data_arrived(struct my_device *dev)
{
    spin_lock(&dev->lock);
    dev->data_ready = 1;
    spin_unlock(&dev->lock);
    
    // 唤醒等待读取的进程
    wake_up_interruptible(&dev->readq);
}
```

### 教程

```c
wait_queue_head_t wait_queue;
unsigned int write_data; //用于保存接收到的数据

/*字符设备操作函数集，write函数*/
static ssize_t led_chr_dev_write(struct file *filp, const char __user *buf, size_t cnt, loff_t *offt)
{

	int ret,error;
	unsigned char receive_data[10]; //用于保存接收到的数据
	

	if(cnt>10)
			cnt =10;

	error = copy_from_user(receive_data, buf, cnt);
	if (error < 0)
	{
		return -1;
	}

	ret = kstrtoint(receive_data, 16, &write_data);
	if (ret) {
		return -1;
        }

	if(write_data)
	{
		wake_up(&wait_queue);
		return cnt;
	}
	else
	{
		gpio_set_value(rgb_led_red,0);
	}

	return cnt;
}

__poll_t led_chrdev_poll (struct file *filp, struct poll_table_struct *wait)
{
	unsigned int mask = 0;

	poll_wait(filp, &wait_queue, wait);

	if(write_data)
	{
		mask |= POLLOUT;
	}
	return mask;
}
```

```c
#include <linux/poll.h>

struct my_device {
    wait_queue_head_t readq;
    struct mutex lock;
    char buffer[1024];
    int data_len;
    bool data_ready;
};

static ssize_t my_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
{
    struct my_device *dev = filp->private_data;
    int ret;
    
    // 如果没有数据，等待
    if (wait_event_interruptible(dev->readq, dev->data_ready))
        return -ERESTARTSYS;
    
    mutex_lock(&dev->lock);
    // 复制数据到用户空间
    ret = copy_to_user(buf, dev->buffer, min(count, dev->data_len));
    dev->data_ready = false;
    mutex_unlock(&dev->lock);
    
    return ret;
}

static unsigned int my_poll(struct file *filp, poll_table *wait)
{
    struct my_device *dev = filp->private_data;
    unsigned int mask = 0;
    
    // 注册调用poll的进程到等待队列
    poll_wait(filp, &dev->readq, wait);
    
    mutex_lock(&dev->lock);
    if (dev->data_ready)
        mask |= POLLIN | POLLRDNORM;  // 数据可读
    mutex_unlock(&dev->lock);
    
    return mask;
}

// 数据到达时（可能在中断中调用）
static void data_received(struct my_device *dev, const char *data, int len)
{
    mutex_lock(&dev->lock);
    memcpy(dev->buffer, data, len);
    dev->data_len = len;
    dev->data_ready = true;
    mutex_unlock(&dev->lock);
    
    // 唤醒所有等待读取的进程
    wake_up_interruptible(&dev->readq);
}
```



