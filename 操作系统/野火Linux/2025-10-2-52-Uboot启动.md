# Uboot启动

**上电—>设备初始化—>启动设备—>镜像头—>Uboot入口**

SPL部分(引导Full Uboot)未使用到(IMX6ULL会使用镜像头初始化DDR, 同时自动加载bin文件到DDR里面去0x8780 0000)

```'1. ROM Bootloader 加载 SPL 到 SRAM
   ↓
2. _start (入口点)
   ↓
3. reset()
   ├── save_boot_params()
   ├── cpu_init_cp15()
   ├── cpu_init_crit()
   └── _main()
       ↓
4. _main()
   ├── board_init_f_alloc_reserve()
   ├── board_init_f_init_reserve()
   └── board_init_f()
       ↓
5. board_init_f()
   ├── arch_cpu_init()
   ├── spl_clear_bss()
   └── board_init_r()
       ↓
6. board_init_r()
   ├── 硬件初始化
   ├── 存储设备初始化
   ├── 加载 U-Boot 镜像
   └── 跳转到 U-Boot'
```

+ 加载镜像头(加载完全的Uboot到RAM里面)
+ Uboot启动

```c
1. SPL 加载 U-Boot 到内存
   ↓
2. _start (入口点)
   ↓
3. reset()
   ├── save_boot_params()
   ├── cpu_init_cp15()
   ├── cpu_init_crit()
   └── _main()
       ↓
4. _main()
   ├── board_init_f_alloc_reserve()
   ├── board_init_f_init_reserve()
   └── board_init_f()
       ↓
5. board_init_f() - 重定位前初始化
   ├── init_sequence_f[] 执行
   │   ├── setup_mon_len
   │   ├── initf_malloc
   │   ├── arch_cpu_init
   │   ├── timer_init
   │   ├── env_init
   │   ├── serial_init
   │   └── console_init_f
   └── 计算重定位地址
       ↓
6. 重定位过程
   ├── relocate_code()
   └── relocate_vectors()
       ↓
7. board_init_r() - 重定位后初始化
   ├── init_sequence_r[] 执行
   │   ├── initr_reloc
   │   ├── initr_caches
   │   ├── initr_malloc
   │   ├── initr_dm
   │   └── board_init
   └── run_main_loop()
       ↓
8. main_loop()
   ├── cli_init()
   ├── bootdelay_process()
   ├── autoboot_command()
   └── cli_loop() (命令循环)
       ↓
9. 启动内核或进入命令模式
```

+ + **设置异常向量表**：CPU 发生中断、快速中断等异常时，会跳转到这个表指定的地址。U-Boot 需要先设置一个简单的向量表。
  + **进入特权模式**：CPU 可能从复位后的特殊模式启动，U-Boot 会切换到 Supervisor 模式，以便执行特权指令。
  + **关闭看门狗**：看门狗定时器如果不及时“喂狗”，会导致系统复位。U-Boot 首先要关闭它或定期复位它，防止系统在启动过程中意外重启。
  + **关闭中断**：在初始化早期，中断系统尚未准备就绪，为了避免意外中断，会先关闭所有中断。
  + **设置时钟系统**：包括 CPU 主频、总线频率、外设时钟等。芯片通常以一个低速的晶振启动，U-Boot 需要配置锁相环等电路，将时钟提升到稳定运行所需的高频率。
  + **初始化内存控制器**：这是**至关重要的一步**。在初始化之前，CPU 无法访问外部的 DDR SDRAM。U-Boot 需要根据板子的硬件设计，正确配置内存控制器的时序、位宽、大小等参数，使内存可用。
  + **设置栈指针**：为 C 语言代码的执行准备运行栈。一旦栈设置好，就可以跳转到 C 代码执行，大大提高开发效率。
  + **代码重定位**：U-Boot 自身可能运行在只读的 ROM、NOR Flash 或容量有限的 SRAM 中。这一步它将**把自己完整的代码拷贝到刚刚初始化好的 DDR 内存中**，然后跳转到内存中继续执行。这样做是为了获得更快的执行速度。

  

## bootROM作用

主要是原厂的固化在芯片内的程序的功能：简单初始化一下总线资源，再通过外部引 脚判断从什么类型的flash中读取数据进行外设的初始化

### 初始化内部ROM RAM

imx6ull里是带有ROM和RAM的，我们称它为iROM和iRAM

![image-20251002202453485](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510022024546.png)

iROM作用：存储异常向量表，HABAPI向量表，ROMAPI向量表，日志缓冲区，固化的出厂程序 

iRAM作用：运行出厂程序和镜像4K头部数据

### 初始化部分时钟

![image-20251012221918839](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510122219911.png)

### 初始化引导模块

![image-20251002202621581](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510022026645.png)

初始化了大部分的总线，为下面读取外部存储做准备

+ 启动MMU/L2映射

启动ROM包括一个功能，使内存管理单元(MMU)和缓存，以提高启动速度。在镜像下载开始 时，将启用Ll指令缓存。图像认证时需要启用L1数据缓存、L2缓存和MMU。当HAB认证完 成时，ROM会关闭L1数据缓存、L2缓存和MMU。其中L1指令缓存、L1数据缓存、L2缓存 和MMU由eFuse控制。默认情况下，这些是启用的

+ 映射异常向量表, 映射后存于iRAM的0x0091FFB8-0x0091FFFF地址中

### 识别存储设备

在使用bootROM进行识别启动的方式的时候, 会检测一下这部分的配置, 通过GPIO的配置, 和LCD的DATA引脚进行复用, 一般默认接地就可以了, BOOTCONFIG4全部接地, BOOTCONFIG2的引脚3选择一下eSDHC接口, 也就是哪一个SD卡, BOOTCONFIG1的3, 4, 5, 6, 7

![image-20251002202928268](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510022029320.png)

![image-20251002203023937](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510022030011.png)

### 镜像头读取

uboot在启动的时候会被复制到0x87800000位置, 前面需要加上3K的数据头, 所以imx文件的起始地址是0x877FF400

![image-20251002203120052](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510022031092.png)

+ NOR

该flash 支持XIP可以在片上运行程序，需要注意的是NOR只能像RAM一样读取数据但不能像 RAM一样写入，写入还得像NAND那样擦除再写入，所以其镜像头的加载可以是整个空间 然后根据镜像头配置好时钟和各种外设（内置外设）

+ OneNAND(不常用)

从256byte 开始读取往后的1K（0页0块的扇区0和扇区1）作为镜像头将其加 载到内部的iRAM中，这1K必须包含完整的镜像头数据，但我们常用的NAND和eMMC镜像 头（2K大小）是不符合的，所以只需要启动主要的内置外设即可将镜像头压缩到1K内，剩下的功能可以在需要使用时再到外置DDR中配置

+ Raw NAND

我们常使用的NANDflash也是固态硬盘中的固态颗粒，imx6ull支持MLC/SLC的 颗粒

**NAND的存储地址较为特殊，不是板子指定，而是由FCB决定**。讲到FCB不得不提一下DBBT。 

**FCB**：全称为Firmwareconfiguration block，主要描述了NAND的各项硬件参数，ECC纠正参数和 镜像入口 

**DBBT**：全称为DiscoveredBad Block Table，主要作用是记录NAND的坏块地址。

FCB 中有一行参数Firmware1_startingPage

![image-20251002203449510](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510022034563.png)

相应值为0x200，但是这个并不是指在NAND中的地址，而是指页数 还需要一个参数是页大小，页大小可以从NAND数据手册上找到

也可以从uboot的命令界面输入`nand info`查看, 还可以根据FCB描述的NAND参数进行计算

![image-20251009130211779](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510091302849.png)

则可以算出页大小=0x1000=4096byte

+ SD卡

 SD 和emmc一类都是根据跳过1K读取4K原则, 这1K里包含了MBR表，主要记录分区信息

![image-20251009132756581](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510091337825.png)

> **MMC/SD卡分区**
>
> MBR表中有一块存储DPT的表，DPT中包含了分区信息
>
> ![image-20251009132848230](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510091338804.png)
>
> ![image-20251009132912395](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510091338732.png)
>
> 可以在Linux下用`fdisk -l`查看

#### 镜像头分析

1. Image vector table，简称 IVT，IVT 里面包含了一系列的地址信息，这些地址信息在 ROM中按照固定的地址存放着
2. Boot data，启动数据，包含了镜像要拷贝到哪个地址，拷贝的大小是多少等等。
3. Device configuration data，简称 DCD，设备配置信息，重点是 DDR3 的初始化配置
4. 可执行文件，比如led.bin

![image-20251012222704716](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510122227765.png)

镜像头的作用主要是，对外置DDR进行初始化，时钟的设置，镜像的大小，uboot（裸机）的入 口地址，CPU的电源控制等

> DDR（双倍速率同步动态随机存储器）是计算机内存的一种类型，属于同步动态随机存储器（[SDRAM](https://baike.baidu.com/item/SDRAM/362234?fromModule=lemma_inlink)）的改进型号，通过时钟信号的上升沿和下降沿各传输一次数据，实现双倍于传统SDRAM的传输速率

```c
const int imx6_512mb_ivtdcd_table[256] = {
0X402000D1,0X87800000,0X00000000,0X877FF42C,0X877FF420,0X877FF400,0X00000000,0X00000000,
0X877FF000,0X00200000,0X00000000,0X40E801D2,0X04E401CC,0X68400C02,0XFFFFFFFF,0X6C400C02,
0XFFFFFFFF,0X70400C02,0XFFFFFFFF,0X74400C02,0XFFFFFFFF,0X78400C02,0XFFFFFFFF,0X7C400C02,
0XFFFFFFFF,0X80400C02,0XFFFFFFFF,0XB4040E02,0X00000C00,0XAC040E02,0X00000000,0X7C020E02,
0X30000000,0X50020E02,0X30000000,0X4C020E02,0X30000000,0X90040E02,0X30000000,0X88020E02,
0X30000C00,0X70020E02,0X00000000,0X60020E02,0X30000000,0X64020E02,0X30000000,0XA0040E02,
0X30000000,0X94040E02,0X00000200,0X80020E02,0X30000000,0X84020E02,0X30000000,0XB0040E02,
0X00000200,0X98040E02,0X30000000,0XA4040E02,0X30000000,0X44020E02,0X30000000,0X48020E02,
0X30000000,0X1C001B02,0X00800000,0X00081B02,0X030039A1,0X0C081B02,0X0B000300,0X3C081B02,
0X44014801,0X48081B02,0X302C4040,0X50081B02,0X343E4040,0X1C081B02,0X33333333,0X20081B02,
0X33333333,0X2C081B02,0X333333F3,0X30081B02,0X333333F3,0XC0081B02,0X09409400,0XB8081B02,
0X00080000,0X04001B02,0X2D000200,0X08001B02,0X3030331B,0X0C001B02,0XF3526B67,0X10001B02,
0X630B6DB6,0X14001B02,0XDB00FF01,0X18001B02,0X40172000,0X1C001B02,0X00800000,0X2C001B02,
0XD2260000,0X30001B02,0X23106B00,0X40001B02,0X4F000000,0X00001B02,0X00001884,0X90081B02,
0X00004000,0X1C001B02,0X32800002,0X1C001B02,0X33800000,0X1C001B02,0X31800400,0X1C001B02,
0X30802015,0X1C001B02,0X40800004,0X20001B02,0X00080000,0X18081B02,0X27020000,0X04001B02,
0X2D550200,0X04041B02,0X06100100,0X1C001B02,0X00000000,0X00000000,0X00000000,0X00000000,
0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,
0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,
0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,
0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,
0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,
0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,
0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,
0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,
0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,
0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,
0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,
0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,
0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,
0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,
0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000
};
```

![image-20251009134140855](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510091341912.png)

> ![image-20251012222841054](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510122228090.png)
>
> ![image-20251012223021094](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510122230136.png)

![image-20251009135350479](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510091353527.png)

> DCD其实就是I.MX6U寄存器地址和 对应的配置信息集合，Boot ROM会使用这些寄存器地址和配置集合来初始化相应的寄存器， 比如开启某些外设的时钟、初始化DDR等等。DCD区域不能超过1768Byte
>
> ![image-20251013145329886](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510131453975.png)
>
> ![image-20251013145444332](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510131454367.png)
>
> 其中Tag是单字节，固定为0XD2，Length为两个字节，表示DCD区域的大小，包含hea der，同样是大端模式，Version是单字节，固定为0X40或者0X41
>
>  CMD 就是要初始化的寄存器地址和相应的寄存器值
>
> ![image-20251013145544039](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510131455099.png)
>
> bytes表示是目标位置宽度，单位为byte，可以选择1、2、和4字节。flags 是命令控制标志位, Address和Vlalue/Mask就是要初始化的寄存器地址和相应的寄存器值，注 意采用的是大端模式
>
> ![image-20251013150011693](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510131500765.png)

![image-20251009135546607](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510091355705.png)

启动所有的时钟以及初始化DDR3所有使用的IO, 配置MMDC控制器初始化DDR3等

后面还有检查数据, NOP命令, 解锁命令等也属于DCD都是0

## Uboot

在镜像头中有一个名为entry地址0x87800000, 真正的uboot入口是没有添加镜像头的

### 第一阶段

reset 函数的位置和执行环境：

1. SPL 阶段：

- 存储在 SD 卡前几个扇区

- 由 ROM Bootloader 直接加载

- 在 SRAM 中执行

- 负责加载完整的 U-Boot

2. U-Boot 阶段：

- 存储在 SD 卡特定扇区（几百KB偏移）

- 由 SPL 加载到内存

- 在 DDR 内存中执行

- 负责系统初始化和内核启动

3. 代码位置：/arch/arm/cpu/armv7/start.S 文件中的 reset 函数被 SPL 和 U-Boot 共享使用，通过编译时宏定义来区分不同的执行环境。

#### 链接文件

![image-20251009145154606](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510091451659.png)

对 于 imx6ull 而 言， 其 第一阶段对应的文件时 arch/arm/cpu/armv7/start.S 和 arch/arm/cpu/armv7/lowlevel_init.S 

编译通过后我们可 以看到源码根目录下会出现一个u-boot.lds文件, 这个是链接的指导文件

```cmake
# 指定输出可执行文件是elf格式，32位ARM指令，小端
OUTPUT_FORMAT("elf32-littlearm", "elf32-littlearm", "elf32-littlearm") 
# 设置输出可执行文件的体系架构为arm
OUTPUT_ARCH(arm)
# 将_start设为入口地址
ENTRY(_start)
SECTIONS
{
 # 指定可执行文件的全局入口点，通常这个地址都放在ROM(flash)0x0位置。
 # 必须使编译器知道这个地址，通常都是修改此处来完成
 . = 0x00000000;
 # 代码以4字节对齐
 . = ALIGN(4);
 # 指定代码段
 .text :
 {
  # u-boot把自己拷贝到RAM中，这里指定拷贝的起始处
  *(.__image_copy_start)
  # arch/arm/lib/vectors.S，存放异常向量表
  *(.vectors)
  # 代码的第一个部分，arch/arm/cpu/armv7/start.S
  arch/arm/cpu/armv7/start.o (.text*)
 }
 .__efi_runtime_start : {
  *(.__efi_runtime_start)
 }
 .efi_runtime : {
  *(.text.efi_runtime*)
  *(.rodata.efi_runtime*)
  *(.data.efi_runtime*)
 }
 .__efi_runtime_stop : {
  *(.__efi_runtime_stop)
 }
 .text_rest :
 {
  # 其它代码段存放于此处
  *(.text*)
 }
 # 上面的代码结束后，可能会导致没有4字节对齐，这里再一次做好4字节对齐，方便后面的只读数据段
 . = ALIGN(4);
 # 指定存放只读数据段
 .rodata : { *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) }
 . = ALIGN(4);
 .data : {
  *(.data*)
 }
 . = ALIGN(4);
 . = .;
 . = ALIGN(4);
 .u_boot_list : {
  # 在读/写数据段后，存放一些u-boot自有的函数，如uboot command等
  KEEP(*(SORT(.u_boot_list*)));
 }
 . = ALIGN(4);
 .efi_runtime_rel_start :
 {
  *(.__efi_runtime_rel_start)
 }
 .efi_runtime_rel : {
  *(.rel*.efi_runtime)
  *(.rel*.efi_runtime.*)
 }
 .efi_runtime_rel_stop :
 {
  *(.__efi_runtime_rel_stop)
 }
 . = ALIGN(4);
 .image_copy_end :
 {
  *(.__image_copy_end) # 这里指定拷贝的末尾处，拷贝的包括代码段、只读数据、读写数据段和 u_boot_list 等
 }
 .rel_dyn_start :
 {
  *(.__rel_dyn_start) # 动态链接符段开始处
 }
 .rel.dyn : {
  *(.rel*)
 }
 .rel_dyn_end :
 {
  *(.__rel_dyn_end) # 动态链接符段末尾处
 }
 .end :
 {
  *(.__end)
 }
 _image_binary_end = .; # 二进制文件结束
 . = ALIGN(4096);
 .mmutable : {
  *(.mmutable) # 内存管理单元表
 }
 .bss_start __rel_dyn_start (OVERLAY) : {
  KEEP(*(.__bss_start));
  __bss_base = .;
 }
 .bss __bss_base (OVERLAY) : {
  *(.bss*)
   . = ALIGN(4);
   __bss_limit = .; # 把__bss_limit赋值为当前位置
 }
 .bss_end __bss_limit (OVERLAY) : {
  KEEP(*(.__bss_end));
 }
 .dynsym _image_binary_end : { *(.dynsym) }
 .dynbss : { *(.dynbss) }
 .dynstr : { *(.dynstr*) }
 .dynamic : { *(.dynamic*) }
 .plt : { *(.plt*) }
 .interp : { *(.interp*) }
 .gnu.hash : { *(.gnu.hash) }
 .gnu : { *(.gnu*) }
 .ARM.exidx : { *(.ARM.exidx*) }
 .gnu.linkonce.armexidx : { *(.gnu.linkonce.armexidx.*) }
}

```

#### 入口函数

查找`_start`即可找到它定义在arch/arm/lib/vectors.S文件中，这里便是代码入口处，见名知意，这里便指明了异常向量

```assembly
#include <config.h>

/*
 * A macro to allow insertion of an ARM exception vector either
 * for the non-boot0 case or by a boot0-header. 终端向量表的宏定义, 实际是一系列的跳转
 */
        .macro ARM_VECTORS
#ifdef CONFIG_ARCH_K3
	ldr     pc, _reset
#else
	b	reset
#endif
	ldr	pc, _undefined_instruction
	ldr	pc, _software_interrupt
	ldr	pc, _prefetch_abort
	ldr	pc, _data_abort
	ldr	pc, _not_used
	ldr	pc, _irq
	ldr	pc, _fiq
	.endm


/*
 *************************************************************************
 *
 * Symbol _start is referenced elsewhere, so make it global
 *
 *************************************************************************
 */

.globl _start

/*
 *************************************************************************
 *
 * Vectors have their own section so linker script can map them easily
 *
 *************************************************************************
 */

	.section ".vectors", "ax"

#if defined(CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK)
/*
 * Various SoCs need something special and SoC-specific up front in
 * order to boot, allow them to set that in their boot0.h file and then
 * use it here.
 *
 * To allow a boot0 hook to insert a 'special' sequence after the vector
 * table (e.g. for the socfpga), the presence of a boot0 hook supresses
 * the below vector table and assumes that the vector table is filled in
 * by the boot0 hook.  The requirements for a boot0 hook thus are:
 *   (1) defines '_start:' as appropriate
 *   (2) inserts the vector table using ARM_VECTORS as appropriate
 */
#include <asm/arch/boot0.h>
#else

/*
 *************************************************************************
 *
 * Exception vectors as described in ARM reference manuals
 *
 * Uses indirect branch to allow reaching handlers anywhere in memory.
 *
 *************************************************************************
 */

_start:
#ifdef CONFIG_SYS_DV_NOR_BOOT_CFG
	# 则包含 SoC 特定的引导代码
	.word	CONFIG_SYS_DV_NOR_BOOT_CFG
#endif
	# 中断向量表
	ARM_VECTORS
#endif /* !defined(CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK) */

/*
 *************************************************************************
 *
 * Indirect vectors table
 *
 * Symbols referenced here must be defined somewhere else
 *
 *************************************************************************
 */

	.globl  _reset
	.globl	_undefined_instruction
	.globl	_software_interrupt
	.globl	_prefetch_abort
	.globl	_data_abort
	.globl	_not_used
	.globl	_irq
	.globl	_fiq
# 这部分定义了每个异常处理程序的实际地址，通过 .word 指令存储各个异常处理函数的入口地址。
#ifdef CONFIG_ARCH_K3
_reset:			.word reset
#endif
_undefined_instruction:	.word undefined_instruction
_software_interrupt:	.word software_interrupt
_prefetch_abort:	.word prefetch_abort
_data_abort:		.word data_abort
_not_used:		.word not_used
_irq:			.word irq
_fiq:			.word fiq
```

![image-20251009153648845](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510091536907.png)

resets其实就定义在 arch/arm/cpu/armv7/start.S文件中

```assembly
reset:
	/* Allow the board to save important registers */
	b	save_boot_params
```

```assembly
/*************************************************************************
 *
 * void save_boot_params(u32 r0, u32 r1, u32 r2, u32 r3)
 *	__attribute__((weak));
 *
 * Stack pointer is not yet initialized at this moment
 * Don't save anything to stack even if compiled with -O0
 *
 *************************************************************************/
ENTRY(save_boot_params)
	b	save_boot_params_ret		@ back to my caller
ENDPROC(save_boot_params)
	.weak	save_boot_params
```

```assembly
save_boot_params_ret:
#ifdef CONFIG_ARMV7_LPAE
/*
 * check for Hypervisor support
 */
	mrc	p15, 0, r0, c0, c1, 1		@ read ID_PFR1
	and	r0, r0, #CPUID_ARM_VIRT_MASK	@ mask virtualization bits
	cmp	r0, #(1 << CPUID_ARM_VIRT_SHIFT)
	beq	switch_to_hypervisor
switch_to_hypervisor_ret:
#endif
	/*
	 * disable interrupts (FIQ and IRQ), also set the cpu to SVC32 mode,
	 * except if in HYP mode already
	 */
	mrs	r0, cpsr
	and	r1, r0, #0x1f		@ mask mode bits 屏蔽寄存器的非模式位域，留下模式位域的值
	teq	r1, #0x1a		@ test for HYP mode 测试看看当前 cpu 是否处于 hyp 模式
	bicne	r0, r0, #0x1f		@ clear all mode bits 清除所有的模式位M[4:0]
	orrne	r0, r0, #0x13		@ set SVC mode 设置为 Supervisor（SVC）模式
	orr	r0, r0, #0xc0		@ disable FIQ and IRQ 屏蔽 FIQ 和 IRQ 中断
	msr	cpsr,r0
```

> 将cpu的工作模式设置为SVC32模式（即管理模式），同时将中断禁止位与 快速中断禁止位都设置为1，以此屏蔽IRQ和FIQ的中断
>
> ![image-20251009154456511](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510091544556.png)
>
> M[4:0]决定 了当前cpu的工作模式，而位域F[6]为FIQ中断屏蔽位，位域I[7]为IRQ中断屏蔽位，位域T[5] 为Thumb执行状态位（此位没有设置，可忽略），模式位域M[4:0]详情如下表格所示
>
> ![image-20251009154534801](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510091545864.png)

```assembly
/*
 * Setup vector:
 * (OMAP4 spl TEXT_BASE is not 32 byte aligned.
 * Continue to use ROM code vector only in OMAP4 spl)
 */
#if !(defined(CONFIG_OMAP44XX) && defined(CONFIG_SPL_BUILD))
	/* Set V=0 in CP15 SCTLR register - for VBAR to point to vector */
	# 是要设置SCTLR（系统控制寄存器）
	mrc	p15, 0, r0, c1, c0, 0	@ Read CP15 SCTLR Register 
	bic	r0, #CR_V		@ V = 0
	mcr	p15, 0, r0, c1, c0, 0	@ Write CP15 SCTLR Register

#ifdef CONFIG_HAS_VBAR
	/* Set vector address in CP15 VBAR register */
	ldr	r0, =_start # 将_start的值加载到r0寄存器当中
	/*
	设置 c12 的值为 0x87800000（_start），即设置非安全模式异常基址寄存器为
    0x87800000，结合前面清除SCTLR中的V[13]，即实现的向量表的重定位。ARM默认的异
    常向量表入口在0x0地址，uboot的运行介质（norflashnandflashsram等）映射地址可能不
    在0x0起始的地址，所以需要修改异常向量表入口
    */
	mcr	p15, 0, r0, c12, c0, 0	@Set VBAR 实现分区表的映射
#endif
#endif

```

SCTLR寄存器用于控制标准内存和系统设备，并且为在硬件内核中实现的功能提供状态信息， 其中位域V[13]的作用是选择异常向量表的基地址，根据ARMv7架构参考手册描述可知，当往 V[13]填如0时，异常向量表的基地址=0x00000000, 并且该地址可以被re-mapped（重映射）

当往V[13]填如1时，异常向量表的基地址=0xffff0000，此时该地址不能被重映射

在System.map 文件中，可以看到 _start 的值为 0x87800000，该地址为我们前面分析u-boot.lds 中向量表vectors 的起始地址

```assembly
	/* the mask ROM code should have PLL and others stable */
#ifndef CONFIG_SKIP_LOWLEVEL_INIT
	# 未被定义，后面的代码块有效
#ifdef CONFIG_CPU_V7A
	# 跳转至cpu_init_cp15标号处，执行完cpu_init_cp15函数后返回
	bl	cpu_init_cp15
#endif
#ifndef CONFIG_SKIP_LOWLEVEL_INIT_ONLY
	# 跳转至cpu_init_crit 标号处，执行完cpu_init_crit 函数后返回
	bl	cpu_init_crit
#endif
#endif
	bl	_main
```

##### cpu_init_cp15

![image-20251009224551639](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202510092245712.png)

```assembly
/*************************************************************************
 *
 * cpu_init_cp15
 *
 * Setup CP15 registers (cache, MMU, TLBs). The I-cache is turned on unless
 * CONFIG_SYS_ICACHE_OFF is defined.
 *
 *************************************************************************/
ENTRY(cpu_init_cp15)
	/*
	 * Invalidate L1 I/D
	 */
	mov	r0, #0			@ set up for MCR 将r0寄存器的内容清零
	/*
        即将0写入到寄存器8（Register
         8）中去，它是一个只写的寄存器，配合指令“mcrp15,0,r0,c8,c7,0”最后两个参数，其
        作用是使整个数据和指令TLB无效，禁止虚拟地址到物理地址的转换，为何要关闭呢？因
        为刚开始我们并没有建立页表，且都是直接操作物理寄存器的，所以不能打开，否则会发
        生意想不到的错误。
	*/
	mcr	p15, 0, r0, c8, c7, 0	@ invalidate TLBs 
	mcr	p15, 0, r0, c7, c5, 0	@ invalidate icache 使无效整个指令缓冲
	mcr	p15, 0, r0, c7, c5, 6	@ invalidate BP array 清空整个跳转目标缓冲，关闭分支预测功能
	mcr     p15, 0, r0, c7, c10, 4	@ DSB 清空写缓冲区，以便数据同步
	mcr     p15, 0, r0, c7, c5, 4	@ ISB 清空预取缓冲区，以便指令同步，清空流水线中已经取到的指令，进行重新取指令。
	
    /*
	 * disable MMU stuff and caches
	 * 将cp15的寄存器c1的值读到r0中，c1是一个控制寄存器，它包括使能或禁止
	 * mmu以及与其他存储系统相关的功能，配置存储系统以及ARM处理器中的相关部分的工作
	 */
	mrc	p15, 0, r0, c1, c0, 0
	# 清除位域V[13]，即选择低端异常中断向量表，向量表基地址为0x00000000，且支持向量表重映射
	bic	r0, r0, #0x00002000	@ clear bits 13 (--V-)
	# 清除位域M[0]、A[1]、C[2],即分别禁止内存管理单元mmu、地址对齐检查、数据缓冲。
	bic	r0, r0, #0x00000007	@ clear bits 2:0 (-CAM)
	# 使能地址对齐检查
	orr	r0, r0, #0x00000002	@ set bit 1 (--A-) Align
	# 打开ARM系统的跳转预测（分支预测）功能，不打断流水线，提高指令执行效率
	orr	r0, r0, #0x00000800	@ set bit 11 (Z---) BTB
#if CONFIG_IS_ENABLED(SYS_ICACHE_OFF)
	bic	r0, r0, #0x00001000	@ clear bit 12 (I) I-cache
#else
	# 故打开I-cache
	orr	r0, r0, #0x00001000	@ set bit 12 (I) I-cache
#endif
	# 将修改后的r0重新写入SCTLR寄存器中
	mcr	p15, 0, r0, c1, c0, 0

#ifdef CONFIG_ARM_ERRATA_716044
	# 未使用
	mrc	p15, 0, r0, c1, c0, 0	@ read system control register
	orr	r0, r0, #1 << 11	@ set bit #11
	mcr	p15, 0, r0, c1, c0, 0	@ write system control register
#endif
 ...
 # 处理cp15协处理器
```

> mmu负责从虚 拟地址到物理地址之间的转换，但是我们现在的汇编都是直接操作物理寄存器，此时如果打开了 mmu，而我们并没有有效的TLB，这样cpu可以说是胡乱运行的，所以我们需要关闭mmu，不 需要它转换地址，直接操作寄存器方便快捷。
>
> 因为 catch和MMU是通过cp15管理的，刚上电的时候，CPU并不能管理他们。所以上电的时候mmu 必须关闭，指令cache可关闭，可不关闭，但数据cache一定要关闭，否则可能导致刚开始的代 码里面，去取数据的时候，从catch里面取，而这时候RAM中数据还没有cache过来，导致数据 预取异常

##### cpu_init_crit

````assembly
/*************************************************************************
 *
 * CPU_init_critical registers
 *
 * setup important registers
 * setup memory timing
 *
 *************************************************************************/
ENTRY(cpu_init_crit)
	/*
	 * Jump to board specific initialization...
	 * The Mask ROM will have already initialized
	 * basic memory. Go here to bump up clock rate and handle
	 * wake up conditions.
	 */
	b	lowlevel_init		@ go setup pll,mux,memory 跳转至lowlevel_init 函数
ENDPROC(cpu_init_crit)
````

> lowlevel_init 完成了内存的初始化工作，而内存的初始化依赖于开发板，所以lowlevel_init于 当前imx6u 相关，lowlevel_init 函数是与特定开发板相关的初始化函数，在这个函数里会做一些 pll 初始化，如果不是从内存启动，则会做内存初始化，方便后续拷贝到内存中运行。全局搜索 lowlevel_init 发现其在 arch/arm/cpu/armv7/lowlevel_init.S 文件中有定义

```assembly
WEAK(lowlevel_init)
	/*
	 * Setup a temporary stack. Global data is not available yet.
	 */
#if defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_STACK)
	ldr	sp, =CONFIG_SPL_STACK
#else
	ldr	sp, =CONFIG_SYS_INIT_SP_ADDR # 设置栈指针指向CONFIG_SYS_INIT_SP_ADDR 0x0091ff00
#endif
	bic	sp, sp, #7 /* 8-byte alignment for ABI compliance 遵从ABI的8字节对齐 */
#ifdef CONFIG_SPL_DM
	mov	r9, #0
#else
	/*
	 * Set up global data for boards that still need it. This will be
	 * removed soon.
	 */
#ifdef CONFIG_SPL_BUILD
	ldr	r9, =gdata
#else
	sub	sp, sp,  # GD_SIZE # 将堆栈指针减去GD_SIZE，GD_SIZE在include/generated/generic-asm-offsets.h 中
				# 被定义为256，即sp=sp-0x00000100		
	bic	sp, sp, #7 # 遵从ABI的8字节对齐
	mov	r9, sp	# 将sp的值存储在r9寄存器当中
#endif
#endif
	/*
	 * Save the old lr(passed in ip) and the current lr to stack
	 */
	push	{ip, lr}

	/*
	 * Call the very early init function. This should do only the
	 * absolute bare minimum to get started. It should not:
	 *
	 * - set up DRAM
	 * - use global_data
	 * - clear BSS
	 * - try to start a console
	 *
	 * For boards with SPL this should be empty since SPL can do all of
	 * this init in the SPL board_init_f() function which is called
	 * immediately after this.
	 */
	bl	s_init # s_init函数为一个空的函数，里面什么也没做
	pop	{ip, pc}
ENDPROC(lowlevel_init)
```

> CONFIG_SYS_INIT_SP_ADDR 具体是什么？它在include/configs/mx6ullevk.h 文件中有如下定义
>
> ```c
> #define CONFIG_SYS_INIT_SP_ADDR \
>  (CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET)
> ```
>
> IRAM_BASE_ADDR 在 arch/arm/include/asm/arch-mx6/imx regs.h 定义为 0x00900000，IRAM_SIZE 在 arch/arm/include/asm/arch-mx6/imx-regs.h 中定义为 0x00020000
>
> ```c
>  #if !(defined(CONFIG_MX6SX) || \
>  defined(CONFIG_MX6UL) || defined(CONFIG_MX6ULL) || \
>  defined(CONFIG_MX6SLL) || defined(CONFIG_MX6SL))
>  #define IRAM_SIZE		 0x00040000
>  #else
>  #define IRAM_SIZE		 0x00020000
>  #endif
> ```
>
> .config 文件中我们配置了 CONFIG_MX6ULL=y，所以条件不成立，即定义 IRAM_SIZE = 0x00020000
>
> GENERATED_GBL_DATA_SIZE 在 include/generated/generic-asm-offsets.h 中定义为 256，转换成 十六进制为0x00000100。故 CONFIG_SYS_INIT_SP_ADDR = （0x00900000 + （0x00020000 0x00000100））= 0x0091ff00

