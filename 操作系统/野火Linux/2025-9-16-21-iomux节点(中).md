## pin function和pin group：iomuxc节点解析始末

#### imx_pinctrl_probe_dt()函数

drivers/pinctrl/freescale/pinctrl-imx.c

pinctrl_dev下面有三个基数树, 分别记录所有的引脚信息, function的信息以及group的信息

![image-20250916105054851](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509161050929.png)

```c
static int imx_pinctrl_probe_dt(struct platform_device *pdev,
				struct imx_pinctrl *ipctl)
{
	//iomux节点
	struct device_node *np = pdev->dev.of_node; // 使用platform结构体进行获取实际的设备树描述
	struct device_node *child;
	struct pinctrl_dev *pctl = ipctl->pctl;
	// 遍历两层, 检查一下是不是有fsl,pins属性, 直接的下一层True, 下下层False
	flat_funcs = imx_pinctrl_dt_is_flat_functions(np);
	if (flat_funcs) {
		nfuncs = 1; // 没有function层, 但是设置这个变量为1, 至少使用一个function来进行管理所有的节点
	} else {
		nfuncs = of_get_child_count(np);
		if (nfuncs == 0) {
			dev_err(&pdev->dev, "no functions defined\n");
			return -EINVAL;
		}
	}
	
	for (i = 0; i < nfuncs; i++) {
		struct function_desc *function;
		// 申请一个function_desc
		function = devm_kzalloc(&pdev->dev, sizeof(*function),
					GFP_KERNEL);
		if (!function)
			return -ENOMEM;

		mutex_lock(&ipctl->mutex);
        // 加入基数树里面
		radix_tree_insert(&pctl->pin_function_tree, i, function);
		mutex_unlock(&ipctl->mutex);
	}
	
	pctl->num_functions = nfuncs; // 1
	ipctl->group_index = 0; // 初始化一下上一个节点里面的这个变量
	
	if (flat_funcs) {
        // 记录一下所有的group的数量
		pctl->num_groups = of_get_child_count(np);
	} else {
		pctl->num_groups = 0;
		for_each_child_of_node(np, child)
			pctl->num_groups += of_get_child_count(child);
	}
	
	if (flat_funcs) {
		imx_pinctrl_parse_functions(np, ipctl, 0);
	} else {
		i = 0;
		for_each_child_of_node(np, child)
			imx_pinctrl_parse_functions(child, ipctl, i++);
	}
```

#### imx_pinctrl_dt_is_flat_functions()函数

drivers/pinctrl/freescale/pinctrl-imx.c

遍历两层, 检查一下是不是有fsl,pins属性, 判断是在哪一层

```c
static bool imx_pinctrl_dt_is_flat_functions(struct device_node *np)
{
	struct device_node *function_np;
	struct device_node *pinctrl_np;
	// 遍历所有的子节点
	for_each_child_of_node(np, function_np) {
		// 查看一下是不是有这个属性
		if (of_property_read_bool(function_np, "fsl,pins"))
			return true;
			
		for_each_child_of_node(function_np, pinctrl_np) {
			if (of_property_read_bool(pinctrl_np, "fsl,pins"))
				return false;
		}
	}

	return true;
}
```



#### imx_pinctrl_parse_functions()函数

drivers/pinctrl/freescale/pinctrl-imx.c

iomuxc节点的device_node结构体指针, ipctl, 0

初始化一下func的基数树, 之后创建一下group_desc这个基数树

![image-20250916110157447](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509161101566.png)

```c
static int imx_pinctrl_parse_functions(struct device_node *np,
				       struct imx_pinctrl *ipctl,
				       u32 index)
{
	struct pinctrl_dev *pctl = ipctl->pctl;
	struct device_node *child;
	struct function_desc *func;
	struct group_desc *grp;
	u32 i = 0;
	// 获取之前挂载在基数树的func结构体
	func = pinmux_generic_get_function(pctl, index);
	...
	func->name = np->name; // 设置为设备树节点的名字
	func->num_group_names = of_get_child_count(np); // 记录一下子节点(group)的数量
	...
    // 根据group的数量分配名字指针
	func->group_names = devm_kcalloc(ipctl->dev, func->num_group_names,
					 sizeof(char *), GFP_KERNEL);
	if (!func->group_names)
		return -ENOMEM;
	// 遍历节点
	for_each_child_of_node(np, child) {
		func->group_names[i] = child->name;
		// 请求一个group_desc结构体, 用于记录每一个group里面的信息
		grp = devm_kzalloc(ipctl->dev, sizeof(struct group_desc),
				   GFP_KERNEL);
		if (!grp)
			return -ENOMEM;

		mutex_lock(&ipctl->mutex);
        // 会在这里imx_pinctrl++这个数据, 记录所有的group数量
		radix_tree_insert(&pctl->pin_group_tree,
				  ipctl->group_index++, grp);
		mutex_unlock(&ipctl->mutex);

		imx_pinctrl_parse_groups(child, grp, ipctl, i++);
	}

	return 0;
}
```

#### pinmux_generic_get_function()函数

drivers/pinctrl/pinmux.c

```c
struct function_desc *pinmux_generic_get_function(struct pinctrl_dev *pctldev,
						  unsigned int selector)
{
	struct function_desc *function;

	function = radix_tree_lookup(&pctldev->pin_function_tree,
				     selector);
	if (!function)
		return NULL;

	return function;
}
```



#### imx_pinctrl_parse_groups()函数

```c
static int imx_pinctrl_parse_groups(struct device_node *np,
				    struct group_desc *grp,
				    struct imx_pinctrl *ipctl,
				    u32 index)
{
	const struct imx_pinctrl_soc_info *info = ipctl->info;
	int size, pin_size;
	const __be32 *list, **list_p;
	u32 config;
	int i;
	// flags未初始化, 所有是0
	if (info->flags & IMX8_USE_SCU)
		pin_size = FSL_IMX8_PIN_SIZE;
	else if (info->flags & SHARE_MUX_CONF_REG)
		pin_size = FSL_PIN_SHARE_SIZE;
	else
		pin_size = FSL_PIN_SIZE;//24一个引脚配置的长度
	
	grp->name = np->name; // 记录group的名字
	// 获取配置属性
	list = of_get_property(np, "fsl,pins", &size);
	...
    // 记录设备树里面的所有节点的信息
	list_p = &list;
	...
	/*该组引脚的配置个数*/
	grp->num_pins = size / pin_size;
	// 为每一个引脚分配一个结构体
	grp->data = devm_kcalloc(ipctl->dev,
				 grp->num_pins, sizeof(struct imx_pin),
				 GFP_KERNEL);
	
	grp->pins = devm_kcalloc(ipctl->dev,
				 grp->num_pins, sizeof(unsigned int),
				 GFP_KERNEL);
	...
	for (i = 0; i < grp->num_pins; i++) {
		struct imx_pin *pin = &((struct imx_pin *)(grp->data))[i];

		if (info->flags & IMX8_USE_SCU)
			imx_pinctrl_parse_pin_scu(ipctl, &grp->pins[i],
				pin, list_p, config);
		else
            // 实际的调用位置, 传入刚才申请的两个数组的对应位置
			imx_pinctrl_parse_pin_mem(ipctl, &grp->pins[i],
				pin, list_p, config);
	}

	return 0;
}
```

#### imx_pinctrl_parse_pin_mem()函数

drivers/pinctrl/freescale/pinctrl-memmap.c

![image-20250916113744715](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509161137808.png)

![image-20250916113842266](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509161138411.png)

```c
int imx_pinctrl_parse_pin_mem(struct imx_pinctrl *ipctl,
			  unsigned int *grp_pin_id, struct imx_pin *pin,
			  const __be32 **list_p, u32 generic_config)
{
	struct imx_pin_memmap *pin_memmap = &pin->pin_conf.pin_memmap;
	const struct imx_pinctrl_soc_info *info = ipctl->info;
    // 解析一条数据
	u32 mux_reg = be32_to_cpu(*((*list_p)++));
	u32 conf_reg;
	u32 config;
	unsigned int pin_id;
	struct imx_pin_reg *pin_reg;
	
	if (info->flags & SHARE_MUX_CONF_REG) {
		conf_reg = mux_reg;
	} else {
		conf_reg = be32_to_cpu(*((*list_p)++));
		if (!conf_reg)
			conf_reg = -1;
	}
	// 使用复用寄存器的偏移获取引脚的编号
	pin_id = (mux_reg != -1) ? mux_reg / 4 : conf_reg / 4;
    // 获取到imx_pin_reg用于记录实际的寄存器地址
	pin_reg = &ipctl->pin_regs[pin_id];
	pin->pin = pin_id; // 记录引脚的编号
	*grp_pin_id = pin_id;
	pin_reg->mux_reg = mux_reg;
	pin_reg->conf_reg = conf_reg;
    // 解析设备树数据
	pin_memmap->input_reg = be32_to_cpu(*((*list_p)++));
	pin_memmap->mux_mode = be32_to_cpu(*((*list_p)++));
	pin_memmap->input_val = be32_to_cpu((*(*list_p)++));
	...
     // 获取硬件的配置属性
	config = be32_to_cpu(*((*list_p)++));
	...
	if (config & IMX_PAD_SION)
		pin_memmap->mux_mode |= IOMUXC_CONFIG_SION;
	pin_memmap->config = config & ~IMX_PAD_SION;
	...
	return 0;
}
```

## pin state：pinctrl-names的真相

#### iomuxc节点

- 存储全部所需的引脚配置信息
- "虚拟"外设
    - 设置pin state数量和类型
    - 设置状态对应的pin group

pin state->pin group，一对多

pin group->pin，一对多

#### pinctl_map 

存储外设所有state下pin group的配置信息

#### 函数层次分析

`pinctrl_enable()->pinctrl_claim_hogs()`

- `create_pinctrl`

    ----------------------------------------------第一部分-------------------------------------

    - `pinctrl_dt_to_map()`

        - `for (state = 0; ; state++)：`查找外设所有pin group的状态

            - `for (config = 0; config < size; config++)：`查找状态的所有引脚组

                ------------------------------第二部分-------------------------------------

                - `dt_to_map_one_config`
                    - 创建一个`pinctrl_map`，负责初始化引脚组的所有引脚复用

                    - 创建多个`pinctrl_map`，每个pinctrl_map负责配置引脚中的一个引脚属性

    ----------------------------------------------第三部分-------------------------------------

    - `add_setting`

#### pinctrl_enable()函数

drivers/pinctrl/core.c

```c
int pinctrl_enable(struct pinctrl_dev *pctldev)
{
	int error;

	error = pinctrl_claim_hogs(pctldev);
	...
	//将pctldev加入全局链表
	list_add_tail(&pctldev->node, &pinctrldev_list);
	...
	return 0;
}
```

#### pinctrl_claim_hogs()函数

drivers/pinctrl/core.c

```c
static int pinctrl_claim_hogs(struct pinctrl_dev *pctldev)
{
	
	pctldev->p = create_pinctrl(pctldev->dev, pctldev);
	
	//第四部分
	pctldev->hog_default =
		pinctrl_lookup_state(pctldev->p, PINCTRL_STATE_DEFAULT);
	if (IS_ERR(pctldev->hog_default)) {
		dev_dbg(pctldev->dev,
			"failed to lookup the default state\n");
	} else {
		//设置为default状态
		if (pinctrl_select_state(pctldev->p,
					 pctldev->hog_default))
			dev_err(pctldev->dev,
				"failed to select default state\n");
	}
	...
	pctldev->hog_sleep =
		pinctrl_lookup_state(pctldev->p,
		
	...
}
```

#### create_pinctrl()函数

drivers/pinctrl/core.c

![image-20250916142330628](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509161423704.png)

```c
static struct pinctrl *create_pinctrl(struct device *dev,
				      struct pinctrl_dev *pctldev)
{
	struct pinctrl *p;
	const char *devname;
	struct pinctrl_maps *maps_node;
	int i;
	const struct pinctrl_map *map;
	int ret;
	
	p = kzalloc(sizeof(*p), GFP_KERNEL);
	...
	p->dev = dev;
	INIT_LIST_HEAD(&p->states);
	INIT_LIST_HEAD(&p->dt_maps);
	//第一部分
	ret = pinctrl_dt_to_map(p, pctldev);
	
	devname = dev_name(dev);
	...
	for_each_maps(maps_node, i, map) {
		/* Map must be for this device */
		if (strcmp(map->dev_name, devname))
			continue;
			
        if (pctldev &&
            strcmp(dev_name(pctldev->dev), map->ctrl_dev_name))
            continue;
		//第三部分
		ret = add_setting(p, pctldev, map);
		...
	}
	...
	list_add_tail(&p->node, &pinctrl_list);
	...
}
```

#### pinctrl_dt_to_map()函数

drivers/pinctrl/devicetree.c

```c
pinctrl-names = "default"，"init","sleep";
pinctrl-0 = <&pinctrl_hog_1 &aaa &bbb>;
pinctrl-1 =<&xxx>;
pinctrl-2 =<&yyy>;
```

```c
int pinctrl_dt_to_map(struct pinctrl *p, struct pinctrl_dev *pctldev)
{
	/*iomux节点*/
	struct device_node *np = p->dev->of_node;
	int state, ret;
	char *propname;
	struct property *prop;
	const char *statename;
	const __be32 *list;
	int size, config;
	phandle phandle;
	struct device_node *np_config;
	
	...
    // 所有的初始化状态
	for (state = 0; ; state++) {
        // 合成初始化属性的名字
		propname = kasprintf(GFP_KERNEL, "pinctrl-%d", state);
		// 查找是不是有这个对应的设置, 可以获取到实际的配置引用数组
        prop = of_find_property(np, propname, &size);
		kfree(propname);
		
		if (!prop) {
			if (state == 0) {
				of_node_put(np);
				return -ENODEV;
			}
			break;
		}
		list = prop->value;
		// 获取当前state中的group数量
		size /= sizeof(*list);
		// 读取对应的名字, 之后设置在对应的引脚组配置里面
		ret = of_property_read_string_index(np, "pinctrl-names",state, &statename);
		...
         // 遍历所有的引脚组
		for (config = 0; config < size; config++) {
            //句柄
            phandle = be32_to_cpup(list++);
            //根据句柄查找子节点
            np_config = of_find_node_by_phandle(phandle);
            // 处理引脚组
            ret = dt_to_map_one_config(p, pctldev, statename,
                               np_config);
            ...
		}
   ...
}
```

#### dt_to_map_one_config()函数

drivers/pinctrl/devicetree.c

为每一个引脚创建一个pinctrl_map

![image-20250916143818909](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509161438040.png)

```c
static int dt_to_map_one_config(struct pinctrl *p,
				struct pinctrl_dev *hog_pctldev,
				const char *statename,
				struct device_node *np_config)
{
	struct pinctrl_dev *pctldev = NULL;
	struct device_node *np_pctldev;
	const struct pinctrl_ops *ops;
	int ret;
	struct pinctrl_map *map;
	unsigned num_maps;
	bool allow_default = false;
	
	np_pctldev = of_node_get(np_config);
	
	for (;;) {
		/*获取到iomuxc节点*/	
        np_pctldev = of_get_next_parent(np_pctldev);

        if (hog_pctldev && (np_pctldev == p->dev->of_node)) {
                // 成立
                pctldev = hog_pctldev;
                break;
            }
		// 遍历数组里面的
        pctldev = get_pinctrl_dev_from_of_node(np_pctldev);

        if (pctldev)
            break;
	}
	...
	//imx_pctrl_ops
	ops = pctldev->desc->pctlops;
	...
	//imx_dt_node_to_map函数, 为每一个引脚组创建一个pinctrl_map数组, 并获取到对应的配置
	ret = ops->dt_node_to_map(pctldev, np_config, &map, &num_maps);
	...
    // 初始化pinctrl_map的dev_name以及对应的配置名字, 创建pinctrl_dt_map
	return dt_remember_or_free_map(p, statename, pctldev, map, num_maps);
}
```

#### of_node_get()函数

include/linux/of.h

```c
static inline struct device_node *of_node_get(struct device_node *node)
{
	return node;
}
```

## pinctl_map：引脚三千，只取一瓢

#### pinctrl_map数组

![image-20250916144610707](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509161446912.png)

- pin group配置信息

    - `pinctrl_map[0]`：配置pin group的所有引脚复用

    - `pinctrl_map[1~n]`：配置pin group的每个引脚的属性

#### 函数层次分析

pinctrl_enable()->pinctrl_claim_hogs()

- create_pinctrl

    ----------------------------------------------第一部分-------------------------------------

    - pinctrl_dt_to_map()

        - for (state = 0; ; state++)：查找外设所有pin group的状态

            - for (config = 0; config < size; config++)：查找状态的所有引脚组

                ------------------------------第二部分-------------------------------------

                - dt_to_map_one_config

                    - 创建一个pinctrl_map，负责初始化配置pin group的所有引脚复用

                    - 创建多个pinctrl_map，每个pinctrl_map负责配置引脚中的一个引脚属性

    ----------------------------------------------第三部分-------------------------------------

    - add_setting

#### imx_dt_node_to_map()函数

drivers/pinctrl/freescale/pinctrl-imx.c

把引脚的数据转移到pinctrl_map里面进行保存

```c
static int imx_dt_node_to_map(struct pinctrl_dev *pctldev,
			struct device_node *np,
			struct pinctrl_map **map, unsigned *num_maps)
{
    // 获取到dirver_data记录的imx_pinctrl变量
	struct imx_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);
    // 获取一下info指向的imx_pinctrl_soc_info变量
	const struct imx_pinctrl_soc_info *info = ipctl->info;
	const struct group_desc *grp;
	struct pinctrl_map *new_map;
	struct device_node *parent;
	int map_num = 1;
	int i, j;
	// 基数树里面查找一下group
	grp = imx_pinctrl_find_group_by_name(pctldev, np->name);
	
	if (info->flags & IMX8_USE_SCU) {
		map_num += grp->num_pins;
	} else {
        // 这里
		for (i = 0; i < grp->num_pins; i++) {
            // 遍历所有的引脚 
            struct imx_pin *pin = &((struct imx_pin *)(grp->data))[i];
		   // 查看一下是不是有这个标志, 在设备数里面设置, 一般是没有的, 取反, 获取到True
		   if (!(pin->pin_conf.pin_memmap.config & IMX_NO_PAD_CTL))
				map_num++; // 计算一下有几个引脚需要建立pinctrl_map
		}
	}
	
	new_map = kmalloc_array(map_num, sizeof(struct pinctrl_map),
				GFP_KERNEL);
				
	*map = new_map;
	*num_maps = map_num;
	
	 /*iomuxc节点*/
	 parent = of_get_parent(np);
	 ...
     // 初始化第一个元素
	 new_map[0].type = PIN_MAP_TYPE_MUX_GROUP;
	 new_map[0].data.mux.function = parent->name;
	 new_map[0].data.mux.group = np->name;
	 ..
	 new_map++;
	 
	 for (i = j = 0; i < grp->num_pins; i++) {
		struct imx_pin *pin = &((struct imx_pin *)(grp->data))[i];

		if (info->flags & IMX8_USE_SCU) {
			new_map[j].type = PIN_MAP_TYPE_CONFIGS_PIN;
			new_map[j].data.configs.group_or_pin =
					pin_get_name(pctldev, pin->pin);
			new_map[j].data.configs.configs =
					(unsigned long *)&pin->pin_conf.pin_scu;
			new_map[j].data.configs.num_configs = 2;
			j++;
		} else if (!(pin->pin_conf.pin_memmap.config & IMX_NO_PAD_CTL)) {
            // 实际运行的部分, 从基数树里面查找数据的信息
			new_map[j].type = PIN_MAP_TYPE_CONFIGS_PIN;
			new_map[j].data.configs.group_or_pin =
					pin_get_name(pctldev, pin->pin); // 使用引脚的编号, 查找一下引脚的名字
			new_map[j].data.configs.configs =
					&pin->pin_conf.pin_memmap.config; // 获取属性配置
			new_map[j].data.configs.num_configs = 1;
			j++;
		}
	}
	...
}
```

#### imx_pinctrl_find_group_by_name()函数

从基数树里面使用名字进行查找对应的group_desc结构

```c
static inline const struct group_desc *imx_pinctrl_find_group_by_name(
				struct pinctrl_dev *pctldev,
				const char *name)
{
	const struct group_desc *grp = NULL;
	int i;

	for (i = 0; i < pctldev->num_groups; i++) {
		grp = pinctrl_generic_get_group(pctldev, i);
		if (grp && !strcmp(grp->name, name))
			break;
	}

	return grp;
}
```

#### pinctrl_generic_get_group()函数

drivers/pinctrl/core.c

查找

```c
struct group_desc *pinctrl_generic_get_group(struct pinctrl_dev *pctldev,
					     unsigned int selector)
{
	struct group_desc *group;

	group = radix_tree_lookup(&pctldev->pin_group_tree,
				  selector);
	if (!group)
		return NULL;

	return group;
}
```

#### pin_get_name()函数

drivers/pinctrl/core.c

使用引脚的编号获取引脚的名字

![image-20250916215138560](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509162151642.png)

```c
const char *pin_get_name(struct pinctrl_dev *pctldev, const unsigned pin)
{
	const struct pin_desc *desc;
	// 获取对应的基数树里面的desc
	desc = pin_desc_get(pctldev, pin);
	if (!desc) {
		dev_err(pctldev->dev, "failed to get pin(%d) name\n",
			pin);
		return NULL;
	}

	return desc->name;
}
```

#### pin_desc_get函数

drivers/pinctrl/core.h

```c
static inline struct pin_desc *pin_desc_get(struct pinctrl_dev *pctldev,
					    unsigned int pin)
{
	return radix_tree_lookup(&pctldev->pin_desc_tree, pin);
}
```

#### dt_remember_or_free_map()函数

drivers/pinctrl/devicetree.c

设置一下pinctrl_map数组, 设置名字以及对应的状态名字

```c
static int dt_remember_or_free_map(struct pinctrl *p, const char *statename,struct pinctrl_dev *pctldev,struct pinctrl_map *map, unsigned num_maps)
{
	int i;
	struct pinctrl_dt_map *dt_map;

	/* Initialize common mapping table entry fields */
	for (i = 0; i < num_maps; i++) {
        // 初始化引脚组的名字以及对应的配置名字
		map[i].dev_name = dev_name(p->dev);
		map[i].name = statename;
		if (pctldev)
			map[i].ctrl_dev_name = dev_name(pctldev->dev);
	}

	/* Remember the converted mapping table entries */
    // 创建pinctrl_dt_map
	dt_map = kzalloc(sizeof(*dt_map), GFP_KERNEL);
	if (!dt_map) {
		dt_free_map(pctldev, map, num_maps);
		return -ENOMEM;
	}

	dt_map->pctldev = pctldev;
	dt_map->map = map;
	dt_map->num_maps = num_maps;
	list_add_tail(&dt_map->node, &p->dt_maps);

	return pinctrl_register_map(map, num_maps, false);
}
```



#### pinctrl_register_map()函数

drivers/pinctrl/core.c

![image-20250916222454338](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509162224417.png)

```c
int pinctrl_register_map(const struct pinctrl_map *maps, unsigned num_maps,
			 bool dup)
{
	int i, ret;
	struct pinctrl_maps *maps_node;
	
	for (i = 0; i < num_maps; i++) {
	// 判断一下是不是有初始化值, 这里都是成功的
	switch (maps[i].type) {
		case PIN_MAP_TYPE_DUMMY_STATE:
			break;
		case PIN_MAP_TYPE_MUX_GROUP:
            // 0位置的进入这里
			ret = pinmux_validate_map(&maps[i], i);
			if (ret < 0)
				return ret;
			break;
		case PIN_MAP_TYPE_CONFIGS_PIN:
		case PIN_MAP_TYPE_CONFIGS_GROUP:
            // 其他位置的进入这里
			ret = pinconf_validate_map(&maps[i], i);
			if (ret < 0)
				return ret;
			break;
		default:
			pr_err("failed to register map %s (%d): invalid type given\n",
			       maps[i].name, i);
			return -EINVAL;
		}
	}
	// 创建pinctrl_maps
	maps_node = kzalloc(sizeof(*maps_node), GFP_KERNEL);
	maps_node->num_maps = num_maps;
	
	if (dup) {
		maps_node->maps = kmemdup(maps, sizeof(*maps) * num_maps,
					  GFP_KERNEL);
		if (!maps_node->maps) {
			kfree(maps_node);
			return -ENOMEM;
		}
	} else {
        // 实际执行的
		maps_node->maps = maps;
	}
	...
	list_add_tail(&maps_node->node, &pinctrl_maps);
	...
}
```



#### pinmux_validate_map()函数

drivers/pinctrl/pinmux.c

```c
int pinmux_validate_map(const struct pinctrl_map *map, int i)
{
    // function记录的是iomux的名字, 所以这个判断是不成立的
	if (!map->data.mux.function) {
		pr_err("failed to register map %s (%d): no function given\n",
		       map->name, i);
		return -EINVAL;
	}

	return 0;
}
```



#### pinconf_validate_map()函数

drivers/pinctrl/pinmux.c

```c
int pinconf_validate_map(const struct pinctrl_map *map, int i)
{
	if (!map->data.configs.group_or_pin) {
		pr_err("failed to register map %s (%d): no group/pin given\n",
		       map->name, i);
		return -EINVAL;
	}

	if (!map->data.configs.num_configs ||
			!map->data.configs.configs) {
		pr_err("failed to register map %s (%d): no configs given\n",
		       map->name, i);
		return -EINVAL;
	}

	return 0;
}
```

