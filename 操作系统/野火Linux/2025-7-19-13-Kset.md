# Kset

![image-20250719131703278](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507191317328.png)

| 特性                      | 父对象是 `kobject` (`kobj->parent = &other_kobj`) | 父对象是 `kset` (`kobj->kset = &some_kset`, 常隐含设置 `parent`) |
| :------------------------ | :------------------------------------------------ | :----------------------------------------------------------- |
| **`sysfs` 目录位置**      | 在父 `kobject` 的目录下                           | 在 `kset` 的目录 (`kset->kobj` 对应的目录) 下                |
| **主要语义**              | 直接的层级/包含关系 (Part-of)                     | 集合/类别成员关系 (Member-of)                                |
| **主要目的**              | 构建 `sysfs` 树形结构                             | 分组管理、提供默认行为 (`ktype`/属性)                        |
| **是否自动设置 `parent`** | 否 (必须显式设置)                                 | **是** (当 `parent` 未显式设置时，自动设为 `kset->kobj`)     |
| **引用持有者**            | 父 `kobject` 持有子 `kobject` 的引用              | `kset` 持有成员 `kobject` 的引用                             |
| **`kset` 关联**           | 仍需单独设置 `kobj->kset` (用于类型/分组)         | 直接通过 `kobj->kset` 设置                                   |

##### kset_create_and_add()函数

lib/kobject.c

创建一个kset并且关联一个目录项, kobj不可以直接发送消息到用户空间, 需要使用kset对象转发, 守护进程接收以后创建文件

```c
// kset_uevent_ops: 操作接口, 用于和用户空间通信
// name 目录项的名称, kset_uevent_ops 一系列接口, 用于发送信息到用户空间, parent_kobj 上一级的
struct kset *kset_create_and_add(const char *name,
const struct kset_uevent_ops *uevent_ops,struct kobject *parent_kobj)
{
	struct kset *kset;
	int error;
	// 分配一个kset注册立即信息, 名字以及操作函数
	kset = kset_create(name, uevent_ops, parent_kobj);
	if (!kset)
		return NULL;
	// 和目录项进行绑定, 同时通知用户空间
	error = kset_register(kset);
	if (error) {
		kfree(kset);
		return NULL;
	}
	return kset;
}
```

##### kset_create()函数

lib/kobject.c

分配一个kset注册立即信息, 名字以及操作函数

<img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507181437767.png" alt="image-20250718143722417" style="zoom:35%;" />

```c
static struct kset *kset_create(const char *name,const struct kset_uevent_ops *uevent_ops,struct kobject *parent_kobj)
{
	struct kset *kset;
	int retval;

	kset = kzalloc(sizeof(*kset), GFP_KERNEL);
	if (!kset)
		return NULL;
	retval = kobject_set_name(&kset->kobj, "%s", name);
	if (retval) {
		kfree(kset);
		return NULL;
	}
	/*注册消息发送接口*/
	kset->uevent_ops = uevent_ops;
	kset->kobj.parent = parent_kobj;

	kset->kobj.ktype = &kset_ktype; // kobject对应属性操作接口
	kset->kobj.kset = NULL;

	return kset;
}
```

##### kset_init()函数

lib/kobject.c

```c
void kset_init(struct kset *k)
{
    // 初始化kobj的各种标志链表
	kobject_init_internal(&k->kobj);
    // 初始化链表头
	INIT_LIST_HEAD(&k->list);
	spin_lock_init(&k->list_lock);
}
```

##### kset_register()函数

lib/kobject.c, 和目录项绑定, 同时通知用户空间

```c
int kset_register(struct kset *k)
{
	int err;

	if (!k)
		return -EINVAL;

	kset_init(k);
	// 依据之间设置的parent, 初始化文件系统关联目录项, 和父对象进行关联, 初始化kernfs_node
	err = kobject_add_internal(&k->kobj);
	if (err)
		return err;

	/*发送驱动模型消息到应用层*/
	kobject_uevent(&k->kobj, KOBJ_ADD);
	return 0;
}
```

## 代码实现

```c
static int __init led_init(void)
{
	int retval;

	/* GPIO相关寄存器映射 */
  	IMX6U_CCM_CCGR1 = ioremap(0x20c406c, 4);
	SW_MUX_GPIO1_IO04 = ioremap(0x20e006c, 4);
  	SW_PAD_GPIO1_IO04 = ioremap(0x20e02f8, 4);
	GPIO1_GDIR = ioremap(0x0209c004, 4);
	GPIO1_DR = ioremap(0x0209c000, 4);


	/* 使能GPIO1时钟 */
	iowrite32(0xffffffff, IMX6U_CCM_CCGR1);

	/* 设置GPIO1_IO04复用为普通GPIO*/
	iowrite32(5, SW_MUX_GPIO1_IO04);
	
    /*设置GPIO属性*/
	iowrite32(0x10B0, SW_PAD_GPIO1_IO04);

	/* 设置GPIO1_IO04为输出功能 */
	iowrite32(1 << 4, GPIO1_GDIR);

	/* LED输出高电平 */
	iowrite32(1<< 4, GPIO1_DR);

	/*创建一个kset对象, 无发送信息函数以及父对象*/
	example_kset = kset_create_and_add("kset_example", NULL, NULL);
	if (!example_kset)
		return -ENOMEM;

	/* 创建一个kobject对象*/
	led_kobj = kobject_create_and_add("led_kobject", &example_kset->kobj);
	if (!led_kobj)
		return -ENOMEM;

	/* 为kobject设置属性文件*/
	retval = sysfs_create_group(led_kobj, &attr_group);
	if (retval)
		kobject_put(led_kobj);

	return retval;

	return 0;
}
```

![image-20250719133340540](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507191333594.png)

## 使用kset以及kobject的区别

### 1. Uevent 事件无法发送（最严重的问题）

这是最核心的区别。`kset` 结构体中包含一个至关重要的成员 `uevent_ops`：

c

```
struct kset {
    struct kobj_type * ktype;
    struct list_head list;
    spinlock_t list_lock;
    struct kobject kobj;
    const struct kset_uevent_ops *uevent_ops; // <-- 关键！
};
```

这个 `uevent_ops` 提供了三个函数指针：

- `filter`: 决定是否允许为某个 kobject 发送 uevent。
- `name`: 当发送 uevent 时，如何获取该 kobject 在 uevent 中的名称。
- `uevent`: 在发送 uevent 之前，允许添加额外的环境变量。

**当你调用 `kobject_uevent()` 为某个 kobject 发送事件时（例如，设备被添加 `KOBJ_ADD`），该函数会沿着父级链向上查找，直到找到一个拥有 `uevent_ops` 的父对象（即一个 `kset`），然后调用它的 `uevent_ops` 来最终完成事件的发送。**

**如果父对象只是一个普通的 `kobject`：**

- 它没有 `uevent_ops` 成员。
- `kobject_uevent()` 在向上查找时会遇到这个“死胡同”，找不到能够处理事件的 `kset`。
- **结果就是：uevent 事件发送失败，用户空间的 udev 或其他守护进程永远不会收到“设备添加”、“设备移除”等通知。**
- **这直接导致 `/dev` 目录下不会自动创建设备节点，应用程序无法通过设备节点访问你的驱动。**

### 2. 组织结构混乱，不符合内核设计模式

`kset` 被设计为**同类 kobject 的容器**。它的 `list` 成员会维护一个链表，自动将所有属于它的子 kobject 链接起来。

c

```
// kobject_add() 内部会发生类似这样的操作
list_add_tail(&kobj->entry, &kobj->parent->kset->list);
```

**如果父对象只是一个普通的 `kobject`：**

- 它没有 `kset` 所需的链表头 (`list`) 和自旋锁 (`list_lock`)。
- 子对象无法被加入到任何容器链表中。
- 你无法通过遍历一个父 `kset` 的链表来找到所有属于它的子对象。
- 这打破了内核的对象管理模型，使得代码难以维护和调试。你无法使用内核提供的标准方法来管理和查询一组相关的对象。

### 3. 可能缺乏必要的生命周期管理支持

虽然一个 `kobject` 可以有自己的 `ktype` 并提供 `release` 方法，但 `kset` 作为一个容器，其生命周期通常与其包含的对象紧密相关。

- 当引用计数为 0 时，`kset` 的 `release` 方法 (`kset_release`) 会负责释放 `kset` 本身。
- 如果一个 `kobject` 的父指针指向另一个 `kobject`，而不是一个管理它的 `kset`，那么父 `kobject` 的释放可能会在其子对象之前发生，这可能导致无效的父指针和不可预知的行为。而 `kset` 的设计更能保证容器生命周期的正确性。