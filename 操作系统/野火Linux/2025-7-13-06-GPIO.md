# GPIO

### GPIO控制原理

#### 了解GPIO

##### 数量

 5 组 GPIO（GPIO1～GPIO5），每组最多32个，共124个

- GPIO1_IO0~GPIO1_IO31

- GPIO2_IO0~GPIO2_IO21

- GPIO3_IO0~GPIO3_IO28

- GPIO4_IO0~GPIO4_IO28

- GPIO5_IO0~GPIO5_IO11

    

数据手册描述

28.2 External Signals  

![image-20250713091051734](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507130910878.png)

####  时钟

clock controller module(CCM模块)用于配置芯片的各种外设时钟。跟GPIO相关的时钟主要有CCM_CCGR(0~3)寄存器。

![image-20250713091326020](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507130913069.png)

数据手册描述

18.4 System Clocks  

![image-20250713091607134](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507130916194.png)

![image-20250713091623936](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507130916026.png)

两个bit的不同取值，设置GPIO时钟的不同属性：

- 00：所有模式下都关闭外设时钟
- 01：只有在运行模式下打开外设时钟
- 10：保留
- 11：除了停止模式以外，该外设时钟全程使能

![image-20250713091806028](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507130918063.png)

#### 引脚复用

相关寄存器：IOMUXC_SW_MUX_CTL_PAD_XXX 控制引脚的功能

数据手册：

![image-20250713094208279](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507130942405.png)

![image-20250713094443010](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507130944157.png)

- 0101：ALT5 ->普通GPIO模式

    ##### 引脚属性

    相关寄存器：IOMUXC_SW_PAD_CTL_PAD_XXX

    数据手册：

    ![image-20250713094723845](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507130947896.png)

    注意：数据手册上对GPIO引脚的命令，不是严格按顺序命名的，而是根据Table 28来命名的

![image-20250713094813412](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507130948484.png)

![image-20250713094828157](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507130948227.png)

- HYS（bit16）：用来使能迟滞比较器 
- PUS（bit15-bit14）：用来设置上下拉电阻大小
- PUE（bit13）：当 IO 作为输入的时候，这个位用来设置 IO 使用上下拉还是状态保持器
- PKE（bit12）：用来使能或者禁止上下拉/状态保持器功能
- ODE（bit11）：IO 作为输出的时候，此位用来禁止或者使能开漏输出。
- SPEED（bit7-bit6）：当 IO 用作输出的时候，此位用来设置 IO 速度。
- DSE（bit5-bit3）：当 IO 用作输出的时候用来设置 IO 的驱动能力。
- SRE（bit0）：设置压摆率



#### 控制GPIO引脚

5组GPIO,每组GPIO有8个相关寄存器

- GPIOx_GDIR：设置引脚方向
- GPIOx_DR：设置输出引脚的电平
- ...

每个寄存器有32位，分别控制每位的gpio



​	数据手册描述：

​	28.5.2 GPIO direction register (GPIOx_GDIR)  

![image-20250713095048024](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507130950065.png)

​	- 0：输入

​	- 1：输出

![image-20250713095220504](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507130952572.png)

28.5.1 GPIO data register (GPIOx_DR)  

![image-20250713095240001](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507130952139.png)

2.2 ARM Platform Memory Map  

![image-20250713095428091](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507130954160.png)

可以用于计算GDIR之类的寄存器的位置

控制GPIO总结

- 使能GPIO时钟

- 设置引脚复用为GPIO
- 设置引脚属性(上下拉、速率、驱动能力)
- 控制GPIO引脚输出高低电平

硬件原理图：

![image-20250713095832730](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507130958784.png)

![image-20250713100121769](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507131001872.png)

### 汇编寄存器操作实例

```assembly
.global _start



_start:

    @ start timer
    ldr r0, =0x20c406c
    ldr r1, =0xffffffff
    str r1, [r0]

    @ pin use as gpio
    ldr r0, =0x20e006c
    ldr r1, =5
    str r1, [r0]

	@ 设置一下引脚的属性
    ldr r0, =0x20e02f8
    ldr r1, =0x10b0
    str r1, [r0]
	@ 设置引脚方向
    ldr r0, =0x2009c004
    ldr r1, =16
    str r1, [r0]
	@ 设置输出电平
    ldr r0, =0x2009c000
    ldr r1, =0
    str r1, [r0]
```

> ```bash
> arm-none-eabi-gcc -c ./led.s -o led.o
> arm-none-eabi-ld -Ttext 0x80000000 led.o -o led.elf
> arm-none-eabi-objcopy -O binary led.elf led.bin
> ```
>
> 

## C语言

### 使用官方头文件

![image-20250713122755020](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507131227104.png)

> 需要注释掉他引用的其他头文件, 加入数据类型
>
> ```c
> #define __O  volatile
> #define __IO  volatile 
> #define __I  volatile const 
> 
> #define uint32_t unsigned int
> #define uint16_t unsigned short
> #define uint8_t unsigned char
> ```
>
> ![image-20250713123052192](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507131230249.png)

### 初始化C语音环境

+ .bss段清零
+ 初始化栈指针sp

```assembly
.global _start

_start:

    ldr sp,=0x84000000
    b main
```

### 实际的代码



```c
#include  "MCIMX6Y2.h"
#include  "fsl_iomuxc.h"

/*简单延时函数*/
void delay(uint32_t count)
{
    volatile uint32_t i = 0;
    for (i = 0; i < count; ++i)
    {
        __asm("NOP"); /* 调用nop空指令 */
    }
}

int main(void)
{
    /*使能GPIO1时钟*/
      CCM->CCGR1 = 0xffffffff;

     /*设置 红灯 引脚的复用功能以及PAD属性*/
    IOMUXC_SetPinMux(IOMUXC_GPIO1_IO04_GPIO1_IO04,0);     
    IOMUXC_SetPinConfig(IOMUXC_GPIO1_IO04_GPIO1_IO04, 0X10B0); 

    /*设置GPIO1_04为输出模式*/
    GPIO1->GDIR |= (1<<4);  

    /*设置GPIO1_04输出电平为高电平*/
    GPIO1->DR |= (1<<4);  

    while(1)
    {
         GPIO1->DR &= ~(1<<4); //红灯亮
         delay(0xFFFFF);
         GPIO1->DR |= (1<<4); //红灯灭
          delay(0xFFFFF);
    }

    return 0;

}
```



```makefile
ifeq ($(ARCH),x86)
CC = gcc
 else
##CC = arm-linux-gnueabihf-gcc
CC = arm-none-eabi-gcc
LD = arm-none-eabi-ld
OBJCOPY = arm-none-eabi-objcopy
endif

TARGET = led
BUILD_DIR = build
SRC_DIR = sources
INC_DIR = include
CFLAGS = $(patsubst %, -I%, $(INC_DIR))
INCLUDES = $(foreach dir,$(INC_DIR),$(wildcard $(dir)/*.h))

#源文件要加上汇编文件
SOURCES_c= $(foreach dir,$(SRC_DIR),$(wildcard $(dir)/*.c))
SOURCES_s= $(foreach dir,$(SRC_DIR),$(wildcard $(dir)/*.s))
OBJS = $(patsubst %.c, $(BUILD_DIR)/%.o, $(notdir $(SOURCES_c)))
OBJS += $(patsubst %.s, $(BUILD_DIR)/%.o, $(notdir $(SOURCES_s)))
VPATH=$(SRC_DIR)

$(BUILD_DIR)/$(TARGET).bin: $(OBJS)
	$(LD) -Tscript.lds -o $(BUILD_DIR)/$(TARGET).elf $^
	$(OBJCOPY) -O binary $(BUILD_DIR)/$(TARGET).elf $@

$(BUILD_DIR)/%.o : %.c  $(INCLUDES) |  create_build
	$(CC) -c $< -o $@  $(CFLAGS) 

#编译汇编文件
$(BUILD_DIR)/%.o : %.s  $(INCLUDES) |  create_build
	$(CC) -c $< -o $@  $(CFLAGS) 

.PHONY:clean create_build burn

clean:
	rm -r $(BUILD_DIR)

create_build:
	mkdir -p $(BUILD_DIR)
# 烧录的部分
burn:
	cp  $(BUILD_DIR)/$(TARGET).bin /home/embedfire/bare_mental/part_1/download_tool
	cd /home/embedfire/bare_mental/part_1/download_tool && ./mkimage.sh  $(TARGET).bin
```

```
 SECTIONS{
        . = 0x80000000;

        .text ALIGN(4) :
        {
            build/start.o
            *(.text)
        }

        .rodata ALIGN(4) :
        {
            *(.rodata)
        }

        .data ALIGN(4) : 
        { 
            *(.data) 
        }

        __bss_start = .;
        .bss ALIGN(4) : 
        { 
            *(.bss) 
            *(COMMON) 
        }
        __bss_end = .;
 }
```

## 按键输入

### 轮训

使用GPIO5_1这个引脚, 实际初始化的过程基本是一样的, 但是设置GPIO为输入, 从DR寄存器读取按键的状态

### 中断

使用头文件CORTEXA/include/core_ca7.h

修改文件内容：

- 注销：

```
#include "core_ca.h"   
```

- 添加：

```
#define __STRINGIFY(x) #x
/* C语言实现写cp15协处理器 */
#define __MCR(coproc, opcode_1, src, CRn, CRm, opcode_2)                          \
    __ASM volatile ("MCR " __STRINGIFY(p##coproc) ", " __STRINGIFY(opcode_1) ", " \
                    "%0, " __STRINGIFY(c##CRn) ", " __STRINGIFY(c##CRm) ", "      \
                    __STRINGIFY(opcode_2)                                         \
                    : : "r" (src) )

/* C语言实现读cp15协处理器 */                    
#define __MRC(coproc, opcode_1, CRn, CRm, opcode_2)                               \
  ({                                                                              \
    uint32_t __dst;                                                               \
    __ASM volatile ("MRC " __STRINGIFY(p##coproc) ", " __STRINGIFY(opcode_1) ", " \
                    "%0, " __STRINGIFY(c##CRn) ", " __STRINGIFY(c##CRm) ", "      \
                    __STRINGIFY(opcode_2)                                         \
                    : "=r" (__dst) );                                             \
    __dst;                                                                        \
  })

#define __ISB() 
#define __DSB() 
```

