## Linux中断基础概念

#### 回顾

裸机开发

- 通用中断控制器(GIC)
    - 中断类型、硬件中断号、分发器和cpu接口单元

- 中断向量表
    - 一级查表、二级查表

- 中断处理流程
    - 进入irq模式、保护现场、获取硬件中断编号、执行中断处理函数、还原现场

#### GIC中断控制器节点

arch/arm/boot/dts/imx6ull.dtsi

初始化中断控制器、设置其他中断控制器节点的描述格式, 实际初始化的时间比较早, 所以不是在设备树初始化的时候进行匹配进行的

```json
intc: interrupt-controller@a01000 {
		compatible = "arm,cortex-a7-gic";
		#interrupt-cells = <3>; // 描述中断需要使用的格式
		interrupt-controller;
		reg = <0xa01000 0x1000>,
		      <0xa02000 0x100>; // 分发器以及CPU接口
	};
```

- #interrupt-cells：描述下一级中断信息所需要的单元个数
- interrupt-controller：表示该设备是一个中断控制器，外设可以连接在该中断控制器上
- reg：GIC的分发器和cpu接口单元寄存器地址

#### 外设中断控制器节点

arch/arm/boot/dts/imx6ull.dtsi

管理某一种具体中断

```c
gpio5: gpio@20ac000 {
				compatible = "fsl,imx6ul-gpio", "fsl,imx35-gpio";
				reg = <0x20ac000 0x4000>;
				interrupts = <GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH>,
					     <GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH>; // 一共32个引脚
				clocks = <&clks IMX6UL_CLK_GPIO5>;
				gpio-controller;
				#gpio-cells = <2>;
				interrupt-controller; // 标记是一个中断
				#interrupt-cells = <2>; // 其他外设使用的时候, 描述的格式
				gpio-ranges = <&iomuxc 0 7 10>, <&iomuxc 10 5 2>;
			};
```

- interrupts：

    - GIC_SPI：中断类型，0 表示 SPI 中断，1 表示 PPI 中断

    > - **SPI（Shared Peripheral Interrupt）**：共享外设中断
    >     - 中断号范围：通常为 32-1019（具体取决于GIC版本）
    >     - 特点：可以被路由到任何一个或多个CPU核心处理
    >     - 示例：GPIO、USB、Ethernet等外设中断
    > - **PPI（Private Peripheral Interrupt）**：私有外设中断
    >     - 中断号范围：通常为 16-31
    >     - 特点：每个CPU核心独有的中断（如定时器中断）
    > - **SGI（Software Generated Interrupt）**：软件生成中断
    >     - 中断号范围：通常为 0-15
    >     - 用途：用于CPU核心间的通信
    
    - 74：中断号，对于 SPI 中断来说中断号的范围为 0~987，对于 PPI 中断来说中断号的范围为 0~15
    
    ![image-20250927162546686](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509271625733.png)
    
    - IRQ_TYPE_LEVEL_HIGH：中断类型，高电平触发

#### 其他设备使用中断节点

使用某一种具体中断

```c
button_interrupt {
    compatible = "button_interrupt";
    pinctrl-names = "default";
    pinctrl-0 = <&pinctrl_button>;
    button_gpio = <&gpio5 1 GPIO_ACTIVE_LOW>;
    status = "okay";
    interrupt-parent = <&gpio5>; // 使用gpio5的中断控制器
    interrupts = <1 IRQ_TYPE_EDGE_RISING>; // 实际使用的是GPIO5 1的上升沿
};
```

- interrupt-parent：表明归属的上一级中断

- interrupts：

    - 1：具体中断源，GPIO5-1
- IRQ_TYPE_EDGE_RISING：中断类型，上升沿触发

##### 中断类型

 include/linux/irq.h

```c
enum {
	IRQ_TYPE_NONE		= 0x00000000,
	IRQ_TYPE_EDGE_RISING	= 0x00000001,
	IRQ_TYPE_EDGE_FALLING	= 0x00000002,
	IRQ_TYPE_EDGE_BOTH	= (IRQ_TYPE_EDGE_FALLING | IRQ_TYPE_EDGE_RISING),
	IRQ_TYPE_LEVEL_HIGH	= 0x00000004,
	IRQ_TYPE_LEVEL_LOW	= 0x00000008,
	...
	}
```



#### 常用函数

##### request_irq()函数

申请中断

include/linux/interrupt.h

```c
static inline int __must_check
request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags,
	    const char *name, void *dev)
```

参数：

- irq：要申请的中断号
- handler：中断处理函数
- flags：中断标志, 中断放入特征
- name：中断名字
- dev：传递给中断处理函数的第二个参数
    - device结构体变量，区分不同设备共用同一中断

返回值：

- 成功：0

- 失败：负数

###### irq_handler_t

```c
typedef irqreturn_t (*irq_handler_t)(int, void *);
```

###### irqreturn_t

```c
enum irqreturn {
    IRQ_NONE                = (0 << 0),
    IRQ_HANDLED             = (1 << 0),
    IRQ_WAKE_THREAD         = (1 << 1),
};

typedef enum irqreturn irqreturn_t;
```

- IRQ_NONE：不是本驱动程序的中断，不处理
- IRQ_HANDLED：正常处理
- IRQ_WAKE_THREAD：这个处理函数里面暂时不处理, 使用中断下半部处理

###### flags

include/linux/interrupt.h

```c
#define IRQF_SHARED		0x00000080
#define IRQF_ONESHOT		0x00002000
#define IRQF_TRIGGER_NONE	0x00000000
#define IRQF_TRIGGER_RISING	0x00000001
#define IRQF_TRIGGER_FALLING	0x00000002
#define IRQF_TRIGGER_HIGH	0x00000004
#define IRQF_TRIGGER_LOW	0x00000008
```

IRQF_SHARED: 共享中断, 多外设使用

IRQF_ONESHOT: 只处理一次

##### free_irq()函数

释放中断

include/linux/interrupt.h

```c
const void *free_irq(unsigned int irq, void *dev_id)
```

参数：

- irq：要释放的中断号

- dev：传递给中断处理函数的第二个参数

返回值：

​	无

##### enable_irq()函数

使能中断

kernel/irq/manage.c

```c
void enable_irq(unsigned int irq)
```

参数：

- irq：要使能的中断号

返回值：

​	无

##### disable_irq()函数

禁止中断，等待中断执行完毕

kernel/irq/manage.c

```c
void disable_irq(unsigned int irq)
```

参数：

- irq：要禁止的中断号

返回值：

​	无

##### disable_irq_nosync()函数

禁止中断，不等待中断执行完

kernel/irq/manage.c

```
void disable_irq_nosync(unsigned int irq)
```

参数：

- irq：要禁止的中断号

返回值：

​	无

##### local_irq_disable()宏

include/linux/irqflags.h

禁止处理器中断

```c
#define local_irq_disable()	do { raw_local_irq_disable(); } while (0)
```

##### local_irq_enable()宏

include/linux/irqflags.h

开处理器中断

```c
#define local_irq_enable()	do { raw_local_irq_enable(); } while (0)
```

## Linux按键中断实验

#### 硬件原理图

![image-20200917203137234](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509271633109.png)

#### 设备树节点

##### iomuxc子节点

描述一下引脚的硬件配置

```
pinctrl_button: button{
				fsl,pins = <
					MX6UL_PAD_SNVS_TAMPER1__GPIO5_IO01      0x000110A1
				>;
			};
```

##### 自定义按键节点

```json
button_interrupt {
    pinctrl-names = "default";
    pinctrl-0 = <&pinctrl_button>;
    button_gpio = <&gpio5 1 GPIO_ACTIVE_LOW>;
    interrupt-parent = <&gpio5>;
    interrupts = <1 IRQ_TYPE_EDGE_RISING>;
};
```

#### irq_of_parse_and_map()函数

drivers/of/irq.c

```c
unsigned int irq_of_parse_and_map(struct device_node *dev, int index)
```

参数：

- dev：设备节点
- index：索引号，interrupts属性可能包含多条中断信息

返回值：中断号

## 实际应用

```c

#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/delay.h>
#include <linux/ide.h>
#include <linux/errno.h>
#include <linux/gpio.h>
#include <asm/mach/map.h>
#include <linux/of.h>
#include <linux/of_address.h>
#include <linux/of_gpio.h>
#include <asm/io.h>
#include <linux/device.h>
#include <linux/irq.h>
#include <linux/of_irq.h>


/*------------------字符设备内容----------------------*/
#define DEV_NAME "button"
#define DEV_CNT (1)

static dev_t button_devno;		 //定义字符设备的设备号
static struct cdev button_chr_dev; //定义字符设备结构体chr_dev
struct class *class_button;		 //保存创建的类
struct device *device_button;		 // 保存创建的设备


struct device_node	*button_device_node = NULL;  //定义按键设备节点结构体
unsigned  button_GPIO_number = 0;  //保存button使用的GPIO引脚编号
u32  interrupt_number = 0;         // button 引脚中断编号
atomic_t   button_status = ATOMIC_INIT(0);  //定义整型原子变量，保存按键状态 ，设置初始值为0



static irqreturn_t button_irq_hander(int irq, void *dev_id)
{
	// printk_green("button on \n");
	/*按键状态加一*/
	atomic_inc(&button_status);
	return IRQ_HANDLED;
}

static int button_open(struct inode *inode, struct file *filp)
{
	int error = -1;
	
	
	/*添加初始化代码*/
	// printk_green("button_open");

	/*获取按键 设备树节点*/
	button_device_node = of_find_node_by_path("/button_interrupt");
	if(NULL == button_device_node)
	{
		printk("of_find_node_by_path error!");
		return -1;
	}

	/*获取按键使用的GPIO*/
	button_GPIO_number = of_get_named_gpio(button_device_node ,"button_gpio", 0);
	if(0 == button_GPIO_number)
	{
		printk("of_get_named_gpio error");
		return -1;
	}

	/*申请GPIO  , 记得释放*/
	error = gpio_request(button_GPIO_number, "button_gpio");
	if(error < 0)
	{
		printk("gpio_request error");
		gpio_free(button_GPIO_number);
		return -1;
	}

	error = gpio_direction_input(button_GPIO_number);//设置引脚为输入模式

	/*获取中断号*/
	interrupt_number = irq_of_parse_and_map(button_device_node, 0);
	printk("\n irq_of_parse_and_map! =  %d \n",interrupt_number);


	/*申请中断, 记得释放*/
	error = request_irq(interrupt_number,button_irq_hander,IRQF_TRIGGER_RISING,"button_interrupt",device_button);
	if(error != 0)
	{
		printk("request_irq error");
		free_irq(interrupt_number, device_button);
		return -1;
	}

	/*申请之后已经开启了，切记不要再次打开，否则运行时报错*/
	// // enable_irq(interrupt_number);

	return 0;

}

static int button_read(struct file *filp, char __user *buf, size_t cnt, loff_t *offt)
{
	int error = -1;
	int button_countervc = 0;

	/*读取按键状态值*/
	button_countervc = atomic_read(&button_status);

	/*结果拷贝到用户空间*/
	error = copy_to_user(buf, &button_countervc, sizeof(button_countervc));
	if(error < 0)
	{
		printk("copy_to_user error");
		return -1;
	}

	/*清零按键状态值*/
	atomic_set(&button_status,0);
	return 0;
}

/*字符设备操作函数集，.release函数实现*/
static int button_release(struct inode *inode, struct file *filp)
{
	/*释放申请的引脚,和中断*/
	gpio_free(button_GPIO_number);
	free_irq(interrupt_number, device_button);
	return 0;
}



/*字符设备操作函数集*/
static struct file_operations button_chr_dev_fops = {
	.owner = THIS_MODULE,
	.open = button_open,
	.read = button_read,
	.release = button_release};

/*
*驱动初始化函数
*/
static int __init button_driver_init(void)
{
	int error = -1;

	/*采用动态分配的方式，获取设备编号，次设备号为0，*/
	error = alloc_chrdev_region(&button_devno, 0, DEV_CNT, DEV_NAME);
	if (error < 0)
	{
		printk("fail to alloc button_devno\n");
		goto alloc_err;
	}

	/*关联字符设备结构体cdev与文件操作结构体file_operations*/
	button_chr_dev.owner = THIS_MODULE;
	cdev_init(&button_chr_dev, &button_chr_dev_fops);

	/*添加设备至cdev_map散列表中*/ 
	error = cdev_add(&button_chr_dev, button_devno, DEV_CNT);
	if (error < 0) 
	{
		printk("fail to add cdev\n");
		goto add_err;
	}

	class_button = class_create(THIS_MODULE, DEV_NAME);                         //创建类
	device_button = device_create(class_button, NULL, button_devno, NULL, DEV_NAME);//创建设备 DEV_NAME 指定设备名，

	return 0;

add_err:
	unregister_chrdev_region(button_devno, DEV_CNT);    // 添加设备失败时，需要注销设备号
	printk("\n error! \n");
	
alloc_err:
	return -1;
}



/*
*驱动注销函数
*/
static void __exit button_driver_exit(void)
{
	pr_info("button_driver_exit\n");
	/*删除设备*/
	device_destroy(class_button, button_devno);		   //清除设备
	class_destroy(class_button);					   //清除类
	cdev_del(&button_chr_dev);					       //清除设备号
	unregister_chrdev_region(button_devno, DEV_CNT);   //取消注册字符设备
}



module_init(button_driver_init);
module_exit(button_driver_exit);

MODULE_LICENSE("GPL");
```

