# Linux

![image-20250930100823295](C:\Users\14586\AppData\Roaming\Typora\typora-user-images\image-20250930100823295.png)

NXP官方镜像(后简称官方镜像)与鲁班猫镜像(后简称lubancat)，我们将kernel，dtb,dtbo打包进 了rootfs 内，这样更为通用且更换其中如何一部分只需将文件替换即可。官方镜像则得烧写指定 地址需要更新其中一部分则较为困难

![image-20250930101051141](C:\Users\14586\AppData\Roaming\Typora\typora-user-images\image-20250930101051141.png)

```bash
git clone https://github.com/Embedfire/ebf_linux_kernel.git
```

## 目录

+ **arch** ：主要包含和硬件体系结构相关的代码，如arm、x86、MIPS，PPC，每种CPU平台占一个 相应的目录，例如我们使用的imx系列CPU就在arch/arm/mach-imx目录下，Linux内核目 前已经支持30种左右的CPU体系结构。arch中的目录下存放的是各个平台以及各个平台的芯片 对Linux 内核进程调度、内存管理、中断等的支持，以及每个具体的SoC和电路板的板级支持代 码
+ **block** ：在Linux 中block 表示块设备（以块（多个字节组成的整体，类似于扇区）为单位来整体 访问），譬如说SD卡、Nand、硬盘等都是块设备，block目录下放的是一些Linux存储体系中关 于块设备管理的代码。
+ **crypto** ：这个目录下存放的是常用加密和散列算法（如md5、AES、SHA等），还有一些压缩和 CRC校验算法
+ **Documentation**：内核各部分的文档描述。
+ **drivers** ：设备驱动程序，里面列出了linux内核支持的所有硬件设备的驱动源代码，每个不同的 驱动占用一个子目录，如char、block、net、mtd、i2c等。
+ **fs** ：fs 就是filesystem，里面包含Linux所支持的各种文件系统，如EXT、FAT、NTFS、JFFS2等。
+ **include** ：目录包括编译核心所需要的大部分头文件，例如与平台无关的头文件在include/ linux 子目录下，与cpu架构相关的头文件在include目录下对应的子目录中。
+ **init** ：内核初始化代码，这个目录下的代码就是linux内核启动时初始化内核的代码。
+ **ipc** ：ipc 就是 inter process commuication ，进程间通信，该目录下都是linux进程间通 信的代码。
+ **kernel** ：kernel 就是 Linux 内核，是Linux中最核心的部分，包括进程调度、定时器等，而和平台 相关的一部分代码放在arch/*/kernel目录下。
+ **lib** ：lib 是库的意思，lib目录下存放的都是一些公用的有用的库函数，注意这里的库函数和C语 言的库函数不一样的，因为在内核编程中是不能用C语言标准库函数的，所以需要使用lib中的 库函数，除此之外与处理器结构相关的库函数代码被放在arch/*/lib/目录下。
+ **mm**：目录包含了所有独立于cpu体系结构的内存管理代码，如页式存储管理内存的分配和释放等，而与具体硬件体系结构相关的内存管理代码位于arch/*/mm目录下，例如arch/arm/mm/fault.c 。
+ **net** ：网络协议栈相关代码，net目录下实现各种常见的网络协议。
+ **scripts** ：这个目录下全部是脚本文件，这些脚本文件不是linux内核工作时使用的，而是用了配置编译linux内核的。
+ **security** ：内核安全模型相关的代码，例如最有名的SELINUX
+ **sound** ：ALSA、OSS音频设备的驱动核心代码和常用设备驱动。
+ **usr** ：实现用于打包和压缩的cpio等。

## 配置

### Makefile

分布在Linux内核源代码根目录及各层目录中，定义Linux内核的编译规则

### 配置文件

给用户提供配置选择的功能，如Kconfig文件定义了配置项，使用make_deb.sh 脚本编译时，使用arch/arm/configs/npi_v7_defconfig文件对配置项进行赋值

### 配置工具

包括配置命令解释器（对配置脚本中使用的配置命令进行解释）和配置用户界 面（linux 提供基于字符界面、基于Ncurses图形界面以及基于Xwindows图形界面的用户配 置界面，各自对应于makeconfig、makemenuconfig和makexconfig）

### 应用

````bash
make menuconfig KCONFIG_CONFIG=arch/arm/configs/npi_v7_defconfig ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf-
````

需要提前安装一下`sudo apt install libncurses-dev`

可以使用/进行查找, 比如使用ds18b20温湿度传感器

`-> Device Drivers 选项下的-> Embedfire Modules下的-> Embedfire Modules (EBF_MODULE [=y])`

可使用y、n、m键更改ds18b20驱动的配置时，其中y表示编译进内核中，m表示编译成模块， n 表示不编译。

> #### 1. `y` - 编译进内核
>
> - **工作方式**：当你选择 `y` 时，DS18B20 驱动的所有源代码都会被编译，并直接链接到最终生成的内核镜像文件里。这个驱动会成为内核不可分割的一部分。
> - **加载时机**：在系统启动过程中，内核初始化时，会自动将该驱动初始化并注册到系统中。
> - **使用场景**：
>     - **基础/必需硬件**：例如，你正在为一个特定的嵌入式设备（比如一个智能温控器）构建内核，而 DS18B20 是这个设备的**核心、必需**的传感器。你必须保证它每次开机都能用。
>     - **根文件系统驱动**：如果该驱动是挂载根文件系统所必需的（虽然DS18B20通常不是），那么它必须编译进内核，否则内核无法启动。
>     - **简化部署**：你希望系统“开箱即用”，不想处理模块加载的脚本或依赖。
>
> #### 2. `m` - 编译成模块
>
> - **工作方式**：选择 `m` 时，DS18B20 驱动的源代码会被编译，但不会链接到主内核镜像中。它会生成一个或多个独立的 `.ko` 文件，这些文件通常存放在 `/lib/modules/$(uname -r)/` 目录下。
> - **加载时机**：内核启动时，这个驱动**不会自动加载**。你需要：
>     - **手动加载**：在需要时，通过命令行 `sudo insmod /path/to/w1_therm.ko` 或 `sudo modprobe w1_therm`（推荐）来加载。
>     - **自动加载**：可以配置系统的 `modules` 文件，让系统在启动时或硬件插入时自动加载该模块。
> - **使用场景**：
>     - **非必需或可选功能**：DS18B20 在你的项目中是可选配件，或者只在特定情况下使用。不需要时可以不加载，节省内存。
>     - **驱动开发与调试**：在开发驱动时，编译成模块可以让你快速修改、编译、加载、测试，而无需每次都重启系统，极大提高效率。
>     - **通用发行版**：像 Ubuntu、Debian 这样的桌面或服务器发行版，它们的内核需要应对成千上万种不同的硬件。如果把所有驱动都编译进内核，内核会变得无比臃肿。因此，绝大多数驱动都以模块形式提供，系统会在检测到硬件时自动加载对应的模块。
>
> #### 3. `n` - 不编译
>
> - **工作方式**：选择 `n` 时，配置系统会完全跳过对 DS18B20 驱动源代码的编译。
> - **加载时机**：无法加载，因为驱动根本不存在。
> - **使用场景**：
>     - **目标系统绝对不需要此功能**：你非常确定你的设备永远不会使用 DS18B20 温度传感器。
>     - **追求极致的精简**：你在为一个资源极其受限的嵌入式系统构建内核，需要剔除所有不必要的代码，哪怕一字节也要节省。
>     - **排除问题**：在排查内核冲突或问题时，可以暂时不编译某个驱动，以判断它是否是问题的根源。

## 编译

编译Kernel有两种方法，一种是编译较为通用的zImage，常用于构建成镜像固件。另一种则是 编译成deb安装包，将其下载到板子上安装即可更新Kernel。

### zImage

```bash
# 清除之前编译环境
make mrproper
 # 编译内核
make ARCH=arm npi_v7_defconfig
make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf--j8
```

编译得到的zImage 内核在arch/arm/boot 目录下，设备树在 arch/arm/boot/dts 目录下设备树分为 emmc 版本imx6ull-mmc-npi.dtb 以及 nand 版本 imx6ull-nand-npi.dtb

+ zImage 生成简述

通过arm-linux-gnueabihf-ld 命令将 vmlinux.lds head.o piggy.o misc.o decompress.o string.o hyp-stub.o lib1funcs.o ashldi3.o bswapsdi2.o 链接成 vmlinux

再通过arm-linux-gnueabihf-objcopy 命令将vmlinux以bin格式输出到zImage，期间删去了comment 等信息

### deb包

想要编译内核的deb安装包，以sudo权限运行野火提供的make_deb.sh脚本即可，我们也推荐使 用这样的编译方式编译内核，构建出来的deb安装包可直接使用sudodpkg-ixxx.deb命令安装在 鲁班猫系统上，然后重启使用cat/proc/version查看内核是否更新

```c
deb_distro=bionic
DISTRO=stable
build_opts="-j 16"
build_opts="${build_opts} O=build_image/build"
build_opts="${build_opts} ARCH=arm"
build_opts="${build_opts} KBUILD_DEBARCH=${DEBARCH}"
build_opts="${build_opts} LOCALVERSION=-imx6"
build_opts="${build_opts} KDEB_CHANGELOG_DIST=${deb_distro}"
build_opts="${build_opts} KDEB_PKGVERSION=1.$(date +%g%m)${DISTRO}"
build_opts="${build_opts} CROSS_COMPILE=arm-linux-gnueabihf-"
build_opts="${build_opts} KDEB_SOURCENAME=linux-upstream"
make ${build_opts} npi_v7_defconfig
make ${build_opts}
make ${build_opts} bindeb-pkg
```

+ `deb_distro=bionic`: 设置了变量 deb_distro，用于指定生成的Debian包的目标发行版，这里设 置为bionic。
+ `DISTRO=stable`: 设置了变量DISTRO，用于指定Linux内核的目标发行版，这里设置为stable。标记构建的软件包为稳定版
+ `build_opts=”-j 16”`: 设置了编译选项，-j16表示并行编译时使用16个线程。
+ `build_opts=”${build_opts} O=build_image/build”`: 添加了编译选项，指定编译输出目录为 build_image/build。
+ `build_opts=”${build_opts} ARCH=arm”`: 添加了编译选项，指定目标架构为ARM。
+ `build_opts=”${build_opts} KBUILD_DEBARCH=${DEBARCH}”`: 添加了编译选项，指定deb包的架构为${DEBARCH}。
+ `build_opts=”${build_opts} LOCALVERSION=-imx6”`: 添加了编译选项，设置了内核的本地 版本标识为-imx6。
+ `build_opts=”${build_opts} KDEB_CHANGELOG_DIST=${deb_distro}”`: 添加了编译选项，指 定生成的deb包changelog的目标发行版为${deb_distro}。
+ `build_opts=”${build_opts} KDEB_PKGVERSION=1.$(date +%g%m)${DISTRO}”`: 添加了编 译选项，指定生成的deb包的版本号为当前年份后两位加上当前月份，后跟${DISTRO}（在 这种情况下是stable）。
+ `build_opts=”${build_opts} CROSS_COMPILE=arm-linux-gnueabihf-“`: 添加了编译选项，指定 交叉编译工具链为arm-linux-gnueabihf-。
+ `build_opts=”${build_opts} KDEB_SOURCENAME=linux-upstream”`: 添加了编译选项，指定 生成的deb包的源名称为linux-upstream。
+ `make ${build_opts} npi_v7_defconfig`: 使用 make 命令加载了名为 npi_v7_defconfig 的预配置 文件。
+ `make ${build_opts}`: 使用 make 命令编译 Linux 内核。
+ `make ${build_opts} bindeb-pkg`: 使用 make 命令生成内核 deb 包。

1. **交叉编译**：在x86主机上编译ARM目标平台的内核
2. **版本管理**：自动生成带时间戳的版本号
3. **包管理**：生成标准的Debian软件包，便于分发和安装
4. **定制化**：针对i.MX6平台进行专门配置
5. **高效编译**：使用多线程和独立输出目录

`build_opts=”${build_opts} KDEB_PKGVERSION=1.$(date +%g%m)${DISTRO}”`：设置了内 核deb 包的版本号，默认是数字+当前年份后两位加上当前月份后跟stable，如果是大版 本更新可修改前面的数字，如果是当月频繁更新，可以将`$(date+%g%m) 修改为 $(date +%g%m%d)`，添加具体日期，如果是测试版，可修改stable为beta等。

构成生成的deb包在内核源码/build_image目录下

> 将kernel，dtb,dtbo打包进 了rootfs内，这样更为通用且更换其中如何一部分只需将文件替换即可。官方镜像则是烧写指定 地址对于不同芯片存储的地址是不同的不利于移植于其他芯片

## 烧录

### USB烧录

烧写完毕后通过USBOTG连接电脑会存在一个BOOT分区

编译的zImage拷贝到BOOT\kernel目录下，将zImage更名为vmlinuz-4.19.35 imx6

```
ln -s /lib/modules/4.19.35-imx6 /lib/modules/4.19.35+
reboot
```

### DEB包

将编译出来的build_image/linux-image-4.19.35-imx6_1.xxxstable_armhf.deb内核安装包拷贝到 开发板上面，使用dpkg命令即可替换板子上的内核

```bash
#查看当前的内核
dpkg -l | grep imx

#卸载当前内核
sudo dpkg -r linux-image-4.19.35-imx6

#若使用dpkg安装内核deb包提示错误，删除/boot/kernel目录下所有文件
sudo rm /boot/kernel/*

#安装新内核
sudo dpkg -i linux-image-4.19.35-imx6_1stable_armhf.deb
```

`cat /proc/version` 命令查看内核版本

### 直接替换

将编译出来的ebf_linux_kernel/arch/arm/boot/zImage 的拷到板子上，重命名为 vmlinuz-4.19.35 imx6 并替换/boot/kernel/vmlinuz-4.19.35-imx6