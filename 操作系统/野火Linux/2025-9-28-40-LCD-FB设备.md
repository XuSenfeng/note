## LCD驱动框架分析

实际就是配置eLCDIF的配置参数

#### 裸机开发--lcd显示原理

- 相关寄存器
    - 分辨率
    - 显示时序(6个时间参数)
    - 显存地址

#### framebuffer机制

帧缓冲

- 显示图像信息
- /dev/fbx(x=0~n)

fb是一种机制，将系统中所有跟显示有关的硬件以及软件集合起来，虚拟出一个 fb 设备, 是个字符设备, 操作集定义在 drivers/video/fbdev/core/fbmem.c 文件, 可以使用mmap函数进行控制

#### 分层模型

- ##### 核心层

    drivers/video/fbdev/core/fbmem.c

    linux内核实现

    - 创建graphics设备类，占据主设备号29
    - 为不同的显示设备提供文件通用处理接口

- ##### 硬件设备层

    驱动人员实现

    - 提供显示时序、显存、像素格式等硬件信息
    - 提供显示设备的私有文件操作接口
    - 创建lcd设备文件/dev/fbx(x=0~n)

#### 核心层分析

drivers/video/fbdev/core/fbmem.c

##### 创建graphics设备类，占据主设备号29

开机以后自动执行

```c
static int __init
fbmem_init(void)
{
	int ret;

	if (!proc_create_seq("fb", 0, NULL, &proc_fb_seq_ops))
		return -ENOMEM;

	ret = register_chrdev(FB_MAJOR, "fb", &fb_fops); // 占据设备号
	if (ret) {
		printk("unable to get major %d for fb devs\n", FB_MAJOR);
		goto err_chrdev;
	}

	fb_class = class_create(THIS_MODULE, "graphics");
	if (IS_ERR(fb_class)) {
		ret = PTR_ERR(fb_class);
		pr_warn("Unable to create fb class; errno = %d\n", ret);
		fb_class = NULL;
		goto err_class;
	}

	fb_console_init();

	return 0;

err_class:
	unregister_chrdev(FB_MAJOR, "fb");
err_chrdev:
	remove_proc_entry("fb", NULL);
	return ret;
}
```

##### FB_MAJOR宏

/usr/include/linux/major.h

```c
#define FB_MAJOR		29
```

##### fb_fops文件操作接口

drivers/video/fbdev/core/fbmem.c

```c
static const struct file_operations fb_fops = {
	.owner =	THIS_MODULE,
	.read =		fb_read,
	.write =	fb_write,
	.unlocked_ioctl = fb_ioctl,
#ifdef CONFIG_COMPAT
	.compat_ioctl = fb_compat_ioctl,
#endif
	.mmap =		fb_mmap,
	.open =		fb_open,
	.release =	fb_release,
#if defined(HAVE_ARCH_FB_UNMAPPED_AREA) || \
	(defined(CONFIG_FB_PROVIDE_GET_FB_UNMAPPED_AREA) && \
	 !defined(CONFIG_MMU))
	.get_unmapped_area = get_fb_unmapped_area,
#endif
#ifdef CONFIG_FB_DEFERRED_IO
	.fsync =	fb_deferred_io_fsync,
#endif
	.llseek =	default_llseek,
};

```

> 所有LCD的通用接口

#### 硬件设备层分析

##### fb_info 结构体

include/linux/fb.h

LCD硬件的相关信息, 这个结构体需要在驱动文件里面初始化, 是Linux所有的framebuffer都会被抽象的一个结构, 屏幕的驱动最重要的就是初始化这个结构

```c
struct fb_info {
	atomic_t count;
	int node;
	int flags;
	
	int fbcon_rotate_hint;
	struct mutex lock;		/* Lock for open/release/ioctl funcs */
	struct mutex mm_lock;		/* Lock for fb_mmap and smem_* fields */
	struct fb_var_screeninfo var;	/* Current var 当前可变参数 */
	struct fb_fix_screeninfo fix;	/* Current fix 当前固定参数 */
	struct fb_monspecs monspecs;	/* Current Monitor specs 显示器特性 */
	struct work_struct queue;	/* Framebuffer event queue 事件缓冲区 */
	struct fb_pixmap pixmap;	/* Image hardware mapper 硬件映射 */
	struct fb_pixmap sprite;	/* Cursor hardware mapper 光标映射 */
	struct fb_cmap cmap;		/* Current cmap 调色板 */
	struct list_head modelist;      /* mode list 模式列表 */
	struct fb_videomode *mode;	/* current mode 视频模式 */

#ifdef CONFIG_FB_BACKLIGHT
	/* assigned backlight device */
	/* set before framebuffer registration, 
	   remove after unregister */
	struct backlight_device *bl_dev;

	/* Backlight level curve */
	struct mutex bl_curve_mutex;	
	u8 bl_curve[FB_BACKLIGHT_LEVELS];
#endif
#ifdef CONFIG_FB_DEFERRED_IO
	struct delayed_work deferred_work;
	struct fb_deferred_io *fbdefio;
#endif

	struct fb_ops *fbops; // 对应的操作函数
	struct device *device;		/* This is the parent */
	struct device *dev;		/* This is this fb device */
	int class_flag;                    /* private sysfs flags */
#ifdef CONFIG_FB_TILEBLITTING
	struct fb_tile_ops *tileops;    /* Tile Blitting */
#endif
	union {
		char __iomem *screen_base;	/* Virtual address */
		char *screen_buffer;
	};
	unsigned long screen_size;	/* Amount of ioremapped VRAM or 0 */ 
	void *pseudo_palette;		/* Fake palette of 16 colors */ 
...
};
```

-  var、fix、screen_base、screen_size：提供显示时序、显存、像素格式等硬件信息

-  fbops：显示设备的私有文件操作接口, 会被通用的接口调用

#### register_framebuffer()函数

drivers/video/fbdev/core/fbmem.c

注册一个fb_info到内核里面

```c
register_framebuffer(struct fb_info *fb_info)
{
	int ret;

	mutex_lock(&registration_lock);
	ret = do_register_framebuffer(fb_info);
	mutex_unlock(&registration_lock);

	return ret;
}
```

##### do_register_framebuffer()函数

drivers/video/fbdev/core/fbmem.c

```c
static int do_register_framebuffer(struct fb_info *fb_info)
{
	...
	for (i = 0 ; i < FB_MAX; i++)
		if (!registered_fb[i])
			break;
    // 获取一个空闲选项(次设备号)
	fb_info->node = i;
	...
    // 创建一个设备
	fb_info->dev = device_create(fb_class, fb_info->device,
				     MKDEV(FB_MAJOR, i), NULL, "fb%d", i);
    ...
}
```

##### registered_fb数组

drivers/video/fbdev/core/fbmem.c

```c
struct fb_info *registered_fb[FB_MAX]
```

##### FB_MAX宏

include/uapi/linux/fb.h

```c
#define FB_MAX			32	/* sufficient for now */
```

##### fb_open()函数

drivers/video/fbdev/core/fbmem.c

```c
static int fb_open(struct inode *inode, struct file *file)
{
	int fbidx = iminor(inode); // 获取次设备号
	struct fb_info *info;
	int res = 0;

	info = get_fb_info(fbidx);
	...
	file->private_data = info;
	if (info->fbops->fb_open) {
		res = info->fbops->fb_open(info,1); // 使用自定义的open函数
		if (res)
			module_put(info->fbops->owner);
	}
#ifdef CONFIG_FB_DEFERRED_IO
	if (info->fbdefio)
		fb_deferred_io_open(info, inode, file);
#endif
out:
	mutex_unlock(&info->lock);
	if (res)
		put_fb_info(info);
	return res;
}
```

## LCD驱动实验

### 硬件原理图

![1595577582841](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509282222986.png)

### 设备树节点

arch/arm/boot/dts/imx6ull-seeed-npi.dts

#### iomuxc子节点

```json
pinctrl_lcdif_dat: lcdifdatgrp {
			    fsl,pins = <
			        MX6UL_PAD_LCD_DATA00__LCDIF_DATA00  0x79
			        MX6UL_PAD_LCD_DATA01__LCDIF_DATA01  0x79
			        MX6UL_PAD_LCD_DATA02__LCDIF_DATA02  0x79
			        MX6UL_PAD_LCD_DATA03__LCDIF_DATA03  0x79
			        MX6UL_PAD_LCD_DATA04__LCDIF_DATA04  0x79
			        MX6UL_PAD_LCD_DATA05__LCDIF_DATA05  0x79
			        MX6UL_PAD_LCD_DATA06__LCDIF_DATA06  0x79
			        MX6UL_PAD_LCD_DATA07__LCDIF_DATA07  0x79
			        MX6UL_PAD_LCD_DATA08__LCDIF_DATA08  0x79
			        MX6UL_PAD_LCD_DATA09__LCDIF_DATA09  0x79
			        MX6UL_PAD_LCD_DATA10__LCDIF_DATA10  0x79
			        MX6UL_PAD_LCD_DATA11__LCDIF_DATA11  0x79
			        MX6UL_PAD_LCD_DATA12__LCDIF_DATA12  0x79
			        MX6UL_PAD_LCD_DATA13__LCDIF_DATA13  0x79
			        MX6UL_PAD_LCD_DATA14__LCDIF_DATA14  0x79
			        MX6UL_PAD_LCD_DATA15__LCDIF_DATA15  0x79
			        MX6UL_PAD_LCD_DATA16__LCDIF_DATA16  0x79
			        MX6UL_PAD_LCD_DATA17__LCDIF_DATA17  0x79
			        MX6UL_PAD_LCD_DATA18__LCDIF_DATA18  0x79
			        MX6UL_PAD_LCD_DATA19__LCDIF_DATA19  0x79
			        MX6UL_PAD_LCD_DATA20__LCDIF_DATA20  0x79
			        MX6UL_PAD_LCD_DATA21__LCDIF_DATA21  0x79
			        MX6UL_PAD_LCD_DATA22__LCDIF_DATA22  0x79
			        MX6UL_PAD_LCD_DATA23__LCDIF_DATA23  0x79
			    >;
			};
			
pinctrl_lcdif_ctrl: lcdifctrlgrp {
    			fsl,pins = <
    			    MX6UL_PAD_LCD_CLK__LCDIF_CLK	    0x79
    			    MX6UL_PAD_LCD_ENABLE__LCDIF_ENABLE  0x79
    			    MX6UL_PAD_LCD_HSYNC__LCDIF_HSYNC    0x79
    			    MX6UL_PAD_LCD_VSYNC__LCDIF_VSYNC    0x79
    			>;
			};
			
pinctrl_pwm1: pwm1grp {
				fsl,pins = <
					MX6UL_PAD_GPIO1_IO08__PWM1_OUT 0x110b0
				>;
			};
```

####  backlight子节点

```json
backlight {
    compatible = "pwm-backlight";
	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_pwm1>;
    pwms = <&pwm1 0 5000000>;
    brightness-levels = <0 4 8 16 32 64 128 255>;
    default-brightness-level = <6>;
    status = "okay";
};
```

#### lcdif节点

arch/arm/boot/dts/imx6ull.dtsi

对应的相关驱动文件, 这个驱动文件对应的位置在`drivers/video/fbdev/mxsfb.c`

```json
	lcdif: lcdif@21c8000 {
				compatible = "fsl,imx6ul-lcdif", "fsl,imx28-lcdif";
				reg = <0x21c8000 0x4000>;
				interrupts = <GIC_SPI 5 IRQ_TYPE_LEVEL_HIGH>;
				clocks = <&clks IMX6UL_CLK_LCDIF_PIX>,
					 <&clks IMX6UL_CLK_LCDIF_APB>,
					 <&clks IMX6UL_CLK_DUMMY>;
				clock-names = "pix", "axi", "disp_axi";
				status = "disabled";
			};
```

#### lcd设备节点

Documentation\devicetree\binding

```json
&lcdif {
	pinctrl-names = "default";
    pinctrl-0 = <&pinctrl_lcdif_dat &pinctrl_lcdif_ctrl>;
    display = <&display0>;
    status = "okay";
    display0: display {
        bits-per-pixel = <32>;
        bus-width = <24>;
            display-timings {
                native-mode = <&timing1>;
                    timing1: timing1 {
                    mode_name = "TFT50AB";
                    clock-frequency = <27000000>;
                    hactive = <800>;
                    vactive = <480>;
                    hfront-porch = <23>;
                    hback-porch = <46>;
                    hsync-len = <1>;
                    vback-porch = <22>;
                    vfront-porch = <22>;
                    vsync-len = <1>;

                    hsync-active = <0>;
                    vsync-active = <0>;
                    de-active = <1>;
                    pixelclk-active = <0>;
                  };
			};
		};
};
```

- display：lcd属性信息
- bits-per-pixel：一个像素占用24bit
- bus-width：总线宽度
- native-mode：时序信息
- clock-frequency：lcd像素时钟，单位Hz
- hactive：x轴像素个数
- vactive：y轴像素个数
- hfront-porch、hback-porch、hsync-len、vback-porch、vfront-porch、vsync-len：时序参数
- *-active：时钟极性

### 驱动文件

主要实现的功能是fb_info的注册

#### mxsfb_probe

驱动匹配以后执行`static int mxsfb_probe(struct platform_device *pdev)`函数

这个函数实现电源引脚初始化, 申请mxsfb_info结构体的内存, 进行ioremap, 申请中断, 之后会进一步调用`ret = mxsfb_init_fbinfo(host);`初始化fb_info

初始化之后, registere这个fb_info

其他还有对于寄存器的一系列初始化操作

#### mxsfb_init_fbinfo

初始化各种变量, 同时申请一块帧显存, 清空显存, 记录的操控结构体是`mfsfb_ops`, 这个函数还要使用设备树里面的相关参数`mxsfb_init_fbinfo_bt`

#### mxsfb_init_fbinfo_bt

从设备树里读取信息进行初始化, 获取lcdif节点, 获取实际屏幕的时序信息

### 控制函数

#### mmap()函数

\#include <sys/mman.h>

将文件内容映射到内存, 这里是把位图文件映射一下

```c
void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);
```

参数：

- addr：表示指定映射的內存起始地址，通常设为 NULL表示让系统自动选定地址
- length：表示将文件中多大的内容映射到内存中
- prot：表示映射区域的保护方式
    - PROT_EXEC ：映射区域可被执行
    - PROT_READ ：映射区域可被读取
    - PROT_WRITE ：映射区域可被写入
    - PROT_NONE ：映射区域不能被访问

- Flags：映射区域的不同特性

    - MAP_SHARED：共享映射，多个进程实时看到文件映射内容的变化，映射内容写入到磁盘文件
    - MAP_PRIVATE：匿名映射，其他进程无法看到映射内容变化，映射内容不会写入到磁盘文件

    - ...

#### 位图转换器 SEGGER

图片转化c文件

《emWin应用开发实战指南》--第11章 显示位图

-  ARGB格式

## 实际应用

```c
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <stdlib.h>
#include <sys/ioctl.h>

/*显示屏相关头文件*/
#include <linux/fb.h>
#include <sys/mman.h>

extern unsigned int test_picture[];

typedef struct lcd_color
{
   unsigned char bule;
   unsigned char green;
    unsigned char red;
    unsigned char alpha;
} lcd_color;


int main()
{
    int fp = 0;
    long screensize=0; 
    struct fb_var_screeninfo vinfo;
    struct fb_fix_screeninfo finfo;
    char *fbp = 0;
    int x = 0, y = 0;
    long location = 0;


    fp = open("/dev/fb0", O_RDWR);

    if (fp < 0)
    {
        printf("Error : Can not open framebuffer device/n");
        exit(1);
    }

    if (ioctl(fp, FBIOGET_FSCREENINFO, &finfo))
    {
        printf("Error reading fixed information/n");
        exit(2);
    }

    if (ioctl(fp, FBIOGET_VSCREENINFO, &vinfo))
    {
        printf("Error reading variable information/n");
        exit(3);
    }
    // printf("The mem is :%d\n", finfo.smem_len);

    screensize = vinfo.xres * vinfo.yres * vinfo.bits_per_pixel / 8;
     /*这就是把fp所指的文件中从开始到screensize大小的内容给映射出来，得到一个指向这块空间的指针*/
    fbp =(char *) mmap (0, screensize, PROT_READ | PROT_WRITE, MAP_SHARED, fp,0);
    if ((int) fbp == -1)
    {
       printf ("Error: failed to map framebuffer device to memory./n");
       exit (4);
    }

    /*刷红色*/
    int i = 0;
    lcd_color clear_color = {0,0,255,0};
    for(i=0; i < screensize; i+=4)
    {
        *((lcd_color*)(fbp + i)) = clear_color;
    }
    usleep(1000*2000);

    /*刷绿色*/
    clear_color.red = 0;
    clear_color.green = 255;
    clear_color.bule = 0;
    for(i=0; i < screensize; i+=4)
    {
        *((lcd_color*)(fbp + i)) = clear_color;
    }
    usleep(1000*2000);

    /*刷蓝色*/
    clear_color.red = 0;
    clear_color.green = 0;
    clear_color.bule = 255;
    for(i=0; i < screensize; i+=4)
    {
        *((lcd_color*)(fbp + i)) = clear_color;
    }

    /*显示图片*/
    memcpy(fbp,test_picture,800*480*4);


    munmap (fbp, screensize); /*解除映射*/
    printf("The mem is :%d\n", finfo.smem_len);
    printf("The line_length is :%d\n", finfo.line_length);
    printf("The xres is :%d\n", vinfo.xres);
    printf("The yres is :%d\n", vinfo.yres);
    printf("bits_per_pixel is :%d\n", vinfo.bits_per_pixel);
    close(fp);
    return 0;
}
```

可以使用`echo test > /dev/tty1`的方式实现在屏幕上显示字符

### 设置屏幕为终端

1.   在/etc/inittab文件里面添加`tty1::askfirst:~/bin/sh`
2.   在uboot的bootargs里面添加`console=tty1`
