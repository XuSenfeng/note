##  SPI物理总线

## 基础知识

### 信号线

- SCK：时钟线，数据收发同步
- MOSI：数据线，主设备数据发送、从设备数据接收
- MISO：数据线，从设备数据发送，主设备数据接收

- NSS、CS：片选信号线

支持一主多从，全双工通信，最大速率可达上百MHz

![image-20200912081954858](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509262016237.png)

### spi时序

![image-20200912083029061](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509262016148.png)

- 起始信号：NSS 信号线由高变低
- 停止信号：NSS 信号由低变高
- 数据传输：在 SCK的每个时钟周期 MOSI和 MISO同时传输一位数据，高/低位传输没有硬性规定
    - 传输单位： 8 位或 16 位
    - 单位数量：不受限制

#### spi通信模式

总线空闲时 SCK 的时钟状态以及数据采样时刻

- 时钟极性 CPOL：指 SPI 通讯设备处于空闲状态时，SCK信号线的电平信号
    - CPOL=0时， SCK在空闲状态时为低电平
    - CPOL=1时， SCK在空闲状态时为高电平

- 时钟相位 CPHA：数据的采样的时刻
    - 当 CPHA=0 时，数据在 SCK 时钟线的“奇数边沿”被采样
    - 当 CPHA=1时，数据在 SCK 时钟线的“偶数边沿”被采样

##### 案例

![image-20200912084313769](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509262016794.png)

- SCK信号线在空闲状态为低电平时，CPOL=0；空闲状态为高电平时，CPOL=1
- CPHA=0，数据在 SCK 时钟线的“奇数边沿”被采样
- 当 CPOL=0 的时候，时钟的奇数边沿是上升沿
- 当CPOL=1 的时候，时钟的奇数边沿是下降沿

##### 四大模式

![image-20200912084116532](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509262016704.png)

## SPI驱动框架简介

### SPI框架图

![image-20200904124712459](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509271037021.png)

- SPI核心层

    提供SPI控制器驱动和设备驱动的注册方法、注销方法、SPI通信硬件无关接口

- SPI主机驱动

    主要包含SPI硬件体系结构中适配器(spi控制器)的控制，用于产生SPI 读写时序

    主要数据结构：spi_master(spi_controller)

- SPI设备驱动

    通过SPI主机驱动与CPU交换数据

    主要数据结构：spi_device和spi_driver

### 核心数据结构

##### spi_master

include/linux/spi/spi.h

```c
#define spi_master			spi_controller
```

##### spi_controller

include/linux/spi/spi.h

```c
struct spi_controller {
	struct device	dev; // 设备
	...
	struct list_head list; // 链表节点, 可能有多个控制器
	s16			bus_num; // 编号
	u16			num_chipselect; // 片选信号的数量
	...
	struct spi_message		*cur_msg; // 表示需要发送的信息
	...
	int			(*setup)(struct spi_device *spi); // 初始化使用的函数指针
	int			(*transfer)(struct spi_device *spi, 
						struct spi_message *mesg); // 传输消息(异步传输)
	void		(*cleanup)(struct spi_device *spi); // 清理工作
	struct kthread_worker		kworker; // 一个处理工人
	struct task_struct		*kworker_task; // 指向实际的处理task
	struct kthread_work		pump_messages; // 具体的工作
	struct list_head		queue; // 一系列的消息
	struct spi_message		*cur_msg;
	
	...
	int (*transfer_one)(struct spi_controller *ctlr, struct spi_device *spi,struct spi_transfer *transfer);
	int (*prepare_transfer_hardware)(struct spi_controller *ctlr);
	int (*transfer_one_message)(struct spi_controller *ctlr,struct spi_message *mesg);
	void (*set_cs)(struct spi_device *spi, bool enable);
	...
	int			*cs_gpios; // 具体的片选信号
}
```

- list：链表节点，芯片可能有多个spi控制器

- bus_num：spi控制器编号

- num_chipselect：片选信号的个数

- cur_msg：当前正带处理的消息队列

- transfer ：用于把数据加入控制器的消息链表中

- cleanup：当spi_master被释放的时候，完成清理工作

- kworker：内核线程工人，spi可以使用异步传输方式发送数据

- pump_messages：具体传输工作

- queue：所有等待传输的消息队列挂在该链表下

- transfer_one_message：发送一个spi消息，类似IIC适配器里的algo->master_xfer，产生spi通信时序

- 相关API

    - `int spi_register_master(struct spi_master *master)`

        注册一个spi_controller

    - `void spi_unregister_master(struct spi_master *master)`

        注销一个spi_controller

##### spi_device

include/linux/spi/spi.h

```c
struct spi_device {
	struct device		dev;
	struct spi_controller	*controller; // 控制器
	struct spi_controller	*master;	/* compatibility layer */
	u32			max_speed_hz; // 通信最大频率
	u8			chip_select; // 片选
	u8			bits_per_word; // 传输单位
	u16			mode; // 四种模式
#define	SPI_CPHA	0x01			/* clock phase */
#define	SPI_CPOL	0x02			/* clock polarity */
#define	SPI_MODE_0	(0|0)			/* (original MicroWire) */
#define	SPI_MODE_1	(0|SPI_CPHA)
#define	SPI_MODE_2	(SPI_CPOL|0)
#define	SPI_MODE_3	(SPI_CPOL|SPI_CPHA)
#define	SPI_CS_HIGH	0x04			/* chipselect active high? */
#define	SPI_LSB_FIRST	0x08			/* per-word bits-on-wire */
#define	SPI_3WIRE	0x10			/* SI/SO signals shared */
#define	SPI_LOOP	0x20			/* loopback mode */
#define	SPI_NO_CS	0x40			/* 1 dev/bus, no chipselect */
#define	SPI_READY	0x80			/* slave pulls low to pause */
#define	SPI_TX_DUAL	0x100			/* transmit with 2 wires */
#define	SPI_TX_QUAD	0x200			/* transmit with 4 wires */
#define	SPI_RX_DUAL	0x400			/* receive with 2 wires */
#define	SPI_RX_QUAD	0x800			/* receive with 4 wires */
...
	char			modalias[SPI_NAME_SIZE]; // 名字, 配对使用
...
}
```

##### spi_driver

include/linux/spi/spi.h

```c
struct spi_driver {
	const struct spi_device_id *id_table; // 名字
	int			(*probe)(struct spi_device *spi);
	int			(*remove)(struct spi_device *spi);
	void			(*shutdown)(struct spi_device *spi);
	struct device_driver	driver;
};
```

- probe：spi设备和spi驱动匹配后，回调该函数指针

- 相关API：

    - `int spi_register_driver(struct spi_driver *sdrv)`

        注册一个spi驱动

    - `void spi_unregister_driver(struct spi_driver *sdrv)`

        注册一个spi驱动

### 总线注册

#### spi_init函数

drivers/spi/spi.c

这个是自动调用的

```c
static int __init spi_init(void)
{
	int	status;
	...
	status = bus_register(&spi_bus_type); // 生成/sys/bus/spi
	...
	status = class_register(&spi_master_class); // 生成/sys/class/spi_master
	...
}
```

#### spi总线定义

实际使用的匹配规则

```c
struct bus_type spi_bus_type = {
	.name		= "spi",
	.dev_groups	= spi_dev_groups,
	.match		= spi_match_device,
	.uevent		= spi_uevent,
};
```

#### spi_match_device()函数

drivers/spi/spi.c 进行匹配的函数

```c
static int spi_match_device(struct device *dev, struct device_driver *drv)
{
	const struct spi_device	*spi = to_spi_device(dev);
	const struct spi_driver	*sdrv = to_spi_driver(drv);

	/* Attempt an OF style match */
	if (of_driver_match_device(dev, drv))
		return 1;

	/* Then try ACPI */
	if (acpi_driver_match_device(dev, drv))
		return 1;

	if (sdrv->id_table)
		return !!spi_match_id(sdrv->id_table, spi);

	return strcmp(spi->modalias, drv->name) == 0;
}
```

#### 设备树节点

arch/arm/boot/dts/imx6ull.dtsi

4个spi控制器节点

```json
ecspi3: ecspi@2010000 {
					#address-cells = <1>;
					#size-cells = <0>;
					compatible = "fsl,imx6ul-ecspi", "fsl,imx51-ecspi";
					reg = <0x2010000 0x4000>;
					interrupts = <GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>;
    				// 时钟体系
					clocks = <&clks IMX6UL_CLK_ECSPI3>,
						 <&clks IMX6UL_CLK_ECSPI3>;
					clock-names = "ipg", "per";
					// DMA传输
    				dmas = <&sdma 7 7 1>, <&sdma 8 7 2>;
					dma-names = "rx", "tx";
					status = "disabled";
				};
```

### 总线驱动

#### module_platform_driver()宏

include/linux/platform_device.h

spi总线注册的时候调用的函数

```c
#define module_platform_driver(__platform_driver) \
	module_driver(__platform_driver, platform_driver_register, \
			platform_driver_unregister)
```

###### module_driver()宏

include/linux/device.h

定义一个函数同时定义为模块的入口函数

```c
#define module_driver(__driver, __register, __unregister, ...) \
static int __init __driver##_init(void) \
{ \
	return __register(&(__driver) , ##__VA_ARGS__); \
} \
module_init(__driver##_init); \
```

- __driver：spi_imx_driver
- __register：platform_driver_register

- __unregister：platform_driver_unregister
- \##\__VA_ARGS__：可变参数

###### module_platform_driver(spi_imx_driver)

对这个宏定义进行展开以后得结构

```
static int __init spi_imx_driver_init(void) \
{ \
	return platform_driver_register(&(spi_imx_driver) , ##__VA_ARGS__); \
} \
module_init(spi_imx_driver_init); \
```

#### SPI主控制器驱动

##### spi_imx_probe()函数

- 获取设备树节点信息，初始化spi时钟、dma...
- 保存spi寄存器起始地址，填充spi控制器回调函数

drivers/spi/spi-imx.c

![image-20250927113042133](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509271130213.png)

```c
static int spi_imx_probe(struct platform_device *pdev)
{
	struct device_node *np = pdev->dev.of_node;
	const struct of_device_id *of_id =
			of_match_device(spi_imx_dt_ids, &pdev->dev);
	struct spi_imx_master *mxc_platform_info =
			dev_get_platdata(&pdev->dev);
	struct spi_master *master;
	struct spi_imx_data *spi_imx;
	struct resource *res;
	const struct spi_imx_devtype_data *devtype_data = of_id ? of_id->data :
		(struct spi_imx_devtype_data *)pdev->id_entry->driver_data;
	bool slave_mode;
	...
	slave_mode = devtype_data->has_slavemode &&
			of_property_read_bool(np, "spi-slave"); // 获取主从模式
    // 初始化一下结构的driver_data指针
	if (slave_mode)
        // 从模式
		master = spi_alloc_slave(&pdev->dev,
					 sizeof(struct spi_imx_data));
	else
        // 主模式
		master = spi_alloc_master(&pdev->dev,
					  sizeof(struct spi_imx_data));
	if (!master)
		return -ENOMEM;
	...
        // 获取到driver_data这个对象
       spi_imx = spi_master_get_devdata(master); 
    ...
        // 片选的数量
		ret = of_property_read_u32(np, "fsl,spi-num-chipselects", &num_cs);
        if (ret < 0) {
            if (mxc_platform_info) {
                num_cs = mxc_platform_info->num_chipselect;
                master->num_chipselect = num_cs;
            }
        } else {
            master->num_chipselect = num_cs; // 记录片选信号的数量
        }
	// bitbang用于使用普通的GPIO模拟时序
	spi_imx->bitbang.master = master;
	spi_imx->dev = &pdev->dev;
	spi_imx->slave_mode = slave_mode;

	spi_imx->devtype_data = devtype_data;
	// 初始化一个记录GPIO的数组
	master->cs_gpios = devm_kzalloc(&master->dev,
			sizeof(int) * master->num_chipselect, GFP_KERNEL);
	// 回调函数(模拟SPI)
	spi_imx->bitbang.chipselect = spi_imx_chipselect;
	spi_imx->bitbang.setup_transfer = spi_imx_setupxfer;
	spi_imx->bitbang.txrx_bufs = spi_imx_transfer;
	spi_imx->bitbang.master->setup = spi_imx_setup;
	spi_imx->bitbang.master->cleanup = spi_imx_cleanup;
	spi_imx->bitbang.master->prepare_message = spi_imx_prepare_message;
	spi_imx->bitbang.master->unprepare_message = spi_imx_unprepare_message;
	spi_imx->bitbang.master->slave_abort = spi_imx_slave_abort;
	spi_imx->bitbang.master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH \
	...
	init_completion(&spi_imx->xfer_done);
	// 获取SPI的基地址
	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
	spi_imx->base = devm_ioremap_resource(&pdev->dev, res);
	...
    // 处理模拟SPI
	ret = spi_bitbang_start(&spi_imx->bitbang);
	...
}
```

##### spi_bitbang_start()函数

drivers/spi/spi-bitbang.c

```c
int spi_bitbang_start(struct spi_bitbang *bitbang)
{
	struct spi_master *master = bitbang->master;
	int ret;

	if (!master || !bitbang->chipselect)
		return -EINVAL;

	mutex_init(&bitbang->lock);

	if (!master->mode_bits)
		master->mode_bits = SPI_CPOL | SPI_CPHA | bitbang->flags;

	if (master->transfer || master->transfer_one_message)
		return -EINVAL;

	master->prepare_transfer_hardware = spi_bitbang_prepare_hardware;
	master->unprepare_transfer_hardware = spi_bitbang_unprepare_hardware;
	master->transfer_one = spi_bitbang_transfer_one;
	master->set_cs = spi_bitbang_set_cs;

	if (!bitbang->txrx_bufs) {
		bitbang->use_dma = 0;
		bitbang->txrx_bufs = spi_bitbang_bufs;
		if (!master->setup) {
			if (!bitbang->setup_transfer)
				bitbang->setup_transfer =
					 spi_bitbang_setup_transfer;
			master->setup = spi_bitbang_setup;
			master->cleanup = spi_bitbang_cleanup;
		}
	}

	/* driver may get busy before register() returns, especially
	 * if someone registered boardinfo for devices
	 */
    // 注册到Linux里面
	ret = spi_register_master(spi_master_get(master));
	if (ret)
		spi_master_put(master);

	return ret;
}
EXPORT_SYMBOL_GPL(spi_bitbang_start);
```

## 核心API

![image-20250927123351813](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509271233908.png)

### 配置函数(设备树自动设置)

#### spi_setup()函数

设置spi设备的片选信号、传输单位、最大传输速率...

drivers/spi/spi.c

```c
int spi_setup(struct spi_device *spi)
{
	unsigned	bad_bits, ugly_bits;
	int		status;

	...
    // 初始化数据的长度
	status = __spi_validate_bits_per_word(spi->controller,
					      spi->bits_per_word);
	...
    // 初始化一下数据的传输速率
	spi->max_speed_hz = spi->controller->max_speed_hz;
	...
	if (spi->controller->setup)
        // 调用spi_imx_setup函数
		status = spi->controller->setup(spi);
	...
	return status;
}
```

#### spi_imx_setup()函数

drivers/spi/spi-imx.c

```c
static int spi_imx_setup(struct spi_device *spi)
{
	dev_dbg(&spi->dev, "%s: mode %d, %u bpw, %d hz\n", __func__,
		 spi->mode, spi->bits_per_word, spi->max_speed_hz);
	// 看一下是不是使用CS
	if (spi->mode & SPI_NO_CS)
		return 0;

	if (gpio_is_valid(spi->cs_gpio))
        // 设置为输出模式
		gpio_direction_output(spi->cs_gpio,
				      spi->mode & SPI_CS_HIGH ? 0 : 1);
    
	spi_imx_chipselect(spi, BITBANG_CS_INACTIVE);

	return 0;
}
```

#### spi_imx_chipselect()函数

drivers/spi/spi-imx.c 进行设备的片选

```c
static void spi_imx_chipselect(struct spi_device *spi, int is_active)
{
	int active = is_active != BITBANG_CS_INACTIVE;
	int dev_is_lowactive = !(spi->mode & SPI_CS_HIGH); // 查找一下有效信号的电平

	if (spi->mode & SPI_NO_CS)
		return;

	if (!gpio_is_valid(spi->cs_gpio))
		return;
	// 设置电平
	gpio_set_value(spi->cs_gpio, dev_is_lowactive ^ active);
}
```

### 数据传输(重要)

##### spi_message_init()函数

include/linux/spi/spi.h

```c
static inline void spi_message_init(struct spi_message *m)
{
	memset(m, 0, sizeof *m);
	spi_message_init_no_memset(m); // 初始化两个链表
}

```

###### spi_message_init_no_memset()函数

```c
static inline void spi_message_init_no_memset(struct spi_message *m)
{
	INIT_LIST_HEAD(&m->transfers);
	INIT_LIST_HEAD(&m->resources);
}
```

###### spi_message结构体

include/linux/spi/spi.h

```c
struct spi_message {
	struct list_head	transfers;

	struct spi_device	*spi; // 属于的设备
	...
	void			(*complete)(void *context); // 传输成功回调
	void			*context;
	unsigned		frame_length;
	unsigned		actual_length;
	int			status;
	...
	struct list_head	queue; // 内核异步传输使用
	void			*state;

	/* list of spi_res reources when the spi message is processed */
	struct list_head        resources; // 记录相关资源
};
```

##### spi_message_add_tail()函数

include/linux/spi/spi.h

添加节点到链表

```c
spi_message_add_tail(struct spi_transfer *t, struct spi_message *m)
{
	list_add_tail(&t->transfer_list, &m->transfers);
}
```

###### spi_transfer结构体

include/linux/spi/spi.h

是spi message里面的一个基础元素

```c
struct spi_transfer {

	const void	*tx_buf; // 发送的buf
	void		*rx_buf; // 接收的buf
	unsigned	len;
	...
	u32		speed_hz;
	struct list_head transfer_list;
};
```

##### spi_sync()函数

drivers/spi/spi.c

同步传输数据，阻塞当前线程

```
int spi_sync(struct spi_device *spi, struct spi_message *message)

```

##### spi_async()函数

drivers/spi/spi.c

异步传输数据，不会阻塞当前线程

```c
int spi_async(struct spi_device *spi, struct spi_message *message)
```

##### spi_read/write

上面的函数可以使用这两个内核封装以后得函数进行替代

```c
static inline int
spi_read(struct spi_device *spi, void *buf, size_t len);
static inline int
spi_write(struct spi_device *spi, const void *buf, size_t len);
int spi_write_then_read(struct spi_device *spi,
		const void *txbuf, unsigned n_tx,
		void *rxbuf, unsigned n_rx);
```

这两个函数使用的是sync

## SPI数据传输剖析：同步、异步

#### spi_register_master()函数

include/linux/spi/spi.h

```c
#define spi_register_master(_ctlr)	spi_register_controller(_ctlr)
```

##### spi_register_controller()函数

drivers/spi/spi.c

```c
int spi_register_controller(struct spi_controller *ctlr)
{
	struct device		*dev = ctlr->dev.parent;
	struct boardinfo	*bi;
	int			status = -ENODEV;
	int			id, first_dynamic;
	...
	dev_set_name(&ctlr->dev, "spi%u", ctlr->bus_num); // 初始化一下设备的名字
	status = device_add(&ctlr->dev); // 进行设备的添加
    ...
    if (ctlr->transfer) {
		dev_info(dev, "controller is unqueued, this is deprecated\n");
	} else if (ctlr->transfer_one || ctlr->transfer_one_message) {
        // 这里
		status = spi_controller_initialize_queue(ctlr);
		...
	}
	...
	list_add_tail(&ctlr->list, &spi_controller_list);
	...
}
```

##### spi_controller_initialize_queue()函数

drivers/spi/spi.c

```c
static int spi_controller_initialize_queue(struct spi_controller *ctlr)
{
	int ret;
	// 初始化两个指针
	ctlr->transfer = spi_queued_transfer;
	if (!ctlr->transfer_one_message)
		ctlr->transfer_one_message = spi_transfer_one_message;

	/* Initialize and start queue */
    // 初始化一个内核线程以及具体的工作
	ret = spi_init_queue(ctlr);
	if (ret) {
		dev_err(&ctlr->dev, "problem initializing queue\n");
		goto err_init_queue;
	}
	ctlr->queued = true;
    // 启动工作
	ret = spi_start_queue(ctlr);
	if (ret) {
		dev_err(&ctlr->dev, "problem starting queue\n");
		goto err_start_queue;
	}

	return 0;

err_start_queue:
	spi_destroy_queue(ctlr);
err_init_queue:
	return ret;
}
```

##### spi_init_queue()函数

- 初始化内核线程工人
- 初始化内核具体工作

drivers/spi/spi.c

```c
static int spi_init_queue(struct spi_controller *ctlr)
{
	struct sched_param param = { .sched_priority = MAX_RT_PRIO - 1 };

	ctlr->running = false;
	ctlr->busy = false;
	// 初始化工人以及使用的线程
	kthread_init_worker(&ctlr->kworker);
	ctlr->kworker_task = kthread_run(kthread_worker_fn, &ctlr->kworker,
					 "%s", dev_name(&ctlr->dev));
	if (IS_ERR(ctlr->kworker_task)) {
		dev_err(&ctlr->dev, "failed to create message pump task\n");
		return PTR_ERR(ctlr->kworker_task);
	}
    // 初始化一个具体的工作, 记录在ctlr->pump_messages里面
	kthread_init_work(&ctlr->pump_messages, spi_pump_messages);

	...

	return 0;
}
```

##### spi_start_queue()函数

启动内核具体工作

drivers/spi/spi.c

```c
static int spi_start_queue(struct spi_controller *ctlr)
{
	unsigned long flags;

	spin_lock_irqsave(&ctlr->queue_lock, flags);

	if (ctlr->running || ctlr->busy) {
		spin_unlock_irqrestore(&ctlr->queue_lock, flags);
		return -EBUSY;
	}

	ctlr->running = true;
	ctlr->cur_msg = NULL;
	spin_unlock_irqrestore(&ctlr->queue_lock, flags);
	// 添加工作
	kthread_queue_work(&ctlr->kworker, &ctlr->pump_messages);

	return 0;
}
```

##### spi_pump_messages()函数

内核工作具体处理

drivers/spi/spi.c

```c
static void spi_pump_messages(struct kthread_work *work)
{
    // 从message获取到实际的spi控制器
	struct spi_controller *ctlr =
		container_of(work, struct spi_controller, pump_messages);

	__spi_pump_messages(ctlr, true);
}
```

##### __spi_pump_messages()函数

drivers/spi/spi.c

```c
static void __spi_pump_messages(struct spi_controller *ctlr, bool in_kthread)
{
	unsigned long flags;
	bool was_busy = false;
	int ret;
	...
    // 获取到第一个spi_message结构体
	ctlr->cur_msg =
		list_first_entry(&ctlr->queue, struct spi_message, queue);

	list_del_init(&ctlr->cur_msg->queue);
	...
	if (ctlr->prepare_message) {
		ret = ctlr->prepare_message(ctlr, ctlr->cur_msg);
		...
		ctlr->cur_msg_prepared = true;
	}
	...
    // 传输信息
	ret = ctlr->transfer_one_message(ctlr, ctlr->cur_msg);
	...
}
	
```

#### spi_sync()函数

同步传输数据

drivers/spi/spi.c

```c
int spi_sync(struct spi_device *spi, struct spi_message *message)
{
	int ret;

	mutex_lock(&spi->controller->bus_lock_mutex);
	ret = __spi_sync(spi, message);
	mutex_unlock(&spi->controller->bus_lock_mutex);

	return ret;
}
```

##### __spi_sync()函数

drivers/spi/spi.c

```c
static int __spi_sync(struct spi_device *spi, struct spi_message *message)
{
	int status;
	struct spi_controller *ctlr = spi->controller;
	unsigned long flags;

	status = __spi_validate(spi, message); // 校验通信参数
	if (status != 0)
		return status;
	// 注册一个complete用于通知这一次通信的完成
	message->complete = spi_complete;
	message->context = &done;
	message->spi = spi;
	...
	if (ctlr->transfer == spi_queued_transfer) {
        // 执行这里
		spin_lock_irqsave(&ctlr->bus_lock_spinlock, flags);

		trace_spi_message_submit(message);

		status = __spi_queued_transfer(spi, message, false);

		spin_unlock_irqrestore(&ctlr->bus_lock_spinlock, flags);
	} else {
		status = spi_async_locked(spi, message);
	}
	
	
	if (status == 0) {
		...
         // 等待completion的完成
		wait_for_completion(&done);
		status = message->status;
	}
	message->context = NULL;
	return status;
}
```

##### __spi_queued_transfer()函数

drivers/spi/spi.c

```c
static int __spi_queued_transfer(struct spi_device *spi,
				 struct spi_message *msg,
				 bool need_pump)
{
	struct spi_controller *ctlr = spi->controller;
	unsigned long flags;

	spin_lock_irqsave(&ctlr->queue_lock, flags);
	// 判断一下是不是被占用的
	if (!ctlr->running) {
		spin_unlock_irqrestore(&ctlr->queue_lock, flags);
		return -ESHUTDOWN;
	}
	msg->actual_length = 0;
	msg->status = -EINPROGRESS;

	list_add_tail(&msg->queue, &ctlr->queue);
	if (!ctlr->busy && need_pump)
        // 添加具体的工资
		kthread_queue_work(&ctlr->kworker, &ctlr->pump_messages);

	spin_unlock_irqrestore(&ctlr->queue_lock, flags);
	return 0;
}
```



##### spi_transfer_one_message()函数

drivers/spi/spi.c

```c
static int spi_transfer_one_message(struct spi_controller *ctlr,
				    struct spi_message *msg)
{
	struct spi_transfer *xfer;
	bool keep_cs = false;
	int ret = 0;
	unsigned long long ms = 1;
	struct spi_statistics *statm = &ctlr->statistics;
	struct spi_statistics *stats = &msg->spi->statistics;
	...
	list_for_each_entry(xfer, &msg->transfers, transfer_list) {
		...
		if (xfer->tx_buf || xfer->rx_buf) {
			reinit_completion(&ctlr->xfer_completion);
            // 实际的发送函数
			ret = ctlr->transfer_one(ctlr, msg->spi, xfer);
			...
			if (ret > 0) {
				ret = 0;
				ms = 8LL * 1000LL * xfer->len;
				do_div(ms, xfer->speed_hz);
				ms += ms + 200; /* some tolerance */

				if (ms > UINT_MAX)
					ms = UINT_MAX;

				ms = wait_for_completion_timeout(&ctlr->xfer_completion,
								 msecs_to_jiffies(ms));
			}
		
   	 	}
   	...
    // 添加新的工作
   	spi_finalize_current_message(ctlr);
   	...
}
```

##### spi_finalize_current_message()函数

drivers/spi/spi.c

```c
void spi_finalize_current_message(struct spi_controller *ctlr)
{
	struct spi_message *mesg;
	unsigned long flags;
	int ret;
	
	...
	ctlr->cur_msg = NULL;
	ctlr->cur_msg_prepared = false;
    // 添加下一个处理任务
	kthread_queue_work(&ctlr->kworker, &ctlr->pump_messages);
	...
	mesg->state = NULL;
	if (mesg->complete)
        // 唤醒阻塞的线程
		mesg->complete(mesg->context);
}
```



#### spi_async()函数

异步传输数据

drivers/spi/spi.c

```c
int spi_async(struct spi_device *spi, struct spi_message *message)
{
	...
	ret = __spi_async(spi, message);
	...
}
```

##### __spi_async()函数

drivers/spi/spi.c

```c
static int __spi_async(struct spi_device *spi, struct spi_message *message)
{
	struct spi_controller *ctlr = spi->controller;
	...
	return ctlr->transfer(spi, message);
}
```

##### spi_queued_transfer()函数

drivers/spi/spi.c

```c
static int spi_queued_transfer(struct spi_device *spi, struct spi_message *msg)
{
	return __spi_queued_transfer(spi, msg, true);
}
```

##### __spi_queued_transfer()函数

drivers/spi/spi.c

```c
static int __spi_queued_transfer(struct spi_device *spi,
				 struct spi_message *msg,
				 bool need_pump)
{
	struct spi_controller *ctlr = spi->controller;
	unsigned long flags;

	spin_lock_irqsave(&ctlr->queue_lock, flags);

	if (!ctlr->running) {
		spin_unlock_irqrestore(&ctlr->queue_lock, flags);
		return -ESHUTDOWN;
	}
	msg->actual_length = 0;
	msg->status = -EINPROGRESS;

	list_add_tail(&msg->queue, &ctlr->queue);
	if (!ctlr->busy && need_pump)
		kthread_queue_work(&ctlr->kworker, &ctlr->pump_messages);

	spin_unlock_irqrestore(&ctlr->queue_lock, flags);
	return 0;
}
```



