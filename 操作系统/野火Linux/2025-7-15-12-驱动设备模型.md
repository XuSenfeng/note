# elem_attr驱动设备模型

## linux设备驱动模型

### 应用

创建一个kobject对象, 这个对象里面可以有很多个属性, 分别对应一个文件, 对文件读写操控对应的函数

```c
// 创建一个文件夹
struct kobject *kobject_create_and_add(const char *name, struct kobject *parent);
// 添加属性文件
int sysfs_create_group(struct kobject *kobj, const struct attribute_gr释放资源
// 释放资源
void kobject_put(struct kobject *kobj);
```

使用的参数

```c
static struct kobj_attribute led_attribute =
    // 第一个是名字的字符串, 使用宏定义进行类型的转换
	__ATTR(led, 0664, led_show, led_store);
// 参数的列表 
static struct attribute *attrs[] = {
	&foo_attribute.attr,
	&led_attribute.attr,
	NULL,	/* need to NULL terminate the list of attributes */
};
// 实际注册的类型
static struct attribute_group attr_group = {
	.attrs = attrs,
};
```

### 概念

#### 为什么需要设备驱动模型

- 早期内核（2.4之前）没有统一的设备驱动模型，但照样可以用, 需要使用mknod命令在/dev创建驱动文件
- 2.4~2.6期间使用devfs，挂载在/dev目录。
    - 需要在内核驱动中创建设备文件(可以使用devfs_register函数进行文件的创建)，在代码里面写死命名死板
- 2.6以后使用sysfs，挂载在/sys目录
    - 将设备分类、分层次统一进行管理
    - 配合udev/mdev守护进程动态创建设备文件，命令规则自由制定, 守护进程监听用户发来的信息
    - 实际控制的是模型的多个属性, 可以进行读写

#### sysfs概述

linux系统通过sysfs体现出设备驱动模型

- sysfs是一个虚拟文件系统（类似proc文件系统）
- **目录**对应的inode节点会记录基本驱动对象(kobject)，从而将系统中的设备组成层次结构
- 用户可以读写目录下的不同文件来配置驱动对象(kobject)的不同属性

> proc文件系统一般适用于展示任务的信息的
>
> rootfs的根文件系统在初始化脚本里面有`echo /sbin/mdev > /proc/sys/kernel/hotplug`把 hotplug 机制的路径设置为 /sbin/mdev
>
> - /proc/sys/kernel/hotplug 是一个内核参数，用于指定当检测到新硬件设备时，内核应调用哪个程序来处理设备的创建与删除（即 hotplug 事件的处理器）。
> - /sbin/mdev 是 busybox 或类似工具提供的一个轻量级设备管理器，它负责在设备节点和 /dev 目录之间建立或删除设备节点。它常用于嵌入式系统、内核初始阶段尚未运行 udev 的场景。

#### 设备驱动模型基本元素

- kobject：sysfs中的一个目录，常用来表示基本驱动对象，不允许发送消息到用户空间
- kset：sysfs中的一个目录，常用来管理kobject，允许发送消息到用户空间
- kobj_type：目录下属性文件的操作接口

### 驱动模型1

![image-20250718142106602](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507181421091.png)

在 Linux 内核的设备模型中，**`kset`（Kernel Object Set）** 是一个 **管理同类型 `kobject` 的容器**。它本质上是 `kobject` 的集合管理器，用于组织、管理和操作一组逻辑相关的内核对象。

#### kset 的核心作用

1. **逻辑分组**

- 将具有**相同类型或功能属性**的 `kobject` 归入同一集合（如所有 USB 设备、所有 PCI 设备）。

- 示例：

    ```
    struct kset *usb_devices_kset; // 所有 USB 设备的集合
    ```

2. **统一管理**

- 提供对组内对象的批量操作：
    - 遍历所有成员（通过链表 `kobject->entry` 连接）。
    - 递归释放组内所有对象（当 `kset` 自身被释放时）。

3. **sysfs 目录结构**

- 每个 `kset` 在 sysfs 中对应**一个目录**（如 `/sys/bus/usb/devices/`）。
- 成员 `kobject` 默认显示在该目录下（除非显式指定 `parent`）。

4. **继承默认行为**

- 为组内对象提供共享的属性和方法：
    - 通过关联 `ktype`（如所有 USB 设备共享相同的属性文件操作）。
    - 若组内 `kobject` 未单独设置 `ktype`，则继承 `kset->ktype`。

5. **热插拔事件处理**

- 管理 **uevent** 事件（如设备插入/移除）：
    - 定义 `kset->uevent_ops` 处理事件回调。
    - 统一向用户空间（如 udev）发送事件通知。

1. `*kset` 指针：管理对象集合（横向分组）

> - **作用**：
>     指向一个 **`kset` 对象**，表示当前 `kobject` **所属的集合**。`kset` 是相同类型对象的逻辑分组（如所有 USB 设备、所有 PCI 设备）。
>
> - **核心功能**：
>
>     - **统一管理**：通过 `kset` 可批量操作组内对象（如遍历所有对象、统一释放资源）。
>     - **定义默认属性**：`kset` 可提供组内对象共享的默认属性和方法（如 `ktype`）。
>     - **sysfs 组织结构**：
>         - 若 `kobject` 未显式指定 `parent`，则它在 sysfs 中默认出现在 `kset` 对应的目录下。
>         - 例如：所有 USB 设备（`kobject`）位于 `/sys/bus/usb/devices/`（`kset` 的目录）。
>
> - **特点**：
>     体现对象的 **“分类归属”**（如设备类型、总线类型），强调逻辑分组。

2. `*parent` 指针：构建层次结构（纵向继承）

>- **作用**：
>    指向另一个 **`kobject` 对象**，表示当前对象的 **父对象**，用于构建树形层次结构。
>- **核心功能**：
>    - **sysfs 目录结构**：
>        当前对象的 sysfs 目录直接位于父对象的目录下（形成路径如 `/sys/devices/parent/child/`）。
>    - **生命周期管理**：
>        父对象被释放时，所有子对象会递归释放（引用计数机制）。
>    - **设备模型关系**：
>        描述物理/逻辑层级（如：USB 鼠标的 `parent` 是 USB 集线器，集线器的 `parent` 是 USB 控制器）。
>- **特点**：
>    体现对象的 **“从属关系”**（如设备拓扑结构），强调物理/逻辑层级。

#### kset 的数据结构

```c
struct kset {
    struct list_head list;        // 连接所有成员的链表头
    spinlock_t list_lock;         // 链表操作锁
    struct kobject kobj;          // 内嵌的 kobject（kset本身也是kobject！）
    const struct kset_uevent_ops *uevent_ops; // 热插拔事件操作集
};
```

### 驱动模型2

![image-20250718142424444](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507181424565.png)

上层kobject节点无法遍历查找下层kobject

### kobject

sysfs中每一个目录都对应一个kobject, 目录里面的文件是实际需要控制的属性

![image-20250718143722417](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507181437767.png)

include/linux/kobject.h

```c
struct kobject {
	//用来表示该kobject的名称
	const char		*name;
	//链表节点
	struct list_head	entry;
	//该kobject的上层节点，构建kobject之间的层次关系
	struct kobject		*parent;
	//该kobject所属的kset对象，用于批量管理kobject对象
	struct kset		*kset;
	//该Kobject的sysfs文件系统相关的操作和属性
	struct kobj_type	*ktype;
	//该kobject在sysfs文件系统中对应目录项
	struct kernfs_node	*sd; /* sysfs directory entry */
	//该kobject的引用次数
	struct kref		kref;
#ifdef CONFIG_DEBUG_KOBJECT_RELEASE
	struct delayed_work	release;
#endif
	//记录内核对象的初始化状态
	unsigned int state_initialized:1;
	//表示该kobject所代表的内核对象有没有在sysfs建立目录
	unsigned int state_in_sysfs:1;
    // 用于发送消息到用户空间
	unsigned int state_add_uevent_sent:1;
	unsigned int state_remove_uevent_sent:1;
	unsigned int uevent_suppress:1;
};
```

#### kobject_create_and_add()

lib/kobject.c 

+ kobject对象的构建
+ 构建一个sysfs里面的目录项, kernelfs_node
+ 关联起来

```c
struct kobject *kobject_create_and_add(const char *name, struct kobject *parent)
{
	struct kobject *kobj;
	int retval;
	/*创建并初始化一个kobject对象*/
	kobj = kobject_create();
	if (!kobj)
		return NULL;
	/*sysfs创建一个目录项并与kobject对象关联*/
	retval = kobject_add(kobj, parent, "%s", name);
	if (retval) {
		pr_warn("%s: kobject_add error: %d\n", __func__, retval);
		kobject_put(kobj);
		kobj = NULL;
	}
	return kobj;
}
```

#### kobject_create()函数

lib/kobject.c

创建一个对象以及初始化他的操作函数

```c
struct kobject *kobject_create(void)
{
	struct kobject *kobj;
	/*动态申请内存，存放kobject对象*/
	kobj = kzalloc(sizeof(*kobj), GFP_KERNEL);
	if (!kobj)
		return NULL;
	// 初始化, 设置实际的操作接口ktype为dynamic_kobj_ktype
	kobject_init(kobj, &dynamic_kobj_ktype);
	return kobj;
}
```

```c
static struct kobj_type dynamic_kobj_ktype = {
	.release	= dynamic_kobj_release,
	.sysfs_ops	= &kobj_sysfs_ops,
};
```

```c
// 文件的属性接口, 是一个统一的接口
const struct sysfs_ops kobj_sysfs_ops = {
	.show	= kobj_attr_show,
	.store	= kobj_attr_store,
};
```

##### kobject_init()函数

lib/kobject.c

初始化操作的接口

```c
void kobject_init(struct kobject *kobj, struct kobj_type *ktype)
{
...
    // 初始化一下其他的操作对象
	kobject_init_internal(kobj);
	/*设置目录属性文件的操作接口*/
	kobj->ktype = ktype;
	return;
...
}
```

##### kobject_init_internal()函数

lib/kobject.c

初始化一下基础的成员变量, 计数链表初始化

```c
static void kobject_init_internal(struct kobject *kobj)
{
	if (!kobj)
		return;\
	/*将kobject的引用计数设置为1*/
	kref_init(&kobj->kref);
	/*初始化链表节点*/
	INIT_LIST_HEAD(&kobj->entry);
	/*该kobject对象还没和sysfs目录项关联*/
	kobj->state_in_sysfs = 0;
	kobj->state_add_uevent_sent = 0;
	kobj->state_remove_uevent_sent = 0;
	/*kobject对象的初始化标志*/
	kobj->state_initialized = 1;
}
```

#### kobject_add()函数

lib/kobject.c

设置名字参数以及把这个对象和父对象进行链接等

调用: `retval = kobject_add(kobj, parent, "%s", name);`

```c
int kobject_add(struct kobject *kobj, struct kobject *parent,const char *fmt, ...)
{
	va_list args;
	int retval;
...
	/*获取第一个可变参数(名字)，可变参数函数的实现与函数传参的栈结构有关*/
	va_start(args, fmt);
	retval = kobject_add_varg(kobj, parent, fmt, args);
	va_end(args);
...
	return retval;
}
```

##### kobject_add_varg()函数

lib/kobject.c

设置父对象以及设置名字等

```c
static __printf(3, 0) int kobject_add_varg(struct kobject *kobj,
					   struct kobject *parent,
					   const char *fmt, va_list vargs)
{
	int retval;
	retval = kobject_set_name_vargs(kobj, fmt, vargs);
	if (retval) {
		pr_err("kobject: can not set name properly!\n");
		return retval;
	}
	/*第一次设置kobj的parent指针*/
	kobj->parent = parent;
	return kobject_add_internal(kobj);
}
```

##### kobject_set_name_vargs()函数

lib/kobject.c

初始化名字参数

```c
int kobject_set_name_vargs(struct kobject *kobj, const char *fmt,
				  va_list vargs)
{
	const char *s;
	...
	/*参数格式化打印到s字符串中*/
	s = kvasprintf_const(GFP_KERNEL, fmt, vargs);
	...
	/*设置kobject对象的名称*/
	kobj->name = s;
	...
}
	
```

##### kobject_add_internal()函数

lib/kobject.c

把这个对象和父对象进行连接

```c
static int kobject_add_internal(struct kobject *kobj)
{
	struct kobject *parent;
	...
	parent = kobject_get(kobj->parent);
	
	if (kobj->kset) {
		/*如果parent为空，parent设置为kobj->kset->kobj*/
		if (!parent)
			parent = kobject_get(&kobj->kset->kobj);
		/*把该kobject加入到kset链表的末尾*/
		kobj_kset_join(kobj);
		/*第二次设置kobj的parent指针*/
		kobj->parent = parent;
	}
	...
     // 负责创建目录项
	error = create_dir(kobj);
	...
	kobj->state_in_sysfs = 1;
	...
}
```

##### create_dir()函数

lib/kobject.c

```c
static int create_dir(struct kobject *kobj)
{
	const struct kobj_ns_type_operations *ops;
	int error;
	// 实际的创建函数
	error = sysfs_create_dir_ns(kobj, kobject_namespace(kobj));
	...
}
```

##### sysfs_create_dir_ns()函数

fs/sysfs/dir.c

```c
int sysfs_create_dir_ns(struct kobject *kobj, const void *ns)
{
	struct kernfs_node *parent, *kn;
	kuid_t uid;
	kgid_t gid;

	BUG_ON(!kobj);
	
	if (kobj->parent)
		/*获取上一层节点的目录项*/
		parent = kobj->parent->sd;
	else
		/*设置上一层节点的目录项为sysfs根目录*/
		parent = sysfs_root_kn;

	if (!parent)
		return -ENOENT;
	// 记录在sysfs文件系统里面
	kn = kernfs_create_dir_ns(parent, kobject_name(kobj),
				  S_IRWXU | S_IRUGO | S_IXUGO, uid, gid,
				  kobj, ns);
	...
	/*kobj对象关联sysfs目录项*/
	kobj->sd = kn;
	return 0;
}
```

##### kernfs_create_dir_ns()函数

```c
struct kernfs_node *kernfs_create_dir_ns(struct kernfs_node *parent,
					 const char *name, umode_t mode,
					 kuid_t uid, kgid_t gid,
					 void *priv, const void *ns)
{
	struct kernfs_node *kn;
	int rc;

	/* allocate */
	kn = kernfs_new_node(parent, name, mode | S_IFDIR,
			     uid, gid, KERNFS_DIR);
	...
	/*sysfs目录项关联kobject对象*/
	kn->priv = priv; // 记录的是kobject对象
	...
}
```

##### kernfs_new_node()函数

```c
struct kernfs_node *kernfs_new_node(struct kernfs_node *parent,
				    const char *name, umode_t mode,
				    kuid_t uid, kgid_t gid,
				    unsigned flags)
{
	struct kernfs_node *kn;

	kn = __kernfs_new_node(kernfs_root(parent),
			       name, mode, uid, gid, flags);
	if (kn) {
		kernfs_get(parent);
		kn->parent = parent;
	}
	return kn;
}
```

### kset

对应一个目录, 可以用于管理多个子目录

```c
struct kset {
	//用来将起中的object对象构建成链表
	struct list_head list;
	//自旋锁
	spinlock_t list_lock;
	//当前kset内核对象的kobject变量
	struct kobject kobj;
	//定义了一组函数指针，当kset中的某些kobject对象发生状态变化需要通知用户空间时，调用其中的函数来完成
	const struct kset_uevent_ops *uevent_ops;
}
```

### kobj_type

目录文件的操作接口, 初始化的时候注册在kobject里面

```c
struct kobj_type {
	//销毁kobject对象时调用
	void (*release)(struct kobject *kobj);
	//kobject对象属性文件统一操作接口, 之后调用不同属性的具体接口
	const struct sysfs_ops *sysfs_ops;
	//kobject默认属性文件的名字、"文件具体操作接口"
	struct attribute **default_attrs;                                                         
	const struct kobj_ns_type_operations *(*child_ns_type)(struct kobject *kobj);
	const void *(*namespace)(struct kobject *kobj);
	void (*get_ownership)(struct kobject *kobj, kuid_t *uid, kgid_t *gid);
};
```

#### kobj_type：用户空间的法宝

- 为kobject对象构建多个**属性文件**
- 为每个属性文件设置具体操作接口
- vfs的inode对象与sysfs的kernfs_node对象的绑定过程, 使得文件系统可以直接控制

![image-20250718235010661](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507182350766.png)

#### 重点

- 关注属性文件具体操作接口的赋值过程
- 关注open()、read()、write函数的底层机制

###  属性

#### 第一阶段：属性文件操作接口赋值

##### sysfs_create_group()函数

fs/sysfs/group.c

创建属性文件以及和文件接口的绑定

```c
int sysfs_create_group(struct kobject *kobj,
		       const struct attribute_group *grp)
{
	return internal_create_group(kobj, 0, grp);
}
```

- attribute_group结构体：

    include/linux/sysfs.h

    ![image-20250718235047632](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507182350775.png)

```c
struct attribute_group {
	const char		*name;
	umode_t			(*is_visible)(struct kobject *,
					      struct attribute *, int);
	umode_t			(*is_bin_visible)(struct kobject *,
						  struct bin_attribute *, int);
	struct attribute	**attrs; // 一个attribute的指针数组, 记录属性
	struct bin_attribute	**bin_attrs;
};
```

- struct attribute结构体：

    include/linux/sysfs.h

```c
// 一个属性
struct attribute {
	const char		*name;
	umode_t			mode;  // 属性文件的权限
};
```

- kobj_attribute结构体

```c
// 实际使用的属性
struct kobj_attribute {
	struct attribute attr;
    // 实际的操作接口
	ssize_t (*show)(struct kobject *kobj, struct kobj_attribute *attr,
			char *buf);
	ssize_t (*store)(struct kobject *kobj, struct kobj_attribute *attr,
			 const char *buf, size_t count);
};
```

##### internal_create_group()函数

![image-20250718235130790](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507182351866.png)

fs/sysfs/group.c

把一个kobject和属性建立关系

```c
tatic int internal_create_group(struct kobject *kobj, int update,
				 const struct attribute_group *grp)
{
	struct kernfs_node *kn;
	kuid_t uid;
	kgid_t gid;
	int error;
	
	...
	if (grp->name)
	...
	else
		kn = kobj->sd; // 获取目录项
    ...
    // 文件的目录节点, 所属的用户以及组等信息
    error = create_files(kn, kobj, uid, gid, grp, update);
    ...
}	
```

##### create_files()函数

fs/sysfs/group.c

依次个每个属性建立文件

```c
static int create_files(struct kernfs_node *parent, struct kobject *kobj,
			kuid_t uid, kgid_t gid,
			const struct attribute_group *grp, int update)
{
	struct attribute *const *attr;
	struct bin_attribute *const *bin_attr;
	int error = 0, i;

	if (grp->attrs) {
		for (i = 0, attr = grp->attrs; *attr && !error; i++, attr++) {
            // 遍历所有属性, 属性以及权限是自己设置的
			umode_t mode = (*attr)->mode;
			...
			error = sysfs_add_file_mode_ns(parent, *attr, false,
						       mode, uid, gid, NULL);
			...
			}
	...
}
```

##### sysfs_add_file_mode_ns()函数

fs/sysfs/file.c

 获取一下实际的操作函数

```c
int sysfs_add_file_mode_ns(struct kernfs_node *parent,
			   const struct attribute *attr, bool is_bin,
			   umode_t mode, kuid_t uid, kgid_t gid, const void *ns)
{
	struct lock_class_key *key = NULL;
	const struct kernfs_ops *ops;
	struct kernfs_node *kn;
	loff_t size;
	// 参数是false, 一定进入
	if (!is_bin) {
		struct kobject *kobj = parent->priv;
		/*kobj_sysfs_ops 初始化默认的属性操作函数*/
		const struct sysfs_ops *sysfs_ops = kobj->ktype->sysfs_ops;
		...
         // 默认初始化的两个函数
		if (sysfs_ops->show && sysfs_ops->store) {
			if (mode & SYSFS_PREALLOC)
				ops = &sysfs_prealloc_kfops_rw;
			else
                 // 实际初始化的操作接口
				ops = &sysfs_file_kfops_rw;
		else if
			...
		}
	...
    // 实际创建文件的位置
	kn = __kernfs_create_file(parent, attr->name, mode & 0777, uid, gid,
				  size, ops, (void *)attr, ns, key);
    ...
}
```

- kernfs_ops节点的操作函数

`ops = &sysfs_file_kfops_rw;`初始化的操作函数, 最后赋值给kernelfs_node的节点

```c
static const struct kernfs_ops sysfs_file_kfops_rw = {
	.seq_show	= sysfs_kf_seq_show,
	.write		= sysfs_kf_write,
};
```

##### __kernfs_create_file()函数

为每一个属性创建一个kernfs_node文件

```c
struct kernfs_node *__kernfs_create_file(struct kernfs_node *parent,
					 const char *name,
					 umode_t mode, kuid_t uid, kgid_t gid,
					 loff_t size,
					 const struct kernfs_ops *ops,
					 void *priv, const void *ns,
					 struct lock_class_key *key)
{
	struct kernfs_node *kn;
	unsigned flags;
	int rc;

	flags = KERNFS_FILE;
	// 建立一个新的节点
	kn = kernfs_new_node(parent, name, (mode & S_IALLUGO) | S_IFREG,
			     uid, gid, flags);
	if (!kn)
		return ERR_PTR(-ENOMEM);
	/*给这一个节点的操作接口赋值*/
	kn->attr.ops = ops;
	kn->attr.size = size;
	kn->ns = ns;
	/*文件属性赋值*/
	kn->priv = priv; // 实际的前一级是一个attribute
	
	if (ops->seq_show)
		kn->flags |= KERNFS_HAS_SEQ_SHOW;
	...
}
```

#### 第二阶段：open()\read()\write()的底层机制

**设置参数的相关的部分**, 使用对于参数的控制实现操作

![image-20250718235348248](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507182353345.png)

在 Linux 内核的 `kernfs` 子系统（用于 sysfs、cgroupfs 等）中，当用户空间进程与一个 `kernfs_node`（代表文件、目录、符号链接等）进行交互（特别是打开和读写文件）时，涉及到的结构体 `inode`, `kernfs_open_file`, `file`, `seq_file`, `seq_operations` 扮演着关键角色。它们协同工作，将 VFS 层的操作路由到具体的 `kernfs` 实现。以下是它们建立关系和发挥作用的过程：

1. **`kernfs_node` (核心实体):**
    - 这是 `kernfs` 文件系统的基石，代表文件系统中的一个对象（文件、目录、符号链接、属性）。
    - 它包含：
        - 名称、父节点、操作权限等元数据。
        - 一个指向 `kernfs_ops` 结构体的指针 (`kernfs_ops *ops`)。这个结构体定义了该节点类型（特别是文件节点）的核心操作：
            - `open`：可选，当文件被打开时调用。
            - `release`：可选，当文件被关闭时调用。
            - `read` / `write`：**传统模式**的直接读写函数。
            - `seq_show` / `seq_start` / `seq_next` / `seq_stop`：**seq_file 模式**的函数，用于实现顺序、迭代式读取（常用于输出内核数据结构）。
            - `mmap`：内存映射操作。
        - 节点特定的私有数据 (`void *priv`)。
2. **`inode` (VFS 索引节点):**
    - 当 `kernfs_node`（特别是文件节点）被查找或创建时，`kernfs` 会为其在内存中创建一个对应的 VFS `inode` 结构体（通过 `kernfs_get_inode`）。
    - 这个 `inode` 的 `i_private` 字段会被设置为指向它所代表的 `kernfs_node` (`kn`)。
    - `inode` 的 `i_fop` (文件操作) 字段会被设置为 `kernfs` 定义的通用文件操作结构体 `kernfs_file_operations`。
    - **作用:** 在 VFS 层代表 `kernfs_node`。当 VFS 操作（如 `open`, `read`, `write`）作用在这个 `inode` 上时，VFS 会调用 `i_fop` 中注册的函数，这些函数由 `kernfs` 提供，并将操作路由到具体的 `kernfs_node` 及其 `kernfs_ops`。
3. **`file` (VFS 文件对象):**
    - 当用户空间**进程**调用 `open()` 打开一个由 `kernfs_node` 代表的文件时，VFS 会创建一个 `file` 结构体来表示这次“打开”的实例。
    - 这个 `file` 结构体的 `private_data` 字段至关重要。
    - VFS 会调用该文件对应 `inode->i_fop->open()` 函数。对于 `kernfs`，这个函数是 `kernfs_fop_open`。
    - **`kernfs_fop_open` 的关键作用 (建立桥梁):**
        1. 通过 `file->f_inode->i_private` 获取对应的 `kernfs_node` (`kn`)。
        2. 分配一个 `kernfs_open_file` 结构体 (`of`)。
        3. 将 `of->kn` 设置为 `kn` (关联 `kernfs_node`)。
        4. 将 `file->private_data` 设置为 `of` (关联 `file` 和 `kernfs_open_file`)。
        5. 检查 `kn->attr.ops` (`kernfs_ops`)：
            - 如果定义了 `kn->attr.ops->open`，则调用它。
            - 如果定义了 `kn->attr.ops->seq_show` (表明使用 seq_file 模式)，则调用 `seq_open(file, &kernfs_seq_ops)`。这个函数：
                - 分配一个 `seq_file` 结构体 (`seq`)。
                - 将 `seq->private` 设置为 `of` (关联 `seq_file` 和 `kernfs_open_file`)。
                - 将 `file->private_data` **覆盖**为指向这个 `seq_file` 结构体 (`seq`)。*(注意：此时 `file->private_data` 指向 `seq`，而 `seq->private` 指向 `of`，`of->kn` 指向 `kn`)*
                - 设置 `seq->op` 为 `&kernfs_seq_ops` (一个 `seq_operations` 结构体，其函数内部会再路由到 `kernfs_open_file` 和 `kernfs_ops`)。
            - 否则（传统模式），`file->private_data` 保持指向 `of`。
4. **`kernfs_open_file` (Per-open-file 状态):**
    - 表示一个 `kernfs_node` 文件被**打开一次**的上下文信息。
    - 关键字段：
        - `kn`: 指向关联的 `kernfs_node`。
        - `file`: 指向关联的 VFS `file` 结构体。
        - `priv`: 可选的私有数据，可由 `kernfs_ops->open` 设置，供后续操作（`read`/`write`/`seq_show` 等）使用。
        - `atomic_write_len`: 原子写长度（如果适用）。
        - `mutex`: 保护该打开文件状态的互斥锁（用于防止并发读写冲突）。
    - **作用:** 维护特定于这次文件打开操作的状态（如 `priv` 数据）。它是连接 VFS `file` 和底层 `kernfs_node` 及其操作的核心中间结构。无论是传统模式还是 seq_file 模式，最终的操作都需要通过它来访问 `kn` 和可能的 `priv` 数据。
5. **`seq_file` (序列文件抽象):**
    - 当 `kernfs_ops` 定义了 `seq_show` 时，`kernfs_fop_open` 会调用 `seq_open` 创建一个 `seq_file` 结构体。
    - 该结构体管理顺序、迭代读取的状态。它处理缓冲区、游标位置、迭代状态机等。
    - 关键字段：
        - `buf`: 内核缓冲区，用于累积要输出到用户空间的数据。
        - `size` / `from` / `count` / `index`: 缓冲区管理和迭代状态。
        - `op`: 指向 `seq_operations` 结构体 (这里是 `&kernfs_seq_ops`)。
        - `private`: 指向与之关联的 `kernfs_open_file` (`of`)。
    - **作用:** 为需要迭代输出大量或结构化数据（如链表、数组）的 `kernfs` 文件提供标准化的、更简单的编程接口 (`seq_operations`)。它处理了缓冲区管理、多次调用 (`start`/`next`/`show`/`stop`) 的协调等复杂性。
6. **`seq_operations` (序列文件操作):**
    - 这是一个包含函数指针的结构体 (`start`, `next`, `show`, `stop`)，定义了如何遍历和显示序列中的元素。
    - 在 `kernfs` 的 seq_file 模式下，它被设置为 `kernfs_seq_ops`。
    - `kernfs_seq_ops` 的函数实现 (`kernfs_seq_start`, `kernfs_seq_next`, `kernfs_seq_stop`, `kernfs_seq_show`) 充当适配器：
        1. 它们通过 `seq_file->private` 获取 `kernfs_open_file *of`。
        2. 它们通过 `of->kn` 获取 `kernfs_node *kn`。
        3. 它们最终调用 `kn->attr.ops` (`kernfs_ops`) 中定义的对应 seq_file 函数：
            - `kernfs_seq_start` -> 调用 `ops->seq_start(of, &pos)` (如果定义了)，否则处理简单的单次输出。
            - `kernfs_seq_next` -> 调用 `ops->seq_next(of, v, &pos)` (如果定义了)。
            - `kernfs_seq_show` -> 调用 `ops->seq_show(of, v)` **(核心输出函数！)**.
            - `kernfs_seq_stop` -> 调用 `ops->seq_stop(of, v)` (如果定义了)。
    - **作用:** 提供 VFS seq_file 子系统期望的通用接口 (`seq_operations`)，并将这些通用调用**适配**到具体的 `kernfs_node` 的 `kernfs_ops` 中定义的 seq_file 操作函数上。`kernfs_seq_show` 是核心，它调用 `ops->seq_show` 来生成文件的实际内容。

##### kernfs_init_inode()函数

进行inode以及kernfs_node的关联, 实际是在open函数的时候进行的

```c
static void kernfs_init_inode(struct kernfs_node *kn, struct inode *inode)
{
	kernfs_get(kn);
	/*sysfs的kernels_node赋值给vfs的inode*/
	inode->i_private = kn; // 使用这个函数记录关联
	inode->i_mapping->a_ops = &kernfs_aops;
	inode->i_op = &kernfs_iops;
	inode->i_generation = kn->id.generation;

	set_default_inode_attr(inode, kn->mode);
	kernfs_refresh_inode(kn, inode);

	/* 判断sysfs的kernels_node类型 */
	switch (kernfs_type(kn)) {
	case KERNFS_DIR:
		inode->i_op = &kernfs_dir_iops;
		inode->i_fop = &kernfs_dir_fops;
		if (kn->flags & KERNFS_EMPTY_DIR)
			make_empty_dir_inode(inode);
		break;
	case KERNFS_FILE:
         // 属性分支
		inode->i_size = kn->attr.size;
		/*文件的操作接口*/
		inode->i_fop = &kernfs_file_fops; // 初始化一下各种实际的操作指针
		break;
	case KERNFS_LINK:
		inode->i_op = &kernfs_symlink_iops;
		break;
	default:
		BUG();
	}

	unlock_new_inode(inode);
}
```

```c
// 最先调用的函数
const struct file_operations kernfs_file_fops = {
	.read		= kernfs_fop_read,
	.write		= kernfs_fop_write,
	.llseek		= generic_file_llseek,
	.mmap		= kernfs_fop_mmap,
	.open		= kernfs_fop_open,
	.release	= kernfs_fop_release,
	.poll		= kernfs_fop_poll,
	.fsync		= noop_fsync,
};
```

##### kernfs_fop_open()函数

初始化kernfs_open_file结构

```c
static int kernfs_fop_open(struct inode *inode, struct file *file)
{
	struct kernfs_node *kn = inode->i_private; // sysfs的node, 是kernfs_node类
	struct kernfs_open_file *of;
	...
	of = kzalloc(sizeof(struct kernfs_open_file), GFP_KERNEL);
	...
	/*sysfs中文件的kernfs_node赋值给of->kn*/
	of->kn = kn;
	/*进程的struct file赋值给of->file*/
	of->file = file;
	...
    // 这里获取到的是kernfs_node里面的attr属性的ops参数
	if (ops->seq_show)
		error = seq_open(file, &kernfs_seq_ops);
	...
	/*struct file的私有指针赋值给of->seq_file */
	of->seq_file = file->private_data;
	/*of赋值给of->seq_file->private*/
	of->seq_file->private = of;
	...
 }
```

// 记录的是fs系统的操作

```c
static const struct seq_operations kernfs_seq_ops = {
	.start = kernfs_seq_start,
	.next = kernfs_seq_next,
	.stop = kernfs_seq_stop,
	.show = kernfs_seq_show,
};
```

seq_open

```c
int seq_open(struct file *file, const struct seq_operations *op)
{
	struct seq_file *p;

	WARN_ON(file->private_data);

	p = kmem_cache_zalloc(seq_file_cache, GFP_KERNEL);
	if (!p)
		return -ENOMEM;
	
	file->private_data = p;
	...
	p->op = op;
	...
}
```



##### kernfs_fop_read()函数

用于调用之前设置的 seq_operations里面的show函数

```c
static ssize_t kernfs_fop_read(struct file *file, char __user *user_buf,
			       size_t count, loff_t *ppos)
{
	struct kernfs_open_file *of = kernfs_of(file);
	// 创建的时候设置的这个标志位
	if (of->kn->flags & KERNFS_HAS_SEQ_SHOW)
         // 实际的读取函数
		return seq_read(file, user_buf, count, ppos);
	else
		return kernfs_file_direct_read(of, user_buf, count, ppos);
}

```

##### kernfs_of()函数

获取一个file结构体和sysfs连接的kernfs_open_file结构

```c
static struct kernfs_open_file *kernfs_of(struct file *file)
{
	return ((struct seq_file *)file->private_data)->private;
}
```

##### seq_read()函数

```c
ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)
{
	struct seq_file *m = file->private_data;
	...
	err = m->op->show(m, p); // 实际是kernfs_seq_show函数
	...
	err = copy_to_user(buf, m->buf, n);
	...
}
```

##### kernfs_seq_show()函数

![image-20250719000819498](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507190008624.png)

```c
static int kernfs_seq_show(struct seq_file *sf, void *v)
{
	struct kernfs_open_file *of = sf->private;
	...
	return of->kn->attr.ops->seq_show(sf, v); // 调用的是sysfs_kf_seq_show
}
```

##### sysfs_kf_seq_show()函数

这里的seq_file实际就是和用户空间通信使用的, 记录读取的数据缓冲区等

![image-20250719001258975](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507190012035.png)

```c
static int sysfs_kf_seq_show(struct seq_file *sf, void *v)
{
	struct kernfs_open_file *of = sf->private;
	struct kobject *kobj = of->kn->parent->priv;
	const struct sysfs_ops *ops = sysfs_file_ops(of->kn);
	ssize_t count;
	char *buf;
	// 获取一个缓冲区buf
	count = seq_get_buf(sf, &buf);
	if (count < PAGE_SIZE) {
		seq_commit(sf, -1);
		return 0;
	}
	memset(buf, 0, PAGE_SIZE);

	/*
	 * Invoke show().  Control may reach here via seq file lseek even
	 * if @ops->show() isn't implemented.
	 */
	if (ops->show) {
        // 实际是sysfs_kf_seq_show, 使用属性的上一级节点, 获取kobject
		count = ops->show(kobj, of->kn->priv, buf); // 使用这个文件对用的属性进行读取kobj_attr_show
		if (count < 0)
			return count;
	}

	/*
	 * The code works fine with PAGE_SIZE return but it's likely to
	 * indicate truncated result or overflow in normal use cases.
	 */
	if (count >= (ssize_t)PAGE_SIZE) {
		printk("fill_read_buffer: %pS returned bad count\n",
				ops->show);
		/* Try to struggle along */
		count = PAGE_SIZE - 1;
	}
	seq_commit(sf, count);
	return 0;
}
```

##### sysfs_file_ops()函数

获取到最初的kobject的sysfs_ops, 实际是kobj_sysfs_ops函数

```c
static const struct sysfs_ops *sysfs_file_ops(struct kernfs_node *kn)
{
	struct kobject *kobj = kn->parent->priv;

	if (kn->flags & KERNFS_LOCKDEP)
		lockdep_assert_held(kn);
	return kobj->ktype ? kobj->ktype->sysfs_ops : NULL;
}
```

##### seq_get_buf()函数

在seq_file里面有一个buf, 用于和用户通信

```c
static inline size_t seq_get_buf(struct seq_file *m, char **bufp)
{
	BUG_ON(m->count > m->size);
	if (m->count < m->size)
		*bufp = m->buf + m->count; // 缓冲区加偏移
	else
		*bufp = NULL;

	return m->size - m->count;
}
```

#### kobj_attr_show()函数

最终的获取属性的位置

```c
static ssize_t kobj_attr_show(struct kobject *kobj, struct attribute *attr,char *buf)
{
	struct kobj_attribute *kattr;
	ssize_t ret = -EIO;
	/*根据结构体成员的内存地址获取结构体的地址*/
	kattr = container_of(attr, struct kobj_attribute, attr);
	if (kattr->show)
		ret = kattr->show(kobj, kattr, buf);// 用户自己初始化的show属性
	return ret;
}
```

## 实际应用

### 实验思路

内核模块+led驱动+kobject+kobj_attribute

首先使用函数`kobject_create_and_add`创建一个kobject对象, 之后使用`sysfs_create_group`添加对应的参数

#### 内核模块

- 动态加载功能

#### led驱动

- 控制硬件led

#### kobject

- 在/sys创建目录项

#### kobj_attribute

- 为kobject对象的属性文件提供独有的读写接口

### 代码示例

```c
#include <linux/module.h>
#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/kobject.h>
#include <linux/string.h>
#include <linux/sysfs.h>
#include <linux/fs.h>
#include <linux/uaccess.h>
#include <asm/io.h>

#define DEV_MAJOR		0		/* 动态申请主设备号 */
#define DEV_NAME		"red_led" 	/*led设备名字 */

/* GPIO虚拟地址指针 */
static void __iomem *IMX6U_CCM_CCGR1;
static void __iomem *SW_MUX_GPIO1_IO04;
static void __iomem *SW_PAD_GPIO1_IO04;
static void __iomem *GPIO1_DR;
static void __iomem *GPIO1_GDIR;

static int foo;

static ssize_t foo_show(struct kobject *kobj, struct kobj_attribute *attr,
			char *buf)
{
	return sprintf(buf, "%d\n", foo);
}

static ssize_t foo_store(struct kobject *kobj, struct kobj_attribute *attr,
			 const char *buf, size_t count)
{
	int ret;
	// 使用10进制的格式进行读取
	ret = kstrtoint(buf, 10, &foo);
	if (ret < 0)
		return ret;

	return count;
}
// 第一个参数是名字会被转换为字符串, 第二个是文件的权限, 后面的是读写的函数
static struct kobj_attribute foo_attribute =
	__ATTR(foo, 0664, foo_show, foo_store);


static ssize_t led_show(struct kobject *kobj, struct kobj_attribute *attr,
		      char *buf)
{
	int var;

	if (strcmp(attr->attr.name, "led") == 0)
			var =123;

	return sprintf(buf, "%d\n", var);
}

static ssize_t led_store(struct kobject *kobj, struct kobj_attribute *attr,
		       const char *buf, size_t count)
{

	if (strcmp(attr->attr.name, "led") == 0){
		if(!memcmp(buf,"on",2)) {	
			iowrite32(0 << 4, GPIO1_DR);	
		} else if(!memcmp(buf,"off",3)) {
			iowrite32(1 << 4, GPIO1_DR);
		}
	}
	return count;
}

static struct kobj_attribute led_attribute =
    // 第一个是名字的字符串, 使用宏定义进行类型的转换
	__ATTR(led, 0664, led_show, led_store);

static struct attribute *attrs[] = {
	&foo_attribute.attr,
	&led_attribute.attr,
	NULL,	/* need to NULL terminate the list of attributes */
};

static struct attribute_group attr_group = {
	.attrs = attrs,
};

static struct kobject *led_kobj;

static int __init led_init(void)
{
	int retval;

	/* GPIO相关寄存器映射 */
  IMX6U_CCM_CCGR1 = ioremap(0x20c406c, 4);
	SW_MUX_GPIO1_IO04 = ioremap(0x20e006c, 4);
  SW_PAD_GPIO1_IO04 = ioremap(0x20e02f8, 4);
	GPIO1_GDIR = ioremap(0x0209c004, 4);
	GPIO1_DR = ioremap(0x0209c000, 4);


	/* 使能GPIO1时钟 */
	iowrite32(0xffffffff, IMX6U_CCM_CCGR1);

	/* 设置GPIO1_IO04复用为普通GPIO*/
	iowrite32(5, SW_MUX_GPIO1_IO04);
	
    /*设置GPIO属性*/
	iowrite32(0x10B0, SW_PAD_GPIO1_IO04);

	/* 设置GPIO1_IO04为输出功能 */
	iowrite32(1 << 4, GPIO1_GDIR);

	/* LED输出高电平 */
	iowrite32(1<< 4, GPIO1_DR);

	/* 创建一个kobject对象, 目录在sys的根目录*/
	led_kobj = kobject_create_and_add("led_kobject", NULL);
	if (!led_kobj)
		return -ENOMEM;

	/* 为kobject设置属性文件*/
	retval = sysfs_create_group(led_kobj, &attr_group);
	if (retval)
		kobject_put(led_kobj);

	return retval;

	return 0;
}

static void __exit led_exit(void)
{
	/* 取消映射 */
	iounmap(IMX6U_CCM_CCGR1);
	iounmap(SW_MUX_GPIO1_IO04);
	iounmap(SW_PAD_GPIO1_IO04);
	iounmap(GPIO1_DR);
	iounmap(GPIO1_GDIR);

	/* 注销字符设备驱动 */
	kobject_put(led_kobj);
}

module_init(led_init);
module_exit(led_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("embedfire ");
MODULE_DESCRIPTION("led_module");
MODULE_ALIAS("led_module");
```

```c
#define __ATTR(_name, _mode, _show, _store) {				\
	.attr = {.name = __stringify(_name),				\
		 .mode = VERIFY_OCTAL_PERMISSIONS(_mode) },		\
	.show	= _show,						\
	.store	= _store,						\
}

/* Indirect stringification.  Doing two levels allows the parameter to be a
 * macro itself.  For example, compile with -DFOO=bar, __stringify(FOO)
 * converts to "bar".
 */

#define __stringify_1(x...)	#x
#define __stringify(x...)	__stringify_1(x)

/* Permissions on a sysfs file: you didn't miss the 0 prefix did you? */
#define VERIFY_OCTAL_PERMISSIONS(perms)						\
	(BUILD_BUG_ON_ZERO((perms) < 0) +					\
	 BUILD_BUG_ON_ZERO((perms) > 0777) +					\
	 /* USER_READABLE >= GROUP_READABLE >= OTHER_READABLE */		\
	 BUILD_BUG_ON_ZERO((((perms) >> 6) & 4) < (((perms) >> 3) & 4)) +	\
	 BUILD_BUG_ON_ZERO((((perms) >> 3) & 4) < ((perms) & 4)) +		\
	 /* USER_WRITABLE >= GROUP_WRITABLE */					\
	 BUILD_BUG_ON_ZERO((((perms) >> 6) & 2) < (((perms) >> 3) & 2)) +	\
	 /* OTHER_WRITABLE?  Generally considered a bad idea. */		\
	 BUILD_BUG_ON_ZERO((perms) & 2) +					\
	 (perms))
#endif
```

![image-20250719130531021](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507191305098.png)