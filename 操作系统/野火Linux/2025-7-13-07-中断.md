# 通用中断处理器GIC

GIC用于处理单核或者多核的芯片中的处理资源

- ARM公司开发了4 个版本GIC规范 ，V1~V4, 板子使用的是V2
- ARMv7-A内核搭配GIC-400使用

#### GIC结构

GIC官方手册：ARM® Generic Interrupt Controller  

- V2最多支持 8 个内核

- 三类信号源：

    - 软件中断：用于多核通信，ID0~ID15
    - 私有中断：内核独有的中断，ID16~ID31
    - 共享中断：所有内核共享的中断，ID32~ID1019, 使用的比较多的

- 分发器：选择把中断信号发送到哪一个cpu接口单元

    ​	**有哪些相关寄存器？**

    - 中断数量：GICD_TYPER

    - 中断清除： GICD_ ICENABLERn
    - 中断使能：GICD_ISACTIVERn
    - 中断优先级设置：GICD_IPRIORITYR

- cpu接口单元：处理信号后，发送信号给CPU

    ​	**有哪些相关寄存器？**

    - 中断优先级数量：GICC_PMR
    - 抢占优先级和子优先级设置： GICC_BPR
    - 保存中断ID：GICC_IAR 
    - 通知cpu中断完成：GICC_EOIR

### 读取GIC基地址

#### 方法一

![image-20250713161938224](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507131619320.png)

#### 方法二：查询cp15协处理器

> CP15可以被配置为很多不同的寄存器, 用于不同的功能, 比如读取数据, 设置cache, mmu, 预测分支等

共有16个：c0~c15。**每个协处理器本身有多种含义，需逐步配置**

```
//设置并读协处理器
MRC {cond} p15, <opc1>, <Rn>, <CRn>, <CRm>, <opc2>
//设置并写协处理器
MCR {cond} p15, <opc1>, <Rn>, <CRn>, <CRm>, <opc2> 
```

- cond：执行条件，一般省略
- opc1：第一层设置
- Rn：通用寄存器
- CRn：要设置的协处理器
- CRm：第二层设置
- opc2：第三层设置

![image-20250713163559275](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507131635370.png)

> 可以使用命令`mrc p15,0,r0,c1,c0,0`读取的SCTLR(系统控制寄存器)

#####  CBAR寄存器

- GIC的地址

```
MRC p15, 4, r1, c15, c0, 0 ;获取 GIC 基地址
```

CRn=c15，opc1=4，CRm=c0，opc2=0, 使用这个命令可以把c15设置为CBAR寄存器, 同时使用r1读取GIC的基地址

![image-20250713164736843](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507131647939.png)

##### SCTLR寄存器

![image-20250713170056574](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507131700626.png)

使用bit13记录中断向量表的基地址

![image-20250713170128727](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507131701790.png)

#### VABR寄存器

 CRn=c12，opc1=0，CRm=c0，opc2=0

- bit5~31：中断向量表偏移地址

```
MRC p15, 0, <Rt>, c12, c0, 0 ;读取 VBAR 寄存器，数据保存到 Rt 中。
MCR p15, 0, <Rt>, c12, c0, 0 ;将 Rt 中的数据写到 VBAR寄存器中。
```

## 中断向量表

V7-A会使用两级查表

### 一级查表

自动跳转基址+偏移的方式, 这个表的起始位置一般在代码的起始位置, 基址为0, 获取的是终端的类型, 一般使用的是IRQ

| addr | TYPE                   | FUNCTION         | MODE   |
| ---- | ---------------------- | ---------------- | ------ |
| 0x00 | Reset                  | 复位中断         | SVC    |
| 0x04 | Undefined instructions | 未定义指令中断   | Undef  |
| 0x08 | Supervisor Call        | 软中断           | SYC    |
| 0x0C | Prefetch abort         | 指令预取中止中断 | ABT    |
| 0x10 | Data abort             | 数据访问中止中断 | ABT    |
| 0x14 | RESERVED               | 未使用           | 未使用 |
| 0x18 | IRQ interrupt          | IRQ 中断         | IRQ    |
| 0x1C | FIQ interrupt          | FIQ 中断         | FIQ    |

![image-20250713173722466](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507131737521.png)

### 二级查表

可以在官方芯片手册里面获取到, 这里的终端是共享中断, 需要有32位的偏移

![image-20250713174059043](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507131740116.png)

![image-20250713174219138](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507131742200.png)

```c
 void SystemIrqHandler(uint32_t giccIar)
{

  uint32_t intNum = giccIar & 0x3FFUL;

 
  /* j检查中断号是否合法 */
  if ((intNum == 1023) || (intNum >= NUMBER_OF_INT_VECTORS))
  {
    return;
  }

  /*如果对应的中断函数不为空，则调用该中断函数*/
  if(NULL != irqTable[intNum].irqHandler)
      irqTable[intNum].irqHandler(giccIar, irqTable[intNum].userParam);

  return;
}
```



### 代码实现

```assembly
.global _start

_start:

    ldr     pc, =Reset_Handler           /* Reset                  */
    ldr     pc, =Undefined_Handler       /* Undefined instructions */
    ldr     pc, =SVC_Handler             /* Supervisor Call        */
    ldr     pc, =PrefAbort_Handler       /* Prefetch abort         */
    ldr     pc, =DataAbort_Handler       /* Data abort             */
    .word   0                            /* RESERVED               */
    ldr     pc, =IRQ_Handler             /* IRQ interrupt          */
    ldr     pc, =FIQ_Handler             /* FIQ interrupt          */

Reset_Handler:
    @ 禁止 IRQ 中断
    cpsid   i 

    @ 定义IRQ模式的栈地址, cps可以控制cpsr寄存器, 控制状态为IRQ模式
    cps     #0x12                
    ldr     sp, =0x9FF00000

#if 0
    mrs r0, cpsr
    bic r0, r0, #0x1f @将 r0 的低 5 位清零，也就是 cpsr 的 M0~M4 
    orr r0, r0, #0x12 @r0 或上 0x12,表示使用 IRQ 模式 
    msr cpsr, r0 @将 r0 的数据写入到 cpsr 中 
    ldr sp, =0x80600000 @IRQ 模式栈首地址为 0X80600000,大小为 2MB 
#endif


	@ 设置栈地址为64M,0X80000000~0XA0000000(512MB), 进入SVC模式
	cps     #0x13
    ldr sp, =0x84000000

	@ 打开全局中断 
	cpsie i				

	@重定位data段 
	bl copy_data

	@清除bss段 
	bl clean_bss

	@ 跳转main函数
    b main 

IRQ_Handler:

	push {r0-r12, lr}		  @保存r0-r2，lr寄存器 
	mrs r0, spsr				 @读取spsr寄存器 
	push {r0}						@保存spsr寄存器 

	mrc p15, 4, r1, c15, c0, 0   @从CP15的C0寄存器内的值到R1寄存器中						
	add r1, r1, #0X2000				@ GIC基地址加0X2000，也就是GIC的CPU接口端基地址
	ldr r0, [r1, #0XC]				 	@ GIC的CPU接口端基地址加0X0C就是GICC_IAR寄存器，GICC_IAR寄存器保存这当前发生中断的中断号
	push {r0, r1}				 			@保存r0,r1 
	
	bl SystemIrqHandler			@ 运行C语言中断处理函数，带有一个参数，保存在R0寄存器中 

	pop {r0, r1}				
	str r0, [r1, #0X10]					@ 中断执行完成，通知cpu

	pop {r0}						
	msr spsr_cxsf, r0				  @ 恢复spsr

	pop {r0-r12, lr} 			@恢复r0-r2，lr寄存器 
	subs pc, lr, #4				 @将lr-4赋给pc 

 FIQ_Handler:
	ldr r0, =FIQ_Handler	
	bx r0	
 
 Undefined_Handler:
	ldr r0, =Undefined_Handler
	bx r0

SVC_Handler:
	ldr r0, =SVC_Handler
	bx r0

PrefAbort_Handler:
	ldr r0, =PrefAbort_Handler	
	bx r0

DataAbort_Handler:
	ldr r0, =DataAbort_Handler
	bx r0

NotUsed_Handler:
	ldr r0, =NotUsed_Handler
	bx r0

copy_data:
	ldr r1, =data_load_addr  @ data段的加载地址
	ldr r2, =data_start  @data段重定位地址
	ldr r3, =data_end  @data段结束地址

	loop:
	ldrb r4, [r1] @从r1读到r4 
	strb r4, [r2] @r4存放到r2 
	add r1, r1, #1@复制下1个字节
	add r2, r2, #1 
	cmp r2, r3 @ r2 、r3比较 
	bne loop  @ 如果没拷贝完则重复拷贝 

	mov pc, lr

clean_bss:
	ldr r1, =__bss_start  @将链接脚本变量__bss_start变量保存于r1
    ldr r2, =__bss_end  @将链接脚本变量__bss_end变量保存于r2
	mov r3, #0

clean:
	strb r3, [r1]  @将当前地址下的数据清零
	add r1, r1, #1  @将r1内存储的地址+4
	cmp r1, r2  @相等：清零操作结束；否则继续执行clean函数清零bss段
	bne clean

	mov pc, lr
```

> ### 1. `mrc p15, 4, r1, c15, c0, 0` 的作用
>
> armasm
>
> ```
> mrc p15, 4, r1, c15, c0, 0   @ 关键指令
> ```
>
> - **功能**：从CP15协处理器的寄存器中读取GIC的**分发器(Distributor)基地址**。
> - **寄存器说明**：
>     - `p15`：协处理器编号
>     - `opc1=4`：操作码1
>     - `CRn=c15, CRm=c0`：指定协处理器寄存器
>     - `opc2=0`：操作码2
> - **返回值**：ARM内核通过此操作将**GIC分发器的物理基地址**存入`r1`寄存器。这是由硬件确定的固定地址。
>
> ### 2. `add r1, r1, #0X2000` 的作用
>
> armasm
>
> ```
> add r1, r1, #0X2000  @ 地址转换
> ```
>
> - **功能**：将分发器基地址偏移`0x2000`，得到**CPU接口(CPU Interface)的基地址**。
> - **GIC架构划分**：
>     - `GIC Distributor` (基地址 + `0x0000`)：全局中断管理（优先级/路由等）
>     - `GIC CPU Interface` (基地址 + `0x2000`)：CPU核心相关的中断控制（应答/完成等）
> - **为何偏移0x2000**：这是ARM GICv2架构的标准偏移量，代表从分发器到CPU接口的固定地址距离。
>
> ------
>
> ### 地址使用详解
>
> armasm
>
> ```
> ldr r0, [r1, #0XC]    @ r1 + 0x0C → GICC_IAR
> str r0, [r1, #0X10]   @ r1 + 0x10 → GICC_EOIR
> ```
>
> - **GICC_IAR (0x0C)**：中断应答寄存器
>     - 读取后返回当前中断号（如0x42代表SPI#34）
>     - 自动标记该中断为"处理中"
> - **GICC_EOIR (0x10)**：中断结束寄存器
>     - 写入相同中断号通知GIC中断处理完成
>     - 清除"处理中"状态，允许新中断
>
> ------
>
> ### 完整流程总结
>
> 1. **保存现场**：压栈寄存器及`spsr`
> 2. **获取GIC地址**：
>     - 读CP15 → **GIC Distributor基地址** (e.g., `0xA0020000`)
>     - 加`0x2000` → **CPU Interface基地址** (e.g., `0xA0022000`)
> 3. **处理中断**：
>     - 读`GICC_IAR`获取中断号 → `r0`
>     - 调用C函数`SystemIrqHandler(r0)`
>     - 写`GICC_EOIR`通知完成
> 4. **恢复现场**：弹栈并返回`lr-4`（ARM流水线修正）
>
> > - 取指令（pc）
> > - 译指令
> > - 执行指令
> >
> > ```
> > lr = pc = 当前执行指令+8
> > 当前执行指令的下一条：lr-4
> > ```
> >
>
> > **关键点**：CP15返回的是GIC Distributor的硬件固定地址，通过`+0x2000`偏移转换到CPU Interface地址空间，这是GICv2标准设计。所有后续操作（中断号获取/完成通知）都基于CPU Interface地址进行。

## 初始化中断

```c
/*中断初始化*/
void irq_init()
{
    GIC_Init();
   
    for(int i = 0; i < NUMBER_OF_INT_VECTORS; i++)
	{
		system_register_irqhandler((IRQn_Type)i, NULL, NULL);
	}
	// 设置终端向量表的位置
     __set_VBAR((uint32_t)0x80002000);
}
```

初始化的函数在库函数里面

```c
/* For simplicity, we only use group0 of GIC */
FORCEDINLINE __STATIC_INLINE void GIC_Init(void)
{
  uint32_t i;
  uint32_t irqRegs;
  /*获取GIC地址*/
  GIC_Type *gic = (GIC_Type *)(__get_CBAR() & 0xFFFF0000UL);
  /*支持共享中断数量*/
  irqRegs = (gic->D_TYPER & 0x1FUL) + 1;

  /* On POR, all SPI is in group 0, level-sensitive and using 1-N model */

  /* Disable all PPI, SGI and SPI */
  for (i = 0; i < irqRegs; i++)
    gic->D_ICENABLER[i] = 0xFFFFFFFFUL;

  /* Make all interrupts have higher priority */
  /*设置中断优先级数为32*/
  gic->C_PMR = (0xFFUL << (8 - __GIC_PRIO_BITS)) & 0xFFUL;

  /* No subpriority, all priority level allows preemption */
  /*设置5级抢占优先级，3级子优先级*/
  gic->C_BPR = 7 - __GIC_PRIO_BITS;

  /* Enable group0 distribution */
  /*使能第0组中断*/
  gic->D_CTLR = 1UL;

  /* Enable group0 signaling */
  gic->C_CTLR = 1UL;
}
```

> #### GIC相关寄存器
>
> - 分发器
>
>     - 中断数量：GICD_TYPER
>     - 中断清除： GICD_ ICENABLERn
>     - 中断使能：GICD_ISACTIVERn
>     - 中断优先级设置：GICD_IPRIORITYR
>
>     详见GIC官方手册
>
>     **4.3 Distributor register descriptions**  
>
> - cpu接口单元
>
>     - 中断优先级数量：GICC_PMR
>     - 抢占优先级和子优先级设置： GICC_BPR
>     - 保存中断ID：GICC_IAR 
>     - 通知cpu中断完成：GICC_EOIR
>
>     详见GIC官方手册
>
>     **4.4 CPU interface register descriptions**  
>
> #### GPIO中断相关寄存器
>
> - gpio中断触发类型:高/低电平、上升/下降沿
>
>     - GPIO5_ICR1(0~15)
>
>     - GPIO5_ICR2(16~31)
>
> - gpio中断屏蔽
>
>     - GPIO5_IMR
>
> - gpio中断状态寄存器
>
>     - GPIO5_ISR
>
> - gpio双边缘触发
>
>     - GPIO5_EDGE_SEL
>
>     详见芯片数据手册
>
>     **28.5 GPIO Memory Map/Register Definition** 

```c
FORCEDINLINE __STATIC_INLINE uint32_t __get_CBAR(void)
{
  return __MRC(15, 4, 15, 0, 0);
}


#define __STRINGIFY(x) #x
/* C语言实现写cp15协处理器 */
#define __MCR(coproc, opcode_1, src, CRn, CRm, opcode_2)                          \
    __ASM volatile ("MCR " __STRINGIFY(p##coproc) ", " __STRINGIFY(opcode_1) ", " \
                    "%0, " __STRINGIFY(c##CRn) ", " __STRINGIFY(c##CRm) ", "      \
                    __STRINGIFY(opcode_2)                                         \
                    : : "r" (src) )

/* C语言实现读cp15协处理器 */                    
#define __MRC(coproc, opcode_1, CRn, CRm, opcode_2)                               \
  ({                                                                              \
    uint32_t __dst;                                                               \
    __ASM volatile ("MRC " __STRINGIFY(p##coproc) ", " __STRINGIFY(opcode_1) ", " \
                    "%0, " __STRINGIFY(c##CRn) ", " __STRINGIFY(c##CRm) ", "      \
                    __STRINGIFY(opcode_2)                                         \
                    : "=r" (__dst) );                                             \
    __dst;                                                                        \
  })
```

> C语言读写cp15协处理器
>
> `__ASM ( code     : 输出操作数列表    : 输入操作数列表  );`
>
> - code
>
>     - 具体操作指令(字符串表示)
>
>     - #是把宏参数变为一个字符串
>
>     - ##是把两个参数连接在一起
>
>     __STRINGIFY(p##coproc) ", ->"p15"
>
> - 操作数
>
>     通过%加数字引用，比如%0 引用第一个操作数，%1 引用第二个操作数
>
>     r：将变量放入通用寄存器, 实际是把返回值放入__dst这个参数里面
>
> 处理以后得是``

## 位置无关码和重定位

位置无关的代码可以在任意的合法内存里面运行, 位置相关的代码是需要放到对应的位置里面

一般访问的.bss, .data, .rodata段里面的数据是位置无关的, 还有一部分特殊的.text代码, 比如进行绝对地址的跳转

