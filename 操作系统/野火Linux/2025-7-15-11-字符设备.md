# 字符设备

![image-20250901220422532](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509012204612.png)

#### (1) **字符设备注册流程**

- **步骤 1**：
    调用 `__register_chrdev_region()` → 创建/更新 `char_device_struct`，添加到 `chrdevs[]` 哈希表。
- **步骤 2**：
    调用 `cdev_add()` → 最终触发 `kobj_map(cdev_map, ...)`：
    - 向全局 `kobj_map` 实例 **`cdev_map`**（专用于字符设备）插入一个 `probe`。
    - `probe->data` 指向字符设备的 `struct cdev`。
    - `probe->get` 设置为默认回调 `exact_match()`（通过设备号查找 `cdev`）。

#### (2) **字符设备打开流程**

- **步骤 1**：
    用户调用 `open("/dev/char_dev")` → VFS 通过设备号查找操作函数集。
- **步骤 2**：
    调用 `kobj_lookup(cdev_map, dev_t, &idx)`：
    - 在 `cdev_map` 的哈希表中搜索匹配的 `probe`。
    - 执行 `probe->get()` 回调 → 返回 `cdev->kobj`。
- **步骤 3**：
    通过 `container_of` 从 `kobject` 获取 `struct cdev` → 访问其 `file_operations`。

> - **`char_device_struct` 为静态管理**：
>     记录设备号分配情况（防止冲突），维护 `major/minor` 到 `cdev` 的基本映射。
> - **`kobj_map` 为动态映射**：
>     提供高效的设备号（`dev_t`）到内核对象（`kobject`）的运行时查找，实际用于设备操作。

#### Linux哲学

一切皆文件

#### 如何把字符设备抽象成文件

##### 复习文件描述符本质

open()函数,在文件系统中找到指定文件的操作接口，绑定到进程`task_srtuct->files_struct->fd_array[]->file_operations`

实际实现的时候需要read, write等文件操控函数的实现

#### 驱动层原理

把file_operations文件操作接口注册到内核，内核通过主次设备号来登记记录它

- 构造驱动基本对象：struct cdev，里面记录具体的file_operations

    ```c
    cdev_init()
    ```

    > 实际是建立两个hash表
    >
    > - chrdevs：登记设备号, 看一下是不是被使用了
    >
    >     ```
    >     __register_chrdev_region()
    >     ```
    >
    >     > - **注册函数**：`__register_chrdev_region()`
    >     >     - 申请主设备号（如 255）
    >     >     - 指定次设备号范围（如 0~255）
    >     >     - 冲突检测：防止重复注册相同设备号
    >
    > - cdev_map->probe：保存驱动基本对象`struct cdev`
    >
    >     ```
    >     cdev_add()
    >     ```
    >
    >     > **注册流程**：
    >     >
    >     > 1. **初始化**：`cdev_init(&my_cdev, &my_fops);`
    >     >
    >     >     - 绑定 `file_operations` 到 `cdev`
    >     >
    >     > 2. **添加到系统**：`cdev_add(&my_cdev, dev, count);`
    >     >
    >     >     - `dev`：起始设备号（主+次）
    >     >     - `count`：连续设备数量
    >     >
    >     > 3. **存入 cdev_map**：
    >     >
    >     >     ```c
    >     >     struct kobj_map *cdev_map; // 全局映射表
    >     >     kobj_map(cdev_map, dev, count, NULL, exact_match, exact_lock, my_cdev);
    >     >     ```
    >     >
    >     >     - 生成 `dev_t → cdev` 的映射关系

#### 文件系统层原理

mknod指令+主从设备号, 生成一个实际用于读写控制的文件

- 构建一个新的设备文件
- 通过主次设备号在cdev_map中找到cdev->file_operations

- 把cdev->file_operations绑定到新的设备文件中

到这里，应用程序就可以使用open()、write()、read()等函数来控制设备文件了

## 设备号的组成与哈希表

#### 设备号

记录在文件`ebf-buster-linux/include/linux/kdev_t.h`

```c
#define MINORBITS	20
#define MINORMASK	((1U << MINORBITS) - 1)

#define MAJOR(dev)	((unsigned int) ((dev) >> MINORBITS))
#define MINOR(dev)	((unsigned int) ((dev) & MINORMASK))
#define MKDEV(ma,mi)	(((ma) << MINORBITS) | (mi))

理论取值范围
主设备号：2^12=1024*4=4k
次设备号：2^20=1024*1024=1M
```

- 已注册的设备号可以使用`cat /proc/devices`查看
- 内核是希望一个设备驱动(file_operation)可以独自占有一个主设备号和多个次设备号，而通常一个设备文件绑定一个主设备号和一个次设备号，所以设备驱动与设备文件是一对一或者一对多的关系。

> 通常情况下主设备号相同的话使用的file_operation是一样的

#### hash table

哈希表、散列表

- 数组的优缺点：查找快，增删元素效率低，容量固定
- 链表的优缺点：查找慢，增删元素效率高，容量不限
- 哈希表：数组+链表

    - 以主设备号为编号，使用哈希函数`f(major)=major%255`来计算数组下标
    - 主设备号冲突(如0、255)，则以次设备号为比较值来排序**链表**节点。

> 使用一个数组记录链表的头结点

哈希函数的设计目标：链表节点尽量平均分布在各个数组元素中，提高查询效率

## 从源码看如何管理设备号

##### 关键数据结构

ebf-buster-linux/fs/char_dev.c

```c
static struct char_device_struct {
	//指向下一个链表节点
    struct char_device_struct *next;
	//主设备号
    unsigned int major;
	//次设备号
    unsigned int baseminor;
	//次设备号的数量
    int minorct;
	//设备的名称
    char name[64];
	//内核字符对象(已废弃)
    struct cdev *cdev;      /* will die */

} *chrdevs[CHRDEV_MAJOR_HASH_SIZE]; // 一共有255个, 用于管理设备号
```

> 一个专门用于设备号管理的结构, 记录字符设备号范围（主设备号 + 次设备号范围）与字符设备驱动程序（`struct cdev`）的映射关系。

#### __register_chrdev_region函数分析

ebf-buster-linux/fs/char_dev.c

保存新注册的设备号到chrdevs哈希表中，防止设备号冲突

分析结论：

- 主设备号为0，动态分配设备号：

    - 优先使用：255~234
- 其次使用：511~384
- 主设备号最大为512

```c
/*
 * Register a single major with a specified minor range.
 *
 * If major == 0 this functions will dynamically allocate a major and return
 * its number.
 *
 * If major > 0 this function will attempt to reserve the passed range of
 * minors and will return zero on success.
 *
 * Returns a -ve errno on failure.
 */
static struct char_device_struct *
__register_chrdev_region(unsigned int major, unsigned int baseminor,
			   int minorct, const char *name)
{
	struct char_device_struct *cd, **cp;
	int ret = 0;
	int i;
	
	cd = kzalloc(sizeof(struct char_device_struct), GFP_KERNEL);
	if (cd == NULL)
		return ERR_PTR(-ENOMEM);
	// 获取一个互斥锁
	mutex_lock(&chrdevs_lock);
	// 动态分配一个主设备号
	if (major == 0) {
		ret = find_dynamic_major();
		if (ret < 0) {
			pr_err("CHRDEV \"%s\" dynamic allocation region is full\n",
			       name);
			goto out;
		}
		major = ret;
	}
	// 判断一下是不是合法, 最多512个
	if (major >= CHRDEV_MAJOR_MAX) {
		pr_err("CHRDEV \"%s\" major requested (%u) is greater than the maximum (%u)\n",
		       name, major, CHRDEV_MAJOR_MAX-1);
		ret = -EINVAL;
		goto out;
	}
	
	cd->major = major;
	cd->baseminor = baseminor;
	cd->minorct = minorct;
	strlcpy(cd->name, name, sizeof(cd->name));

	i = major_to_index(major);

	for (cp = &chrdevs[i]; *cp; cp = &(*cp)->next)
		if ((*cp)->major > major ||
		    ((*cp)->major == major &&
		     (((*cp)->baseminor >= baseminor) ||
		      ((*cp)->baseminor + (*cp)->minorct > baseminor))))
			break;

	/* Check for overlapping minor ranges.  查看一下子设备号范围是不是会冲突*/
	if (*cp && (*cp)->major == major) {
		int old_min = (*cp)->baseminor;
		int old_max = (*cp)->baseminor + (*cp)->minorct - 1;
		int new_min = baseminor;
		int new_max = baseminor + minorct - 1;

		/* New driver overlaps from the left.  */
		if (new_max >= old_min && new_max <= old_max) {
			ret = -EBUSY;
			goto out;
		}

		/* New driver overlaps from the right.  */
		if (new_min <= old_max && new_min >= old_min) {
			ret = -EBUSY;
			goto out;
		}

		if (new_min < old_min && new_max > old_max) {
			ret = -EBUSY;
			goto out;
		}

	}
	// 插入链表
	cd->next = *cp;
	*cp = cd;
	mutex_unlock(&chrdevs_lock);
	return cd;
out:
	mutex_unlock(&chrdevs_lock);
	kfree(cd);
	return ERR_PTR(ret);
}
```

动态获取一个空闲的数组位置

```c
static int find_dynamic_major(void)
{
	int i;
	struct char_device_struct *cd;
	// 优先234-254
	for (i = ARRAY_SIZE(chrdevs)-1; i >= CHRDEV_MAJOR_DYN_END; i--) {
        // 记录在链表的第一位
		if (chrdevs[i] == NULL)
			return i;
	}
	// 511 - 384的设备
	for (i = CHRDEV_MAJOR_DYN_EXT_START;
	     i >= CHRDEV_MAJOR_DYN_EXT_END; i--) {
        // major_to_index 哈希函数, 实际是 % 255, 遍历一下链表
		for (cd = chrdevs[major_to_index(i)]; cd; cd = cd->next)
			if (cd->major == i)
				break;

		if (cd == NULL)
			return i;
	}

	return -EBUSY;
}
```



## 从源码看如何保存file_operation接口

#### 关键数据结构梳理

`kobj_map` 是一个全局的注册表/映射表，而 `cdev` 是被注册到这个表中的项目。它们共同协作，实现了字符设备号（主设备号、次设备号）到具体字符设备驱动程序（`cdev` 结构体）的动态查找和关联。

kernel/ebf-buster-linux/include/linux/cdev.h

字符设备管理对象, 记录实际的设备的数据

```c
struct cdev {
	//内核驱动基本对象, 继承上一级
    struct kobject kobj;
	//相关内核模块
    struct module *owner;
	//设备驱动接口, 实际调用的各种接口
    const struct file_operations *ops;
	//链表节点
    struct list_head list;
	//设备号
    dev_t dev;
	//次设备号的数量
    unsigned int count;
} __randomize_layout;
```

ebf-buster-linux/fs/char_dev.c

另一个哈希表probes, 用于记录file_operations这个接口

```c
struct kobj_map {
	struct probe {
		//指向下一个链表节点
		struct probe *next;
		//设备号
		dev_t dev;
		//次设备号的数量
		unsigned long range;
		struct module *owner;
		kobj_probe_t *get;
		int (*lock)(dev_t, void *);
		//空指针，内核常用技巧, 一般用于记录struct cdev这个结构体
		void *data;
	} *probes[255];
    // 互斥锁
	struct mutex *lock;
};
```

> 是**通用设备号映射框架**, 管理设备号（`dev_t`）到内核对象（`kobject`）的动态映射。用于字符设备（`cdev_map`）、块设备（`bdev_map`）等。

#### cdev_init函数分析

实际先比喻这个函数使用`register_chrdev`函数作为`cdev_init + cdev_add`更方便

ebf-buster-linux/fs/char_dev.c

记录一下实际的操作函数

```c
/**
 * cdev_init() - initialize a cdev structure
 * @cdev: the structure to initialize
 * @fops: the file_operations for this device
 *
 * Initializes @cdev, remembering @fops, making it ready to add to the
 * system with cdev_add().
 */
void cdev_init(struct cdev *cdev, const struct file_operations *fops)
{
	memset(cdev, 0, sizeof *cdev);
	INIT_LIST_HEAD(&cdev->list);
	kobject_init(&cdev->kobj, &ktype_cdev_default);
	cdev->ops = fops; // 记录一下file_operations
}
```

保存file_operation到cdev中

#### cdev_add函数分析

ebf-buster-linux/fs/char_dev.c

根据哈希函数保存cdev到probes哈希表中，方便内核查找file_operation使用

```c
/**
 * cdev_add() - add a char device to the system
 * @p: the cdev structure for the device
 * @dev: the first device number for which this device is responsible
 * @count: the number of consecutive minor numbers corresponding to this
 *         device
 *
 * cdev_add() adds the device represented by @p to the system, making it
 * live immediately.  A negative error code is returned on failure.
 */
int cdev_add(struct cdev *p, dev_t dev, unsigned count)
{
	int error;
	// 记录一下设备号以及设备数量
	p->dev = dev;
	p->count = count;
	// 实际的填充数据, 记录到prob里面
	error = kobj_map(cdev_map, dev, count, NULL,
			 exact_match, exact_lock, p);
	if (error)
		return error;

	kobject_get(p->kobj.parent);

	return 0;
}
```

```c
int kobj_map(struct kobj_map *domain, dev_t dev, unsigned long range,
	     struct module *module, kobj_probe_t *probe,
	     int (*lock)(dev_t, void *), void *data)
{
    // 计算一下次设备号是不是溢出, 溢出的话计算一下需要几个主设备号
	unsigned n = MAJOR(dev + range - 1) - MAJOR(dev) + 1;
	unsigned index = MAJOR(dev);
	unsigned i;
	struct probe *p;
	// 计算一下主设备号的数量
	if (n > 255)
		n = 255;
	// 获取probe结构体
	p = kmalloc_array(n, sizeof(struct probe), GFP_KERNEL);
	if (p == NULL)
		return -ENOMEM;
	// 使用probe结构体保存一下cdev的数据
	for (i = 0; i < n; i++, p++) {
		p->owner = module;
		p->get = probe;
		p->lock = lock;
		p->dev = dev;
		p->range = range;
		p->data = data;
	}
	mutex_lock(domain->lock);
	for (i = 0, p -= n; i < n; i++, p++, index++) {
		struct probe **s = &domain->probes[index % 255];
        // 按照范围的大小进行排序, 获取在这个链表的位置
		while (*s && (*s)->range < range)
			s = &(*s)->next;
		p->next = *s;
		*s = p;
	}
	mutex_unlock(domain->lock);
	return 0;
}
```

## 如何创建一个设备文件

#### mknod命令

创建指定类型的特殊文件

mknod --help

```
用法：mknod [选项]... 名称 类型 [主设备号 次设备号]
Create the special file NAME of the given TYPE.
...
当类型为"p"时可不指定主设备号和次设备号，否则它们是必须指定的。
如果主设备号和次设备号以"0x"或"0X"开头，它们会被视作十六进制数来
解析；如果以"0"开头，则被视作八进制数；其余情况下被视作十进制数。
可用的类型包括：

  b      创建(有缓冲的)区块特殊文件
  c, u   创建(没有缓冲的)字符特殊文件
  p      创建先进先出(FIFO)特殊文件, 一般不需要设备号
```

![image-20250717172315583](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507171723834.png)

> vfs是虚拟文件系统, 根据文件系统的类型去使用实际的文件系统进行创建, 最后实际是建立一个inode节点
>
> 在Linux和其他类Unix操作系统中，inode（索引节点）是用来存储文件元数据的一个数据结构。它相当于文件的“身份证”或“档案卡”，描述了文件的各种信息，但不包含文件名本身。
>
> 一个inode主要包含以下内容：
>
> - 文件的类型（普通文件、目录、符号链接等）
> - 文件的权限（读、写、执行权限）
> - 文件所有者的用户ID（UID）
> - 文件所属组的组ID（GID）
> - 文件的大小
> - 文件的创建、修改、访问时间戳
> - 指向存储文件内容的磁盘块的指针（数据块地址）
>
> 每个文件在创建时都会分配一个唯一的inode编号，操作系统通过这个编号找到文件的所有元数据。文件名是存储在目录中的条目，目录实际上是从文件名到inode编号的映射。
>
> ![image-20250717173334639](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507171733711.png)

#### init_special_inode函数分析

ebf-buster-linux/fs/inode.c

判断文件的inode类型，如果是字符设备类型，则把def_chr_fops作为该文件的操作接口，并把设备号记录在inode->i_rdev。

```c
// mode是文件的权限, rdev是设备号
void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev)
{
	inode->i_mode = mode;
	if (S_ISCHR(mode)) {
		inode->i_fop = &def_chr_fops; // 初始化一下通用的操作接口(之后这个接口调用自己构建的)
		inode->i_rdev = rdev; // 记录一下设备号
	} else if (S_ISBLK(mode)) {
		inode->i_fop = &def_blk_fops;
		inode->i_rdev = rdev;
	} else if (S_ISFIFO(mode))
		inode->i_fop = &pipefifo_fops;
	else if (S_ISSOCK(mode))
		;	/* leave it no_open_fops */
	else
		printk(KERN_DEBUG "init_special_inode: bogus i_mode (%o) for"
				  " inode %s:%lu\n", mode, inode->i_sb->s_id,
				  inode->i_ino);
}
```

## open函数如何查找file_operation接口

![image-20250717191133208](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507171911323.png)

- get_unused_fd_flags
    - 为本次操作分配一个未使用过的文件描述符

- do_file_open
    - 生成一个空白struct file结构体
    - 从文件系统中查找到文件对应的inode

- + do_dentry_open

    + 获取到实际inode的chrdev_open 函数, 并进行调用, 记录在任务的文件句柄里面

```c
static int do_dentry_open(struct file *f,
			  struct inode *inode,
			  int (*open)(struct inode *, struct file *))
{
	...
	/*把inode的file_operation赋值给struct file的f_op*/
	f->f_op = fops_get(inode->i_fop); // 这个参数是在创建文件的时候初始化的
	...
	if (!open)
		open = f->f_op->open;
	if (open) {
		error = open(inode, f);
		if (error)
			goto cleanup_all;
	}
	...
}
```

- def_chr_fops->chrdev_open 实际用于调用不同的cdev注册的operation的函数

    ​	ebf-buster-linux/fs/char_dev.c

```c
static int chrdev_open(struct inode *inode, struct file *filp)
{
	const struct file_operations *fops;
	struct cdev *p;
	struct cdev *new = NULL;
	...
	struct kobject *kobj;
	int idx;
	/*从内核哈希表cdev_map中，根据设备号查找自己注册的sturct cdev，获取cdev中的file_operation接口*/
	kobj = kobj_lookup(cdev_map, inode>i_rdev,&idx);
	new = container_of(kobj, struct cdev, kobj);
	...
	inode->i_cdev = p = new;
	...
	fops = fops_get(p->ops);
	...
	/*把cdev中的file_operation接口赋值给struct file的f_op*/
	replace_fops(filp, fops);
	
	/*调用自己实现的file_operation接口中的open函数*/
	if (filp->f_op->open) {
		ret = filp->f_op->open(inode, filp);
		if (ret)
			goto out_cdev_put;
	}
	...
}
```

## 代码实现

1. 可以直接使用`register_chrdev`一个函数实现所有的功能
2. 使用分开的函数实现

+ 使用alloc_chrdev_region动态分配一个内存
+ 使用函数cdev_init初始化一个cdev结构体
+ 使用cdev_add添加设备号等信息

`alloc_chrdev_region(dev_t *, baseminor, count, name)`

> 分别是输出参数, 起始的设备号, 分配的数量以及设备的名字

```c
//第一步
//采用动态分配的方式，获取设备编号，次设备号为0，
//设备名称为EmbedCharDev，可通过命令cat  /proc/devices查看
//DEV_CNT为1，当前只申请一个设备编号
ret = alloc_chrdev_region(&led_devno, 0, DEV_CNT, DEV_NAME);
if(ret < 0){
printk("fail to alloc led_devno\n");
goto alloc_err;
}

led_chrdev_class = class_create(THIS_MODULE, "led_chrdev");
//第二步
//关联字符设备结构体cdev与文件操作结构体file_operations
cdev_init(&led_chr_dev, &led_chr_dev_fops);
//第三步
//添加设备至cdev_map散列表中
ret = cdev_add(&led_chr_dev, led_devno, DEV_CNT);
```

+ 使用register_chrdev实现

```c
#include <linux/module.h>
#include <linux/init.h>
#include <linux/kernel.h>

#include <linux/fs.h>
#include <linux/uaccess.h>
#include <asm/io.h>

#define DEV_MAJOR		0		/* 动态申请主设备号 */
#define DEV_NAME		"red_led" 	/*led设备名字 */

/* GPIO虚拟地址指针 */
static void __iomem *IMX6U_CCM_CCGR1;
static void __iomem *SW_MUX_GPIO1_IO04;
static void __iomem *SW_PAD_GPIO1_IO04;
static void __iomem *GPIO1_DR;
static void __iomem *GPIO1_GDIR;

static int led_open(struct inode *inode, struct file *filp)
{
	return 0;
}

static ssize_t led_read(struct file *filp, char __user *buf, size_t cnt, loff_t *offt)
{
	return -EFAULT; // 这里不可以返回一个0, 这个实际表示的是长度一直为0会卡住
}

static ssize_t led_write(struct file *filp, const char __user *buf, size_t cnt, loff_t *offt)
{

	unsigned char databuf[10];

	if(cnt >10)
		cnt =10;
		
    /*从用户空间拷贝数据到内核空间, 避免访问非法的内存*/
    if(copy_from_user(databuf, buf, cnt)){
		return -EIO;
	}
    	
	if(!memcmp(databuf,"on",2)) {	
		iowrite32(0 << 4, GPIO1_DR);	
	} else if(!memcmp(databuf,"off",3)) {
		iowrite32(1 << 4, GPIO1_DR);
	}
	/*写成功后，返回写入的字数*/
	return cnt;
}

static int led_release(struct inode *inode, struct file *filp)
{
	return 0;
}

/* 自定义led的file_operations 接口*/
static struct file_operations led_fops = {
	.owner = THIS_MODULE,
	.open = led_open,
	.read = led_read,
	.write = led_write,
	.release = 	led_release, // 对应close当所有的打开都释放的时候调用这个
};

int major = 0;
static int __init led_init(void)
{
	
	/* GPIO相关寄存器映射 */
  	IMX6U_CCM_CCGR1 = ioremap(0x20c406c, 4);
	SW_MUX_GPIO1_IO04 = ioremap(0x20e006c, 4);
  	SW_PAD_GPIO1_IO04 = ioremap(0x20e02f8, 4);
	GPIO1_GDIR = ioremap(0x0209c004, 4);
	GPIO1_DR = ioremap(0x0209c000, 4);


	/* 使能GPIO1时钟 */
	iowrite32(0xffffffff, IMX6U_CCM_CCGR1);

	/* 设置GPIO1_IO04复用为普通GPIO*/
	iowrite32(5, SW_MUX_GPIO1_IO04);
	
    /*设置GPIO属性*/
	iowrite32(0x10B0, SW_PAD_GPIO1_IO04);

	/* 设置GPIO1_IO04为输出功能 */
	iowrite32(1 << 4, GPIO1_GDIR);

	/* LED输出高电平 */
	iowrite32(1<< 4, GPIO1_DR);

	/* 注册字符设备驱动 */
	major = register_chrdev(DEV_MAJOR, DEV_NAME, &led_fops);
    printk(KERN_ALERT "led major:%d\n",major);

	return 0;
}

static void __exit led_exit(void)
{
	/* 取消映射 */
	iounmap(IMX6U_CCM_CCGR1);
	iounmap(SW_MUX_GPIO1_IO04);
	iounmap(SW_PAD_GPIO1_IO04);
	iounmap(GPIO1_DR);
	iounmap(GPIO1_GDIR);

	/* 注销字符设备驱动 */
	unregister_chrdev(major, DEV_NAME);
}


module_init(led_init);
module_exit(led_exit);

MODULE_LICENSE("GPL2");
MODULE_AUTHOR("embedfire ");
MODULE_DESCRIPTION("led_module");
MODULE_ALIAS("led_module");
```

#### 驱动模块初始化

##### 地址映射

GPIO寄存器物理地址和虚拟地址映射

ebf-buster-linux/arch/arm/include/asm/io.h

```c
void __iomem *ioremap(resource_size_t res_cookie, size_t size)
```

参数：

- res_cookie：物理地址

- size：映射长度

返回值：

- void * 类型的指针，指向被映射的虚拟地址
- __iomem 主要是用于编译器的检查地址在内核空间的有效性

##### 虚拟地址读写

```c
readl()/ writel()	//过时

void iowrite32(u32 b, void __iomem *addr)   //写入一个双字（32bit）

unsigned int ioread32(void __iomem *addr)   //读取一个双字（32bit）
```

检查cpu大小端，调整字节序，以提高驱动的可移植性

#### 自定义led的file_operations接口

````c
static struct file_operations led_fops = {
	.owner = THIS_MODULE,
	.open = led_open,
	.read = led_read,
	.write = led_write,
	.release = led_release,
};
````

- owner：设置驱动接口关联的内核模块，防止驱动程序运行时内核模块被卸载
- release：文件引用数为0时调用

#### 拷贝数据

include/linux/uaccess.h

避免访问非法内存, 导致内核崩溃

```c
copy_from_user(void *to, const void __user *from, unsigned long n)
```

参数：

- *to：将数据拷贝到内核的地址

- *from  需要拷贝数据的用户空间地址

- n   拷贝数据的长度（字节）

返回值：

失败：没有被拷贝的字节数

成功：0

#### register_chrdev函数(cdev_init + cdev_add)

ebf-buster-linux/include/linux/fs.h

```c
static inline int register_chrdev(unsigned int major, const char *name,
				  const struct file_operations *fops)
{
    // 实际是设置主设备号随机分配, 次设备号有256个
	return __register_chrdev(major, 0, 256, name, fops);
}
```

#### __register_chrdev函数

kernel/ebf-buster-linux/fs/char_dev.c

```c
int __register_chrdev(unsigned int major, unsigned int baseminor,unsigned int count, const char *name,const struct file_operations *fops)
{
	struct char_device_struct *cd;
	struct cdev *cdev;
	int err = -ENOMEM;
	// 登记设备号, 0的时候自动分分配
	cd = __register_chrdev_region(major, baseminor, count, name);
...
    // 实际是实现cdev_init函数的功能
	cdev = cdev_alloc();
...
    // 记录信息
	cdev->owner = fops->owner;
	cdev->ops = fops;
...
    // 记录实际的cdec到probe里面
	err = cdev_add(cdev, MKDEV(cd->major, baseminor), count);
...
}
```

- 次设备号为0，次设备号数量为256

### 现象

可以在`/proc/devices`文件里面看到实际的设备文件以及对应的设备号, 在使用insmod加载模块以及, 可以查看到分配的主设备号

之后可以使用命令`mknod /dev/xxx c 主次设备号`进行设备的创建

