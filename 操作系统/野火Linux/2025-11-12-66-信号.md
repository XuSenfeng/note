# 信号

## 使用

+   初始化afsync操作函数, 初始化fasync_struct, 记录可以通知的进程
+   使用kill_fasync函数发送信号
+   应用注册对应的信号处理函数
+   使用fcntl通知驱动开启捕获

## 介绍

使用阻塞或者非阻塞的方式来读取驱动中按键值都是应用程序主动读取的，对于非阻塞方式来说还需要应用程序通过 poll函数不断的轮询。最好的方式就是驱动程序能主动向应用程序发出通知，报告自己可以访问，然后应用程序在从驱动程序中读取或写入数据，类似于我们在裸机例程中讲解的中断

驱动可以通过主动向应用程序发送信号的方式来报告自己可以访问了，应用程序获取到信号以后就可以从驱动设备中读取或者写入数据了。整个过程就相当于应用程序收到了驱动发送过来了的一个中断，然后应用程序去响应这个中断

可以使用的中断如下

```c
#define SIGHUP		 1 	/* 终端挂起或控制进程终止 */
#define SIGINT		 2	/* 终端中断(Ctrl+C组合键) */
#define SIGQUIT		 3	/* 终端退出(Ctrl+\组合键) */
#define SIGILL		 4	/* 非法指令 */
#define SIGTRAP		 5	/* debug使用，有断点指令产生 */
#define SIGABRT		 6	/* 由 abort(3)发出的退出指令 */
#define SIGIOT		 6	/* IOT指令 */
#define SIGBUS		 7	/* 总线错误 */
#define SIGFPE		 8	/* 浮点运算错误 */
#define SIGKILL		 9	/* 杀死、终止进程 */
#define SIGUSR1		10	/* 用户自定义信号 1 */
#define SIGSEGV		11	/* 段违例(无效的内存段) */
#define SIGUSR2		12	/* 用户自定义信号 2 */
#define SIGPIPE		13	/* 向非读管道写入数据 */
#define SIGALRM		14	/* 闹钟 */
#define SIGTERM		15	/* 软件终止 */
#define SIGSTKFLT	16	/* 栈异常 */
#define SIGCHLD		17	/* 子进程结束 */
#define SIGCONT		18	/* 进程继续 */
#define SIGSTOP		19	/* 停止进程的执行，只是暂停 */
#define SIGTSTP		20	/* 停止进程的运行(Ctrl+Z组合键) */
#define SIGTTIN		21	/* 后台进程需要从终端读取数据 */
#define SIGTTOU		22	/* 后台进程需要向终端写数据 */
#define SIGURG		23	/* 有"紧急"数据 */
#define SIGXCPU		24	/* 超过 CPU资源限制 */
#define SIGXFSZ		25	/* 文件大小超额 */
#define SIGVTALRM	26	/* 虚拟时钟信号 */
#define SIGPROF		27	/* 时钟信号描述 */
#define SIGWINCH	28	/* 窗口大小改变 */
#define SIGIO		29		/* 可以进行输入/输出操作 */
#define SIGPOLL		SIGIO
/* #define SIGLOST		29 */
#define SIGPWR		30	/* 断点重启 */
#define SIGSYS		31	/* 非法的系统调用 */
#define	SIGUNUSED	31	/* 未使用信号 */

/* These should not be considered constants from userland.  */
#define SIGRTMIN	32
#define SIGRTMAX	(_NSIG-1)
```

除了 SIGKILL(9)和 SIGSTOP(19)这两个信号不能被忽略外，其他的信号都可以忽略。这些信号就相当于中断号，不同的中断号代表了不同的中断，不同的中断所做的处理不同，因此，驱动程序可以通过向应用程序发送不同的信号来实现不同的功能

## 使用的API

### 应用

#### 设置处理函数

```c
sighandler_t signal(int signum, sighandler_t handler)
```

+   **signum**：要设置处理函数的信号。
+   **handler**：信号的处理函数。

设置成功的话返回信号的前一个处理函数，设置失败的话返回 SIG_ERR

>   ```c
>   typedef void (*sighandler_t)(int)
>   ```

#### 通知驱动开启

```c
fcntl(fd, F_SETOWN, getpid()); // 通知进程的pid 
flags = fcntl(fd, F_GETFL); /* 获取当前的进程状态 */
fcntl(fd, F_SETFL, flags | FASYNC); /* 开启当前进程异步通知功能 */
```

之后就可以设置信号捕获

### 驱动

#### fasync_struct结构体

每个 `fasync_struct` 节点都包含了关键信息——**需要接收信号的进程的进程ID（PID）**。这样当事件发生时，驱动就知道该向谁发信号

```c
struct fasync_struct {
  spinlock_t fa_lock;
  int magic;
  int fa_fd;
  struct fasync_struct *fa_next;
  struct file *fa_file;
  struct rcu_head fa_rcu;
};
```

#### fasync开启异步通知

异步通知，需要在设备驱动中实现 file_operations 操作集中的 fasync 函数

驱动程序中的 `fasync` 函数是一个"**注册与注销**"函数。当应用程序希望启用或禁用异步 I/O 通知时，它通过 `fcntl` 系统调用间接地触发驱动中的这个函数，其核心任务就是更新驱动内部维护的"订阅者列表"（即 `fasync_struct` 链表）

```c
int (*fasync) (int fd, struct file *filp, int on)
```

fasync 函数里面一般通过调用 fasync_helper 函数来初始化前面定义的 fasync_struct 结构体指针

```c
int fasync_helper(int fd, struct file * filp, int on, struct fasync_struct **fapp)
```

fasync_helper函数的前三个参数就是 fasync 函数的那三个参数，第四个参数就是要初始化的 fasync_struct 结构体指针变量。当应用程序通过`fcntl(fd, F_SETFL, flags | FASYNC)`改变 fasync标记的时候，驱动程序 file_operations操作集中的fasync函数就会执行

在关闭驱动文件的时候需要在 file_operations 操作集中的 release 函数中释放 fasync_struct

```c
xxx_fasync(-1, filp, 0);
```

### 发送信号

```c
void kill_fasync(struct fasync_struct **fp, int sig, int band)
```

+   **fp**：要操作的fasync_struct。
+   **sig**：要发送的信号。
+   **band**：可读时设置为POLL_IN，可写时设置为 POLL_OUT。
