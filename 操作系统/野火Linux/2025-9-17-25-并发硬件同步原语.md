## 硬件同步原语

####  并发的根源

- 多线程、多进程调度
- 各种中断

#### 并发对程序的不良影响

- 篡改共享数据
- 动作不完整
- 同步、死锁、数据竞争、系统调度开销...

#### 硬件同步原语

由计算机硬件提供的一组原子操作，具有不可分割性，避免并行运算执行错误。

#### 案例

```c
//C语言代码
进程一：i=10
进程二：i=20

//汇编代码
进程一：
ldr r0, =0X30000000 /* i 变量的内存地址 */
ldr r1, = 10 /* 要写入的值 */
str r1, [r0] /* 将 10 写入到 i 变量中 */

进程二：
ldr r0, =0X30000000 /* i 变量的内存地址 */
ldr r1, = 20 /* 要写入的值 */
str r1, [r0] /* 将 10 写入到 i 变量中 */
```

#### 原子整型操作接口

##### 原子整型变量

```c
typedef struct {
int counter;
} atomic_t;
```

##### ATOMIC_INIT()

定义整型原子变量并设置初始值

```c
atomic_t data = ATOMIC_INIT(int i)
```

##### atomic_set()

用于设置整型原子变量的值

```c
atomic_set(atomic_t *v,int i)
```

##### atomic_read()

获取原子变量的值

```c
atomic_read(atomic_t *v)
```

##### atomic_add()/atomic_sub()

整型原子变量的加/减

```c
static inline void atomic_add(int i, atomic_t *v) //整型原子变量加i
static inline void atomic_sub(int i, atomic_t *v) //整型原子变量减i
```

##### atomic_inc()/atomic_dec()

整型原子变量自增/自减

```c
static inline void atomic_inc(atomic_t *v) //整型原子变量自增1
static inline void atomic_dec(atomic_t *v)//整型原子变量自减1
```

#### 位原子操作函数

##### set_bit()

将某一位置1

```c
set_bit(int nr, unsigned long *addr)
```

##### clear_bit()

将某一位置0

```c
clear_bit(int nr, unsigned long *addr)
```

##### change_bit()

反转某一位的值

```c
int test_bit(int nr, unsigned long \*addr)
```

## 实际使用

```c
static atomic_t test_atomic = ATOMIC_INIT(1);

/*字符设备操作函数集，open函数*/
static int led_chr_dev_open(struct inode *inode, struct file *filp)
{
	if(atomic_read(&test_atomic))
	{
		atomic_set(&test_atomic,0);
	}
    else
    {
		printk("\n driver on using!  open failed !!!\n");
		return - EBUSY;
    }
	printk("\n open form driver \n");
	return 0;
}


static int led_chrdev_release(struct inode *inode, struct file *filp)
{
    atomic_set(&test_atomic,1);
	printk("KERN_ALERT  \n finished  !!!\n");

	return 0;
}
```

```c
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
int main(int argc, char *argv[])
{
    /*判断输入的命令是否合法*/
    if(argc != 2)
    {
        printf(" commend error ! \n");
        return -1;
    }

    /*打开文件*/
    int fd = open("/dev/rgb_led", O_RDWR);
    if(fd < 0)
    {
		printf("\n open file : /dev/rgb_led failed !!!\n");
		return -1;
	}


    /*写入命令*/
    int error = write(fd,argv[1],sizeof(argv[1]));
    if(error < 0)
    {
        printf("write file error! \n");
        close(fd);
        /*判断是否关闭成功*/
    }


    sleep(10);  //休眠10秒

    /*关闭文件*/
    error = close(fd);
    if(error < 0)
    {
        printf("close file error! \n");
    }
    return 0;
}
```

## 自旋锁

#### 原子操作

- 简单易用
- 只能作计数操作，保护的东西太少

#### 自旋锁

主要用于多核处理器

- 短时期的轻量级加锁
- 加锁失败时，原地打转、忙等待

- 避免上下文调度、系统开销较小

**加锁步骤**：

1. 查看锁的状态，如果锁是空闲的
2. 将锁设置为当前线程持有

##### 存在问题

在没有 **CAS 函数**前，多个线程同时执行这 2 个步骤是会出错的。

##### 解决方案

CAS 函数把这 2 个步骤**合并为一条硬件级指令**。这样第 1 步比较锁状态和第 2 步锁变量赋值，将变为不可分割的原子指令(硬件同步原语)

#### CAS 函数

自旋锁使用CPU 提供的 CAS 函数（Compare And Swap），在用户态代码中完成加锁与解锁操作

#### PAUSE 指令

自旋锁并不一直"忙等待"，会与 CPU紧密配合 ，它通过 CPU 提供的 PAUSE 指令，**减少循环等待时的耗电量**；对于单核CPU，忙等待并没有意义，此时它会主动把线程休眠。

#### 自旋锁原理

- 设自旋锁为变量 lock，整数 0 表示锁是空闲状态，整数 pid 表示线程 ID
    - CAS(lock, 0, pid) 就表示自旋锁的**加锁**操作
    - CAS(lock, pid,0) 则表示自旋锁的**解锁**操作

##### 自旋锁伪代码

```c
while (true) {
    //因为判断lock变量的值比CAS操作更快，所以先判断lock再调用CAS效率更高
    if (lock == 0 && CAS(lock, 0, pid) == 1) 
        return;

    if (CPU_count > 1 ) { 
        //如果是多核CPU，“忙等待”才有意义
        for (n = 1; n < 2048; n <<= 1) {
            //pause的时间，应当越来越长
            for (i = 0; i < n; i++) 
                pause();//CPU专为自旋锁设计了pause指令
        if (lock == 0 && CAS(lock, 0, pid)) 
            return;//pause后再尝试获取锁
        }
    }

    sched_yield();//单核CPU，或者长时间不能获取到锁，应主动休眠，让出CPU
}
```

#### 自旋锁相关API

##### 定义自旋锁

```c
spinlock_t s_lock ;
```

##### 初始化自旋锁

```c
int spin_lock_init(spinlock_t *lock);
```

##### 获取自旋锁函数

```c
void spin_lock(spinlock_t *lock)
```

> 这个函数在尝试的时候会进行忙等待

##### 尝试获取自旋锁函数

````c
int spin_trylock(spinlock_t *lock)
````

> 尝试获取一次，获取成功返回“true”,获取失败返回“false”。程序继续往下执行

##### 释放自旋锁

```c
void spin_unlock(spinlock_t *lock)
```

## 信号量

#### 本质

计数器，用来控制对公共资源的访问

#### 特点

- 长时期的资源占用
- 获取信号量失败，触发上下文调度
- 当前进程(线程)陷入休眠，系统开销大

#### 信号量相关API

##### 定义信号量

```c
struct semaphore sem;
```

##### 初始化信号量

```c
static inline void sema_init(struct semaphore *sem, int val)
```

参数：

- sem：指定要初始化的信号量
- val：信号量的初始值

##### 获取信号量

```c
void down(struct semaphore *sem);
```

参数：

- sem：指定要初始化的信号量

##### 尝试获取信号量

```c
int down_trylock(struct semaphore *sem)
```

尝试获取一次信号量，获取成功返回0,获取失败返回非0值。

##### 释放信号量

```c
void up(struct semaphore *sem)
```

参数：

- sem：指定要初始化的信号量

## 互斥锁

#### 信号量与互斥锁：同步还是独占？

##### 信号量

- 强调信号机制(同步)
- 生产者--消费者模型
- 获取信号量失败，触发上下文调度

##### 互斥锁

- 强调互斥机制
- 独占共享资源

- 获取互斥锁失败，触发上下文调度

```
服务于多个线程间的执行的逻辑顺序的选信号量, 可以有多个资源
服务于共享资源的选互斥锁, 只可以使用一个资源
```

#### 自旋锁与互斥锁：休眠还是“忙等待”？

##### 自旋锁

- 加锁成本低，不释放cpu使用权

##### 互斥锁

- 加锁成本更高(上下文切换耗时在几十纳秒到几微秒之间)，加锁失败时会释放 CPU 给其他线程

```
无法判断锁住的代码会执行多久时，首选互斥锁
确定被锁住的代码执行时间很短，使用自旋锁取代互斥锁
```

#### 互斥锁相关API

##### 定义互斥锁

```c
struct mutex lock;
```

##### 初始化互斥锁

```c
void mutex_init(mutex *lock);
```

参数：

- lock：指定要初始化的互斥锁

##### 互斥锁加锁

```c
void mutex_lock(struct mutex *lock);
```

参数：

- lock：指定要加锁的互斥锁

##### 尝试获取互斥锁

```c
int mutex_trylock(struct mutex *lock);
```

尝试获取一次互斥锁，获取成功返回“true”,获取失败返回“false”。程序继续往下执行

##### 互斥锁解锁

```c
void mutex_unlock(struct mutex *lock);
```

参数：

- lock：指定要解锁的互斥锁







