## pinctl_setting：如何统一管理pin state

![image-20250916232218271](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509162322383.png)

#### pinctl_map

- 保存了所有`pin state`所需要的`pin group`信息

#### pinctl_setting

- 把`pin group`信息按`pin state`分类保存

#### 目的

- `pinctl_map`->`pinctl_setting`

#### for_each_maps()宏

drivers/pinctrl/core.h

```c
#define for_each_maps(_maps_node_, _i_, _map_) \
	list_for_each_entry(_maps_node_, &pinctrl_maps, node) \
		for (_i_ = 0, _map_ = &_maps_node_->maps[_i_]; \
			_i_ < _maps_node_->num_maps; \
			_i_++, _map_ = &_maps_node_->maps[_i_])
```

> 一个两层的循环, 第一层的循环里面遍历所有的pinctrl_maps, 第二次遍历所有的pinctrl_map的所有引脚

#### add_setting()函数

drivers/pinctrl/core.c

```c
static int add_setting(struct pinctrl *p, struct pinctrl_dev *pctldev,
		       const struct pinctrl_map *map)
{	
	struct pinctrl_state *state;
	struct pinctrl_setting *setting;
	// 查找一下和map名字一样的pinctrl_state
	state = find_state(p, map->name); // 返回NULL
	if (!state)
		state = create_state(p, map->name); // 创建一下
	...
	setting = kzalloc(sizeof(*setting), GFP_KERNEL);
	if (!setting)
		return -ENOMEM;

	setting->type = map->type;

	if (pctldev)
		setting->pctldev = pctldev;
	else
		setting->pctldev =
			get_pinctrl_dev_from_devname(map->ctrl_dev_name);
	
    setting->dev_name = map->dev_name;
    
    switch (map->type) {
	case PIN_MAP_TYPE_MUX_GROUP:
         // 第一个
		ret = pinmux_map_to_setting(map, setting);
		break;
	case PIN_MAP_TYPE_CONFIGS_PIN:
	case PIN_MAP_TYPE_CONFIGS_GROUP:
		ret = pinconf_map_to_setting(map, setting);
		break;
	default:
		ret = -EINVAL;
		break;
	}
	...
	list_add_tail(&setting->node, &state->settings);
	
	return 0;
}
```



#### find_state()函数

drivers/pinctrl/core.c

```c
static struct pinctrl_state *find_state(struct pinctrl *p,
					const char *name)
{
	struct pinctrl_state *state;
	// 这个遍历的时候是没有数据的
	list_for_each_entry(state, &p->states, node)
		if (!strcmp(state->name, name))
			return state;

	return NULL;
}
```



#### create_state()函数

drivers/pinctrl/core.c

```c
static struct pinctrl_state *create_state(struct pinctrl *p,const char *name)
{
	struct pinctrl_state *state;

	state = kzalloc(sizeof(*state), GFP_KERNEL);
	if (!state)
		return ERR_PTR(-ENOMEM);

	state->name = name;
	INIT_LIST_HEAD(&state->settings);

	list_add_tail(&state->node, &p->states);

	return state;
}
```



#### pinmux_map_to_setting()函数

drivers/pinctrl/pinmux.c

![image-20250916233056589](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509162330628.png)

对一个map里面的节点的group和基数树里面的function以及对应的group进行对应

```c
int pinmux_map_to_setting(const struct pinctrl_map *map,struct pinctrl_setting *setting)
{
	struct pinctrl_dev *pctldev = setting->pctldev;
	//imx_pmx_ops, 对应的是pinmux_ops
	const struct pinmux_ops *pmxops = pctldev->desc->pmxops;
	char const * const *groups;
	unsigned num_groups;
	int ret;
	const char *group;
	...
     // 使用map的function名字获取对应的function的编号
	ret = pinmux_func_name_to_selector(pctldev, map->data.mux.function);
	...
	/*function的索引*/
	setting->data.mux.func = ret;
	// 对应pinmux_generic_get_function_groups函数, 获取对应的所有group的名字以及总数
	ret = pmxops->get_function_groups(pctldev, setting->data.mux.func,&groups, &num_groups);
	
	if (map->data.mux.group) {
		// map节点的group节点名进行比对
		group = map->data.mux.group;
		ret = match_string(groups, num_groups, group);
		...
		}
	} else {
		group = groups[0];
	}
	// 获取一下group在基数树的对应编号
	ret = pinctrl_get_group_selector(pctldev, group);
	...
	setting->data.mux.group = ret;
	...
}
	
```



#### pinmux_func_name_to_selector()函数

drivers/pinctrl/pinmux.c

使用map记录的function名字获取对应的function的编号, 这里获取的是唯一的一个function编号0

```c
static int pinmux_func_name_to_selector(struct pinctrl_dev *pctldev,
					const char *function)
{
	const struct pinmux_ops *ops = pctldev->desc->pmxops;
	//imx_pmx_ops, 实际对应的函数是pinmux_generic_get_function_count
	unsigned nfuncs = ops->get_functions_count(pctldev); // 获取到function层的数量, 是1
	unsigned selector = 0;

	while (selector < nfuncs) {
        // 对应pinmux_generic_get_function_name, 获取基数树上面的function的名字
		const char *fname = ops->get_function_name(pctldev, selector);
        // 实际是对比一下iomux节点的名字, 对比是成立的, 返回0
		if (!strcmp(function, fname))
			return selector;

		selector++;
	}

	return -EINVAL;
}
```



#### pinmux_generic_get_function_count()函数

drivers/pinctrl/pinmux.c

```c
int pinmux_generic_get_function_count(struct pinctrl_dev *pctldev)
{
	return pctldev->num_functions;
}
```



#### pinmux_generic_get_function_name()函数

drivers/pinctrl/pinmux.c

```c
const char * pinmux_generic_get_function_name(struct pinctrl_dev *pctldev,
				 unsigned int selector)
{
	struct function_desc *function;

	function = radix_tree_lookup(&pctldev->pin_function_tree,
				     selector);
	if (!function)
		return NULL;

	return function->name;
}
```

#### pinmux_generic_get_function_groups()函数

drivers/pinctrl/pinmux.c

查找function里面对应的group的名字链表

```c
int pinmux_generic_get_function_groups(struct pinctrl_dev *pctldev,
				       unsigned int selector,
				       const char * const **groups,
				       unsigned * const num_groups)
{
	struct function_desc *function;

	function = radix_tree_lookup(&pctldev->pin_function_tree,selector);
	if (!function) {
		dev_err(pctldev->dev, "%s could not find function%i\n",__func__, selector);
		return -EINVAL;
	}
	*groups = function->group_names;
	*num_groups = function->num_group_names;

	return 0;
}
```



#### pinctrl_get_group_selector()函数

drivers/pinctrl/core.c

依据引脚group的名字获取一下group在基数树的对应编号

![image-20250916234626214](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509162346264.png)

```c
int pinctrl_get_group_selector(struct pinctrl_dev *pctldev,const char *pin_group)
{
	const struct pinctrl_ops *pctlops = pctldev->desc->pctlops;
    // pinctrl_generic_get_group_count函数, 获取所有的group的数量
	unsigned ngroups = pctlops->get_groups_count(pctldev);
	unsigned group_selector = 0;

	while (group_selector < ngroups) {
        // 遍历所有的group, pinctrl_generic_get_group_name, 在基数树使用编号获取名字
		const char *gname = pctlops->get_group_name(pctldev,
							    group_selector);
		if (gname && !strcmp(gname, pin_group)) {
			dev_dbg(pctldev->dev,
				"found group selector %u for %s\n",
				group_selector,
				pin_group);
			return group_selector;
		}

		group_selector++;
	}

	dev_err(pctldev->dev, "does not have pin group %s\n",
		pin_group);

	return -EINVAL;
}
```



#### pinctrl_generic_get_group_count()函数

```c
int pinctrl_generic_get_group_count(struct pinctrl_dev *pctldev)
{
	return pctldev->num_groups;
}
```



#### pinctrl_generic_get_group_name()函数

```c
const char *pinctrl_generic_get_group_name(struct pinctrl_dev *pctldev,
					   unsigned int selector)
{
	struct group_desc *group;

	group = radix_tree_lookup(&pctldev->pin_group_tree,
				  selector);
	if (!group)
		return NULL;

	return group->name;
}
```





#### pinconf_map_to_setting()函数

其他的引脚的处理函数

```c
int pinconf_map_to_setting(const struct pinctrl_map *map,
			  struct pinctrl_setting *setting)
{
	struct pinctrl_dev *pctldev = setting->pctldev;
	int pin;

	switch (setting->type) {
	case PIN_MAP_TYPE_CONFIGS_PIN:
         // 使用引脚名字获取引脚的编号
		pin = pin_get_from_name(pctldev,
					map->data.configs.group_or_pin);
		if (pin < 0) {
			dev_err(pctldev->dev, "could not map pin config for \"%s\"",
				map->data.configs.group_or_pin);
			return pin;
		}
		setting->data.configs.group_or_pin = pin;
		break;
		...
	}
	setting->data.configs.num_configs = map->data.configs.num_configs;
	setting->data.configs.configs = map->data.configs.configs;
	...
}
    
```

```c
int pin_get_from_name(struct pinctrl_dev *pctldev, const char *name)
{
	unsigned i, pin;

	/* The pin number can be retrived from the pin controller descriptor */
	for (i = 0; i < pctldev->desc->npins; i++) {
		struct pin_desc *desc;

		pin = pctldev->desc->pins[i].number;
		desc = pin_desc_get(pctldev, pin);
		/* Pin space may be sparse */
		if (desc && !strcmp(name, desc->name))
			return pin;
	}

	return -EINVAL;
}
```

```c
static inline struct pin_desc *pin_desc_get(struct pinctrl_dev *pctldev,
					    unsigned int pin)
{
	return radix_tree_lookup(&pctldev->pin_desc_tree, pin);
}
```

## pinctrl子系统的引脚设置接口

#### pinctrl子系统对外接口

##### 状态查询接口

pinctrl_lookup_state

##### 状态设置接口

pinctrl_select_state

##### 状态类型

```
#define PINCTRL_STATE_DEFAULT "default"
#define PINCTRL_STATE_INIT "init"
#define PINCTRL_STATE_IDLE "idle"
#define PINCTRL_STATE_SLEEP "sleep"
```

#### 函数原型

#### pinctrl_lookup_state()函数

drivers/pinctrl/core.c

查找一下这个状态是不是存在, 不是的话, 创建一下, 是的话返回这个结构体

```c
struct pinctrl_state *pinctrl_lookup_state(struct pinctrl *p,
						 const char *name)
{
	struct pinctrl_state *state;

	state = find_state(p, name);
	if (!state) {
		if (pinctrl_dummy_state) {
			/* create dummy state */
			dev_dbg(p->dev, "using pinctrl dummy state (%s)\n",
				name);
			state = create_state(p, name);
		} else
			state = ERR_PTR(-ENODEV);
	}

	return state;
}
```

#### find_state()函数

drivers/pinctrl/core.c

实际的查找函数

```c
static struct pinctrl_state *find_state(struct pinctrl *p,const char *name)
{
	struct pinctrl_state *state;

	list_for_each_entry(state, &p->states, node)
		if (!strcmp(state->name, name))
			return state;

	return NULL;
}
```

#### pinctrl_select_state()函数

drivers/pinctrl/core.c

```c
int pinctrl_select_state(struct pinctrl *p, struct pinctrl_state *state)
{
	if (p->state == state)
		return 0;

	return pinctrl_commit_state(p, state);
}
```



#### pinctrl_commit_state()函数

drivers/pinctrl/core.c

```c
static int pinctrl_commit_state(struct pinctrl *p, struct pinctrl_state *state)
{
	struct pinctrl_setting *setting, *setting2;
	struct pinctrl_state *old_state = p->state;
	int ret;
	
	...
	
	list_for_each_entry(setting, &state->settings, node) {
        // 遍历所有的谁知
		switch (setting->type) {
		case PIN_MAP_TYPE_MUX_GROUP:
             // 设置复用
			ret = pinmux_enable_setting(setting);
			break;
		case PIN_MAP_TYPE_CONFIGS_PIN:
		case PIN_MAP_TYPE_CONFIGS_GROUP:
			// 设置实际的属性
             ret = pinconf_apply_setting(setting);
			break;
		default:
			ret = -EINVAL;
			break;
		}
```

#### pinmux_enable_setting()函数

处理一个Setting的第一项, 是一个group的设置

![image-20250917143615707](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509171436757.png)

![image-20250917143407593](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509171434643.png)

```c
int pinmux_enable_setting(const struct pinctrl_setting *setting)
{
	struct pinctrl_dev *pctldev = setting->pctldev;
	const struct pinctrl_ops *pctlops = pctldev->desc->pctlops;
	const struct pinmux_ops *ops = pctldev->desc->pmxops;
	int ret = 0;
	const unsigned *pins = NULL;
	unsigned num_pins = 0;
	int i;
	struct pin_desc *desc;
	
	if (pctlops->get_group_pins)
        // 获取对应的group里面的引脚的编号以及数量
		ret = pctlops->get_group_pins(pctldev, setting->data.mux.group,&pins, &num_pins);

	...
    // 
	ret = ops->set_mux(pctldev, setting->data.mux.func,
			   setting->data.mux.group);
	...
}
```

#### pinctrl_generic_get_group_pins()函数

drivers/pinctrl/pinmux.c

获取对应的group里面的引脚的编号以及数量

```c
int pinctrl_generic_get_group_pins(struct pinctrl_dev *pctldev,
				   unsigned int selector,
				   const unsigned int **pins,
				   unsigned int *num_pins)
{
	struct group_desc *group;

	group = radix_tree_lookup(&pctldev->pin_group_tree,
				  selector);
	if (!group) {
		dev_err(pctldev->dev, "%s could not find pingroup%i\n",
			__func__, selector);
		return -EINVAL;
	}

	*pins = group->pins;
	*num_pins = group->num_pins;

	return 0;
}
```

#### imx_pmx_set()函数

drivers/pinctrl/freescale/pinctrl-imx.c

```c
static int imx_pmx_set(struct pinctrl_dev *pctldev, unsigned selector,unsigned group)
{
	struct imx_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);
	unsigned int npins;
	const struct imx_pinctrl_soc_info *info = ipctl->info;
	int i, err;
	struct group_desc *grp = NULL;
	struct function_desc *func = NULL;

	/*
	 * Configure the mux mode for each pin in the group for a specific
	 * function.
	 */
    // 基数树获取一下对应的group
	grp = pinctrl_generic_get_group(pctldev, group);
	if (!grp)
		return -EINVAL;
	// 基数树获取对应的function结构体
	func = pinmux_generic_get_function(pctldev, selector);
	if (!func)
		return -EINVAL;

	npins = grp->num_pins;

	dev_dbg(ipctl->dev, "enable function %s group %s\n",
		func->name, grp->name);

	for (i = 0; i < npins; i++) {
        // 遍历group的所有引脚
		struct imx_pin *pin = &((struct imx_pin *)(grp->data))[i];
		if (info->flags & IMX8_USE_SCU)
			err = imx_pmx_set_one_pin_scu(ipctl, pin);
		else
            // 实际执行的位置
			err = imx_pmx_set_one_pin_mem(ipctl, pin);
		if (err)
			return err;
	}

	return 0;
}
```

#### imx_pmx_set_one_pin_mem()函数

drivers/pinctrl/freescale/pinctrl-memmap.c

```c
int imx_pmx_set_one_pin_mem(struct imx_pinctrl *ipctl, struct imx_pin *pin)
{
	const struct imx_pinctrl_soc_info *info = ipctl->info;
    // 获取引脚的编号
	unsigned int pin_id = pin->pin;
	struct imx_pin_reg *pin_reg;
	struct imx_pin_memmap *pin_memmap;
    // 获取他的对应的寄存器描述数组, 复用寄存器以及属性寄存器
	pin_reg = &ipctl->pin_regs[pin_id];
    // 获取各项具体的值
	pin_memmap = &pin->pin_conf.pin_memmap;
	
	if (info->flags & SHARE_MUX_CONF_REG) {
		u32 reg;
		reg = readl(ipctl->base + pin_reg->mux_reg);
		reg &= ~info->mux_mask;
		reg |= (pin_memmap->mux_mode << info->mux_shift);
		writel(reg, ipctl->base + pin_reg->mux_reg);
		dev_dbg(ipctl->dev, "write: offset 0x%x val 0x%x\n",
			pin_reg->mux_reg, reg);
	} else {
        // 执行的位置, 写入数据
		writel(pin_memmap->mux_mode, ipctl->base + pin_reg->mux_reg);
		dev_dbg(ipctl->dev, "write: offset 0x%x val 0x%x\n",
			pin_reg->mux_reg, pin_memmap->mux_mode);
	}
	...
 }
```

#### 引脚的部分

![image-20250917191649873](C:\Users\14586\AppData\Roaming\Typora\typora-user-images\image-20250917191649873.png)

```c
int pinconf_apply_setting(const struct pinctrl_setting *setting)
{
	struct pinctrl_dev *pctldev = setting->pctldev;
	const struct pinconf_ops *ops = pctldev->desc->confops;
	int ret;

	if (!ops) {
		dev_err(pctldev->dev, "missing confops\n");
		return -EINVAL;
	}

	switch (setting->type) {
	case PIN_MAP_TYPE_CONFIGS_PIN:
		if (!ops->pin_config_set) {
			dev_err(pctldev->dev, "missing pin_config_set op\n");
			return -EINVAL;
		}
        // 写入实际的寄存器
		ret = ops->pin_config_set(pctldev,
				setting->data.configs.group_or_pin,
				setting->data.configs.configs,
				setting->data.configs.num_configs);
		if (ret < 0) {
			dev_err(pctldev->dev,
				"pin_config_set op failed for pin %d\n",
				setting->data.configs.group_or_pin);
			return ret;
		}
		break;
	case PIN_MAP_TYPE_CONFIGS_GROUP:
		if (!ops->pin_config_group_set) {
			dev_err(pctldev->dev,
				"missing pin_config_group_set op\n");
			return -EINVAL;
		}
		ret = ops->pin_config_group_set(pctldev,
				setting->data.configs.group_or_pin,
				setting->data.configs.configs,
				setting->data.configs.num_configs);
		if (ret < 0) {
			dev_err(pctldev->dev,
				"pin_config_group_set op failed for group %d\n",
				setting->data.configs.group_or_pin);
			return ret;
		}
		break;
	default:
		return -EINVAL;
	}

	return 0;
}
```

```c
static int imx_pinconf_set(struct pinctrl_dev *pctldev,
			     unsigned pin_id, unsigned long *configs,
			     unsigned num_configs)
{
	struct imx_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);
	const struct imx_pinctrl_soc_info *info = ipctl->info;

	if (info->flags & IMX8_USE_SCU)
		return imx_pinconf_backend_set_scu(pctldev, pin_id, configs, num_configs);
	else
		return imx_pinconf_backend_set_mem(pctldev, pin_id, configs, num_configs);
}
```

```c
int imx_pinconf_backend_set_mem(struct pinctrl_dev *pctldev,
			    unsigned pin_id, unsigned long *configs,
			    unsigned num_configs)
{
	struct imx_pinctrl *ipctl = pinctrl_dev_get_drvdata(pctldev);
	const struct imx_pinctrl_soc_info *info = ipctl->info;
	const struct imx_pin_reg *pin_reg = &ipctl->pin_regs[pin_id];
	int i;

	if (pin_reg->conf_reg == -1) {
		dev_err(ipctl->dev, "Pin(%s) does not support config function\n",
			info->pins[pin_id].name);
		return -EINVAL;
	}

	dev_dbg(ipctl->dev, "pinconf set pin %s\n",
		info->pins[pin_id].name);

	for (i = 0; i < num_configs; i++) {
		if (info->flags & SHARE_MUX_CONF_REG) {
			u32 reg;
			reg = readl(ipctl->base + pin_reg->conf_reg);
			reg &= info->mux_mask;
			reg |= configs[i];
			writel(reg, ipctl->base + pin_reg->conf_reg);
			dev_dbg(ipctl->dev, "write: offset 0x%x val 0x%x\n",
				pin_reg->conf_reg, reg);
		} else {
			writel(configs[i], ipctl->base + pin_reg->conf_reg);
			dev_dbg(ipctl->dev, "write: offset 0x%x val 0x%lx\n",
				pin_reg->conf_reg, configs[i]);
		}
	} /* for each config */

	return 0;
}
```









