# xbus驱动总线

## xbus：打造自属的驱动总线

#### 驱动总线

软件与硬件代码分离，提高程序的复用性

- device--关联硬件代码, 寄存器相关的
- driver_devices--关联软件代码
- bus_type--统一管理、设置match匹配规则, 使用链表进行关联上面两个

> 在进行添加的时候, 会使用match函数进行匹配, 添加一个的时候会去匹配另一个进行合作

设备驱动模型体现分离思想, 如果自定义以及xbus总线会被记录在sys/xbus目录下面, 有两个目录分别管理

- /bus/xbus/devices - drivers

> 默认的总线是在/bus目录下边的

#### 总线管理

![image-20250719171651745](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507191716837.png)

##### buses_init()函数

内核启动默认执行

创建/sys/bus目录

```c
int __init buses_init(void)
{
    // 默认的bus目录项
	bus_kset = kset_create_and_add("bus", &bus_uevent_ops, NULL);
	if (!bus_kset)
		return -ENOMEM;
	// 创建一个system目录项
	system_kset = kset_create_and_add("system", NULL, &devices_kset->kobj);
	if (!system_kset)
		return -ENOMEM;

	return 0;
}
```

#### 总线注册

##### bus_register()函数

添加新的总线类型

```c
int bus_register(struct bus_type *bus)
```

- 在/sys/bus下建立xbus目录项(xbus为自定义的名字)，并创建属性文件
- 在/sys/bus/xbus下建立devices目录项，并创建属性文件
- 在/sys/bus/xbus下建立drivers目录项，并创建属性文件

> 记录在bustype里面的subsys_private里面, 有三个kset对应目录, 属性记录在bustype里面

- 初始化 priv->klist_devices链表头
- 初始化priv->klist_drivers链表头

> 记录一系列的驱动代码

#### 设备注册

##### device_register()函数 

添加设备，关联硬件相关代码, 添加设备的同时记录在链表里面, 不管有没有匹配到driver都会在/dev/建立这个文件

```c
int device_register(struct device *dev)
```

- 在/sys/bus/xbus/devices下建立yyy目录项
- 加入bus-> priv->devices_kset链表
- 加入bus-> priv->klist_devices链表
- 遍历bus-> priv->klist_drivers，执行bus->match()寻找合适的drv
- dev关联driv，执行drv->probe()

#### 驱动注册

##### driver_register()函数

添加驱动，关联软件相关代码

```c
int driver_register(struct device_driver *drv)
```

- 在/sys/bus/xbus/drivers下建立zzz目录项
- 加入bus-> priv->drivers_kset链表
- 加入bus-> priv->klist_drivers链表
- 遍历bus-> priv->klist_klist_devices链表，执行bus->match()寻找合适的dev
- dev关联dev，执行drv->probe()

#### 设备驱动模型框图

![image-20250719171845725](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507191718818.png)

## 代码实现

注册的时候需要先注册总线, 之后注册设备和驱动, 使用总线里面的match函数进行匹配, 匹配以后执行driver里面的probe函数

```c
/*
 * Struct used for matching a device
 */
struct of_device_id {
	char	name[32];
	char	type[32];
	char	compatible[128];
	const void *data;
};

/**
 * struct device_driver - The basic device driver structure
 * @name:	Name of the device driver.
 * @bus:	The bus which the device of this driver belongs to.
 * @owner:	The module owner.
 * @mod_name:	Used for built-in modules.
 * @suppress_bind_attrs: Disables bind/unbind via sysfs.
 * @probe_type:	Type of the probe (synchronous or asynchronous) to use.
 * @of_match_table: The open firmware table.
 * @acpi_match_table: The ACPI match table.
 * @probe:	Called to query the existence of a specific device,
 *		whether this driver can work with it, and bind the driver
 *		to a specific device.
 * @remove:	Called when the device is removed from the system to
 *		unbind a device from this driver.
 * @shutdown:	Called at shut-down time to quiesce the device.
 * @suspend:	Called to put the device to sleep mode. Usually to a
 *		low power state.
 * @resume:	Called to bring a device from sleep mode.
 * @groups:	Default attributes that get created by the driver core
 *		automatically.
 * @pm:		Power management operations of the device which matched
 *		this driver.
 * @coredump:	Called when sysfs entry is written to. The device driver
 *		is expected to call the dev_coredump API resulting in a
 *		uevent.
 * @p:		Driver core's private data, no one other than the driver
 *		core can touch this.
 *
 * The device driver-model tracks all of the drivers known to the system.
 * The main reason for this tracking is to enable the driver core to match
 * up drivers with new devices. Once drivers are known objects within the
 * system, however, a number of other things become possible. Device drivers
 * can export information and configuration variables that are independent
 * of any specific device.
 */
struct device_driver {
	const char		*name;
	struct bus_type		*bus;

	struct module		*owner;
	const char		*mod_name;	/* used for built-in modules */

	bool suppress_bind_attrs;	/* disables bind/unbind via sysfs */
	enum probe_type probe_type;

	const struct of_device_id	*of_match_table;
	const struct acpi_device_id	*acpi_match_table;

	int (*probe) (struct device *dev);
	int (*remove) (struct device *dev);
	void (*shutdown) (struct device *dev);
	int (*suspend) (struct device *dev, pm_message_t state);
	int (*resume) (struct device *dev);
	const struct attribute_group **groups;

	const struct dev_pm_ops *pm;
	void (*coredump) (struct device *dev);

	struct driver_private *p;
};
```



### 总线

```c
#include <linux/init.h>
#include <linux/module.h>

#include <linux/device.h>
// 使用的匹配函数
int xbus_match(struct device *dev, struct device_driver *drv)
{

	printk(KERN_ALERT "%s-%s\n", __FILE__, __func__);
	if (!strncmp(dev_name(dev), drv->name, strlen(drv->name))) {
		printk(KERN_ALERT "dev & drv match\n");
		return 1;
	}
	return 0;

}
static struct bus_type xbus = {
	.name = "xbus",
	.match = xbus_match,
};
// 共享参数
EXPORT_SYMBOL(xbus);

static __init int xbus_init(void)
{
    int ret;
	printk(KERN_ALERT "xbus init\n");
	ret = bus_register(&xbus);
    if(ret != 0){
         return -1;
    }
	return 0;
}

module_init(xbus_init);

static __exit void xbus_exit(void)
{
	printk(KERN_ALERT "xbus exit\n");
	bus_unregister(&xbus);
}

module_exit(xbus_exit);

MODULE_AUTHOR("embedfire");
MODULE_LICENSE("GPL");
```

### 硬件

```c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/device.h>

extern struct bus_type xbus;

void xdev_release(struct device *dev)
{
	printk(KERN_ALERT "%s-%s\n", __FILE__, __func__);
}

static struct device xdev = {
	.init_name = "xdev",
	.bus = &xbus, // 之前构建的总线
	.release = xdev_release,
};

static __init int xdev_init(void)
{
    int ret;
	printk(KERN_ALERT "xdev init\n");
	ret = device_register(&xdev);
    if(ret != 0){
         return -1;
    }
       
	return 0;
}

static __exit void xdev_exit(void)
{
	printk(KERN_ALERT "xdev exit\n");
	device_unregister(&xdev);
}

module_init(xdev_init);
module_exit(xdev_exit);

MODULE_AUTHOR("embedfire");
MODULE_LICENSE("GPL");
```

### 驱动

```c
#include <linux/init.h>
#include <linux/module.h>

#include <linux/device.h>

extern struct bus_type xbus;

int xdrv_probe(struct device *dev)
{
	printk(KERN_ALERT "%s-%s\n", __FILE__, __func__);
	return 0;
}

int xdrv_remove(struct device *dev)
{
	printk(KERN_ALERT "%s-%s\n", __FILE__, __func__);
	return 0;
}

static struct device_driver xdrv = {
	.name = "xdev",
	.bus = &xbus,
	.probe = xdrv_probe,
	.remove = xdrv_remove,
};

static __init int xdrv_init(void)
{
    int ret;
	printk( KERN_ALERT"xdrv init\n");
	ret = driver_register(&xdrv);
    if(ret != 0){
         return -1;
    }
	return 0;
}

static __exit void xdrv_exit(void)
{
	printk(KERN_ALERT "xdrv exit\n");
	driver_unregister(&xdrv);
}

module_init(xdrv_init);
module_exit(xdrv_exit);

MODULE_AUTHOR("embedfire");
MODULE_LICENSE("GPL");
```

![image-20250719222449450](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507192224545.png)

## platform：虚拟的平台总线

在 Linux 设备驱动模型中，`platform_device` 是一种**描述片上系统 (SoC) 或固定连接的非总线设备**的核心机制。它用于管理那些 不通过标准硬件总线（如 I2C、PCI、USB）连接，但由 CPU 直接控制或集成在芯片内部的设备。

- platform_device：继承device，关联硬件代码, 记录相关的硬件资源信息
- platform_driver：继承device_driver，重设probe函数指针, 实际使用device记录的硬件资源进行初始化, 这个prob实际会调用driver里面的probe函数
- platform(bus_type)：统一管理、设置match匹配规则

适用设备：

- SoC 内部外设（如 UART、GPIO 控制器、时钟模块）
- 固定连接的硬件（如板载 Flash、专用硬件加速器）
- 无法自动检测的旧式设备（如 ISA 设备）

- **不依赖物理总线**：无需实现总线协议（如 I2C 的 `i2c_driver`），直接由内核管理。

![image-20250719230755520](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507192307614.png)

#### 平台总线注册

drivers/base/platform.c

/sys/bus/platform

##### platform_bus_init()函数

这个函数是自动调用的

```c
struct bus_type platform_bus_type = {
	.name		= "platform",
	.dev_groups	= platform_dev_groups,
	.match		= platform_match,
	.uevent		= platform_uevent,
	.dma_configure	= platform_dma_configure,
	.pm		= &platform_dev_pm_ops,
};

int __init platform_bus_init(void)
{
...
	error =  bus_register(&platform_bus_type);
...
	return error;
}
```

###### platform_match()函数

设置匹配规则

```c
static int platform_match(struct device *dev, struct device_driver *drv)
{
	struct platform_device *pdev = to_platform_device(dev);
	struct platform_driver *pdrv = to_platform_driver(drv);

	/* When driver_override is set, only bind to the matching driver */
	if (pdev->driver_override)
		return !strcmp(pdev->driver_override, drv->name);

	/* Attempt an OF style match first 设备树的匹配 */
	if (of_driver_match_device(dev, drv))
		return 1;

	/* Then try ACPI style match 比较少用 */
	if (acpi_driver_match_device(dev, drv))
		return 1;

	/* Then try to match against the id table 进行名字和名字列表的匹配 */
	if (pdrv->id_table)
		return platform_match_id(pdrv->id_table, pdev) != NULL;

	/* fall-back to driver name match */
	return (strcmp(pdev->name, drv->name) == 0);
}
```

- of_driver_match_device：设备树匹配
- acpi_driver_match_device：ACPI匹配
- platform_match_id：id_table匹配, platform_device里面的device_id记录一系列的name, 和platform里面的name进行匹配
- strcmp(pdev->name, drv->name)：设备名和驱动名匹配

#### 平台设备注册

drivers/base/platform.c

##### platform_device_register()函数

```c
int platform_device_register(struct platform_device *pdev)
```

- 继承device

###### resources结构体

描述驱动的硬件资源

- start：资源的开始值
- end：资源的结束值
- flasg：资源的类型
    - IORESOURCE_MEM：内存地址
    - IORESOURCE_IO：IO端口
    - IORESOURCE_DMA：DMA传输
    - IORESOURCE_IRQ：中断

#### 平台驱动注册

include/linux/platform_device.h

##### platform_driver_register()宏

```c
#define platform_driver_register(drv) \
	__platform_driver_register(drv, THIS_MODULE)
extern int __platform_driver_register(struct platform_driver *,
					struct module *);
```



#### 平台驱动获取资源

drivers/base/platform.c

##### platform_get_resource()函数

获取一个device的资源信息

```c
struct resource *platform_get_resource(struct platform_device *dev, unsigned int type, unsigned int num)
```

- dev：平台设备
- type：资源类型
- num：resources数组中资源编号

	## 代码实现

```c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/mod_devicetable.h>
#include <linux/platform_device.h>

#define CCM_CCGR1 																			  0x20C406C		//时钟控制寄存器
#define IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO04 			  0x20E006C	  //GPIO1_04复用功能选择寄存器
#define IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO04 			  0x20E02F8	  //PAD属性设置寄存器
#define GPIO1_GDIR 									0x0209C004	//GPIO方向设置寄存器（输入或输出）
#define GPIO1_DR 									0x0209C000  //GPIO输出状态寄存器
#define REGISTER_LENGTH		 						4			//寄存器长度

/*定义平台设备的硬件资源列表*/
static struct resource rled_resource[] = {
	
	[0] = {
		.start 	= GPIO1_DR,
		.end 	= (GPIO1_DR + REGISTER_LENGTH - 1),
		.flags 	= IORESOURCE_MEM,
	},	
	[1] = {
		.start	= GPIO1_GDIR,
		.end	= (GPIO1_GDIR + REGISTER_LENGTH - 1),
		.flags	= IORESOURCE_MEM,
	},
	[2] = {
		.start	= IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO04,
		.end	= (IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO04 + REGISTER_LENGTH - 1),
		.flags	= IORESOURCE_MEM,
	},
	[3] = {
		.start	= CCM_CCGR1,
		.end	= (CCM_CCGR1 + REGISTER_LENGTH - 1),
		.flags	= IORESOURCE_MEM,
	},
	[4] = {
		.start	= IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO04,
		.end	= (IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO04 + REGISTER_LENGTH - 1),
		.flags	= IORESOURCE_MEM,
	},
};

/*释放paltform设备模块时执行*/
static void	rled_release(struct device *dev)
{
	printk(KERN_ALERT "led device released!\r\n");	
}

/*定义平台设备*/
static struct platform_device rled_pdev = {
	.name = "imx6ull-rled", // 使用名字进行匹配
	.id = -1, // 防止有多个同名的设备
	.dev.release  = rled_release,
	.num_resources = ARRAY_SIZE(rled_resource), // 记录元素的大小
	.resource = rled_resource,
};

/*模块入口函数，注册平台设备*/
static __init int leddevice_init(void)
{
	printk(KERN_ALERT "leddevice_init\r\n");
	platform_device_register(&rled_pdev);
	return 0;
}

/*模块退出函数，注销平台设备*/
static __exit void leddevice_exit(void)
{
	platform_device_unregister(&rled_pdev);
}

module_init(leddevice_init);
module_exit(leddevice_exit);


MODULE_LICENSE("GPL");
MODULE_AUTHOR("embedfire ");
MODULE_DESCRIPTION("led_module");
MODULE_ALIAS("led_module");
```

```c
#include <linux/module.h>
#include <linux/init.h>
#include <linux/kernel.h>

#include <linux/fs.h>
#include <linux/uaccess.h>
#include <asm/io.h>

#include <linux/mod_devicetable.h>
#include <linux/platform_device.h>
#include <linux/device.h>

#define DEV_MAJOR		0		/* 动态申请主设备号 */
#define DEV_NAME		"red_led" 	/*led设备名字 */

/* GPIO虚拟地址指针 */
static void __iomem *IMX6U_CCM_CCGR1;
static void __iomem *SW_MUX_GPIO1_IO04;
static void __iomem *SW_PAD_GPIO1_IO04;
static void __iomem *GPIO1_DR;
static void __iomem *GPIO1_GDIR;

static int led_open(struct inode *inode, struct file *filp)
{
	return 0;
}

static ssize_t led_read(struct file *filp, char __user *buf, size_t cnt, loff_t *offt)
{
	return -EFAULT;
}

static ssize_t led_write(struct file *filp, const char __user *buf, size_t cnt, loff_t *offt)
{

	unsigned char databuf[10];

	if(cnt >10)
		cnt =10;
		
    /*从用户空间拷贝数据到内核空间*/
    if(copy_from_user(databuf, buf, cnt)){
		return -EIO;
	}
    	
	if(!memcmp(databuf,"on",2)) {	
		iowrite32(0 << 4, GPIO1_DR);	
	} else if(!memcmp(databuf,"off",3)) {
		iowrite32(1 << 4, GPIO1_DR);
	}
	/*写成功后，返回写入的字数*/
	return cnt;
}

static int led_release(struct inode *inode, struct file *filp)
{
	return 0;
}

/* 自定义led的file_operations 接口*/
static struct file_operations led_fops = {
	.owner = THIS_MODULE,
	.open = led_open,
	.read = led_read,
	.write = led_write,
	.release = 	led_release,
};


int major = 0;
struct class *class_led;
static int led_probe(struct platform_device *pdev)
{

	struct resource *mem_dr;
	struct resource *mem_gdir;
	struct resource *mem_iomuxc_mux;
	struct resource *mem_ccm_ccgrx;
	struct resource *mem_iomux_pad; 

	printk(KERN_ALERT "led_probe\r\n");
    // 获取资源的地址
	mem_dr = platform_get_resource(pdev, IORESOURCE_MEM, 0);
	mem_gdir = platform_get_resource(pdev, IORESOURCE_MEM, 1);
	mem_iomuxc_mux = platform_get_resource(pdev, IORESOURCE_MEM, 2);
	mem_ccm_ccgrx = platform_get_resource(pdev, IORESOURCE_MEM, 3);
	mem_iomux_pad = platform_get_resource(pdev, IORESOURCE_MEM, 4);

	/* GPIO相关寄存器映射 */
  	IMX6U_CCM_CCGR1 = ioremap(mem_ccm_ccgrx->start,resource_size(mem_ccm_ccgrx));
	SW_MUX_GPIO1_IO04 = ioremap(mem_iomuxc_mux->start,resource_size(mem_iomuxc_mux));
  	SW_PAD_GPIO1_IO04 = ioremap(mem_iomux_pad->start,resource_size(mem_iomux_pad));
	GPIO1_GDIR = ioremap(mem_gdir->start, resource_size(mem_gdir));
	GPIO1_DR = ioremap(mem_dr->start, resource_size(mem_dr));	
		
		
	/* 使能GPIO1时钟 */
	iowrite32(0xffffffff, IMX6U_CCM_CCGR1);

	/* 设置GPIO1_IO04复用为普通GPIO*/
	iowrite32(5, SW_MUX_GPIO1_IO04);
	
    /*设置GPIO属性*/
	iowrite32(0x10B0, SW_PAD_GPIO1_IO04);

	/* 设置GPIO1_IO04为输出功能 */
	iowrite32(1 << 4, GPIO1_GDIR);

	/* LED输出高电平 */
	iowrite32(1<< 4, GPIO1_DR);	

	/* 注册字符设备驱动 */
	major = register_chrdev(DEV_MAJOR, DEV_NAME, &led_fops);
    printk(KERN_ALERT "led major:%d\n",major);

	/*创建/sys/class/xxx目录项*/
	class_led = class_create(THIS_MODULE, "xxx");

	/*创建/sys/class/xxx/my_led目录项，并生成dev属性文件*/
	device_create(class_led, NULL, MKDEV(major, 0), NULL,"my_led");

	return 0;
}

static int led_remove(struct platform_device *dev)
{
		/* 取消映射 */
	iounmap(IMX6U_CCM_CCGR1);
	iounmap(SW_MUX_GPIO1_IO04);
	iounmap(SW_PAD_GPIO1_IO04);
	iounmap(GPIO1_DR);
	iounmap(GPIO1_GDIR);

	/* 注销字符设备驱动 */
	unregister_chrdev(major, DEV_NAME);

	/*销毁/sys/class/xxx/my_led目录项*/
	device_destroy(class_led, MKDEV(major, 0));

	/*销毁/sys/class/xxx目录项*/
	class_destroy(class_led);

	return 0;
}

/*与平台设备文件名匹配*/
static struct platform_device_id led_ids[] = {
	{.name = "imx6ull-rled"},
	{}
};

/*定义平台驱动*/
static struct platform_driver led_driver = {
	.driver.name  =   "imx6ull-rled",
	.probe	  = led_probe,
	.remove	  = led_remove,
	.id_table = led_ids, // 匹配的一系列id
};

/*模块入口函数，注册平台驱动*/
static int __init leddriver_init(void)
{
	printk(KERN_ALERT "leddriver_init\r\n");
	return platform_driver_register(&led_driver);
}

/*模块退出函数，注销平台驱动*/
static void __exit leddriver_exit(void)
{
	platform_driver_unregister(&led_driver);
}


module_init(leddriver_init );
module_exit(leddriver_exit);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("embedfire ");
MODULE_DESCRIPTION("led_module");
MODULE_ALIAS("led_module");
```

![image-20250903203244949](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202509032032049.png)
