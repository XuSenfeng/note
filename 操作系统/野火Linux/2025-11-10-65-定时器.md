# Linux定时器

## 时钟节拍

可以在内核配置的时候选择使用的系统时钟的频率

`Kernel Features => Timer freaquency`

Linux 内核使用全局变量 jiffies 来记录系统从启动以来的系统节拍数，系统启动的时候会将 jiffies初始化为0，jiffies定义在文件include/linux/jiffies.h中

jiffies_64和 jiffies其实是同一个东西， jiffies_64用于 64位系统，而jiffies用于32位系统。为了兼容不同的硬件，jiffies 其实就是 jiffies_64 的低 32 位

32位的 jiffies只需要49.7天就发生了绕回，对于64位的 jiffies来说大概需要5.8亿年才能绕回，因此 jiffies_64的绕回忽略不计。处理 32位jiffies的绕回显得尤为重要

![image-20251110101907626](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/mac-picture/image-20251110101907626.png)

如果 unkown超过 known的话，time_after函数返回真，否则返回假。如果 unkown没有超过 known的话 time_before函数返回真，否则返回假。 time_after_eq函数和 time_after函数类似，只是多了判断等于这个条件, 在实际使用的时候需要自己计算超时的时间对应的节拍

![image-20251110174455668](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/mac-picture/image-20251110174455668.png)

可以使用这部分函数实现时间的类型转换

## 基础定时器

这个定时器不是周期性的, 所以可以在处理函数里面重新打开

```c
struct timer_list {
	/*
	 * All fields that change during normal runtime grouped to the
	 * same cacheline
	 */
	struct list_head entry;
	unsigned long expires; // 超时时间记录的是节拍数
	struct tvec_base *base;

	void (*function)(unsigned long); // 处理函数
	unsigned long data; // 个函数传递的值

	int slack;

#ifdef CONFIG_TIMER_STATS
	int start_pid;
	void *start_site;
	char start_comm[16];
#endif
#ifdef CONFIG_LOCKDEP
	struct lockdep_map lockdep_map;
#endif
};
```

### 相关API

```c
void init_timer(struct timer_list *timer);
void add_timer(struct timer_list *timer);
// 在多处理器系统上，定时器可能会在其他的处理器上运行，因此在调用del_timer函数删除定时
// 器之前要先等待其他处理器的定时处理器函数退出
// 返回值：0，定时器还没被激活；1，定时器已经激活
int del_timer(struct timer_list * timer);
// del_timer函数的同步版，会等待其他处理器使用完定时器再删除，del_timer_sync
// 不能使用在中断上下文
// 返回值：0，定时器还没被激活；1，定时器已经激活
int del_timer_sync(struct timer_list *timer);
// 修改定时值，如果定时器还没有激活的话，mod_timer函数会激活定时器
// 返回值：0，调用 mod_timer 函数前定时器未被激活；1，调用 mod_timer 函数前定时器已
// 被激活。
int mod_timer(struct timer_list *timer, unsigned long expires)
```

## 延时

![image-20251110181452162](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/mac-picture/image-20251110181452162.png)