## 软中断和tasklet基础概念

#### 中断函数

软中断上下文具有以下关键特征，这些特征决定了它能做什么和不能做什么：

a) 执行时机：在中断的"下半部"执行

- 软中断处理函数不是在硬件中断发生的那一刻立即执行的（那是上半部）。
- 它们是在上半部完成后，由内核在**相对安全**的时机调度的，比如：
    - 从硬件中断处理程序返回时
    - 在特定的内核线程（如 `ksoftirqd`）中
    - 由内核代码显式调用（如 `local_bh_enable`）

b) 不能睡眠（最关键的约束！）

- **与硬件中断上下文相同**：软中断处理函数**绝对不能调用任何可能引起睡眠的函数**（如 `kmalloc(GFP_KERNEL)`、`mutex_lock`、`wait_event` 等）。
- **原因**：软中断上下文没有属于自己的进程控制块（`task_struct`），它只是在"借用"被中断进程的内核栈。如果它睡眠，调度器将无法正确地保存和恢复上下文，可能导致系统崩溃或严重错误。

c) 可以被硬件中断打断，但不会自我嵌套

- **可以被硬件中断打断**：当一个CPU正在执行软中断时，新的硬件中断可以发生，CPU会转去执行硬件中断的上半部。
- **但通常不会自我嵌套**：在同一个CPU上，内核会防止软中断重入。即一个软中断处理函数在执行时，不会再次被同一个类型的软中断打断。这简化了编程。

d) 当前进程（current宏）指向被中断的进程

- 就像硬件中断上下文一样，`current` 宏指向的是被中断时正在运行的进程。
- **但请注意**：软中断处理函数与这个进程**没有直接关系**，它只是碰巧在这个进程的内核栈上运行。你不能也不应该访问该进程的用户空间内存。

e) 运行时间不宜过长

- 虽然软中断是为了处理比上半部更耗时的任务，但如果一个软中断处理函数运行时间过长，会导致：
    - 用户进程响应延迟
    - 其他软中断得不到及时处理
    - 如果软中断负载很高，内核会唤醒 `ksoftirqd` 内核线程来协助处理

##### 设计原则

- 执行越快越好

##### 根源

- 打断其他重要代码的执行
- 中断函数通常在关中断情况下执行

#### 中断上下半部机制

##### 上半部

传统的中断处理函数

- 表明中断已经被系统捕获
- 对响应时间有苛刻要求的操作

- 执行速度快的操作
- 硬件信号控制
- ...

下半部

非中断处理函数，由上半部设置工作任务

- 数据复制
- 数据包装和转发
- 计算时间长的数据处理
- 读取外部数据
- ...

#### 软中断

中断下半部的一种机制

##### softirq_action结构体

 include/linux/interrupt.h

```c
struct softirq_action
{
	void (*action)(struct softirq_action *); // 处理的具体工作
};
```

##### softirq_vec数组

 kernel/softirq.c

默认有十种软中断, 记录在数组里面

```c
static struct softirq_action softirq_vec[NR_SOFTIRQS];
```

##### NR_SOFTIRQS变量

```c
enum
{
    HI_SOFTIRQ=0, /* 最高优先级软中断 */
    TIMER_SOFTIRQ, /* 定时器软中断 */
    NET_TX_SOFTIRQ, /* 网络数据发送软中断 */
    NET_RX_SOFTIRQ, /* 网络数据接收软中断 */
    BLOCK_SOFTIRQ,	/*块设备软中断*/
    BLOCK_IOPOLL_SOFTIRQ,
    TASKLET_SOFTIRQ, /* tasklet 软中断 */
    SCHED_SOFTIRQ, /* 调度软中断 */
    HRTIMER_SOFTIRQ, /* 高精度定时器软中断  */
    RCU_SOFTIRQ, /* RCU服务软中断  */
    NR_SOFTIRQS
};
```

- 内核已经规定了所有软中断的用法, 默认可以使用的tasklet这个软中断

#### open_softirq()函数

include/linux/interrupt.h

注册一个软中断

```c
void open_softirq(int nr, void (*action)(struct softirq_action *));
```

参数：

- nr：要开启的软中断编号
- action：相应的处理函数

返回值：无

#### raise_softirq()函数

include/linux/interrupt.h

主动触发指定软中断

```c
void raise_softirq(unsigned int nr);
```

参数：

- nr：指定激活的软中断

返回值：无

#### tasklet机制

基于软中断实现的下半部机制，运行在软中断环境下

##### softirq_init()函数

 kernel/softirq.c

默认开机的时候会运行这一个代码

```c
void __init softirq_init(void)
{
	int cpu;

	for_each_possible_cpu(cpu) {
		per_cpu(tasklet_vec, cpu).tail =
			&per_cpu(tasklet_vec, cpu).head;
		per_cpu(tasklet_hi_vec, cpu).tail =
			&per_cpu(tasklet_hi_vec, cpu).head;
	}
	// 注册一下tasklet的处理函数
	open_softirq(TASKLET_SOFTIRQ, tasklet_action);
	open_softirq(HI_SOFTIRQ, tasklet_hi_action);
}
```

内核在初始化时，通过 open_softirq 注册了两个专门用于处理 tasklet 的 softirq

##### tasklet_struct结构体

include/linux/interrupt.h

```c
struct tasklet_struct
{
	struct tasklet_struct *next;
	unsigned long state; // 记录状态
	atomic_t count; // 记录引用的次数
	void (*func)(unsigned long); // 处理任务
	unsigned long data; // function的参数
};
```

- next：下一个tasket
- state：tasklet状态
- count：计数器，记录对tasket的引用数
- func：tasklet执行的函数
- data：函数参数

##### tasklet_init()函数

初始化一个tasket对象

include/linux/interrupt.h

```c
void tasklet_init(struct tasklet_struct *t,
		  void (*func)(unsigned long), unsigned long data)
```

参数：

- t：要初始化的tasket
- func：tasklet执行的函数
- data：函数参数

返回值：无

##### tasklet_schedule()函数

调度执行tasket对象, 设置这个任务的状态

include/linux/interrupt.h

```c
static inline void tasklet_schedule(struct tasklet_struct *t)
```

参数：

- t：要调度的tasket对象

返回值：无

##### tasklet_kill()函数

注销tasket对象

include/linux/interrupt.h

```c
void tasklet_kill(struct tasklet_struct *t);
```

参数：

- t：要注销的tasket对象

返回值：无

## 实际使用

```c

#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/fs.h>
#include <linux/cdev.h>
#include <linux/uaccess.h>
#include <linux/delay.h>
#include <linux/ide.h>
#include <linux/errno.h>
#include <linux/gpio.h>
#include <asm/mach/map.h>
#include <linux/of.h>
#include <linux/of_address.h>
#include <linux/of_gpio.h>
#include <asm/io.h>
#include <linux/device.h>
#include <linux/irq.h>
#include <linux/of_irq.h>


/*------------------字符设备内容----------------------*/
#define DEV_NAME "button"
#define DEV_CNT (1)

static dev_t button_devno;		 //定义字符设备的设备号
static struct cdev button_chr_dev; //定义字符设备结构体chr_dev
struct class *class_button;		 //保存创建的类
struct device *device_button;		 // 保存创建的设备


struct device_node	*button_device_node = NULL;  //定义按键设备节点结构体
unsigned  button_GPIO_number = 0;  //保存button使用的GPIO引脚编号
u32  interrupt_number = 0;         // button 引脚中断编号
atomic_t   button_status = ATOMIC_INIT(0);  //定义整型原子变量，保存按键状态 ，设置初始值为0

struct tasklet_struct button_tasklet;

void tasklet_hander(unsigned long data)
{

	printk(KERN_EMERG "tasklet_hander is running!");

}

static irqreturn_t button_irq_hander(int irq, void *dev_id)
{
	// printk_green("button on \n");
	/*按键状态加一*/
	printk(KERN_EMERG "button_irq_hander is running!");
	atomic_inc(&button_status);
	tasklet_schedule(&button_tasklet);
	printk(KERN_EMERG "button_irq_hander is end!");
	return IRQ_HANDLED;
}

static int button_open(struct inode *inode, struct file *filp)
{
	int error = -1;
	
	
	/*添加初始化代码*/
	// printk_green("button_open");

	/*获取按键 设备树节点*/
	button_device_node = of_find_node_by_path("/button_interrupt");
	if(NULL == button_device_node)
	{
		printk("of_find_node_by_path error!");
		return -1;
	}

	/*获取按键使用的GPIO*/
	button_GPIO_number = of_get_named_gpio(button_device_node ,"button_gpio", 0);
	if(0 == button_GPIO_number)
	{
		printk("of_get_named_gpio error");
		return -1;
	}

	/*申请GPIO  , 记得释放*/
	error = gpio_request(button_GPIO_number, "button_gpio");
	if(error < 0)
	{
		printk("gpio_request error");
		gpio_free(button_GPIO_number);
		return -1;
	}

	error = gpio_direction_input(button_GPIO_number);//设置引脚为输入模式

	/*获取中断号*/
	interrupt_number = irq_of_parse_and_map(button_device_node, 0);
	printk("\n irq_of_parse_and_map! =  %d \n",interrupt_number);


	/*申请中断, 记得释放*/
	error = request_irq(interrupt_number,button_irq_hander,IRQF_TRIGGER_RISING,"button_interrupt",device_button);
	if(error != 0)
	{
		printk("request_irq error");
		free_irq(interrupt_number, device_button);
		return -1;
	}

	/*申请之后已经开启了，切记不要再次打开，否则运行时报错*/
	// // enable_irq(interrupt_number);

	return 0;

}

static int button_read(struct file *filp, char __user *buf, size_t cnt, loff_t *offt)
{
	int error = -1;
	int button_countervc = 0;

	/*读取按键状态值*/
	button_countervc = atomic_read(&button_status);

	/*结果拷贝到用户空间*/
	error = copy_to_user(buf, &button_countervc, sizeof(button_countervc));
	if(error < 0)
	{
		printk("copy_to_user error");
		return -1;
	}

	/*清零按键状态值*/
	atomic_set(&button_status,0);
	return 0;
}

/*字符设备操作函数集，.release函数实现*/
static int button_release(struct inode *inode, struct file *filp)
{
	/*释放申请的引脚,和中断*/
	gpio_free(button_GPIO_number);
	free_irq(interrupt_number, device_button);
	return 0;
}



/*字符设备操作函数集*/
static struct file_operations button_chr_dev_fops = {
	.owner = THIS_MODULE,
	.open = button_open,
	.read = button_read,
	.release = button_release};

/*
*驱动初始化函数
*/
static int __init button_driver_init(void)
{
	int error = -1;

	/*采用动态分配的方式，获取设备编号，次设备号为0，*/
	error = alloc_chrdev_region(&button_devno, 0, DEV_CNT, DEV_NAME);
	if (error < 0)
	{
		printk("fail to alloc button_devno\n");
		goto alloc_err;
	}

	/*关联字符设备结构体cdev与文件操作结构体file_operations*/
	button_chr_dev.owner = THIS_MODULE;
	cdev_init(&button_chr_dev, &button_chr_dev_fops);

	/*添加设备至cdev_map散列表中*/ 
	error = cdev_add(&button_chr_dev, button_devno, DEV_CNT);
	if (error < 0) 
	{
		printk("fail to add cdev\n");
		goto add_err;
	}

	class_button = class_create(THIS_MODULE, DEV_NAME);                         //创建类
	device_button = device_create(class_button, NULL, button_devno, NULL, DEV_NAME);//创建设备 DEV_NAME 指定设备名，

	tasklet_init(&button_tasklet,tasklet_hander,0);

	return 0;

add_err:
	unregister_chrdev_region(button_devno, DEV_CNT);    // 添加设备失败时，需要注销设备号
	printk("\n error! \n");
	
alloc_err:
	return -1;
}



/*
*驱动注销函数
*/
static void __exit button_driver_exit(void)
{
	pr_info("button_driver_exit\n");
	/*删除设备*/
	tasklet_kill(&button_tasklet);
	device_destroy(class_button, button_devno);		   //清除设备
	class_destroy(class_button);					   //清除类
	cdev_del(&button_chr_dev);					       //清除设备号
	unregister_chrdev_region(button_devno, DEV_CNT);   //取消注册字符设备
}



module_init(button_driver_init);
module_exit(button_driver_exit);

MODULE_LICENSE("GPL");
```

