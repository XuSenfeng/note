# uevent

kobject对象可以通过uevent机制往用户空间发送信息, 主要是驱动设备使用的

![image-20250719153349309](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507191533370.png)

- kobject_uevent：内核消息发送接口
    - 广播方式发送
- NETLINK：特殊的网络通信，本地主机使用
    - 传统做法是内核执行*hotplug*程序进行消息通知（效率低、不优雅）

- udev/mdev：用户空间守护进程，监听广播信息
    - 默认开机启动, debian系统使用的是udev，通过systemd进行启动
    - udevadm monitor指令：打印uevent事件

####  内核消息发送

##### 消息类型

```c
enum kobject_action {
	KOBJ_ADD,
	KOBJ_REMOVE,
	KOBJ_CHANGE,
	KOBJ_MOVE,
	KOBJ_ONLINE,
	KOBJ_OFFLINE,
	KOBJ_BIND,
	KOBJ_UNBIND,
	KOBJ_MAX
};
```

##### kobject_uevent()函数

通常使用的发送消息的函数

```c
int kobject_uevent(struct kobject *kobj, enum kobject_action action)
{
	return kobject_uevent_env(kobj, action, NULL);
}
```

##### kobject_uevent_env()函数

使用kobject找到一个最上层的kset对象, 使用他的uevent_ops里面的部分函数, 实际不初始化可以可以发送的, 主要是使用里面的过滤函数和标志位

```c
int kobject_uevent_env(struct kobject *kobj, enum kobject_action action,
		       char *envp_ext[])
{
	struct kobj_uevent_env *env;
	...
	top_kobj = kobj;
	/*while循坏查找kobj所隶属的最顶层kobject或者kset指针不为空的kobj*/
	while (!top_kobj->kset && top_kobj->parent)
		top_kobj = top_kobj->parent;
	/*判断kobj的kset指针是否为空, 只有有kset的时候才可以进行*/
	if (!top_kobj->kset) {
		pr_debug("kobject: '%s' (%p): %s: attempted to send uevent "
			 "without kset!\n", kobject_name(kobj), kobj,
			 __func__);
		return -EINVAL;
	}
	/*得到kobj指向的kset对象*/
	kset = top_kobj->kset;
	/*获取kset的uevent_ops*/
	uevent_ops = kset->uevent_ops;
	/*若kobject->uevent_suppress为1，表示kobj不适用uevent*/
	if (kobj->uevent_suppress) {
		pr_debug("kobject: '%s' (%p): %s: uevent_suppress "
				 "caused the event to drop!\n",
				 kobject_name(kobj), kobj, __func__);
		return 0;
	}
	/*过滤event事件, filter执行为0的时候过滤*/
	if (uevent_ops && uevent_ops->filter)
		if (!uevent_ops->filter(kset, kobj)) {
			pr_debug("kobject: '%s' (%p): %s: filter function "
				 "caused the event to drop!\n",
				 kobject_name(kobj), kobj, __func__);
			return 0;
		}
	...
	/* environment buffer */
	env = kzalloc(sizeof(struct kobj_uevent_env), GFP_KERNEL);
	if (!env)
		return -ENOMEM;

	/* 获取kobj在sysfs中的路径 */
	devpath = kobject_get_path(kobj, GFP_KERNEL);
	if (!devpath) {
		retval = -ENOENT;
		goto exit;
	}

	/* 消息内容 记录路径, 事件的string, 上层节点*/
	retval = add_uevent_var(env, "ACTION=%s", action_string);
	if (retval)
		goto exit;
	retval = add_uevent_var(env, "DEVPATH=%s", devpath);
	if (retval)
		goto exit;
	retval = add_uevent_var(env, "SUBSYSTEM=%s", subsystem);
	if (retval)
		goto exit;

	...
	
	if (uevent_ops && uevent_ops->uevent) {
		retval = uevent_ops->uevent(kset, kobj, env);
		if (retval) {
			pr_debug("kobject: '%s' (%p): %s: uevent() returned "
				 "%d\n", kobject_name(kobj), kobj,
				 __func__, retval);
			goto exit;
		}
	}
	...
	/*本地socket通信，发送广播信息*/
	retval = kobject_uevent_net_broadcast(kobj, env, action_string,
					      devpath);
	...
 }
```

## 代码实现

```c
static int __init led_init(void)
{
	int retval;

	/* GPIO相关寄存器映射 */
  	IMX6U_CCM_CCGR1 = ioremap(0x20c406c, 4);
	SW_MUX_GPIO1_IO04 = ioremap(0x20e006c, 4);
  	SW_PAD_GPIO1_IO04 = ioremap(0x20e02f8, 4);
	GPIO1_GDIR = ioremap(0x0209c004, 4);
	GPIO1_DR = ioremap(0x0209c000, 4);


	/* 使能GPIO1时钟 */
	iowrite32(0xffffffff, IMX6U_CCM_CCGR1);

	/* 设置GPIO1_IO04复用为普通GPIO*/
	iowrite32(5, SW_MUX_GPIO1_IO04);
	
    /*设置GPIO属性*/
	iowrite32(0x10B0, SW_PAD_GPIO1_IO04);

	/* 设置GPIO1_IO04为输出功能 */
	iowrite32(1 << 4, GPIO1_GDIR);

	/* LED输出高电平 */
	iowrite32(1<< 4, GPIO1_DR);

	/*创建一个kset对象*/
	example_kset = kset_create_and_add("kset_example", NULL, NULL);
	if (!example_kset)
		return -ENOMEM;

	/* 创建一个kobject对象*/
	led_kobj = kobject_create_and_add("led_kobject", &example_kset->kobj);
	// 设置一下父对象的kset, 之后会使用这个
	led_kobj->kset = example_kset;
	if (!led_kobj)
		return -ENOMEM;

	/* 为kobject设置属性文件*/
	retval = sysfs_create_group(led_kobj, &attr_group);
	if (retval)
		kobject_put(led_kobj);

	kobject_uevent(led_kobj, KOBJ_ADD);

	return retval;

	return 0;
}


static void __exit led_exit(void)
{
	/* 取消映射 */
	iounmap(IMX6U_CCM_CCGR1);
	iounmap(SW_MUX_GPIO1_IO04);
	iounmap(SW_PAD_GPIO1_IO04);
	iounmap(GPIO1_DR);
	iounmap(GPIO1_GDIR);

	/* 注销字符设备驱动 */
	kobject_put(led_kobj);

	/*取消字符设备的注册*/
	kset_unregister(example_kset);
}
```



![image-20250719160839870](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507191608931.png)

第一条是内核自己的打印, 第二个是自己发送的