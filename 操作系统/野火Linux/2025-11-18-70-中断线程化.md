# 中断线程化

## 概念

在中断函数中断上文的同步触发的情况下，中断下文基于内核机制在线程或者进程中同步处理。甚至中断上文触发函数都不要了 设为null,直接触发中断下文的 中断线程化机制 处理 延时、阻塞业务。

```c
int request_threaded_irq(unsigned int irq, irq_handler_t handler,
  irq_handler_t thread_fn, unsigned long irqflags,
  const char *devname, void *dev_id);
```

+   irq： 中断号， 表示要请求的中断线路。
+   handler： 是在发生中断时首先要执行的处理程序， 非常类似于顶半部， 该函数最后会返回 IRQ_WAKE_THREAD 来唤醒中断， 一般 handler 设为 NULL， 用系统提供的默认处理。
+   thread_fn： 线程化的中断处理函数， 非常类似于底半部。 如果此处设置为 NULL 则表示没有使用中断线程化。
+   irqflags： 中断标志， 用于指定中断的属性和行为。
+   devname： 中断的名称， 用于标识中断请求的设备。
+   dev_id： 设备标识符， 用于传递给中断处理函数的参数。

>   对于触摸屏而言只要手指放到屏幕上，它可能就会一直产生中断(视具体芯片而定，FT5426是这样的)，中断处理程序里面需要通过 I2C读取触摸信息并上报给内核，I2C的速度最大只有 400KHz，算是低速外设。不断的产生中断、读取触摸信息、上报信息会导致处理器在触摸中断上花费大量的时间，但是触摸相对来说不是那么重要的事件，因此可以将触摸中断线程化
