# BusyBox

BusyBox 就是一个大的工具箱，这个工具箱里面集成了Linux的许多工具和命令, 是一个比较基础的构建根文件系统的工具

https://busybox.net/

## Makefile

在Makefile文件里面加入`CROSS_COMPILE ?= /usr/bin/arm-linux/gnueabihf-`以及`ARCH ?= arm`这两个选项

## 中文支持

打开文件`busybox-1.2 9.0/libbb/printable_string.c`，找到函数`printable_string`

把这个函数里面的对于大于0x7f跳出的判断注释掉

之后是文件busybox-1.29.0/libbb/unicode.c里面unicode_conv_to_printable2函数, 这个函数也是把关于0x7f的判断去除

后面的使能unicode编码在配置的时候进行

## 配置

在配置busy的时候有三个可以使用的默认配置

+ defconfig: 缺省的配置, 默认的配置
+ allyesconfig: 使能所有的功能
+ allnoconfig: 最小的配置

一般使用`make defconfig`加载默认的配置

之后可以使用`make menuconfig`进行配置的进一步控制

1. 使用动态编译, 文件系统里面有库的形式, 这个不要选择

`Settings => Build static binary no shared libs`

2. 使用vi style的命令行, 选中

`Settings => vi-style line editing commands` 

3. 不使用精简的命令集合, 这个不选择, 使用完整的命令

`Linux Module Utilities => Simplified modutils`

4. 使能mdev, 这个是用于动态的生成/dev文件夹下面的节点文件的, 全部选择

`Linux System Utilities => mdev (16kb)`

5. 使能Unicode, 选中下面的两个选项

`Settings -> Support Unicode //选中 -> Check $LC_ALL, $LC_CTYPE and $LANG environment variables`

## 编译

```bash
make 
make install CONFIG_PREFIX=实际生成的路径位置
```

rootfs 目录下有bin、sbin 和usr 这三个目录，以及linuxrc这个文件,

Linux 内核init 进程最后会查找用户空间的init 程序，找到以后就会运行这个用户空间的init程序，从而切换到用户态。如果bootargs设置init=/linuxrc，那么linuxrc就是可以作为用户空间的init程序，所以用户态空间的init程序是busybox来生成的

## 添加库文件

之前指定的交叉编译器使用了库文件, 所以需要把库文件加过来, 在生成的根目录下面创建一个lib目录, 交叉编译器的库目录在

`/usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/lib`里面

`cp *so* *.a ./lib/ -d `主要作用是“保持符号链接本身不跟随（不解引用）”，把链接文件本身复制，而不是复制链接指向的目标文件

> 有个比较特殊的库文件：ld-linux-armhf.so.3，此库文件也是个符号链接。会链接到库ld-2.19-2014.08-1-git.so 上
>
> ld-linu x-armhf.so.3 不能作为符号链接，否则的话在根文件系统中执行程序无法执行, 使用`cp ld-linux-armhf.so.3 ./lib`

`/usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/lib`这个目录里面的也需要复制

之后创建`/usr/lib`, 复制`/usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/arm-linux-gnueabihf/libc/ usr/lib`目录里面的文件

之后在根文件系统中创建其他文件夹，如dev、proc、mnt、sys、tmp和root等

## 添加初始化文件

### /etc/fstab

这个文件用于配置fstab在Linux启动以后需要自动挂载的分区

```bash
<file system>    <mount point>   <type>    <options>    <dump>    <pass> 
```

+ `<file system>`：要挂载的特殊的设备，也可以是块设备，比如/dev/sda等等。
+ ` <mount point>`：挂载点。
+  `<type>`：文件系统类型，比如ext2、ext3、proc、romfs、tmpfs等等。 
+ `<options>`：挂载选项，在Ubuntu中输入“man mount”命令可以查看具体的选项。一般使用defaults，也就是默认选项，defaults包含了rw、suid、 dev、 exec、 auto、 nouser和 asyn c。 
+ `<dump>`：为1的话表示允许备份，为0不备份，一般不备份，因此设置为0。 
+ `<pass>`：磁盘检查设置，为0表示不检查。根目录‘/’设置为1，其他的都不能设置为1，其他的分区从2开始。一般不在fstab中挂载根目录，因此这里一般设置为0。  

实际的文件示例如下

```
#<file system> <mount point>  <type>   <options>   <dump>  <pass> 
 proc              /proc       proc        defaults    0        0 
tmpfs             /tmp         tmpfs       defaults    0        0 
sysfs             /sys         sysfs       defaults    0        0 
```

> proc 是进程管理的文件系统
>
> tmpfs 可以使用您的内存或 swap 分区来存储文件。tmpfs 既可以使用物理内存，也可以使用交换分区，因为 tmpfs 使用的是 “ 虚拟内存 ” 。 Linux 内核的虚拟内存同时来源于物理内存和交换分区，主要由内核中的 VM 子系统进行调度，进行内存页和 SWAP 的换入和换出操作， tmpfs 自己并不知道这些页面是在交换分区还是在物理内存中
>
> Sysfs 连接在系统上的设备和总线组织成为一个分级的文件，它们可以被从用户的空间存取到

### /etc/init.d/rcS

Linux内核启动以后需要启动一些服务，而rcS就是规定启动哪些文件的脚本文件

```bash
#!/bin/sh 

PATH=/sbin:/bin:/usr/sbin:/usr/bin:$PATH # 设置环境变量
D_LIBRARY_PATH=$LD_LIBRARY_PATH:/lib:/usr/lib  # 设置库文件的位置
export PATH LD_LIBRARY_PATH  
 
mount -a # 使用/etc/fstab 挂载所有的文件系统
mkdir /dev/pts 
mount -t devpts devpts /dev/pts 

echo /sbin/mdev > /proc/sys/kernel/hotplug  # 使用mdev管理热插拔设备 
mdev -s 
```

>  这个文件需要可执行权限

### /etc/inittab

可以参考 busybox 下的文件 examples/inittab。init 程序会读取/etc/inittab这个文件，inittab由若干条指令组成。每条指令的结构都是一样的，由以“:”分隔的4个段组成

`<id>:<runlevels>:<action>:<process> `

+ `<id>`：每个指令的标识符，不能重复。但是对于busybox的init来说，`<id>`有着特殊意义。对于busybox 而言`<id>`用来指定启动进程的控制 tty，一般我们将串口或者LCD 屏幕设置为控制tty。
+ ` <runlevels>`：对 busybox 来说此项完全没用，所以空着。
+ ` <action>`：动作，用于指定`<process>`可能用到的动作。

![image-20251102110959211](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/mac-picture/image-20251102110959211.png)

![image-20251102111023394](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/mac-picture/image-20251102111023394.png)

+ `<process>`：具体的动作，比如程序、脚本或命令等

```
#etc/inittab 
::sysinit:/etc/init.d/rcS 
console::askfirst:-/bin/sh 
::restart:/sbin/init 
::ctrlaltdel:/sbin/reboot 
::shutdown:/bin/umount -a -r 
::shutdown:/sbin/swapoff -a
```



## 测试

使用的是nfs的测试方式

把bootargs里面的root改为下面的形式即可从nfs启动

```bash
root=/dev/nfs nfsroot=[<server-ip>:]<root-dir>[,<nfs-options>] ip=<client-ip>:<server-ip>:<gw-ip>:<netmask>:<hostname>:<device>:<autoconf>:<dns0-ip>:<dns1-ip>
```

> <server-ip>：服务器 IP 地址，也就是存放根文件系统主机的IP地址，那就是Ubuntu的I P 地址，比如我的Ubuntu主机IP地址为192.168.1.250。 
>
> <root-dir>：根文件系统的存放路径，比如我的就是/home/zuozhongkai/linux/nfs/rootfs。 
>
> <nfs-options>：NFS 的其他可选选项，一般不设置。 
>
> <client-ip>：客户端 IP 地址，也就是我们开发板的IP地址，Linux内核启动以后就会使用此IP地址来配置开发板。此地址一定要和Ubuntu主机在同一个网段内，并且没有被其他的设备使用，在Ubuntu中使用ping命令ping一下就知道要设置的IP地址有没有被使用，如果不能ping 通就说明没有被使用，那么就可以设置为开发板的IP地址，比如我就可以设置为192.168. 1.251。 
>
> <server-ip>：服务器 IP 地址，前面已经说了。 
>
> <gw-ip>：网关地址，我的就是192.168.1.1。 
>
> <netmask>：子网掩码，我的就是255.255.255.0。 
>
> <hostname>：客户机的名字，一般不设置，此值可以空着。 
>
> <device>：设备名，也就是网卡名，一般是eth0，eth1….，正点原子的I.MX6U-ALPHA开发板的ENET2为eth0，ENET1 为eth1。如果你的电脑只有一个网卡，那么基本只能是eth0。这里我们使用ENET2，所以网卡名就是eth0。 
>
> <autoconf>：自动配置，一般不使用，所以设置为off。 
>
> <dns0-ip>：DNS0 服务器IP地址，不使用。 
>
> <dns1-ip>：DNS1 服务器IP地址，不使用。 

测试的示例是

```bash
root=/dev/nfs nfsroot=192.168.1.250:/home/zuozhongkai/linux/nfs/rootfs,proto=tcp rw ip=192.168.1.251:192.168.1.250:192.168.1.1:255.255.255.0::eth0:off 
```

## 网络获取

在使用这个根文件系统连接网络的时候, 首先使用`ifconfig eth0 up`开启网卡

之后使用`udhcp -i eth0`动态获取ip(需要尾灯的配置)

连接电脑的时候可以使用`ifconfig eth0 ip地址 netmask 子网掩码`的方式进行设置, 可以使用`route add default gw ip地址`的方式添加默认的网关

