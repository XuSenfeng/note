---
layout: post
title: "多任务" 
date:   2024-5-14 15:39:08 +0800
tags: python基础
---

# 多线程

多任务:同时可以运行多个任务

一个程序可以同时执行多个事件, 就是一个多任务的程序, 实际是程序之间的快速轮转

````python
from time import sleep
import threading

def sing():
    for i in range(5):
        print("Singing...")
        sleep(1)

def dance():
    for i in range(5):
        print("Dancing...")
        sleep(1)

if __name__ == "__main__":
    t1 = threading.Thread(target=sing)
    t2 = threading.Thread(target=dance)
    t1.start() # start the thread
    t2.start()
    t1.join() # wait for the thread to finish
    t2.join()
    print("Main thread is over.")
````

> 并发: 假的多任务, 快速切换实现
>
> 并行: 真的多任务

python里面有一个thread模块, 但是比较底层, 建议使用threading的封装 

## threading使用

### 基础使用

```python
t1 = threading.Thread(target=dance) # 获取一个线程, 这一个线程执行dance这一个函数
t1.start() # start the thread
```

> 可以使用Thread这一个类创建一个线程, 创建以后不会立即执行, 需要使用start进行启动, 这一个线程会使用创建的时候target参数指定的执行的代码
>
> 主线程的代码结束以后不会立即结束, 而是会等待子线程的结束, 为了回收垃圾, 子线程执行完以后则会直接结束

### 获取线程数量

```python
print(threading.enumerate())
```

> ```bash
> [<_MainThread(MainThread, started 16076)>, <Thread(Thread-1 (dance), started 104)>, <Thread(Thread-2 (dance), started 
> 35924)>, <Thread(Thread-3 (dance), started 5528)>, <Thread(Thread-4 (dance), started 11448)>, <Thread(Thread-5 (dance), started 
> 33788)>]
> ```
>
> 获取一个列表, 这一个列表里面有现在的线程

### 传递参数

```python
t = threading.Thread(target=dance, args=("John", i + 18))
```

> 这一个args是一个元组, 这一个元组会被拆包传递给这一个函数

还可以通过字典的方式进行传递参数

```python
t = threading.Thread(target=dance, kwargs={"name": "Alice", "age": i+18})
```

### 继承的方式创建

```python
from time import sleep
import threading

class MyThread(threading.Thread):
    def __init__(self, name):
        threading.Thread.__init__(self)
        self.name = name

    def run(self):
        print(f"Thread {self.name} started")
        sleep(2)
        print(f"Thread {self.name} finished")


if __name__ == "__main__":
    threads = []
    for i in range(3):
        thread = MyThread(name=f"Thread-{i}")
        threads.append(thread)
        thread.start()
    for thread in threads:
        thread.join()
    print("Main thread finished")
```

> 在调用start函数以后会执行这一个类里面的run方法
>
> 这一个类结束的时候会调用`__del__`可以在这一个类里面处理需要关闭的信息等

## 互斥锁

使用全局变量的时候需要使用互斥锁进行保护

```python
mutex = threading.Lock()
mutex.acquire()
mutex.release()
```

> 这一个是不可以重入的锁
>
> ```python
> acquire(blocking=True, timeout=-1) # 时间是按秒计算的
> ```

```python
mutex = threading.RLock()
```

> 这一个锁是可以重入的

## 栅栏对象

在所有的线程都调用with以后这一个线程才会被允许继续进行

```python
b = Barrier(2, timeout=5) # 两个, 5秒以后超时

def server():
    start_server()
    b.wait()
    while True:
        connection = accept_connection()
        process_server_connection(connection)

def client():
    b.wait()
    while True:
        connection = make_connection()
        process_client_connection(connection)
```

# 多进程

```python
import multiprocessing as mp
import time 

def test():
    """This function will be run by a separate process"""
    while True:
        print("Hello from the child process")
        time.sleep(1)

if __name__ == "__main__":
    # Create a new process
    p = mp.Process(target=test)
    # Start the process
    p.start()
    while True:
        print("Hello from the main process")
        time.sleep(1)
```

```python
import multiprocessing as mp
import time 

class MyProcess(mp.Process):
    def __init__(self, name):
        super().__init__()
        self.name = name

    def run(self):
        while True:
            print(f"Process {self.name} is running")
            time.sleep(1)
            print(f"Process {self.name} is done")


if __name__ == "__main__":
    p1 = MyProcess("p1")
    p2 = MyProcess("p2")

    p1.start()
    p2.start()
```

> 可以使用以上的两种方法实现一个进程

## 参数传递

```python
def test(name, age, m):
    pass
mp.Process(target=test, args=("jiao", 21), kwargs={"m", 20})
```

## 变量

进程里面的全局变量是不共享的

