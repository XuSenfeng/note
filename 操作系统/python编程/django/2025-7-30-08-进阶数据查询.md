# 进阶数据查询

## 过滤条件

ORM在内部生成SQL中的where子句时，提供3个方法可以帮我们实现where过滤操作，包括：

- **filter** 过滤出符合条件的多个结果
- exclude 排除掉符合条件的多个结果，与filter相反，与filter互斥。
- **get** 过滤单一结果, 结果不是一个，会报错。

对于过滤条件的使用，上述三个方法相同，但是互斥的，只能使用任意1个，故仅以**filter**进行讲解。

文档：https://docs.djangoproject.com/zh-hans/4.2/ref/models/querysets/#field-lookups

ORM使用过程中，设置查询过滤条件的表达语法，如下：

```python
# 单表的过滤:
模型类.objects.filter(属性名称__运算符=值)  # 此处的运算符是django的ORM提供的英文单词的运算符，与python的运算符不一样，例如ORM的大于是gt，大于等于是gte。
模型类.objects.exclude(属性名称__运算符=值) 
模型类.objects.get(属性名称__运算符=值) 

# 多表的过滤
模型类.objects.filter(外键属性名称__外键模型的属性名称__运算符=值)
模型类.objects.exclude(外键属性名称__外键模型的属性名称__运算符=值)
模型类.objects.get(外键属性名称__外键模型的属性名称__运算符=值)
# 属性名称和比较运算符间使用两个英文下划线，所以这就是为什么，之前声明模型类，规定了属性名不能包括多个下划线
```

> 1. 外键属性名称
>     - 当前模型（你正在查询的模型）中定义的**外键字段名**
>     - 即 `models.ForeignKey` 字段的名称
>     - 它指向另一个模型（关联模型）
> 2. 外键模型的属性名称
>     - 被关联模型（外键指向的模型）中的**字段名**
>     - 你想基于这个字段的值进行查询

#### 1. 相等

**exact：表示判断值是否相等。**

例：查询学生信息。

```python
"""exact 过滤相等的条件"""
# student_list = Student.objects.filter(name__exact="吴杰").all()
student_list = Student.objects.filter(name="吴杰").all()  # 简写方式，这个最常用！！
print(student_list)
return HttpResponse("OK")
```

#### 2. 模糊查询

**contains：是否包含。**

> 说明：如果要包含%无需转义，直接写即可。

例：查询姓名包含'华'的学生。

```python
"""模糊查询[简单数据表才使用这个，数据量大了不要使用这个，改用全文搜索，使用专业的搜索引擎]"""
# name__contains -> 包含 ---> name like "%华%"
student1 = Student.objects.filter(name__contains='华')
# print(student1)
```

**startswith、endswith：以指定值开头或结尾。**

例：查询姓名以'华'结尾的学生

```python
# name__endswith -> 结尾 ---> name like "%华"
student2 = Student.objects.filter(name__endswith='华')
# print(student2)

# name__startswith->开头 ---> name like "江%"
student3 = Student.objects.filter(name__startswith="江")
print(student3)
```

> 以上运算符都区分大小写，在这些运算符前加上i表示不区分字母大小写，如iexact、icontains、istartswith、iendswith.

#### 3. 空查询

**isnull：字段值是否为null。**

例：查询个性签名不为空的学生。

```python
# 添加测试数据,SQL语句
INSERT INTO student (name, age, sex, class, description, status, created_time, updated_time, mobile) VALUES ('刘德华', 17, 1, '407', null, 0, '2020-11-20 10:00:00.000000', '2020-11-20 10:00:00.000000', '15067895432');

# 代码操作
"""空查询"""
student = Student.objects.filter(description__isnull=True)
print(student)
```

#### 4. 范围查询

**in：是否包含在范围内。**

例：查询班级编号为301,302或303的学生

```python
"""范围查询"""
student = Student.objects.filter(classmate__in=[301, 302, 303]).all().values("id", "name", "classmate")
print(student)
```

#### 5. 取值范围

range 设置开始值与结束值范围，进行数值判断，符合范围的数据被查询出来。不仅可以设置数值范围，也可以设置时间范围。

例如：查询出学号id在51~67之间的。

```python
"""取值范围"""
# SQL: SELECT ... WHERE id BETWEEN 51 and 67; 
student_list = Student.objects.filter(id__range=(51, 67)).values("id", "name")
print(student_list)
return HttpResponse("ok")
```

#### 6. 比较查询

- **gt** 大于 (greater then)
- **gte** 大于等于 (greater then equal)
- **lt** 小于 (less then)
- **lte** 小于等于 (less then equal)

例：查询编号大于3的学生

```python
        """比较查询"""
        # # 年龄大于20的
        # # age__gt=20  ---->>>  where age > 20
        # student_list = Student.objects.filter(age__gt=22).values("name", "age")  # 后面任何方法，默认补充all()
        # print(student_list)

        # # 年龄小于19的
        # # age__lt=19  ---->>>  where age < 19
        # student_list = Student.objects.filter(age__gt=19).all().values("name","age")
        # print(student_list)

        # 年龄不等于19的
        # 使用exclude把符合条件的排除掉
        student_list = Student.objects.exclude(age=19).all().values("name","age")
        print(student_list)

```

不等于的运算符，使用exclude()过滤器。

#### 7. 日期查询

> 注意：
>
> 1. django的ORM中提供了许多方法用于进行日期的查询过滤，例如：**year、month、day、week_day、hour、minute、second都可以对日期时间类型的属性进行运算。**
> 2. 要进行日期时间的过滤查询，必须保证python代码中使用的时间时区与mysql数据库中的时间时区是对应的！如果mysql的时区与python代码的时区不对应，则得到的结果纯在时区的差异。
>
> 可以使用`SELECT NOW()`查看mysql的时区

例：查询2017年被添加到数据中的学生。

```python
"""日期过滤查询
需要调整settings.py的时区配置项为：USE_TZ = False
"""
# 查询2017年被加入数据表的信息
# created_time__year=2017  ---> where year(created_time)=2017
student_list = Student.objects.filter(created_time__year=2017).values("name", "created_time")
print(student_list)

# 查询11月份被加入数据表的信息
# SQL: where month(created_time) = 11;
student_list = Student.objects.filter(created_time__month=7).values("name", "created_time")
print(student_list)

# 查询出2022年07月份的学生
# SQL: WHERE month(created_time) = 7 AND year(created_time) = 2022;
student_list = Student.objects.filter(created_time__year=2022, created_time__month=7).values("name", "created_time")
print(student_list)

# 查询出2017年11月20号的学生
# SQL: WHERE month(created_time) = 7 AND year(created_time) = 2022 AND day(created_time);
student_list = Student.objects.filter(
created_time__year=2017,
created_time__month=7,
created_time__day=20
).values("name", "created_time")
print(student_list)

# 查询07月20号的学生
student_list = Student.objects.filter(
created_time__month=7,
created_time__day=20
).values("name", "created_time")
print(student_list)
```

###### 业务场景：时间判断

例：查询2021-08-18 16:19:38 这个时间点上添加的学生信息。

例：查询时间范围在 "2021-08-18 16:19:38" ~ "2021-08-18 16:21:56" 的数据。

```python
"""精确时间查询"""
# 方式1：当在模型使用datetime指定字段的数据类型以后，就不能直接通过字符串的比较来过滤查询了，因为字符串时间格式无法与datetime对象来进行很精确的判断比较
student_objs = models.Student.objects.filter(created_time="2021-08-18 16:19:38").all()
print(student_objs)

# 方式2：把字符窜格式的时间转换成datetime对象，也可以查询。
from django.utils.timezone import datetime
# 把字符串格式时间转换成datetime时间戳对象
timestamp = datetime.strptime("2021-08-18 16:19:38", "%Y-%m-%d %H:%M:%S")
student_objs = models.Student.objects.filter(created_time=timestamp).all()
print(student_objs)

"""判断两个时间范围"""
time1 = "2020-11-20 9:00:00"
time2 = "2020-11-20 11:00:00"
# 查询添加时间在time1与time2之间的学生信息
student_objs = models.Student.objects.filter(
created_time__gte=time1,
created_time__lte=time2,
).all()
print(student_objs) # <QuerySet [<Student: 刘德华>]>
```

#### 8. F对象, 字段间

F对象，主要用于在SQL语句中针对字段之间的值进行比较的查询。

之前的查询都是对象的属性与常量值比较，两个属性怎么比较呢？ 答：使用F对象，被定义在django.db.models中。

语法如下：

```python
"""F对象，字段间的值比较查询"""
from django.db.models import F
# 查询出入学以后，数据没有被修改过的学生信息, 比较updated_time和created_time
student = Student.objects.filter(created_time=F("updated_time")).values("name","created_time","updated_time")
print(student)
return HttpResponse("ok")

# 除了上面例子，我们还可以从工作中针对公司每月的营收(支出和收入)、股票(每月涨和跌)都可以使用F对象进行查询。
```

#### 9. Q对象 逻辑比较

**多个过滤器逐个调用表示逻辑与关系，同sql语句中where部分的and关键字。**

例：查询年龄大于20，并且编号小于30的学生。

```python
Student.objects.filter(age__gt=20,id__lt=30)
或
Student.filter(age__gt=20).filter(id__lt=30)
```

**如果需要实现逻辑或or的查询，需要使用Q()对象结合|运算符**，Q对象被义在django.db.models中。

语法如下：

```python
# And
filter( Q(属性名__运算符=值) )
filter(Q(属性名__运算符=值, 属性名__运算符=值, ....))

# OR
filter(Q(属性名__运算符=值) | Q(属性名__运算符=值))
filter(Q(属性名__运算符=值) | Q(属性名__运算符=值) | ....)

# NOT
filter(~Q(属性名__运算符=值))
```

例子。

```python
"""Q对象，复杂逻辑查询，针对多条件进行与或非处理"""
from django.db.models import Q
# 多个与 and  Q(条件) & Q(条件)
# 查询出301班的男生
# student = Student.objects.filter(Q(classmate=301) & Q(xingbie=1)).values("name","xingbie","classmate")
# 上面完全可以简写成
student = Student.objects.filter(classmate=301, xingbie=1).values("name","xingbie","classmate")
"""单纯的多个条件并立的情况下，没必要使用到Q对象进行处理，直接编写多个条件，使用逗号串联即可"""

# 多个或，or Q(条件) | Q(条件)
# 查询出301班的男生 或者 302班的男生
student = Student.objects.filter(Q(classmate=301, xingbie=1) | Q(classmate=302, xingbie=1)).values("name","xingbie","classmate")
# print(student)
# 上面完全可以简写成
student = Student.objects.filter(classmate__in=[301,302], xingbie=1).values("name","xingbie","classmate")
# print(student)

# 如果是这样则不能简写了
# 查询出301班年龄大于21男生，或者 302班年龄小于19岁的女生
student = Student.objects.filter( Q(classmate=301, age__gt=21, xingbie=1) | Q(classmate=302, age__lt=22, xingbie=2) ).values("name","age","xingbie","classmate")
# print(student)
```

**Q对象可以使用& 表示逻辑与（and），| 表示逻辑或（or），~表示逻辑非（not）**

例：查询年龄大于20，或编号小于30的学生，只能使用Q对象实现

```
Student.objects.filter(Q(age__gt=20) | Q(pk__lt=30))
```

`Q对象左边可以使用~操作符，表示非not。但是工作中，我们只会使用Q对象进行或者的操作，只有多种嵌套复杂的查询条件才会使用&和~进行与和非得操作`。

例：查询出年龄不是20岁的

```
student = Student.objects.filter(~Q(age=20)).values("name", "age")
print(student)
# 相当于 exclude
student = Student.objects.exclude(age=20).values("name", "age")
print(student)
```

 

### 结果排序

使用**order_by**对结果进行排序

```python
"""结果排序"""
# order_by("第一排序字段","第二排序字段",....)
#  当前第一字段的值一样时，参考第二字段进行排序，第二字段的值一样时，参考第三字段进行排序,....
# 如果没有声明order_by()来查询，而值又是一样的时候，则根据MySQL在内部执行查询计划的顺序进行排列，也就是随机排列
# 字段排序写法：
# order_by("id")   # 表示按id字段的值进行升序排序，id数值从小到大
# order_by("-id")  # 表示按id字段的值进行降序排序，id数值从大到小
# 先按班级进行第一排序降序处理，当班级数值一样时，再按id进行第二排序升序处理
# student = Student.objects.order_by("-classmate","id").values("classmate","id","name")

# 调用了order_by以后，如果没有后续声明返回结果的all方法时，默认使用all()进行结果查询
student = Student.objects.order_by("-id")
print(student)
```

### 限制查询

ORM中针对查询结果的数量限制，提供了一个查询集对象[QuerySet].这个QuerySet,是ORM中针对查询结果进行**临时保存**数据的一个容器对象,我们可以通过了解这个QuerySet进行使用,达到**查询优化**的目的，也或者**限制查询结果数量**的作用。

#### 查询集 QuerySet

查询集，也称查询结果集、QuerySet，表示从数据库中获取的对象集合。

当调用如下ORM提供的过滤器方法时，Django会返回查询集（而不是简单的列表）：

- `all()`：返回所有数据。
- `filter()`：返回满足条件的数据。filter会默认调用all方法。
- `exclude()`：返回满足条件之外的数据。exclude会默认调用all方法
- `order_by()`：对结果进行排序。order_by会默认调用all方法

对查询集可以再次调用过滤器进行过滤，如

```python
Student.objects.filter(pk__gt=30).order_by('age')
```

也就意味着查询集可以含有零个、一个或多个filter过滤器。过滤器基于所给的参数限制查询的结果。

**从SQL的角度讲，查询集与select语句等价，过滤器像where、limit、order by子句。**

判断某一个查询集中是否有数据：

- `exists()`：判断查询集中是否有数据，如果有则返回True，没有则返回False。
- `values()`: 把结果集中的模型对象转换成**字典**,并可以设置转换的字段列表，达到减少内存损耗，提高性能
- `values_list()`: 把结果集中的模型对象转换成**列表**，并可以设置转换的字段列表（元祖），达到减少内存损耗，提高性能

注意：工作中如果需要返回数据的过程中进行优化，则一般我们选择使用`values()`或`values_list()`返回字段，比我们操作模型对象效率更高！当然从提供的功能操作上来说，肯定模型对象更强大灵活。

```python
# 所有基于all方法返回的结果，都是Query（查询集），路径： django.db.models.query.QuerySet

# 查询出301班是否有男生
# student_list = Student.objects.filter(classmate="301")
# student_list = student_list.order_by("-age")
# student_list = student_list.filter(sex=1)
# ret = student_list.exists()

# values 把查询结果中模型对象转换成字典
student_list = Student.objects.filter(classmate="301")
student_list = student_list.order_by("-age")
student_list = student_list.filter(sex=1)
ret1 = student_list.values() # 默认把所有字段全部转换并返回
ret2 = student_list.values("id","name","age") # 可以通过参数设置要转换的字段并返回
ret3 = student_list.values_list() # 默认把所有字段全部转换并返回
ret4 = student_list.values_list("id","name","age") # 可以通过参数设置要转换的字段并返回
print(ret4)
return JsonResponse({},safe=False)
```

##### QuerySet的两大特性

学习之前的准备工作

为了观察QuerySet的2个特性，我们可以直接到mysql配置mysql.ini中配置查看SQL的运行日志

```python
"""
说明：
开启mysql数据库日志有2种方式：
   临时开启, 通过mysql交互终端临时设置，如果服务器重启或者mysql重启，则日志的配置信息还原。
   永久开启, 通过mysql的配置文件进行参数设置，将来即便服务器重启或mysql重启，都不会关闭日子功能
此处我们设置的打印日志是输入临时开启，用于辅助学习之用，数据库关闭或重启以后就失效了
"""
-- 查看日志功能是否开启了，接下来在mysql终端下开启日志显示，根据下面提示输入命令和SQL
-- 进入数据库终端[账户与密码自己修改下]
mysql -uroot -p123
show variables like "%general_log%";
--    +------------------+------------------------------------------------------+
--    | Variable_name    | Value                                                |
--    +------------------+------------------------------------------------------+
--    | general_log      | OFF                                                  |  # OFF表示没有开启普通日志功能
--    | general_log_file | C:\tool\mysql-8.0.28-winx64\data\WIN-Q0O96JBBIJ2.log |  # 这里记录的是普通日志开启以后，日志文件路径
--    +------------------+------------------------------------------------------+

set global general_log = 'ON';       -- 设置临时开启，mysql重启后关闭
set global general_log_file = 'C:/Users/Administrator/Desktop/rg2305/day06/general.log'; -- 可以不设置日志路径，默认日志路径[路径不要包括特殊字符也不要出现中文，路径分隔符使用正斜杠]

--   +------------------+---------------------------------------------------------+
--   | Variable_name    | Value                                                   |
--   +------------------+---------------------------------------------------------+
--   | general_log      | ON                                                    |   # 日志功能也开启了
--   | general_log_file | C:/Users/Administrator/Desktop/rg2305/day06/general.log |  # 可以看到路径发生改变了，。
--   +------------------+---------------------------------------------------------+


-- mysql日志文件中时间一般跟系统时间是对不上的。原因是mysql的时区是0时区，我们这边是东八区。
select @@log_timestamps;
--      +------------------+
--      | @@log_timestamps |
--      +------------------+
--      | UTC              |   # 可以发现是UTC，0时区
--      +------------------+
set global log_timestamps=SYSTEM;  # 如果要永久设置，在上面配置文件中，添加 log_timestamps = SYSTEM
--      +------------------+
--      | @@log_timestamps |
--      +------------------+
--      | SYSTEM           |   # 时区参考当前操作系统
--      +------------------+

-- 退出数据库终端
exit

接下来，我们只需要打开上面配置好的日志文件就可以了。
```

##### 1）惰性执行

QuerySet查询集在创建时是不会访问数据库执行SQL语句，直到模型对象被调用输出或者调用模型对象的属性时，才会真正的访问数据库执行SQL语句，调用模型的情况包括**循环迭代、序列化、与if合用，print**的时候。

例如，当执行如下语句时，并未进行数据库查询，只是创建了一个查询集对象student_list，并没有执行SQL语句的。

```python
student_list = Student.objects.all()
```

继续执行遍历迭代、或打印操作之后操作后，才真正的进行了数据库的查询

```python
for student in student_list:
    pass
```

惰性执行，可以让重复的查询操作，只执行一次。

##### 2）缓存结果

使用同一个查询集，第一次使用时会发生数据库的查询，然后Django会把结果缓存下来，再次使用这个查询集时会使用缓存的数据，**减少了数据库的查询次数**。

**情况一**：如下是两个查询集，无法重用缓存，每次查询都会与数据库进行一次交互，增加了数据库的负载。

```python
from .models import Student
[student.id for student in Student.objects.all()] # 因为没有缓存查询集到变量中，所以此处第一次执行了SQL语句
[student.id for student in Student.objects.all()] # 因为没有缓存查询集到变量中，所以此处第一次执行了SQL语句
```

**情况二**：经过存储后，可以重用查询集，第二次使用缓存中的数据。

```python
student_list=Student.objects.all()
[student.id for student in student_list] # 因为上面保存到查询到变量中，所以此处执行了SQL语句
[student.id for student in student_list] # 此处调用了之前的缓存数据
```

##### 限制结果数量

django中还可以对查询集QuerySet进行**取下标或切片操作，等同于SQL中的limit和offset子句**。

注意：QuerySet毕竟不是真正的列表，所以它**不支持负数索引**。

**对查询集QuerySet进行切片后返回一个新的查询集，但还是不会立即执行数据库查询。**

如果获取一个对象，直接使用[0]，等同于[0:1].get()，但是如果没有数据，[0]引发IndexError异常，[0:1].get()如果没有数据引发DoesNotExist异常。

示例：获取第1、2项，运行查看。

```python
qs = Student.objects.all()[0:2]
```

代码：

```python
# 查询集结果数量的下标和切片操作
qs = Student.objects.all()
# print(qs[0])  # 第1条数据， ORM会自动识别这个操作并转化成SQL语句的 limit 1
# print(qs[2])  # 第3条数据， ORM会自动识别这个操作并转化成SQL语句的 limit 1 offset 2
# print(qs[:2])   # 前2条数据， ORM会自动识别这个操作并转化成SQL语句的 limit 2
# print(qs[1:4])  # 第1，2，3 数据， ORM会自动识别这个操作并转化成SQL语句的 limit 3 offset 1
# print( qs[-1] )   # 报错！！！不能使用负数
```

### 聚合分组

#### 聚合函数(平均/最大值...)

django中，可以使用aggregate()过滤器调用聚合函数。聚合函数包括：**Avg** 平均，**Count** 总数，**Max** 最大，**Min** 最小，**Sum** 求和，被定义在django.db.models中。

例：查询301班学生的平均年龄。

```python
"""聚合函数"""
from django.db.models import Avg,Max,Min,Sum,Count
# 查询301班学生的平均年龄
ret = Student.objects.filter(classmate=301).aggregate(Avg("age"))
# print(ret) # {'age__avg': 19.6364}

# 查询301班年龄最大的学生
ret = Student.objects.filter(classmate=301).aggregate(Max("age"))
# print(ret)  # {'age__max': 23}

# 查新301班入学最早的学生[也就是ID最小的]
ret = Student.objects.filter(classmate=301).aggregate(c=Min("id"))
print(ret) # {'id__min': 2}  ==> {'c': 2}
```

注意：aggregate的返回值是一个字典类型，格式如下：

```python
{'属性名__聚合类小写':值}
如:{'id__min': 2}  ==> {'c': 2}
```

使用count时一般不使用aggregate()过滤器。

例：查询301班的学生总数。

```python
# 查询301班的总人数
ret = Student.objects.filter(classmate=301).aggregate(t=Count("id"))
print(ret) # {'t':11}

# 统计总数，完全可以调用count方法即可，不需要经过aggregate的调用
ret = Student.objects.filter(classmate=301).count()
print(ret) # 11
```

注意：count函数的返回值是一个数字。

#### 分组查询

可以先使用`values`进行分组, values放在不同的位置的时候含义是不同的

| id   | name     | class |
| ---- | -------- | ----- |
| 1    | xiaoming | 301   |
| 2    | xiaohong | 301   |
| 3    | xiaoli   | 302   |

```python
QuerySet对象.annotate()
# annotate() 进行分组统计，按前面values的字段进行 group by
# annotate() 返回值依然是 queryset对象，增加了分组统计后的键值对

# SQL原生语句中分组之后可以使用having过滤，在django中并没有提供having对应的方法，但是可以使用filter对分组结果进行过滤
# 所以filter在annotate之前，表示分组查询之间的where子句，在annotate之后代表分组结果的having子句
# 同理，values在annotate之前，代表分组的字段，在annotate之后代表数据查询结果返回的字段列
```

代码：

```python
# 查询各个班级中的学生数量
from django.db.models import Count,Min
# 针对单个字段进行分组  values("classmate").annotate(total=Count("id")  按班级统计人数
ret = Student.objects.values("classmate").annotate(total=Count("id")) # total是返回的参数的名字
# print(ret)
"""
        <QuerySet [
            {'classmate': '307', 'total': 3}, 
            {'classmate': '301', 'total': 11}, 
            {'classmate': '504', 'total': 2}, 
            ....
        ]>
"""
# 针对多个字段进行分组  values("classmate","xingbie").annotate(total=Count("id")) 按 班级和性别 统计人数
ret = Student.objects.values("classmate","xingbie").annotate(total=Count("id"))
# print(ret)
"""
        <QuerySet [
            {'classmate': '307', 'xingbie': 1, 'total': 3}, 
            {'classmate': '301', 'xingbie': 1, 'total': 8}, 
            {'classmate': '301', 'xingbie': 2, 'total': 2},
            {'classmate': '301', 'xingbie': 0, 'total': 1},
            {'classmate': '504', 'xingbie': 1, 'total': 2},
            ...
        ]>
        """

# 查询出每一个班级中年龄最小的学生信息
ret = Student.objects.values("classmate").annotate(min=Min("age"))
# print(ret)
"""
           <QuerySet [
                {'classmate': '307', 'min': 19}, 
                {'classmate': '301', 'min': 17}, 
                {'classmate': '504', 'min': 19},
                ....
           ]>     
"""
ret = Student.objects.values("classmate").annotate(min=Min("age")).values("classmate","min").order_by("classmate")
# print(ret)
"""
        <QuerySet [
            {'classmate': '301', 'min': 17}, 
            {'classmate': '302', 'min': 21}, 
            {'classmate': '303', 'min': 19},
            ...
        ]>
"""

# 查询出人数在4个人以上(包括4个人)的班级
# 写在annotate后面的filter实际上表示的是having，表示对于分组后的数据结果进行过滤
# 写在annotate前面的filter实际上表示的是where， 表示对于分组前的数据结果进行过滤
ret = Student.objects.values("classmate").annotate(total=Count("id")).values("classmate","total").filter(total__gte=4)
# print(ret)
"""
        <QuerySet [
            {'classmate': '301', 'total': 11}, 
            {'classmate': '502', 'total': 5}, 
            {'classmate': '306', 'total': 6}, 
            {'classmate': '503', 'total': 7}, 
            {'classmate': '508', 'total': 4}, 
            ....
        ]>
"""
# 查询出女生数量在2个以上的班级
ret = Student.objects.filter(sex=2).values("classmate").annotate(total=Count("id")).values("classmate","total").filter(total__gte=2)
print(ret)
"""
        <QuerySet [
            {'classmate': '306', 'total': 4}, 
            {'classmate': '405', 'total': 2}, 
            {'classmate': '502', 'total': 3}, 
            ....
        ]>
"""
```

### 原生查询

执行原生SQL语句，在django中我们可以自己引入pymysql执行SQL，也可以调用ORM提供的raw方法来执行SQL语句

如果使用raw方法执行SQL语句，则返回结果是QuerySet，这个返回结果在操作字段时，会有额外性能损耗。

```python
# 查询所有学生的班级、年龄、姓名和性别
sql = "SELECT id,name,sex,age,class FROM `db_student`"
ret = Student.objects.raw(sql)
# 针对原生SQL语句中已经查询出来的字段，只会查询一遍
# 但是如果SQL语句没有查询出来的字段，而在模型中调用，则会由ORM再次调用数据库查询，把数据临时查询出来。
for student in ret:
    print(student)
    print(student.description)
```

# 多数据库

## 多库共存

在django中，settings.py配置的DATABASES配置项允许注册多个数据库，当然也就支持在项目中随时切换操作不同的数据库了。

1. 先到`djdemo/settings.py`里面，在DATABASES配置项中新增一个数据库
2. 为了方便快速演示，所以我们直接把school里面的student复制到student数据库

```mysql
use students; # 切换数据
create table student (
id  bigint auto_increment primary key,
created_time datetime(6) null,
updated_time datetime(6) null,
name         varchar(15) not null,
age          smallint    not null,
sex          tinyint(1)  not null,
class        varchar(50) not null,
mobile       varchar(20) not null,
description  longtext    null,
status       int         null,
constraint mobile unique (mobile)
);
```

![image-20250731154900919](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507311549034.png)

3. 使用以下语句复制student表的所有数据

```mysql
insert into `students`.`students` (id, created_time, updated_time, name, age, sex, class, mobile, description, status)
select id, created_time, updated_time, name, age, sex, class, mobile, description, status from `school1`.`students`;
```

![image-20250731154742871](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507311547963.png)

4. 添加到settings.py里面

```python
DATABASES = {
    # 'default': {
    #     'ENGINE': 'django.db.backends.sqlite3',
    #     'NAME': BASE_DIR / 'db.sqlite3',
    # }
    'default': {
        'ENGINE': 'django.db.backends.mysql',  # ORM的底层对接pymysql的核心引擎类
        'NAME': 'school1',          # 数据库名
        'PORT': 3306,              # 端口
        'HOST': '127.0.0.1',       # 数据库IP
        'USER': 'root',            # 账号
        'PASSWORD': 'jhy030116',         # 密码
        'POOL_OPTIONS': {  # pool表示数据库连接池配置，主要为了节省连接数据库的开销，临时存储数据库连接对象
            'POOL_SIZE': 10,     # 默认情况下，打开的数据库连接对象的数量 [1,2,3,4,5,6,7,8,9,10]
            'MAX_OVERFLOW': 30,  # 负载情况下，允许溢出的连接数量  [11,12,13,14,15,16,17,18,19,20]
        }
    },
    "djdemo": {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'students',
        'PORT': 3306,
        'HOST': '127.0.0.1',
        'USER': 'root',
        'PASSWORD': 'jhy030116',
        'POOL_OPTIONS': {
            'POOL_SIZE': 10,     # 默认情况下，打开的数据库连接对象的数量 [1,2,3,4,5,6,7,8,9,10]
            'MAX_OVERFLOW': 30,  # 负载情况下，允许溢出的连接数量  [11,12,13,14,15,16,17,18,19,20]
        }
    }
}
```

5. 切换链接

```python
def get(self, request):
    """多库共存下，基于django底层安装的pymysql来使用原生SQL语句操作的切换数据连接，完成数据库查询的过程"""
    # from django.db import connections
    # with connections["djdemo"].cursor() as cursor:
    #     # 让游标执行SQL语句
    #     cursor.execute("select * from student")
    #     # 通过游标获取查询结果
    #     result = cursor.fetchall()
    #     print(result)

    """多库共存下，基于django的ORM模型操作，来切换数据连接完成数据库操作的过程"""
    student_objs = models.Student.objects.using("default").values("name", "age")
    print(student_objs)
    return JsonResponse({})

```

## 关联模型

关联模型实际上就是ORM提供给开发者用于操作多表数据的功能。因为多个表之间的存在的关联关系，往往都是基于建库建表之初的实体关系分析( ER图 ) 和 范式理论 梳理出来的。

构建数据库和构建数据表：实体、属性、关系。

实体：在现实世界中，客观存在的能够被区分的人事物或集体概念。

属性：具有描述性、修饰性的词语，用于描述实体的特征的。

| id   | title  | price | sale 销量 |
| ---- | ------ | ----- | --------- |
| 1    | meta40 | 3299  | 15        |
| 2    |        |       |           |
|      |        |       |           |

| id   | status | goods_id |
| ---- | ------ | -------- |
| 1    | 已成交 | 1        |
| 2    | 未支付 |          |
|      | 已取消 |          |

### 范式理论(三范式、逆范式)

范式理论是关系型模型建库建表的参考标准。

[第一范式](https://baike.baidu.com/item/第一范式/3193590)（1NF，原子性）：数据表的每一列都是不可分割，不能重复。如果出现重复的属性，就可能需要定义一个新的实体（也就是新建一张数据表来进行保存）。

[第二范式](https://baike.baidu.com/item/第二范式/3193760)（2NF，依赖性）：数据表的每一行都是唯一，需要创建ID来进行区分每一行数据。

[第三范式](https://baike.baidu.com/item/第三范式/3193798)（3NF，冗余性）：数据表的数据不能冗余，针对冗余数据应该单独创建一个数据表，并把ID写到新表中进行关联。

逆范式指的是通过增加冗余或重复的数据来提高数据库的读取速度。

往往逆范式遵循的原则是：**空间换时间**。本质就是： 以廉价的硬盘空间，换取珍贵的数据库查询时间，以更快的数据从数据库读取数据返回给客户端。

ORM中针对数据表之间进行的关联操作,也可以外键绑定的操作方式,其中根据数据库表与表之间的关系, 可以有三种以上的关联方式：1对1，1对多，多对多。其中针对外键设置的模型代码，在django中一般有2种**操作方式**：

```python
# 正向查询按字段，从主模型查询外键模型的数据
    模型对象 = 当前模型.filter(xxx).first()  # 例如，获取商品，查询商品的分类，假设分类属性 category
    模型对象.外键    # 商品.category  ---> 商品分类

# 反向查询按表名，从外键模型查询主模型数据
    主键对象 = 主键模型.filter(xxx).first()  # 先查询分类  --> 当前分类下有多少商品
    主键对象.外键模型表名_set   # _set方法可以使用related_name代替 [_set操作在一对一里面是没有的]
```

set方法文档：https://docs.djangoproject.com/zh-hans/4.0/ref/models/relations/

#### 创建实例

### 一对一关联(OneToOneField)

创建模型的关联关系，`orm/models.py`，代码：

#### 模型实现

使用`OneToOneField`进行关联

> #### `"Student"`
>
> - **关联的目标模型**（这里是名为 `Student` 的模型）
> - 使用字符串形式避免循环导入（Django 会按需解析）
> - 等效写法：`Student`（需先导入模型类）
>
> #### ▶ `related_name="profile"`
>
> - **反向关系名称**（从 `Student` 访问当前模型的关键字）
>
> - 效果：通过 `student.profile` 直接获取关联对象
>
>     python
>
>     ```
>     student = Student.objects.get(id=1)
>     profile = student.profile  # 获取该学生的关联档案
>     ```
>
> - 未设置时默认名：`小写模型类名`（如 `studentprofile`）
>
> #### ▶ `on_delete=models.CASCADE`
>
> - **删除联动规则**：当关联的 `Student` 被删除时
> - `CASCADE`：同步删除当前模型实例（级联删除）
>     *例如：删除学生时，其档案自动删除*
> - 其他选项：
>     - `PROTECT`：阻止删除（引发 `ProtectedError`）
>     - `SET_NULL`：设为 `NULL`（需字段允许 `null=True`）
>     - `SET_DEFAULT`：设为默认值（需设置 `default`）
>
> #### ▶ `verbose_name="学生"`
>
> - **可读的字段名称**（用于后台/admin界面展示）
> - 中文显示为"学生"（替代默认的英文显示）

```python
from django.db import models

# Create your models here.
"""
一对一模型关联
"""

# 主表
class Student(models.Model):
    name = models.CharField(max_length=20, db_index=True, verbose_name="姓名")
    age = models.IntegerField(verbose_name="年龄")
    sex = models.BooleanField(null=True, blank=True, default=None, verbose_name="性别")
    created_time = models.DateTimeField(auto_now_add=True, verbose_name="创建时间")
    updated_time = models.DateTimeField(auto_now=True, verbose_name="更新时间")

    class Meta:
        db_table = 'orm_student'
        verbose_name = "学生信息"
        verbose_name_plural = verbose_name

    def __str__(self):
        return str({"id": self.pk, "name": self.name, "age": self.age})

# 附加的表
class StudentProfile(models.Model):
    # 设置外键[1对1，models.OneToOneField("主键模型类名", on_delete="外键约束类型", ....)]
    # 设置外键以后，在数据库中会自动生成一个"属性_id"的真实字段给开发者进行外键记录
    # related_name 主要声明给主模型来使用的，用于反向查询。
    # StudentProfile.student = 学生信息
    # Student.profile = 学生详细信息
    student = models.OneToOneField("Student", related_name="profile", on_delete=models.CASCADE, verbose_name="学生")
    description = models.TextField(default="", verbose_name="个性签名")
    address = models.CharField(max_length=500, verbose_name="家庭住址")
    mobile = models.CharField(max_length=15, verbose_name="紧急联系电话")

    class Meta:
        db_table = "orm_student_profile"
        verbose_name = "学生详细信息"
        verbose_name_plural = verbose_name

    def __str__(self):
        return str({"address": self.address, "mobile": self.mobile})

```

![image-20250731192326508](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507311923571.png)

进行数据迁移

```bash
python manage.py makemigrations
python manage.py migrate
```

#### 添加数据

```python
class StudentView(View):
    """1：1模型关联"""
    def get1(self, request):
        """添加数据操作"""
        """
        唯一方式：先添加主模型数据Student, 后添加外键模型数据
        """
        student = models.Student.objects.create(
            name="小白",
            age=17,
            sex=True,
        )
        profile = models.StudentProfile.objects.create(
            # student=student, # 通过指定对象的方式，可以帮我们自动绑定外键
            student_id=student.id,  # 等价于上一句
            description="一段长长长长的个性签名....",
            address="学生小白的家庭住址",
            mobile="13312345618",
        )
       

        """注意：不要使用以下写法，外键模型的数据无法提添加，但是不会报错。"""
        # student = models.Student.objects.create(
        #     name="小辉",
        #     age=17,
        #     sex=True,
        #     profile=models.StudentProfile(
        #         description="一段长长长长的个性签名....",
        #         address="学生小辉的家庭住址",
        #         mobile="13312345668",
        #     )
        # )

        return JsonResponse({})


```

 #### 相互访问筛选

```python
    def get2(self, request):
        """查询数据"""
        """
        方式1：从主模型(主表, orm_student)查询到外键模型(附加表, orm_student_profile)
        """
        # 例如，小明今天没上学，查询他的紧急联系电话和家庭地址
        student = models.Student.objects.filter(name="小明").first()
        if student:
            # profile就是在StudentProfile里面定义的 related_name
            print(student.profile.mobile)
            print(student.profile.address)

        """
        方式2：使用外键模型中查询数据，以主键模型作为条件
        """
        # 例如，小白今天没上学，查询他的紧急联系电话和家庭地址
        profile = models.StudentProfile.objects.filter(student__name="小白").first()
        print(profile.mobile)

        """
        方式3：从外键模型(附加表, orm_student_profile)查询到主模型(主表, orm_student)
        """
        # 例如，根据手机号，13312345618 是谁的手机号码
        student_profile = models.StudentProfile.objects.filter(mobile="13312345618").first()
        if student_profile:
            print(student_profile.student.name)

        """
        方式4：查询主模型数据，以外键模型作为条件
        """
        # 例如，根据手机号，13312345618 是谁的手机号码
        student = models.Student.objects.filter(profile__mobile="13312345618").first()
        print(student.name)

        return JsonResponse({})
```

#### 修改数据

```python
    def get3(self, request):
        """更新数据"""
        """方式1：从主模型更新外键模型数据（save）"""
        # 例如，修改小明的家庭地址
        student = models.Student.objects.filter(name="小明").first()
        if student:
            print(student)
            print(student.profile)
            print(student.profile.address)
            # 直接修改，并保存即可
            student.profile.address = "学生小明的新家庭地址"
            # 修改的address是StudentProfile的字段，所以使用StudentProfile的save方法
            student.profile.save()

        """方式2：修改外键模型数据，使用主模型作为修改条件(update)"""
        # 例如，修改小白的家庭地址
        models.StudentProfile.objects.filter(student__name="小白").update(address="学生小白的新家庭地址")

        """方式3：从外键模型更新主模型数据(save)"""
        # 例如，修改手机号："13312345618" 的学生的年龄为21岁
        student_profile = models.StudentProfile.objects.filter(mobile="13312345618").first()
        if student_profile:
            print(student_profile)
            print(student_profile.student)
            print(student_profile.student.age)
            student_profile.student.age = 21
            student_profile.student.save()

        """方式4：修改主模型数据，使用外键模型作为修改条件（update）"""
        # 例如，修改手机号："13312345118" 的学生的年龄为18岁
        models.Student.objects.filter(profile__mobile="13312345118").update(age=18)

        return JsonResponse({})

```

#### 删除数据

```python
def get(self,request):
    """删除操作"""
    """当on_delete=models.CASCADE时，删除主模型数据，mysql会自动删除外键模型数据"""
    # 例如，删除小明的数据记录
    #models.Student.objects.filter(name="小明").delete()

    """当on_delete=models.CASCADE时，删除外键模型数据，不会影响主模型数据的"""
    # 例如，删除手机号为13312345118的学生附加资料
    models.StudentProfile.objects.filter(mobile="13312345118").delete()
    return JsonResponse({})
```

#### 外键约束选项(删除)

在设置外键时，需要通过**on_delete**选项指明主表删除数据时，对于外键引用表数据如何处理，在django.db.models中包含了可选常量：

- **CASCADE**： 级联/株连，删除主表数据时连通一起删除外键表中数据

- **PROTECT**： 删除保护，通过抛出**ProtectedError**异常，来阻止删除主表中被外键应用的数据，意思是必须先删除外键数据以后才能删除主键数据

- **SET_NULL**： 设置为NULL，仅在该字段null=True允许为null时可用

- SET_DEFAULT： 设置为默认值，仅在该字段设置了默认值时可用

- SET()： 设置为特定值或者调用特定方法，例如：

    ```python
    from django.conf import settings
    from django.contrib.auth import get_user_model
    from django.db import models
    def get_sentinel_user():
        return get_user_model().objects.get_or_create(username='deleted')[0]
    class UserModel(models.Model):
        user = models.ForeignKey(
            settings.AUTH_USER_MODEL,
            on_delete=models.SET(get_sentinel_user),
        )
    ```

- **DO_NOTHING**： 不做任何操作，如果数据库前置指明级联性，此选项会抛出**IntegrityError**异常

### 一对多关联(ForeignKey)

一对多模型关联，例如学生和成绩，文章分类和文章，商品分类和商品，商品品牌和商品之间的关系。

使用`ForeignKey`进行关联(在子模型里面)

```python
class Author(models.Model):
    name = models.CharField(max_length=20, db_index=True, verbose_name="姓名")
    age = models.IntegerField(verbose_name="年龄")
    sex = models.BooleanField(null=True, blank=True, default=None, verbose_name="性别")

    class Meta:
        db_table = 'orm_author'
        verbose_name = "作者信息"
        verbose_name_plural = verbose_name

    def __str__(self):
        return str({"id": self.pk, "name": self.name, "age": self.age,  "sex": self.sex})


class Article(models.Model):
    title = models.CharField(max_length=50, verbose_name="文章标题")
    content = models.TextField(null=True, verbose_name="文章内容")
    pubdate = models.DateTimeField(null=True, verbose_name="发布时间")
    created_time = models.DateTimeField(auto_now_add=True, verbose_name="创建时间")
    updated_time = models.DateTimeField(auto_now=True, verbose_name="创建时间")
    author = models.ForeignKey("Author", on_delete=models.DO_NOTHING, related_name="article_list", verbose_name="作者")

    class Meta:
        db_table = "orm_article"
        verbose_name = "文章信息"
        verbose_name_plural = verbose_name

    def __str__(self):
        return str({"id": self.id, "title": self.title, "pubdate": self.pubdate})
```

进行数据迁移

```bash
python manage.py makemigrations
python manage.py migrate
```

关联操作

```python
# from .models import Achievement
# student = Student.objects.get(pk=10)
# achievement_list = [
#   Achievement(student=student,score=100),
#   Achievement(student=student,score=100),
#   Achievement(student=student,score=100),
#   Achievement(student=student,score=100),
# ]
#
# Achievement.objects.bulk_create(achievement_list)

# 获取一个学生的所有成绩
# student = Student.objects.get(pk=10)
# print(student.score_list.all().values("id","score"))      # 必须在外键模型中设置related_name="score_list",否则无法获取外键关系
# print(student.achievement_set.all().values("id","score")) # 如果外键模型中没有设置related_name则可以通过模型_set提供给主模型调用数据

# 从外键数据查找主模型
from .models import Achievement
student_achievement = Achievement.objects.filter(score=80).first()
print(student_achievement.student)    # 查找外键属性字段
print(student_achievement.student_id) # 直接查数据表中的数值ID
```

#### 添加数据

```python
class ArticleView(View):
    """1:多模型关联"""
    def get1(self,request):
        """添加数据"""
        """1. 先添加主模型，根据主模型添加外键模型"""
        author = models.Author.objects.create(
            name="小明",
            age=23,
            sex=True
        )
        article_list = [
            models.Article(title="文章标题1", content="文章内容1", 
                           pubdate="2023-03-15 10:30:30", author=author),
            models.Article(title="文章标题2", content="文章内容2", 
                           pubdate="2023-03-16 10:30:30", author_id=author.id),
        ]
        models.Article.objects.bulk_create(article_list)

        """如果已经有了主模型，则直接通过查询主模型提取主键ID，再添加外键模型数据即可。"""
        # 例如，给小明记录多2片文章
        author = models.Author.objects.filter(name="小明").first()
        if author:
            article_list = [
                models.Article(title="文章标题3", content="文章内容3", 
                               pubdate="2023-03-15 10:30:33", author=author),
                models.Article(title="文章标题4", content="文章内容4", 
                               pubdate="2023-03-16 10:30:34", author_id=author.id),
            ]
            models.Article.objects.bulk_create(article_list)

        """添加主模型，再添加外键模型的另一种写法"""
        models.Article.objects.create(
            title="文章标题5",
            content="文章内容5",
            pubdate="2023-10-03 12:05:00",
            author=models.Author.objects.create(name="小白", age=23, sex=False)
        )

        return JsonResponse({})
```

#### 查询数据

```python
    def get2(self, request):
        """查询数据"""
        """通过主模型查找外键模型"""
        # 例如，查询小明的所有文章
        author = models.Author.objects.filter(name="小明").first()
        if author:
            print(author)
            # 获取外键，article_list就是Article中related_name定义，提供给Author反向查询使用的
            print(author.article_list.all())

        """使用主模型作为条件，直接查询外键模型的数据"""
        # 例如，查询小白的所有文章
        article_list = models.Article.objects.filter(author__name="小白").all()
        print(article_list)

        """通过外键模型查询主模型"""
        # 例如，查询文章标题为《文章标题5》的作者
        article = models.Article.objects.filter(title="文章标题5").first()
        if article:
            print(article.author, type(article.author))
            print(article.author.name)

        """使用外键模型作为条件，直接查询主模型的数据"""
        # 例如，查询文章标题为《文章标题3》的作者
        author = models.Author.objects.filter(article_list__title="文章标题3").first()
        print(author)
        print(author.name)
        return JsonResponse({})
```

#### 更新数据

```python
def get3(self, request):
    """更新操作"""
    """获取主模型，再改动外键模型[外键模型可以是1个或多个，如果是多个，则需要循环]"""
    # 把小明的所有文章发布时间修改成 2023-10-15 10:00:00
    author = models.Author.objects.filter(name="小明").first()
    for article in author.article_list.all():
        article.pubdate = "2023-10-15 10:00:00"
        article.save()

    """以主模型作为更新条件，更新外键模型数据"""
    # 把小白的所有文章发布时间修改成 2023-05-05 10:00:00
    models.Article.objects.filter(author__name="小白").update(pubdate="2023-05-05 10:00:00")

    """获取到外键模型，再改动主模型"""
    # 例如，修改文章标题《文章标题4》的作者的年龄为27岁
    article = models.Article.objects.filter(title="文章标题4").first()
    article.author.age = 27
    article.author.save()


    """以外键模型作为更新条件，更新主模型数据"""
    # 例如，修改文章标题《文章标题1》的作者的年龄为22岁
    models.Author.objects.filter(article_list__title="文章标题1").update(age=22)


    """外键是可以在开发中更改绑定关系"""
    # # 例如，修改文章标题《文章标题3》的作者为小白
    article = models.Article.objects.filter(title="文章标题3").first()
    author = models.Author.objects.filter(name="小白").first()
    article.author = author
    article.save()

    # # 例如，修改文章标题《文章标题3》的作者为小明
    # models.Article.objects.filter(title="文章标题3").update(
    #     author=models.Author.objects.filter(name="小明").first()
    # )

    return JsonResponse({})
```

#### 删除数据

```python
def get(self,request):
    """删除数据"""
    models.Author.objects.filter(name="小白").delete()
    return JsonResponse({})
```

### 多对多关联（ManyToManyField）

#### 模型实现

多对多模型关联, 例如：网课和学生，活动和商品，软件应用和服务器。使用`ManyToManyField`进行关联, 同时没有主次之分

在创建这两个表的时候, 实际还会创建一个关系表

```python
"""多对多"""
# 一个老师可以授课多个课程
# 一个课程也可以由多个老师授课
# 多对多关联以后，在数据迁移时，在数据库中实际上会创建三张表，分别是：2个模型对象实体表，1张关联2个模型的关系表。
# 一对一，把主模型的主键id，作为外键字段声明在外键模型中【所以外键模型多出一个关联属性字段】
# 一对多，把主模型的主键id，作为外键字段声明在外键模型中【所以外键模型多出一个关联属性字段】
# 多对多，把2个主模型的主键id，作为外键字段记录第三张关系表中，这张表主要有2个外键字段。而且ORM中，我们无法直接访问和操作这个表的，只能通过主模型来操作
class Teacher(models.Model):
    name = models.CharField(max_length=15,verbose_name="老师")
    # 注意：Teacher模型中设置了course外键，就不要设置Course的teacher外键了。2个冲突的。
    # course = models.ManyToManyField("Course", related_name="to_teacher")

    class Meta:
        db_table = "tb_teacher"
        verbose_name = '老师信息表'
        verbose_name_plural = verbose_name

class Course(models.Model):
    name = models.CharField(max_length=20, verbose_name="课程")
    # 多对多不需要我们设置on_delete，直接默认就是models.CASCADE级联了。
    teacher = models.ManyToManyField("Teacher", related_name="to_course")

    class Meta:
        db_table = "tb_course"
        verbose_name = '课程信息表'
        verbose_name_plural = verbose_name
```

进行数据迁移

```
python manage.py makemigrations
python manage.py migrate
```

#### 添加数据

```python
class TeacherView(View):
    """多对多关联操作"""
    def get1(self, request):
        """添加数据"""
        """先添加实体模型，然后通过外键使用add进行关联两个模型"""
        # 1. 先添加实体模型
        teacher = models.Teacher.objects.create(name="大明", age=32, sex=True)
        course = models.Course.objects.create(name="python基础课")
        # 2. 通过外键使用add绑定关系
        teacher.course.add(course)

        # 也可以给已有的模型绑定关系
        teacher = models.Teacher.objects.filter(name="大明").first()
        course1 = models.Course.objects.create(name="python框架")
        course2 = models.Course.objects.create(name="python项目实战")
        teacher.course.add(course1, course2)

        return JsonResponse({})
```

#### 查询

```python
def get2(self, request):
    """查询数据"""
    """先查其中一个模型，接着通过外键，查询另一个模型的数据"""
    # 例如，查询大明的授课列表
    teacher = models.Teacher.objects.filter(name="大明").first()
    print(teacher.course.all())

    """使用其中一个模型作为条件，查询另一个模型的数据"""
    # 例如，查询大明的授课列表
    course_objs = models.Course.objects.filter(teacher__name="大明").all()
    print(course_objs)

    """反过来，也是如此"""
    # 例如，python基础课的授课老师列表
    course = models.Course.objects.filter(name="python基础课").first()
    print(course.teacher.all())

    teacher_list = models.Teacher.objects.filter(course__name="python基础课").all()
    print(teacher_list)

    return JsonResponse({})
```

#### 更新

```python
def get(self,request):
    """更新数据"""
    # 把大明的所有授课课程的名字后面加上（大明专讲）
    teacher = models.Teacher.objects.filter(name="大明").first()
    if teacher:
        for course in teacher.course.all():
            course.name = course.name + "（大明专讲）"
            course.save()

    # # 通过update修改, 字符串的拼接需要使用Concat
    from django.db.models import F, Value
    from django.db.models.functions import Concat
    models.Course.objects.filter(teacher__name="大白").update(name=Concat(F("name"), Value("[精讲]")))
    return JsonResponse({})
```

#### 删除

```python
    def get4(self,request):
        """删除数据"""
        """删除模型表记录时，对应的关系也会被删除"""
        # 删除大明的信息，mysql会自动删除绑定关系
        models.Teacher.objects.filter(name="大明").delete()

        """解绑关系"""
        teacher = models.Teacher.objects.filter(name="大白").first()
        course = models.Course.objects.filter(name="java基础课").first()
        teacher.course.remove(course) # 注意：这并非删除课程，而是解除绑定关系而已

        return JsonResponse({})

```

### 自关联

自关联就是1张数据表中，主键和外键都在一张表上。一般会在多级部门，多级菜单，多级权限，省市区行政区划，粉丝关注，好友关系，这些业务中使用到。举例：

行政区划表 tb_area, 这里的一个地区的上一级可以是同一个表里面的另一项

| id   | name     | parent_id/pid |
| ---- | -------- | ------------- |
| 1    | 河南省   |               |
| 2    | 河北省   |               |
| 3    | 郑州市   | 1             |
| 4    | 开封市   | 1             |
| 5    | 石家庄   | 2             |
| 6    | 邯郸市   | 2             |
| 7    | 二七区   | 3             |
| 8    | 新郑区   | 3             |
| 9    | 郑东新区 | 3             |

要理解自关联，就要这个数据表理解成2张或者3张表就可以了。

省级别，province，

| id   | name   |      |
| ---- | ------ | ---- |
| 1    | 河南省 |      |
| 2    | 河北省 |      |

市级别，city，

| id   | name   | parent_id/pid |
| ---- | ------ | ------------- |
| 3    | 郑州市 | 1             |
| 4    | 开封市 | 1             |
| 5    | 石家庄 | 2             |
| 6    | 邯郸市 | 2             |

区级别，area，

| id   | name     | parent_id/pid |
| ---- | -------- | ------------- |
| 7    | 二七区   | 3             |
| 8    | 新郑区   | 3             |
| 9    | 郑东新区 | 3             |

上面很明显是1个省份有多个城市，1个城市有多个地区，这就是属于1对多的自关联

用户与用户之间的好友关系，这就是属于多对多的自关联。

用户表 user

| id   | username |
| ---- | -------- |
| 1    | 小明     |
| 2    | 小红     |
| 3    | 小黑     |
| 4    | 小白     |
| 5    | 小辉     |

好友关系表 user_friend

| id   | user1 | user2 |
| ---- | ----- | ----- |
| 1    | 1     | 2     |
| 2    | 1     | 3     |
| 3    | 1     | 4     |
| 4    | 2     | 3     |
| 5    | 2     | 4     |
| 6    | 2     | 5     |
| 7    | 3     | 4     |

#### 模型实现

还是使用的`ForeignKey`和`ManyToManyField`但是不是写另一个模型的名字是使用self, 在进行多对多的时候为了避免递归搜寻, 默认是不支持反向查询的, 需要加一下参数`symmetrical=True`

```python
class Area(models.Model):
    """一对多的自关联"""
    name = models.CharField(max_length=50)
    parent = models.ForeignKey("self", on_delete=models.SET_NULL, related_name="to_son", null=True, blank=True)
    class Meta:
        db_table = "orm_area"
        verbose_name = '行政区划表'
        verbose_name_plural = verbose_name

    def __str__(self):
        return str({"id":self.id, "name":self.name})


class Member(models.Model):
    """多对多的自关联"""
    name = models.CharField(max_length=50, unique=True, verbose_name="用户名")
    age = models.SmallIntegerField(default=0, verbose_name="年龄")
    # symmetrical=True 默认值，表示双向关系，绑定的关系是双向，一般用于好友关系
    # 这种情况下，django不提供反向查询
    friends = models.ManyToManyField(to="self", symmetrical=True)
    # symmetrical=False 表示单向关系，绑定的关系是单向，一般用于单向关注，黑名单
    focus = models.ManyToManyField(to="self", symmetrical=False, related_name="fans_list")

    class Meta:
        db_table = "orm_member"
        verbose_name = '会员信息表'
        verbose_name_plural = verbose_name

    def __str__(self):
        return str({"id":self.id, "name":self.name})

```

数据迁移

```
python manage.py makemigrations
python manage.py migrate
```

分析：

```
父级对象：area.parent  # parent就是自关联模型的外键属性，并非固定属性，看创建模型时的设置
父级获取子级数据对象：area.son_list.all()
```

#### 添加数据

```python
class Student4View(View):
    """自关联"""
    def get1(self, request):
        """添加数据"""
        # 添加省份数据，因为没有上级辖区，所以不需要声明其他字段
        area1 = Area.objects.create(name="河南省")
        area2 = Area.objects.create(name="河北省")
        #
        # # 添加城市数据
        area3 = Area.objects.get(name="河南省")
        area3.to_son.add(
            Area.objects.create(name="郑州市"),
            Area.objects.create(name="开封市")
        )
        
        area4 = Area.objects.get(name="河北省")
        Area.objects.create(name="石家庄", parent=area4)
        Area.objects.create(name="邯郸市", parent_id=area4.id)

        # # 添加地区数据
        area5 = Area.objects.get(name="郑州市")
        area5.to_son.add(*[
            Area.objects.create(name="二七区"),
            Area.objects.create(name="新郑区"),
            Area.objects.create(name="郑东新区")
        ])

        province = Area.objects.create(name="广东省")
        area_list = [
            Area(name="佛山市"),
            Area(name="广州市"),
            Area(name="珠海市"),
            Area(name="深圳市"),
        ]
        # bulk属性只有在一对多的时候存在，多对多是没有。bulk允许列表中出现没有保存到数据库中的模型对象，django会自动创建到数据库中
        province.to_son.add(*area_list, bulk=False)

        return HttpResponse("ok")
```

#### 查找数据

```python
def get2(self, request):
    """查询数据"""
    """通过子级记录查找父级记录，得到唯一的父级"""
    area = Area.objects.get(name="二七区")
    print(area.parent)  # {'id': 3, 'name': '郑州市'}
    print(area.parent.parent) # {'id': 1, 'name': '河南省'}

    """通过父级记录查找子级记录，得到多个子级"""
    area = Area.objects.get(name="河南省")
    son_list = area.to_son.all()
    print(son_list)  # <QuerySet [<Area: {'id': 3, 'name': '郑州市'}>, <Area: {'id': 4, 'name': '开封市'}>]>
    
    data = []
    for son_area in son_list:
        grandson_list = son_area.to_son.all()
        data.extend(list(grandson_list))
    print(data)

    """使用子级记录作为查询条件，查询数据"""
    area = Area.objects.filter(to_son__name__in=["郑东新区"]).first() # 因为同一个父级下有多个子级记录，所以必须使用in来查找
    print(area)  # {'id': 3, 'name': '郑州市'}
    
    # 通过孙子找爷爷
    area = Area.objects.filter(to_son__to_son__name__in=["郑东新区"]).first()
    print(area)  # {'id': 1, 'name': '河南省'}

    """使用父级记录作为查询条件，查询数据"""
    son_list = Area.objects.filter(parent__name="河南省").all()
    print(son_list)  # <QuerySet [<Area: {'id': 3, 'name': '郑州市'}>, <Area: {'id': 4, 'name': '开封市'}>]>

    grandson_list = Area.objects.filter(parent__parent__name="河南省").all()
    print(grandson_list) # <QuerySet [<Area: {'id': 7, 'name': '二七区'}>, <Area: {'id': 8, 'name': '新郑区'}>, <Area: {'id': 9, 'name': '郑东新区'}>]>
    # SQL: SELECT `orm_area`.`id`, `orm_area`.`name`, `orm_area`.`parent_id` FROM `orm_area` INNER JOIN `orm_area` T2 ON (`orm_area`.`parent_id` = T2.`id`) INNER JOIN `orm_area` T3 ON (T2.`parent_id` = T3.`id`) WHERE T3.`name` = '河南省' LIMIT 21


    return HttpResponse("ok")
```

#### 多对多建立关联

```python
def get3(self, request):
    """多对多的自关联[双向]：添加数据"""
    # 添加数据
    member1 = Member.objects.create(name="小明", age=16)
    member2 = Member.objects.create(name="小红", age=15)
    member3 = Member.objects.create(name="小白", age=15)
    member4 = Member.objects.create(name="小黑", age=15)
    member5 = Member.objects.create(name="小兰", age=15)

    # 小红添加好友
    member1 = Member.objects.get(name="小红")
    member2 = Member.objects.get(name="小黑")
    member3 = Member.objects.get(name="小白")
    member1.friends.add(member2, member3)

    # 小明添加好友
    member1 = Member.objects.get(name="小明")
    member2 = Member.objects.get(name="小黑")
    member3 = Member.objects.get(name="小白")
    member4 = Member.objects.get(name="小红")
    member1.friends.add(member2, member3, member4)

    # 小兰添加好友
    member1 = Member.objects.get(name="小兰")
    member2 = Member.objects.get(name="小黑")
    member3 = Member.objects.get(name="小白")
    member4 = Member.objects.get(name="小红")
    member5 = Member.objects.get(name="小明")
    member1.friends.add(member2, member3, member4, member5)

    # 小白添加好友
    member1 = Member.objects.get(name="小白")
    member2 = Member.objects.get(name="小黑")
    member3 = Member.objects.get(name="小明")
    member4 = Member.objects.get(name="小红")
    member1.friends.add(member2, member3, member4)

    return HttpResponse("OK")
```

#### 多对多数据操作

```python
def get4(self, request):
    """多对多的自关联[双向]：查询数据"""
    member = Member.objects.get(name="小黑")
    # 查找小黑的朋友?
    print(member.friends.all())
    return HttpResponse("OK")

def get5(self,request):
    """多对多的自关联[单向]: 添加数据"""
    # 小红的关注
    member1 = Member.objects.get(name="小红")
    member2 = Member.objects.get(name="小黑")
    member3 = Member.objects.get(name="小白")
    member1.focus.add(member2, member3)

    # 小明的关注
    member1 = Member.objects.get(name="小明")
    member2 = Member.objects.get(name="小黑")
    member3 = Member.objects.get(name="小白")
    member4 = Member.objects.get(name="小红")
    member1.focus.add(member2, member3, member4)

    # 小兰的关注
    member1 = Member.objects.get(name="小兰")
    member2 = Member.objects.get(name="小黑")
    member3 = Member.objects.get(name="小白")
    member4 = Member.objects.get(name="小红")
    member5 = Member.objects.get(name="小明")
    member1.focus.add(member2, member3, member4, member5)

    # 小白的关注
    member1 = Member.objects.get(name="小白")
    member2 = Member.objects.get(name="小黑")
    member3 = Member.objects.get(name="小明")
    member4 = Member.objects.get(name="小红")
    member1.focus.add(member2, member3, member4)

    """自关联的添加关系与普通多表关联的关系操作类似，不仅支持add，也支持set，clear,remove等操作"""

    return HttpResponse("OK")

def get(self,request):
    """多对多的自关联[单向]: 查询数据"""
    查询小红的关注列表
    member = Member.objects.get(name="小红")
    print(member.focus.all())

    # 查询小红的粉丝列表
    member = Member.objects.get(name="小红")
    print(member.fans_list.all())

    return HttpResponse("OK")
```