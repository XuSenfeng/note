## 模型扩展

### 模型管理器

> 模型类.objects.操作方法()  # objects 就是模型管理器对象，它提供了所有关于数据库的操作以及获取数据库查询结果的属性方法。

objects是 模型管理器（Manager）的实例对象，而模型管理器（Manager）是`models.Model`提供给模型进行数据库操作的接口对象，因为数据库模型类都必须要继承`models.Model`，所以django中每个模型类都拥有至少一个模型管理器对象(objects)。

我们在通过模型类的**objects**属性提供的方法操作数据库时，即是在使用一个模型管理器的实例对象objects。当没有为模型类定义管理器时，Django会为每一个模型类生成一个名为objects的管理器对象，它是**models.Manager**类的实例对象。

在源代码中`models.Model`的元类ModelBase提供了一个`_prepare`方法，在`_prepare`方法中创建了objects对象并补充到Model类中。`django/db/models/base.py`，代码：

```python
def _prepare(cls):
        """Create some methods once self._meta has been populated."""
        opts = cls._meta
        opts._prepare(cls)

        if opts.order_with_respect_to:
            cls.get_next_in_order = partialmethod(
                cls._get_next_or_previous_in_order, is_next=True
            )
            cls.get_previous_in_order = partialmethod(
                cls._get_next_or_previous_in_order, is_next=False
            )

            # Defer creating accessors on the foreign class until it has been
            # created and registered. If remote_field is None, we're ordering
            # with respect to a GenericForeignKey and don't know what the
            # foreign class is - we'll add those accessors later in
            # contribute_to_class().
            if opts.order_with_respect_to.remote_field:
                wrt = opts.order_with_respect_to
                remote = wrt.remote_field.model
                lazy_related_operation(make_foreign_order_accessors, cls, remote)

        # Give the class a docstring -- its definition.
        if cls.__doc__ is None:
            cls.__doc__ = "%s(%s)" % (
                cls.__name__,
                ", ".join(f.name for f in opts.fields),
            )

        get_absolute_url_override = settings.ABSOLUTE_URL_OVERRIDES.get(
            opts.label_lower
        )
        if get_absolute_url_override:
            setattr(cls, "get_absolute_url", get_absolute_url_override)
		# 添加一个object
        if not opts.managers:
            if any(f.name == "objects" for f in opts.fields):
                raise ValueError(
                    "Model %s must specify a custom Manager, because it has a "
                    "field named 'objects'." % cls.__name__
                )
            manager = Manager()
            manager.auto_created = True
            cls.add_to_class("objects", manager)

        # Set the name of _meta.indexes. This can't be done in
        # Options.contribute_to_class() because fields haven't been added to
        # the model at that point.
        for index in cls._meta.indexes:
            if not index.name:
                index.set_name_with_model(cls)

        class_prepared.send(sender=cls)

```

同时，Manager模型管理器，实际上是继承了一个元类，这个元类就是QuerySet对象，从而提供了所有的数据库查询操作。

```python
class Manager(BaseManager.from_queryset(QuerySet)):
    pass
```

查找from_queryset方法的源代码，可以发现，此处在构建元类(我们在python面向对象高级中曾经讲过这块)

```python
@classmethod
def from_queryset(cls, queryset_class, class_name=None):
    if class_name is None:
        class_name = "%sFrom%s" % (cls.__name__, queryset_class.__name__)
        return type(
            class_name,
            (cls,),
            {
                "_queryset_class": queryset_class,
                **cls._get_queryset_methods(queryset_class),
            },
        )

```

 

#### 自定义模型管理器

我们可以自定义模型管理器，并应用到我们的模型类上，以增加一些自定义数据库查询操作。但是**一旦为模型类指明自定义模型管理器以后，Django不再提供默认的模型管理器对象objects了**。

自定义管理器类主要用于两种情况，分别是重写objects的现有方法与新增数据库操作方法。

准备一个用户模型，代码：

```python
class User(models.Model):
    """用户信息表"""
    nickname = models.CharField(max_length=50, verbose_name="昵称")
    username = models.CharField(max_length=50, verbose_name="用户名")
    password = models.CharField(max_length=255, verbose_name="密码")
    created_time = models.DateTimeField(auto_now_add=True, verbose_name="注册时间")
    updated_time = models.DateTimeField(auto_now=True, verbose_name="更新时间")
    deleted_time = models.DateTimeField(null=True, blank=True, verbose_name="删除时间")

    class Meta:
        db_table = "orm_user"
        verbose_name = "用户信息"
        verbose_name_plural = verbose_name

    def __str__(self):
        return str({"name": self.nickname, "deleted_time": self.deleted_time})
```

数据迁移

```bash
python manage.py makemigrations
python manage.py migrate
```

#### 直接重写模型类

可以直接在模型里面写入自己的函数比如实现`get_user`

```python
def get_user(self):
    return self.objects.filter(age__gte=18).all()
```

但在这时候发现实际使用的时候`models.User().get_user()`里面的User()初始化的时候设置不了参数

```python
@classmethod
def get_user(cls):
    return cls.objects.filter(age__gte=18).all()
```

需要改为这种方式, 很不方便

#### 重写objects的现有方法

打开orm/models.py文件，定义类UserManager

```python
from django.db.models import Manager

"""
1. 自定义模型管理器
模型管理器，必须直接或间接继承于 Manager
注意：filter的返回值并非QuerySet，所以跟在filter后面的调用的方法无法重写。
"""
class UserManager(Manager):
    def create(self, **kwargs):
        if "password" in kwargs:
            from hashlib import sha256
            hash = sha256()
            hash.update(kwargs["password"].encode())
            kwargs["password"] = str(hash.hexdigest())
        return super().create(**kwargs)

    def all(self):
        return super().filter(deleted_time__isnull=True).all()
```

在模型类User中注册模型管理器

```python
class User(models.Model):
    """用户信息表"""
    nickname = models.CharField(max_length=50, verbose_name="昵称")
    username = models.CharField(max_length=50, verbose_name="用户名")
    password = models.CharField(max_length=255, verbose_name="密码")
    created_time = models.DateTimeField(auto_now_add=True, verbose_name="注册时间")
    updated_time = models.DateTimeField(auto_now=True, verbose_name="更新时间")
    deleted_time = models.DateTimeField(null=True, blank=True, verbose_name="删除时间")

    """
    2. 作为类属性注册到模型类中
    """
    objects = UserManager()

    class Meta:
        db_table = "orm_user"
        verbose_name = "用户信息"
        verbose_name_plural = verbose_name

    def __str__(self):
        return str({"name": self.nickname, "deleted_time": self.deleted_time})

```

视图中调用模型管理器

```python
class Student6View(View):
    def get(self, request):
        """修改objects原有方法"""
        # from hashlib import sha256
        # hash = sha256()
        # hash.update("123456".encode())
        # user = User.objects.create(username="root", nickname="超级管理员", password=str(hash.hexdigest()))

        # user = User.objects.create(username="root", nickname="超级管理员", password="123456")

        user_list = User.objects.all()
        print(user_list)

        return HttpResponse("ok")
```

 

#### 在管理器类中补充定义新的查询方法

a）打开models.py文件，定义方法create。

```python
from django.db.models import Manager

class UserManager(Manager):
    def create(self, **kwargs):
        if "password" in kwargs:
            from hashlib import sha256
            hash = sha256()
            hash.update(kwargs["password"].encode())
            kwargs["password"] = str(hash.hexdigest())
        return super().create(**kwargs)

    def all(self):
        return super().filter(deleted_time__isnull=True).all()

    def soft_delete(self, **kwargs):
        """逻辑删除，并非真实删除数据，而是给数据设置了一个删除时间"""
        from datetime import datetime
        return self.filter(**kwargs).update(deleted_time=datetime.now())

```

视图代码调用：

```python
class Student6View(View):
    def get1(self, request):
        """修改objects原有方法"""
        from hashlib import sha256
        hash = sha256()
        hash.update("123456".encode())
        user = User.objects.create(username="root", nickname="超级管理员", password=str(hash.hexdigest()))
		# 重写以后 
        user = User.objects.create(username="root", nickname="超级管理员", password="123456")

        user_list = User.objects.all()
        print(user_list)

        return HttpResponse("ok")

    def get(self, request):
        """新增objects没有的方法"""
        User.objects.soft_delete(username="root")
        return HttpResponse("ok")
```

### 代理模型(模型细分)

Django提供的ORM模型声明中，一共有3种不同类型的模型。我们前面已经了解并使用了2种。使用代理模型的时候可以共享父类模型的数据



```python
from django.db import models
from django.db.models.base import Manager

class UserManager(Manager):
    def get_user_list(self):
        return self.filter(age__gte=18).all()


# Create your models here.
class User(models.Model):
    name = models.CharField(max_length=20, db_index=True, verbose_name="姓名")
    age = models.IntegerField(verbose_name="年龄")
    sex = models.BooleanField(null=True, blank=True, default=None, verbose_name="性别")
    # 覆盖设置了django默认的模型管理器
    objects2 = UserManager() # 模型的对象管理器，是否叫objects都不影响django取消内部的objects，因为我们自定义了

    class Meta:
        db_table = 'tb_user'
        verbose_name = "用户信息"
        verbose_name_plural = verbose_name

    def __str__(self):
        return self.name

    @classmethod
    def get_user(cls):
        """获取成年人列表"""
        return cls.objects.filter(age__gte=18).all()


class Female(User):
    class Meta:
        proxy = True # 设置当前模型为代理模型，共享父模型的数据和操作方法

    @classmethod
    def all(cls):
        return cls.objects2.filter(sex=False).all()


class Male(User):
    class Meta:
        proxy = True

    @classmethod
    def all(cls):
        return cls.objects2.filter(sex=True).all()

```