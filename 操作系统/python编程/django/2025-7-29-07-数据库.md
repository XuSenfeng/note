# 数据库

```
python manage.py makemigrations
python manage.py migrate
```



常用数据库有2大阵营：

1. 关系型数据库[RDB]: 数据库中存储数据的表之间存在某种内在的关联关系，因为这种关系，所以我们称这一类型的数据为关系型数据库。
    常见的数据库：mysql[MariaDB]，PostgreSQL（简称PG），Oracle，MSSQLServer，DB2，sqlite，Access，SequoiaDB
    共同的特点：都使用了SQL语句进行数据库操作。

2. 非关系型数据库[NOSQL（Not Only SQL）]：泛指那些不适用SQL语句进行数据库操作的所有其他数据库。
   常见的数据库：Redis，MongoDB， Memcached，Elasticsearch，HBase/CouchDB, Neo4j、FlockDB、AllegroGrap，rethinkDB

## ORM框架

django中内置了一个基于面向对象的强大的ORM框架给开发者对数据库进行操作的。

O是Object，也就**类对象**的意思。

R是Relational，翻译成中文是**关系**，也就是关系型数据库中**数据表**的意思。

M是mapping，是**映射**的意思，表示类对象和数据表之间的映射关系。

ORM框架会帮我们把类对象和数据表进行了一对一的映射，让我们可以**通过类对象来操作对应的数据表**。

ORM框架还可以**根据我们设计的类自动帮我们生成数据库中的数据表**，也就是使用代码生成数据库建表语句，省去了我们自己建表的过程。

django中内嵌了ORM框架，不需要直接编写SQL语句进行数据库操作，而是通过定义模型类，操作模型类来完成对数据库中数据的增删改查和数据表的创建删除等操作。

![image-20250729181017944](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507291810035.png)

### ORM的优点

- 数据模型类都在一个地方定义，更容易更新和维护，也利于重用代码。
- ORM 有现成的工具，很多功能都可以自动完成，比如数据消除、预处理、事务等等。
- ORM迫使开发人员使用 MVC 架构，ORM 就是天然的 Model，最终使代码结构更清晰易懂。
- 基于 ORM 的业务代码比较简单，代码量少，语义性好，容易理解。
- 新手对于复杂业务容易写出性能不佳的 SQL,有了ORM不必编写复杂的SQL语句, 只需要通过操作模型对象即可同步修改数据表中的数据.
- 开发中应用ORM将来如果要切换数据库.只需要切换ORM底层对接数据库的驱动【修改配置文件的连接地址即可】

### ORM 也有缺点

- ORM 库不是轻量级工具，需要花很多精力学习和设置，甚至不同的项目框架会存在不同操作的ORM。
- 对于复杂的业务查询，ORM表达起来比原生的SQL要更加困难和复杂。ORM并非万能的，总有些功能需要我们使用原生SQL语句，当然ORM也提供执行原生SQL语句的功能
- ORM操作数据库的性能要比使用原生pymysql执行SQL差。[ORM内部要拼接SQL语句]
- ORM 抽象掉了数据库层，开发者无法了解底层的数据库操作，也无法定制一些特殊的 SQL。【自己使用pymysql另外操作即可，用了ORM并不表示当前项目不能使用别的数据库操作工具。】

## 配置数据库连接

在settings.py中保存了数据库的连接配置信息，Django默认初始配置使用**sqlite**数据库。

我们可以通过以下步骤来使用django的数据库操作

1. settings.py配置数据库连接信息
2. 在目标子应用下的models.py中定义模型类
3. 生成数据库迁移文件并执行迁移文件[注意：数据迁移是一个独立的用于创建数据表的功能，这个功能在其他web框架未必和ORM一块的]
   第3步非必要，有些公司直接由DBA（数据库管理员）设计与管理数据表的，那么就不需要在django中数据迁移了。直接开撸代码
4. 通过模型类对象提供的方法或属性完成数据表的增删改查操作

## 安装

需要使用python的MQL库

```bash
pip install PyMySQL
pip install cryptography
```

在Django的主应用目录的`__init__.py`文件中添加如下语句，`djdemo/__init__.py`，代码：

```python
from pymysql import install_as_MySQLdb

install_as_MySQLdb()  # 让pymysql以MySQLDB的运行模式和Django的ORM对接运行
```

![image-20250730105035989](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507301050058.png)

启动数据库

```
mysql.exe -h 127.0.0.1 -P 3306 -u root -p
```

创建数据库

```sql
create database school charset=utf8mb4;
```

修改**DATABASES**配置信息，settings.py配置文件配置数据库的连接信息

```python

# Database
# https://docs.djangoproject.com/zh-hans/4.2/ref/settings/#databases
# 数据库配置
DATABASES = {
    'default': {
        # 'ENGINE': 'django.db.backends.sqlite3',
        # 'NAME': BASE_DIR / 'db.sqlite3',
        'ENGINE': 'django.db.backends.mysql',  # ORM的底层对接pymysql的核心引擎类
        'NAME': 'school',          # 数据库名
        'PORT': 3306,              # 端口
        'HOST': '127.0.0.1',       # 数据库IP
        'USER': 'root',            # 账号
        'PASSWORD': '123',         # 密码
        'POOL_OPTIONS': {  # pool表示数据库连接池配置，主要为了节省连接数据库的开销，临时存储数据库连接对象
            'POOL_SIZE': 10,     # 默认情况下，打开的数据库连接对象的数量 [1,2,3,4,5,6,7,8,9,10]
            'MAX_OVERFLOW': 30,  # 负载情况下，允许溢出的连接数量  [11,12,13,14,15,16,17,18,19,20]
        }
    }
}
```

## 定义模型类

- 模型类被定义在"子应用/models.py"文件中。
- 模型类必须直接或者间接继承于django.db.models.Model类【Model相当于我们之前学习mysql基础时封装的DB类一样，里面提供了大量对数据库的操作方法】。

接下来以学校的学生管理为例进行演示。[系统大概3-4表，学生信息，课程信息，老师信息]，之前我们在mysql基础时直接使用SQL来建表，现在我们可以使用django提供的数据迁移来生成建表SQL语句，并创建数据表。使用数据迁移，必须先定义模型。

再次强调，工作中并非每个公司都使用数据迁移的

```python
from django.db import models
"""
    学生表, 继承自models.Model, 表示是一个模型类, 用于定义数据库表结构
    create table 'student' (
        id int auto_increment primary key,
        name varchar(15) not null,
        age int default 18,
        gender boolean default true,
        class_id int not null,
        description text,
    )
"""
class Student(models.Model):
    # 姓名, 最大长度15, 索引(db_index=True)用于快速查询, 字段名name, 字段描述verbose_name='姓名'
    name = models.CharField(max_length=15, verbose_name='姓名', db_index=True) 
    # 年龄, 整数类型, 默认值为18, 字段名age, 字段描述verbose_name='年龄'
    age = models.IntegerField(default=18, verbose_name='年龄')
    # 性别, 字符串类型, 最大长度10, 字段名gender, 字段描述verbose_name='性别'
    gender = models.BooleanField(default=True, verbose_name='性别')
    # 创建时间, 自动获取当前时间, 字段名create_time, 字段描述verbose_name='创建时间'
    create_time = models.DateTimeField(auto_now_add=True, verbose_name='创建时间')
    # 描述, 文本类型, 字段名description, 字段描述verbose_name='描述', 允许为空(null=True)
    # 允许为空字符串(blank=True)
    description = models.TextField(verbose_name='描述', null=True, blank=True)
    class Meta:
        db_table = 'student' # 指定表名
        verbose_name = '学生' # 指定表的别名
        verbose_name_plural = '学生' # 指定表的别名复数
```



```python
from django.db import models
"""
1. django中所有的模型，必须直接或间接继承models.Model模型基类
"""
 
"""
-- auto-generated definition
create table student
(
    id           bigint auto_increment
        primary key,
    name         varchar(15) not null,
    age          smallint    not null,
    sex          tinyint(1)  not null,
    class        varchar(50) not null,
    mobile       varchar(20) not null,
    description  longtext    null,
    status       int         null,
    created_time datetime(6) null,
    updated_time datetime(6) null,
    constraint mobile
        unique (mobile)
);
 
create index student_class_ad9a3931
    on student (class);
 
create index student_name_68e26583
    on student (name);
"""
 
 
class BaseModel(models.Model):
    # auto_now_add 设置新建数据时，把当前时间戳作为默认值保存到当前字段中
    created_time = models.DateTimeField(auto_now_add=True, null=True, verbose_name="创建时间")
    # auto_now 设置更新数据时，把当前时间戳作为默认值保存到当前字段中
    updated_time = models.DateTimeField(auto_now=True, null=True, verbose_name="更新时间")
 
    class Meta:
        # 设置当前类为抽象模型，表示当前模型并不是一个真正的表，django就不会跟踪识别这个模型了。
        abstract = True
 
 
# Create your models here.
class Student(BaseModel):
    STATUS = (
        # (数据库值, "程序显示给外界看的文本"),
        (0, "正常"),
        (1, "未入学"),
        (2, "已毕业"),
    )
    # django模型中不需要自己单独声明主键，模型会自动创建主键ID，将来直接可以通过模型对象.id 或者 模型对象.pk就可以调用主键了。
    name = models.CharField(max_length=15, db_index=True, verbose_name="姓名")
    age = models.SmallIntegerField(default=0, verbose_name="年龄")
    sex = models.BooleanField(default=True, verbose_name="性别")
    classmate = models.CharField(max_length=50, db_column="class", default="", db_index=True, verbose_name="班级编号")
    mobile = models.CharField(max_length=20, unique=True, verbose_name="手机号码")
    description = models.TextField(blank=True, null=True, verbose_name="个性签名")
    status = models.IntegerField(choices=STATUS, default=1, null=True, verbose_name="毕业状态")
 
    class Meta:
        db_table = "student"
        verbose_name = "学生信息"
        verbose_name_plural = verbose_name
 
    def __str__(self):
        # 当使用print打印django模型对象时的输出内容，返回值必须是字符串，方法名固定
        return self.name
```

> 主键不需要自己声明, 会自己创建, 可以使用`.id`或者`.pk`获取

1. 数据库表名

可通过**Meta.db_table** 指明数据库表名。

模型类如果未指明表名Meta.db_table，Django默认以 **小写子应用目录名_小写模型类名** 为数据库表名。

2. 关于主键

![image-20250730135337437](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507301353519.png)

django会为模型自动声明一个自动增长的主键列，每个模型只能有一个主键列。

如果使用选项设置某个字段的约束属性为主键列(primary_key)后，django不会再创建自动增长的主键列。

```python
class Student(models.Model):
    # django会自动在创建数据表的时候生成id主键/还设置了一个调用别名 pk
    id = models.BigAutoField(primary_key=True, verbose_name="主键") # 设置主键
```

默认创建的主键列属性名为id，也可以使用pk代替id，pk全拼为primary key。

3. 性命名限制

- 不能是python的关键字或保留字。
- 不允许使用连续的2个下划线，这是因为django的查询方式提供了很多以`__xx`开头的方法或属性，所以`__xx`是django的模型内部的关键字，不能使用！
- 定义属性时需要指定字段类型，通过字段类型的参数指定选项，语法如下：

```python
属性名 = models.字段类型(约束选项, verbose_name="注释")

# 在mysql数据表中的字段名如果在python是一个关键字/保留字。则选项中需要通过db_column()来进行关联绑定
class_name = models.SmallIntegerField(db_column="class", verbose_name="班级")
# class就是实际上在mysql数据表中的真实字段名
# class_name 就是python中将来用于操作数据的属性名 
```

4. 字段类型

文档：https://docs.djangoproject.com/zh-hans/4.2/ref/models/fields/#field-types

| 类型              | 说明                                                         |
| :---------------- | :----------------------------------------------------------- |
| AutoField         | 自动增长的IntegerField，通常不用指定，不指定时Django会自动创建属性名为id的自动增长属性，并且提供了一个pk属性与主键进行关联。django3.0以后，系统默认采用了**BigAutoField**，从原来的int类型变成了bigint类型，其他不变。 |
| BigAutoField      | 一个 64 位整数，与 [`AutoField`](https://docs.djangoproject.com/zh-hans/4.2/ref/models/fields/#django.db.models.AutoField) 很相似，但保证适合 `1` 到 `9223372036854775807` 的数字。 |
| **BooleanField**  | 布尔字段，值为True或False，实际上在数据库中存储的是smallint，采用0/1表示False/True |
| NullBooleanField  | 支持None、True、False三种值，在4.0版本的django中已经被声明废弃了。 |
| **CharField**     | 字符串，参数max_length表示最大字符个数，对应mysql中的varchar |
| **TextField**     | 大文本字段，一般大段文本（超过4000个字符）才使用，对应mysql中的bigtext。 |
| **IntegerField**  | 整数，对应mysql中的int                                       |
| BigIntegerField   | 大整型，对应mysql的bitint                                    |
| **DecimalField**  | 十进制定点数， 参数max_digits表示总位数， 参数decimal_places表示小数位数，常用于表示分数和价格 Decimal(max_digits=7, decimal_places=2) ==> 99999.99~ 0.00 |
| FloatField        | 浮点数                                                       |
| DateField         | 日期，年-月-日 参数auto_now表示每次创建/更新对象时，自动设置该字段的值为当前时间。 参数auto_now_add表示当对象第一次被创建时自动设置该字段的值为当前时间。 参数auto_now_add和auto_now是相互排斥的，一起使用会发生错误。 |
| TimeField         | 时间，时分秒，参数同DateField                                |
| **DateTimeField** | 日期时间，年月日时分秒，参数同DateField                      |
| **FileField**     | 继承于CharField，上传文件字段类型，但是django在FileField中内置了文件上传保存类, django可以通过模型的字段存储自动保存上传文件, 但是在数据库中本质上保存的仅仅是文件在项目中的`存储路径`!! 参数upload_to，表示设置当前上传文件的存储路径位置，当前路径如果不存在，django会自动生成路径。 |
| **ImageField**    | 继承于FileField，对上传的内容进行校验，确保是有效的图片      |
| EmailField        | 继承于CharField，邮件字段类型，但是增加字段值的验证是否为邮件格式 |
| UUIDField         | 继承于CharField，UUID字段类型，保存内容格式字符串，但是会验证当前字段是否是UUID格式。 |

5. **约束选项**

文档：https://docs.djangoproject.com/zh-hans/4.2/ref/models/fields/#field-options

| 选项             | 说明                                                         |
| :--------------- | ------------------------------------------------------------ |
| **null**         | 如果为True，表示允许为空，默认值是False。相当于python的None  |
| **blank**        | 如果为True，则该字段允许为空白，默认值是False。 相当于python的空字符串："" |
| **db_column**    | 数据表中真实的字段名称，如果未指定，则使用模型类属性的名称。防止数据字段是python的关键字。 |
| **db_index**     | 若值为True, 则在表中会为此字段创建索引，默认值是False。 相当于SQL语句中的key |
| **default**      | 默认值，当不填写数据时，使用该选项的值作为字段的默认值。     |
| **primary_key**  | 如果为True，则该字段在表中设置为主键，默认值是False，一般不用设置，django会自动默认设置id作为主键。 |
| **unique**       | 如果为True，则该字段在表中创建唯一索引，默认值是False。相当于SQL语句中的unique |
| **choices**      | 设置当前字段值的候选值选项，必须是二维序列，子序列必须是2个成员。用于限定可以使用的数值 |
| help_text        | 设置当前字段的辅助提示文本信息，是一个人类可读的文本信息。一般显示给客户端（前台）的。 |
| **verbose_name** | 设置当前字段的提示字段名，是一个人类可读的名称，一般显示给服务端（后台）的。 |

### 建立表

-- 完成上面的步骤以后，建表有2种方式：手动SQL语句建表与数据迁移
-- 数据迁移

```bash
python manage.py makemigrations
python manage.py migrate
```

> 1. `python manage.py makemigrations`
>
> **作用**：检测模型变化并生成迁移脚本
>
> - 扫描所有已安装应用的模型 (`models.py`)
> - 将检测到的模型变化（新增模型、修改字段、删除字段等）转换为数据库操作指令
> - 在应用的 `migrations/` 目录下生成新的迁移文件（如 `0002_auto_20210730.py`）
> - **不修改实际数据库**，只创建变更记录文件
>
> 使用场景：
>
> - 修改模型后首次运行
> - 添加新模型时
> - 字段增删改时
> - 修改模型关系时
>
> 2. `python manage.py migrate`
>
> **作用**：将迁移脚本应用到实际数据库
>
> - 检查 `django_migrations` 表（记录已应用的迁移）
> - 按顺序执行所有未应用的迁移文件中的操作
> - 修改实际数据库结构（创建表/字段/索引等）
> - 更新 `django_migrations` 表记录
>
> **使用场景**：
>
> - 首次初始化数据库
> - 应用新的迁移文件后
> - 同步团队成员的数据库变更

![image-20250730143441552](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507301434610.png)

![image-20250730143746102](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507301437204.png)

## 数据操作

### 查询数据

#### get获取符合的

**查询单一结果**，如果不存在或者返回多个结果会抛出异常。主要是基于唯一的索引进行的

查询不到, 则返回**模型类.DoesNotExist**异常。

查询多个, 则返回**模型类.MultipleObjectsReturned**异常。

```python
def get(self,request):
    """基本查询数据"""
    """get 获取一条数据"""
    try:
        # student = Student.objects.get(name="小黄人4号")
        # student = Student.objects.get(name="小白")
        student = Student.objects.get(name="小黄人")
        print(student, type(student))
        print(student.name)
        print(student.description)
    except Student.DoesNotExist:
        print("没有查询结果！")
    except Student.MultipleObjectsReturned:
        print("当前数据不是唯一的结果！")
    
    return HttpResponse("OK")
```

#### first

**查询一个结果**, 查询不到，则返回None，查询多个，返回查询结果列表的第一个。

django还提供了last方法，可以获取结果列表中最后一个成员。

```python
"""基于first来查询第一条数据"""
# first不会报错！
# 当查询结果为多个结果时，只会返回查询到的第一个结果，作为模型对象返回
# 当查询结果为0个结果时，则返回None
student = Student.objects.first()
# SQL: select * from tb_student limit 1;
print(student)
if student:  # 判断如果student不是None
    print(student.pk, student.id)  # pk是id的别名
    print(student.description)

"""使用filter来过滤数据，并返回一条"""
# student = Student.objects.filter(classmate=301).first()
student = Student.objects.filter(classmate=333).first()
print(student, type(student))  # None <class 'NoneType'>  对于没有结果的查询，使用first则会返回一个None
```

#### all查询所有

查询所有结果。查询不到,则返回空列表对象

```python
"""all 获取所有数据"""
student_list = Student.objects.all()
print(student_list)       # 获取结果列表
print(len(student_list))  # 获取结果列表的长度

# 把结果列表中的所有模型对象转化成字典结构
student_list = Student.objects.all().values()
print(student_list)

# 把结果列表中的所有模型对象转换成元组结构
student_list = Student.objects.all().values_list()
print(student_list)

"""
使用filter查询过滤数据，并返回所有符合条件的结果
filter(字段名=条件值)
filter(字段名=条件值, 字段名=条件值)  # 相当于and
"""
student_list = Student.objects.filter(classmate=302).all()
print(student_list)
# <QuerySet [<Student: 王天歌>, <Student: 王天龙>, <Student: 祝华生>]>
```

#### count返回总数

查询结果数量。实际上是一个聚合函数来的

```python
"""count 获取结果总数"""
# 没有任何条件的统计当前数据表的结果
total = Student.objects.count()
print(f"学生总人数：{total}")

# 也可以添加where条件
total = Student.objects.filter(classmate="301").count()
print(f"学生总人数：{total}")
```

#### 示例

可以使用以下的代码获取所有的数据

```python
from .models import Student
students = Student.objects.all()
```

> 获取的是一个`Queryset`的数组, 这个数组是ORM里面提供的查询使用的对象集合, 可以使用索引限定一下索引的数量但是不可以使用负数(伪列表)

```python
def get(self, request):
    student_list = []
    students = Student.objects.all()
    for student in students:
        student_list.append({
            'id': student.id,
            'name': student.name,
            'age': student.age,
            'sex': student.sex,
            'status': student.get_status_display(), # 获取status的文字描述
        })
    return JsonResponse(student_list, safe=False)
```

#### value获取字典所有

all返回的是模型对象列表, 如果需要获取字典的列表可以使用`list(Student.objects.values())`, 这个函数的才参数是可以选择获取的字段, 默认是获取所有的字段

#### 获取choice对应信息

使用`模型对象.get__字段名__display()`即可获取提示文本

#### 控制台

在admin.py文件里面添加

```python
from django.contrib import admin

# Register your models here.
from .models import Student

admin.site.register(Student)
```



![image-20250730161056458](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507301610566.png)

![image-20250730161238943](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507301612003.png)

> 之前设置的`verbose_net`在这里进行显示

### 数据回滚

`python manage.py migrate 子应用名 数据记录`例如 `python manage.py migrate test1 0001_initial`

![image-20250730154905617](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507301549662.png)

可以使用zero把表都删了

### 添加数据

#### save

通过创建模型类对象，执行对象的save()方法保存到数据库中。

```python
"""添加一条数据"""
# ORM对于数据的所有操作都是有子类objects来提供的。objects，可以被修改，开发中一般叫objects为"模型管理器"
student = Student(
    name="刘德华",
    age=17,
    xingbie=True,
    classmate=301,
    description="一杯忘情水",
)
# 自动执行添加数据
student.save()
# 添加后的模型会多出一个主键数据，可以通过id或者pk来读取
print(student.id) # print(student.pk)
```

![image-20250730165759324](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507301657426.png)

#### create

通过模型类.objects.create()保存。

```python
"""使用create来完成添加一条数据"""
# 返回值就是添加后的模型对象，会有ID主键的
student = Student.objects.create(
    name="赵本山",
    age=50,
    xingbie=True,
    classmate=301,
    description="一段小品"
)
print(student)
print(student.pk)  # print(student.id)
```

#### bulk_create批量添加

通过`模型类.objects.bulk_create()`批量添加数据

```python
"""基于bulk_create添加多条数据"""
stu1 = Student(name="小黄人1号", age=17, xingbie=True, classmate=301, description="卜乃奈")
stu2 = Student(name="小黄人2号", age=17, xingbie=False, classmate=301, description="卜乃奈")
stu3 = Student(name="小黄人3号", age=17, xingbie=True, classmate=301, description="卜乃奈")
stu4 = Student(name="小黄人3号", age=17, xingbie=True, classmate=301, description="卜乃奈")
stu_list = [stu1,stu2,stu3,stu4]
ret = Student.objects.bulk_create(stu_list)
print(ret)
return HttpResponse("ok")
```

### 更新数据

#### save一条

修改模型类对象的属性，然后执行save()方法同步到数据库中

```python
"""save 更新一条数据"""
# 先把要更新的数据查询出来，得到一个模型类对象
student = Student.objects.filter(name="小白").first()
# SQL: select * from tb_student where name='小白' limit1;
if student:
    student.name = "小黑"
    student.age = 18
    student.save()  # 把当前模型的中字段值同步到数据库
    # SQL: update student set name='小黑', age=18, sex=True, description='xxx' where id=103;
```

#### update更新多条

使用`模型类.objects.filter().update()`，基于update来完成更新满足条件的所有数据，结果是受影响的行数

```python
"""update 更新多条数据"""
# 基于update这种操作在数据库操作中，一般称之为"乐观锁"
# update操作的执行效率比save要高！
# update如果条件设置宽松，可以修改多条数据
Student.objects.filter(name="刘德华").update(name="刘福荣")
# SQL: update tb_student set name="刘福荣" where name="刘德华";
```

 ### 删除

删除有两种方法，分别是删一条或删多条数据。

#### 模型类对象.delete()

```
    def get(self,request):
        """删除数据"""
        """删除一条数据"""
        # 先查询要删除的数据
        student = Student.objects.filter(name="小白").first()
        if student:
            # 调用模型对象的delete方法进行删除
            student.delete()
        return HttpResponse("Ok")
```

#### 模型类.objects.filter().delete()

```
        """删除多条"""
        # 把符合条件的数据全部删除，注意：这种删除操作务必加上filter过滤条件，否则会变成全表删除
        # 返回值是删除的数量
        Student.objects.filter(name="小黄人").delete()
```