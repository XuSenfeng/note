# 中间件

MiddleWare，是 Django 请求/响应处理的钩子框架。它是一个轻量级的、低级的“插件”系统，用于全局改变 Django 的输入或输出。【输入指代的就是客户端向服务端django发送数据，输出指代django根据客户端要求处理数据的结果返回给客户端】

钩子就是编程开发的一个术语，hook，钩子可以理解为一段代码(要么是类，要么是函数)，它的作用就类似日常生活中墙上的钩子，不需要的时候，挂在墙上不会占用房子的空间，但是需要的时候我们可以把一些物件挂在上面。

这种中间件在平时不使用情况下不会耗费任何的性能,如果编写了中间件以后,可以在特定的条件下,全局执行!!

文档: https://docs.djangoproject.com/zh-hans/4.2/topics/http/middleware/

## 内置中间件

django框架内部声明了很多的中间件，这些中间件有着各种各种的用途，有些没有被使用，有些被默认开启使用了。

而被开启使用的中间件，都是在settngs.py的MIDDLEWARE中注册使用的。

```python
# 中间件列表
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware', # 安全监测相关的中间件,防止页面过期, js跨站脚本攻击xss
    'django.contrib.sessions.middleware.SessionMiddleware', # session加密和读取、保存session相关
    'django.middleware.common.CommonMiddleware', # 通用中间件,用于给url进行重写，自动给URL后面加上/
    'django.middleware.csrf.CsrfViewMiddleware', # 防止网站遭到csrf攻击的
    'django.contrib.auth.middleware.AuthenticationMiddleware', # 用户认证的中间件
    'django.contrib.messages.middleware.MessageMiddleware', # 错误提示信息的中间件【提示错误信息，一次性提示】
    'django.middleware.clickjacking.XFrameOptionsMiddleware', # 用于防止点击劫持攻击的 iframe标签
]
```

 Csrf攻击

跨站请求伪造, Cross-site request forgery，利用用户在不知情的情况下实现伪造表单提交给服务端中进行攻击的手段。

![image-20250729160911404](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507291609598.png)

django中提供了一个Csrfmiddleware的中间件给开发者用于防止网站用户遭到这种攻击的.

中间件主要是每次客户端通过post,patch,put等方式提交数据操作时,判断当前表单是否是隐藏了一个django发放的**csrf_token**的随机字符串令牌.如果有这个随机字符串,则中间件则会判断这个随机字符串是否是由服务端提供的.

我们开发者只需要在每个表单页面中, 内置一个隐藏的输入框里面填写cstf_token则可以让当前页面的表单顺利提交数据到后台.

> csrf_token的生成是每次都是基于服务端的秘钥进行随机生成的,所以有一定的生成算法在里面的,所以如果没有秘钥的情况下, 则生成的随机token令牌则会轻易被django识别到.

+ html获取csrf_token用于post

```python
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CSRF防范</title>
</head>
<body>
    <form action="/usr/form/" method="post">
        <!-- {{ csrf_token }} -->
        <input type="hidden" name="csrfmiddlewaretoken" value="{{ csrf_token }}">
        <input type="text" name="username" placeholder="用户名">
        <input type="password" name="password" placeholder="密码">
        <input type="submit" value="提交">
    </form>
</body>
</html>
```

+ 处理

```python
class UserView(View):

    def get(self,request):
        """只允许通过get请求访问,建议编写读取数据的页面,一般例如:首页,列表页,详情页"""
        # 视图中的视图方法里面的代码，与原来的函数视图中的代码，是一模一样的。原来怎么写，现在还是怎么写。
        return render(request, 'form.html', locals())

    def post(self,request):
        print(request.POST)
        username = request.POST.get('username', '')
        password = request.POST.get('password', '')
        
        if username and password:
            return HttpResponse(f"用户名: {username}, 密码: {password}")
        else:
            return HttpResponse("请填写完整的用户名和密码")
```

### GZIP压缩

压缩所有现代浏览器的响应，节省带宽和传输时间。

注意，GzipMiddleware目前被认为是一种安全风险，并且容易受到TSL/SSL提供的保护无效的攻击。

settings.py，代码：

```python
MIDDLEWARE = [
    'django.middleware.gzip.GZipMiddleware', # 实际工作中，我们往往是采用web服务器（uwsgi, nginx）来实现gzip压缩
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    # 'django.middleware.csrf.CsrfViewMiddleware',   # ctrl+/
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]
```

### 执行顺序

![image-20250729164037657](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507291640762.png)

请求的时候执行的是process_request, 返回的时候执行process_response

## 自定义

### 函数式中间件

在项目的主应用目录下创建一个专门存放中间件函数的模块 主应用djdemo/my_middleware.py,代码:

```python
def simple_middleware(get_response):
    # 自定义中间件
    def middleware(request):
        # Code to be executed for each request before
        # the view (and later middleware) are called.
        print("--------------视图执行之前---------------")
        # 记录访问用户记录的信息,识别判断黑名单,白名单,判断用户是否登录, 判断用户是否拥有访问权限.....
        # 视图执行之前
        response = get_response(request) # 视图调用
        # 视图执行之后
        print("-------------视图执行以后----------------")
        # 记录用户的操作历史,访问历史,日志记录, 资源的回收...
        return response

    return middleware
```

>  `get_response`实际就是执行的视图

![image-20250729171649592](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507291716642.png)

添加进来即可执行

### 类中间件

和函数式的中间件一样,我们一般都会保存在一个独立的文件中.把所有的中间件按不同的业务存放在一块,.

middle.py,代码:

```python
from django.utils.deprecation import MiddlewareMixin
from django.http.response import HttpResponse
class CustomMiddleware(MiddlewareMixin):
    """中间件类"""
    def process_request(self,request):
        # 方法名是固定的,该方法会在用户请求访问路由解析完成以后,调用视图之前自动执行
        print("1. process_request在路由解析以后，产生request对象，视图执行之前,会执行这个方法")
        # 用途：权限,路由分发,cdn,用户身份识别,白名单,黑名单...
        # 注意,此方法不能使用return,使用则报错!!!

    def process_view(self,request,view_func, view_args, view_kwargs):
        # 用途：进行缓存处理,识别参数,根据参数查询是否建立缓存
        print("2. process_view在视图接受了参数以后，没有执行内部代码之前")
        # 可以返回response对象, 如果返回response对象以后,则当前对应的视图函数将不会被执行
        # return HttpResponse("ok")
        # 也可以不返回response,则默认返回None,django就会自动执行视图函数

    def process_response(self,request,response):
        print("4. process_response在视图执行以后,才执行的")
        # 用途：记录操作历史, 记录访问历史,修改返回给客户端的数据, 建立缓存
        # 必须返回response对象,否则报错!!
        return response
        
    def process_exception(self, request, exception):
        print(exception)
        # 用途：进行异常的处理或者记录错误日志
        print("5. process_exception会在视图执行发生异常的时候才会执行")

    def process_template_response(self,request, response):
        # 用途：建立页面缓存, 调用rander函数以后调用
        print("6. process_template_response只有在视图调用了模板以后,才会执行!!!")
        return response
```