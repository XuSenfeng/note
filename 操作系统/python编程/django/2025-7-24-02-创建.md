# 创建

可以使用命令`django-admin startproject 名字`

![image-20250724174839544](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507241748592.png)

启动: `python manage.py runserver 8000`

![image-20250724175212776](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507241752847.png)

可以在`ElectronicPet/settings.py`文件里面的ALLOWED_HOSTS选择可以用于访问的IP地址

## 目录架构

```
djdemo/   # 项目根目录
│─ manage.py    # 入口程序，终端脚本命令, 提供了一系列用于生成文件或者目录的命令,也叫脚手架
└─ djdemo/          # 主应用开发目录,保存了项目中的所有开发人员编写的代码, 目录是生成项目时指定的
    │- asgi.py      # django3.0以后新增的，用于让django运行在异步编程模式的一个web应用对象
    │- settings.py  # 默认开发配置文件，将来填写数据库账号，密码等相关配置
    │- urls.py      # 总路由文件,用于绑定django应用程序和url的映射关系, 不同的路径对应不同的功能
    │- wsgi.py      # wsgi就是项目运行在wsgi服务器时的入口文件, 本质上来说，manage.py runserver 内部调用的就是wsgi
    └- __init__.py  # 包初始化文件
```

> 默认运行的是这个同步阻塞的

可以在http://127.0.0.1:8000/admin这个页面进行登录

## 快速使用

在django中要提供数据展示给用户,我们需要完成3个步骤.

```
1. 创建子应用

2. 在子应用的视图文件views.py 中编写视图函数

3. 把视图函数和url进行绑定注册到django项目.
   用户就可以通过url地址访问，用户访问的时候，django自动根据url地址执行对应的视图函数
```

### 1. 创建子应用

```
python manage.py startapp 子应用名称（目录）
django-admin startapp 子应用名称
```

子应用的名称将来会作为目录名而存在，**务必按变量名的命名规则**来创建，不能出现特殊符号,也是不能出现中文等多字节的字符，更不能以数字开头！！！

 ![image-20250724191058505](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507241910558.png)

+ migrations: 数据迁移文件, 同步数据到数据库的
+ views: 视图函数

### 2. 在子应用的视图文件中编写视图函数

`home/views.py`,代码:

```python
from django.http.response import HttpResponse
def index(request):
    # 业务代码
    print("视图运行了")
    return HttpResponse("hello world!")

# 可以使用这种方式解析html
HttpResponse("<h1>ok!!!</h1>")
```

### 3. 绑定路由和视图的映射关系

`djdemo/urls.py`代码：

```
from django.contrib import admin
from django.urls import path
from home.views import index
urlpatterns = [
    path('admin/', admin.site.urls),
    path("index/", index), # 新加入的代码
]

```

因为上面我们绑定index视图函数的url地址是index,所以我们可以通过`http://127.0.0.1:8000/`拼接url地址`index`来访问视图函数

上面的过程,我们就可以展示数据给客户端浏览器了.但是这个过程发生了什么,怎么实现的?我们需要清晰几个相关概念：`网页类型`，`web服务器`和`MVT设计模式`，`路由`。


## web服务

**web服务器**，全称也叫`http web server`，专门**用于提供网页文件浏览的一类服务器软件**，本质上就是一种收发http协议并解析http内容的服务器软件，可以通过各类语言使用代码开发实现。 前面的学习中，我们在编辑器中执行manage.py文件以后, 之所以用户能使用浏览器访问视图函数就是django内置的**测试**web服务器的功劳. 常见的web服务器软件:  **nginx**，**uwsgi**，gunicorn，apache，toncat，uvicon。

其中, uwsgi和gunicorn, uvicon就是使用python开发的web服务器软件。

注意: 大部分的项目框架都有内置的测试web服务器。其中django框架就内置了python解析器提供的wsgiref模块，这个模块是python官方提供给开发者进行学习测试使用的，不能用于项目实际运营的线上环境中,    因为这个测试web服务器，性能不好，不支持多线程。

wsgi 就是python基于cgi标准实现的http通讯技术 asgi 就是wsgi的异步版本，async就是这个a，也就是python使用协程异步基于cgi标准实现的异步http通信技术。

![image-20250725102911071](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507251029225.png)

> **路由作用：将请求分发到正确的处理逻辑（视图）**
>
> - 接收从 `Application` 传来的 `Request` 对象
> - 根据请求的 URL 路径、请求方法（GET/POST 等）等信息
> - 匹配到对应的处理函数（即视图）
> - 把请求交给对应视图函数去处理
>
> **视图作用：负责处理业务逻辑并返回响应数据**
>
> - 从请求对象中提取参数
> - 调用数据库或业务逻辑
> - 构建响应对象（Response），通常是 HTML、JSON、文件等
> - 返回给路由或 Application 层处理

```
客户端浏览器
     ↓
http 请求报文
     ↓
http web服务器（监听端口、解析请求）
     ↓
Application（web应用处理程序，实例化Request对象）
     ↓
→【路由】⇒ 调用 View（Django 中的 View 处理逻辑）
     ↓
→【Template】模板渲染（生成 HTML 页面）
     ↓
返回 http 响应报文
```

#### MVT 设计模式

所谓的设计模式，就是前人针对解决常用业务场景所总结出来的一套解决方案【解决问题的流程】。

+ Django主要采用MVT模式。

*M-model\*：模型，操作数据库功能部分。

*V-View\*：视图，处理业务逻辑的位置，提取数据、获取用户数据等等操作都在这里。

*T-Template\*：模版，用来展示视图操作后的数据，也可以在模版中为用户提供表单，让用户可以提交数据。

------

| MVT            | MVC             | 描述     |
| -------------- | --------------- | -------- |
| *M-model**\*** | *M-model\*      | 数据模型 |
| *V-View\*      | *C-Controller\* | 业务逻辑 |
| *T-Template\*  | *V-view\*       | 外观效果 |

```
#  MVT 的交互流程 --前后端不分离开发， 后台工程师 会写前端代码（所有的， 只写模板部分）
#  MVC            前后端分离， 后台工程师 只写后台代码--json数据
1. 发请求----django框架--V--处理主业务逻辑（1.判断路由 2.解析参数 3.对接Model 4.返回数据）
2. V--获取数据--Model(交互数据库)
3. model--->V
4. V-->数据---Template-模板
5. Template--模板-数据渲染--V--展示--客户端
```

##### MVC设计模式

***M-model\***：**数据模型**，和**MVT**的 m 是一样的，同样用来操作数据库

***V-view\***：**视图**，和**MVT**的 T 是一样的，用来进行数据的可视化

***C-Controller\***：**控制器**，相当于**MVT**中的 C，用来进行数据的逻辑操作

```
#  MVC 的交互流程
1. 前端 View视图里面页面--发送请求 给后台后端
2. 控制器来接收请求Controller----> 处理主业务逻辑（1.判断路由 2.解析参数 3.对接Model 4.返回数据）
3. Model-交互数据库-返回数据给 C 
4. C把数据 传给V 展示
```



## 会话控制技术

在web开发领域，网络中网页之间进行内容传输使用的协议是http/https协议。

http协议是一种无状态, 有所请求必有所回应的超文本传输协议，HTTP为了提升效率，一经完成请求和响应的过程以后，就会自动关闭连接。所谓无状态意指: 基于http协议提供服务的服务端,无法识别前后多次请求过程中,是不是同一个客户端发送的还是多个客户端发送的。

web开发的应用往往不仅仅只是一个网页或一个功能，那么怎么多个页面不同的请求，识别用户之前的状态和行为？

为了能在多次请求过程中,识别客户端是否是同一个客户端,所以就出现了会话跟踪技术，就需要使用会话控制技术, 也叫会话保持或者会话跟踪技术.

会话控制技术，主要作用是**为了识别和记录用户在web应用中的身份行为和操作历史**。

### 会话

会话的单词：session，所谓一次会话其实就是客户端和服务端之间进行通信的一次完整过程。

在web项目中：

​         客户端和服务端之间产生的会话开始于: **在用户第一次通过url访问网站的时候**

​         客户端和服务端之间的会话结束于**关闭浏览器**

注意: 如果在移动端下面，则必须是关闭当前app应用才算结束会话，如果只是后台运行，会话并没有结束的.

所以会话跟踪技术就是在一次完整的会话中,能让服务端识别客户端在整个过程中的身份行为和操作历史的一项技术.

实现会话控制的几种技术类型：

1. url地址栏记录用户身份的参数[少见，很古老的技术了，例如：QQ邮箱，QQ空间]
2. cookie: 在浏览器中由浏览器自动读写保存用户信息的一种小文件，能够存储的数据有限，30M左右，[过时了，谷歌在2021开始慢慢关闭这个cookie技术了]
3. session: 在服务端中保存用户信息的文件存储信息技术，能够存储的数据视存储设备而定，根据服务端配置而定。session默认是基于cookie的
4. token令牌: 就是一段可以记录和识别用户身份的字符串，通过客户端语言[js/安卓/ios]保存在客户端中一项技术，替代cookie或session.
     jwt就是token技术的其中一种。Oauth2.0也是属于token令牌技术的一种。

### cookie

cookie是保存在客户端浏览器中的小文本，由浏览器自动管理和收发, 所以cookie中不要保存用户的敏感信息，例如: 密码，身份证，手机号等等之类的。而且cookie在浏览器中用户是可以手动关闭或禁止cookie功能的.如果关闭了cookie功能,一般服务端能做的就只有2个事情了:1. 提示用户开启cookie功能, 2. 不要使用cookie进行会话控制了。

![image-20250725154826345](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507251548433.png)

#### 使用实例

```python
from django.http.response import HttpResponse
​
​
def set_cookie(request):
    """设置/保存/更新Cookie"""
    response = HttpResponse()
    # 生成cookie
    """
    参数列表：
        key,             # 键/变量
        value='',        # 值/内容
        max_age=None,    # 设置cookie的有效时间，单位: 秒
        expires=None,    # 设置cookie的过期时间戳[时间戳表示从1970-01-01 00:00:00至今的总秒数]
                         # datetime.now().timestamp() 获取时间戳
                         # int( time.time() * 1000 )  获取毫秒时间戳
                         # datetime.now().timestamp() 获取毫秒时间戳
​
        path=None,       # 当前cookie是否只能在指定公共路径下使用，None表示在同一个域名下，任意路径都可以使用
        domain=None,     # 当前cookie是否只能在指定同一段域名下使用，None表示在当前服务器所在域名下使用
        secure=False,    # 当前cookie是否只能在https协议下使用，False表示在http协议下也能使用    
        httponly=False,  # 当前cookie是否只能在http协议下使用,False表示在其他协议下也可以使用
    """
    response.set_cookie("uname", "xiaoming", max_age=5)
    response.set_cookie("uid", 100, max_age=180)
    # 设置cookie信息，可以不设置过期时间，默认cookie有效期的就是浏览器关闭时自动删除
    # 会话结束时浏览器会自动删除没有设置有效的cookie，而设置了有效期的cookie则只会在到期时才删除
    response.set_cookie("is_login", True, )
    return response

def get_cookie(request):
    """通过request.COOKIES可以获取客户端发送过来的cookie"""
    # 获取本次客户端发送过来的所有cookie
    print(request.COOKIES)  
    # 获取指定名称cookie
    print("uid=", request.COOKIES.get("uid"))  
    # 不存在的或过期的cookie不会被浏览器通过http请求头携带到服务端
    print("uname=", request.COOKIES.get("uname"))  
    # cookie的修改，与添加一致，cookie重复的变量名会覆盖
    response = HttpResponse("OK")
    response.set_cookie("uname", "xiaohong", max_age=15)
    return response

def del_cookie(request):
    """直接删除cookie在服务端是做不到的，因为cookie保存在客户端，所以我们需要通知客户端自己去删除"""
    # 告诉浏览器，cookie过期了
    response = HttpResponse("告诉客户端，删除cookie")
    # 设置有效期为0秒，当浏览器接受响应内容时，0秒早就到了，所以会自动删除
    response.set_cookie("uid", "", max_age=0)  
    return response
```

### session

这里的session就是会话控制技术的一种, **session主要把用户状态信息保存在服务器的文件中**。

在没有进行特殊设置的情况下，session以文件格式保存状态数据, 一般保存的目录是系统的缓存文件存储目录.

例如: windows的C:/windows/temp目录 ,Linux/Mac OS的/tmp目录

> 因为session是在服务端中保存数据,相对而言比cookie要安全.但是因为用户的数据都保存到服务器中,当用户基数大了,则服务器的存储压力就来了.所以一般不会考虑把session数据保存在文件，而是采用的第三方设置存储session的方案，例如保存到redis或者mysql之类的数据库里面。

![image-20250725164931095](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507251649183.png)

#### 数据存储

用户的数据可以放在文件里面, 也可以放在数据库里面, 可以在setting里面配置

```python

# 配置项
# session核心类
SESSION_ENGINE = "django.contrib.sessions.backends.file"
# 保存到文件: django.contrib.sessions.backends.file
# 保存到数据库: django.contrib.sessions.backends.db    # 需要配置数据库连接
# 保存到缓存中: django.contrib.sessions.backends.cache # 需要配置缓存连接
 
# session存储目录[如果不设置,则默认是系统的缓存目录]
# 3.0以前的django 通过以下代码配置
# SESSION_FILE_PATH = os.path.join(BASE_DIR, "session")
# 3.0以后通过以下配置
SESSION_FILE_PATH = BASE_DIR / "session_path"   # 路径拼接，如果当前目录不存在，必须手动创建，否则报错
```

#### 读写

```python
def set_session(request):
    """设置session"""
    # session保存在服务端，所以所有关于session的操作都是由request.session来完成的
    #
    request.session["uname"] = "root"
    request.session["uid"] = 1
    return HttpResponse("设置session数据")

def get_session(request):
    """获取session """
    print(f"uname={request.session.get('uname')}") # format string python3.6提供的
    print(f"uid={request.session.get('uid')}")
    
    # 获取session所有的键值对
    print(request.session.items())
    
    # 获取session数据的有效，默认值是：2周 ==>  60 * 60 * 24 * 7 * 2
    print(request.session.get_session_cookie_age() )
    return HttpResponse("获取session数据")


def del_session(request):
    """删除session数据"""
    # 删除单个指定名称的session
    if request.session.get("name"):
        request.session.pop("name")
 
    # 删除所有的session，慎用
    request.session.clear()
    return HttpResponse("删除session数据")
```

![image-20250725174956854](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507251749993.png)