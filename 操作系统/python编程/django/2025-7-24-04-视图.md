## 视图基础

django的视图主要有2种写法的视图，分别是**函数视图**（Function Base View，FBV）和**类视图**（Class Base View，CBV）。

现在刚开始学习django，我们先学习函数视图(FBV)，后面再学习类视图[CBV]。

### 函数视图

django中所有的视图都建议编写在子应用的views.py文件中。

```python
from django.http.response import HttpResponse
def 函数视图的名字(request):
    # 代码
    return HttpResponse("返回内容")
```

函数视图名称，同一个模块下不能重复，同时采用变量命名规则.

### 请求对象

视图中的request，实际上是django源码中的HTTPRequest的子类WSGIRequest类的实例对象，主要由django对客户端请求的http协议报文进行解析后得到的请求相关数据都在request对象中。

#### 限制请求方式

| HTTP请求方法 | 描述                |
| ------------ | ------------------- |
| POST         | 添加/上传           |
| GET          | 获取/下载           |
| PUT          | 修改/更新，修改整体 |
| PATCH        | 修改/更新，修改部分 |
| DELETE       | 删除/废弃           |

django支持让客户端只能通过指定的Http请求来访问到项目的视图

`home/views.py`,代码:

```python
# 让用户发送POST才能访问的页面
from django.views.decorators.http import require_http_methods
@require_http_methods(["POST"])  # 注意，中括号中的请求方法名务必大写！！！否则无法正常显示
def login(request):
    return HttpResponse("登录成功！")
```

> 默认在获取POST请求的时候有一个CSRF拦截机制, 可以在setting里面关了
>
> CSRF（Cross-Site Request Forgery，跨站请求伪造）是一种常见的 Web 安全攻击。攻击者诱导用户在已登录的情况下访问恶意网站，悄悄向目标网站发起请求，执行非用户本意的操作，比如转账、修改密码等。

![image-20250725105757443](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507251057490.png)

#### 视图接收http请求参数

在http请求和响应过程中, 用户往往会在请求过程中发送请求信息给服务端。那么客户端发送请求数据一般无非以下几种格式：

1. 查询字符串[Query String]
    所谓的查询字符串就是url地址上面?号后面的数据，例如:
    http://127.0.0.1:8000/home/index/?name=xiaoming&pwd=123
    上面name=xiaoming&pwd=123 就是查询字符串
    可以通过 request.GET 来获取。
    注意: `request.GET`不是http请求，也就是说，只要地址上有查询字符串，不管使用什么样的http请求方法，都可以在视图中使用request.GET来获取参数

![image-20250725113026048](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202507251130109.png)

> `<QueryDict: {'name': ['jiao'], 'pwd': ['123']}>`
>
> 如果客户端传过来的数据相同的名字有多个值使用`.getList`方法

2. 请求体数据[request.POST 接受表单  request.body 接受请求体], 只可以获取POST请求的

.POST获取的是一个QueryDict, body获取的是原始的数据

> 表单发送会对数据进行封装

3. 请求头报文信息[request.headers] 获取的是处理以后的, 可以使用META获取客户端以及服务器相关的环境信息, 包括请求头, 是原始数据

```json
// META
{
    'LANG': 'zh_CN.UTF-8',    # 服务端系统的默认语言
    'USER': 'moluo',          # 服务端运行的系统用户名
    'HOME': '/home/moluo',    # 服务端运行的系统用户家目录路径
    'DJANGO_SETTINGS_MODULE': 'djdemo.settings',  # 只有在django下才有的，当前django框架运行时加载的配置文件导包路径
    'SERVER_NAME': 'ubuntu',             # 服务端系统名称
    'SERVER_PORT': '8000',               # 服务端的运行端口
    'REMOTE_HOST': '',                   # 客户端的所在IP地址，有时候可能是域名
    'SCRIPT_NAME': '',                   # 客户端本次请求时，服务端执行的程序所在路径
    'SERVER_PROTOCOL': 'HTTP/1.1',       # 服务端运行的协议
    'SERVER_SOFTWARE': 'WSGIServer/0.2', # 服务端运行web服务器的软件打印信息
    'REQUEST_METHOD': 'POST',            # 客户端本次请求时的http请求方法
    'PATH_INFO': '/home/index3/',        # 客户端本次请求时的url路径
    'QUERY_STRING': '',                  # 客户端本次请求时的查询字符串
    'REMOTE_ADDR': '127.0.0.1',          # 客户端的所在IP地址
    'CONTENT_TYPE': 'application/json',  # 客户端本次请求时的数据MIME格式
    'HTTP_USER_AGENT': 'PostmanRuntime/7.26.10', # 客户端本次请求时，所使用的网络代理软件提示信息
    'HTTP_ACCEPT': '*/*',          # 客户端期望服务端返回的数据MIME格式格式
    'HTTP_HOST': '127.0.0.1:8000', # 客户端本次请求时，所使用服务端地址
    'HTTP_ACCEPT_ENCODING': 'gzip, deflate, br', # 客户端期望服务端返回的数据的压缩格式
    'HTTP_CONNECTION': 'keep-alive', # 客户端支持的服务端协议的链接类型,keep-alive 表示客户端支持http的长连接
}

// request.headers
{
    'Content-Length': '601',     // 客户端本次请求的内容大小
    'Content-Type': 'multipart/form-data;',   # 客户端本次请求的内容MIME类型
    'User-Agent': 'PostmanRuntime/7.26.10',   # 客户端本次请求的代理软件打印信息
    'Accept': '*/*',   
    'Host': '127.0.0.1:8000',    # 客户端本次请求的服务端地址
    'Accept-Encoding': 'gzip, deflate, br', 
    'Connection': 'keep-alive',
    # 以下就是自定义请求头了
    'Company': 'baidu', 
    'Num': '1000', 
}
```

> 常见的请求头：
>
> SERVER_NAME，  服务端系统名称
>
> SERVER_PORT，   服务端的运行端口
>
> REMOTE_ADDR，客户端的所在IP地址
>
> SERVER_SOFTWARE，服务端运行web服务器的软件打印信息
>
> PATH_INFO，客户端本次请求时的url路径
>
> 在使用META的时候可以使用get进行获取属性, HTTP里面的属性会自动加上`HTTP_`的前缀, 同时把名字大写, 使用`request.header`的是可以直接使用原始的名字进行get

4. 上传文件[request.FILES], 只可以获取使用POST的文件

django在解析http协议的时候，针对上传文件，会自动实例化一个内存保存文件的文件上传处理对象InMemoryUploadedFile
`from django.core.files.uploadedfile import InMemoryUploadedFile`

```python
print(request.FILES.get("file"))
print(request.FILES.get("file").name)
print(request.FILES.get("file").size)
print(request.FILES.get("file").content_type)

```

获取到的数据是`<MultiValueDict: {'file': [<InMemoryUploadedFile: logo.bmp (image/bmp)>]}>`

```python
# 处理多个一次性上传文件
for file in request.FILES.getlist("avatar"):
    with open(f"{os.path.dirname(__file__)}/{file.name}", "wb") as f:
        f.write(file.read())
```



5. 请求方法method, 请求路径

### 响应对象

django和大多数的web框架一样，针对http的响应，提供了2种不同的响应方式：

1. 响应内容，就是直接返回数据给客户端
    1. 响应html内容【一般用于web前后端不分离的项目】
    2. 响应json内容【一般用于开发web前后端分离的项目的api接口开发】
2. 响应页面跳转，就是通过返回页面跳转的信息给浏览器，让浏览器自己进行页面跳转

#### 返回http数据

```python
HttpResponse("<h1>hello world!</h1>", content_type="text/html")
```

#### 返回json数据

```python
def index6(request):
    """响应对象：响应json数据"""
    # 返回字典数据作为json给客户端
    """
    import json
    data = {"name":"xiaoming", "age":16, "sex": True}
    return HttpResponse(json.dumps(data), content_type="application/json;charset=utf-8")
    """
 
    # 原生返回json数据，太麻烦了
    # 因此django提供了一个HttpResponse的子类JsonResponse，转换提供给我们返回json数据的
    # from django.http.response import JsonResponse
    # data = {"name": "xiaoming", "age": 16, "sex": True}
    # return JsonResponse(data)
 
    # JsonResponse返回的数据如果不是字典，则必须要加上safe参数声明，并且值为False
    # 返回列表数据给客户端
    from django.http.response import JsonResponse
    data = [
        {"id":1, "name": "小明", "age": 16},
        {"id":3, "name": "小火", "age": 15},
    ]
 	# safe=False表示不是只有字典才可以传输, 可以使用status设置返回码, headers返回响应头 
    return JsonResponse(data, safe=False)
```

#### 返回图片/压缩包

```python
def index7(request):
    """返回图片格式"""
    import os
    with open(f"{os.path.dirname(__file__)}/avatar.jpg", "rb") as f:
        content = f.read()
        return HttpResponse(content, content_type="image/jpeg")
```

```c
def index8(request):
    """返回压缩包格式"""
    import os
    with open(f"{os.path.dirname(__file__)}/code.zip", "rb") as f:
        content = f.read()
        return HttpResponse(content, content_type="application/zip")
```

#### 自定义响应头

```python
def index9(request):
    """返回数据的过程中设置响应头"""
    response = HttpResponse("ok")
    # 自定义响应头[值和属性都不能是多字节]
    response["company"] = "baidu"
    return response
```

#### 跳转

在站内跳转时,如果使用django.urls.reverse函数进行路由反转解析（可以根据路由的别名反向生成路由的URL地址）,则必须在总路由文件和子路由文件中，对路由的前缀和子路由后缀进行别名绑定

+ 站外跳转

```python
## 1. 基于django提供的Response对象也可以进行页面跳转
from django.http.response import HttpResponse
response = HttpResponse(status=301)
response["Location"] = "https://www.tmall.com"
return response

# 2. 基于django提供的Response对象的原生写法[HttpResponseRedirect与HttpResponsePermanentRedirect都是HttpResponse的子类]
from django.http.response import HttpResponseRedirect    # 临时重定向
# from django.http.response import HttpResponsePermanentRedirect  # 永久重定向
return HttpResponseRedirect("https://www.qq.com")

# 2. 基于django提供快捷函数（简写函数, shortcuts）来完成[常用]
from django.shortcuts import redirect
return redirect("http://www.baidu.com")
```

+ 在进行站内跳转的时候可以直接使用路径, 也可以起别名

1. 直接跳转

```python
def index11(request):
    """跳转到站内"""
    from django.shortcuts import redirect  # 根据指定的url地址，进行页面跳转
 
    # 直接基于redirect跳转
    return redirect("/home/index12")
```

2.  起别名(使用比较少)

+ 命名空间

```python
from django.contrib import admin
from django.urls import path, include
from users import urls
urlpatterns = [
    path('admin/', admin.site.urls),
    path('users/', include('users.urls', namespace='usr')),
]
```

+ 子应用中的 urls.py 配置一个app_name的参数, 和namespace是一样的, 之后再给路由命名

```python
from django.urls import path
from . import views

app_name = 'usr'

urlpatterns = [
    path('index/', views.index, name='index'),
    path('login/', views.login, name='login'),
]
```

+ 解析

```python
from django.shortcuts import render
from django.shortcuts import redirect  # 根据指定的url地址，进行页面跳转
from django.urls import reverse  # 根据路由别名，反向解析生成url地址


# Create your views here.
from django.http.response import JsonResponse, HttpResponse
def index(request):
    # 开始解析
    url = reverse("usr:login")
    print(url)
    return redirect(url)

def login(request):
    return HttpResponse("login")
```

## 类视图

Class Base View,简称"CBV",与我们之前编写的视图函数不同, 类视图是类的结构编写视图代码的.可以让我们实现相关业务代码的整合. 同时还在函数视图的基础上, 可以实现 对于客户端访问的http请求进行分流和限制。

### 基本定义

实际是通过重写一个页面的各种访问操作实现的

```python

from django.shortcuts import render

# Create your views here.
# 1. 类视图必须直接或者间接继承于django.views.View
# 2. 在django的类视图中，所有提供给外界用户访问的视图方法名必须是 http请求动作的小写名称.
#    也就是说，方法名只能是 get, post, put, patch, delete ...
# 3. 使用类视图，可以有效的减少路由绑定的代码
#    3.1 可以直接通过视图方法名就可以达到限制客户端访问当前视图方法的http请求。
#    3.2 客户端访问对应的URL地址就会来到视图类中，访问这个地址所使用http请求，就是将来视图类自动执行的方法
#    3.3 有了类视图，我们可以把多个函数视图中原来的公共代码封装到一块进行调用，有利于代码复用。

# 4. 注意：同一个视图中，方法名不能出现重复！！！
 
from django.views import View
from django.http.response import HttpResponse, JsonResponse
class UserView(View):
    # 类视图中的公共方法/公共属性, 自己加的
    def ret(self, data):
        print(self.request.method) # 在类视图中，不仅可以通过视图方法中的参数，接收路由传递过来的请求对象，还可以通过self.request来或路由转发过来的请求对象
        return HttpResponse(data)

    def get(self,request):
        """只允许通过get请求访问,建议编写读取数据的页面,一般例如:首页,列表页,详情页"""
        # 视图中的视图方法里面的代码，与原来的函数视图中的代码，是一模一样的。原来怎么写，现在还是怎么写。
        return self.ret("hello, get")

    def post(self,request):
        """只允许通过post请求访问,一般用于上传,添加数据的页面"""
        return self.ret("hello, post")

    def put(self,request):
        """只允许通过put请求访问,一般用于修改,更新数据的页面"""
        return self.ret("hello, put")

    def patch(self,request):
        """只允许通过patch请求访问,一般用于修改,更新数据的页面"""
        return self.ret("hello, patch")

    def delete(self,request):
        """只允许通过delete请求访问,一般用于处理删除数据的页面"""
        return self.ret("hello, delete")
 
```

绑定

```python
from django.urls import path
from . import views
 
# 在django中，路由只识别函数视图，对于类视图，我们必须要通过as_view() 帮我们把类的视图方法转换成函数视图
urlpatterns = [
    # path("index", views.视图类名.as_view()),
    path("index", views.IndexView.as_view()),
]
```

> 本质是返回一个函数

```python
def view(request, *args, **kwargs):
    self = cls(**initkwargs) # 实例化一个当前的类(参数this传过来), 获取视图对象
    self.setup(request, *args, **kwargs)
    if not hasattr(self, "request"):
        raise AttributeError(
            "%s instance has no 'request' attribute. Did you override "
            "setup() and forget to call super()?" % cls.__name__
        )
        return self.dispatch(request, *args, **kwargs)
# 初始化一下类里面的参数
def setup(self, request, *args, **kwargs):
    """Initialize attributes shared by all view methods."""
    if hasattr(self, "get") and not hasattr(self, "head"):
        self.head = self.get
        self.request = request
        self.args = args
        self.kwargs = kwargs
        
        
def dispatch(self, request, *args, **kwargs):
    # Try to dispatch to the right method; if a method doesn't exist,
    # defer to the error handler. Also defer to the error handler if the
    # request method isn't on the approved list.
    if request.method.lower() in self.http_method_names:
        handler = getattr(
            self, request.method.lower(), self.http_method_not_allowed
        )
    else:
        handler = self.http_method_not_allowed 
    return handler(request, *args, **kwargs)
```

### 相关扩展

```
在django提供的视图类View使用中，还提供了一些视图子类和视图基类。
不过这块内容需要结合django的数据库操作才可以使用，所以我们后面再来学习。
视图子类是django为了方便开发者快速提供基于不同http请求视图而提供的。

from django.views.generic import ListView,DetailView,CreateView,UpdateView,DeleteView

ListView:   列表视图，可以通过get请求访问，用于展示列表数据，内置了分页功能    
DetailView：详情视图，可以通过get请求访问，用于展示单个数据
CreateView：添加视图，可以通过get/post请求访问，用于添加单个数据
UpdateView：更新视图，可以通过get/post请求访问，用于更新单个数据
DeleteView：删除视图，可以通过get请求访问，用于删除单个数据
```
