# ORM优化

## 虚拟外键

在前面所有的关联查询操作中，我们使用的外联手段都是依靠数据库本身维护的物理外键(使用数据库里面的一个数据进行记录关系)，但是这在一定程度上会增加数据库的运行成本，消耗数据库性能，因为数据量大了之后DB在高并发情况会产生大量锁。所以在外界就存在了相当一部分公司(50%左右)为了追求性能，舍弃了物理外键（就是在数据库建表操作中不再创建外键索引），改用ORM提供的虚拟外键（逻辑外键，这种外键关系是由ORM代码来维护的）来进行关联查询操作。当然，如果没有数据库本身维护的物理外键，肯定也会存在对数据库一致性的风险。

![image-20250801165746125](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202508011657219.png)

> 在数据删除的时候由于数据库里面没有记录, 所以实际会导致数据库不会主动维护

要在Django中使用虚拟外键，只需要在模型声明外键字段中设置属性`db_constraint=False`即可。

> 补充：
>
> db_constraint=True    表示当前外键使用物理外键
>
> db_constraint=False   表示当前外键使用虚拟外键

代码举例：

```python
# 一对一的逻辑外键
student = models.OneToOneField("Student", related_name="profile", on_delete=models.CASCADE, db_constraint=False, verbose_name="学生")

# 一对多的逻辑外键
student = models.ForeignKey("Student", on_delete=models.CASCADE, db_constraint=False, verbose_name="学生")

# 多对多的逻辑外键
teacher = models.ManyToManyField("Teacher", db_constraint=False, related_name="to_course")
```

当我们在模型声明时，使用虚拟外键，则将来生成的数据表中DDL（表定义语句）则不会出现外键的约束声明，只会出现普通索引的声明。



课堂代码：

```python
from django.db import models


"""1对1的虚拟外键设置"""
class Student(models.Model):
    name = models.CharField(max_length=20, verbose_name="学生")
    age = models.SmallIntegerField(verbose_name="年龄")
    sex = models.BooleanField(default=True, verbose_name="性别")

    class Meta:
        db_table = "tb_student"
        verbose_name = "学生信息表"
        verbose_name_plural = verbose_name


class StudentProfile(models.Model):
    student = models.OneToOneField("Student", on_delete=models.CASCADE, db_constraint=False, verbose_name="学生")
    mobile = models.CharField(max_length=15, verbose_name="紧急电话")
    address = models.CharField(max_length=200, verbose_name="联系地址")

    class Meta:
        db_table = "tb_student_profile"
        verbose_name = "学生详情表"
        verbose_name_plural = verbose_name


"""1对多的虚拟外键设置"""


class Author(models.Model):
    name = models.CharField(max_length=20, db_index=True, verbose_name="姓名")
    age = models.IntegerField(verbose_name="年龄")
    sex = models.BooleanField(null=True, blank=True, default=None, verbose_name="性别")

    class Meta:
        db_table = 'tb_author'
        verbose_name = "作者信息"
        verbose_name_plural = verbose_name


class Article(models.Model):
    title = models.CharField(max_length=50, verbose_name="文章标题")
    content = models.TextField(null=True, verbose_name="文章内容")
    pubdate = models.DateTimeField(null=True, verbose_name="发布时间")
    created_time = models.DateTimeField(auto_now_add=True, verbose_name="创建时间")
    updated_time = models.DateTimeField(auto_now=True, verbose_name="创建时间")
    author = models.ForeignKey("Author", on_delete=models.DO_NOTHING, db_constraint=False, verbose_name="作者")

    class Meta:
        db_table = "tb_article"
        verbose_name = "文章信息"
        verbose_name_plural = verbose_name


"""多对多的虚拟外键设置"""


class Teacher(models.Model):
    name = models.CharField(max_length=20, db_index=True, verbose_name="姓名")
    age = models.IntegerField(verbose_name="年龄")
    sex = models.BooleanField(null=True, blank=True, default=None, verbose_name="性别")
    # course = models.ManyToManyField("Course", related_name="teacher", db_constraint=False)

    class Meta:
        db_table = 'tb_teacher'
        verbose_name = "老师信息"
        verbose_name_plural = verbose_name


class Course(models.Model):
    name = models.CharField(max_length=20, db_index=True, verbose_name="课程名称")
    teacher = models.ManyToManyField("Teacher", related_name="course", db_constraint=False)

    class Meta:
        db_table = 'tb_course'
        verbose_name = "课程信息"
        verbose_name_plural = verbose_name
```

### 查询优化

django在关联查询中**为了减少SQL查询的数量**，提供了2个优化方法，prefetch_related()和select_related()。2个优化方法的功能作用类似，使用方式也一样，但是内部实现方式不同（也就是内部生成的SQL语句不同，使用场合不同）。

select_related() 是通过JOIN语句，在查询时减少SQL查询数量，一般适用于**一对一**的连表查询中，不适用在多对多。对于多对多关系使用SQL语句JOIN得到的SQL将会很长，会导致SQL语句运行时间和内存占用比例的增加。

prefetch_related()是通过 IN 语句分别查询关联的每个表的数据，然后在ORM中使用python处理他们之间的关联关系，通过这种方式来达到减少SQL连表查询数量。但是这样也有弊端，在QuerySet中的对象数量过多时，根据数据库特性的不同有可能造成性能额外损耗。

对于多对多字段（ManyToManyField）和一对多字段，可以使用`prefetch_related()`来进行优化。

对于一对一和多对一关系字段，可以使用`select_related()` 来进行优化。

2个优化函数是好的，但是使用不当会导致比原来还要糟心，那还不如别优化，所以最好慎用。

举例：实现用户的足迹功能，拿用户到过那些省份和城市以及他的家乡来举例，模型代码：

```python
class Province(models.Model):
    name = models.CharField(max_length=50, verbose_name="省份")
    class Meta:
        db_table = "tb_province"
        verbose_name = "省份信息"
        verbose_name_plural = verbose_name

    def __str__(self):
        return self.name


class City(models.Model):
    name = models.CharField(max_length=50, verbose_name="城市")
    province = models.ForeignKey("Province", on_delete=models.DO_NOTHING, verbose_name="省份")

    class Meta:
        db_table = "tb_city"
        verbose_name = "城市信息"
        verbose_name_plural = verbose_name

    def __str__(self):
        return self.name


class Person(models.Model):
    firstname = models.CharField(max_length=10, verbose_name="姓")
    lastname = models.CharField(max_length=10, verbose_name="名")
    hometown = models.ForeignKey("City", on_delete=models.DO_NOTHING, related_name="hometown_peoples", verbose_name="家乡")
    living = models.ForeignKey("City", on_delete=models.DO_NOTHING, related_name="living_peoples", verbose_name="现居地")
    visitation = models.ManyToManyField("City", related_name="visit_peoples", verbose_name="旅游地")

    class Meta:
        db_table = "tb_person"
        verbose_name = "用户信息"
        verbose_name_plural = verbose_name

    def __str__(self):
        return self.firstname + self.lastname


class PersonProfile(models.Model):
    mobile = models.CharField(max_length=20, verbose_name="联系电话")
    wechat = models.CharField(max_length=50, verbose_name="微信号")
    person = models.OneToOneField("Person", on_delete=models.CASCADE, related_name="profile")

    class Meta:
        db_table = "tb_person_profile"
        verbose_name = "用户详细信息"
        verbose_name_plural = verbose_name

    def __str__(self):
        return self.person.firstname + self.person.lastname

```

数据迁移

```
python manage.py makemigrations
python manage.py migrate
```

测试数据，代码：

```mysql
INSERT INTO school.tb_province (name) VALUES ("河南省");
INSERT INTO school.tb_province (name) VALUES ("广东省");

INSERT INTO school.tb_city (name, province_id) VALUES ('开封市', 1);
INSERT INTO school.tb_city (name, province_id) VALUES ('郑州市', 1);
INSERT INTO school.tb_city (name, province_id) VALUES ('广州市', 2);
INSERT INTO school.tb_city (name, province_id) VALUES ('深圳市', 2);

INSERT INTO school.orm_person (firstname, lastname, hometown_id, living_id) VALUES ('张', '三丰', 1, 1);
INSERT INTO school.orm_person (firstname, lastname, hometown_id, living_id) VALUES ('张', '雷锋', 1, 2);
INSERT INTO school.orm_person (firstname, lastname, hometown_id, living_id) VALUES ('张', '翠山', 2, 3);
INSERT INTO school.orm_person (firstname, lastname, hometown_id, living_id) VALUES ('张', '无忌', 3, 4);
INSERT INTO school.orm_person (firstname, lastname, hometown_id, living_id) VALUES ('张', '老六', 3, 2);


INSERT INTO school.orm_person_visitation (person_id, city_id) VALUES (1, 1);
INSERT INTO school.orm_person_visitation (person_id, city_id) VALUES (1, 2);
INSERT INTO school.orm_person_visitation (person_id, city_id) VALUES (1, 3);
INSERT INTO school.orm_person_visitation (person_id, city_id) VALUES (2, 2);
INSERT INTO school.orm_person_visitation (person_id, city_id) VALUES (2, 3);
INSERT INTO school.orm_person_visitation (person_id, city_id) VALUES (2, 4);
INSERT INTO school.orm_person_visitation (person_id, city_id) VALUES (3, 1);
INSERT INTO school.orm_person_visitation (person_id, city_id) VALUES (3, 2);
INSERT INTO school.orm_person_visitation (person_id, city_id) VALUES (3, 3);
INSERT INTO school.orm_person_visitation (person_id, city_id) VALUES (3, 4);
INSERT INTO school.orm_person_visitation (person_id, city_id) VALUES (4, 3);
INSERT INTO school.orm_person_visitation (person_id, city_id) VALUES (4, 4);
INSERT INTO school.orm_person_visitation (person_id, city_id) VALUES (5, 2);
INSERT INTO school.orm_person_visitation (person_id, city_id) VALUES (5, 3);
INSERT INTO school.orm_person_visitation (person_id, city_id) VALUES (5, 4);
```

#### select_related

```python
# 获取主表信息的同时，也把外键表数据也获取到
模型.objects.all().select_related() # 默认主表数据时，获取全部的外键字段
模型.objects.all().select_related('外键字段')
模型.objects.all().select_related('外键字段1').select_related('外键字段2')....select_related('外键字段n') #一次查询，连表操作性能低
模型.objects.all().select_related('外键字段__外键字段')　　　　#一次查询，连表操作性能低

举例：
        # 获取张三丰到过的城市, 分别在查找而非和查找城市的时候查两次
        person = Person.objects.filter(firstname="张", lastname="三丰").first()
        # # print(person)
        print(person.living)
        # """
        # SELECT `orm_person`.`id`, `orm_person`.`firstname`, `orm_person`.`lastname`, `orm_person`.`hometown_id`, `orm_person`.`living_id` FROM `orm_person` WHERE (`orm_person`.`firstname` = '张' AND `orm_person`.`lastname` = '三丰') ORDER BY `orm_person`.`id` ASC LIMIT 1
        # SELECT `orm_city`.`id`, `orm_city`.`name`, `orm_city`.`province_id` FROM `orm_city` WHERE `orm_city`.`id` = 1 LIMIT 21
        # """

        # # select_related 全外键关联优化, 只查找一次, 使用INNER JOIN连表, 默认查找所有的表
        person = Person.objects.filter(firstname="张", lastname="三丰").select_related().first()
        """
        SELECT `orm_person`.`id`, `orm_person`.`firstname`, `orm_person`.`lastname`, `orm_person`.`hometown_id`, `orm_person`.`living_id`, `orm_city`.`id`, `orm_city`.`name`, `orm_city`.`province_id`, `orm_province`.`id`, `orm_province`.`name`, T4.`id`, T4.`name`, T4.`province_id`, T5.`id`, T5.`name`
        FROM `orm_person`
        INNER JOIN `orm_city` ON (`orm_person`.`hometown_id` = `orm_city`.`id`)
        INNER JOIN `orm_province` ON (`orm_city`.`province_id` = `orm_province`.`id`)
        INNER JOIN `orm_city` T4 ON (`orm_person`.`living_id` = T4.`id`)
        INNER JOIN `orm_province` T5 ON (T4.`province_id` = T5.`id`)
        WHERE (`orm_person`.`firstname` = '张' AND `orm_person`.`lastname` = '三丰')
        ORDER BY `orm_person`.`id` ASC LIMIT 1
        """
        print(person.living)

        # # 限定外键的优化查找, 指定连接的表
        person = Person.objects.filter(firstname="张", lastname="三丰").select_related("living").first()
        print(person.living)
        print(person.living.province)
        """
        SELECT `orm_person`.`id`, `orm_person`.`firstname`, `orm_person`.`lastname`, `orm_person`.`hometown_id`, `orm_person`.`living_id`, `orm_city`.`id`, `orm_city`.`name`, `orm_city`.`province_id`
        FROM `orm_person`
        INNER JOIN `orm_city` ON (`orm_person`.`living_id` = `orm_city`.`id`)
        WHERE (`orm_person`.`firstname` = '张' AND `orm_person`.`lastname` = '三丰')
        ORDER BY `orm_person`.`id` ASC LIMIT 1
       
        SELECT `orm_province`.`id`, `orm_province`.`name` FROM `orm_province` WHERE `orm_province`.`id` = 1 LIMIT 21
        """

        # 限定外键的优化查找
        person = Person.objects.filter(firstname="张", lastname="三丰").select_related("hometown").select_related("living__province").first()
        print(person.living)
        print(person.living.province)
        print(person.living.hometown)
        """
        SELECT `orm_person`.`id`, `orm_person`.`firstname`, `orm_person`.`lastname`, `orm_person`.`hometown_id`, `orm_person`.`living_id`, `orm_city`.`id`, `orm_city`.`name`, `orm_city`.`province_id`, `orm_province`.`id`, `orm_province`.`name` 
        FROM `orm_person` 
        INNER JOIN `orm_city` ON (`orm_person`.`living_id` = `orm_city`.`id`) 
        INNER JOIN `orm_province` ON (`orm_city`.`province_id` = `orm_province`.`id`) 
        WHERE (`orm_person`.`firstname` = '张' AND `orm_person`.`lastname` = '三丰') 
        ORDER BY `orm_person`.`id` ASC LIMIT 1
        """
    
```

#### prefetch_related

```python
模型.objects.prefetch_related('外键字段')   　#不连表，一次性多次查询
模型.objects.all().select_related('外键字段__外键字段')

举例
        """[查询优化] prefetch_related"""
        # 查询所有人的足迹, 首先查询Person, 之后在查询visitation, 进行两次查询
        person_list = Person.objects.all()
        for person in person_list:
            print(person.visitation.all())
        """
        SELECT `orm_person`.`id`, `orm_person`.`firstname`, `orm_person`.`lastname`, `orm_person`.`hometown_id`, `orm_person`.`living_id` FROM `orm_person`
        SELECT `orm_city`.`id`, `orm_city`.`name`, `orm_city`.`province_id` FROM `orm_city` INNER JOIN `orm_person_visitation` ON (`orm_city`.`id` = `orm_person_visitation`.`city_id`) WHERE `orm_person_visitation`.`person_id` = 1 LIMIT 21
        SELECT `orm_city`.`id`, `orm_city`.`name`, `orm_city`.`province_id` FROM `orm_city` INNER JOIN `orm_person_visitation` ON (`orm_city`.`id` = `orm_person_visitation`.`city_id`) WHERE `orm_person_visitation`.`person_id` = 2 LIMIT 21
        SELECT `orm_city`.`id`, `orm_city`.`name`, `orm_city`.`province_id` FROM `orm_city` INNER JOIN `orm_person_visitation` ON (`orm_city`.`id` = `orm_person_visitation`.`city_id`) WHERE `orm_person_visitation`.`person_id` = 3 LIMIT 21
        SELECT `orm_city`.`id`, `orm_city`.`name`, `orm_city`.`province_id` FROM `orm_city` INNER JOIN `orm_person_visitation` ON (`orm_city`.`id` = `orm_person_visitation`.`city_id`) WHERE `orm_person_visitation`.`person_id` = 4 LIMIT 21
        SELECT `orm_city`.`id`, `orm_city`.`name`, `orm_city`.`province_id` FROM `orm_city` INNER JOIN `orm_person_visitation` ON (`orm_city`.`id` = `orm_person_visitation`.`city_id`) WHERE `orm_person_visitation`.`person_id` = 5 LIMIT 21
        """

        # 多对多中使用prefetch_related来减少SQL语句
        person_list = Person.objects.prefetch_related("visitation").all()
        for person in person_list:
            print(person.visitation.all())

        """
        SELECT `orm_person`.`id`, `orm_person`.`firstname`, `orm_person`.`lastname`, `orm_person`.`hometown_id`, `orm_person`.`living_id` FROM `orm_person` WHERE (`orm_person`.`firstname` = '张' AND `orm_person`.`lastname` = '三丰') ORDER BY `orm_person`.`id` ASC LIMIT 1

        SELECT (`orm_person_visitation`.`person_id`) AS `_prefetch_related_val_person_id`, `orm_city`.`id`, `orm_city`.`name`, `orm_city`.`province_id` FROM `orm_city` INNER JOIN `orm_person_visitation` ON (`orm_city`.`id` = `orm_person_visitation`.`city_id`) WHERE `orm_person_visitation`.`person_id` IN (1, 2, 3, 4, 5)
        """

        # prefetch_related也支持多级外键
        person_list = Person.objects.prefetch_related("visitation__province").all()
        for person in person_list:
            print(person.visitation.all())

        """
        SELECT `orm_person`.`id`, `orm_person`.`firstname`, `orm_person`.`lastname`, `orm_person`.`hometown_id`, `orm_person`.`living_id` FROM `orm_person`
        SELECT (`orm_person_visitation`.`person_id`) AS `_prefetch_related_val_person_id`, `orm_city`.`id`, `orm_city`.`name`, `orm_city`.`province_id` FROM `orm_city` INNER JOIN `orm_person_visitation` ON (`orm_city`.`id` = `orm_person_visitation`.`city_id`) WHERE `orm_person_visitation`.`person_id` IN (1, 2, 3, 4, 5)
        SELECT `orm_province`.`id`, `orm_province`.`name` FROM `orm_province` WHERE `orm_province`.`id` IN (1, 2)
        """
```

