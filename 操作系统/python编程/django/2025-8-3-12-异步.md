# WSGI和ASGI

WSGI和ASGI，都是基于Python设计的网关接口（Gateway Interface，GI）。

WSGI是python语言基于http协议模式开发的，不支持websocket协议，而ASGI的诞生解决了python中的WSGI不支持当前的web开发中的一些新的协议标准，同时ASGI支持原有模式和Websocket的扩展，即ASGI是WSGI的扩展。

## 基础定义

### 网关接口

网关接口（Gateway Interface，GI）就是一种为了实现加载动态脚本而运行在Web服务器和Web应用程序中的通信接口，也可以理解为一份协议/规范。只有Web服务器和Web应用程序都实现了网关接口规范以后，双方的通信才能顺利完成。常见的网关接口协议：CGI，FastCGI，WSGI，ASGI。

![image-20210608222947398](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202508031319966.png)

### CGI

公共网关接口（Common Gateway Interface，CGI）是最早的Web服务器主机提供信息服务的标准接口规范。只要实现了CGI协议，Web服务器就能够获取并了解客户端提交的信息，转交给服务器端的web应用程序进行处理，最后返回结果给客户端。

CGI程序是一种实现了CGI协议的程序。

快速通用网关接口（Fast Common Gateway Interface／FastCGI）是一种让web应用程序与Web服务器通信的协议。FastCGI是公共网关接口（CGI）的增强版本。

### Web服务器

Web服务器（Web Server）是一种运行于网站后台（物理服务器）的软件。Web服务器主要用于提供网页浏览或文件下载服务，它可以向浏览器等Web客户端提供html网页文档，也可以提供其他类型的可展示文档，让客户端用户浏览；还可以提供数据文件下载等。目前世界上最主流的Web服务器有 Nginx 、Apache、IIS、tomcat。

### Web应用程序

Web应用程序（Web Programming Application）是一种能完成web业务逻辑，能让用户基于web浏览器访问的应用程序，它可以是一个实现http请求和响应功能的函数或者类，也可以是Django、Flask、FastAPI等这样的web框架，当然也可以是其他语言的web程序或web框架。

> 问：Web服务器和Web应用程序的区别？
> 答：Web应用程序主要是完成web应用的业务逻辑的处理，Web服务器则主要是应对外部请求的接收、响应和转发。
>     需要使用web服务器启动运行，web应用程序才能被用户访问到。
>     而django框架中，我们之所以只有一个web应用程序就跑起来了，是因为我们在终端执行了一个命令，python manage.py runserver。
>     这个命令启动了django框架中内置提供的测试web服务器。

## WSGI

![image-20210608223815714](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202508031329264.png)

Web服务器网关接口（Web Server Gateway Interface，WSGI），是Python为了解决**Web服务器端与客户端之间的通信**基于CGI标准而设计的。实现了WSGI协议的web服务器有：uWSGI、[gunicorn](https://gunicorn.org/)、uvicorn、[Hypercorn](https://pgjones.gitlab.io/hypercorn/)。像django框架开发的项目一般在线上服务器运行就不会使用runserver来运行，而是采用上面实现了WSGI协议的web服务器来运行。

django中运行runserver命令时，其实内部就启动了wsgiref模块作为web服务器运行的。wsgiref是python内置的一个简单地遵循了wsgi接口规范的web服务器程序。

### WSGI web服务器

```python
from wsgiref.simple_server import make_server
# application 由wsgi服务器调用、函数对http请求与响应的封装、使得Python专注于HTML
# environ http 请求 (是一个字典)
# start_response 响应 (是一个函数)

def application(environ, start_response):
    """web应用程序"""
    # 判断请求
    if environ['REQUEST_METHOD'] == 'GET' and environ['PATH_INFO'] == '/':
        # 响应
        start_response('200 OK', [('Content-Type', 'text/html')])
        return [b'<h1>hi, python!</h1>']
    # 判断请求
    elif environ['REQUEST_METHOD'] == 'GET' and environ['PATH_INFO'] == '/python':
        # 响应
        start_response('200 OK', [('Content-Type', 'text/html')])
        return [b"<h1>it work!</h1>"]

if __name__ == '__main__':
    # 启动服务器 | 这个服务器负责与 wsgi 接口的 application 函数对接数据
    httpd = make_server('127.0.0.1', 8888, application)

    # 监听请求
    httpd.serve_forever()

    # 1. 监听8000端口,
    # 2. 把http请求根据WSGI协议将其转换到applcation中的environ参数, 然后调用application函数.
    # 3. wsgiref会把application函数提供的响应头设置转换为http协议的响应头,
    # 4. 把application的返回(return)作为响应体, 根据http协议,生成响应, 返回给浏览器.

    # http://127.0.0.1:8888/
    # http://127.0.0.1:8888/python
```

开发中，我们一般使用uWSGI或者Gunicorn作为web服务器运行django。

### uWSGI

[uWSGI](https://uwsgi-docs.readthedocs.io/) 是一个快速的，自我驱动的，对开发者和系统管理员友好的应用容器服务器，完全由 C 编写，实现了WSGI协议,uwsgi,http等协议。注意：uwsgi 协议是一个 uWSGI服务器自有的协议,用于定义传输信息的类型，常用于uWSGI服务器与其他网络服务器的数据通信中。

文档：https://docs.djangoproject.com/zh-hans/3.2/howto/deployment/wsgi/uwsgi/

配置：https://uwsgi.readthedocs.io/en/latest/Configuration.html	

```
conda config --add channels conda-forge
conda install uWSGI
```

项目根目录下创建uwsgi配置文件，uwsgi.ini(不是python文件)，代码样本：

```
[uwsgi]
#使用nginx连接时使用，Django程序所在服务器地址
socket=0.0.0.0:8000
#直接做web服务器使用，Django程序所在服务器地址
# http=0.0.0.0:8000
#项目目录
chdir=项目根目录绝对路径
#项目中wsgi.py文件的目录，相对于项目目录
wsgi-file=主应用目录/wsgi.py
# 进程数 CPU * 2 -1
processes=4
# 线程数
threads=2
# uwsgi服务器的角色
master=True
# 存放进程编号的文件
pidfile=uwsgi.pid
# 日志文件，因为uwsgi可以脱离终端在后台运行，日志看不见。我们以前的runserver是依赖终端的
daemonize=uwsgi.log
# 指定依赖的虚拟环境
virtualenv=虚拟环境的绝对路径
```

uwsgi.ini，代码：

```
[uwsgi]
# 使用nginx连接时使用，Django程序所在服务器地址
# socket=0.0.0.0:8000
# 直接做web服务器使用，Django程序所在服务器地址
http=0.0.0.0:8000
# 项目目录
# chdir=项目根目录，务必使用绝对路径
chdir=/home/moluo/Desktop/djdemo
# 项目中wsgi.py文件的目录，相对于项目根目录
wsgi-file=djdemo/wsgi.py
# 进程数 CPU * 2 - 1 , 也可以不减1
processes= 4
# 线程数 CPU数量
threads=2
# uwsgi服务器的角色
master=True
# 存放进程编号的文件
pidfile=uwsgi.pid
# 日志文件，因为uwsgi可以脱离终端在后台运行，日志看不见。我们以前的runserver是依赖终端的
daemonize=uwsgi.log
# 指定依赖的虚拟环境
# virtualenv=/root/.virtualenvs/环境名称
virtualenv=/home/moluo/anaconda3/envs/djdemo
```

项目根目录下，启动uwsgi服务器

```bash
# 启动项目
uwsgi --ini uwsgi.ini

# 停止运行
uwsgi --stop uwsgi.pid  # 调用系统的 kill -9 uwsgi.pid中的进程号

# 查看当前系统中的指定名称的进程
ps aux | grep uwsgi

# 输出效果如下，则表示成功运行，接下来就可以根据配置中设置的地址访问项目了。
# (base) moluo@ubuntu:~$ ps aux | grep uwsgi
# moluo      12759  2.3  0.9  96944 37736 ?        S    11:52   0:00 uwsgi --ini uwsgi.ini
# moluo      13167  0.0  0.7 170676 29468 ?        Sl   11:52   0:00 uwsgi --ini uwsgi.ini
# moluo      13169  0.0  0.7 170676 29468 ?        Sl   11:52   0:00 uwsgi --ini uwsgi.ini
# moluo      13171  0.0  0.7 170676 29468 ?        Sl   11:52   0:00 uwsgi --ini uwsgi.ini
# moluo      13173  0.0  0.7 170676 29468 ?        Sl   11:52   0:00 uwsgi --ini uwsgi.ini
# moluo      13176  0.0  0.8 105140 35416 ?        S    11:52   0:00 uwsgi --ini uwsgi.ini
# moluo      18073  0.0  0.0  17688   740 pts/2    R+   11:52   0:00 grep --color=auto uwsgi
```

 ![image-20210609121333733](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202508031514654.png)

## ASGI

ASGI，是构建于WSGI接口规范之上的**异步服务器网关接口**，是WSGI的延伸和扩展。

```
A指的是Async，异步的意思。 
```

| 协议，规范 | 支持的请求协议（常见，未列全） | 同步/异步 | 支持的框架                                |
| ---------- | ------------------------------ | --------- | ----------------------------------------- |
| CGI        | HTTP                           |           | CGI程序                                   |
| WSGI       | HTTP                           | 同步      | django3.0以前，Flask1.0                   |
| ASGI       | HTTP，HTTP2，WebSocket等       | 同步/异步 | FastAPI，Tornado，django3.1以后，flask2.0 |

在 Python3.5 之后增加 async/await 特性之后简化了协程操作以后，异步编程变得异常火爆，越来越多开发者投入异步的怀抱。

3.0版本以前，django所提供的所有内部功能都是基于同步编程的。所以，在以往django开发中，针对网络请求，数据库读取等IO操作形成的阻塞，往往会导致项目运行性能的下降。虽然等待I/O操作数微秒时，但是随着流量的增加和操作的频率上升，这一点点的阻塞就会导致整个项目运作的缓慢。而如果换成异步就不会有任何阻塞，还可以同时处理其他任务，从而以较低的延迟处理更多的请求。所以在目前python开发中，越来越多的框架开始支持了异步编程。所以，3.0版本以后，django开始支持异步编程，可以让开发者在django中使用python第三方异步模块，推出了asgi异步web服务器。3.1版本推出了异步视图，当然，目前django的异步编程还不够完善，django中只有极少的功能是支持了异步操作。

### Uvicorn

> Django支持的另一个web服务器

![image-20210608235013829](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/lenovo-picture/202508031518244.png)

Uvicorn 是一个快速的 ASGI 服务器，Uvicorn 是基于 uvloop 和 httptools 构建的，是 Python 异步生态中重要的一员。

Uvicorn 当前支持 HTTP / 1.1 和 WebSockets，将来计划支持HTTP/2.0。

文档：https://www.uvicorn.org/

安装uvicorn

```python
pip install uvicorn
```

项目根目录下，运行django项目, 实际是运行asgi.py 的application函数

```bash
# uvicorn 主应用目录名.asgi:application --reload
uvicorn djdemo.asgi:application --reload
```

开发中一般使用gunicorn来管理uvicorn。所以可以一并安装(不支持Windows)

> **Gunicorn**（Green Unicorn）是一个成熟的WSGI（Web Server Gateway Interface）服务器，广泛用于同步的Python Web应用的部署（例如Django、Flask）。其特点是：
>
> - **以同步模式运行**
> - **多进程模型**
> - **丰富的插件和扩展支持**
>
> 随着异步Web框架变得流行，单纯的Gunicorn不支持异步功能，于是出现了一种常用的模式：**将Gunicorn作为管理器，使用Uvicorn作为工作类（worker）**。
>
> ### 关系总结
>
> - **Uvicorn** 是一个纯粹的ASGI服务器，专为异步应用设计，性能极佳。
> - **Gunicorn** 提供强大的多进程管理和部署能力，不直接支持ASGI标准，但可以通过插件（类似 `uvicorn.workers.UvicornWorker`）实现对ASGI应用的支持。
> - **结合使用**：通常在生产环境中，将Gunicorn作为管理进程，使用`UvicornWorker`作为worker类，来部署异步应用。这样既能利用Gunicorn的管理与扩展能力，又能享受Uvicorn的高性能异步处理。

```
pip install gunicorn
```

运行

```
# gunicorn -w 4 主应用目录名.asgi:application -k uvicorn.workers.UvicornWorker --reload
gunicorn -w 4 djdemo.asgi:application -k uvicorn.workers.UvicornWorker --reload
```

### Daphne

[如何使用 Daphne 托管 Django | Django documentation | Django](https://docs.djangoproject.com/zh-hans/4.2/howto/deployment/asgi/daphne/)

- 由Django团队开发，最初为支持Channels设计
- 未来发展紧密结合Django生态

```bash
python -m pip install daphne
daphne myproject.asgi:application
```

#### 与 `runserver` 集成

Daphne 提供了一个 [`runserver`](https://docs.djangoproject.com/zh-hans/4.2/ref/django-admin/#django-admin-runserver) 命令，用于在开发过程中使用 ASGI 来提供站点服务。

这可以通过将 `daphne` 添加到你的 [`INSTALLED_APPS`](https://docs.djangoproject.com/zh-hans/4.2/ref/settings/#std-setting-INSTALLED_APPS) 的开头，并添加一个指向你的 ASGI 应用程序对象的 `ASGI_APPLICATION` 设置来启用：

```
INSTALLED_APPS = [
    "daphne",
    ...,
]

ASGI_APPLICATION = "myproject.asgi.application"
```

## 异步视图

文档：https://docs.djangoproject.com/zh-hans/4.2/topics/async/

### 函数视图

在Django3.1后的版本中，我们可以通过`async def`语法，将任何函数视图定义为异步视图。

```python
"""同步视图"""
import time
def home1(request):
    time.sleep(5)
    return HttpResponse('Hello, sync view!')

"""异步视图"""
import asyncio
async def home2(request):
    # asyncio.sleep(5)
    await asyncio.sleep(5)  # 开发中，一般就是ORM操作，http请求，或者读取文件等IO操作，就需要在左边上加上 await
    return HttpResponse('Hello, async view!') 
```

### 类视图

类视图，django内部是将它的`__call__()`方法定义为`async def`，成为异步视图。

```python
class Home3View(View):
    async def __call__(self, *args, **kwargs): # 当把一个类当函数去调用，就会触发__call__方法
        return super().__call__(*args, **kwargs)

    async def get(self, request):
        await asyncio.sleep(5)
        return HttpResponse("ok, get") 
```

## 模型异步操作

django4.2版本的ORM对数据库的访问这块还没有全面实现异步处理，默认还是同步的。当我们需要在项目中调用模型进行异步操作时，django有提供了2个适配函数，可从`asgiref.sync`包中获取：`async_to_sync()`和 `sync_to_async()` 。它们用于同步和异步之间调用风格的转换，同时保持兼容性。适配函数既可以当包装函数使用，也可以作为装饰器使用。

async_to_sync()：异步转同步，参数就是同步函数

sync_to_async()：同步转异步，参数就是异步函数

```python
from asgiref.sync import async_to_sync
# 用法1
sync_function = async_to_sync(async_function)

# 用法2
@async_to_sync
async def async_function(...):
    pass
```

代码：

```python
from django.views import View
from django.http.response import JsonResponse
from component import models
from asgiref.sync import sync_to_async


# Create your views here.
class User1View(View):
    async def __call__(self, *args, **kwargs):
        return super().__call__(*args, **kwargs)

    async def get(self, request):
        """因为是异步视图，无法直接使用同步代码，所以报错：SynchronousOnlyOperation"""
        # student = models.Student.objects.get(id=12)
        # print(student)

        """在异步视图中，必须异步操作模型"""
        # sync_to_async(models.Student.objects.get, thread_sensitive=True)
        # 上面就是把 models.Student.objects.get 进行异步转换，在线程安全模式运行

        """异步获取一条数据"""
        aget = sync_to_async(models.Student.objects.get, thread_sensitive=True)
        student = await aget(id=12)  # # aget就是get的异步方法，调用方法与原来的get一样
        return JsonResponse({"msg": "ok, get", "data": {
            "id": student.id,
            "name": student.name,
        }})

        """异步获取多条数据"""
        # QuerySet 惰性查询，all执行的时候，根本没发生数据操作，自然也就没有IO
        student_objs = models.Student.objects.all()
        student_list = []
        async for student in student_objs:
            student_list.append({
                "id": student.id,
                "name": student.name,
            })
        return JsonResponse({"msg": "ok, get", "data": student_list})

        """异步添加数据"""
        acreate = sync_to_async(models.Student.objects.create, thread_sensitive=False)
        student = await acreate(
            name="小柏",
            age=13,
            sex=True,
            mobile="13956567878",
            status=1,
            classmate="307",
            description="话不多数，上就完事了！")
        return JsonResponse({"msg": "ok, get", "data": {
            "id": student.id,
            "name": student.name,
        }}, status=201) 
```

redis异步库：aioredis

mysql异步库：aiomysql

mongoDB异步库：motor

http网络请求异步库：httpx

## 异步HTTP请求

views.py，代码：

```python
import httpx
from django.views import View
from django.http.response import JsonResponse
from component import models
from asgiref.sync import sync_to_async


# Create your views here.
class User1View(View):
    async def __call__(self, *args, **kwargs):
        return super().__call__(*args, **kwargs)

    async def get(self, request):
        """异步网络请求"""
        # 同步代码在遇到IO操作时就会出现阻塞，所以异步代码在IO时需要交出程序执行权
        async with httpx.AsyncClient() as client:
            response = await client.get("https://httpbin.org/get")
        return JsonResponse(response.json())

```

## 异步中间件

3.1版本以后，django还提供了中间件的异步支持。

[中间件 | Django documentation | Django](https://docs.djangoproject.com/zh-hans/4.2/topics/http/middleware/)

中间件支持同步和异步请求的任意组合。如果Django不能同时支持它们，它会调整请求来适应中间件的需求，但会有性能损失。

默认情况下，Django假设你的中间件只能处理同步请求。如果要改变这种模式，需要在你的中间件工厂函数或类中添加入如下属性：

- `sync_capable` 是一个布尔值，来表明中间件是否处理同步请求。默认为 `True`。
- `async_capable` 是一个布尔值，来表明中间件是否处理异步请求。默认为 `False`。

如果你的中间件同时设置了 `sync_capable = True` 和 `async_capable = True`，那么Django将直接传递请求而不进行转换。在这种情况下，你可以通过检查传递给你的 `get_response` 对象是否是协程函数，使用 `asgiref.sync.iscoroutinefunction` 来确定你的中间件是否会接收到异步请求。

```python
"""
wsgiref 是python内置模块，提供给开发者在开发时，用于创建同步web服务器
asgiref 是python内置模块，提供给开发者在开发时，用于创建异步web服务器
"""
"""异步中间件"""


"""异步函数中间件"""
from asgiref.sync import iscoroutinefunction
# iscoroutinefunction 是python内置 判断当前参数是否是协程函数，如果是协程函数，则返回值为True，否则False
def simple_middleware(get_response):
    if iscoroutinefunction(get_response):
        async def middleware(request):
            response = await get_response(request)
            return response
    else:
        def middleware(request):
            response = get_response(request)
            return response
    return middleware


"""异步类中间件"""
from asgiref.sync import iscoroutinefunction, markcoroutinefunction
# markcoroutinefunction 把当前参数标记为协程函数


class SimpleMiddleware2:
    """异步中间件"""
    async_capable = True
    sync_capable = False

    def __init__(self, get_response):
        self.get_response = get_response
        if iscoroutinefunction(self.get_response):
            markcoroutinefunction(self)

    async def __call__(self, request):
        response = await self.get_response(request)
        return response

    async def process_request(self, request):
        print("视图执行之前!!")

    async def process_response(self, request, response):
        print("视图执行以后！！")
        return response
```

 