# CpptigsC接口

C++ 和 C 的编译规则、函数名修饰（Name Mangling）、类型系统存在本质差异：

-   C++ 会对函数名进行**名字修饰**（如`void func(int)`可能被编译为`_Z4funci`），导致 C 编译器无法识别；
-   C++ 支持重载、类、异常等特性，而 C 不支持，直接暴露 C++ 接口给 C 调用会导致编译 / 链接错误。

因此，C++ 库要给 C 调用，核心是**屏蔽 C++ 特性、让接口符合 C 的编译 / 链接规则**，并通过特定方式封装 C++ 的类 / 对象。

## 用`extern "C"`屏蔽 C++ 名字修饰

+   头文件

```cpp
// 头文件（供C/C++调用）
#ifdef __cplusplus
extern "C" {
#endif

// C风格接口声明（无类、无重载、无异常）
void* create_obj(int param);
void obj_do_something(void* obj);
void destroy_obj(void* obj);

#ifdef __cplusplus
}
#endif
```

## 封装 C++ 类

C 不支持 C++ 类，因此需要将 C++ 对象的指针**隐式转换为`void\*`**（通用指针）暴露给 C，C 侧仅持有指针，不感知对象内部结构。

```c
// cpp_lib.h（仅C++可见，C不包含）
class MyClass {
private:
    int value;
public:
    MyClass(int param) : value(param) {}
    void doSomething() {
        printf("MyClass::doSomething, value=%d\n", value);
    }
    ~MyClass() {
        printf("MyClass destroyed\n");
    }
};
```

```c
// c_api.h（C/C++兼容）
#ifndef C_API_H
#define C_API_H

#ifdef __cplusplus
extern "C" {
#endif

// 创建对象：返回void*（C侧仅持有指针）
void* my_class_create(int param);

// 调用对象方法：接收void*，内部转换为MyClass*
void my_class_do_something(void* obj);

// 销毁对象：释放内存，避免泄漏
void my_class_destroy(void* obj);

#ifdef __cplusplus
}
#endif

#endif // C_API_H
```

```cpp
// c_api.cpp
#include "c_api.h"
#include "cpp_lib.h"
#include <cstdio>

// 创建对象：C++侧new对象，返回void*
void* my_class_create(int param) {
    // 异常安全：C不支持异常，需捕获并返回NULL
    try {
        return new MyClass(param);
    } catch (...) {
        return nullptr;
    }
}

// 调用方法：将void*转回MyClass*
void my_class_do_something(void* obj) {
    if (obj == nullptr) return; // 空指针检查
    MyClass* cls = static_cast<MyClass*>(obj);
    cls->doSomething();
}

// 销毁对象：delete C++对象
void my_class_destroy(void* obj) {
    if (obj == nullptr) return;
    MyClass* cls = static_cast<MyClass*>(obj);
    delete cls;
}
```

-   **禁止 C 侧直接操作指针**：C 侧只能通过接口传递`void*`，不能强制转换为 C++ 类指针（破坏封装）；
-   **异常处理**：C 不支持异常，C++ 接口实现中必须捕获所有异常，转为错误码 / NULL 返回；
-   **数据类型兼容**：接口中仅使用 C 兼容类型（`int`/`char`/`void*`等），避免 C++ 特有类型（`std::string`/`std::vector`）；
-   **链接规则**：确保`extern "C"`包裹所有 C 接口声明，否则 C 编译器无法解析 C++ 修饰的函数名。

## 不透明指针

**不透明指针**是一种设计模式，它通过指针来隐藏数据结构的实现细节，只暴露操作该数据结构的接口。在C语言中，它通常表现为一个未完全定义的结构体指针, 相比`void*`，不透明指针是强类型（如`MyObj*`），避免错误的指针类型转换

#### 1. static_cast：编译期语义转换

`static_cast` 是最常用的转换方式，用于**编译器可验证的、语义上合理的类型转换**，本质是 “模拟编译器的隐式转换，或反向执行隐式转换”。

##### 适用场景

-   **基础数据类型转换**（隐式转换的显式化，或反向）：

    ```cpp
    // 隐式转换的显式化（int→double）
    int a = 10;
    double b = static_cast<double>(a); // 等价于隐式转换，但更清晰
    
    // 反向转换（double→int，会丢失精度，编译器允许但需显式）
    double c = 3.14;
    int d = static_cast<int>(c); // d=3，精度丢失（编译期无警告，需程序员负责）
    ```

-   **父子类向上转型**（安全，等价于隐式转换）：

    ```cpp
    class Base {};
    class Derived : public Base {};
    
    Derived d;
    // 向上转型（子类→父类），static_cast 等价于隐式转换
    Base* b_ptr = static_cast<Base*>(&d);
    ```

-   **父子类向下转型**（不安全，无运行时检查）：注意：仅当父类指针确实指向子类对象时，转换才合法；否则会导致未定义行为（UB）。

    ```cpp
    Base* base_ptr = new Derived(); // 父类指针指向子类对象（合法）
    Derived* der_ptr = static_cast<Derived*>(base_ptr); // 转换成功
    
    Base* pure_base = new Base();
    Derived* bad_der = static_cast<Derived*>(pure_base); // 编译通过，但解引用会UB
    ```

-   **void\* 与具体类型指针的转换**：

    ```cpp
    // void* → int*（static_cast 语义更贴合“类型转换”，而非底层重解释）
    void* void_ptr = new int(100);
    int* int_ptr = static_cast<int*>(void_ptr); // 合法
    
    // int* → void*（隐式转换也可，static_cast 显式化）
    void* v_ptr = static_cast<void*>(int_ptr);
    ```

-   **类的构造 / 转换函数调用**：

    ```cpp
    class MyInt {
    public:
        explicit MyInt(int x) : val(x) {} // explicit 禁止隐式转换
        operator int() const { return val; } // 转换函数：MyInt→int
    private:
        int val;
    };
    
    MyInt mi(10);
    int x = static_cast<int>(mi); // 调用转换函数，合法
    MyInt mi2 = static_cast<MyInt>(20); // 调用explicit构造函数，合法（隐式则报错）
    ```

##### 关键特点

-   编译期检查，无运行时开销；
-   不支持 “无关类型” 转换（如 `int*`→`double*`），需用 `reinterpret_cast`；
-   不能修改 `const/volatile` 限定符（需用 `const_cast`）。

#### 2. const_cast：修改常量性限定符

`const_cast` 是**唯一能添加 / 移除 `const`/`volatile` 限定符**的转换运算符，仅作用于指针、引用、成员指针，不改变类型本身。

##### 适用场景

-   **临时移除 const 调用非 const 接口**（仅当原对象实际非 const 时合法）：

    ```cpp
    void func(int* ptr) { *ptr = 20; }
    
    int main() {
        // 场景1：原对象非 const，仅指针是 const → 转换合法
        int val = 10;
        const int* const_ptr = &val;
        int* non_const_ptr = const_cast<int*>(const_ptr);
        func(non_const_ptr); // 合法，val 被修改为 20
    
        // 场景2：原对象是 const → 转换后修改会导致UB
        const int const_val = 100;
        const int* cp = &const_val;
        int* np = const_cast<int*>(cp);
        *np = 200; // UB！const_val 是只读内存，修改会崩溃/数据错乱
        return 0;
    }
    ```

-   **添加 const 限定符**（较少用，隐式转换也可）：

    ```cpp
    int x = 10;
    int* p = &x;
    const int* cp = const_cast<const int*>(p); // 等价于隐式转换
    ```

##### 关键特点

-   编译期检查，仅修改限定符，不改变指针 / 引用指向的类型；
-   若修改 `const` 限定符后操作原对象（且原对象是 `const`），会触发 UB；
-   不能用于普通数值类型（如 `const_cast<int>(10)` 非法）。

#### 3. dynamic_cast：运行时安全的继承体系转换

`dynamic_cast` 专为**多态类（含虚函数）的继承体系转换**设计，核心是**运行时检查类型合法性**，是最安全的继承体系转换方式。

##### 适用前提

-   转换的目标类型必须是 “多态类”（类中有至少一个虚函数，包括虚析构函数）；
-   仅支持指针或引用的转换（不支持普通类型）。

##### 适用场景

-   **父子类向下转型**（安全，运行时验证）：

    ```cpp
    class Base { virtual void func() {} }; // 多态类（有虚函数）
    class Derived : public Base { void func() override {} };
    
    Base* base_ptr = new Derived(); // 父类指针指向子类
    // 向下转型：运行时检查，返回非空指针
    Derived* der_ptr = dynamic_cast<Derived*>(base_ptr); 
    if (der_ptr) { // 转换成功，非空
        der_ptr->func();
    }
    
    Base* pure_base = new Base(); // 父类指针指向父类对象
    Derived* bad_der = dynamic_cast<Derived*>(pure_base); // 转换失败，返回null
    ```

-   **交叉转型**（同一基类的不同子类之间转换）：

    ```cpp
    class Base { virtual void func() {} };
    class A : public Base {};
    class B : public Base {};
    
    A* a_ptr = new A();
    // 交叉转型：A* → B*，运行时检查（a_ptr 指向A，转换失败）
    B* b_ptr = dynamic_cast<B*>(a_ptr); // b_ptr = nullptr
    ```

-   **引用的向下转型**（失败时抛异常）：指针转换失败返回 `nullptr`，但引用不能为空，因此失败时抛出 `std::bad_cast` 异常。

    ```cpp
    #include <typeinfo> // 包含 bad_cast 定义
    
    Base& base_ref = *new Base();
    try {
        Derived& der_ref = dynamic_cast<Derived&>(base_ref); // 转换失败
    } catch (const std::bad_cast& e) {
        std::cout << "转换失败：" << e.what() << std::endl;
    }
    ```

##### 关键特点

-   运行时检查，有一定性能开销（需查询类型信息 RTTI）；
-   仅支持多态类，非多态类使用会编译报错；
-   转换失败时：指针返回 `nullptr`，引用抛 `std::bad_cast`；
-   不能用于 `void*` 转换，也不能修改 `const` 限定符。

#### 4. reinterpret_cast：底层二进制重解释

`reinterpret_cast` 是最 “暴力” 的转换方式，核心是**忽略类型语义，仅对内存二进制位进行重新解释**，无任何类型检查，完全依赖程序员保证安全性。

##### 适用场景

-   **指针 ↔ 整数类型**（存储 / 打印指针地址）：

    ```cpp
    #include <cstdint> // uintptr_t：可存储指针的整数类型
    int x = 10;
    int* p = &x;
    
    // 指针→整数：存储指针的二进制值
    uintptr_t addr = reinterpret_cast<uintptr_t>(p);
    // 整数→指针：重新解释整数为指针
    int* p2 = reinterpret_cast<int*>(addr);
    ```

-   **无关类型指针 / 引用转换**（底层内存操作）：

    ```cpp
    // int* → double*：仅重解释内存，无类型检查
    int val = 0x4048f5c3; // 对应 double 的 3.14（小端序）
    int* ip = &val;
    double* dp = reinterpret_cast<double*>(ip);
    std::cout << *dp << std::endl; // 输出 3.14（内存布局匹配时合法）
    ```

-   **函数指针转换**（适配跨语言回调）：

    ```cpp
    // C 回调签名
    typedef void (*C_Callback)(int);
    // C++ 函数签名不匹配
    void MyFunc(double d) { std::cout << d << std::endl; }
    
    // 函数指针转换：double(*)() → int(*)()
    C_Callback cb = reinterpret_cast<C_Callback>(MyFunc);
    cb(10); // 输出 10.0（需确保参数传递兼容，否则UB）
    ```

-   **结合跨语言接口（如 C++ 暴露 C 接口）**：

    ```cpp
    // void* → MyClass*：重解释内存，语义更贴合“底层转换”
    void* void_obj = new MyClass();
    MyClass* cls = reinterpret_cast<MyClass*>(void_obj);
    ```

##### 关键特点

-   编译期转换，无运行时开销；
-   无类型检查，转换结果完全依赖平台（指针大小、字节序、内存对齐），移植性差；
-   解引用转换后的指针 / 引用极易触发 UB，仅用于底层编程（跨语言、硬件操作）；
-   不能用于普通数值类型转换（如 `int→char` 需用 `static_cast`）。

### 三、C 风格转换 vs C++ 显式转换

C 风格转换（`(T)val`）是 “万能转换”，编译器会根据场景自动选择 `static_cast`/`const_cast`/`reinterpret_cast` 的组合，缺点是：

-   语义模糊，阅读代码时无法判断转换意图；
-   缺乏针对性检查，容易隐藏风险（如误将 `const` 转换 + 底层重解释）。

**建议**：

-   优先使用 C++ 显式转换，让转换语义清晰；
-   日常开发：`static_cast` 为主，`dynamic_cast` 用于多态类向下转型，`const_cast` 仅临时移除 const，`reinterpret_cast` 尽量不用。

### 四、使用原则总结

1.  **能不用转换就不用**：优先通过合理的类型设计避免强制转换；
2.  **优先选安全的转换**：`dynamic_cast`（多态转型）> `static_cast`（语义转型）> `const_cast`（仅改限定符）> `reinterpret_cast`（底层重解释）；
3.  **reinterpret_cast 仅用于底层场景**：跨语言接口、硬件内存操作、序列化，且必须加详细注释；
4.  **const_cast 不修改 const 对象**：仅当原对象非 const 时，移除 const 后修改才合法；
5.  **dynamic_cast 检查返回值**：指针转换后必须判空，引用转换需捕获 `bad_cast` 异常。