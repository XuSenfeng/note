---
layout: post
title: "文件IO" 
date:   2023-9-6 15:39:08 +0800
tags: Linux
---

# 文件IO

## 系统调用

操作系统提供给外界的程序编程接口(API)

![img](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202402142035039.png)

## C语言的IO函数

fopen、fclose、fseek、fgets、fputs、fread、fwrite......

​     r 只读、 r+读写

w只写并截断为0、 w+读写并截断为0

a追加只写、 a+追加读写

### open

```c
int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
```

> pathname: 文件名
>
> flags: 文件的打开方式, O_RDONLY、O_WRONLY、O_RDWR  , O_APPEND、O_CREAT、O_EXCL、 O_TRUNC、 O_NONBLOCK
>
> modo: 文件的权限, 参数2有O_CREAT的时候才会使用这一个函数, 文件权限由open的mode参数和当前进程的umask掩码共同决定, 实际的是mode & ~umask
>
> 返回值: 是一个文件描述符, 错误的时候是-1
>
> 使用头文件: unistd.h

### 显示错误

Linux有一个全局变量errno, 使用头文件errno.h可以使用

还可以使用strerror获取这一个错误的描述, 头文件string.h

```c
#include<stdio.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>
int main()
{
	int fd;
	fd = open("test.txt", O_CREAT| O_RDWR, 0666);
	printf("fd = %d, errno = %d:%s \n", fd, errno, strerror(errno));
	close(fd);
	return 0;
}
```

### read/write

```c
#include <unistd.h>
ssize_t read(int fd, void *buf, size_t count);
```

> 文件, 保存的位置以及读取的大小
>
> 返回的时候返回实际读取的大小, 为0的时候已经到末尾了, On error, -1 is returned, and errno  is  set  appropriately.

```c
#include <unistd.h>
ssize_t write(int fd, const void *buf, size_t count);
```

> 返回实际写入的数据的个数, 错误的话返回-1



