---
layout: post
title: "文件IO" 
date:   2024-3-23 15:39:08 +0800
tags: Linux
---

# 进程间通信

IPC: InterProcess Communication

使用内核里面的一块缓冲区, 进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信

在进程间完成数据传递需要借助操作系统提供特殊的方法，如：文件、管道、信号、共享内存、消息队列、套接字、命名管道等。随着计算机的蓬勃发展，一些方法由于自身设计缺陷被淘汰或者弃用。现今常用的进程间通信方式有：

​     ① 管道 (使用最简单, 这一个一般是有关系的进程间)

​     ② 信号 (开销最小, 数据量受限)

​     ③ 共享映射区 (无血缘关系)

​     ④ 本地套接字 (最稳定, 网络中, 实现复杂)

> 主要有三套不同的通信机制
>
> 1. 早期Linux的, 管道, 信号, fifo
> 2. system-v ipc(贝尔实验室) 的消息队列, 信号量, 共享内存
> 3. socket
> 4. posix ipc(IEEE) 的消息队列, 信号量, 共享内存

## 管道

可以使用pipe函数进行创建, 以及命令mkfifo命令, 通过文件系统中的某一个文件名来建立，它允许无关进程之间的通信。使用有名管道时，需要先用 mkfifo 命令创建管道文件，然后通过文件 I/O 操作来进行数据的读写。在使用完毕后，需要手动删除该文件。

管道是一种最基本的IPC机制，作用于有血缘关系的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道。有如下特质：

1. 其本质是一个伪文件(实为内核缓冲区) 
2. 由两个文件描述符引用，一个表示读端，一个表示写端。
3. 规定数据从管道的写端流入管道，从读端流出。

管道的原理: 管道实为内核使用环形队列机制，借助内核缓冲区(4k)实现。

管道的局限性：

① 数据不能进程自己写，自己读。

② 管道中数据不可反复读取。一旦读走，管道中不再存在。 

③ 采用半双工通信方式，数据只能在单方向上流动。

常见的通信方式有，单工通信、半双工通信、全双工通信。

### pipe

```c
int pipe(int pipefd[2]);
```

> pipe()  creates  a pipe, a unidirectional data channel that can be used
>        for interprocess communication.  The array pipefd is used to return two
>        file  descriptors  referring to the ends of the pipe.  pipefd[0] refers
>        to the read end of the pipe.  pipefd[1] refers to the write end of  the
>        pipe.   Data  written  to  the write end of the pipe is buffered by the
>        kernel until it is read from the read end of  the  pipe.
>
> 参数是返回两个文件描述符, 0用来读, 1用来写, 这两个管道是被打开的
>
> 成功的话返回0

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>

int main(int argc, char *argv[]){
	int ret;
	int fd[2];
	pid_t pid;

	ret = pipe(fd);
	if(ret == -1){
		perror("pipe error");
		exit(1);
	}

	pid = fork();
	if(pid > 0){
		//parent
		close(fd[0]);//close read pipe
		write(fd[1], "hello pipe", strlen("hello pipe"));
		close(fd[1]);//关闭写的管道
	}else if(pid == 0 ){
		sleep(1);
		char temp;
		close(fd[1]);
		while(read(fd[0], &temp, 1)){
			putc(temp, stdout);
		}
		close(fd[0]);
	}
}
```

使用管道需要注意以下4种特殊情况（假设都是阻塞I/O操作，没有设置O_NONBLOCK标志）：

1. 如果所有指向管道写端的文件描述符都关闭了（管道写端引用计数为0），而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样。

2. 如果有指向管道写端的文件描述符没关闭（管道写端引用计数大于0），而持有管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次read会阻塞，直到管道中有数据可读了才读取数据并返回。

3. 如果所有指向管道读端的文件描述符都关闭了（管道读端引用计数为0），这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。当然也可以对SIGPIPE信号实施捕捉，不终止进程。具体方法信号章节详细介绍。

4. 如果有指向管道读端的文件描述符没关闭（管道读端引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写端写数据，那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。

总结：

① 读管道： 1. 管道中有数据，read返回实际读到的字节数。

​                    2. 管道中无数据：

​					 (1) 管道写端被全部关闭，read返回0 (好像读到文件结尾)

​                     (2) 写端没有全部被关闭，read阻塞等待(不久的将来可能有数据递达，此时会让出cpu)

  ② 写管道： 1. 管道读端全部被关闭， 进程异常终止(也可使用捕捉SIGPIPE信号，使进程不终止)

​                  	2. 管道读端没有全部关闭： 

​					  (1) 管道已满，write阻塞。

​                      (2) 管道未满，write将数据写入，并返回实际写入的字节数。

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>

int main(int argc, char *argv[]){
	int ret;
	int fd[2];
	pid_t pid;

	ret = pipe(fd);
	if(ret == -1){
		perror("pipe error");
		exit(1);
	}

	pid = fork();
	if(pid > 0){
		//parent
		close(fd[0]);//close read pipe
		dup2(fd[1], STDOUT_FILENO);
		execlp("ls" ,"ls", "-l", NULL);
		close(fd[1]);
	}else if(pid == 0 ){
		sleep(1);
		close(fd[1]);
		dup2(fd[0], STDIN_FILENO);
		execlp("wc", "wc", "-l", NULL);
		close(fd[0]);
	}
}
```

#### 注意

如果某一个进程里面没有使用这一个管道, 需要把这一个管道对应的文件关闭

### 管道缓冲区大小

​     可以使用ulimit –a 命令来查看当前系统中创建管道文件所对应的内核缓冲区大小。通常为：

​         pipe size      (512 bytes, -p) 8

​     也可以使用fpathconf函数，借助参数  选项来查看。使用该宏应引入头文件<unistd.h>

​         long fpathconf(int fd, int name);   第二个参数_PC_PIPE_BUF成功：返回管道的大小    失败：-1，设置errno

### 管道的优劣

​     优点：简单，相比信号，套接字实现进程间通信，简单很多。

​     缺点：1. 只能单向通信，双向通信需建立两个管道。

2. 只能用于父子、兄弟进程(有共同祖先)间通信。该问题后来使用fifo有名管道解决。

## FIFO 

FIFO常被称为命名管道，以区分管道(pipe)。管道(pipe)只能用于“有血缘关系”的进程间。但通过FIFO，不相关的进程也能交换数据。

​     FIFO是Linux基础文件类型中的一种。但，FIFO文件在磁盘上没有数据块，仅仅用来标识内核中一条通道。各进程可以打开这个文件进行read/write，实际上是在读写内核通道，这样就实现了进程间通信。

创建方式：

1. 命令：`mkfifo` 管道名
2. 库函数：`int mkfifo(const char *pathname,  mode_t mode);`Mode是这一个文件的权限 成功：0； 失败：-1

​     一旦使用mkfifo创建了一个FIFO，就可以使用open打开它，常见的文件I/O函数都可用于fifo。如：close、read、write、unlink等。

1)、如果当前打开操作是为读而打开FIFO时，若已经有相应进程为写而打开该FIFO，则当前打开操作将成功返回；否则，可能阻塞直到有相应进程为写而打开该FIFO（当前打开操作设置了阻塞标志）；或者，成功返回（当前打开操作没有设置阻塞标志）。
2)、如果当前打开操作是为写而打开FIFO时，如果已经有相应进程为读而打开该FIFO，则当前打开操作将成功返回；否则，可能阻塞直到有相应进程为读而打开该FIFO（当前打开操作设置了阻塞标志）；或者，返回ENXIO错误（当前打开操作没有设置阻塞标志）。

总之，一旦设置了阻塞标志，调用mkfifo建立好之后，那么管道的两端读写必须分别打开，有任何一方未打开，则在调用open的时候就阻塞。对管道或者FIFO调用lseek，返回ESPIPE错误。

> 在write函数执行的时候这个函数有原子性, 如果缓冲区的大小比较小不足以写入所有的数据, 这部分写入会失败

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <sys/stat.h>
#include "string.h"
#include "fcntl.h"
int main(int argc, char *argv){
	int ret = mkfifo("myfifo", 0664);
	if(ret < 0){
		perror("mkfifo err");
		exit(1);
	}
	pid_t pid = fork();
	if(pid == 0){
		int fd2 = open("myfifo", O_WRONLY);
		int num = write(fd2, "hello\n", strlen("hello\n"));
		if(ret < 0){
			perror("write error");
		}
		printf("write : %d\n", num);
		close(fd2);
	}else{

		int fd1 = open("myfifo", O_RDONLY);
		char buf[10];
		int num = read(fd1, buf, strlen("hello\n"));
		if(ret < 0){
			perror("read error");
		}
		printf("read : %d\n", num);
		close(fd1);
		printf(buf);
	}
	
}
```



## 存储映射I/O

使一个磁盘文件和存储空间里面的一个缓冲区映射, 从缓冲区里面读取数据实际就是从文件里面读取数据

把数据存入缓冲区实际是写文件, 可以在不使用read write的情况下完成文件的读写

![img](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202403241056186.jpg)

可以使用mmap函数进行

### mmap进行存储映射

`void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);`

> addr: 指定映射区域的位置, 一般使用NULL,系统自动分配
>
> length: 这一个区域的大小
>
> port: 共享内存映射区域的属性PORT_READ, PORT_EXEC, PORT_WRITE, PORT_NONE
>
> flags: 这一块共享内存的共享属性MAP_SHARED, MAP_PRIVATE, 这一个会决定这一个文件会不会反映到磁盘
>
> fd: 用于创建的那一个文件的文件描述符
>
> offset: 偏移, 这一个需要时4K的倍数, 这一个值是0的时候默认是这一个文件的全部
>
> 返回值: 这一个映射区域的首地址, 失败的话返回一个MAP_FAILED(实际是(void *)-1)

### munmap取消映射

`int munmap(void *addr, size_t length);`

> addr, mmap的返回值
>
> length:大小

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <sys/mman.h>
#include <fcntl.h>
int main(int argc, char *argv[]){
	char *p = NULL;
	int fd  = open("test.map", O_RDWR | O_CREAT | O_TRUNC, 0644);
	if(fd == -1){
		perror("creat errro");
		exit(0);
	}
	/*
	lseek(fd, 10, SEEK_END);
	write(fd, "\0", 1);
	*/
	//进行映射 
	ftruncate(fd, 20);//拓展文件
	int len = lseek(fd, 0, SEEK_END);
	p = mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
	if(p == MAP_FAILED){
		perror("mmap error");
		exit(1);
	}
	//测试
	strcpy(p, "hello mmap");
	printf("----%s----", p);
	int ret = munmap(p, len);
	if(ret == -1){

		perror("unmap error");
		exit(0);
	}
	return 0;
}
```

> **常见错误**
>
> 实际使用的时候这一个文件的大小需要和映射的大小相同
>
> 文件大小为0, 出现总线错误, 映射区域大小为0, 返回无效参数, 文件的权限不对也是无效参数
>
> 这一个文件必须要有读权限, 映射的时候需要读文件
>
> 文件的描述符mmap之后可以关闭, 之后可以用地址访问
>
> offset是4096的倍数

> **注**: 
>
> 1. 这一个申请的内存不可以越界访问
> 2. 获取的地址不能释放了, munmap会失败
> 3. 使用私有的时候这一个文件只需要有读权限
>
> 实际使用(最保险的)
>
> + open: 使用O_RDWR
> + mmap(NULL, 有效的文件大小, PORT_READ | PORT_WRITE, MAP_SHARED, fd, 0)

### 父子进程间的通信

父子等有血缘关系的进程之间也可以通过mmap建立的映射区来完成数据通信。但相应的要在创建映射区的时候指定对应的标志位参数flags：

MAP_PRIVATE: (私有映射) 父子进程各自独占映射区；

MAP_SHARED: (共享映射) 父子进程共享映射, 应该使用这一个

1. mmap建立映射
2. 使用fork创建子进程

### 无关进程之间的通信

打开文件的时候使用同一个文件就可以了

### 匿名映射

使用映射的时候需要有一个文件, 但是这一个文件不需要一直存在, 这时候可以使用unlink对这一个文件进行删除, 这一个文件不被使用以后会被自动回收

可以直接使用匿名映射来代替。其实Linux系统给我们提供了创建匿名映射区的方法，无需依赖一个文件即可创建映射区。同样需要借助标志位参数flags来指定。

使用MAP_ANONYMOUS (或MAP_ANON)， 如: 

`     int *p = mmap(NULL, 4, PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANONYMOUS, -1, 0); `

  "4"随意举例，该位置表大小，可依实际需要填写。

> The mapping is not backed by any file; its contents are initialized  to zero.  The fd argument is ignored; however, some implementations require fd to be -1 if MAP_ANONYMOUS (or MAP_ANON) is specified,  and  portable  applications should ensure this.  The offset argument should be zero.  The  use  of  MAP_ANONYMOUS  in conjunction  with  MAP_SHARED  is  supported on Linux only since kernel 2.4.

> 需注意的是，MAP_ANONYMOUS和MAP_ANON这两个宏是Linux操作系统特有的宏。在类Unix系统中如无该宏定义，可使用如下两步来完成匿名映射区的建立。
>
> ​     ① fd = open("/dev/zero", O_RDWR);
>
> ​     ② p = mmap(NULL, size, PROT_READ|PROT_WRITE, MMAP_SHARED, fd, 0);

> /dev/null  ： 在类Unix系统中，/dev/null，或称空设备，是一个特殊的设备文件，它丢弃一切写入其中的数据（但报告写入操作成功），读取它则会立即得到一个EOF。
> 在程序员行话，尤其是Unix行话中，/dev/null 被称为位桶(bit bucket)或者黑洞(black hole)。空设备通常被用于丢弃不需要的输出流，或作为用于输入流的空文件。这些操作通常由重定向完成。
>
> /dev/zero  ： 在类UNIX 操作系统中, /dev/zero 是一个特殊的文件，当你读它的时候，它会提供无限的空字符(NULL, ASCII NUL, 0x00)。
>
> 其中的一个典型用法是用它提供的字符流来覆盖信息，另一个常见用法是产生一个特定大小的空白文件。BSD就是通过mmap把/dev/zero映射到虚地址空间实现共享内存的。可以使用mmap将/dev/zero映射到一个虚拟的内存空间，这个操作的效果等同于使用一段匿名的内存（没有和任何文件相关）。

值得注意的是：MAP_ANON和 /dev/zero 都不能应用于非血缘关系进程间通信

## System-V消息队列

+ 是一个独立于进程的概念
+ 没有文件名和文件描述符
+ 有ID和key

### 使用

+ 定义一个唯一的key, 使用ftok

> `key_t ftok(const char *path, int proj_id)`, 一个合法的路径和一个整数, 通常是一个非零的8位整数, 返回一个合法的键值
>
> `ftok` 的主要作用是根据文件的属性（如 inode 编号）生成一个唯一的键值。这个键值与文件系统相关联，并结合项目标识符生成独特的 IPC 键。通过这个键，多个进程能够访问相同的 IPC 资源，比如共享内存段、消息队列或信号量。
>
> ftok 函数生成的键值并不是完全随机的，它依赖于文件的 inode 编号 和 设备号，因此同一个文件路径在相同的文件系统上会生成相同的键值。
> 键值的生成方式基于以下几个因素：
>
> 文件的 inode 编号：一个文件的唯一标识符。
> 文件所在设备的设备号：标识文件所在的设备。
> 项目标识符（proj_id）：由用户指定的标识符，用于进一步区分同一文件的不同 IPC 资源。
> ftok 会将这些值组合起来，生成一个可以唯一标识 IPC 资源的键。

+ 构建一个消息对象msgget

> `int msgget(key_t key, int msgflg)` key是一个键值, msgflg: IPC_CREAT, 不存在的时候创建一下, mode是方位的权限
>
> 返回这个队列的ID

+ 发送特定类型的消息msgsnd

> `int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);`
>
> + msqid: 队列ID
> + msgp: 消息缓冲区
>
> ```c
> struct msgbuf {
>     long mtype;       /* message type, must be > 0 */
>     char mtext[1];    /* message data */
> };
> ```
>
> + msgsz: 消息的长度, 实际是mtext的长度
> + msgflg: 发送的方式, 0阻塞发送, IPC_NOWAIT非阻塞

+ 接受特定的消息msgrcv

```c
ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg);
```

> msgtyp: 接受的消息的类型
>
> msgflag: IPC_NOWAIT不阻塞, MSG_NOERROR截断消息(实际的消息比给的缓冲区要小), 0阻塞读取

+ 删除消息队列msgctl

> `int msgctl(int msqid, int cmd, struct msqid_ds *buf);`
>
> 获取信息和删除
>
> IPC_STAT: 获取消息队列的属性信息, 填入buf里面
>
> IPC_SET: 设置队列的属性
>
> IPC_RMID: 删除消息队列
>
> buf: 相关结构体的缓冲区
>
> ```c
> struct msqid_ds {
>     struct ipc_perm msg_perm;     /* Ownership and permissions */
>     time_t          msg_stime;    /* Time of last msgsnd(2) */
>     time_t          msg_rtime;    /* Time of last msgrcv(2) */
>     time_t          msg_ctime;    /* Time of last change */
>     unsigned long   __msg_cbytes; /* Current number of bytes in
>                                                 queue (nonstandard) */
>     msgqnum_t       msg_qnum;     /* Current number of messages
>                                                 in queue */
>     msglen_t        msg_qbytes;   /* Maximum number of bytes
>                                                 allowed in queue */
>     pid_t           msg_lspid;    /* PID of last msgsnd(2) */
>     pid_t           msg_lrpid;    /* PID of last msgrcv(2) */
> };
> ```
>
> 

```c
#include <sys/msg.h>
#include <stdio.h>
#include <stdlib.h>

struct msgbuf {
    long mtype;
    char mtext[100];
};

int main() {
    int msqid;
    key_t key;
    struct msgbuf sbuf, rbuf;
    
    // 生成key
    if ((key = ftok("/tmp", 'a')) == -1) {
        perror("ftok");
        exit(1);
    }
    
    // 创建消息队列
    if ((msqid = msgget(key, IPC_CREAT | 0666)) == -1) {
        perror("msgget");
        exit(1);
    }
    
    // 发送消息
    sbuf.mtype = 1;
    sprintf(sbuf.mtext, "Hello Message Queue");
    if (msgsnd(msqid, &sbuf, sizeof(sbuf.mtext), 0) == -1) {
        perror("msgsnd");
        exit(1);
    }
    
    // 接收消息
    if (msgrcv(msqid, &rbuf, sizeof(rbuf.mtext), 1, 0) == -1) {
        perror("msgrcv");
        exit(1);
    }
    printf("Received: %s\n", rbuf.mtext);
    
    // 删除消息队列
    if (msgctl(msqid, IPC_RMID, NULL) == -1) {
        perror("msgctl");
        exit(1);
    }
    
    return 0;
}
```

### 多进程示例

```c
#ifndef MSG_COMMON_H
#define MSG_COMMON_H

#include <sys/ipc.h>
#include <sys/msg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

// 消息结构
struct message {
    long mtype;
    char mtext[100];
};

// 生成相同的key
#define MSG_KEY_PATH "/tmp"
#define MSG_KEY_PROJ 'A'

// 获取消息队列ID
int get_msg_queue(int create_flag) {
    key_t key;
    // 获取同样的队列
    if ((key = ftok(MSG_KEY_PATH, MSG_KEY_PROJ)) == -1) {
        perror("ftok");
        exit(EXIT_FAILURE);
    }
    
    int flags = create_flag ? (IPC_CREAT | 0666) : 0;
    int msqid = msgget(key, flags);
    if (msqid == -1) {
        perror("msgget");
        exit(EXIT_FAILURE);
    }
    
    return msqid;
}

#endif
```

```c
#include "msg_common.h"

int main() {
    int msqid = get_msg_queue(1); // 创建队列
    struct message msg;
    
    printf("Sender started. Enter messages (type 'exit' to quit):\n");
    
    while (1) {
        printf("> ");
        fgets(msg.mtext, sizeof(msg.mtext), stdin);
        msg.mtext[strcspn(msg.mtext, "\n")] = '\0'; // 移除换行符
        
        if (strcmp(msg.mtext, "exit") == 0) {
            break;
        }
        
        msg.mtype = 1; // 消息类型设为1
        
        if (msgsnd(msqid, &msg, sizeof(msg.mtext), 0) == -1) {
            perror("msgsnd");
            exit(EXIT_FAILURE);
        }
        
        printf("Sent: %s\n", msg.mtext);
    }
    
    printf("Sender exiting...\n");
    return 0;
}
```

```c
#include "msg_common.h"

int main() {
    int msqid = get_msg_queue(0); // 获取已存在的队列
    struct message msg;
    
    printf("Receiver started. Waiting for messages...\n");
    
    while (1) {
        if (msgrcv(msqid, &msg, sizeof(msg.mtext), 1, 0) == -1) {
            perror("msgrcv");
            exit(EXIT_FAILURE);
        }
        
        printf("Received: %s\n", msg.mtext);
        
        if (strcmp(msg.mtext, "exit") == 0) {
            // 删除消息队列
            if (msgctl(msqid, IPC_RMID, NULL) == -1) {
                perror("msgctl");
                exit(EXIT_FAILURE);
            }
            break;
        }
    }
    
    printf("Receiver exiting...\n");
    return 0;
}
```

## System-V信号量

本质是一个计数器, 用于互斥以及同步, 同时只有一个在访问, 并且可以设置访问的顺序

### 使用

+ 获取一个唯一的key(fork)
+ 构建一个信号量集合(semget)

>  `int semget(key_t key, int nsems, int semflg);`
>
> **nsems**: 信号量集合里面的信号量的数量, 如果使用已存在的信号量集合，则这个值可以忽略，但在创建时需要指定合适的数目。在某些情况下，只有在创建新信号量集时才会用到。
>
> **semflg**（`int` 类型）：控制信号量集的行为和权限的标志位（即标志参数）。
>
> 常用的标志包括：
>
> - `IPC_CREAT`：如果不存在对应的信号量集，就创建它。
> - `IPC_EXCL`：结合 `IPC_CREAT` 使用，确保创建新集，若已存在则返回错误。
> - 权限标志（类似文件权限），如 `0666` 表示让所有用户都可以读写。

+ 初始化集合中的信号量(semctl SETVA)

> `int semctl(int semid, int semnum, int cmd, ...);`
>
> **semid: **信号量的ID
>
> **semnum: **信号量的编号, 通常设置为0(集合里面只有一个信号量的时候)
>
> **cmd: **
>
> + IPC_STAT: 获取信号量的状态
> + IPC_SET: 设置信号量的属性
> + IPC_RMID: 删除信号量
> + SETVAL: 设置实际的数量
>
> ```c
> union semun {
>     int              val;    /* Value for SETVAL 设置数量*/
>     struct semid_ds *buf;    /* Buffer for IPC_STAT, IPC_SET 获取/设置状态 */
>     unsigned short  *array;  /* Array for GETALL, SETALL */
>     struct seminfo  *__buf;  /* Buffer for IPC_INFO
>                                            (Linux-specific) */
> };
> ```
>
> ```c
> struct semid_ds {
>     struct ipc_perm sem_perm;  /* Ownership and permissions */
>     time_t          sem_otime; /* Last semop time */
>     time_t          sem_ctime; /* Last change time */
>     unsigned long   sem_nsems; /* No. of semaphores in set */
> };
> ```

+ 进行P/V操作(semop)

> `int semop(int semid, struct sembuf *sops, size_t nsops);`
>
> ```c
> struct sembuf{
>     unsigned short sem_num;  /* semaphore number 编号 */
>     short          sem_op;   /* semaphore operation 进行的操作数量 进行+-的num可以使正数负数和0 */
>     short          sem_flg;  /* operation flags 行为一般是 SEM_UNDO, 进程结束的时候自动释放信号量 */
> }
> ```
>
> - **`sem_op`**
>     - `-1`：等待（P操作），如果信号量值为0，则阻塞直到变为正数，然后减1
>     - `1`：信号释放（V操作），将信号量值加1
>     - `0`：等待信号量变为0（常用于同步条件）
>
> `nsops: `操作的信号量的个数, 一般是1个

### 实际使用

```c
#ifndef SEM_COMMON_H
#define SEM_COMMON_H

#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define SEM_KEY_PATH "/tmp"
#define SEM_KEY_PROJ 'B'

// 获取信号量集ID
int get_semaphore(int create_flag) {
    key_t key;
    if ((key = ftok(SEM_KEY_PATH, SEM_KEY_PROJ)) == -1) {
        perror("ftok");
        exit(EXIT_FAILURE);
    }
    
    int flags = create_flag ? (IPC_CREAT | 0666) : 0;
    int semid = semget(key, 1, flags); // 只创建1个信号量
    if (semid == -1) {
        perror("semget");
        exit(EXIT_FAILURE);
    }
    
    return semid;
}

// 信号量操作
void sem_op(int semid, int sem_num, int op) {
    struct sembuf sb = {sem_num, op, SEM_UNDO};
    if (semop(semid, &sb, 1) == -1) {
        perror("semop");
        exit(EXIT_FAILURE);
    }
}

// 初始化信号量
void init_semaphore(int semid, int value) {
    union semun {
        int val;
        struct semid_ds *buf;
        unsigned short *array;
    } arg;
    
    arg.val = value;
    if (semctl(semid, 0, SETVAL, arg) == -1) {
        perror("semctl SETVAL");
        exit(EXIT_FAILURE);
    }
}

#endif
```

```c
#include "sem_common.h"
#include <time.h>

int main() {
    int semid = get_semaphore(1); // 创建信号量
    
    // 初始化信号量值为1（二进制信号量/互斥锁）
    init_semaphore(semid, 1);
    
    printf("Process 1 started\n");
    
    for (int i = 0; i < 5; i++) {
        printf("Process 1 trying to enter critical section...\n");
        
        // P操作（等待信号量）
        sem_op(semid, 0, -1);
        
        printf("Process 1 entered critical section\n");
        
        // 模拟临界区工作
        srand(time(NULL));
        int sleep_time = rand() % 3 + 1;
        sleep(sleep_time);
        
        printf("Process 1 leaving critical section after %d seconds\n", sleep_time);
        
        // V操作（释放信号量）
        sem_op(semid, 0, 1);
        
        // 模拟非临界区工作
        sleep(1);
    }
    
    printf("Process 1 exiting...\n");
    
    // 删除信号量（通常由最后一个退出的进程执行）
    if (semctl(semid, 0, IPC_RMID) == -1) {
        perror("semctl IPC_RMID");
    }
    
    return 0;
}
```

```c
#include "sem_common.h"
#include <time.h>

int main() {
    int semid = get_semaphore(0); // 获取已存在的信号量
    
    printf("Process 2 started\n");
    
    for (int i = 0; i < 5; i++) {
        printf("Process 2 trying to enter critical section...\n");
        
        // P操作（等待信号量）
        sem_op(semid, 0, -1);
        
        printf("Process 2 entered critical section\n");
        
        // 模拟临界区工作
        srand(time(NULL));
        int sleep_time = rand() % 3 + 1;
        sleep(sleep_time);
        
        printf("Process 2 leaving critical section after %d seconds\n", sleep_time);
        
        // V操作（释放信号量）
        sem_op(semid, 0, 1);
        
        // 模拟非临界区工作
        sleep(1);
    }
    
    printf("Process 2 exiting...\n");
    return 0;
}
```

## System-V共享内存

+ 获取一个唯一的key(ftok)
+ 构建一个共享内存的对象(shmget)

`int shmget(key_t key, size_t size, int shmflg);`

> size: 共享内存的大小
>
> shmflg: 
>
> + IPC_CREATE: 不存在的时候创建
> + mode: 权限

+ 共享内存映射(shmat)

`void *shmat(int shm_id, const void *shm_addr, int shmflg);`

> shm_id: 创建的ID
>
> shm_addr: 映射的地址, NULL的时候自动分配
>
> shmflg: 0的时候可读可写, SHM_RDONLY可读的方式映射

+ 解除映射(shmdt)

`int shmdt(const void *shmaddr);`

+ 删除共享内存(shmctl RMID)

`int shmctl(int shm_id, int command, struct shmid_ds *buf);`

> **CMD**
>
> - IPC_STAT：把shmid_ds结构中的数据设置为共享内存的当前关联值，即用共享内存的当前关联值覆盖shmid_ds的值。
> - IPC_SET：如果进程有足够的权限，就把共享内存的当前关联值设置为shmid_ds结构中给出的值
> - IPC_RMID：删除共享内存段
>
> ```c
> struct shmid_ds
> {
>     uid_t shm_perm.uid;
>     uid_t shm_perm.gid;
>     mode_t shm_perm.mode;
> };
> ```
>

### 使用实例

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/types.h>

#define SHM_SIZE 1024  // 共享内存大小

int main() {
    int shmid;
    key_t key;
    char *shm, *s;

    // 生成一个唯一的key
    if ((key = ftok("shmfile", 65)) == -1) {
        perror("ftok");
        exit(1);
    }

    // 创建共享内存段
    if ((shmid = shmget(key, SHM_SIZE, IPC_CREAT | 0666)) < 0) {
        perror("shmget");
        exit(1);
    }

    // 将共享内存附加到进程地址空间
    if ((shm = shmat(shmid, NULL, 0)) == (char *)-1) {
        perror("shmat");
        exit(1);
    }

    // 向共享内存写入数据
    printf("Writing to shared memory...\n");
    s = shm;
    strcpy(s, "Hello from shared memory!");

    // 等待读取进程读取数据
    while (*shm != '*') {
        sleep(1);
    }

    // 分离共享内存
    if (shmdt(shm) == -1) {
        perror("shmdt");
        exit(1);
    }

    // 删除共享内存段
    if (shmctl(shmid, IPC_RMID, NULL) == -1) {
        perror("shmctl");
        exit(1);
    }

    printf("Write process completed.\n");
    return 0;
}
```

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ipc.h>
#include <sys/shm.h>
#include <sys/types.h>

#define SHM_SIZE 1024  // 共享内存大小

int main() {
    int shmid;
    key_t key;
    char *shm, *s;

    // 生成相同的key
    if ((key = ftok("shmfile", 65)) == -1) {
        perror("ftok");
        exit(1);
    }

    // 获取共享内存段
    if ((shmid = shmget(key, SHM_SIZE, 0666)) < 0) {
        perror("shmget");
        exit(1);
    }

    // 将共享内存附加到进程地址空间
    if ((shm = shmat(shmid, NULL, 0)) == (char *)-1) {
        perror("shmat");
        exit(1);
    }

    // 读取共享内存中的数据
    printf("Reading from shared memory...\n");
    for (s = shm; *s != '\0'; s++) {
        putchar(*s);
    }
    putchar('\n');

    // 通知写入进程数据已读取
    *shm = '*';

    // 分离共享内存
    if (shmdt(shm) == -1) {
        perror("shmdt");
        exit(1);
    }

    printf("Read process completed.\n");
    return 0;
}
```

