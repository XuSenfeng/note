---
layout: post
title: "网络基础" 
date:   2024-3-10 15:39:08 +0800
tags: Linux 网络
---

# 网络基础

## 协议

一组规则, 数据传输和数据的解释的规则。

比如说依次发送文件的文件名, 文件的大小, 以及实际的文件, 这样规定发送一个文件的顺序以及发送的每一个部分的格式等可以算是一种协议

### 型协议

传输层 常见协议有TCP/UDP协议。

应用层 常见的协议有HTTP协议，FTP协议。

网络层 常见协议有IP协议、ICMP协议、IGMP协议。

网络接口层 常见协议有ARP协议、RARP协议。

TCP[传输控制协议](http://baike.baidu.com/view/544903.htm)（Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的[传输层](http://baike.baidu.com/view/239605.htm)通信协议。

UDP用户数据报协议（User Datagram Protocol）是[OSI](http://baike.baidu.com/view/113948.htm)参考模型中一种无连接的[传输层](http://baike.baidu.com/view/239605.htm)协议，提供面向事务的简单不可靠信息传送服务。

HTTP[超文本传输协议](http://baike.baidu.com/view/468465.htm)（Hyper Text Transfer Protocol）是[互联网](http://baike.baidu.com/view/6825.htm)上应用最为广泛的一种[网络协议](http://baike.baidu.com/view/16603.htm)。

FTP文件传输协议（File Transfer Protocol）

IP协议是[因特网](http://baike.baidu.com/view/1706.htm)互联协议（Internet Protocol）

ICMP协议是Internet控制[报文](http://baike.baidu.com/view/175122.htm)协议（Internet Control Message Protocol）它是[TCP/IP协议族](http://baike.baidu.com/view/2221037.htm)的一个子协议，用于在IP[主机](http://baike.baidu.com/view/23880.htm)、[路由](http://baike.baidu.com/view/18655.htm)器之间传递控制消息。

IGMP协议是 Internet 组管理协议（Internet Group Management Protocol），是因特网协议家族中的一个组播协议。该协议运行在主机和组播路由器之间。

[ARP](http://baike.baidu.com/view/32698.htm)协议是正向[地址解析协议](http://baike.baidu.com/view/149421.htm)（Address Resolution Protocol），通过已知的IP，寻找对应主机的[MAC地址](http://baike.baidu.com/view/69334.htm)。

## 分层模型

### OSI七层模型

![img](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202404021007234.jpg)

OSI模型

1. **物理层**：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。
2. **数据链路层**：定义了如何让格式化数据以帧为单位进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。如：串口通信中使用到的115200、8、N、1
3. **网络层**：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。
4. **传输层**：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。
5. **会话层**：通过传输层(端口号：传输端口与接收端口)建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。
6. **表示层**：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码(EBCDIC)，而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。
7. **应用层**：是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。

> 物数网传会表应
>
> 网网传应

### TCP/IP四层模型

TCP/IP网络协议栈分为应用层（Application）、传输层（Transport）、网络层（Network）和链路层（Link）四层。如下图所示：

![img](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202404021009884.png)

TCP/IP模型

> 应用层: http ftp nfs ssh telnet, 处理应用的数据
>
> 传输层: tcp udp, 处理端口
>
> 网络层: IP ICMP IGMP, 主要是处理ip地址
>
> 链路层: 以太网帧协议 ARP, 主要是处理MAC地址
>
> 一般在应用开发过程中，讨论最多的是TCP/IP模型。

## 通信过程

两台计算机通过TCP/IP协议通讯的过程如下所示：

![img](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202404021015622.jpg)

> 发送一个信息的时候首先会被应用层进行封装, 比如如果是一个文件可能使用FTP协议
>
> 之后是传输层, 网络层, 链路层依次增加他自己的协议
>
> 封装之后就可以发送到网络里面了
>
> 获取到信息以后反方向进行解封

数据没有封装是不能在网络里面传输的, 用户层协议是我们实际需要实现的

### TCP/IP通信过程

上图对应两台计算机在同一网段中的情况，如果两台计算机在不同的网段中，那么数据从一台计算机到另一台计算机传输过程中要经过一个或多个路由器，如下图所示：

![img](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202404021015657.jpg)

### 跨路由通信

**链路层**有以太网、令牌环网等标准，链路层负责网卡设备的驱动、帧同步（即从网线上检测到什么信号算作新帧的开始）、冲突检测（如果检测到冲突就自动重发）、数据差错校验等工作。交换机是工作在链路层的网络设备，可以在不同的链路层网络之间转发数据帧（比如十兆以太网和百兆以太网之间、以太网和令牌环网之间），由于不同链路层的帧格式不同，交换机要将进来的数据包拆掉链路层首部重新封装之后再转发。

**网络层**的IP协议是构成Internet的基础。Internet上的主机通过IP地址来标识，Inter-net上有大量路由器负责根据IP地址选择合适的路径转发数据包，数据包从Internet上的源主机到目的主机往往要经过十多个路由器。路由器是工作在第三层的网络设备，同时兼有交换机的功能，可以在不同的链路层接口之间转发数据包，因此路由器需要将进来的数据包拆掉网络层和链路层两层首部并重新封装。IP协议不保证传输的可靠性，数据包在传输过程中可能丢失，可靠性可以在上层协议或应用程序中提供支持。

网络层负责点到点（ptop，point-to-point）的传输（这里的“点”指主机或路由器），而传输层负责端到端（etoe，end-to-end）的传输（这里的“端”指源主机和目的主机）。传输层可选择TCP或UDP协议。

TCP是一种面向连接的、可靠的协议，有点像打电话，双方拿起电话互通身份之后就建立了连接，然后说话就行了，这边说的话那边保证听得到，并且是按说话的顺序听到的，说完话挂机断开连接。也就是说TCP传输的双方需要首先建立连接，之后由TCP协议保证数据收发的可靠性，丢失的数据包自动重发，上层应用程序收到的总是可靠的数据流，通讯之后关闭连接。

UDP是无连接的传输协议，不保证可靠性，有点像寄信，信写好放到邮筒里，既不能保证信件在邮递过程中不会丢失，也不能保证信件寄送顺序。使用UDP协议的应用程序需要自己完成丢包重发、消息排序等工作。

目的主机收到数据包后，如何经过各层协议栈最后到达应用程序呢？其过程如下图所示：

![img](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202404021015660.jpg)

以太网驱动程序首先根据以太网首部中的“上层协议”字段确定该数据帧的有效载荷（payload，指除去协议首部之外实际传输的数据）是IP、ARP还是RARP协议的数据报，然后交给相应的协议处理。假如是IP数据报，IP协议再根据IP首部中的“上层协议”字段确定该数据报的有效载荷是TCP、UDP、ICMP还是IGMP，然后交给相应的协议处理。假如是TCP段或UDP段，TCP或UDP协议再根据TCP首部或UDP首部的“端口号”字段确定应该将应用层数据交给哪个用户进程。IP地址是标识网络中不同主机的地址，而端口号就是同一台主机上标识不同进程的地址，IP地址和端口号合起来标识网络中唯一的进程。

虽然IP、ARP和RARP数据报都需要以太网驱动程序来封装成帧，但是从功能上划分，ARP和RARP属于链路层，IP属于网络层。虽然ICMP、IGMP、TCP、UDP的数据都需要IP协议来封装成数据报，但是从功能上划分，ICMP、IGMP与IP同属于网络层，TCP和UDP属于传输层。

> 具体的数据传输过程如下：
>
> 1. 应用层：应用程序生成需要发送的数据。
> 2. 传输层：TCP将应用数据进行分段并进行序列化。
> 3. 网络层：IP将每个TCP段封装到IP数据包中，并添加源IP地址和目标IP地址。
> 4. 数据链路层：在发送数据之前，网络层的IP数据包会被封装到以太网帧中。以太网帧包含了以太网的目标MAC地址和源MAC地址。
> 5. 物理层：以太网帧在物理层被转换为比特流，并通过物理介质（如以太网电缆）发送出去。

## 协议格式

### 数据包封装

传输层及其以下的机制由内核提供，应用层由用户进程提供（后面将介绍如何使用socket API编写应用程序），应用程序对通讯数据的含义进行解释，而传输层及其以下处理通讯的细节，将数据从一台计算机通过一定的路径发送到另一台计算机。应用层数据通过协议栈发到网络上时，每层协议都要加上一个数据首部（header），称为封装（Encapsulation），如下图所示：

![img](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202404021244635.jpg)

TCP/TP数据包封装

不同的协议层对数据包有不同的称谓，在传输层叫做段（segment），在网络层叫做数据报（datagram），在链路层叫做帧（frame）。数据封装成帧后发到传输介质上，到达目的主机后每层协议再剥掉相应的首部，最后将应用层数据交给应用程序处理。

### 以太网帧格式(链路层)

以太网的帧格式如下所示：

![img](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202404021242758.png)

> 这一个图是如何把一个数据封装为实际发送的信息, 无论是TIP/IP发送的IP数据报还是APR请求, 最后都要加上这几个然后进行发送

其中的源地址和目的地址是指网卡的硬件地址（也叫MAC地址），长度是48位，是在网卡出厂时固化的。可在shell中使用ifconfig命令查看，“HWaddr 00:15:F2:14:9E:3F”部分就是硬件地址。协议字段有三种值，分别对应IP、ARP、RARP。帧尾是CRC校验码。

> ARP协议: 通过ip地址获取MAC地址
>
> ![image-20240402125241576](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202404021252635.png)

以太网帧中的数据长度规定最小46字节，最大1500字节，ARP和RARP数据包的长度不够46字节，要在后面补填充位。

最大值1500称为以太网的最大传输单元（MTU) ，不同的网络类型有不同的MTU，如果一个数据包从以太网路由到拨号链路上，数据包长度大于拨号链路的MTU，则需要对数据包进行分片（fragmentation）。ifconfig命令输出中也有“MTU:1500”。注意，MTU这个概念指数据帧中有效载荷的最大长度，不包括帧头长度。

> 无论是ARP协议还是TCP，在TCP/IP协议栈中，数据都是通过以太网帧进行传输的。以太网帧是一种在以太网（Ethernet）上传输数据的标准格式。

### ARP数据报格式

> ARP协议用于获取目标主机的MAC地址，发生在三次握手之前，确保在TCP连接建立时源主机已经知道目标主机的MAC地址。之后，TCP三次握手建立连接，然后才进行数据的传输。ARP和三次握手是在TCP/IP通信过程中的不同阶段，但都是确保数据通信的可靠性和正确性的重要步骤。

在网络通讯时，源主机的应用程序知道目的主机的IP地址和端口号，却不知道目的主机的硬件地址，而数据包首先是被网卡接收到再去处理上层协议的，如果接收到的数据包的硬件地址与本机不符，则直接丢弃。因此在通讯前必须获得目的主机的硬件地址。ARP协议就起到这个作用。源主机发出ARP请求，询问“IP地址是192.168.0.1的主机的硬件地址是多少”，并将这个请求广播到本地网段（以太网帧首部的硬件地址填FF:FF:FF:FF:FF:FF表示广播），目的主机接收到广播的ARP请求，发现其中的IP地址与本机相符，则发送一个ARP应答数据包给源主机，将自己的硬件地址填写在应答包中。

每台主机都维护一个ARP缓存表，可以用arp -a命令查看。缓存表中的表项有过期时间（一般为20分钟），如果20分钟内没有再次使用某个表项，则该表项失效，下次还要发ARP请求来获得目的主机的硬件地址。想一想，为什么表项要有过期时间而不是一直有效？

ARP数据报的格式如下所示：

![image-20240402131227491](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202404021312516.png)

![img](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202404021250602.png)

> 下面的这一个图里面没有PAD, 上面的这一个少了目的和源地址

ARP数据报格式

源MAC地址、目的MAC地址在以太网首部和ARP请求中各出现一次，对于链路层为以太网的情况是多余的，但如果链路层是其它类型的网络则有可能是必要的。硬件类型指链路层网络类型，1为以太网，协议类型指要转换的地址类型，0x0800为IP地址，后面两个地址长度对于以太网地址和IP地址分别为6和4（字节），op字段为1表示ARP请求，op字段为2表示ARP应答。

看一个具体的例子。

> [以太网协议 | ARP协议详解-ARP报文结构解析 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/648270097)

请求帧如下（为了清晰在每行的前面加了字节计数，每行16个字节）：

以太网首部（14字节）

0000: ff ff ff ff ff ff 00 05 5d 61 58 a8 08 06

> ff ff ff ff ff ff : 表示广播
>
> 00 05 5d 61 58 a8 : 自己的MAC地址
>
> 08 06 : ARP类型

ARP帧（28字节）

000e: 00 01

0010: 08 00 06 04 00 01 00 05 5d 61 58 a8 c0 a8 00 37

0020: 00 00 00 00 00 00 c0 a8 00 02

> 00 01: 硬件为以太网 
>
> 08 00 : 解析一个IP地址 
>
> 06 :硬件地址长度
>
> 04 :协议地址长度, 表示ip地址长度
>
> 00 01 : op字段为1表示ARP请求，op字段为2表示ARP应答。
>
> 00 05 5d 61 58 a8 : 自己的MAC地址
>
> c0 a8 00 37 : IP地址192.168.0.55
>
> 00 00 00 00 00 00 : 目的MAC地址, 未知填0
>
> c0 a8 00 02 : 目的地ip地址

填充位（18字节）

002a: 00 77 31 d2 50 10

0030: fd 78 41 d3 00 00 00 00 00 00 00 00

> ARP的填充位用于满足最小帧长度的要求。在以太网帧中，最小帧长度为64字节，如果ARP请求或应答数据包的长度不足64字节，则需要用填充位将其填充到最小帧长度。(其中的数据长度为46字节)

> 应答的时候
>
> 1. 源和目的反向(IP和AMC)
> 2. 把之前的掩码和未知填充位自己的MAC地址

以太网首部：目的主机采用广播地址，源主机的MAC地址是00:05:5d:61:58:a8，上层协议类型0x0806表示ARP。

ARP帧：硬件类型0x0001表示以太网，协议类型0x0800表示IP协议，硬件地址（MAC地址）长度为6，协议地址（IP地址）长度为4，op为0x0001表示请求目的主机的MAC地址，源主机MAC地址为00:05:5d:61:58:a8，源主机IP地址为c0 a8 00 37（192.168.0.55），目的主机MAC地址全0待填写，目的主机IP地址为c0 a8 00 02（192.168.0.2）。

由于以太网规定最小数据长度为46字节，ARP帧长度只有28字节，因此有18字节填充位，填充位的内容没有定义，与具体实现相关。

应答帧如下：

以太网首部

0000: 00 05 5d 61 58 a8 00 05 5d a1 b8 40 08 06

> 00 05 5d 61 58 a8 : 获取的对方的MAC地址
>
> 00 05 5d a1 b8 40 : 自己的MAC地址
>
> 08 06 : 模式

ARP帧

0000: 00 01

0010: 08 00 06 04 00 02 00 05 5d a1 b8 40 c0 a8 00 02

0020: 00 05 5d 61 58 a8 c0 a8 00 37

> 00 01 : 以太网
>
> 08 00 : 解析ip
>
> 06 04 : 两个长度
>
> 00 02 : 应答
>
> 00 05 5d a1 b8 40 : 发送端地址(自己的地址)
>
> c0 a8 00 02 : 自己的IP地址
>
> 00 05 5d 61 58 a8 : 这一个是对方的MAC(请求MAC的那一方)
>
> c0 a8 00 37 对方的IP

填充位

0020: 00 77 31 d2 50 10

0030: fd 78 41 d3 00 00 00 00 00 00 00 00

以太网首部：目的主机的MAC地址是00:05:5d:61:58:a8，源主机的MAC地址是00:05:5d:a1:b8:40，上层协议类型0x0806表示ARP。

ARP帧：硬件类型0x0001表示以太网，协议类型0x0800表示IP协议，硬件地址（MAC地址）长度为6，协议地址（IP地址）长度为4，op为0x0002表示应答，源主机MAC地址为00:05:5d:a1:b8:40，源主机IP地址为c0 a8 00 02（192.168.0.2），目的主机MAC地址为00:05:5d:61:58:a8，目的主机IP地址为c0 a8 00 37（192.168.0.55）。

### IP段格式

> IP协议主要用于IP地址的保存

![img](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202404022254601.jpg)

IP数据报格式

+ IP数据报的首部长度和数据长度都是可变长的，但总是4字节的整数倍。
+ 对于IPv4，4位版本字段是4。
+ 4位首部长度的数值是以4字节为单位的，最小值为5，也就是说首部长度最小是4x5=20字节，也就是不带任何选项的IP首部，4位能表示的最大值是15，也就是说首部长度最大是60字节。
+ 8位TOS字段有3个位用来指定IP数据报的优先级（目前已经废弃不用），还有4个位表示可选的服务类型（最小延迟、最大?吐量、最大可靠性、最小成本），还有一个位总是0。
+ 总长度是整个数据报（包括IP首部和IP层payload）的字节数。
+ 每传一个IP数据报，16位的标识加1，可用于分片和重新组装数据报。
+ 3位标志和13位片偏移用于分片。
+ TTL（Time to live)是这样用的：源主机为数据包设定一个生存时间，比如64，每过一个路由器就把该值减1，如果减到0就表示路由已经太长了仍然找不到目的主机的网络，就丢弃该包，因此这个生存时间的单位不是秒，而是跳（hop）。
+ 协议字段指示上层协议是TCP、UDP、ICMP还是IGMP。
+ 然后是校验和，只校验IP首部，数据的校验由更高层协议负责。IPv4的IP地址长度为32位。

> [TCP/IP协议详解 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/33889997)

> IP地址: 标识唯一的一台主机
>
> 端口号: 一台主机标识唯一的进程

### UDP数据报格式

> 和TCP协议的主要作用是端口号的选择

![img](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202404032022936.jpg)

UDP数据段

下面分析一帧基于UDP的TFTP协议帧。

以太网首部

0000: 00 05 5d 67 d0 b1 00 05 5d 61 58 a8 08 00

IP首部

0000: 45 00

0010: 00 53 93 25 00 00 80 11 25 ec c0 a8 00 37 c0 a8

0020: 00 01

UDP首部

0020： 05 d4 00 45 00 3f ac 40

TFTP协议

0020: 00 01 'c'':''\''q'

0030: 'w''e''r''q''.''q''w''e'00 'n''e''t''a''s''c''i'

0040: 'i'00 'b''l''k''s''i''z''e'00 '5''1''2'00 't''i'

0050: 'm''e''o''u''t'00 '1''0'00 't''s''i''z''e'00 '0'

0060: 00以太网首部：源MAC地址是00:05:5d:61:58:a8，目的MAC地址是00:05:5d:67:d0:b1，上层协议类型0x0800表示IP。

IP首部：每一个字节0x45包含4位版本号和4位首部长度，版本号为4，即IPv4，首部长度为5，说明IP首部不带有选项字段。服务类型为0，没有使用服务。16位总长度字段（包括IP首部和IP层payload的长度）为0x0053，即83字节，加上以太网首部14字节可知整个帧长度是97字节。IP报标识是0x9325，标志字段和片偏移字段设置为0x0000，就是DF=0允许分片，MF=0此数据报没有更多分片，没有分片偏移。TTL是0x80，也就是128。上层协议0x11表示UDP协议。IP首部校验和为0x25ec，源主机IP是c0 a8 00 37（192.168.0.55），目的主机IP是c0 a8 00 01（192.168.0.1）。

UDP首部：源端口号0x05d4（1492）是客户端的端口号，目的端口号0x0045（69）是TFTP服务的well-known端口号。UDP报长度为0x003f，即63字节，包括UDP首部和UDP层pay-load的长度。UDP首部和UDP层payload的校验和为0xac40。

TFTP是基于文本的协议，各字段之间用字节0分隔，开头的00 01表示请求读取一个文件，接下来的各字段是：

c:\qwerq.qwe

netascii

blksize 512

timeout 10

tsize 0

一般的网络通信都是像TFTP协议这样，通信的双方分别是客户端和服务器，客户端主动发起请求（上面的例子就是客户端发起的请求帧），而服务器被动地等待、接收和应答请求。客户端的IP地址和端口号唯一标识了该主机上的TFTP客户端进程，服务器的IP地址和端口号唯一标识了该主机上的TFTP服务进程，由于客户端是主动发起请求的一方，它必须知道服务器的IP地址和TFTP服务进程的端口号，所以，一些常见的网络协议有默认的服务器端口，例如HTTP服务默认TCP协议的80端口，FTP服务默认TCP协议的21端口，TFTP服务默认UDP协议的69端口（如上例所示）。在使用客户端程序时，必须指定服务器的主机名或IP地址，如果不明确指定端口号则采用默认端口，请读者查阅ftp、tftp等程序的man page了解如何指定端口号。/etc/services中列出了所有well-known的服务端口和对应的传输层协议，这是由IANA（Internet Assigned Numbers Authority）规定的，其中有些服务既可以用TCP也可以用UDP，为了清晰，IANA规定这样的服务采用相同的TCP或UDP默认端口号，而另外一些TCP和UDP的相同端口号却对应不同的服务。

很多服务有well-known的端口号，然而客户端程序的端口号却不必是well-known的，往往是每次运行客户端程序时由系统自动分配一个空闲的端口号，用完就释放掉，称为ephemeral的端口号，想想这是为什么？

前面提过，UDP协议不面向连接，也不保证传输的可靠性，例如：

发送端的UDP协议层只管把应用层传来的数据封装成段交给IP协议层就算完成任务了，如果因为网络故障该段无法发到对方，UDP协议层也不会给应用层返回任何错误信息。

接收端的UDP协议层只管把收到的数据根据端口号交给相应的应用程序就算完成任务了，如果发送端发来多个数据包并且在网络上经过不同的路由，到达接收端时顺序已经错乱了，UDP协议层也不保证按发送时的顺序交给应用层。

通常接收端的UDP协议层将收到的数据放在一个固定大小的缓冲区中等待应用程序来提取和处理，如果应用程序提取和处理的速度很慢，而发送端发送的速度很快，就会丢失数据包，UDP协议层并不报告这种错误。

因此，使用UDP协议的应用程序必须考虑到这些可能的问题并实现适当的解决方案，例如等待应答、超时重发、为数据包编号、流量控制等。一般使用UDP协议的应用程序实现都比较简单，只是发送一些对可靠性要求不高的消息，而不发送大量的数据。例如，基于UDP的TFTP协议一般只用于传送小文件（所以才叫trivial的ftp），而基于TCP的FTP协议适用于  各种文件的传输。TCP协议又是如何用面向连接的服务来代替应用程序解决传输的可靠性问题呢。

### TCP数据报格式

![img](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202404032022193.jpg)

TCP数据段

+ 与UDP协议一样也有源端口号和目的端口号，通讯的双方由IP地址和端口号标识。
+ 32位序号: 以一个随机数为起始, 每一次加上数据的长度
+ 32位确认序号: 发送期望得到的数据的起始位置
+ 4位首部长度和IP协议头类似，表示TCP协议头的长度，以4字节为单位，因此TCP协议头最长可以是4x15=60字节，如果没有选项字段，TCP协议头最短20字节。
+ URG、ACK、PSH、RST、SYN、FIN是六个控制位

> - ACK：确认序号有效
> - RST：重置连接
> - SYN：发起了一个新连接
> - FIN：释放一个连接
> - PSH: 当 PSH = 1 的时候，表示该报文段高优先级

+ 16位窗口: 告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据
+ 16位检验和将TCP协议头和数据都计算在内。
+ 紧急指针: 仅在 URG = 1 时才有意义，它指出本报文段中的紧急数据的字节数。
+ 各种选项

## TCP协议

发送数据的时候, 每一个数据都必须得到对方的应答, 有超时重传, 错误校验以及流量管理

在传输指之前需要建立连接

### TCP通信时序

下图是一次TCP通讯的时序图。TCP连接建立断开。包含大家熟知的**三次握手**和四次挥手。

<img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202404042155205.png" alt="img" style="zoom:200%;" />

#### 三次握手

![image-20240404220524603](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202404042205645.png)

> SYN: 请求建立连接
>
> 1000(0), 一个随机的额起始位置, 以及数据的大小为0
>
> <mss 1460>可以接受的信息的大小, 这一个1460是一个以太网帧减去各种头部以后实际可以携带的数据大小

> SYN请求建立连接
>
> 8000(0)一个随机的起始位置, 数据大小为1
>
> ACK应答标志位
>
> 1001表示下一次希望获取的数据

> ASK请求8001

在这个例子中，首先客户端主动发起连接、发送请求，然后服务器端响应请求，然后客户端主动关闭连接。两条竖线表示通讯的两端，从上到下表示时间的先后顺序，注意，数据从一端传到网络的另一端也需要时间，所以图中的箭头都是斜的。双方发送的段按时间顺序编号为1-10，各段中的主要信息在箭头上标出

建立连接（三次握手）的过程：

1. 客户端发送一个带SYN标志的TCP报文到服务器。这是三次握手过程中的段1。

客户端发出段1，SYN位表示连接请求。序号是1000，这个序号在网络通讯中用作临时的地址，每发一个数据字节，这个序号要加1，这样在接收端可以根据序号排出数据包的正确顺序，也可以发现丢包的情况，另外，规定SYN位和FIN位也要占一个序号，这次虽然没发数据，但是由于发了SYN位，因此下次再发送应该用序号1001。mss表示最大段尺寸，如果一个段太大，封装成帧后超过了链路层的最大帧长度，就必须在IP层分片，为了避免这种情况，客户端声明自己的最大段尺寸，建议服务器端发来的段不要超过这个长度。

2. 服务器端回应客户端，是三次握手中的第2个报文段，同时带ACK标志和SYN标志。它表示对刚才客户端SYN的回应；同时又发送SYN给客户端，询问客户端是否准备好进行数据通讯。

服务器发出段2，也带有SYN位，同时置ACK位表示确认，确认序号是1001，表示“我接收到序号1000及其以前所有的段，请你下次发送序号为1001的段”，也就是应答了客户端的连接请求，同时也给客户端发出一个连接请求，同时声明最大尺寸为1024。

3. 客户必须再次回应服务器端一个ACK报文，这是报文段3。

客户端发出段3，对服务器的连接请求进行应答，确认序号是8001。在这个过程中，客户端和服务器分别给对方发了连接请求，也应答了对方的连接请求，其中服务器的请求和应答在一个段中发出，因此一共有三个段用于建立连接，称为“三方握手（three-way-handshake）”。在建立连接的同时，双方协商了一些信息，例如双方发送序号的初始值、最大段尺寸等。**这一次是可以带数据的, 但是通常情况不会带**

> 这三次的操作是内核完成的, 实际的用户对用的函数是accept和connect, 这两个成功执行返回
>
> 建立三次握手主要是因为A发送了再一次的确认，那么A为什么会再确认一次呢，主要是为了防止已失效的连接请求报文段又突然传送给B，从而产生了错误。
>
> 如果采用两次握手会出现以下情况：
> 客户端向服务器端发送的请求报文由于网络等原因滞留，未能发送到服务器端，此时连接请求报文失效，客户端会再次向服务器端发送请求报文，之后与服务器端建立连接，当连接释放后，由于网络通畅了，第一次客户端发送的请求报文又突然到达了服务器端，这条请求报文本该失效了，但此时服务器端误认为客户端又发送了一次连接请求，两次握手建立好连接，此时客户端忽略服务器端发来的确认，也不发送数据，造成不必要的错误和网络资源的浪费。
>
> 如果采用三次握手的话，就算那条失效的报文发送到服务器端，服务器端确认并向客户端发送报文，但此时客户端不会发出确认，由于客户端没有确认，由于服务器端没有接收到确认，就会知道客户端没有请求连接。
>

> 在TCP通讯中，如果一方收到另一方发来的段，读出其中的目的端口号，发现本机并没有任何进程使用这个端口，就会应答一个包含RST位的段给另一方。例如，服务器并没有任何进程使用8080端口，我们却用telnet客户端去连接它，服务器收到客户端发来的SYN段就会应答一个RST段，客户端的telnet程序收到RST段后报告错误Connection refused：
>
> ```bash
> $ telnet 192.168.0.200 8080
> 
> Trying 192.168.0.200...
> 
> telnet: Unable to connect to remote host: Connection refused
> ```

#### 数据传输的过程

![image-20240404220957665](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202404042209704.png)

1. 客户端发出段4，包含从序号1001开始的20个字节数据。
2. 服务器发出段5，确认序号为1021，对序号为1001-1020的数据表示确认收到，同时请求发送序号1021开始的数据，服务器在应答的同时也向客户端发送从序号8001开始的10个字节数据，这称为piggyback。
3. 客户端发出段6，对服务器发来的序号为8001-8010的数据表示确认收到，请求发送序号8011开始的数据。

在数据传输过程中，ACK和确认序号是非常重要的，应用程序交给TCP协议发送的数据会暂存在TCP层的发送缓冲区中，发出数据包给对方之后，只有收到对方应答的ACK段才知道该数据包确实发到了对方，可以从发送缓冲区中释放掉了，如果因为网络故障丢失了数据包或者丢失了对方发回的ACK段，经过等待超时后TCP协议自动将发送缓冲区中的数据包重发。

##### 滑动窗口 (TCP流量控制)

> 实际使用的时候不需要对每一次的信息都回应
>
> <img src="https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202404042258827.png" alt="img" style="zoom:150%;" />

1. 发送端发起连接，声明最大段尺寸是1460，初始序号是0，窗口大小是4K，表示“我的接收缓冲区还有4K字节空闲，你发的数据不要超过4K”。

2. 接收端应答连接请求，声明最大段尺寸是1024，初始序号是8000，窗口大小是6K。发送端应答，三方握手结束。发送端发出段4-9，每个段带1K的数据，发送端根据窗口大小知道接收端的缓冲区满了，因此停止发送数据。

   > 在回应之前客户端已经发送了很多数据, 回应6145, 表示在这之前的所有数据都收到了, 不需要回应每一次发送

3. 接收端的应用程序提走2K数据，接收缓冲区又有了2K空闲，接收端发出段10，在应答已收到6K数据的同时声明窗口大小为2K。

4. 接收端的应用程序又提走2K数据，接收缓冲区有4K空闲，接收端发出段11，重新声明窗口大小为4K。

5. 发送端发出段12-13，每个段带2K数据，段13同时还包含FIN位。

6. 接收端应答接收到的2K数据（6145-8192），再加上FIN位占一个序号8193，因此应答序号是8194，连接处于半关闭状态，接收端同时声明窗口大小为2K。

7. 接收端的应用程序提走2K数据，接收端重新声明窗口大小为4K。

8. 接收端的应用程序提走剩下的2K数据，接收缓冲区全空，接收端重新声明窗口大小为6K。

9. 接收端的应用程序在提走全部数据后，决定关闭连接，发出段17包含FIN位，发送端应答，连接完全关闭。

> 上图在接收端用小方块表示1K数据，实心的小方块表示已接收到的数据，虚线框表示接收缓冲区，因此套在虚线框中的空心小方块表示窗口大小，从图中可以看出，随着应用程序提走数据，虚线框是向右滑动的，因此称为滑动窗口。

> 从这个例子还可以看出，发送端是一K一K地发送数据，而接收端的应用程序可以两K两K地提走数据，当然也有可能一次提走3K或6K数据，或者一次只提走几个字节的数据。也就是说，应用程序所看到的数据是一个整体，或说是一个流（stream），在底层通讯中这些数据可能被拆成很多数据包来发送，但是一个数据包有多少字节对应用程序是不可见的，因此TCP协议是面向流的协议。而UDP是面向消息的协议，每个UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据，这一点和TCP是很不同的。

#### 关闭连接

![image-20240404230622514](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202404042306557.png)

由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

1. 客户端发出段7，FIN位表示关闭连接的请求。
2. 服务器发出段8，应答客户端的关闭连接请求。
3. 服务器发出段9，其中也包含FIN位，向客户端发送关闭连接请求。
4. 客户端发出段10，应答服务器的关闭连接请求。

建立连接的过程是三方握手，而关闭连接通常需要4个段，服务器的应答和关闭连接请求通常不合并在一个段中，因为有连接半关闭的情况，这种情况下客户端关闭连接之后就不能再发送数据给服务器了，但是服务器还可以发送数据给客户端，直到服务器也关闭连接为止。

> 这一个协议支持半关闭, 这个时候信息的传递是单向的
>
> ![image-20240405101403060](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202404051014315.png)
>
> 这两次会关闭发起者的读缓冲区, 以及接受者的写缓冲区, 关闭的不是套接字, 所以还可以发送信息
>
> 所以需要关闭两次

##### 半关闭

当TCP链接中A发送FIN请求关闭，B端回应ACK后（A端进入FIN_WAIT_2状态），B没有立即发送FIN给A时，A方处在半链接状态，此时A可以接收B发送的数据，但是A已不能再向B发送数据。

从程序的角度，可以使用API来控制实现半连接状态。

```c
#include <sys/socket.h>

int shutdown(int sockfd, int how);
```

> sockfd: 需要关闭的socket的描述符
>
> how:  允许为shutdown操作选择以下几种方式:
>
> SHUT_RD(0)：  关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。
>
> ​          该套接字**不再接收数据**，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。
>
>   SHUT_WR(1):   关闭sockfd的写功能，此选项将不允许sockfd进行写操作。进程不能在对此套接字发出写操作。
>
>   SHUT_RDWR(2):  关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD,然后以SHUT_WR。

使用close中止一个连接，但它只是减少描述符的引用计数，并不直接关闭连接，只有当描述符的引用计数为0时才关闭连接。

**shutdown** **不考虑描述符的引用计数，直接关闭描述符**。也可选择中止一个方向的连接，只中止读或只中止写。

注意:

1. 如果有多个进程共享一个套接字，close每被调用一次，计数减1，直到计数为0时，也就是所用进程都调用了close，套接字将被释放。 
2. 在多进程中如果一个进程调用了shutdown(sfd, SHUT_RDWR)后，其它的进程将无法进行通信。但，如果一个进程close(sfd)将不会影响到其它进程。

### TCP状态转换

这个图N多人都知道，它排除和定位网络或系统故障时大有帮助，但是怎样牢牢地将这张图刻在脑中呢？那么你就一定要对这张图的每一个状态，及转换的过程有深刻的认识，不能只停留在一知半解之中。下面对这张图的11种状态详细解析一下，以便加强记忆！不过在这之前，先回顾一下TCP建立连接的三次握手过程，以及 关闭连接的四次握手过程。

![img](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202404061029712.jpg)

TCP状态转换图

**CLOSED：**表示初始状态。

**LISTEN：**该状态表示服务器端的某个SOCKET处于监听状态，可以接受连接。

**SYN_SENT：**这个状态与SYN_RCVD遥相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，随即进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。

**SYN_RCVD:** 该状态表示接收到SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂。此种状态时，当收到客户端的ACK报文后，会进入到ESTABLISHED状态。

**ESTABLISHED：**表示连接已经建立。

**FIN_WAIT_1:** FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。区别是：

FIN_WAIT_1状态是当socket在ESTABLISHED状态时，想主动关闭连接，向对方发送了FIN报文，此时该socket进入到FIN_WAIT_1状态。

FIN_WAIT_2状态是当对方回应ACK后，该socket进入到FIN_WAIT_2状态，正常情况下，对方应马上回应ACK报文，所以FIN_WAIT_1状态一般较难见到，而FIN_WAIT_2状态可用netstat看到。

**FIN_WAIT_2**：主动关闭链接的一方，发出FIN收到ACK以后进入该状态。称之为半连接或半关闭状态。该状态下的socket只能接收数据，不能发。

**TIME_WAIT:** 表示收到了对方的FIN报文，并发送出了ACK报文，等2MSL后即可回到CLOSED可用状态。如果FIN_WAIT_1状态下，收到对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。

> 发完最后一个ASK以后, 需要等待看对方有没有收到, 没有收到的话, 对方会一直发送FIN信号过来
>
> 在这一个等待的时长的时候可以使用setsockopt函数进行端口的复用, 提高用户体验

**CLOSING:** 这种状态较特殊，属于一种较罕见的状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。

**CLOSE_WAIT:** 此种状态表示在等待关闭。当对方关闭一个SOCKET后发送FIN报文给自己，系统会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，察看是否还有数据发送给对方，如果没有可以 close这个SOCKET，发送FIN报文给对方，即关闭连接。所以在CLOSE_WAIT状态下，需要关闭连接。

**LAST_ACK:** 该状态是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，即可以进入到CLOSED可用状态。

> ![image-20240406110413693](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202404061104813.png)

> 可以使用命令`netstate | grep 端口号`查看对应端口的端口号
>
> ![image-20240406110828198](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202404061108232.png)



## C/S模型

client-server:客户端-服务器模型

### 优缺点

可以缓存大量数据, 加载快, 可以自定义协议, 方便迭代

安转的程序不可控, 安全性比较低

## B/S模型

browser-server: 浏览器服务器

### 优缺点

不能缓存大量的数据, 严格遵循http, 可以跨平台, 开发的工作量比较小

## TCP/UDP优缺点

TCP: 面向连接, 可靠的数据包传输 对不稳定的网络层, 采取完全弥补的通信方式 丢包重传

+ 优点

稳定, 数据流量稳定, 数据传输的速度稳定, 传输的顺序稳定

+ 缺点

发送的速度慢, 效率比较低, 系统资源开销比较大

+ 使用场景

对数据的完整性要求比较高, 不追求效率

> 大数据传输, 文件传输

UDP: 无连接的, 不可靠的传输 对网络不稳定的网络层, 采用完全不弥补的方式 默认还原网络状况

+ 优点

速度快, 效率高, 系统开销小

+ 缺点

不稳定, 数据的流量以及速度, 顺序不一定正确

+ 使用场景

时效性比较高的, 稳定性其次

> 游戏, 直播, 视频电话

> 企业使用的时候, 一般会直接使用TCP协议, 通过提高服务器的性能之类的方法达到提高效率的作用
>
> 但是腾讯, 华为, 阿里之类的公司会使用UDP, 在应用层校验来弥补UDP的不足

## 网络通信过程

+ 最简单的网络

使用网络的时候, 使用两根线把两台电脑连接起来, 之后设置一个ip地址, 两个设备之间就可以通信了

> ip地址: 电脑的身份证
>
> 掩码: ip | mask获取的数字如果是一样的话这两个电脑在同一个局域网里面, 可以直接通信

如果电脑只有一个网卡的时候, 只有两个电脑可以通过这一个方式进行通信

+ 交换机

把很多的网线连接到这一个交换机, 直到这一个交换机的上限

这个时候使用ping命令和另一个交换机进行通信, 首先发送一个ARP信息给交换机, 这一个ARP会被叫交换机发送给每一个连接的机器去获取目标机器的MAC地址(这个时候只知道对方的ip地址)

网络在通信的时候需要有对方的网卡的物理地址, 目标的网卡收到数据以后会使用这一个MAC地址判断是不是发送给自己的数据, 因为不同的局域网里面可能会由相同的ip地址

之后这一个电脑就可以给对方发送ICMP数据包从而进行通信, 一般来说一次ping会发送4次ICMP数据包

> 交换机: 可以把多个设备连接为一个局域网, 但是不能连接多个局域网

+ 路由器

用于连接不同的局域网, 一个路由器可以处于不同的局域网里面, 使用不同的网卡进入不同的局域网, 从一个网卡收数据, 另一个网卡把数据发送出去, 从而实现不同局域网之间的通信

实际使用的时候需要把交换机的网卡ip设置为它连接的那一个局域网里面的一个ip

在发送的时候如果发现这一个ip地址不是在这一个局域网里面, 会发送给默认网关(Gateway)

在实际ping的时候ARP命令获取的是路由器的MAC地址, 之后发送ICMP信号的时候传给路由器之后路由器会把这一个信息丢弃, 然后发送一个ARP信号去获取实际对象的MAC地址, 路由器获取以后会记录获取到的MAC地址

第二个ICMP信息才会发送给目标对象

> 不同的路由器之间可以直接连接, 但是需要记录其他的路由器的ip以及对应的局域网的范围
>
> 在实际的数据传输的时候MAC地址记录的是下一站的地址, ip地址记录是最终的目的地的IP地址, MAC地址会随着路由器的通信而变化

### 服务器功能

+ DHCP

用于自动分配ip地址

+ TFTP

文件传输

+ DNS

域名解析, 记录域名以及对应的ip地址

这一个记录的ip地址的主机号一般为0, 代表网络号

+ HTTP

网页处理

### 访问网页的过程

1. 发送一个DNS数据包, 会把这一个数据包发送给DNS服务器

![image-20240513230919005](https://picture-01-1316374204.cos.ap-beijing.myqcloud.com/image/202405132309145.png)

2. 如果路由器里面没有记录这一个DNS服务的MAC地址, 会丢弃数据转而发送ARP命令
3. 浏览器发现超时以后会再次发送DNS, DNA服务器收到以后会回复一个DNS信息, 里面有对应的ip地址
4. 获取以后开始进行三次握手
5. 之后发送http信息(依附于TCP协议)
