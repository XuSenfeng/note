---
layout: post
title: "线程" 
date:   2023-6-18 15:39:08 +0800
tags: 操作系统
---

# 线程

![image-20230622110243256](E:\a学习\笔记\img\image-20230622110243256.png)

没有进程之前, 系统只能串行执行, 引入进程之后就可以

进程是一个程序的一次执行, 一个进程不能同时完成多种任务, 同时处理多种事务的时候, 线程用来增加系统的并发度

CPU轮流执行线程

, CPU服务的对象变为进程的线程, 进程中有一定的线程, 并发执行, 程序执行流的最小单位,轻量级进程, 进程还是CPU资源调度的基本单位

## 变化

+   资源分配、调度
+   +   资源分配调度的基本单位
    +   引入线程、线程是调度的基本单位
+   并发性
+   系统开销
+   +   进程切换，切换运行环境， 系统开销大
    +   线程并发， 线程切换不需要切换进程环境，系统开销小
    +   开发带来的开销小



## 属性

线程的属性

+   处理机调度单位
+   多CPU计算机各个线程占据不同的CPU
+   每一个线程都有线程ID，线程控制模块TCP
+   线程也有就绪， 阻塞， 运行三种状态
+   线程基本不拥有系统资源
+   同一进程的不同线程共享进程的资源
+   共享内存空间，通讯不需要系统参与
+   同一进程的线程切换不会使进程切换
+   不同进程线程切换会导致进程切换
+   切换同进程线程系统开销小
+   切换进程系统开销大

## 实现方式

+   线程
+   +   用户级线程
    +   内核级线程
+   多线程模型
+   +   一对一模型
    +   多对一模型
    +   多对多模型

### 用户级线程

![image-20230622161158693](E:\a学习\笔记\img\image-20230622161158693.png)

最早的线程, 早期的操作系统只支持进程, 由程序员的线程库实现, 操作系统看到的还是进程

线程的切换是用户态进行的, 不需要操作系统的管理

+   优点: 不需要CPU切换状态
+   缺点: 如果线程阻塞, 其他的线程也会被阻塞, 不能在多个核上面并行运行

### 内核级线程

KLT: 管理工作实际是操作系统来完成, 需要操作系统转换为内核态

+   优点: 处理机调度基本单位, 可以使用多个内核, 线程阻塞其他的正常进行
+   缺点: 进程对应多个线程, CPU变态管理成本更高

用户级线程和内核级线程的映射关系

#### 一对一

![image-20230622161604459](E:\a学习\笔记\img\image-20230622161604459.png)

一个用户级线程对应一个系统级线程, 一个线程被阻塞别的线程正常进行, 并发能力强, 但是占用内核级线程多, 管理成本大

#### 多对一

多个用户级线程对应一个内核级线程

![image-20230622155738885](E:\a学习\笔记\img\image-20230622155738885.png)

优点, 用户级线程在用户空间进行切换, 管理系统开销比较小, 开销比较小, 但是一个用户级线程阻塞之后整个进程被阻塞, 并发性不高, 不能并行运行

#### 多线程模型

多对多, n个用户级进程映射到m个内核级进程(n>=m)

![image-20230622160037936](E:\a学习\笔记\img\image-20230622160037936.png)

克服了多对一并发性不高的缺点, 克服了一对一线程中一个用户占用太多内核级进程, 开销太大, 只有所有都被阻塞才会被称为阻塞态, 分配资源是以内核级线程为单元

## 状态和转换

![image-20230622162023025](E:\a学习\笔记\img\image-20230622162023025.png)

### 组织与控制

![image-20230622162144062](E:\a学习\笔记\img\image-20230622162144062.png)

多个TCB组装成线程表=>组织

在不同的状态来回切换=>控制



















