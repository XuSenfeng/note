{"/note/Linux/野火Linux/2025-9-26-33-SPI使用.html":{"title":"","content":"## spidev：SPI“万能”驱动 + 需要注意两个结构体, `spi_device`以及`spi_driver` + `spi_device`是读取设备树和驱动匹配的时候自动生成的 + `spi_driver`是实际需要自己实现的部分, 里面的probe是在匹配以后执行的函数, 替代`platform_driver`, 在probe函数参数可以获得实际使用的`spi_device` + 初始化`spi_message`结构体收发消息 >`spi_message_init`, 里面的每一个信息使用`spi_transfer`描述 + 添加具体的信息(`spi_transfer`)到`spi_message`里面`spi_message_add_tail` + 把信息添加到队列里面 >`spi_message_add_tail` + 同步异步传输 >`spi_sync/spi_async` > 上面的传输可以使用`spi_write`以及`spi_read`函数替代 > > 在使用官方的cs软件片选的时候, 一次操作不要分为多个函数, 否则片选引脚拉低会中断, , 可以使用`spi_write_then_read`函数 #### 设备树节点 arch/arm/boot/dts/imx6ull seeed npi.dts ##### pinctrl子节点 ```json \tpinctrl_ecspi3:ecspi3grp { \t\t\t\t\tfsl,pins < \t\t\t\t\t\tMX6UL_PAD_UART2_TX_DATA__ECSPI3_SS0 0x1a090 \t\t\t\t\t\tMX6UL_PAD_UART2_RX_DATA__ECSPI3_SCLK\t\t0x11090 \t\t\t\t\t\tMX6UL_PAD_UART2_CTS_B__ECSPI3_MOSI\t\t\t0x11090 \t\t\t\t\t\tMX6UL_PAD_UART2_RTS_B__ECSPI3_MISO\t\t\t0x11090 \t\t\t\t\t>; \t}; ``` 如果使用的软件片选, 片片选引脚的复用可以设置为gpio ##### spidev子节点 ecspi相关属性的描述记录在文件Documentation/devicetree/bindings/spi/fsl imx cspi.txt里面, 子节点对应的具体的设备的描述Documentation/devicetree/bindings/spi/spi bus.txt ```json &ecspi3{ \tpinctrl names \"default\"; \tpinctrl 0 <&pinctrl_ecspi3>; \tstatus \"okay\"; \t#address cells <1>; \t#size cells <0>; \tspidev@0 { \t\tcompatible \"spidev\"; \t\tspi max frequency <20000000>; \t\treg <0>; \t}; }; ``` > Required properties: **espi节点使用的参数的描述** > compatible : > \"fsl,imx1 cspi\" for SPI compatible with the one integrated on i.MX1 > \"fsl,imx21 cspi\" for SPI compatible with the one integrated on i.MX21 > \"fsl,imx27 cspi\" for SPI compatible with the one integrated on i.MX27 > \"fsl,imx31 cspi\" for SPI compatible with the one integrated on i.MX31 > \"fsl,imx35 cspi\" for SPI compatible with the one integrated on i.MX35 > \"fsl,imx51 ecspi\" for SPI compatible with the one integrated on i.MX51 > reg : Offset and length of the register set for the device > interrupts : Should contain CSPI/eCSPI interrupt > fsl,spi num chipselects : Contains the number of the chipselect 片选信号的数量 > cs gpios : Specifies the gpio pins to be used for chipselects. 实际使用的片选引脚, 使用的是软件片选, 需要复用为gpio使用 > clocks : Clock specifiers for both ipg and per clocks. > clock names : Clock names should include both \"ipg\" and \"per\" > \tSee the clock consumer binding, > \tDocumentation/devicetree/bindings/clock/clock bindings.txt > dmas: DMA specifiers for tx and rx dma. See the DMA client binding, > \t\tDocumentation/devicetree/bindings/dma/dma.txt > dma names: DMA request names should include \"tx\" and \"rx\" if present. > The SPI master node requires the following properties: **作为主机子节点的需要的属性(部分)** > #address cells number of cells required to define a chip select > \t\taddress on the SPI bus. > #size cells should be zero. > compatible name of SPI bus controller following generic names > \t\trecommended practice. > > SPI slave nodes must be children of the SPI master node and can > contain the following properties. **作为从机使用的属性** > > **reg** (required) chip select address of device. 使用的硬件片选信号 > **compatible** (required) name of SPI device following generic names > \t\trecommended practice > **spi max frequency** (required) Maximum SPI clocking speed of device in Hz 时钟频率 > spi cpol (optional) Empty property indicating device requires > \t\tinverse clock polarity (CPOL) mode > spi cpha (optional) Empty property indicating device requires > \t\tshifted clock phase (CPHA) mode > spi cs high (optional) Empty property indicating device requires > \t\tchip select active high > spi 3wire (optional) Empty property indicating device requires > \t\t 3 wire mode. > spi lsb first (optional) Empty property indicating device requires > \t\tLSB first mode. > spi tx bus width (optional) The bus width(number of data wires) that > used for MOSI. Defaults to 1 if not present. > spi rx bus width (optional) The bus width(number of data wires) that > used for MISO. Defaults to 1 if not present. #### spidev_init()函数 一个实际的设备匹配到的位置 ```c static int __init spidev_init(void) { \tint status; \t... // 获取153号设备号的主设备号 \tstatus register_chrdev(SPIDEV_MAJOR, \"spi\", &spidev_fops); \t... \tspidev_class class_create(THIS_MODULE, \"spidev\"); // 创建一个类 \t... \tstatus spi_register_driver(&spidev_spi_driver); // 注册一个设备 \t... \treturn status; } ``` ##### spidev_fops文件操作接口 ```c static const struct file_operations spidev_fops { \t.owner \tTHIS_MODULE, \t.write \tspidev_write, \t.read \t\tspidev_read, \t.unlocked_ioctl spidev_ioctl, \t.compat_ioctl spidev_compat_ioctl, \t.open \t\tspidev_open, \t.release \tspidev_release, \t.llseek \tno_llseek, }; ``` unlocked_ioctl：ioctl()函数底层操作接口(32位系统) compat_ioctl：ioctl()函数底层操作接口(64位系统) #### ioctl()函数 ```c #include <sys/ioctl.h> int ioctl(int d,int request,...) ``` 参数： d：要控制的文件描述符 request：控制命令 返回值： 成功：0 失败： 1 #### spidev_probe()函数 创建字符设备 次设备号按位图分配 设备文件名后缀数字的含义 spi控制器编号 spi设备片选信号编号 ```c static int spidev_probe(struct spi_device *spi) { \tstruct spidev_data\t*spidev; \tint\t\t\tstatus; \tunsigned long\t\tminor; \t... \t/* Allocate driver data */ \tspidev kzalloc(sizeof(*spidev), GFP_KERNEL); \tif (!spidev) \t\treturn ENOMEM; \t/* Initialize the driver data */ // 初始化基础的参数 \tspidev >spi spi; \tspin_lock_init(&spidev >spi_lock); \tmutex_init(&spidev >buf_lock); \tINIT_LIST_HEAD(&spidev >device_entry); \t/* If we can allocate a minor number, hook up this device. \t * Reusing minors is fine so long as udev or mdev is working. \t */ \tmutex_lock(&device_list_lock); // 分配一个次设备号 \tminor find_first_zero_bit(minors, N_SPI_MINORS); \tif (minor < N_SPI_MINORS) { \t\tstruct device *dev; \t\t// 记录实际的设备号 \t\tspidev >devt MKDEV(SPIDEV_MAJOR, minor); // 在class创建一个新的设备 \t\tdev device_create(spidev_class, &spi >dev, spidev >devt, \t\t\t\t spidev, \"spidev%d.%d\", \t\t\t\t spi >master >bus_num, spi >chip_select); // 使用设备的总线以及片选进行命名 \t\tstatus PTR_ERR_OR_ZERO(dev); \t} else { \t\tdev_dbg(&spi >dev, \"no minor number available!\\n\"); \t\tstatus ENODEV; \t} \tif (status 0) { \t\tset_bit(minor, minors); \t\tlist_add(&spidev >device_entry, &device_list); \t} \tmutex_unlock(&device_list_lock); \tspidev >speed_hz spi >max_speed_hz; // 初始化传输速率 \tif (status 0) \t\tspi_set_drvdata(spi, spidev); \telse \t\tkfree(spidev); \treturn status; } ``` ##### spidev_data结构体 记录一个设备树的节点 ```c struct spidev_data { \tdev_t\t\t\tdevt; \tspinlock_t\t\tspi_lock; \tstruct spi_device\t*spi; \tstruct list_head\tdevice_entry; \tstruct mutex\t\tbuf_lock; \tunsigned\t\tusers; \tu8\t\t\t*tx_buffer; // 发送接收buf \tu8\t\t\t*rx_buffer; \tu32\t\t\tspeed_hz; // 频率 }; ``` #### spidev_open()函数 为tx_buffer、rx_buffer分配4096字节内存 ```c static int spidev_open(struct inode *inode, struct file *filp) { \tstruct spidev_data\t*spidev; \tint\t\t\tstatus ENXIO; \tmutex_lock(&device_list_lock); \t// 记录所有spi设备的链表 \tlist_for_each_entry(spidev, &device_list, device_entry) { \t\tif (spidev >devt inode >i_rdev) { \t\t\tstatus 0; \t\t\tbreak; \t\t} \t} \tif (status) { \t\tpr_debug(\"spidev: nothing for minor %d\\n\", iminor(inode)); \t\tgoto err_find_dev; \t} \t// buf的分配 \tif (!spidev >tx_buffer) { \t\tspidev >tx_buffer kmalloc(bufsiz, GFP_KERNEL); \t\tif (!spidev >tx_buffer) { \t\t\tdev_dbg(&spidev >spi >dev, \"open/ENOMEM\\n\"); \t\t\tstatus ENOMEM; \t\t\tgoto err_find_dev; \t\t} \t} \tif (!spidev >rx_buffer) { \t\tspidev >rx_buffer kmalloc(bufsiz, GFP_KERNEL); \t\tif (!spidev >rx_buffer) { \t\t\tdev_dbg(&spidev >spi >dev, \"open/ENOMEM\\n\"); \t\t\tstatus ENOMEM; \t\t\tgoto err_alloc_rx_buf; \t\t} \t} \t// 记录在设备文件系统里面 \tspidev >users++; \tfilp >private_data spidev; \tnonseekable_open(inode, filp); // 不支持lseek指针 \tmutex_unlock(&device_list_lock); \treturn 0; err_alloc_rx_buf: \tkfree(spidev >tx_buffer); \tspidev >tx_buffer NULL; err_find_dev: \tmutex_unlock(&device_list_lock); \treturn status; } ``` #### spidev_read()函数 ```c static ssize_t spidev_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos) { \tstruct spidev_data\t*spidev; \tssize_t\t\t\tstatus 0; \t/* chipselect only toggles at start or end of operation */ // 读取的数据是不可以大于部分的 \tif (count > bufsiz) \t\treturn EMSGSIZE; \tspidev filp >private_data; \tmutex_lock(&spidev >buf_lock); \tstatus spidev_sync_read(spidev, count); // 同步读取 \tif (status > 0) { \t\tunsigned long\tmissing; \t\tmissing copy_to_user(buf, spidev >rx_buffer, status); \t\tif (missing status) \t\t\tstatus EFAULT; \t\telse \t\t\tstatus status missing; \t} \tmutex_unlock(&spidev >buf_lock); \treturn status; } ``` ##### spidev_sync_read()函数 ```c spidev_sync_read(struct spidev_data *spidev, size_t len) { // 读取的基础数据 \tstruct spi_transfer\tt { \t\t\t.rx_buf\t\t spidev >rx_buffer, \t\t\t.len\t\t len, \t\t\t.speed_hz\t spidev >speed_hz, \t\t}; \tstruct spi_message\tm; \tspi_message_init(&m); \tspi_message_add_tail(&t, &m); \treturn spidev_sync(spidev, &m); } ``` ##### spidev_sync()函数 ```c static ssize_t spidev_sync(struct spidev_data *spidev, struct spi_message *message) { \tint status; \tstruct spi_device *spi; \tspin_lock_irq(&spidev >spi_lock); \tspi spidev >spi; \tspin_unlock_irq(&spidev >spi_lock); \tif (spi NULL) \t\tstatus ESHUTDOWN; \telse \t\tstatus spi_sync(spi, message); // 实际的读取 \tif (status 0) \t\tstatus message >actual_length; \treturn status; } ``` #### spidev_ioctl()函数 ```c static long spidev_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) { \tint\t\t\tretval 0; \tstruct spidev_data\t*spidev; \tstruct spi_device\t*spi; \tu32\t\t\ttmp; \tunsigned\t\tn_ioc; \tstruct spi_ioc_transfer\t*ioc; \t... \tspidev filp >private_data; \tspin_lock_irq(&spidev >spi_lock); \tspi spi_dev_get(spidev >spi); \tspin_unlock_irq(&spidev >spi_lock); \t... // 处理不同的控制命令 \tswitch (cmd) { \t/* read requests */ \tcase SPI_IOC_RD_MODE: // 获取模式 \t\tretval put_user(spi >mode & SPI_MODE_MASK, \t\t\t\t\t(__u8 __user *)arg); \t\tbreak; \tcase SPI_IOC_RD_MODE32: \t\tretval put_user(spi >mode & SPI_MODE_MASK, \t\t\t\t\t(__u32 __user *)arg); \t\tbreak; \tcase SPI_IOC_RD_LSB_FIRST: \t\tretval put_user((spi >mode & SPI_LSB_FIRST) ? 1 : 0, \t\t\t\t\t(__u8 __user *)arg); \t\tbreak; \tcase SPI_IOC_RD_BITS_PER_WORD: \t\tretval put_user(spi >bits_per_word, (__u8 __user *)arg); \t\tbreak; \tcase SPI_IOC_RD_MAX_SPEED_HZ: \t\tretval put_user(spidev >speed_hz, (__u32 __user *)arg); \t\tbreak; \t/* write requests */ \tcase SPI_IOC_WR_MODE: \tcase SPI_IOC_WR_MODE32: \t\tif (cmd SPI_IOC_WR_MODE) \t\t\tretval get_user(tmp, (u8 __user *)arg); \t\telse \t\t\tretval get_user(tmp, (u32 __user *)arg); \t\tif (retval 0) { \t\t\tu32\tsave spi >mode; \t\t\tif (tmp & ~SPI_MODE_MASK) { \t\t\t\tretval EINVAL; \t\t\t\tbreak; \t\t\t} \t\t\ttmp spi >mode & ~SPI_MODE_MASK; \t\t\tspi >mode (u16)tmp; \t\t\tretval spi_setup(spi); \t\t\tif (retval < 0) \t\t\t\tspi >mode save; \t\t\telse \t\t\t\tdev_dbg(&spi >dev, \"spi mode %x\\n\", tmp); \t\t} \t\tbreak; \tcase SPI_IOC_WR_LSB_FIRST: \t\tretval get_user(tmp, (__u8 __user *)arg); \t\tif (retval 0) { \t\t\tu32\tsave spi >mode; \t\t\tif (tmp) \t\t\t\tspi >mode SPI_LSB_FIRST; \t\t\telse \t\t\t\tspi >mode & ~SPI_LSB_FIRST; \t\t\tretval spi_setup(spi); \t\t\tif (retval < 0) \t\t\t\tspi >mode save; \t\t\telse \t\t\t\tdev_dbg(&spi >dev, \"%csb first\\n\", \t\t\t\t\t\ttmp ? 'l' : 'm'); \t\t} \t\tbreak; \tcase SPI_IOC_WR_BITS_PER_WORD: \t\tretval get_user(tmp, (__u8 __user *)arg); \t\tif (retval 0) { \t\t\tu8\tsave spi >bits_per_word; \t\t\tspi >bits_per_word tmp; \t\t\tretval spi_setup(spi); \t\t\tif (retval < 0) \t\t\t\tspi >bits_per_word save; \t\t\telse \t\t\t\tdev_dbg(&spi >dev, \"%d bits per word\\n\", tmp); \t\t} \t\tbreak; \tcase SPI_IOC_WR_MAX_SPEED_HZ: \t\tretval get_user(tmp, (__u32 __user *)arg); \t\tif (retval 0) { \t\t\tu32\tsave spi >max_speed_hz; \t\t\tspi >max_speed_hz tmp; \t\t\tretval spi_setup(spi); \t\t\tif (retval > 0) \t\t\t\tspidev >speed_hz tmp; \t\t\telse \t\t\t\tdev_dbg(&spi >dev, \"%d Hz (max)\\n\", tmp); \t\t\tspi >max_speed_hz save; \t\t} \t\tbreak; \tdefault: // 消息的全双工通信, 可以使用短接进行消息的回环 \t\t/* segmented and/or full duplex I/O request */ \t\t/* Check message and copy into scratch area */ \t\tioc spidev_get_ioc_message(cmd, \t\t\t\t(struct spi_ioc_transfer __user *)arg, &n_ioc); \t\tif (IS_ERR(ioc)) { \t\t\tretval PTR_ERR(ioc); \t\t\tbreak; \t\t} \t\tif (!ioc) \t\t\tbreak;\t/* n_ioc is also 0 */ \t\t/* translate to spi_message, execute */ \t\tretval spidev_message(spidev, ioc, n_ioc); \t\tkfree(ioc); \t\tbreak; \t} \tmutex_unlock(&spidev >buf_lock); \tspi_dev_put(spi); \treturn retval; } ``` ##### SPI_MODE_MASK宏 ```c #define SPI_MODE_MASK (SPI_CPHASPI_CPOLSPI_CS_HIGHSPI_LSB_FIRSTSPI_3WIRESPI_LOOPSPI_NO_CSSPI_READY) ``` ##### spi_ioc_transfer结构体 include/uapi/linux/spi/spidev.h ```c struct spi_ioc_transfer { \t__u64\t\ttx_buf; //发送读取缓冲区 \t__u64\t\trx_buf; \t__u32\t\tlen; \t__u32\t\tspeed_hz; \t// 各种通信参数 \t__u16\t\tdelay_usecs; \t__u8\t\tbits_per_word; \t__u8\t\tcs_change; \t__u8\t\ttx_nbits; \t__u8\t\trx_nbits; \t__u16\t\tpad; }; ``` tx_buf：spi数据发送缓存区 rx_buf：spi数据接收缓存区 len：收发数据长度 ##### spi_ioc_transfer()函数 drivers/spi/spidev.c ```c static struct spi_ioc_transfer * spidev_get_ioc_message(unsigned int cmd, struct spi_ioc_transfer __user *u_ioc, \t\tunsigned *n_ioc) { \tu32\ttmp; \t/* Check type, command number and direction */ // 检查命令是否非法 \tif (_IOC_TYPE(cmd) ! SPI_IOC_MAGIC \t\t\t _IOC_NR(cmd) ! _IOC_NR(SPI_IOC_MESSAGE(0)) \t\t\t _IOC_DIR(cmd) ! _IOC_WRITE) \t\treturn ERR_PTR( ENOTTY); \ttmp _IOC_SIZE(cmd); // cmd里面记录了spi_ioc_transfer数组的大小 \tif ((tmp % sizeof(struct spi_ioc_transfer)) ! 0) \t\treturn ERR_PTR( EINVAL); \t*n_ioc tmp / sizeof(struct spi_ioc_transfer); \tif (*n_ioc 0) \t\treturn NULL; \t/* copy into scratch area */ \treturn memdup_user(u_ioc, tmp); } ``` ##### spidev_message()函数 ```c static int spidev_message(struct spidev_data *spidev, \t\tstruct spi_ioc_transfer *u_xfers, unsigned n_xfers) { \tstruct spi_message\tmsg; \tstruct spi_transfer\t*k_xfers; \tstruct spi_transfer\t*k_tmp; \tstruct spi_ioc_transfer *u_tmp; \tunsigned\t\tn, total, tx_total, rx_total; \tu8\t\t\t*tx_buf, *rx_buf; \tint\t\t\tstatus EFAULT; \t// 初始化message \tspi_message_init(&msg); \tk_xfers kcalloc(n_xfers, sizeof(*k_tmp), GFP_KERNEL); \tif (k_xfers NULL) \t\treturn ENOMEM; \ttx_buf spidev >tx_buffer; \trx_buf spidev >rx_buffer; \ttotal 0; \ttx_total 0; \trx_total 0; \tfor (n n_xfers, k_tmp k_xfers, u_tmp u_xfers; \t\t\tn; \t\t\tn , k_tmp++, u_tmp++) { \t\tk_tmp >len u_tmp >len; \t\ttotal + k_tmp >len; \t\t \t\tif (total > INT_MAX k_tmp >len > INT_MAX) { \t\t\tstatus EMSGSIZE; \t\t\tgoto done; \t\t} \t\tif (u_tmp >rx_buf) { \t\t\t/* this transfer needs space in RX bounce buffer */ \t\t\trx_total + k_tmp >len; \t\t\tif (rx_total > bufsiz) { \t\t\t\tstatus EMSGSIZE; \t\t\t\tgoto done; \t\t\t} \t\t\tk_tmp >rx_buf rx_buf; \t\t\trx_buf + k_tmp >len; \t\t} \t\tif (u_tmp >tx_buf) { \t\t\t/* this transfer needs space in TX bounce buffer */ \t\t\ttx_total + k_tmp >len; \t\t\tif (tx_total > bufsiz) { \t\t\t\tstatus EMSGSIZE; \t\t\t\tgoto done; \t\t\t} \t\t\tk_tmp >tx_buf tx_buf; // 获取一下需要发送的消息 \t\t\tif (copy_from_user(tx_buf, (const u8 __user *) \t\t\t\t\t\t(uintptr_t) u_tmp >tx_buf, \t\t\t\t\tu_tmp >len)) \t\t\t\tgoto done; \t\t\ttx_buf + k_tmp >len; \t\t} \t\tk_tmp >cs_change !!u_tmp >cs_change; \t\tk_tmp >tx_nbits u_tmp >tx_nbits; \t\tk_tmp >rx_nbits u_tmp >rx_nbits; \t\tk_tmp >bits_per_word u_tmp >bits_per_word; \t\tk_tmp >delay_usecs u_tmp >delay_usecs; \t\tk_tmp >speed_hz u_tmp >speed_hz; \t\tif (!k_tmp >speed_hz) \t\t\tk_tmp >speed_hz spidev >speed_hz; #ifdef VERBOSE \t\tdev_dbg(&spidev >spi >dev, \t\t\t\" xfer len %u %s%s%s%dbits %u usec %uHz\\n\", \t\t\tu_tmp >len, \t\t\tu_tmp >rx_buf ? \"rx \" : \"\", \t\t\tu_tmp >tx_buf ? \"tx \" : \"\", \t\t\tu_tmp >cs_change ? \"cs \" : \"\", \t\t\tu_tmp >bits_per_word ? : spidev >spi >bits_per_word, \t\t\tu_tmp >delay_usecs, \t\t\tu_tmp >speed_hz ? : spidev >spi >max_speed_hz); #endif \t\tspi_message_add_tail(k_tmp, &msg); \t} \t// 同步发送时 \tstatus spidev_sync(spidev, &msg); \tif (status < 0) \t\tgoto done; \t/* copy any rx data out of bounce buffer */ \trx_buf spidev >rx_buffer; \tfor (n n_xfers, u_tmp u_xfers; n; n , u_tmp++) { \t\tif (u_tmp >rx_buf) { // 返回读取的消息 \t\t\tif (copy_to_user((u8 __user *) \t\t\t\t\t(uintptr_t) u_tmp >rx_buf, rx_buf, \t\t\t\t\tu_tmp >len)) { \t\t\t\tstatus EFAULT; \t\t\t\tgoto done; \t\t\t} \t\t\trx_buf + u_tmp >len; \t\t} \t} \tstatus total; done: \tkfree(k_xfers); \treturn status; } ``` ## 回环实验 ## SPI驱动实验 #### spi回环通信实验 SPI 3的 MIOS与MOSI引脚使用跳线帽短接 #### 硬件原理图 ![image 20200915085654223](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509271531257.png) spi3引脚与uart2存在引脚复用，不能同时使用 ##### 映射关系 ![image 20200915085935052](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509271530047.png) #### 设备树节点 arch/arm/boot/dts/imx6ull seeed npi.dts ##### pinctrl子节点 ``` \tpinctrl_ecspi3:ecspi3grp { \t\t\t\t\tfsl,pins < \t\t\t\t\t\tMX6UL_PAD_UART2_TX_DATA__ECSPI3_SS0 0x1a090 \t\t\t\t\t\tMX6UL_PAD_UART2_RX_DATA__ECSPI3_SCLK\t\t0x11090 \t\t\t\t\t\tMX6UL_PAD_UART2_CTS_B__ECSPI3_MOSI\t\t\t0x11090 \t\t\t\t\t\tMX6UL_PAD_UART2_RTS_B__ECSPI3_MISO\t\t\t0x11090 \t\t\t\t\t>; \t}; ``` ##### spidev子节点 ```c &ecspi3{ \tfsl,spi num chipselects <1>; // 片选引脚的数量 \tcs gpio <&gpio1 20 GPIO_ACTIVE_LOW>; // 使用的具体引脚 \tpinctrl names \"default\"; \tpinctrl 0 <&pinctrl_ecspi3>; \tstatus \"okay\"; \t#address cells <1>; \t#size cells <0>; \tspidev@0 { \t\tcompatible \"spidev\"; \t\tspi max frequency <20000000>; \t\treg <0>; // 使用的cs引脚 \t}; }; ``` ##### 设备树插件删除 /boot/uEnv.txt spi、uart2 规范方面，我也重写了一个章节当模板，你们相互看一下对方的文档，一致认为风格一致，规范统一，再提交到gitlab吧。质量方面，一定要控制好错别字和病句的频率，围绕驱动核心内容，打造自己的亮点"},"/note/Linux/野火Linux/2025-11-22-78-Regmap通用寄存器.html":{"title":"Regmap","content":"# Regmap Linux下大部分设备的驱动开发都是操作其内部寄存器，比如 I2C/SPI设备的本质都是一样的，通过 I2C/SPI接口读写芯片内部寄存器。芯片内部寄存器也是同样的道理 Linux 下使用 i2c_transfer 来读写 I2C 设备中的寄存器，SPI 接口的话使用 spi_write/spi_read等。I2C/SPI芯片又非常的多，因此Linux内核里面就会充斥了大量的i2c_transfer这类的冗余代码，再者，代码的复用性也会降低 如icm20608这个芯片既支持I2C接口，也支持SPI接口。假设我们在产品设计阶段一开始将 icm20608设计为SPI接口，但是后面发现 SPI接口不够用，或者SOC的引脚不够用，我们需要将 icm20608改为I2C接口。这个时候 icm20608的驱动就要大改，我们需要将 SPI接口函数换为I2C的，工作量比较大 出于代码复用的原则，Linux内核引入了regmap模型，regmap将寄存器访问的共同逻辑抽象出来，驱动开发人员不需要再去纠结使用SPI或者I2C接口API函数，统一使用 regmap API 函数。这样的好处就是统一使用 regmap，降低了代码冗余，提高了驱动的可以移植性 regmap将寄存器访问的共同逻辑抽象出来，驱动开发人员不需要再去纠结使用SPI或者I2C接口API函数，统一使用 regmap API 函数。这样的好处就是统一使用 regmap，降低了代码冗余，提高了驱动的可以移植性 通过 regmap 模型提供的统一接口函数来访问器件的寄存器，SOC 内部的寄存器也可以使用 regmap接口函数来访问 ## 驱动框架 ![image 20251122225449312](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251122225449312.png) regmap框架分为三层： 1. 底层物理总线：regmap 就是对不同的物理总线进行封装，目前 regmap 支持的物理总线有i2c、i3c、spi、mmio、sccb、sdw、slimbus、irq、spmi和w1。 2. regmap核心层，用于实现 regmap，我们不用关心具体实现。 3. regmap API 抽象层，regmap 向驱动编写人员提供的 API 接口，驱动编写人员使用这些 API接口来操作具体的芯片设备，也是驱动编写人员重点要掌握的 ### 数据结构 需要初始化一个`struct regmap`, 初始化的时候使用结构体`struct regmap_config`对他进行配置 ```c /** * Configuration for the register map of a device. * * @name: Optional name of the regmap. Useful when a device has multiple * register regions. * * @reg_bits: Number of bits in a register address, mandatory. * @reg_stride: The register address stride. Valid register addresses are a * multiple of this value. If set to 0, a value of 1 will be * used. * @pad_bits: Number of bits of padding between register and value. * @val_bits: Number of bits in a register value, mandatory. * * @writeable_reg: Optional callback returning true if the register *\t\t can be written to. If this field is NULL but wr_table *\t\t (see below) is not, the check is performed on such table * (a register is writeable if it belongs to one of the ranges * specified by wr_table). * @readable_reg: Optional callback returning true if the register *\t\t can be read from. If this field is NULL but rd_table *\t\t (see below) is not, the check is performed on such table * (a register is readable if it belongs to one of the ranges * specified by rd_table). * @volatile_reg: Optional callback returning true if the register *\t\t value can't be cached. If this field is NULL but *\t\t volatile_table (see below) is not, the check is performed on * such table (a register is volatile if it belongs to one of * the ranges specified by volatile_table). * @precious_reg: Optional callback returning true if the register *\t\t should not be read outside of a call from the driver *\t\t (e.g., a clear on read interrupt status register). If this * field is NULL but precious_table (see below) is not, the * check is performed on such table (a register is precious if * it belongs to one of the ranges specified by precious_table). * @lock:\t Optional lock callback (overrides regmap's default lock *\t\t function, based on spinlock or mutex). * @unlock:\t As above for unlocking. * @lock_arg:\t this field is passed as the only argument of lock/unlock *\t\t functions (ignored in case regular lock/unlock functions *\t\t are not overridden). * @reg_read:\t Optional callback that if filled will be used to perform * \t all the reads from the registers. Should only be provided for *\t\t devices whose read operation cannot be represented as a simple *\t\t read operation on a bus such as SPI, I2C, etc. Most of the *\t\t devices do not need this. * @reg_write:\t Same as above for writing. * @fast_io:\t Register IO is fast. Use a spinlock instead of a mutex *\t \t to perform locking. This field is ignored if custom lock/unlock *\t \t functions are used (see fields lock/unlock of struct regmap_config). *\t\t This field is a duplicate of a similar file in *\t\t 'struct regmap_bus' and serves exact same purpose. *\t\t Use it only for \"no bus\" cases. * @max_register: Optional, specifies the maximum valid register index. * @wr_table: Optional, points to a struct regmap_access_table specifying * valid ranges for write access. * @rd_table: As above, for read access. * @volatile_table: As above, for volatile registers. * @precious_table: As above, for precious registers. * @reg_defaults: Power on reset values for registers (for use with * register cache support). * @num_reg_defaults: Number of elements in reg_defaults. * * @read_flag_mask: Mask to be set in the top byte of the register when doing * a read. * @write_flag_mask: Mask to be set in the top byte of the register when doing * a write. If both read_flag_mask and write_flag_mask are * empty the regmap_bus default masks are used. * @use_single_rw: If set, converts the bulk read and write operations into *\t\t a series of single read and write operations. This is useful *\t\t for device that does not support bulk read and write. * @can_multi_write: If set, the device supports the multi write mode of bulk * write operations, if clear multi write requests will be * split into individual write operations * * @cache_type: The actual cache type. * @reg_defaults_raw: Power on reset values for registers (for use with * register cache support). * @num_reg_defaults_raw: Number of elements in reg_defaults_raw. * @reg_format_endian: Endianness for formatted register addresses. If this is * DEFAULT, the @reg_format_endian_default value from the * regmap bus is used. * @val_format_endian: Endianness for formatted register values. If this is * DEFAULT, the @reg_format_endian_default value from the * regmap bus is used. * * @ranges: Array of configuration entries for virtual address ranges. * @num_ranges: Number of range configuration entries. */ struct regmap_config { \tconst char *name; // 名字 \tint reg_bits; // 寄存器地址的位数 \tint reg_stride; // 寄存器地址的步长 \tint pad_bits; // 寄存器以及值之间的填充 \tint val_bits; // 寄存器的位数 // 可选写回调函数 \tbool (*writeable_reg)(struct device *dev, unsigned int reg); \tbool (*readable_reg)(struct device *dev, unsigned int reg); // 寄存器值不能被读出来的时候此回调函数会被调用 \tbool (*volatile_reg)(struct device *dev, unsigned int reg); \tbool (*precious_reg)(struct device *dev, unsigned int reg); \tregmap_lock lock; \tregmap_unlock unlock; \tvoid *lock_arg; \t// 读写操作回调函数 \tint (*reg_read)(void *context, unsigned int reg, unsigned int *val); \tint (*reg_write)(void *context, unsigned int reg, unsigned int val); \tbool fast_io; \tunsigned int max_register; // 有效的最大寄存器地址 \tconst struct regmap_access_table *wr_table; // 可写的地址范围 \tconst struct regmap_access_table *rd_table; \tconst struct regmap_access_table *volatile_table; \tconst struct regmap_access_table *precious_table; \tconst struct reg_default *reg_defaults; // 寄存器模式值 \tunsigned int num_reg_defaults; // 默认寄存器表中的元素个数 \tenum regcache_type cache_type; \tconst void *reg_defaults_raw; \tunsigned int num_reg_defaults_raw; \t// 标志掩码, 在进行寄存器操作的时候, 自动对地址进行falg位的设置 \tu8 read_flag_mask; \tu8 write_flag_mask; \tbool use_single_rw; \tbool can_multi_write; \t \tenum regmap_endian reg_format_endian; \tenum regmap_endian val_format_endian; \tconst struct regmap_range_cfg *ranges; \tunsigned int num_ranges; }; ``` ### 操作API #### 申请 regmap支持多种物理总线，比如 I2C和 SPI，我们需要根据所使用的接口来选择合适的regmap初始化函数。Linux内核提供了针对不同接口的regmap初始化函数 ```c struct regmap * regmap_init_spi(struct spi_device *spi, const struct regmap_config *config); struct regmap * regmap_init_i2c(struct i2c_client *i2c, const struct regmap_config *config); ``` 对出的时候需要释放 ```c void regmap_exit(struct regmap *map); ``` #### 读写 ```c int regmap_read(struct regmap *map, unsigned int reg, unsigned int *val); int regmap_write(struct regmap *map, unsigned int reg, unsigned int val); ``` #### 位操作 ```c int regmap_update_bits(struct regmap *map, unsigned int reg, unsigned int mask, unsigned int val); ``` #### 多寄存器读写 ```c int regmap_bulk_read(struct regmap *map, unsigned int reg, void *val, size_t val_count); int regmap_bulk_write(struct regmap *map, unsigned int reg, const void *val, size_t val_count) ``` ## 驱动 ### IIC 基于IIC驱动框架, 但是实际的操控函数改为Regmap ```c /*************************************************************** Copyright © ALIENTEK Co., Ltd. 1998 2029. All rights reserved. 文件名\t\t: ap3216c.c 作者\t \t: 正点原子Linux团队 版本\t \t: V1.0 描述\t \t: AP3216C驱动程序 其他\t \t: 无 论坛 \t \t: www.openedv.com 日志\t \t: 初版V1.0 2021/03/19 正点原子Linux团队创建 \t\t\t V1.1 2021/03/19 \t\t\t 使用regmap来访问寄存器\t ***************************************************************/ #include <linux/types.h> #include <linux/kernel.h> #include <linux/delay.h> #include <linux/ide.h> #include <linux/init.h> #include <linux/module.h> #include <linux/errno.h> #include <linux/gpio.h> #include <linux/cdev.h> #include <linux/device.h> #include <linux/of_gpio.h> #include <linux/semaphore.h> #include <linux/timer.h> #include <linux/i2c.h> #include <asm/mach/map.h> #include <asm/uaccess.h> #include <asm/io.h> #include \"ap3216creg.h\" #include <linux/regmap.h> #define AP3216C_CNT\t1 #define AP3216C_NAME\t\"ap3216c\" struct ap3216c_dev { \tstruct i2c_client *client;\t/* i2c 设备 */ \tdev_t devid;\t\t\t/* 设备号 \t */ \tstruct cdev cdev;\t\t/* cdev \t*/ \tstruct class *class;\t/* 类 \t\t*/ \tstruct device *device;\t/* 设备 \t */ \tstruct device_node\t*nd; /* 设备节点 */ \tunsigned short ir, als, ps;\t\t/* 三个光传感器数据 */ \tstruct regmap *regmap;\t\t\t\t/* regmap */ \tstruct regmap_config regmap_config;\t }; /* * @description\t: 读取ap3216c指定寄存器值，读取一个寄存器 * @param dev: ap3216c设备 * @param reg: 要读取的寄存器 * @return \t : 读取到的寄存器值 */ static unsigned char ap3216c_read_reg(struct ap3216c_dev *dev, u8 reg) { \tu8 ret; \tunsigned int data; \tret regmap_read(dev >regmap, reg, &data); \treturn (u8)data; } /* * @description\t: 向ap3216c指定寄存器写入指定的值，写一个寄存器 * @param dev: ap3216c设备 * @param reg: 要写的寄存器 * @param data: 要写入的值 * @return : 无 */ static void ap3216c_write_reg(struct ap3216c_dev *dev, u8 reg, u8 data) { \tregmap_write(dev >regmap, reg, data); } /* * @description\t: 读取AP3216C的数据，读取原始数据，包括ALS,PS和IR, 注意！ *\t\t\t\t: 如果同时打开ALS,IR+PS的话两次数据读取的时间间隔要大于112.5ms * @param ir\t: ir数据 * @param ps \t: ps数据 * @param ps \t: als数据 * @return \t\t: 无。 */ void ap3216c_readdata(struct ap3216c_dev *dev) { \tunsigned char i 0; unsigned char buf[6]; \t \t/* 循环读取所有传感器数据 */ for(i 0; i < 6; i++) { buf[i] ap3216c_read_reg(dev, AP3216C_IRDATALOW + i);\t } if(buf[0] & 0X80) \t/* IR_OF位为1,则数据无效 */ \t\tdev >ir 0;\t\t\t\t\t \telse \t\t\t\t/* 读取IR传感器的数据 \t\t*/ \t\tdev >ir ((unsigned short)buf[1] << 2) (buf[0] & 0X03); \t\t\t \t \tdev >als ((unsigned short)buf[3] << 8) buf[2];\t/* 读取ALS传感器的数据 \t\t\t */ \t if(buf[4] & 0x40)\t/* IR_OF位为1,则数据无效 \t\t\t*/ \t\tdev >ps 0; \t\t\t\t\t\t\t\t\t\t\t\t\t \telse \t\t\t\t/* 读取PS传感器的数据 */ \t\tdev >ps ((unsigned short)(buf[5] & 0X3F) << 4) (buf[4] & 0X0F); } /* * @description\t\t: 打开设备 * @param inode \t: 传递给驱动的inode * @param filp \t: 设备文件，file结构体有个叫做private_data的成员变量 * \t\t\t\t\t 一般在open的时候将private_data指向设备结构体。 * @return \t\t\t: 0 成功;其他 失败 */ static int ap3216c_open(struct inode *inode, struct file *filp) { \t/* 从file结构体获取cdev的指针，在根据cdev获取ap3216c_dev结构体的首地址 */ \tstruct cdev *cdev filp >f_path.dentry >d_inode >i_cdev; \tstruct ap3216c_dev *ap3216cdev container_of(cdev, struct ap3216c_dev, cdev); \t/* 初始化AP3216C */ \tap3216c_write_reg(ap3216cdev, AP3216C_SYSTEMCONG, 0x04);\t\t/* 复位AP3216C \t\t\t*/ \tmdelay(50);\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* AP3216C复位最少10ms \t*/ \tap3216c_write_reg(ap3216cdev, AP3216C_SYSTEMCONG, 0X03);\t\t/* 开启ALS、PS+IR \t\t*/ \treturn 0; } /* * @description\t\t: 从设备读取数据 * @param filp \t: 要打开的设备文件(文件描述符) * @param buf \t: 返回给用户空间的数据缓冲区 * @param cnt \t: 要读取的数据长度 * @param offt \t: 相对于文件首地址的偏移 * @return \t\t\t: 读取的字节数，如果为负值，表示读取失败 */ static ssize_t ap3216c_read(struct file *filp, char __user *buf, size_t cnt, loff_t *off) { \tshort data[3]; \tlong err 0; \tstruct cdev *cdev filp >f_path.dentry >d_inode >i_cdev; \tstruct ap3216c_dev *dev container_of(cdev, struct ap3216c_dev, cdev); \t \tap3216c_readdata(dev); \tdata[0] dev >ir; \tdata[1] dev >als; \tdata[2] dev >ps; \terr copy_to_user(buf, data, sizeof(data)); \treturn 0; } /* * @description\t\t: 关闭/释放设备 * @param filp \t: 要关闭的设备文件(文件描述符) * @return \t\t\t: 0 成功;其他 失败 */ static int ap3216c_release(struct inode *inode, struct file *filp) { \treturn 0; } /* AP3216C操作函数 */ static const struct file_operations ap3216c_ops { \t.owner THIS_MODULE, \t.open ap3216c_open, \t.read ap3216c_read, \t.release ap3216c_release, }; /* * @description : i2c驱动的probe函数，当驱动与 * 设备匹配以后此函数就会执行 * @param client : i2c设备 * @param id : i2c设备ID * @return : 0，成功;其他负值,失败 */ static int ap3216c_probe(struct i2c_client *client, const struct i2c_device_id *id) { \tint ret; \tstruct ap3216c_dev *ap3216cdev; \tap3216cdev devm_kzalloc(&client >dev, sizeof(*ap3216cdev), GFP_KERNEL); \tif(!ap3216cdev) \t\treturn ENOMEM; \t/* 初始化regmap_config设置 */ \tap3216cdev >regmap_config.reg_bits 8;\t\t/* 寄存器长度8bit */ \tap3216cdev >regmap_config.val_bits 8;\t\t/* 值长度8bit */ \t/* 初始化IIC接口的regmap */ \tap3216cdev >regmap regmap_init_i2c(client, &ap3216cdev >regmap_config); \tif (IS_ERR(ap3216cdev >regmap)) { \t\treturn PTR_ERR(ap3216cdev >regmap); \t}\t \t\t \t/* 注册字符设备驱动 */ \t/* 1、创建设备号 */ \tret alloc_chrdev_region(&ap3216cdev >devid, 0, AP3216C_CNT, AP3216C_NAME); \tif(ret < 0) { \t\tpr_err(\"%s Couldn't alloc_chrdev_region, ret %d\\r\\n\", AP3216C_NAME, ret); \t\tgoto del_regmap; \t} \t/* 2、初始化cdev */ \tap3216cdev >cdev.owner THIS_MODULE; \tcdev_init(&ap3216cdev >cdev, &ap3216c_ops); \t \t/* 3、添加一个cdev */ \tret cdev_add(&ap3216cdev >cdev, ap3216cdev >devid, AP3216C_CNT); \tif(ret < 0) { \t\tgoto del_unregister; \t} \t \t/* 4、创建类 */ \tap3216cdev >class class_create(THIS_MODULE, AP3216C_NAME); \tif (IS_ERR(ap3216cdev >class)) { \t\tgoto del_cdev; \t} \t/* 5、创建设备 */ \tap3216cdev >device device_create(ap3216cdev >class, NULL, ap3216cdev >devid, NULL, AP3216C_NAME); \tif (IS_ERR(ap3216cdev >device)) { \t\tgoto destroy_class; \t} \tap3216cdev >client client; \t/* 保存ap3216cdev结构体 */ \ti2c_set_clientdata(client,ap3216cdev); \treturn 0; destroy_class: \tdevice_destroy(ap3216cdev >class, ap3216cdev >devid); del_cdev: \tcdev_del(&ap3216cdev >cdev); del_unregister: \tunregister_chrdev_region(ap3216cdev >devid, AP3216C_CNT); del_regmap: \tregmap_exit(ap3216cdev >regmap); \treturn EIO; } /* * @description : i2c驱动的remove函数，移除i2c驱动的时候此函数会执行 * @param client \t: i2c设备 * @return : 0，成功;其他负值,失败 */ static int ap3216c_remove(struct i2c_client *client) { \tstruct ap3216c_dev *ap3216cdev i2c_get_clientdata(client); \t/* 注销字符设备驱动 */ \t/* 1、删除cdev */ \tcdev_del(&ap3216cdev >cdev); \t/* 2、注销设备号 */ \tunregister_chrdev_region(ap3216cdev >devid, AP3216C_CNT); \t/* 3、注销设备 */ \tdevice_destroy(ap3216cdev >class, ap3216cdev >devid); \t/* 4、注销类 */ \tclass_destroy(ap3216cdev >class); \t/* 5、释放regmap */ \tregmap_exit(ap3216cdev >regmap); \treturn 0; } /* 传统匹配方式ID列表 */ static const struct i2c_device_id ap3216c_id[] { \t{\"alientek,ap3216c\", 0}, \t{} }; /* 设备树匹配列表 */ static const struct of_device_id ap3216c_of_match[] { \t{ .compatible \"alientek,ap3216c\" }, \t{ /* Sentinel */ } }; /* i2c驱动结构体 */\t static struct i2c_driver ap3216c_driver { \t.probe ap3216c_probe, \t.remove ap3216c_remove, \t.driver { \t\t\t.owner THIS_MODULE, \t\t \t.name \"ap3216c\", \t\t \t.of_match_table ap3216c_of_match, \t\t }, \t.id_table ap3216c_id, }; \t\t /* * @description\t: 驱动入口函数 * @param \t\t: 无 * @return \t\t: 无 */ static int __init ap3216c_init(void) { \tint ret 0; \tret i2c_add_driver(&ap3216c_driver); \treturn ret; } /* * @description\t: 驱动出口函数 * @param \t\t: 无 * @return \t\t: 无 */ static void __exit ap3216c_exit(void) { \ti2c_del_driver(&ap3216c_driver); } /* module_i2c_driver(ap3216c_driver) */ module_init(ap3216c_init); module_exit(ap3216c_exit); MODULE_LICENSE(\"GPL\"); MODULE_AUTHOR(\"ALIENTEK\"); MODULE_INFO(intree, \"Y\");"},"/note/Linux/野火Linux/2025-11-18-71-音频.html":{"title":"音频","content":"# 音频 CODEC的本质是ADC和DAC，那么采样率和采样位数就是衡量一款音频CODEC 最重要的指标。比如常见音频采样率有 8K、44.1K、48K、192K甚至 384K 和 768K，采样位数常见的有 8 位、16 位、24 位、32 位。采样率和采样位数越高，那么音频 CODEC 越能真实的还原声音，也就是大家说的 HIFI。 实际的音频处理的流程 1. 读取音频文件 2. 软件界面 3. 使用I2S传输数据给音频芯片 使用整个框架称为`ALSA`分为三部分 1. SOC: SOC使用的音频接口, 比如IMX6ULL使用的SAL接口, 半导体厂商提供 2. Codec: 具体的音频芯片, WM8960, IIC驱动等, Codec厂商编写 3. 板载部分: Machine部分, 具体的SOC以及Codec需要结合的部分 ## 硬件 ### 音频解码 ![image 20251118151740230](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251118151740230.png) 1. 输入接口，作为立体声音频输入源，一共提供了三路，分别为 LINPUT1/RINPUT1、LINPUT2/RINPUT2、LINPUT3/RINPUT3。麦克风或线路输入就连接到此接口上，这部分是需要硬件工程师重点关心的 2. 此部分是WM8960的输出接口，比如输出给耳机或喇叭，SPK_LP/SPKLN用于连接_左声道的喇叭，支持1W的8Ω喇叭。SPK\\_RP/SPKRN用于连接右声道的喇叭，同样支持 1W\\_的 8Ω喇叭，最后就是HP\\_L/HP\\_R，用于连接耳机 3. 此部分是数字音频接口，用于和主控制器连接，有5根线，用于主控制器和WM8960之间进行数据“沟通”。主控制器向WM8960的DAC发送的数据，WM8960的ADC向主控制传递的数据都是通过此音频接口来完成的。这个接口非常重要，是我们驱动开发人员重点关注的，此接口支持I2S格式 + **ADCDAT**： ADC数据输出引脚，采集到的音频数据转换为数字信号以后通过此引脚传输给主控制器。 + **ADCLRC**：ADC 数据对齐时钟，也就是帧时钟(LRCK)，用于切换左右声道数据，此信号的频率就是采样率。此引脚可以配置为 GPIO功能，配置为 GPIO以后 ADC就会使用 DACLRC引脚作为帧时钟。 + **DACDAT**：DAC 数据输入引脚，主控器通过此引脚将数字信号输入给 WM8960 的 DAC。 + **DACLRC**：DAC数据对齐时钟，功能和ADCLRC一样，都是帧时钟(LRCK)，用于切换左右声道数据，此信号的频率等于采样率。 + **BCLK**：位时钟，用于同步。 + **MCLK**：主时钟，WM8960工作的时候还需要一路主时钟，此时钟由 I.MX6ULL提供，MCLK 频率等于采样率的 256 或 384 倍，因此大家在 WM8960 的数据手册里面常看到 MCLK 256fs或 MCLK 384fs 4. 此部分为控制接口，是一个标准的 I2C 接口，WM8960 要想工作必须对其进行配置，这个I2C接口就是用于配置 WM8960的 ### 音频编解码芯片 ES8388 是一款高性能、低功耗且低成本的音频 CODEC 芯片。它集成了 2 通道 ADC、2 通道 DAC、麦克风放大器、耳机放大器、数字音效处理功能以及模拟信号混合增益功能。 1. ADC（模数转换）24位高精度，8kHz~96kHz采样率, 95dB动态范围和信噪比, 支持立体声/单声道麦克风，内置放大器, 自动增益（AGC）、噪声门、模拟混音 2. DAC（数模转换）24位高精度，8kHz~96kHz采样率, 96dB动态范围和信噪比, 40mW耳机驱动，免耦电容输出, 支持音效增强、混音和增益调节 3. 低功耗 1.8V~3.3V供电，超低功耗, 播放仅7mW，录放同步仅 16mW 4. 系统接口 支持 I²C/SPI配置, 支持 I²S、DSP/PCM等音频格式, 可做主机或从机，兼容多种时钟和采样率 ![image 20251118152615315](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251118152615315.png) ## IIS 飞利浦公司提出的一种用于数字音频设备之间进行音频数据传输的总线, I2S总线用于主控制器和音频 CODEC 芯片之间传输音频数据。因此，要想使用 I2S 协议，主控制器和音频 CODEC都得支持I2S协议 **SCK**：串行时钟信号，也叫做位时钟(BCLK)，音频数据的每一位数据都对应一个 SCK，立体声都是双声道的，因此SCK 2×采样率×采样位数。比如采样率为44.1KHz、16位的立体声音频，那么`SCK 2**×**44100**×**16 1411200Hz 1.4112MHz`。 **WS**：字段(声道)选择信号，也叫做LRCK，也叫做帧时钟，用于切换左右声道数据，WS为“1”表示正在传输左声道的数据，WS为“0”表示正在传输右声道的数据。WS的频率等于采样率，比如采样率为 44.1KHz的音频，WS 44.1KHz。 **SD**：串行数据信号，也就是我们实际的音频数据，如果要同时实现放音和录音，那么就需要 2根数据线，比如WM8960的ADCDAT和DACDAT，就是分别用于录音和放音。不管音频数据是多少位的，数据的最高位都是最先传输的。数据的最高位总是出现在一帧开始后(LRCK变化)的第2个SCK脉冲处。 > 有时候为了使音频 CODEC 芯片与主控制器之间能够更好的同步，会引入另外一个叫做MCLK的信号，也叫做主时钟或系统时钟，一般是采样率的 256倍或 384倍 ![image 20251118153112142](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251118153112142.png) 如果数据时钟一个周期的位数比实际的数据的数量大, 在实际的使用的时候需要确定一下对齐方式 ![image 20251118202024397](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251118202024397.png) ## SAI驱动 i.MX 6ull芯片上具有iic、sai和lcd fpc接口，其中iic和sai接口用来控制和播放音频， fpc接口用来播放视频。通过这些接口，用户可以把相关外设连接到芯片上，从而来实现音视频的播放。 SAI 接口（串行音频接口）适用于许多立体声或单声道应用。例如，它可配置为支持 I2S 标准、LSB 或 MSB 对齐、PCM/DSP、TDM 和 AC’97 等协议。将音频模块配置为发 送器时，SAI 接口可提供 SPDIF 输出。 ### 设备树 #### I2C部分 由于实际的控制使用的接口是i2c的, 所以需要在i2c的节点下面添加设备, 这个设备是被内核支持的, 所以可以直接使用, 具体使用的驱动放在sound/soc/codecs文件夹下面 > Documentation/devicetree/bindings/sound/wm8960.txt > > Required properties: > > compatible : \"wlf,wm8960\" > > reg : the I2C address of the device. > > Optional properties: > wlf,shared lrclk: This is a boolean property. If present, the LRCM bit of > \tR24 (Additional control 2) gets set, indicating that ADCLRC and DACLRC pins > \twill be disabled only when ADC (Left and Right) and DAC (Left and Right) > \tare disabled. > \tWhen wm8960 works on synchronize mode and DACLRC pin is used to supply > \tframe clock, it will no frame clock for captrue unless enable DAC to enable > \tDACLRC pin. If shared lrclk is present, no need to enable DAC for captrue. > > 这是一个bool类型的属性，如果添加了此属性，WM8960的R24寄存器的 LRCM位(bit2)就会置 1。当 LRCM 为 1 的时候只有当 ADC 和 DAC全部关闭以后 ADCLRC和DACLRC时钟才会关闭 > wlf,capless: This is a boolean property. If present, OUT3 pin will be > \tenabled and disabled together with HP_L and HP_R pins in response to jack > \tdetect events. > bool 类型的属性，如果添加了此属性，OUT3 引脚将会使能，并且为了响应耳机插入响应事件，HP_L和HP_R这两个引脚都会关闭。 实际应用如下 ```json codec2: wm8960@1a { compatible \"wlf,wm8960\"; reg <0x1a>; clocks <&clks IMX6UL_CLK_SAI2>; clock names \"mclk\"; wlf,shared lrclk; }; ``` 为了更好的同步，一般都会额外提供一条 MCLK时钟 #### SAI部分 Documentation/devicetree/bindings/sound/fsl sai.txt imx6ull.dtsi文件中会有关于 SAI相关接口的描述，这部分是 NXP原厂编写的，我们不需要做任何修改 ```c sai2: sai@0202c000 { compatible \"fsl,imx6ul sai\", \"fsl,imx6sx sai\"; reg <0x0202c000 0x4000>; interrupts <GIC_SPI 98 IRQ_TYPE_LEVEL_HIGH>; clocks <&clks IMX6UL_CLK_SAI2_IPG>, <&clks IMX6UL_CLK_DUMMY>, <&clks IMX6UL_CLK_SAI2>, <&clks 0>, <&clks 0>; clock names \"bus\", \"mclk0\", \"mclk1\", \"mclk2\", \"mclk3\"; dma names \"rx\", \"tx\"; dmas <&sdma 37 24 0>, <&sdma 38 24 0>; status \"disabled\"; }; ``` 我们需要将其打开，也就是设置 status属性的值为“okay” ```json &sai2 { \tpinctrl names \"default\"; \tpinctrl 0 <&pinctrl_sai2>; \tassigned clocks <&clks IMX6UL_CLK_SAI2_SEL>, \t\t\t <&clks IMX6UL_CLK_SAI2>; \tassigned clock parents <&clks IMX6UL_CLK_PLL4_AUDIO_DIV>; \tassigned clock rates <0>, <11289600>; \tstatus \"okay\"; }; ``` 默认使用的引脚的驱动如下 ```json pinctrl_sai2: sai2grp { fsl,pins < MX6UL_PAD_JTAG_TDI__SAI2_TX_BCLK\t0x17088 MX6UL_PAD_JTAG_TDO__SAI2_TX_SYNC\t0x17088 MX6UL_PAD_JTAG_TRST_B__SAI2_TX_DATA\t0x11088 MX6UL_PAD_JTAG_TCK__SAI2_RX_DATA\t0x11088 MX6UL_PAD_JTAG_TMS__SAI2_MCLK\t\t0x17088 >; }; ``` #### sound节点 可以参考Documentation/devicetree/bindings/sound/imx audio wm8962.txt, 使用的驱动文件是sound/soc/fsl/imx wm8960.c, 这部分是wm8960以及SAI部分的匹配连接使用的节点, 理论这个文件是需要我们自己进行编写的文件 ```json sound { compatible \"fsl,imx6ul evk wm8960\", \"fsl,imx audio wm8960\"; model \"wm8960 audio\"; cpu dai <&sai2>;\t\t\t/* CPU使用的dai是sai2 */ audio codec <&codec>;\t/* 使用的codec节点是codec */ asrc controller <&asrc>; codec master; gpr <&gpr 4 0x100000 0x100000>; /* * hp det <hp det pin hp det polarity>; * hp det pin: JD1 JD2 or JD3 * hp det polarity 0: hp detect high for headphone * hp det polarity 1: hp detect high for speaker */ hp det <3 0>; /* hp det gpios <&gpio5 4 0>; mic det gpios <&gpio5 4 0>; */ audio routing \"Headphone Jack\", \"HP_L\", \"Headphone Jack\", \"HP_R\", \"Ext Spk\", \"SPK_LP\", \"Ext Spk\", \"SPK_LN\", \"Ext Spk\", \"SPK_RP\", \"Ext Spk\", \"SPK_RN\", \"LINPUT2\", \"Mic Jack\", \"LINPUT3\", \"Mic Jack\", \"RINPUT1\", \"Main MIC\", \"RINPUT2\", \"Main MIC\", \"Mic Jack\", \"MICB\", \"Main MIC\", \"MICB\", \"CPU Playback\", \"ASRC Playback\", \"Playback\", \"CPU Playback\", \"ASRC Capture\", \"CPU Capture\", \"CPU Capture\", \"Capture\"; }; ``` + **compatible**：非常重要，用于匹配相应的驱动文件，有两个属性值，在整个 linux内核源码中搜索这两个属性值即可找到对应的驱动文件，这里找到的驱动文件为：sound/soc/fsl/imx wm8960.c。 + **model**：最终用户看到的此声卡名字，这里设置为“wm8960 audio”。 + **cpu dai**：CPU DAI(Digital Audio Interface)句柄，这里是sai2这个节点。 + **audio codec**：音频解码芯片句柄，也就是 WM8960 芯片，这里为“codec1”和“codec2”这两个节点。 + **gpr**：控制 I.MX6ULL SAI MCLK接口输出 11.289MHz时钟。 + **asrc controller**：asrc 控制器，asrc 全称为 Asynchronous Sample Rate Converters，翻译过来就是异步采样频率转化器。 + **hp det**：耳机插入检测引脚设置，第一个参数为检测引脚，3表示JD3为检测引脚。第二个参数设置检测电平，设置为 0的时候，hp检测到高电平表示耳机插入；设置为 1的时候，hp检测到高电平表示是喇叭，也就是耳机拔出了。 + **audio routing**：音频器件一系列的连接设置，每个条目都是一对字符串，第一个字符串是连接的sink，第二个是连接的 source(源) ## ALSA框架 ALSA 是 Advanced Linux Sound Architecture（高级的 Linux 声音体系）的缩写，目前已经成为了 linux下的主流音频体系架构，提供了音频和 MIDI 的支持 alsa lib 是一套 Linux 应用层的 C 语言函数库，为音频应用程序开发提供了一套统一、标准的接口，应用程序只需调用这一套 API 即可完成对底层声卡设备的操控，譬如播放与录音 用户空间的 alsa lib 对应用程序提供了统一的 API 接口，这样可以隐藏驱动层的实现细节，简化了应用程序的实现难度、无需应用程序开发人员直接去读写音频设备节点。所以对于我们来说，学习音频应用编程其实就是学习 alsa lib 库函数的使用、如何基于 alsa lib 库函数开发音频应用程序。 ### ASoc 建立在标准ALSA驱动层上，为了更好地支持嵌入式处理器和移动设备 中的音频Codec的一套软件体系。在ASoc出现之前，内核对于SoC中的音频已经有部分的支持，不过会有一些局限性： 1. Codec驱动与SoC CPU的底层耦合过于紧密，这种不理想会导致代码的重复，例如，仅是wm8731的驱动，当时Linux中有分别针对4个平台的驱动代码。 2. 音频事件没有标准的方法来通知用户，例如耳机、麦克风的插拔和检测，这些事件在移动设备中是非常普通的，而且通常都需要特定于机器的代码进行重新对音频路劲进行配置。 3. 当进行播放或录音时，驱动会让整个codec处于上电状态，这对于PC没问题，但对于移动设备来说，这意味着浪费大量的电量。同时也不支持通过改变过取样频率和偏置电流来达到省电的目的。 ASoC正是为了解决上述种种问题而提出的，目前已经被整合至内核的代码树中：sound/soc。ASoC不能单独存在，他只是建立在标准ALSA驱动上的一个它必须和标准的ALSA驱动框架相结合才能工作。 > 我们实际主要需要处理的Machine部分的文档为Documentation/sound/alsa/soc/machine.txt ## 配置 ``` > Device Drivers > Sound card support (SOUND [ y]) > Advanced Linux Sound Architecture (SND [ y]) > <> OSS Mixer API //不选择 > <> OSS PCM (digital audio) API //不选择 ``` ``` > Device Drivers > Sound card support (SOUND [ y]) > Advanced Linux Sound Architecture (SND [ y]) > ALSA for SoC audio support (SND_SOC [ y]) > SoC Audio for Freescale CPUs > <*> Asynchronous Sample Rate Converter (ASRC) module support //选中 > <*> SoC Audio support for i.MX boards with wm8960 //选中 ``` ## 使用 移植成功以后可以在`/dev/snd`目录查看对应的音频驱动 + **controlC0**：用于声卡控制，C0表示声卡 0。 + **pcmC0D0c** 和 **pcmC0D1c**：用于录音的pcm设备，其中的“COD0”和“C0D1”分别表示声卡0中的设备0和设备1，最后面的“c”是capture的缩写，表示录音。 + **pcmC0D0p** 和 **pcmC0D1p**：用于播放的pcm设备，其中的“COD0”和“C0D1”分别表示声卡0中的设备0和设备1，最后面的“p”是 playback的缩写，表示放音。 + **timer**：定时器。 在实际使用的时候需要移植alsa lib和alsa utils"},"/note/Linux/野火Linux/2025-9-29-42-Uboot基础使用.html":{"title":"Uboot","content":"# Uboot 不仅支持嵌入式Linux系统的引导，还支持NetBSD,VxWorks, QNX, RTEMS, ARTOS, LynxOS, Android 等嵌入式操作系统的引导 一般来说BootLoader必须提供系统上电时的初始化代码，在系统上电时初始化相关环境后，Boot Loader 需要引导完整的操作系统，然后将控制器交给操作系统。简单来说BootLoader是一段小 程序，它在系统上电时执行，通过这段小程序可以将硬件设备进行初始化，如CPU、SDRAM、 Flash、串口、网络等，初始化完毕后调用操作系统内核。 ## 基础使用 ### 编译 ```bash make ARCH arm CROSS_COMPILE arm linux gnueabihf distclean make ARCH arm CROSS_COMPILE arm linux gnueabihf mx6ull_14x14_ddr512_emmc_defconfig make V 1 ARCH arm CROSS_COMPILE arm linux gnueabihf j12 ``` ### 进入 启动的时候随意按一个按键即可进入boot > **Uboot里面的数字都是16进制的** ### 基础命令 在没有命令名冲突的情况下可以使用命令的前几个字母作为命令的输入 ![image 20250929205522833](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509292055963.png) + bdinfo: 查看板子的内存基础配置以及网络等信息 + nm: 修改内存里面的信息 `nm[.b .w .l] address`, 修改以后地址不会进行自增 + mm: 同上, 地址自增 + mw: 使用一个数值进行一段内存地址的填充`mw[.b .w .l] address value [count]` + cp: 复制一段地址`cp [.b, .w, .l] source target count` + cmp: 比较两段地址 `cmp [.b, .w, .l] addr1 addr2 count ` #### mmc命令 ![image 20250929205629354](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509292056405.png) ![image 20250929205856104](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509292058140.png) uboot 能够对ext2/3/4 以及 fat 文件系统设备进行访问，可使用fstype命令判断存储介质分区使用 的是什么类型的文件系统。 ![image 20250929205945430](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509292059455.png) ```bash > ? mmc mmc MMC sub system Usage: mmc info display info of the current MMC device mmc read addr blk# cnt mmc write addr blk# cnt mmc erase blk# cnt mmc rescan mmc part lists available partition on current mmc device mmc dev [dev] [part] show or set current mmc device [partition] mmc list lists available devices mmc hwpartition [args...] does hardware partitioning arguments (sizes in 512 byte blocks): [user [enh start cnt] [wrrel {onoff}]] sets user data area attributes [gp1gp2gp3gp4 cnt [enh] [wrrel {onoff}]] general purpose partition [checksetcomplete] mode, complete set partitioning completed WARNING: Partitioning is a write once setting once it is set to complete. Power cycling is required to initialize partitions after set to complete. mmc bootbus dev boot_bus_width reset_boot_bus_width boot_mode Set the BOOT_BUS_WIDTH field of the specified device mmc bootpart resize <dev> <boot part size MB> <RPMB part size MB> Change sizes of boot and RPMB partitions of specified device mmc partconf dev boot_ack boot_partition partition_access Change the bits of the PARTITION_CONFIG field of the specified device mmc rst function dev value Change the RST_n_FUNCTION field of the specified device WARNING: This is a write once field and 0 / 1 / 2 are the only valid values. mmc setdsr <value> set DSR register value ``` + `mmc dev 1 0`: 切换分区到设备1的分区0 + `mmc read 80800000 600 10`从0x600块读取0x10个块 + `mmc write 80800000 80800000 2 32E`可以使用这个命令配合tftp进行Uboot升级 #### 文件系统 可以使用`fstype`查看一个分区的格式`fs mmc 0:1` ![image 20250929210407759](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509292104794.png) + `fatinfo mmc 0:1`查看SD卡第一个分区, 里面有dtb以及zImage文件 + fatmkdir：创建目录 + fatrm：删除文件 + `fatwrite mmc 1:1 80800000 zImage 6788f8`: 把内存上的数据存储到FAT分区的一个文件里 + `fatload mmc 1:1 80800000 zImage` ![image 20250929210818807](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509292108840.png) #### 网络 + ping: ping一个ip查看是不是可以连接 + dhcp: 自动分配ip地址 + nfs: 使用nfs下载文件, 需要设置一下serverip的环境变量, `nfs 0x80800000 192.168.106.173:/home/jiao/nfs/test.txt`(失败) + tftp: ```bash sudo apt get install tftp hpa tftpd hpa sudo apt get install xinetd mkdir /home/zuozhongkai/linux/tftpboot chmod 777 /home/zuozhongkai/linux/tftpboot ``` 设置两个文件 ```bash jiao@jiao virtual machine:~$ cat /etc/xinetd.d/tftp server tftp { socket_type dgram protocol udp wait yes user root server /usr/sbin/in.tftp.d server_args s /home/jiao/tftp disable no per_source 11 cps 100 2 flags IPv4 } sudo service tftpd hpa start jiao@jiao virtual machine:~$ cat /etc/default/tftpd hpa # /etc/default/tftpd hpa TFTP_USERNAME \"tftp\" TFTP_DIRECTORY \"/home/jiao/tftp\" TFTP_ADDRESS \":69\" TFTP_OPTIONS \" l c s\" sudo service tftpd hpa restart ``` #### 其他 + go: 去指定位置运行bin文件 + reboot: 重启 + run: 运行一个命令的字符串, 可以设置为环境变量 + mtest: 测试内存 + ## 启动过程 ### 命令 #### bootz启动内核 bootz: 将zImage镜像以及dtb设备树复制到DRAM里面, bootz命令用于启动zImage镜像文件 ```bash bootz [addr [initrd[:size]] [fdt]] ``` addr是Linux镜像文件在DRAM中的位置，initrd是initrd文件在 DRAM中的地址，如果不使用initrd的话使用‘ ’代替即可，fdt就是设备树文件在DRAM中 的地址。 + 从网络启动 ```bash > ping 192.168.106.173 Using FEC1 device error frame: 0x9ef547c0 0x00000804 host 192.168.106.173 is alive > tftp 80800000 zImage Using FEC1 device TFTP from server 192.168.106.173; our IP address is 192.168.137.168; sending through gateway 192.168.137.1 Filename 'zImage'. Load address: 0x80800000 Loading: ################################################################# ################################################################# ################################################################# ################################################################# ################################################################# ################################################################# ################################################################# ######## 831.1 KiB/s done Bytes transferred 6792144 (67a3d0 hex) > tftp 83000000 imx6ull 14x14 emmc 7 1024x600 c.dtb Using FEC1 device TFTP from server 192.168.106.173; our IP address is 192.168.137.168; sending through gateway 192.168.137.1 Filename 'imx6ull 14x14 emmc 7 1024x600 c.dtb'. Load address: 0x83000000 Loading: ### 7.8 KiB/s done Bytes transferred 40381 (9dbd hex) > bootz 80800000 83000000 Kernel image @ 0x80800000 [ 0x000000 0x67a3d0 ] ## Flattened Device Tree blob at 83000000 Booting using the fdt blob at 0x83000000 Using Device Tree in place at 83000000, end 8300cdbc Starting kernel ... ``` + 从EMMC启动 ```bash > fatls mmc 1:1 6792136 zimage 40381 imx6ull 14x14 emmc 4.3 480x272 c.dtb 40381 imx6ull 14x14 emmc 4.3 800x480 c.dtb 40381 imx6ull 14x14 emmc 7 800x480 c.dtb 40381 imx6ull 14x14 emmc 7 1024x600 c.dtb 40381 imx6ull 14x14 emmc 10.1 1280x800 c.dtb 41217 imx6ull 14x14 emmc hdmi.dtb 41125 imx6ull 14x14 emmc vga.dtb 8 file(s), 0 dir(s) > fatload mmc 1:1 80800000 zimage reading zimage 6792136 bytes read in 223 ms (29 MiB/s) > fatload mmc 1:1 83000000 imx6ull 14x14 emmc 7 1024x600 c.dtb reading imx6ull 14x14 emmc 7 1024x600 c.dtb 40381 bytes read in 24 ms (1.6 MiB/s) > bootz 80800000 83000000 Kernel image @ 0x80800000 [ 0x000000 0x67a3c8 ] ## Flattened Device Tree blob at 83000000 Booting using the fdt blob at 0x83000000 Using Device Tree in place at 83000000, end 8300cdbc Starting kernel ... ``` #### bootm bootm 和bootz 功能类似，但是bootm用于启动uImage镜像文件。 `bootm [addr [initrd[:size]] [fdt]] ` #### boot boot 命令也是用来启动Linux系统的，只是boot会读取环境变量bootcmd来启动Linux系统 bootcmd与bootargs可以说是uboot最重要的两个环境参数，uboot执行完毕之后，如果没有按下 回车，则会自动执行bootcmd命环境参数里的内容，而bootargs则是传递给内核的启动参数 > 参数的配置可以从include/configs/mx6ullfire.h文件里面查看 ``` > printenv bootcmd bootcmd run distro_bootcmd > printenv distro_bootcmd distro_bootcmd for target in ${boot_targets}; do run bootcmd_${target}; done > printenv boot_targets boot_targets mmc0 mmc1 ``` > mmc0表示的sd卡的存储设备，mmc1表示的emmc设备, 当sd卡插在板子时， 若sd卡装有系统则会优先从sd卡内启动 bootcmd_mmc0与bootcmd_mmc1均设置各自devtype、mmcdev、bootpart、rootfpart环境参数 的值，最后运行boot环境参数 ``` > printenv bootcmd_mmc0 bootcmd_mmc0 if test n \"${SDBOOT}\"; then setenv devtype mmc; setenv mmcdev 0; setenv bootpart 0:1 ; setenv rootfpart 0:2 ; run boot; fi > printenv bootcmd_mmc1 bootcmd_mmc1 setenv devtype mmc; setenv mmcdev 1; setenv bootpart 1:1 ; setenv rootfpart 1:2 ; run boot ``` 最后执行的boot命令如下 ```python \t\"boot mmc check;${devtype} dev ${mmcdev};mmc rescan; \" \\ \t\t\"echo loading [${devtype} ${bootpart}] /uEnv.txt ...; \"\\ \t\t\"if run loaduEnv; then \" \\ # 加载uEnv.txt文件的配置 \t\t\t\"run importbootenv;\" \\ # 运行importbootenv，从内存地址中导入环境参数 \t\t\t\"if test ${second_flash} emmc; then \" \\ # 判断启动的介质设置dtb、storage、init环境参数 \t\t\t\t\t\"setenv dtb ${mmc_dtb};\" \\ \t\t\t\t\t\"setenv storage_media init /opt/scripts/tools/eMMC/init eMMC flasher v3.sh;\" \\ \t\t\t\t\"else \" \\ \t\t\t\t\t\"setenv dtb ${nand_dtb};\" \\ \t\t\t\t\t\"setenv storage_media init /opt/scripts/tools/Nand/init Nand flasher v1.sh;\" \\ \t\t\t\t\"fi; \" \\ \t\t\t\"if test n ${flash_firmware}; then \" \\ \t\t\t\t\t\"echo setting flash firmware...;\" \\ \t\t\t\t\t\"setenv flashtype ${storage_media};\" \\ \t\t\t\"fi;\" \\ \t\t\t\"run args_mmc_old;\" \\ # args_mmc_old 的作用主要用于设置bootargs环境参数 \t\t\t\"echo loading vmlinuz ${uname_r} ...; \"\\ # 将kernel内核加载到内存地址0x80800000 \t\t\t\"load ${devtype} ${bootpart} 0x80800000 /kernel/vmlinuz ${uname_r};\"\\ \t\t\t\"echo loading ${dtb} ...; \"\\ # 将主设备树加载到内存地址0x83000000处 \t\t\t\"load ${devtype} ${rootfpart} 0x83000000 /usr/lib/linux image ${uname_r}/${dtb};\"\\ # ，将设备树插件的内容解析合成到主设备树上，dtfile命令并不是原来uboot就有的， \t\t # 为了方便用户使用/boot/uEnv.txt 文件使用设备树插件而添加的，有兴趣的读者可自行查看相关源码。 \t\t\t\"dtfile 0x83000000 0x87000000 /uEnv.txt ${loadaddr};\" \\ # 将虚拟文件系统加载到0x88000000中 \t\t\t\"load ${devtype} ${bootpart} 0x88000000 /kernel/initrd.img ${uname_r};\"\\ \t\t\t\"echo debug: [${bootargs}] ... ;\" \\ \t\t\t\"echo debug: [bootz] ... ;\" \\ \t\t # 启动linux内核 \t\t\t\"bootz 0x80800000 0x88000000:${filesize} 0x83000000;\"\t\\ \t\t\"fi;\\0\" \\ ``` 这里面的loaduEnv是` loaduEnv load${devtype} ${bootpart} ${loadaddr} /uEnv.txt;`, 加载一下这个文件 ```c \"args_mmc_old setenv bootargs console ttymxc0 \" \\ \"root /dev/mmcblk${mmcdev}p2 rw \" \\ \"rootfstype ext4 \" \\ \"rootwait ${cmdline} ${flashtype}\\0\" \\ ``` ## 环境参数 uboot 中环境参数为我们提供一种不修改uboot源码的情况下，能够修改kernel启动倒计时、ip地 址、以及向内核传递不同的参数等 默认情况下使用`setenv`命令修改环境参数重启后就会消失，若想要掉电保存需要执行`saveenv`将环境参数保存到存储介质。 > [The U Boot Documentation — Das U Boot unknown version documentation](https://docs.u boot.org/en/latest/) ## 编译 ![image 20250929215934240](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509292159312.png) 野火提供的imx6ulluboot分为nand版本和emmc版本，以编译emmc版本为例 ```bash sudo make distclean # 编译 emmc 版本 uboot, 加载板级配置文件，具体的板级配置文件在uboot根目录下的configs目录下 sudo make ARCH arm CROSS_COMPILE arm none eabi mx6ull_fire_mmc_defconfig # 编译 uboot sudo make ARCH arm CROSS_COMPILE arm none eabi ``` #### 生成的文件 + u boot：初步链接后得到的uboot文件 + u boot nodtb.bin：是在u boot的基础上，经过objcopy去除符号表信息之后的可执行程序， 具体代码如下 + u boot.dtb：uboot的设备树，是由arm none eabi gcc和dtc编译出来的，详细的可以分析编 译过程，这里就不展开分析了 + u boot.bin：是在u boot nodtb.bin后追加了u boot.dtb形成的 + u boot dtb.imx：是u boot.bin添加了3KB头部信息和尾部信息(结尾添加了1298字节的 00,00实际没什么作用)组成的镜像 编译生成的u boot dtb.imx 文件就是我们想要文件 ## 烧录 ### Windows MFGTool 工具是 NXP 官方推荐的一个使用USBOTG来升级镜像的软件工具，它是NXP针对 i.MX 系列处理器专门使用的烧录工具 可以用来升级linux，单独烧录某一系统分区，独立地烧 录spi flash、nor flash、sd card、nand flash，emmc 等 MFGtool工具的烧录步骤分为两个阶段：BurnStarp和Updater。第一阶段是烧录前的准 备工作，配置设备USB的vid和pid，来选择烧录的设备。第二阶段是MFGtools开始烧录到结束 烧录的过程，这个阶段的烧录过程是严格根据ucl2.xml文件来处理的，实际上是将bootloader加 载到ram，然后在运行时将编译好的文件系统和镜像文件烧录到开发板上，烧录的位置由用户指 定，可以是sdcard、nandflash，emmc等 入到mfgtool 目录中的`mfgtools release\\Profiles\\Linux\\OS Firmware\\release` 目录将相应文 件替换即 将mfgtools release\\Profiles\\Linux\\OS Firmware 目录下的 ucl2.xml 替换 “cfg.ini”文件默认为EMMC的烧写配置文件，若想要烧写NAND版本镜像，将cfg.ini 重命名为cfg emmc.ini，并将cfg nand.ini 文件重命名为cfg.ini 即可 emmc 版本：将1/4/5/7打到ON档，其他拨码开关打到OFF档。 > 也可以选择通过按键方式进入烧录模式，按键法可以不用拨码，拨码状态在之前的EMMC 或者NAND都可以 > > 1. 上电 > 2. 按下MODE按键 > 3. 按下复位(RESET)按键 > 4. 松开复位(RESET)按键 > 5. 松开MODE按键 ### Ubuntu 1. 将sd卡通过读卡器连接到虚拟机前，使用lsblk命令查看当前磁盘设备 2. 将sd卡通过读卡器连接到电脑上，并选择连接到虚拟机上 3. 再次使用lsblk命令插件磁盘设备，如下所示 4. 执行以下烧录命令，将u boot dtb.imx烧写到/dev/sdb中 ```bash sudo dd iflag dsync oflag dsync if u boot dtb.imx of /dev/sdb seek 2 ``` 将sd卡插到开发板上将拨码开关设置sd卡启动打开电源即可启动uboot。 ## 图形化配置界面 ### 安装 menuconfig 是一套图形化的配置工具，需要ncurses库支持。ncurses 库提供了一系列的API函数供调用 者生成基于文本的图形界面 ```c sudo apt get install build essential sudo apt get install libncurses5 dev ``` menuconfig 重点会用到两个文件：.config 和 Kconfig，.config 文件前面已经说了，这个文 件保存着uboot的配置项，使用menuconfig配置完uboot以后肯定要更新.config文件。Kconfig 文件是图形界面的描述文件，也就是描述界面应该有什么内容，很多目录下都会有Kconfig文 件。 在打开图形化配置界面之前，要先使用`make xxx_defconfig`对 uboot进行一次默认配置， 只需要一次即可。如果使用`make clean`清理了工程的话就那就需要重新使用`make xxx_d efconfig`再对 uboot 进行一次配置 ## 使用 使用`make menuconfig`即可打开 > 可以在这个文件里面进行使能, 也可以在板子的.h文件里面进行使能, 在这个文件里面使能的命令是识别不了的, 因为它使用的是.config文件里面的配置 可以通过这个页面使能一下DNS命令, 使能的命令在使用时候还需要设置参数`setenv dnsip 114.114.114.114` 页面最下面的Save进行保存, 一般记录为.config文件, 可以复制一份, 之后直接使用Load加载"},"/note/Linux/野火Linux/2025-10-11-55-buildroot.html":{"title":"BuildRoot","content":"# BuildRoot 它把bootloader，linux和rootfs集成在一起，可以非常方便的去定制，管理，编译和组装一个自己需要的，针对自己的设备的一个完整的软件系统 安装使用的软件 ``` sudo apt get install zlib1g dev unzip gcc g++ aptitude lib32stdc++6 4.8 dbg make build essential libncurses5 libncurses5 dev u boot tools traceroute y ``` [Buildroot Making Embedded Linux Easy](https://buildroot.org/) 下载一下`tar vxf buildroot 2021.02.3.tar.gz` `tar xvf gcc arm 8.3 2019.03 x86_64 arm linux gnueabihf.tar.xz`解压一个使用的交叉编译器 使用`make menuconfig`打开配置页面 ```c Target options > Target Architecture ARM (little endian) > Target Binary Format ELF > Target Architecture Variant cortex A7 > Target ABI EABIhf > Floating point strategy NEON/VFPv4 > ARM instruction set ARM Toolchain > Toolchain type External toolchain > Toolchain Custom toolchain //选择用户的交叉编译器 > Toolchain origin Pre installed toolchain > Toolchain path $(TOPDIR)/gcc arm 8.3 2019.03 x86_64 arm linux gnueabihf //这里填入交叉编译器路径，$(TOPDIR)是 buildroot 源码根目录 > Toolchain prefix arm linux gnueabihf //交叉编译链前缀 > External toolchain gcc version 8.x //交叉编译链版本 > External toolchain kernel headers series 4.19.x //交叉编译链 LINUX_VERSION_CODE 版本 > External toolchain C library glibc/eglibc > [*] Toolchain has SSP support? (NEW) //选中 > [*] Toolchain has RPC support? (NEW) //选中 > [*] Toolchain has C++ support? //选中 > [*] Enable MMU support (NEW) //选中 System configuration > (buildroot) System hostname buildroot //主机名字 > (Welcome to Buildroot) System banner Welcome to Buildroot //欢迎语 > Init system (BusyBox) BusyBox //使用 busybox Filesystem images > [*] ext2/3/4 root filesystem //EMMC 或 SD 卡使用 ext3/ext4 格式 > ext2/3/4 variant ext4 //选择 ext4 格式 > (300M)exact size //设置文件系统大小 > [*] ubi image containing an ubifs root filesystem //NAND 使用 ubi 格式 Kernel > [ ] Linux Kernel Bootloaders > [ ] U Boot ``` 因为Buildroot编译时会拉取软件包源码存放到dl/目录下，如果访问外网困难则拉取的时间将会 十分漫长，因此可以使用编译时拉取好的 ```bash # 根据.config 生成 defconfig 精简配置 make savedefconfig # 保存到 configs 目录下 cp f defconfig configs/imx6ullfire_defconfig # 加载配置文件 make imx6ullfire_defconfig # 编译，使用 16 线程，根据自己的电脑性能而定 make j16 ``` ```bash # 进入源码根目录 cd buildroot 2021.02.3 # 解压 tar xvf dl.tar.gz # 查看源码包 ls dl/ ``` ## 默认启动配置 ```bash ls /etc/init.d/ S01syslogd S02sysctl S20urandom rcK S02klogd S10mdev S40network rcS ``` + S01syslogd：用于启动系统日志服务，负责将系统中的各种日志信息记录到指定的日志文件 中 + S02sysctl：用于在系统启动时设置内核参数，如内存管理、进程调度等 + S02klogd：用于处理内核日志，负责从内核获取日志消息，并将其传递给系统日志机制进 行记录或显示 + S10mdev：用于管理和创建设备节点，负责在系统启动时根据内核检测到的设备信息，动态地创建和删除相应的设备节点 + S20urandom：用于初始化系统的随机数生成器，为系统提供随机数源 + S40network：用于配置和启动网络服务，包括设置网络接口的IP地址、子网掩码、网关等参数 + **rcS**：是系统启动时，用于按顺序执行/etc/init.d目录下以S开头的初始化脚本，从而启动系 统所需的各项服务, 循环遍历/etc/init.d 目录下以**S开头且后面跟着两位字符**的所有文件和目录, 使用case语句根据脚本的文件名是否以.sh结尾来决定执行方式 > 调用脚本的时候使用的参数是start + rcK：是系统关闭或重启等需要停止服务的场景时，用于按逆序来停止/etc/init.d目录下以S 开头的初始化脚本 > 电泳脚本使用的参数是stop ## 定制内容 Buildroot 源码的overlay目录存放在buildroot源码/board/xxx厂商/xxx型号/overlay目录 ```bash mkdir p buildroot 2021.02.3/board/freescale/imx6ullfire/overlay ``` 之后这个目录就是文件系统的根文件 ```bash # 加载自己的配置文件 make imx6ullfire_defconfig # 打开界面 make menuconfig ``` 在菜单中找到Systemconfiguration > Root filesystem overlay directories，或者在图像界面输入”/”， 打开搜索框，输入BR2_ROOTFS_OVERLAY的配置项可以快速找到对应位置 设置为覆盖使用的文件夹 ```bash $(TOPDIR)/board/freescale/imx6ullfire/overlay ```"},"/note/Linux/野火Linux/2025-11-25-80-ADC驱动.html":{"title":"ADC驱动","content":"# ADC驱动 纯粹的 ADC驱动也是IIO驱动框架的 ## 驱动 I.MX6ULL 有 2 个 ADC，但是对应一个 ADC 控制器 ### 设备树 ```json adc1: adc@02198000 { compatible \"fsl,imx6ul adc\", \"fsl,vf610 adc\"; reg <0x02198000 0x4000>; interrupts <GIC_SPI 100 IRQ_TYPE_LEVEL_HIGH>; clocks <&clks IMX6UL_CLK_ADC1>; num channels <2>; clock names \"adc\"; status \"disabled\"; }; ``` > **compatible**：兼容性属性，必须的，可以设置为“fsl,vf610 adc”。 > **reg**：ADC控制器寄存器信息。 > **interrupts**：中断属性，ADC1和ADC2各对应一个中断信息。 > **clocks**：时钟属性。 > **clock names**：时钟名字，可选“adc”。 > **vref supply**：此属性对应vref参考电压句柄 对应的驱动文件`drivers/iio/adc/vf610_adc.c`, 可以找到对应的绑定文档`Documentation/devicetree/bindings/iio/adc/vf610 adc.txt` 实际使用的时候添加自己的设备树配置就可以了 + 添加ADC使用的GPIO1_IO01引脚配置信息 ```c pinctrl_adc1: adc1grp { fsl,pins < MX6UL_PAD_GPIO1_IO01__GPIO1_IO01 0xb0 >; }; ``` + 接下来在imx6ull alientek emmc.dts文件中的在 regulators节点下添加参考电源子节点 ```json reg_vref_adc: regulator@2 { compatible \"regulator fixed\"; regulator name \"VREF_3V3\"; regulator min microvolt <3300000>; regulator max microvolt <3300000>; }; ``` + 最后在imx6ull alientek emmc.dts文件中向 adc1节点追加一些内容 ```c &adc1 { pinctrl names \"default\"; pinctrl 0 <&pinctrl_adc1>; num channels <2>; vref supply <&reg_vref_adc>; status \"okay\"; }; ``` > num channels用于设置IIO系统里面实际暴漏的通道的数量 ### 驱动使能 ```c > Device Drivers > Industrial I/O support > Analog to digital converters > <*> Freescale vf610 ADC driver //选中 ``` + **n_voltage1_raw**：ADC1通道 1原始值文件。 + **in_voltage_scale**：ADC1 比例文件(分辨率)，单位为 mV。实际电压值`(mV) in_voltage1_raw* in_voltage_scale`"},"/note/Linux/野火Linux/2025-12-8-82-DRM显示设备.html":{"title":"DRM显示设备","content":"# DRM显示设备 现代Linux的图形显示系统 管理所有显示相关的硬件：GPU、显示器、内存等 ``` 1. 显示控制 > 管理多个显示器 2. GPU管理 > 让程序使用显卡加速 3. 内存管理 > 高效分配显存 4. 多程序支持 > 多个程序可以同时使用显卡 ``` DRM更能适应当前日益更新的显示硬件。 比如FB原生不支持多层合成，不支持VSYNC，不支持DMA BUF，不支持异步更新，不支持fence机制等等， 而这些功能DRM原生都支持。同时DRM可以统一管理GPU和Display驱动，使得软件架构更为统一，方便管理和维护 ![image 20251208152503592](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512081525686.png) 可以看到DRM的图像系统可以分为两部分 应用层– **libdrm** 内核驱动层— **GEM**, **KMS** libdrm: 对底层接口进行封装，向上层提供通用的API接口，主要是对各种IOCTL接口进行封装。 KMS(Kernel Mode Setting): 即Mode setting：更新画面和设置显示参数。 1. 更新画面：显示buffer的切换，多图层的合成方式，以及每个图层的显示位置。 2. 设置显示参数：包括分辨率、刷新率、电源状态（休眠唤醒）等。 GEM(Graphic Execution Manager): 主要负责显示buffer的分配和释放，内存管理与同步 ## 显示 对于DRM而言，在framebuffer与显示器之间有四个部件， framebuffer的数据经过几个部件的联合处理最终把图像输出到显示器中 > 请求一个planes, 向里面的framebuffer写入图片数据, CRTC对数据进行合成 ![image 20251208152712062](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512081527168.png) + DRM Frambuffer DRM Framebuffer也是一片存放图像的内存区域， 且需要设置图像的格式(RGB888,YUV,C8等)以及画布的大小 + CRTC(Cathode Ray Tube Controller)阴极射线显像管控制器 在DRM显示系统中CRTC会配置display timings和显示分辨率(Planes提供)来扫描framebuffer上的内容，传给Encoder display timings: 扫描framebuffer的时序，因为LCD屏的显示并不像0.96寸的屏幕那样， 直接把所有的显示数据写进去就可以显示东西，LCD屏需要一定的时序才能正确显示东西， 因此，CRTC在这里就有着很重要的作用，生成视频模式定时信号,输出内容到Encoder中，Encoder和Connector则只作为数据的转换和传输 + Planes 图层: 包含向CRTC发送数据的缓存块的内存对象， 每个CRTC必须关联一个Planes，它是CRTC决定采用哪种视频模式的根据—显示分辨率（宽度和高度），像素大小，像素格式，刷新率等 1. DRM_PLANE_TYPE_PRIMARY: 主要图层，显示背景或者图像内容，每个CRTC中含一个 2. DRM_PLANE_TYPE_OVERLAY： 用于显示叠加、缩放，每个CRTC中含一个以上 3. DRM_PLANE_TYPE_CURSOR： 用于显示鼠标，每个CRTC中含0 N个 > **PRIMARY**：基础显示能力。 > **OVERLAY**：通常具备**缩放、旋转、Alpha透明度混合**等高级能力。 > **CURSOR**：极低延迟、可高速移动（硬件光标）。 图层类型 角色比喻 关键特性 数量（每 CRTC） 典型用途 : : : : : **PRIMARY** **“背景画布”图层** 主显示层，是必须存在的基石。通常分辨率固定（等于显示模式），功能基础。 **有且仅有 1 个** 显示桌面背景、主应用程序窗口。 **OVERLAY** **“悬浮小部件”图层** 拥有“超能力”，如**缩放、旋转、半透明叠加**。非常灵活。 **0 到 N 个**（取决于硬件） 播放悬浮小视频窗口、系统状态图标、OSD菜单、游戏抬头显示。 **CURSOR** **“鼠标箭头”图层** 专为极低延迟设计，由硬件直接控制移动，不经过复杂的图形流水线。 **0 到 N 个**（通常 1 2 个） **只显示鼠标光标**，确保光标移动绝对流畅，不卡顿。 + Encoder 译为编码器。它的作用就是将 pixel 像素编码（转换）为显示器所需要的信号 + Connector 对应于物理连接器 (VGA, DVI, FPD Link, HDMI, DisplayPort, S Video …) 他会连接将一个物理显示输出设备 (monitor, laptop panel, …) 。 与当前物理连接的输出设备相关的信息（如连接状态，EDID数据，DPMS状态或支持的视频模式）也存储在 Connector 内"},"/note/Linux/野火Linux/2025-9-27-34-中断.html":{"title":"","content":"## Linux中断基础概念 ## 使用 + `request_irq`注册中断 #### 回顾 裸机开发 通用中断控制器(GIC) 中断类型、硬件中断号、分发器和cpu接口单元 中断向量表 一级查表、二级查表 中断处理流程 进入irq模式、保护现场、获取硬件中断编号、执行中断处理函数、还原现场 #### GIC中断控制器节点 arch/arm/boot/dts/imx6ull.dtsi 初始化中断控制器、设置其他中断控制器节点的描述格式, 实际初始化的时间比较早, 所以不是在设备树初始化的时候进行匹配进行的 Documentation/devicetree/bindings/arm/gic.txt ```json intc: interrupt controller@a01000 { \t\tcompatible \"arm,cortex a7 gic\"; \t\t#interrupt cells <3>; // 描述中断需要使用的格式 \t\tinterrupt controller; \t\treg <0xa01000 0x1000>, \t\t <0xa02000 0x100>; // 分发器以及CPU接口 \t}; ``` #interrupt cells：描述下一级中断信息所需要的单元个数 interrupt controller：表示该设备是一个中断控制器，外设可以连接在该中断控制器上 reg：GIC的分发器和cpu接口单元寄存器地址 #### 外设中断控制器节点 arch/arm/boot/dts/imx6ull.dtsi 管理某一种具体中断, 可以在Documentation/devicetree/bindings/gpio/fsl imx gpio.txt里面描述, 以及Documentation/devicetree/bindings/gpio/gpio mxs.txt ```c gpio5: gpio@20ac000 { \t\t\t\tcompatible \"fsl,imx6ul gpio\", \"fsl,imx35 gpio\"; \t\t\t\treg <0x20ac000 0x4000>; \t\t\t\tinterrupts <GIC_SPI 74 IRQ_TYPE_LEVEL_HIGH>, \t\t\t\t\t <GIC_SPI 75 IRQ_TYPE_LEVEL_HIGH>; // 一共32个引脚 \t\t\t\tclocks <&clks IMX6UL_CLK_GPIO5>; \t\t\t\tgpio controller; \t\t\t\t#gpio cells <2>; \t\t\t\tinterrupt controller; // 标记是一个中断 \t\t\t\t#interrupt cells <2>; // 其他外设使用的时候, 描述的格式 \t\t\t\tgpio ranges <&iomuxc 0 7 10>, <&iomuxc 10 5 2>; \t\t\t}; ``` interrupts： GIC_SPI：中断类型，0 表示 SPI 中断，1 表示 PPI 中断 > **SPI（Shared Peripheral Interrupt）**：共享外设中断 > 中断号范围：通常为 32 1019（具体取决于GIC版本） > 特点：可以被路由到任何一个或多个CPU核心处理 > 示例：GPIO、USB、Ethernet等外设中断 > **PPI（Private Peripheral Interrupt）**：私有外设中断 > 中断号范围：通常为 16 31 > 特点：每个CPU核心独有的中断（如定时器中断） > **SGI（Software Generated Interrupt）**：软件生成中断 > 中断号范围：通常为 0 15 > 用途：用于CPU核心间的通信 74：中断号，对于 SPI 中断来说中断号的范围为 0~987，对于 PPI 中断来说中断号的范围为 0~15 ![image 20250927162546686](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509271625733.png) IRQ_TYPE_LEVEL_HIGH：中断类型，高电平触发 #### 其他设备使用中断节点 使用某一种具体中断, Documentation/devicetree/bindings/gpio/gpio mxs.txt ```c button_interrupt { compatible \"button_interrupt\"; pinctrl names \"default\"; pinctrl 0 <&pinctrl_button>; button_gpio <&gpio5 1 GPIO_ACTIVE_LOW>; status \"okay\"; interrupt parent <&gpio5>; // 使用gpio5的中断控制器 interrupts <1 IRQ_TYPE_EDGE_RISING>; // 实际使用的是GPIO5 1的上升沿 }; ``` interrupt parent：表明归属的上一级中断 interrupts： 1：具体中断源，GPIO5 1 IRQ_TYPE_EDGE_RISING：中断类型，上升沿触发 ##### 中断类型 include/linux/irq.h ```c enum { \tIRQ_TYPE_NONE\t\t 0x00000000, \tIRQ_TYPE_EDGE_RISING\t 0x00000001, \tIRQ_TYPE_EDGE_FALLING\t 0x00000002, \tIRQ_TYPE_EDGE_BOTH\t (IRQ_TYPE_EDGE_FALLING IRQ_TYPE_EDGE_RISING), \tIRQ_TYPE_LEVEL_HIGH\t 0x00000004, \tIRQ_TYPE_LEVEL_LOW\t 0x00000008, \t... \t} ``` #### 常用函数 ##### request_irq()函数 申请中断, 激活中断, 可能会导致睡眠 include/linux/interrupt.h ```c static inline int __must_check request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, \t const char *name, void *dev) ``` 参数： irq：要申请的中断号, 一般是在设备树里面可以获取 handler：中断处理函数 flags：中断标志, 中断放入特征 name：中断名字 dev：传递给中断处理函数的第二个参数 device结构体变量，区分不同设备共用同一中断 返回值： 成功：0 失败：负数 ###### irq_handler_t 中断处理函数 ```c typedef irqreturn_t (*irq_handler_t)(int, void *); ``` ###### irqreturn_t ```c enum irqreturn { IRQ_NONE (0 << 0), IRQ_HANDLED (1 << 0), IRQ_WAKE_THREAD (1 << 1), }; typedef enum irqreturn irqreturn_t; ``` IRQ_NONE：不是本驱动程序的中断，不处理 IRQ_HANDLED：正常处理 IRQ_WAKE_THREAD：这个处理函数里面暂时不处理, 使用中断下半部处理 ###### flags include/linux/interrupt.h里面记录有更多的中断 ```c #define IRQF_SHARED\t\t0x00000080 #define IRQF_ONESHOT\t\t0x00002000 #define IRQF_TRIGGER_NONE\t0x00000000 #define IRQF_TRIGGER_RISING\t0x00000001 #define IRQF_TRIGGER_FALLING\t0x00000002 #define IRQF_TRIGGER_HIGH\t0x00000004 #define IRQF_TRIGGER_LOW\t0x00000008 ``` IRQF_SHARED: 共享中断, 多外设使用 IRQF_ONESHOT: 只处理一次 ##### free_irq()函数 释放中断 include/linux/interrupt.h ```c const void *free_irq(unsigned int irq, void *dev_id) ``` 参数： irq：要释放的中断号 dev：传递给中断处理函数的第二个参数 返回值： ​\t无 ##### enable_irq()函数 使能中断 kernel/irq/manage.c ```c void enable_irq(unsigned int irq) ``` 参数： irq：要使能的中断号 返回值： ​\t无 ##### disable_irq()函数 禁止中断，等待中断执行完毕 kernel/irq/manage.c ```c void disable_irq(unsigned int irq) ``` 参数： irq：要禁止的中断号 返回值： ​\t无 ##### disable_irq_nosync()函数 禁止中断，不等待中断执行完 kernel/irq/manage.c ``` void disable_irq_nosync(unsigned int irq) ``` 参数： irq：要禁止的中断号 返回值： ​\t无 ##### local_irq_disable()宏 include/linux/irqflags.h 禁止处理器中断 ```c #define local_irq_disable()\tdo { raw_local_irq_disable(); } while (0) ``` ##### local_irq_enable()宏 include/linux/irqflags.h 开处理器中断 ```c #define local_irq_enable()\tdo { raw_local_irq_enable(); } while (0) ``` ##### 记录关闭前中断的状态 ```c unsigned long flags; local_irq_save(flags) local_irq_restore(flags) ``` ### 设备树获取 ```c unsigned int irq_of_parse_and_map(struct device_node *dev, int index) ``` + **dev**：设备节点。 + **index**：索引号，interrupts属性可能包含多条中断信息，通过index指定要获取的信息。 + 返回值：中断号。 gpio可以使用gpio的标号获取 ```c int gpio_to_irq(unsigned int gpio) ``` 获取中断号 ## Linux按键中断实验 #### 硬件原理图 ![image 20200917203137234](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509271633109.png) #### 设备树节点 ##### iomuxc子节点 描述一下引脚的硬件配置 ``` pinctrl_button: button{ \t\t\t\tfsl,pins < \t\t\t\t\tMX6UL_PAD_SNVS_TAMPER1__GPIO5_IO01 0x000110A1 \t\t\t\t>; \t\t\t}; ``` ##### 自定义按键节点 ```json button_interrupt { pinctrl names \"default\"; pinctrl 0 <&pinctrl_button>; button_gpio <&gpio5 1 GPIO_ACTIVE_LOW>; interrupt parent <&gpio5>; interrupts <1 IRQ_TYPE_EDGE_RISING>; }; ``` #### irq_of_parse_and_map()函数 drivers/of/irq.c ```c unsigned int irq_of_parse_and_map(struct device_node *dev, int index) ``` 参数： dev：设备节点 index：索引号，interrupts属性可能包含多条中断信息 返回值：中断号 ## 实际应用 ```c #include <linux/init.h> #include <linux/kernel.h> #include <linux/module.h> #include <linux/fs.h> #include <linux/cdev.h> #include <linux/uaccess.h> #include <linux/delay.h> #include <linux/ide.h> #include <linux/errno.h> #include <linux/gpio.h> #include <asm/mach/map.h> #include <linux/of.h> #include <linux/of_address.h> #include <linux/of_gpio.h> #include <asm/io.h> #include <linux/device.h> #include <linux/irq.h> #include <linux/of_irq.h> /* 字符设备内容 */ #define DEV_NAME \"button\" #define DEV_CNT (1) static dev_t button_devno;\t\t //定义字符设备的设备号 static struct cdev button_chr_dev; //定义字符设备结构体chr_dev struct class *class_button;\t\t //保存创建的类 struct device *device_button;\t\t // 保存创建的设备 struct device_node\t*button_device_node NULL; //定义按键设备节点结构体 unsigned button_GPIO_number 0; //保存button使用的GPIO引脚编号 u32 interrupt_number 0; // button 引脚中断编号 atomic_t button_status ATOMIC_INIT(0); //定义整型原子变量，保存按键状态 ，设置初始值为0 static irqreturn_t button_irq_hander(int irq, void *dev_id) { \t// printk_green(\"button on \\n\"); \t/*按键状态加一*/ \tatomic_inc(&button_status); \treturn IRQ_HANDLED; } static int button_open(struct inode *inode, struct file *filp) { \tint error 1; \t \t \t/*添加初始化代码*/ \t// printk_green(\"button_open\"); \t/*获取按键 设备树节点*/ \tbutton_device_node of_find_node_by_path(\"/button_interrupt\"); \tif(NULL button_device_node) \t{ \t\tprintk(\"of_find_node_by_path error!\"); \t\treturn 1; \t} \t/*获取按键使用的GPIO*/ \tbutton_GPIO_number of_get_named_gpio(button_device_node ,\"button_gpio\", 0); \tif(0 button_GPIO_number) \t{ \t\tprintk(\"of_get_named_gpio error\"); \t\treturn 1; \t} \t/*申请GPIO , 记得释放*/ \terror gpio_request(button_GPIO_number, \"button_gpio\"); \tif(error < 0) \t{ \t\tprintk(\"gpio_request error\"); \t\tgpio_free(button_GPIO_number); \t\treturn 1; \t} \terror gpio_direction_input(button_GPIO_number);//设置引脚为输入模式 \t/*获取中断号*/ \tinterrupt_number irq_of_parse_and_map(button_device_node, 0); \tprintk(\"\\n irq_of_parse_and_map! %d \\n\",interrupt_number); \t/*申请中断, 记得释放*/ \terror request_irq(interrupt_number,button_irq_hander,IRQF_TRIGGER_RISING,\"button_interrupt\",device_button); \tif(error ! 0) \t{ \t\tprintk(\"request_irq error\"); \t\tfree_irq(interrupt_number, device_button); \t\treturn 1; \t} \t/*申请之后已经开启了，切记不要再次打开，否则运行时报错*/ \t// // enable_irq(interrupt_number); \treturn 0; } static int button_read(struct file *filp, char __user *buf, size_t cnt, loff_t *offt) { \tint error 1; \tint button_countervc 0; \t/*读取按键状态值*/ \tbutton_countervc atomic_read(&button_status); \t/*结果拷贝到用户空间*/ \terror copy_to_user(buf, &button_countervc, sizeof(button_countervc)); \tif(error < 0) \t{ \t\tprintk(\"copy_to_user error\"); \t\treturn 1; \t} \t/*清零按键状态值*/ \tatomic_set(&button_status,0); \treturn 0; } /*字符设备操作函数集，.release函数实现*/ static int button_release(struct inode *inode, struct file *filp) { \t/*释放申请的引脚,和中断*/ \tgpio_free(button_GPIO_number); \tfree_irq(interrupt_number, device_button); \treturn 0; } /*字符设备操作函数集*/ static struct file_operations button_chr_dev_fops { \t.owner THIS_MODULE, \t.open button_open, \t.read button_read, \t.release button_release}; /* *驱动初始化函数 */ static int __init button_driver_init(void) { \tint error 1; \t/*采用动态分配的方式，获取设备编号，次设备号为0，*/ \terror alloc_chrdev_region(&button_devno, 0, DEV_CNT, DEV_NAME); \tif (error < 0) \t{ \t\tprintk(\"fail to alloc button_devno\\n\"); \t\tgoto alloc_err; \t} \t/*关联字符设备结构体cdev与文件操作结构体file_operations*/ \tbutton_chr_dev.owner THIS_MODULE; \tcdev_init(&button_chr_dev, &button_chr_dev_fops); \t/*添加设备至cdev_map散列表中*/ \terror cdev_add(&button_chr_dev, button_devno, DEV_CNT); \tif (error < 0) \t{ \t\tprintk(\"fail to add cdev\\n\"); \t\tgoto add_err; \t} \tclass_button class_create(THIS_MODULE, DEV_NAME); //创建类 \tdevice_button device_create(class_button, NULL, button_devno, NULL, DEV_NAME);//创建设备 DEV_NAME 指定设备名， \treturn 0; add_err: \tunregister_chrdev_region(button_devno, DEV_CNT); // 添加设备失败时，需要注销设备号 \tprintk(\"\\n error! \\n\"); \t alloc_err: \treturn 1; } /* *驱动注销函数 */ static void __exit button_driver_exit(void) { \tpr_info(\"button_driver_exit\\n\"); \t/*删除设备*/ \tdevice_destroy(class_button, button_devno);\t\t //清除设备 \tclass_destroy(class_button);\t\t\t\t\t //清除类 \tcdev_del(&button_chr_dev);\t\t\t\t\t //清除设备号 \tunregister_chrdev_region(button_devno, DEV_CNT); //取消注册字符设备 } module_init(button_driver_init); module_exit(button_driver_exit); MODULE_LICENSE(\"GPL\"); ```"},"/note/Linux/野火Linux/2025-7-15-11-字符设备.html":{"title":"字符设备","content":"# 字符设备 ![image 20250901220422532](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509012204612.png) ## **字符设备注册流程** **步骤 1**： 调用 `__register_chrdev_region()` → 创建/更新 `char_device_struct`，添加到 `chrdevs[]` 哈希表。 **步骤 2**： 调用 `cdev_add()` → 最终触发 `kobj_map(cdev_map, ...)`： 向全局 `kobj_map` 实例 **`cdev_map`**（专用于字符设备）插入一个 `probe`。 `probe >data` 指向字符设备的 `struct cdev`。 `probe >get` 设置为默认回调 `exact_match()`（通过设备号查找 `cdev`）。 > 实际使用的时候有两个框架 > > 1. 使用`register_chrdev`一个函数实现注册以及设备号的分配, 使用结束以后`unregister_chrdev`释放 > > ```c > stic inline int register_chrdev(unsigned int major, const char *name, const struct file_operations *fops) > static inline void unregister_chrdev(unsigned int major, const char *name) > ``` > > 2. 分配设备号以及字符设备的注册是分开的 > > `int alloc_chrdev_region(dev_t *dev, unsigned baseminor, unsigned count, const char *nam e) `: 向Linux内核申请, 一般是动态的申请, 可以使用`MKDEV`合成完整设备号 > > `int register_chrdev_region(dev_t from, unsigned count, const char *name)`动态获取一下 > > 使用结束以后释放`void unregister_chrdev_region(dev_t from, unsigned count)` > > 设备号和字符设备是分开的 > > 使用`void cdev_init(struct cdev *cdev, const struct file_operations *fops)`初始化, 初始化以后`int cdev_add(struct cdev *p, dev_t dev, unsigned count) `添加, 释放的时候`void cdev_del(struct cdev *p)` ## **字符设备打开流程** **步骤 1**： 用户调用 `open(\"/dev/char_dev\")` → VFS 通过设备号查找操作函数集。 **步骤 2**： 调用 `kobj_lookup(cdev_map, dev_t, &idx)`： 在 `cdev_map` 的哈希表中搜索匹配的 `probe`。 执行 `probe >get()` 回调 → 返回 `cdev >kobj`。 **步骤 3**： 通过 `container_of` 从 `kobject` 获取 `struct cdev` → 访问其 `file_operations`。 > **`char_device_struct` 为静态管理**： > 记录设备号分配情况（防止冲突），维护 `major/minor` 到 `cdev` 的基本映射。 > **`kobj_map` 为动态映射**： > 提供高效的设备号（`dev_t`）到内核对象（`kobject`）的运行时查找，实际用于设备操作。 ### 字符设备抽象成文件 openalloc_chrdev_region()函数,在文件系统中找到指定文件的操作接口，绑定到进程`task_srtuct >files_struct >fd_array[] >file_operations` 实际实现的时候需要read, write等文件操控函数的实现 ### 驱动层原理 把file_operations文件操作接口注册到内核，内核通过主次设备号来登记记录它 构造驱动基本对象：struct cdev，里面记录具体的file_operations ```c cdev_init() ``` > 实际是建立两个hash表 > > chrdevs：登记设备号, 看一下是不是被使用了 > > ``` > __register_chrdev_region() > ``` > > > **注册函数**：`__register_chrdev_region()` > > 申请主设备号（如 255） > > 指定次设备号范围（如 0~255） > > 冲突检测：防止重复注册相同设备号 > > cdev_map >probe：保存驱动基本对象`struct cdev` > > ``` > cdev_add() > ``` > > > **注册流程**： > > > > 1. **初始化**：`cdev_init(&my_cdev, &my_fops);` > > > > 绑定 `file_operations` 到 `cdev` > > > > 2. **添加到系统**：`cdev_add(&my_cdev, dev, count);` > > > > `dev`：起始设备号（主+次） > > `count`：连续设备数量 > > > > 3. **存入 cdev_map**： > > > > ```c > > struct kobj_map *cdev_map; // 全局映射表 > > kobj_map(cdev_map, dev, count, NULL, exact_match, exact_lock, my_cdev); > > ``` > > > > 生成 `dev_t → cdev` 的映射关系 ### 文件系统层原理 mknod指令+主从设备号, 生成一个实际用于读写控制的文件 构建一个新的设备文件 通过主次设备号在cdev_map中找到cdev >file_operations 把cdev >file_operations绑定到新的设备文件中 到这里，应用程序就可以使用open()、write()、read()等函数来控制设备文件了 ## 设备号的组成与哈希表 #### 设备号 记录在文件`ebf buster linux/include/linux/kdev_t.h` ```c #define MINORBITS\t20 #define MINORMASK\t((1U << MINORBITS) 1) #define MAJOR(dev)\t((unsigned int) ((dev) >> MINORBITS)) #define MINOR(dev)\t((unsigned int) ((dev) & MINORMASK)) #define MKDEV(ma,mi)\t(((ma) << MINORBITS) (mi)) 理论取值范围 主设备号：2^12 1024*4 4k 次设备号：2^20 1024*1024 1M ``` 已注册的设备号可以使用`cat /proc/devices`查看 内核是希望一个设备驱动(file_operation)可以独自占有一个主设备号和多个次设备号，而通常一个设备文件绑定一个主设备号和一个次设备号，所以设备驱动与设备文件是一对一或者一对多的关系。 > 通常情况下主设备号相同的话使用的file_operation是一样的 #### hash table 哈希表、散列表 数组的优缺点：查找快，增删元素效率低，容量固定 链表的优缺点：查找慢，增删元素效率高，容量不限 哈希表：数组+链表 以主设备号为编号，使用哈希函数`f(major) major%255`来计算数组下标 主设备号冲突(如0、255)，则以次设备号为比较值来排序**链表**节点。 > 使用一个数组记录链表的头结点 哈希函数的设计目标：链表节点尽量平均分布在各个数组元素中，提高查询效率 ## 管理设备号 ##### 关键数据结构 ebf buster linux/fs/char_dev.c ```c static struct char_device_struct { \t//指向下一个链表节点 struct char_device_struct *next; \t//主设备号 unsigned int major; \t//次设备号 unsigned int baseminor; \t//次设备号的数量 int minorct; \t//设备的名称 char name[64]; \t//内核字符对象(已废弃) struct cdev *cdev; /* will die */ } *chrdevs[CHRDEV_MAJOR_HASH_SIZE]; // 一共有255个, 用于管理设备号 ``` > 一个专门用于设备号管理的结构, 记录字符设备号范围（主设备号 + 次设备号范围）与字符设备驱动程序（`struct cdev`）的映射关系。 #### __register_chrdev_region函数分析 ebf buster linux/fs/char_dev.c 保存新注册的设备号到chrdevs哈希表中，防止设备号冲突 分析结论： 主设备号为0，动态分配设备号： 优先使用：255~234 其次使用：511~384 主设备号最大为512 ```c /* * Register a single major with a specified minor range. * * If major 0 this functions will dynamically allocate a major and return * its number. * * If major > 0 this function will attempt to reserve the passed range of * minors and will return zero on success. * * Returns a ve errno on failure. */ static struct char_device_struct * __register_chrdev_region(unsigned int major, unsigned int baseminor, \t\t\t int minorct, const char *name) { \tstruct char_device_struct *cd, **cp; \tint ret 0; \tint i; \t \tcd kzalloc(sizeof(struct char_device_struct), GFP_KERNEL); \tif (cd NULL) \t\treturn ERR_PTR( ENOMEM); \t// 获取一个互斥锁 \tmutex_lock(&chrdevs_lock); \t// 动态分配一个主设备号 \tif (major 0) { \t\tret find_dynamic_major(); \t\tif (ret < 0) { \t\t\tpr_err(\"CHRDEV \\\"%s\\\" dynamic allocation region is full\\n\", \t\t\t name); \t\t\tgoto out; \t\t} \t\tmajor ret; \t} \t// 判断一下是不是合法, 最多512个 \tif (major > CHRDEV_MAJOR_MAX) { \t\tpr_err(\"CHRDEV \\\"%s\\\" major requested (%u) is greater than the maximum (%u)\\n\", \t\t name, major, CHRDEV_MAJOR_MAX 1); \t\tret EINVAL; \t\tgoto out; \t} \t \tcd >major major; \tcd >baseminor baseminor; \tcd >minorct minorct; \tstrlcpy(cd >name, name, sizeof(cd >name)); \ti major_to_index(major); \tfor (cp &chrdevs[i]; *cp; cp &(*cp) >next) \t\tif ((*cp) >major > major \t\t ((*cp) >major major && \t\t (((*cp) >baseminor > baseminor) \t\t ((*cp) >baseminor + (*cp) >minorct > baseminor)))) \t\t\tbreak; \t/* Check for overlapping minor ranges. 查看一下子设备号范围是不是会冲突*/ \tif (*cp && (*cp) >major major) { \t\tint old_min (*cp) >baseminor; \t\tint old_max (*cp) >baseminor + (*cp) >minorct 1; \t\tint new_min baseminor; \t\tint new_max baseminor + minorct 1; \t\t/* New driver overlaps from the left. */ \t\tif (new_max > old_min && new_max < old_max) { \t\t\tret EBUSY; \t\t\tgoto out; \t\t} \t\t/* New driver overlaps from the right. */ \t\tif (new_min < old_max && new_min > old_min) { \t\t\tret EBUSY; \t\t\tgoto out; \t\t} \t\tif (new_min < old_min && new_max > old_max) { \t\t\tret EBUSY; \t\t\tgoto out; \t\t} \t} \t// 插入链表 \tcd >next *cp; \t*cp cd; \tmutex_unlock(&chrdevs_lock); \treturn cd; out: \tmutex_unlock(&chrdevs_lock); \tkfree(cd); \treturn ERR_PTR(ret); } ``` 动态获取一个空闲的数组位置 ```c static int find_dynamic_major(void) { \tint i; \tstruct char_device_struct *cd; \t// 优先234 254 \tfor (i ARRAY_SIZE(chrdevs) 1; i > CHRDEV_MAJOR_DYN_END; i ) { // 记录在链表的第一位 \t\tif (chrdevs[i] NULL) \t\t\treturn i; \t} \t// 511 384的设备 \tfor (i CHRDEV_MAJOR_DYN_EXT_START; \t i > CHRDEV_MAJOR_DYN_EXT_END; i ) { // major_to_index 哈希函数, 实际是 % 255, 遍历一下链表 \t\tfor (cd chrdevs[major_to_index(i)]; cd; cd cd >next) \t\t\tif (cd >major i) \t\t\t\tbreak; \t\tif (cd NULL) \t\t\treturn i; \t} \treturn EBUSY; } ``` ## 保存file_operation接口 #### 关键数据结构梳理 `kobj_map` 是一个全局的注册表/映射表，而 `cdev` 是被注册到这个表中的项目。它们共同协作，实现了字符设备号（主设备号、次设备号）到具体字符设备驱动程序（`cdev` 结构体）的动态查找和关联。 kernel/ebf buster linux/include/linux/cdev.h 字符设备管理对象, 记录实际的设备的数据 ```c struct cdev { \t//内核驱动基本对象, 继承上一级 struct kobject kobj; \t//相关内核模块 struct module *owner; \t//设备驱动接口, 实际调用的各种接口 const struct file_operations *ops; \t//链表节点 struct list_head list; \t//设备号 dev_t dev; \t//次设备号的数量 unsigned int count; } __randomize_layout; ``` ebf buster linux/fs/char_dev.c 另一个哈希表probes, 用于记录file_operations这个接口 ```c struct kobj_map { \tstruct probe { \t\t//指向下一个链表节点 \t\tstruct probe *next; \t\t//设备号 \t\tdev_t dev; \t\t//次设备号的数量 \t\tunsigned long range; \t\tstruct module *owner; \t\tkobj_probe_t *get; \t\tint (*lock)(dev_t, void *); \t\t//空指针，内核常用技巧, 一般用于记录struct cdev这个结构体 \t\tvoid *data; \t} *probes[255]; // 互斥锁 \tstruct mutex *lock; }; ``` > 是**通用设备号映射框架**, 管理设备号（`dev_t`）到内核对象（`kobject`）的动态映射。用于字符设备（`cdev_map`）、块设备（`bdev_map`）等。 ### 新的接口 #### cdev_init函数分析 实际相比于这个函数使用`register_chrdev`函数作为`cdev_init + cdev_add`更方便 ebf buster linux/fs/char_dev.c 记录一下实际的操作函数 ```c /** * cdev_init() initialize a cdev structure * @cdev: the structure to initialize * @fops: the file_operations for this device * * Initializes @cdev, remembering @fops, making it ready to add to the * system with cdev_add(). */ void cdev_init(struct cdev *cdev, const struct file_operations *fops) { \tmemset(cdev, 0, sizeof *cdev); \tINIT_LIST_HEAD(&cdev >list); \tkobject_init(&cdev >kobj, &ktype_cdev_default); \tcdev >ops fops; // 记录一下file_operations } ``` 保存file_operation到cdev中 #### cdev_add函数分析 ebf buster linux/fs/char_dev.c 根据哈希函数保存cdev到probes哈希表中，方便内核查找file_operation使用 ```c /** * cdev_add() add a char device to the system * @p: the cdev structure for the device * @dev: the first device number for which this device is responsible * @count: the number of consecutive minor numbers corresponding to this * device * * cdev_add() adds the device represented by @p to the system, making it * live immediately. A negative error code is returned on failure. */ int cdev_add(struct cdev *p, dev_t dev, unsigned count) { \tint error; \t// 记录一下设备号以及设备数量 \tp >dev dev; \tp >count count; \t// 实际的填充数据, 记录到prob里面 \terror kobj_map(cdev_map, dev, count, NULL, \t\t\t exact_match, exact_lock, p); \tif (error) \t\treturn error; \tkobject_get(p >kobj.parent); \treturn 0; } ``` ```c int kobj_map(struct kobj_map *domain, dev_t dev, unsigned long range, \t struct module *module, kobj_probe_t *probe, \t int (*lock)(dev_t, void *), void *data) { // 计算一下次设备号是不是溢出, 溢出的话计算一下需要几个主设备号 \tunsigned n MAJOR(dev + range 1) MAJOR(dev) + 1; \tunsigned index MAJOR(dev); \tunsigned i; \tstruct probe *p; \t// 计算一下主设备号的数量 \tif (n > 255) \t\tn 255; \t// 获取probe结构体 \tp kmalloc_array(n, sizeof(struct probe), GFP_KERNEL); \tif (p NULL) \t\treturn ENOMEM; \t// 使用probe结构体保存一下cdev的数据 \tfor (i 0; i < n; i++, p++) { \t\tp >owner module; \t\tp >get probe; \t\tp >lock lock; \t\tp >dev dev; \t\tp >range range; \t\tp >data data; \t} \tmutex_lock(domain >lock); \tfor (i 0, p n; i < n; i++, p++, index++) { \t\tstruct probe **s &domain >probes[index % 255]; // 按照范围的大小进行排序, 获取在这个链表的位置 \t\twhile (*s && (*s) >range < range) \t\t\ts &(*s) >next; \t\tp >next *s; \t\t*s p; \t} \tmutex_unlock(domain >lock); \treturn 0; } ``` ### 旧的接口 #### register_chrdev函数(cdev_init + cdev_add) ebf buster linux/include/linux/fs.h ```c static inline int register_chrdev(unsigned int major, const char *name, \t\t\t\t const struct file_operations *fops) { // 实际是设置主设备号随机分配, 次设备号有256个 \treturn __register_chrdev(major, 0, 256, name, fops); } ``` #### __register_chrdev函数 kernel/ebf buster linux/fs/char_dev.c ```c int __register_chrdev(unsigned int major, unsigned int baseminor,unsigned int count, const char *name,const struct file_operations *fops) { \tstruct char_device_struct *cd; \tstruct cdev *cdev; \tint err ENOMEM; \t// 登记设备号, 0的时候自动分分配 \tcd __register_chrdev_region(major, baseminor, count, name); ... // 实际是实现cdev_init函数的功能 \tcdev cdev_alloc(); ... // 记录信息 \tcdev >owner fops >owner; \tcdev >ops fops; ... // 记录实际的cdec到probe里面 \terr cdev_add(cdev, MKDEV(cd >major, baseminor), count); ... } ``` 次设备号为0，次设备号数量为256 ## 创建一个设备文件 ### mknod命令 创建指定类型的特殊文件 mknod help ``` 用法：mknod [选项]... 名称 类型 [主设备号 次设备号] Create the special file NAME of the given TYPE. ... 当类型为\"p\"时可不指定主设备号和次设备号，否则它们是必须指定的。 如果主设备号和次设备号以\"0x\"或\"0X\"开头，它们会被视作十六进制数来 解析；如果以\"0\"开头，则被视作八进制数；其余情况下被视作十进制数。 可用的类型包括： b 创建(有缓冲的)区块特殊文件 c, u 创建(没有缓冲的)字符特殊文件 p 创建先进先出(FIFO)特殊文件, 一般不需要设备号 ``` ![image 20250717172315583](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507171723834.png) > vfs是虚拟文件系统, 根据文件系统的类型去使用实际的文件系统进行创建, 最后实际是建立一个inode节点 > > 在Linux和其他类Unix操作系统中，inode（索引节点）是用来存储文件元数据的一个数据结构。它相当于文件的“身份证”或“档案卡”，描述了文件的各种信息，但不包含文件名本身。 > > 一个inode主要包含以下内容： > > 文件的类型（普通文件、目录、符号链接等） > 文件的权限（读、写、执行权限） > 文件所有者的用户ID（UID） > 文件所属组的组ID（GID） > 文件的大小 > 文件的创建、修改、访问时间戳 > 指向存储文件内容的磁盘块的指针（数据块地址） > > 每个文件在创建时都会分配一个唯一的inode编号，操作系统通过这个编号找到文件的所有元数据。文件名是存储在目录中的条目，目录实际上是从文件名到inode编号的映射。 > > ![image 20250717173334639](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507171733711.png) ### init_special_inode函数分析 ebf buster linux/fs/inode.c 判断文件的inode类型，如果是字符设备类型，则把def_chr_fops作为该文件的操作接口，并把设备号记录在inode >i_rdev。 ```c // mode是文件的权限, rdev是设备号 void init_special_inode(struct inode *inode, umode_t mode, dev_t rdev) { \tinode >i_mode mode; \tif (S_ISCHR(mode)) { \t\tinode >i_fop &def_chr_fops; // 初始化一下通用的操作接口(之后这个接口调用自己构建的) \t\tinode >i_rdev rdev; // 记录一下设备号 \t} else if (S_ISBLK(mode)) { \t\tinode >i_fop &def_blk_fops; \t\tinode >i_rdev rdev; \t} else if (S_ISFIFO(mode)) \t\tinode >i_fop &pipefifo_fops; \telse if (S_ISSOCK(mode)) \t\t;\t/* leave it no_open_fops */ \telse \t\tprintk(KERN_DEBUG \"init_special_inode: bogus i_mode (%o) for\" \t\t\t\t \" inode %s:%lu\\n\", mode, inode >i_sb >s_id, \t\t\t\t inode >i_ino); } ``` ## open函数查找file_operation ![image 20250717191133208](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507171911323.png) get_unused_fd_flags 为本次操作分配一个未使用过的文件描述符 do_file_open 生成一个空白struct file结构体 从文件系统中查找到文件对应的inode + do_dentry_open + 获取到实际inode的chrdev_open 函数, 并进行调用, 记录在任务的文件句柄里面 ```c static int do_dentry_open(struct file *f, \t\t\t struct inode *inode, \t\t\t int (*open)(struct inode *, struct file *)) { \t... \t/*把inode的file_operation赋值给struct file的f_op*/ \tf >f_op fops_get(inode >i_fop); // 这个参数是在创建文件的时候初始化的 \t... \tif (!open) \t\topen f >f_op >open; \tif (open) { \t\terror open(inode, f); \t\tif (error) \t\t\tgoto cleanup_all; \t} \t... } ``` def_chr_fops >chrdev_open 实际用于调用不同的cdev注册的operation的函数 ​\tebf buster linux/fs/char_dev.c ```c static int chrdev_open(struct inode *inode, struct file *filp) { \tconst struct file_operations *fops; \tstruct cdev *p; \tstruct cdev *new NULL; \t... \tstruct kobject *kobj; \tint idx; \t/*从内核哈希表cdev_map中，根据设备号查找自己注册的sturct cdev，获取cdev中的file_operation接口*/ \tkobj kobj_lookup(cdev_map, inode>i_rdev,&idx); \tnew container_of(kobj, struct cdev, kobj); \t... \tinode >i_cdev p new; \t... \tfops fops_get(p >ops); \t... \t/*把cdev中的file_operation接口赋值给struct file的f_op*/ \treplace_fops(filp, fops); \t \t/*调用自己实现的file_operation接口中的open函数*/ \tif (filp >f_op >open) { \t\tret filp >f_op >open(inode, filp); \t\tif (ret) \t\t\tgoto out_cdev_put; \t} \t... } ``` ### struct file ```c struct file *filp; // 在操作函数中常用的 filp 字段 filp >f_flags; // 文件打开标志 (O_RDONLY, O_WRONLY, O_NONBLOCK等) filp >f_mode; // 文件访问模式 filp >f_pos; // 当前文件位置 (读写偏移量) filp >f_op; // 文件操作函数指针 ``` 可以使用这个结构体里面的`private_data`传递数据 ## ioctl ### 用户空间 ```c #include <sys/ioctl.h> int ioctl(int fd, int cmd, ...); ``` ### 驱动 ```c long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long); long (*compat_ioctl) (struct file *, unsigned int, unsigned long); ``` > unlocked_ioctl，顾名思义，应该在无大内核锁(BKL)的情况下调用；compat_ioctl，compat 全称 compatible(兼容的)，主要目的是为 64 位系统提供 32 位 ioctl 的兼容方法，也是在无大内核锁的情况下调用 > > 一般情况下只要实现 unlocked_ioctl 函数即可 ### cmd ioctl 方法第二个参数 cmd 为用户与驱动的 “协议”，理论上可以为任意 int 型数据，可以为 0、1、2、3……，但是为了确保该 “协议” 的唯一性，ioctl 命令应该使用更科学严谨的方法赋值，在linux中，提供了一种 ioctl 命令的统一格式，将 32 位 int 型数据划分为四个位段 ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/v2 c4c0b56ac8ca78b86cfa709979a381d0_r.jpg) > 1. dir（direction），ioctl 命令访问模式（数据传输方向），占据 2 bit，可以为 _IOC_NONE、_IOC_READ、_IOC_WRITE、_IOC_READ _IOC_WRITE，分别指示了四种访问模式：无数据、读数据、写数据、读写数据； > 2. type（device type），设备类型，占据 8 bit，在一些文献中翻译为 “幻数” 或者 “魔数”，可以为任意 char 型字符，例如‘a’、’b’、’c’ 等等，其主要作用是使 ioctl 命令有唯一的设备标识； > 3. nr（number），命令编号/序数，占据 8 bit，可以为任意 unsigned char 型数据，取值范围 0~255，如果定义了多个 ioctl 命令，通常从 0 开始编号递增； > 4. size，涉及到 ioctl 函数 第三个参数 arg ，占据 13bit 或者 14bit（体系相关，arm 架构一般为 14 位），指定了 arg 的数据类型及长度，如果在驱动的 ioctl 实现中不检查，通常可以忽略该参数 实际合成的时候可以使用以下的宏定义 ```c /* used to create numbers */ #define _IO(type,nr) _IOC(_IOC_NONE,(type),(nr),0) #define _IOR(type,nr,size) _IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size))) #define _IOW(type,nr,size) _IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size))) #define _IOWR(type,nr,size) _IOC(_IOC_READ_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size))) ``` > _IO： 定义不带参数的 ioctl 命令 > _IOW： 定义带写参数的 ioctl 命令（copy_from_user） > _IOR： 定义带读参数的ioctl命令（copy_to_user） > _IOWR： 定义带读写参数的 ioctl 命令 > > 这里面的type指的是魔数, 可以在手册里面查看Documentation/ioctl/ioctl number.txt > > size设置为一个数据类型, 比如`struct test`, `int`等, 但是实际传输的还是一个unsigned long类型, 所以可以使用这个参数传递一个指针或一个数字, 传递的参数不受这个宏定义控制, 只是一个约定俗成的定义方式 ## 代码实现 1. 可以直接使用`register_chrdev`一个函数实现所有的功能 2. 使用分开的函数实现 + 使用alloc_chrdev_region动态分配一个内存 + 使用函数cdev_init初始化一个cdev结构体 + 使用cdev_add添加设备号等信息 `alloc_chrdev_region(dev_t *, baseminor, count, name)` > 分别是输出参数, 起始的设备号, 分配的数量以及设备的名字 ```c //第一步 //采用动态分配的方式，获取设备编号，次设备号为0， //设备名称为EmbedCharDev，可通过命令cat /proc/devices查看 //DEV_CNT为1，当前只申请一个设备编号 ret alloc_chrdev_region(&led_devno, 0, DEV_CNT, DEV_NAME); if(ret < 0){ printk(\"fail to alloc led_devno\\n\"); goto alloc_err; } led_chrdev_class class_create(THIS_MODULE, \"led_chrdev\"); //第二步 //关联字符设备结构体cdev与文件操作结构体file_operations cdev_init(&led_chr_dev, &led_chr_dev_fops); //第三步 //添加设备至cdev_map散列表中 ret cdev_add(&led_chr_dev, led_devno, DEV_CNT); ``` + 使用register_chrdev实现 ```c #include <linux/module.h> #include <linux/init.h> #include <linux/kernel.h> #include <linux/fs.h> #include <linux/uaccess.h> #include <asm/io.h> #define DEV_MAJOR\t\t0\t\t/* 动态申请主设备号 */ #define DEV_NAME\t\t\"red_led\" \t/*led设备名字 */ /* GPIO虚拟地址指针 */ static void __iomem *IMX6U_CCM_CCGR1; static void __iomem *SW_MUX_GPIO1_IO04; static void __iomem *SW_PAD_GPIO1_IO04; static void __iomem *GPIO1_DR; static void __iomem *GPIO1_GDIR; static int led_open(struct inode *inode, struct file *filp) { \treturn 0; } static ssize_t led_read(struct file *filp, char __user *buf, size_t cnt, loff_t *offt) { \treturn EFAULT; // 这里不可以返回一个0, 这个实际表示的是长度一直为0会卡住 } static ssize_t led_write(struct file *filp, const char __user *buf, size_t cnt, loff_t *offt) { \tunsigned char databuf[10]; \tif(cnt >10) \t\tcnt 10; \t\t /*从用户空间拷贝数据到内核空间, 避免访问非法的内存*/ if(copy_from_user(databuf, buf, cnt)){ \t\treturn EIO; \t} \t \tif(!memcmp(databuf,\"on\",2)) {\t \t\tiowrite32(0 << 4, GPIO1_DR);\t \t} else if(!memcmp(databuf,\"off\",3)) { \t\tiowrite32(1 << 4, GPIO1_DR); \t} \t/*写成功后，返回写入的字数*/ \treturn cnt; } static int led_release(struct inode *inode, struct file *filp) { \treturn 0; } /* 自定义led的file_operations 接口*/ static struct file_operations led_fops { \t.owner THIS_MODULE, \t.open led_open, \t.read led_read, \t.write led_write, \t.release \tled_release, // 对应close当所有的打开都释放的时候调用这个 }; int major 0; static int __init led_init(void) { \t \t/* GPIO相关寄存器映射 */ \tIMX6U_CCM_CCGR1 ioremap(0x20c406c, 4); \tSW_MUX_GPIO1_IO04 ioremap(0x20e006c, 4); \tSW_PAD_GPIO1_IO04 ioremap(0x20e02f8, 4); \tGPIO1_GDIR ioremap(0x0209c004, 4); \tGPIO1_DR ioremap(0x0209c000, 4); \t/* 使能GPIO1时钟 */ \tiowrite32(0xffffffff, IMX6U_CCM_CCGR1); \t/* 设置GPIO1_IO04复用为普通GPIO*/ \tiowrite32(5, SW_MUX_GPIO1_IO04); \t /*设置GPIO属性*/ \tiowrite32(0x10B0, SW_PAD_GPIO1_IO04); \t/* 设置GPIO1_IO04为输出功能 */ \tiowrite32(1 << 4, GPIO1_GDIR); \t/* LED输出高电平 */ \tiowrite32(1<< 4, GPIO1_DR); \t/* 注册字符设备驱动 */ \tmajor register_chrdev(DEV_MAJOR, DEV_NAME, &led_fops); printk(KERN_ALERT \"led major:%d\\n\",major); \treturn 0; } static void __exit led_exit(void) { \t/* 取消映射 */ \tiounmap(IMX6U_CCM_CCGR1); \tiounmap(SW_MUX_GPIO1_IO04); \tiounmap(SW_PAD_GPIO1_IO04); \tiounmap(GPIO1_DR); \tiounmap(GPIO1_GDIR); \t/* 注销字符设备驱动 */ \tunregister_chrdev(major, DEV_NAME); } module_init(led_init); module_exit(led_exit); MODULE_LICENSE(\"GPL2\"); MODULE_AUTHOR(\"embedfire \"); MODULE_DESCRIPTION(\"led_module\"); MODULE_ALIAS(\"led_module\"); ``` #### 驱动模块初始化 ##### 地址映射 GPIO寄存器物理地址和虚拟地址映射 ebf buster linux/arch/arm/include/asm/io.h ```c void __iomem *ioremap(resource_size_t res_cookie, size_t size) ``` 参数： res_cookie：物理地址 size：映射长度 返回值： void * 类型的指针，指向被映射的虚拟地址 __iomem 主要是用于编译器的检查地址在内核空间的有效性 ##### 虚拟地址读写 ```c readl()/ writel()\t//过时 void iowrite32(u32 b, void __iomem *addr) //写入一个双字（32bit） unsigned int ioread32(void __iomem *addr) //读取一个双字（32bit） ``` 检查cpu大小端，调整字节序，以提高驱动的可移植性 #### 自定义led的file_operations接口 ````c static struct file_operations led_fops { \t.owner THIS_MODULE, \t.open led_open, \t.read led_read, \t.write led_write, \t.release led_release, }; ```` owner：设置驱动接口关联的内核模块，防止驱动程序运行时内核模块被卸载 release：文件引用数为0时调用 #### 拷贝数据 include/linux/uaccess.h 避免访问非法内存, 导致内核崩溃 ```c unsigned long copy_from_user(void *to, const void __user *from, unsigned long n) unsigned long copy_to_user(void __user *to, const void *from, unsigned long n); ``` 参数： *to：将数据拷贝到内核的地址 *from 需要拷贝数据的用户空间地址 n 拷贝数据的长度（字节） 返回值： 失败：没有被拷贝的字节数 成功：0 ### 现象 可以在`/proc/devices`文件里面看到实际的设备文件以及对应的设备号, 在使用insmod加载模块以及, 可以查看到分配的主设备号 之后可以使用命令`mknod /dev/xxx c 主次设备号`进行设备的创建"},"/note/Linux/野火Linux/2025-10-2-51-备份量产.html":{"title":"备份量产","content":"# 备份量产 ![image 20251002180401679](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510021804743.png) ## 备份 ### fire config 1. 首先需要准备一张空 白的 sd 卡，将sd卡插入到板子上并重启开发板。使用lsblk可看到用于演示的sd卡大小 2. 在`sudo fire config`里面进行设置 3. Advanced > SD Burning ### 命令行 需要使用到两张SD卡，一张空白的SD镜像，一张装有系统镜像，同时需要板子支 持SD卡启动 1. 在需要备份的开发板中插入装有系统的SD卡，选SD卡启动。 2. 将空白SD卡通过读卡器插到开发板上。 3. 将开发板的内容备份到空白SD卡上。 ## SD卡文件打包 ### Ubuntu 1. 将已经搭建好环境的SD卡从开发板取出并插到读卡器上，然后将读卡器接入PC机（ubuntu 中），在桌面版本的ubuntu中会自动挂载SD卡的内容 可以使用`df h`查看镜像的大小 2. 使用mkdir命令创建一个新的目录，用于存放从带镜像的SD卡中拷贝的镜像。然后使用 dd 命令将带镜像的SD中的镜像拷贝到新创建的目录中 ```bash # 创建新目录 mkdir image_backup # 将带镜像的 SD 卡中的镜像拷贝到创建的目录中 sudo dd if /dev/sdb of ./image_backup/imx6ull_backup.img count 1100 bs 1024k conv sync ``` > + if 文件名：输入文件名，缺省为标准输入。即指定源文件。 > + of 文件名：输出文件名，缺省为标准输出。即指定目的文件。< of ./image_backup/imx6ull_bakcup.img, 这里的.img 是镜像的格式，转成.img格式的文件后方便后续使用etcher烧录镜像> > + bs bytes：同时设置读入/输出的块大小为bytes个字节，此处填的是1024，表示1M大小 > + count blocks：仅拷贝blocks个块，块大小等于ibs指定的字节数，此处设置的是1100，表示1100个bs，也就是1100M > + conv sync：将每个输入块填充到ibs个字节，不足部分用空（NUL）字符补齐 > > 若备份的镜像烧录后仍无法正常运行，请将 bs 1024k 改为 bs 1M 并去 掉conv 参数, 即 `sudo dd if /dev/sdb of ./image_backup/imx6ull_backup.img count 1100 bs 1M` 得到img文件后，就可以将这个img文件烧录到其它卡上了 ### Win https://win32diskimager.org/ 在windows下新建一个空文件，后缀为img，例如backup.img，将需要备份镜像的SD卡插到 windows 上并打开Win32磁盘映像工具，然后点击文件夹图标，找到刚刚创建的backup.img 文件并确认，并确认SD卡盘符，取消“仅读取已分配区”的勾选，最后点击读取按钮，如 果弹出是否覆盖backup.img的对话框，点击是 ![image 20251002195010084](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510021950131.png) ## 根文件系统备份 ### 使用脚本 执行野火提供的系统备份脚本，该备份脚本已经在野火最新发布的系统 镜像中提供，具体路径为`/opt/scripts/tools/backup/backup_rootfs.sh` `sudo /opt/scripts/tools/backup/backup_rootfs.sh /dev/sda` ```bash #!/bin/bash e # 设置脚本执行错误和退出时应当执行的函数，这里主要是卸载和删除临时挂载目录 _exit_trap() { umount ${tmp_rootfs_dir} rmdir ${tmp_rootfs_dir} } _err_trap() { umount ${tmp_rootfs_dir} rmdir ${tmp_rootfs_dir} } # 判断系统是否安装了exfat fuse和exfat utils两个工具包为方便 # 在windows 平台上从u盘拷贝出根文件系统，u盘应当格式化为exfat文件系统，该文件系 # 统格式可以直接被windows平台识别。但是，在linux系统中挂载和格式化exfat文件系统， # 则需要使用上面的两个工具。如果系统未安装这两个工具包，应该使用apt工具进行安装 dpkg l grep exfat fuse deb_pkgs \"${deb_pkgs}exfat fuse \" dpkg l grep exfat utils deb_pkgs \"${deb_pkgs}exfat utils \" if [ \"${deb_pkgs}\" ] ; then echo \"Installing: ${deb_pkgs}\" sudo apt get update sudo apt get y install ${deb_pkgs} fi # 设置u盘挂载时使用的临时文件夹 tmp_rootfs_dir /mnt/rootfs_backup # 判断执行脚本的传参，这里需要传入u盘相关设备文件 if [ $# gt 0 ]; then DEV \"$1\" else echo \"please input a storage device!\" exit 0 fi # 以exfat格式化u盘设备 mkfs.exfat n rootfs $DEV # 捕捉脚本执行错误和退出的信号，如果捕捉成功，则执行相应处理函数 trap _exit_trap EXIT trap _err_trap ERR if [ ! d ${tmp_rootfs_dir} ] ; then mkdir ${tmp_rootfs_dir} fi mount t exfat $DEV $tmp_rootfs_dir # 用tar工具打包当前根文件系统。注意，当前系统目录有一系列虚拟文件系统和 # 临时文件，用户无需备份，用–exclude参数排除这部分目录和文件即可。打包得到的根文件 #系统命令为rootfs.tar tar cvf ${tmp_rootfs_dir}/rootfs.tar exclude {/dev/*,/proc/*,/sys/*,/tmp/*,/run/*,/mnt/*,/media/*,/lost+found,/boot} /* cd /boot tar cvf ${tmp_rootfs_dir}/boot.tar . cd ``` 系统备份成功后，拔下u盘，查入到windows电脑上，可查看到rootfs.tar与boot.tar文件分别对应系统根文件系统和/boot分区的两个文件"},"/note/Linux/野火Linux/2025-12-6-81-音频驱动.html":{"title":"音频驱动","content":"# 音频驱动 [(82 封私信 / 80 条消息) 正点原子linux应用编程——提高篇4 知乎](https://zhuanlan.zhihu.com/p/670785159) ALSA是Advanced Linux Sound Architecture(高级的Linux声音体系)的缩写，目前已经成为了 linux 下的主流音频体系架构，提供了音频和MIDI的支持，替代了原先旧版本中的OSS(开发声音系统) ALSA提供了一套标准的API，应用程序只需要调用这些API就可完成对底层音频硬 件设备的控制，譬如播放、录音等 ![image 20251206145644930](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512061456094.png) #### 1. 声卡（Sound Card）—— 物理载体 **本质**：电脑的音频硬件（内置 / 外置），核心功能是完成**数模转换（DAC，数字音频→模拟声波）** 和**模数转换（ADC，麦克风输入→数字音频）**，是所有音频操作的物理基础。 系统标识：Linux/ALSA 中用 `hw:0`、`hw:1` 区分（0 是第一块声卡，1 是第二块，以此类推），对应代码里的 `const char *card \"hw:0\"`。 核心作用：所有音频的输入 / 输出最终都通过声卡完成，混音器、控件都是围绕声卡的功能展开的。 #### 2. 混音器（Mixer）—— 声卡的 “调音台模块” 本质 声卡硬件内置的一个功能模块（也有软件模拟的混音器），核心作用是 管理多个音频流的混合、音量调节、路由选择 比如：把音乐、系统提示音、游戏音效等多个数字音频流混合成一个信号，调整各自音量后，再通过 DAC 输出到音箱；也能管理麦克风输入的音量、是否静音等。 软件抽象：ALSA 中用 `snd_mixer_t` 结构体（代码里的 `handle`）表示混音器，它是应用程序操作声卡混音功能的 “入口句柄”。 核心特点： 一个声卡对应**一个核心混音器**（你可以理解为 “一块声卡只有一个调音台”）； 要操作声卡的音频参数，必须先打开并关联该声卡的混音器（代码里的 `snd_mixer_open` + `snd_mixer_attach`）。 #### 3. 控件（Control Element/Selem）—— 混音器的 “旋钮 / 开关” **本质**：混音器的最小可操作单元，每个控件对应混音器的一个具体功能（比如调节某一路音频的音量、开关静音、选择音频输入源等）。 软件抽象：ALSA 中用 `snd_mixer_elem_t` 结构体（代码里的 `elem`）表示控件，通过 `snd_mixer_selem_id_t`（`sid`）定位具体控件（名称 + 索引）。 常见控件类型（对应不同 “旋钮 / 开关”）： 音量控件：`Master`（主音量）、`PCM`（数字音频音量）、`DAC LINEOUT`（DAC 输出音量，代码里的控件名）、`Speaker`（扬声器音量）； 开关控件：`Master Playback Switch`（主音量静音开关）； 枚举控件：`Input Source`（选择麦克风 / 线路输入等音频源）。 核心特点： 一个混音器包含**多个控件**（调音台上有多个旋钮 / 开关，各自管不同功能）； 不同声卡的混音器控件名称 / 数量不同（比如有的声卡叫 `Master`，有的工业声卡叫 `DAC LINEOUT`）。 ## alas lib **alsa lib是一套Linux应用层的C语言函数库**，为音频应用程序开发提供了一套**统一、标准的接口，应用程序只需调用这一套API即可完成对底层声卡设备的操控**，譬如播放与录音。 主要涉及三个模块：PCM Interface、Error Interface以及Mixer Interface PCM Interface：提供了PCM设备相关的操作接口，譬如打开/关闭PCM设备、配置PCM设备硬件或软件参数、控制PCM设备(启动、暂停、恢复、写入/读取数据)； Error Interface：提供了关于错误处理相关的接口； Mixer Interface：提供了关于混音器相关的一系列操作接口。 一般在使用的时候需要移植一个alsa utils用于测试以及配置 alsa utils提供了一些用于测试、配置声卡的工具，譬如[aplay](https://zhida.zhihu.com/search?content_id 237193447&content_type Article&match_order 1&q aplay&zhida_source entity)、[arecord](https://zhida.zhihu.com/search?content_id 237193447&content_type Article&match_order 1&q arecord&zhida_source entity)、alsactl、alsaloop、[alsamixer](https://zhida.zhihu.com/search?content_id 237193447&content_type Article&match_order 1&q alsamixer&zhida_source entity)、amixer等，在开发板出厂系统上可以直接使用这些工具，这些应用程序也都是基于alsa lib编写的。 aplay：用于测试音频播放功能程序，可以使用aplay播放wav格式的音频文件；aplay只能解析wav格式音频文件； alsamixer：用于配置声卡的混音器，它是一个字符图形化的配置工具，直接在开发板串口终端运行alsamixer命令，就打开图形化配置界面； alsactl：将当前声卡配置保存，默认文件是/var/lib/alsa/asound.state，可通过如下命令保存与加载： alsactl f /var/lib/alsa/asound.state store alsactl f /var/lib/alsa/asound.state restore amixer：声卡配置工具，但是是基于命令行操作的。 arecord：用于录音测试的应用程序。 ## 设备节点 在Linux内核设备驱动层，**基于ALSA音频驱动框架注册的sound设备会在/dev/snd目录下生成相应的设备节点文件**。 controlC0：用于声卡控制的设备节点，譬如通道选择、混音器、麦克风的控制等，C0表示声卡0(card0)； pcmC0D0p：用于播放(或叫放音、回放)的PCM设备节点。其中C0表示card0，也就是声卡0；而D0表示device 0，也就是设备0；最后一个字母p是playback的缩写，表示播放；所以pcmC0D0p便是系统的声卡0中的播放设备0 pcmC0D1c：用于录音的PCM设备节点。对应系统的声卡0中的录音设备1； pcmC0D2c：用于录音的PCM设备节点。对应系统的声卡0中的录音设备2； timer：定时器。 在Linux系统的/proc/asound目录下，有很多的 文件，这些文件记录了系统中声卡相关的信息： cards：通过\"cat /proc/asound/cards\"命令，查看cards文件的内容，可列出系统中可用的、注册的声卡；系统中注册的所有声卡都会在/proc/asound/目录下存在一个相应的目录，该目录的命名方式为cardX(X表示声卡的编号)； devices：通过\"cat /proc/asound/devices\"命令，查看系统中所有声卡注册的设备，包括control、pcm、timer、seq等等； pcm：通过\"cat /proc/asound/pcm\"命令，查看系统中所有PCM设备，包括playback和capture。 ## 应用 ### 基础概念 样本长度(Sample)：采样位数，也称为位深度，是指数字声音信号的二进制位数； 声道数(channel)：分为单声道和双声道； 帧(frame)：记录一个声音单元，长度为样本长度与声道数乘积； 采样率(Sample rate)：每秒采样次数； 交错模式(interleaved)：音频数据的记录方式，分为交错模式和非交错模式；交错模式下，数据以连续帧形式存放；非交错模式下则是先记录一个周期内所有帧左声道再记录右声道； 周期(period)：音频设备处理数据的单位； 缓冲区(buffer)：一个缓冲区包含若干周期。 PCM播放 在播放情况下，buffer中存放了需要播放的PCM音频数据，由应用程序向buffer中写入音频数据，buffer中的音频数据由DMA传输给音频设备进行播放，所以应用程序向buffer写入数据、音频设备从buffer读取数据，这就是buffer中数据的传输情况。 这里是有读指针和写指针，在缓冲区没有数据时均指向buffer起始位置，每次读写到末尾后会回到buffer起始位置。 PCM录音 buffer中存放了音频设备采集到的音频数据(外界模拟声音通过ADC转为数字声音)，由音频设备向buffer中写入音频数据(DMA搬运)，而应用程序从buffer中读取数据，所以音频设备向buffer写入数据、应用程序从buffer读取数据。 Over and Under Run 当一个声卡处于工作状态时，环形缓冲区buffer中的数据总是连续地在音频设备和应用程序缓存区间传输，如下图所示： ![image 20251206152133716](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512061521790.png) 在录音例子中，如果应用程序读取数据不够快，环形缓冲区buffer中的数据已经被音频设备写满了、而应用程序还未来得及读走，那么数据将会被覆盖；这种**数据的丢失被称为overrun**。在播放例子中，如果应用程序写入数据到环形缓冲区buffer中的速度不够快，**缓存区将会“饿死”(缓冲区中无数据可播放)，这样的错误被称为underrun(欠载)**。**在ALSA 文档中，将这两种情形统称为\"XRUN\"**，适当地设计应用程序可以最小化XRUN并且可以从中恢复过来 ### 相关API #### 打开关闭 ```c int snd_pcm_open(snd_pcm_t **pcmp, const char *name, snd_pcm_stream_t stream, int mode); int snd_pcm_close(snd_pcm_t *pcm); ``` pcmp(返回参数)：snd_pcm_t用于描述一个PCM设备，所以一个snd_pcm_t对象表示一个PCM设备；snd_pcm_open函数会打开参数name所指定的设备，实例化snd_pcm_t对象，并将对象的指针(也就是PCM设备的句柄)通过pcmp返回出来； name：指定PCM设备名字，命名方式为\"hw:i,j\"，i表示声卡的卡号，j则表示这块声卡上的设备号； stream：指定流类型，SND_PCM_STREAM_PLAYBACK表示播放，SND_PCM_STREAM_CAPTURE则表示采集； mode：指定了open模式，通常情况下会将其设置为0，表示默认打开模式，使用阻塞方式打开设备；也可将其设置为SND_PCM_NONBLOCK，表示以非阻塞方式打开设备。 #### 设置 对采样率、声道数、格式、访问类型、period周期大小、buffer大小等进行配置 实例化snd_pcm_hw_params_t对象 使用snd_pcm_hw_params_malloc或snd_pcm_hw_params_alloca()来实例化一个snd_pcm_hw_params_t对象, snd_pcm_hw_params_free()函数用于释放snd_pcm_hw_params_t对象占用的内存空间 ```c snd_pcm_hw_params_t *hwparams NULL; snd_pcm_hw_params_malloc(&hwparams); snd_pcm_hw_params_alloca(&hwparams); void snd_pcm_hw_params_free(snd_pcm_hw_params_t *obj); ``` 初始化snd_pcm_hw_params_t对象 调用snd_pcm_hw_params_any()对snd_pcm_hw_params_t对象进行初始化操作，调用该函数会使用PCM设备当前的配置参数去初始化snd_pcm_hw_params_t对象 ```c snd_pcm_hw_params_any(pcm_handle, hwparams); ``` 第一个参数为PCM设备的句柄，第二个参数传入snd_pcm_hw_params_t对象的指针 硬件参数设置 alsa lib提供了一系列的snd_pcm_hw_params_set_xxx函数用于设置PCM设备的硬件参数，同样也提供了一系列的snd_pcm_hw_params_get_xxx函数用于获取硬件参数。 调用snd_pcm_hw_params_set_access**设置访问类型** ```c int snd_pcm_hw_params_set_access(snd_pcm_t *pcm, snd_pcm_hw_params_t * params, snd_pcm_access_t access ); ``` 参数access指定设备的访问类型，是一个snd_pcm_access_t类型常量，通常将访问类型设置为SND_PCM_ACCESS_RW_INTERLEAVED，交错访问模式，通过snd_pcm_readi/snd_pcm_writei对PCM设备进行读/写操作 函数调用成功返回0，失败返回小于0的错误码，可通过snd_strerror()函数获取错误信息。 调用snd_pcm_hw_params_set_format()函数**设置PCM设备的数据格式**，函数原型如下所示： ```c int snd_pcm_hw_params_set_format(snd_pcm_t *pcm, snd_pcm_hw_params_t *params, snd_pcm_format_t format ); ``` 参数format指定数据格式，该参数是一个snd_pcm_format_t类型常量，用的最多的格式是SND_PCM_FORMAT_S16_LE，有符号16位、小端模式。当然，可能不支持这个格式，可以调用snd_pcm_hw_params_test_format()函数测试PCM设备是否支持某种格式，如下所示： ```c if (snd_pcm_hw_params_test_format(pcm_handle, hwparams, SND_PCM_FORMAT_S16_LE)) { // 返回一个非零值 表示不支持该格式 } else { // 返回 0 表示支持 } ``` 调用snd_pcm_hw_params_set_channels()函数**设置PCM设备的声道数**，函数原型如下所示： ```c int snd_pcm_hw_params_set_channels(snd_pcm_t *pcm, snd_pcm_hw_params_t *params, unsigned int val ); ``` 参数val指定声道数量，val 2表示双声道，也就是立体声。函数调用成功返回0，失败返回小于0的错误码。 调用snd_pcm_hw_params_set_rate()**设置采样率大小**，其函数原型如下所示： ```c int snd_pcm_hw_params_set_rate(snd_pcm_t *pcm, snd_pcm_hw_params_t *params, unsigned int val, int dir ); ``` 参数val指定采样率大小，譬如44100；参数dir用于控制方向，若dir 1，则实际采样率小于参数val指定的值；dir 0表示实际采样率等于参数val；dir 1表示实际采样率大于参数val。函数调用成功返回0；失败将返回小于0的错误码。 调用snd_pcm_hw_params_set_period_size()函数**设置周期大小**，其函数原型如下所示： ```c int snd_pcm_hw_params_set_period_size(snd_pcm_t *pcm, snd_pcm_hw_params_t *params, snd_pcm_uframes_t val, int dir ); ``` alsa lib使用snd_pcm_uframes_t类型表示帧的数量；参数dir与snd_pcm_hw_params_set_rate()函数的dir参数意义相同。 调用snd_pcm_hw_params_set_buffer_size()函数**设置buffer的大小**，其函数原型如下所示： ```c int snd_pcm_hw_params_set_buffer_size(snd_pcm_t *pcm, snd_pcm_hw_params_t *params, snd_pcm_uframes_t val ); ``` 参数val指定buffer的大小，以帧为单位，通常buffer的大小是周期大小的整数倍；但函数snd_pcm_hw_params_set_buffer_size()是以帧为单位来表示buffer的大小，所以需要转换一下。函数调用成功返回0；失败返回一个小于0的错误码。 还可以调用snd_pcm_hw_params_set_periods()函数设置buffer大小，其函数原型如下所示： ```c int snd_pcm_hw_params_set_periods(snd_pcm_t *pcm, snd_pcm_hw_params_t *params, unsigned int val, int dir ); ``` 参数val指定了buffer的大小，该大小以周期为单位、并不是以帧为单位，注意区分！参数dir与snd_pcm_hw_params_set_rate()函数的dir参数意义相同。函数调用成功返回0；失败将返回一个小于0的错误码。 调用snd_pcm_hw_params()加载/安装配置、**将配置参数写入硬件使其生效**，其函数原型如下所示： ```c int snd_pcm_hw_params(snd_pcm_t *pcm, snd_pcm_hw_params_t *params); ``` 函数调用成功返回0，失败将返回一个小于0的错误码。 函数snd_pcm_hw_params()调用之后，其内部 会自动调用snd_pcm_prepare()函数，PCM设备的状态被更改为SND_PCM_STATE_PREPARED。 #### 读写数据 如果是PCM播放，则调用snd_pcm_writei()函数向播放缓冲区buffer中写入音频数据；如果是PCM录音，则调用snd_pcm_readi()函数从录音缓冲区buffer中读取数据，它们的函数原型如下所示： ```c snd_pcm_sframes_t snd_pcm_writei(snd_pcm_t *pcm, const void *buffer, snd_pcm_uframes_t size ); snd_pcm_sframes_t snd_pcm_readi(snd_pcm_t *pcm, void *buffer, snd_pcm_uframes_t size ); ``` 参数pcm为PCM设备的句柄；参数size指定写入数据的大小，以帧为单位。通常情况下，两个函数都是读/写一个周期。 要注意的是，这里的buffer是应用程序的缓冲区，会通过函数与驱动层的环形buffer进行交互 snd_pcm_readi/snd_pcm_writei调用成功，返回实际读取/写入的帧数；调用失败将返回一个负数错误码。即使调用成功，实际读取/写入的帧数不一定等于参数size所指定的帧数，仅当发生信号或XRUN时，返回的帧数可能会小于参数size。 调用snd_pcm_open()打开设备时，若指定为阻塞方式，则调用snd_pcm_readi/snd_pcm_writei以阻塞方 式进行读/写。若**调用snd_pcm_open()打开设备时，指定为非阻塞方式**，则调用snd_pcm_readi/snd_pcm_writei以非阻 塞方式进行读/写。对于PCM录音来说，当buffer缓冲区中无数据可读时，**调用snd_pcm_readi()不会阻塞、而是立即以错误形式返回**；同理，对于PCM播放来说，当buffer缓冲区中的数据满时，**调用snd_pcm_writei()函数也不会阻塞、而是立即以错误形式返回**。 **snd_pcm_readi/snd_pcm_writei适用于交错模式(interleaved)读/写数据**，如果用户设置的访问类型并不是交错模式，而是**非交错模式(non interleaved)**，此时便不可再使用snd_pcm_readi/snd_pcm_writei进行读写操作了，**而需要使用snd_pcm_readn和snd_pcm_writen进行读写**。 ## 混音器设置 混音器相关的接口在alsa lib的Mixer Interface模块中有介绍。控制音频路由和音量 ### 打开混音器 调用snd_mixer_open()函数打开一个空的混音器，其函数原型如下所示： ```c int snd_mixer_open(snd_mixer_t **mixerp, int mode); ``` snd_mixer_t数据结构描述混音器，调用snd_mixer_open()函数会实例化一个snd_mixer_t对象，并将对象的指针(混音器的句柄)通过mixerp返回出来。参数mode指定了打开模式，通常设置为0使用默认模式即可。函数调用成功返回0；失败返回一个小于0的错误码。 ### Attach关联设备 调用snd_mixer_attach()函数进行关联声卡控制设备，其函数原型如下所示： ```c int snd_mixer_attach(snd_mixer_t *mixer, const char *name); ``` 参数mixer对应的是混音器的句柄，参数name指定了声卡控制设备的名字，同样这里使用的也是逻辑设备名，而非设备节点的名字，命名方式为\"hw:i\"，i表示声卡的卡号，通常一个声卡对应一个控制设备。函数调用成功返回0；失败返回一个小于0的错误码。 可通过 `cat /proc/asound/cards` 查看系统声卡列表 ### 注册 调用snd_mixer_selem_register()函数注册混音器，其函数原型如下所示： ```c int snd_mixer_selem_register( snd_mixer_t *mixer, struct snd_mixer_selem_regopt *options, snd_mixer_class_t **classp); ``` 参数options和参数classp直接设置为NULL即可。函数调用成功返回0；失败返回一个小于0的错误码。 ### 加载 最后需要加载混音器，调用snd_mixer_load()函数完成加载，函数原型如下所示： ```c int snd_mixer_load(snd_mixer_t * mixer); ``` 函数调用成功返回0；失败返回小于0的错误码。 ### 查找元素 alsa lib中把混音器的配置项称为元素(element)。 alsa lib使用数据结构snd_mixer_elem_t来描述一个元素。混音器有很多的元素(很多配置项)，通过snd_mixer_first_elem()函数可以找到混音器的第一个元素，其函数原型如下所示： ```c snd_mixer_elem_t *snd_mixer_first_elem(snd_mixer_t *mixer); ``` 通过snd_mixer_last_elem()函数可找到混音器的最后一个元素，如下： ```c snd_mixer_elem_t *snd_mixer_last_elem(snd_mixer_t *mixer); ``` 调用snd_mixer_elem_next()和snd_mixer_elem_prev()函数可获取指定元素的下一个元素和上一个元素： ```c snd_mixer_elem_t *snd_mixer_elem_next(snd_mixer_elem_t *elem); snd_mixer_elem_t *snd_mixer_elem_prev(snd_mixer_elem_t *elem); ``` 遍历如下所示： ```c snd_mixer_elem_t *elem NULL; elem snd_mixer_first_elem(mixer);//找到第一个元素 while (elem) { ...... ...... snd_mixer_elem_next(elem); //找到下一个元素 } ``` 调用snd_mixer_selem_get_name()函数可获取指定元素的名字，如下所示： ```c const char *snd_mixer_selem_get_name(snd_mixer_elem_t *elem); ``` ### 获取/更改元素 有两种配置值：第一种它的配置值是在一个范围内的数值，譬如音量大小的调节；另一种则是bool类型，用于控制开启或关闭，譬如0表示关闭配置、1表示使能配置。 可以调用snd_mixer_selem_has_playback_volume或snd_mixer_selem_has_capture_volume函数来判断一个指定元素的配置值是否是volume类型，也就是上文的第一种类型。函数原型如下所示： ```c int snd_mixer_selem_has_playback_volume(snd_mixer_elem_t *elem); int snd_mixer_selem_has_capture_volume(snd_mixer_elem_t *elem); ``` 函数返回0表示不是volume类型；返回1表示是volume类型。 调用snd_mixer_selem_has_playback_switch和snd_mixer_selem_has_capture_switch函数判断一个指定元素的配置值是否是switch类型，也就是上面说的第二种情况。函数原型如下所示： ```c int snd_mixer_selem_has_playback_switch(snd_mixer_elem_t *elem); int snd_mixer_selem_has_capture_switch(snd_mixer_elem_t *elem); ``` 函数返回0表示不是switch类型；返回1表示是switch类型。 通过snd_mixer_selem_has_playback_channel或snd_mixer_selem_has_capture_channel函数可判断指定元素是否包含指定通道，其函数原型如下所示： ```c int snd_mixer_selem_has_playback_channel( snd_mixer_elem_t *elem, snd_mixer_selem_channel_id_t channel ); int snd_mixer_selem_has_capture_channel( snd_mixer_elem_t *elem, snd_mixer_selem_channel_id_t channel ); ``` 参数channel用于指定一个通道，snd_mixer_selem_channel_id_t是一个枚举类型。如果元素是双声道元素，通常只包含左前(SND_MIXER_SCHN_FRONT_LEFT)和右前(SND_MIXER_SCHN_FRONT_RIGHT)两个声道。如果是单声道设备，通常只包含SND_MIXER_SCHN_MONO，其数值等于SND_MIXER_SCHN_FRONT_LEFT。 可以调用snd_mixer_selem_is_playback_mono或snd_mixer_selem_is_capture_mono函数判断一个指定的元素是否是单声道元素，其函数原型如下所示： ```c int snd_mixer_selem_is_playback_mono(snd_mixer_elem_t *elem); int snd_mixer_selem_is_capture_mono(snd_mixer_elem_t *elem); ``` 调用snd_mixer_selem_get_playback_volume或snd_mixer_selem_get_capture_volume获取指定元素的音量大小，其函数原型如下所示： ```c int snd_mixer_selem_get_playback_volume( snd_mixer_elem_t *elem, snd_mixer_selem_channel_id_t channel, long *value ); int snd_mixer_selem_get_capture_volume( snd_mixer_elem_t *elem, snd_mixer_selem_channel_id_t channel, long *value ); ``` 参数elem指定对应的元素，参数channel指定该元素的某个声道。调用snd_mixer_selem_get_playback_volume()函数可获取elem元素的channel声道对应的音量大小，并将获取到的音量值通过value返回出来。函数调用成功返回0，失败返回一个小于0的错误码。 调用snd_mixer_selem_set_playback_volume或snd_mixer_selem_set_capture_volume设置指定元素的音量值，其函数原型如下所示： ```c int snd_mixer_selem_set_playback_volume( snd_mixer_elem_t *elem, snd_mixer_selem_channel_id_t channel, long value ); int snd_mixer_selem_set_capture_volume( snd_mixer_elem_t *elem, snd_mixer_selem_channel_id_t channel, long value ); ``` 参数elem指定元素、参数channel指定该元素的某个声道，参数value指定音量值。 调用snd_mixer_selem_set_playback_volume_all或snd_mixer_selem_set_capture_volume_all可一次性设置指定元素所有声道的音量，函数原型如下所示： ```c int snd_mixer_selem_set_playback_volume_all( snd_mixer_elem_t *elem, long value ); int snd_mixer_selem_set_capture_volume_all( snd_mixer_elem_t *elem, long value ); ``` 调用snd_mixer_selem_get_playback_volume_range或snd_mixer_selem_get_capture_volume_range获取指定元素的音量范围，其函数原型如下所示： ```c int snd_mixer_selem_get_playback_volume_range( snd_mixer_elem_t *elem, long *min, long *max ); int snd_mixer_selem_get_capture_volume_range( snd_mixer_elem_t *elem, long *min, long *max ); ``` ## 示例 ### 设置音量 打开混音器→定位声卡→查找音量控件→设置音量 ```c // 设置音量 int sys_set_volume(int level) { if (level < 0 level > 100) return 1; // 音量级别应在0到100之间 // 这里可以添加实际设置硬件音量的代码 #if LV_USE_SIMULATOR 0 const char *card \"hw:0\"; // 声卡名称 // selem_name 必须与声卡实际的控件名一致， // 可通过 amixer 命令查看（如 amixer c 0 scontrols // 查看第 0 块声卡的所有控件名） const char *selem_name \"DAC LINEOUT\"; // 控件名称 snd_mixer_t *handle; snd_mixer_selem_id_t *sid; snd_mixer_elem_t *elem; long min, max, mapped_volume; // 打开混音器 if (snd_mixer_open(&handle, 0) < 0) { fprintf(stderr, \"Error: Unable to open mixer.\\n\"); return 1; } // 加载指定声卡 if (snd_mixer_attach(handle, card) < 0) { fprintf(stderr, \"Error: Unable to attach to card '%s'.\\n\", card); snd_mixer_close(handle); return 1; } // 注册元素类, 是加载控件的前置步骤 if (snd_mixer_selem_register(handle, NULL, NULL) < 0) { fprintf(stderr, \"Error: Unable to register mixer.\\n\"); snd_mixer_close(handle); return 1; } // 加载混音器元素 // 加载指定声卡上的所有混音器控件（如音量、静音、声道等控件） // 到内存，供后续查找和操作 if (snd_mixer_load(handle) < 0) { fprintf(stderr, \"Error: Unable to load mixer.\\n\"); snd_mixer_close(handle); return 1; } // 创建混音器元素 ID snd_mixer_selem_id_alloca(&sid); // 分配元素ID结构体 // 设置属性索引以及名字 snd_mixer_selem_id_set_index(sid, 0); // 默认索引为 0 snd_mixer_selem_id_set_name(sid, selem_name); // 查找对应元素, 使用刚才设置的两个属性 elem snd_mixer_find_selem(handle, sid); if (!elem) { fprintf(stderr, \"Error: Unable to find element '%s'.\\n\", selem_name); snd_mixer_close(handle); return 1; } // 获取音量范围 snd_mixer_selem_get_playback_volume_range(elem, &min, &max); printf(\"Volume range: %ld to %ld\\n\", min, max); // 映射音量值到实际范围 mapped_volume min + (long)((double)(max min) * level / 100.0); // 设置音量 if (snd_mixer_selem_set_playback_volume_all(elem, mapped_volume) < 0) { fprintf(stderr, \"Error: Unable to set volume.\\n\"); snd_mixer_close(handle); return 1; } printf(\"Set '%s' volume to %ld (mapped from %d%%)\\n\", selem_name, mapped_volume, level); // 关闭混音器 snd_mixer_close(handle); #endif return 0; } ```"},"/note/Linux/野火Linux/Untitled.html":{"title":"","content":""},"/note/Linux/原子Linux/2022-8-16-GPT时钟.html":{"title":"GPT时钟","content":" layout: post title: \"GPT时钟\" date: 2022 8 15 15:39:08 +0800 tags: 嵌入式 原子Linux # GPT时钟 General Purpose Timer 使用一个硬件来实现高精度延时 1. 32位向上计数器 2. 可以捕获外部信号, 通过上升下降沿触发 3. 支持比较输出, 一共有三个通道, 以及产生中断 ![image 20251015104808782](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510151048932.png) 12位分频器, 可以使用ipg_clk 66MHz 两种运行模式: + restart模式: 达到之后就重新开始计数, 只用于比较通道1 + freerun模式: 三个输出比较通道都使用, 但是不会回到0, 加满以后返回 有几种中断: + 溢出中断, 计数满了的时候触发 + 输入捕获中断 + 输出比较中断 ![image 20251015110726661](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510151107837.png) > GPTx_CR: 用来配置bit0使能为, bit1是否使用上次关闭的时候的值, 1设置为0开始, bit6 8时钟源选择, 设置为1位66M, bit9设置定时器工作模式为0的时候restart, 15软件复位, 自动清零 > GPTx_PR: 0 11分频设置 > GPTx_SR: bit5: 状态寄存器, 溢出发生 bit4, bit3输入通道2, 3捕获, bit2 0输出比较, 也是复位使用的 > GPTx_IR: 设置中断使能寄存器 > GPTx_OCR:输出比较 > GPTx_ICR :输入捕获 > GPTx_CNT计数器 ## 使用"},"/note/Linux/原子Linux/2022-9-5-音频驱动.html":{"title":"音频驱动","content":" layout: post title: \"音频驱动\" date: 2022 9 5 15:39:08 +0800 tags: 嵌入式 原子Linux # 音频驱动 ## 音频接口 首先需要音频解码芯片, 要把外界的声音转换为0和1, 由模拟电路采集到之后传递给处理器, 就是音频的编解码器, 还有把数字信号转换为模拟信号就是声卡 ADC录音, DAC放音, 声卡就是对两者进行优化英文为\"CODEC\", 采样率就是HIFI, 常见音频采样率有8K、44.1K、48K、192K甚至384K和768K, 采样位数常见的有8位、16位、24位、32位 大多是使用软件解码, 把音频文件软件解码为数字信号, 之后通过声卡进行转换为模拟信号 ## WM8960音频解码芯片 低功耗, 高质量, 双声道, 可以驱动1W喇叭, 集成三个立体声输入, 有一个完整的麦克风, , 24位最高48K采样 + 立体声音频输入源，一共提供了三路，分别为LINPUT1/RINPUT1、LINPUT2/RINPUT2、LINPUT3/RINPUT3。麦克风或线路输入就连接到此接口上 + WM8960的输出接口，比如输出给耳机或喇叭，SPK_LP/SPK_LN用于连接左声道的喇叭，支持1W的8Ω喇叭。SPK_RP/SPK_RN用于连接右声道的喇叭，同样支持1W的8Ω喇叭，最后就是HP_L/HP_R，用于连接耳机 + 数字音频接口，用于和主控制器连接，有5根线，用于主控制器和WM8960之间进行数据“沟通”, ADCDAT：ADC数据输出引脚，采集到的音频数据转换为数字信号以后通过此引脚传输给主控制器 ADCLRC：ADC数据对齐时钟，也就是帧时钟(LRCK)，用于切换左右声道数据，此信号的频率就是采样率。此引脚可以配置为GPIO功能，配置为GPIO以后ADC就会使用DACLRC引脚作为帧时钟 DACDAT：DAC数据输入引脚，主控器通过此引脚将数字信号输入给WM8960的DAC DACLRC：DAC数据对齐时钟，功能和ADCLRC一样，都是帧时钟(LRCK)，用于切换左右声道数据，此信号的频率等于采样率 BCLK：位时钟，用于同步 MCLK：主时钟，WM8960工作的时候还需要一路主时钟，此时钟由I.MX6ULL提供，MCLK频率等于采样率的256或384倍 + 标准的I2C接口，WM8960要想工作必须对其进行配置，这个I2C接口就是用于配置WM8960的 ## IIS接口 主要用于音频的传输 还有采集的原始的音频数据格式就是PCM格式等 IIS用于主控制器和音频芯片之间传递音频信息, I2S接口需要3根信号线(如果需要实现收和发，那么就要4根信号线，收和发分别使用一根信号线) + SCK：串行时钟信号，也叫做位时钟(BCLK) + WS：字段(声道)选择信号，也叫做LRCK，也叫做帧时钟，用于切换左右声道数据, “1”表示正在传输左声道的数据，WS为“0”表示正在传输右声道的数据。WS的频率等于采样率 + SD：串行数据信号，也就是我们实际的音频数据，如果要同时实现放音和录音，那么就需要2根数据线，比如WM8960的ADCDAT和DACDAT，就是分别用于录音和放音。不管音频数据是多少位的，数据的最高位都是最先传输的 ![QQ图片20220906120215](https://blog 1308522872.cos.ap beijing.myqcloud.com/jhy/202301010003158.png) + 有时候为了使音频CODEC芯片与主控制器之间能够更好的同步，会引入另外一个叫做MCLK的信号，也叫做主时钟或系统时钟，一般是采样率的256倍或384倍 根据DATA数据相对于LRCK和SCLK位置的不同，出现了LeftJustified(左对齐)和RightJustified(右对齐)两种格式 ![QQ图片20220906120858](https://blog 1308522872.cos.ap beijing.myqcloud.com/jhy/202301010003159.png) ## SAI简介 I.MX6ULL也提供了一个叫做SAI的外设, 就是同步音频接口 I.MX6ULL的SAI是一个全双工、支持帧同步的串行接口，支持I2S、AC97、TDM和音频DSP，SAI ## 音频使能 需要一个WM8960驱动框架, IIC接口, 用来配置WM8960 需要一个SOC端SAI驱动文件 需要一个驱动文件, WM8960和I.MX6ull连接起来 ## ALSA音频驱动框架 Linux的默认音频驱动框架 用户空间: alsa lib, 使用这个库进行音频处理 针对于嵌入式处理器推出了ASoC, 针对移动设备, 建立在ALSA框架之上, 实际使用的就是这个 只要分为三部分, SOC, Codec, 板载硬件 SOC: 具体的SOC音频接口驱动, 比如SAI, 都是半导体厂商编写的 Codec: 具体的芯片, 比如WM8960驱动, IIC驱动, Codec芯片厂商写了 板载硬件: 将具体的SOC和具体的Codec结合的, 与具体的硬件框架相关 ## 实现 配置wm8960的接口设备树 + 驱动文件在sound/soc/codecs文件中 ```c codec: wm8960@1a { compatible \"wlf,wm8960\"; reg <0x1a>; clocks <&clks IMX6UL_CLK_SAI2>; clock names \"mclk\"; wlf,shared lrclk; }; ``` + SOC就是6ULL的驱动, 驱动文件fsl_sai.c文件 ```device tree sai2: sai@0202c000 { compatible \"fsl,imx6ul sai\", \"fsl,imx6sx sai\"; reg <0x0202c000 0x4000>; interrupts <GIC_SPI 98 IRQ_TYPE_LEVEL_HIGH>; clocks <&clks IMX6UL_CLK_SAI2_IPG>, <&clks IMX6UL_CLK_DUMMY>, <&clks IMX6UL_CLK_SAI2>, <&clks 0>, <&clks 0>; clock names \"bus\", \"mclk0\", \"mclk1\", \"mclk2\", \"mclk3\"; dma names \"rx\", \"tx\"; dmas <&sdma 37 24 0>, <&sdma 38 24 0>; status \"disabled\"; }; &sai2 { \tpinctrl names \"default\"; \tpinctrl 0 <&pinctrl_sai2 \t\t &pinctrl_sai2_hp_det_b>; \tassigned clocks <&clks IMX6UL_CLK_SAI2_SEL>, \t\t\t <&clks IMX6UL_CLK_SAI2>; \tassigned clock parents <&clks IMX6UL_CLK_PLL4_AUDIO_DIV>; \tassigned clock rates <0>, <12288000>; \tstatus \"okay\"; }; ``` + sound节点, 驱动文件imx wm8960.c ```c sound { compatible \"fsl,imx6ul evk wm8960\", \"fsl,imx audio wm8960\"; model \"wm8960 audio\"; cpu dai <&sai2>; audio codec <&codec>; asrc controller <&asrc>; codec master; gpr <&gpr 4 0x100000 0x100000>; /* * hp det <hp det pin hp det polarity>; \t\t * hp det pin: JD1 JD2 or JD3 \t\t * hp det polarity 0: hp detect high for headphone \t\t * hp det polarity 1: hp detect high for speaker \t\t */ hp det <3 0>; audio routing \"Headphone Jack\", \"HP_L\", \"Headphone Jack\", \"HP_R\", \"Ext Spk\", \"SPK_LP\", \"Ext Spk\", \"SPK_LN\", \"Ext Spk\", \"SPK_RP\", \"Ext Spk\", \"SPK_RN\", \"LINPUT2\", \"Mic Jack\", \"LINPUT3\", \"Mic Jack\", \"RINPUT1\", \"Main MIC\", \"RINPUT2\", \"Main MIC\", \"Mic Jack\", \"MICB\", \"Main MIC\", \"MICB\", \"CPU Playback\", \"ASRC Playback\", \"Playback\", \"CPU Playback\", \"ASRC Capture\", \"CPU Capture\", \"CPU Capture\", \"Capture\"; }; ``` > cpu dai: 数字音频接口 > > audio codec: 对应的音频解码芯片 > > model：最终用户看到的此声卡名字，这里设置为“wm8960 audio” > > audio routing：音频器件一系列的连接设置，每个条目都是一对字符串，第一个字符串是连接的sink，第二个是连接的source(源) ### 驱动使能 图形界面, 取消ALSA模拟OSS Device dirver >Sound card support > <*> Advanced Linux Sound Architecture 之后使能对应的驱动 Device dirver >Sound card support > <*> Advanced Linux Sound Architecture ><\\*> ALSA for SoC audio support > SoC Audio for Freescale CPUs >< > SoC Audio support for i.MX boards with wm8960 启动之后显示 ```c ALSA device list: #0: wm8960 audio ``` 在文件/dev/snd文件夹 ```bash /dev/snd # ls controlC0 pcmC0D0c pcmC0D0p pcmC0D1c pcmC0D1p timer ``` > ontrolC0：用于声卡控制，C0表示声卡0。 > > pcmC0D0c和pcmC0D1c：用于录音的pcm设备，其中的“COD0”和“C0D1”分别表示声卡0中的设备0和设备1，最后面的“c”是capture的缩写，表示录音。 > > pcmC0D0p和pcmC0D1p：用于播放的pcm设备，其中的“COD0”和“C0D1”分别表示声卡0中的设备0和设备1，最后面的“p”是playback的缩写，表示放音。 > > timer：定时器 ## 测试 还需要移植alsa lib和alsa utils, 前面的是库文件, 后面的是测试文件 ### 库文件移植 创建文件夹/usr/share/arm alsa, 开发板和主机都需要 ```shell cd alsa lib 1.2.2///进入alsa lib源码目录 jiao@jiao virtual machine:~/linux/tool/alsa lib$ ./configure host arm linux gnueabihf prefix /home/jiao/linux/tool/alsa lib with configdir /usr/share/arm alsa make//编译 sudo makeinstall//安装 ``` 失败的话使用sudo用户执行/etc/profile 把得到的lib文件放到lib文件夹 把之前创建的文件夹中的文件放到对应的目录中 ### 软件移植 ``` cd alsa utils 1.2.2///进入 ./configure host arm linux gnueabihf prefix /home/zuozhongkai/linux/IMX6ULL/tool/alsa utils with alsa inc prefix /home/zuozhongkai/linux/IMX6ULL/tool/alsa lib/include/ with alsa prefix /home/zuozhongkai/linux/IMX6ULL/tool/alsa lib/lib/ disable alsamixer disable xmlto make//编译 sudo make instal ``` ``` cd alsa utilssudo cp bin/* /home/zuozhongkai/linux/nfs/rootfs/bin/ rfasudo cp sbin/* /home/zuozhongkai/linux/nfs/rootfs/sbin/ rfasudo cp share/* /home/zuozhongkai/linux/nfs/rootfs/usr/share/ rfa ``` /etc/profile文件 ``` export ALSA_CONFIG_PATH /usr/share/arm alsa/alsa.conf ``` ### 使用 aplay可以播放wav模式的音频 不作任何配置没有效果, 产生错误 ``` aplay: pcm_write:2061: write error: Interrupted system call ``` 声卡默认都是关闭的 使用软件amixer配置 `amixer scontents`: 具体的调试 ``` amixer sset Headphone 100,100 amixer sset Speaker 120,120 amixer sset 'Right Output Mixer PCM' on amixer sset 'Left Output Mixer PCM' on ``` + 录音测试 使用软件`arecord f cd d 10 record.wav` f是设置录音质量，“ fcd”表示录音质量为cd级别。 d是指定录音时间，单位是s，这条指令就是录制一段cd级别10s的wav音频，音频名字为record.wav。 麦克风连接的是左声道, 右声道是杂音, 喇叭连接的时候右声道 解决方法: 修改寄存器 wm8960.c文件 ``` { 0x16, 0x00c3 }, /*{ 0x17, 0x01c0 },*/ { 0x17, 0x01c4 }, ``` ## 开机自动配置 声卡设置的保存通过alsactl工具来完成, 将声卡配置文件保存在/var/lib/alsa目录下 使用命令`alsactl f /var/lib/alsa/my_asound.state store` 使用`alsactl f /var/lib/alsa/my_asound.state restore`使用文件"},"/note/Linux/原子Linux/2022-8-30-Linux中断.html":{"title":"Linux中断","content":" layout: post title: \"Linux中断\" date: 2022 8 30 15:39:08 +0800 tags: 嵌入式 原子Linux # Linux中断 ## 函数 + 中断号 每一个中断都有一个对应的中断号, `request_irq`函数用来申请所需要的中断, 有可能会导致睡眠, 所以要在可以睡眠的位置调用 ```c int request_irq(unsigned int irq, irq_handler_t handler, \t\t\t\tunsigned long flags,const char *name, void *dev) ``` > irq：要申请中断的中断号。handler：中断处理函数，当中断发生以后就会执行此中断处理函数。flags：中断标志在文件include/linux/interrupt.h里面查看所有 name：中断名字，设置以后可以在/proc/interrupts文件中看到对应的中断名字。dev：如果将flags设置为IRQF_SHARED的话，dev用来区分不同的中断，一般情况下将dev设置为设备结构体，dev会传递给中断处理函数irq_handler_t的第二个参数。 + 申请一个线程中断 ```c int devm_request_threaded_irq(struct device *dev, unsigned int \t\t\tirq, irq_handler_t handler, irq_handler_t \t\t\t\t\tthread_fn, unsigned long irqflags, const char \t\t\t\t*devname, void *dev_id) ``` > 是申请线程中断, 参数一, 申请的设备, 参数二, 中断号, 参数三`handler`：中断处理函数，发生中断时，先处理中断处理函数, 参数4中断处理线程，该参数可为NULL。类似于中断处理函数的下半部分, 参数5: 中断标志, 参数6中断名称, 参数7: 传递的参数 ![QQ图片20220830202302](https://blog 1308522872.cos.ap beijing.myqcloud.com/jhy/202301010002828.png) ```c void free_irq(unsigned int irq, void *dev) ``` > irq：要释放的中断。dev：如果中断设置为共享(IRQF_SHARED)的话，此参数用来区分具体的中断。 ``` irqreturn_t (*irq_handler_t) (int, void *) ``` > 中断处理函数格式 > > ```c > 10\tenumirqreturn { > 11\t\tIRQ_NONE (0<<0), > 12\t\tIRQ_HANDLED (1<<0), > 13\t\tIRQ_WAKE_THREAD (1<<1), > 14\t}; > 15 > 16\ttypedef enum irqreturn irqreturn_t; > ``` > > ``` void enable_irq(unsigned int irq) void disable_irq(unsigned int irq ``` > 中断使能, 禁止某一个中断, 等到当前正在执行的中断处理函数执行完才返回 ``` void disable_irq_nosync(unsigned int irq) ``` > 不会等待当前中断处理程序执行完毕。 ``` local_irq_enable() local_irq_disable() ``` > local_irq_enable用于使能当前处理器中断系统，local_irq_disable用于禁止当前处理器中断系统, 恢复的时候可能会导致不可预知错误 ``` local_irq_save(flags) local_irq_restore(flags) ``` > 这两个函数是一对，local_irq_save函数用于禁止中断，并且将中断状态保存在flags中。local_irq_restore用于恢复中断，将中断到flags状态. ## 上半部下半部 我们在使用request_irq申请中断的时候注册的中断服务函数属于中断处理的上半部，只要中断触发，那么中断处理函数就会执行 在实际处理的时候, 有的中断处理函数会占用大量的时间, 不符合中断的规则 中断处理函数仅仅响应中断，然后清除中断标志位即可。这个时候中断处理过程就分为了两部分： 上半部：上半部就是中断处理函数，那些处理过程比较快，不会占用很长时间的处理就可以放在上半部完成。 下半部：如果中断处理过程比较耗时，那么就将这些比较耗时的代码提出来，交给下半部去执行，这样中断处理函数就会快进快出。 + 如果要处理的内容不希望被其他中断打断，那么可以放到上半部。 + 如果要处理的任务对时间敏感，可以放到上半部 + 如果要处理的任务与硬件有关，可以放到上半部 + 除了上述三点以外的其他任务，优先考虑放到下半部。 ### 软终端 使用结构体`softirq_action`表示软中断, `include/linux/interrupt.h` ```c 433\tstruct softirq_action 434\t{ 435\t\tvoid(*action)(structsoftirq_action *); 436\t}; ``` 在`kernel/softirq.c`文件中一共定义了10个软中断, 被定义为一个枚举类型 要使用软中断，必须先使用open_softirq函数注册对应的软中断处理函数 ```c void open_softirq(int nr, void (*action)(struct softirq_action *)) ``` > nr：要开启的软中断。action：软中断对应的处理函数。 > > **必须在编译的时候静态注册, **内核中默认会打开TASKLET_SOFTIRQ和HI_SOFTIRQ ```c void raise_softirq(unsigned int nr) ``` > 注册以后触发, nr：要触发的软中断 ### tasklet `tasklet`是利用软中断来实现的另外一种下半部机制, 建议使用这一个 Linux内核使用`tasklet_struct`结构体来表示`tasklet` ```c 484\tstruct tasklet_struct 485\t{ 486\t\tstructtasklet_struct *next;\t/* 下一个tasklet */ 487\t\tunsignedlongstate;\t\t\t/* tasklet状态*/ 488\t\tatomic_t count;/* 计数器，记录对tasklet的引用数*/ 489\t\tvoid(*func)(unsignedlong);\t/* tasklet执行的函数*/ 490\t\tunsignedlongdata;\t\t\t/* 函数func的参数*/ 491\t}; ``` ```c void tasklet_init(struct tasklet_struct *t,void (*func)(unsigned long), unsigned long data); ``` > 进行结构物初始化, t：要初始化的`tasklet` `func`: `tasklet`的处理函数。data：要传递给`func`函数的参数 也 可 以 使 用 宏DECLARE_TASKLET来 一 次 性 完 成`tasklet`的 定 义 和 初 始 化, ``` DECLARE_TASKLET(name, func, data) ``` > name为要定义的`tasklet`名字，这个名字就是一个`tasklet_struct`类型的时候变量，`func`就是`tasklet`的处理函数，data是传递给`func`函数的参数 + 在上半部，也就是中断处理函数中调用tasklet_schedule函数就能使tasklet在合适的时间运行，tasklet_schedule函数原型如下 ```c void tasklet_schedule(struct tasklet_struct *t) ``` 也要使用上半部, 但是主要的作用是调用下半部的处理函数 ### 工作队列 工作队列在进程上下文执行，工作队列将要推后的工作交给一个内核线程去执行，因为工作队列工作在进程上下文，因此工作队列允许睡眠或重新调度。 使用work_struct结构体表示一个工作 ```c struct work_struct { atomic_long_t data; structlist_head entry; work_func_t func;/* 工作队列处理函数*/ }; ``` 直接定义一个work_struct结构体变量即可，然后使用INIT_WORK宏来初始化工作 ```c #define INIT_WORK(_work, _func) ``` > _work表示要初始化的工作，\\_func是工作对应的处理函数, `static void kaywork(struct work_struct *work)` 也可以使用DECLARE_WORK宏一次性完成工作的创建和初始化 ``` #define DECLARE_WORK(n, f) ``` > n表示定义的工作(work_struct)，f表示工作对应的处理函数 和tasklet一样，工作也是需要调度才能运行的，工作的调度函数为schedule_work ```c bool schedule_work(struct work_struct *work) ``` 由于最后调用的函数参数是work_struct结构体, 所以可以使用函数`container_of`获取结构体所在的结构体的首地址, 第一个参数, 传入的work结构体, 第二个参数所在的结构体, 第三个参数自己的名字 ## 在设备树中描述 Linux内核通过读取设备树中的中断属性信息来配置中断 打开imx6ull.dtsi文件，其中的intc节点就是I.MX6ULL的中断控制器节点 ```c intc: interrupt controller@00a01000 { compatible \"arm,cortex a7 gic\"; #interrupt cells <3>; interrupt controller; reg <0x00a01000 0x1000>, <0x00a02000 0x100>; }; ``` + compatible \"arm,cortex a7 gic\";描述使用的驱动文件 + #interrupt cells <3>; 表示此中断控制器下设备的cells大小 第一个cells：中断类型，0表示SPI中断，1表示PPI中断。第二个cells：中断号，对于SPI中断来说中断号的范围为0\\~987，对于PPI中断来说中断号的范围为0~15。第三个cells：标志，bit[3:0]表示中断触发类型，为1的时候表示上升沿触发，为2的时候表示下降沿触发，为4的时候表示高电平触发，为8的时候表示低电平触发。bit[15:8]为PPI中断的CPU掩码 ```c gpio1: gpio@0209c000 { compatible \"fsl,imx6ul gpio\", \"fsl,imx35 gpio\"; reg <0x0209c000 0x4000>; interrupts <GIC_SPI 66 IRQ_TYPE_LEVEL_HIGH>, <GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH>; gpio controller; #gpio cells <2>; interrupt controller; #interrupt cells <2>; }; ``` 在单独的gpio中把cell改为2, ```c fxls8471@1e { compatible \"fsl,fxls8471\"; reg <0x1e>; position <0>; interrupt parent <&gpio5>; \t//父中断 interrupts <0 8>;\t\t//指定对应的引脚以及触发电平 }; ``` > 0表示GPIO5_IO00，8表示低电平触发, 1是上升沿, 2是下降沿, 4高电平触发 ①、#interrupt cells，指定中断源的信息cells个数。②、interrupt controller，表示当前节点为中断控制器。③、interrupts，指定中断号，触发方式等。④、interrupt parent，指定父中断，也就是中断控制器 + interrupt controller; 这是一个中断控制器 ### 对应的函数 ```c unsigned int irq_of_parse_and_map(struct device_node *dev,int index) ``` > dev：设备节点。index：索引号，interrupts属性可能包含多条中断信息，通过index指定要获取的信息 ```c int gpio_to_irq(unsigned int gpio) ``` > `gpio`：要获取的GPIO编号"},"/note/Linux/原子Linux/2022-9-5-触摸屏.html":{"title":"触摸屏","content":" layout: post title: \"触摸屏\" date: 2022 9 5 15:39:08 +0800 tags: 嵌入式 原子Linux # 触摸屏 就是上报多点触摸信息, 通过触摸芯片, 多点电容触摸屏本质就是I2C驱动, 通过中断读取, 得到信息之后Linux使用INPUT进行输入 Linux有触摸屏上报的流程 Document/input/multi touch protocol.txt 有两种协议, 大多数使用的是Type B, Type A比较简单, 没有轨迹追踪, 会上报所有的数据, Type使用于有硬件追踪的数据 上报触摸信息时候, 通过上报事件进行上报, include/uapi/linux/input.h中 ```c #define ABS_MT_SLOT\t\t0x2f\t/* MT slot being modified */ #define ABS_MT_TOUCH_MAJOR\t0x30\t/* Major axis of touching ellipse */ #define ABS_MT_TOUCH_MINOR\t0x31\t/* Minor axis (omit if circular) */ #define ABS_MT_WIDTH_MAJOR\t0x32\t/* Major axis of approaching ellipse */ #define ABS_MT_WIDTH_MINOR\t0x33\t/* Minor axis (omit if circular) */ #define ABS_MT_ORIENTATION\t0x34\t/* Ellipse orientation */ #define ABS_MT_POSITION_X\t0x35\t/* Center X touch position */ #define ABS_MT_POSITION_Y\t0x36\t/* Center Y touch position */ #define ABS_MT_TOOL_TYPE\t0x37\t/* Type of touching device */ #define ABS_MT_BLOB_ID\t\t0x38\t/* Group a set of packets as a blob */ ...... ``` > 最常用的事件就是, ABS_MT_POSITION_X, ABS_MT_POSITION_Y和ABS_MT_BLOB_ID, 分别上报对应的坐标以及区分坐标点, 一般先上报点的横坐标, 纵坐标, 点和点之间使用ABS_MT_BLOB_ID隔离 ```c void input_mt_sync(struct input_dev *dev) ``` > 对于TypeA类型的设备，通过input_mt_sync()函数来隔离不同的触摸点数据信息, 实际是上报SYN_MT_REPORT信息, 通知接收者获取当前触摸数据，并且准备接收下一个触摸点数据 ```c static inline void input_sync(struct input_dev *dev) ``` > 所有上报结束之后使用的函数, SYN_REPORT事件 ```c void input_mt_report_slot_state(struct input_dev *dev, unsigned \t\t\t\t\t\t\t\tint tool_type, bool active); ``` > 用来上报一个点的, 如果是添加一个新的触摸点，那么此函数的第三个参数active要设置为true，linux内核会自动分配一个ABS_MT_TRACKING_ID值, 产生ABS_MT_TRACKING_ID和ABS_MT_TOOL_TYPE事件, ABS_MT_TOOL_TYPE事 件 指 定 触 摸 类 型 （ 是 笔 还 是 手 指 等 ） > > dev：MT设备对应的input_dev。tool_type：触摸类型，可以选择MT_TOOL_FINGER(手指)、MT_TOOL_PEN(笔)或MT_TOOL_PALM(手掌)，对于多点电容触摸屏来说一般都是手指。active：true，连续触摸，input子系统内核会自动分配一个ABS_MT_TRACKING_ID给slot。false，触摸点抬起，表示某个触摸点无效了，input子系统内核会分配一个 1给slot，表示触摸点溢出 ```c void input_mt_slot(struct input_dev *dev, int slot) ``` > 此函数用于产生ABS_MT_SLOT事件，告诉内核当前上报的是哪个触摸点的坐标数据, dev：MT设备对应的input_dev。slot：当前发送的是哪个slot的坐标信息，也就是哪个触摸点 ```c int input_mt_init_slots(struct input_dev *dev, unsigned int \t\t\t\t\t\t\tnum_slots,unsigned int flags) ``` > 用于初始化MT的输入slots，编写MT驱动的时候必须先调用此函数初始化slots, dev：MT设备对应的input_dev，因为MT设备隶属于input_dev。num_slots：设备要使用的SLOT数量，也就是触摸点的数量。flags：其他一些flags信息 ```c void input_report_abs(struct input_dev *dev, unsigned int code, \t\t\t\t\t\tint value) ``` > dev：MT设备对应的input_dev。code：要上报的是什么数据，可以设置为ABS_MT_POSITION_X或ABS_MT_POSITION_Y，也就是X轴或者Y轴坐标数据。value：具体的X轴或Y轴坐标数据值 ```c void input_mt_report_pointer_emulation(struct input_dev *dev, \t\t\t\tbool use_count) ``` > dev：MT设备对应的input_dev。use_count：true，有效的触摸点数量；false，追踪到的触摸点数量多于当前上报的数量。返回值：无。 ## 实际流程 + Type A ```c ABS_MT_POSITION_X x[0] ABS_MT_POSITION_Y y[0] SYN_MT_REPORT ABS_MT_POSITION_X x[1] ABS_MT_POSITION_Y y[1] SYN_MT_REPORT SYN_REPORT ``` + Type B ```c \tABS_MT_SLOT 0\t\t\t//input_mt_slot ABS_MT_TRACKING_ID 45\t//input_mt_report_slot_state ABS_MT_POSITION_X x[0]\t//input_report_abs ABS_MT_POSITION_Y y[0] ABS_MT_SLOT 1 ABS_MT_TRACKING_ID 46 ABS_MT_POSITION_X x[1] ABS_MT_POSITION_Y y[1] SYN_REPORT ``` TypeB设备驱动需要给每个识别出来的触摸点分配一个slot，后面使用这个slot来上报触摸点信息。可以通过slot的ABS_MT_TRACKING_ID来新增、替换或删除触摸点 一个非负数的ID表示一个有效的触摸点， 1这个ID表示未使用slot。一个以前不存在的ID表示这是一个新加的触摸点 ### 中断线程化 驱动的主框架就是i2c, 需要使用中断处理, 中断处理函数中上报, 要使用到INPUT子系统框架 devm_request_threaded_irq函数 > 中断进程化, 用于申请中断，作用和request_irq函数类似, 中断线程化以后中断将作为内核线程运行，而且也可以被赋予不同的优先级，任务的优先级可能比中断线程的优先级高，这样做的目的就是保证高优先级的任务能被优先处理 下半部可以被延迟处理，但是依旧先于线程执行，中断线程化可以让这些比较耗时的下半部与进程进行公平竞争 ### devm “devm\\_\"前缀, 使用“devm_”前缀的函数申请到的资源可以由系统自动释放，不需要我们手动处理。 ## 实现 ``` ft5426: ft5426@38 { compatible \"edt,edt ft5426\"; reg <0x38>; pinctrl names \"default\"; pinctrl 0 <&pinctrl_tsc &pinctrl_tsc_reset>; interrupt parent <&gpio1>; interrupts <9 0>; reset gpios <&gpio5 9 GPIO_ACTIVE_LOW>; interrupt gpios <&gpio1 9 GPIO_ACTIVE_LOW>; status \"okay\"; }; ``` .proc/device tree/soc/aps bus@2100000/i2c@021a40000 1. 搭建框架 2. 初始化引脚 使用函数`devm_gpio_request_one`一次性初始化引脚 3. 初始化中断 4. 初始化ft5426 5. 读取坐标上报 ```c if(touch_num) { /* 单点触摸按下 */ gt9147_read_regs(dev, GT_TP1_REG, touch_data, 5); id touch_data[0] & 0x0F; if(id 0) { input_x touch_data[1] (touch_data[2] << 8); input_y touch_data[3] (touch_data[4] << 8); input_mt_slot(dev >input, id); \t\t input_mt_report_slot_state(dev >input, MT_TOOL_FINGER, true);\t\t//为连续触摸 \t\t input_report_abs(dev >input, ABS_MT_POSITION_X, input_x); \t\t input_report_abs(dev >input, ABS_MT_POSITION_Y, input_y); } } else if(touch_num 0){ /* 单点触摸释放 */ input_mt_slot(dev >input, id); input_mt_report_slot_state(dev >input, MT_TOOL_FINGER, false);\t\t//不是连续触摸 } ``` ## 测试 tslib, 用于测试触摸屏 1. 安装 ```c sudo apt get install autoconf sudo apt get install automake sudo apt get install libtool ``` 2. 编译 ```c ./autogen.sh ./configure host arm linux gnueabihf prefix /home/zuozhongkai/linux/IMX6ULL/tool/tslib make//编译 make install//安装 ``` 3. 复制到根文件 4. et/profile加入 ```c export TSLIB_TSDEVICE /dev/input/event2\t//使用的设备 export TSLIB_CALIBFILE /etc/pointercal //校准文件 export TSLIB_CONFFILE /etc/ts.conf //触摸配置文件 export TSLIB_PLUGINDIR /lib/ts //插件目录 export TSLIB_CONSOLEDEVICE none \t// export TSLIB_FBDEVICE /dev/fb0\t\t//关联的目录 ``` 5. 使用 ```bash ts_calibrate \t\t\t//校准,不满意删除文件/etc/pointercal ts_test_mt\t\t\t\t//测试 ``` ## 设置驱动为内核 打开Linux, ```bash jiao@jiao virtual machine:~/linux/IMX6ULL/Bord_Drivers/23_multitouch$ cp gt9147. /home/jiao/linux/IMX6ULL/linux/linux imx rel_imx_4.1.15_2.1.0_ga_alientek/drivers/input/touchscreen/ ``` 之后在这个文件夹最后加上`obj y + gt9147.o`"},"/note/Linux/原子Linux/2022-8-14-按键检测.html":{"title":"按键检测","content":" layout: post title: \"按键检测\" date: 2022 8 14 15:39:08 +0800 tags: 嵌入式 原子Linux # 按键检测 (IOMUXC_SW_MUX_CTL_PAD_UART1_CTS_B 默认情况为高电平, 按下的时候是低电平, UART1_CTS复用为GPIO1_IO18, 模式5 设置电气属性:设置为22K上拉 ## 出现问题 加入清除ssh区域的代码以后不运行, ```bash 87800000 <_bss_start>: 87800000:\t87800241 \tstrhi\tr0, [r0, r1, asr #4] 87800004 <_bss_end>: 87800004:\t87800241 \tstrhi\tr0, [r0, r1, asr #4] ``` 清除的时候地址不是按照4字节处理的, 所以会导致清除其他位置的代码段, 所以需要对BSS_Start进行四字节对齐 > 在进行段地址赋值的时候, 等号前后要有空格"},"/note/Linux/原子Linux/2022-8-11-文件系统结构.html":{"title":"文件系统结构","content":" layout: post title: \"文件系统结构\" date: 2022 8 11 15:39:08 +0800 tags: 嵌入式 原子Linux # 文件系统结构 ## /bin 存放二进制的文件, 单用户下可以使用, 一般为命令 ## /boot ubuntu的启动文件 存放Linux内核, 镜像, 启动grub ## /dev 设备的驱动文件 ## /etc 配置文件 /etc/apt/sources.list这一个是控制下载的源 [ubuntu 镜像站使用帮助 清华大学开源软件镜像站 Tsinghua Open Source Mirror](https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/) ## /home 家目录 ## /lib 库文件.so结尾 ![image 20240207214140536](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402072141612.png) > 这一个是C语言的标准库 ## /media 可以插拔的文件 ## /mnt 用户可以选择的挂载点 ## /opt 可选的文件, 一般是测试时候使用的目录 ## /proc 虚拟的文件系统, 存放运行的系统信息 存放于内存上的信息 ## /sbin 存放命令 ## /snap Linux引入的包管理工具 ## /sys 虚拟文件系统, 记录系统信息 ## /temp 临时文件夹 ## /usr Unix Software Resource缩写, 存放系统用户有关的文件, 占内存最大, 第三方的文件以及库等, 可以存放用户的程序, 文档等 有/usr/bin和/usr/sbin文件存放可执行文件, 还有/usr/share/doc文件存放文档 ## /var 变化的文件, 比如日志, /var/log ## 文件类型 普通文件 目录文件 d 字符设备 c 块设备 b 软连接 l 管道文件 p 套接字 s 未知文件 ."},"/note/Linux/原子Linux/2022-9-11-Regmap.html":{"title":"Regmap","content":" layout: post title: \"Regmap\" date: 2022 9 11 15:39:08 +0800 tags: 嵌入式 原子Linux # Regmsp Linux下的很多开发都是针对寄存器, 为了方便进行管理 比如有一些产品更改寄存器的方法有多种, I2C, SPI等, 当进行更改的时候需要的工作量比较大 使用regmap模型可以进一步简化使用 重点是和寄存器打交道, 提供统一的接口 最主要的就是i2c, spi, mmio ## 实现 Linux内 核 将regmap框 架 抽 象 为regmap结 构 体 ， 这 个 结 构 体 定 义 在 文 件drivers/base/regmap/internal.h中 有很多的函数以及table，这些需要驱动编写人员根据实际情况选择性的初始化 regmap的初始化通过结构体regmap_config来完成 regmap_config结构体就是用来初始化regmap的，这个结构体也定义在include/linux/regmap.h ```c struct regmap_config { \tconst char *name; \tint reg_bits; \tint reg_stride; \tint pad_bits; \tint val_bits; \tbool (*writeable_reg)(struct device *dev, unsigned int reg); \tbool (*readable_reg)(struct device *dev, unsigned int reg); \tbool (*volatile_reg)(struct device *dev, unsigned int reg); \tbool (*precious_reg)(struct device *dev, unsigned int reg); \tregmap_lock lock; \tregmap_unlock unlock; \tvoid *lock_arg; \tint (*reg_read)(void *context, unsigned int reg, unsigned int *val); \tint (*reg_write)(void *context, unsigned int reg, unsigned int val); \tbool fast_io; \tunsigned int max_register; \tconst struct regmap_access_table *wr_table; \tconst struct regmap_access_table *rd_table; \tconst struct regmap_access_table *volatile_table; \tconst struct regmap_access_table *precious_table; \tconst struct reg_default *reg_defaults; \tunsigned int num_reg_defaults; \tenum regcache_type cache_type; \tconst void *reg_defaults_raw; \tunsigned int num_reg_defaults_raw; \tu8 read_flag_mask; \tu8 write_flag_mask; \tbool use_single_rw; \tbool can_multi_write; \tenum regmap_endian reg_format_endian; \tenum regmap_endian val_format_endian; \tconst struct regmap_range_cfg *ranges; \tunsigned int num_ranges; }; ``` > reg_bits：寄存器地址位数，必填字段。reg_stride：寄存器地址步长。val_bits：寄存器值位数，必填字段。read_flag_mask：读标志掩码。write_flag_mask：写标志掩码。 regmap支持多种物理总线，比如I2C和SPI，我们需要根据所使用的接口来选择合适的regmap初始化函数 ```c struct regmap * regmap_init_spi(struct spi_device *spi,const \t\t\t\t\t\t\tstruct regmap_config *config) ``` > spi：需要使用regmap的spi_device。config：regmap_config结构体，需要程序编写人员初始化一个regmap_config实例，然后将其地址赋值给此参数。返回值：申请到的并进过初始化的regmap。实际就是把结构体和标准的驱动进行绑定 ```c struct regmap*regmap_init_i2c(struct i2c_client *i2c,const struct regmap_config *config) ``` > i2c：需要使用regmap的i2c_client。config：regmap_config结构体，需要程序编写人员初始化一个regmap_config实例，然后将其地址赋值给此参数。 ```c int regmap_read(struct regmap *map, unsigned int reg, unsigned int \t\t\t\t\t\t\t\t\t\t\t\t*val) ``` > map：要操作的regmap。reg：要读的寄存器。val：读到的寄存器值。返回值：0，读取成功；其他值，读取失败。 ```c int regmap_write(struct regmap *map, unsigned int reg, unsigned \t\t\t\t\t\t\t\t\t\t\tint val) ``` > map：要操作的regmap。reg：要写的寄存器。val：要写的寄存器值。 ```c int regmap_update_bits (struct regmap *map, unsigned int reg,unsigned int mask,unsigned int val) ``` > map：要操作的regmap。reg：要操作的寄存器。mask：掩码，需要更新的位必须在掩码中设置为1。val：需要更新的位值。返回值：0，写成功；其他值，写失败。 ```c int regmap_bulk_read(struct regmap *map, unsigned int reg, void \t\t\t\t\t\t\t\t\t*val,size_t val_count) ``` > 读取多个寄存器的值, map：要操作的regmap。reg：要读取的第一个寄存器。val：读取到的数据缓冲区。val_count：要读取的寄存器数量。 ```c int regmap_bulk_write(struct regmap *map, unsigned int reg, const \t\t\t\t\t\tvoid *val,size_t val_count) ``` > map：要操作的regmap。reg：要写的第一个寄存器。val：要写的寄存器数据缓冲区。val_count：要写的寄存器数量。返回值：0，写成功；其他值，读失败。 标准的SPI驱动，其中第21行将寄存器的地址bit7置1，表示这是一个读操作。当我们使用regmap的时候就不需要手动将寄存器地址的bit7置1，在初始化regmap_config的时候直接将read_flag_mask设置为0X80即可"},"/note/Linux/原子Linux/2022-8-15-主频时钟配置.html":{"title":"主频时钟配置","content":" layout: post title: \"主频时钟配置\" date: 2022 8 15 15:39:08 +0800 tags: 嵌入式 原子Linux # 主频时钟配置 初始化默认为396M, 最高792M 时钟来源 时钟 晶振1, 32.768kHz, 供给给RTC实时时钟使用 晶振2, 在T16和T17上有一个24MHz的晶振 ## 时钟的构成 手册18章 首先是7路PLL, 为了方便生成时钟, 从24MHz生成的, 有的再次生成PFD 时钟树: PLL >PFD >外设 + PLL1(ARMPLL): 650MHz 1.3GHz, 提供给ARM内核的, 此PLL通过编程的方式最高可倍频到1.3GHz + PLL2(System PLL, 528PLL): 528MHz, 这个是固定的, 分出四路PFD, PLL2_PFD0 3 + PLL3(USB1_PLL, 480PLL): 只要用于USB但是也会用于其他, 固定为480MHz, 也有四路PFD, PLL3_PFD0 3 + PLL4(Audio PLL): 主供音频使用 + PLL5(Video PLL): 主供视频外设, RGB LCD以及图形处理的外设 + PLL6(ENET PLL): 网络连接外设 + PLL7(USB2_PLL): 480Mhz没有PFD ![image 20251014102854159](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510141028314.png) ![image 20251014103222465](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510141032555.png) ### 要初始化的PLL以及PFD PLL1 PLL2以及各路PFD PLL3以及PFD 一般按照时钟树里面的值进行设置, 表18 4给出系统时钟的值 ![image 20251014104525321](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510141045375.png) ## 配置 ### 主频 PLL1通过CACRR[ARM_PODF]的0 3位控制1 8分频 设置主频为528Mhz, 设置为二分频, PLL1 为1056Mhz, 设置CACRR[ARM_PODF]等于一的时候 #### 设置PLL1 18 5 1 5 1图片 + PLL1 pll1_sw_clk, 有两路可以选择, 分别为pll1_main_clk 和 step_clk(来自osc_clk等), 通过CCSR\\[pll1_sw_clk_sel](bit2)进行选择, 为0的时候选择pll1_main_clk, + 在修改PLL1的时候需要有一个临时的时钟, 在修改的时候切换到step_clk, 有两个来源, 有CCSR\\[ step_sel](bit8)来进行设置, 0的时候设置为晶振24Mhz + 时钟切换成功以后就可以修改PLL1的值了 $PLL output frequency Fref * DIV_SEL/2$ Fref就是晶振, DIVsEL就是CCM_ANALOG_PLL_ARM\\[DIV_SELECT](bit0 6)设置的 设置为528主频的时候, 这个位就是88, 还要设置CCM_ANALOG_PLL_ARM\\[ENABLE](bit13)位为1 注: **再切换回来之前一定要设置为二分频CACRR[ARM_PODF]为1** ## 其他PLL初始化 PLL2和PLL3, 他们的频率固定, 528和480, 但是PFD需要初始化 ### PLL2 寄存器CCM_ANALOG_PFD528用于设置四路PFD的时钟 $PFD0 528*18/PFD0_FRAC$ PFD0_FRAC is in the range 12 35,占用6位,还有两位其他设置不修改, 其他的四路公式一样 PFD0 352M, PFD1 594M, PFD2 396M, PFD3 297M PLL3设置类似 ## 设置其他外设时钟源配置 这里初始化PERCLK_CLK_ROOT, IPG_CLK_ROOT, USDHC1_CLK_ROOT, 应为之后学习常用, 因为从时钟树得知PERCLK_CLK_ROOT, IPG_CLK_ROOT来自AHB_CLK_ROOT, 所以初始化AHB_CLK_ROOT最大为132M, PERCLK_CLK_ROOT, IPG_CLK_ROOT为66M ![QQ图片20220815165518](https://blog 1308522872.cos.ap beijing.myqcloud.com/jhy/202212312358194.png) > 图片629页 设置CBCMR\\[PRE_PERIPH_CLK_SEL](bit18 19)设置为1, 设置使用来源为PFD2不分频, 396M CBCDR\\[PERIPH_CLK_SEL](bit25): 外设主时钟, 设置为0走下边 CBCDR\\[AHB_PODF](bit12 10)三分频, 设置为2, 设置完以后等待完成, 有可能会产生错误, 可以保持默认值 后面差不多了"},"/note/Linux/原子Linux/2022-8-13-IMX启动方式.html":{"title":"IMX启动方式","content":" layout: post title: \"IMX启动方式\" date: 2022 8 12 15:39:08 +0800 tags: 嵌入式 原子Linux # IMX启动方式 ![image 20251016233308259](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510162333380.png) ## 启动方式的选择 LED灯是从SD卡读取启动文件, 所以支持从SD卡启动 大多数的Linux芯片都支持多种启动方式 ### 6ULL 怎么选择启动方式, 手册第八章 + 启动方式的选择 根据引脚设置, BOOT_MODE1和BOOT_MODE0两个引脚 这是两个I/O控制的, 默认连接到拨码开关的1,2按键, 在芯片内部默认为下拉, 外接上拉电阻 > 00: 从熔丝启动, 烧录一次, 作为产品发布 > 01: 串行下载, USB启动, 串口启动 > 10: 内部的boot, SD卡, eMMC > 11: 保留 如果要烧写系统使用USB下载, 一般下载到SD卡EMMC中等, 烧写完成后设置为从内部boot启动 + 启动设备的选择 前提是你已经设置为从内部启动 支持的设备:` nor fash, oneNAND, QSPI fash, SD/EMMPRON`, 最常用的是NAND, SD, EMMC和 QSPI Flash > 选择, 通过BOOT_CFG选择 有BOOT_CFG1, 2, 4每个八位 是由LCD_DATA0 23进行设置的, 开发板上大部分默认为47K接地 BOOT_CFG4全部接地 BOOT_CFG2 3, 4可以选择使用哪一个SD卡接口(一共有两个), 但是4都接0, 所以只有第三个接口连接到拨码开关, 0的时候从eSDHC1启动, 1从eSDHC2启动 BOOT1 3, 4, 5, 6, 7被使用, 0,1默认上拉, 其他的位设施SD卡, EMMC, NADA启动的方式, 以及设备的格式 在核心板上boot核心设置, 一般为47k接地, 拨码开关有一个4.7k电阻接3.3v, 用以设置 > BOOT_MODE1和BOOT_MODE0两个引脚设置启动位置, 使用BOOT_CFG1[4:7]进行设置不同的介质, 使用BOOT_CFG2[5]选择实际的接口编号(SD卡和EMMC), BOOT_CFG2[5]设置的是接口的属性, 比如位宽, 读取速度等, 对应8位引脚 > > 实际的BOOT_CFG对应LCD_DATAx引脚 > > ![image 20250712185054408](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507121850546.png) > > 用户手册 > > ![image 20250712185307273](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507121853337.png) > > ![image 20250712185445533](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507121854596.png) > > ![image 20250712190039836](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507121900917.png) > > ![image 20250712185516982](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507121855033.png) ## 启动头文件 在`boot rom`启动的时候 首先会进行 手册8.4设备初始化 ROM是从0x00000000到0x00017fff一共96k RAM是从0x00900000到0x0091ffff ### Boot Rom做的事情 设置时钟, 内核时钟为396M, 以及各个外设的时钟源 使能MMU(内存管理单元), 和Cache, 加快运行的速度 从BOOT_CFG设置的外部存储之中读取image, 然后做相应的处理 ### IVT和Boot Data数据 8.7烧写镜像 ①、`Image vectortable`，简称IVT，IVT里面包含了一系列的地址信息，这些地址信息在ROM中按照固定的地址存放着 ②、`Bootdata`，启动数据，包含了镜像要拷贝到哪个地址，拷贝的大小是多少等等。 ③、`Device configuration data`，简称DCD，设备配置信息，重点是DDR3的初始化配置 ④、用户代码可执行文件，比如`led.bin`。 在头部之中必须有的数据结构, 放置有一系列的地址 #### IVT表 包含镜像的入口地址, DCD数据的位置, 以及其他需要的地址, 不同的设备位置不同, 我们烧写到SD卡中的文件起始地址是0x400也就是1024, 然后存放3K的头部信息.之后才是我们烧写的bin文件, 在书写的时候是低字节在前 IVT大小是32字节, 一共有8条 地址为0x877FF400开始 + 第一条header保存自己的信息0X402000D1 格式为 tag >Length >Version Tag为一个字节长度固定为0xD1, Length两个字节, 最后是Version为0x41或0x40 高直接保存在低字节 + 第二条entry: 入口地址0X87800000 + 第三条: 保留 + 第四条dcd: 0X877FF42C, DCD地址, 由于已经设置文件的地址为0X87800000, 所以`load.imx`的起始地址就是0X87800000 0XC00 0X877FF400。0X2C这个地址开始就是DCD数据了。 + 第五条boot data: header里面已经设置了IVT大小是32个 字 节 ， 所 以boot data的 地 址 就 是0X877FF400+32 0X877FF420。 + 第六条self: IVT复制到DDR中以后的首地址0X877FF400 + 第七条csf: CSF地址。0X00000000没有用到 + 保留 #### Boot data 有三个, 每一个32位 + 镜像绝对地址0X877FF000, 实际为定位前4kb处, 多出来的1kb是为了防止破坏SD卡的原始数据 + 镜像绝对大小0X00200000: 镜像大小，这里设置2MByte。镜像大小不能超过2MByte。 + plugin: 0X00000000插件 ## DCD数据 设备配置数据 就是用来配置内部寄存器的数据, 最大为1178b + 0X40E801D2也是有一个header, 结构和IVT表一样, 固定字节为0xD2, 所以DCD大小为0X01E8 488字节 + 0X04E401CC第一个为Tag，固定为0XCC，第二和三这两个字节是大端模式的命令总长度，为0X01E4 484个字节。第四个字节是Parameter，为0X04，表示目标位置宽度为4个字节 + 地址大端模式 + 值 + 地址 + 值 + ... 首先设置引脚, 然后设置DDR(内存) ## 其他的数据 检查数据命令, NOP命令, 解锁命令, 插件镜像等都没有写, 都属于DCD"},"/note/Linux/原子Linux/2022-9-11-PWM.html":{"title":"PWM","content":" layout: post title: \"PWM\" date: 2022 9 11 15:39:08 +0800 tags: 嵌入式 原子Linux # PWM imx6ull有8路PWM输出 NXP定义结构体imx_chip, 下面的pwd_chip是内核自己的结构体, 对应的结构体是 ```c static struct imx_pwm_data imx_pwm_data_v2 { \t.config imx_pwm_config_v2, \t.set_enable imx_pwm_set_enable_v2, }; ``` imx_chip ```c struct imx_chip { \tstruct clk\t*clk_per; \tstruct clk\t*clk_ipg; \tvoid __iomem\t*mmio_base; \tstruct pwm_chip\tchip; \tint (*config)(struct pwm_chip *chip, \t\tstruct pwm_device *pwm, int duty_ns, int period_ns); \tvoid (*set_enable)(struct pwm_chip *chip, bool enable); }; ``` 最终imx_chip >config imx_pwm_config_v2, imx_chip >set_enable imx_pwm_set_enable_v2 pwm_chip ```c struct pwm_chip { \tstruct device\t\t*dev; \tstruct list_head\tlist; \tconst struct pwm_ops\t*ops;\t\t//操作集, 需要驱动人员 \tint\t\t\tbase; \tunsigned int\t\tnpwm; \tstruct pwm_device\t*pwms; \tstruct pwm_device *\t(*of_xlate)(struct pwm_chip *pc, \t\t\t\t\t const struct of_phandle_args *args); \tunsigned int\t\tof_pwm_n_cells; \tbool\t\t\tcan_sleep; }; ``` > 里面的ops包括了开启关闭, 切换频率等 初始化这个结构体之后, 使用pwnchip_add进行注册 ```c 1\t&pwm3 { 2\t\tpinctrl names \"default\"; 3\t\tpinctrl 0 <&pinctrl_pwm3>; 4\t\tclocks <&clks IMX6UL_CLK_PWM3>, 5\t\t<&clks IMX6UL_CLK_PWM3>; 6\t\tstatus \"okay\"; 7\t}; ``` > 设备树 > Device Drivers > Pulse Width Modulation (PWM) Support > <*> i.MX PWM support > 图形化界面 直接看linux内核里面关于backlight(背光)的绑定文档，路径为Documentation/devicetree/bindings/video/backlight/pwm backlight.txt"},"/note/Linux/原子Linux/2022-9-10-网络驱动.html":{"title":"网络设备","content":" layout: post title: \"网络设备\" date: 2022 9 5 15:39:08 +0800 tags: 嵌入式 原子Linux # 网络设备 ## 硬件接口 网卡, 现在已经集成为一个芯片, 嵌入式主要就是两个芯片, MAC和PHY, 一般说芯片支持网络都是指内部有MAC MAC就类似于SPI控制芯片, 还需要外部搭载一个PHY芯片 ### 实现的方法 内部没有MAC, 可以使用外部MAC+PHY芯片, W5500可以通过SPI进行联网, 内部集成了TCP/IP协议, 但是网络速度较低, 成本也要高一点 内部集成了MAC外设, 直接外接PHY芯片就可以, 一般常见的单片机都会集成MAC外设, 有专门的加速模块, DMA的等, 支持的网速快, 可以支持的PHY种类多, 通过MII和RMII等接口连接外部的芯片, 用来传输网络数据, 还有用来控制PHY的控制接口, 有两根线, MDIO和MDC(时钟线), ### MII和RMII + MII 用于连接MAC和PHY芯片, 有16根线 TX_CLK：发送时钟，如果网速为100M的话时钟频率为25MHz，10M网速的话时钟频率为2.5MHz，此时钟由PHY产生并发送给MAC。 TX_EN：发送使能信号。 TX_ER：发送错误信号，高电平有效，表示TX_ER有效期内传输的数据无效。10Mpbs网速下TX_ER不起作用。 TXD[3:0]：发送数据信号线，一共4根。 RXD[3:0]：接收数据信号线，一共4根。 RX_CLK：接收时钟信号，如果网速为100M的话时钟频率为25MHz，10M网速的话时钟频率为2.5MHz，RX_CLK也是由PHY产生的。 RX_ER：接收错误信号，高电平有效，表示RX_ER有效期内传输的数据无效。10Mpbs网速下RX_ER不起作用。 RX_DV：接收数据有效，作用类似TX_EN。 CRS：载波侦听信号。 COL：冲突检测信号。 + RMII 精简以后只有9根线 TX_EN：发送使能信号。 TXD[1:0]：发送数据信号线，一共2根。 RXD[1:0]：接收数据信号线，一共2根。 CRS_DV：相当于MII接口中的RX_DV和CRS这两个信号的混合。 REF_CLK：参考时钟，由外部时钟源提供，频率为50MHz。这里与MII不同，MII的接收和发送时钟是独立分开的，而且都是由PHY芯片提供的。 ### MDIO接口 管理数据输入输出接口, 有两根线, MDIO和MDC线, 最多支持32个PHY ### RJ45接口 用来链接网网线, 和PHY芯片连接的时候需要一个网络变压器, 用于隔离滤波等作用 有的RJ45座子会内置一个网络变压器 一般有两个灯, 绿灯代表网络连接正常, 黄色的代表数据正在传输, ### PHY芯片 是标准规定下的标准模块, 寄存器地址空间有5位, 32个寄存器, 协议定义了前16个寄存器, 要求使用这个实现功能, 可以写出通用的驱动, 但是还是需要一些小的修改 #### 常用寄存器 BCR寄存器, 标号为0, bit15软件复位, bit14回测模式, bit13速度选择, bit12自动协商, bit11掉电模式, bit10隔离, bit9重启自动协商, bit8双工模式 BSR(Basic Status Register)寄存器，地址为1。此寄存器为PHY的状态寄存器，通过此寄存器可以获取到PHY芯片的工作状态 ## 内核驱动框架 使用net_device表示一个网络设备, 定义在include/linux/netdevice.h中 + 重要的成员 ```c const struct net_device_ops *netdev_ops; ``` > 网络设备的操作集, 一系列的网络设备操作回调函数，类似字符设备中的file_operations ```c const struct ethtool_ops *ethtool_ops; ``` > 网络工具相关的, 函数集，用户空间网络管理工具会调用此结构体中的相关函数获取网卡状态或者配置网卡。 ```c unsigned int\t\tflags; ``` > 网络标志 ````c unsigned char\t\tif_port; ```` > 可选的网络类型 + 实现 ``` #define alloc_netdev(sizeof_priv,name,name_assign_type,setup)\\ alloc_netdev_mqs(sizeof_priv,name,name_assign_type,setup,1,1) ``` > 申请一个net_device结构体, sizeof_priv：私有数据块大小。name：设备名字eth0等。setup：回调函数，初始化设备的设备后调用此函数。txqs：分配的发送队列数量。rxqs：分配的接收队列数量。返回值：如果申请成功的话就返回申请到的net_device指针，失败的话就返回NULL。可以支持多种网络设备, 包括以太网, CAN网络, WIFI等 ```c #define alloc_etherdev(sizeof_priv) alloc_etherdev_mq(sizeof_priv,1) #define alloc_etherdev_mq(sizeof_priv,count) alloc_etherdev_mqs(sizeof_priv,count,count) ``` > 专门用于以太网的数据结构体的申请 ```c struct net_device *alloc_netdev_mqs ( int sizeof_priv, \t\t\tconst char *name, void (*setup) (struct \tnet_device *)) \tunsigned int txqs, \t\tunsigned int rxqs); ``` > 这就是最后实际调用的的函数, sizeof_priv：私有数据块大小。name：设备名字。setup：回调函数，初始化设备的设备后调用此函数, 以太网的初始化函数是设置寄存器的各位的数据。txqs：分配的发送队列数量。rxqs：分配的接收队列数量。 ```c void free_netdev(struct net_device *dev) ``` > 用于释放网络设备 + net_device_ops 网络设备的操作集。需要网络驱动编写人员去实现，不需要全部都实现，根据实际驱动情况实现其中一部分即可 ```c int (*ndo_init) (structnet_device *dev); ``` > 当第一次注册网络设备的时候此函数会执行，设备可以在此函数中做一些需要退后初始化的内容，不过一般驱动中不使用此函数，虚拟网络设备可能会使用 ```c int (*ndo_open) (structnet_device *dev); int (*ndo_stop) (structnet_device *dev); ``` > 打开网络设备的时候此函数会执行，网络驱动程序需要实现此函数，非常重要 > > 关闭网络设备的时候此函数会执行，网络驱动程序也需要实现此函数 ```c netdev_tx_t (*ndo_start_xmit) (struct sk_buff *skb, struct net_device *dev); ``` > 需要发送数据的时候会调用的函数, 此函数有一个参数为sk_buff结构体指针，sk_buff结构体在Linux的网络驱动中非常重要，sk_buff保存了上层传递给网络驱动层的数据 + sk_buff 网络是分层的, 各个协议层在sk_buff中添加自己的协议头，最终由底层驱动讲sk_buff中的数据发送出去。网络数据的接收过程恰好相反，网络底层驱动将接收到的原始数据打包成sk_buff，然后发送给上层协议，上层会取掉相应的头部，然后将最终的数据发送给用户 ```c static inline int dev_queue_xmit(struct sk_buff *skb) ``` > 在内核中通过这个把数据发送出去, 最后调用的是ndo_start_xmit函数, ```c int netif_rx(struct sk_buff *skb) ``` > 上层接收数据的话使用netif_rx函数，但是最原始的网络数据一般是通过轮询、中断或NAPI的方式来接收 **主要的重要参数:** ```c sk_buff_data_t\t\ttail; sk_buff_data_t\t\tend; unsigned char\t\t*head, \t\t*data; ``` > head指向缓冲区的头部，data指向实际数据的头部。data和tail指向实际数据的头部和尾部，head和end指向缓冲区的头部和尾部。 **申请释放:** ```c static inline struct sk_buff *alloc_skb(unsigned int size,gfp_t priority) ``` > 申请一个sk_buff, size：要分配的大小，也就是skb数据段大小。priority：为GFP MASK宏，比如GFP_KERNEL、GFP_ATOMIC等。 ```c static inline struct sk_buff *netdev_alloc_skb(struct net_device \t\t\t\t\t\t*dev,unsigned int length) ``` > 常常使用netdev_alloc_skb来为某个设备申请一个用于接收的skb_buff, dev：要给哪个设备分配sk_buff。length：要分配的大小。 ```c void kfree_skb(struct sk_buff *skb) ``` > 用于释放sk_buff ```c void dev_kfree_skb(struct sk_buff *skb) ``` > 对于网络设备而言最好使用这个进行释放 **变更结构体:** ```c unsigned char *skb_put(struct sk_buff *skb, unsigned int len) ``` > 将skb_buff的tail后移n个字节，从而导致skb_buff的len增加n个字节, skb：要操作的sk_buff。len：要增加多少个字节。返回值：扩展出来的那一段数据区首地址。 ```c unsigned char *skb_push(struct sk_buff *skb, unsigned int len) ``` > 在头部扩展skb_buff的数据区, skb：要操作的sk_buff。len：要增加多少个字节。返回值：扩展完成以后新的数据区首地址。 ```c unsigned char *skb_pull(struct sk_buff *skb, unsigned int len) ``` > 从sk_buff的数据区起始位置删除数据, skb：要操作的sk_buff。len：要删除的字节数。返回值：删除以后新的数据区首地址。 ```c static inline void skb_reserve(struct sk_buff *skb, int len) ``` > 调整缓冲区的头部大小，方法很简单讲skb_buff的data和tail同时后移n个字节即可 ## 网络NAPI处理机制 NAPI是一种高效的网络处理技术。NAPI的核心思想就是不全部采用中断来读取网络数据，而是采用中断来唤醒数据接收服务程序，在接收服务程序中采用POLL的方法来轮询处理数据。这种方法的好处就是可以提高短数据包的接收效率，减少中断处理的时间。 ### 初始化 初始化一个napi_struct实例 ```c void netif_napi_add(struct net_device *dev, struct napi_struct \t\t\t*napi,int (*poll)(struct napi_struct *, int), int weight) ``` > dev：每个NAPI必须关联一个网络设备，此参数指定NAPI要关联的网络设备。napi：要初始化的NAPI实例。poll：NAPI所使用的轮询函数，非常重要，一般在此轮询函数中完成网络数据接收的工作。weight：NAPI默认权重(weight)，一般为NAPI_POLL_WEIGHT。 ```c void netif_napi_del(struct napi_struct *napi) ``` > 删除 ```c inline void napi_enable(struct napi_struct *n) ``` > 使能 ```c void napi_disable(struct napi_struct *n) ``` > 关闭 ```c inline bool napi_schedule_prep(struct napi_struct *n) ``` > 检查是否可以调度 ```c void __napi_schedule(struct napi_struct *n) ``` > 实际的调度 ```c inline void napi_complete(struct napi_struct *n) ``` > 处理完成 ## 设备树 ```v &fec2 { \tpinctrl names \"default\"; \tpinctrl 0 <&pinctrl_enet2>; \tphy mode \"rmii\"; \tphy handle <&ethphy1>; \tphy reset gpios <&gpio5 8 GPIO_ACTIVE_LOW>; \tphy reset duration <26>; \tstatus \"okay\"; \tmdio { \t\t#address cells <1>; \t\t#size cells <0>; \t\tethphy0: ethernet phy@0 { \t\t\tcompatible \"ethernet phy ieee802.3 c22\"; \t\t\treg <0>; \t\t}; \t\tethphy1: ethernet phy@1 { \t\t\tcompatible \"ethernet phy ieee802.3 c22\"; \t\t\treg <1>; \t\t}; \t}; }; ``` mdio：可以设置名为“mdio”的子节点，此子节点用于指定网络外设所使用的MDIO总线，主要做为PHY节点的容器，也就是在mdio子节点下指定PHY相关的属性信息，具体信息可以参考PHY的绑定文档Documentation/devicetree/bindings/net/phy.txt。 ### MDIO总线注册 用来管理PHY芯片的，分为MDIO和MDC两根线，Linux内核专门为MDIO准备一个总线，叫做MDIO总线，采用mii_bus结构体表示 ## PHY驱动 需要我们实现的 phy_driver就是PHY的驱动函数, 使能驱动 >Device Driver >Networlk device support > PHY Device support and infrastructure >Driver' for SMSC PHYs"},"/note/Linux/原子Linux/2022-9-11-4G.html":{"title":"WIFI","content":" layout: post title: \"WIFI\" date: 2022 9 11 15:39:08 +0800 tags: 嵌入式 原子Linux # 4G 是MiniPCIE接口的, 但是实际上的通信接口都是USB，所以4G模块的驱动就转换为了USB驱动。4G模块都遵循同样的接口标准，但是大家在使用的时候还是要详细的看一下4G模块的接口引脚描述。 4G模块工作是需要天线的, 一般MiniPCIE接口的4G模块留出来的天线接口为IPEX座，因此购买天线的时候也要选择IPEX接口的，或者使用IPEX转SMA线来转接。 ## ME3630 4G模块 ME3630 4G模块有多种配置，比如纯数据版本、集成GNSS版本、全网通版本等等，本节教程我们主要使用到ME3630的数据通信功能，因此推荐大家购买全网通数据版，如果想要定位功能的话就购买全网通数据+GNSS版本 配置Linux内核，首先使能USBNET功能 > Device Drivers > * Network device support > USB Network Adapters > * Multi purpose USB Networking Framework 使能USB串口GSM、CDMA驱动 > Device Drivers >[\\*] USB support > <\\*> USB Serial Converter support > <\\*> USB driver for GSM and CDMA modems 使能USB的CDC ACM模式 > Device Drivers > [\\*] USB support ><\\*> Support for Host side USB > <*> USB Modem (CDC ACM) support 使能Linux内核ppp功能 > Device Drivers >[\\*] Network device support ><\\*> PPP (point to point protocol) support > <\\*> PPP BSD Compress compression 在连接4G网络的时候不能直接ping通, 原因是网关的问题, 需要把获取到的ip添加到网关之中 查看: ip route show 添加: route add default gw 申请到的ip地址 在使用有线网络的时候需要把这一条删除route del default gw 申请到的ip地址"},"/note/Linux/原子Linux/2022-8-12-用户和用户组.html":{"title":"用户和用户组","content":" layout: post title: \"用户和用户组\" date: 2022 8 12 15:39:08 +0800 tags: 嵌入式 原子Linux # 用户和用户组 ## Linux用户 ubuntu有三种用户 + 初次创建的用户 + root用户 + 普通用户 记录在`/etc/passwd`, 保存用户的信息 `/etc/shadow`保存密码 ## 用户组 控制用户的权限 `/etc/group` 图形化界面, gnome system tools ### `adduser`命令 ``` adduser 用户名 ``` ### finger命令 用来查看用户信息 ```bash jiao@jiao virtual machine:~$ finger test Login: test \t\t\tName: Directory: /home/test \tShell: /bin/bash Office: 01, 110\t\t\t\tHome Phone: 120 Never logged in. No mail. No Plan. ``` ### `passwd`命令 修改密码 ### `deluser命令` 删除用户 ### `addgroup`命令 添加组 ### groups命令 ``` group 用户名 ``` 查看用户所在的组 ### `delgroup`命令 删除一个组"},"/note/Linux/原子Linux/2022-8-22-源码目录分析.html":{"title":"源码目录分析","content":" layout: post title: \"源码目录分析\" date: 2022 8 22 15:39:08 +0800 tags: 嵌入式 原子Linux # 源码目录分析 由于`uboot`会使用编译才会生成的文件, 所以在分析的时候需要编译一下 ## 文件夹 名字 描述 : : : : api 硬件无关的API函数 arch 架构相关的代码, 针对不同的架构 board 开发板相关的文件 cmd 命令相关的文件 common 通用代码 configs 配置文件 disk 磁盘分区相关代码 doc 文档 drivers 驱动代码 dts 设备树 examples 示例代码 fs 文件系统 include 头文件 lib 库文件 Licenses 许可证相关的文件 net 网络相关 > 在文件`arch >arm >CPU >u boot.lds`就是整个`uboot`的链接脚本, 确定每一块内容的位置, 在编译过后会出现一个在主目录下的相同文件 > 在board文件夹下的`freescale`文件下的mx6slevk就是我们使用的芯片 > configs是默认的配置文件下, 都使用`defconfig`结尾的, 根据不同的板子或平台进行配置, 一定要标志好自己的平台, 在编译的时候要指定默认的配置文件 + 在移植的时候, 重点关注broad, 根据参考进行修改 + configs设置不同的配置 + 之后的都是通用的文件 ## 文件 > .config在我们执行make xxx_defconfig之后会生成的文件, 保存了详细的配置信息 > > ``` > CONFIG_CREATE_ARCH_SYMLINK y > CONFIG_HAVE_GENERIC_BOARD y > CONFIG_SYS_GENERIC_BOARD y > # CONFIG_ARC is not set > CONFIG_ARM y > ``` > > Makefile文件中会使用在这里配置为信息 > > ``` > # This selects which instruction set is used. > arch $(CONFIG_CPU_ARM720T)\t march armv4 > arch $(CONFIG_CPU_ARM920T)\t march armv4t > arch $(CONFIG_CPU_ARM926EJS)\t march armv5te > arch $(CONFIG_CPU_ARM946ES)\t march armv4 > arch $(CONFIG_CPU_SA1100)\t march armv4 > ``` > > 使用这样的形式, 最后定义的变量名字最后是一个y > .u boot.cmd文件, 相关的命令 > Kconfig图形界面相关的 > 顶层Makefile最重要的Makefile > 顶层READEME最重要的README文件 > systemmap映射, 不同地址的内容 > u boot这个就是有elf信息的uboot可执行文件 > > > u boot：编译出来的ELF格式的uboot镜像文件。 > > > > u boot.bin：编译出来的二进制格式的uboot可执行镜像文件。 > > > > u boot.cfg：uboot的另外一种配置文件。 > > > > u boot.imx：u boot.bin添加头部信息以后的文件，NXP的CPU专用文件。 > > > > u boot.lds：链接脚本。 > > > > u boot.map：uboot映射文件，通过查看此文件可以知道某个函数被链接到了哪个地址上。 > > > > u boot.srec：S Record格式的镜像文件。 > > > > u boot.sym：uboot符号文件。 > > > > u boot nodtb.bin：和u boot.bin一样，u boot.bin就是u boot nodtb.bin的复制文件。 ## 启动流程 配置vscode 设定搜索以及显示的文件 新建文件夹.vscode, 在文件夹下建立settings.json文件 ``` { \"search.exclude\": { \"**/node_modules\": true, \"**/bower_components\": true, }, \"files.exclude\": { \"**/.git\": true, \"**/.svn\": true, \"**/.hg\": true, \"**/CVS\": true, \"**/.DS_Store\": true, \"**/Thumbs.db\": true } } ``` ###"},"/note/Linux/原子Linux/2022-8-16-EPIT定时器.html":{"title":"中断","content":" layout: post title: \"中断\" date: 2022 8 15 15:39:08 +0800 tags: 嵌入式 原子Linux # EPIT定时器 第24章 ![image 20251015094933241](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510150949479.png) 提供周期性的中断, 只能做定时器, 一共有两个 是一个32位的向下计数器, 没一个周期减一, 可以选择`ipg_clk`, 被配置为66MHz 可以对时钟源进行分频, 有一个12位的分频器1 4096 有三个寄存器, 计数寄存器, 比较寄存器, 重加载寄存器 开启以后计数寄存器每一个时钟周期减一, 如果和比较相等就会产生中断或者某个引脚产生一个信号 + 两种工作 1. set and forget模式：从加载寄存器`EPITx_LR`中获取初始值，不能直接向计数器寄存器写入数据。 2. free running模式 : 当计数器计数到0以后会重新从0XFFFFFFFF开始计数，并不是从加载寄存器`EPITx_LR`中获取数据 > `EPITx_CR`\\[RLD](bit3): 控制模式的选择设置为1的时候会从重加载寄存器获取数字 `EPIT_CR` 用来控制EPIT, 设置是否使能(bit0), 启动时候初始值是否重新加载的设置(bit1), 中断使能(bit2), 工作模式, 获取计数最大值的位置(bit3), 设置分频(4 15), 软复位(bit16), 时钟源选择(24 25) `EPIT_SR`: bit0有效进行中断复位, 1的时候为中断发生, 写1复位 `EPIT_LR`寄存器, 重加载寄存器 `EPIT_CMPR`: 比较寄存器, 比较的结果相等的时候会进行 ## 按键销抖 在每一次跳变的时候都会重新设置定时器, 在最后一次跳变的时候才会进行按键功能的实现, 在定时器的中断中实现要实现的功能"},"/note/Linux/原子Linux/2022-9-11-RGBtoHDMI.html":{"title":"RGB转HDMI","content":" layout: post title: \"RGB转HDMI\" date: 2022 9 11 15:39:08 +0800 tags: 嵌入式 原子Linux # RGB转HDMI 由于本身没有HDMI接口, 只能使用转接进行, 最好使用包含有HDIM支持的芯片"},"/note/Linux/原子Linux/2022-8-13-vscode.html":{"title":"vscode","content":" layout: post title: \"vscode\" date: 2022 8 12 15:39:08 +0800 tags: 嵌入式 原子Linux # vscode ## 安装的插件 + C/C++ + C/C++ Snippets : C/C++ 重用代码块 + C/C++ Advanced Lint: 静态检测 + Code Runner : 代码运行 + Include Autocomplete : 头文件自动包含 + Rainbow Brackets : 彩色花括号 + One Dark Pro : 主题 + GBKtoUTF8 + Chinese (Simplified) (简体中文) Language Pack for Visual St + vscode icons : 图标显示 + compareit 文件比较 + DeviceTree : 设备树语法 Ctrl+ shift+p: configure Display Language 更改语言的设置"},"/note/Linux/原子Linux/2022-8-23-启动流程.html":{"title":"启动流程","content":" layout: post title: \"启动流程\" date: 2022 8 23 15:39:08 +0800 tags: 嵌入式 原子Linux # 启动流程 ## u boot.lds 连接的首地址是_start, 最开始的是中断向量表, 根据不容的代码获取开始地址以及结束地址的变量名, 记录代码段的长度, 然后是rel段 ### 启动 + 把处理器设置为SVC模式, 关闭FIQ和IRQ + 之后对中断向量表进行重定位 + 初始化CP15"},"/note/Linux/原子Linux/2022-9-4-串口.html":{"title":"串口","content":" layout: post title: \"串口\" date: 2022 9 4 15:39:08 +0800 tags: 嵌入式 原子Linux # 串口 我们要做的就是在文件中修改设备树, 在启动的时候uboot设置为使用串口ttymxc0, 就是6ull串口一, 我们真正要做的就是在设备树中添加所要使用的串口节点信息。当系统启动以后串口驱动和设备匹配成功，相应的串口就会被驱动起来，生成/dev/ttymxcX(X 0....n)文件 在编写的时候主要实现的是uart_driver结构体 ```c struct uart_driver { \tstruct module\t\t*owner; \tconst char\t\t*driver_name; \tconst char\t\t*dev_name; \tint\t\t\t major; \tint\t\t\t minor; \tint\t\t\t nr; \tstruct console\t\t*cons; \t/* \t * these are private; the low level driver should not \t * touch these; they should be initialised to NULL \t */ \tstruct uart_state\t*state; \tstruct tty_driver\t*tty_driver; }; ``` > 需要驱动编写人员实现注册 另一个就是uart_port表示一个具体的port，uart_port定义在include/linux/serial_core.h文件, 用于描述一个具体的串口端口 每个具体的UART都有一个uart_port, 使用函数uart_add_one_port向函数添加一个端口, uart_remove_one_port卸载端口, 这个里面有一个uart_ops包含所有的操作函数, 这个结构体办函了针对结构体所有的操作 驱动文件在driver/tty/serial/imx.c文件中 通过usrt_driver的dev_name决定挂载设备的名字, major设置主设备号207, 还有串口个数等的处理 之后就是uart_port处理, 是用自己定义的结构体imx_port, 里面包含了uart_port 串口处理函数imx_rxint中断处理函数接收到数据以后使用函数tty_insert_flip_char把它放到tty里面 ## 实际使用 主要就是修改设备树, 使能对应的串口 默认情况下使能了两个串口, 使能的是uart1和2, 实际上使用的1连接电脑 ```c &uart3 { \tpinctrl names \"default\"; \tpinctrl 0 <&pinctrl_uart3>; \tstatus \"okay\"; }; ``` ## 测试 移植minicom 要进行库的移植 linux下的软件移植基本就是自己编译源码, 首先进行配置, 然后编译 1. 执行文件.configure ```shell jiao@jiao virtual machine:~/linux/tool/ncurses 6.0$ ./configure prefix /home/jiao/linux/tool/ncurses host arm linux gnueabihf target arm linux gnueabihf with shared without profile disable stripping without progs with manpages without tests ``` > 第一个参数设置输出的文件, 不设置的话就是默认安装位置, 会替代ubuntu的文件 2. make 3. make install 3. 把得到的文件放到/usr下的对应的文件夹除了bin 3. 同样的方法编译minicom ```c jiao@jiao virtual machine:~/linux/tool/minicom 2.7.1$ ./configure CC arm linux gnueabihf gcc prefix /home/jiao/linux/tool/minicom host arm linux gnueabihf CPPFLAGS I/home/jiao/linux/tool/ncurses/include LDFLAGS L/home/jiao/linux/tool/ncurses/lib enable cfg dir /etc/minicon ``` 6. make 7. make install 8. bin文件复制到/usr/bin 9. 设置文件/etc/passwd加入`root:x:0:0:root:/root:/bin/sh` 10. 在文件/etc/profile加入 ``` #!/bin/bash LD_LIBRARY_PATH /lib:/usr/lib:$LD_LIBRARY_PATH export LD_LIBRARY_PATH export TERM vt100 export TERMINFO /usr/share/terminfo ``` 11. minicom s 启动"},"/note/Linux/原子Linux/2022-8-26-linux点灯.html":{"title":"Linux点灯","content":" layout: post title: \"Linux点灯\" date: 2022 8 26 15:39:08 +0800 tags: 嵌入式 原子Linux # Linux点灯 Linux也可以直接操作寄存器, 但是很麻烦, 不能直接对寄存器的物理地址进行操作, 因为Linux会使用MMU进行操作, 完成虚拟空间到物理空间的映射, 还有进行内存保护, 对于32位的寄存器可以映射的地址是4GB空间 在Linux中进行的都是虚拟的地址, 在对物理地址进行操作之前, 需要先得到物理地址对应的虚拟地址, 开启MMU以后就需要使用ioremap函数, 定义在arch/arm/linux/asm/io.h文件之中, 第一个参数是物理地址起始地址, 第二个是内存的长度 在使用后需要使用函数进行释放, iounmap, 只有一个参数, 是首地址, 返回的 ## 流程 初始化时钟, 初始化复用, 电气属性 在输入输出的时候, 有专门的操作函数 readb(地址) readw read 读取参数 writeb(值, 地址) writew writel 写操作 ## 缺点 使用register_chrdev,, 浪费了很多的次设备号, 需要手动进行设置设备号 手动创建节点 ## 新版实现方法 + 设备号的注册 `alloc_chrdev_region`: 自动分配设备号, 第一个参数, 返回的设备号, 为指针, 第二个参数基础的次设备号, 第三个次设备号的个数, 第四个是名字 `unregister_chrdev_region`: 卸载驱动的时候使用释放之前申请的设备号, 第一个参数, 起始设备号, 第二个参数, 数值的大小 `register_chrdev_region`: 指定某一个设备号, 如果指定某一个设备号就是用这个函数, 第一个参数设备号, 一般是主设备号, 使用MKDEV构建完整的, 第二个参数多少个设备号, 第三个是名字 > 实际的驱动编写有两种方式, 给定了没有给定两种, 释放的时候使用同一个函数进行 + 新的字符设备注册 ```C struct cdev { \tstruct kobject kobj; \tstruct module *owner; \tconst struct file_operations *ops; \tstruct list_head list; \tdev_t dev; \tunsigned int count; }; ``` 表示字符设备, 两个重要的成员变量：ops和dev，这两个就是字符设备文件操作函数集合file_operations以及设备号dev_t。 之后使用`cdev_init`函数进行初始化, 有两个参数, 第一个是cdev, 第二个是file_operations, 都是指针 初始化之后使用`cdev_add`添加到内核, 第一个参数, cdev指针, 第二个参数设备号, 第三个是个数 删除使用`cdev_del`: 进行删除, 一个参数cdev指针 > 实际上就是对之前使用的函数进行的一次拆解 ## 自动创建设备节点 `ndev`机制, 2.6内核引入, 替换`devfs`, 提供热插拔管理, 在创建的时候自动创建/dev/xx, busy会创建一个`ndev`的简化版本, `mdev`, 一般在嵌入式Linux中使用 ``` 在文件中 /lib/modules/4.1.15 # vi /etc/init.d/rcS 加入 echo /sbin/mdev > /proc/sys/kernel/hotplug ``` + 创建类 在`include/linux/device.h`有一个宏定义`class_create`有两个参数, owner和name, 返回一个struct class类型的指针 ```C newcharled.class class_create(THIS_MODULE, NEWCHARLCD_NAME); if(IS_ERR(newcharled.class)) return PTR_ERR(newcharled.class); ``` IS_ERR用来对指针进行检查 > 这个类存放于sysfs下面，一旦创建好了这个类，再调用device_create(…)函数来在/dev目录下创建相应的设备节点。这样，加载模块的时候，用户空间中的udev会自动响应device_create(…)函数，去/sysfs下寻找对应的类从而创建设备节点。 + 删除一个类 ```C void class_destroy(struct class *cls) ``` + 创建好一个类之后还需要在类下面创建设备 `device_creat`函数, 参数一是class, 使用的类指针, 参数二是父设备, 一般为NULL, 参数三设备号, 参数四, 可能会用的参数一般NULL, , 参数五, 设备名, 返回值是struct device + 删除一个设备 `device_destroy`: 参数是设备struct class以及设备号 ## 文件是有数据 在使用结构体进行描述设备变量的时候 是一个void类型的指针 一般是在open的时候设置私有的数据, ```C static int newcharled_open(struct inode *inode, struct file *filp) { filp >private_data &newcharled; return 0; } ``` 在使用的时候首先进行提取 ```C static int newcharled_realse(struct inode *inode, struct file *filp) { struct newcharled_dev *dev (struct newcharled_dev*)filp >private_data; return 0; } ``` ## 出现错误 一般会使用goto, 在函数return 0之后定义标签进行处理, 一般用于处理申请的资源内存等"},"/note/Linux/原子Linux/2022-8-23-Linux内核.html":{"title":"Linux内核","content":" layout: post title: \"Linux内核\" date: 2022 8 23 15:39:08 +0800 tags: 嵌入式 原子Linux # Linux内核 默认配置文件保存在arch/arm/configs文件下 ``` /bin/sh: 1: lzop: not found arch/arm/boot/compressed/Makefile:180: recipe for target 'arch/arm/boot/compressed/piggy.lzo' failed make[2]: *** [arch/arm/boot/compressed/piggy.lzo] Error 1 make[2]: *** 正在等待未完成的任务.... CC arch/arm/boot/compressed/misc.o arch/arm/boot/Makefile:52: recipe for target 'arch/arm/boot/compressed/vmlinux' failed make[1]: *** [arch/arm/boot/compressed/vmlinux] Error 2 arch/arm/Makefile:316: recipe for target 'zImage' failed make: *** [zImage] Error 2 make: *** 正在等待未完成的任务.... ``` 出现这个安装lzop zImage存放在 ,./arch/arm/boot文件夹, 设备树存放在./arch/arm/boot/dts文件夹 编译单个的dts文件, 直接在顶层目录make对应的.dtb文件就行了 ## 来源 内核官方, www.kernel.org, 有各个额版本的 NXP会挑选一个重点维护其中一个, 相当于官方的BSP或者说SDK供用户使用 正点原子使用NXP的Linux添加修改过的内核给用户时候用, 讲解的是NXP的内核 ## 目录分析 + arch: 架构相关zImage存放在/arch/arm/boot文件夹, 设备树存放在./arch/arm/boot/dts文件夹 + bllock块设备相关, emmc等 + crypto加密相关 + Documentation:文档相关目录, 最常用的是devicetree/bindings这个目录下的描述设备树绑定的信息 + firmeare: 固件相关的目录 + fs: 文件系统相关 + include: 头文件 + init: 初始化相关 + ipc: 进程之间通信 + kernel: 内核相关 + lib: 库相关 + mm: 内存管理 + net: 网络相关 + samples: 例程 + scripts: 脚本 + security: 安全相关 + sound: 音频相关 + tools: 工具 + urs: + virt: 虚拟化 生成的vmlinux, Image, zImage, uImage区别 > vmlinux生成的最初的文件, 没有压缩, 很大 > Image内核镜像文件, 取消掉一些符号表之类的信息 > zImage: 使用gzip压缩的文件 > uImage: 老板的uboot专用的镜像, 多加了一个头部 ## 启动流程 ## 移植 对已ing的配置文件存放在arch/arm/configs 直接移植官方的文件没有根文件系统, 发现可以正常启动 ### 添加开发板 就是添加一个默认的配置文件, 一个设备树 在移植之前要保证可以正常的启动, , 使用现成的文件系统, 设置bootcmd和bootargs, Bootcmd通过网络启动 在运行的时候会使用bootcmd中的命令自动启动 ``` > setenv bootargs 'console ttymxc0,115200 root /dev/mmcblk1p2 rootwait rw' ``` > 设置串口以及默认的根文件 把usdhc2的内容更该为emmc版本 ### 修改主频 使用`root@ATK IMX6U:~# cat /proc/cpuinfo`可以查看cpu信息, BogoMIPS是Linux系统中衡量处理器运行速度的一个“尺子”，处理器性能越强，主频越高，BogoMIPS值就越大。BogoMIPS只是粗略的计算CPU性能，并不十分准确。但是我们可以通过BogoMIPS值来大致的判断当前处理器的性能。 进入到目录/sys/bus/cpu/devices/cpu0/cpufreq中，此目录下会有很多文件 **cpuinfo_cur_freq**：当前cpu工作频率，从CPU寄存器读取到的工作频率。 **cpuinfo_max_freq**：处理器所能运行的最高工作频率(单位: KHz）。 **cpuinfo_min_freq**：处理器所能运行的最低工作频率(单位: KHz）。 **cpuinfo_transition_latency**：处理器切换频率所需要的时间(单位:ns)。 **scaling_available_frequencies**：处理器支持的主频率列表(单位: KHz）。 **scaling_available_governors**：当前内核中支持的所有governor(调频)类型 **scaling_cur_freq**：保存着cpufreq模块缓存的当前CPU频率，不会对CPU硬件寄存器进行检查。 **scaling_driver**：该文件保存当前CPU所使用的调频驱动。 **scaling_governor：governor**(调频)策略，Linux内核一共有5中调频策略， ①、Performance，最高性能，直接用最高频率，不考虑耗电。 ②、Interactive，一开始直接用最高频率，然后根据CPU负载慢慢降低。 ③、Powersave，省电模式，通常以最低频率运行，系统性能会受影响，一般不会用这个！ ④、Userspace，可以在用户空间手动调节频率。 ⑤、Ondemand，定时检查负载，然后根据负载来调节频率。负载低的时候降低CPU频率，这样省电，负载高的时候提高CPU频率，增加性能。**scaling_max_freq：governor**(调频)可以调节的最高频率。 **cpuinfo_min_freq：governor**(调频)可以调节的最低频率。 可以在arch/arm/configs文件中文件中, CONFIGS_CPU_xxx设置各种模式的使用, 可以在图形界面进行配置, 一般把cpu的模式配置为ondemand模式, 在图形界面CPU Power Mangagement >CPU Frequency scaling > Default CPUFreq governor (ondemand) >进行设置"},"/note/Linux/原子Linux/2022-9-6-CAN协议.html":{"title":"CAN","content":" layout: post title: \"CAN\" date: 2022 9 6 15:39:08 +0800 tags: 嵌入式 原子Linux # CAN ## 协议特点 最大的速率只有125K速率 多主控制, 空闲的时候所有的机器都可以发送消息, 两个以上同时开始比较优先级 系统的柔性, 没有地址 有错误检测 ## 电气属性 有两根差分线, 有显性电平, 隐性电平, 显性的电平表0, CAN_H比CAN_L的电平,H为3.5V, L为1.5V, 都为2.5V表示1 两端连接一个120Ω ## 协议 有五种帧格式 + 数据帧: 用于CAN节点之间进行数据传输的帧 + 遥控帧: 用于接收单元向具有相同ID 的发送单元请求数据的帧 + 错误帧: 用于当检测出错误时向其它单元通知错误的帧 + 过载帧: 用于接收单元通知其尚未做好接收准备的帧 + 间隔帧: 用于将数据帧及遥控帧与前面的帧分离开来的帧 数据帧由7段组成：①、帧起始，表示数据帧开始的段。②、仲裁段，表示该帧优先级的段。③、控制段，表示数据的字节数及保留位的段。④、数据段，数据的内容，一帧可发送0~8个字节的数据。⑤、CRC段，检查帧的传输错误的段。⑥、ACK段，表示确认正常接收的段。⑦、帧结束，表示数据帧结束的段。 1. 帧起始很简单，标准格式和扩展格式都是由一个位的显性电平0来表示帧起始 ![QQ图片20220906213807](https://blog 1308522872.cos.ap beijing.myqcloud.com/jhy/202301010003584.png) 2. 表示帧优先级, 标准格式的ID为11位，发送顺序是从ID10到ID0，最高7位ID10~ID4不能全为隐性(1), 扩展格式的ID为29位，基本ID从ID28到ID18，扩展ID由ID17到ID0，基本ID与标准格式一样，禁止最高7位都为隐性, RTR位远程请求位, 显性为数据帧, 隐性为远程帧 3. 控制段由6个位构成，表示数据段的字节数，标准格式和扩展格式的控制段略有不同, r1和r0为保留位，保留位必须以显性电平发送。DLC为数据长度，高位在前，DLC段有效值范围为0~8, 单位是字节, 最大64bit ![QQ图片20220906214011](https://blog 1308522872.cos.ap beijing.myqcloud.com/jhy/202301010003585.png) 4. 数据段也就是帧的有效数据，标准格式和扩展格式相同，可以包含0~8个字节的数据，从最高位(MSB)开始发送 5. CRC段保存CRC校准值，用于检查帧传输错误，标准格式和扩展格式相同, CRC段由15位的CRC值与1位的CRC界定符组成。CRC值的计算范围包括：帧起始、仲裁段、控制段、数据段，接收方以同样的算法进行计算，然后用计算得到的CRC值与此CRC段进行比较，如果不一致的话就会报错 ![QQ图片20220906214857](https://blog 1308522872.cos.ap beijing.myqcloud.com/jhy/202301010003586.png) 6. ACK段用来确认接收是否正常，标准格式和扩展格式相同, 发送单元的ACK，发送2个隐性位，而接收到正确消息的单元在ACK槽（ACK Slot）发送显性位，通知发送单元正常接收结束，这个过程叫发送ACK/返回ACK。发送ACK 的是所有接收单元中接收到正常消息的单元，所谓正常消息是指不含填充错误、格式错误、CRC 错误的消息，这些接收单元既不处于总线关闭态也不处于休眠态的所有接收单元中 7. 最后就是帧结束段, 7位隐性位构成。 ## IMX6U的CAN"},"/note/Linux/原子Linux/2022-9-2-Linux自带的led.html":{"title":"Linux自带的led驱动","content":" layout: post title: \"Linux自带的led驱动\" date: 2022 9 2 15:39:08 +0800 tags: 嵌入式 原子Linux # Linux自带的led驱动 一般自带的驱动都是需要使用图形界面进行配置 图形界面 >Device Driver >LED Support > LED Support for GPIO connected LEDs 使能驱动之后在在文件.config中存在`CONFIG_LEDS_GPIO y`, 会把驱动文件编译到内核之中 ## 驱动分析 使用标准的platform driver ```c module_platform_driver(gpio_led_driver); ``` > 使用一个宏完成函数的注册, 代替module_init和module_exit函数, 根据参数生成两个函数, 分别调用platform_driver_register, 和platform_driver_unregister, 使用宏定义完成之前写的函数 匹配的设备`{ .compatible \"gpio leds\", }`, 驱动设备匹配之后会执行probe函数, 根据有没有设备树进行处理 ## 使用 首先把驱动编译进内核里面, 根据文档设备树里面添加节点的信息 如果没有设备树, 需要使用platform_device_register向总线注册一个设备, 有设备树的话, 直接修改设备树, 添加对应的节点, 文档的目录在`./document/device tree/bindings/leds/leds gpio.txt`,"},"/note/Linux/原子Linux/2022-9-2-LCD屏幕.html":{"title":"LCD","content":" layout: post title: \"LCD\" date: 2022 9 2 15:39:08 +0800 tags: 嵌入式 原子Linux # LCD屏幕 ## Framebuffer设备 RGBLCD屏幕 framebuffer为Linux显示模拟出来的显存, 允许程序直接对显存进行读写, 应用程序操作显存的机制 系统会虚拟出来fbX这样的设备, 对设备进行操作即可 ```c lcdif: lcdif@021c8000 { compatible \"fsl,imx6ul lcdif\", \"fsl,imx28 lcdif\"; reg <0x021c8000 0x4000>; interrupts <GIC_SPI 5 IRQ_TYPE_LEVEL_HIGH>; clocks <&clks IMX6UL_CLK_LCDIF_PIX>, <&clks IMX6UL_CLK_LCDIF_APB>, <&clks IMX6UL_CLK_DUMMY>; clock names \"pix\", \"axi\", \"disp_axi\"; status \"disabled\"; }; ``` > 驱动文件为mxsfb.c文件, 为paltfoem驱动框架, framebuffer在内核中的表现就是fb_info结构体, 屏幕驱动重点就是初始化fb_info中的各种变量, 之后通过register_framebuffer向内核注册实现的结构体 卸载的时候调用unregister_framebuffer卸载之前注册的结构体 ## 实现 驱动lcd正常可以配置显示一个企鹅logo, 可以在图形界面配置 Device Drivers >Graphics support >logo ### 设备树设置 引脚和官方的一样, 但是需要改电气属性, 97 >49修改驱动能力 ```c &lcdif { \tpinctrl names \"default\"; \tpinctrl 0 <&pinctrl_lcdif_dat \t\t &pinctrl_lcdif_ctrl>; \tdisplay <&display0>; \tstatus \"okay\"; \tdisplay0: display { \t\tbits per pixel <32>; \t\tbus width <24>; \t\tdisplay timings { \t\t\tnative mode <&timing0>; \t\t\ttiming0: timing0 { \t\t\tclock frequency <51200000>; \t\t\thactive <1024>; \t\t\tvactive <600>; \t\t\thfront porch <160>; \t\t\thback porch <140>; \t\t\thsync len <20>; \t\t\tvback porch <20>; \t\t\tvfront porch <12>; \t\t\tvsync len <3>; \t\t\thsync active <0>; \t\t\tvsync active <0>; \t\t\tde active <1>; \t\t\tpixelclk active <0>; \t\t\t}; \t\t}; \t}; }; ``` ### 实现显示器作为输出 修改文件/etc/inittab ``` #etc/inittab ::sysinit:/etc/init.d/rcS console::askfirst: /bin/sh tty1::askfirst: /bin/sh ::restart:/sbin/init ::ctrlaltdel:/sbin/reboot ::shutdown:/bin/umount a r ::shutdown:/sbin/swapoff a ``` > tty指的是当前终端, /dev/tty0代表当前虚拟控制台，而/dev/tty1等代表第一个虚拟控制台, tty0, tty1,tty2等是虚拟的“终端”，它有输入、输出功能 uboot ```c > print bootargs bootargs console ttymxc0,115200 root /dev/mmcblk1p2 rootwait rw > setenv bootargs 'console tty1 console ttymxc0,115200 root /dev/mmcblk1p2 rootwait rw' > saveenv Saving Environment to MMC... Writing to MMC(1)... done > boot ``` > ttymxc0是NXP公司的串口节点 ## 设置 ### 背光 ``` /sys/devices/platform/backlight/backlight/backlight ``` ## 自动息屏 drivers/tty/vt/vt.c这个文件，在此文件中找到blankinterval变量, 在181行"},"/note/Linux/原子Linux/2022-8-29-pinclt和gpio.html":{"title":"pinctl和gpio子系统","content":" layout: post title: \"pinctl和gpio子系统\" date: 2022 8 29 15:39:08 +0800 tags: 嵌入式 原子Linux # pinctl和gpio子系统 在开发的时候不用直接操作寄存器, Linux提供了gpio操作的方法 ## pinctl子系统 在使用时候的, 之前要设置PIN的复用和电气属性, 配置GPIO Linux使用pinctl子系统进行管理, 设置PIN的电气属性和复用 + 主要功能 从设备树获取pin的信息, 根据设置进行设置复用, 设置各种属性, 厂商已经写好了, 对于用户来说就是在设备树中添加对应的配置信息 + IOMUX SNVS控制器 ```c iomuxc_snvs: iomuxc snvs@02290000 { compatible \"fsl,imx6ull iomuxc snvs\"; reg <0x02290000 0x10000>; }; ``` + IOMUXC控制器 ```c iomuxc: iomuxc@020e0000 { compatible \"fsl,imx6ul iomuxc\"; reg <0x020e0000 0x4000>; }; ``` > 在dts文件中进行追加, 根据设备的类型创建对应的子节点, , 然后把用到的io放到对应的节点下面 > > ```c > pinctrl_csi1: csi1grp { > fsl,pins < > MX6UL_PAD_CSI_MCLK__CSI_MCLK\t\t0x1b088 > MX6UL_PAD_CSI_PIXCLK__CSI_PIXCLK\t0x1b088 > MX6UL_PAD_CSI_VSYNC__CSI_VSYNC\t\t0x1b088 > MX6UL_PAD_CSI_HSYNC__CSI_HSYNC\t\t0x1b088 > ... > >; > }; > ``` > 后面的数字就是电气属性 **如何添加一个PIN** 前面的是一个宏, 定义在imx6ull pinfunc.h, ```c #define MX6UL_PAD_CSI_MCLK__CSI_MCLK 0x01D4 0x0460 0x0000 0x0 0x0 ``` > <mux_reg conf_reg input_reg mux_mode input_val>, 第一个是设置IO复用的寄存器, 是对于父节点的偏移, 第四个是第几个复用, 第二个是电气属性寄存器, 第三个偏移是0表示没有这个寄存器, 最后一个值是写入这个寄存器的 每种功能对应一个宏, 名字前面是IO名字, 后面是复用的功能 + GPR控制器 ```c gpr: iomuxc gpr@020e4000 { compatible \"fsl,imx6ul iomuxc gpr\", \"fsl,imx6q iomuxc gpr\", \"syscon\"; reg <0x020e4000 0x4000>; }; ``` + 如何找到对应的驱动 不同的芯片由半导体厂商写出来不同的驱动, 通过compatible属性进行匹配, 这个属性是一个字符串列表, 当设备树的节点的属性和驱动里面的匹配的时候就代表两者匹配了, 根据这个可以找到pinctrl imx6ull文件, 这个文件就是6ull的pinctl文件 当驱动设备匹配的时候probe函数执行, ## gpio子系统 用来对gpio的操作, 复用为GPIO的时候使用这个 ``` &usdhc1 { \tpinctrl names \"default\", \"state_100mhz\", \"state_200mhz\"; \tpinctrl 0 <&pinctrl_usdhc1>; \tpinctrl 1 <&pinctrl_usdhc1_100mhz>; \tpinctrl 2 <&pinctrl_usdhc1_200mhz>; \tcd gpios <&gpio1 19 GPIO_ACTIVE_LOW>; \tkeep power in suspend; \tenable sdio wakeup; \tvmmc supply <&reg_sd1_vmmc>; \tstatus \"okay\"; }; ``` **pinctrl 0,1,2**: 设置几种不同的IO属性, 主要是电气属性不同, 是pinctl的参数设置 + **cd gpios <&gpio1 19 GPIO_ACTIVE_LOW>;** 重点 定义了一个属性, 重点是后面的值, 比如此处使用GPIO1_19, 对应的结构体 ``` gpio1: gpio@0209c000 { compatible \"fsl,imx6ul gpio\", \"fsl,imx35 gpio\"; reg <0x0209c000 0x4000>; interrupts <GIC_SPI 66 IRQ_TYPE_LEVEL_HIGH>, <GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH>; gpio controller; #gpio cells <2>; interrupt controller; #interrupt cells <2>; }; ``` compatible: \"fsl, <soc> gpio\" reg: 寄存器范围 gpio controller: 这是一个gpio控制器 #gpio cells <2>;: 必须是2, 第一个是gpio的编号, 第二个是gpio的极性, 高电平为0, 低电平为1 **cd gpios <&gpio1 19 GPIO_ACTIVE_LOW>;** 表示引用gpio1, 之后就是两个cell ### 函数 ```c int gpio_request(unsigned gpio, const char *label) ``` > 申请一个GPIO管脚，在使用一个GPIO之前一定要使用gpio_request进行申请, gpio, 要申请的gpio编号, label设置gpio的名字, 主要是用来检测有没有被别的设备使用, 正常返回0 ```c void gpio_free(unsigned gpio) ``` > 释放一个gpio的标号 ```c int gpio_direction_input(unsigned gpio) ``` > 设置gpio为输入 ```c int gpio_direction_output(unsigned gpio, int value) ``` > 设置某个GPIO为输出，并且设置默认输出值, 正常的时候返回0 ```c #define gpio_get_value __gpio_get_value int __gpio_get_value(unsigned gpio) ``` > 获得某一个gpio的值 ```c #define gpio_set_value __gpio_set_valuevoid __gpio_set_value(unsigned gpio, int value) ``` > 设置gpio的值 ```c int devm_gpio_request_one(struct device *dev, unsigned gpio, \t\t\t unsigned long flags, const char *label) ``` > 一次性完成设置, 参数一, 调用的dev设备, 第二个参数, gpio标号, 第三个参数, 以GPIOF_开头的标志, 最后一个名字 ### 相关的of函数 ```c int of_gpio_named_count(struct device_node *np,const char *propname) ``` > 获取设备树某个属性里面定义了几个GPIO信息, 空的GPIO信息也会被统, propname：要统计的GPIO属性 ```c int of_gpio_count(struct device_node *np) ``` > 统计任意属性的GPIO信息 ```c int of_get_named_gpio(struct device_node *np,const char *propname, int index) ``` > 类似<&gpio5 7 GPIO_ACTIVE_LOW>的属性信息转换为对应的GPIO编号, np：设备节点。propname：包含要获取GPIO信息的属性名, index：GPIO索引，因为一个属性里面可能包含多个GPIO，此参数指定要获取哪个GPIO的编号，如果只有一个GPIO信息的话此参数为0 ### 实际过程 首先获取到gpio所处的节点of_find_node_by_path 之后获取GPIO编号, of_get_named_gpio函数返回值就是编号 之后进行请求gpio_request 使用, 设置输入输出, 之后进行读写 使用完成后释放gpio_free ## gpio驱动 ### gpio_lib 两部分, 给原厂编写GPIO底层驱动, 给驱动力开发人员的操作函数 ### gpio驱动 在drivers/gpio目录下, gpio xxx.c文件为具体的的的gpio驱动, gpiolib是Linux内核自己写的 gpiolib legacy.c文件 ## 失败 申请的时候失败大部分原因是被其他的外设占用了, 检查设备树 一 检查复用设置 二 gpio使用 ## 总结 添加pinctrl相关信息 检查当前设备的IO使用 添加设备节点, 在节创建属性, 描述使用的gpio 编写驱动 ## 蜂鸣器 注意使用的引脚, 使用MX6ULL_PAD_SNVS_TAMPER1__GPIO5_IO01, 6UL和6ULL的引脚不同"},"/note/Linux/原子Linux/2022-8-27-设备树.html":{"title":"设备树","content":" layout: post title: \"设备树\" date: 2022 8 27 15:39:08 +0800 tags: 嵌入式 原子Linux # 设备树 Linux在ARM中使用设备树 是用一个树形的结构进行描述各种设备, 让内核可以解释分析, 使用单独的文件进行描述 在内核中arch/arm中有大量的`mach`开头的文件, 这些是不同的机器, plat开头的代表不同的平台 使用大量的结构体, 在裸机进行的时候直接写死了, 在.c文件中, 最终导致大量的重复内核无用的信息, 不能编译到Linux内核之中 文件的扩展名为`.dts`, 相当于.c, 就是DTC的源码文件, DTC相当于gcc编译器, 生成.deb文件 我们使用的时候使用`make dtbs`把所有的编译, 编译指定的`make 文件名.dtb` 也有头文件`.dtsi`文件 ## DTS语法 有一个斜杠开始, 作为根, 可以使用追加 ``` /dts v1/; ``` 版本1的`dts`文件, 是设备数的开头 ``` \tmodel \"Freescale i.MX6SLL EVK Board\"; \tcompatible \"fsl,imx6sll evk\", \"fsl,imx6sll\"; ``` + 根节点相关的属性, 属性名+属性值, 一般都`dtsi`文件是由芯片厂商提供, 从根节点开始描述设备信息 + 根节点外有一些&cpu0 之类是追加 + 使用#include进行引进的dtsi文件都是使用同一个根节点 + 注释使用的跟C语言一样 + 使用同一个名字的节点会加到一起 + 同一个节点同名的属性会进行覆盖 + 节点的名字`node name@unit address`, 节点名字有数字, 字母, 逗号, +, , 下划线,句号, 大多数使用小写字母, 之后@单元地址, 一般都是外设的起始地址, 有时候可能为I2C设备地址等 + 还有使用`label:node name@unit address`, label方便访问节点, 直接通过&label进行访问 ## 设备树在Linux中的体现 系统启动以后可以在根文件系统中看到设备树节点的信息, 在目录/proc/device tree目录 描述外设信息的 描述6ull芯片的内部外设寄存器节点, 在soc的aips2中存在I2C外设 内核启动的时候回解析设备树 ## 特殊的节点 chosen:为了uboot向Linux传递参数, 传递bootargs, 是boot的fdt_chosen查找节点, 添加属性 aliases(别名): 在实际的使用的时候很少, 是为了方便访问节点, 最后的作用就是为了在/dev下面生成 ## 属性 不同的设备属性不同, 以及根据驱动进行描述 ### 标准属性 + compatible: 兼容的, 每一个节点都有, 是一个字符串, 格式为`\"manufacturer,model\"`, 第一个是厂商, 第二个是设备名, 可以拥有多个 + model: 描述模块的信息 + status: 描述状态, \"okey\"可用, \"disable\"不可操作, \"fail\"不可操作, 检测到错误, 也不大可能可操作, \"fail sss\", 同上sss为检测到的错误 + #address cells和#size cells, 用于描述地址属性, 分别描述reg的两个参数的长度, 单位为32位, 都是父节点描述子节点 ``` #address cells <1>; #size cells <0>; ``` ``` reg <address1 length1 address2 length2 address3 length3......> ``` + reg: 大多数是描述一段内存 + ranges属性: `(child bus address,parent bus address,length)`, 子地址, 父地址, 地址空间长度, 是一个地址映射转换表, 在arm很少使用 + name属性, 已经被弃用了 + device_type: 描述设备的FCode, 弃用 ### 特殊的属性 根节点下compatible用来检测内核是不是支持这个平台 使用设备树之前使用机器ID进行控制, 文件`include/generated/mach types.h`中，此文件定义了大量的machine id, 使用MACHINE_START和MACHINE_END 在include/generated/mach types.h定义了支持的ID 使用之后用根节点下的这个属性, DT_MACHINE_START。DT_MACHINE_START定义在文件`arch/arm/include/asm/mach/arch.h`里面, 但是都是使用同一个结构体, 对应内核中的文件`arch/arm/mach imx/mach imx6ul.c`中的属性就可以兼容 ### 绑定信息文档 有一些设备描述有特定的描述方式 `document/devicetree/bindings/`文件夹下有多种描述, 只是一个参考, 不完善, 找芯片的厂家找 ## OF操作函数 驱动获取设备树节点信息 在驱动中使用OF函数获取设备树的内容, `include/linux/of.h`文件中 + 设备是以节点的形式挂载到设备树上面的, 使用结构体描述一个节点 ```c struct device_node { \tconst char *name; \tconst char *type; \tphandle phandle; \tconst char *full_name; \tstruct fwnode_handle fwnode; \tstruct\tproperty *properties; \tstruct\tproperty *deadprops;\t/* removed properties */ \tstruct\tdevice_node *parent; \tstruct\tdevice_node *child; \tstruct\tdevice_node *sibling; \tstruct\tkobject kobj; \tunsigned long _flags; \tvoid\t*data; #if defined(CONFIG_SPARC) \tconst char *path_component_name; \tunsigned int unique_id; \tstruct of_irq_controller *irq_trans; #endif }; ``` + 驱动想获取到设备树的内容, 首先要找到节点, 常用的的函数有 ```c extern struct device_node *of_find_node_by_name(struct device_node *from,const char *name); ``` > from: 从哪一个节点开始为NULL就是从根节点开始, name查找的节点的名字 ```c extern struct device_node *of_find_compatible_node(struct device_node *from, const char *type, const char *compat); ``` > 根据device_type和compatible这两个属性, NULL表示忽略 ```c static inline struct device_node *of_find_node_by_path(const char *path) ``` > 通过路径 + 查找父节点子节点 ```c extern struct device_node *of_get_parent(const struct device_node *node); ``` ```c extern struct device_node *of_get_next_child(const struct device_node *node,struct device_node *prev); ``` > 前一个子节点，也就是从哪一个子节点开始迭代的查找下一个子节点。可以设置为NULL，表示从第一个子节点开始 + 提取属性 使用一个结构体来表示属性 ```c struct property { \tchar\t*name;\t//属性的名字 \tint\tlength;\t\t//属性长度 \tvoid\t*value; //属性的值 \tstruct property *next;\t//下一个属性 \tunsigned long _flags; \tunsigned int unique_id; \tstruct bin_attribute attr; }; ``` + 查找属性的函数 ```c extern struct property *of_find_property(const struct device_node *np, const char *name, int *lenp); ``` > 查找结构体, 参数一, 节点, 参数二, 节点的名字, 第三个参数的长度, 一般为NULL, 返回值为结构体 ```c extern int of_property_count_elems_of_size(const struct device_node *np, const char *propname, int elem_size); ``` > 获取属性中元素的数量，比如reg属性值是一个数组，那么使用此函数可以获取到这个数组的大小, np: 设备节点。proname：需要统计元素数量的属性名字。elem_size: 元素长度, 一般都是用sizeof(u32), 返回值为结果 ```c extern int of_property_read_u32_index(const struct device_node *np, const char *propname, u32 index, u32 *out_value); ``` > 从属性中获取指定标号的u32类型数据值, np: 设备节点。proname: 要读取的属性名字。index: 要读取的值标号。out_value: 读取到的值, 返回值是是否读取成功 ``` extern int of_property_read_u8_array(const struct device_node *np,const char *propname, u8 *out_values, size_t sz); extern int of_property_read_u16_array(const struct device_node *np,const char *propname, u16 *out_values, size_t sz); extern int of_property_read_u32_array(const struct device_node *np, const char *propname, u32 *out_values,size_t sz); extern int of_property_read_u64(const struct device_node *np, const char *propname, u64 *out_value); ``` > 查找一个数组, 节点, 名字, 返回的数组, 读取的大小 ```c extern int of_property_read_string(struct device_node *np, const char *propname,const char **out_string); ``` > 读取字符串 ```c extern int of_n_addr_cells(struct device_node *np); extern int of_n_size_cells(struct device_node *np); ``` > \\#address cells \\#size cells + 其他的常用的属性 ```c static inline int of_device_is_compatible(const struct device_node *device,const char *name) ``` > 查看节点的compatible属性是否有包含compat指定的字符串，也就是检查设备节点的兼容性 好像没有实现 ```c const __be32 *of_get_address(struct device_node *dev, intindex, u64 *size,unsigned int *flags) ``` > 用于获取地址相关属性，主要是“reg”或者“assigned addresses”属性值 ```c u64 of_translate_address(struct device_node *dev, const __be32 *in_addr) ``` > 负责将从设备树读取到的地址转换为物理地址 ```c void __iomem *of_iomap(struct device_node *np, int index) ``` > 直接内存映射, 直接从节点进行操作, 对象是reg, 每两个是一对, 索引从0开始 ```c kmalloc ``` > 内核申请内存, 参数一大小, 参数二flags为GFP_KERNEL时候正常申请 ``` kfree ``` > 释放"},"/note/Linux/原子Linux/2022-8-12-Makefile书.html":{"title":"和我一起写Makefile","content":" layout: post title: \"和我一起写Makefile\" date: 2022 8 12 15:39:08 +0800 tags: 嵌入式 原子Linux # 和我一起写`Makefile` ## `Makefile`介绍 ### 自动推导 make 看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中 并且 `cc c whatever.c` 也会被推导出来 ```makefile main.o : main.c defs.h cc c main.c # 使用自动化推导后 main.o : defs.h ``` ### 收拢 ```makefile objects main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.o $(objects) : defs.h kbd.o command.o files.o : command.h display.o insert.o search.o files.o : buffer.h ``` 定义文件关联文件进行收拢 ## `Makefile`综述 ### `Makefile`中有什么 + 显式规则: 如何生成一个或者多个文件 + 隐晦规则: 使用自动推导, 简略书写 + 变量的定义: 变量一般都是字符串, 有点类似于宏 + 文件指示: 包括三部分, 引用其他的`Makefile`, 另一种是指定有效的部分, 还有多行命令 + 注释: 只有单行注释, # ### 文件名 默认的情况下，make 命令会在当前目录下按顺序找寻文件名为`“GNUmakefile”、 “makefile”、“Makefile”`的文件 有另外一些 make 只对全小 写的`“makefile”`文件名敏感 你 可 以 使 用 别 的 文 件 名 来 书 写 `Makefile` ， 比 如 ： `“Make.Linux” ， “Make.Solaris”，“Make.AIX”`等，如果要指定特定的` Makefile`，你可以使用 make 的 “ f”和“ file”参数，如`：make f Make.Linux `或 `make file Make.AIX` ### 引用其他的`Makefile` 使用 include 关键字可以把别的 `Makefile` 包含进来 ```makefile include <filename> ``` filename 可以是当前操作系统 Shell 的文件模式（可以保含路径和通配符） 前面可以有一些空字符，但是绝不能是[Tab]键开始 你有这样几个 Makefile：a.mk、b.mk、c.mk，还有一个文件叫` foo.make`，以及一个变变量$(bar)，其包含了 e.mk 和 f.mk ```makefile include foo.make *.mk $(bar) 等价于： include foo.make a.mk b.mk c.mk e.mk f.mk ``` + 如果文件都没有指定绝对路径或是相对路径的话， make 会在当前目录下首先寻找 + 如果 make 执行时，有“ I”或“ include dir”参数，那么 make 就会在这个参数 所指定的目录下去寻找 + 如果目录/include（一般是：`/usr/local/bin` 或`/usr/include`）存在的话， make 也会去找。 如果你想让 make 不理那些无法读取的文件，而继续执行，你可以在 include 前加一个减号“ ” ### 环境变量MAKEFILES make 会把这个变量中的值做一个类 似于 include 的动作。这个变量中的值是其它的 Makefile 这个变量中的值是其它的` Makefile`，用空格分隔 从这个环境变中引入的` Makefile `的“目标”不会起作用，如果环境变量中定义 的文件发现错误，make 也会不理 **建议不要使用这个环境变量** ### make工作方式 1. 读入所有的 `Makefile`。 2. 读入被 include 的其它` Makefile`。 3. 初始化文件中的变量。 4. 推导隐晦规则，并分析所有规则。 5. 为所有的目标文件创建依赖关系链。 6. 根据依赖关系，决定哪些目标要重新生成。 7. 执行生成命令。 make 使用的是拖延战术，如 果变量出现在依赖关系的规则中，那么仅当这条依赖被决定要使用了，变量才会在其内部展 开。 ## 书写规则 第一条规则中的目标将被确立为 最终的目标。如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。make 所完成的也就是这个目标。 ### 规则的语法 ```makefile targets : prerequisites command ... ``` 或者 ```makefile targets : prerequisites ; command command ... ``` > 如果其不与`“target:prerequisites”`在一行，那么，必须以[Tab 键]开头，如果和 prerequisites 在一行，那么可以用分号做为分隔。 如果命令太长，你可以使用反斜框（‘\\’）作为换行符 一般来说，make 会以 UNIX 的标准 Shell，也就是/bin/sh 来执行命令 ### 在规则中使用通配符 make 支持 三各通配符： + * + ? + ... 波浪号（“~”）表示当前用户的$HOME 目录 通配符代替了你一系列的文件，如“*.c”表示所以后缀为 c 的文件。 ```makefile objects *.o ``` > 通符同样可以用在变量中。并不是说[*.o]会展开，不！objects 的值就是\\*.o 如果你要让通配符在变量中 展开，也就是让 objects 的值是所有[.o]的文件名的集合 ```makefile objects : $(wildcard *.o) ``` ### 文件搜索 当 make 需要去找寻文件的依赖关系时，你可以在文件前加上路 径，但最好的方法是把一个路径告诉 make，让 make 在自动去找 `Makefile `文件中的特殊变量“VPATH”就是完成这个功能的，如果没有指明这个变量， make 只会在当前的目录中去找寻依赖文件和目标文件, 目录由“冒号”分隔 ```makefile VPATH src:../headers ``` 另一个设置文件搜索路径的方法是使用 make 的``“vpath”``关键字（注意，它是全小写 的），这不是变量，这是一个 make 的关键字 + `vpath <pattern> <directories>` 为符合模式`<pattern>`的文件指定搜索目录`<direction>` + `vpath <pattern> ` 清除符合模式`<pattern>`的文件的搜索目录 + `vapth` 清除所有已被设置好了的文件搜索目录 `vapth `使用方法中的`<pattern>`需要包含“%”字符。“%”的意思是匹配零或若干字符， 例如，“%.h”表示所有以“.h”结尾的文件。`<directories>`指定了要搜索的文件集，而 则指定了的文件集的搜索的目录。 我们可以连续地使用 `vpath` 语句，以指定不同搜索策略。如果连续的 `vpath` 语句中出现 了相同的`<pattern>`，或是被重复了的`<pattern>`，那么，make 会按照` vpath` 语句的先后顺 序来执行搜索 ### 伪目标 向 make 说明，不管是否有这个文件，这个目标就是“伪 目标”。 伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同 样可以作为“默认目标”，只要将其放在第一个 如果你的 Makefile 需要 一口气生成若干个可执行文件，但你只想简单地敲一个 make 完事，并且，所有的目标文件 都写在一个 Makefile 中，那么你可以使用“伪目标”这个特性 ```makefile all : prog1 prog2 prog3 .PHONY : all prog1 : prog1.o utils.o cc o prog1 prog1.o utils.o ... ``` > 由于伪目标的特性是，总是被执行的，所以其依赖的那三 个目标就总是不如“all”这个目标新。所以，其它三个目标的规则总是会被决议。也就达 到了我们一口气生成多个目标的目的。 目标也可以成为依赖。所以，伪目标同样也 可成为依赖。 ### 多目标 目标可以不止一个，其支持多目标，有可能我们的多个目标同时依赖 于一个文件，并且其生成的命令大体类似。于是我们就能把其合并起来。 ### 静态模式 ``` <targets ...>: <target pattern>: <prereq patterns ...> ``` targets 定义了一系列的目标文件，可以有通配符。是目标的一个集合。 `target parrtern` 是指明了 targets 的模式，也就是的目标集模式。 `prereq parrterns` 是目标的依赖模式，它对 `target parrtern` 形成的模式再进行一次依赖 目标的定义。 ```makefile $(SOBJS) : obj/%.o : %.s \t$(CC) Wall nostdlib c O2 $(INCLUDE) o $@ $< ``` > 这里是从$(SOBJS)中找出所有的符合条件的文件, 然后生成依赖文件 ## 通用模板 ```makefile CROSS_COMPILE \t? arm linux gnueabihf TARGET \t\t\t? ledc CC \t\t\t\t: $(CROSS_COMPILE)gcc LD \t\t\t\t: $(CROSS_COMPILE)ld OBJCOPY \t\t: $(CROSS_COMPILE)objcopy OBJDUMP \t\t: $(CROSS_COMPILE)objdump INCUDIRS\t\t: \timx6u \\ \t\t\t\t\tbsp/clk \\ \t\t\t\t\tbsp/led \\ \t\t\t\t\tbsp/delay \\ \t\t\t\t\tproject SRCDIRS\t\t\t: \tproject\t\\ \t\t\t\t\tbsp/clk \\ \t\t\t\t\tbsp/led \\ \t\t\t\t\tbsp/delay # 给所有的头文件加上 I, 用于在编译的时候添加头文件路径 INCLUDE \t\t: $(patsubst %, I %, $(INCUDIRS)) # 寻找筛选c和s文件,遍历列表, 找出复合条件的文件 SFILES\t\t\t: $(foreach dir, $(SRCDIRS), $(wildcard $(dir)/*.s) ) CFILES\t\t\t: $(foreach dir, $(SRCDIRS), $(wildcard $(dir)/*.c) ) # 保存生成的文件 # 先生成没有路径的文件名 SFILENDIR \t\t: $(notdir $(SFILES)) CFILENDIR \t\t: $(notdir $(CFILES)) # 对生成的中间文件进行添加目录 SOBJS\t\t\t: $(patsubst %, obj/%, $(SFILENDIR:.s .o)) COBJS\t\t\t: $(patsubst %, obj/%, $(CFILENDIR:.c .o)) OBJS\t\t\t: $(SOBJS) $(COBJS) # 指定寻找的路径, 这是系统变量, 找文件的时候会从这些路径寻找 VPATH \t\t\t: $(SRCDIRS) .PHONY: clear $(TARGET).bin : $(OBJS) \t# 生成带有编译信息的文件 \t$(LD) Timx6u.lds o $(TARGET).elf $^ \t# 生成目标文件 \t$(OBJCOPY) O binary S $(TARGET).elf $@ \t# 生成反汇编文件 \t$(OBJDUMP) D m arm $(TARGET).elf > $(TARGET).dis # 这里是用静态模式，第一项是一系列的文件，第二个是目标文件遵守的格式，第三个是依赖文件的格式 # 加入头文件的路径 $(SOBJS) : obj/%.o : %.s \t$(CC) Wall nostdlib c O2 $(INCLUDE) o $@ $< # 加入头文件的路径 $(COBJS) : obj/%.o : %.c \t$(CC) Wall nostdlib c O2 $(INCLUDE) o $@ $< clear : \trm rf $(TARGET).elf $(TARGET).bin $(TARGET).dis $(OBJS) ```"},"/note/Linux/原子Linux/2022-8-29-Linux的并发与竞争.html":{"title":"Linux并发与竞争","content":" layout: post title: \"Linux并发与竞争\" date: 2022 8 29 15:39:08 +0800 tags: 嵌入式 原子Linux # Linux并发与竞争 在驱动中有可能存在, 对于公用的资源, 产生的原因, 多任务, 中断, 抢占, 多核 会竞争资源, 就是数据, 需要进行保护, 首先就是全局变量, ## 常用的处理方法 ### 原子操作 分为原子整形, 原子位操作 就是不能进一步分割的操作, 保证几条代码不会被分开执行, Linux提供了对于整形以及位操作的函数 #### 整形操作API 提供了一个结构体用来进行操作, 定义在`include/linux/types.h`文件中 ``` typedef struct { \tint counter; } atomic_t; ``` 在定义变量的时候使用这个结构体进行定义 可以在定义的时候进行赋值 ```c atomic_t b ATOMIC_INIT(0);//定义原子变量b并赋初值为0 ``` > 在定义的时候不能直接进行赋值`#define ATOMIC_INIT(i)\t{ (i) }` 在使用的时候有专门的函数, 函数 描述 : : : : `ATOMIC_INIT(int i)` 定义原子变量的时候对其初始化。 `int atomic_read(atomic_t *v)` 读取v的值，并且返回。 `void atomic_set(atomic_t *v, int i)` 向v写入i值。 `void atomic_add(int i, atomic_t *v)` 给v加上i值。 `void atomic_sub(int i, atomic_t *v)` 从v减去i值。 `void atomic_inc(atomic_t *v)` 给v加1，也就是自增。 `void atomic_dec(atomic_t *v)` 从v减1，也就是自减 `int atomic_dec_return(atomic_t *v)` 从v减1，并且返回v的值 `int atomic_inc_return(atomic_t *v)` 给v加1，并且返回v的值 `int atomic_sub_and_test(inti, atomic_t *v)` 从v减i，如果结果为0就返回真，否则返回假 `int atomic_dec_and_test(atomic_t *v)` 从v减1，如果结果为0就返回真，否则返回假 `int atomic_inc_and_test(atomic_t *v)` 给v加1，如果结果为0就返回真，否则返回假 `int atomic_add_negative(inti, atomic_t *v)` 给v加i，如果结果为负就返回真，否则返回假 ```c typedefstruct{ longlongcounter; }atomic64_t; ``` > 有64位的, 在64位机器使用 #### 原子位操作 不像原子整形变量那样有个atomic_t的数据结构，原子位操作是直接对内存进行操作 函数 描述 : : : : `void set_bit(intnr, void*p)` 将p地址的第nr位置1。 `void clear_bit(intnr,void*p)` 将p地址的第nr位清零 `void change_bit(intnr, void*p)` 将p地址的第nr位进行翻转。 `int test_bit(intnr,void *p)` 获取p地址的第nr位的值。 `int test_and_set_bit(intnr, void*p)` 将p地址的第nr位置1，并且返回nr位原来的值。 `int test_and_clear_bit(intnr, void*p)` 将p地址的第nr位清零，并且返回nr位原来的值。 `int test_and_change_bit(intnr, void*p)` 将p地址的第nr位翻转，并且返回nr位原来的值。 ### 自旋锁 原子操作只对整形进行操作, 或位操作 当一个线程要访问某个共享资源的时候首先要先获取相应的锁，锁只能被一个线程持有，只要此线程不释放持有的锁，那么其他的线程就不能获取此锁 如果自旋锁正在被线程A持有，线程B想要获取自旋锁，那么线程B就会处于忙循环 旋转 等待状态，线程B不会进入休眠状态或者说去做其他的处理 自旋锁的一个缺点：那就等待自旋锁的线程会一直处于自旋状态，这样会浪费处理器时间，降低系统性能，所以自旋锁的持有时间不能太长 可以用在多核的情况下 也是使用一个结构体 ```c typedef struct spinlock { \tunion { \t\tstruct raw_spinlock rlock; #ifdef CONFIG_DEBUG_LOCK_ALLOC # define LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map)) \t\tstruct { \t\t\tu8 __padding[LOCK_PADSIZE]; \t\t\tstruct lockdep_map dep_map; \t\t}; #endif \t}; } spinlock_t; ``` > 定义一个结构体, 然后对结构体进行操作 函数 描述 : : : : `DEFINE_SPINLOCK(spinlock_t lock)` 定义并初始化一个自选变量。 `int spin_lock_init(spinlock_t *lock)` 初始化自旋锁。 `void spin_lock(spinlock_t *lock)` 获取指定的自旋锁，也叫做加锁。 `void spin_unlock(spinlock_t *lock)` 释放指定的自旋锁。 `int spin_trylock(spinlock_t *lock)` 尝试获取指定的自旋锁，如果没有获取到就返回0 `int spin_is_locked(spinlock_t *lock)` 检查指定的自旋锁是否被获取，如果没有被获取就返回非0，否则返回0。 > 被自旋锁保护的临界区一定不能调用任何能够引起睡眠和阻塞的API函数，否则的话会可能会导致死锁现象的发生, 原因是在进行锁的时候会关闭内核抢占, 如果A进行休眠, B进行申请不成功会等待, 但是A由于不能抢占只能一直休眠 > 线程和中断之间, 和上面的情况相同 最好的解决方法就是获取锁之前关闭本地中断 函数 描述 : : : : `void spin_lock_irq(spinlock_t *lock)` 禁止本地中断，并获取自旋锁 `void spin_unlock_irq(spinlock_t *lock)` 激活本地中断，并释放自旋锁 `void spin_lock_irqsave(spinlock_t *lock, unsigned long flags)` 保存中断状态，禁止本地中断，并获取自旋锁。 `void spin_unlock_irqrestore(spinlock_t *lock, unsigned long flags)` 将中断状态恢复到以前的状态，并且激活本地中断，释放自旋锁。 > 我们是很难确定某个时刻的中断状态, 因此不推荐使用`spin_lock_irq/ spin_unlock_irq`, 建议使用`spin_lock_irqsave / spin_unlock_irqrestore` flogs用来保存中断的状态 #### 还有其他的锁 + 读写自旋锁 可以有多个进行读, 一个进行写 读写自旋锁为读和写操作提供了不同的锁，一次只能允许一个写操作，也就是只能一个线程持有写锁，而且不能进行读操作。 ```c typedefstruct{ arch_rwlock_t raw_lock; }rwlock_t; ``` ![QQ图片20220829212303](https://blog 1308522872.cos.ap beijing.myqcloud.com/jhy/202301010001233.png) ![QQ图片20220829212350](https://blog 1308522872.cos.ap beijing.myqcloud.com/jhy/202301010001234.png) + 顺序锁 使用顺序锁的话可以允许在写的时候进行读操作，也就是实现同时读写，但是不允许同时进行并发的写操作。如果在读的过程中发生了写操作，最好重新进行读取，保证数据完整性。 保护的资源不能是指针 ![QQ图片20220829212633](https://blog 1308522872.cos.ap beijing.myqcloud.com/jhy/202301010001235.png) #### 注意事项 在等待的时候会进行自旋, 所以不能持续时间太长 不能调用导致线程休眠的函数 不能递归申请, 否则会自己把自己锁死 为了兼容把所有的当做多核进行编写 ### 信号量 用来处理长时间, 可以让等待的进程进入休眠状态, 不能用于中断中，因为信号量会引起休眠，中断不能休眠。 如果共享资源的持有时间比较短，那就不适合使用信号量了，因为频繁的休眠、切换线程引起的开销要远大于信号量带来的那点优势。 线程使用自旋锁的时候就不能再使用信号量, 否则有可能进入休眠 信号量有一个信号量值, 可以通过信号量来控制访问共享资源的访问数量，通过信号量控制访问资源的线程数，在初始化的时候将信号量值设置的大于1，那么这个信号量就是计数型信号量，计数型信号量不能用于互斥访问 如果要互斥的访问共享资源那么信号量的值就不能大于1，此时的信号量就是一个二值信号量。 ```c struct semaphore { raw_spinlock_t lock; unsigned int count; struct list_head wait_list; }; ``` ![QQ图片20220829215359](https://blog 1308522872.cos.ap beijing.myqcloud.com/jhy/202301010001236.png) ```c structsemaphore sem;/* 定义信号量*/ sema_init(&sem,1);/* 初始化信号量*/ down(&sem);/* 申请信号量*/ /* 临界区*/ up(&sem);/* 释放信号量*/ ``` #### 互斥体mutex 互斥访问表示一次只有一个线程可以访问共享资源，不能递归申请互斥体。 ```c structmutex { /* 1: unlocked, 0: locked, negative: locked, possible waiters */ atomic_t count; spinlock_t wait_lock; }; ``` > 因为一次只有一个线程可以持有mutex，因此，必须由mutex的持有者释放mutex。并且mutex不能递归上锁和解锁 ![QQ图片20220829215821](https://blog 1308522872.cos.ap beijing.myqcloud.com/jhy/202301010001237.png)"},"/note/Linux/原子Linux/2022-8-19-多点电容触摸屏.html":{"title":"多点电容触摸屏","content":" layout: post title: \"多点电容触摸屏\" date: 2022 8 19 15:39:08 +0800 tags: 嵌入式 原子Linux # 多点电容触摸屏 多点触摸, 不需要按下去, 电容屏不需要校准, 电容触摸屏需要一个IC控制, 一般是I2C通讯协议, 读寄存器就可以的, 最终就是一个外设的驱动 ## 电容触摸屏芯片 FT5206和FT5426, 有4个IO用于连接主控制器：SCL、SDA、RST和INT，SCL和SDA是I2C引脚，RST是复位引脚，INT是中断引脚。一般通过INT引脚来通知主控制器有触摸点按下，然后在INT中断服务函数中读取触摸数据。也可以不使用中断功能，采用轮询的方式不断查询是否有触摸点按下 ### 引脚 CT INT >GPIO1_IO09上中断引脚 I2C2 SCL > UART5 TXD I2C2 SDA >UART5 RXD CT RST >SNVS_TAMPER9引脚 复位引脚, 默认上拉 ### 输出的触摸点坐标信息 输出的信息是和屏幕的显示器像素点相互对应的 实际上在Linux上需要校准 正点原子的地址为0x38地址 ### 寄存器 一个寄存器八位 需要用到的到的寄存器 DEVICE_MODE 0x00 设置模式, 设置为0, 工作在正常模式 ID_G_LIB_VERSION_H和ID_G_LIB_VERSION_L 0xa1, 0xa2 固件版本号 ID_G_MODE 0xa4 描述中断状态, 设置中断触发设置为1, 采用中断上报触摸的信息 TD_STATUS 0x02 当前的触摸点个数 1 5 一个触摸点六个寄存器, 使用前四个 0x03 04 第一个触摸点, 03的bit6 7事件标志, bit0 3是x坐标高四位, 04 低八位 > 事件: 0按下, 1抬起, 2接触, 3保留 0x05 06 第一个触摸点, 05的bit6 7触摸点ID, bit0 3是y坐标高四位, 06 低八位 一直到0x20 一个触摸点坐标信息为12bit ## 实现 手指放在屏幕上的时候就会一直产生中断"},"/note/Linux/原子Linux/2022-9-11-IIO.html":{"title":"IIO","content":" layout: post title: \"IIO\" date: 2022 9 11 15:39:08 +0800 tags: 嵌入式 原子Linux # IIO 就是为了ADC或DAC之类的传感器准备的, 电压, 电流, 光传感器等都可以使用IIO驱动框架 之前的写法就是驱动编写人员自己上传取得的数据, 在编写应用的时候不灵活, 上传的数据结构不统一, 最好是应用可以直接人性化的读取到传感器的数据 ## 实现方法 需要使能内核对应的配置 > Device Drivers > Industrial I/O support (IIO [ y]) >[\\*]Enable buffer support within IIO //选中 ><\\*>Industrial I/O buffering based on kfifo//选中 ### 构建 使用结构体iio_dev进行初始化 + 重要的参数 modes: 设备支持的模式 模式 描述 : : : : INDIO_DIRECT_MODE 提供sysfs接口。 INDIO_BUFFER_TRIGGERED 支持硬件缓冲触发。 INDIO_BUFFER_SOFTWARE 支持软件缓冲触发。 INDIO_BUFFER_HARDWARE 支持硬件缓冲区。 一般使用第一种 channels: 设置为通道, 为iio_chan_spec结构体类型, 实际上就是表示传感器的每一个测量通道 num_channels: IIO设备的通道数 info为iio_info: 结构体类型，这个结构体里面有很多函数，需要驱动开发人员编写，非常重要 ```c int (*read_raw)(struct iio_dev *indio_dev, struct iio_chan_spec const *chan, int *val, int *val2, long mask); int (*write_raw)(struct iio_dev *indio_dev, struct iio_chan_spec const *chan, int val, int val2, long mask); ``` > 在进行读写的时候最终会调用的函数, > > indio_dev：需要读写的IIO设备。 > > chan：需要读取的通道。 > > val，val2：对于read_raw函数来说val和val2这两个就是应用程序从内核空间读取到数据，一般就是传感器指定通道值，或者传感器的量程、分辨率等。对于write_raw来说就是应用程序向设备写入的数据。val和val2共同组成具体值，val是整数部分，val2是小数部分。但是val2也是对具体的小数部分扩大N倍后的整数值，因为不能直接从内核向应用程序返回一个小数值。比如现在有个值为1.00236，那么val就是1，vla2理论上来讲是0.00236，但是我们需要对0.00236扩大N倍，使其变为整数，这里我们扩大1000000倍，那么val2就是2360。因此val 1，val2 2360。扩大的倍数我们不能随便设置，而是要使用Linux定义的倍数 > > ![QQ图片20220911204316](https://blog 1308522872.cos.ap beijing.myqcloud.com/jhy/202301010003618.png) > > 靠返回值告诉内核放大的倍数 > > mask: 实际读取的数据的种类, 就是设置通道的时候设置的拥有的参数 ```c int (*write_raw_get_fmt)(struct iio_dev *indio_dev, struct iio_chan_spec const *chan, long mask); ``` > 根据写入的数据判断放大的倍数, write_raw_get_fmt函数决定了wtite_raw函数中val和val2的意义 + 通道 ```c struct iio_chan_spec { \tenum iio_chan_type\ttype;\t\t//类型 \tint\t\t\tchannel; \tint\t\t\tchannel2; \tunsigned long\t\taddress; \tint\t\t\tscan_index; \tstruct { \t\tchar\tsign; \t\tu8\trealbits; \t\tu8\tstoragebits; \t\tu8\tshift; \t\tu8\trepeat; \t\tenum iio_endian endianness; \t} scan_type; \tlong\t\t\tinfo_mask_separate; \tlong\t\t\tinfo_mask_shared_by_type; \tlong\t\t\tinfo_mask_shared_by_dir; \tlong\t\t\tinfo_mask_shared_by_all; \tconst struct iio_event_spec *event_spec; \tunsigned int\t\tnum_event_specs; \tconst struct iio_chan_spec_ext_info *ext_info; \tconst char\t\t*extend_name; \tconst char\t\t*datasheet_name; \tunsigned\t\tmodified:1; \tunsigned\t\tindexed:1; \tunsigned\t\toutput:1; \tunsigned\t\tdifferential:1; }; ``` > type, 枚举类型, 定义了采集到的数据的的类型, 里面有很多种类型 > > 当成员变量indexed为1时候，channel为通道索引. > > 当成员变量modified为1的时候，channel2为通道修饰符。用来在种类相同的时候进行区分, Linux内核给出了可用的通道修饰符，定义在include/uapi/linux/iio/types.h文件里面 > > address: 读取的起始地址 > > scan_type是一个结构体，描述了扫描数据在缓冲区中的存储格式。 > > ```c > struct { > char\tsign; > u8\trealbits; > u8\tstoragebits; > u8\tshift; > u8\trepeat; > enum iio_endian endianness; > } scan_type; > ``` > > > sign：如果为‘u’表示数据为无符号类型，为‘s’的话为有符号类型。 > > > > scan_type.realbits：数据真实的有效位数，比如很多传感器说的10位ADC，其真实有效数据就是10位。scan_type.storagebits：存储位数，有效位数+填充位。比如有些传感器ADC是12位的，那么我们存储的话肯定要用到2个字节，也就是16位，这16位就是存储位数。 > > > > scan_type.shift:右移位数，也就是存储位数和有效位数不一致的时候，需要右移的位数，这个参数不总是需要，一切以实际芯片的数据手册位数。 > > > > scan_type.repeat：实际或存储位的重复数量。 > > > > scan_type.endianness:数据的大小端模式，可设置为IIO_CPU、IIO_BE(大端)或IIO_LE(小端)。 > > info_mask_separate: 标记某些属性专属于此通道，include/linux/iio/types.h文件中的iio_chan_info_enum枚举类型描述了可选的属性值 + 使用 ```c struct iio_dev *iio_device_alloc(int sizeof_priv) ``` > 申请一个结构体, sizeof_priv：私有数据内存空间大小，一般我们会将自己定义的设备结构体变量作为iio_dev的私有数据，这样可以直接通过iio_device_alloc函数同时完成iio_dev和设备结构体变量的内存申请。 > > 申请成功以后使用iio_priv函数来得到自定义的设备结构体变量首地址。返回值：如果申请成功就返回iio_dev首地址，如果失败就返回NULL。 ```c void iio_device_free(struct iio_dev *indio_dev) ``` > 释放 ```c int iio_device_register(struct iio_dev *indio_dev) ``` > 注册 ```c void iio_device_unregister(struct iio_dev *indio_dev) ``` > 注销 ## 编写 + 初始化 ```c //申请iio_dev和icm20608_dev indio_dev devm_iio_device_alloc(&spi >dev, sizeof(*dev)); if(!indio_dev) { ret ENOMEM; goto fail_iio_dev; } dev iio_priv(indio_dev); dev >spi spi; spi_set_drvdata(spi, indio_dev); //设置设备的私有数据 mutex_init(&dev >lock); //初始化互斥锁 //初始化iio_dev indio_dev >dev.parent &spi >dev; //设置父设备 indio_dev >channels icm20608_channel; //设置通道 indio_dev >num_channels ARRAY_SIZE(icm20608_channel); //通道的数量 indio_dev >name ICM20608_NAME; indio_dev >modes INDIO_DIRECT_MODE; //直接接口，提供sysfs indio_dev >info &icm20608_info; //对应的函数 //将iio_dev注册到内核 \tret iio_device_register(indio_dev); \tif (ret < 0) { \t\tdev_err(&spi >dev, \"unable to register iio device\\n\"); \t\tgoto fail_iio_register; \t} ``` + 初始化通道 ```c #define ICM20608_CHANNEL(_type, _channel2, _index) \\ { \\ .type _type, \\ /*设置为1的时候channel12为通道修饰符*/ \\ .modified 1, \\ .channel2 _channel2, \\ /*共享的信息文件*/ \\ .info_mask_shared_by_type BIT(IIO_CHAN_INFO_SCALE), \\ /*分开的信息*/ \\ .info_mask_separate BIT(IIO_CHAN_INFO_RAW) \\ BIT(IIO_CHAN_INFO_CALIBBIAS), \\ .scan_index _index, \\ .scan_type { \\ .sign 's', \\ .realbits 16, \\ .storagebits 16, \\ .shift 0, \\ .endianness IIO_BE, \\ }, \\ } //加速度的三个通道,第一个参数种类, 第二三个同类区分 ICM20608_CHANNEL(IIO_ACCEL, IIO_MOD_X, INV_ICM20608_SCAN_ACCL_X), ICM20608_CHANNEL(IIO_ACCEL, IIO_MOD_Y, INV_ICM20608_SCAN_ACCL_Y), ICM20608_CHANNEL(IIO_ACCEL, IIO_MOD_Z, INV_ICM20608_SCAN_ACCL_Z), //陀螺仪 ICM20608_CHANNEL(IIO_ANGL, IIO_MOD_X, INV_ICM20608_SCAN_GYRO_X), ICM20608_CHANNEL(IIO_ANGL, IIO_MOD_Y, INV_ICM20608_SCAN_GYRO_Y), ICM20608_CHANNEL(IIO_ANGL, IIO_MOD_Z, INV_ICM20608_SCAN_GYRO_Z), ``` + 实际的判断 首先采用的mask是在设计通道的时候设置的拥有的参数种类比如原始值, 偏移, 参照之类的, chan >type是区分相同种类中的不同参数比如加速度计, 温度, chan >channel2可以提取其他的相关数字比如xyz轴 ```c static int icm20608_sensor_show(struct icm20608_dev *dev, int reg, \t\t\t\t int axis, int *val) { \tint ind, result; \t__be16 d; \tind (axis IIO_MOD_X) * 2; // 计算对应的寄存器位置偏移 \tresult regmap_bulk_read(dev >regmap, reg + ind, (u8 *)&d, 2); \tif (result) \t\treturn EINVAL; \t*val (short)be16_to_cpup(&d); \treturn IIO_VAL_INT; } static int icm20608_read_channel_data(struct iio_dev *indio_dev, struct iio_chan_spec const *chan, int *val) { \tstruct icm20608_dev *dev iio_priv(indio_dev); \tint ret 0; \tswitch (chan >type) { \tcase IIO_ANGL:\t/* 读取陀螺仪数据 */ \t\tret icm20608_sensor_show(dev, ICM20_GYRO_XOUT_H, chan >channel2, val); /* channel2为X、Y、Z轴 */ break; \tcase IIO_ACCEL:\t\t/* 读取加速度计数据 */ \t\tret icm20608_sensor_show(dev, ICM20_ACCEL_XOUT_H, chan >channel2, val); /* channel2为X、Y、Z轴 */ \t\tbreak; \tcase IIO_TEMP:\t\t/* 读取温度 */ \t\tret icm20608_sensor_show(dev, ICM20_TEMP_OUT_H, IIO_MOD_X, val); \t\tbreak; \tdefault: \t\tret EINVAL; \t\tbreak; \t} \treturn ret; } static int icm20608_read_raw(struct iio_dev *indio_dev,struct iio_chan_spec const *chan,int *val, \t\t\tint *val2,long mask) { int ret 0; struct icm20608_dev *dev iio_priv(indio_dev); unsigned char regdata 0; //区分读取的文件类型 switch(mask){ case IIO_CHAN_INFO_RAW: //读取得是原始的数据 mutex_lock(&dev >lock); ret icm20608_read_channel_data(indio_dev, chan, val); mutex_unlock(&dev >lock); return ret; case IIO_CHAN_INFO_CALIBBIAS: //读取的是数据文件 switch (chan >type) { case IIO_ANGL: mutex_lock(&dev >lock); regdata (icm20608_read_reg(dev, ICM20_GYRO_CONFIG) & 0X18) >> 3;//获取量程 *val 0; *val2 gyro_scale_icm20608[regdata]; mutex_unlock(&dev >lock); return IIO_VAL_INT_PLUS_MICRO;\t/* 值为val+val2/1000000 */ case IIO_ACCEL: mutex_lock(&dev >lock); regdata (icm20608_read_reg(dev, ICM20_ACCEL_CONFIG) & 0X18) >> 3; *val 0; *val2 accel_scale_icm20608[regdata];; mutex_unlock(&dev >lock); return IIO_VAL_INT_PLUS_NANO;/* 值为val+val2/1000000000 */ case IIO_TEMP:\t\t\t\t\t *val ICM20608_TEMP_SCALE/ 1000000; *val2 ICM20608_TEMP_SCALE % 1000000; return IIO_VAL_INT_PLUS_MICRO;\t/* 值为val+val2/1000000 */ default: return EINVAL; } return ret; case IIO_CHAN_INFO_OFFSET: //读取的是温度参照文件 switch (chan >type) { case IIO_TEMP: *val ICM20608_TEMP_OFFSET; return IIO_VAL_INT; default: return EINVAL; } return ret; case IIO_CHAN_INFO_SCALE: //读取的是数据文件 switch (chan >type) { case IIO_ANGL_VEL:\t\t/* 陀螺仪的校准值 */ mutex_lock(&dev >lock); ret icm20608_sensor_show(dev, ICM20_XG_OFFS_USRH, chan >channel2, val); mutex_unlock(&dev >lock); return ret; case IIO_ACCEL:\t\t\t/* 加速度计的校准值 */ mutex_lock(&dev >lock);\t ret icm20608_sensor_show(dev, ICM20_XA_OFFSET_H, chan >channel2, val); mutex_unlock(&dev >lock); return ret; default: return EINVAL; } default: ret EINVAL; return ret; } return 0; } ``` + 写相关 ```c static int icm20608_write_gyro_scale(struct icm20608_dev *dev, int val) { \tint result, i; \tu8 d; \tfor (i 0; i < ARRAY_SIZE(gyro_scale_icm20608); ++i) { \t\tif (gyro_scale_icm20608[i] val) {//判断传进来的数字是不是正确的参数, 是的话更改寄存器的设置 \t\t\td (i << 3); \t\t\tresult regmap_write(dev >regmap, ICM20_GYRO_CONFIG, d); \t\t\tif (result) \t\t\t\treturn result; \t\t\treturn 0; \t\t} \t} \treturn EINVAL; } static int icm20608_write_accel_scale(struct icm20608_dev *dev, int val) { \tint result, i; \tu8 d; \tfor (i 0; i < ARRAY_SIZE(accel_scale_icm20608); ++i) { \t\tif (accel_scale_icm20608[i] val) { \t\t\td (i << 3); \t\t\tresult regmap_write(dev >regmap, ICM20_ACCEL_CONFIG, d); \t\t\tif (result) \t\t\t\treturn result; \t\t\treturn 0; \t\t} \t} \treturn EINVAL; } /* * @description \t: 设置ICM20608传感器，可以用于陀螺仪、加速度计设置 * @param dev\t: icm20608设备 * @param reg \t: 要设置的通道寄存器首地址。 * @param anix \t: 要设置的通道，比如X，Y，Z。 * @param val \t: 要设置的值。 * @return\t\t\t: 0，成功；其他值，错误 */ static int icm20608_sensor_set(struct icm20608_dev *dev, int reg, \t\t\t\tint axis, int val) { \tint ind, result; \t__be16 d cpu_to_be16(val); \tind (axis IIO_MOD_X) * 2; \tresult regmap_bulk_write(dev >regmap, reg + ind, (u8 *)&d, 2); \tif (result) \t\treturn EINVAL; \treturn 0; } static int icm20608_write_raw(struct iio_dev *indio_dev, \t\tstruct iio_chan_spec const *chan, int val, int val2, long mask) { \tstruct icm20608_dev *dev iio_priv(indio_dev); \tint ret 0; \tswitch (mask) { \tcase IIO_CHAN_INFO_SCALE:\t/* 设置陀螺仪和加速度计的分辨率 */ \t\tswitch (chan >type) { \t\tcase IIO_ANGL:\t\t/* 设置陀螺仪 */ \t\t\tmutex_lock(&dev >lock); \t\t\tret icm20608_write_gyro_scale(dev, val2); \t\t\tmutex_unlock(&dev >lock); \t\t\tbreak; \t\tcase IIO_ACCEL:\t\t\t/* 设置加速度计 */ \t\t\tmutex_lock(&dev >lock); \t\t\tret icm20608_write_accel_scale(dev, val2); \t\t\tmutex_unlock(&dev >lock); \t\t\tbreak; \t\tdefault: \t\t\tret EINVAL; \t\t\tbreak; \t\t} \t\tbreak; \tcase IIO_CHAN_INFO_CALIBBIAS:\t/* 设置陀螺仪和加速度计的校准值*/ \t\tswitch (chan >type) { \t\tcase IIO_ANGL:\t\t/* 设置陀螺仪校准值 */ \t\t\tmutex_lock(&dev >lock); \t\t\tret icm20608_sensor_set(dev, ICM20_XG_OFFS_USRH, \t\t\t\t\t\t\t\t\t chan >channel2, val); \t\t\tmutex_unlock(&dev >lock); \t\t\tbreak; \t\tcase IIO_ACCEL:\t\t\t/* 加速度计校准值 */ \t\t\tmutex_lock(&dev >lock); \t\t\tret icm20608_sensor_set(dev, ICM20_XA_OFFSET_H, \t\t\t\t\t\t\t chan >channel2, val); \t\t\tmutex_unlock(&dev >lock); \t\t\tbreak; \t\tdefault: \t\t\tret EINVAL; \t\t\tbreak; \t\t} \t\tbreak; \tdefault: \t\tret EINVAL; \t\tbreak; \t} \treturn ret; } //在写入数据的时候进行判断, 根据返回值对写入的数值进行放大 static int icm20608_write_raw_get_fmt(struct iio_dev *indio_dev,struct iio_chan_spec const *chan, \t\t\t long mask) { \tswitch (mask) { \tcase IIO_CHAN_INFO_SCALE: \t\tswitch (chan >type) { \t\tcase IIO_ANGL:\t\t/* 用户空间写的陀螺仪分辨率数据要乘以1000000 */ \t\t\treturn IIO_VAL_INT_PLUS_MICRO; \t\tdefault:\t\t\t\t/* 用户空间写的加速度计分辨率数据要乘以1000000000 */ \t\t\treturn IIO_VAL_INT_PLUS_NANO; \t\t} \tdefault: \t\treturn IIO_VAL_INT_PLUS_MICRO; \t} \treturn EINVAL; } ``` ## 使用 IIO驱动框架提供了sysfs接口，因此加载成功以后我们可以在用户空间访问对应的sysfs目录项，进入目录“/sys/bus/iio/devices/”目录里面 iio:device0是I.MX6ULL内部ADC，iio:device1才是ICM20608。大家进入到对应的设备目录就可以看出对应的IIO设备 此目录下有很多文件，比如in_accel_scale、in_accel_x_calibias、in_accel_x_raw等，这些就是我们设置的通道。in_accel_scale就是加速度计的比例，也就是分辨率(量程)，in_accel_x_calibias就是加速度计X轴的校准值，in_accel_x_raw就是加速度计的X轴原始值。我们在配置通道的时候，设置了类型相同的所有通道共用SCALE，所以这里只有一个in_accel_scale，而X、Y、Z轴的原始值和校准值每个轴都有一个文件，陀螺仪和温度计同理。 ```c in_accel_z_calibbias in_angl_y_raw in_accel_scale in_accel_z_raw in_angl_z_calibbias ``` > 产生的部分文件 文件的名字是.type, .channel2 _channel2, .info_mask_shared_by_type或.info_mask_separate共同决定 ## 应用 文件读取到的都是字符串"},"/note/Linux/原子Linux/2022-8-17-DDR3.html":{"title":"DDR3","content":" layout: post title: \"DDR3\" date: 2022 8 17 15:39:08 +0800 tags: 嵌入式 原子Linux # DDR3 由于芯片内部的SRAM太小, 所以需要外界的RAM, 就是DDR ## 内存发展历史 + RAM: 随机存储器, 可以对任意地址进行操作, 比如内存条、SRAM、SDRAM、DDR等都是RAM。 + ROM：只读存储器, ROM是Flash，比如EMMC或UFS存储器, 因为历史原因，很多人还是将Flash叫做ROM。但是EMMC和UFS，甚至是NAND Flash，这些都是可以进行写操作的 + SRAM: 静态随机存储器, 最开始的是芯片内部的, 后来由于内存不够用, 会进行外扩RAM, SRAM突出的特点就是无需刷新, 通常作为SOC的内部RAM使用或Cache使用, STM32内存的RAM或I.MX6U内部的OCRAM都是SRAM, 缺点就是成本高, 有数据线, 地址线 + SDRAM:同步动态随机存储器，价格低, 容量高, SDRAM中的数据需要不断的刷新来保证数据不会丢失，“随机”的意思就是可以读写任意地址的数据。需要时钟线, 常见的是100MHz, 133MHz, 166MHz, 200MHz, 通过行地址和列地址之分, 还要选择BANK区域 + DDR: 本质上是SDRAM, 对于数据的传输速率提升, 一个clk传输两次数据, 在上升沿和下降沿各传输一次数据，这个概念叫做预取 + DDR2: 进一步增加预取(prefetch)，增加到了4bit，相当于比DDR多读取一倍的数据，因此DDR2的数据传输速率就是533~800MT/s + DDR3在DDR2的基础上将预取(prefetch)提高到8bit，因此又获得了比DDR2高一倍的传输速率，因此在总线时钟同样为266\\~400MHz的情况下，DDR3的传输速率就是1066~1600MT/S > I.MX6U的MMDC外设用于连接DDR，支持LPDDR2、DDR3、DDR3L，最高支持16位数据位宽。总线速度为400MHz(实际是396MHz)，数据传输速率最大为800MT/S + LPDDR3叫做低功耗DDR3，工作电压为1.2V。DDR3叫做标压DDR3，工作电压为1.5V，一般台式内存条都是DDR3。DDR3L是低压DDR3，工作电压为1.35V，一般手机、嵌入式、笔记本等都使用DDR3L 开发板上接了一个256MB/512MB的DDR3L，16位宽, BANK三根线, 有八个, 行15根, 线10根 ## 时间参数 ### 传输的速度 MT/S每秒传输多少M次数据DDR3 1600, DDR3 1866等不同的速率和时序有关 ### tRCD参数 行地址和列地址之间的延时, DDR的寻址流程是先指定BANK地址，然后再指定行地址，最后指定列地址确定最终要寻址的单元, BANK地址和行地址是同时发出的，这个命令叫做“行激活\", 行激活以后就发送列地址和具体的操作命令(读还是写)，这两个是同时发出的，因此一般也用“读/写命令”表示列寻址。在行有效(行激活)到读写命令发出的这段时间间隔叫做tRCD ### CL参数 数据从存储单元到内存芯片IO接口上还需要一段时间，这段时间就是非常著名的CL(CAS Latency)，也就是列地址选通潜伏期, 一般tRCD和CL大小一样 ### tRC参数 tRC是两个ACTIVE命令，或者ACTIVE命令到REFRESH命令之间的周期 ### tRAS 是ACTIVE命令到PRECHARGE命令之间的最小时间 ## MMDC控制器 第35章 支持多重的DDR, 16位 最高支持的频率是400Mhz, 传输的速率是800MHz 提供的DDR3连接信号, 6ULL提供了专用的I/O, 不可以设置I/O的复用, 但是可以设置电气属性 时钟源: 使用的是PLL2 PFD2设置的是396MHz, MMDC的最大个频率就是这个, 之前已将设置好了, bootrom也进行了相关的设置 CBCMR[PRE_PERIPH2_CLK_SEL]进行选择时钟源, 01 CBCDR[PERIPH2_CLK_SEL]\\(bit26)再次选择, 0这时候就是396分频 CBCDR[FABRIC_MMDC_PODF]设置分频 ## 测试工具 ddr_stress_tester软件 有一个配置文件, 是一个excel到恩智浦官方可以找到, 配置好以后会同步更新RealView.inc文件, 然后ddr_stress会使用这个软件 测试: 会通过配置信息下载到芯片中 USB通讯, 然后可以进行超频测试 测试前进行校准 ``` Write leveling calibration MMDC_MPWLDECTRL0 ch0 (0x021b080c) 0x00000000 MMDC_MPWLDECTRL1 ch0 (0x021b0810) 0x00080008 Read DQS Gating calibration MPDGCTRL0 PHY0 (0x021b083c) 0x013C0138 MPDGCTRL1 PHY0 (0x021b0840) 0x00000000 Read calibration MPRDDLCTL PHY0 (0x021b0848) 0x40403234 Write calibration MPWRDLCTL PHY0 (0x021b0850) 0x4040342E ```"},"/note/Linux/原子Linux/2022-8-12-链接文件.html":{"title":"链接文件","content":" layout: post title: \"链接文件\" date: 2022 8 12 15:39:08 +0800 tags: 嵌入式 原子Linux # 链接文件 符号链接, 就是快捷方式 硬链接, 有关`inode`, 相当于文件的新的ID ## 创建软连接 软 连接 >硬链接\\ >`inode` + 创建软连接 ```bash ln s 文件名 ``` 可以连接到目录, 可以跨文件系统, 符号链接要使用绝对路径创建, 否则不能进行移动,直接对文件进行复制的时候会把源文件一同复制 ```bash jiao@jiao virtual machine:~/桌面$ cp hello1 test/ jiao@jiao virtual machine:~/桌面$ cd test jiao@jiao virtual machine:~/桌面/test$ ls a.c b.c hello1 jiao@jiao virtual machine:~/桌面/test$ ls l 总用量 12 rw rw r 1 jiao jiao 0 8月 11 23:56 a.c rw rw r 1 jiao jiao 0 8月 11 23:56 b.c rwxrwxr x 1 jiao jiao 8600 8月 12 15:01 hello1 ``` 可以使用`cp d` 进行不变属性的复制,但是相对路径会出错 ## 创建硬链接 一般用来防止文件删除, 不能跨文件系统, 不能连接到目录 多个链接指向一个`inode`, 删除了所有连接文件才会删除源文件 ```bash ln 文件名 ``` ## 强制创建链接文件 ``` ln f 文件名 ``` 创建的文件存在先删除, 再创建 可以使用`ls i`查看文件的`inode`"},"/note/Linux/原子Linux/2022-9-1-platform设备驱动.html":{"title":"platform设备驱动","content":" layout: post title: \"platform设备驱动\" date: 2022 9 1 15:39:08 +0800 tags: 嵌入式 原子Linux # platform设备驱动 当驱动变得复杂的时候, 为了方便驱动的编写, 提高可重用性 ## 驱动分离与分层 ### 驱动分离分隔 把控制器和具体的设备分隔开, 根据Linux提供的框架使用统一的API接口, 分为主机控制器驱动, 设备驱动, 主机控制器驱动是由半导体厂商写的, 在linux下编写具体的设备驱动 中间的练习就是核心层, 统一的API定义 ### 驱动的分层 我们在编写输入设备驱动的时候只需要处理好输入事件的上报即可，至于如何处理这些上报的输入事件那是上层去考虑的 ## 总线 设备 驱动 根据分层理念形成的, 总线属于内核, 我们要编写驱动和设备 驱动就是具体的设备驱动 设备就是具体的设备属性, 包括属性, 地址范围等 ### 总线 总线有一个结构体进行表示 ```c struct bus_type { \tconst char\t\t*name; \tconst char\t\t*dev_name; \tstruct device\t\t*dev_root; \tstruct device_attribute\t*dev_attrs;\t/* use dev_groups instead */ \tconst struct attribute_group **bus_groups; \tconst struct attribute_group **dev_groups; \tconst struct attribute_group **drv_groups; \tint (*match)(struct device *dev, struct device_driver *drv); \tint (*uevent)(struct device *dev, struct kobj_uevent_env *env); \tint (*probe)(struct device *dev); \tint (*remove)(struct device *dev); \tvoid (*shutdown)(struct device *dev); \tint (*online)(struct device *dev); \tint (*offline)(struct device *dev); \tint (*suspend)(struct device *dev, pm_message_t state); \tint (*resume)(struct device *dev); \tconst struct dev_pm_ops *pm; \tconst struct iommu_ops *iommu_ops; \tstruct subsys_private *p; \tstruct lock_class_key lock_key; }; ``` > match函数，此函数很重要，单词match的意思就是“匹配、相配”，因此此函数就是完成设备和驱动之间匹配的，总线就是使用match函数来根据注册的设备来查找对应的驱动，或者根据注册的驱动来查找相应的设备, dev和drv，这两个参数分别为device和device_driver类型 总线主要就是为了总线下的设备驱动进行匹配, 有很多条总线在/sys/bus目录下面就是具体的总线 ``` / # cd sys/bus /sys/bus # ls clockevents event_source mmc sdio usb clocksource hid platform serio virtio container i2c rpmsg soc workqueue cpu mdio_bus scsi spi /sys/bus # cd i2c /sys/bus/i2c # ls devices drivers_autoprobe uevent drivers drivers_probe ``` 向Linux内核注册总线 ```c bus_reguister() bus_unreguister() ``` > 一般不会使用 ### 驱动 ```c struct device_driver { \tconst char\t\t*name; \tstruct bus_type\t\t*bus;\t\t//属于的总线 \tstruct module\t\t*owner; \tconst char\t\t*mod_name;\t/* used for built in modules */ \tbool suppress_bind_attrs;\t/* disables bind/unbind via sysfs */ \tconst struct of_device_id\t*of_match_table; \tconst struct acpi_device_id\t*acpi_match_table; \tint (*probe) (struct device *dev);\t//使用的函数 \tint (*remove) (struct device *dev); \tvoid (*shutdown) (struct device *dev); \tint (*suspend) (struct device *dev, pm_message_t state); \tint (*resume) (struct device *dev); \tconst struct attribute_group **groups; \tconst struct dev_pm_ops *pm; \tstruct driver_private *p; }; ``` + 驱动设备匹配以后, 驱动里面的probe函数就会运行 使用diriver_register进行向总线注册驱动, 会检查有没有匹配的设备, 有的话就会调probe函数 > 匹配方式, name和of_match_table > > ```c > struct of_device_id { > \tchar\tname[32]; > \tchar\ttype[32]; > \tchar\tcompatible[128]; > \tconst void *data; > }; > ``` > > ### 设备 ```c struct device { \tstruct device\t\t*parent; \tstruct device_private\t*p; \tstruct kobject kobj; \tconst char\t*init_name; /* initial name of the device */ \tconst struct device_type *type; \tstruct mutex mutex;\t/* mutex to synchronize calls to * its driver.*/ \tstruct bus_type\t*bus; /* type of bus device is on */ \tstruct device_driver *driver;\t/* which driver has allocated this device */ ...... }; ``` > 会定义自己的bus和driver 向总线注册设备的时候使用device_register函数, 和上面的driver注册类似,进行查找匹配, 最后也会调用probe函数 probe函数就是驱动编写人员进行编写的 ## platform平台驱动开发 对于soc内部的RTC, timer等不好总结为讲具体的总线, Linux提出虚拟总线, plantform总线, 有对应的设备和驱动 对于platform平台来说, 他的platform_match函数就是用来匹配的 ```c struct bus_type platform_bus_type { \t.name\t\t \"platform\", \t.dev_groups\t platform_dev_groups, \t.match\t\t platform_match, \t.uevent\t\t platform_uevent, \t.pm\t\t &platform_dev_pm_ops, }; ``` 使用驱动和设备里面的成员变量 ### dirver ```c struct platform_driver { \tint (*probe)(struct platform_device *); \tint (*remove)(struct platform_device *); \tvoid (*shutdown)(struct platform_device *); \tint (*suspend)(struct platform_device *, pm_message_t state); \tint (*resume)(struct platform_device *); \tstruct device_driver driver; //调用父类 \tconst struct platform_device_id *id_table; \tbool prevent_deferred_probe; }; ``` > 在父类下面添加相关的属性, 能否匹配根据id_table属性以及父类中的`const struct acpi_device_id\t*acpi_match_table;` 和name进行匹配 > > 主要实现的是probe加载匹配时候进行的函数, remove不匹配时候进行的函数, driver >name匹配使用的名字, 使用**platform_driver_register**函数向内核注册驱动, 注册的就是上面的结构体, 在注册驱动的时候如果驱动设备匹配成功执行probe函数 ### device ```c struct platform_device { \tconst char\t*name; \tint\t\tid; \tbool\t\tid_auto; \tstruct device\tdev; //父类 \tu32\t\tnum_resources; \tstruct resource\t*resource; \tconst struct platform_device_id\t*id_entry; \tchar *driver_override; /* Driver name to force a match */ \t/* MFD cell pointer */ \tstruct mfd_cell *mfd_cell; \t/* arch specific additions */ \tstruct pdev_archdata\tarchdata; }; ``` > 使用name进行匹配, id 为 1 表示没有id > > num_resources, 资源大小, resource资源, 一般用来面描述内存, 是一个结构体数组 > > ```c > struct resource { > \tresource_size_t start; > \tresource_size_t end; > \tconst char *name; > \tunsigned long flags; > \tstruct resource *parent, *sibling, *child; > }; > ``` > > > start和end分别表示资源的起始和终止信息，对于内存类的资源，就表示内存起始和终止地址，name表示资源名字，flags表示资源类型, 可选的资源类型都定义在了文件include/linux/ioport.h, 这里使用IORESOURCE_MEM表示内存 设备有两种情况, 有设备树和没有设备树 没有的时候需要注册一个platform_device结构体, 这个时候需要驱动开发人员编写注册文件, 使用platform_device_register函数注册设备 有了以后修改节点就可以了, 匹配之后会运行platform_device的probe函数 ### 匹配过程 驱动的匹配是通过bus >match函数进行的, platform总线下的match函数就是对应结构体下面的platform match函数完成的 有四种匹配的方式, 有设备树的时候直接比较设备树, 没有的时候通常比较名字, driver使用父类中的name 有设备树的时候, driver使用的是父类中的of_match_table, 非常重要, 类型为of_device_id结构体数组, 使用他的compatible属性, 可以有多个匹配的对象 ### 信息交流 ```c extern struct resource *platform_get_resource(struct platform_device *,unsigned int, unsigned int); ``` > 获取对应的资源, 参数一, 对应的设备, 参数二, 资源的类型, 第三个是索引 ## 实际编写(有设备树) 分为两部分, driver和device 1. 注册设备platform_device_register, 取消设备platform_device_unregister ```c struct platform_device leddevice { .name \"imx6ull led\", .id 1, //表示没有id .dev { .release leddevice_release, //在释放的时候调用这个函数 void\t(*release)(struct device *dev); }, .num_resources ARRAY_SIZE(led_resource), //资源 .resource led_resource, } ``` 2. 添加各种属性, 尤其是匹配时用的name和操作的时候使用的resource + 驱动编写 1. 和上面类似, 注册删除结构体 2. 编写驱动需要寄存器地址信息, 属于设备信息, 定义在platform_device里面, 需要在驱动获取设备资源, 使用函数platform_get_resource() ``` for(i 0;i<5;i++) { \t//获取 \tledsource[i] platform_get_resource(dev,IORESOURCE_MEM, i); if(ledsource[i] NULL) { \treturn EINVAL; } } ``` 注册函数, 实现函数, 和前面的实现方法一样 ## 实际编写(没有设备树) 不用再进行注册, 直接修改设备树 只需要修改设备树然后编写驱动文件 1. 初始化设备树 ```c 163 gpioled { 164 compatible \"jiao, gpioled\"; 165 pinctrl name \"default\"; 166 pinctrl 0 <&pinctrl_gpioled>; 167 status \"okey\"; 168 led gpio <&gpio1 3 GPIO_ACTIVE_LOW>; 169 }; ``` 2. platform_device初始化, 这里匹配采用的是结构体下.driver的of_match_table属性 ```c static const struct of_device_id beep_of_match[] { \t{.compatible \"jiao,beep\"}, \t{/* sentinel */}, }; struct platform_device leddriver { \t.driver { \t\t.name \"imx6ull led\", \t\t.of_match_tablem acpi_device_id; \t}, }; ``` 匹配成功之后probe函数的参数本身就带有设备的信息 ```c #if 0 gpioled.nd of_find_node_by_path(\"/gpioled\"); if(gpioled.nd NULL) { ret EINVAL; goto fail_findnd; } #endif \tgpioled.nd dev >dev.of_node; //简化之后 ``` platform提供很多函数去获取相关的信息"},"/note/Linux/原子Linux/2022-8-18-RTC.html":{"title":"RTC","content":" layout: post title: \"RTC\" date: 2022 8 18 15:39:08 +0800 tags: 嵌入式 原子Linux # RTC > SNVC章节的部分是加密的内容, 是拿不到的, 同时6ULL的手册是不完整的, 所以使用6UL的手册 在SNVS章节, 只有在初始化LP包含SRTC的时候才有掉电不复位, 用了电池也没用, 在做产品使用的时候最好使用外部的RTC, HP是一个供电的时候才可以使用的RTC时钟 类似于计数器的, 外接32,768MHz晶振 有两个寄存器保存计数值, 由于读的时候有时间差, 最好读两次 使用很简单, 打开读取就可以了, 获取时间值就可以了, 或者写入时间 ## 寄存器 SNVS_HPCOMR: bit31: 设置为所有软件可以访问, bit8: 安全有关随便配 SNVS_LPCR: bit0使能, 为1 SNVS_LPSRTCMR: 高15位为计数寄存器, 每秒加一 SNVS_LPSRTCLR: bit15 31作为低17位"},"/note/Linux/原子Linux/2022-8-11-磁盘管理.html":{"title":"磁盘管理","content":" layout: post title: \"磁盘管理\" date: 2022 8 11 15:39:08 +0800 tags: 嵌入式 原子Linux # 磁盘管理 Linux大部分不支持NTFS, 最好使用FAT格式的文件系统 在/dev文件中一般为`sd*`文件 `sd*n`表示第n个分区 ## `df`命令 显示磁盘使用 ## du命令 查看文件的大小 ## 挂载卸载 一般情况自动挂载 ### 取消 `umount`: 取消挂载 在取消挂载之前要从启动器解锁才能取消挂载 ```bash umount 挂载的地址/分区 ``` 挂载的地址为/media/用户名/... 分区是`sd*n` ### 挂载 创建用来挂载的文件夹 ``` mount /dev/设备 挂载点 ``` 挂载的时候有可能中文出现乱码, 加上` o iocharset utf8` ## 分区 `fdisk`命令 > l(小写L): 查看所有分区 ```bash sudo fdisk 设备 jiao@jiao virtual machine:/media/jiao$ sudo fdisk /dev/sdb ``` 在挂载的时候不能进行修改的操作 ## 创建系统 ``` mkfs t vfat 设备 ```"},"/note/Linux/原子Linux/2022-8-15-中断.html":{"title":"中断","content":" layout: post title: \"中断\" date: 2022 8 15 15:39:08 +0800 tags: 嵌入式 原子Linux # 中断 ## stm32中断 ARM芯片从0x00000000开始运行, 最开始的时候设置有中断向量表, 用于主要用来记录中断对应的中断函数 代码最开始的地方存放堆栈栈顶指针, 之后存放各种中断函数 ### 中断向量偏移 ARM从0x00000000开始的但是stm32是从0x80000000地址开始的, 如果代码一定要从别的位置开始, 就需要告诉内核, 设置中断向量偏移, 设置内核SCB的VTOR寄存器为新的中断向量表起始地址就可以了 ### NVIC终端管理 使能关闭终端, 设置优先级 ### 中断服务函数的编写 ## Cortex A7中断系统 ## 中断向量表 只有八个, 位于地址的最开始部分 + 复位: 上电以后第一个, 初始化工作 + 未定义指令: 指令不能识别 + 软中断: SWI指令中断, LInux使用进入内核, SVC特权模式 + 指令预取中止中断: 预取指令出错 + 数据访问中止中断: 数据访问出错 + 未使用: + IRQ中断: 外部中断, 所有的外设中断 + FIQ中断: 需要快速处理的终端 我们外面使用的是IRQ 没有已经写好的中断向量表, 用户自己定义 所有的裸机中断偏移都是在0x87800000开始的, 在main函数最开始的地址设置 ### GIC中断控制器 和NVIC一样, 用来控制中断, 有四个版本, V1已经被放弃了, V2是给ARMv7 A架构使用的, Cortex A7, Cortex A9等, V3,V4是给ARMv8 A/R使用的, 64位芯片 GIC V2最多支持八个核 接收终端之后发送给内核, 但是内核只提供了四个信号, + VFIQ: 虚拟快速 + VIRQ: 虚拟快速 + FIQ: 快速中断 + IRQ: 外部快速 > `cpsid i`: 禁止IRQ > > `cpsie i`: 使能IRQ > > `cpsid f`: 禁止FIQ > > `cpsie f`: 使能FIQ > 或者使用寄存器`GICD_ISENABLERn`和`GICD_ ICENABLERn`, 一个bit控制一个中断ID的使能, 16个GICD_ISENABLER寄存器来完成中断的使能。同理，也需要16个GICD_ICENABLER寄存器来完成中断的禁止。 GIC把所有的中断源分为了三种 + SPI: 共享中断, 所有的核共享的中断 + PPI: 私有中断, 独有的中断 + SGI: 软件终端 ### 中断ID 为了区分不同的中断, 最多支持1020个, 号码为0 1019, 包含了以上的三大类, 0 15给SGI, 16 31给PPI, 剩下的SPI 6ULL支持128个中断ID, ，加上前面属于PPI和SGI的32个ID，I.MX6U的中断源共有160个中断 前32个作为CPU的中断, ### 中断函数编写 IRQ中断服务函数的编写, 另一个是在IRQ中断服务函数中查找运行的具体函数 ## 编写按键中断例程 ### 中断向量表 在`start.s`文件中编写中断向量表, 复位中断函数, IRQ中断服务函数 ### 编写复位中断函数 #### 关闭I.D Cache和MMU CP15协处理器: CP15寄存器一般用于存储系统管理, 在中断中也会用, 有16个32位寄存器 c0 c15有特定的指令访问 + MCR: 读取, 将CP15协处理器中的寄存器数据读到ARM寄存器中 + MRC: 写入, 将ARM寄存器的数据写入到CP15协处理器寄存器中 ``` MCR{cond} p15, <opc1>, <Rt>, <CRn>, <CRm>, <opc2> ``` > `cond`:指令执行的条件码，如果忽略的话就表示无条件执行 > > `opc1`：协处理器要执行的操作码 > > `Rt：ARM`源寄存器，要写入到CP15寄存器的数据就保存在此寄存器中 > > `CRn`：CP15协处理器的目标寄存器。 > > `CRm`：协处理器中附加的目标寄存器或者源操作数寄存器，如果不需要附加信息就将`CRm`设置为C0，否则结果不可预测。 > > opc2：可选的协处理器特定操作码，当不需要的时候要设置为0 ![QQ图片20220815234911](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259323.png) 在Cortex A7 Technical... 手册中有每一个寄存器操作的指令, `CRn c1，opc1 0，CRm c0，opc2 0`的时候就表示此时的c1就是SCTLR寄存器，也就是系统控制寄存器 读取SCTLR寄存器, 采用读改写, 系统控制寄存器, bit0打开关闭MMU, bit1对齐控制位, bit2D Cache打开关闭, bit 11分支预测, bit12 I Cache #### 中断向量偏移 把新的中断向量表首地址写入CP15协处理器的VBAR寄存器 ![QQ图片20220815234553](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259325.png) 从图中可以知道, CRn c12，opc1 0，CRm c0，opc2 0的时候就表示此时c12为VBAR寄存器 ``` ldr r0, 0X87800000;r0 0X87800000 MCR p15, 0, r0, c12, c0, 0;将r0里面的数据写入到c12中 ``` ### 中断服务函数 保存寄存器 ![QQ图片20220815235124](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259326.png) `mrc p15, 4, r1, c15, c0, 0`读取CP15的寄存器CBAR, CBAR保存了GIC的控制寄存器首地址, GIC首地址偏移0x1000 0x1fff为GIC分发器, 0x2000 0x3fff为CPU接口端, 这意味着我们可以访问GIC控制器 分发器端口:处理各个中断事件的分发问题，也就是中断事件应该发送到哪个CPU Interface上去。分发器收集所有的中断源，可以控制每个中断的优先级，它总是将优先级最高的中断事件发送到CPU接口端 + 全局中断使能控制 + 控制每一个中断的使能或者关闭 + 设置每个中断的优先级 + 设置每个中断的目标处理器列表 + 设置每个外部中断的触发模式：电平触发或边沿触发 + 设置每个中断属于组0还是组1 CPU Interface(CPU接口端)：每个CPU Core都可以在GIC中找到一个与之对应的CPU Interface 从CPU相关的寄存器可以获得中断号, GICC_IAR的bit0 9保存中断ID, 可以使用这些ID得到对应的中断处理函数 + 使能或者关闭发送到CPU Core的中断请求信号 + 应答中断。 + 通知中断处理完成 + 设置优先级掩码，通过掩码来设置哪些中断不需要上报给CPU Core + 定义抢占策略 + 当多个中断到来的时候，选择优先级最高的中断通知给CPU Core 得到之后先进入SVC模式, 允许其他的中断,保存lr(上一级返回地址)寄存器, 然后跳转到处理的函数, 返回以后出栈这一个, 因为不同模式栈不同, 然后返回到IRQ模式, 恢复现场 在处理完函数之后, 需要把GICC_IAR写入GICC_EOIR寄存器里面 最后在返回的时候 ``` subs pc, lr, #4\t\t\t\t/* 将lr 4赋给pc */ ``` 在ARM的指令是三级流水线：取指、译指、执行，pc指向的是正在取值的地址，这就是很多书上说的pc 当前执行指令地址+8, 就需要将lr 4赋值给pc，也就是pc 0X2004，从指令“MOV R2，R3”开始执行 ## GPIO中断设置 ### GPIO的设置 `GPIOx_ICR1, GPIOx_ICR2`每一个寄存器使用两个位来控制中断, 分别控制低16高16位, 设置触发方式 + 00LOW_LEVEL — Interrupt n is low level sensitive.低电平 + 01HIGH_LEVEL — Interrupt n is high level sensitive.高电平 + 10RISING_EDGE — Interrupt n is rising edge sensitive.上升沿 + 11FALLING_EDGE — Interrupt n is falling edge sensitive下降沿 这里的按键设置为下降沿, `GPIOx_IMR`:掩码寄存器, 控制是不是屏蔽某一位的中断 + 0MASKED — Interrupt n is disabled. + 1UNMASKED — Interrupt n is enabled `GPIOx_EDGE_SEL`:用来控制上升沿以及下降沿都会触发中断, 设置的时候ICR寄存器不会发挥作用 `GPIOx_ISR`: 中断标志位, 处理完以后需要清除这个寄存器, 写1进行清除 ### GIC的设置 在手册的第三章查找对应的中断, 然后进行中断号使能 + 66 gpio1 Combined interrupt indication for GPIO1 signal 0 throughout15 + 67 gpio1 Combined interrupt indication for GPIO1 signal 16 throughout31 + 这里的数字应该加上32, 这里中断号为99 + 设置中断的优先级 + 添加中断的优先级 ### 实现 > 完成GPIO中断初始化 > 使用寄存器号使能GICD_ISENABLER寄存器 > 关闭掩码 ## 总结 中断向量表必须在程序开始的位置 然后设置向量表的偏移, 设置中断时候的栈 打开中断GIC的相关的中断, 设置中断产生的方法 在中断开始之后, 首先保护现场, , 获取中断的编号, 然后进入判断的函数, 根据得到的中断数进行中断函数调用 返回的时候清除中断的标志位 返回恢复现场"},"/note/Linux/原子Linux/2022-8-13-汇编LED驱动.html":{"title":"汇编LED实验","content":" layout: post title: \"汇编LED实验\" date: 2022 8 12 15:39:08 +0800 tags: 嵌入式 原子Linux # 汇编LED实验 + 在使用之前要初始化一些外设 + 准备C语言运行环境 + 之后进入C语言 + 使用汇编初始化DDR I.MX6U不需要 + 设置`sp`指针指向DDR, 设置好C语言运行环境 ## 硬件原理分析 stm32初始化流程, 首先使能GPIO时钟, 之后设置GPIO功能, 设置IO复用, 配置GPIO电气属性, 最后使用GPIO输出高低电平 I.MX6U: ### 时钟 时钟管理18章, 也可以控制内每一个外设的时钟 **Address: 20C_4000h base + 68h offset 20C_4068h** + CCGR0 CCGR6七个寄存器控制所有时钟的使能 每一个有两个位控制时钟, 有三种模式 + 00: 关闭 + 01 :在run模式开启 + 11 : 所有模式开启 为了简单设置CCGR0 6寄存器全部使能0xffffffff, 相当于使能所有的外设时钟 ### 复用 I/O复用寄存器IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO03 **Address: 20E_0000h base + 68h offset 20E_0068h** 位0 3四个位设置他的模式 > 0000ALT0 — Select mux mode: ALT0 mux port: I2C1_SDA of instance: i2c1 > > 0001ALT1 — Select mux mode: ALT1 mux port: GPT1_COMPARE3 of instance: gpt1 > > 0010ALT2 — Select mux mode: ALT2 mux port: USB_OTG2_OC of instance: usb > > 0100ALT4 — Select mux mode: ALT4 mux port: USDHC1_CD_B of instance: usdhc1 > > 0101ALT5 — Select mux mode: ALT5 mux port: **GPIO1_IO03 of instance: gpio1** > > 0110ALT6 — Select mux mode: ALT6 mux port: CCM_DI0_EXT_CLK of instance: ccm > > 0111ALT7 — Select mux mode: ALT7 mux port: SRC_TESTER_ACK of instance: src > > > NOTE:ALT7 mode will be automatically active when system reset. The PAD setting will be 100 Kpull down and input enable during reset period. Once system reset is completed, the stateof GPIO1_IO03 will be output keeper and input enable. > > 1000ALT8 — Select mux mode: ALT8 mux port: UART1_RX of instance: uart1 0101的时候设置为GPIO的功能 ### 配置电气属性 寄存器IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO03设置电气属性 **Address: 20E_0000h base + 2F4h offset 20E_02F4h** > bit0: 设置压摆率, 就是电平跳变使用的时间 > 2 1 : 保留 > 5 3: > > > 000 输出驱动关闭 > > > > 001: 3.3V时候R0为260Ω, 1.8V时候240Ω, DDR的时候240Ω > > > > 010: R0/2 > > > > 011: R0/3 > > > > ... > > 数字越大驱动能力越强 > 6 7: 设置速度 > > > 00SPEED_0_low_50MHz_ — low(50MHz) > > > > 01SPEED_1_medium_100MHz_ — medium(100MHz) > > > > 10SPEED_2_medium_100MHz_ — medium(100MHz) > > > > 11SPEED_3_max_200MHz_ — max(200MHz) > 11 : 开漏输出1打开 > 12 : 上拉保持1开启, 断电以后保持I/O状态, 使能或者禁止上下拉/状态保持器功能，为0时禁止上下拉/状态保持器，为1时使能上下拉和状态保持器 > 13: 当IO作为输入的时候，这个位用来设置IO使用上下拉还是状态保持器。当为0的时候使用状态保持器，当为1的时候使用上下拉。状态保持器在IO作为输入的时候才有用，顾名思义，就是当外部电路断电以后此IO口可以保持住以前的状态 > 14, 15 :上拉下拉 > > > 00PUS_0_100K_Ohm_Pull_Down — 100K Ohm Pull Down > > > > 01PUS_1_47K_Ohm_Pull_Up — 47K Ohm Pull Up > > > > 10PUS_2_100K_Ohm_Pull_Up — 100K Ohm Pull Up > > > > 11PUS_3_22K_Ohm_Pull_Up — 22K Ohm Pull Up > 16: 迟滞比较器，当IO作为输入功能的时候有效，用于设置输入接收器的施密特触发器是否使能。如果需要对输入波形进行整形的话可以使能此位。此位为0的时候禁止迟滞比较器，为1的时候使能迟滞比较器 主要设置, 压摆率, 速度, 驱动能力, 开漏输出, 上下拉 具体的设置为 > bit0:0低速率 > > bit5 3: 110设置为R0/6驱动能力 > > bit7 6: 10设置为100MHz > > bit11: 0开漏输出关闭 > > bit12: 1使能pullkepper > > bit13: 0 > > bit15 14:00默认下拉 > > bit16: 0关闭 0x10b0 ### 配置GPIO功能 设置输入输出 第二十八章 > GPIOx_DR寄存器控制高低 > > **209_C000** > GPIOx_GDIR: 输入输出, 0输入 > > **209_C004** > GPIOx_PSR: 只读寄存器, 状态寄存器 > GPIOx_ICR1: 中断相关, 用两个位设置中断电平以及上升沿下降沿 > > > 00LOW_LEVEL — Interrupt n is low level sensitive. > > > > 01HIGH_LEVEL — Interrupt n is high level sensitive. > > > > 10RISING_EDGE — Interrupt n is rising edge sensitive. > > > > 11FALLING_EDGE — Interrupt n is falling edge sensitive. > > GPIOx_ICR2: 控制位数较高的引脚 > GPIOx_IMR: 控制中断的打开关闭1打开 > GPIOx_ISR: 中断状态寄存器 只是用最上面两个的寄存器, GPIO1_GDIR的bit3为1输出模式 GPIO1_DR的bit3寄存器为0输出低电平 ## 汇编 编写的是ARM汇编, 使用GCC交叉编译期, 要符合GNU语法 ```GUN label: instruction @ comment ``` > label: 标签 > > instruction: 指令 > > @ 注释 汇编语言的默认入口是_start ### 常用的指令 > 数据传输 > > + 寄存器之间的传递 > + 特殊寄存器之间的传递 > + 把数字传递到寄存器 > > > MOV R0,R1把R1传递到R0 > > > > MRS R0, CPSR 读取特殊寄存器 > > > > MSR CPSR,RO 写入特殊寄存器 > 操作内存存储器访问指令 > > LDR Rd, [Rn,#offset] 把Rn+offset读取 > > STR Rd, [Rn,#offset] 放入 > > ``` > LDR R0, 0x3008000 @把数字放入寄存器 > LDR R1, [R0] @读取这个地址的数字 > ``` > > ``` > LDR R0, 0x30008000 > LDR R1, 0x01001010 > STR R1, [R0] @ 把数据放入这个地址 > ``` > 出栈压栈 > > POP {} > > PUSH > 跳转B、BL、BX > > > `B <lable>`: 跳转到标签 > > > > `BL <lable>`: 跳转以后把地址保存在Rm中 > > > > `BX <Rm>`: 跳转到存放在Rm的地址 > > > > `BLX <Rm>`: 跳转到Rm地址, 并保存返回地址 ### 处理器运行模型 ARM处理器有7种模式, 六种是特权模式, User是非特权模式, 最新的架构加入了其他的模式 最常用的 + Supervisor(SVC): 超级管理员模式, 供操作系统使用 + IRQ: 一般中断模式 + User(USR): 用户模式 ### 寄存器组 内核寄存器, 16个32位, 前十五个可以当做通用使用, 最后一个是PC寄存器 CPSR当前状态寄存器 SPSR: 备份状态寄存器(有的的模式没有) R13堆栈指针(SP) R14链接寄存器, 上一级地址(LR) R15程序计数器(RC) 不同模式的寄存器有可能不一样 > 状态寄存器保存着计算的结果, 使用的指令集, 大小端, 中断控制, 处理器模式等 ### 编译 将.c .s文件编译为.o文件 `arm linux gnueabihf gcc g c leds.s o leds.o` , g : 调试信息 c: 源文件编译不连接 ### 链接 将所有的.o文件链接为elf格式的可执行文件, 带有调试信息的bin文件 `arm linux gnueabihf ld Ttext 0x87800000 led.o o led.elf` “存储地址”就是可执行文件存储在哪里，可执行文件的存储地址可以随意选择。“运行地址”就是代码运行的时候所处的地址，这个我们在链接的时候就已经确定好了，代码要运行，那就必须处于运行地址处，否则代码肯定运行出错。 在链接的时候要指定起始的地址, 链接的起始地址就是代码运行的起始地址 对于stm32已经设置好了 对于6ULL指向RAM地址, 没有内部flash, ROM无法使用 一般有内部的RAM和外部的RAM也就是DDR > 6ULL内部有128K的RAM(**0X900000~0X91FFFF**) > DDR中，链接起始地址为0X87800000。对于每一个开发板都不同, 终止地址为0X9FFFFFFF 0X87800000这个地址是因为后面要讲的`Uboot`其链接地址就是0X87800000，这样我们统一使用0X87800000这个链接地址 想要使用DDR需要初始化DDR, bin文件不能直接在SD卡等外部存储设备中运行, 需要添加一个头部信息, 包含DDR的初始化参数LXM系列的SOC内部的boot rom里面的程序会从SD卡,EMMC等读取头部信息, 然后初始化DDR, 并把斌文件拷贝到指定的地址 bin的运行地址, 一定要和链接起始地址一致, 位置无关代码除外 ### 格式转换 把elf文件转换为bin文件 `arm linux gnueabihf objcopy O binary S g led.elf led.bin` O binary : 输出的文件为二进制 S : 不要复制源文件中的重定位信息以及符号信息 g : 不复制调试信息 ### 反汇编 也可以吧c的elf文件转换为汇编 ``` arm linux gnueabihf objdump D led.elf > led.dis ``` D: 反汇编所有的段 ## 烧写代码 STM32烧写到内部的flash 6ULL支持SD卡启动, EMMC启动, nor等方式启动 裸机例程烧写到SD卡然后从SD卡启动 在ubuntu下进行烧写, 不是直接拷贝, 而是烧写到绝对地址上, 而且对于L.MX而言不可以直接烧写, 要添加头部, 完成这个工作要使用专用软件 ```bash jiao@jiao virtual machine:~/linux/IMX6ULL/Bord_Drivers/1_leds$ ls imxdownload led.bin led.dis led.elf leds.code workspace leds.o leds.s ``` > `imxdownload`软件 格式`./imxdownload <.bin file> <SD Card>` 可以使用`sudo fdisk l`查看, 确定要烧写的SD卡文件我的是/dev/sdb ```bash jiao@jiao virtual machine:~/linux/IMX6ULL/Bord_Drivers/1_leds$ ./imxdownload led.bin /dev/sdb I.MX6ULL bin download software Edit by:zuozhongkai Date:2019/6/10 Version:V1.1 log:V1.0 initial version,just support 512MB DDR3 V1.1 and support 256MB DDR3 file led.bin size 160Bytes Board DDR SIZE: 512MB Delete Old load.imx Create New load.imx Download load.imx to /dev/sdb ...... 记录了6+1 的读入 记录了6+1 的写出 3232 bytes (3.2 kB, 3.2 KiB) copied, 0.145773 s, 22.2 kB/s ``` > 添加头部生成新的文件load.imx然后烧写 ## 创建Makefile ```makefile led.bin: leds.s \tarm linux gnueabihf gcc g c leds.s o led.o \tarm linux gnueabihf ld Ttext 0x87800000 led.o o led.elf \tarm linux gnueabihf objcopy O binary S g led.elf led.bin \tarm linux gnueabihf objdump D led.elf > led.dis clear: \trm rf *.o led.bin led.elf led.dis ``` ### 不使用jlnk 引脚冲突, 得不偿失 没有烧写的算法, 不能下载使用, 只能烧写到内部的RAM中去 ## 链接脚本 描述了要链接的文件以及顺序还有首地址 通过“ Ttext”来指定链接地址是0X87800000的，这样的话所有的文件都会链接到以0X87800000为起始地址的区域。但是有时候我们很多文件需要链接到指定的区域，或者叫做段里面 ```C SECTIONS{ . 0x10000000 .text (*(.text)) . 0x30000000 .data ALLGN(4) : ( *(.data) ) .bss ALLGN(4) : ( *(.bss) ) } ``` . : 叫做定位计数器, 默认为0, 代码链接的地址 在放置数据段之前要重新设置定位计数器 ``` SECTIONS{ \t. 0X87800000; \t.text : \t{ \t\tstart.o \t\tmain.o \t\t*(.text) \t} \t.rodata ALIGN(4) : {*(.rodata*)} \t.data ALIGN(4) : { *(.data) } \t__bss_start .; \t.bss ALIGN(4) : { *(.bss) *(COMMON) } \t__bss_end .; } ``` > ALIGN(4)表示4字节对齐。也就是说段“.data”的起始地址要能被4整除 > > start.o要被链接到最开始的地方，因为start.o里面包含这第一个要执行的命令 > > `“bss_start”和“__bss_end”`用来保存`.bss`段的起始地址和结束地址"},"/note/Linux/原子Linux/2022-8-12-make和Makefile.html":{"title":"make和Makefile","content":" layout: post title: \"make和Makefile\" date: 2022 8 12 15:39:08 +0800 tags: 嵌入式 原子Linux # make和Makefile ## make工具 自动完成编译工作 + 如果修改了源文件, 就只会再次编译修改了的文件 + 修改了头文件就会再次编译所有包含头文件的文件 需要Makefile文件 直接使用gcc编译会导致全部重复编译 ## Makefile语法 ```makefile 目标...: 依赖的文件集合 \t命令1 \t命令2 \t... ``` ```makefile 1 main: main.o input.o calcu.o 2 gcc main.o input.o calcu.o o main 3 main.o: main.c 4 gcc c main.c 5 input.o: input.c 6 gcc c input.c 7 calcu: calcu.c 8 gcc c calcu.c 9 clear: 10 rm *.o 11 rm main ``` > 如果要更新目标文件, 所有的依赖文件都要更新, 依赖文件任何一个更新目标文件也必须更新 > 每一条命令以Tab开头 make命令会为每一个Tab开头的命令创建一个shell去执行 make的默认目标: 文件开始出现的第一个目标 make会使用当前文件夹下的Makefile文件进行, 按照定义的规则创建目标问文件, 发现目标文件不存在或者依赖的文件更新时间比目标文件昕就进行编译, 如果不是一个文件, 会每次都执行对应的目标的命令(可以使用`.PHONY 目标命令`指定伪目标, 不会去匹配文件了, 避免和文件重名) ### Makefile变量 只有字符串 ```makefile 变量名 值 ``` + 使用 ```makefile $(变量名) ``` 还有两种赋值方法 + : + ? 在使用shell命令的时候在前面加上@符号可以让不输出执行的命令 ```bash 14 name jiao 15 name2 $(name) 16 name haoyang 17 print: 18 echo name2 $(name2) jiao@jiao virtual machine:~/桌面/test/c_language$ make print echo name2 haoyang name2 haoyang jiao@jiao virtual machine:~/桌面/test/c_language$ vim Makefile # 在此处更改为 @echo name2 $(name2) jiao@jiao virtual machine:~/桌面/test/c_language$ make print name2 haoyang ``` 赋值符号 借助另一个变量可以把变量的真实值推迟定义, 真实值为引用的变量的最后一次有效值, 只有在被调用的时候才会被赋值 ### 系统变量 ```makefile jiao@jiao virtual machine:~/yh linux/makefile_test$ make echo \"cc\" cc echo \"as\" as echo \"make\" make jiao@jiao virtual machine:~/yh linux/makefile_test$ cat Makefile .PHONY:all all: \techo \"$(CC)\" \techo \"$(AS)\" \techo \"$(MAKE)\" ``` 默认这几个变量是有一个默认值的 ### 延时赋值 只有这个值实际被引用的时候才会进行赋值 ````makefile jiao@jiao virtual machine:~/yh linux/makefile_test$ make echo \"456\" 456 jiao@jiao virtual machine:~/yh linux/makefile_test$ cat Makefile A 123 B $(A) A 456 .PHONY:all all: \techo \"$(B)\" ```` ### : 赋值符号 立即赋值, 这时候不会取最后一次修改的值 ```makefile 14 name jiao 15 name2: $(name) 16 name haoyang 17 print: 18 @echo name2 $(name2) jiao@jiao virtual machine:~/桌面/test/c_language$ make print name2 jiao ``` ### ? 赋值符号 前面的变量没有赋值就进行赋值, 相当于等号, 反之不进行赋值 ```makefile 14 name jiao 15 name2? $(name) 16 name haoyang 17 print: 18 @echo name2 $(name2) jiao@jiao virtual machine:~/桌面/test/c_language$ make print name2 haoyang 14 name2 kangkang 15 name jiao 16 name2? $(name) 17 name haoyang 18 print: 19 @echo name2 $(name2) jiao@jiao virtual machine:~/桌面/test/c_language$ make print name2 kangkang ``` ### + 赋值 追加 ## 模式规则 模式规则中最少要包含%, 否则视为一般规则 > % 相当于长度任意的非空字符创 当%出现在目标文件中的时候, 目标中的%决定了以来的%的值 ```makefile %.o : %.c \t命令 ``` ```makefile %: \techo \"$@\" ``` > 会匹配所有输入的命令并打印出来 ## 自动化变量 实现从不同的依赖文件中生成对应的文件 自动化变量 描述 : : : : $@ 当前的目标文件 $% 目标是函数库时候表示规则中的目标成员名, 否则为空 $< 依赖文件集合第一个文件, %定义就是集合 $? 所有比目标文件新的文件 $^ 所有依赖文件集合, 去除重复的文件 \\$+\\和$^相似, 但是不去除重复 $* 目标模式%以及之前的部分 常用\\$@, \\$<, \\$^ ### 特殊变量 在 Makefile 中，`VPATH` 是一个特殊变量，用于指定 **源文件搜索路径**。当 make 在当前目录找不到目标所需的依赖文件时，它会到 `VPATH` 指定的目录中查找这些文件。 ``` VPATH dir1:dir2:dir3... ``` 使用冒号 `:` 分隔多个目录（Windows 中使用分号 `;`） 搜索顺序：从左到右 ## 伪目标 不代表真正的目标名, 在执行make命令的时候通过指定伪目标执行其所在规则定义的命令 ```makefile 6 clear: 7 rm *.o 8 rm main jiao@jiao virtual machine:~/桌面/test/c_language$ make clear make: 'clear' is up to date. ``` > 如果文件夹下有一个和clear同名的文件, 由于没有依赖文件, 会被认定为更新到最新的文件, 不会执行这个命令 + 声明为伪目标 ```makefile .PHONY: clean ``` ```makefile 6 .PHONY: clear 7 clear: 8 rm *.o 9 rm main jiao@jiao virtual machine:~/桌面/test/c_language$ make clear rm *.o rm main ``` ## 条件判断 ```makefile <条件关键字> \t<条件为真的时候> else \t<条件为加的时候> endif ``` 条件关键字有四个 + ifeq ```makefile ifeq (<参数1>, <参数2>) ifeq '<参数1>', '<参数2>' ifeq \"<参数1>\", \"<参数2>\" ``` + ifneq + ifdef ```makefile ifdef<变量名> ``` + ifndef ## 函数使用 ```makefile $(函数名 参数集合) ``` ```makefile ${函数名 参数集合} ``` 只能使用支持的函数, 不能自定义 ### 常用的函数 + patsubst: 模式替换函数, 有三个函数 $(patsubst PATTERN, REPATTERN, TEXT) 在第一个参数匹配的内容中, 如果匹配的内容出现在TEXT中, 就会换成第二个参数 ```makefile $(patsubst %.c, %.o, x.c bar.c) ``` > 因为x.c或者bar.c匹配%.c所以会被替换为x.o或bar.o ```makefile $(VAR:pattern replacement) ``` 也可以使用这个语句进行替换比如使用`$(S_SOURCES:$(SRC_DIR)/%.s $(BUILD_DIR)/%.o)`把S_SOURCES里面的所有.s文件替换为.o文件 + notdir: 取文件名(删除路径) ```makefile $(notdir 路径或文件名) ``` + wildcard: 获取匹配的文件名 ```makefile $(wildcard *.c) ``` > 提取当前路径所有c文件 + foreach $(foreach VAR, LIST, TEXT) 第二个参数是一系列的文本, 遍历LIST, 赋值给VAR, 然后执行TEXT表达式 ```makefile dirs: a b c d files : $(foreach dir,$(dirs),$(wildcard $(dir)/*) ) ``` > 获取四个文件夹下所有的文件名 ## Makefile头文件依赖 先写一个头文件, 添加到头文件目录, 实施检查头文件依赖 使用替换函数生成头文件路径, 然后用 I参数添加到gcc编译器的头文件路径 要把头文件放在编译的文件的依赖文件上 ## 示例 ```bash 1 ARCH ? x86 2 3 ifeq ($(ARCH),x86) 4 CC gcc 5 else 6 CC arm linux gnueabihf gcc 7 endif 8 9 10 TARGET mp3 11 BUILD_DIR build 12 SRC_DIR module1 module2 13 14 SOURCES $(foreach dir,$(SRC_DIR),$(wildcard $(dir)/*)) # 获取到所有的源码文件.c文件, 有路径 15 OBJS $(patsubst %.c,$(BUILD_DIR)/%.o,$(notdir $(SOURCES)))# 创建目标文件名, 在build文件夹下面的.c 16 VPATH $(SRC_DIR) # 实际的搜索文件的路径 17 $(BUILD_DIR)/$(TARGET):$(OBJS) 18\t\t$(CC) $^ o $@ 19 20 $(BUILD_DIR)/%.o:%.c create_build # 使用VPATH下边的.c生成build下面的.o 21 $(CC) c $< o $@ 22\t 23 .PHONY:clean create_build 24 create_build: 25 \tmkdir p $(BUILD_DIR) ``` > 在 Makefile 中，管道符号 `` 用于声明 **order only prerequisites**（仅顺序依赖）。这是一种特殊类型的依赖关系，它确保依赖项在目标构建之前存在，但**不参与目标的时间戳比较**。这意味着： > > 1. **构建前必须存在**：目标构建前，order only 依赖项必须已经构建完成 > 2. **不触发重建**：当 order only 依赖项更新时，不会导致目标被重新构建 ```makefile CC arm linux gnueabihf gcc LD arm linux gnueabihf ld OBJCOPY arm linux gnueabihf objcopy OBJDUMP arm linux gnueabihf objdump TARGET led BUILD_DIR build SRC_DIR source # 获取所有源文件 C_SOURCES $(wildcard $(SRC_DIR)/*.c) S_SOURCES $(wildcard $(SRC_DIR)/*.s) C_OBJS $(C_SOURCES:$(SRC_DIR)/%.c $(BUILD_DIR)/%.o) S_OBJS $(S_SOURCES:$(SRC_DIR)/%.s $(BUILD_DIR)/%.o) OBJS $(C_OBJS) $(S_OBJS) # 默认目标 all: $(BUILD_DIR)/$(TARGET) # 创建可执行文件 $(BUILD_DIR)/$(TARGET): $(OBJS) \t@mkdir p $(BUILD_DIR) \t$(LD) Ttext 0x87800000 $^ o $@.elf \t$(OBJCOPY) O binary $@.elf $@.bin \t$(OBJDUMP) D $@.elf > $@.dis \t@echo \"Build complete: $(BUILD_DIR)/$(TARGET).bin\" \t../imxdownload $(BUILD_DIR)/$(TARGET).bin /dev/sdb # 编译C文件 $(BUILD_DIR)/%.o: $(SRC_DIR)/%.c \t@mkdir p $(BUILD_DIR) \t$(CC) c $< o $@ # 编译汇编文件 $(BUILD_DIR)/%.o: $(SRC_DIR)/%.s \t@mkdir p $(BUILD_DIR) \t$(CC) g c $< o $@ # 清理 clean: \trm rf $(BUILD_DIR) .PHONY: all clean ``` ## 模式匹配 %: 匹配任意多个非空的字符 ### 默认规则 默认.o文件使用.c文件进行编译, 所以不需要写出来 ## 静态模式规则 ### 语法结构 ```makefile $(SOBJS) : obj/%.o : %.S \t$(CC) Wall nostdlib c O2 $(INCLUDE) o $@ $< ``` #### 各组成部分解析 1. 目标定义 `$(SOBJS)` `$(SOBJS)` 是一个变量，包含要构建的目标文件列表 例如：`SOBJS obj/start.o obj/boot.o obj/interrupt.o` 2. 静态模式 `obj/%.o : %.S` **`obj/%.o`** 目标文件模式，在 `obj/` 目录下的 `.o` 文件 **`%.S`** 依赖文件模式，对应的汇编源文件 **`%`** 是通配符，匹配相同的部分 3. 编译命令 ``` $(CC) Wall nostdlib c O2 $(INCLUDE) o $@ $< ``` ### 实际工作示例 ``` SOBJS obj/start.o obj/boot.o ``` ```makefile obj/start.o : start.S \t$(CC) Wall nostdlib c O2 $(INCLUDE) o obj/start.o start.S obj/boot.o : boot.S \t$(CC) Wall nostdlib c O2 $(INCLUDE) o obj/boot.o boot.S ``` 这种模式规则避免了为每个源文件重复编写规则，提高了 Makefile 的维护性。"},"/note/Linux/原子Linux/2022-9-7-USB.html":{"title":"USB","content":" layout: post title: \"USB\" date: 2022 9 7 15:39:08 +0800 tags: 嵌入式 原子Linux # USB ## 概念 通用串行总线, 可以扩展为多种的方式 USB1.0速度为1.5M, 之后提出USB1.1 USB2.0, 分为两个版本, 全速(FS)12M, 高速(HS)480M, STM32要使用PHY新品, FS有内部的PHY, HS只有部分有 USB3.0, 最高的速度5G ### 接口 + 最常见的就是A口, 就是较大的方形口 + 有四个触点, 两边长中间短, 当插入USB的时候会先供电，然后再接通数据线。拔出的时候先断开数据线，然后再断开电源线 ![QQ图片20220907105017](https://blog 1308522872.cos.ap beijing.myqcloud.com/jhy/202301010003612.png) 第1根线为VBUS，电压为5V，第2根线为D ，第3根线为D+，第4根线为GND 使用的是差分信号 + 之后就是B口, 没用过方形 + Mini USB接口, 较小的厚口 有5个触点，也就是5根线，线序从左往右依次是1~5。第1根线为VCC(5V)，第2根线为D ，第3根线为D+，第4根线为ID，第5根线为GND ID线存在使得可以实现OTG功能, 也就是既可以做主机, 也可以做从机, 最大的供电电流是500mA, 作为主机供电的时候一般需要专门的电源 + Micro接口, 较小的扁口 + Typec接口 ### 拓扑结构 usb使用的是主从结构, 主机(HOST), 下面接多个设备, 键盘等叫做从机( device, slave) 可以使用USB HUB进行扩展USB接口, 6U只有两个控制器, 只能扩展数量, 不能扩展带宽, 最多支持128个地址, 0是默认的, 最多7层 ### USB OTG 同一个接口只能作为主机或只能作为从机 如果某一个接口, 可以在需要的时候进行转换, 就叫做OTG ID线的高低电平表示USB口工作在HOST还是DEVICE模式： ID 1：OTG设备工作在从机模式。 ID 0：OTG设备工作在主机模式。 支持OTG模式的USB接口一般都是MiniUSB或MicroUSB等这些带有ID线的接口 ### 规格 OHCI、UHCI、EHCI和xHCI + OHCI：全称为Open Host Controller Interface，这是一种USB控制器标准，厂商在设计USB控制器的时候需要遵循此标准，用于USB1.1标准。OHCI不仅仅用于USB，也支持一些其他的接口，比如苹果的Firewire等，OHCI由于硬件比较难，所以软件要求就降低了，软件相对来说比较简单。OHCI主要用于非X86的USB，比如扩展卡、嵌入式USB控制器 + UHCI：全称是Universal Host Controller Interface，UHCI是Inter主导的一个用于USB1.0/1.1的标准，与OHCI不兼容。与OHCI相比UHCI硬件要求低，但是软件要求相应就高了，因此硬件成本上就比较低 + EHCI：全称是Enhanced Host Controller Interface，是Inter主导的一个用于USB2.0的USB控制器标准。I.MX6ULL的两个USB控制器都是2.0的，因此兼容EHCI标准。EHCI仅提供USB2.0的高速功能，至于全速和低速功能就由OHCI或UHCI来提供 + xHCI：全称是eXtensible Host Controller Interface，是目前最流行的USB3.0控制器标准，在速度、能效和虚拟化等方面比前三个都有较大的提高。xHCI支持所有速度种类的USB设备，xHCI出现的目的就是为了替换前面三个 ### IMX6U 有两个USB接口, 都支持OTG, 一般都是使用一个作为OTG但是大部分情况使用作为从机, 烧写代码, 另一个连接HUB进行扩展, 集成了两个PHY芯片, 最高支持到480MHz 支持EHCI ## 驱动 HUB的驱动不需要自己编写, NXP默认使能了键盘鼠标 ### 使能 键盘鼠标属于HID设备, 内核集成相关的驱动 Device driver > HID support > <*> Generic HID driver U盘: Device driver > SCSI device support ><*> SCSI disk support 大容量设备 Device driver > [*] USB support > <\\*> EHCI HCD (USB 2.0) support ​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t <*> USB Mass Storage support ### 使用 U盘, 挂载使用 ```shell mount /dev/sda1 /mnt/usb_disk/ t vfat o iocharset utf8//挂载 sync \t//同步 cd/\t \t//如果处于/mnt/usb_disk目录的话先退出来，否则卸载的时候提设 \t\t//备忙，导致卸载失败，切记！ umount /mnt/usb_disk //卸载 ``` 使用usb转串口模块, 直接插进去没有什么反应 在使用otg作为主机前需要修改设备树, 加入ID电气属性设置 ### 模拟优盘 Linux下的SD卡, emmc的文件系统一般是ext4格式, 会提示格式化 Device driver >[*] USB support ><\\*> USB Gadget Support ><M> USB Gadget Drivers (Mass Storage Gadget) >(X) Mass Storage Gadget ```c cd drivers/usb/gadget///进入gadget目录下 sudo cp libcomposite.ko /home/zuozhongkai/linux/nfs/rootfs/lib/modules/4.1.15/ sudo cp function/usb_f_mass_storage.ko /home/zuozhongkai/linux/nfs/rootfs/lib/modules/4.1.15/ sudo cp legacy/g_mass_storage.ko /home/zuozhongkai/linux/nfs/rootfs/lib/modules/4.1.15/ ``` ```c depmod modprobe libcomposite.ko modprobe usb_f_mass_storage.ko modprobe g_mass_storage.ko file /dev/sda1 removable 1 ``` ``` rmmod g_mass_storage.ko ```"},"/note/Linux/原子Linux/2022-8-10-Linux常用命令.html":{"title":"Linux常用命令","content":" layout: post title: \"Linux常用命令\" date: 2022 8 10 15:39:08 +0800 tags: 嵌入式 原子Linux # Linux常用命令 [00 Linux cmd命令.zh.pdf](file:///E:/a学习/16 Linux/系统编程/00 Linux cmd命令.zh.pdf) [前言 — Linux latest 文档 (gnu linux.readthedocs.io)](https://gnu linux.readthedocs.io/zh/latest/preface.html) ## 快捷键 ![image 20240207213202140](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402072132261.png) ctrl + alt + T 打开一个终端 ctrl + shift + T在这一个中端里面打开一个终端 Alt + 数字 选择第几个终端 ## 小技巧 !! : 执行上一条命令 sudo !! : 使用管理员权限执行上一条命令 ## 命令 ### ls ```bash ls a\t\t\t#显示所有 ls l ls d \t\t\t#当前目录 ls R \t\t\t#递归显示 ``` ### cd ```bash cd \t\t\t#回上一个目录 ``` ### ifconfig显示网络配置 可以使用 a显示没有打开的网卡 大多数操作需要root权限 可以用来打开关闭网卡 ```bash ifconfig 网卡名 down ifconfig 网卡名 up ``` 修改网络的相关数据 修改ip地址 ```bash ifconfig 网卡名 IP地址 ``` 重启网卡 ```bash ifconfig 网卡名 reload ``` ### reboot 重启 ### poweroff 关机 ### sync 同步写入磁盘 ### find 查找 ```bash find name '*.jpg' find ./ type 'l' #获取这个类型的文件 find ./ maxdepth 1 name '*.jpg' #这个会限制层级 find ./ size +20M size 50M\t\t#大小区间 find ./ atime \t\t\t#最近访问的时间 find ./ ctime\t\t\t#最近改变的时间 find ./ mtime\t\t\t#最近属性改变(单位是天) find ./ name \"*name*\" exec ls l { } \\; #会把结果放到{}里面, \\是一个转义字符 find ./ name \"*name*\" ok ls l { } \\; #以一个交互的模式选择每一个是否执行 find ./ type f xargs ls l \t\t#这个也会把结果给后面的命令处理, 比 exec智能一点, 大量命令的时候会分批, 但是文件名里面有空格的时候会分开(空格的处理有问题) find ./ type f print0 xargs print0 ls l #这个时候会使用NULL作为分隔符 ``` > 普通文件 , 目录文件 d, 字符设备 c, 块设备 b, 软连接 l, 管道文件 p, 套接字 s, 未知文件 . > > 默认使用的是递归的搜索 > > b: 512 byte(默认的) c: byte w: two byte k:1024 byte M: 1024k G: 1024M ![image 20240208203906588](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402082039178.png) ### grep 在文件中查找某个字符串 ```bash grep nr \"字符串\" 目录 ``` > r: 递归查找 > > n: 显示第几行 ### du 查看目录文件大小, 默认是所有的文件 s 总大小 h 易读 ### df 查看磁盘, 使用的磁盘, 使用的多少, 挂载位置, 可以使用 h使便于查看 ### ps > 默认的是可以和用户交互的进程 > > e 显示所有的进程 > > f 全格式, 使用ASCII的格式显示进程的层次关系(树状图) > > h 不显示标题 > > l 长格式 > > w 宽输出 > > r 显示正在运行的任务 > > a 显示除了会话引导进程（session leaders）和无终端进程外的所有进程（通常显示所有终端的进程）。 > > u 查看所有者以及其他的详细信息 > > x 显示没有控制终端的任务 > > j 作业格式（显示PPID, PGID, SID） > > 可是使用aux ```bash ps aux grep jiao #看和我有关的进程, 显示进程树（需要支持）。参数VSZ是虚拟内存的大小, rss是物理内存的大小 \t\t\t\t # TTY是当前的终端, 可以用于查看任务的CPU, 内存百分比 ps ajxf # 可以使用这一个命令查看进程的父进程, 查看一个进程的相关的层次 ``` > 获取的只有一个的话是这一个查找的进程 > > STAT的含义 > > **状态码** 全称 含义 > : : : > `R` **Running** 进程正在运行（或 **可运行**，即在运行队列中等待 CPU 调度）。 > `S` **Sleeping** 进程在 **可中断睡眠**（等待事件完成，如 I/O 操作、信号等）。 > `D` **Uninterruptible Sleep** 进程在 **不可中断睡眠**（通常等待硬件 I/O，不能被信号唤醒，必须等待完成）。 > `T` **Stopped** 进程被 **暂停**（通常由 `SIGSTOP`、`SIGTSTP` 等信号触发）。 > `Z` **Zombie** **僵尸进程**（进程已终止，但其父进程尚未回收资源）。 > `X` **Dead** 进程已完全死亡（极少见，通常在进程刚被终止的瞬间出现）。 > > **附加字符** 含义 > : : > `<` 进程 **高优先级**（`nice` 值为负，如 `R<`）。 > `N` 进程 **低优先级**（`nice` 值为正，如 `SN`）。 > `s` 进程是 **会话领导者**（Session Leader）。 > `l` 进程是 **多线程的**（如 `Sl` 表示多线程睡眠进程）。 > `+` 进程位于 **前台进程组**（与终端关联，如 `S+`）。 > `L` 进程有 **锁定的内存页**（如 `RL`）。 > `I` 进程是 **空闲的内核线程**（如 `I`）。 > > START: 启动的时间 > > TIME: 运行的时间 > > COMMAND: 运行的程序 > > PPID: 父进程ID > > PID: 当前进程的ID > > PGID: 进程组ID > > SID: 会话的ID > > TTY: 关联的终端 > > TPGID: 是不是一个守护进程, 1的话是 > > UID: 哪一个用户启动的, 用户的id ### top 实时 ### file 查看文本 ### cat 用于查看一个文件, 可以不加文件名用于回显 还可以用tac倒着显示 ![image 20240207220358277](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402072203338.png) ### more less 显示文件以一个分页的形式 基本和more一样 ### head tail 显示前面几行, 后几行 ```bash head 5 main.c ``` ### ln 软连接 ```bash ln s 原名 链接名 ``` > 一个原名一个连接名字, 这一个会记录文件的路径, 使用相对路径的时候不可以移动, 这一个的大小实际是路径的字符串大小 ![image 20240207221754619](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402072217677.png) 硬链接 ```bash ln 原名 链接名 ``` ![image 20240207221531298](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402072215362.png) > 硬链接改变一个文件其他的文件同步更改, 原因是这几个文件的Inode相同, 操控的时候操控的是同一个文件(类似于指针), 在删除的时候先对计数减一, 为1的时候实际删除 ### chmod ```bash chmod [who] [+ ] [mode] 文件名 ``` > u 用户(所有者) > > g 同组 > > o 其他用户 > > a 所有的用户 > > 还可以使用数字 ### chown 改变他的所有者 ### stat 获取一个文件的状态 ### fg bg 前后台切换 ### alias起别名 ```bash alias pg 'gs aux grep' ``` ### umask 指定一个文件的掩码 ```bash umask [ p] S [mode] ``` mode的格式和chmod一样, 这一个可以设置一个文件创建的时候的执行权限(默认的时候没有执行权限), 单独使用显示当前的掩码 ```c jiao@ubuntu:~/Desktop$ touch test jiao@ubuntu:~/Desktop$ umask 0022 jiao@ubuntu:~/Desktop$ ll test rw r r 1 jiao jiao 0 Feb 9 01:56 test #这一个的权限是666 022的结果(没有执行的111) ``` ### shutdown 关机 比poweroff安全 ![image 20240209180649231](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402091806569.png) ### wc查看文本文件信息 打印文本文件的行数单词数等信息 ### useradd/adduser useradd: 创建一个基础的用户, 没有家目录, 密码等 adduser: 会提示建立这部分信息 > 删除使用userdel/deluser ### usermod管理用户属性 ``` usermod g 1001 xiaoming ``` > 把xiaominggid改为1001 ## 安装软件 ### deb文件 ```bash sudo dpkg i netease cloud music_1.2.1_amd64_ubuntu_20190428.deb # 安装命令 sudo dpkg r netease cloud music_1.2.1_amd64_ubuntu_20190428.deb # 删除 ```"},"/note/Linux/原子Linux/2022-8-22-顶层Makefile.html":{"title":"顶层Makefile","content":" layout: post title: \"顶层Makefile\" date: 2022 8 22 15:39:08 +0800 tags: 嵌入式 原子Linux # 顶层Makefile ## 预处理 ### 版本信息 最上面的是版本号 ### MAKEFLAGS变量 在执行子目录下的Makefile文件的时候, 在编译的时候主目录的Makefile可以调用子目录的Makefile 主目录的Makefile可以使用如下代码来编译这个子目录 ``` $(MAKE) C subdir ``` 调用make命令, 使用 C指定子目录, 可以使用用“export”来导出要传递给子make的变量, 不希望哪个变量传递给子make的话就使用“unexport”来声明不导出 有两个特殊的变量：“SHELL”和“MAKEFLAGS”，这两个变量除非使用“unexport”声明，否则的话在整个make的执行过程中，它们的值始终自动的传递给子make ```makefile MAKEFLAGS + rR include dir $(CURDIR) ``` “ rR”表示禁止使用内置的隐含规则和变量定义，“ include dir”指明搜索路径，”$(CURDIR)”表示当前目录 ### 命令的输出 uboot默认编译是不会在终端中显示完整的命令，都是短命令,“V 1“来实现完整的命令输出 ``` 73\tifeq (\"$(origin V)\",\"command line\") 74\t\tKBUILD_VERBOSE $(V) 75\tendif 76\tifndef KBUILD_VERBOSE 77\t\tKBUILD_VERBOSE 0 78\tendif 79 80\tifeq ($(KBUILD_VERBOSE),1) 81\t\tquiet 82\t\tQ 83\telse 84\t\tquiet quiet_ 85\t\tQ @ 86\tendif ``` 函数origin用于告诉你变量是哪来的, `$(origin <variable>)`, 返回值就是变量来源，因此$(origin V)就是变量V的来源。如果变量V是在命令行定义的那么它的来源就是\"command line\" 可以通过在命令之前加@控制是否输出命令 ``` $(Q)$(MAKE) $(build) tools ``` ``` quiet_cmd_sym ? SYM $@ cmd_sym ? $(OBJDUMP) t $< > $@ ``` 如果变量quiet为空的话，整个命令都会输出。 如果变量quiet为“quiet_”的话，仅输出短版本。_ 如果变量quiet为“silent_”的话，整个命令都不会输出。 ### 静默输出 编译的时候使用“make s”即可实现静默输出 ``` $(filter <pattern...>,<text>) ``` filter函数表示以pattern模式过滤text字符串中的单词，仅保留符合模式pattern的单词 > 函数firstword是获取首单词 ```makefile $(firstword <text>) ``` > 于取出text字符串中的第一个单词 ```makefile 91\tifneq ($(filter 4.%,$(MAKE_VERSION)),)# make 4 92\tifneq ($(filter %s ,$(firstword x$(MAKEFLAGS))),) 93\t\tquiet silent_ 94\tendif 95\telse# make 3.8x 96\tifneq ($(filter s% s%,$(MAKEFLAGS)),) 97\t\tquiet silent_ 98\tendif ``` 这几个参数会传递给子Makefile ### 设置编译结果输出目录 ``` O 目录名 ``` ### 设置代码检查 ``` C 数字 ``` ### 设置模块编译 ``` make M dir ``` 这里的结果是为当前目录 ### 获取主机架构 使用命令uname m获取, 使用替换命令进行替换, 使用uname s获取当前的系统, “tr '[:upper:]' '[:lower:]'”表示将所有的大写字母替换为小写字母 ### 设置编译器和交叉编译期 这里需要参数指定, 也可以自行添加到文件中 ### 进行变量的处理 导入文件config.mk的变量, 然后对文件中的变量进行导出, 他的变量来源是.config文件, 对变量进行提取 config.mk对对应的CPU架构的文件夹下的config.mk进行读取, 以及对对应的板子下面的config.mk进行读取, 然后进行处理 ## 编译过程分析 首先调用distclean, 清除一些文件 make xxx_defconfig, 有两个依赖的命令, 第二个命令为空, 第一个命令是为了编译出来一个软件, 他的命令就是用来生成另一个软件并利用软件生成一个.config文件 make命令, 根据之前编译出来的内容生成对应的文件 ### 链接脚本 默认为u boot.lds uboot链接的首地址为0x87800000, 定义在芯片的初始化定义中"},"/note/Linux/原子Linux/2022-8-18-I2C.html":{"title":"I2C","content":" layout: post title: \"I2C\" date: 2022 8 18 15:39:08 +0800 tags: 嵌入式 原子Linux # I2C 有一个用于测试的器件, AP3216C, 链接到一个I2C接口上面, , 还有一个APINT的中断, I2C_SCL使用的是UART4_TXD引脚, I2C_SDA使用的是UART4_RXD 两条线都是用一个4.7k上拉, 支持一个多从机, 使用唯一的地址进行访问 信号时序:[I2C协议(用于stm32) (xusenfeng.github.io)](https://xusenfeng.github.io/2022/07/I2C(stm32)/) 应答信号, 由从机进行拉低, 设置应答信号 + 写: 1)、开始信号。 2)、发送I2C设备地址，每个I2C器件都有一个设备地址，通过发送具体的设备地址来决定访问哪个I2C器件。这是一个8位的数据，其中高7位是设备地址，最后1位是读写位，为1的话表示这是一个读操作，为0的话表示这是一个写操作。 3)、I2C器件地址后面跟着一个读写位，为0表示写操作，为1表示读操作。 4)、从机发送的ACK应答信号。 5)、重新发送开始信号。 6)、发送要写写入数据的寄存器地址。 7)、从机发送的ACK应答信号。 8)、发送要写入寄存器的数据。 9)、从机发送的ACK应答信号。 10)、停止信号。 + 读 1)、主机发送起始信号。 2)、主机发送要读取的I2C从设备地址。 3)、读写控制位，因为是向I2C从设备发送数据，因此是写信号。 4)、从机发送的ACK应答信号。 5)、重新发送START信号。 6)、主机发送要读取的寄存器地址。 7)、从机发送的ACK应答信号。 8)、重新发送START信号。 9)、重新发送要读取的I2C从设备地址。 10)、读写控制位，这里是读信号，表示接下来是从I2C从设备里面读取数据。 11)、从机发送的ACK应答信号。 12)、从I2C器件里面读取到的数据。 13)、主机发出NO ACK信号，表示读取完成，不需要从机再发送ACK信号了。 14)、主机发出STOP信号，停止I2C通信 ## 时钟 66MHz ## 寄存器 I2Cx_IADR: 自己的从机地址 I2Cx_IFDR: 设置频率bit0 5分频因子, 设置为0x38或0x15的时候会进行640分频, 大概为103.125Kbit I2Cx_I2CR: bit7, 使能I2C, bit6中断, bit5主从模式选择0为从机, bit4发送接收设置为, 0接收1发送, I2Cx_I2SR: 状态寄存器, bit7数据传输, 0正在传输, 1完成, bit5, 总线忙闲位, 为0的时候空闲, bit0读却认位ACK信号 I2Cx_I2DR: 数据寄存器 > 在发送从机地址的时候自动产生开始信号 > I2Cx_I2CR[MSTA]: > > 0Slave mode. Changing MSTA from 1 to 0 generates a Stop and selects Slave mode. > > 1Master mode. Changing MSTA from 0 to 1 signals a Start on the bus and selects Master mode ## AP3216C 是一个三合一的环境光传感器, ALS(环境光)+PS(接近传感器)+IRLED(红外LED灯), 使用I2C最高400K频率 ALS是十六位输出, PS10bit输出, IR传感器也是10bit 从机地址为七位, 地址为0x1E ### 寄存器 + 0x00系统配置, bit0, 2设置开启的传感器设置为3的时候开启所有, 读取周期大于112ms + 0x0a是IR Data的low,bit7 为0的时候, 表示IR和PS数据有效, bit1, bit0是IR低两位 + 0x0b是bit0 7:IR Data的高字节, 和0xa一起组成10bit + 0x0c: ALS低字节bit0 7 + 0x0d: ALS高字节bit0 7 + 0x0e: bit0 3是ps的低四位, bit6 + 0x0f: bit0 5高六位数据"},"/note/Linux/原子Linux/2022-8-20-uBoot.html":{"title":"uBoot","content":" 00:layout: post title: \"uBoot\" date: 2022 8 20 15:39:08 +0800 tags: 嵌入式 原子Linux # uBoot 是一个裸机程序 用于启动Linux或者其他的系统, 最重要的是初始化DDR, 因为Linux运行在DDR中, 一般Linux镜像zImage(uImage)+设备树(.dtb)存放在SD, EMMC, NAND, SPIFLASH中 需要将系统镜像从外部的Flash拷贝到DDR中, 然后才能启动 uboot就是为了启动系统, 不知可以启动Linux, 也可以其他系统, Linux不止可以从uBoot启动, uboot是一个通用的bootloader, 支持多种架构 ## 获取 + 官网, 支持的芯片不完善, 支持少, 某一款的芯片驱动不完善 + SOC厂商会下载某一个版本, 然后进行修改, 加上SOC以及驱动, 定制版的uBoot + 开发板的厂商, 开发板会参考SOC厂商的板子, 开发板必然会和官方的不一样, 又会去修改 ## 编译 在编译Uboot的时候要先编译 ```bash jiao@jiao virtual machine:~/linux/IMX6ULL/uboot/alientek_uboot$ make ARCH arm CROSS_COMPILE arm linux gnueabihf distclean ``` 设置为arm架构, 设定使用的编译器, 进行第一次清理 ```bash jiao@jiao virtual machine:~/linux/IMX6ULL/uboot/alientek_uboot$ make ARCH arm CROSS_COMPILE arm linux gnueabihf mx6ull_14x14_ddr512_emmc_defconfig HOSTCC scripts/basic/fixdep HOSTCC scripts/kconfig/conf.o SHIPPED scripts/kconfig/zconf.tab.c SHIPPED scripts/kconfig/zconf.lex.c SHIPPED scripts/kconfig/zconf.hash.c HOSTCC scripts/kconfig/zconf.tab.o HOSTLD scripts/kconfig/conf # # configuration written to .config # ``` > 根据配置文件进行编译 直接接生成文件, 加上参数显示编译过程 ```bash jiao@jiao virtual machine:~/linux/IMX6ULL/uboot/alientek_uboot$ make V 1 ARCH arm CROSS_COMPILE arm linux gnueabihf ``` 生成u boot.bin文件, 向他添加头部信息, 在编译的时候会通过./tools/mkimage工具自动添加, 生成u boot.imx文件也就是最终烧写的文件 ## 注意 通过图形界面配置之后不要使用清除命令, 配置文件也会被删除 为了方便开发可以直接在makefile中更改变量 在之后带有调试作用的开发可以吧uboot烧写到SD卡 ## 使用 在启动之前按任意键可以进入uboot界面 > help: 进入帮助界面 ```bash U Boot 2016.03 gee88051 (Nov 05 2021 17:59:02 +0800) CPU: Freescale i.MX6ULL rev1.1 792 MHz (running at 396 MHz) CPU: Industrial temperature grade ( 40C to 105C) at 35C Reset cause: POR Board: I.MX6U ALPHAMINI I2C: ready DRAM: 512 MiB MMC: FSL_SDHC: 0, FSL_SDHC: 1 *** Warning bad CRC, using default environment In: serial Out: serial Err: serial switch to partitions #0, OK mmc1(part 0) is current device Net: FEC1 Error: FEC1 address not set. Normal Boot Hit any key to stop autoboot: 0 ``` + 第一行是Uboot版本以及编译时间 + 之后是CPU的格式以及运行的频率 + 然后是运行的温度以及现在的温度 + 复位模式POR + 开发板名字 + DRAM频率 + 两个MMC, 一个SD卡, 一个EMMC + 没有找到定义的此变量, 使用默认环境变量 + 标准输出输入, 错误都是串口 + 切换到0分区 + mmc0是当前的设备(命令mmc list) ``` > mmc list FSL_SDHC: 0 FSL_SDHC: 1 (eMMC) ``` ## 命令 ### 帮助 > 查看帮助信息: help或者? > 查看某一个命令: ?命令名 > > ``` > > ? help > help print command description/usage > > Usage: > help > \t print brief description of all commands > help command ... > \t print detailed usage of 'command' > > ``` ### 查询 > bdinfo: 查看板子的信息 > printenv: 查看当前的环境变量 #### 设置 > setenv: 设置环境变量 > > 设置有空格的变量, 要用单引号括起来 #### 保存 > saveenv: 保存环境变量 > > ``` > > setenv bootdelay 5 > > saveenv > ``` > > > 设置倒计时为五秒 #### 自定义环境变量 > setenv也可以用来设置, 也可以用来删除, 把值设置为空就是删除 ### 内存命令 #### 查看 用于显示命令值 ``` > ? md md memory display Usage: md [.b, .w, .l] address [# of objects] ``` > .b字节, .w字, .l四个字节显示内存, address起始地址, of objects 内存的大小, 长度的大小是单位和大小一同决定 > > **注:** 命令中的数字是十六进制 ``` > md.b 0x80000000 20 80000000: ff ff ff ff ff ff ef ff ff ff ff ff ff ff ff ff ................ 80000010: ff ff ff ff fe bf ff ff ff ff ff ff ff ff ff ff ................ > md.b 0x80000000 14 80000000: ff ff ff ff ff ff ef ff ff ff ff ff ff ff ff ff ................ 80000010: ff ff ff ff .... > md.w 0x80000000 14 80000000: ffff ffff ffff ffef ffff ffff ffff ffff ................ 80000010: ffff ffff bffe ffff ffff ffff ffff ffff ................ 80000020: ffff ffff fbbf ffff ........ > md.l 0x80000000 14 80000000: ffffffff ffefffff ffffffff ffffffff ................ 80000010: ffffffff ffffbffe ffffffff ffffffff ................ 80000020: ffffffff fffffbbf ffffffff ffffffff ................ 80000030: fffffff7 ffbbbfaf fff7ffff afffffff ................ 80000040: ff5ffdff ffffbeff dfffffff ffffffbf .._............. ``` > 显示20个数据 #### 设置 ``` > ? nm nm memory modify (constant address) Usage: nm [.b, .w, .l] address ``` > 输入地址回车进入修改模式, 输入q回车退出, 只修改一个地址 ``` > ? mm mm memory modify (auto incrementing address) Usage: mm [.b, .w, .l] address ``` > 递增的修改 ``` > ? mw mw memory write (fill) Usage: mw [.b, .w, .l] address value [count] ``` > 用指定的值填充一段地址 ``` > ? cp cp memory copy Usage: cp [.b, .w, .l] source target count ``` > 赋值 原地址, 目标值, 长度 ``` > ? cmp cmp memory compare Usage: cmp [.b, .w, .l] addr1 addr2 count ``` > 用来比较两段地址 ## 网络命令 网线插在ENET2上, 保证在同一个网段 使用setenv设置ip地址 ```` setenv ipaddr 地址 ```` 设置mac地址 ``` setenv ethaddr ``` > windows设置为WIFI的共享网络, 可以连接到Ubuntu的网络, 但是连接不上windows > setenv ethaddr 00:04:9f:04:d2:25 IP address is 192.168.137.164; sending through gateway 192.168.137.1 ``` setenv ipaddr 192.168.1.50 setenv ethaddr b8:ae:1d:01:00:00 setenv gatewayip 192.168.1.1 setenv netmask 255.255.255.0 setenv serverip 192.168.1.253 saveenv ``` ``` > ? ping ping send ICMP ECHO_REQUEST to network host Usage: ping pingAddress ``` > 用于测试网络链接是不是成功 ``` > ? dhcp dhcp boot image via network using DHCP/TFTP protocol Usage: dhcp [loadAddress] [[hostIPaddr:]bootfilename] ``` > 从路由器获取一个网络ip地址, 这是一个临时的地址, 不会影响环境变量中的地址, 下一次连接使用的是环境变量 ``` > ? nfs nfs boot image via network using NFS protocol Usage: nfs [loadAddress] [[hostIPaddr:]bootfilename] ``` > 目的是为了调试代码, 把系统镜像以及设备树下载到开发板中 > > 但是不能使用???? 可以使用 ``` > tftp 80800000 zImage Using FEC1 device TFTP from server 192.168.31.187; our IP address is 192.168.137.52; sending through gateway 192.168.137.1 Filename 'zImage'. Load address: 0x80800000 Loading: ######################################################################################################################################################################################################################################################################################################################################################################################### ############# 2.2 MiB/s done Bytes transferred 5901752 (5a0db8 hex) ``` ``` sudo apt get install tftp hpa tftpd hpa ``` > 下载 ``` mkdir/home/zuozhongkai/linux/tftpbootchmod777 /home/zuozhongkai/linux/tftpboot ``` > 建文件夹 建立文件设置/etc/xinetd.d/tftp ``` 1\tserver tftp 2\t{ 3\tsocket_type dgram 4\tprotocol udp 5\twait yes 6\tuser root 7\tserver /usr/sbin/in.tftpd 8\tserver_args s /home/zuozhongkai/linux/tftpboot/ 9\tdisable no 10\tper_source 1111cps 1002 12\tflags IPv4 13\t} ``` > 文件中 ``` sudo service tftpd hpa star ``` /etc/default/tftpd hpa文件 ``` 1\t# /etc/default/tftpd hpa 2 3\tTFTP_USERNAME \"tftp\" 4\tTFTP_DIRECTORY \"/home/zuozhongkai/linux/tftpboot\" 5\tTFTP_ADDRESS \":69\" 6\tTFTP_OPTIONS \" l c s\" ``` ``` sudo service tftpd hpa restart ``` ## EMMC和SD卡操作 只要驱动写好 就支持EMMC和SD卡 ``` > ? mmc mmc MMC sub system Usage: mmc info display info of the current MMC device mmc read addr blk# cnt mmc write addr blk# cnt mmc erase blk# cnt mmc rescan mmc part lists available partition on current mmc device mmc dev [dev] [part] show or set current mmc device [partition] mmc list lists available devices mmc hwpartition [args...] does hardware partitioning arguments (sizes in 512 byte blocks): [user [enh start cnt] [wrrel {onoff}]] sets user data area attributes [gp1gp2gp3gp4 cnt [enh] [wrrel {onoff}]] general purpose partition [checksetcomplete] mode, complete set partitioning completed WARNING: Partitioning is a write once setting once it is set to complete. Power cycling is required to initialize partitions after set to complete. mmc bootbus dev boot_bus_width reset_boot_bus_width boot_mode Set the BOOT_BUS_WIDTH field of the specified device mmc bootpart resize <dev> <boot part size MB> <RPMB part size MB> Change sizes of boot and RPMB partitions of specified device mmc partconf dev boot_ack boot_partition partition_access Change the bits of the PARTITION_CONFIG field of the specified device mmc rst function dev value Change the RST_n_FUNCTION field of the specified device WARNING: This is a write once field and 0 / 1 / 2 are the only valid values. mmc setdsr <value> set DSR register value ``` > `mmc info` 打印当前设备的信息 > > `mmc rescan` 重新扫描 > > `mmc list` 所有可用的 > > `mmc dev 设备号 [块地址]` 设置当前的设备 > > `mmc part`显示分区 > > `mmc read addr blk# cnt`: addr是数据写入DRAM中的地址, blk是读取的块起始地址, cnt是块的数量 > > `mmc write addr blk# cnt`: 用来把内容写入 > > `mmc erase`: 擦除少用 ## 文件系统有关 FAT文件格式命令 对于i.mxdull有三个分区, 第一个是uboot, 第二个是Linux内核和设备树FAT格式, 第三个系统的根文件系统EXT4格式 ``` > ? fatinfo fatinfo print information about filesystem Usage: fatinfo <interface> [<dev[:part]>] print information about filesystem from 'dev' on 'interface' ``` > 查看文件某一个分区的信息, 查某一个设备的某一个分区 > > ``` > fatinfo mmc 1:1 > > > fatinfo mmc 0:1 > Interface: MMC > Device 0: Vendor: Man 000000 Snr 00011801 Rev: 10.11 Prod: APPSD > Type: Removable Hard Disk > Capacity: 7680.0 MB 7.5 GB (15728640 x 512) > Filesystem: FAT32 \"NO NAME \" > ``` > > > 检查mmc设备一的分区一, 第一个分区没有格式, 第二个是FAT格式, > 查看某一个分区的所有的文件 > > ``` > > ? fatls > fatls list files in a directory (default /) > > Usage: > fatls <interface> [<dev[:part]>] [directory] > list files from 'dev' on 'interface' in a 'directory' > ``` > ``` > > ? fstype > fstype Look up a filesystem type > > Usage: > fstype <interface> <dev>:<part> > print filesystem type > fstype <interface> <dev>:<part> <varname> > set environment variable to filesystem type > > ``` > > 查看文件格式 > > ``` > > fstype mmc 0:1 > fat > > fstype mmc 0:0 > Failed to mount ext2 filesystem... > ** Unrecognized filesystem type ** > ``` > fatload 把指定的文件读取到MMC中, 就是读取系统的命令 > > ``` > fatload mmc 1:1 80800000 zImage > ``` > fatwrite写入文件 > > ``` > fatwrite <interface> <dev[:part]> <addr> <filename> <bytes> > ``` > EXT格式的文件, 有四个常用, ext2load, ext2ls, ext4load, ext4write ## NAND命令 > nand info 查看信息 > nand device 切换NADA Flash > nand erase 擦除 > nand write 写 ## boot指令 ### bootz命令 用于启动zImage bootz 要启动Linux首先要把Linux镜像zImage和设备树dtb拷贝到DRAM中, 设备树也要拷贝到DRAM中, 或者通过tftp下载 ``` > ? bootz bootz boot Linux zImage image from memory Usage: bootz [addr [initrd[:size]] [fdt]] boot Linux zImage stored in memory \tThe argument 'initrd' is optional and specifies the address \tof the initrd in memory. The optional argument ':size' allows \tspecifying the size of RAW initrd. \tWhen booting a Linux kernel which requires a flat device tree \ta third argument is required which is the address of the \tdevice tree blob. To boot that kernel without an initrd image, \tuse a ' ' for the second argument. If you do not pass a third \ta bd_info struct will be passed instead ``` > addr是镜像在DRAM中的位置, initrd就是initrd文件的位置, 不用的话使用一个 代替, fdt是设备树的地址, + 网络启动 把镜像存放至0x80800000, 设备树在0x83000000地址 ``` > dhcp BOOTP broadcast 1 *** Unhandled DHCP Option in OFFER/ACK: 46 *** Unhandled DHCP Option in OFFER/ACK: 46 DHCP client bound to address 192.168.137.247 (27 ms) Using FEC1 device TFTP from server 192.168.31.187; our IP address is 192.168.137.247; sending through gateway 192.168.137.1 Filename 'zImage'. Load address: 0x80800000 Loading: ########################################################################################################################################################################################################################################################################################################################### ############################################################### \t 2.2 MiB/s done Bytes transferred 5901752 (5a0db8 hex) > tftp 83000000 imx6ull alientek emmc.dtb Using FEC1 device TFTP from server 192.168.31.187; our IP address is 192.168.137.247; sending through gateway 192.168.137.1 Filename 'imx6ull alientek emmc.dtb'. Load address: 0x83000000 Loading: ### \t 1 MiB/s done Bytes transferred 39280 (9970 hex) > bootz 80800000 83000000 Kernel image @ 0x80800000 [ 0x000000 0x5a0db8 ] ## Flattened Device Tree blob at 83000000 Booting using the fdt blob at 0x83000000 Using Device Tree in place at 83000000, end 8300c96f ``` ### bootm 用于启动uImage ### boot 会读取变量bootcmd变量来启动系统, ``` \tsetenv bootcmd 'tftp 80800000 zImage; tftp 83000000 imx6ull 14x14 emmc 7 1024x600 c.dtb; bootz 80800000 83000000' \tsaveenv \tboot ``` 起始就是调用一个命令集合 ### reset 复位 ### go 跳转进行运行 ### run 运行自己设计的变量 ### mtest 测试内存, 重复读写内存"},"/note/Linux/原子Linux/2022-9-3-SPI.html":{"title":"SPI","content":" layout: post title: \"SPI\" date: 2022 9 3 15:39:08 +0800 tags: 嵌入式 原子Linux # SPI 和I2C类似, 主要的结构体是spi_master及认购提, 主要的实现就是个结构体的实现, 有通过控制器和外设交流的通信函数 主要实现的函数有transfer或者transfer_one_message函数, 6ull主机使用的是后者 6u自己使用的结构体叫`spi_imx_data`结构体, 实现函数tx和rx `spi_imx_data`结构体中有`spi_master`, 还有函数`setup_transfer`以及`txrx_bufs`函数 setup_transfer: 设置tx, rx的绑定函数 + `spi_master` ```c struct spi_master *spi_alloc_master(struct device *dev, \t\t\t\t\t\t\t\t\t\t\tunsigned size) ``` > 申请结构体, 同时申请片选以及`spi_imx_data`, 之后再进行处理 ```c void spi_master_put(struct spi_master *master) ``` > 释放 ```c intspi_register_master(struct spi_master *master) ``` > 注册 ```c void spi_unregister_master(struct spi_master *master) ``` > 注销 ## 实现 在设备树中使用cs gpios定义片选信号, 实际使用的是软件片选, 所以复用为gpio ```c struct spi_device { \tstruct device\t\tdev; \tstruct spi_master\t*master; \tu32\t\t\tmax_speed_hz; \tu8\t\t\tchip_select; \tu8\t\t\tbits_per_word; \tu16\t\t\tmode; #define\tSPI_CPHA\t0x01\t\t\t/* clock phase */ #define\tSPI_CPOL\t0x02\t\t\t/* clock polarity */ #define\tSPI_MODE_0\t(00)\t\t\t/* (original MicroWire) */ #define\tSPI_MODE_1\t(0SPI_CPHA) #define\tSPI_MODE_2\t(SPI_CPOL0) #define\tSPI_MODE_3\t(SPI_CPOLSPI_CPHA) #define\tSPI_CS_HIGH\t0x04\t\t\t/* chipselect active high? */ #define\tSPI_LSB_FIRST\t0x08\t\t\t/* per word bits on wire */ #define\tSPI_3WIRE\t0x10\t\t\t/* SI/SO signals shared */ #define\tSPI_LOOP\t0x20\t\t\t/* loopback mode */ #define\tSPI_NO_CS\t0x40\t\t\t/* 1 dev/bus, no chipselect */ #define\tSPI_READY\t0x80\t\t\t/* slave pulls low to pause */ #define\tSPI_TX_DUAL\t0x100\t\t\t/* transmit with 2 wires */ #define\tSPI_TX_QUAD\t0x200\t\t\t/* transmit with 4 wires */ #define\tSPI_RX_DUAL\t0x400\t\t\t/* receive with 2 wires */ #define\tSPI_RX_QUAD\t0x800\t\t\t/* receive with 4 wires */ \tint\t\t\tirq; \tvoid\t\t\t*controller_state; \tvoid\t\t\t*controller_data; \tchar\t\t\tmodalias[SPI_NAME_SIZE]; \tint\t\t\tcs_gpio;\t/* chip select gpio */ \t/* \t * likely need more hooks for more protocol options affecting how \t * the controller talks to each chip, like: \t * memory packing (12 bit samples into low bits, others zeroed) \t * priority \t * drop chipselect after each word \t * chipselect delays \t * ... \t */ }; ``` > 每一个spi_device都有一个spi_master, 挂载在某一个spi控制器, 由设备树创建, 这个的mode参数需要自己设置 spi_driver ```c struct spi_driver { \tconst struct spi_device_id *id_table; \tint\t\t\t(*probe)(struct spi_device *spi); \tint\t\t\t(*remove)(struct spi_device *spi); \tvoid\t\t\t(*shutdown)(struct spi_device *spi); \tstruct device_driver\tdriver; }; ``` > 使用函数spi_register_driver注册结构体, spi_unregister_driver注销结构体 ## 实现 1. 修改设备树, 首先配置引脚复用, 使用软件片选, 之后在ecspi3节点下面创建设备 ```c &ecspi1 { \tfsl,spi num chipselects <1>;\t//片选信号的数量 \tcs gpios <&gpio4 9 0>;\t\t//片选引脚 \tpinctrl names \"default\"; \tpinctrl 0 <&pinctrl_ecspi1>; \tstatus \"okay\"; \tflash: m25p80@0 {\t//对应的芯片,后面的0表示接到的硬件片选上 \t\t#address cells <1>; \t\t#size cells <1>; \t\tcompatible \"st,m25p32\"; \t\tspi max frequency <20000000>;\t//最大的频率 \t\treg <0>;\t//硬件片选对应的引脚 \t}; }; ``` > 参考示例 2. 搭建对应的结构, 初始化字符设备 3. 使用SPI进行读写 用到两个重要的结构体 spi_transfer, spi_message ```c struct spi_transfer { \tconst void\t*tx_buf; \tvoid\t\t*rx_buf; \tunsigned\tlen; \tdma_addr_t\ttx_dma; \tdma_addr_t\trx_dma; \tstruct sg_table tx_sg; \tstruct sg_table rx_sg; \tunsigned\tcs_change:1; \tunsigned\ttx_nbits:3; \tunsigned\trx_nbits:3; #define\tSPI_NBITS_SINGLE\t0x01 /* 1bit transfer */ #define\tSPI_NBITS_DUAL\t\t0x02 /* 2bits transfer */ #define\tSPI_NBITS_QUAD\t\t0x04 /* 4bits transfer */ \tu8\t\tbits_per_word; \tu16\t\tdelay_usecs; \tu32\t\tspeed_hz; \tstruct list_head transfer_list; }; ``` > tx_buf发送的数据, rx_buf读取的数据, len数据的长度, 不能直接使用, 要封装为spi_message ```c struct spi_message { \tstruct list_head\ttransfers; \tstruct spi_device\t*spi; \tunsigned\t\tis_dma_mapped:1; \tvoid\t\t\t(*complete)(void *context); \tvoid\t\t\t*context; \tunsigned\t\tframe_length; \tunsigned\t\tactual_length; \tint\t\t\tstatus; \tstruct list_head\tqueue; \tvoid\t\t\t*state; }; ``` > 使用之前进行初始化 > > ```c > static inline void spi_message_init(struct spi_message *m) > ``` > > 之后把spi_transfer添加到队列中, list_head使用这个链表进行连接 > > ```c > spi_message_add_tail(struct spi_transfer *t, struct \t\t\t\t\t\t\tspi_message *m) > ``` > > 最后使用函数进行传输 > > ```c > spi_sync(struct spi_device *spi, struct spi_message \t\t\t\t\t*message); > ``` 4. 引脚的获取, 从spi >dev.of_node获取节点, 但是引脚在更上一层节点, 使用函数of_get_parent函数, 初始化引脚 5. 设置spi_device的参数 ```c spi >mode SPI_MODE_0; //设置SPI为模式0,也就是CPOL 0.CPHA 0 spi_setup(spi);\t//设置好以后需要使用spi_setup配置一下 icm20608.private_data spi; ``` 6. spi读写寄存器, 设置 ```c static s32 icm20608_write_regs(struct icm20608_dev *dev, u8 reg, u8 *buf, int len) { unsigned char txdata[1]; struct spi_message m; struct spi_transfer *t; struct spi_device *spi dev >private_data; \t//发送写的第一位寄存器 gpio_set_value(dev >cs_gpio, 0); t kzalloc(sizeof(struct spi_transfer), GFP_KERNEL); txdata[0] reg & ~0x80; t >tx_buf txdata; t >len 1; spi_message_init(&m); spi_message_add_tail(t, &m); spi_sync(spi, &m); //读取数据 t >tx_buf buf; t >len len; spi_message_init(&m); spi_message_add_tail(t, &m); spi_sync(spi, &m); gpio_set_value(dev >cs_gpio, 1); kfree(t); return 0; } ``` > 也可以直接使用spi_read, spi_write函数 ```c static int icm20608_read_regs(struct icm20608_dev *dev, u8 reg, \t\t\t\tvoid *buf, int len) { struct spi_device *spi dev >private_data; u8 data reg 0x80; gpio_set_value(dev >cs_gpio, 0); spi_write(spi, &data, 1); spi_read(spi, buf, len); gpio_set_value(dev >cs_gpio, 1); } ``` ## 使用官方的片选 每次读写的时候把寄存器和数据合二为一 使用函数 ```c int spi_write_then_read(struct spi_device *spi,const void \t*txbuf, unsigned n_tx,void *rxbuf, unsigned n_rx); ```"},"/note/Linux/原子Linux/2022-9-2-INPUT子系统.html":{"title":"INPUT子系统","content":" layout: post title: \"INPUT子系统\" date: 2022 9 2 15:39:08 +0800 tags: 嵌入式 原子Linux # INPUT子系统 输入有按键, 鼠标, 键盘, 触摸屏等, linux做了一个专门的框架, 本质上还是字符设备 不同设备的输入代表的含义不同, 我们需要按照要求上报事件 主要分为三层: + 驱动层：输入设备的具体驱动程序，比如按键驱动程序，向内核层报告输入内容。 + 核心层：承上启下，为驱动层提供输入设备注册和操作接口。通知事件层对输入事件进行处理。 + 事件层：主要和用户空间进行交互。 input核心层会帮我们注册一个字符设备类, 主设备号为13, 创建的类放在/sys/class目录下面, 在文件`drivers/input/input.c`进行创建 内核已经写好了input驱动, 需要我们完善具体的输入设备, 按照input子系统驱动框架 ## 实际编写 实际就是注册设备, 使用input_dev结构体 ![QQ图片20220902154816](https://blog 1308522872.cos.ap beijing.myqcloud.com/jhy/202301010002786.png) > evbit:事件的类型, 可选的事件类型定义在include/uapi/linux/input.h文件中 > > ![QQ图片20220902154229](https://blog 1308522872.cos.ap beijing.myqcloud.com/jhy/202301010002787.png) > > 那么就需要注册EV_KEY事件，如果要使用连按功能的话还需要注册EV_REP事件 > > 设置按键的值, 就是keybit, Linux内核定义了很多按键值，这些按键值定义在include/uapi/linux/input.h文件中 + 申请结构体 ```c struct input_dev *input_allocate_device(void) ``` > 得到一个input结构体 + 注销结构体 ```c void input_free_device(struct input_dev *dev) ``` + 注册input_dev驱动 ```c int input_register_device(struct input_dev *dev) ``` + 卸载驱动 ```c void input_unregister_device(struct input_dev *dev) ``` + 初始化结构体 ```c 10\t/*********第一种设置事件和事件值的方法***********/ 11\t__set_bit(EV_KEY,inputdev >evbit);/* 设置产生按键事件*/ 12\t__set_bit(EV_REP,inputdev >evbit);/* 重复事件*/ 13\t__set_bit(KEY_0,inputdev >keybit);/*设置产生哪些按键值*/ 16\t/*********第二种设置事件和事件值的方法***********/ 17\tkeyinputdev.inputdev > evbit[0] BIT_MASK(EV_KEY) \t\t\t\t\t\t\t\t\t\t\tBIT_MASK(EV_REP); 18\tkeyinputdev.inputdev >keybit[BIT_WORD(KEY_0)] \t\t\t\t\t\t\t\t\t\t\tBIT_MASK(KEY_0); 21\t/*********第三种设置事件和事件值的方法***********/ 22\tkeyinputdev.inputdev >evbit[0] BIT_MASK(EV_KEY) \t\t\t\t\t\t\t\t\t\tBIT_MASK(EV_REP); 23\tinput_set_capability(keyinputdev.inputdev,EV_KEY,KEY_0); ``` + 上报事件 对于按键来说就是在按键中断或者销抖函数中获取按键的按下的情况, 然后上报, 可以使用 ```c void input_event(struct input_dev *dev, unsigned int type, \t\t\t\t\t\t\tunsigned int code, int value) ``` > dev：需要上报的input_dev。type:上报的事件类型，比如EV_KEY。code：事件码，也就是我们注册的按键值，比如KEY_0、KEY_1等等。value：事件值，比如1表示按键按下，0表示按键松开。 这个函数是用来提供所有时间的, linux也有专门的函数处理特定的事件, ```c staticinline void input_report_key(struct input_dev *dev , unsigned int code,int value) { input_event(dev,EV_KEY,code,!!value); } ``` > 对于按键而言, 也可以使用这个 + 上报完成之后使用函数进行同步, 实际上也是一个事件, 同步事件 ```c void input_sync(struct input_dev *dev) ``` ```c 1\t/* 用于按键消抖的定时器服务函数*/ 2\tvoidtimer_function(unsignedlongarg) 3\t{ 4\t\tunsigned char value; 5 6\t\tvalue gpio_get_value(keydesc >gpio);/* 读取IO值*/ 7\t\tif(value 0){/* 按下按键*/ 8\t\t/* 上报按键值*/ 9\t\tinput_report_key(inputdev,KEY_0,1);/* 1，按下*/ 10\t\tinput_sync(inputdev);/* 同步事件*/ 11\t\t}else{/* 按键松开*/ 12\t\t\tinput_report_key(inputdev,KEY_0,0);/*0，松开*/ 13\t\t\tinput_sync(inputdev);/* 同步事件*/ 14\t\t} 15\t} ``` ### 最后的结果 内核使用input_event这个结构体来表示所有的输入事件，input_envent结构体定义在include/uapi/linux/input.h文件中 ```c struct input_event { \tstruct timeval time; \t__u16 type; \t__u16 code; \t__s32 value; }; ``` > time：时间，也就是此事件发生的时间 > > ```c > struct timeval { > \t__kernel_time_t\t\ttv_sec;\t\t/* seconds */ > \t__kernel_suseconds_t\ttv_usec;\t/* microseconds */ > }; > ``` > > > 都是long类型的 > > type：事件类型，比如EV_KEY, code：事件码，比如在EV_KEY事件中code就表示具体的按键码, value：值，比如EV_KEY事件中value就是按键值，表示按键有没有被按下 ## 测试 ``` /lib/modules/4.1.15 # hexdump /dev/input/event1 0000000 4497 0000 8ac1 0008 0001 000b 0001 0000 0000010 4497 0000 8ac1 0008 0000 0000 0000 0000 0000020 4497 0000 1167 000a 0001 000b 0000 0000 0000030 4497 0000 1167 000a 0000 0000 0000 0000 ``` > 使用这个命令返回的就是上面的input_event结构体 hexdump是Linux下的一个二进制文件查看工具，它可以将二进制文件转换为ASCII、八进制、十进制、十六进制格式进行查看。 32位表示秒, 32位表微秒, 16位的时间类型, 16位按键码, 32位状态 ``` 0000000 4497 0000 8ac1 0008 0001 000b 0001 0000 编号 秒 微秒 type code value ``` EV_KEY事件值为1，EV_SYN事件值为0。因此第1行表示EV_KEY事件，第2行表示EV_SYN事件, KEY_0这个按键编号为11，对应的十六进制为0xb ## 软件编写 通过读取文件得到的形式是input_event形式的 根据结构体的各个数值进行使用, 一般key作为键盘使用, button为按键 ## Linux自带的驱动 Device driver > Input device support > * Generic input layer (needed for keyboard, mouse, ...) , keyboard > GPIO Buttons drivers/input/keyboard/gpio_keys.c文件 ```c gpio_keys { compatible \"gpio keys\"; #address cells <1>; #size cells <0>; autorepeat; pinctrl name \"default\"; pinctrl 0 <&pinctrl_key>; status \"okay\"; key0 { label \"GPIO KEY Enter\"; linux,code <KEY_ENTER>; gpios <&gpio1 18 GPIO_ACTIVE_HIGH>; }; }; ``` > 设置为回车键"},"/note/Linux/原子Linux/2022-9-2-MISC.html":{"title":"MISC","content":" layout: post title: \"MISC\" date: 2022 9 3 15:39:08 +0800 tags: 嵌入式 原子Linux # MISC 混合的, 混杂的, 有一些外设不能进行分类的时候就使用MISC驱动, 其实就是最简单的字符驱动, 嵌套在platform之中 所有的MISC设备驱动的主设备号都为10，不同的设备使用不同的从设备号 MISC设备会自动创建cdev，不需要像我们以前那样手动创建 我们需要向Linux注册一个miscdevice设备 ```c struct miscdevice { \tint minor;//次设备号 \tconst char *name; \tconst struct file_operations *fops;//用户填写 \tstruct list_head list; \tstruct device *parent; \tstruct device *this_device; \tconst struct attribute_group **groups; \tconst char *nodename; \tumode_t mode; }; ``` > 驱动编写的核心就是初始化file_operations, name就是此MISC设备名字，当此设备注册成功以后就会在/dev目录下生成一个名为name的设备文件 Linux系统已经预定义了一些MISC设备的子设备号，这些预定义的子设备号定义在`include/linux/miscdevice.h`文件中, 定义为255 > 动态分配 使用函数向内核注册 ```c int misc_register(struct miscdevice * misc) ``` > `misc`：要注册的MISC设备。返回值：负数，失败；0，成功。 > > ```c > 1\talloc_chrdev_region();/* 申请设备号*/ > 2\tcdev_init();/* 初始化cdev */ > 3\tcdev_add();/* 添加cdev */ > 4\tclass_create();/* 创建类*/ > 5\tdevice_create();/* 创建设备*/ > ``` > > 相当于以上的函数的集合 ```c int misc_deregister(struct miscdevice *misc) ``` > 用来卸载, 相当于所有卸载函数的结合"},"/note/Linux/原子Linux/2022-8-20-系统烧写.html":{"title":"系统烧写","content":" layout: post title: \"系统烧写\" date: 2022 8 20 15:39:08 +0800 tags: 嵌入式 原子Linux # 系统烧写 ![image 20251021095937676](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510210959733.png) 在windows下使用NXP的`nmfgtool`来向开发板烧写系统, 使用线吧USBOTG连接到电脑上, 工具是先下载一个系统, 然后通过系统完成烧写 使用OTG烧写的时候把SD卡拔出来, 链接好以后就好了, 烧写系统都是从NADA或者eMMc里面 选择对应的脚本 ## Linux 首先下载一个系统到SD卡, 然后从SD卡启动, 启动后在Linux中执行烧写"},"/note/Linux/原子Linux/2022-8-23-移植.html":{"title":"移植","content":" layout: post title: \"移植\" date: 2022 8 23 15:39:08 +0800 tags: 嵌入式 原子Linux # 移植 将NXPuboot 拷贝 一个开发板运行uboot, DDR, 串口 ,SD卡, EMMC, NAND等需要存在, 板子可以工作, 一般情况下不会更改 直接移植, 测试结果, 可以正常启动, lcd初始化不对, 网咯初始化失败, DDR, emmc初始化正常, 串口正常 ## 添加自己的驱动 ### 添加默认配置文件 借鉴NXP官方板子 首先复制官方的configs文件夹下的配置文件, 找到对应的文件夹 添加的头部信息就是broad/mx6ullevk文件夹下的imximage.cfg文件 ### 添加对应的头文件信息 每一个板子都有唯一的头文件信息, 存放于include文件夹下的configs文件夹中 更改broad文件夹下的文件 更改arch/cpu/armv7/mx6文件夹下的Kconfig文件夹 ### 解决驱动问题 #### lcd 修改的文件就是, mx6ull_jiao_emmc.h和mx6ull_jiao_emmc.c文件 由于使用的引脚相同, 不需要更改, 保存在c文件的lcd_pads数组中, 各种初始化正确, lcd参数`struct display_info_t const displays[]`结构体的fb_videomode就是lcd的参数 > 具体参数 > > .bus >lcd寄存器首地址 > > .pixfmt > 像素格式 > > detect > 函数不需要 > > .enable > 函数, 进行初始化, 初始化时钟, 复位, 设置背光为高电平 > > .mode > 屏幕的参数, 根据屏幕的参数进行设置, 唯一不同的是.pixclock, 使用的是 (1/时钟频率)*10^12^ 显示一个像素使用的时间 头文件中的对应的屏幕的名字也要更改, panel环境变量中存储 #### 网络 内部有个以太网MAC外设，也就是ENET，需要外接一个PHY芯片来实现网络通信功能, 没有内部MAC的CPU中，比如三星的2440，4412等，就会采用DM9000来实现联网功能。DM9000提供了一个类似SRAM的访问接口，主控CPU通过这个接口即可与DM9000进行通信，DM9000就是一个MAC+PHY芯片 6ULL采用内部的MAC加尾部的PHY, 官方使用的是KSZ8081, 正点原子使用的是LAN8720A芯片, 因此要修改驱动 8720有一个管理接口, 叫做MDIO和MDC, , 一个MDIO接口管理32个PHY芯片, 通过PHY ADDR来访问, ALPHA开发板ENET1使用的0x0, ENET2使用的是0x1, 通过有一个引脚进行设置上拉的时候为1 每一个都有一个复位引脚, 1和2分别使用SNVS TAMPER7和8两个复位引脚 驱动, 芯片的寄存器要进行配置, 前32个寄存器要求必须一样, 通用的, 理论上不需要修改, 在drivers/net/phy/phy.c ## 配置文件讲解 ### imx6ull_jiao_emmc.h 还可以进行超频, 在设备树imx6ull.dtsi文件, arch/arm/boot/dts, 在cpu0设备树中添加696000 1225000 对于低性能的板子可以用来超频 ### `emmc`使能 一般使用八根线, 对应节点是usdhc2节点, 已经修改完成(复制官方的代码) ### 网络驱动 在做驱动调试的时候一般是通过网络进行的, 使能对应的驱动, 在图形化界面中 Device Drivers >[\\*] Network device support > * PHY Device support and infrastructure ><*> Drivers for SMSC PHYs 使用SMSC的驱动然后重新编译, 启动 ### 根文件系统的构建 ROOTFS(根文件系统), 不等于FATFS, FATFS属于Linux你为内核第一部分, 属于软件代码, 根文件系统就是一堆的软件, 配置文件等, 是Linux运行必须的 内核只有6M, 其余的都是根文件系统, 根文件系统就是一个\"文件夹\", 无法放到内核中, 比如命令, 库, 配置文件等等, 所有的软件就需要我们自己构建 #### busybox 构建根文件系统, 最基础的构建方法, 还有很多更成熟的根文件系统buildroot, yocto等, 提供常用的功能命令 构建的根文件系统通过网络挂载, 也就是存放在ubuntu, 开发板启动后使用nfs使用 ##### 使用 修改makefile, 添加交叉编译器, 添加架构ARCH和CROSS_COMPILE 修改为中文支持, 修改printable_string.c文件, unicode.c文件 有几种配置defconfig, 默认, allyesconfig全部配置, allnoconfig最小配置 打开图形化配置界面 编译指定编译的目录 ##### 库文件 使用交叉编译期的库文件, `cp d`拷贝符号链接 先是rootfs/lib 然后是rootfs/usr/lib ##### 创建其他文件夹 ## MfgTool烧写工具 基本原理, 先下载一个Linux系统, 然后使用已经运行的系统完成系统烧写工作, E:\\mfgtools with rootfs\\mfgtools\\Profiles\\Linux\\OS Firmware文件夹下的firmware文件夹下的是zImage文件以及dtb文件uboot文件, files文件是文件的根文件系统, 以及对应的dtb [(126条消息) linux 使用SD卡做根文件系统_qinyun188的博客 CSDN博客](https://blog.csdn.net/qinyun188/article/details/8955201)"},"/note/Linux/原子Linux/2022-8-12-LinuxC.html":{"title":"LinuxC","content":" layout: post title: \"LinuxC\" date: 2022 8 12 15:39:08 +0800 tags: 嵌入式 原子Linux # LinuxC 交叉编译器: 编译使用在其他架构的编译器 ## 编译 `gcc`编译器 `gcc c`: 只编译不连接 `gcc v`: 显示编译过程 `gcc o`: 设置输出文件的名字 `gcc g`: 添加调试信息 `gcc O`: 优化编译 `gcc O2`: 进一步优化"},"/note/Linux/原子Linux/2022-9-10-WIFI.html":{"title":"WIFI","content":" layout: post title: \"WIFI\" date: 2022 9 5 15:39:08 +0800 tags: 嵌入式 原子Linux # WIFI 支持两种WIFI, USB和SDIO其中USB使用的是RTL8188EUS或RTL8188CUS芯片, 还有SDIO接口 只需要添加模块到内核就可以了 需要把相关的文件添加到Linux内核之中, 之后通过图形化界面进行配置 + 配置USB支持 > Device Drivers > <\\*> USB support ><\\*> Support for Host side USB > <\\*> EHCI HCD (USB 2.0) support > <\\*>OHCI HCD (USB 1.1) support > <\\*> ChipIdea Highspeed Dual Role Controller > [\\*] ChipIdea device controller ​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t >[*] ChipIdea host controller + 配置WIFI > Device Drivers > [\\*] Network device support > [\\*] Wireless LAN ><*> IEEE 802.11 for Host AP (Prism2/2.5/3 and WEP/TKIP/CCMP) >[\\*] Support downloading firmware images with Host AP driver > [\\*] Support for non volatile firmware download + 配置IEEE > Networking support > \\* Wireless > [\\*] cfg80211 wireless extensions compatibility > <\\*> Generic IEEE 802.11 Networking Stack (mac80211) 使用 安装 sudo apt get install wireless tools sudo apt get install wpa_supplicant 扫描 + 配置 ```c // /etc/wpa_supplicant.conf文件 ctrl_interface /var/run/wpa_supplicant ap_scan 1 network { ssid \"jiao\" psk \"1234567890\" } ``` mkdir /var/run/wpa_supplicant p + 链接 ``` modprobe 8188eu\t//加载模块 ifconfig wlan0 up iwlist wlan0 scan wpa_supplicant D wext c /etc/wpa_supplicant.conf i wlan0 & //进行连接 udhcpc wlan0 ```"},"/note/Linux/原子Linux/2022-8-23-uboot图形化配置界面.html":{"title":"uboot图形化配置文件","content":" layout: post title: \"uboot图形化配置文件\" date: 2022 8 23 15:39:08 +0800 tags: 嵌入式 原子Linux # uboot图形化配置界面 通过终端配置 进入到源码根目录, 首先默认配置`make mx6ull_jiao_emmc_defconfig` 输入`make menuconfig`, 在打开之前要安装build essential, libncurses5, libncurses5 dev 图形化配置界面对于一个功能有三种模式, y对应的功能编译, n不编译进uboot,m对应的功能编译为模块, 使用斜杠进行搜索, ## Kconfig文件 图形化界面配置文件,"},"/note/Linux/原子Linux/2022-8-12-开发环境搭建.html":{"title":"开发环境搭建","content":" layout: post title: \"开发环境搭建\" date: 2022 8 12 15:39:08 +0800 tags: 嵌入式 原子Linux # 开发环境搭建 ## 文件的互传 xftp用来传递文件, 通过网络实现 FTP环境, 下载`vsftpd`软件 `sudo vim /etc/vsftpd.conf`把local_enable和write_enable改为Yes ```bash jiao@jiao virtual machine:~/桌面/test/c_language$ sudo /etc/init.d/vsftpd restart [ ok ] Restarting vsftpd (via systemctl): vsftpd.service. ``` > 重启 ### Windows下FileZilla 文件 > 站点 >新建站点 使用Ubuntu的IP以及用户名地址 ## NFS和SSH开启 ### nfs ```bash jiao@jiao virtual machine:~/公共的$ sudo apt get install nfs kernel server portmap jiao@jiao virtual machine:~$ mkdir linux jiao@jiao virtual machine:~$ cd linux jiao@jiao virtual machine:~/linux$ mkdir nfs jiao@jiao virtual machine:~/linux$ vim /etc/exports jiao@jiao virtual machine:~/linux$ sudo vim /etc/exports jiao@jiao virtual machine:~/linux$ sudo /etc/init.d/nfs kernel server restart ``` 创建一个文件夹 在文件/etc/exports中添加 ```bash 12 /home/jiao/linux/nfs *(rw,sync,no_root_squash) ``` 然后重启 ### ssh ```bash jiao@jiao virtual machine:~/linux$ sudo apt get install openssh server ``` 安装 使用默认 ## CH340串口驱动 连接开发板之后直接使用软件 ## SecureCRT 高级的窗口调试助手 收费 使用xshell ## 交叉编译器 ### 编译arm可以使用的软件 使用`Linaro`公司的编译器 `arm linux gnueabihf gcc` ### ftp ```bash sudo apt get install openssh server sudo service sshd start ```"},"/note/Linux/原子Linux/2022-9-3-I2C.html":{"title":"I2C","content":" layout: post title: \"I2C\" date: 2022 9 3 15:39:08 +0800 tags: 嵌入式 原子Linux # I2C 分为I2C控制器驱动, 由原厂进行编写, 还有具体的设备驱动, 由我们自己编写 之前使用的platform是虚拟出来的总线, I2C可以自己作为一条总线, 重点就是I2C是适配器 ## 总线驱动 重要的数据结构:i2c_adapter和i2c_algorithm,定义在`include/linux/i2c.h`文件中 驱动是i2c imx.c文件, 使用platform从设备树获取设备 定义一个物理的控制器 或者说I2C适配器驱动的主要工作就是初始化i2c_adapter结构体变量，然后设置i2c_algorithm中的master_xfer函数, 这个函数用来进行I2C读写操作, 还实现了一个functionality函数, 用于返回可以提供的功能 ```c int i2c_add_adapter(struct i2c_adapter *adapter) int i2c_add_numbered_adapter(struct i2c_adapter*adap) ``` > 注册结构体, 这个结构体中的i2c_algorithm包含了IIC控制器访问的接口函数, 需要实现 ```c void i2c_del_adapter(struct i2c_adapter * adap) ``` > 删除 ## 设备驱动 + i2c_client结构体 定义在`include/linux/i2c.h`文件中 ```c struct i2c_client { \tunsigned short flags;\t\t/* div., see below\t\t*/ \tunsigned short addr; /* chip address NOTE: 7bit\t*/ \t\t\t\t\t/* addresses are stored in the\t*/ \t\t\t\t\t/* _LOWER_ 7 bits\t\t*/ \tchar name[I2C_NAME_SIZE]; \tstruct i2c_adapter *adapter;\t/* the adapter we sit on\t*/ \tstruct device dev;\t\t/* the device structure\t\t*/ \tint irq;\t\t\t/* irq issued by device\t\t*/ \tstruct list_head detected; #if IS_ENABLED(CONFIG_I2C_SLAVE) \ti2c_slave_cb_t slave_cb;\t/* callback for slave mode\t*/ #endif }; ``` > 描述具体的设备, flgs: 标志, addr芯片的地址, 7位放在低位, adapter: 使用的控制器 不需要自己创建i2c_client, 通过设备树来告诉 ```c &i2c1 { \tclock frequency <100000>; \tpinctrl names \"default\"; \tpinctrl 0 <&pinctrl_i2c1>; \tstatus \"okay\"; \tmag3110@0e { \t\tcompatible \"fsl,mag3110\"; \t\treg <0x0e>; \t\tposition <2>; \t}; \tfxls8471@1e { \t\tcompatible \"fsl,fxls8471\"; \t\treg <0x1e>; \t\tposition <0>; \t\tinterrupt parent <&gpio5>; \t\tinterrupts <0 8>; \t}; }; ``` > 一般在这里添加具体的芯片, 系统在解析的时候就会知道然后创建对应的i2c_client + i2c_driver结构体 需要驱动编写人员进行编写, ```c struct i2c_driver { \tunsigned int class; \t/* Notifies the driver that a new bus has appeared. You should avoid \t * using this, it will be removed in a near future. \t */ \tint (*attach_adapter)(struct i2c_adapter *) __deprecated; \t/* Standard driver model interfaces */ \tint (*probe)(struct i2c_client *, const struct i2c_device_id *); \tint (*remove)(struct i2c_client *); \t/* driver model interfaces that don't relate to enumeration */ \tvoid (*shutdown)(struct i2c_client *); \t/* Alert callback, for example for the SMBus alert protocol. \t * The format and meaning of the data value depends on the protocol. \t * For the SMBus alert protocol, there is a single bit of data passed \t * as the alert response's low bit (\"event flag\"). \t */ \tvoid (*alert)(struct i2c_client *, unsigned int data); \t/* a ioctl like command that can be used to perform specific functions \t * with the device. \t */ \tint (*command)(struct i2c_client *client, unsigned int cmd, void *arg); \tstruct device_driver driver; \tconst struct i2c_device_id *id_table; \t/* Device detection callback for automatic device creation */ \tint (*detect)(struct i2c_client *, struct i2c_board_info *); \tconst unsigned short *address_list; \tstruct list_head clients; }; ``` > 有参数probe和remove函数, 具体就是初始化这个然后注册 ```c int i2c_register_driver(struct module *owner, struct i2c_driver \t\t\t\t\t\t*driver) ``` > 注册函数 另外i2c_add_driver也常常用于注册i2c_driver，i2c_add_driver是一个宏 ```c #define i2c_add_driver(driver) i2c_register_driver(THIS_MODULE,driver) ``` ```c void i2c_del_driver(struct i2c_driver *driver) ``` > 删除 ### 没有使用设备树 需要在BSP里面使用i2c_board_info结构体来描述一个具体的I2C设备 ```c struct i2c_board_info { \tchar\t\ttype[I2C_NAME_SIZE]; \tunsigned short\tflags; \tunsigned short\taddr; \tvoid\t\t*platform_data; \tstruct dev_archdata\t*archdata; \tstruct device_node *of_node; \tstruct fwnode_handle *fwnode; \tint\t\tirq; }; ``` ### 使用设备树 ```c i2c1: i2c@021a0000 { #address cells <1>; #size cells <0>; compatible \"fsl,imx6ul i2c\", \"fsl,imx21 i2c\"; reg <0x021a0000 0x4000>; interrupts <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>; clocks <&clks IMX6UL_CLK_I2C1>; status \"disabled\"; }; &i2c1 { \tclock frequency <100000>;\t//总线时钟频率 \tpinctrl names \"default\";\t//两个引脚 \tpinctrl 0 <&pinctrl_i2c1>; \tstatus \"okay\";\t\t//打开控制器 \tmag3110@0e { \t\tcompatible \"fsl,mag3110\";\t//名字, 自己起 \t\treg <0x0e>;\t//具体的地址 \t\tposition <2>;\t//方向,可选 \t}; \tfxls8471@1e { \t\tcompatible \"fsl,fxls8471\"; \t\treg <0x1e>; \t\tposition <0>; \t\tinterrupt parent <&gpio5>; \t\tinterrupts <0 8>; \t}; }; ``` > 添加设备信息, 挂在到哪一个设备树下面就使用哪一个, 创建重点是compatible属性和reg属性的设置 ## 实际编写 1. 修改设备树, 添加相关的信息, 添加的地址属性是7位的地址 2. 挂载i2c_driver结构体i2c_add_driver, i2c_del_driver 3. 初始化这个结构体 ```c static int ap3216c_probe(struct i2c_client *client, const \t\t\t\t\t\t\t\t\tstruct i2c_device_id *id); static int ap3216c_remove(struct i2c_client *client); //设备树匹配表 static struct of_device_id ap3216c_of_match[] { {.compatible \"jiao,ap3216c\"}, {/* sentinel */}, }; //传统匹配表 static struct i2c_device_id ap3216c_id[] { {\"jiao,ap3216c123\",0}, {} }; static struct i2c_driver ap3216c_driver { .probe ap3216c_probe, .remove ap3216c_remove, .driver { .name \"ap3216c\", .owner THIS_MODULE, .of_match_table of_match_ptr(), //设备树匹配方式 }, .id_table ap3216c_id, //老版本的匹配方式 }; ``` > 两种方法一同使用的时候才可以正常使用, id_table必须存在, 但可以不匹配, 原因是probe的判断条件是只有两个都存在的时候才会进行 4. 使用字符设备 5. 通过IIC控制器中的函数进行发送接收数据 ```c int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num); ``` > 第一个参数, adap就是设备对应的适配器, 就是传入probe函数的第一个结构体的参数之一 > > ```c > struct i2c_msg { > \t__u16 addr;\t/* 从机地址*/ > \t__u16 flags;\t//标志, 就是下面的, 0表示发送 > #define I2C_M_TEN\t\t0x0010\t/* this is a ten bit chip address */ > #define I2C_M_RD\t\t0x0001\t/* read data, from slave to master */ > #define I2C_M_STOP\t\t0x8000\t/* if I2C_FUNC_PROTOCOL_MANGLING */ > #define I2C_M_NOSTART\t\t0x4000\t/* if I2C_FUNC_NOSTART */ > #define I2C_M_REV_DIR_ADDR\t0x2000\t/* if I2C_FUNC_PROTOCOL_MANGLING */ > #define I2C_M_IGNORE_NAK\t0x1000\t/* if I2C_FUNC_PROTOCOL_MANGLING */ > #define I2C_M_NO_RD_ACK\t\t0x0800\t/* if I2C_FUNC_PROTOCOL_MANGLING */ > #define I2C_M_RECV_LEN\t\t0x0400\t/* length will be first received byte */ > \t__u16 len;\t\t/* 消息的长度\t*/ > \t__u8 *buf;\t\t/* 消息\t\t\t*/ > }; > ``` > > > 不同的传输的数据 > > > > ```c > > struct i2c_client *client *dev >private_data; > > struct i2c_msg msg[2]; > > //发送要读取的寄存器 > > msg[0].addr client >addr; > > msg[0].flags 0; > > msg[0].buf &reg; //发送的数据，就是寄存器首地址 > > msg[0].len 1; > > //接受地址 > > msg[1].addr client >addr; > > msg[1].flags I2C_M_RD; > > msg[1].buf val; //接收 > > msg[1].len len; > > i2c_transfer(client >adapter, msg, 2); > > ``` > > > > > 根据协议, 首先发送寄存器首地址, 之后进行读取数据 > > > > ```c > > struct i2c_client *client dev >private_data; > > u8 b[256]; > > b[0] reg;\t//根据协议构建发送的数据 > > memcpy(&b[1], buf, len); > > struct i2c_msg msg; > > msg.addr client >addr; > > msg.flags 0; > > msg.buf b; //发送的数据 > > msg.len 1+len; > > return return i2c_transfer(client >adapter, msg, 1); > > ``` > > > > 也可以使用函数`i2c_smbus_read_byte_data`读取一个"},"/note/Linux/原子Linux/2022-8-24-驱动开发.html":{"title":"驱动开发","content":" layout: post title: \"驱动开发\" date: 2022 8 24 15:39:08 +0800 tags: 嵌入式 原子Linux # 驱动开发 根据`linux`的各种驱动框架进行开发, 一低要满足框架, 驱动最终的表现就是/dev/xxx文件, 就是文件的打开关闭读写, 现在新的内核支持设备树, dts文件描述板子的设备信息 分类, 有三种 + 字符设备, 最多的 + 块设备, 以固定的大小进行 + 网络设备驱动 > 一个设备可能不止属于一种类型, ## 记录uboot ``` > print baudrate 115200 board_name EVK board_rev 14X14 boot_fdt try bootargs console ttymxc0,115200 root /dev/mmcblk1p2 rootwait rw bootcmd tftp 80800000 zImage; tftp 83000000 imx6ull alientek emmc.dtb; bootz 80800000 83000000 bootcmd_mfg run mfgtool_args;bootz ${loadaddr} ${initrd_addr} ${fdt_addr}; bootdelay 3 bootfile imx6ull alientek emmc.dtb bootscript echo Running bootscript from mmc ...; source console ttymxc0 ethact FEC1 ethaddr 00:04:9f:04:d2:25 ethprime FEC fdt_addr 0x83000000 fdt_file undefined fdt_high 0xffffffff fileaddr 83000000 filesize 8d32 findfdt if test $fdt_file undefined; then if test $board_name EVK && test $board_rev 9X9; then setenv fdt_file imx6ull 9x9 evk.dtb; fi; if test $board_name EVK && test $board_rev 14X14; then setenv fdt_file imx6ull 14x14 evk.dtb; fi; if test $fdt_file undefined; then echo WARNING: Could not determine dtb to use; fi; fi; gatewayip 192.168.137.164 image zImage initrd_addr 0x83800000 initrd_high 0xffffffff ip_dyn yes ipaddr 192.168.137.164 loadaddr 0x80800000 loadbootscript fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script}; loadfdt fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file} loadimage fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image} mfgtool_args setenv bootargs console ${console},${baudrate} rdinit /linuxrc g_mass_storage.stall 0 g_mass_storage.removable 1 g_mass_storage.file /fat g_mass_storage.ro 1 g_mass_storage.idVendor 0x066F g_mass_storage.idProduct 0x37FF g_mass_storage.iSerialNumber \"\" clk_ignore_unused mmcargs setenv bootargs console ${console},${baudrate} root ${mmcroot} mmcautodetect yes mmcboot echo Booting from mmc ...; run mmcargs; if test ${boot_fdt} yes test ${boot_fdt} try; then if run loadfdt; then bootz ${loadaddr} ${fdt_addr}; else if test ${boot_fdt} try; then bootz; else echo WARN: Cannot load the DT; fi; fi; else bootz; fi; mmcdev 1 mmcpart 1 mmcroot /dev/mmcblk1p2 rootwait rw netargs setenv bootargs console ${console},${baudrate} root /dev/nfs ip dhcp nfsroot ${serverip}:${nfsroot},v3,tcp netboot echo Booting from net ...; run netargs; if test ${ip_dyn} yes; then setenv get_cmd dhcp; else setenv get_cmd tftp; fi; ${get_cmd} ${image}; if test ${boot_fdt} yes test ${boot_fdt} try; then if ${get_cmd} ${fdt_addr} ${fdt_file}; then bootz ${loadaddr} ${fdt_addr}; else if test ${boot_fdt} try; then bootz; else echo WARN: Cannot load the DT; fi; fi; else bootz; fi; netmask 255.255.255.0 panel TFT7016 script boot.scr serverip 192.168.31.187 Environment size: 2589/8188 bytes ``` ## 驱动开发测试 驱动就是获取外设, 传感器数据, 控制外设, 数据会提供给应用程序, Linux, 既要编写驱动, 又要编写简单的应用程序, Linux下这两方面是分开的 用户空间和内核空间, Linux操作系统在内核空间, 应用程序在用户空间, 只要是为了安全, 应用想要访问内核可以通过系统调用, 中断, 异常三种, 通常情况下是通过API调用, 比如说C库POSIX等 每一个系统调用号, 根据号码进行调用, 使用软终端 Linux一切皆文件, 使用open打开一个文件的时候, 应用程序通过write写入数据进行操作, 关闭使用close, 编写驱动的时候, 也需要编写对应的open, write, close函数, 使用file_operations进行编写 ### 框架 字符设备编写主要就是对应的file_operations, 保存在内核include/linux/fs.h文件夹中, 对其成员变量的实现 ### 加载卸载 可以编译到内核里面, 也可以编译为模块.ko, 测试的时候加载模块就可以了, 使用两个函数进行 ``` module_init(xxx_init); moudle_exit(xxx_exit); ``` 模块的加载卸载 ### Makefile ```makefile 1\tKERNELDIR: /home/zuozhongkai/linux/IMX6ULL/linux/temp/linux imx rel_imx_4.1.15_2.1.0_ga_alientek 2\tCURRENT_PATH: $(shell pwd) 3\tobj m: chrdevbase.o 4 5\tbuild:kernel_modules 6 7\tkernel_modules: 8\t\t$(MAKE) C $(KERNELDIR) M $(CURRENT_PATH) modules 9\tclean: 10\t\t$(MAKE) C $(KERNELDIR) M $(CURRENT_PATH)clean ``` C切换make使用的目录, M 要编译的模块的目录, fatload mmc 1:1 80800000 zImage; fatload mmc 1:1 83000000 imx6ull alientek emmc.dtb; bootz 80800000 830000008300 ### 调试 加载模块有两个命令, insmode和modprobe, 前者不能处理依赖关系 默认回到会到/lib/moudles/目录中查找模块, 创建对应的文件夹, 然后创建4.1.15文件夹存放模块, 使用`depmod`进行创建 这里使用 ``` /lib/modules # tftp g r chardevbase.ko 192.168.31.187 chardevbase.ko 100% ******************************** 2827 0:00:00 ETA 上传 tftp p l c:\\User\\Administrator\\Download 1.2.3.4 ``` depmod: 加载新的 lsmod: 查看当前的驱动 modprobe: 加载存在的 rmmod: 卸载 > 第一次加载提示licence, 需要在编写的时候添加 > > ``` > MODULE_LICENSE(\"GPL\") > ``` > > 测试记载退出函数的时候使用printk, 这是内核中的函数, printf是在用户态时候使用的函数, 在内核中输出的时候使用, 可以根据等级对信息进行分类 有八个等级 + \\#define KERN_SOH\"\\001\" + #define KERN_EMERG KERN_SOH \"0\"/* 紧急事件，一般是内核崩*/ + #define KERN_ALERT KERN_SOH \"1\"/* 必须立即采取行动*/ + #define KERN_CRIT KERN_SOH \"2\"/* 临界条件，比如严重的软件或硬件错误*/ + #define KERN_ERR KERN_SOH \"3\"/* 错误状态，一般设备驱动程序中使用KERN_ERR报告硬件错误*/ + #define KERN_WARNING KERN_SOH \"4\"/* 警告信息，不会对系统造成严重影响*/ + #define KERN_NOTICE KERN_SOH \"5\"/* 有必要进行提示的一些信息*/ + #define KERN_INFO KERN_SOH \"6\"/* 提示性的信息*/ + #define KERN_DEBUG KERN_SOH \"7\"/* 调试信息*/ ``` printk(KERN_EMERG \"gsmi: Log Shutdown Reason\\n\"); ``` printk默认MESSAGE_LOGLEVEL_DEFAULT, MESSAGE_LOGLEVEL_DEFAULT默认为4 CONSOLE_LOGLEVEL_DEFAULT控制着哪些级别的消息可以显示在控制台上，此宏默认为7，意味着只有优先级高于7的消息才能显示在控制台上 在`include/linux/printk.h` ## 真正的开发 在加载的时候注册字符设备, 退出的时候就会注销字符设备, 内核提供 ``` static inline int register_chrdev(unsigned int major, const \t\t\t char *name,const struct file_operations *fops) static inline void unregister_chrdev(unsigned int major, const \t\t\t\tchar *name) ``` > major是设备号, 每一个设备都有 > name: 设备名字 > fops: file_operations类型的指针, 有设备操作函数的集合 设备号, 为了方便管理, , 有主设备号次设备号, 通过dev_t进行管理, 在文件/include/linux/types.h文件中定义, 是一个u32_t类型, 高12位主设备号, 低20位次设备号, , 提供了三个宏进行操作, 在/include/linux/kdev_t.h + MAJOR(dev) + MINOR(dev): 通过dev_t获取两个设备号 + MKDEV(ma,mi): 组装设备号 注册字符设备的函数会把主设备号下面的所有次设备号进行使用, 所以很少使用 可以查看/proc/devices查看已经使用 要求实现的函数 ``` .owner YHIS_MODULE, .open , .realse , .read , .write , ``` > read在返回的时候不能直接给用户原来的函数, 使用函数copy_to_user > > 写的时候使用copy_to_user, 因为用户不能访问内核空间 ### APP编写 Linux man手册 手册分为很多的段 1是普通的命令 2是系统调用,如open,write之类的(通过这个，至少可以很方便的查到调用这个函数，需要加什么头文件) 3是库函数,如printf,fread 4是特殊文件,也就是/dev下的各种设备文件 5是指文件的格式,比如passwd, 就会说明这个文件中各个字段的含义 6是给游戏留的,由各个游戏自己定义 7是附件还有一些变量,比如向environ这种全局变量在这里就有说明 8是系统管理用的命令,这些命令只能由root使用,如ifconfig > 手册中可以参看使用的头文件, 相关的参数 ## 测试 加载驱动, 但是这时候没有显示在/dev目录下 ``` /lib/modules/4.1.15 # modprobe chardevbase.ko chrdevbase_init /lib/modules/4.1.15 # lsmod Module Size Used by Tainted: G chardevbase 1418 0 ``` 因为没有创建设备节点, 使用mknod命令`mknod /dev/设备名 c 主设备号, 次设备号`, c代表字符型设备 ``` /lib/modules/4.1.15 # mknod /dev/chardevbase c 200 0 ``` 可以使用atoi()函数把字符串转化为数字 ## file_operation ```C struct file_operations { \tstruct module *owner; \tloff_t (*llseek) (struct file *, loff_t, int); \tssize_t (*read) (struct file *, char __user *, size_t, loff_t *); \tssize_t (*write) (struct file *, const char __user *, size_t, loff_t *); \tssize_t (*read_iter) (struct kiocb *, struct iov_iter *); \tssize_t (*write_iter) (struct kiocb *, struct iov_iter *); \tint (*iterate) (struct file *, struct dir_context *); \tunsigned int (*poll) (struct file *, struct poll_table_struct *); \tlong (*unlocked_ioctl) (struct file *, unsigned int, unsigned long); \tlong (*compat_ioctl) (struct file *, unsigned int, unsigned long); \tint (*mmap) (struct file *, struct vm_area_struct *); \tint (*mremap)(struct file *, struct vm_area_struct *); \tint (*open) (struct inode *, struct file *); \tint (*flush) (struct file *, fl_owner_t id); \tint (*release) (struct inode *, struct file *); \tint (*fsync) (struct file *, loff_t, loff_t, int datasync); \tint (*aio_fsync) (struct kiocb *, int datasync); \tint (*fasync) (int, struct file *, int); \tint (*lock) (struct file *, int, struct file_lock *); \tssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int); \tunsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long); \tint (*check_flags)(int); \tint (*flock) (struct file *, int, struct file_lock *); \tssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int); \tssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int); \tint (*setlease)(struct file *, long, struct file_lock **, void **); \tlong (*fallocate)(struct file *file, int mode, loff_t offset, \t\t\t loff_t len); \tvoid (*show_fdinfo)(struct seq_file *m, struct file *f); #ifndef CONFIG_MMU \tunsigned (*mmap_capabilities)(struct file *); #endif }; ```"},"/note/Linux/原子Linux/2022-8-14-C语言点灯.html":{"title":"C语言点灯","content":" layout: post title: \"C语言点灯\" date: 2022 8 14 15:39:08 +0800 tags: 嵌入式 原子Linux # C语言点灯 ## 运行环境搭建 ### 设置处理器模式 设置处于SVC模式下, 超级管理员, 特权模式, 可以访问所有资源 设置CPSR寄存器0 4位设置为10011, 读写状态寄存器使用MRS和MSR指令, MRS指令读出, MSR写入寄存器 取反命令`BIC R0, R0, #某几 位` 或命令: `ORR R0, R0, #数字` ### 设施SP指针 SP可以指向内部RAM, 也可以指向DDR, 512M范围是0x80000000到0x9fffffff, 栈大小设置为2M A7处理器的栈处理方式为向下增长设置SP指向0x80200000地址 ### 跳转到C语言 使用B指令跳转到main函数 ### 设置寄存器的宏 ```C #define CCCM_CCGR0 *((volatile unsigned long*) 0x020c4068) ``` > volatile关键字用来在每次读取的时候都去操作内存而不是缓冲区 ## 编译 ```makefile %.o : %.c \tarm linux gnueabihf gcc Wall nostdlib c O2 o $@ $< ``` > ` Wal`l: 显示所有的警告 > > ` nostdlib`: 显示不链接标准启动文件"},"/note/Linux/原子Linux/2022-8-30-Linux内核定时器.html":{"title":"Linux内核定时器","content":" layout: post title: \"Linux内核定时器\" date: 2022 8 30 15:39:08 +0800 tags: 嵌入式 原子Linux # 内核定时器 ## Linux时间管理 Cortex M使用Systick作为系统定时器 定时器分为硬件定时器, 软件定时器, 原理是依靠系统定时器驱动, 硬件定时器提供时钟源，时钟源的频率可以设置，设置好以后就周期性的产生定时中断，系统使用定时中断来计时, 中断周期性产生的频率就是系统频率，也叫做节拍率(tickrate)(有的资料也叫系统频率) 可以通过图形化界面设置系统节拍率, 默认为100Hz, 定义在HZ变量中 ``` > Kernel Features \t > Timer frequency (<choice> [ y]) ``` 高节拍率会导致中断的产生更加频繁，频繁的中断会加剧系统的负担 Linux内核使用全局变量jiffies来记录系统从启动以来的系统节拍数，系统启动的时候会将jiffies初始化为0，jiffies定义在文件`include/linux/jiffies.h`中 ``` 76extern u64 __jiffy_data jiffies_64; 77extern unsigned long volatile __jiffy_data jiffies; ``` jiffies_64和jiffies其实是同一个东西，jiffies_64用于64位系统，而jiffies用于32位系统。为了兼容不同的硬件, jiffies其实就是jiffies_64的低32位 ![QQ图片20220830155110](https://blog 1308522872.cos.ap beijing.myqcloud.com/jhy/202301010001345.png) 如果`unkown`超过known的话，time_after函数返回真，否则返回假。如果`unkown`没有超过known的话time_before函数返回真，否则返回假。`time_after_eq`函数和`time_after`函数类似，只是多了判断等于这个条件 ![QQ图片20220830155441](https://blog 1308522872.cos.ap beijing.myqcloud.com/jhy/202301010001346.png) ## 内核定时器 软件定时器不是直接给周期值, 是设置周期满了以后的时间点, 然后会运行处理函数, 并关闭 Linux内核使用timer_list结构体表示内核定时器，timer_list定义在文件`include/linux/timer.h`中 expires成员变量表示超时时间，单位为节拍数 ```c struct timer_list { \tstruct list_head entry; \tunsigned long expires;/* 定时器超时时间，单位是节拍数*/ \tstruct tvec_base *base; \tvoid (*function) (unsigned long); /* 定时处理函数*/ \t\t\tunsigned long data; /* 要传递给function函数的参数, 可以用来传递自己的地址*/ \tint slack; }; ``` ### 函数 ```c void init_timer(structtimer_list *timer) ``` > 定义了一个timer_list变量以后一定要先用`init_timer`初始化一下 ```c void add_timer(struct timer_list *timer) ``` > 向Linux内核注册定时器，使用add_timer函数向内核注册定时器以后，定时器就会开始运行 ```c int del_timer(struct timer_list * timer) ``` > 删除一个定时器，不管定时器有没有被激活，都可以使用此函数删除。在多处理器系统上，定时器可能会在其他的处理器上运行，因此在调用del_timer函数删除定时器之前要先等待其他处理器的定时处理器函数退出 ```c int del_timer_sync(struct timer_list *timer) ``` > del_timer函数的同步版，会等待其他处理器使用完定时器再删除，del_timer_sync不能使用在中断上下文中。 ```c int mod_timer(struct timer_list *timer, unsigned long expires) ``` > 用于修改定时值，如果定时器还没有激活的话，mod_timer函数会激活定时器, expires：修改后的超时时间。返回值：0，调用mod_timer函数前定时器未被激活, 经常用于周期处理函数 ![QQ图片20220830164038](https://blog 1308522872.cos.ap beijing.myqcloud.com/jhy/202301010001347.png) ## 编写驱动 `ioctl`函数 ```c \tlong (*unlocked_ioctl) (struct file *, unsigned int, unsigned long); \tlong (*compat_ioctl) (struct file *, unsigned int, unsigned long); ``` 对应两个函数, 和应用中的ioctl函数对应, 但是在64位系统上32位程序调用后者, 32微系统调用前者 ```c static long timer_ioctl(struct file *filp, unsigned int cmd, unsigned long arg) ``` > cmd就是命令, arg是命令的参数 命令是自己定义的, 但是要符合规则, 其实就是一个数, 是一个32位的数字, 分为四段, 每一段的意义不同, 高8位是幻数, 用来区分不同的驱动, 8位序数, 2位的传输方向, 最低的14位是数据的大小 ### 函数 ``` #define _IO(type,nr)\t\t #define _IOR(type,nr,size)\t #define _IOW(type,nr,size)\t #define _IOWR(type,nr,size)\t ``` > 第一个, 没有参数的命令, 第二个命令是读取数据, 第三个写数据, 第四个双向数据传输, 三个参数对应幻数, 序数, 数据大小 > > ``` > #define SETPERIOD_CMD _IOW(0xef, 3, int) > ```"},"/note/Linux/原子Linux/2022-8-14-模仿stm32编程.html":{"title":"模仿stm32编程","content":" layout: post title: \"模仿stm32编程\" date: 2022 8 14 15:39:08 +0800 tags: 嵌入式 原子Linux # 模仿stm32编程 ## stm32寄存器结构体 使用一个结构体把所有的结构体放在一起 ### 清空bss段 ```arm .global _bss_start _bss_start: .word __bss_start .global _bss_end _bss_end: .word __bss_end ``` > `_bss_start`: 相当于变量的值 > > .word就是在这里放了一个值 ```` ldr r0, _bss_start; ldr r1, _bss_end; mov r2, #0 \tbss_loop: stmia r0!, {r2} @ 写入数据，然后地址加一 cmp r0, r1 ble bss_loop @ 小于等于的时候进行跳转 ```` ### 结构体 ```c #define CCM_BASE (0x20c4000) typedef struct{ volatile unsigned int CCR; volatile unsigned int CCDR; \t... }CCM_Typedef #define CCM ((CCM_Typedef *)RCC_BASE ) ``` > 注意没有相连的寄存器"},"/note/Linux/原子Linux/2022-9-7-块设备驱动.html":{"title":"块设备驱动","content":" layout: post title: \"块设备驱动\" date: 2022 9 7 15:39:08 +0800 tags: 嵌入式 原子Linux # 块设备 块设备是针对存储设备的，比如SD卡、EMMC、NAND Flash、NorFlash、SPI Flash、机械硬盘、固态硬盘等 块设备只能以块为单位进行读写访问，块是linux虚拟文件系统(VFS)基本的数据传输单位。字符设备是以字节为单位进行数据传输的，不需要缓冲 块设备在结构上是可以进行随机访问的，对于这些设备的读写都是按块进行的，块设备使用缓冲区来暂时存放数据，等到条件成熟以后在一次性将缓冲区中的数据写入块设备中。 ## 驱动 使用结构体block_device表示设备 ```c struct block_device { \tdev_t\t\t\tbd_dev; /* not a kdev_t it's a search key */ \tint\t\t\tbd_openers; \tstruct inode *\t\tbd_inode;\t/* will die */ \tstruct super_block *\tbd_super; \tstruct mutex\t\tbd_mutex;\t/* open/close mutex */ \tstruct list_head\tbd_inodes; \tvoid *\t\t\tbd_claiming; \tvoid *\t\t\tbd_holder; \tint\t\t\t\tbd_holders; \tbool\t\t\tbd_write_holder; #ifdef CONFIG_SYSFS \tstruct list_head\tbd_holder_disks; #endif \tstruct block_device *\tbd_contains; \tunsigned\t\tbd_block_size; \tstruct hd_struct *\tbd_part; \t/* number of times partitions within this device have been opened. */ \tunsigned\t\tbd_part_count; \tint\t\t\tbd_invalidated; \tstruct gendisk *\tbd_disk; \tstruct request_queue * bd_queue; \tstruct list_head\tbd_list; \t/* \t * Private data. You must have bd_claim'ed the block_device \t * to use this. NOTE: bd_claim allows an owner to claim \t * the same device multiple times, the owner must take special \t * care to not mess up bd_private for that case. \t */ \tunsigned long\t\tbd_private; \t/* The counter of freeze processes */ \tint\t\t\tbd_fsfreeze_count; \t/* Mutex for freeze */ \tstruct mutex\t\tbd_fsfreeze_mutex; }; ``` > 重点是bd_disk结构体, 表示一个磁盘对象, 类型为struct gendisk ```c int register_blkdev(unsigned int major, const char *name) ``` > 注册块设备, major：主设备号。name：块设备名字。如果major为0的话表示由系统自动分配主设备号，那么返回值就是系统分配的主设备号(1~255)，如果返回负值那就表示注册失败 ```c void unregister_blkdev(unsigned int major, const char *name) ``` > 注销块设备, major：要注销的块设备主设备号。name：要注销的块设备名字 + gendisk结构体 描述某一个磁盘设备 struct block_device_operations包含操作函数 > open函数用于打开指定的块设备。 > > release函数用于关闭(释放)指定的块设备。 > > rw_page函数用于读写指定的页。 > > ioctl函数用于块设备的I/O控制。 > > compat_ioctl函数和ioctl函数一样，都是用于块设备的I/O控制。区别在于在64位系统上，32位应用程序的ioctl会调用compat_iotl函数。在32位系统上运行的32位应用程序调用的就是ioctl函数。 > > getgeo函数用于获取磁盘信息，包括磁头、柱面和扇区等信息。 > > owner表示此结构体属于哪个模块，一般直接设置为THIS_MODULE。 ```c struct gendisk *alloc_disk(int minors) ``` > 申请一个结构体, minors：次设备号数量，也就是gendisk对应的分区数量。返回值：成功：返回申请到的gendisk，失败：NULL。 ```c void del_gendisk(struct gendisk *gp) ``` > 删除结构体gp：要删除的gendisk。返回值：无。 ```c void add_disk(struct gendisk *disk) ``` > 添加到内核, disk：要添加到内核的gendisk。返回值：无。 ```c void set_capacity(struct gendisk *disk, sector_t size) ``` > 设置磁盘的容量, disk：要设置容量的gendisk。size：磁盘容量大小，注意这里是扇区数量。块设备中最小的可寻址单元是扇区，一个扇区一般是512字节 ```c truct kobject *get_disk(struct gendisk *disk) void put_disk(struct gendisk *disk) ``` > 内核会通过get_disk和put_disk这两个函数来调整gendisk的引用计数，根据名字就可以知道，get_disk是增加gendisk的引用计数，put_disk是减少gendisk的引用计数 + struct request_queue: 请求队列 请求队列, 内核把读写请求发送到request_queue中, request_queue中是大量的request(请求结构体)，而request又包含了bio，bio保存了读写相关数据 ```c request_queue *blk_init_queue(request_fn_proc *rfn, spinlock_t *lock) ``` > 申请并初始化一个request_queue, rfn：请求处理函数指针，每个request_queue都要有一个请求处理函数`void (request_fn_proc) (struct request_queue *q)`, lock：自旋锁指针，需要驱动编写人员定义一个自旋锁，然后传递进来。，请求队列会使用这个自旋锁, 主要用于机械硬盘, 会使用电梯算法 > > 在绑定的函数中申请并进行处理 ```c void blk_cleanup_queue(struct request_queue *q) ``` > 卸载块设备驱动的时候我们还需要删除掉前面申请到的request_queue, q：需要删除的请求队列。返回值：无。 + 请求request request里面有一个名为“bio”的成员变量，类型为bio结构体指针。前面说了，真正的数据就保存在bio里面 ```c request *blk_peek_request(struct request_queue *q) ``` > 依次获取每个request ```c void blk_start_request(struct request *req) ``` > 处理这个请求 ```c structrequest *blk_fetch_request(structrequest_queue *q) ``` > 也可以使用blk_fetch_request函数来一次性完成请求的获取和开启 ```c struct request_queue *blk_alloc_queue(gfp_t gfp_mask) ``` > 用于只申请一个队列头 ```c void blk_queue_make_request(struct request_queue *q, make_request_fn *mfn) ``` > q：需要绑定的请求队列，也就是blk_alloc_queue申请到的请求队列。mfn：需要绑定的“制造”请求函数，函数原型如下`void (make_request_fn) (struct request_queue *q, struct bio *bio)`, 一般blk_alloc_queue和blk_queue_make_request是搭配在一起使用的，用于那么非机械的存储设备、无需I/O调度器，比如EMMC、SD卡等。 + bio结构体 每个request里面里面会有多个bio，bio保存着最终要读写的数据、地址等信息 上层会将bio提交给I/O调度器，I/O调度器会将这些bio构造成request结构，而一个物理存储设备对应一个request_queue，request_queue里面顺序存放着一系列的request。新产生的bio可能被合并到request_queue里现有的request中，也可能产生新的request 有可能会使用电梯调度算法, 主要是对硬盘使用, SD和emmc可以直接随机读取 ```c 1\tstruct bio { 2\tstruct bio *bi_next;/* 请求队列的下一个bio*/ 3\tstruct block_device *bi_bdev;/* 指向块设备*/ 4\tunsigned long bi_flags;/* bio状态等信息*/ 5\tunsigned long bi_rw;/* I/O操作,读或写*/ 6\tstruct bvec_iter bi_iter;/* I/O操作,读或写*/ 7\t.... 30\tstructbio_vec *bi_io_vec;/* bio_vec列表*/ 31 ... 33 \t}; ``` 包含的总要结构体: bvec_iter结构体描述了要操作的设备扇区等信息 ```c 1\tstruct bvec_iter { 2\t\tsector_t bi_sector;/*I/O请求的设备起始扇区(512字节)*/ 3\t\tunsignedintbi_size;/* 剩余的I/O数量*/ 4\t\tunsignedintbi_idx;/* blv_vec中当前索引*/ 5\t\tunsignedintbi_bvec_done;/*当前bvec中已经处理完成的字节数*/ 6\t}; ``` bio_vec结构体 ```c 1\tstruct bio_vec { 2\t\tstructpage *bv_page;/* 页*/ 3\t\tunsignedintbv_len;/* 长度*/ 4\t\tunsignedintbv_offset;/* 偏移*/ 5\t}; ``` ![QQ图片20220907173747](https://blog 1308522872.cos.ap beijing.myqcloud.com/jhy/202301010003326.png) ```c #define __rq_for_each_bio(_bio, rq) \\ \tif ((rq >bio)) \\ \t\t\tfor (_bio (rq) >bio; _bio; _bio _bio >bi_next) ``` > 遍历请求中所有bio并进行处理。这是一个宏 ```c #define bio_for_each_segment(bvl, bio, iter) \\ \t__bio_for_each_segment(bvl, bio, iter, (bio) >bi_iter) ``` > bio包 含了 最 终 要操 作的 数 据 ，因此还需要遍历bio中的所有段此函数也是一个宏 ```c unsigned long start blk_rq_pos(req) << 9; ``` > 获取操作的设备块的扇区首地址, 左移九位就是实际的地址 ``` unsigned long len blk_rq_cur_bytes(req); ``` > 获取处理的数据的长度 ```c void *buffer bio_data(req >bio); ``` > 获取bio的信息, 如果是读数据就会把读取到的数据保存在这个缓冲区中 > > 如果是写的话这个缓冲区保存要写入的数据 ```c rq_data_dir(req) ``` > 获取读写的方向 + 不使用电梯函数 ```c struct bio_vec bvec; struct bvec_iter iter; offset bio >bi_iter.bi_sector; //要操作的扇区偏移 bio_for_each_segment(bvec, bio, iter); //循环处理每一个段,两个数据结构体 ``` > 这是用来处理每一个bio的函数 ## 机械硬盘结构 盘片, 一个机械硬盘有多个盘片, 每一个盘片都有对应的读写磁头, 一般在5之内, 盘上面一圈一圈的叫磁道, 从圆心划线可以把他分割为多个弧段, 每个磁道上的一个弧段称为一个扇区, 扇区是最小单位, 每一个有512字节, 每一个盘面的编号相同的磁道组成的圆柱叫做柱面 容量的计算 磁头数 x 磁道数 x 每道扇区数 x 每一个扇区的字节数 ## 使用 ### 初始化 ```c //注册块设备 ramdisk.major register_blkdev(0, RAMDISK_NAME); if(ramdisk.major<0) { ret EINVAL; goto fail_ramdisk_register_file; } printk(\"major %d\\r\\n\", ramdisk.major); //申请gendisk ramdisk.gendisk alloc_disk(RAMDISK_MINOR); if(!ramdisk.gendisk) { ret EINVAL; goto gendisk_fail; } //初始化自旋锁 spin_lock_init(&ramdisk.lock); ``` ### 申请处理 + 使用电梯处理函数 ```c //申请并初始化队列 ramdisk.queue blk_init_queue(ramdisk_request_fn, &ramdisk.lock); if(!ramdisk.queue) { ret EINVAL; goto blk_queue_fail; } //具体的数据处理过程 static void ramdisk_transfer(struct request *req) { unsigned long start blk_rq_pos(req) << 9; //获取要操作的扇区的首地址 unsigned long len blk_rq_cur_bytes(req); void *buffer bio_data(req >bio); if(rq_data_dir(req) READ) { memcpy(buffer, ramdisk.ramdiskbuf + start, len); }else { memcpy(ramdisk.ramdiskbuf + start, buffer, len); } } ``` + 不使用 ```c ramdisk.queue blk_alloc_queue(GFP_KERNEL); if(!ramdisk.queue) { ret EINVAL; goto blk_queue_fail; } //绑定制造请求函数 blk_queue_make_request(ramdisk.queue, ramdisk_make_request); //制造请求函数 static void ramdisk_make_request(struct request_queue *queue, struct bio *bio) { int offset; struct bio_vec bvec; struct bvec_iter iter; offset bio >bi_iter.bi_sector<<9; //要操作的扇区偏移 bio_for_each_segment(bvec, bio, iter){ char *ptr page_address(bvec.bv_page) + bvec.bv_offset; //获取缓冲区 int len bvec.bv_len; //循环处理每一个段 if(bio_data_dir(bio) READ) { memcpy(ptr, ramdisk.ramdiskbuf + offset, len); }else { memcpy(ramdisk.ramdiskbuf + offset, ptr, len); } offset + len; } set_bit(BIO_UPTODATE, &bio >bi_flags); bio_endio(bio, 0); //告知处理结束 } ``` ### 设置参数 ```c ramdisk.gendisk >major ramdisk.major; ramdisk.gendisk >first_minor 0; ramdisk.gendisk >fops &ramdisk_fops; ramdisk.gendisk >private_data &ramdisk; ramdisk.gendisk >queue ramdisk.queue; sprintf(ramdisk.gendisk >disk_name, RAMDISK_NAME); set_capacity(ramdisk.gendisk, RAMDISK_SIZE/512); //设置容量 add_disk(ramdisk.gendisk); return 0; blk_queue_fail: put_disk(ramdisk.gendisk); gendisk_fail: unregister_blkdev(ramdisk.major, RAMDISK_NAME); fail_ramdisk_register_file: kfree(ramdisk.ramdiskbuf); ramalloc_fail: return ret; ``` ### 其他 ```c static int ramdisk_getgeo(struct block_device *dev, struct hd_geometry *geo) { //用来获取硬盘的信息 geo >heads 2; //磁头 geo >cylinders 32; //柱面 geo >sectors RAMDISK_SIZE/(2*32*512); //一个磁道的扇区数量 return 0; } ```"},"/note/Linux/原子Linux/2022-8-11-压缩解压缩.html":{"title":"压缩解压缩","content":" layout: post title: \"压缩解压缩\" date: 2022 8 11 15:39:08 +0800 tags: 嵌入式 原子Linux # 压缩解压缩 ## 7zip windows的压缩使用的软件, 支持多种格式 ## gzip命令 Linux压缩命令, 这一个一次只能压缩一个文件, 需要使用tar一起使用 + 压缩文件 ``` gzip 文件名 ``` + 解压缩文件 ```bash gzip d 文件名 ``` + 压缩所有文件不打包 ```bash gzip r 文件夹名 ``` ## bzip2命令 生成bz2压缩文件 > z压缩 > d解压缩 ## tar命令 打包功能 > c 新建归档 > x解除归档 > j: bzip2进行压缩 > z: gzip进行压缩 > f: 输出结果到文件或设备file + 进行打包 ```bash tar cvf 创建的文件.tar 源文件名 ``` + 压缩.bz2, 解压缩 ```bash tar vcjf 创建的文件.tar.bz2 源文件 tar vxjf 文件.tar.bz2 ``` + 压缩.gz ```bash tar vczf 创建的文件.tar.gz 源文件 tar vxzf 文件.tar.gz ``` ## Linux官网 www.kernel.org 下载Linux源码 http >Linux >kernel ## 其他格式 ### rar格式 + 压缩 ``` rar a 文件名.rar 源文件 ``` + 解压 ``` rar x 压缩包 ``` ### zip格式 + 压缩 ```bash zip rv 文件名.zip 源文件 ``` + 解压缩 ```bash unzip 压缩包 ```"},"/note/Linux/原子Linux/2022-8-31-阻塞非阻塞.html":{"title":"Linux中断","content":" layout: post title: \"Linux中断\" date: 2022 8 31 15:39:08 +0800 tags: 嵌入式 原子Linux # 阻塞非阻塞 IO指的是文件的输入输出 当应用程序对设备驱动进行操作的时候，如果不能获取到设备资源，那么阻塞式IO就会将应用程序对应的线程挂起，直到设备资源可以获取为止。 对于非阻塞IO，应用程序对应的线程不会挂起，它要么一直轮询等待，直到设备资源可以使用，要么就直接放弃, 会有超时处理 应用程序使用open打开驱动文件默认是用的是阻塞模式打开, 可以使用参数O_NONBLOCK打开文件, ## 等待队列 当设备文件不可操作的时候进程可以进入休眠态，这样可以将CPU资源让出来。但是，当设备文件可以操作的时候就必须唤醒进程，一般在中断函数里面完成唤醒工作。 等待队列是若干个休眠进程的集合 task想等待某种事件，那么调用wait_event（等待队列，事件）就可以了。 本质上就是：将进程线程状态设置为`TASK_UNINTERRUPTIBLE`状态，然后调用schedule将本线程程序调度出去。 ### 等待队列头 在驱动中使用等待队列，必须创建并初始化一个等待队列头，等待队列头使用结构体wait_queue_head_t表示, 在文件`include/linux/wait.h`中 ```c 39\tstruct __wait_queue_head { 40\t\tspinlock_t lock; 41\t\tstruct list_head task_list; 42\t}; 43\ttypedef struct __wait_queue_head wait_queue_head_t; ``` 定义好等待队列头以后需要初始化，使用init_waitqueue_head函数初始化等待队列头 ```c void init_waitqueue_head(wait_queue_head_t *q) ``` 也可以使用宏DECLARE_WAIT_QUEUE_HEAD来一次性完成等待队列头的定义的初始化。 ### 等待队列项 当设备不可用的时候就要将这些进程对应的等待队列项添加到等待队列里面 ```c struct __wait_queue { unsigned int flags; void *private; wait_queue_func_t func; struct list_head task_list; }; typedef struct __wait_queue wait_queue_t; ``` 使用宏DECLARE_WAITQUEUE定义并初始化一个等待队列项，宏的内容如下 ```c DECLARE_WAITQUEUE(name, tsk) ``` name就是等待队列项的名字，tsk表示这个等待队列项属于哪个任务(进程)，一般设置为current，在Linux内核中current相 当 于 一 个 全 局 变 量 ， 表 示 当 前 进 程 。 ### 把队列项添加到等待队列头 当设备不可访问的时候就需要将进程对应的等待队列项添加到前面创建的等待队列头中，只有添加到等待队列头中以后进程才能进入休眠态 ```c void add_wait_queue(wait_queue_head_t *q, wait_queue_t *wait) ``` > q：等待队列项要加入的等待队列头。wait：要加入的等待队列项 这里要使用这种格式 ```c __set_current_state(TASK_INTERRUPTIBLE); schedule(); //执行__schedule()这个函数是调度的核心处理函数，当前CPU会选择到下一个合适的进程去执行了, 这是上面的函数的拆分 //唤醒以后运行 if(signal_pending(current)) //判断是不是被信号唤醒的, 是的话退出 { ret ERESTARTSYS; goto data_error; } data_error: __set_current_state(TASK_RUNNING);\t//切换状态 remove_wait_queue(&&dev >r_wait, &wait); //移除对应 ``` > 设置当前进程为可以被打断的 ```c void remove_wait_queue(wait_queue_head_t *q, wait_queue_t*wait) ``` > q：要删除的等待队列项所处的等待队列头。wait：要删除的等待队列项。 ### 唤醒 ```c void wake_up(wait_queue_head_t *q) void wake_up_interruptible(wait_queue_head_t *q) ``` q就是要唤醒的等待队列头，这两个函数会将这个等待队列头中的所有进程都唤醒。 ### 进入休眠 ![QQ图片20220831175105](https://blog 1308522872.cos.ap beijing.myqcloud.com/jhy/202301010002100.png) ![QQ图片20220831175003](https://blog 1308522872.cos.ap beijing.myqcloud.com/jhy/202301010002101.png) 这种用于是由头部的休眠状态 ## 轮询 主要对应的是非阻塞方式, poll、epoll和select可以用于处理轮询, 当应用程序调用select、epoll或poll函数的时候设备驱动程序中的poll函数就会执行 以下的函数使用在应用中 ### select函数 ```c int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set \t\t*exceptfds, struct timeval *timeout) ``` > nfds:最大文件描述符加一, readfds、writefds和exceptfds：这三个指针指向描述符集合，这三个参数指明了关心哪些描述符、需要满足哪些条件等等，这三个参数都是fd_set类型的，fd_set类型变量的每一个位都代表了一个文件描述符。timeout:超时时间, 使用结构体timeval表示 > > readfds用于监视指定描述符集的读变化，也就是监视这些文件是否可以读取，只要这些集合里面有一个文件可以读取那么seclect就会返回一个大于0的值表示文件可以读取。如果没有文件可以读取，那么就会根据timeout参数来判断是否超时。可以将readfs设置为NULL，表示不关心任何文件的读变化。writefds和readfs类似，只是writefs用于监视这些文件是否可以进行写操作。exceptfds用于监视这些文件的异常 ```c void FD_ZERO(fd_set *set) void FD_SET(int fd, fd_set *set) void FD_CLR(int fd, fd_set *set) int FD_ISSET(int fd, fd_set *set) ``` > FD_ZERO用于将fd_set变量的所有位都清零 > > FD_SET用于将fd_set变量的某个位置1，也就是向fd_set添加一个文件描述符，参数fd就是要加入的文件描述符 > > FD_CLR用于将fd_set, 变量的某个位清零，也就是将一个文件描述符从fd_set中删除 > > FD_ISSET用于测试一个文件是否属于某个集合，参数fd就是要判断的文件描述符 ```c struct timeval { long tv_sec; /* 秒*/ long tv_usec; /* 微秒*/ }; ``` > 返回值：0，表示的话就表示超时发生，但是没有任何文件描述符可以进行操作； 1，发生错误；其他值，可以进行操作的文件描述符个数 ```c 1\tvoid main(void) 2\t{ 3\tintret, fd;/* 要监视的文件描述符*/ 4\tfd_set readfds;/* 读操作文件描述符集*/ 5\tstructtimeval timeout;/* 超时结构体*/ 6 7\tfd open(\"dev_xxx\",O_RDWR O_NONBLOCK);/* 非阻塞式访问*/ 8 9\tFD_ZERO(&readfds);/* 清除readfds */ 10\tFD_SET(fd,&readfds);/* 将fd添加到readfds里面*/ 11 12\t/* 构造超时时间*/ 13\ttimeout.tv_sec 0; 14\ttimeout.tv_usec 500000;/* 500ms */ 15 16\tret select(fd +1,&readfds,NULL,NULL,&timeout); 17\tswitch(ret){ 18\t\tcase0:/* 超时*/ 19\t\t\tprintf(\"timeout!\\r\\n\"); 20\t\t\tbreak; 21\t\tcase 1:/* 错误*/ 22\t\t\tprintf(\"error!\\r\\n\"); 23\t\t\tbreak; 24\t\tdefault:/* 可以读取数据*/ 25\t\tif(FD_ISSET(fd,&readfds)){/* 判断是否为fd文件描述符*/ 26\t\t\t/* 使用read函数读取数据*/ 27\t\t} 28\t\tbreak; 29\t} 30} ``` ### poll函数 select函数能够监视的文件描述符数量有最大的限制，一般为1024, 可以使用poll函数，poll函数本质上和select没有太大的差别，但是poll函数没有最大文件描述符限制 ```c int poll(struct pollfd *fds, nfds_t nfds, int timeout) ``` > `nfds：poll`函数要监视的文件描述符数量。timeout：超时时间，单位为ms ```c struct pollfd { int fd;/* 文件描述符*/ short events; /* 请求的事件*/ short revents; /* 返回的事件*/ }; ``` > fd是要监视的文件描述符, events是要监视的事件, 返回值：返回`revents`域中不为0的`pollfd`结构体个数，也就是发生事件或错误的文件描述符数量；0，超时； 1，发生错误 > > ```c > POLLIN 有数据可以读取。 > POLLPRI 有紧急的数据需要读取。 > POLLOUT可以写数据。 > POLLERR指定的文件描述符发生错误。 > POLLHUP指定的文件描述符挂起。 > POLLNVAL无效的请求。 > POLLRDNORM等同于POLLIN > ``` ```c while(1) { fds.fd fd; fds.events POLLIN; ret poll(&fds, 1, 500);\t//设置时间是500ms if(ret 0) {//错误 } else if(ret<0) {//超时 } else { if(fds.revents POLLIN){//检测结果是可读 ret read(fd, &data, sizeof(data)); if(ret<0) { }else { if(data) { printf(\"keyvalue %#X\\r\\n\", data); } } } } } ``` ### epoll函数 epoll就是为处理大并发而准备的，一般常常在网络编程中使用epoll函数 ### pull操作函数 select或poll函数来对驱动程序进行非阻塞访问的时候，驱动程序file_operations操作集中的poll函数就会执行 ```c unsigned int (*poll) (struct file *filp, struct poll_table_struct *wait) ``` > filp：要打开的设备文件(文件描述符)。wait：结构体poll_table_struct类型指针，由应用程序传递进来的。一般将此参数传递给poll_wait函数。返回值如下 ```c POLLIN 有数据可以读取。 POLLPRI 有紧急的数据需要读取。 POLLOUT可以写数据。 POLLERR指定的文件描述符发生错误。 POLLHUP指定的文件描述符挂起。 POLLNVAL无效的请求。 POLLRDNORM等同于 POLLIN，普通数据可读 ``` ```c void poll_wait(struct file * filp, wait_queue_head_t * wait_address, poll_table *p) ``` > poll_wait函数不会引起阻塞，只是将应用程序添加到poll_table中 > > 参数wait_address是要添加到poll_table中的等待队列头，参数p就是poll_table，就是file_operations中poll函数的wait参数 ### 后台 ```c static unsigned int imx6uirq_poll(struct file *filp, poll_table *wait) { int mask 0; struct imx6uirq_dev *dev filp >private_data; poll_wait(filp, &dev >r_wait, wait); if(atomic_read(dev >realsekey)) { //按键按下可读 mask POLLIN POLLRDNORM; } return mask; } ``` > 最终调用的都是这个函数, 自己测试大概是每一次定义时间开始结束的时候调用一次, 根据返回值, 上面的函数进行分析得出结果"},"/note/Linux/原子Linux/2022-8-13-开发板简介.html":{"title":"开发板简介","content":" layout: post title: \"开发板简介\" date: 2022 8 12 15:39:08 +0800 tags: 嵌入式 原子Linux # 开发板简介 `emmc5.1` 8GB DDR 512MRAM 800M频率 ## 外设 9V 24V电源, 外接屏幕的时候最好连接 两个100M网卡 RS282接口, 实际为串口, 和RS485一样通过跳帽选择 CAN接口 ## MX6U芯片 ARM处理器 i.MX6ULL最高支持900M频率 低功耗 一级缓存32K 二级缓存128K CortexA7内核 ## IO 表示形式 对于stm32 PA0 15 PB0 15 I.M6ULL: 管脚名字很长但只有最后用于分辨PAD_BOOT_MODE0 管脚的复用功能 IOMUXC_SNVS_SW_MUX_CTL_PAD_BOOT_MODE0: 代表的是复用 IOMUXC_SNVS_SW_PAD_CTL_PAD_BOOT_MODE0: 设置的是电气特性 对于查看管脚的复用的步骤, 要打开参考手册, 第32章节查找对应的管脚 一个IO有两个寄存器"},"/note/Linux/原子Linux/2022-8-28-led设备树.html":{"title":"led设备树","content":" layout: post title: \"led设备树\" date: 2022 8 28 15:39:08 +0800 tags: 嵌入式 原子Linux # led设备树 1. 建立节点 2. 编写驱动获取信息 3. 根据获取的值处理 设备节点最好添加到好找的地方"},"/note/Linux/原子Linux/2022-8-19-PWM.html":{"title":"PWM","content":" layout: post title: \"PWM\" date: 2022 8 19 15:39:08 +0800 tags: 嵌入式 原子Linux # PWM 十六位寄存器 有四个十六位FIFO, 有一个十二位分频器, 时钟进入计数器, 还有一个周期寄存器, 还有一个采样寄存器 是一个向上计数器, `PWMx_PWMPR` : 当计数的值等于PWMPR+1的时候会重新开始下一个周期, 实际的周期是这个的值加二 FIFO保存着采样值, 向PWMSAR寄存器写值的时候就是写入FIFO, 每输出一个PWM就会让FIFO中的数据减一, 直到FIFO为空的时候就不能产生PWM, FIFO为空的时候会产生中断, 可以这时候写入采样值 PWM_CR寄存器, bit0使能, bit1 2设置每一个数据使用的次数, bit3复位, bit4 15分频设置, 可以设置0 4095, bit16 17设置时钟源, 设置1, bit18 19设置输出的配置, 跳变的时间的设置设置为0, bit27 26空余数字为多少的时候产生中断, 设置为1就是空余大于2的时候 PWM_IRbit0为1开启空中断"},"/note/Linux/原子Linux/2022-8-19-SPI.html":{"title":"I2C","content":" layout: post title: \"I2C\" date: 2022 8 19 15:39:08 +0800 tags: 嵌入式 原子Linux # SPI 最高速度可以达到几十M, 甚至是全双工 有一个六轴传感器 可以连接多个外设, 有四根线, CS/SS片选信号, SCK时钟, MOSI/SDO主出从入, MISO主入从出 通过CS引脚拉低进行选择 引脚: 连接的是SPI3进行连接, UART2_ST_DATA >SCLK, UART2_CTS >MOSI, UART_TXD >SS0, UART2_RTS >MISO 6ULL一个主接口有四个硬件片选 四种模式: ①、CPOL 0，串行时钟空闲状态为低电平。 ②、CPOL 1，串行时钟空闲状态为高电平，此时可以通过配置时钟相位(CPHA)来选择具体的传输协议。 ③、CPHA 0，串行时钟的第一个跳变沿(上升沿或下降沿)采集数据。 ④、CPHA 1，串行时钟的第二个跳变沿(上升沿或下降沿)采集数据。 一般使用两个都为0的模式 6ULL的SPI接口, 叫做ECSPI, 支持全双工, 主从可以配置, 四个硬件片选, 可以使用软件片选 ## ICM 20608 六轴传感器, 三轴陀螺仪, 三轴加速度计 陀螺仪精度可以设置, 及速度分辨率可以设置, 陀螺仪和加速度计都是16位ADC, 可以使用I2C400K, SPI8M, I2C地址默认为110100x, x由引脚控制 寄存器: + ICM20608G的0x75寄存器 WHO_AM_I寄存器, 只读寄存器, 保存了ID默认值为0xaf + 0x3b 0x48为我们要读取的寄存器 读取的时候最少要有16个周期, 前八个发送寄存器地址, 后面的接收数据 在第七位数据决定读或者写 ## 寄存器 `ECSPIx_RXDATA`: 接收数据, 有32位但是一般使用低8位, 标志位为1的时候才可以读取 `ECSPIx_TXDATA`: 发送数据寄存器, 32位, 会自发送 `(ECSPIx_CONREG`: 配置寄存器, bit0使能SPI, bit3设置为1的时候在写入数据以后立即发送, 7 4硬件片选设置主从模式, 7为通道3, 我们是用SS0, 设置4为1, bit8 11分频设置2的n次方, bit12 15分频设置bit18 19设置为00通道选择, bit20 31突发访问长度设置为7也就是8bit长度 `ECSPIx_CONFIGREG`: bit0 3 设置PHA为四个通道, 每个通道一位, bit4 7, 设置POL, 都设置为0, 表示这是SCLK空闲为低电平, 第一个跳变沿读取, bit8 11控制片选的输出设置为0, bit12 15片选极性, 设置为0, bit16 19设置数据线空闲电平, 设置为0, bit20 23空闲时钟0 `ECSPIx_STATREG`: 状态寄存器, bit0等待发送完成为1, bit3接收, 有的时候为1, 在接收数据的时候等待为1, `ECSPIx_PERIODREG`: bit0 14等待状态时间长度, 两个传递数据之间, 设置为2000, bit15设置单位设置为0为时钟周期, bit16 21片选信号延时不需要使用 ## 时钟设置 `spi`时钟源最终来源于`pll3_sw_clk`这是一个480/8MHz是一个60MHz, 也可以设置为晶振(CCM_CSCDR2[ECSPI_CLK_SEL])bit18设置为0, bit19 24分频设置为0, 一分频, 最终为60Mhz `ECSPIx_CONREG`再次设置分频, ## 浮点 在使用浮点运算的时候会卡死, 应为没有使用硬件浮点, 并且没有在编译的时候加入浮点 ①开启浮点 ②编译时候开启` march armv7 a mfpu neon vfpv4 mfloat abi hard` ``` $(CC) Wall march armv7 a mfpu neon vfpv4 mfloat abi hard Wa, mimplicit it thumb nostdlib fno builtin c O2 $(INCLUDE) o $@ $< ``` 所有的A7\\内核打开浮点数 ```C void imx6ul_hardfpu_enable(void) { \tuint32_t cpacr; \tuint32_t fpexc; \t/* 使能NEON和FPU */ \tcpacr __get_CPACR(); \tcpacr (cpacr & ~(CPACR_ASEDIS_Msk CPACR_D32DIS_Msk)) \t\t (3UL << CPACR_cp10_Pos) (3UL << CPACR_cp11_Pos); \t__set_CPACR(cpacr); \tfpexc __get_FPEXC(); \tfpexc 0x40000000UL;\t \t__set_FPEXC(fpexc); } ```"},"/note/Linux/原子Linux/2022-8-17-RGBLED.html":{"title":"RGBLED","content":" layout: post title: \"RGBLED\" date: 2022 8 17 15:39:08 +0800 tags: 嵌入式 原子Linux # RGBLED ## 简介 + 像素点, 分辨率: 略 + 尺寸不变, 分辨率越高显示的效果越好 + PPI: 屏幕对角线的像素点数目, 除以对角线的英寸数字 + 像素格式: 对RGB颜色进行量化, 每一种使用8bit进行表示描述颜色, 现在也流行10bit, HDR10支持HDR效果的10bit面板, 在RGB888基础上再加上ALPHA通道也就是透明通道ARGB888 + 屏幕接口, RGB格式的屏幕一般为RGB接口屏 接口有MIPI, LVDS, MCU, RGB接口 6ULL支持这些接口 屏幕的ID: 使用不同的ID识别不同的屏幕, 在RGB的R7G7B7上焊接不同的上拉下拉电阻实现不同的ID 正点原子的底板使用了三个模拟开关, 防止影响启动(启动使用的引脚就是这几个LED屏幕的引脚) ## 时间参数 ### 水平 HSYNC是水平同步信号，也叫做行同步信号，当产生此信号的话就表示开始显示新的一行了, 出现的时候表示新的一行开始显示 显示的时序图 ![QQ图片20220817192305](https://blog 1308522872.cos.ap beijing.myqcloud.com/jhy/202212312359905.png) + HSYNS信号表示一行的开始, 维持的时间为HSPW 20 + 完成之后需要一段时间的延时, 叫做HBP 240 + 之后就是显示1024个像素数据, 也就是1024个时钟 1024 + 一行结束之后HFP时间等待下一行有效 160 ### 垂直 VSYNC信号是垂直同步信号，也叫做帧同步信号，当产生此信号的话就表示开始显示新的一帧图像了 ![QQ图片20220817194608](https://blog 1308522872.cos.ap beijing.myqcloud.com/jhy/202212312359906.png) + VSPW：有些地方也叫做`tvp`，是VSYNC信号宽度，也就是VSYNC信号持续时间，单位为1行的时间, 这个设置为三行的时间 + VBP：有些地方叫做`tvb`，术语叫做帧同步信号后肩，单位为1行的时间。这里为20 + LINE：有些地方叫做`tvd`，显示一帧有效数据所需的时间，假如屏幕分辨率为1024*600，那么LINE就是600行的时间 + VFP：所有行显示完成之后, 有些地方叫做`tvf`，术语叫做帧同步信号前肩，单位为1行的时间 12 总时间 (VSPW+VBP+LINE+VFP) * (HSPW + HBP + HOZVAL + HFP) 853440 那么显示60帧就是：853440*60 51206400≈51.2M，所以像素时钟就是51.2MHz。 ### 引脚 LCD_CLK引脚输出时钟 LCD_HSYNC: LCD_HSYMN: LCD_ENABLE: DE信号, 有效的时候显示屏幕的数据 ### 显存 显示存储空间, , 采用ARGB888, 一个像素是四字节, 必须存储起来, 一帧大概是2.5M内存留给显示使用 ## 实现 手册34章 使用DOTCLK接口也就是使用上面列出来的四种接口 ### 寄存器 > `LCDIF_CTRLn`: 通用控制, bit0必须为1, 开始传输数据, bit1设置数据24位设置为0, bit5设置工作在主机模式下, bit8 9输入的数据格式, 设置为3为24位, bit10 11数据传输宽度24位为3, bit12 13数据交换顺序, 设置为0, bit14 15输入交换0, bit17 DOTCLK模式为1, bit19根据模式为1, bit31设置为0不复位 > LCDIF_CTRL1n: bit16 19设置格式为24位ARGB 7 > LCDIF_TRANSFER_COUNT: bit0 15LCD屏幕水平像素, 16 31垂直像素 > LCDIF_VDCTRL0n: 设置性质的性质, bit0 17位VSPW, bit20` vsync`信号的单位设置为1行为单位, bit21设置为1, 周期的单位, bit24,25,26,27设置ENABLE系编号0低电平, DOTCLK时钟信号0上升沿有效, HSYNC, VSYNC极性设置0低电平有效, bit28ENABLE信号使能为1, bit29VSYNC输出, 设置为0 > LCDIF_VDCTRL1, VSYNC周期长度 > LCDIF_VDCTRL2: 0 17HSINC信号长度, 18 31HSYNC信号宽度`hspw` > LCDIF_VDCTRL3: bit0 15$vbp+vspw$, bit16 27: $hbp+hspw$ > LCDIF_VDCTRL4: bit0 17每一行像素点1024, bit18 为1 > LCDIF_CUR_BUF:缓存地址 > LCDIF_NEXT_BUF: 下一帧数据地址, 设置为一样的简单处理 > IO初始化 > 时钟设置 ### 时钟配置 LCD需要一个时钟, 这个时钟是CLK发送给RGBLED的大约为51.2MHz, LCDIF1_CLK_ROOT, 设置PLL5也就是`videoPLL`为时钟源, 有两个分频器 $$ PLL5_CLK OSC24M * (loopDivider + (denominator / numerator)) / postDivider $$ > 不使用分数进行配置 `CCM_ANALOG_PLL_VIDEOn[DIV_SELECT]`bit0 6寄存器, 可以选择27 24, bit20 19设置分频 CCM_ANALOG_MISC2n[VIDEO_DIV]另一个分频寄存器bit30 31为0 CCM_ANALOG_PLL_VIDEO_NUM分子寄存器设置为0 CCM_ANALOG_PLL_VIDEO_DENOM分母 CSCDR2[LCDIF1_PRE_CLK_SEL]nit17 15, 选择时钟源 , 设置为2选择PLL5, bit14 12位分频 CCM_CBCMR, bit23 25设施另一次分频 CCM_CSCDR2, bit9 11再次选择时钟, 设置为0 ## 编写 初始化之前读取屏幕的ID, 使用其他的屏幕不需要"},"/note/Linux/原子Linux/2022-8-17-串口.html":{"title":"串口","content":" layout: post title: \"串口\" date: 2022 8 17 15:39:08 +0800 tags: 嵌入式 原子Linux # 串口 第55章 最高位5MHz ## 格式 空闲位: 逻辑1 起始位: 逻辑0 数据位: 可以循着5 8位 奇偶校验位: 可以不使用 停止位: 传输结束可以选择1, 1.5, 2位高电平 波特率: 传输数据的速率, 每秒传递的数据位 ## 寄存器 `UARTx_URXD`: 串口接收到的寄存器保存的位置, 最低的8位 `UARTx_UTXD`: 数据发送寄存器, 发送的时候写入最低的8位 `UARTx_UCR1 4`: 控制器. `UARTx_UCR1`, bit0使能位, bit14自动检测波特率, 1的时候使能, `UARTx_UCR2`: bit0软件复位, 0的时候复位, 1是复位成功, bit1: 接收使能, bit2: 发送使能, bit5: 设置数据位, 0表示7位数据位, 1表示8位数据位, bit6设置停止位, 0为1位, 1为两位, bit7: 奇偶校验位, 0偶校验, bit8:是否使能校验, `UARTx_UCR3`: bit2必须一直设置为1 `UARTx_UFCR`: bit7 9设置分频值, 可以选择PCLL3除以6位80MHz, , 也可以选择晶振频率CSCDR1[UART_CLK_SEL]控制, CSCDR1\\[UART_CLK_PODF](bit0 5)控制再次分频 `UARTx_UFCR, UARTx_UBIR,UARTx_UBMR`:决定串口博得率, 寄 存 器`UARTx_UFCR`中我们要用到的是位RFDIV(bit9:7)，用来设置参考时钟分频 ![QQ图片20220817113440](https://blog 1308522872.cos.ap beijing.myqcloud.com/jhy/202212312359746.png) `UARTx_USR1 2`: 状态寄存器,`UARTx_USR2` bit0表示为1的时候有数据可以读取, bit3为1发送完成, ## 实现 使用UTART1串口UART1_TX_DATA, UART1_RX_DATA 在实现对于库函数的编写的时候要在` fno builtin` 在Linux下的编码方式为`utf 8` ## 移植printf函数 实际是从uboot中提取出来的, 移植模块, 提供`putc`和`getc` 在编译C文件的时候添加了选项“` Wa, mimplicit it thumb`”，否则的话会有如下类似的错误提示： ``` thumb conditional instruction should be in IT block 'addcs r5,r5,#65536' ``` 这里的不支持浮点数 "},"/note/Linux/原子Linux/2022-9-3-RTC.html":{"title":"RTC","content":" layout: post title: \"RTC\" date: 2022 9 2 15:39:08 +0800 tags: 嵌入式 原子Linux # RTC Linux内核将RTC设备抽象为rtc_device结构体，因此RTC设备驱动就是申请并初始化rtc_device，最后将rtc_device注册到Linux内核里面 结构体的重点是rtc_class_ops ## 设备树 ```c snvs_rtc: snvs rtc lp { compatible \"fsl,sec v4.0 mon rtc lp\"; regmap <&snvs>; offset <0x34>; interrupts <GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>, <GIC_SPI 20 IRQ_TYPE_LEVEL_HIGH>; }; ``` > lp就是掉电以后依旧有效 驱动文件rtc_snvs.c ## 使用内部的rtc 不需要配置, ```c imx6ul tsc: probe of 2040000.tsc failed with error 2 snvs_rtc 20cc000.snvs:snvs rtc lp: rtc core: registered 20cc000.snvs:snvs r as rtc0 i2c /dev entries driver ``` 在初始化的时候已经完成, 作为rtc0 使用date命令进行设置时间 使用 s命令进行设置时间, 使用hwclock保存到硬件"},"/note/Linux/原子Linux/2022-8-31-异步通知.html":{"title":"异步通知","content":" layout: post title: \"异步通知\" date: 2022 8 31 15:39:08 +0800 tags: 嵌入式 原子Linux # 异步通知 首先是硬件中断, 只要处理器设置好就不需要再去查看 信号 >软件层次上对于中断的模拟, 效果和中断类似, 驱动可以主动向软件发送信号, 告诉自己可以访问 ```c 34\t#define SIGHUP 1/* 终端挂起或控制进程终止*/ 35\t#define SIGINT 2/* 终端中断(Ctrl+C组合键) */ 36\t#define SIGQUIT 3/* 终端退出(Ctrl+\\组合键) */ 37\t#define SIGILL 4/* 非法指令*/ 38\t#define SIGTRAP 5/* debug使用，有断点指令产生*/ 39\t#define SIGABRT 6/* 由abort(3)发出的退出指令*/ 40\t#define SIGIOT 6/* IOT指令*/ 41\t#define SIGBUS 7/* 总线错误*/ 42\t#define SIGFPE 8/* 浮点运算错误*/ 43\t#define SIGKILL 9/* 杀死、终止进程*/ 44\t#define SIGUSR110/* 用户自定义信号1 */ 45\t#define SIGSEGV 11/* 段违例(无效的内存段) */ 46\t#define SIGUSR2 12/* 用户自定义信号2 */ 47\t#define SIGPIPE 13/* 向非读管道写入数据*/ 48\t#define SIGALRM 14/* 闹钟*/ 49\t#define SIGTERM 15/* 软件终止*/ 50\t#define SIGSTKFLT 16/* 栈异常*/ 51\t#define SIGCHLD 17/* 子进程结束*/ 52\t#define SIGCONT 18/* 进程继续*/ 53\t#define SIGSTOP 19/* 停止进程的执行，只是暂停*/ 54\t#define SIGTSTP 20/* 停止进程的运行(Ctrl+Z组合键) */ 55\t#define SIGTTIN 21/* 后台进程需要从终端读取数据*/ 56\t#define SIGTTOU 22/* 后台进程需要向终端写数据*/ 57\t#define SIGURG 23/* 有\"紧急\"数据*/ 58\t#define SIGXCPU 24/* 超过CPU资源限制*/ 59\t#define SIGXFSZ 25/* 文件大小超额*/ 60\t#define SIGVTALRM 26/* 虚拟时钟信号*/ 61\t#define SIGPROF 27/* 时钟信号描述*/ 62\t#define SIGWINCH 28/* 窗口大小改变*/ 63\t#define SIGIO 29/* 可以进行输入/输出操作*/ 64\t#define SIGPOLL SIGIO 65\t/* #define SIGLOS 29 */ 66\t#define SIGPWR 30/* 断点重启*/ 67\t#define SIGSYS 31/* 非法的系统调用*/ 68\t#define SIGUNUSED 31/* 未使用信号*/ ``` > 除了SIGKILL(9)和SIGSTOP(19)这两个信号不能被忽略外，其他的信号都可以忽略。 ## 应用中处理 + 具体的实现 1）signal(SIGIO, sig_handler); 调用signal函数，让指定的信号SIGIO与处理函数sig_handler对应。 2）fcntl(fd, F_SET_OWNER, getpid()); 指定一个进程作为文件的“属主(filp >owner)”，这样内核才知道信号要发给哪个进程。 3）设置文件标志，添加FASYNC标志 f_flags fcntl(fd, F_GETFL); fcntl(fd, F_SETFL, f_flags FASYNC); 如果要在应用程序中使用信号，那么就必须设置信号所使用的信号处理函数，在应用程序中使用signal函数来设置指定信号的处理函数，signal函数原型如下所示 ```c sighandler_t signal(int signum, sighandler_t handler) ``` > signum：要设置处理函数的信号。handler：信号的处理函数。`typedef void (*sighandler_t)(int)`, 返回值：设置成功的话返回信号的前一个处理函数，设置失败的话返回SIG_ERR Ctrl+C发送SIGINT信号 fcntl系统调用可以用来对已打开的文件描述符进行各种控制操作以改变已打开文件的的各种属性 ```c #include<unistd.h> #include<fcntl.h> int fcntl(int fd, int cmd); int fcntl(int fd, int cmd, long arg); int fcntl(int fd, int cmd ,struct flock* lock); ``` ![QQ图片20220901122303](https://blog 1308522872.cos.ap beijing.myqcloud.com/jhy/202301010002505.png) [ 图片:cntl函数的用法总结](https://blog.csdn.net/fengxinlinux/article/details/51980837) [ 以下描述f:cntl函数用法](https://blog.csdn.net/ALone_cat/article/details/126554725) **F_GETFL** 取得fd的文件状态标志，如同下面的描述一样(arg被忽略)，在说明open函数时，已说明了文件状态标志。 **F_SETFL** 设置给arg描述符状态标志，可以更改的几个标志是：O_APPEND，O_NONBLOCK，O_SYNC 和 O_ASYNC。而fcntl的文件状态标志总共有7个：O_RDONLY , O_WRONLY , O_RDWR , O_APPEND , O_NONBLOCK , O_SYNC和O_ASYNC 可更改的几个标志如下面的描述： > O_NONBLOCK 非阻塞I/O，如果read(2)调用没有可读取的数据，或者如果write(2)操作将阻塞，则read或write调用将返回 1和EAGAIN错误 > O_APPEND 强制每次写(write)操作都添加在文件大的末尾，相当于open(2)的O_APPEND标志 > O_DIRECT 最小化或去掉reading和writing的缓存影响。系统将企图避免缓存你的读或写的数据。如果不能够避免缓存，那么它将最小化已经被缓存了的数据造成的影响。如果这个标志用的不够好，将大大的降低性能 > O_ASYNC 当I/O可用的时候，允许SIGIO信号发送到进程组，例如：当有数据可以读的时候 重点就是通过fcntl函数设置进程状态为FASYNC，经过这一步，驱动程序中的fasync函数就会执行。 **F_SETOWN** 设置将接收SIGIO和SIGURG信号的进程id或进程组id，进程组id通过提供负值的arg来说明(arg绝对值的一个进程组ID)，否则arg将被认为是进程id + 实际使用 ```c fcntl(fd, F_SETOWN, getpid());//添加进程到内核 int flags 0; flags fcntl(fd, F_GETFL);//设置为FASYNC模式, 异步通知 fcntl(fd, F_SETFL, flags FASYNC); ``` ## 信号发送 + 具体实现： 一 驱动方面： 1. 在设备抽象的数据结构中增加一个struct fasync_struct的指针 2. 实现设备操作中的fasync函数，这个函数很简单，其主体就是调用内核的fasync_helper函数。 3. 在需要向用户空间通知的地方(例如中断中)调用内核的kill_fasync函数。 4. 在驱动的release方法中调用kpp_fasync( 1, filp, 0);函数 fasync_struct结构体 ```c struct fasync_struct { spinlock_t fa_lock; int magic; int fa_fd; struct fasync_struct *fa_next; struct file *fa_file; struct rcu_head fa_rcu; }; ``` > fasync_struct结构体指针变量定义到设备结构体中, 实现file_operations里面的fasync函数 ```c int (*fasync) (int fd, struct file *filp, int on) ``` > 一般通过调用fasync_helper函数来初始化前面定义的fasync_struct结构体指针 ```c int fasync_helper(int fd, struct file * filp, int on, struct fasync_struct **fapp) ``` ```c void kill_fasync(struct fasync_struct **fp, int sig, int band) ``` > 负责发送指定的信号, fp：要操作的fasync_struct。sig：要发送的信号。band：可读时设置为POLL_IN，可写时设置为POLL_OUT。 + 关闭驱动的时候要删除信号 在关闭驱动文件的时候需要在file_operations操作集中的release函数中释放fasync_struct，fasync_struct的释放函数同样为fasync_helper ```c return xxx_fasync( 1,filp,0);/* 删除异步通知*/ ``` > 调用的是file_operation中的函数, 是自己写的 ## 示例 ```c static int imx6uirq_fasync(int fd, struct file *filp, int on) { struct imx6uirq_dev *dev filp >private_data; \t//进入的时候加载 return fasync_helper(fd, filp, on, &dev >fasync_queue); } static int imx6uirq_realse(struct inode *inode, struct file *filp) { \t//退出的时候移除 struct imx6uirq_dev *dev filp >private_data; imx6uirq_fasync( 1, filp, 0); return 0; } //定时器 if(atomic_read(&dev >realsekey) 1)//有信号的时候发送 { kill_fasync(&dev >fasync_queue, SIGIO, POLL_IN);//发送信号SIGIO, 文件为可读状态 } ``` 应用 ```c //重写处理函数 static void sigio_signal_func(int num) { int err; unsigned int key_value 0; err read(fd, &key_value, sizeof(key_value)); if(err<0) { } else{ printf(\"keyval is %d\\r\\n\", key_value); } } //main //设置信号处理函数 signal(SIGIO, sigio_signal_func); fcntl(fd, F_SETOWN, getpid());//添加进程到内核 int flags 0; flags fcntl(fd, F_GETFL);//设置为FASYNC模式, 异步通知 fcntl(fd, F_SETFL, flags FASYNC); ```"},"/note/Linux/韦东山Linux/2025-3-4-基础.html":{"title":"基础","content":"# 基础 分为几部分 bootloader Linux内核 根文件系统 APP"},"/note/Linux/服务器/2023-6-12-代理.html":{"title":"","content":"服务器设置: 使用ubuntu 添加秘钥 设置![image 20230618165223612](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242255274.png) ![image 20230618165521638](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242255275.png) https://b23.tv/CGaIhyE?share_medium android&share_source qq&bbid XXD5FB0D9FC7C10845CA2D2E0D5F3BD92AC56&ts 1687078109378 ``` root@ip 172 31 42 227:~# bash <(curl Ls https://raw.githubusercontent.com/vaxilu/x ui/master/install.sh) ``` 使用命令之后更换端口 然后使用![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242255276.png) ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242255277.png)"},"/note/Linux/服务器/2023-6-12-新服务器搭建.html":{"title":"","content":"# 搭建服务器 首先下载使用fail ``` systemctl enable vsftpd.service systemctl start vsftpd.service systemctl status vsftpd.service ``` 使用可视面板 宝塔面板[宝塔面板 简单好用的Linux/Windows服务器运维管理面板 (bt.cn)](https://www.bt.cn/new/index.html) ``` yum install y wget && wget O install.sh https://download.bt.cn/install/install_6.0.sh && sh install.sh ed8484bec ``` ``` Congratulations! Installed successfully! 外网面板地址: https://114.55.226.26:29668/887fef6b 内网面板地址: https://172.19.201.194:29668/887fef6b username: axy0ntob password: c0c7576b If you cannot access the panel, release the following panel port [29668] in the security group 若无法访问面板，请检查防火墙/安全组是否有放行面板[29668]端口 因已开启面板自签证书，访问面板会提示不匹配证书，请参考以下链接配置证书 https://www.bt.cn/bbs/thread 105443 1 1.html Time consumed: 3 Minute! ``` 之后开启相应的端口 在阿里云服务器安全组进行添加 ![image 20230613150835808](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242304293.png) 之后安装相应的软件 然后在网站页面添加对应的域名 网站需要相应的端口, 网站默认的是80 ![image 20230613154026356](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242304294.png) 添加443端口 ## 注册网站的域名 ## 通过SSL ## 使用wordPress进行网站搭建 官网下载之后在搭建的网站根目录部署 https://b23.tv/0zhTCo2 http://jhy.dhx.icu/wp admin 控制台网址"},"/note/Linux/树莓派/2024-2-8-时钟设置.html":{"title":"网时钟设置","content":" layout: post title: \"网时钟设置\" date: 2024 1 2 15:39:08 +0800 tags: 树莓派 # 时钟设置 ## NTP服务 网络时间"},"/note/Linux/树莓派/2024-2-1-01开始使用.html":{"title":"任务状态","content":" layout: post title: \"任务状态\" date: 2024 1 2 15:39:08 +0800 tags: 树莓派 # 开始使用 [Raspberry Pi OS – Raspberry Pi](https://www.raspberrypi.com/software/) 下载一个烧录软件 ![image 20240201132440021](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402011324145.png) ![image 20240201132454205](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402011324236.png) ![image 20240201133634648](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402011336682.png) 选择你的板子, 想用的系统以及你的SD卡(这个SD卡会被格式化), 一般第一个系统是官方的系统 ![image 20240201133305314](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402011333348.png) ![image 20240201133156159](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402011331195.png) > 设置一个用户名字以及密码, 和自动连接的WIFI ![image 20240201133209394](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402011332434.png) ![image 20240201133252689](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402011332724.png) ![image 20240201133528574](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402011335607.png) > 等待, 有条件的可以挂一个代理"},"/note/Linux/树莓派/2024-2-3-04网络连接.html":{"title":"网络连接","content":" layout: post title: \"网络连接\" date: 2024 1 2 15:39:08 +0800 tags: 树莓派 # 网络连接 ## 使用SSH ### 开启 树莓派直接开启就可以使用SSH服务 ```bash sudo raspi config ``` ![image 20240204122409149](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402041224209.png) ![image 20240204122426231](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402041224260.png) > 开启即可 ### 获取ip 1. 一般可以使用ipconfig获取, 但是没有屏幕的时候不方便 2. 使用静态IP地址 静态ip我是用的是图像界面配置的, 点击WIFI图标, 选择要设置的WIFI, 在ipv4里面添加static ip, 选择手动即可 掩码255.255.255.0, 网关使用这个获取 ![image 20240204133856953](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402041338999.png) ![image 20240204133922930](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402041339983.png) ### 使用SSH反向隧道 > 参考 [SSH 反向隧道搭建过程 云社区 华为云 (huaweicloud.com)](https://bbs.huaweicloud.com/blogs/268758) 1. 安全组放开端口 ![image 20240204145742503](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402041457530.png) ![image 20240204145804319](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402041458339.png) ![image 20240204145833030](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402041458052.png) ![image 20240204144813723](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402041448746.png) 2. 打开端口的防火墙 ```bash root@hecs 17189:~# sudo ufw allow 9999 Rule added Rule added (v6) root@hecs 17189:~# sudo ufw reload Firewall reloaded ``` 3. 树莓派与服务器添加密钥(树莓派端) ```bash ssh keygen t rsa C \"your@email.com\" ssh copy id 服务器用户名@服务器id ``` > 第一个生成一个秘钥, 直接回车默认选项即可 > > 第二个上传密钥 4. 改服务器ssh的设置(服务器端) ```c sudo vim /etc/ssh/sshd_config ``` ```javascript GatewayPorts yes ``` > 加入一行这一个, 这样可以把监听的端口绑定到任意 IP 0.0.0.0 上，否则只有本机 127.0.0.1 可以访问。 然后重启 sshd 服务： > > ```bash > sudo service sshd restart > ``` 5. 树莓派开启一个转接服务 [Linux命令后台运行_后台运行命令 CSDN博客](https://blog.csdn.net/caesar1228/article/details/118853871) ```c ssh CNR 你使用的端口:localhost:22 服务器用户名@服务器地址 ``` > 可以使用后台的模式 5. 可以使用ssh服务连接服务器的对应端口访问树莓派"},"/note/Linux/树莓派/2024-2-1-02-使用命令了解树莓派.html":{"title":"使用命令了解树莓派","content":" layout: post title: \"使用命令了解树莓派\" date: 2024 1 2 15:39:08 +0800 tags: 树莓派 # 使用命令了解树莓派 ## 命令 ### 获取CPU信息 ![image 20240201141842074](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402011418265.png) ### 内存信息 ![image 20240201141959731](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402011419771.png) ### SD卡 sudo fdisk l ![image 20240201142157605](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402011421634.png) > 第一个区域用于开机启动, 另一个区域用于打印操作系统的信息 ### SUB设备 ![image 20240201142411920](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402011424956.png) ### 操作系统 ![image 20240201142446414](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402011424455.png) ## 树莓派专用命令 使用vcgencmd命令用于和硬件直接交互 ```bash $vcgencmd measure_temp ``` ![image 20240201142757690](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402011427716.png) ## 使用清华的源 ```bash sudo vim /etc/apt/sources.list ``` ![image 20240201145313770](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402011453851.png)"},"/note/Linux/树莓派/2024-2-1-03-安装mysql.html":{"title":"安装mysql以及换源","content":" layout: post title: \"安装mysql以及换源\" date: 2024 1 2 15:39:08 +0800 tags: 树莓派 # 安装mysql以及换可以使用的源 ## 出现的问题 之前按照网上的教程给树莓派换了一个源, 在下载sysql的时候出现问题 > [[2021 01 05\\]在树莓派 4B+ 里安装 MySQL数据库（实际安装的是 mariadb server）_在樹梅派安裝mysql CSDN博客](https://blog.csdn.net/qq_18301257/article/details/112209931) ![image 20240201181036315](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402011810375.png) 发现我的这个系统基于Debian12, 但是国内的源是给Debian11使用的 ![image 20240201181212411](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402011812462.png) > 这导致我没办法下载`mariadb server` ## 解决 我看了一下树莓派的管理源的文件/etc/apt/sources.list, 发现它直接使用的是Debian的源 ![image 20240201181350861](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402011813937.png) 所以我找到Debian12的镜像源换了一下, 可以使用 ```bash # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non free non free firmware # deb src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm main contrib non free non free firmware deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm updates main contrib non free non free firmware # deb src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm updates main contrib non free non free firmware deb https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm backports main contrib non free non free firmware # deb src https://mirrors.tuna.tsinghua.edu.cn/debian/ bookworm backports main contrib non free non free firmware deb https://security.debian.org/debian security bookworm security main contrib non free non free firmware # deb src https://security.debian.org/debian security bookworm security main contrib non free non free firmware ``` > [debian 镜像站使用帮助 清华大学开源软件镜像站 Tsinghua Open Source Mirror](https://mirrors.tuna.tsinghua.edu.cn/help/debian/) 下载的程序没有问题 ![image 20240201181602098](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402011816223.png)"},"/note/Linux/Linux源码趣读/2024-1-26-01最开始的代码.html":{"title":"GPIO","content":" layout: post title: \"GPIO\" date: 2023 6 20 15:39:08 +0800 tags: stm32 # 最开始的代码 在开机的时候运行的时候会把硬盘里面512b复制到0x7c00, 之后开始运行"},"/note/Linux/操作系统原理/2023-6-20-11进程.html":{"title":"进程","content":" layout: post title: \"进程\" date: 2023 6 18 15:39:08 +0800 tags: 操作系统 # 进程 + 概念 + 组成 + 特征 程序: 存放在磁盘中的可执行文件, 指令的集合 进程: 动态的, 程序的一次执行过程 > 操作系统创建进程的时候分配进程ID, PID, 是不重复的 > > 还需要记录进程的相关信息被存放在PCB(进程控制模块) ## 进程实体 > 进程存在的唯一标识 + PCB + + 进程描述信息 + + 进程标识符PID + 用户标识符UID + 进程控制管理信息 + + CPU、磁盘、网络流量使用情况 + 进程当前状态：就绪/阻塞/运行 + 资源分配清单 + + 正在使用的文件 + 正在使用的区域 + 正在使用的I/O + 处理机相关信息 + + PSW、PC等各种寄存器的值，实现进程切换 + 程序段 + + 程序的代码 + 数据段 + + 运行过程中产生的数据 > 进程是动态的, 进程实体是静态的 > PCB是操作系统使用的, 数据段, 程序段是进程自己使用的 > 进程是进程实体的运行过程, 是系统进行资源分配和调度的独立单位 > > 调度: 系统决定哪一个进程在CPU上进行 > 多次打开同一个程序PCB和数据段不同, 程序段相同 ![image 20230620153950634](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311090943965.png) ![image 20230620154056226](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311090943966.png) > 有了线程之后就不是进行调度的基本单位了 ## 进程的状态与转换 ![image 20230621112716914](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311090943967.png) ### 状态 + 创建态(新建态): 分配系统资源, 初始化PCB + 就绪态: 有运行的状态, 但是CPU没有空闲, 暂时不运行(可能有多个进程) + 运行态: CPU空闲的时候选取一个就绪态进程进行运行, 执行对应的程序 + 阻塞态(等待态): 请求某个资源, 资源获得之前进程没有办法进行, 进入阻塞态, CPU选取另一个就绪态的进程进行执行, 资源获得之后阻塞态 >就绪态 + 终止态(结束态): 运行结束, 发出exit()系统调用, 系统让下CPU然后回收PCB, 工作完成, 进程彻底消失 > 中间三种是基本状态 ### 转换 ![image 20230621114123971](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311090943969.png) > 在PCB中有变量记录当前状态, 为了对同一状态下进程统一管理, 操作系统会将PCB组织起来 > > **链接模式**: 使用不同的指针指向对应的PCB, 操作系统有各个队列的指针 > > **索引模式**: 采用索引模式, 创建不同的索引表, 操作系统有索引表的指针 ## 进程控制 对系统中的所有进程进行有效的管理, 创建新进程, 撤销已有进程, 实现进程状态转换等功能(实现状态的转换) + 进程控制 + + 基本概念 + + 什么是进程控制 + 如何实现 + + 原语 + 进程控制相关原语 + + 进程的创建 + 进程的终止 + 进程的阻塞 + 进程的唤醒 + 进程的切换 ### 怎么实现 **原语**: 特殊的程序, 执行具有原子性, 进行必须一气呵成, 不可以中断 > 在转换的时候需要转换转换变量, 然后更换队列, 防止 没有执行完全导致数据结构数据不统一 #### 如何实现 可以使用关闭中断和开中断指令, 给他实现原执行 ### 相关的的原语 ![image 20230621132952219](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311090943970.png) > 作业: 从外存还没有运行的程序调度一个程序进入内存, 计算机领域的作业是指用户在一次解决或是一个事务处理过程中要求计算机系统所做的工作的集合 > > 作业调度是指**从外存的后备队列中选取某些作业调入内存，并为它们创建进程、分配必要的资源**。作业调度的目的是**提高系统的吞吐量和资源利用率** ![image 20230621134558197](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311090943971.png) ![image 20230621135514776](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311090943972.png) ![image 20230621141326868](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311090943973.png) ### 原语总结 + 更新PCB信息 + 将PCB插入队列 + 分配/回收资源 ## 进程间通讯 IPC: 指两个进程之间产生数据的交换 进程是分配系统资源的单位, 各个进程拥有内存地址空间相互独立 为了保证安全, 一个进程不能直接访问另一个进程的地址空间 ### 解决方式 #### 共享存储 多个进程有一片共享存储区 > Linux下面的`int shm_open`函数, 申请调用一片共享内存, `void mmap`把区域映射到自己的虚拟地址空间(通过增加页表项/段表项) + 有可能导致访问互斥, 可以使用同步互斥工具(P、V操作) > **基于存储区的共享**, 划分出一块共享储存区, 数据的形式, 存放位置由进程决定, 高级通信方式(速度快) > **基于数据结构的共享**, 比如共享空间可以存放固定的数组, 共享速度慢, 限制多, 低级通讯 #### 消息传递 进程之间使用格式化的消息为单位, 通过系统提供的原语进行数据叫喊 ![image 20230621143941725](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311090943974.png) > 直接通讯方式: 在进程的PCB中包含有一个消息队列, 使用原语进行传递接收, 传递时候需要指明对方进程的PID等 > 间接通讯方式: 进程向操作系统申请邮箱, 将信息发送到信箱中, 发送的时候指明信箱, 另一个进程点名从信箱中获取信息 #### 管道通讯 单向传递数据 管道是一种特殊的共享文件, 又叫做pipe文件, 实际上就是在内存中开辟一个固定大小的内存缓冲区 > 先进先出, 本质上是一个队列 > 和共享内存的不同: 只能按顺序进行传递, 是一个半双工通讯, 同时双向进行的时候需要两个管道, 进程的访问也是互斥的 管道写满了写的进程会被阻塞, 直到管道内的数据被取走, 读空的时候也会进入阻塞 数据一旦被读出就会消失, 多个进程读取可能造成错乱 + 一个管道有多个写进程, 只有一个读进程 + 允许有多个读写进程, 但是系统让读进程轮流读取(Linux方案)"},"/note/Linux/操作系统原理/2023-6-18-7系统调用.html":{"title":"系统调用","content":" layout: post title: \"系统调用\" date: 2023 6 18 15:39:08 +0800 tags: 操作系统 # 系统调用 操作系统提供给程序使用的接口, 应用程序调用的特殊函数, 应用程序通过系统调用来请求获得操作系统内核的服务 是比库函数更加底层的接口 不是所有库函数使用操作系统 > **必须性**: 在使用共享资源的时候程序通过操作系统向内核发出请求, 内核对请求协调处理 ![image 20230618200045913](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242305296.png) 和共性资源有关的都是使用系统调用, 提出请求, 由操作系统完成, 保证稳定性, 安全性, 防止非法操作 ## 过程 + 向CPU传入参数 + 陷入指令(trap指令, 访管指令)"},"/note/Linux/操作系统原理/2023-6-17-5运行机制.html":{"title":"运行机制","content":" layout: post title: \"运行机制\" date: 2023 6 18 15:39:08 +0800 tags: 操作系统 # 运行机制 高阶代码经过翻译对应多条机器指令, 指CPU可以识别, 执行的最基本命令 程序分为应用程序, 内核程序, 内核程序组成内核, 是操作系统最核心的部分, 也是最接近硬件的 操作系统的功能不都是内核, 比如说GUI 内核是管理者, 有时会执行影响比较大得指令(特权指令、广义指令), 只允许内核来使用 应用只能使用非特权指令, CPU在生产的时候可以分辨不同的指令 CPU会被划分为内核态, 用户态, 可以执行的指令不同 > 程序状态寄存器(PSW), 1为内核态 > > 内核态 管态, 用户态 目态 + 状态切换: 内核 >用户有一条特权指令会使内核态转换为用户态, 用户 >内核:中断, **硬件完成(模式的改变以及保存状态字)** + 在用户态得到一个特权指令CPU会转换为内核态, 并强行制止, 暂停程序, 执行中断内核程序 > 用户保存程序计数器, 中断处理保存PC以及程序状态寄存器(PSW)"},"/note/Linux/操作系统原理/2023-6-19-8体系结构.html":{"title":"体系结构","content":" layout: post title: \"体系结构\" date: 2023 6 18 15:39:08 +0800 tags: 操作系统 # 体系结构 + 操作系统的结构 + + 大内核(宏内核/单内核) + 微内核 + 分层结构 + 模块化 + 外核 ## 操作系统划分 ![image 20230619131946545](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242258773.png) ![image 20230619132017202](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242258775.png) ![image 20230619132342016](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242258776.png) 微内核会对性能造成影响, 只有关系最深的应用在内核态进行, 其他在用户态进行, 会导致状态的频繁切换, 切换是有成本的, 但是内核功能少, 便于维护 ![image 20230619171523850](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242258777.png) ## 分层结构 最底层是硬件, 最上层是用户接口, 每一层可以调用更低一层, 单向, 只能调用相邻的一层, 方便调试 ## 模块化 ![image 20230619174147455](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242258778.png) 主模块必不可少, 在调用的时候模块依赖, 难调试 宏内核和微内核也会采用模块化功能, 微内核的用户态应用需要内核态的信息传递来相互调用 ## 外核 ![image 20230619175217688](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242258779.png) 内核进行进程调度, 进程通讯 外核为用户分配未经抽象的硬件资源(不是虚拟空间), 外核保证资源使用安全, 应用可以申请连续的存储空间, 外核还要保证安全 降低一致性: 应用申请的空间可能是虚拟的或者是真实的空间, 系统需要根据不同的进行区分"},"/note/Linux/操作系统原理/2023-6-20-10虚拟机.html":{"title":"虚拟机","content":" layout: post title: \"虚拟机\" date: 2023 6 18 15:39:08 +0800 tags: 操作系统 # 虚拟机 传统的计算机只能运行一个操作系统, 运行不同的进程会相互影响 虚拟机: 使用虚拟化技术将一台物理机器虚拟化为多台虚拟机器, 每个虚拟机都可以独立运行操作系统 同义: 虚拟机管理程序, 虚拟机监控程序, Virtual Machine Monitor, Hypervisor + 直接运行在硬件之上![image 20230620120559175](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242255003.png) > 运行在宿主操作系统上, 只有第一类虚拟机管理程序运行在内核态, 会导致上层操作系统使用特权指令, 使用的时候会被虚拟机管理程序截获, 转换之后进行处理 + 运行在宿主操作系统上 ![image 20230620120638297](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242255004.png) > VMware ![image 20230620124244384](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242255005.png) > 第一类的虚拟机也可以使用一定的特权级指令, 在次高特权级, 但是使用Ring0的时候需要VMM进行控制 > > 第二类内核态是虚拟机驱动程序状态运行在内核态"},"/note/Linux/操作系统原理/2023-6-17-3操作系统特征.html":{"title":"操作系统特征","content":" layout: post title: \"操作系统特征\" date: 2023 6 17 15:39:08 +0800 tags: 操作系统 # 操作系统特征 并发 共享 虚拟 异步 前两个最基本, 互为存在条件 ## 并发 两个或多个事件在统一时间内间隔发生, 宏观上同时发上, 微观上交替法伤 并行: 两个或多个事件在同一时刻同时发生 操作系统的并发: 伴随\"多道程序技术\", 两者同时诞生 单核CPU同一时刻只能执行一个程序, 只能并发 多核CPU同一时刻执行多个程序, 可以并行 ## 共享 资源共享 + 互斥共享: 同一时间段只允许一个进程访问 + 同时共享: 某些资源同一时间段内多个进程\"同时\"访问 > 并发共享的关系: 失去并发性, 共享性失去意义, 失去共享性, 就无法实现并发发送文件 ## 虚拟 物理上的实体变为若干逻辑上的对应物, 物理实体上是实际存在的, 逻辑上是用户感受到的 虚拟存储器技术\"空分复用技术\" 虚拟处理器技术, 一个CPU同时处理多个应用, \"时分复用技术\" 这两种技术需要并发性, 否则没有并发性 ## 异步 在多道程序环境下, 允许多个程序并发进行, 但是由于资源有限, 进程不是一贯到底的, 以不可预知的速度前行推进, 这就是一不行 由于并发争抢有限的资源, 会导致在得到资源之前系统的运行暂停, 并发向才会导致异步性"},"/note/Linux/操作系统原理/2023-6-17-2操作系统目标和作用.html":{"title":"操作系统目标和作用","content":" layout: post title: \"操作系统目标和作用\" date: 2023 6 17 15:39:08 +0800 tags: 操作系统 # 操作系统目标和作用 ## 定义 裸机 >操作系统 >应用程序 + 控制和管理整个计算机系统的硬件和软件资源, 并合理的组织调度计算机的工作和资源的分配, 以提供给用户和其他软件方便的接口和环境, 他是计算机系统中最基本的系统软件 作为系统的管理者 + 提供的功能 + + 处理机管理: 进程被CPU处理 + 存储器管理 + 文件管理 + 设备管理 + 目标 + + 安全高效 ## 服务 操作系统要向上层提供方便易用的服务(封装的思想) 1. GUI: 图形化用户接口 2. 联机命令接口 交互命令接口, 用户说一步操作系统做一步 3. 脱机命令接口, 脚本.sh文件和.bat文件, 区别在于是单步执行还是多步执行 4. 程序接口, 编写代码间接使用, 应用程序请求操作系统的唯一方式(系统调用 广义指令) 用户接口: 联机命令接口,脱机命令接口,程序接口 ## 对机器的拓展 没有软件: 裸机 覆盖软件: 扩充机器, 虚拟机"},"/note/Linux/操作系统原理/2023-6-23-13调度.html":{"title":"处理机调度","content":" layout: post title: \"处理机调度\" date: 2023 6 18 15:39:08 +0800 tags: 操作系统 # 处理机调度 + 处理机调度 + 三个层次 + + 高级调度 + 中级调度 + 低级调度 + 三层调度联系, 对比 + 补充知识 + + 进程的挂起态 + 七状态模型 ## 基本概念 按照某种算法选择一个处理机分配给他 有一堆任务要处理的时候, 由于当前的资源有限, 没有办法同时处理, 需要确定某种规则来决定处理的顺序, 这就是调度研究的问题 ### 高级调度(作业调度) 作业: 某一个具体的任务 用户向系统提交了一个作业 >用户让操作系统启动一个程序, 来处理一个任务 > 高级调度(作业调度): 操作系统按照一定的原则从外存中作业后备列表中选一个作业存入内存, 创建进程, 每个作业调入一次, 掉出一次, 分别创建撤销PCB, **是对请求任务的处理** ### 低级调度(进程调度/处理机调度) 按照某一种策略从就绪队列选一个进程, 分配处理机给他, 是最基本的调度, 一般的操作系统都需要进程调度, 进程频率很高, 一般几十毫秒一次, **是对进程的管理** ### 中级调度(内存调度) 内存不够的时候, 将空闲的进程调入外存, 空闲的时候再重新调回内存, 暂时调出去的进程称为挂起状态, 被挂起的PCB称为挂起队列 > 按照某种决策决定哪个处于挂起状态的进程重新调入内存 频率比高级调度要高 ## 七状态模型 暂时挂起到内存的进程状态为挂起状态, 挂起状态又可以细分为就绪挂起, 阻塞挂起 ![image 20230623130731064](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242258489.png) > 两种的挂起状态可能被分为两种或多种队列 ![image 20230623130903240](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242258490.png) ## 进程调度 + 进程调度 + + 时机 + + 什么时候需要 + 什么时候不能进行 + 切换与过程 + + 狭义的\"调度\"与\"切换\"的区别 + 进程切换的过程需要什么 + 方式 + + 非剥夺调度方式(非抢占式) + 剥夺调度方式(抢占式) ### 时机 1. 主动放弃处理 + 进程正常终止 + 进程过程中发生异常终止 + 进程主动请求阻塞(等待I/O) 2. 被动放弃 + 分配的时间片用完 + 有更紧急的事件需要处理 + 有优先级更高的进程进入就绪队列 ### 不能的情况 ![image 20230623132558052](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242258491.png) 进程在操作系统内核程序临界区不能进行调度与切换 [×]处于临界区的时候不能进行处理机调度 > 临界资源: 一个时间段只允许一个进程使用资源, 各个进程需要互斥的访问临界资源 > 临界区: 访问临时资源的那段代码 内核程序临界: 访问某种内核数据结构 ![image 20230623133117333](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242258492.png) > 不可以进行进程调度 ![image 20230623133216906](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242258493.png) > 可以进行进程调度 ### 调度方式 **非剥夺调度方式**: 有的系统只允许进程主动放弃处理机 实现简单开销小, 但是不能处理紧急任务, 使用于早期的批处理系统 **剥夺调度方式**: 有的系统进程可以主动的放弃处理机, 当有更紧急的任务需要处理的时候也会强制剥夺 实现优先处理紧急任务, 也可以实现进程按照时间片轮流执行的功能(时钟中断), 适合分时操作系统, 实时操作系统 ### 进程切换与调度区别 ![image 20230623133957086](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242258494.png) 进程切换完成 1. 保存进程的各种数据 2. 对新进程的数据进行恢复 > 进程切换是有代价的, 不能切换的过于频繁, 否则会导致操作系统效率低 ## 调度器和处理程序 ### 调度器 完成程序在就绪态和运行态之间进行转换 让谁运行 > 调度算法 运行多长时间 > 时间片大小 #### 时机 创建新的进程 进程退出 运行阻塞 I/O中断发生(可能唤醒某些阻塞的程序) + 非抢占式调度策略: 只有运行程序阻塞或者退出的时候才会触发调度程序 + 抢占式调度策略: 每个或者k个时钟中断会触发调度工作 > 不支持内核级线程的操作系统, 调度程序处理的对象是进程 > > 支持内核级线程的操作系统, 调度的处理对象是内核级线程 ## 闲逛进程 调度程序的备胎, 没有其它进程的时候闲逛进程运行(idle) 优先级最低, 0地址指令, 占一个完整的指令周期(指令周期末尾例行检查中断) 能耗低 ## 调度算法的[请假指标 ![image 20230623135429198](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242258495.png) 1. CPU利用率: CPU忙碌时间占总时间的比例 某种设备的利用率 ![image 20230623135740305](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242258496.png) ![image 20230623135754264](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242258497.png) 2. 系统吞吐量 用尽可能少的事件完成尽可能多的作业 ![image 20230623135904816](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242258498.png) 3. 周转时间 作业提交到作业完成所需要的时间 ![image 20230623140008593](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242258499.png) 周转时间 作业完成时间 作业提交时间 平均周转时间 各作业周转时间之和/作业数 ![image 20230623140333160](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242258500.png) 4. 带权周转时间(是一个比例) 带权周转时间 作业周转时间/作业实际的运行时间 (作业完成时间 作业提交时间)作业实际运行时间 ![image 20230623140603796](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242258501.png) ![image 20230623140708589](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242258502.png) 5. 等待时间 进程/作业处于等待处理机状态的时间之和 对于进程来说等待I/O设备完成期间其实也是在被服务, 不计入等待时间 要加上在外存后备队列中等待的时间和建立进程之后的等待时间 ![image 20230623141123332](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242258503.png) 6. 响应时间 用户提交请求到首次产生响应的时间 ![image 20230623141218228](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242258504.png) ## 调度算法 + 先来先服务 + 短作业优先 + 高响应比优先 + 时间片轮转调度算法 + 优先级调度算法 + 多级反馈队列调度算法 > 思路 > > + 算法思想 > + 算法规则 > + 调度算法使用的于作业调度还是进程调度 > + 抢占式?非抢占式? > + 是否会导致饥饿(进程/作业长时间得不到服务) ### 先到先服务 FCFS, first come first serve 按照到来的顺序 ![image 20230624182732217](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242258505.png) ### 短作业优先 SJF Shortest Job First 每次调度的时候选择当时已经到达且运行时间最短的作业/进程(非抢占式的) 抢占式的(SRTN), 最短剩余时间优先算法, 就绪队列改变的时候, 新到达的进程运行时间与当前进程的剩余时间进行比较, 一个进程完成时也会践行调度 > 题目中如果没有特殊说明, 默认是非抢占式的 ![image 20230624191434905](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242258506.png) ![image 20230624191720932](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242258507.png) ### 高响应比优先 综合考虑作业进程的等待时间和要求服务的时间 根据响应比 (等待时间 + 要求服务的时间)/要求服务的时间 进程主动放弃CPU的时候才会进行调度 ![image 20230624193224383](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242258509.png) ### 总结 主要关心用户的公平性, 平均运转周期, 平均等待时间, 评价系统整体性能的指标, 但是不关心响应时间, 也不处理任务的紧急程度, 对用户来说交互性差, 一般适用于早期的批处理系统 FCFS经常结合其他算法 ### 时间片轮转调度算法(RR) 公平轮流为各个进程服务, 在一定时间内所有进程都可以得到响应 按照到达的时间轮流运行时间片, 抢占式的算法 > 常用于分时操作系统, 更注重响应时间, 因此不计算周转时间 默认新到达的进程先进入就绪队列 + 如果时间片比较大会导致退化为先来先服务, 所以不能让太大 + 时间片太小会切换频繁, 导致系统花大量时间进行切换,, 一般占比小于百分之一 ![image 20230626151300194](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242258510.png) ### 优先级调度算法 为每一个任务设置优先级, 根据优先级进行调度 有抢占式也有非抢占式的, 抢占式需要在就绪队列发生变化的时候判断 就绪队列可以有多个, 也可以动态进行排队 > 优先级是否可以动态改变: > > + 静态优先级: 创建以后就不再改变 > + 动态优先级: 创建的时候有一个初始值, 之后动态调整 #### 如何设置 通常系统优先级高于用户进程 前台进程高于后台进程 操作系统偏好I/O型进程(I/O繁忙型进程) > I/O设备可以和CPU并行, 优先的话可以让I/O设备尽早的投入工作, 资源利用率提高 > 相对的是计算型进程(CPU繁忙型进程) 从公平角度来看, 某个进程等待时间长就提高优先级 ![image 20230626153113043](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242258511.png) ### 多级反馈队列调度算法 设置多级就绪队列, 各个队列优先级从高到低, 时间片从大到小, 新到来的进程到大四进入以及队列, 按照FCFS进行调度, 用完时间片进程还未结束进入下一级队列末尾, 已经在最下级就重新放回最下级 第k级为空的时候才会进行k+1级的队列, 被抢占的进程放回原队列的队尾 ![image 20230626154112810](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242258512.png) ### 总结2 更适合交互式操作系统 ### 多级队列调度算法 ![image 20230626155350986](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242258513.png) 队列之间可以采取固定优先级, 或时间片划分 也可以给各个优先级划分时间片长度不同 各个队列可以采用不同的调度策略, 系统采取优先级调度, 交互式队列采用RR, 批处理采用FCFS"},"/note/Linux/操作系统原理/2023-6-28-15锁.html":{"title":"锁","content":" layout: post title: \"锁\" date: 2023 6 18 15:39:08 +0800 tags: 操作系统 # 锁 ## 互斥锁 解决临界问题最简单的工具就是互斥锁, 一个进程在进入临界区的时候获得锁, 退出的时候释放 ![image 20230628135608374](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242258369.png) 两个操作必须是原子操作, 缺点是盲等, 其他进程进入临界区的时候必须连续循环调用acquire(), 有多个进程共享一个CPU的时候浪费时钟周期, 所以常用于多处理器系统 自旋锁: 需要连续循环忙等的互斥锁, 比如TSL和swap指令 违反让权等待, 优点: 等待期间不用切换进程上下文, 多处理机系统中上锁的时间短等待的代价比较低(其他进程在其他处理器处理完成之会释放锁) 不太适用于单处理机系统, 忙等的时候不能解锁"},"/note/Linux/操作系统原理/2023-6-17-4操作系统的发展.html":{"title":"操作系统发展","content":" layout: post title: \"操作系统发展\" date: 2023 6 17 15:39:08 +0800 tags: 操作系统 # 操作系统发展 ## 发展与分类 + 手工操作阶段 + 批处理阶段 + + 单道批处理系统 + 多道批处理系统(操作系统出现) + 分时操作系统 + 实时操作系统 + 网络操作系统 + 分布式操作系统 + 个人计算机操作系统 ### 手工操作阶段 纸带机, 输入输出慢, 计算机速度快 缺点: 用户独占全机, 人机速度矛盾导致资源利用率极低 ### 单道批处理技术 外围机: 把程序存储到磁带中, 引入脱机输入/输出技术, 并由监控程序负责控制作业输入, 输出 缓解一定的人机速度矛盾, 缺点内存中仅能运行一道程序, 只有这个程序结束才进入下一个程序, CPU大部分时间等待I/O ### 多道批处理系统 内存中读取多道程序, 操作系统诞生, 支持多道程序并发运行, 并发进行, 共享资源, 资源利用率大幅提高 缺点: 没有人机交互, 中间不能控制程序的执行, 不能调试程序, 过程间不能输入参数 通过中断实现 ### 分时操作系统 时间片轮流为各个用户, 作业服务, 用户可以通过终端和计算机进行交流 优点, 用户请求及时响应, 解决人机交互问题, 允许多用户使用计算机, 相互独立, 感觉不到其他人的存在 缺点: 不能优先处理某一个紧急任务, 对各个用户都是公平的, 循环的为各个用户服务一段时间 ### 实时操作系统 根据优先级, 某些紧急任务不需要排队 在实时操作系统下, 计算机接收到外部信号后及时处理, 要求在严格的时间内处理完事件, 特点是及时性, 可靠性 硬实时系统: 绝对严格的时间内完成处理 软实时系统: 能接受偶尔的违反时间规定 ### 其他"},"/note/Linux/操作系统原理/2023-6-27-14进程同步进程互斥.html":{"title":"进程互斥, 同步","content":" layout: post title: \"进程互斥, 同步\" date: 2023 6 18 15:39:08 +0800 tags: 操作系统 # 进程互斥同步 进程的异步性: 进程以各自不同的独立的, 不可预知的速度向前推进 ## 同步 进程同步: 解决进程异步会导致顺序错乱的问题, 亦称直接制约关系, 指为完成某种工作而创立的两个或多个进程, 进程需要在某些位置上协调工作次序而产生的制约关系, 进程间的直接制约关系源于他们之间的相互合作, 遵循一定的先后顺序 ## 互斥 进程互斥: 并非进行的进程不可避免的共享资源 + 互斥共享方式: 某些资源提供给多个进程, 但一个时间段只允许一个进程访问该资源 + 同时共享方式: 允许一个时间段内由多个进程同时进行访问 > 一个时间段只允许一个进程进行访问的资源称为临界资源 > > 对临界资源的访问需要互斥进行(间接制约关系), 一个进程访问的时候另一个进程访问该资源需要进行等待, 结束并释放之后别的进程才能进行访问 + 进入区: 检查是否可以进入, 可以进入设置标志, 防止其他进程进入 + 临界区(临界段): 访问临界资源的代码 + 退出区: 解除标志 + 剩余区: 其他处理 1. 空闲让进, 临界区空闲的时候允许请求进入临界区的进程立即进入临界区 2. 忙则等待: 已有进程进入的时候其他试图进入的进程必须等待 3. 有限等待: 对访问的进程, 保证在有限的时间内进入临界区 4. 让权等待: 进程不能进入临界区时, 立即释放处理机, 防止进程等待 ## 进程互斥的软件实现方法 实现方法 + 单标志法 + 双标志先检查 + 双标志后检查 + Peterson算法 ### 单标志法 ![image 20230627174823359](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259519.png) 算法思想: 两个进程在访问临界区后会把临界区权限转移给另一个进程, 每个进程进入临界区的权限只能被另一个进程赋予 缺点: 只能轮流使用, 违背空闲让进(在空闲的时候禁入标志可能给出但另一方没有使用并归还) ### 双标志先检测法 ![image 20230627174759582](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259520.png) 使用一个数组, 用各个元素标记想进入临界区的意愿, 每个进程进入之前检查当前有没有别的进程想进入, 没有把自己的flog[i]设置为true之后开始访问, 退出之后设置为0 进程并发进行, 在检查之后但是没有更改标志的时候发生进程切换会出现问题 ### 双标志后检查法 先上锁后进行检查, 同样会导致卡住, 违背空闲让进和有限等待 ![image 20230627174911450](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259521.png) ### Peterson算法 结合双标志单标志优点 同时设置数组和优先级, 使用turn表示谦让, 让对方先进入 ![image 20230627175204920](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259522.png) turn为全局变量 没有实现让权等待原则 ## 硬件实现方法 ### 中断屏蔽方法 利用开关中断的指令实现, 和原语的实现原理相似, 在执行完成切换不会进行中断 > 优点: 简单高效 > > 缺点: 不适合多处理机(只能关闭一个处理机的中断), 只适用于操作系统内核, 不适合用户进程 ### TestAndSet指令(TS或TSL(TestAndSetLock)) 使用硬件实现, 不能被中断 ![image 20230627182120834](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259523.png) > 使用代码介绍大概原理 ![image 20230627182605604](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259524.png) ![image 20230627183603566](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259525.png) ### swap指令(Exchange或XCHG) ![image 20230627184020105](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259526.png) Swap和TSL逻辑上没有太大区别, 硬件实现不同, 优缺点相似"},"/note/Linux/操作系统原理/2023-6-17-1操作系统.html":{"title":"操作系统导论","content":" layout: post title: \"操作系统导论\" date: 2022 6 17 15:39:08 +0800 tags: 操作系统 # 操作系统导论 + 掌握操作系统的系统软件1.应用2.系统 + 掌握处理并发处理的思想方法 ## 内容 + 操作系统引论 + CPU管理 + + 进程管理 + 处理机调度死锁 + 存储器管理 + + 存储器管理 + 虚拟存储器管理 + 设备管理 + 文件管理 + 用户接口"},"/note/Linux/操作系统原理/2023-6-22-12线程.html":{"title":"线程","content":" layout: post title: \"线程\" date: 2023 6 18 15:39:08 +0800 tags: 操作系统 # 线程 ![image 20230622110243256](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311090944056.png) 没有进程之前, 系统只能串行执行, 引入进程之后就可以 进程是一个程序的一次执行, 一个进程不能同时完成多种任务, 同时处理多种事务的时候, 线程用来增加系统的并发度 CPU轮流执行线程 , CPU服务的对象变为进程的线程, 进程中有一定的线程, 并发执行, 程序执行流的最小单位,轻量级进程, 进程还是CPU资源调度的基本单位 ## 变化 + 资源分配、调度 + + 资源分配调度的基本单位 + 引入线程、线程是调度的基本单位 + 并发性 + 系统开销 + + 进程切换，切换运行环境， 系统开销大 + 线程并发， 线程切换不需要切换进程环境，系统开销小 + 开发带来的开销小 ## 属性 线程的属性 + 处理机调度单位 + 多CPU计算机各个线程占据不同的CPU + 每一个线程都有线程ID，线程控制模块TCP + 线程也有就绪， 阻塞， 运行三种状态 + 线程基本不拥有系统资源 + 同一进程的不同线程共享进程的资源 + 共享内存空间，通讯不需要系统参与 + 同一进程的线程切换不会使进程切换 + 不同进程线程切换会导致进程切换 + 切换同进程线程系统开销小 + 切换进程系统开销大 ## 实现方式 + 线程 + + 用户级线程 + 内核级线程 + 多线程模型 + + 一对一模型 + 多对一模型 + 多对多模型 ### 用户级线程 ![image 20230622161158693](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311090944058.png) 最早的线程, 早期的操作系统只支持进程, 由程序员的线程库实现, 操作系统看到的还是进程 线程的切换是用户态进行的, 不需要操作系统的管理 + 优点: 不需要CPU切换状态 + 缺点: 如果线程阻塞, 其他的线程也会被阻塞, 不能在多个核上面并行运行 ### 内核级线程 KLT: 管理工作实际是操作系统来完成, 需要操作系统转换为内核态 + 优点: 处理机调度基本单位, 可以使用多个内核, 线程阻塞其他的正常进行 + 缺点: 进程对应多个线程, CPU变态管理成本更高 用户级线程和内核级线程的映射关系 #### 一对一 ![image 20230622161604459](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311090944059.png) 一个用户级线程对应一个系统级线程, 一个线程被阻塞别的线程正常进行, 并发能力强, 但是占用内核级线程多, 管理成本大 #### 多对一 多个用户级线程对应一个内核级线程 ![image 20230622155738885](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311090944060.png) 优点, 用户级线程在用户空间进行切换, 管理系统开销比较小, 开销比较小, 但是一个用户级线程阻塞之后整个进程被阻塞, 并发性不高, 不能并行运行 #### 多线程模型 多对多, n个用户级进程映射到m个内核级进程(n> m) ![image 20230622160037936](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311090944061.png) 克服了多对一并发性不高的缺点, 克服了一对一线程中一个用户占用太多内核级进程, 开销太大, 只有所有都被阻塞才会被称为阻塞态, 分配资源是以内核级线程为单元 ## 状态和转换 ![image 20230622162023025](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311090944062.png) ### 组织与控制 ![image 20230622162144062](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311090944063.png) 多个TCB组装成线程表 >组织 在不同的状态来回切换 >控制"},"/note/Linux/操作系统原理/2023-6-20-9操作系统的引导.html":{"title":"操作系统的引导","content":" layout: post title: \"操作系统的引导\" date: 2023 6 18 15:39:08 +0800 tags: 操作系统 # 操作系统的引导 + 什么是操作系统的引导 + 磁盘里的相关数据 + 操作系统引导的过程 ## 操作系统的引导 ![image 20230620113350114](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242305902.png) 分区表: 分区的大小, 分区的位置 C盘: 引导记录PBR, 负责找到启动管器和根目录, 其他 操作系统启动需要放到主存中, 主存分为RAM(内存), ROM(有BIOS基本输入输出系统, 最重要的是ROM引导程序(自举程序))两种 通电 >使用BIOS >读取主引导记录 >执行磁盘引导程序 >读取引导记录 >找到启动管理器(根目录) >初始化 ![image 20230620114040812](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242305903.png)"},"/note/Linux/操作系统原理/2023-6-28-16信号量机制.html":{"title":"信号量机制","content":" layout: post title: \"信号量机制\" date: 2023 6 18 15:39:08 +0800 tags: 操作系统 # 信号量机制 实现进程互斥同步的方法 用户通过操作系统提供的原语实现对信号量的操作 信号量实际上就是一个变量, 可以是一个整数或更复杂的记录型变量, 可以用一个信号量表示操作系统中的某种资源数量 把检查和上锁放在原语中, 这里指的是wait(S)申请和signal(S)释放原语, 也可以称作P、V操作(P(S)V(S)), ## 整形信号量 使用一个整形, 只能有三种操作, 初始化, P操作, V操作 ![image 20230628141835123](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242301612.png) > 原语无法完成的时候会恢复到操作系统之前的状态, 不可拆分 ## 记录型信号量 ![image 20230628142624371](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242301613.png) ![image 20230628143224491](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242301614.png)"},"/note/Linux/操作系统原理/2023-6-18-6中断异常.html":{"title":"中断异常","content":" layout: post title: \"中断异常\" date: 2023 6 18 15:39:08 +0800 tags: 操作系统 # 中断异常 + 中断异常 + + 中断的作用 + 中断的类型 + + 内中断(异常) + 外中断 + 中断的基本原理 ## 作用 + 是让操作系统夺回CPU使用权的唯一途径 没有中断就不能实现多道程序并发 ## 类型 + 内中断(异常): 当前执行的指令有关, 来自CPU内部, 陷阱, 陷入(trap指令故意引起), 故障(fault错误条件引起, 可以被内核修复, 修复后使用权返回给程序), 终止(abort致命错误引起, 无法处理, 直接终止程序) 1. 应用程序执行特权指令 2. 应用程序请求内核服务, 使用陷入指令, 完成系统调用(不是特权指令) + 外中断: 指令无关, 来自CPU外部 1. 时钟中断: 时钟部件, 实现并发 2. 输入输出设备发送中断信号 > 狭义的中断: 外中断 根据中断向量表决定执行的处理程序"},"/note/Linux/index.html":{"title":"","content":"# Linux"},"/note/Linux/Linux系统编程/2024-3-28-06守护进程、线程.html":{"title":"守护进程, 线程","content":" layout: post title: \"守护进程, 线程\" date: 2024 3 25 15:39:08 +0800 tags: Linux # 守护进程, 线程 ## 进程组和会话 ### 概念和特性 **进程组**，也称之为作业。BSD于1980年前后向Unix中增加的一个新特性。代表一个或多个进程的集合。每个进程都属于一个进程组。在waitpid函数和kill函数的参数中都曾使用到。操作系统设计的进程组的概念，是为了简化对多个进程的管理。 一个进程组是一组相关的进程，它们共享同一个终端或控制台，并且可以通过进程组ID(PGID)来标识。一个进程可以创建一个新的进程组，并将其子进程分配给该组。进程组的一个常见用途是在Shell中将一组进程一起启动或停止。 当父进程，创建子进程的时候，默认子进程与父进程属于同一进程组。进程组ID 第一个进程ID(组长进程)。所以，组长进程标识：其进程组ID 其进程ID 可以使用kill SIGKILL 进程组ID(负的)来将整个进程组内的进程全部杀死。 > 使用命令`cat cat cat wc l` > > ![image 20240328180837688](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403281808735.png) > > 可以使用`kill 9 3991`杀死这一个组 > > 这一个使用正的3991也可以, 这是因为这一个管道关闭, 读不到数据, 子进程结束 组长进程可以创建一个进程组，创建该进程组中的进程，然后终止。只要进程组中有一个进程存在，进程组就存在，与组长进程是否终止无关。 进程组生存期：进程组创建到最后一个进程离开(终止或转移到另一个进程组)。 一个进程可以为自己或子进程设置进程组ID **会话** [Linux session(会话) sparkdev 博客园 (cnblogs.com)](https://www.cnblogs.com/sparkdev/p/12146305.html) 见的 Linux session 一般是指 shell session。Shell session 是终端中当前的状态，在终端中只能有一个 session。当我们打开一个新的终端时，总会创建一个新的 shell session。 Session 中的每个进程组被称为一个 job，有一个 job 会成为 session 的前台 job(foreground)，其它的 job 则是后台 job(background)。每个 session 连接一个控制终端(control terminal)，控制终端中的输入被发送给前台 job，从前台 job 产生的输出也被发送到控制终端上。同时由控制终端产生的信号，比如 ctrl + z 等都会传递给前台 job(可以使用一个Ctrl + z 把前台的进程改到后台)。 > 1、 & > 加在一个命令的最后，可以把这个命令放到后台执行 ,如gftp &, > 2、ctrl + z > 可以将一个正在前台执行的命令放到后台，并且处于暂停状态，不可执行 > 3、jobs > 查看当前有多少在后台运行的命令 > jobs l选项可显示所有任务的PID，jobs的状态可以是running, stopped, Terminated,但是如果任务被终止了（kill），shell 从当前的shell环境已知的列表中删除任务的进程标识；也就是说，jobs命令显示的是当前shell环境中所起的后台正在运行或者被挂起的任务信息； > 4、fg > 将后台中的命令调至前台继续运行 > 如果后台中有多个命令，可以用 fg %jobnumber将选中的命令调出，%jobnumber是通过jobs命令查到的后台正在执行的命令的序号(不是pid) > 5、bg > 将一个在后台暂停的命令，变成继续执行 （在后台执行） > 如果后台中有多个命令，可以用bg %jobnumber将选中的命令调出，%jobnumber是通过jobs命令查到的后台正在执行的命令的序号(不是pid) 一般情况下 session 和终端是一对一的关系，当我们打开多个终端窗口时，实际上就创建了多个 session。 Session 的意义在于多个工作(job)在一个终端中运行，其中的一个为前台 job，它直接接收该终端的输入并把结果输出到该终端。其它的 job 则在后台运行。 会话是多个进程组的集合, > 这时候会出现一个问题, 如果你希望一个进程一直在后台执行, 但是因为这一个进程的父进程(或者父进程的父进程等)是shell终端, 一旦这一个终端关闭, 会导致这一个终端里面的所有一个组里面的进程退出 > > 解决方法: 守护进程 ### 创建会话 创建一个会话需要注意以下6点注意事项： 1. 调用进程不能是进程组组长，该进程变成新会话首进程(session header) 2. 该进程成为一个新进程组的组长进程。 3. 需有root权限 (ubuntu不需要) 4. 新会话丢弃原有的控制终端，该会话没有控制终端 5. 该调用进程是组长进程，则出错返回 6. 建立新会话时，先调用fork, 父进程终止，子进程调用setsid ### getsid获取当前的sid 获取进程所属的会话ID `pid_t getsid(pid_t pid);`成功：返回调用进程的会话ID；失败： 1，设置errno pid为0表示察看当前进程session ID ps ajx命令查看系统中的进程。参数a表示不仅列当前用户的进程，也列出所有其他用户的进程，参数x表示不仅列有控制终端的进程，也列出所有无控制终端的进程，参数j表示列出与作业控制相关的信息。 组长进程不能成为新会话首进程，新会话首进程必定会成为组长进程。 ### setsid创建一个会话 创建一个会话，并以自己的ID设置进程组ID，同时也是新会话的ID。 ​ `pid_t setsid(void);` 成功：返回调用进程的会话ID；失败： 1，设置errno ​ 调用了setsid函数的进程，既是新的会长，也是新的组长。 练习：fork一个子进程，并使其创建一个新会话。查看进程组ID、会话ID前后变化 ## 守护进程daemon Daemon(精灵)进程，是Linux中的后台服务进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以d结尾的名字。 Linux后台的一些系统服务进程，没有控制终端，不能直接和用户交互。不受用户登录、注销的影响，一直在运行着，他们都是守护进程。如：预读入缓输出机制的实现；ftp服务器；nfs服务器等。 创建守护进程，最关键的一步是调用setsid函数创建一个新的Session，并成为Session Leader。 ### 创建守护进程模型 1. 创建子进程，父进程退出所有工作在子进程中进行形式上脱离了控制终端 核心目的是**解除守护进程与启动环境的关联**，使其成为真正的后台服务。 **脱离终端控制（核心原因）** **问题**：Linux 的终端（TTY）关闭时，会向关联的进程组发送 `SIGHUP` 信号（默认终止进程）。 **解决方案**： 1. 父进程（通常是 Shell 启动的进程）退出后，其子进程（守护进程）会被 **init/systemd**（PID 1）接管（称为“孤儿进程收养”）。 2. 守护进程与启动它的终端解耦，不再受终端关闭的影响 若父进程不退出，需持续 `wait()` 子进程状态，否则子进程结束时会成为僵尸进程。 **父进程退出后**：守护进程由 init/systemd 接管，结束时 init 会自动回收资源。 2. 在子进程中创建新会话 　　 `setsid()`函数 　　 使子进程完全独立出来，脱离控制 > **解除进程组与会话的绑定** > > **问题**：进程默认继承父进程的进程组（PGID）和会话（SID），仍受终端信号（如 `SIGINT`/`SIGQUIT`）影响。 > **解决方案**： > 1. **`fork()` 后退出父进程**：子进程获得独立身份。 > 2. **子进程调用 `setsid()`**： > 创建新会话（Session）并成为会话首进程（Session Leader）。 > 脱离原终端的控制（不再有控制终端）。 3. 改变当前目录为根目录 　　 `chdir()`函数 　　 防止占用可卸载的文件系统 　　 也可以换成其它路径 > 如果这一个进程处于的目录是一个U盘, 这一个U盘被拔出来会导致这一个程序出问题, 改为根目录这一个程序就不会出错 4. 重设文件权限掩码 　　 umask()函数 　　 防止继承的文件创建屏蔽字拒绝某些权限 　　 增加守护进程灵活性 5. 关闭文件描述符(主要是标准输入输出) 　　 继承的打开文件不会用到，浪费系统资源，无法卸载, 守护任务也不需要标准的输入输出 开始执行守护进程核心工作守护进程退出处理程序模型 > 一般可以把这三个文件重定向到/dev/null里面,用于符合一般的编程习惯 ### 示例 ```c #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> #include <fcntl.h> #include <sys/types.h> #include <sys/stat.h> int main(void){ \tpid_t pid; \tpid fork();\t//1.创建子进程 \tint ret; \tif(pid > 0){ \t\texit(0); \t}else{ \t\tpid setsid(); //2.创建新的会话 \t\tif(pid 1){ \t\t\tperror(\"setid error\"); \t\t\texit(0); \t\t} \t\tret chdir(\"/home/jiao\");//3.改变文件的目录 \t\tif(ret < 0){ \t\t\tperror(\"chdir error\"); \t\t\texit(0); \t\t} \t\tumask(0022);//4.改变文件的掩码 \t\tclose(STDIN_FILENO); \t\tint fd; \t\tfd open(\"/dev/null\", O_RDWR);//5.重定向文件的输出 \t\tif(fd 1){ \t\t\tperror(\"open error\"); \t\t\texit(0); \t\t} \t\tdup2(fd, STDOUT_FILENO); \t\tdup2(fd, STDERR_FILENO); \t\twhile(1); \t} \treturn 0; } ``` ![image 20240328221130070](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403282211131.png) ### 伪装守护进程 可以使用`nohup`命令进行伪装守护进程 1. **进程关系**： `nohup`：进程仍然是原会话（session）的一部分，只是忽略了SIGHUP信号。当终端关闭时，进程的父进程（原shell）退出后，该进程会被init进程接管（成为孤儿进程），但它仍然属于原来的会话组。 守护进程：通过`fork`和`setsid`创建新的会话，完全脱离终端，并且没有控制终端。 2. **控制终端**： `nohup`：进程可能仍然关联着原来的控制终端（虽然终端关闭了，但进程组和会话没有改变），但因为没有终端，所以无法进行终端I/O。 守护进程：没有控制终端，因此不会受到终端关闭的影响。 3. **标准输入/输出/错误**： `nohup`：默认将标准输出和标准错误重定向到文件（nohup.out），但标准输入会关闭（从/dev/null读取）。 守护进程：通常会关闭或重定向所有标准I/O（通常重定向到/dev/null或日志文件）。 4. **工作目录**： `nohup`：进程的工作目录不变，如果该目录在一个可卸载的文件系统上，可能会导致问题。 守护进程：通常会将工作目录改为根目录（/），以避免阻止卸载文件系统。 5. **文件创建掩码（umask）**： `nohup`：不会改变umask。 守护进程：通常会重设umask为0，以避免从父进程继承的umask设置影响创建文件的权限。 6. **会话和进程组**： `nohup`：进程仍然在原来的会话和进程组中。 守护进程：在新的会话中运行，并且是会话首进程，没有进程组控制终端。 7. **使用场景**： `nohup`：通常用于临时性的后台任务，用户希望退出终端后任务继续运行。 守护进程：用于长期运行的服务，如Web服务器、数据库等，通常作为系统服务启动。 8. **管理方式**： `nohup`启动的进程通常由用户管理（通过ps找到进程ID，然后kill）。 守护进程通常由系统服务管理工具（如systemd, sysvinit等）管理，可以通过服务命令（如systemctl）来启动、停止、重启。 ## 线程原理 LWP：light weight process 轻量级的进程，本质仍是进程(在Linux环境下) ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403282243358.jpg) 进程：独立地址空间，拥有PCB 线程：有独立的PCB，但没有独立的地址空间(共享) 区别：在于是否共享地址空间。 独居(进程)；合租(线程)。 Linux下： 线程：最小的执行单位 ​ 进程：最小分配资源单位，可看成是只有一个线程的进程。 > 可以使用`ps Lf pid`查看一个进程的线程 > > ![image 20240328225804010](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403282258077.png) > > LWP: 执行的最小单位, 轻量级线程, 实际等于tid ### Linux内核线程实现原理 类Unix系统中，早期是没有“线程”概念的，80年代才引入，借助进程机制实现出了线程的概念。因此在这类系统中，进程和线程关系密切。 1. 轻量级进程(light weight process)，也有PCB，创建线程使用的底层函数和进程一样，都是clone 2. 从内核里看进程和线程是一样的，都有各自不同的PCB，但是PCB中指向内存资源的三级页表是相同的 3. 进程可以蜕变成线程 4. 线程可看做寄存器和栈的集合 5. 在linux下，线程最是小的执行单位；进程是最小的分配资源单位 察看LWP号：ps –Lf pid 查看指定线程的lwp号。 ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403282300315.png) 三级映射：进程PCB > 页目录(可看成数组，首地址位于PCB中) > 页表 > 物理页面 > 内存单元 [x86使用页表实现虚拟内存原理分析 使用代码分析 CSDN博客](https://blog.csdn.net/qq_61585528/article/details/136172465) 对于进程来说，相同的地址(同一个虚拟地址)在不同的进程中，反复使用而不冲突。原因是他们虽虚拟址一样，但，页目录、页表、物理页面各不相同。相同的虚拟址，映射到不同的物理页面内存单元，最终访问不同的物理页面。 但！线程不同！两个线程具有各自独立的PCB，但共享同一个页目录，也就共享同一个页表和物理页面。所以两个PCB共享一个地址空间。 ​ 实际上，无论是创建进程的fork，还是创建线程的pthread_create，底层实现都是调用同一个内核函数clone。 ​ 如果复制对方的地址空间，那么就产出一个“进程”；如果共享对方的地址空间，就产生一个“线程”。 ​ 因此：Linux内核是不区分进程和线程的。只在用户层面上进行区分。所以，线程所有操作函数 pthread_* 是库函数，而非系统调用。 ### 线程共享资源 1. 文件描述符表 2. 每种信号的处理方式 , 这一个信号的处理方式这几个线程都一样, 实际处理的是获取到的那一个, 但是线程的mask不一样, 可以改变mask使得某一个线程处理这一个信号 > 不推荐线程以及信号混合使用!!! 3. 当前工作目录 4. 用户ID和组ID 5. 内存地址空间 (.text/.data/.bss/heap/共享库), 这一个里面没有栈 ### 线程非共享资源 1. 线程id 2. 处理器现场和栈指针(内核栈, 用于处理高特权级时候使用) 3. 独立的栈空间(用户空间栈, 普通用户使用) 4. errno变量, 这是一个全局变量 5. 信号屏蔽字 6. 调度优先级 ### 线程优、缺点 ​ 优点： 1. 提高程序并发性 2. 开销小 3. 数据通信、共享数据方便(全局变量, 堆区, 以及rodata共享, 可以直接使用) ​ 缺点： 1. 库函数，不稳定 2. 调试、编写困难、gdb不支持 3. 对信号支持不好 ​ 优点相对突出，缺点均不是硬伤。Linux下由于实现方法导致进程、线程差别不是很大。 ## 线程控制 以下的函数是使用pthread 库进行线程级别的操作。 ### pthread_self获取线程ID 获取的线程ID是一个posix标准的ID, 只用于这一个进程里面的区分, 这是这一个线程库使用的变量 对应gettid, 这一个tid是进程里面标示身份的, 一个多线程的任务的所有线程的PID是一样的, tid用于区分不同的线程(内核用于时间片轮转), 这一个是系统级的(lwp:轻量级线程, 实际代表的也是这一个) > gettid() returns the caller's thread ID (TID). In a single threaded > process, the thread ID is equal to the process ID (PID, as returned by > getpid(2)). In a multithreaded process, all threads have the same PID, > but each one has a unique TID. For further details, see the discussion > of CLONE_THREAD in clone(2). > > > 可以使用这一个命令获取TID > > The pthread_self() function returns the ID of the calling thread. This > is the same value that is returned in *thread in the pthread_create(3) > call that created this thread. > > Thread IDs are guaranteed to be unique only within a process. A thread > ID may be reused after a terminated thread has been joined, or a > detached thread has terminated. > > > 使用这一个命令获取这一个线程在这一个库里面的编号 ### pthread_create函数 创建一个新线程。 其作用，对应进程中fork() 函数。 `int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);` ​ 返回值：成功：0； 失败：错误号 Linux环境下，所有线程特点，失败均直接返回错误号。 参数： ​ pthread_t：当前Linux中可理解为：typedef unsigned long int pthread_t; > 参数1：传出参数，保存系统为我们分配好的线程ID > > 参数2：通常传NULL，表示使用线程默认属性。若想使用具体属性也可以修改该参数。设置这一个线程的优先级, 线程的栈空间大小 > > > The attr argument points to a pthread_attr_t structure whose contents > > are used at thread creation time to determine attributes for the new > > thread; this structure is initialized using pthread_attr_init(3) and > > related functions. If attr is NULL, then the thread is created with > > default attributes. > > > > 这一个参数使用pthread_attr_init这一个函数 > > 参数3：函数指针，指向线程主函数(线程体)，该函数运行结束，则线程结束 > > 参数4：线程主函数执行期间所使用的参数 在一个线程中调用pthread_create()创建新的线程后，当前线程从pthread_create()返回继续往下执行，而新的线程所执行的代码由我们传给pthread_create的函数指针start_routine决定。 start_routine函数接收一个参数，是通过pthread_create的arg参数传递给它的，该参数的类型为void *，这个指针按什么类型解释由调用者自己定义。start_routine的返回值类型也是void *，这个指针的含义同样由调用者自己定义。start_routine返回时，这个线程就退出了，其它线程可以调用pthread_join得到start_routine的返回值，类似于父进程调用wait(2)得到子进程的退出状态，稍后详细介绍pthread_join。 pthread_create成功返回后，新创建的线程的id被填写到thread参数所指向的内存单元。我们知道进程id的类型是pid_t，每个进程的id在整个系统中是唯一的，调用getpid(2)可以获得当前进程的id，是一个正整数值。线程id的类型是thread_t，它只在当前进程中保证是唯一的，在不同的系统中thread_t这个类型有不同的实现，它可能是一个整数值，也可能是一个结构体，也可能是一个地址，所以不能简单地当成整数用printf打印，调用pthread_self(3)可以获得当前线程的id。 attr参数表示线程属性，本节不深入讨论线程属性，所有代码例子都传NULL给attr参数，表示线程属性取缺省值，感兴趣的读者可以参考APUE。 #### 示例 ```c #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> #include <pthread.h> #include <sys/types.h> #include <string.h> void *thread_handler(void *arg){ \tprintf(\" thread \\n\"); \tprintf(\"pid %d, swl %ld\\n\", \t\t\tgetpid(), pthread_self()); \treturn NULL; } int main(void){ \tpthread_t tid; \ttid pthread_self(); \tprintf(\"main pid %d swl %ld \\n\", getpid(), tid); \tint ret pthread_create(&tid, NULL, thread_handler, NULL); \tif(ret ! 0){ \t\tprintf(\"pthreat creat error, %d %s\\n\", ret, strerror(ret)); \t\texit(0); \t} \tprintf(\"tid now %ld\\n\", tid); \tsleep(1); \treturn 0; } ``` > 由于pthread_create的错误码不保存在errno中，因此不能直接用perror(3)打印错误信息，可以先用strerror(3)把错误码转换成错误信息再打印。 > 如果任意一个线程调用了exit或_exit，则整个进程的所有线程都终止，由于从main函数return也相当于调用exit，为了防止新创建的线程还没有得到执行就终止 > > 创建的线程的return实际效果是执行pthread_exit返回这一个返回值, main返回实际会结束这一个线程组, 相当于exit #### 线程属性 linux下线程的属性是可以根据实际项目需要，进行设置，之前我们讨论的线程都是采用线程的默认属性，默认属性已经可以解决绝大多数开发时遇到的问题。如我们对程序的性能提出更高的要求那么需要设置线程属性，比如可以通过设置线程栈的大小来降低内存的使用，增加最大线程个数。 ```c typedef struct { int etachstate; //线程的分离状态 int schedpolicy; //线程调度策略 struct sched_param schedparam; //线程的调度参数 int inheritsched; //线程的继承性 int scope; //线程的作用域 size_t guardsize; //线程栈末尾的警戒缓冲区大小 int stackaddr_set; //线程的栈设置 void* stackaddr; //线程栈的位置 size_t stacksize; //线程栈的大小 } pthread_attr_t; ``` > 这是一个比较早的版本 主要结构体成员： 1. 线程分离状态 2. 线程栈大小（默认平均分配） 3. 线程栈警戒缓冲区大小（位于栈末尾） 参 APUE.12.3 线程属性 属性值不能直接设置，须使用相关函数进行操作，初始化的函数为pthread_attr_init，这个函数必须在pthread_create函数之前调用。之后须用pthread_attr_destroy函数来释放资源。 线程属性主要包括如下属性：作用域（scope）、栈尺寸（stack size）、栈地址（stack address）、优先级（priority）、分离的状态（detached state）、调度策略和参数（scheduling policy and parameters）。默认的属性为非绑定、非分离、缺省的堆栈、与父进程同样级别的优先级。 #### 线程属性初始化 注意：应先初始化线程属性，再pthread_create创建线程 初始化线程属性 `int pthread_attr_init(pthread_attr_t *attr);` 成功：0；失败：错误号 销毁线程属性所占用的资源 `int pthread_attr_destroy(pthread_attr_t *attr);` 成功：0；失败：错误号 #### 线程的分离状态 线程的分离状态决定一个线程以什么样的方式来终止自己。 非分离状态：线程的默认属性是非分离状态，这种情况下，原有的线程等待创建的线程结束。只有当pthread_join()函数返回时，创建的线程才算终止，才能释放自己占用的系统资源。 分离状态：分离线程没有被其他的线程所等待，自己运行结束了，线程也就终止了，马上释放系统资源。应该根据自己的需要，选择适当的分离状态。 线程分离状态的函数： 设置线程属性，分离or非分离 `int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate); ` 获取程属性，分离or非分离 ` int pthread_attr_getdetachstate(pthread_attr_t *attr, int *detachstate); ` ​ 参数： attr：已初始化的线程属性 detachstate： PTHREAD_CREATE_DETACHED（分离线程） ​\t\t\t\t\t\tPTHREAD _CREATE_JOINABLE（非分离线程） 这里要注意的一点是，如果设置一个线程为分离线程，而这个线程运行又非常快，它很可能在pthread_create函数返回之前就终止了，它终止以后就可能将线程号和系统资源移交给其他的线程使用，这样调用pthread_create的线程就得到了错误的线程号。要避免这种情况可以采取一定的同步措施，最简单的方法之一是可以在被创建的线程里调用pthread_cond_timedwait函数，让这个线程等待一会儿，留出足够的时间让函数pthread_create返回。设置一段等待时间，是在多线程编程里常用的方法。但是注意不要使用诸如wait()之类的函数，它们是使整个进程睡眠，并不能解决线程同步的问题。 #### 示例1: 使用属性设置是否分离 ```c #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> #include <pthread.h> #include <string.h> void *pthread_func(void *arg){ \tprintf(\"pthread_func\\n\"); \treturn (void *)0x1234; } int main(void){ \tpthread_t tid; \tpthread_attr_t attr; \tint ret; \tret pthread_attr_init(&attr); \tif(ret ! 0){ \t\tprintf(\"pthread_attr_init %s\\n\", strerror(ret)); \t\texit(1); \t} \tret pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED); \tif(ret ! 0){ \t\tprintf(\"pthread_attr_setdetachstate %s\\n\", strerror(ret)); \t\texit(1); \t} \tret pthread_create(&tid, &attr, (void *)pthread_func, NULL); \tif(ret ! 0){ \t\tprintf(\"pthread_create %s\\n\", strerror(ret)); \t\texit(1); \t} \t.... } ``` > 设置一个分离属性 #### 示例2: 使用属性设置栈大小 ```c #include <pthread.h> #define SIZE 0x100000 void *th_fun(void *arg) { \twhile (1) \t\tsleep(1); } int main(void) { \tpthread_t tid; \tint err, detachstate, i 1; \tpthread_attr_t attr; \tsize_t stacksize; \tvoid *stackaddr; \tpthread_attr_init(&attr);\t\t \tpthread_attr_getstack(&attr, &stackaddr, &stacksize);//获取现在的栈的状态 \tpthread_attr_getdetachstate(&attr, &detachstate);//获取这一个线程的线程是否分离 \tif (detachstate PTHREAD_CREATE_DETACHED) \t\tprintf(\"thread detached\\n\"); \telse if (detachstate PTHREAD_CREATE_JOINABLE) \t\tprintf(\"thread join\\n\"); \telse \t\tprintf(\"thread unknown\\n\"); \tpthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);//设置属性的状态 \twhile (1) { \t\tstackaddr malloc(SIZE);//获取一块新的栈 \t\tif (stackaddr NULL) { \t\t\tperror(\"malloc\"); \t\t\texit(1); \t\t} \t\tstacksize SIZE; \t\tpthread_attr_setstack(&attr, stackaddr, stacksize);//设置这一个新的栈 \t\terr pthread_create(&tid, &attr, th_fun, NULL); \t\tif (err ! 0) { \t\t\tprintf(\"%s\\n\", strerror(err)); \t\t\texit(1); \t\t} \t\tprintf(\"%d\\n\", i++); \t} \tpthread_attr_destroy(&attr); \treturn 0; }\t ``` ### pthread_exit线程的退出 将单个线程退出 ​ `void pthread_exit(void *retval);` 参数：retval表示线程退出状态，通常传NULL ​ 结论：线程中，禁止使用exit函数，会导致进程内所有线程全部退出。 ​ 在不添加sleep控制输出顺序的情况下。pthread_create在循环中，几乎瞬间创建5个线程，但只有第1个线程有机会输出（或者第2个也有，也可能没有，取决于内核调度）如果第3个线程执行了exit，将整个进程退出了，所以全部线程退出了。 > 所以，多线程环境中，应尽量少用，或者不使用exit函数，取而代之使用pthread_exit函数，将单个线程退出。任何线程里exit导致进程退出，其他线程未工作结束，主控线程退出时不能return或exit。 **注意**，pthread_exit或者return返回的指针所指向的内存单元必须是全局的或者是用malloc分配的，不能在线程函数的栈上分配，因为当其它线程得到这个返回指针时线程函数已经退出了。 ```c #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> #include <pthread.h> #include <sys/types.h> #include <string.h> void *thread_handler(void *arg){ \tif((long)arg 3){ \t\tpthread_exit((void *)0);//可以单独退出某一个线程 \t} \tprintf(\" thread%ld \\n\", (long)arg); \tprintf(\"pid %d, swl %ld\\n\", \t\t\tgetpid(), pthread_self()); \treturn NULL; } int main(void){ \tpthread_t tid; \ttid pthread_self(); \tprintf(\"main pid %d swl %ld \\n\", getpid(), tid); \tfor(long i 0 ; i < 5 ;i ++){ \t\tint ret pthread_create(&tid, NULL, thread_handler, (void *)i); \t\tif(ret ! 0){ \t\t\tprintf(\"pthreat creat error, %d %s\\n\", ret, strerror(ret)); \t\t\texit(0); \t\t} \t} \tprintf(\"parent pid %d tid now %ld\\n\",getpid(), tid); \t//return 0; \tpthread_exit((void *)0);//这个时候不需要sleep了 } ``` ### pthread_join获取返回值 阻塞等待线程退出，获取线程退出状态 其作用，对应进程中 waitpid() 函数。 ​ int pthread_join(pthread_t thread, void **retval); 成功：0；失败：错误号 ​ 参数：thread：线程ID （【注意】：不是指针）；retval：存储线程结束状态。 ```c #include <stdio.h> #include <pthread.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> #include <string.h> struct thrd { \tint val; \tchar str[256]; }; void * tfn(void *arg){ \tstruct thrd *tval;//初始化一块结构体 \ttval malloc(sizeof(struct thrd)); \ttval >val 100; \tstrcpy(tval >str, \"hello world\"); \treturn (void *)tval; } int main(void){ \tpthread_t tid; \tint ret pthread_create(&tid, NULL, tfn, NULL); \tif(ret ! 0){ \t\tprintf(\"pthread creat error %d :%s\", ret, strerror(ret)); \t\texit(1); \t} \tvoid *retval; \tret pthread_join(tid, &retval);//获取这一个的信息 if(ret ! 0){ printf(\"pthread join error %d :%s\", ret, strerror(ret)); exit(1); } \tprintf(\"get thread ret : %d %s\\n\", ((struct thrd*)retval) >val, \t\t\t((struct thrd*)retval) >str);//打印信息 free(retval); \tpthread_exit(NULL); \treturn 0; } ``` > ![image 20240330104236795](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403301042145.png) > 回收多个进程的时候需要使用数组 ### pthread_detach线程的分离 ` int pthread_detach(pthread_t thread); 成功：0；`失败：错误号 ​ 线程分离状态：指定该状态，线程主动与主控线程断开关系。线程结束后，其退出状态不由其他线程获取，而直接自己自动释放。网络、多线程服务器常用。 ​ 进程若有该机制，将不会产生僵尸进程。僵尸进程的产生主要由于进程死后，大部分资源被释放，一点残留资源仍存于系统中，导致内核认为该进程仍存在。 ​ 也可使用 pthread_create函数参2(线程属性)来设置线程分离。 ```c #include <stdio.h> #include <pthread.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> #include <string.h> struct thrd { \tint val; \tchar str[256]; }; void * tfn(void *arg){ \tstruct thrd *tval; \ttval malloc(sizeof(struct thrd)); \ttval >val 100; \tstrcpy(tval >str, \"hello world\"); \treturn (void *)tval; } int main(void){ \tpthread_t tid; \tint ret pthread_create(&tid, NULL, tfn, NULL); \tif(ret ! 0){ \t\tprintf(\"pthread creat error %d :%s\", ret, strerror(ret)); \t\texit(1); \t} \tret pthread_detach(tid);\t\t\t//进行分离 \tif(ret ! 0){ \t\tprintf(\"pthread detach error %d :%s\", ret, strerror(ret)); \t\texit(1); \t} \tvoid *retval; \tret pthread_join(tid, &retval);\t//获取这一个线程的返回值, 这个时候已经分离了, 会失败 \tif(ret ! 0){ \t\tprintf(\"pthread join error %d :%s\", ret, strerror(ret)); \t\texit(1); \t} \tprintf(\"get thread ret : %d %s\\n\", ((struct thrd*)retval) >val, \t\t\t((struct thrd*)retval) >str); \tpthread_exit(NULL); \tfree(retval); \treturn 0; } ``` ![image 20240330125240212](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403301252305.png) ### pthread_cancel函数 杀死(取消)线程 其作用，对应进程中 kill() 函数。 ​ int pthread_cancel(pthread_t thread); 成功：0；失败：错误号 > 【注意】：线程的取消并不是实时的，而有一定的延时。需要等待线程到达某个取消点(检查点)。类似于玩游戏存档，必须到达指定的场所(存档点，如：客栈、仓库、城里等)才能存储进度。杀死线程也不是立刻就能完成，必须要到达取消点。 > 取消点：是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用creat，open，pause，close，read，write..... 执行命令man 7 pthreads可以查看具备这些取消点的系统调用列表。也可参阅 APUE.12.7 取消选项小节。可粗略认为一个系统调用(进入内核)即为一个取消点。如线程中没有取消点，可以通过调用pthread_testcancel函数自行设置一个取消点。 被取消的线程， 退出值定义在Linux的pthread库中。常数PTHREAD_CANCELED的值是 1。可在头文件pthread.h中找到它的定义：**#define PTHREAD_CANCELED ((void \\*) 1)****。**因此当我们对一个已经被取消的线程使用pthread_join回收时，得到的返回值为 1。 ```c #include <stdio.h> #include <pthread.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> #include <string.h> void * tfn(void *arg){ \twhile(1){ \t\tprintf(\"thread pid %d, tid %lu\\n\", getpid(), pthread_self()); \t\tsleep(1); \t} \treturn NULL; } int main(void){ \tpthread_t tid; \tint ret pthread_create(&tid, NULL, tfn, NULL); \tif(ret ! 0){ \t\tprintf(\"pthread creat error %d :%s\", ret, strerror(ret)); \t\texit(1); \t} \tprintf(\"main pid %d, tid %lu\\n\", getpid(), pthread_self()); \tsleep(5); \tret pthread_cancel(tid); \tif(ret ! 0){ \t\texit(1); \t} \t \twhile(1); } ``` ![image 20240330111848766](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403301118840.png) > if the target > thread was canceled, then PTHREAD_CANCELED is placed in the location > pointed to by retval > > 这一个进程使用pthread_join回收的值是 1 > > ```c > long retv; > pthread_join(tid, (void **)&retv); > printf(\"ret %ld\\n\", retv); > ``` > > ![image 20240330112923210](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403301129279.png) > **注: ** > > 如果这一个子线程使用的是一个while(1);之类的死循环是无法退出的, 因为没有取消点(进入内核) > > ```c > #include <stdio.h> > #include <pthread.h> > #include <stdlib.h> > #include <unistd.h> > #include <errno.h> > #include <string.h> > > > void * tfn(void *arg){ > \twhile(1){ > \t} > \treturn NULL; > } > > int main(void){ > \tpthread_t tid; > \tint ret pthread_create(&tid, NULL, tfn, NULL); > \tif(ret ! 0){ > \t\tprintf(\"pthread creat error %d :%s\", ret, strerror(ret)); > \t\texit(1); > \t} > > \tprintf(\"main pid %d, tid %lu\\n\", getpid(), pthread_self()); > \tsleep(5); > \tret pthread_cancel(tid); > \tif(ret ! 0){ > \t\texit(1); > \t} > \tlong retv; > \tpthread_join(tid, (void **)&retv);//会在这里卡死 > \tprintf(\"ret %ld\\n\", retv); > > } > ``` > > 可以使用函数pthread_testcancel添加一个取消点 > > ```c > \twhile(1){ > \t\tpthread_testcancel(); > } > ``` ### pthread_kill发送信号 ```c #include <signal.h> int pthread_kill(pthread_t thread, int sig); ``` 发送零的时候不会发送信息, 但是会检测错误, 可以使用这一个来判断这一个线程是不是存活 ## 总结 ### 和进程对比 线程 进程 : : : : pthread_create fork pthread_self getpid pthread_exit exit pthread_join wait/waitpid pthread_cancel kill pthread_detach 无 #### 终止线程方式 总结：终止某个线程而不终止整个进程，有三种方法： 1. 从线程主函数return。这种方法对主控线程不适用，从main函数return相当于调用exit。 2. 一个线程可以调用pthread_cancel终止同一进程中的另一个线程。 3. 线程可以调用pthread_exit终止自己。 ## 线程使用注意事项 1. 主线程退出其他线程不退出，主线程应调用pthread_exit 2. 避免僵尸线程 > pthread_join > > pthread_detach > > pthread_create指定分离属性 被join线程可能在join函数返回前就释放完自己的所有内存资源，所以不应当返回被回收线程栈中的值; 3. malloc和mmap申请的内存可以被其他线程释放 4. 应避免在多线程模型中调用fork除非，马上exec，子进程中只有调用fork的线程存在，其他线程在子进程中均pthread_exit 5. 信号的复杂语义很难和多线程共存，应避免在多线程引入信号机制"},"/note/Linux/Linux系统编程/2024-3-25-05信号.html":{"title":"信号","content":" layout: post title: \"信号\" date: 2024 3 25 15:39:08 +0800 tags: Linux # 信号 特性: 1. 简单 2. 不能携带大量的信息 3. 满足某一个特定的条件 ## 信号的机制 ​ A给B发送信号，B收到信号之前执行自己的代码，收到信号后，不管执行到程序的什么位置，都要暂停运行，去处理信号，处理完毕再继续执行。与硬件中断类似——异步模式。但信号是软件层面上实现的中断，早期常被称为“软中断”。 **信号的特质**：由于信号是通过软件方法实现，其实现手段导致信号有很强的延时性。但对于用户来说，这个延迟时间非常短，不易察觉。 ​ **每个进程收到的所有信号，都是由内核负责发送的，内核处理。** ## 与信号相关的事件和状态 ​ 产生信号: 1. 按键产生，如：Ctrl+c、Ctrl+z、Ctrl+\\ 2. 系统调用产生，如：kill、raise、abort 3. 软件条件产生，如：定时器alarm 4. 硬件异常产生，如：非法访问内存(段错误)、除0(浮点数例外)、内存对齐出错(总线错误) 5. 命令产生，如：kill命令 ​ **递达**：递送并且到达进程。 ​ **未决**：产生和递达之间的状态。主要由于阻塞(屏蔽)导致该状态。 **信号的处理方式:** 1. 执行默认动作 2. 忽略(丢弃) 3. 捕捉(调用户处理函数) Linux内核的进程控制块PCB是一个结构体，task_struct, 除了包含进程id，状态，工作目录，用户id，组id，文件描述符表，还包含了信号相关的信息，主要指阻塞信号集和未决信号集。 **阻塞信号集(信号屏蔽字)**： 将某些信号加入集合，对他们设置屏蔽，当屏蔽x信号后，再收到该信号，该信号的处理将推后(解除屏蔽后) **未决信号集**: 1. 信号产生，未决信号集中描述该信号的位立刻翻转为1，表信号处于未决状态。当信号被处理对应位翻转回为0。这一时刻往往非常短暂。 2. 信号产生后由于某些原因(主要是阻塞)不能抵达。这类信号的集合称之为未决信号集。在屏蔽解除前，信号一直处于未决状态。 > 这两个使用的都是位图 ### 信号的编号 ​ 可以使用kill –l命令查看当前系统可使用的信号有哪些。 ``` 1) SIGHUP\t 2) SIGINT\t 3) SIGQUIT\t 4) SIGILL\t 5) SIGTRAP 6) SIGABRT\t 7) SIGBUS\t 8) SIGFPE\t 9) SIGKILL\t10) SIGUSR1 11) SIGSEGV\t12) SIGUSR2\t13) SIGPIPE\t14) SIGALRM\t15) SIGTERM 16) SIGSTKFLT\t17) SIGCHLD\t18) SIGCONT\t19) SIGSTOP\t20) SIGTSTP 21) SIGTTIN\t22) SIGTTOU\t23) SIGURG\t24) SIGXCPU\t25) SIGXFSZ 26) SIGVTALRM\t27) SIGPROF\t28) SIGWINCH\t29) SIGIO\t30) SIGPWR 31) SIGSYS\t34) SIGRTMIN\t35) SIGRTMIN+1\t36) SIGRTMIN+2\t37) SIGRTMIN+3 38) SIGRTMIN+4\t39) SIGRTMIN+5\t40) SIGRTMIN+6\t41) SIGRTMIN+7\t42) SIGRTMIN+8 43) SIGRTMIN+9\t44) SIGRTMIN+10\t45) SIGRTMIN+11\t46) SIGRTMIN+12\t47) SIGRTMIN+13 48) SIGRTMIN+14\t49) SIGRTMIN+15\t50) SIGRTMAX 14\t51) SIGRTMAX 13\t52) SIGRTMAX 12 53) SIGRTMAX 11\t54) SIGRTMAX 10\t55) SIGRTMAX 9\t56) SIGRTMAX 8\t57) SIGRTMAX 7 58) SIGRTMAX 6\t59) SIGRTMAX 5\t60) SIGRTMAX 4\t61) SIGRTMAX 3\t62) SIGRTMAX 2 63) SIGRTMAX 1\t64) SIGRTMAX\t ``` > 前面的31个是普通信号(常规信号), 是编程会使用的, 34以后的信号实时信号, 没有默认的事件, 一般用于驱动的开发 ### 信号4要素 与变量三要素类似的，每个信号也有其必备4要素，分别是： 1. 编号 2. 名称 3. 事件 4. 默认处理动作 使用的时候需要确定这几条信息 > 可以使用man 7 signal查看 > ────────────────────────────────────────────────────────────────────── > SIGHUP 1 Term Hangup detected on controlling terminal > or death of controlling process > SIGINT 2 Term Interrupt from keyboard > SIGQUIT 3 Core Quit from keyboard > SIGILL 4 Core Illegal Instruction > SIGABRT 6 Core Abort signal from abort(3) > SIGFPE 8 Core Floating point exception > SIGKILL 9 Term Kill signal > SIGSEGV 11 Core Invalid memory reference > SIGPIPE 13 Term Broken pipe: write to pipe with no > readers; see pipe(7) > SIGALRM 14 Term Timer signal from alarm(2) > SIGTERM 15 Term Termination signal > SIGUSR1 30,10,16 Term User defined signal 1 > SIGUSR2 31,12,17 Term User defined signal 2 > SIGCHLD 20,17,18 Ign Child stopped or terminated > SIGCONT 19,18,25 Cont Continue if stopped > SIGSTOP 17,19,23 Stop Stop process > SIGTSTP 18,20,24 Stop Stop typed at terminal > SIGTTIN 21,21,26 Stop Terminal input for background process > SIGTTOU 22,22,27 Stop Terminal output for background process > > > 这一段有三个值的时候实际使用与区分不同的架构, 第二个是x86以及arm使用的, 实际使用的时候用这一个宏定义是不会错的 默认动作： ​ Term：终止进程 ​ Ign： 忽略信号 (默认即时对该种信号忽略操作) ​ Core：终止进程，生成Core文件。(查验进程死亡原因， 用于gdb调试) ​ Stop：停止（暂停）进程 ​ Cont：继续运行进程 > 注意从man 7 signal帮助文档中可看到 : The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored. > > 这里特别强调了**9) SIGKILL 和19) SIGSTOP信号，不允许忽略和捕捉，只能执行默认动作。甚至不能将其设置为阻塞。** > > **外需清楚，只有每个信号所对应的事件发生了，该信号才会被递送(但不一定递达)，不应乱发信号！！** ### Linux常规信号一览表 信号名 信号编号 产生原因 默认处理方式 SIGHUP 1 关闭终端 终止 SIGINT 2 ctrl+c 终止 SIGQUIT 3 ctrl+\\ 终止+转储(记录运行的最后状态) SIGABRT 6 abort() 终止+转储 SIGPE 8 算术错误 终止 SIGKILL 9 kill 9 pid 终止，不可被捕获/忽略 SIGUSR1 10 自定义 忽略 SIGSEGV 11 段错误 终止+转储 SIGUSR2 12 自定义 忽略 SIGALRM 14 alarm() 终止 SIGTERM 15 kill pid 终止 SIGCHLD 17 (子)状态变化 忽略 SIGTOP 19 ctrl+z 暂停，不可捕获/忽略 > 可以使用命令`pkill 应用名称`直接杀死进程, 比如`pkill sleep` > 1) SIGHUP: 当用户退出shell时，由该shell启动的所有进程将收到这个信号，默认动作为终止进程 > 2) SIGINT：当用户按下了<Ctrl+C>组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号。默认动作为终止进程。 > 3) SIGQUIT：当用户按下<ctrl+\\\\>组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出些信号。默认动作为终止进程。 > 4) SIGILL：CPU检测到某进程执行了非法指令。默认动作为终止进程并产生core文件 > 5) SIGTRAP：该信号由断点指令或其他 trap指令产生。默认动作为终止里程 并产生core文件。 > 6) SIGABRT: 调用abort函数时产生该信号。默认动作为终止进程并产生core文件。 > 7) SIGBUS：非法访问内存地址，包括内存对齐出错，默认动作为终止进程并产生core文件。 > 8) SIGFPE：在发生致命的运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为0等所有的算法错误。默认动作为终止进程并产生core文件。 > 9) SIGKILL：无条件终止进程。本信号不能被忽略，处理和阻塞。默认动作为终止进程。它向系统管理员提供了可以杀死任何进程的方法。 > 10) SIGUSE1：用户定义 的信号。即程序员可以在程序中定义并使用该信号。默认动作为终止进程。 > 11) SIGSEGV：指示进程进行了无效内存访问。默认动作为终止进程并产生core文件。 > 12) SIGUSR2：另外一个用户自定义信号，程序员可以在程序中定义并使用该信号。默认动作为终止进程。 > 13) SIGPIPE：Broken pipe向一个没有读端的管道写数据。默认动作为终止进程。 > 14) SIGALRM: 定时器超时，超时的时间 由系统调用alarm设置。默认动作为终止进程。 > 15) SIGTERM：程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和终止。通常用来要示程序正常退出。执行shell命令Kill时，缺省产生这个信号。默认动作为终止进程。 > 16) SIGSTKFLT：Linux早期版本出现的信号，现仍保留向后兼容。默认动作为终止进程。 > 17) SIGCHLD：子进程状态发生变化时，父进程会收到这个信号。默认动作为**忽略**这个信号。 > 18) SIGCONT：如果进程已停止，则使其继续运行。默认动作为继续/忽略。 > 19) SIGSTOP：停止进程的执行。信号不能被忽略，处理和阻塞。默认动作为暂停进程。 > 20) SIGTSTP：停止终端交互进程的运行。按下<ctrl+z>组合键时发出这个信号。默认动作为暂停进程。 > 21) SIGTTIN：后台进程读终端控制台。默认动作为暂停进程。 > 22) SIGTTOU: 该信号类似于SIGTTIN，在后台进程要向终端输出数据时发生。默认动作为暂停进程。 > 23) SIGURG：套接字上有紧急数据时，向当前正在运行的进程发出些信号，报告有紧急数据到达。如网络带外数据到达，默认动作为忽略该信号。 > 24) SIGXCPU：进程执行时间超过了分配给该进程的CPU时间 ，系统产生该信号并发送给该进程。默认动作为终止进程。 > 25) SIGXFSZ：超过文件的最大长度设置。默认动作为终止进程。 > 26) SIGVTALRM：虚拟时钟超时时产生该信号。类似于SIGALRM，但是该信号只计算该进程占用CPU的使用时间。默认动作为终止进程。 > 27) SGIPROF：类似于SIGVTALRM，它不公包括该进程占用CPU时间还包括执行系统调用时间。默认动作为终止进程。 > 28) SIGWINCH：窗口变化大小时发出。默认动作为忽略该信号。 > 29) SIGIO：此信号向进程指示发出了一个异步IO事件。默认动作为忽略。 > 30) SIGPWR：关机。默认动作为终止进程。 > 31) SIGSYS：无效的系统调用。默认动作为终止进程并产生core文件。SIGRTMIN ～ (64) SIGRTMAX：LINUX的实时信号，它们没有固定的含义（可以由用户自定义）。所有的实时信号的默认动作都为终止进程。 ### 终端按键产生信号 Ctrl + c → 2) SIGINT（终止/中断） \"INT\" Interrupt Ctrl + z → 20) SIGTSTP（暂停/停止） \"T\" Terminal 终端。 Ctrl + \\ → 3) SIGQUIT（退出） Ctrl + > 3) SIGQUIT (实际是Shift + \\\\) ### 硬件异常产生信号 除0操作 → 8) SIGFPE (浮点数例外) \"F\" float 浮点数。 非法访问内存 → 11) SIGSEGV (段错误) 总线错误 → 7) SIGBUS ## 发送信号函数 ### kill发送一个信号 `int kill(pid_t pid, int sig);` > pid > 0: 发送信号给指定的进程。 > > pid 0: 发送信号给 与调用kill函数进程属于同一进程组的所有进程。 > > pid < 0: 取pid发给对应进程组。 > > pid 1：发送给进程有权限发送的系统中所有进程。 ### alarm定时器 在指定seconds后，内核会给当前进程发送14）SIGALRM信号。进程收到该信号，默认动作终止。 `unsigned int alarm(unsigned int seconds);` 取消定时器alarm(0)，返回旧闹钟余下秒数。, 没有错误的返回值 实际时间 用户时间 + 内核时间 + 等待时间 #### setitimer函数 > 设置定时器(闹钟)。 可代替alarm函数。精度微秒us，可以实现周期定时。 ` int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value)`; 成功：0；失败： 1，设置errno > 可以使用`int getitimer(int which, struct itimerval *curr_value);`获取时间 ​ 参数：which：指定定时方式, 设置不同的which会发生不同的信号 ​ ① 自然定时：\t\t\t\t\t\tITIMER_REAL \t\t → 14）SIGLARM 计算自然时间 ​ ② 虚拟空间计时(用户空间)：ITIMER_VIRTUAL\t → 26）SIGVTALRM 只计算进程占用cpu的时间 ​ ③ 运行时计时(用户+内核)： ITIMER_PROF \t\t → 27）SIGPROF 计算占用cpu及执行系统调用的时间 提示： it_interval：用来设定两次定时任务之间间隔的时间。 ​ it_value：定时的时长 两个参数都设置为0，即清0操作。 ```c struct itimerval { struct timeval it_interval; /* Interval for periodic timer */ struct timeval it_value; /* Time until next expiration */ }; struct timeval { time_t tv_sec; /* seconds 秒*/ suseconds_t tv_usec; /* microseconds 微秒*/ }; ``` > settimer工作机制是，先对it_value倒计时，当it_value为零时触发信号，然后重置为it_interval，继续对it_value倒计时，一直这样循环下去。 ```c #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> #include <sys/time.h> #include <signal.h> void myfunc(int signal){ \tprintf(\"get a signal\\n\"); } int main(void){ \tstruct itimerval it, oldit; \tsignal(SIGALRM, myfunc); \tit.it_value.tv_sec 2;//倒计时2秒 \tit.it_value.tv_usec 0; \tit.it_interval.tv_sec 15;//之后开始循环 \tit.it_interval.tv_usec 0; \tif(setitimer(ITIMER_REAL, &it, &oldit) 1){ \t\tperror(\"setitimer error\"); \t\treturn 1; \t} \twhile(1); } ``` ## 信号集(屏蔽)操作函数 内核通过读取未决信号集来判断信号是否应被处理。信号屏蔽字mask可以影响未决信号集。而我们可以在应用程序中自定义set来改变mask。已达到屏蔽指定信号的目的。 可以操控阻塞信号集以信号屏蔽, 从而达到影响未决信号集的目的 ### 信号集设定 > sigset_t set; // typedef unsigned long sigset_t; `int sigemptyset(sigset_t *set);` 将某个信号集清0 成功：0；失败： 1 `int sigfillset(sigset_t *set); ` 将某个信号集置1 成功：0；失败： 1 > 使用set对信号集进行设置或者清除 `int sigaddset(sigset_t *set, int signum);` 将某个信号加入信号集 成功：0；失败： 1 > 把这一个sigset_t的某一位设置为1 `int sigdelset(sigset_t *set, int signum);` 将某个信号清出信号集 成功：0；失败： 1 `int sigismember(const sigset_t *set, int signum);`判断某个信号是否在信号集中 返回值：在集合：1；不在：0；出错： 1 sigset_t类型的本质是位图。但不应该直接使用位操作，而应该使用上述函数，保证跨系统操作有效。对比认知select 函数。 > 这几个函数实际是对这一个位图的操作, Linux不希望直接操作位图里面的位 ### sigprocmask设置屏蔽信号 用来屏蔽信号、解除屏蔽也使用该函数。其本质，读取或修改进程的信号屏蔽字(PCB中) > 严格注意，屏蔽信号：只是将信号处理延后执行(延至解除屏蔽)；而忽略表示将信号丢处理。 `int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);` 成功：0；失败： 1，设置errno 参数： ​ set：传入参数，是一个位图，set中哪位置1，就表示当前进程屏蔽哪个信号。 ​ oldset：传出参数，保存旧的信号屏蔽集。 ​ how参数取值： 假设当前的信号屏蔽字为mask 1. SIG_BLOCK: 当how设置为此值，set表示需要屏蔽的信号。相当于 mask maskset 2. SIG_UNBLOCK: 当how设置为此，set表示需要解除屏蔽的信号。相当于 mask mask & ~set 3. SIG_SETMASK: 当how设置为此，set表示用于替代原始屏蔽及的新屏蔽集。相当于 mask set若，调用sigprocmask解除了对当前若干个信号的阻塞，则在sigprocmask返回前，至少将其中一个信号递达。 ### sigpending读取未决信号集 读取当前进程的**未决**信号集 `int sigpending(sigset_t *set);` set传出参数。 返回值：成功：0；失败： 1，设置errno > 在实际处理的时候需要区分一下这个信号是不是一个实时信号, 如果这个信号是一个非实时的信号, 这个信号是不进行排队的, 多个信号只保留一个(0 31) > > 如果是一个实时信号, 信号会进行排队, 所有的信号都会进行保留 ### 示例 ```c #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> #include <signal.h> //打印现在挂起的信号 void printf_set(sigset_t set){ \tfor(int i 1;i<32;i++){ \t\tif(sigismember(&set, i)){ \t\t\tputchar('1'); \t\t}else \t\t\tputchar('0'); \t} \tprintf(\"\\n\"); } int main(void){ \tint ret; \tsigset_t set, oldset, myset; \tsigemptyset(&set); \tsigaddset(&set, SIGINT);//设置一下要屏蔽的信号(Ctrl + C) \tret sigprocmask(SIG_BLOCK, &set, &oldset);//设置对应的信号到mask \tif(ret < 0){ \t\tperror(\"sigprocmask error\"); \t\texit(1); \t} \t \twhile(1){ \t\tret sigpending(&myset);//获取挂起的信号 \t\tif(ret < 0){ \t\t\tperror(\"sigprocmask error\"); \t\t\texit(1); \t\t} \t\tprintf_set(myset); \t\tsleep(1); \t} \treturn 0 ; } ``` > ![image 20240327212217099](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403272122336.png) ## 信号捕捉 ### signal设置信号处理函数 注册一个信号捕捉函数, 这一个信号捕获以后执行这一个函数： `typedef void (*sighandler_t)(int);` `sighandler_t signal(int signum, sighandler_t handler);` > 该函数由ANSI定义，由于历史原因在不同版本的Unix和不同版本的Linux中可能有不同的行为。因此应该尽量避免使用它，取而代之使用sigaction函数。函数的返回值是之前设置的处理函数 > > 默认处理信号的时候, 会对一个处理中的信号进行屏蔽 > 第二个参数可以使用: SIG_IGN, 对这一个信号忽略 > > SIG_DFL: 默认的处理 ```c #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> #include <signal.h> void sig_cath(int signo){ \tprintf(\"catch %d\\n\", signo); } int main(void){ \tsignal(SIGINT, sig_cath); \twhile(1); } ``` ### sigaction修改信号处理 修改信号处理动作（通常在Linux用其来注册一个信号的捕捉函数） int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact); 成功：0；失败： 1，设置errno 参数： act：传入参数，新的处理方式。 oldact：传出参数，旧的处理方式。 ```c struct sigaction { void (*sa_handler)(int);\t\t\t\t\t\t//处理函数 void (*sa_sigaction)(int, siginfo_t *, void *); //一般不使用, 可以用这一个进程间通信 sigset_t sa_mask;\t\t\t\t\t\t\t\t //屏蔽字, 只在捕获函数执行期间使用(这一个 \t\t\t\t\t\t\t\t\t\t\t\t //是在原来的mask上面进行添加) \t\t\t\t\t\t\t\t\t\t\t\t //(handler执行期间, 避免重复进入等) int sa_flags;\t\t\t\t\t\t\t //设置参数, 设置为0表示使用默认属性 \t\t\t\t\t\t\t\t\t\t\t\t //这时候不需要设置sa_mask void (*sa_restorer)(void);\t\t\t\t\t\t//废弃了 }; ``` ```c #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> #include <signal.h> void sig_cath(int signo){ \tprintf(\"catch %d\\n\", signo); } int main(void){ \tint ret; \tstruct sigaction action, old_act; \taction.sa_handler sig_cath; //设置处理函数 \taction.sa_flags 0;\t\t //标志位 \tsigemptyset(&action.sa_mask); //清空屏蔽位 \tret sigaction(SIGINT, &action, &old_act); \tif(ret < 0){ \t\tperror(\"sigaction error\"); \t\texit(1); \t} \twhile(1); } ``` > 1. 进程正常运行时，默认PCB中有一个信号屏蔽字，假定为☆，它决定了进程自动屏蔽哪些信号。当注册了某个信号捕捉函数，捕捉到该信号以后，要调用该函数。而该函数有可能执行很长时间，在这期间所屏蔽的信号不由☆来指定。而是用sa_mask来指定。调用完信号处理函数，再恢复为☆。 > 2. XXX信号捕捉函数执行期间，XXX信号自动被屏蔽。 > 3. 阻塞的常规信号不支持排队，产生多次只记录一次。（后32个实时信号支持排队） ## 捕获过程 ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403272301241.png) ## 中断系统调用 系统调用可分为两类：慢速系统调用和其他系统调用。 1. 慢速系统调用：可能会使进程永远阻塞的一类。如果在阻塞期间收到一个信号，该系统调用就被中断,不再继续执行(早期)；也可以设定系统调用是否重启。如，read、write、pause、wait... 2. 其他系统调用：getpid、getppid、fork... 结合pause，回顾慢速系统调用： ​ 慢速系统调用被中断的相关行为，实际上就是pause的行为： 如，read ​ ① 想中断pause，信号不能被屏蔽。 ​ ② 信号的处理方式必须是捕捉 (默认、忽略都不可以) ​ ③ 中断后返回 1， 设置errno为EINTR(表“被信号中断”) 可修改sa_flags参数来设置被信号中断后系统调用是否重启。SA_INTERRURT不重启(这一个是默认的)。 SA_RESTART重启。 扩展了解： ​ sa_flags还有很多可选参数，适用于不同情况。如：捕捉到信号后，在执行捕捉函数期间，不希望自动阻塞该信号，可将sa_flags设置为SA_NODEFER，除非sa_mask中包含该信号。"},"/note/Linux/Linux系统编程/2024-3-21-03程序和进程.html":{"title":"程序和进程","content":" layout: post title: \"程序和进程\" date: 2024 3 21 15:39:08 +0800 tags: Linux # 程序和进程 程序，是指编译好的二进制文件，在磁盘上，不占用系统资源(cpu、内存、打开的文件、设备、锁....) 进程，是一个抽象的概念，与操作系统原理联系紧密。进程是活跃的程序，占用系统资源。在内存中执行。(程序运行起来，产生一个进程) ## 概念 ### 并发 同时可以运行多个程序 #### 单道程序设计 所有进程一个一个排对执行。若A阻塞，B只能等待，即使CPU处于空闲状态。而在人机交互时阻塞的出现时必然的。所有这种模型在系统资源利用上及其不合理，在计算机发展历史上存在不久，大部分便被淘汰了。 #### 多道程序设计 在计算机内存中同时存放几道相互独立的程序，它们在管理程序控制之下，相互穿插的运行。多道程序设计必须有[硬件基础](http://baike.baidu.com/view/4419390.htm)作为保证。 **时钟中断**即为多道程序设计模型的理论基础。 并发时，任意进程在执行期间都不希望放弃cpu。因此系统需要一种强制让进程让出cpu资源的手段。时钟中断有硬件基础作为保障，对进程而言不可抗拒。 操作系统中的中断处理函数，来负责调度程序执行。 在多道程序设计模型中，多个进程轮流使用CPU (分时复用CPU资源)。而当下常见CPU为纳秒级，1秒可以执行大约10亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。 ### 进程控制块 vim /usr/src/linux headers 5.4.0 152 generic/include/linux/sched.h 这一个文件里面的struct task_struct 这一个结构体里面比较重要的有 + 进程id。系统中每个进程有唯一的id，在C语言中用pid_t类型表示，其实就是一个非负整数。 + 进程的状态，有就绪、运行、挂起、停止等状态。 + 进程切换时需要保存和恢复的一些CPU寄存器。 + 描述虚拟地址空间的信息。 + 描述控制终端的信息。 + 当前工作目录（Current Working Directory）。 + umask掩码。 + 文件描述符表，包含很多指向file结构体的指针。 + 和信号相关的信息。 + 用户id和组id。 + 会话（Session）和进程组。 + 进程可以使用的资源上限（Resource Limit）。 ### 进程的状态 进程基本的状态有5种。分别为初始态，就绪态，[运行态](http://baike.baidu.com/subview/1730379/1730379.htm)，挂起态与终止态。其中初始态为进程准备阶段，常与就绪态结合来看。 ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403212206539.png) ### 环境变量 是指在[操作系统](http://baike.baidu.com/view/880.htm)中用来指定操作系统运行环境的一些参数 ① 字符串(本质) ② 有统一的格式：名 值[:值] ③ 值用来描述进程环境信息。 存储形式：与命令行参数类似。char *[]数组，数组名environ，内部存储字符串，NULL作为哨兵结尾。 使用形式：与命令行参数类似。 加载位置：与命令行参数类似。位于用户区，高于stack的起始位置。 引入环境变量表：须声明环境变量。extern char ** environ; > 查看`echo $环境变量名字` > > 可以使用`env`查看所有的环境变量 > 这一个变量实际是放在栈和3G之间 #### 常用的变量 ##### ATH 可执行文件的搜索路径。ls命令也是一个程序，执行它不需要提供完整的路径名/bin/ls，然而通常我们执行当前目录下的程序a.out却需要提供完整的路径名./a.out，这是因为PATH环境变量的值里面包含了ls命令所在的目录/bin，却不包含a.out所在的目录。PATH环境变量的值可以包含多个目录，用:号隔开。在Shell中用echo命令可以查看这个环境变量的值： $ echo $PATH ##### SHELL 当前Shell，它的值通常是/bin/bash。 ##### TERM 当前终端类型，在图形界面终端下它的值通常是xterm，终端类型决定了一些程序的输出显示方式，比如图形界面终端可以显示汉字，而字符终端一般不行。 ##### LANG 语言和locale，决定了字符编码以及时间、货币等信息的显示格式。 ##### HOME 当前用户主目录的路径，很多程序需要在主目录下保存配置文件，使得每个用户在运行该程序时都有自己的一套配置。 ### getenv通过名字获取 获取环境变量值 char *getenv(const char *name); 成功：返回环境变量的值；失败：NULL (name不存在) 练习：编程实现getenv函数。 【getenv.c】 ### setenv设置环境变量 设置环境变量的值 int setenv(const char *name, const char *value, int overwrite); 成功：0；失败： 1 ​ 参数overwrite取值： 1：覆盖原环境变量 0：不覆盖。(该参数常用于设置新环境变量，如：ABC haha day night) ### unsetenv删除 删除环境变量name的定义 int unsetenv(const char *name); 成功：0；失败： 1 ​ 注意事项：name不存在仍返回0(成功)，当name命名为\"ABC \"时则会出错。 ## 进程控制 ### fork创建子进程 创建一个子进程。 pid_t fork(void); 失败返回 1；成功返回：① 父进程返回子进程的ID(非负) ②子进程返回 0 pid_t类型表示进程ID，但为了表示 1，它是有符号整型。(0不是有效进程ID，init最小，为1) ​ 注意返回值，不是fork函数能返回两个值，而是fork后，fork函数变为两个，父子需【各自】返回一个。 > 使用这一个函数创建子进程的时候不能直接使用循环, 否则的话子进程也会在循环里创建进程 > > ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403212247334.jpg) ### getpid函数 获取当前进程ID pid_t getpid(void); ### getppid函数 ​ 获取当前进程的父进程ID ​ pid_t getppid(void); 区分一个函数是“系统函数”还是“库函数”依据： ② 是否访问内核数据结构 ​ ② 是否访问外部硬件资源 二者有任一 → 系统函数；二者均无 → 库函数 ### getuid函数 获取当前进程实际用户ID uid_t getuid(void); ​ 获取当前进程有效用户ID uid_t geteuid(void); ### getgid函数 ​ 获取当前进程使用用户组ID gid_t getgid(void); ​ 获取当前进程有效用户组ID gid_t getegid(void); ### 进程共享 父子相同处: 全局变量、.data、.text、栈、堆、环境变量、用户ID、宿主目录、进程工作目录、信号处理方式... 父子不同处: 1.进程ID 2.fork返回值 3.父进程ID 4.进程运行时间 5.闹钟(定时器) 6.未决信号集 父子进程间遵循**读时共享写时复制**的原则。这样设计，无论子进程执行父进程的逻辑还是执行自己的逻辑都能节省内存开销。 【重点】：父子进程共享：1. 文件描述符(打开文件的结构体) 2. mmap建立的映射区 ### gdb调试 使用gdb调试的时候，gdb只能跟踪一个进程。可以在fork函数调用之前，通过指令设置gdb调试工具跟踪父进程或者是跟踪子进程。默认跟踪父进程。 set follow fork mode child 命令设置gdb在fork之后跟踪子进程。 set follow fork mode parent 设置跟踪父进程。 注意，一定要在fork函数调用之前设置才有效. ### exec函数族 fork创建子进程后执行的是和父进程相同的程序（但有可能执行不同的代码分支），子进程往往要调用一种exec函数以执行另一个程序。当进程调用一种exec函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动例程开始执行。调用exec并不创建新进程，所以调用exec前后该进程的id并未改变。 将当前进程的.text、.data替换为所要加载的程序的.text、.data，然后让进程从新的.text第一条指令开始执行，但进程ID不变，换核不换壳。 其实有六种以exec开头的函数，统称exec函数： ```c int execl(const char *path, const char *arg, ...); int execlp(const char *file, const char *arg, ...); int execle(const char *path, const char *arg, ..., char *const envp[]); int execv(const char *path, char *const argv[]); int execvp(const char *file, char *const argv[]); int execve(const char *path, char *const argv[], char *const envp[]); ``` ### execlp函数 加载一个进程，借助PATH环境变量 int execlp(const char *file, const char *arg, ...); 成功：无返回；失败： 1 参数1：要加载的程序的名字。该函数需要配合PATH环境变量来使用，当PATH中所有目录搜索后没有参数1则出错返回。 > 之后的参数需要再加一下这一个文件的文件名(程序获取的参数的第一个是这一个可执行文件的文件名) > > 参数列表的最后一个参数需要是NULL 该函数通常用来调用系统程序。如：ls、date、cp、cat等命令。 ```c #include<stdio.h> #include<unistd.h> #include<sys/types.h> #include<stdlib.h> int main(void){ \tpid_t pid fork(); \tif(pid 1){ \t\tperror(\"fork error\"); \t\texit(1); \t}else if(pid 0){ \t\texeclp(\"ls\", \"ls\", \" l\", NULL); \t\tperror(\"exec error\"); \t\texit(1); \t}else{ \t\tprintf(\"parent\\n\"); \t} \treturn 0; } ``` ```bash jiao@ubuntu:~/Desktop/C language/2024 3 18 IO$ ./a.out parent jiao@ubuntu:~/Desktop/C language/2024 3 18 IO$ total 72 rwxrwxr x 1 jiao jiao 11160 Mar 22 13:03 a.out rw rw r 1 jiao jiao 524 Mar 18 22:48 block_readtty.c rwxrwxr x 1 jiao jiao 8424 Mar 21 20:35 dup rw rw r 1 jiao jiao 485 Mar 21 20:48 dup.c rw rw r 1 jiao jiao 588 Mar 22 13:03 exec.c rwxrwxr x 1 jiao jiao 12152 Mar 21 13:00 file_IO_test rw rw r 1 jiao jiao 1344 Mar 21 13:15 file_IO_test.c rwxrwxr x 1 jiao jiao 12624 Mar 21 13:15 ls R rw x T 1 jiao jiao 11 Mar 21 20:35 out.txt ``` ### execl函数 加载一个进程， 通过 路径+程序名 来加载。 int execl(const char *path, const char *arg, ...); 成功：无返回；失败： 1 对比execlp，如加载\"ls\"命令带有 l， F参数 `execlp(\"ls\", \"ls\", \" l\", \" F\", NULL);` 使用程序名在PATH中搜索。 execl(\"/bin/ls\", \"ls\", \" l\", \" F\", NULL); 使用参数1给出的绝对路径搜索。 ### execvp函数 加载一个进程，使用自定义环境变量env `int execvp(const char *file, const char *argv[]);` 变参形式： ①... ② argv[] (main函数也是变参函数，形式上等同于 int main(int argc, char *argv0, ...)) 变参终止条件：① NULL结尾 ② 固参指定 execvp与execlp参数形式不同，原理一致。 练习：将当前系统中的进程信息，打印到文件中。 【exec_ps.c】 ### exec函数族一般规律 exec函数一旦调用成功即执行新的程序，不返回。**只有失败才返回，错误值**** 1**。所以通常我们直接在exec函数调用后直接调用perror()和exit()，无需if判断。 + l (list) 命令行参数列表, 不同的参数之间使用`,`进行分割 + p (path) 搜素file时使用环境变量进行查找, 使用系统的程序的时候不再需要路径 + v (vector) 使用命令行参数数组作为参数 + e (environment) 使用环境变量数组,不使用进程原有的环境变量，设置新加载程序运行的环境变量 > l和v二选一, 另外的两个事可选地, 传递参数的时候需要注意使用NULL进行结尾 事实上，只有execve是真正的系统调用，其它五个函数最终都调用execve，所以execve在man手册第2节，其它函数在man手册第3节。这些函数之间的关系如下图所示。 ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403221249644.png) ## 孤儿进程, 僵尸进程 如果一个进程的父进程比子进程先结束, 这一个进程变为孤儿进程, 子进程的父进程变为init进程(1号进程) 僵尸进程, 一个进程结束以后没有被父进程进行回收 > 使用 `ps aux`的时候, 可以看到STAT变为Z ### wait阻塞回收一个子进程 一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的PCB还保留着，内核在其中保存了一些信息：如果是正常终止则保存着退出状态，如果是异常终止则保存着导致该进程终止的信号是哪个。这个进程的父进程可以调用wait或waitpid获取这些信息，然后彻底清除掉这个进程。我们知道一个进程的退出状态可以在Shell中用特殊变量$?查看，因为Shell是它的父进程，当它终止时Shell调用wait或waitpid得到它的退出状态同时彻底清除掉这个进程。 父进程调用wait函数可以回收子进程终止信息。该函数有三个功能： ① 阻塞等待子进程退出 ② 回收子进程残留资源 ③ 获取子进程结束状态(退出原因)。 **pid_t wait(int \\*status);** 成功：清理掉的子进程ID；失败： 1 (没有子进程) 当进程终止时，操作系统的隐式回收机制会：1.关闭所有文件描述符 2. 释放用户空间分配的内存。内核的PCB仍存在。其中保存该进程的退出状态。(正常终止→退出值；异常终止→终止信号) 可使用wait函数传出参数status来保存进程的退出状态。借助宏函数来进一步判断进程终止的具体原因。宏函数可分为如下三组： 1. WIFEXITED(status) 为非0 → 进程正常结束 ​ WEXITSTATUS(status) 如上宏为真，使用此宏 → 获取进程退出状态 (exit的参数) 2. WIFSIGNALED(status) 为非0 → 进程异常终止(被一个信号终止) ​ WTERMSIG(status) 如上宏为真，使用此宏 → 取得使进程终止的那个信号的编号。 > ![image 20240322224349557](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403222243644.png) > > 一般使用`kill 9 id`进行终止进程 3. WIFSTOPPED(status) 为非0 → 进程处于暂停状态 ​ WSTOPSIG(status) 如上宏为真，使用此宏 → 取得使进程暂停的那个信号的编号。 ​ WIFCONTINUED(status) 为真 → 进程暂停后已经继续运行 ### waitpid回收指定的进程 作用同wait，但可指定pid进程清理，可以不阻塞。 **pid_t waitpid(pid_t pid, int \\*status, in options);** > 可以使用options设置为非阻塞 成功：返回清理掉的子进程ID；失败： 1(无子进程) 特殊参数和返回情况： 参数pid： + \\>0 回收指定ID的子进程 + 1 回收任意子进程（相当于wait) + 0 回收和当前调用waitpid一个组的所有子进程 + < 1 回收指定进程组内的任意子进程, 这一个值是一个负的组号 > WNOHANG return immediately if no child has exited. > > WUNTRACED also return if a child has stopped (but not traced via > ptrace(2)). Status for traced children which have stopped > is provided even if this option is not specified. > > WCONTINUED (since Linux 2.6.10) > also return if a stopped child has been resumed by delivery > of SIGCONT. 返回0：参3为WNOHANG，且子进程正在运行 注意：一次wait或waitpid调用只能清理一个子进程，清理多个子进程应使用循环。 ```c while((pid waitpid( 1, NULL, WNOHANG))! 1){ if(pid>0){ //回收成功 }else if(pid 0){ \t\t//等待的进程还没有结束 continue; } } ``` ### 问题 ### 父进程使用exec函数以后没有办法回收子进程 如果子进程需要获取父进程在exec函数以后得信息, 而父进程在使用exec函数以后不能返回调用wait回收子进程, 这个时候这一个子进程的回收只能在父进程结束以后由init函数实现 解决方法, 使用信号SIGCHLD进行回收 #### SIGCHLD的产生条件 子进程终止时 子进程接收到SIGSTOP信号停止时 子进程处在停止态，接受到SIGCONT后唤醒时 #### 实际使用 ```c #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> #include <signal.h> #include <sys/wait.h> void catch_child(int signo){ \tpid_t wpid; \tint state; \twhile((wpid wait(&state)) ! 1){ \t\t//有多个信号的时候需要循环处理 \t\tprintf(\" catch child %d\\n\", wpid); \t\tif(WIFEXITED(state)){ \t\t\tprintf(\" exit status %d\\n\", WEXITSTATUS(state));\t \t\t} \t} \treturn; } int main(void){ \tpid_t pid; \tsigset_t set; \tsigemptyset(&set); \tsigaddset(&set, SIGCHLD); \tsigprocmask(SIG_BLOCK, &set, NULL);//阻塞一下这一个信号, 防止在捕获之前有子进程结束 \tint i; \tfor(i 0;i < 5 ;i++){ \t\tif((pid fork()) 0){ \t\t\tbreak; \t\t} \t} \tif(i 5){ \t\tstruct sigaction act; \t\tact.sa_handler catch_child; \t\tsigemptyset(&act.sa_mask); \t\tact.sa_flags 0; \t\tsigaction(SIGCHLD, &act, NULL);//设置捕获这一个信号, 以及注册处理函数 \t\tsigprocmask(SIG_UNBLOCK, &set, NULL);//结束阻塞 \t\tprintf(\"I'm parent pid %d\\n\", getpid()); \t\twhile(1); //在这里等待子进程从而回首 \t}else{ \t\tprintf(\"child %d pid %d\\n\", i, getpid()); \t} } ``` ## 退出 可以使用return在main函数里面进行返回, 也可以使用exit和_exit两个函数, exit会处理一下文件缓存区里面的数据(读写文件的时候不一定立即写入文件, 使用printf的时候没有换行的时候也会出现问题)"},"/note/Linux/Linux系统编程/2024-3-31-07线程同步.html":{"title":"线程同步","content":" layout: post title: \"线程同步\" date: 2024 3 31 15:39:08 +0800 tags: Linux # 线程同步 ## 需要的原因 编程中、通信中所说的同步与生活中大家印象中的同步概念略有差异。“同”字应是指协同、协助、互相配合。主旨在协同步调，按预定的先后次序运行。 线程同步，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回。同时其它线程为保证数据一致性，不能调用该功能。 > 这一个主要是防止线程使用公共资源的时候, 比如说公共变量的时候发生同时访问(比如读取一个寄存器的时候有读 改 写三步, 读取以后有一个中断把这一个寄存器改变了以后返回, 这时候进行改的变量里面没有更新, 实际写入的数据会进行覆盖中断里面的设置), 以及一个设备同时被多个进程使用 1. 资源共享（独享资源则不会） 2. 调度随机（意味着数据访问会出现竞争） 3. 线程间缺乏必要的同步机制。 > 以上3点中，前两点不能改变，欲提高效率，传递数据，资源必须共享。只要共享资源，就一定会出现竞争。只要存在竞争关系，数据就很容易出现混乱。 > > 所以只能从第三点着手解决。使多个线程在访问共享资源的时候，出现互斥。 ## 互斥量mutex Linux中提供一把互斥锁mutex（也称之为互斥量）。这一个一般有优先级继承, 防止优先级翻转, 不可以在中断里面使用的特点, 这一个锁在初始化的时候可以设置是不是可以重复上锁 > [RT Thread线程间同步(信号量, 互斥量, 事件集) 02源码分析 CSDN博客](https://blog.csdn.net/qq_61585528/article/details/135998116) 每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束解锁。 资源还是共享的，线程间也还是竞争的， 但通过“锁”就将资源的访问变成互斥操作，而后与时间有关的错误也不会再产生了。 ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403312024112.jpg) > 应注意：同一时刻，只能有一个线程持有该锁。 ​ 当A线程对某个全局变量加锁访问，B在访问前尝试加锁，拿不到锁，B阻塞。C线程不去加锁，而直接访问该全局变量，依然能够访问，但会出现数据混乱。 ​ 所以，互斥锁实质上是操作系统提供的一把“建议锁”（又称“协同锁”），建议程序中有多线程访问共享资源的时候使用该机制。但，并没有强制限定。 ​ 因此，即使有了mutex，如果有线程不按规则来访问数据，依然会造成数据混乱。 ### 主要应用函数： ​ pthread_mutex_init函数 ​ pthread_mutex_destroy函数 ​ pthread_mutex_lock函数 ​ pthread_mutex_trylock函数 ​ pthread_mutex_unlock函数 以上5个函数的返回值都是：成功返回0， 失败返回错误号。 pthread_mutex_t 类型，其本质是一个结构体。为简化理解，应用时可忽略其实现细节，**简单当成整数看待。** pthread_mutex_t mutex; 变量mutex只有两种取值1、0。 #### pthread_mutex_init 初始化一个互斥锁(互斥量) > 初值可看作1 ` int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);` > restrict: 这一个指针指向的变量只能被这一个指针调用 ​ 参1：传出参数，调用时应传 &mutex ​ restrict关键字：只用于限制指针，告诉编译器，所有修改该指针指向内存中内容的操作，只能通过本指针完成。不能通过除本指针以外的其他变量或指针修改 ​ 参2：互斥量属性。是一个传入参数，通常传NULL，选用默认属性(线程间共享)。 参APUE.12.4同步属性 > 1. 静态初始化：如果互斥锁 mutex 是静态分配的（定义在全局，或加了static关键字修饰），可以直接使用宏进行初始化 > > ```c > pthread_mutex_t fastmutex PTHREAD_MUTEX_INITIALIZER;//一个不可以重入 > > pthread_mutex_t recmutex PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;//可以重入 > > pthread_mutex_t errchkmutex PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP; > ``` > > 2. 动态初始化：局部变量应采用动态初始化。e.g. pthread_mutex_init(&mutex, NULL) > 可以使用函数pthread_mutexattr_init设置它的参数 #### pthread_mutex_destroy 销毁一个互斥锁 ` int pthread_mutex_destroy(pthread_mutex_t *mutex);` #### pthread_mutex_lock **加锁**。可理解为将**mutex **（或 1），操作后mutex的值为0。 ` int pthread_mutex_lock(pthread_mutex_t *mutex);` > 尝试加锁，如果加锁不成功，线程阻塞，阻塞到持有该互斥量的其他线程解锁为止。 #### pthread_mutex_unlock **解锁**。可理解为将**mutex ++**（或 +1），操作后mutex的值为1。 ​ `int pthread_mutex_unlock(pthread_mutex_t *mutex);` > 在使用这锁的时候使用结束最好立即解锁 > > 主动解锁函数，**同时将阻塞在该锁上的所有线程全部唤醒**，至于哪个线程先被唤醒，取决于优先级、调度。默认：先阻塞、先唤醒。 #### phread_mutex_trylock 尝试加锁 ` int pthread_mutex_trylock(pthread_mutex_t *mutex);` > 如果是一个fast锁, 已经上锁会返回EBUSY ### 示例 ```c #include <string.h> #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> #include <pthread.h> pthread_mutex_t mutex; void *tfn(void *arg){ \twhile(1){ \t\tprintf(\"HELLO \"); \t\tsleep(rand()%3); \t\tprintf(\"WORLD\\n\"); \t\tsleep(rand()%3); \t} \treturn NULL; } int main(void){ \tpthread_t tid; \tint ret pthread_create(&tid, NULL, tfn, NULL); \tif(ret ! 0){ \t\tprintf(\"pthread_create error: %s\", strerror(ret)); \t\texit(1); \t} \twhile(1){ \t\tprintf(\"hello \"); \t\tsleep(rand()%3); \t\tprintf(\"word\\n\"); \t\tsleep(rand()%3); \t} \treturn 0; } ``` > ![image 20240331220445326](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403312204364.png) > > > 不使用互斥锁的时候 ```c #include <string.h> #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> #include <pthread.h> pthread_mutex_t mutex; void *tfn(void *arg){ \twhile(1){ \t\tpthread_mutex_lock(&mutex); \t\tprintf(\"HELLO \"); \t\tsleep(rand()%3); \t\tprintf(\"WORLD\\n\"); \t\tpthread_mutex_unlock(&mutex); \t\tsleep(rand()%3); \t} \treturn NULL; } int main(void){ \tpthread_mutex_init(&mutex, NULL);//初始化 \tpthread_t tid; \tint ret pthread_create(&tid, NULL, tfn, NULL); \tif(ret ! 0){ \t\tprintf(\"pthread_create error: %s\", strerror(ret)); \t\texit(1); \t} \twhile(1){ \t\tpthread_mutex_lock(&mutex);//上锁 \t\tprintf(\"hello \"); \t\tsleep(rand()%3); \t\tprintf(\"word\\n\"); \t\tpthread_mutex_unlock(&mutex);//解锁 \t\tsleep(rand()%3); \t} \treturn 0; } ``` ![image 20240331230116962](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403312301011.png) ### 死锁 1. 线程试图对同一个互斥量A加锁两次。 2. 线程1拥有A锁，请求获得B锁；线程2拥有B锁，请求获得A锁 ## 读写锁 与互斥量类似，但读写锁允许更高的并行性。其特性为：**写独占，读共享。写的优先级比较高** ### 读写锁状态： 特别强调：读写锁**只有一把**，但其具备两种状态： 1. 读模式下加锁状态 (读锁) 2. 写模式下加锁状态 (写锁) ### 读写锁特性： 1. 读写锁是“写模式加锁”时， 解锁前，所有对该锁加锁的线程都会被阻塞。 2. 读写锁是“读模式加锁”时， 如果线程以读模式对其加锁会成功；如果线程以写模式加锁会阻塞。 3. 读写锁是“读模式加锁”时， 既有试图以写模式加锁的线程，也有试图以读模式加锁的线程。那么读写锁会阻塞随后的读模式锁请求。优先满足写模式锁。**读锁、写锁并行阻塞，写锁优先级高** ​ 读写锁也叫共享 独占锁。当读写锁以读模式锁住时，它是以共享模式锁住的；当它以写模式锁住时，它是以独占模式锁住的。**写独占、读共享。** ​ 读写锁非常适合于对数据结构读的次数远大于写的情况。 > 这一个在读线程比较多的时候效率提升比较大 ### 主要应用函数： ​ pthread_rwlock_init函数 ​ pthread_rwlock_destroy函数 ​ pthread_rwlock_rdlock函数 ​ pthread_rwlock_wrlock函数 ​ pthread_rwlock_tryrdlock函数 ​ pthread_rwlock_trywrlock函数 ​ pthread_rwlock_unlock函数 以上7 个函数的返回值都是：成功返回0， 失败直接返回错误号。 ​ pthread_rwlock_t类型 用于定义一个读写锁变量。 ​ pthread_rwlock_t rwlock; #### pthread_rwlock_init 初始化一把读写锁 ` int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);` ​ 参2：attr表读写锁属性，通常使用默认属性，传NULL即可。 #### pthread_rwlock_destroy 销毁一把读写锁 ` int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);` #### pthread_rwlock_rdlock 以读方式请求读写锁。（常简称为：请求读锁） ` int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);` #### pthread_rwlock_wrlock 以写方式请求读写锁。（常简称为：请求写锁） ` int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);` #### pthread_rwlock_unlock 解锁 ` int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);` #### pthread_rwlock_tryrdlock 非阻塞以读方式请求读写锁（非阻塞请求读锁） `int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);` #### pthread_rwlock_trywrlock 非阻塞以写方式请求读写锁（非阻塞请求写锁） ` int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);` ### 示例 ```c #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> #include <pthread.h> int counter;//全局变量 pthread_rwlock_t rwlock; void *reader(void* arg){ \tint t; \tint i (int) arg; \twhile(1){ \t\tpthread_rwlock_rdlock(&rwlock); \t\tt counter;//获取数据 \t\tprintf(\"read %d: %lu, counter: %d\\n\",i,pthread_self(),t); \t\tpthread_rwlock_unlock(&rwlock); \t\tusleep(10000); \t} \treturn NULL; } void *writer(void* arg){ \tint i (int)arg; \twhile(1){ \t\tpthread_rwlock_wrlock(&rwlock); \t\tcounter++;//写一下数据 usleep(1000); \t\tprintf(\"write %d: %lu, counter: %d\\n\",i,pthread_self(),counter); \t\tpthread_rwlock_unlock(&rwlock); \t\tusleep(20000); \t} \treturn NULL; } int main(void){ \tint i; \tpthread_t tid[8]; \tpthread_rwlock_init(&rwlock,NULL); \tfor(i 0;i<3;i++){ \t\tpthread_create(&tid[i],NULL,writer,(void *)i); \t} \tfor(i 0;i<5;i++){ \t\tpthread_create(&tid[i+3],NULL,reader,(void *)i); \t} \tfor(i 0;i<8;i++){ \t\tpthread_join(tid[i],NULL); \t} \tpthread_rwlock_destroy(&rwlock); \treturn 0; } ``` > ![image 20240401162743432](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404011627516.png) > > > 每一次读取都是写以后的数据 ## 条件变量： ​ 条件变量本身不是锁！但它也可以造成线程阻塞。通常与互斥锁配合使用。给多线程提供一个会合的场所。 ### 主要应用函数： ​ pthread_cond_init函数 ​ pthread_cond_destroy函数 ​ pthread_cond_wait函数 ​ pthread_cond_timedwait函数 ​ pthread_cond_signal函数 ​ pthread_cond_broadcast函数 以上6 个函数的返回值都是：成功返回0， 失败直接返回错误号。 ​ pthread_cond_t类型 用于定义条件变量 ​ pthread_cond_t cond; #### pthread_cond_init 初始化一个条件变量 `int pthread_cond_init(pthread_cond_t *restrict cond, const pthread_condattr_t *restrict attr); ` > 参2：attr表条件变量属性，通常为默认值，传NULL即可 也可以使用静态初始化的方法，初始化条件变量： `pthread_cond_t cond PTHREAD_COND_INITIALIZER;` #### pthread_cond_destroy 销毁一个条件变量 `int pthread_cond_destroy(pthread_cond_t *cond);` #### pthread_cond_wait 阻塞等待一个条件变量 ` int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);` 函数作用： 1. 阻塞等待条件变量cond（参1）满足 2. 释放已掌握的互斥锁（解锁互斥量）相当于pthread_mutex_unlock(&mutex);, 这一个互斥量需要是一个已经加锁的 > 1.2.两步为一个原子操作。 3. 当被唤醒，pthread_cond_wait函数返回时，解除阻塞并重新申请获取互斥锁pthread_mutex_lock(&mutex); > 也就是说在等待的时候是可以使用这一个互斥量对变量进行操作, 没有等待的时候这一个互斥锁是不可以使用的, 一旦调用会进入阻塞 > > 下面是GPT的解释 > > ``` > pthread_cond_wait函数使用一个mutex参数的原因是为了确保在等待条件变量的时候，线程能够安全地释放对共享资源的访问。 > > 具体来说，当一个线程调用pthread_cond_wait函数时，它会先释放之前持有的mutex，并且将自己加入到条件变量的等待队列中等待条件的满足。此时，其他线程可以获得该mutex，继续访问共享资源。当满足某个条件时，调用pthread_cond_signal或pthread_cond_broadcast函数唤醒等待队列中的线程。被唤醒的线程会重新获取mutex，并且继续执行。 > > 使用mutex参数的目的是为了确保线程在等待和唤醒的过程中能够正确地同步对共享资源的访问。如果没有mutex参数，线程就无法安全地释放和重新获取mutex，可能会导致竞争条件和数据不一致的问题。因此，mutex与条件变量配合使用，可以实现线程之间的同步与互斥。 > ``` #### pthread_cond_timedwait 限时等待一个条件变量 `int pthread_cond_timedwait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);` ​ 参3： 参看man sem_timedwait函数，查看struct timespec结构体。 ```c struct timespec { time_t tv_sec; /* seconds */ 秒 long tv_nsec; /* nanosecondes*/ 纳秒 } ``` > 形参abstime：绝对时间。 如：time(NULL)返回的就是绝对时间。而alarm(1)是相对时间，相对当前时间定时1秒钟。 ```c struct timespec t {1, 0}; pthread_cond_timedwait (&cond, &mutex, &t); 只能定时到 1970年1月1日 00:00:01秒(早已经过去) ``` 正确用法： ```c time_t cur time(NULL); 获取当前时间。 struct timespec t; 定义timespec 结构体变量t t.tv_sec cur+1; 定时1秒 pthread_cond_timedwait (&cond, &mutex, &t); 传参 参APUE.11.6线程同步条件变量小节 ``` > 在使用的时候应该注意, 这一个time返回的时间是一个秒为单位的, 设置不到一秒的等待的时候, 可能会出现设置的时间没有当前时间大, 导致这一个等待无效 ```c struct timeval { \ttime_t tv_sec; /* seconds */ 秒 \tsuseconds_t tv_usec; /* microseconds */ 微秒 }; ``` > ```c > struct timeval tv; > gettimeofday(&tv, NULL); > ``` > > > 可以使用这一个获取微秒级时间 #### pthread_cond_signal 唤醒至少一个阻塞在条件变量上的线程 `int pthread_cond_signal(pthread_cond_t *cond);` #### pthread_cond_broadcast 唤醒全部阻塞在条件变量上的线程 ` int pthread_cond_broadcast(pthread_cond_t *cond);` ### 实际使用 + 等待方 1. 创建一个锁 2. 初始化锁 pthread_mutex_init 3. 加锁 pthread_mutex_lock 4. 等待条件满足 pthread_cond_wait 5. 访问数据 6. 解锁, (释放条件变量, 释放锁) + 生产方 1. 生成数据 2. 加锁 3. 把数据放到公共区域 4. 解锁 5. 发信号 ### 示例 ```c #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> #include <pthread.h> //一个信息链表 struct msg { \tstruct msg *next; \tint num; }; struct msg* head; //初始化一个条件变量和一个锁 pthread_cond_t has_product PTHREAD_COND_INITIALIZER; pthread_mutex_t lock PTHREAD_MUTEX_INITIALIZER; void *consumer(void *p){ \tstruct msg *mp; \tfor(;;){ \t\tpthread_mutex_lock(&lock); \t\twhile(head NULL){ \t\t\tpthread_cond_wait(&has_product, &lock);//没有数据的时候需要等待 \t\t} //有数据直接处理 \t\tmp head; \t\thead mp >next; \t\tpthread_mutex_unlock(&lock); \t\tprintf(\" Consume %d\\n\", mp >num); \t\tfree(mp); \t\tsleep(rand() % 5); \t} } void *producer(void *p){ \tstruct msg *mp; \tfor(;;){ \t\tmp malloc(sizeof(struct msg)); \t\tmp >num rand() % 1000 + 1;//随机一个产品 \t\tprintf(\" Produce %d\\n\", mp >num); \t\tpthread_mutex_lock(&lock); \t\tmp >next head; \t\thead mp;//把这一个信息加到链表头部 \t\tpthread_mutex_unlock(&lock); \t\tpthread_cond_signal(&has_product);//发送信号 \t\tsleep(rand()%5); \t} } int main(void){ \tpthread_t pid, cid; \tsrand(time(NULL)); \tpthread_create(&pid, NULL, producer, NULL); \tpthread_create(&cid, NULL, consumer, NULL); \tpthread_join(pid, NULL); \tpthread_join(cid, NULL); \treturn 0; } ``` > ![image 20240401175739123](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404011757204.png) ## 信号量 相比于互斥量, 这一个的初始化值可以为N, 可以用于管理有多个资源, N是可以同时访问的线程数量 > [RT Thread线程间同步(信号量, 互斥量, 事件集) 01API函数使用 CSDN博客](https://blog.csdn.net/qq_61585528/article/details/135998083?ops_request_misc %7B%22request%5Fid%22%3A%22171197279516777224481286%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fblog.%22%7D&request_id 171197279516777224481286&biz_id 0&utm_medium distribute.pc_search_result.none task blog 2~blog~first_rank_ecpm_v1~rank_v31_ecpm 2 135998083 null null.nonecase&utm_term 信号量&spm 1018.2226.3001.4450) > > [RT Thread线程间同步(信号量, 互斥量, 事件集) 02源码分析 CSDN博客](https://blog.csdn.net/qq_61585528/article/details/135998116?ops_request_misc %7B%22request%5Fid%22%3A%22171197279516777224481286%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fblog.%22%7D&request_id 171197279516777224481286&biz_id 0&utm_medium distribute.pc_search_result.none task blog 2~blog~first_rank_ecpm_v1~rank_v31_ecpm 1 135998116 null null.nonecase&utm_term 信号量&spm 1018.2226.3001.4450) > > 可以通过RTOS了解一下简单的原理 ### 主要应用函数： ​ sem_init函数 ​ sem_destroy函数 ​ sem_wait函数 ​ sem_trywait函数 ​ sem_timedwait函数 ​ sem_post函数 以上6 个函数的返回值都是：成功返回0， 失败返回 1，同时设置errno。(注意，它们没有pthread前缀) ​ sem_t类型，本质仍是结构体。但应用期间可简单看作为整数，忽略实现细节（类似于使用文件描述符）。 sem_t sem; 规定信号量sem不能 < 0。头文件 <semaphore.h> > 每一次获取的时候相当于一次 , 可以使用的数量为0的时候这一个线程会进入阻塞 > 这一个可以应用于线程以及进程之间 #### 信号量基本操作： sem_wait: 1. 信号量大于0，则信号量 （类比pthread_mutex_lock） 2. 信号量等于0，造成线程阻塞 ​ 对应 sem_post： ​\t将信号量++，同时唤醒阻塞在信号量上的线程 （类比pthread_mutex_unlock） 但，由于sem_t的实现对用户隐藏，所以所谓的++、 操作只能通过函数来实现，而不能直接++、 符号。 **信号量的初值，决定了占用信号量的线程的个数。** #### sem_init 初始化一个信号量 `int sem_init(sem_t *sem, int pshared, unsigned int value);` > 参1：sem信号量 > > 参2：pshared取0用于线程间；取非0（一般为1）用于进程间 > > > The pshared argument indicates whether this semaphore is to be shared > > between the threads of a process, or between processes. > > > > If pshared has the value 0, then the semaphore is shared between the > > threads of a process, and should be located at some address that is visible > > to all threads (e.g., a global variable, or a variable allocated dynami‐ > > cally on the heap). > > > > If pshared is nonzero, then the semaphore is shared between processes, and > > should be located in a region of shared memory (see shm_open(3), mmap(2), > > and shmget(2)). (Since a child created by fork(2) inherits its parent's > > memory mappings, it can also access the semaphore.) Any process that can > > access the shared memory region can operate on the semaphore using > > sem_post(3), sem_wait(3), and so on. > > 参3：value指定信号量初值 #### sem_destroy 销毁一个信号量 ` int sem_destroy(sem_t *sem);` #### sem_wait 给信号量加锁 ` int sem_wait(sem_t *sem);` #### sem_post 给信号量解锁 ++ ` int sem_post(sem_t *sem); ` #### sem_trywait 尝试对信号量加锁 (与sem_wait的区别类比lock和trylock) ` int sem_trywait(sem_t *sem); ` #### sem_timedwait 限时尝试对信号量加锁 ​ int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout); > 这一个时间看pthread_cond_timewait的时间, 这一个时间也是一个绝对时间"},"/note/Linux/Linux系统编程/2024-3-19-02文件系统.html":{"title":"文件系统","content":" layout: post title: \"文件系统\" date: 2024 3 19 15:39:08 +0800 tags: Linux # 文件系统 ## 文件存储相关的概念 文件描述主要有两个inode和dentry ### inode 是一个结构体, 里面有这一个文件的权限, 类型, 大小, 时间, 用户, 盘块位置之类的信息, 这一个是文件属性的管理结构 ![image 20240319210915850](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403192109902.png) > 文件名是单独存储的, 可以使用inode的编号找到这一个结构体 创建一个硬链接的时候实际这两个文件的inode是一样的, 不一样的是dentry ### dentry 目录项 这一个结构体里面有两个主要的变量(经常使用), 分别是文件名以及inode的编号, 可以使用这一个获取文件的信息 ## 文件操作 ### stat函数:获取文件属性 实际上是从文件的inode结构体里面获取 `int stat(const char *pathname, struct stat *statbuf);` > 参数1: 是一个文件的路径 > > 参数2: 这一个实际返回值 ![image 20240319212528504](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403192125553.png) `int fstat(int fd, struct stat *statbuf);`使用的参数是一个文件的描述符 `int lstat(const char *pathname, struct stat *statbuf);`这一个函数的目标是一个软链接的时候返回的是这一个软链接的信息, 之前的几个函数返回的是软连接指向的文件 ![image 20240320203146019](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403202031046.png) ![image 20240319214505214](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403192145258.png) > 可以使用这几个宏定义进行文件的格式的获取, 这一个实际是使用一个16位的数据保存了这一个文件的数据类型, 这几个宏定义是判断这一个数字的高几位是什么, 这一个数据里面还有这一个文件的权限 > 其他位 > > ![image 20240320203124969](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403202031147.png) > > ### 特殊权限位： > > ​ 包含三个二进制位。依次是：设置组ID位setGID；设置用户ID位setID；黏住位sticky > > #### 黏住位 > > 早起计算机内存紧，只有精要的常用的程序可以常驻物理内存，剩下的要暂存磁盘中。当内存不够用的时候会将该部分程序存回磁盘，腾出内存空间。若文件设置了黏住位，那么即使在内存比较吃紧的情况下，也不会将该文件回存到磁盘上。由于现阶段操作系统的虚拟内存管理分页算法完善。该功能已经被废弃。 > > 但我们仍然**可以对目录设置黏住位**。被设置了该位的目录，其内部文件只有： > > ①超级管理员 > > ②该目录所有者 > > ③该文件的所有者 > > 以上三种用户有权限做删除、修改操作。其他用户可以读、创建但不能随意删除。 > > #### setUID位 > > 进程有两个ID：EID(有效用户ID)，表示进程履行哪个用户的权限。 > > ​ UID(实际用户ID)，表示进程实际属于哪个用户。 > > ​ 多数情况下，EID和UID相同。但是，当文件的setID被设置后两个ID则有可能不一样。 > > ​ 例如：当进程执行一个root用户的文件，若该文件的setID位被设置为1， 那么执行该文件时，进程的UID不变。EID变为root，表示进程开始履行root用户权限。 ### access检测文件权限 `int access(const char *pathname, int mode);` > F_OK , R_OK, W_OK, and X_OK. F_OK tests for the existence of the file. R_OK, W_OK, and X_OK test whether the file exists and grants read, write, and execute permissions, respectively. > > 成功的时候返回0, 这一个文件不存在或者这一个文件的某一个查询的文件不存在, 这个时候返回 1 ### chmod改变一个文件的权限 `int chmod(const char *pathname, mode_t mode);` 可以设置权限以及几个特殊位 > + 权限位 > > ![image 20240328171551848](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403281715044.png) > > + 特殊位 > > ![image 20240328171630511](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403281716555.png) > > > [4.4 S_ISUID、S_ISGID位与文件访问权限检查 CSDN博客](https://blog.csdn.net/zhoulaowu/article/details/14103599) > > > > 大致意思是前面两个位设置的时候其他用户使用这一个文件的时候会使用这一个用户的拥有者的ID > > > > 后面是黏住位, 前面有 ### link创建一个硬链接 `int link(const char *oldpath, const char *newpath);` > 这一个文件的路径, 以及硬链接的路径, 实际是为一个文件创建一个新的dentry > > 返回0表示成功 ### unlink删除一个文件 `int unlink(const char *pathname);` 删除一个文件的目录项, 这一个文件的目录项为0的时候这一个文件会被删除, 这一个文件不是立刻被删除的, 实际的删除是操作系统处理的, 如果有一个其他的进程使用这一个文件, 这一个文件会在打开这一个文件的进程结束以后再释放这一个文件 > 可以使用这两个函数实现一个mv命令, 先为这一个文件创建一个dentry, 再把旧的dentry移除 ### 隐式回收 一个进程结束以后, 这一个进程打开的资源会被回收, 包括打开的文件, 申请的空间 ### symlink软连接 `int symlink(const char *target, const char *linkpath);` > 为文件创建一个软连接, 实际是一个记录文件路径的字符串 ### readlink从一个链接获取文件路径 `ssize_t readlink(const char *pathname, char *buf, size_t bufsiz);` 把这一个文件的路径放在这一个buf里面, 如果这一个buf很小, 这一个路径会被截断 ### rename给一个文件重命名 `int rename(const char *oldpath, const char *newpath);` 如果这一个新的文件已经存在, 这一个文件会被替代 ## 目录操作 ### getcwd获取位置 获取进程当前工作目录 (卷3，标库函数) `char *getcwd(char *buf, size_t size);` 成功：buf中保存当前进程工作目录位置。失败返回NULL。 ### chdir变换路径 改变当前进程的作目录, 相当于cd ​ `int chdir(const char *path);` 成功：0；失败： 1设置errno为相应值 ## 文件目录权限 如果使用vi打开一个目录, 可以获取这一个目录里面的文件名(目录项) **r** **w** **x** 文件 文件的内容可以被查看 内容可以被修改 可以运行产生一个进程 cat、more、less… vi、> … ./文件名 目录 目录可以被浏览 ls tree 创建、删除、修改文件 touch rm mkdir 可以被打开、进入 cd > 目录设置黏住位：若有w权限，创建不变，删除、修改只能由root、目录所有者、文件所有者操作。 ### opdir打开一个目录 `DIR *opendir(const char *name);` > 成功的时候返回描述符, 失败的话会返回NULL ### closedir关闭这一个文件 `int closedir(DIR *dirp);` > 0: 成功, 1失败 ### readdir返回目录里面一个目录的描述符 `struct dirent *readdir(DIR *dirp);` ![image 20240320213727817](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403202137875.png) > 这一个是获取这一个文件夹里面的文件的目录项 > > **注** :使用这一个函数的时候需要注意这一个函数可以获取到. 和 .. 目录, 遍历的时候要注意不要死循环 ### rewinddir返回文件夹的开头 `void rewinddir(DIR *dirp);` > 这一个函数主要用于遍历文件的时候, 从头再开始 ### telldir/seekdir函数 ​ 获取目录读写位置 ​ long telldir(DIR *dirp); 成功：与dirp相关的目录当前读写位置。失败 1，设置errno ​ 修改目录读写位置 ​ void seekdir(DIR *dirp, long loc); 返回值：无 ​ 参数loc一般由telldir函数的返回值来决定。 ### dup/dup2重定向文件 dup可以用于对oldfd这个文件建立一个新的文件描述符，指向同一个文件，使用最小的文件描述符，不能对已经有了的描述符重定向，dup2会关闭已经有的newfd 这一个在命令行里面的形式的>(把输出的信息添加到文件)或者>>(追加) ```c int dup(int oldfd); int dup2(int oldfd, int newfd); ``` dup2实际是把后面的那一个文件指向前一个文件, 使用的时候如果newfd这一个描述符被使用了, 会把这一个描述符覆盖,可以使用dmp2(newfd, 1)把输出重定向到其他文件 > 还可以使用fcntl的F_DUPFD实现同样的功能, 但是如果new放到位置的文件被使用的时候这一个文件不会被覆盖, 而是使用比他大的第一个可以使用的描述符 可以使用这两个函数配合exec系列函数实现比如 ls l > wc的功能 ### scandir遍历一个文件夹 ```c int scandir(const char *dirp, struct dirent ***namelist, int (*filter)(const struct dirent *), int (*compar)(const struct dirent **, const struct dirent **)); ``` > drip: 这一个文件夹的路径 > > namelist: 传出参数, 这一个文件夹里面的文件描述结构体 > > ```c > struct dirent { > ino_t \td_ino; \t/* inode number */ > off_t \td_off; \t\t/* not an offset; see NOTES */ > unsigned short \td_reclen; \t\t/* length of this record */ > \tunsigned char \td_type; \t\t\t > \t char \t\t d_name[256]; \t/* filename */ > }; > ``` > > filter: 过滤器回调函数, 可以设置为NULL, 不进行比较 > > compar: 比较, 用于排序 > > ```c > int alphasort(const struct dirent **a, const struct dirent **b); > int versionsort(const struct dirent **a, const struct dirent **b); > ``` > > > 可以使用这两个函数, alphasort按照字符排序, 第二个可以用于版本号进行比较"},"/note/Linux/Linux系统编程/2024-3-23-04进程间通信.html":{"title":"文件IO","content":" layout: post title: \"文件IO\" date: 2024 3 23 15:39:08 +0800 tags: Linux # 进程间通信 IPC: InterProcess Communication 使用内核里面的一块缓冲区, 进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信 在进程间完成数据传递需要借助操作系统提供特殊的方法，如：文件、管道、信号、共享内存、消息队列、套接字、命名管道等。随着计算机的蓬勃发展，一些方法由于自身设计缺陷被淘汰或者弃用。现今常用的进程间通信方式有： ​ ① 管道 (使用最简单, 这一个一般是有关系的进程间) ​ ② 信号 (开销最小, 数据量受限) ​ ③ 共享映射区 (无血缘关系) ​ ④ 本地套接字 (最稳定, 网络中, 实现复杂) > 主要有三套不同的通信机制 > > 1. 早期Linux的, 管道, 信号, fifo > 2. system v ipc(贝尔实验室) 的消息队列, 信号量, 共享内存 > 3. socket > 4. posix ipc(IEEE) 的消息队列, 信号量, 共享内存 ## 管道 可以使用pipe函数进行创建, 以及命令mkfifo命令, 通过文件系统中的某一个文件名来建立，它允许无关进程之间的通信。使用有名管道时，需要先用 mkfifo 命令创建管道文件，然后通过文件 I/O 操作来进行数据的读写。在使用完毕后，需要手动删除该文件。 管道是一种最基本的IPC机制，作用于有血缘关系的进程之间，完成数据传递。调用pipe系统函数即可创建一个管道。有如下特质： 1. 其本质是一个伪文件(实为内核缓冲区) 2. 由两个文件描述符引用，一个表示读端，一个表示写端。 3. 规定数据从管道的写端流入管道，从读端流出。 管道的原理: 管道实为内核使用环形队列机制，借助内核缓冲区(4k)实现。 管道的局限性： ① 数据不能进程自己写，自己读。 ② 管道中数据不可反复读取。一旦读走，管道中不再存在。 ③ 采用半双工通信方式，数据只能在单方向上流动。 常见的通信方式有，单工通信、半双工通信、全双工通信。 ### pipe ```c int pipe(int pipefd[2]); ``` > pipe() creates a pipe, a unidirectional data channel that can be used > for interprocess communication. The array pipefd is used to return two > file descriptors referring to the ends of the pipe. pipefd[0] refers > to the read end of the pipe. pipefd[1] refers to the write end of the > pipe. Data written to the write end of the pipe is buffered by the > kernel until it is read from the read end of the pipe. > > 参数是返回两个文件描述符, 0用来读, 1用来写, 这两个管道是被打开的 > > 成功的话返回0 ```c #include <stdio.h> #include <string.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> int main(int argc, char *argv[]){ \tint ret; \tint fd[2]; \tpid_t pid; \tret pipe(fd); \tif(ret 1){ \t\tperror(\"pipe error\"); \t\texit(1); \t} \tpid fork(); \tif(pid > 0){ \t\t//parent \t\tclose(fd[0]);//close read pipe \t\twrite(fd[1], \"hello pipe\", strlen(\"hello pipe\")); \t\tclose(fd[1]);//关闭写的管道 \t}else if(pid 0 ){ \t\tsleep(1); \t\tchar temp; \t\tclose(fd[1]); \t\twhile(read(fd[0], &temp, 1)){ \t\t\tputc(temp, stdout); \t\t} \t\tclose(fd[0]); \t} } ``` 使用管道需要注意以下4种特殊情况（假设都是阻塞I/O操作，没有设置O_NONBLOCK标志）： 1. 如果所有指向管道写端的文件描述符都关闭了（管道写端引用计数为0），而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样。 2. 如果有指向管道写端的文件描述符没关闭（管道写端引用计数大于0），而持有管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次read会阻塞，直到管道中有数据可读了才读取数据并返回。 3. 如果所有指向管道读端的文件描述符都关闭了（管道读端引用计数为0），这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。当然也可以对SIGPIPE信号实施捕捉，不终止进程。具体方法信号章节详细介绍。 4. 如果有指向管道读端的文件描述符没关闭（管道读端引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写端写数据，那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。 总结： ① 读管道： 1. 管道中有数据，read返回实际读到的字节数。 ​ 2. 管道中无数据： ​\t\t\t\t\t (1) 管道写端被全部关闭，read返回0 (好像读到文件结尾) ​ (2) 写端没有全部被关闭，read阻塞等待(不久的将来可能有数据递达，此时会让出cpu) ② 写管道： 1. 管道读端全部被关闭， 进程异常终止(也可使用捕捉SIGPIPE信号，使进程不终止) ​ \t2. 管道读端没有全部关闭： ​\t\t\t\t\t (1) 管道已满，write阻塞。 ​ (2) 管道未满，write将数据写入，并返回实际写入的字节数。 ```c #include <stdio.h> #include <string.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> int main(int argc, char *argv[]){ \tint ret; \tint fd[2]; \tpid_t pid; \tret pipe(fd); \tif(ret 1){ \t\tperror(\"pipe error\"); \t\texit(1); \t} \tpid fork(); \tif(pid > 0){ \t\t//parent \t\tclose(fd[0]);//close read pipe \t\tdup2(fd[1], STDOUT_FILENO); \t\texeclp(\"ls\" ,\"ls\", \" l\", NULL); \t\tclose(fd[1]); \t}else if(pid 0 ){ \t\tsleep(1); \t\tclose(fd[1]); \t\tdup2(fd[0], STDIN_FILENO); \t\texeclp(\"wc\", \"wc\", \" l\", NULL); \t\tclose(fd[0]); \t} } ``` #### 注意 如果某一个进程里面没有使用这一个管道, 需要把这一个管道对应的文件关闭 ### 管道缓冲区大小 ​ 可以使用ulimit –a 命令来查看当前系统中创建管道文件所对应的内核缓冲区大小。通常为： ​ pipe size (512 bytes, p) 8 ​ 也可以使用fpathconf函数，借助参数 选项来查看。使用该宏应引入头文件<unistd.h> ​ long fpathconf(int fd, int name); 第二个参数_PC_PIPE_BUF成功：返回管道的大小 失败： 1，设置errno ### 管道的优劣 ​ 优点：简单，相比信号，套接字实现进程间通信，简单很多。 ​ 缺点：1. 只能单向通信，双向通信需建立两个管道。 2. 只能用于父子、兄弟进程(有共同祖先)间通信。该问题后来使用fifo有名管道解决。 ## FIFO FIFO常被称为命名管道，以区分管道(pipe)。管道(pipe)只能用于“有血缘关系”的进程间。但通过FIFO，不相关的进程也能交换数据。 ​ FIFO是Linux基础文件类型中的一种。但，FIFO文件在磁盘上没有数据块，仅仅用来标识内核中一条通道。各进程可以打开这个文件进行read/write，实际上是在读写内核通道，这样就实现了进程间通信。 创建方式： 1. 命令：`mkfifo` 管道名 2. 库函数：`int mkfifo(const char *pathname, mode_t mode);`Mode是这一个文件的权限 成功：0； 失败： 1 ​ 一旦使用mkfifo创建了一个FIFO，就可以使用open打开它，常见的文件I/O函数都可用于fifo。如：close、read、write、unlink等。 1)、如果当前打开操作是为读而打开FIFO时，若已经有相应进程为写而打开该FIFO，则当前打开操作将成功返回；否则，可能阻塞直到有相应进程为写而打开该FIFO（当前打开操作设置了阻塞标志）；或者，成功返回（当前打开操作没有设置阻塞标志）。 2)、如果当前打开操作是为写而打开FIFO时，如果已经有相应进程为读而打开该FIFO，则当前打开操作将成功返回；否则，可能阻塞直到有相应进程为读而打开该FIFO（当前打开操作设置了阻塞标志）；或者，返回ENXIO错误（当前打开操作没有设置阻塞标志）。 总之，一旦设置了阻塞标志，调用mkfifo建立好之后，那么管道的两端读写必须分别打开，有任何一方未打开，则在调用open的时候就阻塞。对管道或者FIFO调用lseek，返回ESPIPE错误。 > 在write函数执行的时候这个函数有原子性, 如果缓冲区的大小比较小不足以写入所有的数据, 这部分写入会失败 ```c #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> #include <sys/stat.h> #include \"string.h\" #include \"fcntl.h\" int main(int argc, char *argv){ \tint ret mkfifo(\"myfifo\", 0664); \tif(ret < 0){ \t\tperror(\"mkfifo err\"); \t\texit(1); \t} \tpid_t pid fork(); \tif(pid 0){ \t\tint fd2 open(\"myfifo\", O_WRONLY); \t\tint num write(fd2, \"hello\\n\", strlen(\"hello\\n\")); \t\tif(ret < 0){ \t\t\tperror(\"write error\"); \t\t} \t\tprintf(\"write : %d\\n\", num); \t\tclose(fd2); \t}else{ \t\tint fd1 open(\"myfifo\", O_RDONLY); \t\tchar buf[10]; \t\tint num read(fd1, buf, strlen(\"hello\\n\")); \t\tif(ret < 0){ \t\t\tperror(\"read error\"); \t\t} \t\tprintf(\"read : %d\\n\", num); \t\tclose(fd1); \t\tprintf(buf); \t} \t } ``` ## 存储映射I/O 使一个磁盘文件和存储空间里面的一个缓冲区映射, 从缓冲区里面读取数据实际就是从文件里面读取数据 把数据存入缓冲区实际是写文件, 可以在不使用read write的情况下完成文件的读写 ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403241056186.jpg) 可以使用mmap函数进行 ### mmap进行存储映射 `void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);` > addr: 指定映射区域的位置, 一般使用NULL,系统自动分配 > > length: 这一个区域的大小 > > port: 共享内存映射区域的属性PORT_READ, PORT_EXEC, PORT_WRITE, PORT_NONE > > flags: 这一块共享内存的共享属性MAP_SHARED, MAP_PRIVATE, 这一个会决定这一个文件会不会反映到磁盘 > > fd: 用于创建的那一个文件的文件描述符 > > offset: 偏移, 这一个需要时4K的倍数, 这一个值是0的时候默认是这一个文件的全部 > > 返回值: 这一个映射区域的首地址, 失败的话返回一个MAP_FAILED(实际是(void *) 1) ### munmap取消映射 `int munmap(void *addr, size_t length);` > addr, mmap的返回值 > > length:大小 ```c #include <stdio.h> #include <string.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> #include <sys/mman.h> #include <fcntl.h> int main(int argc, char *argv[]){ \tchar *p NULL; \tint fd open(\"test.map\", O_RDWR O_CREAT O_TRUNC, 0644); \tif(fd 1){ \t\tperror(\"creat errro\"); \t\texit(0); \t} \t/* \tlseek(fd, 10, SEEK_END); \twrite(fd, \"\\0\", 1); \t*/ \t//进行映射 \tftruncate(fd, 20);//拓展文件 \tint len lseek(fd, 0, SEEK_END); \tp mmap(NULL, len, PROT_READ PROT_WRITE, MAP_SHARED, fd, 0); \tif(p MAP_FAILED){ \t\tperror(\"mmap error\"); \t\texit(1); \t} \t//测试 \tstrcpy(p, \"hello mmap\"); \tprintf(\" %s \", p); \tint ret munmap(p, len); \tif(ret 1){ \t\tperror(\"unmap error\"); \t\texit(0); \t} \treturn 0; } ``` > **常见错误** > > 实际使用的时候这一个文件的大小需要和映射的大小相同 > > 文件大小为0, 出现总线错误, 映射区域大小为0, 返回无效参数, 文件的权限不对也是无效参数 > > 这一个文件必须要有读权限, 映射的时候需要读文件 > > 文件的描述符mmap之后可以关闭, 之后可以用地址访问 > > offset是4096的倍数 > **注**: > > 1. 这一个申请的内存不可以越界访问 > 2. 获取的地址不能释放了, munmap会失败 > 3. 使用私有的时候这一个文件只需要有读权限 > > 实际使用(最保险的) > > + open: 使用O_RDWR > + mmap(NULL, 有效的文件大小, PORT_READ PORT_WRITE, MAP_SHARED, fd, 0) ### 父子进程间的通信 父子等有血缘关系的进程之间也可以通过mmap建立的映射区来完成数据通信。但相应的要在创建映射区的时候指定对应的标志位参数flags： MAP_PRIVATE: (私有映射) 父子进程各自独占映射区； MAP_SHARED: (共享映射) 父子进程共享映射, 应该使用这一个 1. mmap建立映射 2. 使用fork创建子进程 ### 无关进程之间的通信 打开文件的时候使用同一个文件就可以了 ### 匿名映射 使用映射的时候需要有一个文件, 但是这一个文件不需要一直存在, 这时候可以使用unlink对这一个文件进行删除, 这一个文件不被使用以后会被自动回收 可以直接使用匿名映射来代替。其实Linux系统给我们提供了创建匿名映射区的方法，无需依赖一个文件即可创建映射区。同样需要借助标志位参数flags来指定。 使用MAP_ANONYMOUS (或MAP_ANON)， 如: ` int *p mmap(NULL, 4, PROT_READPROT_WRITE, MAP_SHAREDMAP_ANONYMOUS, 1, 0); ` \"4\"随意举例，该位置表大小，可依实际需要填写。 > The mapping is not backed by any file; its contents are initialized to zero. The fd argument is ignored; however, some implementations require fd to be 1 if MAP_ANONYMOUS (or MAP_ANON) is specified, and portable applications should ensure this. The offset argument should be zero. The use of MAP_ANONYMOUS in conjunction with MAP_SHARED is supported on Linux only since kernel 2.4. > 需注意的是，MAP_ANONYMOUS和MAP_ANON这两个宏是Linux操作系统特有的宏。在类Unix系统中如无该宏定义，可使用如下两步来完成匿名映射区的建立。 > > ​ ① fd open(\"/dev/zero\", O_RDWR); > > ​ ② p mmap(NULL, size, PROT_READPROT_WRITE, MMAP_SHARED, fd, 0); > /dev/null ： 在类Unix系统中，/dev/null，或称空设备，是一个特殊的设备文件，它丢弃一切写入其中的数据（但报告写入操作成功），读取它则会立即得到一个EOF。 > 在程序员行话，尤其是Unix行话中，/dev/null 被称为位桶(bit bucket)或者黑洞(black hole)。空设备通常被用于丢弃不需要的输出流，或作为用于输入流的空文件。这些操作通常由重定向完成。 > > /dev/zero ： 在类UNIX 操作系统中, /dev/zero 是一个特殊的文件，当你读它的时候，它会提供无限的空字符(NULL, ASCII NUL, 0x00)。 > > 其中的一个典型用法是用它提供的字符流来覆盖信息，另一个常见用法是产生一个特定大小的空白文件。BSD就是通过mmap把/dev/zero映射到虚地址空间实现共享内存的。可以使用mmap将/dev/zero映射到一个虚拟的内存空间，这个操作的效果等同于使用一段匿名的内存（没有和任何文件相关）。 值得注意的是：MAP_ANON和 /dev/zero 都不能应用于非血缘关系进程间通信 ## System V消息队列 + 是一个独立于进程的概念 + 没有文件名和文件描述符 + 有ID和key ### 使用 + 定义一个唯一的key, 使用ftok > `key_t ftok(const char *path, int proj_id)`, 一个合法的路径和一个整数, 通常是一个非零的8位整数, 返回一个合法的键值 > > `ftok` 的主要作用是根据文件的属性（如 inode 编号）生成一个唯一的键值。这个键值与文件系统相关联，并结合项目标识符生成独特的 IPC 键。通过这个键，多个进程能够访问相同的 IPC 资源，比如共享内存段、消息队列或信号量。 > > ftok 函数生成的键值并不是完全随机的，它依赖于文件的 inode 编号 和 设备号，因此同一个文件路径在相同的文件系统上会生成相同的键值。 > 键值的生成方式基于以下几个因素： > > 文件的 inode 编号：一个文件的唯一标识符。 > 文件所在设备的设备号：标识文件所在的设备。 > 项目标识符（proj_id）：由用户指定的标识符，用于进一步区分同一文件的不同 IPC 资源。 > ftok 会将这些值组合起来，生成一个可以唯一标识 IPC 资源的键。 + 构建一个消息对象msgget > `int msgget(key_t key, int msgflg)` key是一个键值, msgflg: IPC_CREAT, 不存在的时候创建一下, mode是方位的权限 > > 返回这个队列的ID + 发送特定类型的消息msgsnd > `int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);` > > + msqid: 队列ID > + msgp: 消息缓冲区 > > ```c > struct msgbuf { > long mtype; /* message type, must be > 0 */ > char mtext[1]; /* message data */ > }; > ``` > > + msgsz: 消息的长度, 实际是mtext的长度 > + msgflg: 发送的方式, 0阻塞发送, IPC_NOWAIT非阻塞 + 接受特定的消息msgrcv ```c ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg); ``` > msgtyp: 接受的消息的类型 > > msgflag: IPC_NOWAIT不阻塞, MSG_NOERROR截断消息(实际的消息比给的缓冲区要小), 0阻塞读取 + 删除消息队列msgctl > `int msgctl(int msqid, int cmd, struct msqid_ds *buf);` > > 获取信息和删除 > > IPC_STAT: 获取消息队列的属性信息, 填入buf里面 > > IPC_SET: 设置队列的属性 > > IPC_RMID: 删除消息队列 > > buf: 相关结构体的缓冲区 > > ```c > struct msqid_ds { > struct ipc_perm msg_perm; /* Ownership and permissions */ > time_t msg_stime; /* Time of last msgsnd(2) */ > time_t msg_rtime; /* Time of last msgrcv(2) */ > time_t msg_ctime; /* Time of last change */ > unsigned long __msg_cbytes; /* Current number of bytes in > queue (nonstandard) */ > msgqnum_t msg_qnum; /* Current number of messages > in queue */ > msglen_t msg_qbytes; /* Maximum number of bytes > allowed in queue */ > pid_t msg_lspid; /* PID of last msgsnd(2) */ > pid_t msg_lrpid; /* PID of last msgrcv(2) */ > }; > ``` > > ```c #include <sys/msg.h> #include <stdio.h> #include <stdlib.h> struct msgbuf { long mtype; char mtext[100]; }; int main() { int msqid; key_t key; struct msgbuf sbuf, rbuf; // 生成key if ((key ftok(\"/tmp\", 'a')) 1) { perror(\"ftok\"); exit(1); } // 创建消息队列 if ((msqid msgget(key, IPC_CREAT 0666)) 1) { perror(\"msgget\"); exit(1); } // 发送消息 sbuf.mtype 1; sprintf(sbuf.mtext, \"Hello Message Queue\"); if (msgsnd(msqid, &sbuf, sizeof(sbuf.mtext), 0) 1) { perror(\"msgsnd\"); exit(1); } // 接收消息 if (msgrcv(msqid, &rbuf, sizeof(rbuf.mtext), 1, 0) 1) { perror(\"msgrcv\"); exit(1); } printf(\"Received: %s\\n\", rbuf.mtext); // 删除消息队列 if (msgctl(msqid, IPC_RMID, NULL) 1) { perror(\"msgctl\"); exit(1); } return 0; } ``` ### 多进程示例 ```c #ifndef MSG_COMMON_H #define MSG_COMMON_H #include <sys/ipc.h> #include <sys/msg.h> #include <stdio.h> #include <stdlib.h> #include <string.h> #include <unistd.h> // 消息结构 struct message { long mtype; char mtext[100]; }; // 生成相同的key #define MSG_KEY_PATH \"/tmp\" #define MSG_KEY_PROJ 'A' // 获取消息队列ID int get_msg_queue(int create_flag) { key_t key; // 获取同样的队列 if ((key ftok(MSG_KEY_PATH, MSG_KEY_PROJ)) 1) { perror(\"ftok\"); exit(EXIT_FAILURE); } int flags create_flag ? (IPC_CREAT 0666) : 0; int msqid msgget(key, flags); if (msqid 1) { perror(\"msgget\"); exit(EXIT_FAILURE); } return msqid; } #endif ``` ```c #include \"msg_common.h\" int main() { int msqid get_msg_queue(1); // 创建队列 struct message msg; printf(\"Sender started. Enter messages (type 'exit' to quit):\\n\"); while (1) { printf(\"> \"); fgets(msg.mtext, sizeof(msg.mtext), stdin); msg.mtext[strcspn(msg.mtext, \"\\n\")] '\\0'; // 移除换行符 if (strcmp(msg.mtext, \"exit\") 0) { break; } msg.mtype 1; // 消息类型设为1 if (msgsnd(msqid, &msg, sizeof(msg.mtext), 0) 1) { perror(\"msgsnd\"); exit(EXIT_FAILURE); } printf(\"Sent: %s\\n\", msg.mtext); } printf(\"Sender exiting...\\n\"); return 0; } ``` ```c #include \"msg_common.h\" int main() { int msqid get_msg_queue(0); // 获取已存在的队列 struct message msg; printf(\"Receiver started. Waiting for messages...\\n\"); while (1) { if (msgrcv(msqid, &msg, sizeof(msg.mtext), 1, 0) 1) { perror(\"msgrcv\"); exit(EXIT_FAILURE); } printf(\"Received: %s\\n\", msg.mtext); if (strcmp(msg.mtext, \"exit\") 0) { // 删除消息队列 if (msgctl(msqid, IPC_RMID, NULL) 1) { perror(\"msgctl\"); exit(EXIT_FAILURE); } break; } } printf(\"Receiver exiting...\\n\"); return 0; } ``` ## System V信号量 本质是一个计数器, 用于互斥以及同步, 同时只有一个在访问, 并且可以设置访问的顺序 ### 使用 + 获取一个唯一的key(fork) + 构建一个信号量集合(semget) > `int semget(key_t key, int nsems, int semflg);` > > **nsems**: 信号量集合里面的信号量的数量, 如果使用已存在的信号量集合，则这个值可以忽略，但在创建时需要指定合适的数目。在某些情况下，只有在创建新信号量集时才会用到。 > > **semflg**（`int` 类型）：控制信号量集的行为和权限的标志位（即标志参数）。 > > 常用的标志包括： > > `IPC_CREAT`：如果不存在对应的信号量集，就创建它。 > `IPC_EXCL`：结合 `IPC_CREAT` 使用，确保创建新集，若已存在则返回错误。 > 权限标志（类似文件权限），如 `0666` 表示让所有用户都可以读写。 + 初始化集合中的信号量(semctl SETVA) > `int semctl(int semid, int semnum, int cmd, ...);` > > **semid: **信号量的ID > > **semnum: **信号量的编号, 通常设置为0(集合里面只有一个信号量的时候) > > **cmd: ** > > + IPC_STAT: 获取信号量的状态 > + IPC_SET: 设置信号量的属性 > + IPC_RMID: 删除信号量 > + SETVAL: 设置实际的数量 > > ```c > union semun { > int val; /* Value for SETVAL 设置数量*/ > struct semid_ds *buf; /* Buffer for IPC_STAT, IPC_SET 获取/设置状态 */ > unsigned short *array; /* Array for GETALL, SETALL */ > struct seminfo *__buf; /* Buffer for IPC_INFO > (Linux specific) */ > }; > ``` > > ```c > struct semid_ds { > struct ipc_perm sem_perm; /* Ownership and permissions */ > time_t sem_otime; /* Last semop time */ > time_t sem_ctime; /* Last change time */ > unsigned long sem_nsems; /* No. of semaphores in set */ > }; > ``` + 进行P/V操作(semop) > `int semop(int semid, struct sembuf *sops, size_t nsops);` > > ```c > struct sembuf{ > unsigned short sem_num; /* semaphore number 编号 */ > short sem_op; /* semaphore operation 进行的操作数量 进行+ 的num可以使正数负数和0 */ > short sem_flg; /* operation flags 行为一般是 SEM_UNDO, 进程结束的时候自动释放信号量 */ > } > ``` > > **`sem_op`** > ` 1`：等待（P操作），如果信号量值为0，则阻塞直到变为正数，然后减1 > `1`：信号释放（V操作），将信号量值加1 > `0`：等待信号量变为0（常用于同步条件） > > `nsops: `操作的信号量的个数, 一般是1个 ### 实际使用 ```c #ifndef SEM_COMMON_H #define SEM_COMMON_H #include <sys/types.h> #include <sys/ipc.h> #include <sys/sem.h> #include <stdio.h> #include <stdlib.h> #include <unistd.h> #define SEM_KEY_PATH \"/tmp\" #define SEM_KEY_PROJ 'B' // 获取信号量集ID int get_semaphore(int create_flag) { key_t key; if ((key ftok(SEM_KEY_PATH, SEM_KEY_PROJ)) 1) { perror(\"ftok\"); exit(EXIT_FAILURE); } int flags create_flag ? (IPC_CREAT 0666) : 0; int semid semget(key, 1, flags); // 只创建1个信号量 if (semid 1) { perror(\"semget\"); exit(EXIT_FAILURE); } return semid; } // 信号量操作 void sem_op(int semid, int sem_num, int op) { struct sembuf sb {sem_num, op, SEM_UNDO}; if (semop(semid, &sb, 1) 1) { perror(\"semop\"); exit(EXIT_FAILURE); } } // 初始化信号量 void init_semaphore(int semid, int value) { union semun { int val; struct semid_ds *buf; unsigned short *array; } arg; arg.val value; if (semctl(semid, 0, SETVAL, arg) 1) { perror(\"semctl SETVAL\"); exit(EXIT_FAILURE); } } #endif ``` ```c #include \"sem_common.h\" #include <time.h> int main() { int semid get_semaphore(1); // 创建信号量 // 初始化信号量值为1（二进制信号量/互斥锁） init_semaphore(semid, 1); printf(\"Process 1 started\\n\"); for (int i 0; i < 5; i++) { printf(\"Process 1 trying to enter critical section...\\n\"); // P操作（等待信号量） sem_op(semid, 0, 1); printf(\"Process 1 entered critical section\\n\"); // 模拟临界区工作 srand(time(NULL)); int sleep_time rand() % 3 + 1; sleep(sleep_time); printf(\"Process 1 leaving critical section after %d seconds\\n\", sleep_time); // V操作（释放信号量） sem_op(semid, 0, 1); // 模拟非临界区工作 sleep(1); } printf(\"Process 1 exiting...\\n\"); // 删除信号量（通常由最后一个退出的进程执行） if (semctl(semid, 0, IPC_RMID) 1) { perror(\"semctl IPC_RMID\"); } return 0; } ``` ```c #include \"sem_common.h\" #include <time.h> int main() { int semid get_semaphore(0); // 获取已存在的信号量 printf(\"Process 2 started\\n\"); for (int i 0; i < 5; i++) { printf(\"Process 2 trying to enter critical section...\\n\"); // P操作（等待信号量） sem_op(semid, 0, 1); printf(\"Process 2 entered critical section\\n\"); // 模拟临界区工作 srand(time(NULL)); int sleep_time rand() % 3 + 1; sleep(sleep_time); printf(\"Process 2 leaving critical section after %d seconds\\n\", sleep_time); // V操作（释放信号量） sem_op(semid, 0, 1); // 模拟非临界区工作 sleep(1); } printf(\"Process 2 exiting...\\n\"); return 0; } ``` ## System V共享内存 + 获取一个唯一的key(ftok) + 构建一个共享内存的对象(shmget) `int shmget(key_t key, size_t size, int shmflg);` > size: 共享内存的大小 > > shmflg: > > + IPC_CREATE: 不存在的时候创建 > + mode: 权限 + 共享内存映射(shmat) `void *shmat(int shm_id, const void *shm_addr, int shmflg);` > shm_id: 创建的ID > > shm_addr: 映射的地址, NULL的时候自动分配 > > shmflg: 0的时候可读可写, SHM_RDONLY可读的方式映射 + 解除映射(shmdt) `int shmdt(const void *shmaddr);` + 删除共享内存(shmctl RMID) `int shmctl(int shm_id, int command, struct shmid_ds *buf);` > **CMD** > > IPC_STAT：把shmid_ds结构中的数据设置为共享内存的当前关联值，即用共享内存的当前关联值覆盖shmid_ds的值。 > IPC_SET：如果进程有足够的权限，就把共享内存的当前关联值设置为shmid_ds结构中给出的值 > IPC_RMID：删除共享内存段 > > ```c > struct shmid_ds > { > uid_t shm_perm.uid; > uid_t shm_perm.gid; > mode_t shm_perm.mode; > }; > ``` > ### 使用实例 ```c #include <stdio.h> #include <stdlib.h> #include <string.h> #include <sys/ipc.h> #include <sys/shm.h> #include <sys/types.h> #define SHM_SIZE 1024 // 共享内存大小 int main() { int shmid; key_t key; char *shm, *s; // 生成一个唯一的key if ((key ftok(\"shmfile\", 65)) 1) { perror(\"ftok\"); exit(1); } // 创建共享内存段 if ((shmid shmget(key, SHM_SIZE, IPC_CREAT 0666)) < 0) { perror(\"shmget\"); exit(1); } // 将共享内存附加到进程地址空间 if ((shm shmat(shmid, NULL, 0)) (char *) 1) { perror(\"shmat\"); exit(1); } // 向共享内存写入数据 printf(\"Writing to shared memory...\\n\"); s shm; strcpy(s, \"Hello from shared memory!\"); // 等待读取进程读取数据 while (*shm ! '*') { sleep(1); } // 分离共享内存 if (shmdt(shm) 1) { perror(\"shmdt\"); exit(1); } // 删除共享内存段 if (shmctl(shmid, IPC_RMID, NULL) 1) { perror(\"shmctl\"); exit(1); } printf(\"Write process completed.\\n\"); return 0; } ``` ```c #include <stdio.h> #include <stdlib.h> #include <string.h> #include <sys/ipc.h> #include <sys/shm.h> #include <sys/types.h> #define SHM_SIZE 1024 // 共享内存大小 int main() { int shmid; key_t key; char *shm, *s; // 生成相同的key if ((key ftok(\"shmfile\", 65)) 1) { perror(\"ftok\"); exit(1); } // 获取共享内存段 if ((shmid shmget(key, SHM_SIZE, 0666)) < 0) { perror(\"shmget\"); exit(1); } // 将共享内存附加到进程地址空间 if ((shm shmat(shmid, NULL, 0)) (char *) 1) { perror(\"shmat\"); exit(1); } // 读取共享内存中的数据 printf(\"Reading from shared memory...\\n\"); for (s shm; *s ! '\\0'; s++) { putchar(*s); } putchar('\\n'); // 通知写入进程数据已读取 *shm '*'; // 分离共享内存 if (shmdt(shm) 1) { perror(\"shmdt\"); exit(1); } printf(\"Read process completed.\\n\"); return 0; } ```"},"/note/Linux/Linux系统编程/2024-2-14-01文件IO.html":{"title":"文件IO","content":" layout: post title: \"文件IO\" date: 2024 2 14 15:39:08 +0800 tags: Linux # 文件IO ## 系统调用 操作系统提供给外界的程序编程接口(API) ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402142035039.png) ## C语言的IO函数 fopen、fclose、fseek、fgets、fputs、fread、fwrite...... ​ r 只读、 r+读写 w只写并截断为0、 w+读写并截断为0 a追加只写、 a+追加读写 ### open ```c int open(const char *pathname, int flags); int open(const char *pathname, int flags, mode_t mode); ``` > pathname: 文件名 > > flags: 文件的打开方式, O_RDONLY、O_WRONLY、O_RDWR , O_APPEND、O_CREAT、O_EXCL(文件存在的时候返回一个错误)、 O_TRUNC(打开的时候把之前的数据丢弃)、 O_NONBLOCK(非阻塞) > > modo: 文件的权限, 参数2有O_CREAT的时候才会使用这一个函数, 文件权限由open的mode参数和当前进程的umask掩码共同决定, 实际的是mode & ~umask > > 返回值: 是一个文件描述符, 错误的时候是 1 > > 使用头文件: unistd.h ### 显示错误 #### strerror Linux有一个全局变量errno, 使用头文件errno.h可以使用 还可以使用strerror获取这一个错误的描述, 头文件string.h ```c #include<stdio.h> #include <fcntl.h> #include <unistd.h> #include <errno.h> #include <string.h> int main() { \tint fd; \tfd open(\"test.txt\", O_CREAT O_RDWR, 0666); \tprintf(\"fd %d, errno %d:%s \\n\", fd, errno, strerror(errno)); \tclose(fd); \treturn 0; } ``` #### perror 还可以使用`perror(const char *);` 这一个函数在打印这一个信息以后, 会根据errno的值进行显示实际的错误 ### read/write ```c #include <unistd.h> ssize_t read(int fd, void *buf, size_t count); ``` > 文件, 保存的位置以及读取的大小 > > 返回的时候返回实际读取的大小, 为0的时候已经到末尾了, On error, 1 is returned, and errno is set appropriately. ```c #include <unistd.h> ssize_t write(int fd, const void *buf, size_t count); ``` > 返回实际写入的数据的个数, 错误的话返回 1 > 在实际使用时候, 如果使用fget和read一次读取一个字符进行测试的话, 会发现fgetc的速度实际比read快, 原因是实际使用的时候, fgetc不是一个一个字节的进行的 > > 可以使用命令`strace 可执行文件名`进行测试, 这一个命令会打印出使用的系统调用 > > 标准库里面有一个缓冲区, 这两个函数是无用户级缓冲 ## 文件描述符 ![image 20240318215501848](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403182155934.png) > 文件描述符是进程描述符里面的其中一项 > > 打开一个文件以后, 实际的文件的描述符是一个struct file, 操作系统实际不会给你这一部分, 实际返回的是文件描述符 > > 前三个文件给了标准的文件输入输出, 一个进程最大可以打开1024个文件, 实际打开的时候打开的是可以使用的最小的那一个 > > 前三个使用的时候, 推荐使用这三个文件使用的宏定义 > 这一个文件描述符里面有 > > + 文件的偏移 > + 文件的权限 > + 文件的打开标志 > + 文件的缓冲区 > + 文件的操作函数 > > > 可以在/usr/src/linux headers 5.4.0 152 generic/include/linux/fs.h这一个文件里面的struct file里面获取实际的实现 ## 阻塞和非阻塞 在实际的读取一个文件的时候是不会阻塞的, 但是在读取文件以及网络的时候有可能会发生阻塞 可以直接使用read函数对STDIO_FILENO进行读取, 不需要对文件进行打开 ```c #include <unistd.h> #include <stdlib.h> #include<stdio.h> int main(void){ \tchar buf[10]; \tint n; \tn read(STDIN_FILENO, buf, 10); \tif(n < 0){ \t\tperror(\"read STDIN_FILENO\"); \t\texit(1); \t} \twrite(STDOUT_FILENO, buf, n); \treturn 0; } ``` > 这一个读取的时候会进行阻塞是文件的属性 可以再一次打开/dev/tty, 这时候打开的时候使用一个非阻塞, 如果读取的时候没有数据, 会返回一个 1, 同时会设置errno EAGIN EWOULDBLOCK, 说明这个时候不是read失败, 而是read在读取一个设备文件的时候使用的是一个非阻塞, 并且这一个文件没有数据 ### fcntl改变一个文件的属性 `int fcntl(int fd, int cmd, ... /* arg */ );` 这里主要使用两个命令, F_GETFL, F_SETFL ![image 20240319091735282](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403190917335.png) > 这一个命令只能改变部分的文件标志 ```c flag fcntl(fd, F_GETFL); flag O_NONBLOCK; flag fcntl(fd, F_SETFL, flag); ``` ## lseek文件偏移 和fseek类似 `off_t lseek(int fd, off_t offset, int whence);` > 这一个可以超过文件的末尾, 文件可以被拓展, 实际拓展的时候需要一个写入 `int fseek(FILE *stream, long int offset, int whence)` > 这一个超出文件的末尾返回0, 超出文件的头部返回 1, 常用的参数有SEEK_SET(文件的开头),SEEK_CUR(文件当前位置), SEEK_WND(文件的结尾) 可以使用这一个函数获取这一个文件的大小(从文件的头部到尾部, 返回这一个文件的偏移(相对于文件头部)) > 可以使用命令od tcx查看文件的16进制模式, od tcd查看文件的10进制模式 ### truncate拓展文件大小 `int truncate(const char *path, off_t length);` 这一个文件必须是已经存在的文件, 这一个命令不需要写入, 成功返回0 ## ioctl查看物理特性 ```c #include <sys/ioctl.h> int ioctl(int fd, ind cmd,...); ``` > ioctl函数是用来操作特殊文件的底层设备参数。特别的，许多字符文件的操作特性是通过ioctl来控制的。 ## 参数传递 传入参数: \t1. 指针为参数 \t1. 通常有const关键字进行修饰 \t1. 使用指针进行读操作 ```c char *strcpy(char *dest, const char *src); ``` > src为传入函数, dest是传出参数 传出参数 1. 指针为参数 2. 函数调用之前, 指向的空间可以无意义, 但是是有效的 3. 函数内部写操作 4. 函数结束以后作为函数的返回值 传入传出参数 1. 指针为函数参数 2. 指向的空间有实际的意义 3. 函数里面先进行读, 后进行写 4. 结束以后是返回值 ```c char *strtok_r(char *str, const char *delim, char **saveptr); ``` > 这一个函数实际的作用是进行字符串的分割 > > 返回值: 实际获取的字符串 > > str是传入的字符串。需要注意的是 ：第一次使用strtok_r之后，要把str置为NULL > > delim指向依据分割的字符串。常见的空格“ ” 逗号“,”等 > > saveptr保存剩下待分割的字符串。 > 这一个函数里面的saveptr实际是一个传入传出参数"},"/note/Linux/Linux网络编程/2024-4-16-08html入门.html":{"title":"html入门","content":" layout: post title: \"html入门\" date: 2024 4 14 15:39:08 +0800 tags: Linux 网络 > [HTML 与 VSCode 环境搭建 极客侠GeeksMan (gitee.io)](https://jonathanluo0604.gitee.io/front end/1.front end html.html#配置环境) > > 原文 # html入门 前端是构建网页的一部分, 负责用户在浏览器里面看到和交互的内容, 网页是用户看到的文档页面, 一般是html, css以及JavaScrip组成的 html: 文本以及内容, 包括图像文本之类的 css: 定义样式以及布局 JS: 交互性以及动态的功能 ## 环境 vscode插件: 1. HTML CSS Support: 写CSS代码使用 2. Live Server: 实时预览这一个网页 3. Auto Rename Tag: 改html标签的时候同步改领一个标签 ## html标签 Hypertext Markup Language(超文本标记语言) 标签一般是成对存在的, 内容在两个标签之间 ```html <p>这是一个段落</p> <h1>这是一个标题<h1> <a href \"H\">这是一个超链接</a> ``` > 双标签用于定义包含内容的元素，例如段落、标题、列表等。 > > 它们由两部分组成：开始标签和结束标签，开始标签用表示，结束标签用表示。 > > 开始标签用于定义元素的起始位置，结束标签用于定义元素的结束位置。 > > 在开始标签和结束标签之间可以包含元素的内容。 示例：`<p>` 这是一个段落。`</p>` 表示一个段落元素，其中 `<p>` 是开始标签，`</p>` 是结束标签，之间的文本是该段落的内容。 也有单标签 ```html <input type \"text\"> <br> <hr> ``` > 单标签通常用于表示没有内容的元素，例如图像、换行、横线等。 > > 它们以自封闭的方式出现，不需要闭合标签，因为它们没有内部内容。 > > 单标签的典型形式是 `<tagname>`，其中 tagname 是标签名称。 示例：`<img src \"image.jpg\" />` 表示插入一张图片，而 `<br>` 表示换行。`<hr>`是一个横线 ## 文件格式 ```html <!DOCTYPE html> <html> <head> <! 这里放置文档的元信息 > <title>文档标题</title> <meta charset \"UTF 8\"> <! 连接外部样式表或脚本文件等 > <link rel \"stylesheet\" type \"text/css\" href \"styles.css\"> <script src \"script.js\"></script> </head> <body> <! 这里放置页面内容 > <h1>这是一个标题</h1> <p>这是一个段落。</p> <a href \"https://www.example.com\">这是一个链接</a> <! 其他内容 > </body> </html> ``` ```html <! 这里放置文档的元信息 > <!DOCTYPE html> ``` > 告诉浏览器这是一个html文件 ```html <html> ... </html> ``` > 这一个文档的最外层, 根元素 ```html <head> <! 这里放置文档的元信息 > <title>文档标题</title> <meta charset \"UTF 8\"> <! 连接外部样式表或脚本文件等 > <link rel \"stylesheet\" type \"text/css\" href \"styles.css\"> <script src \"script.js\"></script> </head> ``` > 文档的头部, 文件的元信息, 文档的格式, 文章的名字, 编码格式, 以及外部的样式表, css以及js文件 ```html <body> <! 这里放置页面内容 > <h1>这是一个标题</h1> <p>这是一个段落。</p> <a href \"https://www.example.com\">这是一个链接</a> <! 其他内容 > </body> ``` > 这里面是实际显示的的内容 > 实际编写的时候, 可以在vscode里面输入一个!, 之后回车就可以生成一个框架 > > ```html > <!DOCTYPE html> > <html lang \"en\"> > <head> > <meta charset \"UTF 8\"> > <meta name \"viewport\" content \"width device width, initial scale 1.0\"> > <title>Test 标题</title> > </head> > <body> > <h1>Test</h1> > </body> > </html> > ``` > > ![image 20240417113925970](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404171139098.png) ![image 20240417114011684](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404171140724.png) ## 语法 ### 语法 了解了 HTML 的基本结构之后，我们就可以来学习一下 HTML 的基本语法了。 #### 文本p `文本内容`：使用 `<p>` 标签定义段落，`<h1>` 到 `<h6>` 标签定义标题，`<b>`加粗、`<strong>`加粗、`<i>`斜体, `<u>`下划线, `<del>` 和 `<em> <span>` 标签可以用于强调文本。 > ![image 20240417115023755](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404171150935.png) ```html <h1>这是一个一级标题</h1> <h2>这是一个二级标题</h2> <h3>这是一个三级标题</h3> <h4>这是一个四级标题</h4> <h5>这是一个五级标题</h5> <h6>这是一个六级标题</h6> <p>这是一个段落。</p> <p><strong>重要信息：</strong>这是一个重要的内容。</p> ``` ### 列表ul和il `列表`： 使用 `<ul>` 和 `<li>` 标签创建无序列表，使用 `<ol>` 和 `<li>` 标签创建有序列表。 ```html <ul> <li>无序项目1</li> <li>无序项目2</li> </ul> <ol> <li>有序项目1</li> <li>有序项目2</li> </ol> ``` > ![image 20240417115140280](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404171151318.png) > > 无序的参数type: 实心disc, 空心circle, 小方块square > > 有序的: 使用type, 使用字母A, 使用罗马数字i, 大写罗马数字I 自定义列表 ```html <dl> <dt></dt>/* 小标题*/ <dd></dd>/* 解释标题 */ <dd></dd> </dl> ``` #### 表格table `表格`： 使用 `<table>`、`<tr>`、`<td>`、`<th>` 等标签创建表格，`<table>` 是表格标签的根元素，然后是 `<tr>` 表格的行标签，在 `<tr>` 内部是 `<td>` 与 `<th>` ```html <table> <tr> <th>列A</th> <th>列B</th> <th>列C</th> </tr> <tr> <td>A1</td> <td>B1</td> <td>C1</td> </tr> <tr> <td>A2</td> <td>B2</td> <td>C2</td> </tr> </table> ``` ![image 20240417115332763](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404171153804.png) ![image 20240417115232856](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404171152895.png) > border: 这一个标签的宽度 #### 图像img `图像`： 使用 `<img>` 标签插入图像。 ```html <img src \"图片路径\" alt \"图片描述\"> ``` > 路径可以是相对的, 绝对的, 以及url > > alt: 这一个图片不可以显示的时候显示的文字 > > width: 宽度 > > height:高度 > > title: 提示文本 #### 链接a 使用 `<a>` 标签创建链接。 ```html <a href \"https://github.com/\">访问 GitHub </a> ``` > href是这一个标签特有的属性, 标记指向的路径 > > target打开的方式 > > ![image 20240417171244218](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404171712355.png) > > > _self:在这一个窗口打开 > > > > _blank: 新的窗口打开 > > > > _parent: 父窗口打开 > > > > _top: 顶层窗口打开 > > title: 提示 可以把里面的文字换为图片 #### 注释`<! 注释内容 >` `注释`： 使用 `` 添加注释，不会在浏览器中显示。 ```html <! 这是一个注释 > ``` ![image 20240417114635656](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404171146746.png) #### 换行br #### 分割线hr #### form输入信息 HTML的`<form>`标签是用于创建表单的元素。表单是用于收集用户输入信息的页面部分，可以包含输入字段、选择框、按钮等元素，用户可以在表单中填写或选择相关信息后提交给服务器进行处理。 最常使用的是input标签, 这一个标签最常使用的属性是type, 这一个表示这一个input属性的类型 > action: 一个后端提供的网址, 用于提交信息 #### 分块div HTML的`<div>`标签是一个块级容器元素，可以用于将文档中的内容进行分组或者进行样式控制。 `<div>`标签本身没有特定的语义含义，主要用于布局和样式的控制，可以根据需要对其进行灵活的定制。 > 使用的时候通常会给他指定一个类, 可是使用`.类名`快速创建 > > 初始带一个id的话可以使用`#id` > > 也可以使用`div.类名`或者`div#id` > > ![image 20240417182103948](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404171821003.png) > > ![image 20240417182302877](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404171823916.png) 可以使用这一个设置居中, 属性align, 参数left, center, right #### span行内分区 没有特殊元素的`<a>和<img>`标签 把一小部分的文本包装起来, 以便于使用样式, CSS或者是JS行为, 这一个是一个行内元素 #### input + text文本输入 ![image 20240417182525597](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404171825631.png) 这一个placeholder属性的作用是没有输入的时候有一个显示 ![image 20240417182636270](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404171826313.png) value是一个默认填写 ![image 20240417182856243](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404171828288.png) labe是和input配套使用的, 相当于span标签 + radio单选框 ![image 20240417183255240](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404171832285.png) > 这两个的name一样的时候只可以选其中一个 + label abe是和input配套使用的, 相当于span标签 > 这一个有一个属性for, 可以指定一个其他框的id + password 输入的信息不再使用明文显示 ![image 20240417183807701](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404171838747.png) + checkbox多选 ![image 20240417183933078](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404171839130.png) + submit提交 把上面的信息提交 ![image 20240417184110380](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404171841438.png) > vlaue: 这一个按钮的名字 + file 上传文件 + email 输入邮箱 ### 锚链接 1. 使用p设置一个锚点 2. 超链接到锚点 ```html <p id \"top\" > <a herf \"#top\">回到顶部</a> ``` ### 属性 每一个标签都可以有多个属性, 用于描述这一个标签的特征以及行为以及与其他元素的关系。下面是 HTML 属性的一些基本概念和常见用法。 在 HTML 中，每个元素都可以有一个或多个属性，用于描述元素的特征和行为。属性的基本语法是：`<开始标签 属性名 \"属性值\">`，其中属性名用于标识该属性，属性值则定义该属性的值。属性名和属性值之间用等号 ` ` 隔开，属性值一般要用引号将其括起来，可以是单引号或双引号，示例： ```html <img src \"image.png\" alt \"图片\"> ``` > 属性的名字不区分大小写, 但是他的属性区分大小写 其中，`src` 是指定图片的文件路径的属性，`alt` 是指定在无法加载图片时显示的替代文本的属性。这些属性可以让用户了解图像的内容，同时也有助于调整图片的大小和位置。 属性是用来定义元素的性质和功能的。它们可以指定元素的尺寸、颜色、文字方向、链接目标等，有助于页面的定位和布局。下面是一些常见的属性用法： 1. `class` 属性：`class` 属性是用于向元素添加一个或多个类名，以便通过 CSS 样式表定义样式。此外，类名还可以用来实现 JavaScript 的交互效果。例如： ```html <p class \"note\">这是一个带有 note 类属性的 p 标签</p> ``` 2. `id` 属性：`id` 属性是用于将元素标识为唯一的标识符。它使得我们可以通过 JavaScript 或 CSS 来定位和操作该元素。例如： ```html <div id \"header\">这是一个带有 header id 的 div 标签</div> ``` 3. `style` 属性：`style` 属性是用于将CSS样式规则直接应用于元素。它可以用于控制元素的颜色、字体、大小和布局等。例如： ```html <div style \"color: red; font size: 20px;\">这是一段红色的文字</div> ``` 以上三种是所有标签都有的属性，也有一些标签具有独特的属性，比如 a 标签的 href 属性，img 标签的 src 属性等等。 ### 区块 当涉及到 HTML 元素时，可以将它们分为两个主要类别：`行内元素` 和 `块级元素`。这些不同类型的元素在 HTML 文档中的呈现和布局方面有很大的不同。下面是关于这两种类型的元素的详细说明： 1. `块级元素（block）`：块级元素通常用于组织和布局页面的主要结构和内容，例如段落、标题、列表、表格等。它们用于创建页面的主要部分，将内容分隔成逻辑块。 块级元素通常会从新行开始，并占据整行的宽度，因此它们会在页面上呈现为一块独立的内容块。 可以包含其他块级元素和行内元素。 常见的块级元素包括 `<div>`, `<p>`, `<h1>` 到 `<h6>`, `<ul>`, `<ol>`, `<li>`, `<table>`, `<form>` 等。 2. `行内元素（inline）`：行内元素通常用于添加文本样式或为文本中的一部分应用样式。它们可以在文本中插入小的元素，例如超链接、强调文本等。 行内元素通常在同一行内呈现，不会独占一行。 它们只占据其内容所需的宽度，而不是整行的宽度。 行内元素不能包含块级元素，但可以包含其他行内元素。 常见的行内元素包括 `<span>`, `<a>`, `<strong>`, `<em>`, `<img>`, `<br>`, `<input>` 等。 示例： ```html <div>这是一个块级元素，它会独占一行。</div> <p>这也是一个块级元素，通常用于段落。</p> <a href \"https://docs.geeksman.com\">这是一个行内元素，它嵌套在段落中。</a> <span>这是第二个行内元素</span> ```"},"/note/Linux/Linux网络编程/2024-4-20-11服务器.html":{"title":"Web服务器","content":" layout: post title: \"Web服务器\" date: 2024 4 20 15:39:08 +0800 tags: Linux 网络 # Web服务器 ## 实际使用 编译的时候需要有一个libevent库 ```c gcc httpserv.c o httpserv levent ``` 实际使用的时候需要指定端口以及共享的目录 ````c ./httpserv 80 . ```` 这一个函数会吧这一个文件夹下面的所有文件共享出去 ![image 20240420195055437](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404201950509.png) > 实际的效果, 这里我是把我的笔记共享了一下 ## 实现目标 1. 使用libevent库进行处理客户端连接(listener_cb) 2. 时候http协议和浏览器进行连接 3. 获取连接以后把服务启的某个文件夹下面的文件目录返回 4. 可以根据返回的目录获取文件信息(bufferevent的读回调函数) 5. 日志会在http.log文件里面 ```c /************************************************************************* > File Name: http0.c > Author: XvSenfeng > Mail: 1458612070@qq.com > Created Time: Thu 18 Apr 2024 11:11:53 AM CST ************************************************************************/ #include <string.h> #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> #include <event2/event.h> #include <event2/listener.h> #include <event2/bufferevent.h> #include <signal.h> #include <arpa/inet.h> #include <ctype.h> #include <sys/stat.h> #include <fcntl.h> #include <dirent.h> //读取一行 int get_line(struct bufferevent *bev, char *buf, int size){ \tint i 0; \tchar c '\\0'; \tint n; \tstatic char temp, todeal 0; \tif(todeal 1){ \t\tbuf[0] temp; \t\ti++; \t\ttodeal 0; \t} \twhile((i < size 1) && (c ! '\\n')){ \t\tn bufferevent_read(bev, &c, 1); \t\tif(n > 0){ \t\t\tif(c '\\r'){ \t\t\t\tn bufferevent_read(bev, &temp, 1); \t\t\t\tif((n > 0) && (temp '\\n')){ \t\t\t\t\tbuf[i++] temp; \t\t\t\t\tbreak; \t\t\t\t}else{ \t\t\t\t\tbuf[i++] '\\n'; \t\t\t\t\ttodeal 1; \t\t\t\t\tbreak; \t\t\t\t} \t\t\t} \t\t\tbuf[i] c; \t\t\ti++; \t\t}else{ \t\t\tc '\\n'; \t\t} \t} \tbuf[i] '\\0'; \tif(n 1){ \t\ti n; \t} \treturn i; } //根据文件的后缀, 获取文件的类型(用于HTTP协议通讯) //name:文件名 //type:传出参数 void get_file_type(const char *name, char *type){ \tif(strstr(name, \".html\")){ \t\tstrcpy(type, \"text/html; charset utf 8\"); \t}else if(strstr(name, \".jpg\")){ \t\tstrcpy(type, \"image/jpeg\"); \t}else if(strstr(name, \".png\")){ \t\tstrcpy(type, \"image/png\"); \t}else if(strstr(name, \".gif\")){ \t\tstrcpy(type, \"image/gif\"); \t}else if(strstr(name, \".wav\")){ \t\tstrcpy(type, \"audio/wav\"); \t}else if(strstr(name, \".mp3\")){ \t\tstrcpy(type, \"audio/mp3\"); \t}else if(strstr(name, \".mp4\")){ \t\tstrcpy(type, \"video/mp4\"); \t}else{ \t\tstrcpy(type, \"text/plain; charset utf 8\"); \t} } //发送一个文件 //filename:文件名 //bev:使用的事件缓冲区 void send_file(const char *filename, struct bufferevent *bev){ \tchar buf[1024]; //打开文件 \tint fd open(filename, O_RDONLY); \tif(fd 1){ \t\tperror(\"open error\"); \t\texit(1); \t} \t//发送文件内容 \tint len 0; \twhile((len read(fd, buf, sizeof(buf))) > 0){ \t\tbufferevent_write(bev, buf, len); \t} \tclose(fd); } //发送HTTP协议的头部 //错误号，错误描述，文件类型，文件长度，bufferevent，文件名 void send_respond(int no, char *disp, char *type, long size, struct bufferevent *bev){ \t//发送http响应 \tchar buf[1024] {0}; \tsprintf(buf, \"HTTP/1.1 %d %s\\r\\n\", no, disp); \tbufferevent_write(bev, buf, strlen(buf)); \tsprintf(buf, \"Content Type: %s\\r\\n\", type); \tbufferevent_write(bev, buf, strlen(buf)); \tsprintf(buf, \"Content Length: %ld\\r\\n\", size); \tbufferevent_write(bev, buf, strlen(buf)); \tsprintf(buf, \"Connection: close\\r\\n\"); \tbufferevent_write(bev, buf, strlen(buf)); \tsprintf(buf, \"\\r\\n\"); \tbufferevent_write(bev, buf, strlen(buf)); } //把文本转化为URL格式, 可用于网址 void strencode(char* to, size_t tosize, const char* from) { \tint tolen; \tfor (tolen 0; *from ! '\\0' && tolen + 4 < tosize; ++from) \t{ \t\tif (isalnum(*from) strchr(\"/_. ~\", *from) ! (char*)0) \t\t{ \t\t\t*to *from; \t\t\t++to; \t\t\t++tolen; \t\t} \t\telse \t\t{ \t\t\tsprintf(to, \"%%%02x\", (int) *from & 0xff); \t\t\tto + 3; \t\t\ttolen + 3; \t\t} \t} \t*to '\\0'; } //发送一个文件夹目录 //dirname:文件夹名字 int send_dir(struct bufferevent *bev,const char *dirname) { \tchar encoded_name[1024]; \tchar path[1024]; \tchar timestr[64]; \tstruct stat sb; \tstruct dirent **dirinfo; \tint i; \tchar *buf malloc(10240); \tsprintf(buf, \"<html><head><meta charset \\\"utf 8\\\"><title>%s</title></head>\", dirname); \tsprintf(buf+strlen(buf), \"<body><h1>当前目录：%s</h1><table>\", dirname); \t//添加目录内容 \tint num scandir(dirname, &dirinfo, NULL, alphasort); \tfor(i 0; i<num; ++i) \t{ \t\t// 编码 \t\tstrencode(encoded_name, sizeof(encoded_name), dirinfo[i] >d_name); \t\tsprintf(path, \"%s%s\", dirname, dirinfo[i] >d_name); \t\tprintf(\"############# path %s\\n\", path); \t\tif (lstat(path, &sb) < 0) \t\t{ \t\t\tsprintf(buf+strlen(buf), \t\t\t\t\t\"<tr><td><a href \\\"%s\\\">%s</a></td></tr>\\n\", \t\t\t\t\tencoded_name, dirinfo[i] >d_name); \t\t} \t\telse \t\t{ \t\t\tstrftime(timestr, sizeof(timestr), \t\t\t\t\t\" %d %b %Y %H:%M\", localtime(&sb.st_mtime)); \t\t\tif(S_ISDIR(sb.st_mode)) \t\t\t{ //这是一个文件夹 \t\t\t\tsprintf(buf+strlen(buf), \t\t\t\t\t\t\"<tr><td><a href \\\"%s/\\\">%s/</a></td><td>%s</td><td>%ld</td></tr>\\n\", \t\t\t\t\t\tencoded_name, dirinfo[i] >d_name, timestr, sb.st_size); \t\t\t} \t\t\telse \t\t\t{ //这是一个普通文件 \t\t\t\tsprintf(buf+strlen(buf), \t\t\t\t\t\t\"<tr><td><a href \\\"%s\\\">%s</a></td><td>%s</td><td>%ld</td></tr>\\n\", \t\t\t\t\t\tencoded_name, dirinfo[i] >d_name, timestr, sb.st_size); \t\t\t} \t\t} \t\tif(strlen(buf)>10000) \t\t{ \t\t\tbreak;\t \t\t} \t\t//bufferevent_write(bev, buf, strlen(buf)); \t\t// memset(buf, 0, sizeof(buf)); \t} \tsprintf(buf+strlen(buf), \"</table></body></html>\"); \tsend_respond(200, \"OK\", \"text/html\", strlen(buf), bev); \tbufferevent_write(bev, buf, strlen(buf)); \tprintf(\"################# Dir Read OK !!!!!!!!!!!!!!\\n\"); \treturn 0; } //发送一个错误页面 void send_404(struct bufferevent *bev){ \t//发送一个404页面 \tstruct stat sbuf; \tstat(\"404.html\", &sbuf); \tsend_respond(404, \"Not Found\", \"text/html\", sbuf.st_size, bev); \tsend_file(\"404.html\", bev); } //16进制数转化为10进制, return 0不会出现 int hexit(char c) { \tif (c > '0' && c < '9') \t\treturn c '0'; \tif (c > 'a' && c < 'f') \t\treturn c 'a' + 10; \tif (c > 'A' && c < 'F') \t\treturn c 'A' + 10; \treturn 0; } void strdecode(char *to, char *from); void http_request(const char *filename1, struct bufferevent *bev){ \tstruct stat sbuf; \tchar filename[1024]; \tstrdecode(filename,(char *) filename1); \tint ret stat(filename, &sbuf); \tif(ret ! 0){ \t\tperror(\"stat error\"); \t\tsend_404(bev); \t\treturn; \t} \tchar buf[128]; \tget_file_type(filename, buf); \t//判断是不是目录 \tif(S_ISDIR(sbuf.st_mode)){ \t\tsend_dir(bev, filename); \t}else{ \t\t//打开文件 \t\t//send_respond(200, \"OK\", \"text/html\", sbuf.st_size, bev); \t\tsend_respond(200, \"OK\", buf, sbuf.st_size, bev); \t\tsend_file(filename, bev); \t}\t \tprintf(\"read cb over\"); } void read_cb(struct bufferevent *bev, void *arg){ \tchar line[1024]; \tint len get_line(bev, line, sizeof(line)); \tif(len < 0){ \t\tprintf(\"get line error\\n\"); \t\tbufferevent_free(bev); \t\treturn; \t} \tprintf(\"http header: %s\", line); \t//判断是不是空行 \tif(strcmp(line, \"\\n\") 0 strcmp(line, \"\\r\\n\") 0){ \t\tprintf(\"空行\\n\"); \t\t//断开连接 \t\tbufferevent_free(bev); \t\treturn; \t} \t//判断是不是请求行 \tchar path[1024] {0}, protocol[20] {0}; \tsscanf(line, \"%*s %s %s\", path, protocol); \t//读取剩余数据 \tchar buf[1024] {0}; \twhile(1){ \t\tlen get_line(bev, buf, sizeof(buf)); \t\tif(len < 0){ \t\t\tbreak; \t\t} \t\tif(strcmp(buf, \"\\n\") 0 strcmp(buf, \"\\r\\n\") 0){ \t\t\tbreak; \t\t} \t} \tif(strncasecmp(line, \"GET\", 3) 0){ \t\tchar *file path + 1; \t\tif(strcmp(path, \"/\") 0){ \t\t\tfile \"./\"; \t\t} \t\thttp_request(file, bev); \t\tsignal_over 1; \t}else{ \t\tprintf(\"POST\\n\"); \t} } //写回调, 这一没啥用 void write_cb(struct bufferevent *bev, void *arg){ \tprintf(\"write_cb\\n\"); } //事件callback函数, 某一次连接被打断的时候会调用这一个函数 void event_cb(struct bufferevent *bev, short events, void *arg){ \tif(events & BEV_EVENT_EOF){ \t\tprintf(\"connection closed\\n\"); \t}else if(events & BEV_EVENT_ERROR){ \t\tprintf(\"some other error\\n\"); \t} \tbufferevent_free(bev); } //监听的回调函数 void listener_cb(struct evconnlistener *listener, evutil_socket_t fd, struct sockaddr *addr, int socklen, void *arg){ \tstruct event_base *base (struct event_base *)arg; \tstruct sockaddr_in *sin (struct sockaddr_in *)addr; \t//获取客户端ip和端口 \tchar ip[16]; \tinet_ntop(AF_INET, &sin >sin_addr.s_addr, ip, sizeof(ip)); \tprintf(\"accept a client %s:%d\\n\", ip, ntohs(sin >sin_port)); \t//创建bufferevent, 之后使用bufferevent的回调函数处理连接事件 \tstruct bufferevent *bev bufferevent_socket_new(base, fd, \t\t\tBEV_OPT_CLOSE_ON_FREE); \tif(bev NULL){ \t\tprintf(\"bufferevent error\"); \t\treturn; \t} \t//设置读写回调 \tbufferevent_flush(bev, EV_READ EV_WRITE, BEV_NORMAL); \tbufferevent_setcb(bev, read_cb, write_cb, event_cb, arg); \tbufferevent_enable(bev, EV_READ EV_WRITE); } //处理信号的回调函数 void signal_cb(evutil_socket_t sig, short events, void *user_data) { \tstruct event_base *base user_data; \tstruct timeval delay { 1, 0 }; \tprintf(\"Caught an interrupt signal; exiting cleanly in one seconds.\\n\"); \tevent_base_loopexit(base, &delay); } //把一个url void strdecode(char *to, char *from) { \tfor ( ; *from ! '\\0'; ++to, ++from) \t{ //检测一下下面的三个字符是不是%xx格式的 \t\tif (from[0] '%' && isxdigit(from[1]) && isxdigit(from[2])) \t\t{ \t\t\t//依次判断from中 %20 三个字符, 把这三个字符转换为10进制的数字 \t\t\t*to hexit(from[1])*16 + hexit(from[2]); \t\t\t// 移过已经处理的两个字符(%21指针指向1),表达式3的++from还会再向后移一个字符 \t\t\tfrom + 2; \t\t} \t\telse \t\t{ \t\t\t*to *from; \t\t} \t} \t*to '\\0'; } int main(int argc, char *argv[]){ \tint pid; \t//看一下参数的个数对不对 if(argc < 3){ \t\tprintf(\"./serv port path\"); \t\treturn 0; \t} //建立一个守护进程 \tpid fork(); \tif(pid > 0){ \t\texit(1); \t} \t//切换工作目录, 使用第三个参数 \tconst char *path argv[2]; \tint ret chdir(path); \tif(ret 1){ \t\tperror(\"chdir error\"); \t\treturn 1; \t} \tpid setsid(); \tumask(0022); \tclose(STDIN_FILENO); \tint fd; //一个日志文件 \tfd open(\"http.log\", O_RDWRO_CREAT); \tif(fd 1){ \t\tperror(\"open error\"); \t\texit(1); \t} \tdup2(fd, STDOUT_FILENO); \tdup2(fd, STDERR_FILENO); \t//获取连接的端口 \tint port atoi(argv[1]); \t//创建服务器地址 \tstruct sockaddr_in serv; \t//初始化服务器地址 \tmemset(&serv, 0, sizeof(serv)); \tserv.sin_family AF_INET; \tserv.sin_port htons(port); \tserv.sin_addr.s_addr htonl(INADDR_ANY); \t//创建event_base \tstruct event_base *base event_base_new(); \tif(base NULL){ \t\tprintf(\"event base error\"); \t\treturn 1; \t} \t//创建监听器 \tstruct evconnlistener *listener evconnlistener_new_bind( \t\t\tbase, listener_cb, base, \t\t\tLEV_OPT_CLOSE_ON_FREE LEV_OPT_REUSEABLE, 1, \t\t\t(struct sockaddr *)&serv, sizeof(serv)); \tif(listener NULL){ \t\tprintf(\"listener error\"); \t\treturn 1; \t} \tstruct event *signal_event; //绑定信号回调 \tsignal_event evsignal_new(base, SIGINT, signal_cb, (void *)base); \tif (!signal_event event_add(signal_event, NULL)<0) \t{ \t\tfprintf(stderr, \"Could not create/add a signal event!\\n\"); \t\treturn 1; \t} //开启循环 \tevent_base_dispatch(base); \tevconnlistener_free(listener); \tevent_base_free(base); \treturn 0; } ``` # 加一个markdown ```c /************************************************************************* > File Name: http0.c > Author: XvSenfeng > Mail: 1458612070@qq.com > Created Time: Thu 18 Apr 2024 11:11:53 AM CST ************************************************************************/ #include <string.h> #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> #include <event2/event.h> #include <event2/listener.h> #include <event2/bufferevent.h> #include <signal.h> #include <arpa/inet.h> #include <ctype.h> #include <sys/stat.h> #include <fcntl.h> #include <dirent.h> int get_line(struct bufferevent *bev, char *buf, int size){ \tint i 0; \tchar c '\\0'; \tint n; \tstatic char temp, todeal 0; \tif(todeal 1){ \t\tbuf[0] temp; \t\ti++; \t\ttodeal 0; \t} \twhile((i < size 1) && (c ! '\\n')){ \t\tn bufferevent_read(bev, &c, 1); \t\tif(n > 0){ \t\t\tif(c '\\r'){ \t\t\t\tn bufferevent_read(bev, &temp, 1); \t\t\t\tif((n > 0) && (temp '\\n')){ \t\t\t\t\tbuf[i++] temp; \t\t\t\t\tbreak; \t\t\t\t}else{ \t\t\t\t\tbuf[i++] '\\n'; \t\t\t\t\ttodeal 1; \t\t\t\t\tbreak; \t\t\t\t} \t\t\t} \t\t\tbuf[i] c; \t\t\ti++; \t\t}else{ \t\t\tc '\\n'; \t\t} \t} \tbuf[i] '\\0'; \tif(n 1){ \t\ti n; \t} \treturn i; } void get_file_type(const char *name, char *type){ \tif(strstr(name, \".html\")){ \t\tstrcpy(type, \"text/html; charset utf 8\"); \t}else if(strstr(name, \".md\")){ \t\tstrcpy(type, \"text/html; charset utf 8\"); \t}else if(strstr(name, \".jpg\")){ \t\tstrcpy(type, \"image/jpeg\"); \t}else if(strstr(name, \".png\")){ \t\tstrcpy(type, \"image/png\"); \t}else if(strstr(name, \".gif\")){ \t\tstrcpy(type, \"image/gif\"); \t}else if(strstr(name, \".wav\")){ \t\tstrcpy(type, \"audio/wav\"); \t}else if(strstr(name, \".mp3\")){ \t\tstrcpy(type, \"audio/mp3\"); \t}else if(strstr(name, \".mp4\")){ \t\tstrcpy(type, \"video/mp4\"); \t}else{ \t\tstrcpy(type, \"text/plain; charset utf 8\"); \t} } int is_md(const char *name){ \tif(strstr(name, \".md\")){ \t\treturn 1; \t} \treturn 0; } void send_file(const char *filename, struct bufferevent *bev){ \tchar buf[1024]; \tint fd open(filename, O_RDONLY); \tif(fd 1){ \t\tperror(\"open error\"); \t\texit(1); \t} \t//发送文件内容 \tint len 0; \twhile((len read(fd, buf, sizeof(buf))) > 0){ \t\tbufferevent_write(bev, buf, len); \t} \tclose(fd); } //错误号，错误描述，文件类型，文件长度，bufferevent，文件名 void send_respond(int no, char *disp, char *type, long size, struct bufferevent *bev){ \t//发送http响应 \tchar buf[1024] {0}; \tsprintf(buf, \"HTTP/1.1 %d %s\\r\\n\", no, disp); \tbufferevent_write(bev, buf, strlen(buf)); \tsprintf(buf, \"Content Type: %s\\r\\n\", type); \tbufferevent_write(bev, buf, strlen(buf)); \tsprintf(buf, \"Content Length: %ld\\r\\n\", size); \tbufferevent_write(bev, buf, strlen(buf)); \tsprintf(buf, \"Connection: close\\r\\n\"); \tbufferevent_write(bev, buf, strlen(buf)); \tsprintf(buf, \"\\r\\n\"); \tbufferevent_write(bev, buf, strlen(buf)); } void strencode(char* to, size_t tosize, const char* from) { \tint tolen; \tfor (tolen 0; *from ! '\\0' && tolen + 4 < tosize; ++from) \t{ \t\tif (isalnum(*from) strchr(\"/_. ~\", *from) ! (char*)0) \t\t{ \t\t\t*to *from; \t\t\t++to; \t\t\t++tolen; \t\t} \t\telse \t\t{ \t\t\tsprintf(to, \"%%%02x\", (int) *from & 0xff); \t\t\tto + 3; \t\t\ttolen + 3; \t\t} \t} \t*to '\\0'; } int send_dir(struct bufferevent *bev,const char *dirname) { \tchar encoded_name[1024]; \tchar path[1024]; \tchar timestr[64]; \tstruct stat sb; \tstruct dirent **dirinfo; \tint i; \tchar *buf malloc(10240); \tsprintf(buf, \"<html><head><meta charset \\\"utf 8\\\"><title>%s</title></head>\", dirname); \tsprintf(buf+strlen(buf), \"<body><h1>当前目录：%s</h1><table>\", dirname); \t//添加目录内容 \tint num scandir(dirname, &dirinfo, NULL, alphasort); \tfor(i 0; i<num; ++i) \t{ \t\t// 编码 \t\tstrencode(encoded_name, sizeof(encoded_name), dirinfo[i] >d_name); \t\tsprintf(path, \"%s%s\", dirname, dirinfo[i] >d_name); \t\t//printf(\"############# path %s\\n\", path); \t\tif (lstat(path, &sb) < 0) \t\t{ \t\t\tsprintf(buf+strlen(buf), \t\t\t\t\t\"<tr><td><a href \\\"%s\\\">%s</a></td></tr>\\n\", \t\t\t\t\tencoded_name, dirinfo[i] >d_name); \t\t} \t\telse \t\t{ \t\t\tstrftime(timestr, sizeof(timestr), \t\t\t\t\t\" %d %b %Y %H:%M\", localtime(&sb.st_mtime)); \t\t\tif(S_ISDIR(sb.st_mode)) \t\t\t{ \t\t\t\tsprintf(buf+strlen(buf), \t\t\t\t\t\t\"<tr><td><a href \\\"%s/\\\">%s/</a></td><td>%s</td><td>%ld</td></tr>\\n\", \t\t\t\t\t\tencoded_name, dirinfo[i] >d_name, timestr, sb.st_size); \t\t\t} \t\t\telse \t\t\t{ \t\t\t\tsprintf(buf+strlen(buf), \t\t\t\t\t\t\"<tr><td><a href \\\"%s\\\">%s</a></td><td>%s</td><td>%ld</td></tr>\\n\", \t\t\t\t\t\tencoded_name, dirinfo[i] >d_name, timestr, sb.st_size); \t\t\t} \t\t} \t\tif(strlen(buf)>10000) \t\t{ \t\t\tbreak;\t \t\t} \t\t//bufferevent_write(bev, buf, strlen(buf)); \t\t// memset(buf, 0, sizeof(buf)); \t} \tsprintf(buf+strlen(buf), \"</table></body></html>\"); \tsend_respond(200, \"OK\", \"text/html\", strlen(buf), bev); \tbufferevent_write(bev, buf, strlen(buf)); \tprintf(\"################# Dir Read OK !!!!!!!!!!!!!!\\n\"); \treturn 0; } void send_404(struct bufferevent *bev){ \t//发送一个404页面 \tstruct stat sbuf; \tstat(\"404.html\", &sbuf); \tsend_respond(404, \"Not Found\", \"text/html\", sbuf.st_size, bev); \tsend_file(\"404.html\", bev); } //16进制数转化为10进制, return 0不会出现 int hexit(char c) { \tif (c > '0' && c < '9') \t\treturn c '0'; \tif (c > 'a' && c < 'f') \t\treturn c 'a' + 10; \tif (c > 'A' && c < 'F') \t\treturn c 'A' + 10; \treturn 0; } void send_md_file(const char *filename, struct bufferevent * bev){ \tchar buf[128]; \tget_file_type(filename, buf); \tstruct stat sbuf, sbuf1, sbuf2; \tint ret stat(filename, &sbuf); \tif(ret ! 0){ \t\tperror(\"stat error\"); \t\tsend_404(bev); \t\treturn; \t} \tret stat(\"markdown2html.html\", &sbuf1); \tif(ret ! 0){ \t\tperror(\"stat error\"); \t\tsend_404(bev); \t\treturn; \t} \tret stat(\"markdown2html2.html\", &sbuf2); \tif(ret ! 0){ \t\tperror(\"stat error\"); \t\tsend_404(bev); \t\treturn; \t} \tsend_respond(200, \"OK\", buf, sbuf.st_size + sbuf1.st_size + sbuf2.st_size, bev); \tprintf(\"sendmd\"); \tsend_file(\"markdown2html.html\", bev); \tsend_file(filename, bev); \tsend_file(\"markdown2html2.html\", bev); } void strdecode(char *to, char *from); void http_request(const char *filename1, struct bufferevent *bev){ \tstruct stat sbuf; \tchar filename[1024]; \tstrdecode(filename,(char *) filename1); \tint ret stat(filename, &sbuf); \tif(ret ! 0){ \t\tperror(\"stat error\"); \t\tsend_404(bev); \t\treturn; \t} \tchar buf[128]; \tget_file_type(filename, buf); \t//判断是不是目录 \tif(S_ISDIR(sbuf.st_mode)){ \t\tsend_dir(bev, filename); \t}else{ \t\t//打开文件 \t\t//send_respond(200, \"OK\", \"text/html\", sbuf.st_size, bev); \t\t \t\tif(!is_md(filename)){ \t\t\tsend_respond(200, \"OK\", buf, sbuf.st_size, bev); \t\t\tsend_file(filename, bev); \t\t}else \t\t{ \t\t\tsend_md_file(filename, bev); \t\t} \t}\t \tprintf(\"read cb over\"); } void conn_eventcb(struct bufferevent *bev, short events, void *user_data) { \tprintf(\"******************** begin call %s.........\\n\", __FUNCTION__); \tif (events & BEV_EVENT_EOF) \t{ \t\tprintf(\"Connection closed.\\n\"); \t} \telse if (events & BEV_EVENT_ERROR) \t{ \t\tprintf(\"Got an error on the connection: %s\\n\", \t\t\t\tstrerror(errno)); \t} \tbufferevent_free(bev); \tprintf(\"******************** end call %s.........\\n\", __FUNCTION__); } int signal_over 0; void read_cb(struct bufferevent *bev, void *arg){ \tchar line[1024]; \tint len get_line(bev, line, sizeof(line)); \tif(len < 0){ \t\tprintf(\"get line error\\n\"); \t\tbufferevent_free(bev); \t\treturn; \t} \tprintf(\"http header: %s\", line); \t//判断是不是空行 \tif(strcmp(line, \"\\n\") 0 strcmp(line, \"\\r\\n\") 0){ \t\tprintf(\"空行\\n\"); \t\t//断开连接 \t\tbufferevent_free(bev); \t\treturn; \t} \t//判断是不是请求行 \tchar path[1024] {0}, protocol[20] {0}; \tsscanf(line, \"%*s %s %s\", path, protocol); \t//读取剩余数据 \tchar buf[1024] {0}; \twhile(1){ \t\tlen get_line(bev, buf, sizeof(buf)); \t\tif(len < 0){ \t\t\tbreak; \t\t} \t\tif(strcmp(buf, \"\\n\") 0 strcmp(buf, \"\\r\\n\") 0){ \t\t\tbreak; \t\t} \t} \tif(strncasecmp(line, \"GET\", 3) 0){ \t\tchar *file path + 1; \t\tif(strcmp(path, \"/\") 0){ \t\t\tfile \"./\"; \t\t} \t\thttp_request(file, bev); \t\tsignal_over 1; \t}else{ \t\tprintf(\"POST\\n\"); \t} } void write_cb(struct bufferevent *bev, void *arg){ \tprintf(\"write_cb\\n\"); \tif(signal_over 1){ \t\t//\t\tbufferevent_free(bev); \t\tsignal_over 0; \t} } void event_cb(struct bufferevent *bev, short events, void *arg){ \tif(events & BEV_EVENT_EOF){ \t\tprintf(\"connection closed\\n\"); \t}else if(events & BEV_EVENT_ERROR){ \t\tprintf(\"some other error\\n\"); \t} \tbufferevent_free(bev); } void listener_cb(struct evconnlistener *listener, evutil_socket_t fd, struct sockaddr *addr, int socklen, void *arg){ \tstruct event_base *base (struct event_base *)arg; \tstruct sockaddr_in *sin (struct sockaddr_in *)addr; \t//获取客户端ip和端口 \tchar ip[16]; \tinet_ntop(AF_INET, &sin >sin_addr.s_addr, ip, sizeof(ip)); \tprintf(\"accept a client %s:%d\\n\", ip, ntohs(sin >sin_port)); \t//创建bufferevent \tstruct bufferevent *bev bufferevent_socket_new(base, fd, \t\t\tBEV_OPT_CLOSE_ON_FREE); \tif(bev NULL){ \t\tprintf(\"bufferevent error\"); \t\treturn; \t} \t//设置读写回调 \tbufferevent_flush(bev, EV_READ EV_WRITE, BEV_NORMAL); \tbufferevent_setcb(bev, read_cb, write_cb, event_cb, arg); \tbufferevent_enable(bev, EV_READ EV_WRITE); } void signal_cb(evutil_socket_t sig, short events, void *user_data) { \tstruct event_base *base user_data; \tstruct timeval delay { 1, 0 }; \tprintf(\"Caught an interrupt signal; exiting cleanly in one seconds.\\n\"); \tevent_base_loopexit(base, &delay); } void strdecode(char *to, char *from) { \tfor ( ; *from ! '\\0'; ++to, ++from) \t{ \t\tif (from[0] '%' && isxdigit(from[1]) && isxdigit(from[2])) \t\t{ \t\t\t//依次判断from中 %20 三个字符 \t\t\t*to hexit(from[1])*16 + hexit(from[2]); \t\t\t// 移过已经处理的两个字符(%21指针指向1),表达式3的++from还会再向后移一个字符 \t\t\tfrom + 2; \t\t} \t\telse \t\t{ \t\t\t*to *from; \t\t} \t} \t*to '\\0'; } int main(int argc, char *argv[]){ \tint pid; \tif(argc < 3){ \t\tprintf(\"./serv port path\"); \t\treturn 0; \t} \tpid fork(); \tif(pid > 0){ \t\texit(1); \t} \t//切换工作目录 \tconst char *path argv[2]; \tint ret chdir(path); \tif(ret 1){ \t\tperror(\"chdir error\"); \t\treturn 1; \t} \tpid setsid(); \tumask(0022); \tclose(STDIN_FILENO); \tint fd; \tfd open(\"http.log\", O_RDWRO_CREAT); \tif(fd 1){ \t\tperror(\"open error\"); \t\texit(1); \t} \tdup2(fd, STDOUT_FILENO); \tdup2(fd, STDERR_FILENO); \tint port atoi(argv[1]); \t//创建服务器地址 \tstruct sockaddr_in serv; \t//初始化服务器地址 \tmemset(&serv, 0, sizeof(serv)); \tserv.sin_family AF_INET; \tserv.sin_port htons(port); \tserv.sin_addr.s_addr htonl(INADDR_ANY); \t//创建event_base \tstruct event_base *base event_base_new(); \tif(base NULL){ \t\tprintf(\"event base error\"); \t\treturn 1; \t} \t//创建监听器 \tstruct evconnlistener *listener evconnlistener_new_bind( \t\t\tbase, listener_cb, base, \t\t\tLEV_OPT_CLOSE_ON_FREE LEV_OPT_REUSEABLE, 1, \t\t\t(struct sockaddr *)&serv, sizeof(serv)); \tif(listener NULL){ \t\tprintf(\"listener error\"); \t\treturn 1; \t} \tstruct event *signal_event; \tsignal_event evsignal_new(base, SIGINT, signal_cb, (void *)base); \tif (!signal_event event_add(signal_event, NULL)<0) \t{ \t\tfprintf(stderr, \"Could not create/add a signal event!\\n\"); \t\treturn 1; \t} \tevent_base_dispatch(base); \tevconnlistener_free(listener); \tevent_base_free(base); \treturn 0; } ```"},"/note/Linux/Linux网络编程/2024-4-6-03高并发服务器.html":{"title":"高并发服务器","content":" layout: post title: \"高并发服务器\" date: 2024 3 10 15:39:08 +0800 tags: Linux 网络 # 高并发服务器 使用多进程并发服务器时要考虑以下几点： 1. 父进程最大文件描述个数(父进程中需要close关闭accept返回的新文件描述符) 2. 系统内创建进程个数(与内存大小相关) 3. 进程创建过多是否降低整体服务性能(进程调度) 4. 每一个子进程的效率 在使用线程模型开发服务器时需考虑以下问题： 1. 调整进程内最大文件描述符上限 2. 线程如有共享数据，考虑线程同步 3. 服务于客户端线程退出时，退出处理。（退出值，分离态） 4. 系统负载，随着链接客户端增加，导致其它线程不能及时得到CPU ## 多路I/O转接服务器 多路IO转接服务器也叫做多任务IO服务器。该类服务器实现的主旨思想是，不再由应用程序自己监视客户端连接，取而代之由内核替应用程序监视文件。 主要使用的方法有三种 ### select 可以使用只一个命令监听一个新的连接(需要把监管使用的lfd给select函数处理), 之后进程可以使用accept获取cfd, select可以使用获取的cfd监听连接的客户端是否发过来数据 1. select能监听的文件描述符个数受限于FD_SETSIZE，一般为1024，单纯改变进程打开的文件描述符个数并不能改变select监听文件个数 2. 解决1024以下客户端时使用select是很合适的，但如果链接客户端过多，select采用的是轮询模型，会大大降低服务器响应效率，不应在select上投入更多精力。 ```c #include <sys/select.h> /* According to earlier standards */ #include <sys/time.h> #include <sys/types.h> #include <unistd.h> int select(int nfds, fd_set *readfds, fd_set *writefds, \t\t\tfd_set *exceptfds, struct timeval *timeout); ``` > nfds: \t\t监控的文件描述符集里最大文件描述符加1，因为此参数会告诉内核检测前多少个文件描述符的状态 > > > 这一个是他的循环的上限 > > readfds：\t监控有读数据到达文件描述符集合，传入传出参数 > > writefds：\t监控写数据到达文件描述符集合，传入传出参数 > > exceptfds：监控异常发生达文件描述符集合,如带外数据到达异常，传入传出参数 > > > 文件描述符指针结合, 传入传出参数, 把需要监听的文件描述符放到这几个数组里面 > > > > 这几个的实现实际是一个和文件描述符表对应的位图 > > > > 传入的时候是要交监听的, 传出来的是实际的有事件发生的, 不关心的事件可以发送一个NULL > > timeout：\t定时阻塞监控时间，3种情况 > \t\t\t1.NULL，永远等下去 > \t\t\t2.设置timeval，等待固定时间 > \t\t\t3.设置timeval里时间均为0，检查描述字后立即返回，轮询 > > ```c > struct timeval { > \tlong tv_sec; /* seconds */ > \tlong tv_usec; /* microseconds */ > }; > ``` > > 返回值: 三个集合里面的事件发生的总个数 > void FD_CLR(int fd, fd_set *set); \t//把文件描述符集合里fd位清0 > int FD_ISSET(int fd, fd_set *set); \t//测试文件描述符集合里fd是否置1 > void FD_SET(int fd, fd_set *set); \t//把文件描述符集合里fd位置1 > void FD_ZERO(fd_set *set); \t\t\t//把文件描述符集合里所有位清0 #### 使用思路 1. lfd socket获取描述符, 用于处理连接 2. bind 把这一个文件描述符和对应的端口连接 3. listen设置监听的个数 4. fd_set rset;设置一个位图 5. FD_ZERO 6. FD_SET 7. int ret select(lfd + 1, &rset, NULL, NULL, NULL); 8. 检测实际的事件 ```c if(ret > 0){ //检测一下哪一个文件描述符被设置了 if(FD_ISSET(lfd, &rset)){ cfd accept(); FD_SET(cfd, &rset); } //遍历其余的 } ``` #### 实际实现 ```c #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> #include <sys/socket.h> #include <arpa/inet.h> #include <ctype.h> #include <sys/select.h> int main(void){ \tint i, j, nready, ret; \tint maxfd 0; \tint listenfd, connfd; \tchar buf[BUFSIZ]; \tstruct sockaddr_in clie_addr, serv_addr; \tsocklen_t clie_addr_len; \tlistenfd socket(AF_INET, SOCK_STREAM, 0); \tif(listenfd 1){ \t\tperror(\"socket error\"); \t\texit(1); \t} \tint opt 1; \t//设置端口复用 \tret setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)); \tif(ret 1){ \t\tperror(\"setsockopt error\"); \t\texit(1); \t} \t//设置监听端口 \tserv_addr.sin_family AF_INET; \tserv_addr.sin_port htons(6666); \tserv_addr.sin_addr.s_addr htonl(INADDR_ANY); \tret bind(listenfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)); \tif(ret 1){ \t\tperror(\"bind error\"); \t\texit(1); \t} \tret listen(listenfd, 128); \tif(ret 1){ \t\tperror(\"listen error\"); \t\texit(1); \t} \t//两个文件描述符集合， 用于监听多个文件描述符 \tfd_set rset, allset; \tmaxfd listenfd; \tFD_ZERO(&allset); \tFD_SET(listenfd, &allset); \twhile(1){ \t\trset allset; \t\t//监听多个文件描述符 \t\tnready select(maxfd+1, &rset, NULL, NULL, NULL); \t\tif(nready < 0){ \t\t\tperror(\"select error\"); \t\t\texit(1); \t\t} //检测一下有没有连接事件 \t\tif(FD_ISSET(listenfd, &rset)){ \t\t\tclie_addr_len sizeof(clie_addr); \t\t\tconnfd accept(listenfd, (struct sockaddr *)&clie_addr, &clie_addr_len); \t\t\tif(connfd 1){ \t\t\t\tperror(\"accept error\"); \t\t\t\texit(1); \t\t\t} \t\t\tFD_SET(connfd, &allset); //记录一下现在的最大值 \t\t\tif(connfd > maxfd){ \t\t\t\tmaxfd connfd; \t\t\t} \t\t\tif( nready 0){ \t\t\t\tcontinue;//只有一个连接, 不需要进一步处理 \t\t\t} \t\t} //遍历其余的读取事件 \t\tfor(i listenfd + 1; i < maxfd; i++){ \t\t\tif(FD_ISSET(i, &rset)){ //获取数据, 这一个实例里面是每一次写入以后会读取服务器的返回值 \t\t\t\tret read(i, buf, sizeof(buf)); \t\t\t\tif(ret 0){ \t\t\t\t\tprintf(\"client close\\n\"); \t\t\t\t\tclose(i); FD_CLR(i, &allset); int nowmax; //处理一下最大值 for(j listenfd + 1; j < maxfd; j++){ if(FD_ISSET(j, &allset)) nowmax j; } maxfd nowmax; \t\t\t\t}else if(ret 1){ \t\t\t\t\tperror(\"read error\"); \t\t\t\t\texit(1); \t\t\t\t}else{ //处理一次写入 \t\t\t\t\tfor(j 0; j < ret; j++){ \t\t\t\t\t\tbuf[j] toupper(buf[j]); \t\t\t\t\t} \t\t\t\t\twrite(i, buf, ret); \t\t\t\t} \t\t\t\tif( nready 0){ \t\t\t\t\tbreak; \t\t\t\t} \t\t\t} \t\t} \t} } ``` #### 优缺点 + 缺点 1. 文件描述符里面不连续的时候上面的效率比较低, 可以使用一个单数的数组记录使用文件描述符 2. 监听的个数有上限, 最大1024 3. 检测满足条件的fd, 自己添加逻辑提高比较小, 编码难度比较大 + 优点 可以跨平台, windows, linux, macOS, Unix, mips都支持这一个 ### poll > 这一个函数的是Linux才有的, 使用的时候不如epoll, 了解即可 ```c #include <poll.h> int poll(struct pollfd *fds, nfds_t nfds, int timeout); ``` > ````c > struct pollfd { > int fd; /* 文件描述符 */ > short events; /* 监控的事件 读写异常*/ > short revents; /* 监控事件中满足条件返回的事件(返回值) */ > }; > ```` > > > 监听的文件描述符的数组, 实际是把select函数的参数分开了 > > > > + 监听事件(主要使用的是是POLLIN(读), POLLOUT(写), POLLERR(错误)) > > > > **POLLIN** 普通或带外优先数据可读,即POLLRDNORM POLLRDBAND > > > > POLLRDNORM 数据可读 > > > > POLLRDBAND 优先级带数据可读 > > > > POLLPRI 高优先级可读数据 > > > > **POLLOUT** 普通或带外数据可写 > > > > POLLWRNORM 数据可写 > > > > POLLWRBAND 优先级带数据可写 > > > > **POLLERR** 发生错误 > > > > POLLHUP 发生挂起 > > > > POLLNVAL 描述字不是一个打开的文件 > > > > 如果传入的是0的话, 只会监听POLLERR, POLLHUP, POLLNVAL > > nfds 监控数组中有多少文件描述符需要被监控 > > timeout 毫秒级等待 > > ​ 1：阻塞等，#define INFTIM 1 Linux中没有定义此宏 > > ​ 0：立即返回，不阻塞进程 > > ​ \\>0：等待指定毫秒数，如当前系统时间精度不够毫秒，向上取值 如果不再监控某个文件描述符时，可以把pollfd中，fd设置为 1，poll不再监控此pollfd，下次返回时，把revents设置为0 > he field fd contains a file descriptor for an open file. If this field is negative, then the corresponding events field is ignored and the revents field returns zero. (This provides an easy way of ignoring a file descriptor for a single poll() call: simply negate the fd field. 相较于select而言，poll的优势： 1. 传入、传出事件分离。无需每次调用时，重新设定监听事件。 2. 文件描述符上限，可突破1024限制。能监控的最大上限数可使用配置文件调整。 #### 示例 ```c #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> #include <sys/socket.h> #include <arpa/inet.h> #include <ctype.h> #include <poll.h> int main(void){ \tint i, j, nready, ret; \tint maxfd 0; \tint listenfd, connfd; \tstruct pollfd client[1024];//poll使用的文件描述符数组 \tchar buf[BUFSIZ], str[INET_ADDRSTRLEN]; \tstruct sockaddr_in clie_addr, serv_addr; \tsocklen_t clie_addr_len; \t//获取文件描述符 \tlistenfd socket(AF_INET, SOCK_STREAM, 0); \tif(listenfd 1){ \t\tperror(\"socket error\"); \t\texit(1); \t} \tint opt 1; \t//设置端口复用 \tret setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)); \tif(ret 1){ \t\tperror(\"setsockopt error\"); \t\texit(1); \t} \t//设置监听端口 \tserv_addr.sin_family AF_INET; \tserv_addr.sin_port htons(6666); \tserv_addr.sin_addr.s_addr htonl(INADDR_ANY); \tret bind(listenfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)); \tif(ret 1){ \t\tperror(\"bind error\"); \t\texit(1); \t} \tret listen(listenfd, 128); \tif(ret 1){ \t\tperror(\"listen error\"); \t\texit(1); \t} \t//设置poll使用的结构体 \tclient[0].fd listenfd; \tclient[0].events POLLIN; \tfor(i 1; i < 1024 ;i++){ \t\tclient[i].fd 1; \t} \tmaxfd 0; \twhile(1){ \t\tnready poll(client, maxfd+1, 1); \t\tif(nready < 0){ \t\t\tperror(\"select error\"); \t\t\texit(1); \t\t} \t\tif(client[0].revents & POLLIN){ \t\t\tclie_addr_len sizeof(clie_addr); \t\t\tconnfd accept(listenfd, (struct sockaddr *)&clie_addr, &clie_addr_len); \t\t\tprintf(\"connect\\n\"); \t\t\tif(connfd 1){ \t\t\t\tperror(\"accept error\"); \t\t\t\texit(1); \t\t\t} \t\t\tfor(i 1;i < 1024; i++){ \t\t\t\tif(client[i].fd < 0){ \t\t\t\t\tclient[i].fd connfd; \t\t\t\t\tclient[i].events POLLIN; \t\t\t\t\tbreak; \t\t\t\t} \t\t\t} \t\t\tif(i 1024){ \t\t\t\tperror(\"too many client\"); \t\t\t} \t\t\tif(i>maxfd){ \t\t\t\tmaxfd i; \t\t\t} \t\t\tif( nready 0){ \t\t\t\tcontinue; \t\t\t} \t\t} \t\t//处理其他的文件描述符 \t\tfor(i 1; i < maxfd; i++){ \t\t\tif(client[i].fd < 0){ \t\t\t\tcontinue; \t\t\t} \t\t\tif(client[i].revents & POLLIN){ \t\t\t\tret read(client[i].fd, buf, sizeof(buf)); \t\t\t\tif(ret 0){ \t\t\t\t\tprintf(\"client close\\n\"); \t\t\t\t\tclose(client[i].fd); \t\t\t\t\tint nowmax 0; \t\t\t\t\tfor(j listenfd + 1; j < maxfd; j++){ \t\t\t\t\t\tif(client[j].fd > 0) \t\t\t\t\t\t\tnowmax i; \t\t\t\t\t} \t\t\t\t\tmaxfd nowmax; \t\t\t\t\tclient[i].fd 1; \t\t\t\t}else if(ret 1){ \t\t\t\t\tperror(\"read error\"); \t\t\t\t\texit(1); \t\t\t\t}else{ \t\t\t\t\tfor(j 0; j < ret; j++){ \t\t\t\t\t\tbuf[j] toupper(buf[j]); \t\t\t\t\t} \t\t\t\t\twrite(client[i].fd, buf, ret); \t\t\t\t} \t\t\t\tif( nready 0){ \t\t\t\t\tbreak; \t\t\t\t} \t\t\t} \t\t} \t} } ``` #### 优缺点 + 优点 自带数据结构, 把监听事件和返回事件分离 可以拓展监听上限, 超出1024 + 缺点 不可以跨平台 无法直接定位满足监听事件的描述符 ### epoll epoll是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率，因为它会复用文件描述符集合来传递结果而不用迫使开发者每次等待事件之前都必须重新准备要被侦听的文件描述符集合，另一点原因就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行 epoll除了提供select/poll那种IO事件的电平触发（Level Triggered）外，还提供了边沿触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。 #### epoll_create打开 ![image 20240408163813369](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404081638402.png) ```c #include <sys/epoll.h> int epoll_create(int size); ``` > 这是一个平衡二叉树里面的红黑树, > > In the initial epoll_create() implementation, the size argument informed the kernel of the number of file descriptors that the caller expected to add to the epoll instance. The kernel used this information as a hint for the amount of space to initially allocate in internal data structures describing events. (If necessary, the kernel would allocate more space if the caller's usage exceeded the hint given in size.) Nowadays, this hint is no longer required (the kernel dynamically sizes the required data structures without needing the hint), but size must still be greater than zero, in order to ensure backward compatibility when new epoll applications are run on older kernels. > > 这一个参数使用一个大于0的数字就可以了, 现在的内核会自动分配 > > 返回值是一个用于监听的文件描述符 , 这一个是红黑树的根节点 #### epoll_ctl控制 ```c #include <sys/epoll.h> int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); ``` > epfd : 之前获取的描述符 > > op： 表示动作，用3个宏来表示： > > ​ EPOLL_CTL_ADD (注册新的fd到epfd)， > > ​ EPOLL_CTL_MOD (修改已经注册的fd的监听事件)， > > ​ EPOLL_CTL_DEL (从epfd删除一个fd, 取消监听)； > > > 这一个事件监听会在这一个文件关闭的时候退出 > > fd : 要监听的fd > > event： 告诉内核需要监听的事件 > > ```c > typedef union epoll_data { > void *ptr; > int fd;\t//对应监听事件的fd > uint32_t u32;\t//这一个不使用 > uint64_t u64;\t//不使用 > } epoll_data_t; > > struct epoll_event { > uint32_t events; /* Epoll events 主要还是EPOLLIN, EPOLLOUT, EPOLLERR*/ > epoll_data_t data; /* User data variable */ > }; > ``` > > 返回值：成功：0；失败： 1，设置相应的errno #### epoll_wait监听 ```c #include <sys/epoll.h> int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); ``` > epfd : 之前获取的文件描述符 > > events： 用来存内核得到事件的集合，可简单看作数组。这是一个传出数组 > > maxevents： 告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size， > > timeout： 是超时时间 > > ​ 1： 阻塞 > > ​ 0： 立即返回，非阻塞 > > ​ \\>0： 指定毫秒 > > 返回值： 成功返回有多少文件描述符就绪，时间到时返回0，出错返回 1 #### 实际使用 1. epoll_creat创建epoll使用的文件描述符 2. 把获取的监听的文件描述符使用epoll_ctl进行监听 3. 调用epoll_wait阻塞等待 4. 返回以后判断是不是监听的文件描述符, 是的话把这一个描述符加入监听 5. 不是的话处理一下连接客户端发送的数据 ```c #include <sys/epoll.h> #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> #include <sys/socket.h> #include <arpa/inet.h> #include <ctype.h> int main(void){ \tint i, j, nready, ret; \tint listenfd, connfd, efd; \tstruct epoll_event temp, ep[1024]; \tchar buf[BUFSIZ], str[INET_ADDRSTRLEN]; \tstruct sockaddr_in clie_addr, serv_addr; \tsocklen_t clie_addr_len; \t//获取文件描述符 \tlistenfd socket(AF_INET, SOCK_STREAM, 0); \tif(listenfd 1){ \t\tperror(\"socket error\"); \t\texit(1); \t} \tint opt 1; \t//设置端口复用 \tret setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)); \tif(ret 1){ \t\tperror(\"setsockopt error\"); \t\texit(1); \t} \t//设置监听端口 \tserv_addr.sin_family AF_INET; \tserv_addr.sin_port htons(6666); \tserv_addr.sin_addr.s_addr htonl(INADDR_ANY); \tret bind(listenfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)); \tif(ret 1){ \t\tperror(\"bind error\"); \t\texit(1); \t} \tret listen(listenfd, 128); \tif(ret 1){ \t\tperror(\"listen error\"); \t\texit(1); \t} \t//获取一个树根 \tefd epoll_create(1024); \tif(efd < 0){ \t\tperror(\"epoll creat error\"); \t\texit(0); \t} \t//把监听使用的节点添加 \ttemp.events EPOLLIN; \ttemp.data.fd listenfd; \tret epoll_ctl(efd, EPOLL_CTL_ADD, listenfd, &temp); \tif(ret 1){ \t\tperror(\"epoll ctl error\"); \t\texit(1); \t} \twhile(1){ //开始等待 \t\tnready epoll_wait(efd, ep, 1024, 1); \t\tif(nready < 0){ \t\t\tperror(\"select error\"); \t\t\texit(1); \t\t} //处理 \t\tfor(i 0 ; i < nready ; i++){ \t\t\tif(!ep[i].events & EPOLLIN) \t\t\t\tcontinue; \t\t\tif(ep[i].data.fd listenfd){ \t\t\t\t//这是一个连接事件 clie_addr_len sizeof(clie_addr); \t\t\t\tconnfd accept(listenfd, (struct sockaddr *)&clie_addr, \t\t\t\t\t\t&clie_addr_len); \t\t\t\t//打印一下连接端口的信息 \t\t\t\tprintf(\"connect %s :%d\\n\", \t\t\t\t\t\tinet_ntop(AF_INET, &clie_addr.sin_addr, \t\t\t\t\t\t\tstr, sizeof(str)), \t\t\t\t\t\tntohs(clie_addr.sin_port)); \t\t\t\tif(connfd 1){ \t\t\t\t\tperror(\"accept error\"); \t\t\t\t\t\texit(1); \t\t\t\t} \t\t\t\ttemp.events EPOLLIN; \t\t\t\ttemp.data.fd connfd; \t\t\t\tret epoll_ctl(efd, EPOLL_CTL_ADD, connfd, &temp); \t\t\t\tif(ret < 0){ \t\t\t\t\tperror(\"epoll ctl con error\"); \t\t\t\t\texit(1); \t\t\t\t} \t\t\t}else{ \t\t\t\t//处理其他的文件 \t\t\t\tif(ep[i].events & EPOLLIN){ \t\t\t\t\tret read(ep[i].data.fd, buf, sizeof(buf)); \t\t\t\t\tif(ret 0){ \t\t\t\t\t\t//连接结束 \t\t\t\t\t\tprintf(\"client close\\n\"); \t\t\t\t\t\tclose(ep[i].data.fd); \t\t\t\t\t\tepoll_ctl(efd, EPOLL_CTL_DEL, ep[i].data.fd, NULL); \t\t\t\t\t}else if(ret 1){ //read错误, 最好判断一下errno \t\t\t\t\t\tperror(\"read error\"); \t\t\t\t\t\tepoll_ctl(efd, EPOLL_CTL_DEL, ep[i].data.fd, NULL); \t\t\t\t\t\tclose(ep[i].data.fd); \t\t\t\t\t}else{ \t\t\t\t\t\tfor(j 0; j < ret; j++){ \t\t\t\t\t\t\tbuf[j] toupper(buf[j]); \t\t\t\t\t\t} \t\t\t\t\t\twrite(ep[i].data.fd, buf, ret); \t\t\t\t\t} \t\t\t\t} \t\t\t} \t\t} \t} } ``` ### poll和epoll突破1024的限制 可以使用cat命令查看一个进程可以打开的socket描述符上限。 cat /proc/sys/fs/file max > ![image 20240408162256242](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404081622389.png) > > 这一个计算机可以打开的最多的文件的个数 > > 之前使用的`ulimit a`查看的是这一个用户下面的进程可以打开的文件的个数 > > ![image 20240408162517790](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404081625837.png) 如有需要，可以通过修改配置文件的方式修改该上限值。 ` sudo vi /etc/security/limits.conf` 在文件尾部写入以下配置,soft软限制，hard硬限制。如下图所示。 \\* soft nofile 65536 \\* hard nofile 100000 > ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404081627791.jpg) > > ![image 20240408162924777](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404081629825.png) > soft nofile ：可打开的文件描述符的最大数(超过会警告); > hard nofile ：可打开的文件描述符的最大数(超过会报错); > > 也可以使用命令`ulimit n 数值`进行改变[改变以后需要注销用户让他生效] > > > [Linux中soft nproc 、soft nofile和hard nproc以及hard nofile配置 CSDN博客](https://blog.csdn.net/zxljsbk/article/details/89153690) ### 事件模型 EPOLL事件有两种模型： Edge Triggered (ET) 边缘触发只有数据到来才触发，不管缓存区中是否还有数据。 Level Triggered (LT) 水平触发只要有数据都会触发(缓冲区里面的数据没有读取完就会触发)。 > 默认使用的时候水平触发 思考如下步骤： 1. 假定我们已经把一个用来从管道中读取数据的文件描述符(rfd)添加到epoll描述符。 2. 管道的另一端写入了2KB的数据 3. 调用epoll_wait，并且它会返回rfd，说明它已经准备好读取操作 4. 读取1KB的数据 5. 调用epoll_wait…… 在这个过程中，有两种工作模式： #### ET模式 ET模式即Edge Triggered工作模式。 如果我们在第1步将rfd添加到epoll描述符的时候使用了EPOLLET标志，那么在第5步调用epoll_wait之后将有可能会挂起，因为剩余的数据还存在于文件的输入缓冲区内，而且数据发出端还在等待一个针对已经发出数据的反馈信息。只有在监视的文件句柄上发生了某个事件的时候 ET 工作模式才会汇报事件。因此在第5步的时候，调用者可能会放弃等待仍在存在于文件输入缓冲区内的剩余数据。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。最好以下面的方式调用ET模式的epoll接口，在后面会介绍避免可能的缺陷。 1) 基于非阻塞文件句柄 2) 只有当read或者write返回EAGAIN(非阻塞读，暂时无数据)时才需要挂起、等待。但这并不是说每次read时都需要循环读，直到读到产生一个EAGAIN才认为此次事件处理完成，当read返回的读到的数据长度小于请求的数据长度时，就可以确定此时缓冲中已没有数据了，也就可以认为此事读事件已处理完成。 > `event.events EPOLLIN EPOLLET;//监听的时候使用ET模式` ```c #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> #include <sys/epoll.h> #include <unistd.h> int main(void){ \tint efd, i; \tint pfd[2];//管道使用的文件描述符 \tpid_t pid; \tchar buf[10]; \tchar ch 'a'; \tpipe(pfd);//创建一个管道 \tpid fork(); \tif(pid 0){ \t\t//子进程 \t\t//子进程关闭读端 \t\tclose(pfd[0]); \t\twhile(1){ \t\t\t//子进程写数据到管道 \t\t\tfor(i 0 ;i < 5 ;i++) \t\t\t\tbuf[i] ch; \t\t\tbuf[i 1] '\\n'; \t\t\tch++; \t\t\tfor(;i<10;i++) \t\t\t\tbuf[i] ch; \t\t\tbuf[i 1] '\\n'; \t\t\tif(ch > 'z') \t\t\t\tch 'a'; \t\t\twrite(pfd[1], buf, sizeof(buf)); \t\t\tsleep(5); \t\t} \t\tclose(pfd[1]); \t}else if(pid > 0){ \t\t//父进程 \t\t//父进程关闭写端 \t\tclose(pfd[1]); \t\tstruct epoll_event event; \t\tstruct epoll_event revents[10]; \t\tint ret, len; \t\tefd epoll_create(1); \t\tevent.events EPOLLIN EPOLLET;//监听的时候使用ET模式 \t\tevent.data.fd pfd[0]; \t\tepoll_ctl(efd, EPOLL_CTL_ADD, pfd[0], &event); \t\t \t\twhile(1){ \t\t\tret epoll_wait(efd, revents, 10, 1); \t\t\tif(ret > 0){ \t\t\t\tfor(i 0; i < ret; i++){ \t\t\t\t\tif(revents[i].data.fd pfd[0]){ \t\t\t\t\t\tlen read(pfd[0], buf, sizeof(buf)/2);//这一个读取的时候只会读取一半 \t\t\t\t\t\twrite(STDOUT_FILENO, buf, len); \t\t\t\t\t} \t\t\t\t} \t\t\t} \t\t} \t\tclose(pfd[0]); \t\tclose(efd); \t}else{ \t\tperror(\"fork\"); \t\texit(1); \t} \treturn 0; } ``` > 使用这一个模式的时候, 虽然还有数据, 但是还是会阻塞, 每5秒打印一行数据 #### LT模式 LT模式即Level Triggered工作模式。 与ET模式不同的是，以LT方式调用epoll接口的时候，它就相当于一个速度比较快的poll，无论后面的数据是否被使用。 #### 比较 LT(level triggered)：LT是**缺省**的工作方式，并且同时支持block和no block socket。在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。**传统的select/poll都是这种模型的代表。** > 如果读取数据的时候不需要读取所有的数据, 其余的数据可以丢弃的时候, 使用这一个模式会导致问题 ET(edge triggered)：ET是高速工作方式，只支持no block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知。请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once). > 如果在epoll的ET模式下使用阻塞方式进行操作，可能会导致以下问题： > > 1. 事件堆积：阻塞方式读取数据时，如果应用程序没有处理完当前的事件，而新的事件已经到达，这些事件会被内核忽略，从而导致事件堆积。这样会造成较差的性能，因为应用程序无法及时处理新到达的事件。 > 2. 资源浪费：阻塞模式下，当没有数据可读时，应用程序会一直阻塞在读取操作上，浪费了CPU资源。在应用程序一直阻塞等待数据可读的过程中，无法进行其他任务的处理，造成资源的浪费。 > 3. 接收数据不及时：由于阻塞模式下需要等待数据到达才能读取，会导致延迟增加。对于实时性要求较高的应用程序，阻塞模式可能无法满足要求。 > 这一个模式一般用于对速率要求比较高的地方, 这个时候最好不要阻塞, 读取的时候需要把所有的数据读取完, 否则下一次的连接会延迟 > > LT（Level Triggered）和ET（Edge Triggered）是两种不同的触发方式，它们支持的模式不同的原因主要有以下几点： > > 1. 触发时机：LT模式在文件描述符还有未处理的数据时会持续触发，即文件描述符可读或可写时都会触发。而ET模式只在文件描述符状态发生变化时触发一次，即文件描述符从未就绪到就绪时触发。 > 2. 处理效率：ET模式相较于LT模式可以提高处理效率。因为ET模式只在状态发生变化时才触发，应用程序需要立即对变化的事件进行处理，避免错过任何已就绪的事件。而LT模式在每次循环中都会检查已就绪的文件描述符，即使应用程序在某一次循环中没有对文件描述符进行操作。 > 3. 应用场景：LT模式适用于对实时性要求不高的场景，例如网络编程中的服务器监听请求。而ET模式适用于对实时性要求较高的场景，例如实时数据处理或高并发服务器。 > [(1 封私信) 如何理解Epoll中的LT和ET模式，底层实现又是怎么样的？ 知乎 (zhihu.com)](https://www.zhihu.com/question/403893498#:~:text 而 et,模式呢，数据从内核拷贝到用户空间后，内核不会重新将就绪事件节点添加回就绪队列，当事件在用户空间处理完后，用户空间根据需要重新将这个事件通过 epoll_ctl 添加回就绪队列（又或者这个节点因为有新的数据到来，重新触发了就绪事件而被添加）。) > > [(1 封私信) epoll中ET/LT触发模式分别适用的场景是什么？ 知乎 (zhihu.com)](https://www.zhihu.com/question/268969909) ### 反应堆模型 实际是使用epoll的ET模式加非阻塞加返回联合体里面的void *ptr 可以使用这一个结构体里面加一个fd和一个回调函数 使用这一个模型的时候处理的方式会发生改变 + 普通模型 socket, bind, listen epoll_creat 创建一个红黑树 返回 epfd epoll_ctl 在树上加一个监听节点 while(1) epoll_wait 监听 监听事件发生 返回数组 判断返回元素 lfd accept / cfd read() 大小写转换 write + 反应堆模型 socket, bind, listen epoll_creat 创建一个红黑树 返回 epfd epoll_ctl 在树上加一个监听节点 while(1) epoll_wait 监听 监听事件发生 返回数组 判断返回元素 lfd accept / cfd 调用读回调函数 epoll_ctl把这一个节点取下来 改为监听写事件 epoll_ctl把这一个节点加回去 epoll_wait等待可写 写回调函数 把这一个节点取下来 改为读事件 加回去 > 这一个加了一下判断是不是可以写, 是的话再发送数据 > > 实际的操作改为使用回调函数 ```c struct myevent_s { \tint fd;\t\t\t\t//记录文件描述符 int events;\t\t\t//记录当前监听的事件 void *arg;\t\t\t//一个数据 void (*call_back)(int fd, int events, void *arg);\t\t//回调函数 int status;\t\t\t\t\t\t//记录在不在红黑树里面 char buf[BUFLEN]; int len;\t\t\t\t\t\t long last_active;\t\t\t\t//记录最后一次的连接时间, 长时间连接不断开踢出去 }; ``` > [高并发服务器epoll接口、epoll Reactor(反应堆)模型详解 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/161073519) > > [[epoll原理详解及epoll反应堆模型 CSDN博客](https://blog.csdn.net/daaikuaichuan/article/details/83862311)](https://zhuanlan.zhihu.com/p/161073519) ### 优缺点 + 优点 高效, 使用简单, 不受文件描述符的个数的限制 + 缺点 不能跨平台, Linux专有"},"/note/Linux/Linux网络编程/2024-4-17-09HTTP协议.html":{"title":"HTTP协议","content":" layout: post title: \"HTTP协议\" date: 2024 4 14 15:39:08 +0800 tags: Linux 网络 # HTTP协议 HTTP，超文本传输协议（ HyperText Transfer Protocol ）。[互联网](https://baike.baidu.com/item/互联网)应用最为广泛的一种[网络应用层协议](https://baike.baidu.com/item/网络协议)。它可以减少网络传输，使浏览器更加高效。 这一个是一个无状态的(不会记录用户的信息), 以请求头, 应答方式运行的协议, 可以使用拓展的语义和自描述的信息格式 ​ 通常HTTP消息包括客户机向服务器的请求消息和服务器向客户机的响应消息。 ## 消息格式 浏览器 —> 发给 —> 服务器。主旨内容包含4部分： + 请求行: 说明请求类型, 要访问的资源, 以及使用的http版本 > + 请求头 > > 1. 请求方法 比如GET/POST/HEAD/PUT 标记对用的资源操作 > 2. 请求的目标, 通常是一个URI, 记录要操作的资源 > 3. 版本号, 使用的协议版本 > > + 响应头 > > 1. 版本号 > 2. 状态码, 三位数字, 200成功, 500 服务错误 > 3. 原因, 数字的描述 + 请求头: 说明服务器要使用的附加信息 > 按照一个key value的形式存在, 使用\":\"进行分割, 使用一个CGLF(\"\\r\\n\")进行分割 > > + 常用数据的类型 > > \"Content type\": 数据的类型(\"application/json\") > > 这一个不只是可以使用以及有的, 还可以自定义拓展 > > **注意:** 名字不区分大小写, 不可以有空格, 可以使用\" \"但是不可以使用\"_\", 名字之后立即是\":\"不可以有空格, 名字前面可以有, 顺序可以是随机的, 原则上是不可以重复的, 但是有的字段是可以重复的(\"Set Cookie\") > > + 常用的字段 > > Host: 标识连接是和哪一个服务建立的 > > Referer: 限制来源 > > Server: 标识服务器的类型 > > Date: 时间 > > Content type: 数据的类型 > > Connection: 连接的方式 + 空行: 必须！, 即使没有请求数据 + 请求数据: 也叫主体, 可以添加任意的其他数据 ## 实际流程 ### 查找ip 会从浏览器的缓存文件里面查找有没有这一个网站的IP地址 `chrome://net export/`这一个网址可以查看chrome浏览器 ![image 20240608130751061](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406081308917.png) 这一个文件里面没有的时候会从本机里面的host文件里面查找, 还没有的话就会使用DNS服务器进行查找 ### 网络请求 进行TCP三次握手, 连接以后就可以进行发送HTTP请求了, 之后返回信息由本地进行解析 连接结束以后四次挥手 ## 实际信息 ### 请求消息(Request) 以下是浏览器发送给服务器的http**协议头**内容举例, 注意：9行的空行(\\r\\n)也是协议头的一部分： 1. GET /hello.c HTTP/1.1 2. Host: localhost:2222 3. User Agent: Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:24.0) Gecko/201001 01 Firefox/24.0 4. Accept: text/html,application/xhtml+xml,application/xml;q 0.9,*/*;q 0. 5. Accept Language: zh cn,zh;q 0.8,en us;q 0.5,en;q 0.3 6. Accept Encoding: gzip, deflate 7. Connection: keep alive 8. If Modified Since: Fri, 18 Jul 2014 08:36:36 GMT 9. ​ //这是一个空行, 用于和数据之间分割 > 默认使用的是TCP连接 ### 响应消息(Response) 服务器 —> 发给 —> 浏览器。主旨内容包含4部分： + 状态行: 包括http协议版本号, 状态码, 状态信息 + 消息报头: 说明客户端要使用的一些附加信息 + 空行: 必须! + 响应正文: 服务器返回给客户端的文本信息 以下是经服务器按照http协议，写回给浏览器的内容举例，1~9行是**协议头**部分。注意：9行\\r\\n的空行不可忽略 1. HTTP/1.1 200 Ok 2. Server: xhttpd 3. Date: Fri, 18 Jul 2014 14:34:26 GMT 4. Content Type: text/plain; charset iso 8859 1 (字符文件, 以及使用的编码, 必选项) 5. Content Length: 32 （ 要么不写 或者 传 1， 要写务必精确 ！(实际测试的时候在服务器 1会出问题) ） 6. Content Language: zh CN 7. Last Modified: Fri, 18 Jul 2014 08:36:36 GMT 8. Connection: close 9. 10. #include <stdio.h> (从这里开始是实际返回的额信息) 11. 12. int main(void) 13. { 14. printf(“ Welcome to itcast ... \\n\"); 15. return 0; 16. } ### HTTP请求方法 + **GET** 请求指定的页面信息，并返回实体主体。参数的传递是受限制的, 传递的参数直接显示在地址栏 + **POST** 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。可以用于传输大量数据 + **HEAD** 类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头 + **PUT** 从客户端向服务器传送的数据取代指定的文档的内容。和POST类似, 但是这一个会指定数据存放的地址 + **DELETE** 请求服务器删除指定的页面。 + **CONNECT** HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 + **OPTIONS** 允许客户端查看服务器的性能。 + **TRACE** 回显服务器收到的请求，主要用于测试或诊断。 ### HTTP常用状态码 状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别: o 1xx：指示信息 表示请求已接收，继续处理 o 2xx：成功 表示请求已被成功接收、理解、接受 o 3xx：重定向 要完成请求必须进行更进一步的操作 o 4xx：客户端错误 请求有语法错误或请求无法实现 o 5xx：服务器端错误 服务器未能实现合法的请求 l **常见状态码：** 200 OK 客户端请求成功 400 Bad Request 客户端请求有语法错误，不能被服务器所理解 401 Unauthorized 请求未经授权， 403 Forbidden 服务器收到请求，但是拒绝提供服务 404 Not Found 请求资源不存在，eg：输入了错误的URL 500 Internal Server Error 服务器发生不可预期的错误 503 Server Unavailable 服务器当前不能处理客户端的请求。 ### 常见网络文件类型： 普通文件: text/plain; charset iso 8859 1 *.html : text/html; charset iso 8859 1 *.jpg : image/jpeg *.gif : image/gif *.png: image/png *.wav: audio/wav *.avi : video/x msvideo *.mov : video/quicktime *.mp3 : audio/mpeg charset iso 8859 1 西欧的编码，说明网站采用英文编码 charset gb2312 说明网站采用的编码是简体中文 charset utf 8 代表世界通用的语言编码；可以用到中文、韩文、日文等世界上所有语言编码 charset euc kr 说明网站采用的编码是韩文； charset big5 说明网站采用的编码是繁体中文； ## HTTPS 在传输之前需要对数据进行一次加密, 在HTTP层和TCP层之间加了一个安全传输层SSL/TSL层, 一般使用端口443 ### 摘要算法 > md5, sha1, sha2, sha1 256 可以把任意长度的数据压缩成为一个固定长度, 并且独一无二的数据, 之后把明文和摘要数据进行一起传输, 数据到对方以后再进行解密以及对比摘要数据 ### 对称加密 编解码的时候使用相同的密钥 > 可以使用xor进行 ### 非对称加密 有两个密钥, 一个是公钥另一个是私钥, 这两个是不同的, 使用公钥进行加密, 使用私钥进行解密 公钥是可以随意分发的, 私钥是不可以在网络进行传输的, 这一种算法的效率比较低 > DH, DSA, RSA, ECC TLS里面综合使用这两种加密方式, 取长补短, 既可以安全的交换密钥, 又可以高效的解密 ### 流程 这一个是在三次握手之后进行的, 客户端发送一下自己支持的加密算法, 服务器选择一个加密套件, 公钥数字以及证书, 告诉客户端 > 这一个证书里面要求有公钥用户信息, 公钥, 权威机构签名, 有效期等用于证明这一个服务器是真正的服务器 之后客户端会随机生成一个密钥(对称加密使用), 之后使用从服务器获取的公钥进行加密, 发送给服务器, 服务器使用自己的私钥进行解密 交换之后就可以使用对称的加密算法进行数据的传输"},"/note/Linux/Linux网络编程/2024-4-3-02Socket编程.html":{"title":"Socket编程","content":" layout: post title: \"Socket编程\" date: 2024 3 10 15:39:08 +0800 tags: Linux 网络 # Socket编程 ## 网络套接字 socket: （电源）插座（电器上的）插口，插孔，管座 在通信过程中, 套接字是成对存在的, 一个客户端的套接字, 一个服务器的套接字 ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404032054051.jpg) > **在网络通信中，套接字一定是成对出现的。**一端的发送缓冲区对应对端的接收缓冲区。我们使用同一个文件描述符索发送缓冲区和接收缓冲区。 > > 为TCP/IP协议设计的应用层编程接口称为socket API。 ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404032106960.jpg) ### 网络字节序 我们已经知道，内存中的多字节数据相对于内存地址有大端和小端之分，磁盘文件中的多字节数据相对于文件中的偏移地址也有大端小端之分。网络数据流同样有大端小端之分，那么如何定义网络数据流的地址呢？发送主机通常将发送缓冲区中的数据按内存地址从低到高的顺序发出，接收主机把从网络上接到的字节依次保存在接收缓冲区中，也是按内存地址从低到高的顺序保存，因此，网络数据流的地址应这样规定：先发出的数据是低地址，后发出的数据是高地址。 > 小段法: 高位的数据在高地址, 低位的数据在低地址(计算机本地使用) > > 大端法: 高位在地地址, 低位在高地址(网络使用) TCP/IP协议规定，网络数据流应采用大端字节序，即低地址高字节。例如上一节的UDP段格式，地址0 1是16位的源端口号，如果这个端口号是1000（0x3e8），则地址0是0x03，地址1是0xe8，也就是先发0x03，再发0xe8，这16位在发送主机的缓冲区中也应该是低地址存0x03，高地址存0xe8。但是，如果发送主机是小端字节序的，这16位被解释成0xe803，而不是1000。因此，发送主机把1000填到发送缓冲区之前需要做字节序的转换。同样地，接收主机如果是小端字节序的，接到16位的源端口号也要做字节序的转换。如果主机是大端字节序的，发送和接收都不需要做转换。同理，32位的IP地址也要考虑网络字节序和主机字节序的问题。 为使网络程序具有可移植性，使同样的C代码在大端和小端计算机上编译后都能正常运行，可以调用以下库函数做**网络字节序和主机字节序的转换**。 ```c #include <arpa/inet.h> uint32_t htonl(uint32_t hostlong); //本地到网络, 主要是IP uint16_t htons(uint16_t hostshort);//本地到网络, 这一个主要是端口 uint32_t ntohl(uint32_t netlong); uint16_t ntohs(uint16_t netshort); ``` > h表示host，n表示network，l表示32位长整数，s表示16位短整数。 > > 如果主机是小端字节序，这些函数将参数做相应的大小端转换然后返回，如果主机是大端字节序，这些函数不做转换，将参数原封不动地返回。 ### IP地址转换函数 ```c #include <arpa/inet.h> int inet_pton(int af, const char *src, void *dst); const char *inet_ntop(int af, const void *src, char *dst, socklen_t size); ``` > 支持IPv4和IPv6 > > This function converts the character string src into a network address structure in the af address family, then copies the network address struc‐ture to dst. The af argument must be either AF_INET or AF_INET6. dst is written in network byte order. > > af : 使用的协议, 可以使用两个宏定义 > > AF_INET: IPV4 > > AF_INET6: IPV6 > > src: 源字符串 > > dst: 获取到的转换后的网络字节序的IP地址 > > 返回值: 1成功, 0:这一个src不是一个有效的ip地址 ## 网络套接字函数 ### socket模型创建流程图 ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404032133459.jpg) ### sockaddr数据结构 strcut sockaddr 很多网络编程函数诞生早于IPv4协议，那时候都使用的是sockaddr结构体,为了向前兼容，现在sockaddr退化成了（void *）的作用，传递一个地址给函数，至于这个函数是sockaddr_in还是sockaddr_in6，由地址族确定，然后函数内部再强制类型转化为所需的地址类型。 **可参看 man 7 ip** ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404032141315.png) > 从左向右依次进化 sockaddr数据结构 ```c struct sockaddr { sa_family_t sa_family; /* address family, AF_xxx */ char sa_data[14]; /* 14 bytes of protocol address */ }; ``` 使用 sudo grep r \"struct sockaddr_in {\" /usr 命令可查看到struct sockaddr_in结构体的定义。一般其默认的存储位置：/usr/include/linux/in.h 文件中。 > 这一个`struct sockaddr_in`这一个是实际使用的参数, 使用的时候需要进行一个强制转换, 这是因为这一个函数设计的时间比较早, 为了兼容早期的程序 ```c struct sockaddr_in { __kernel_sa_family_t sin_family; /* Address family 地址结构类型, 可以使用AF_INET表示ipv4 */ __be16 sin_port; /* Port number 端口号 使用函数htons*/ struct in_addr sin_addr; /* Internet address IP地址, 这一个需要使用inet_pton进行转换 , 这一个可以使用宏定义INADDR_ANY获取当前的有效的IP地址, 之后使用htonl转换一下*/ /* Pad to size of `struct sockaddr'. */ unsigned char __pad[__SOCK_SIZE__ sizeof(short int) sizeof(unsigned short int) sizeof(struct in_addr)]; }; struct in_addr { /* Internet address. */ __be32 s_addr; }; struct sockaddr_in6 { unsigned short int sin6_family; /* AF_INET6 */ __be16 sin6_port; /* Transport layer port # */ __be32 sin6_flowinfo; /* IPv6 flow information */ struct in6_addr sin6_addr; /* IPv6 address */ __u32 sin6_scope_id; /* scope id (new in RFC2553) */ }; struct in6_addr { union { \t__u8 u6_addr8[16]; \t__be16 u6_addr16[8]; \t__be32 u6_addr32[4]; } in6_u; #define s6_addr in6_u.u6_addr8 #define s6_addr16 in6_u.u6_addr16 #define s6_addr32 in6_u.u6_addr32 }; #define UNIX_PATH_MAX 108 struct sockaddr_un { __kernel_sa_family_t sun_family; /* AF_UNIX */ char sun_path[UNIX_PATH_MAX]; /* pathname */ }; ``` Pv4和IPv6的地址格式定义在netinet/in.h中，IPv4地址用sockaddr_in结构体表示，包括16位端口号和32位IP地址，IPv6地址用sockaddr_in6结构体表示，包括16位端口号、128位IP地址和一些控制字段。UNIX Domain Socket的地址格式定义在sys/un.h中，用sock addr_un结构体表示。各种socket地址结构体的开头都是相同的，前16位表示整个结构体的长度（并不是所有UNIX的实现都有长度字段，如Linux就没有），后16位表示地址类型。 IPv4、IPv6和Unix Domain Socket的地址类型分别定义为常数AF_INET、AF_INET6、AF_UNIX。这样，只要取得某种sockaddr结构体的首地址，不需要知道具体是哪种类型的sockaddr结构体，就可以根据地址类型字段确定结构体中的内容。因此，socket API可以接受各种类型的sockaddr结构体指针做参数，例如bind、accept、connect等函数，这些函数的参数应该设计成void *类型以便接受各种类型的指针，但是sock API的实现早于ANSI C标准化，那时还没有void *类型，因此这些函数的参数都用struct sockaddr *类型表示，在传递参数之前要强制类型转换一下，例如： ```c struct sockaddr_in servaddr; bind(listen_fd, (struct sockaddr *)&servaddr, sizeof(servaddr)); /* initialize servaddr */ ``` ## 网络套接字函数 ### socket模型创建流程图 ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404032203769.jpg) > 实际使用的时候客户有一个套接字, 和服务器的一个套接字进行通讯, 服务器还有一个套接字用于监听 > > 这一个监听的客户端设置完成以后, 使用accept函数获取连接, 返回一个新的socket的描述符, 实际通信使用的是这一个新的socket描述符 ### socket创建一个套接字 ```c #include <sys/types.h> /* See NOTES */ #include <sys/socket.h> int socket(int domain, int type, int protocol); ``` > + domain: > > AF_INET 这是大多数用来产生socket的协议，使用TCP或UDP来传输，用IPv4的地址 > > AF_INET6 与上面类似，不过是来用IPv6的地址 > > AF_UNIX, AF_LOCAL本地协议，使用在Unix和Linux系统上，一般都是当客户端和服务器在同一台及其上的时候使用 > > + type: > > SOCK_STREAM 这个协议是按照顺序的、可靠的、数据完整的基于字节流的连接。这是一个使用最多的socket类型，这个socket是使用TCP来进行传输。 > > SOCK_DGRAM 这个协议是无连接的、固定长度的传输调用。该协议是不可靠的，使用UDP来进行它的连接。 > > SOCK_SEQPACKET该协议是双线路的、可靠的连接，发送固定长度的数据包进行传输。必须把这个包完整的接受才能进行读取。 > > SOCK_RAW socket类型提供单一的网络访问，这个socket类型使用ICMP公共协议。（ping、traceroute使用该协议） > > SOCK_RDM 这个类型是很少使用的，在大部分的操作系统上没有实现，它是提供给数据链路层使用，不保证数据包的顺序 > > + protocol: > > 传0 表示使用默认协议。 > > + 返回值： > > 成功：返回指向新创建的socket的文件描述符，失败：返回 1，设置errno socket()打开一个网络通讯端口，如果成功的话，就像open()一样返回一个文件描述符，应用程序可以像读写文件一样用read/write在网络上收发数据，如果socket()调用出错则返回 1。对于IPv4，domain参数指定为AF_INET。对于TCP协议，type参数指定为SOCK_STREAM，表示面向流的传输协议。如果是UDP协议，则type参数指定为SOCK_DGRAM，表示面向数据报的传输协议。protocol参数的介绍从略，指定为0即可。 ### bind绑定ip端口 ```c #include <sys/types.h> /* See NOTES */ #include <sys/socket.h> int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen); ``` > sockfd： > > socket文件描述符 > > addr: > > 构造出IP地址加端口号, 这一个结构体实际使用的是sockaddr_in, 里面的协议要和socket一样, 实际传参的时候需要一个类型转换 > > addrlen: > > sizeof(addr)长度 > > 返回值： > > 成功返回0，失败返回 1, 设置errno ​ 服务器程序所监听的网络地址和端口号通常是固定不变的，客户端程序得知服务器程序的地址和端口号后就可以向服务器发起连接，因此服务器需要调用bind绑定一个固定的网络地址和端口号。 bind()的作用是将参数sockfd和addr绑定在一起，使sockfd这个用于网络通讯的文件描述符监听addr所描述的地址和端口号。前面讲过，struct sockaddr *是一个通用指针类型，addr参数实际上可以接受多种协议的sockaddr结构体，而它们的长度各不相同，所以需要第三个参数addrlen指定结构体的长度。如： ```c struct sockaddr_in servaddr; bzero(&servaddr, sizeof(servaddr)); servaddr.sin_family AF_INET; servaddr.sin_addr.s_addr htonl(INADDR_ANY); servaddr.sin_port htons(6666); ``` 首先将整个结构体清零，然后设置地址类型为AF_INET，网络地址为INADDR_ANY，这个宏表示本地的任意IP地址，因为服务器可能有多个网卡，每个网卡也可能绑定多个IP地址，这样设置可以在所有的IP地址上监听，直到与某个客户端建立了连接时才确定下来到底用哪个IP地址，端口号为6666。 ### listen设置监听上限 ```c #include <sys/types.h> /* See NOTES */ #include <sys/socket.h> int listen(int sockfd, int backlog); ``` > sockfd: > > socket文件描述符 > > backlog: > > 排队建立3次握手队列和刚刚建立3次握手队列的链接数和, 这一个系统的默认最大值是128 查看系统默认backlog cat /proc/sys/net/ipv4/tcp_max_syn_backlog 典型的服务器程序可以同时服务于多个客户端，当有客户端发起连接时，服务器调用的accept()返回并接受这个连接，如果有大量的客户端发起连接而服务器来不及处理，尚未accept的客户端就处于连接等待状态，listen()声明sockfd处于监听状态，并且最多允许有backlog个客户端处于连接待状态，如果接收到更多的连接请求就忽略。listen()成功返回0，失败返回 1。 ### accept阻塞监听客户端 ```c #include <sys/types.h> /* See NOTES */ #include <sys/socket.h> int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); ``` > sockdf: > > socket文件描述符 > > addr: > > 传出参数，返回链接客户端地址信息，含IP地址和端口号 > > addrlen: > > 传入传出参数（值 结果）,传入sizeof(addr)大小，函数返回时返回真正接收到地址结构体的大小 > > 返回值： > > 成功返回一个新的socket文件描述符，用于和客户端通信，失败返回 1，设置errno 三方握手完成后，服务器调用accept()接受连接，如果服务器调用accept()时还没有客户端的连接请求，就阻塞等待直到有客户端连接上来。addr是一个传出参数，accept()返回时传出客户端的地址和端口号。addrlen参数是一个传入传出参数（value result argument），传入的是调用者提供的缓冲区addr的长度以避免缓冲区溢出问题，传出的是客户端地址结构体的实际长度（有可能没有占满调用者提供的缓冲区）。如果给addr参数传NULL，表示不关心客户端的地址。 我们的服务器程序结构是这样的： ```c while (1) { cliaddr_len sizeof(cliaddr); connfd accept(listenfd, (struct sockaddr *)&cliaddr, &cliaddr_len); n read(connfd, buf, MAXLINE); ...... close(connfd); } ``` 整个是一个while死循环，每次循环处理一个客户端连接。由于cliaddr_len是传入传出参数，每次调用accept()之前应该重新赋初值。accept()的参数listenfd是先前的监听文件描述符，而accept()的返回值是另外一个文件描述符connfd，之后与客户端之间就通过这个connfd通讯，最后关闭connfd断开连接，而不关闭listenfd，再次回到循环开头listenfd仍然用作accept的参数。accept()成功返回一个文件描述符，出错返回 1。 ### connect客户连接 ```c #include <sys/types.h> /* See NOTES */ #include <sys/socket.h> int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen); ``` > sockdf: > > socket文件描述符 > > addr: > > 传入参数，指定服务器端地址信息，含IP地址和端口号 > > addrlen: > > 传入参数,传入sizeof(addr)大小 > > 返回值： > > 成功返回0，失败返回 1，设置errno 客户端需要调用connect()连接服务器，connect和bind的参数形式一致，区别在于bind的参数是自己的地址，而connect的参数是对方的地址。connect()成功返回0，出错返回 1。 > 之后就可以使用read和write函数进行读写, 进行数据的传递 > > read的错误: > > 1. errno EINTR 这个被一个信号中断了, 需要再重新读取一次 > 2. errno EAGIN 或 EWOULDBLOCK 以一个非阻塞的模式进行读取, 需要再一次读取 > 3. errno ECONNRESET 连接被重置了需要close, 之后移除监听队列(这一个是服务器端三次握手只进行一般发生RET返回的情景) > 如果不使用bind函数绑定客户端的ip和端口, 这一个会隐式绑定 #### 端口复用 > [socket 网络编程——端口复用技术（setsockopt（））（linux下多个进程监听同一个端口）_linux端口复用怎么区分不同的客户端 CSDN博客](https://blog.csdn.net/JMW1407/article/details/107321853) > > [setsockopt函数的作用和说明 CSDN博客](https://blog.csdn.net/c_base_jin/article/details/94353956) 在server的TCP连接没有完全断开之前不允许重新监听是不合理的。因为，TCP连接没有完全断开指的是connfd（127.0.0.1:6666）没有完全断开，而我们重新监听的是lis tenfd（0.0.0.0:6666），虽然是占用同一个端口，但IP地址不同，connfd对应的是与某个客户端通讯的一个具体的IP地址，而listenfd对应的是wildcard address。解决这个问题的方法是使用setsockopt()设置socket描述符的选项SO_REUSEADDR为1，表示允许创建端口号相同但IP地址不同的多个socket描述符。 ```c int setsockopt(int sockfd, int level, int optname, const void *optval, socklen_t optlen); ``` > optval : 1设置端口复用, 0:设置端口不复用 在server代码的socket()和bind()调用之间插入如下代码： ```c int opt 1; setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, (void *)&opt, sizeof(opt)); ``` > 重用本地地址, 这一个设置需要在bind之前 > SO_REUSEADDR提供如下四个功能： > > + 允许启动一个监听服务器并捆绑其众所周知端口，即使以前建立的将此端口用做他们的本地端口的连接仍存在。这通常是重启监听服务器时出现，若不设置此选项，则bind时将出错。 > + 允许在同一端口上启动同一服务器的多个实例，只要每个实例捆绑一个不同的本地IP地址即可。对于TCP，我们根本不可能启动捆绑相同IP地址和相同端口号的多个服务器。 > + 允许单个进程捆绑同一端口到多个套接口上，只要每个捆绑指定不同的本地IP地址即可。这一般不用于TCP服务器。 > + 允许完全重复的捆绑：当一个IP地址和端口绑定到某个套接口上时，还允许此IP地址和端口捆绑到另一个套接口上。一般来说，这个特性仅在支持多播的系统上才有，而且只对UDP套接口而言（TCP不支持多播）。 > > SO_REUSEPORT有如下语义： > > + 此选项允许完全重复捆绑，但仅在想捆绑相同IP地址和端口的套接口都指定了此套接口选项才行。 > + 如果被捆绑的IP地址是一个多播地址，则SO_REUSEADDR和SO_REUSEPORT等效。 有关setsockopt可以设置的其它选项请参考UNP第7章。 ### 实际的使用流程 + server socket: 获取一个socket用于监听 bind: 绑定一下IP地址和端口号 listen: 设置监听的上限 accept: 阻塞监听客户端连接 read: 读取信息 > NAME > recv, recvfrom, recvmsg receive a message from a socket > > SYNOPSIS > > ```c > #include <sys/types.h> > #include <sys/socket.h> > ssize_t recv(int sockfd, void *buf, size_t len, int flags); > ``` > > 这一个函数和read的区别只有flags参数的不同, 使用0的时候和read一样 write:发送信息 > NAME > send, sendto, sendmsg send a message on a socket > > SYNOPSIS > > ```c > #include <sys/types.h> > #include <sys/socket.h> > ssize_t send(int sockfd, const void *buf, size_t len, int flags); > ``` close + client socket connect:创建数据 write: 写入数据 read: 读取数据 close ### 示例 #### 服务器 ```c #include <ctype.h> #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> #include <sys/socket.h> #include <sys/types.h> #include <arpa/inet.h> #define SERV_PORT\t\t\t\t9078 int main(void){ \tint lfd 0, cfd; \tstruct sockaddr_in serv_addr, clit_addr; \tsocklen_t clit_addr_len; \tchar buf[BUFSIZ]; \tlfd socket(AF_INET, SOCK_STREAM, 0); \tif(lfd 1){ \t\tperror(\"socket error\\n\"); \t\texit(0); \t} \tserv_addr.sin_family AF_INET;\t\t\t\t//使用IPV4 \tserv_addr.sin_port htons(SERV_PORT);\t\t//设置端口 \tserv_addr.sin_addr.s_addr htonl(INADDR_ANY);//设置检测本地的所有ip \tint ret bind(lfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)); \tif(ret ! 0){ \t\tperror(\"bind error\\n\"); \t\texit(0); \t} \tret listen(lfd, 128);\t\t\t\t\t\t//设置最大的处理个数 \tif(ret ! 0){ \t\tperror(\"listen error\\n\"); \t\texit(0); \t} \tclit_addr_len sizeof(clit_addr); \tcfd accept(lfd, (struct sockaddr *)&clit_addr, &clit_addr_len);\t//设置阻塞 \t\tif(cfd 1){ \t\t\tperror(\"sccept error\\n\"); \t\t\texit(1); \t\t} \twhile(1){ \t\tret read(cfd, buf, sizeof(buf)); \t\tif(ret < 0){ \t\t\tperror(\"read error\\n\"); \t\t\texit(1); \t\t}else if(ret 0){ \t\t\tbreak; \t\t} \t\twrite(STDOUT_FILENO , buf, ret); \t\tfor(int i 0;i<ret;i++){ \t\t\tbuf[i] toupper(buf[i]);\t\t//获取的数据转换为大写 \t\t} \t\twrite(cfd, buf, ret); \t} \tclose(cfd); \tclose(lfd); \treturn 0; } ``` ![image 20240404114734669](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404041147860.png) ```c cfd accept(lfd, (struct sockaddr *)&clit_addr, &clit_addr_len); if(cfd 1){ perror(\"sccept error\\n\"); exit(1); } printf(\"client ip: %s port %d\\n\", inet_ntop(AF_INET, &clit_addr.sin_addr.s_addr, buf, sizeof(buf)), ntohs(clit_addr.sin_port)); ``` > 可以使用这一个获取连接的客户端的信息 #### 客户端 ```c #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> #include <sys/socket.h> #include <sys/types.h> #include <arpa/inet.h> int main(void){ \tint cfd;\t \tcfd socket(AF_INET, SOCK_STREAM, 0); \tif(cfd 1){ \t\tperror(\"socket error\"); \t\texit(1); \t} \tstruct sockaddr_in c_sock; \tint ip_addr; \tinet_pton(AF_INET, \"127.0.0.1\", &ip_addr);//获取ip地址的二进制小端数据 \tc_sock.sin_addr.s_addr ip_addr; \tc_sock.sin_port htons(9078); \tc_sock.sin_family AF_INET; \tint ret connect(cfd, (struct sockaddr *)&c_sock, sizeof(c_sock));//连接 \tif(ret 1){ \t\tperror(\"connect error\"); \t\texit(1); \t} \tchar buf[1024]; \twhile(1){ \t\tint len read(STDIN_FILENO, buf, sizeof(buf));//获取输入 \t\twrite(cfd, buf, len);//发送信息 \t\tlen read(cfd, buf, sizeof(buf));//获取返回值 \t\twrite(STDOUT_FILENO, buf, len);//显示 \t} \treturn 0; } ``` > 这一个实现的功能是从stdin获取信息发送给服务器, 之后打印服务器的返回值 #### 多进程处理 ```c #include <ctype.h> #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> #include <sys/socket.h> #include <sys/types.h> #include <arpa/inet.h> #define SERV_PORT\t\t\t\t9078 void deal_one_server(struct sockaddr_in *clit_addr, int cfd){ \tint ret; \tchar buf[1024]; \tprintf(\"client ip: %s port %d\\n\", \t\t\tinet_ntop(AF_INET, &clit_addr >sin_addr.s_addr, buf, sizeof(buf)), \t\t\tntohs(clit_addr >sin_port)); \twhile(1){ \t\tret read(cfd, buf, sizeof(buf)); \t\tif(ret < 0){ \t\t\tperror(\"read error\\n\"); \t\t\texit(1); \t\t}else if(ret 0){ \t\t\tbreak; \t\t} \t\twrite(STDOUT_FILENO , buf, ret); \t\tfor(int i 0;i<ret;i++){ \t\t\tbuf[i] toupper(buf[i]); \t\t} \t\twrite(cfd, buf, ret); \t} } int main(void){ \tint lfd 0, cfd; \tstruct sockaddr_in serv_addr, clit_addr; \tsocklen_t clit_addr_len; \tchar buf[BUFSIZ]; \tlfd socket(AF_INET, SOCK_STREAM, 0); \tif(lfd 1){ \t\tperror(\"socket error\\n\"); \t\texit(0); \t} \tserv_addr.sin_family AF_INET; \tserv_addr.sin_port htons(SERV_PORT); \tserv_addr.sin_addr.s_addr htonl(INADDR_ANY); \tint ret bind(lfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)); \tif(ret ! 0){ \t\tperror(\"bind error\\n\"); \t\texit(0); \t} \tret listen(lfd, 128); \tif(ret ! 0){ \t\tperror(\"listen error\\n\"); \t\texit(0); \t} \tclit_addr_len sizeof(clit_addr); \tpid_t pid; \twhile(1){ \t\tprintf(\"waiting connect\\n\"); \t\tcfd accept(lfd, (struct sockaddr *)&clit_addr, &clit_addr_len); \t\tif(cfd 1){ \t\t\tperror(\"sccept error\\n\"); \t\t\texit(1); \t\t}else \t\t{ \t\t\tpid fork();//创建一个子进程 \t\t\tprintf(\"pid %d\\n\", pid); \t\t\tif(pid 1){ \t\t\t\tperror(\"fork error\"); \t\t\t\texit(1); \t\t\t} \t\t\tif(pid 0){ //使用子进程处理这一个连接 close(lfd); \t\t\t\tprintf(\"deal a connect %d %d\\n\", getpid(), getppid()); \t\t\t\tdeal_one_server(&clit_addr, cfd); close(cfd); \t\t\t\texit(1); \t\t\t}else{ //父进程继续捕获 \t\t\t\tclose(cfd); } \t\t} \t} \treturn 0; } ``` > ![image 20240404211134041](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404042111108.png) > > > 可以使用信号机制回收子进程, 如果使用的线程, 可以使用一个detach把这一个线程分离出去, 也可以专门使用一个线程进行回收兄弟线程 #### 多线程 ```c #include <ctype.h> #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> #include <sys/socket.h> #include <sys/types.h> #include <arpa/inet.h> #include <pthread.h> #define SERV_PORT\t\t\t\t9078 //子线程的处理函数 void *deal_one_server(void * arg){ \tint ret; \tint cfd (int)arg; \tchar buf[1024]; \twhile(1){ \t\tret read(cfd, buf, sizeof(buf)); \t\tif(ret < 0){ \t\t\tperror(\"read error\\n\"); \t\t\texit(1); \t\t}else if(ret 0){ \t\t\tbreak; \t\t} \t\twrite(STDOUT_FILENO , buf, ret); \t\tfor(int i 0;i<ret;i++){ \t\t\tbuf[i] toupper(buf[i]); \t\t} \t\twrite(cfd, buf, ret); \t} \tclose(cfd); } int main(void){ \tint lfd 0, cfd; \tstruct sockaddr_in serv_addr, clit_addr; \tsocklen_t clit_addr_len; \tchar buf[BUFSIZ]; \tlfd socket(AF_INET, SOCK_STREAM, 0); \tif(lfd 1){ \t\tperror(\"socket error\\n\"); \t\texit(0); \t} \t//设置一下服务器的接收 \tserv_addr.sin_family AF_INET; \tserv_addr.sin_port htons(SERV_PORT); \tserv_addr.sin_addr.s_addr htonl(INADDR_ANY); \tint ret bind(lfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr)); \tif(ret ! 0){ \t\tperror(\"bind error\\n\"); \t\texit(0); \t} \tret listen(lfd, 128);//设置可以接受的个数 \tif(ret ! 0){ \t\tperror(\"listen error\\n\"); \t\texit(0); \t} \tclit_addr_len sizeof(clit_addr); \tpid_t pid; \twhile(1){ \t\tprintf(\"waiting connect\\n\"); sig_continue: \t\tcfd accept(lfd, (struct sockaddr *)&clit_addr, &clit_addr_len);//开始接收 \t \t\tif(cfd 1){ \t\t\tif((errno ECONNABORTED) (errno EINTR)){ \t\t\t\tgoto sig_continue;//处理一下信号打断 \t\t\t} \t\t\tperror(\"sccept error\\n\"); \t\t\texit(1); \t\t}else \t\t{ \t\t\tprintf(\"client ip: %s port %d\\n\", \t\t\t\tinet_ntop(AF_INET, &clit_addr.sin_addr.s_addr, \t\t\t\tbuf, sizeof(buf)), \t\t\t\tntohs(clit_addr.sin_port)); \t\t\tpthread_t pid; \t\t\tpthread_create(&pid, NULL, deal_one_server, (void *)cfd);//使用一个线程接收 \t\t\tpthread_detach(pid);//把这一个线程分离 \t\t} \t} \treturn 0; } ``` ### 和TCP协议的对应 <img src \"https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404051030791.png\" alt \"img\" style \"zoom:150%;\" /> 服务器调用socket()、bind()、listen()完成初始化后，调用accept()阻塞等待，处于监听端口的状态，客户端调用socket()初始化后，调用connect()发出SYN段并阻塞等待服务器应答，服务器应答一个SYN ACK段，客户端收到后从connect()返回，同时应答一个ACK段，服务器收到后从accept()返回。 > 这个时候三次握手已经完成了 建立连接后，TCP协议提供全双工的通信服务，但是一般的客户端/服务器程序的流程是由客户端主动发起请求，服务器被动处理请求，一问一答的方式。因此，服务器从accept()返回后立刻调用read()，读socket就像读管道一样，如果没有数据到达就阻塞等待，这时客户端调用write()发送请求给服务器，服务器收到后从read()返回，对客户端的请求进行处理，在此期间客户端调用read()阻塞等待服务器的应答，服务器调用write()将处理结果发回给客户端，再次调用read()阻塞等待下一条请求，客户端收到后从read()返回，发送下一条请求，如此循环下去。 如果客户端没有更多的请求了，就调用close()关闭连接，就像写端关闭的管道一样，服务器的read()返回0，这样服务器就知道客户端关闭了连接，也调用close()关闭连接。 > 四次挥手 注意，任何一方调用close()后，连接的两个传输方向都关闭，不能再发送数据了。如果一方调用shutdown()则连接处于半关闭状态，仍可接收对方发来的数据。 > 半关闭 在学习socket API时要注意应用程序和TCP协议层是如何交互的： 应用程序调用某个socket函数时TCP协议层完成什么动作，比如调用connect()会发出SYN段 应用程序如何知道TCP协议层的状态变化，比如从某个阻塞的socket函数返回就表明TCP协议收到了某些段，再比如read()返回0就表明收到了FIN段 ### 使用UDP进行数据传输 在使用的时候accept以及connect函数不再使用 实际接收的时候不能使用recv/send以及read/write函数, 需要使用函数recvfrom以及sendto函数 #### recvfrom获取数据 ```c ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen); ``` > socket: socket返回的lfd > > buf: 数据 > > len: 缓冲区大小 > > flags: 0 > > src_addr: 接收的地址, 这一个是一个传出参数 > > addrlen :这一个结构体的大小 > > 返回值: 成功获取的数据的个数, 1失败, 0对端关闭 #### sendto发送数据 ```c ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen); ``` > socket: socket返回的lfd > > buf: 数据 > > len: 缓冲区大小 > > flags: 0 > > dest_addr: 发送的目标地址 > > addrlen :这一个结构体的大小 > > 返回值: 实际发送的字节数, 失败的时候返回 1 + server lfd socket(AF_INET, SOCK_DGRAM, 0); bind(); listen(); 不需要连接, 所以这一个函数可有可无 while(1){ ​\trecvfrom ​\t处理 ​\tsendto } + client lfd socket(AF_INET, SOCK_DGRAM, 0); sendto recvfrom 处理获取的数据 #### 实际实现 ```c #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> #include <string.h> #include <ctype.h> #include <arpa/inet.h> #include <sys/socket.h> int main(void){ \tstruct sockaddr_in serveraddr, clientaddr; \tsocklen_t addrlen sizeof(struct sockaddr_in); \tchar buf[BUFSIZ]; \tchar str[INET_ADDRSTRLEN]; // #define INET_ADDRSTRLEN 16 \tint i, n; \tint sockfd; \tint ret; \t//获取套接字 \tsockfd socket(AF_INET, SOCK_DGRAM, 0); \tif(sockfd < 0){ \t\tperror(\"socket\"); \t\texit( 1); \t} \tprintf(\"sockfd %d\\n\", sockfd); \t \tbzero(&serveraddr, sizeof(serveraddr)); \tserveraddr.sin_family AF_INET; \tserveraddr.sin_port htons(8000); \tserveraddr.sin_addr.s_addr htonl(INADDR_ANY); \tbind(sockfd, (struct sockaddr *)&serveraddr, addrlen); \t \twhile(1){ \t\tn recvfrom(sockfd, buf, BUFSIZ, 0, (struct sockaddr *)&clientaddr, &addrlen); \t\tif(n 1){ \t\t\tperror(\"recvfrom\"); \t\t\texit( 1); \t\t} \t\tprintf(\"received from %s at PORT %d\\n\", \t\t\t\tinet_ntop(AF_INET, &clientaddr.sin_addr, str, sizeof(str)), \t\t\t\tntohs(clientaddr.sin_port)); \t\tfor(i 0; i < n; i++){ \t\t\tbuf[i] toupper(buf[i]); \t\t} \t\tn sendto(sockfd, buf, n, 0, (struct sockaddr *)&clientaddr, addrlen); \t\tif(n 1){ \t\t\tperror(\"sendto\"); \t\t\texit( 1); \t\t} \t} \tclose(sockfd); \treturn 0; } ``` ```c #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> #include <string.h> #include <arpa/inet.h> #include <sys/socket.h> int main(void){ \tstruct sockaddr_in server_addr; \tint sockfd, n; \tchar buf[1024]; \tsockfd socket(AF_INET, SOCK_DGRAM, 0); \tif(sockfd < 0){ \t\tperror(\"socket\"); \t\texit(1); \t} \tserver_addr.sin_family AF_INET; \tserver_addr.sin_port htons(8000); \tinet_pton(AF_INET, \"127.0.0.1\", &server_addr.sin_addr); \twhile(fgets(buf, sizeof(buf), stdin) ! NULL){ \t\tn sendto(sockfd, buf, strlen(buf), 0, \t\t\t\t(struct sockaddr *)&server_addr, sizeof(server_addr)); \t\tif(n < 0){ \t\t\tperror(\"sendto\"); \t\t\texit(1); \t\t} \t\tn recvfrom(sockfd, buf, sizeof(buf), 0, NULL, NULL); \t\twrite(STDOUT_FILENO, buf, n); \t} \tclose(sockfd); \treturn 0; } ``` ## 出错处理封装函数 上面的例子不仅功能简单，而且简单到几乎没有什么错误处理，我们知道，系统调用不能保证每次都成功，必须进行出错处理，这样一方面可以保证程序逻辑正常，另一方面可以迅速得到故障信息。 为使错误处理的代码不影响主程序的可读性，我们把与socket相关的一些系统函数加上错误处理代码包装成新的函数，做成一个模块wrap.c： > 这里只改变了一个字母的大小写不影响进入man手册 ### wrap.c ```c #include <stdlib.h> #include <errno.h> #include <sys/socket.h> //一个错误信息打印函数 void perr_exit(const char *s) { perror(s); exit(1); } int Accept(int fd, struct sockaddr *sa, socklen_t *salenptr) { int n; again: if ( (n accept(fd, sa, salenptr)) < 0) { if ((errno ECONNABORTED) (errno EINTR)) goto again;//这一个系统调研被一个中断打断 else perr_exit(\"accept error\"); } return n; } int Bind(int fd, const struct sockaddr *sa, socklen_t salen) { int n; if ((n bind(fd, sa, salen)) < 0) perr_exit(\"bind error\"); return n; } int Connect(int fd, const struct sockaddr *sa, socklen_t salen) { int n; if ((n connect(fd, sa, salen)) < 0) perr_exit(\"connect error\"); return n; } int Listen(int fd, int backlog) { int n; if ((n listen(fd, backlog)) < 0) perr_exit(\"listen error\"); return n; } int Socket(int family, int type, int protocol) { int n; if ( (n socket(family, type, protocol)) < 0) perr_exit(\"socket error\"); return n; } ssize_t Read(int fd, void *ptr, size_t nbytes) { ssize_t n; again: if ( (n read(fd, ptr, nbytes)) 1) { if (errno EINTR) goto again; else return 1; } return n; } ssize_t Write(int fd, const void *ptr, size_t nbytes) { ssize_t n; again: if ( (n write(fd, ptr, nbytes)) 1) { if (errno EINTR) goto again; else return 1; } return n; } int Close(int fd) { int n; if ((n close(fd)) 1) perr_exit(\"close error\"); return n; } //在socket编程里面没有文件描述符, 所以这一个读取的时候只能使用系统调用 //在使用的时候封装一下会提高效率 ssize_t Readn(int fd, void *vptr, size_t n) { size_t nleft; ssize_t nread; char *ptr; ptr vptr; nleft n; while (nleft > 0) { if ( (nread read(fd, ptr, nleft)) < 0) { if (errno EINTR) nread 0; else return 1; } else if (nread 0) break; nleft nread; ptr + nread; } return n nleft; } ssize_t Writen(int fd, const void *vptr, size_t n) { size_t nleft; ssize_t nwritten; const char *ptr; ptr vptr; nleft n; while (nleft > 0) { if ( (nwritten write(fd, ptr, nleft)) < 0) { if (nwritten < 0 && errno EINTR) nwritten 0; else return 1; } nleft nwritten; ptr + nwritten; } return n; } //以此获取一个字符, 这一个只能针对一个文件 static ssize_t my_read(int fd, char *ptr) { static int read_cnt; static char *read_ptr; static char read_buf[100];//一个静态的缓冲区 if (read_cnt < 0) { again: if ((read_cnt read(fd, read_buf, sizeof(read_buf))) < 0) { if (errno EINTR) goto again; return 1; } else if (read_cnt 0) return 0;//没有数据了 read_ptr read_buf; } read_cnt ; *ptr *read_ptr++;//读取一个数据 return 1; } ssize_t Readline(int fd, void *vptr, size_t maxlen) { ssize_t n, rc; char c, *ptr; ptr vptr; for (n 1; n < maxlen; n++) { \t if ( (rc my_read(fd, &c)) 1) { \t *ptr++ c; \t if (c '\\n') \t break; \t} else if (rc 0) { *ptr 0; return n 1; } else return 1; } *ptr 0; return n; } ``` ### wrap.h ```c #ifndef __WRAP_H_ #define __WRAP_H_ void perr_exit(const char *s); int Accept(int fd, struct sockaddr *sa, socklen_t *salenptr); int Bind(int fd, const struct sockaddr *sa, socklen_t salen); int Connect(int fd, const struct sockaddr *sa, socklen_t salen); int Listen(int fd, int backlog); int Socket(int family, int type, int protocol); ssize_t Read(int fd, void *ptr, size_t nbytes); ssize_t Write(int fd, const void *ptr, size_t nbytes); int Close(int fd); ssize_t Readn(int fd, void *vptr, size_t n); ssize_t Writen(int fd, const void *vptr, size_t n); ssize_t my_read(int fd, char *ptr); ssize_t Readline(int fd, void *vptr, size_t maxlen); #endif ``` ## 补充函数(非常用) ### shutdown关闭连接 当TCP链接中A发送FIN请求关闭，B端回应ACK后（A端进入FIN_WAIT_2状态），B没有立即发送FIN给A时，A方处在半链接状态，此时A可以接收B发送的数据，但是A已不能再向B发送数据。 从程序的角度，可以使用API来控制实现半连接状态。 ```c #include <sys/socket.h> int shutdown(int sockfd, int how); ``` > sockfd: 需要关闭的socket的描述符 > > how: 允许为shutdown操作选择以下几种方式: > > SHUT_RD(0)： 关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。 > > ​ 该套接字**不再接收数据**，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。 > > SHUT_WR(1): 关闭sockfd的写功能，此选项将不允许sockfd进行写操作。进程不能在对此套接字发出写操作。 > > SHUT_RDWR(2): 关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD,然后以SHUT_WR。 使用close中止一个连接，但它只是减少描述符的引用计数，并不直接关闭连接，只有当描述符的引用计数为0时才关闭连接。 **shutdown**不考虑描述符的引用计数，直接关闭描述符。也可选择中止一个方向的连接，只中止读或只中止写。 注意: 1. 如果有多个进程共享一个套接字，close每被调用一次，计数减1，直到计数为0时，也就是所用进程都调用了close，套接字将被释放。 2. 在多进程中如果一个进程调用了shutdown(sfd, SHUT_RDWR)后，其它的进程将无法进行通信。但，如果一个进程close(sfd)将不会影响到其它进程。 ## 补充 把文件上传服务器 ```bash scp r 文件名 服务器用户名@服务器ip:目录 scp r ./socket.c root@110.41.39.131:/root/ ```"},"/note/Linux/Linux网络编程/2024-4-20-10telnet调试.html":{"title":"调试","content":" layout: post title: \"调试\" date: 2024 4 14 15:39:08 +0800 tags: Linux 网络 # 调试 ## telnet 可以使用这一个命令模拟浏览器和服务器进行通信 ```bash telnet ip port ``` > 之后手动输入HTTP协议头就可以了以及"},"/note/Linux/Linux网络编程/2024-4-10-04线程池.html":{"title":"线程池","content":" layout: post title: \"线程池\" date: 2024 3 10 15:39:08 +0800 tags: Linux 网络 # 线程池 如果一个客户端建立连接使用创建一个线程用于处理这一个线程, 处理结束的时候把这一个线程删除, 这个时候会导致线程的创建以及销毁会消耗大量的时间 这时候可以一次性创建多个线程, 这几个线程统称线程池, 如果客户端建立一个连接, 线程池分配一个线程处理客户发过来的数据, 不处理的时候这几个线程阻塞 可以使用条件变量进行阻塞 线程的数量可以随着连接的个数, 时间等条件进行变换, 但是要有一个上限, 连接分个数增加的时候加线程, 如果忙的线程数量比较少的时候释放线程, 这一些处理使用一个adjust线程进行处理 ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404101952348.jpg) ## 实际实现 主函数 + 创建一个线程池 + 在里面添加任务 + 等待 + 关闭线程池 线程池 + 初始化各种数据 + 获取基础线程, 让他们阻塞等待任务 + 获取任务, 唤醒线程处理 + 处理结束接着阻塞 > 后台的控制线程(adjust_thread)根据线程的实际使用情况添加或者释放线程 ```c /************************************************************************* > File Name: thread_pool.c > Author: XvSenfeng > Mail: 1458612070@qq.com > Created Time: Wed 10 Apr 2024 08:23:27 PM CST ************************************************************************/ #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> #include <string.h> #include <signal.h> #include <pthread.h> //多长时间判断一下是否需要增加获取减少线程个数 //这一个值小一点看现象 #define DEFAULT_TIME\t3 //最小的执行的线程的个数 #define MIN_WAIT_TASK_NUM\t10 //增加减少的时候步长 #define DEFAULT_THREAD_VARY\t10 #define true 1 #define false 0 //记录一个回调函数, 由于线程执行 typedef struct { \tvoid *(*function)(void *); \tvoid *arg; } threadpool_task_t; //线程池的控制结构体 typedef struct{ \tpthread_mutex_t lock;\t\t\t\t//这一个结构体使用 \tpthread_mutex_t thread_counter;\t\t//记录忙状态的线程的个数 \t \tpthread_cond_t queue_not_full;\t\t//队列，没有满的时候添加使用 \tpthread_cond_t queue_not_empty; \tpthread_t *threads;\t\t\t\t\t//线程数组, 记录现在使用的线程的pid \tpthread_t adjust_tid;\t\t\t\t//管理者的id \tthreadpool_task_t *task_queue;\t\t//线程执行任务的时候使用的环形队列 \tint min_thr_num;\t\t\t//最小的时候保留的线程个数 \tint max_thr_num;\t\t\t//最大可以支持的个数 \tint live_thr_num;\t\t\t//存活的线程的个数 \tint busy_thr_num;\t\t\t//执行任务的线程的个数 \tint wait_exit_thr_num;\t\t//需要释放的线程的个数 \t//队列使用 \tint queue_front; \tint queue_rear; \tint queue_size; \tint queue_max_size; \tint shutdown;\t\t\t//记录这一个线程池有没有使用 }threadpool_t; void *adjust_thread(void *threadpool); void threadpool_free(threadpool_t *pool); //普通的线程处理函数 void *threadpool_thread(void *threadpool){ \tthreadpool_t *pool (threadpool_t *)threadpool; \tthreadpool_task_t task; \twhile(true){ \t\tpthread_mutex_lock(&(pool >lock)); \t\t//判断一下现在没有可以执行的任务, 并且这一个线程组还没有销毁 \t\twhile((pool >queue_size 0) && (!pool >shutdown)){ \t\t\tprintf(\"thread %#x is waiting\\n\", (unsigned int)pthread_self()); \t\t\t//等待任务, 获取清除唤醒 pthread_cond_wait(&pool >queue_not_empty, &pool >lock); \t\t\t//需要清除一部分线程 \t\t\tif(pool >wait_exit_thr_num > 0){ \t\t\t\tpool >wait_exit_thr_num ;//记录需要清除的任务的个数 \t\t\t\tif(pool >live_thr_num > pool >min_thr_num){ \t\t\t\t\tprintf(\"thread %#x is exiting\\n\", (unsigned int)pthread_self()); \t\t\t\t\tpool >live_thr_num ; \t\t\t\t\tpthread_mutex_unlock(&pool >lock); \t\t\t\t\tpthread_exit(NULL); \t\t\t\t} \t\t\t} \t\t} \t\t//这时候是有待处理的任务, 或者这一个线程池被销毁了 \t\tif(pool >shutdown){ //销毁线程池 \t\t\tpthread_mutex_unlock(&pool >lock); \t\t\tprintf(\"thread %#x will exit\\n\", (unsigned int)pthread_self()); \t\t\tpthread_detach(pthread_self()); \t\t\tpthread_exit(NULL); \t\t} //处理一个待处理的任务 \t\t//获取一下这一个任务的处理函数 \t\ttask.function pool >task_queue[pool >queue_front].function; \t\ttask.arg pool >task_queue[pool >queue_front].arg; \t\t//调整一下环形缓冲区的指针 \t\tpool >queue_front (pool >queue_front + 1) % pool >queue_max_size; \t\tpool >queue_size ; \t\t//发送一个任务队列现在有位置的信号, 这一个的阻塞在添加一个待处理任务的位置 \t\tpthread_cond_broadcast(&pool >queue_not_full); \t\tpthread_mutex_unlock(&pool >lock); \t\t \t\tprintf(\"thread %#x start working\\n\", (unsigned int)pthread_self()); \t\tpthread_mutex_lock(&pool >thread_counter); \t\tpool >busy_thr_num++; \t\tpthread_mutex_unlock(&pool >thread_counter); \t\t \t\t(*(task.function))(task.arg);//调用则一个任务的处理函数 \t\tprintf(\"thread %#x end working\\n\", (unsigned int)pthread_self()); \t\tpthread_mutex_lock(&pool >thread_counter); \t\tpool >busy_thr_num ; \t\tpthread_mutex_unlock(&pool >thread_counter); \t} \tpthread_exit(NULL); } //创建一个线程池, 返回这一个线程池的操控结构体 threadpool_t *threadpool_create(int min_thr_num, int max_thr_num, int queue_max_size){ \tint i; \tthreadpool_t *pool NULL; \tdo{ \t\tprintf(\"malloc thread pool\\n\"); \t\tif((pool (threadpool_t *)malloc(sizeof(threadpool_t))) NULL){ \t\t\tprintf(\"malloc threadpool fail\"); \t\t\tbreak; \t\t} //记录一下初始信息 \t\tpool >min_thr_num min_thr_num; \t\tpool >max_thr_num max_thr_num; \t\tpool >busy_thr_num 0; \t\tpool >live_thr_num min_thr_num; \t\tpool >wait_exit_thr_num 0; \t\t \t\tpool >queue_size 0; \t\tpool >queue_max_size queue_max_size; \t\tpool >queue_front 0; \t\tpool >queue_rear 0; \t\tpool >shutdown false; \t\t//获取线程数组 \t\tpool >threads (pthread_t *)malloc(sizeof(pthread_t)*max_thr_num); \t\tif(pool >threads NULL){ \t\t\tprintf(\"malloc threads fail\"); \t\t\tbreak; \t\t} \t\tmemset(pool >threads, 0, sizeof(pthread_t)*max_thr_num); \t\t//获取任务队列 \t\tprintf(\"malloc task queue\\n\"); \t\tpool >task_queue (threadpool_task_t *)malloc(sizeof(threadpool_task_t)*queue_max_size); \t\tprintf(\"success\\n\"); \t\tif(pool >task_queue NULL){ \t\t\tprintf(\"malloc queue fail\"); \t\t\tbreak; \t\t} \t\tmemset(pool >task_queue, 0, sizeof(threadpool_task_t)*queue_max_size); \t\t//初始化一下各种锁 \t\tif(pthread_mutex_init(&(pool >thread_counter), NULL)! 0\t \t\t\tpthread_mutex_init(&(pool >lock), NULL)\t! 0\t\t\t \t\t\tpthread_cond_init(&(pool >queue_not_empty), NULL) ! 0\t \t\t\tpthread_cond_init(&(pool >queue_not_full), NULL) ! 0 \t\t){ \t\t\tprintf(\"init lock fail\"); \t\t\tbreak; \t\t} \t\t//开启一定数量的线程 \t\tfor(i 0;i<min_thr_num ;i++){ \t\t\tpthread_create(&(pool >threads[i]), NULL, threadpool_thread, (void *)pool); \t\t\tprintf(\"start thread %#x...\\n\", (unsigned int)pool >threads[i]); \t\t} //开启一个控制线程 \t\tpthread_create(&pool >adjust_tid, NULL, adjust_thread, (void *)pool); \t\treturn pool; \t}while(0); \tthreadpool_free(pool); \treturn NULL; } //释放这一个线程池的空间 void threadpool_free(threadpool_t *pool){ \tif(pool NULL){ \t\treturn; \t} \tif(pool >task_queue){ \t\tfree(pool >task_queue); \t} \tif(pool >threads){ \t\tfree(pool >threads); \t\tpthread_mutex_lock(&(pool >lock)); \t\tpthread_mutex_destroy(&(pool >lock)); \t\tpthread_mutex_lock(&(pool >thread_counter)); \t\tpthread_mutex_destroy(&(pool >thread_counter)); \t\tpthread_cond_destroy(&(pool >queue_not_empty)); \t\tpthread_cond_destroy(&(pool >queue_not_full)); \t\tfree(pool); \t} \tpool NULL; } //销毁这一个线程池 void threadpool_destory(threadpool_t *pool){ \tif(pool NULL){ \t\treturn; \t} \tpool >shutdown true; //等待服务线程的结束 \tpthread_join(pool >adjust_tid, NULL); \tint i; \tfor(i 0; i < pool >live_thr_num; i++){ \t\tpthread_cond_broadcast(&(pool >queue_not_empty)); \t} \tfor(i 0; i < pool >live_thr_num; i++){ \t\tpthread_join(pool >threads[i], NULL); \t} \tthreadpool_free(pool); } //判断一个线程是不是还活着 int is_thread_alive(pthread_t tid){ \tint kill_rc pthread_kill(tid, 0); \tif(kill_rc ESRCH){ \t\treturn false; \t} \treturn true; } //控制线程 void *adjust_thread(void *threadpool){ \tint i; \tthreadpool_t *pool (threadpool_t *)threadpool; //只要这一个线程池还在, 这一个线程就在 \twhile(!pool >shutdown){ \t\tsleep(DEFAULT_TIME); \t\tpthread_mutex_lock(&(pool >lock)); \t\t \t\tint queue_size pool >queue_size; \t\tint live_thr_num pool >live_thr_num; \t\tpthread_mutex_unlock(&(pool >lock)); \t\tpthread_mutex_lock(&(pool >thread_counter)); \t\tint busy_thr_num pool >busy_thr_num;\t\t//获取忙线程的个数 \t\tpthread_mutex_unlock(&(pool >thread_counter)); \t\t \t\t//创建线程, 这时候等待队列中的任务数大于等待阈值，且存活的线程数小于最大线程数 \t\tif(queue_size > MIN_WAIT_TASK_NUM && live_thr_num < pool >max_thr_num){ \t\t\t//需要创建的线程数 \t\t\tpthread_mutex_lock(&(pool >lock)); \t\t\tint add 0; \t\t\t//获取可以使用的数组位置 \t\t\tfor(i 0; i < pool >max_thr_num && add < DEFAULT_THREAD_VARY && pool >live_thr_num < pool >max_thr_num; i++){ \t\t\t\tif(pool >threads[i] 0 !is_thread_alive(pool >threads[i])){ \t\t\t\t\tpthread_create(&pool >threads[i], NULL, threadpool_thread, (void *)pool); \t\t\t\t\tadd++; \t\t\t\t\tpool >live_thr_num++; printf(\"new thread %#x is created\\n\", (unsigned int)pool >threads[i]); \t\t\t\t} \t\t\t} \t\t\tpthread_mutex_unlock(&(pool >lock)); \t\t} \t\t//销毁线程，如果忙线程*2 < 存活线程数且存活线程数大于最小线程数 \t\tif((busy_thr_num * 2) < live_thr_num && live_thr_num > pool >min_thr_num){ \t\t\tpthread_mutex_lock(&(pool >lock)); \t\t\tpool >wait_exit_thr_num DEFAULT_THREAD_VARY;//需要销毁的线程数 \t\t\tpthread_mutex_unlock(&(pool >lock)); \t\t\t//唤醒空闲线程，让其自杀 \t\t\tfor(i 0; i < DEFAULT_THREAD_VARY; i++){ \t\t\t\tpthread_cond_signal(&(pool >queue_not_empty)); \t\t\t} \t\t} \t} } //给线程池里面加一个待处理的任务 int threadpool_add(threadpool_t *pool, void*(*function)(void *arg), void *arg){ \t \tpthread_mutex_lock(&(pool >lock)); \t//如果队列满了，调用wait阻塞 \twhile((pool >queue_size pool >queue_max_size) && (!pool >shutdown)){ \t\tpthread_cond_wait(&(pool >queue_not_full), &(pool >lock)); \t} \t//线程池已经关闭 \tif(pool >shutdown){ \t\tpthread_cond_broadcast(&(pool >queue_not_empty)); \t\tpthread_mutex_unlock(&(pool >lock)); \t\treturn 0; \t} \t//清空工作线程的回调函数的参数 \tif(pool >task_queue[pool >queue_rear].arg ! NULL){ \t\tpool >task_queue[pool >queue_rear].arg NULL; \t} \t//添加任务到任务队列中 \tpool >task_queue[pool >queue_rear].function function; \tpool >task_queue[pool >queue_rear].arg arg; \tpool >queue_rear (pool >queue_rear + 1) % pool >queue_max_size; \tpool >queue_size++; \t//添加任务后，队列不为空，唤醒线程池中的线程 \tpthread_cond_signal(&(pool >queue_not_empty)); \tpthread_mutex_unlock(&(pool >lock)); \treturn 0; } //模拟处理业务 void * process(void *arg){ \tprintf(\"thread %x working on task %d\\n\", (int)pthread_self(), *(int *)arg); \tsleep(1); \tprintf(\"task %d is end\\n\", *(int *)arg); \treturn NULL; } int main(void){ \tthreadpool_t *thp threadpool_create(3, 100, 100); \tprintf(\"pool inited\\n\"); \tint num[20]; \t//模拟添加任务 \tfor(int i 0; i < 20 ; i++){ \t\tnum[i] i; \t\tprintf(\"add task %d\\n\", i); \t\tthreadpool_add(thp, process, (void *)&num[i]); //添加任务 \t} \tsleep(10);//等待处理结束 \tthreadpool_destory(thp); } ``` > ```bash > ➜ 2024 4 7 MPIO ./a.out > start thread 0x2b192700...\t\t\t#开启线程池的基础线程 > thread 0x2b192700 is waiting > start thread 0x2a991700... > thread 0x2a991700 is waiting > start thread 0x2a190700... > thread 0x2a190700 is waiting > pool inited\t\t\t\t\t\t\t#初始化结束 > add task 0\t\t\t\t\t\t\t#加入任务 > add task 1 > add task 2 > thread 0x2b192700 start working\t\t #任务开始处理 > thread 723068672 working on task 0 > thread 0x2a991700 start working > thread 714675968 working on task 1 > thread 0x2a190700 start working > add task 3 > add task 4 > add task 5 > add task 6 > add task 7 > add task 8 > add task 9 > add task 10 > add task 11 > add task 12 > add task 13 > add task 14 > add task 15 > add task 16 > add task 17 > add task 18 > add task 19 > thread 706283264 working on task 2\t\t#任务处理结束 > task 0 is end > thread 0x2b192700 end working > thread 0x2b192700 start working > thread 723068672 working on task 3 > task 1 is end > thread 0x2a991700 end working > thread 0x2a991700 start working > thread 714675968 working on task 4 > task 2 is end > thread 0x2a190700 end working > thread 0x2a190700 start working > thread 706283264 working on task 5 > task 3 is end > thread 0x2b192700 end working > thread 0x2b192700 start working > thread 723068672 working on task 6 > task 4 is end > thread 0x2a991700 end working > thread 0x2a991700 start working > thread 714675968 working on task 7 > task 5 is end > thread 0x2a190700 end working > thread 0x2a190700 start working > thread 706283264 working on task 8 > new thread 0x2918e700 is created\t#由于线程数量比较少, 开始加入线程 > new thread 0x2898d700 is created > new thread 0x23fff700 is created > new thread 0x237fe700 is created > new thread 0x22ffd700 is created > new thread 0x227fc700 is created > new thread 0x21ffb700 is created > new thread 0x217fa700 is created > new thread 0x20ff9700 is created > new thread 0x207f8700 is created > thread 0x207f8700 start working > thread 0x2898d700 start working > thread 681105152 working on task 11 > thread 0x23fff700 start working > thread 603977472 working on task 12 > thread 545228544 working on task 9 > thread 0x237fe700 start working > thread 595584768 working on task 13 > thread 0x2918e700 start working > thread 689497856 working on task 10 > thread 0x22ffd700 start working > thread 587192064 working on task 14 > thread 0x227fc700 start working > thread 578799360 working on task 15 > thread 0x21ffb700 start working > thread 570406656 working on task 16 > thread 0x217fa700 start working > thread 562013952 working on task 17 > thread 0x20ff9700 start working > thread 553621248 working on task 18 > task 6 is end > task 8 is end > task 7 is end > thread 0x2a190700 end working > thread 0x2b192700 end working > thread 0x2b192700 is waiting > thread 0x2a991700 end working > thread 0x2a991700 is waiting > thread 0x2a190700 start working > thread 706283264 working on task 19 > task 11 is end > thread 0x2898d700 end working > task 10 is end > thread 0x2918e700 end working > task 16 is end > thread 0x21ffb700 end working > task 12 is end > thread 0x23fff700 end working > task 15 is end > thread 0x227fc700 end working > task 18 is end > thread 0x20ff9700 end working > task 17 is end > thread 0x217fa700 end working > task 13 is end > thread 0x237fe700 end working > thread 0x2898d700 is waiting\t\t#线程开始空闲 > thread 0x2918e700 is waiting > task 9 is end > thread 0x207f8700 end working > task 19 is end > thread 0x2a190700 end working > task 14 is end > thread 0x22ffd700 end working > thread 0x21ffb700 is waiting > thread 0x23fff700 is waiting > thread 0x227fc700 is waiting > thread 0x20ff9700 is waiting > thread 0x217fa700 is waiting > thread 0x237fe700 is waiting > thread 0x207f8700 is waiting > thread 0x2a190700 is waiting > thread 0x22ffd700 is waiting > thread 0x2918e700 is exiting\t\t\t#空闲任务不需要了 > thread 0x2b192700 is exiting > thread 0x2a991700 is exiting > thread 0x2898d700 is exiting > thread 0x21ffb700 is exiting > thread 0x23fff700 is exiting > thread 0x227fc700 is exiting > thread 0x217fa700 is exiting > thread 0x237fe700 is exiting > thread 0x20ff9700 is exiting > thread 0x207f8700 will exit\t\t\t\t#销毁线程池的时候还有三个线程 > thread 0x2a190700 will exit > thread 0x22ffd700 will exit > ```"},"/note/Linux/Linux网络编程/2024-4-16-07简单的Web服务器.html":{"title":"简单的Web服务器","content":" layout: post title: \"简单的Web服务器\" date: 2024 4 14 15:39:08 +0800 tags: Linux 网络 # 简单的Web服务器"},"/note/Linux/Linux网络编程/2024-4-13-05本地套接字.html":{"title":"本地套接字","content":" layout: post title: \"本地套接字\" date: 2024 3 10 15:39:08 +0800 tags: Linux 网络 # 本地套接字 这是一个可靠的本地通信手段 > [本地套接字（domain）通信_本地通信套接字 CSDN博客](https://blog.csdn.net/qq_43290168/article/details/119078595) 用于本地通信, 对比网络编程, TCP C/S模型, 需要注意 1. socket函数的参数domain: AF_INET > AF_UNIX / AF_LOCAL, 使用协议改变, type可以使用SOCK_STREAM / SOCK_DGRAM都可以 > 在man手册的unix有AF_UNIX的定义 > > The AF_UNIX (also known as AF_LOCAL) socket family is used to communi‐ > cate between processes on the same machine efficiently. Traditionally, > UNIX domain sockets can be either unnamed, or bound to a filesystem > pathname (marked as being of type socket). Linux also supports an > abstract namespace which is independent of the filesystem. 2. bind这时候不再使用sockaddr_in, 使用sockaddr_un > ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404032141315.png) ```c struct sockaddr_un { __kernel_sa_family_t sun_family; /* AF_UNIX */ char sun_path[UNIX_PATH_MAX]; /* pathname */ }; ``` > 传入的时候这一个结构体的大小是2(使用的协议)+字符串的大小 ```c #define offsetof(type, member) ((int)&((type *)0) >MEMBER) size offsetof(struct sockaddr_un, sun_path) + strlen(un.sun_path); ``` > 可以使用这一个宏求这一个结构体的实际使用的大小(这一个宏返回path在这一个结构体里面的偏移), 也可以直接使用sizeof 3. UNIX Domain Socket的地址是一个socket类型的文件在文件系统中的路径，这个socket文件由bind()调用创建，如果调用bind()时该文件已存在，则bind()错误返回。bind成功的话会创建一个socket, 因此为了保证这一个成功, 可以在这之前使用unlink ```c #include <ctype.h> #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> #include <sys/socket.h> #include <stddef.h> #include <sys/types.h> #include <string.h> #include <sys/un.h> #include <arpa/inet.h> #define SERV_ADDR\t\t\t\"serv.addr\" int main(void){ \tint lfd, cfd, len, size, i; \tstruct sockaddr_un servaddr, cliaddr; \tchar buf[1024]; \t//获取监听使用的套接字 \tlfd socket(AF_UNIX, SOCK_STREAM, 0); \tif(lfd 1){ \t\tperror(\"socket error\"); \t\texit(1); \t} //初始化以及绑定自己使用的信息 \tbzero(&servaddr, sizeof(servaddr)); \tservaddr.sun_family AF_UNIX; \tstrcpy(servaddr.sun_path, SERV_ADDR); \tlen offsetof(struct sockaddr_un, sun_path) + strlen(servaddr.sun_path); \tunlink(SERV_ADDR); \tbind(lfd, (struct sockaddr*)&servaddr, len); \t//设置监听的数量 \tlisten(lfd, 20); \twhile(1){ \t\tlen sizeof(cliaddr); //等待连接 \t\tcfd accept(lfd, (struct sockaddr *)&cliaddr, (socklen_t *)&len); \t\tif(cfd < 0){ \t\t\tperror(\"accept error\"); \t\t\texit(1); \t\t} \t\tlen offsetof(struct sockaddr_un, sun_path); \t\tcliaddr.sun_path[len] '\\0'; \t\tprintf(\"client bind filename %s\\n\", cliaddr.sun_path); \t\twhile((size read(cfd, buf, sizeof(buf))) > 0){ \t\t\tprintf(\"in\\n\"); \t\t\tfor(i 0;i<size;i++){ \t\t\t\tbuf[i] toupper(buf[i]); \t\t\t} \t\t\twrite(cfd, buf, size); \t\t} \t\tprintf(\"close\\n\"); \t\tclose(cfd); \t} \tclose(lfd); \treturn 0; } ``` ```c #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> #include <sys/socket.h> #include <sys/socket.h> #include <sys/un.h> #include <stddef.h> #define SERV_ADDR\t\t\t\"serv.addr\" #define CLIE_ADDR\t\t\t\"clie.addr\" int main(void){ \tint cfd, len; \tstruct sockaddr_un servaddr, cliaddr; \tchar buf[1024]; \t//创建套接字 \tcfd socket(AF_UNIX, SOCK_STREAM, 0); //初始化以及绑定自己使用的信息 \tbzero(&cliaddr, sizeof(cliaddr)); \tcliaddr.sun_family AF_UNIX; \tstrcpy(cliaddr.sun_path, CLIE_ADDR); \tunlink(CLIE_ADDR); \tlen offsetof(struct sockaddr_un, sun_path) + strlen(cliaddr.sun_path); \tint ret bind(cfd, (struct sockaddr *)&cliaddr, len); \tif(ret < 0){ \t\tperror(\"bind\"); \t\texit(1); \t} \tbzero(&servaddr, sizeof(servaddr)); \t//初始化serv使用的信息 \tservaddr.sun_family AF_UNIX; \tstrcpy(servaddr.sun_path, SERV_ADDR); \tlen offsetof(struct sockaddr_un, sun_path) + strlen(servaddr.sun_path); //建立连接 \tret connect(cfd, (struct sockaddr *)&servaddr,len); \tif(ret < 0){ \t\tperror(\"connect error\"); \t\texit(1); \t} \twhile(fgets(buf, sizeof(buf), stdin)! NULL){ \t\twrite(cfd, buf, strlen(buf)); \t\tlen read(cfd, buf, sizeof(buf)); \t\tif(len > 0) \t\t\twrite(STDOUT_FILENO, buf, len); \t\telse \t\t\texit(0); \t} \tclose(cfd); } ``` > 客户端连接的时候可以不使用bind, 这个时候连接的时候使用的文件名为空, 不建议使用 > > 在使用本地套接字的时候使用的结构体sockaddr_un需要头文件`<sys/un.h>` ## 和网络套接字的对比 + server 1. socket 使用的协议不同AF_INET(网络), AF_UNIX(本地) 2. bind使用的结构体不同, 分别使用的是struct sockaddr_in和struct sockaddr_un, 初始化的时候使用的协议不同, 一个使用ip和端口, 另一个使用文件名 3. 本地套接字使用的时候最好使用unlink把这一个文件删除一下 4. 之后使用accept函数的时候传出参数sockaddr不同 + 客户端 1. socket函数的第一个参数不同 2. 网络使用的时候可以隐式绑定, 使用本地套接字的时候不能这么使用 3. 之后connect的时候使用的结构体不同"},"/note/Linux/Linux网络编程/2024-4-17-09CSS.html":{"title":"CSS","content":" layout: post title: \"CSS\" date: 2024 4 14 15:39:08 +0800 tags: Linux 网络 https://docs.geeksman.com/front end/2.front end css.html # CSS Cascading Style Sheets层叠样式表 是一种用于定义网页样式和布局的样式表语言。它与 HTML 一起用于构建 Web 页面，HTML 负责定义页面的结构和内容，而 CSS 则负责控制页面的外观和样式。 当谈到 HTML 和 CSS 的关系时，你可以将 HTML 想象成一座建筑的结构，而 CSS 则是这座建筑的外观和装饰。 HTML（结构） 就像是一座建筑的骨架和框架。它定义了建筑的基本结构，包括墙壁、窗户、门、楼梯等。在网页开发中，HTML 定义了文本、图片、链接、表格、表单等基本元素的结构，它告诉浏览器应该在页面上放置哪些内容，但没有指定它们的外观。就像建筑的骨架告诉你建筑有哪些房间，但不告诉你它们的颜色或装饰。 CSS（样式） 就像是建筑的粉刷、装饰和布局。它决定了建筑的外观，包括墙壁的颜色、窗户的形状、门的样式以及家具的摆放。在网页开发中，CSS 用于定义文本的颜色、字体、间距、背景颜色，以及页面的布局和排列方式。就像建筑的外观和装饰可以让你的建筑变得独特而吸引人，CSS 可以让你的网页看起来吸引人且专业。 所以，HTML 提供了网页的结构和内容，而 CSS 负责定义这些内容的外观和样式。它们在前端开发中密切合作，使开发者能够创建具有良好结构和视觉吸引力的网页。就像建筑师和室内设计师一起合作，建立了一个坚固而美观的建筑。 CSS（Cascading Style Sheets）的语法用于定义网页的样式和外观。CSS 规则通常由选择器、属性和属性值组成，多个规则可以组合在一起，以便同时应用多个样式，以下是 CSS 的基本语法： ## 语法 ```c 选择器 { 属性1: 属性值1; 属性2: 属性值2; } ``` 1. 声明的每一行属性，都需要以英文分号结尾； 2. 声明中的所有属性和值都是以键值对这种形式出现的； 3. 选择器的声明中可以写无数条属性 总的来说，CSS 的语法就是选择一个元素，为它指定属性，然后为这些属性指定值。你可以使用不同的选择器来定位不同的元素，然后定义它们的样式以实现所需的外观。 CSS 样式表通常包含多个规则，这些规则会按照特定的优先级和级联规则（Cascading）应用到页面上，以确保一致的外观。 ### 导入 在头部加一个style标签 ![image 20240417205835104](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404172058142.png) 在 CSS 中，你可以使用不同的方式来导入样式表，以便将样式应用到 HTML 文档。下面是三种常见的 CSS 导入方式： 1. `内联样式（Inline Styles）`：内联样式是将 CSS 样式直接嵌入到 HTML 元素中的一种方式。你可以在 HTML 标签的 style 属性中定义样式规则。这些样式仅适用于特定元素，优先级较高。 示例： ```html <h1 style \"color: blue; font size: 30px;\">这是一段内联样式文本。</h1> ``` 2. `内部样式表（Internal Stylesheet）`：内部样式表是将 CSS 样式放置在 HTML 文档的 `<head>` 部分的 `<style>` 标签内。这些样式将应用于整个文档，但仍具有较高的优先级。 示例： ```html <head> <style> h2 { color: red; font size: 16px; } </style> </head> <body> <h2>这是一段内部样式表控制文本。</h2> </body> ``` ![image 20240417210841943](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404172108976.png) 3. `外部样式表（External Stylesheet）`：外部样式表是将 CSS 样式定义在一个单独的 .css 文件中，并使用 `<link>` 元素将其链接到 HTML 文档中。这是一种最常用的方式，允许你在多个页面上重用相同的样式。外部样式表具有较低的优先级。 示例： 在该 HTML 文件目录下创建名为 `css` 的目录，并创建 `style.css` 的外部样式表文件，在其中加入以下代码： ```css p { color: purple; font size: 16px; } ``` 在 HTML 文档中链接外部样式表： ```html <head> <link rel \"stylesheet\" type \"text/css\" href \"./css/style.css\"> </head> <body> <p>这是一段外部样式表控制文本。</p> </body> ``` 使用外部样式表的优势在于它可以帮助你更好地维护和管理样式，使样式与内容分离，提高代码的可维护性。根据需要，你可以选择其中一种或多种导入方式，具体取决于项目的要求和结构。 > 三种导入方式的优先级 > > 不同的导入方式（内联样式、内部样式表、外部样式表）具有不同的优先级，优先级高的会覆盖掉优先级低的样式：`内联样式` > `内部样式表` > `外部样式表` ## 选择器（Selectors） 选择器用于选择要应用样式的 HTML 元素。可以选择所有的元素、特定元素、特定类或 ID 的元素，甚至更多。选择器位于规则的开头。 元素选择器：选择特定类型的 HTML 元素（例如，`p` 选择所有段落）。 类选择器：选择具有特定类的元素（例如，`.highlight` 选择具有 highlight 类的元素）。 ID 选择器：选择具有特定 ID 的元素（例如，`#header` 选择 ID 为 header 的元素）。 通用选择器 *：选择页面上所有的元素。 子元素选择器：选择直接位于父元素内部的子元素。语法：`父元素 > 子元素`，例如，`ul > li` 选择了 `<ul>` 元素内直接包含的 `<li>` 元素。 后代选择器（包含选择器）：选择元素的后代元素。语法：`元素名 元素名`，例如，`ul li` 选择了所有在 `<ul>` 元素内部的 `<li>` 元素。 相邻兄弟选择器：选择紧邻在另一个元素后面的兄弟元素。`元素名 + 元素名`，例如，`h2 + p` 选择了与 `<h2>` 相邻的 `<p>` 元素。 伪类选择器：选择 HTML 文档中的元素的特定状态或位置，而不仅仅是元素自身的属性。伪类选择器以冒号（:）开头，通常用于为用户交互、文档结构或其他条件下的元素应用样式。这些条件可以包括鼠标悬停（`:hover` ）、链接状态（`:active`）、第一个子元素（`:first child`）等。 ```html <!DOCTYPE html> <html lang \"en\"> <head> <title>CSS 选择器</title> <style> /* 元素选择器 */ h2 { color: aqua; } /* 类选择器 */ .highlight { background color: yellow; } /* ID选择器 */ #header { font size: 35px; } /* 子元素选择器 */ .box > .element { color: yellowgreen; } /* 后代选择器 */ div .element { font size: x large; color: brown; } /* 相邻兄弟选择器 */ h3 + p { color: red; } /* 通用兄弟选择器 */ h4 ~ p { background color: #1b91ff; } /* 伪类选择器 */ .hover:hover { background color: blueviolet; } /* 通用选择器 */ * { font family: 'KaiTi'; font weight: bold; } </style> </head> <body> <h1>不同类型的CSS选择器示例</h1> <h2>这是一个元素选择器示例</h2> <h3 class \"highlight\">这是一个类选择器示例</h3> <h4 id \"header\">这是一个ID选择器示例</h4> <div class \"box\"> <p class \"element\">这是一个子元素选择器示例</p> <div> <p class \"element\">这是一个后代选择器示例</p> </div> </div> <p>选中标签之前的 p 标签</p> <h3>这是相邻兄弟选择器示例</h3> <p>相邻兄弟元素示例</p> <h4>这是通用兄弟元素选择器示例</h4> <p>通用兄弟元素示例</p> <h3 class \"hover\">这是一个 hover 伪类选择器示例</h3> </body> </html> ``` 选择器的优先级 CSS 中，样式的优先级顺序为：`内联样式 > ID选择器 > 类选择器、属性选择器、伪类选择器 > 元素选择器 > 伪元素选择器 > 通用选择器`，且在样式表链接时后链接的规则覆盖先链接的规则，而! important标志可覆盖所有其他规则。"},"/note/Linux/Linux网络编程/2024-4-14-06libevent库.html":{"title":"libevent库","content":" layout: post title: \"libevent库\" date: 2024 4 14 15:39:08 +0800 tags: Linux 网络 # libevent库 这一个开源, 精简, 跨平台的库, 专注于网络通信 有两个版本比较稳定1.4和2.0 > 1.4比较简单适合用于学习 > > 使用的话建议使用2.0 这两个版本的接口是不兼容的 [libevent官网](https://libevent.org/) [libevent源码深度剖析 张亮_libevent源码深度剖析是c语言 CSDN博客](https://blog.csdn.net/xp178171640/article/details/105490027) 从官网下载以后可以使用`./configure` 检查安装环境以及生成Makefile, 之后使用make, 生成.o或者可执行文件, 最后`sudo make install`把必要的资源拷贝到系统的指定目录 > 一般直接看readme文件 建立成功以后, 可以使用sample目录里面运行demo验证安装情况 ```bash ➜ sample gcc hello world.c o hello levent ``` > 编译的时候需要链接这一个库, 这一个库的实际的安装目录是/usr/local/lib文件夹 > > ![image 20240414125346381](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404141253456.png) ![image 20240414115435365](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404141154664.png) ## 特点 1）事件驱动（event driven），高性能; 2）轻量级，专注于网络，不如ACE那么臃肿庞大； 3）源代码相当精炼、易读； 4）跨平台，支持Windows、Linux、*BSD和Mac Os； 5）支持多种I/O多路复用技术， epoll、poll、dev/poll、select和kqueue等； 6）支持I/O，定时器和信号等事件； 7）注册事件优先级； ## 框架 1. 创建event_base ```c #include <event2/event.h> struct event_base *event_base_new(void); struct event_base *base event_base_new(); ``` 2. 创建事件event 事件有两种, 常规的事件event, 以及bufferevent ```c struct event *event_new(struct event_base* base, evutil_socket_t fd, short what, event_callback_fn cd, void *arg); struct bufferevent * bufferevent_socket_new(struct event_base *base, evutil_socket_t fd, enum bufferevent_options options); ``` > what: EV_READ > > ​\t\t EV_WRITE > > ​\t\t EV_PERSIST 持续触发 > > cd : 回调函数 3. 把事件放到base上面 ```c int event_add(struct event *ev, const struct timeval *tv) ``` 4. 循环监听事件满足 ```c int event_base_dispatch(struct event_base *event_base) { return (event_base_loop(event_base, 0)); //调用event_base_loop() } ``` > event_new函数里面指定了参数EV_PERSIST才可以持续触发, 否则只触发一次, 之后跳出循环 > > 通常使用EV_WRITEEV_PERSIST, EV_READEV_PERSIST ```c int event_base_loopexit(struct event_base*base, const struct timeval*tv); ``` > 指定时间以后退出循环 ```c int event_base_loopbreak(struct event_base*base); ``` > 立即停止循环 5. 释放eventbase ```c void bufferevent_free(struct bufferevent *bev); ``` ## 示例分析 这是一个事件异步通信模型, 这一个文件里的所有都是事件, 主要依赖回调函数 ```c #include <string.h> #include <errno.h> #include <stdio.h> #include <signal.h> #ifndef _WIN32 #include <netinet/in.h> # ifdef _XOPEN_SOURCE_EXTENDED # include <arpa/inet.h> # endif #include <sys/socket.h> #endif #include <event2/bufferevent.h> #include <event2/buffer.h> #include <event2/listener.h> #include <event2/util.h> #include <event2/event.h> static const char MESSAGE[] \"Hello, World!\\n\"; static const int PORT 9995; //cb指的是call back回调函数 static void listener_cb(struct evconnlistener *, evutil_socket_t, struct sockaddr *, int socklen, void *); static void conn_writecb(struct bufferevent *, void *); static void conn_eventcb(struct bufferevent *, short, void *); static void signal_cb(evutil_socket_t, short, void *); int main(int argc, char **argv) { \tstruct event_base *base; \tstruct evconnlistener *listener;//用于监听 \tstruct event *signal_event;\t\t//一个事件 \tstruct sockaddr_in sin;\t\t\t//socket结构 #ifdef _WIN32 \tWSADATA wsa_data; \tWSAStartup(0x0201, &wsa_data); #endif \tbase event_base_new();\t\t//获取一个底座 \tif (!base) { \t\tfprintf(stderr, \"Could not initialize libevent!\\n\"); \t\treturn 1; \t} \tmemset(&sin, 0, sizeof(sin)); \tsin.sin_family AF_INET; \tsin.sin_port htons(PORT);\t\t//这里的ip地址使用的是0, 也就是监听所有的ip \t//这一个相当于socket, bind, listen, accept \tlistener evconnlistener_new_bind(base, listener_cb, (void *)base, \t LEV_OPT_REUSEABLELEV_OPT_CLOSE_ON_FREE, 1, \t (struct sockaddr*)&sin, \t sizeof(sin)); \tif (!listener) { \t\tfprintf(stderr, \"Could not create a listener!\\n\"); \t\treturn 1; \t} \t//获取另一个事件, 这是一个信号事件 \tsignal_event evsignal_new(base, SIGINT, signal_cb, (void *)base); \tif (!signal_event event_add(signal_event, NULL)<0) { \t\tfprintf(stderr, \"Could not create/add a signal event!\\n\"); \t\treturn 1; \t} \t//这一个这一个相当于while和epoll_wait \tevent_base_dispatch(base); \t//这三个函数很可能到不了 \tevconnlistener_free(listener); \tevent_free(signal_event); \tevent_base_free(base); \tprintf(\"done\\n\"); \treturn 0; } static void listener_cb(struct evconnlistener *listener, evutil_socket_t fd, struct sockaddr *sa, int socklen, void *user_data) { \tstruct event_base *base user_data; \tstruct bufferevent *bev; \tbev bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE); \tif (!bev) { \t\tfprintf(stderr, \"Error constructing bufferevent!\"); \t\tevent_base_loopbreak(base); \t\treturn; \t} \tbufferevent_setcb(bev, NULL, conn_writecb, conn_eventcb, NULL); \tbufferevent_enable(bev, EV_WRITE); \tbufferevent_disable(bev, EV_READ); \tbufferevent_write(bev, MESSAGE, strlen(MESSAGE)); } static void conn_writecb(struct bufferevent *bev, void *user_data) { \tstruct evbuffer *output bufferevent_get_output(bev); \tif (evbuffer_get_length(output) 0) { \t\tprintf(\"flushed answer\\n\"); \t\tbufferevent_free(bev); \t} } static void conn_eventcb(struct bufferevent *bev, short events, void *user_data) { \tif (events & BEV_EVENT_EOF) { \t\tprintf(\"Connection closed.\\n\"); \t} else if (events & BEV_EVENT_ERROR) { \t\tprintf(\"Got an error on the connection: %s\\n\", \t\t strerror(errno));/*XXX win32*/ \t} \t/* None of the other events can happen here, since we haven't enabled \t * timeouts */ \tbufferevent_free(bev); } static void signal_cb(evutil_socket_t sig, short events, void *user_data) { \tstruct event_base *base user_data; \tstruct timeval delay { 2, 0 }; \t//这是一个信号的回调函数 \tprintf(\"Caught an interrupt signal; exiting cleanly in two seconds.\\n\"); \tevent_base_loopexit(base, &delay); } ``` ## 常用函数 ### event_base_new创建base ```c #include <event2/event.h> struct event_base *event_base_new(void); struct event_base *base event_base_new(); ``` ### event_base_free销毁base ```c void event_base_free(struct event_base *base); ``` ### event_base_dispatch开启循环 ```c int event_base_dispatch(struct event_base *event_base); ``` ### event_new创建事件 ```c struct event *event_new(struct event_base*base, evutil_socket_t fd, short what, event_callback_fn cb, void *arg); ``` > 在这一个事件base里面加入一个事件 > > base: 使用的base > > fd: 监听的文件描述符 > > what: 监听的这一个文件的什么事件(读写异常) > > > + 常用 > > > > 读事件EV_READ > > > > 写事件EV_ERITE > > > > 持续触发EV_PERSIST, 一般是配合event_base_dispatch函数使用 > > > > ```c > > #define EV_TIMEOUT 0x01\t\t//这一个废弃了 > > #define EV_READ 0x02 > > #define EV_WRITE 0x04 > > #define EV_SIGNAL 0x08 > > #define EV_PERSIST 0x10 > > #define EV_ET 0x20 > > ``` > > cb: 回调函数 > > > `typedef void(*event_callback_fn)(evutil_socket_t fd, short, void *)` > > > > evutil_socket_t实际就是一个int类型, short是上面的what和arg > > arg: 这一个函数的参数 > > 返回值是成功创建的事件对象 ### event_add添加事件 ```c int event_add(struct event *ev, const struct timeval *tv); ``` > ev: event_new函数的返回值 > > tv: 时间, NULL这一个不会超时, 为非零的时候, 这一个事件没有触发也会被回调 > > 不要设置 tv 为希望超时事件执行的时间。如果在 2010 年 1 月 1 日设置 “tv >tv_sec time(NULL)+10;”,超时事件将会等待40年,而不是10秒 > > `struct timeval delay { 2, 0 };` > > 返回值 : 成功0, 失败 1 ### event_free销毁事件 ```c void event_free(struct event *event); ``` ### event_del事件移出base ```c int event_del(struct event *ev); ``` ### 未决和非未决 未决: 有资格被处理, 但是还没有被处理 非未决: 没有资格被处理 ![image 20240415222945402](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404152229527.png) ## 实际使用 ```c #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> #include <event2/event.h> #include <fcntl.h> #include <string.h> #include <sys/stat.h> void write_cb(evutil_socket_t fd, short what, void *arg){ \tchar buf[1024]; \tstatic int num 0; \tsprintf(buf, \"hello world %d\\n\", num++); \twrite(fd, buf, strlen(buf)+1); \tsleep(1); } int main(void){ \tint fd open(\"myfifo\", O_WRONLY O_NONBLOCK); \tif(fd 1){ \t\tperror(\"open error\"); \t\texit(1); \t} \tstruct event_base *base NULL; \tbase event_base_new(); \tstruct event *event event_new(base, fd, EV_WRITEEV_PERSIST, write_cb, NULL); \tevent_add(event, NULL); \tevent_base_dispatch(base); \tevent_free(event); \tevent_base_free(base); \tclose(fd); \treturn 0; } ``` ```c #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> #include <sys/types.h> #include <sys/stat.h> #include <string.h> #include <event2/event.h> #include \"fcntl.h\" void read_cb(evutil_socket_t fd, short what, void *arg){ \tchar buf[1024]; \tint len read(fd, buf, sizeof(buf)); \tprintf(\"read event: %s \\n\", what & EV_READ ? \"Yse\" :\"No\" ); \tprintf(\"data len %d, buf %s\\n\", len, buf); \tsleep(1); } int main(void){ \tunlink(\"myfifo\"); \tmkfifo(\"myfifo\", 0664); \tint fd open(\"myfifo\", O_RDONLY O_NONBLOCK); \tif(fd 1){ \t\tperror(\"open error\"); \t\texit(1); \t} \tstruct event_base*base; \tbase event_base_new(); \tstruct event* ev NULL; \tev event_new(base, fd, EV_READ EV_PERSIST, read_cb, NULL); \t//添加事件，不加时间限制 \tevent_add(ev, NULL); \t//开始循环 \tevent_base_dispatch(base); \tevent_free(ev); \tevent_base_free(base); \tclose(fd); \treturn 0; } ``` ## 其他函数 ```c const char **event_get_supported_methods(void); ``` > 查看这一个系统支持的多路IO, epoll, poll, select之类的 ```c const char * event_base_get_method(const struct event_base * base); ``` > 查看现在使用的IO ```c int event_reinit(struct event_base *base); ``` > 查看fork以后使用的这一个重新初始化这一个base ```c #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> #include <event2/event.h> int main(void){ \tstruct event_base *base; \tbase event_base_new(); \tconst char **buf; \tif(!base){ \t\tprintf(\"Could not initialize libevent!\\n\"); \t\treturn 1; \t} \tbuf event_get_supported_methods();//获取支持的IO \tprintf(\"Using Libevent with backend method %s.\\n\", event_base_get_method(base));//获取使用IO \tprintf(\"Starting Libevent %s. Available methods are:\\n\", event_get_version());//获取版本 \tfor(int i 0; buf[i] ! NULL; i++){ \t\tprintf(\"%s\\n\", buf[i]); \t} } ``` > ```bash > ➜ 2024 4 14 libvent ./event > Using Libevent with backend method epoll. > Starting Libevent 2.1.8 stable. Available methods are: > epoll > poll > select > ``` ## 带缓冲区的事件 > **需要使用头文件<event2/bufferevent.h>** bufferevent, 里面有两个buffer, 一个读一个写, 使用队列实现, 读走以后就没有了, 先进先出 读 : 有数据 > 读回调函数 > 使用bufferevent_read > 把数据读出来 写: 使用bufferevent_write > 向缓冲区写数据 > 缓冲区有数据自动写出 > 写完 > 回调函数 > 在这里面就不能使用read和write函数了 > > 实际使用的时候需要在读缓冲回调函数里面使用bufferevent_read读取数据, 读取以后处理数据, 之后写入 > > 写缓冲的回调函数用处不大 ### bufferevent_socket_new ```c struct bufferevent *bufferevent_socket_new(struct event_base *base,evutil_socket_t fd,enum bufferevent_options options); ``` > base 是 event_base,options 是表示 bufferevent 选项 (BEV_OPT_CLOSE_ON_FREE 等) 的位掩码 > > fd是一个可选的表示套接字的文件 描述符。如果想以后设置文件描述符,可以设置fd为 1。 成功时函数返回一个 bufferevent,失败则返回 NULL。 > > optiona: > > + BEV_OPT_CLOSE_ON_FREE：释放 bufferevent 时关闭底层传输端口。这将关闭底 层套接字，释放底层 bufferevent 等。 > > > 主要使用的是这一个 > > + BEV_OPT_THREADSAFE：自动为 bufferevent 分配锁，这样就可以安全地在多个线 程中使用 bufferevent。 > + BEV_OPT_DEFER_CALLBACKS：设置这个标志时，bufferevent 延迟所有回调，如 上所述。 > + BEV_OPT_UNLOCK_CALLBACKS：默认情况下，如果设置 bufferevent 为线程安全 的，则 bufferevent 会在调用用户提供的回调时进行锁定。设置这个选项会让 libevent 在执行回调的时候不进行锁定。 ### bufferevent_free ```c void bufferevent_free(struct bufferevent *bev); ``` ### bufferevent_setcb ```c typedef void (*bufferevent_data_cb)(struct bufferevent *bev, void *ctx); typedef void (*bufferevent_event_cb)(struct bufferevent *bev, short events, void *ctx); void bufferevent_setcb(struct bufferevent *bufev, bufferevent_data_cb readcb, bufferevent_data_cb writecb, bufferevent_event_cb eventcb, void *cbarg); void bufferevent_getcb(struct bufferevent *bufev, bufferevent_data_cb *readcb_ptr, bufferevent_data_cb *writecb_ptr, bufferevent_event_cb *eventcb_ptr, void **cbarg_ptr); ``` > 这两个缓冲区的回调函数 > > readcb_ptr: 读缓冲回调 > > writecb: 写缓冲回调 > > eventcb: 事件回调, 用于处理状态以及异常 > > cbarg: 回调使用的参数 > > + 回调函数参数 > > events: 实际的事件 > > > BEV_EVENT_READING：读取操作时发生某事件，具体是哪种事件请看其他标志。 > > > > BEV_EVENT_WRITING：写入操作时发生某事件，具体是哪种事件请看其他标志。 > > > > BEV_EVENT_ERROR ： 操作时发生错误。关于错误的更多信息，请调用 EVUTIL_SOCKET_ERROR()。 > > > > BEV_EVENT_TIMEOUT：发生超时。 > > > > BEV_EVENT_EOF：遇到文件结束指示。 > > > > BEV_EVENT_CONNECTED：请求的连接过程已经完成 > > ctx : 传递的参数 ### bufferevent_read ````c size_t bufferevent_read(struct bufferevent *bufev, void *data, size_t size); ```` ### bufferevent_write ```c int bufferevent_write(struct bufferevent *bufev,const void *data, size_t size); ``` ### bufferevent_enable ```c void bufferevent_enable(struct bufferevent *bufev, short events); void bufferevent_disable(struct bufferevent *bufev, short events); ``` > 启用以及禁用缓冲区 > > 可以启用或者禁用 bufferevent 上的 EV_READ、EV_WRITE 或者 EV_READ EV_WRITE 事件。 > > 默认的时候读是disable, 写是enable的 ```c short bufferevent_get_enabled(struct bufferevent *bufev); ``` > 获取缓冲区状态 ## 网络通信 ### 流程 > 使用头文件<event2/listener.h> + 客户端 socket, connect ```c int bufferevent_socket_connect(struct bufferevent *bev, struct sockaddr *address, int addrlen); ``` > 可以使用这一个函数进行封装使用 > > address, addrlen实际就是connect函数的参数2和参数3 + 服务器端 socket, bind, listen, accept ```c struct evconnlistener *evconnlistener_new(struct event_base *base, evconnlistener_cb cb, void *ptr, unsigned flags, int backlog, evutil_socket_t fd);//建立一个监听器, 这一个不多使用(了解) struct evconnlistener *evconnlistener_new_bind(struct event_base *base, evconnlistener_cb cb, void *ptr, unsigned flags, int backlog,const struct sockaddr *sa, int socklen);//主要使用 void evconnlistener_free(struct evconnlistener *lev); ``` > cb: 回调函数 > > ptr : 回调使用的参数 > > flags: 标志 > > > 主要使用的有两个 > > > > 1. LEV_OPT_CLOSE_ON_FRE, 释放bufferevent时候关闭这一个传输端口, 释放底层套接字 > > 2. LEV_OPT_REUSABLE: 端口可以复用 > > backlog: listen的第二个参数, 传 1表示使用最大值 > > sa: 服务器的IP+Port, 这一个是服务器自己的地址结构 > > 成功的话返回一个监听器 ```c typedef void (*evconnlistener_cb)(struct evconnlistener *listener, evutil_socket_t fd, struct sockaddr *address, int socklen, void *arg); ``` > 这一个是他的回调函数, 会在客户端连接的时候调用这一个函数 > > listener: evconnlistener_new_bind函数的返回值 > > fd: 用于通信的文件描述符 > > address: 客户端的IP+端口 ### 实际使用 + 服务器端 1. 创建event_base 2. 建立一个监听服务器evconnlistener_new_bind, 设置一个回调函数, 有连接的时候这一个回调函数会被调用, 获取fd 3. 封装listner_cb, 在这一个函数里面和客户端通信 4. 在连接回调函数里面使用获取的fd创建一个buffer_event, 使用bufferevent_socket_new 5. 设置一下回调函数, bufferevent_setcb, 给bufferevent的read, write和event设置回调函数 6. 开启读写缓冲区 7. 初始化回调函数, 监听的事件满足的时候, 回调函数被调用, 在read_cb里面使用bufferevent_read 8. 启动监听event_base_dispatch 9. 释放 ```c #include <stdio.h> #include <string.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> #include <event2/event.h> #include <event2/listener.h> #include <event2/bufferevent.h> #include <arpa/inet.h> #include <ctype.h> void event_cb(struct bufferevent *bev, short events, void *arg){ \tif(events & BEV_EVENT_EOF){ \t\tprintf(\"connection closed\\n\"); \t}else if(events & BEV_EVENT_ERROR){ \t\tprintf(\"some other error\\n\"); \t} \tbufferevent_free(bev); \tprintf(\"event_cb\\n\"); } void read_cb(struct bufferevent *bev, void *arg){ \tchar buf[1024]; \tint len bufferevent_read(bev, buf, sizeof(buf)); \tif(len < 0){ \t\tprintf(\"read_cb: connection closed\\n\"); \t\tbufferevent_free(bev); \t\treturn; \t} \tbuf[len] '\\0'; \tprintf(\"read_cb: %s\\n\", buf); \tfor(int i 0;i<len;i++){ \t\tbuf[i] toupper(buf[i]); \t} \tbufferevent_write(bev, buf, len); } void write_cb(struct bufferevent *bev, void *arg){ \tprintf(\"write_cb\\n\"); } void listener_cb(struct evconnlistener *listener, evutil_socket_t fd, \t\tstruct sockaddr *addr, int socklen, void *arg){ \tchar buf[1024]; \tint len; \tprintf(\"connect from %s:%d\\n\", \t\t\tinet_ntop(AF_INET, &((struct sockaddr_in*)addr) >sin_addr, \t\t\t\tbuf, sizeof(buf)), \t\t\tntohs(((struct sockaddr_in*)addr) >sin_port)); \tstruct bufferevent *bev bufferevent_socket_new( \t\t\tevconnlistener_get_base(listener), fd, BEV_OPT_CLOSE_ON_FREE); \tif(bev NULL){ \t\tprintf(\"bufferevent_socket_newi error\"); \t\treturn; \t} \tbufferevent_setcb(bev, read_cb, write_cb, event_cb, NULL); \tbufferevent_enable(bev, EV_READ); } int main(void){ \tstruct sockaddr_in serv; \t \tmemset(&serv, 0, sizeof(serv)); \tserv.sin_family AF_INET; \tserv.sin_port htons(9876); \tserv.sin_addr.s_addr htonl(INADDR_ANY); \t//创建event_base \tstruct event_base *base event_base_new(); \tif(base NULL){ \t\tprintf(\"event_base_new\"); \t\treturn 1; \t} \t//创建监听器 \tstruct evconnlistener *listener evconnlistener_new_bind(base, \t\t\tlistener_cb, base, LEV_OPT_CLOSE_ON_FREE LEV_OPT_REUSEABLE, \t\t\t 1, (struct sockaddr*)&serv, sizeof(serv)); \tif(listener NULL){ \t\tprintf(\"evconnlistener_new_bind\"); \t\treturn 1; \t} \t//启动事件循环 \tevent_base_dispatch(base); \t//释放资源 \tevconnlistener_free(listener); \tevent_base_free(base); \treturn 0; } ``` + 客户端 1. 获取一个base 2. bufferevent_socket_new, 获取一个用于通信的bufferevent对象 3. 使用bufferevent_socket_connect进行连接服务器 4. 使用bufferevent_setcb()给这一个对象设置一个回调函数 5. 读写缓冲区的使能以及失能 6. 收发数据 7. 释放资源 ```c #include <stdio.h> #include <stdlib.h> #include <unistd.h> #include <errno.h> #include <string.h> #include <sys/socket.h> #include <arpa/inet.h> #include <event2/event.h> #include <event2/listener.h> #include <event2/bufferevent.h> void read_cb(struct bufferevent *bev, void *ctx){ \tchar buf[1024] {0}; \tint len bufferevent_read(bev, buf, sizeof(buf) 1); \tif(len < 0){ \t\tfprintf(stderr, \"read data error!\\n\"); \t\treturn; \t} \tprintf(\"recv data: %s\\n\", buf); } void read_terminal(evutil_socket_t fd, short what, void *arg){ \tchar buf[1024] {0}; \tint len read(fd, buf, sizeof(buf) 1); \tif(len < 0){ \t\tfprintf(stderr, \"read data error!\\n\"); \t\treturn; \t} \tstruct bufferevent *bev (struct bufferevent *)arg; \tbufferevent_write(bev, buf, len); } void write_cb(struct bufferevent *bev, void *ctx){ \tprintf(\"write data\\n\"); } void event_cb(struct bufferevent *bev, short what, void *ctx){ \tif(what & BEV_EVENT_EOF){ \t\tprintf(\"connection closed\\n\"); \t}else if(what & BEV_EVENT_ERROR){ \t\tprintf(\"some other error\\n\"); \t}else if(what & BEV_EVENT_CONNECTED){ \t\tprintf(\"connected\\n\"); \t\treturn; \t} \tbufferevent_free(bev); } int main(void){ \tstruct event_base *base; \tstruct bufferevent *bev; \tstruct sockaddr_in serv; \tbase event_base_new(); \tif(!base){ \t\tfprintf(stderr, \"Could not initialize libevent!\\n\"); \t\treturn 1; \t} \tint fd socket(AF_INET, SOCK_STREAM, 0); \tmemset(&serv, 0, sizeof(serv)); \tbev bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE); \tif(!bev){ \t\tfprintf(stderr, \"Could not create bufferevent!\\n\"); \t\treturn 1; \t} \t//连接服务器 \tserv.sin_family AF_INET; \tserv.sin_port htons(9876); \tinet_pton(AF_INET, \"127.0.0.1\", &serv.sin_addr); \tbufferevent_socket_connect(bev, (struct sockaddr *)&serv, sizeof(serv)); \tbufferevent_setcb(bev, read_cb, write_cb, event_cb, NULL); \t \tbufferevent_enable(bev, EV_READEV_WRITE); \t//监听标准输入 \tstruct event *ev event_new(base, STDIN_FILENO, EV_READEV_PERSIST, read_terminal, bev); \tevent_add(ev, NULL); \tevent_base_dispatch(base); \tevent_free(ev); \tevent_base_free(base); \tbufferevent_free(bev); \treturn 0; } ```"},"/note/Linux/Linux网络编程/2024-4-2-01网络基础.html":{"title":"网络基础","content":" layout: post title: \"网络基础\" date: 2024 3 10 15:39:08 +0800 tags: Linux 网络 # 网络基础 ## 协议 一组规则, 数据传输和数据的解释的规则。 比如说依次发送文件的文件名, 文件的大小, 以及实际的文件, 这样规定发送一个文件的顺序以及发送的每一个部分的格式等可以算是一种协议 ### 型协议 传输层 常见协议有TCP/UDP协议。 应用层 常见的协议有HTTP协议，FTP协议。 网络层 常见协议有IP协议、ICMP协议、IGMP协议。 网络接口层 常见协议有ARP协议、RARP协议。 TCP[传输控制协议](http://baike.baidu.com/view/544903.htm)（Transmission Control Protocol）是一种面向连接的、可靠的、基于字节流的[传输层](http://baike.baidu.com/view/239605.htm)通信协议。 UDP用户数据报协议（User Datagram Protocol）是[OSI](http://baike.baidu.com/view/113948.htm)参考模型中一种无连接的[传输层](http://baike.baidu.com/view/239605.htm)协议，提供面向事务的简单不可靠信息传送服务。 HTTP[超文本传输协议](http://baike.baidu.com/view/468465.htm)（Hyper Text Transfer Protocol）是[互联网](http://baike.baidu.com/view/6825.htm)上应用最为广泛的一种[网络协议](http://baike.baidu.com/view/16603.htm)。 FTP文件传输协议（File Transfer Protocol） IP协议是[因特网](http://baike.baidu.com/view/1706.htm)互联协议（Internet Protocol） ICMP协议是Internet控制[报文](http://baike.baidu.com/view/175122.htm)协议（Internet Control Message Protocol）它是[TCP/IP协议族](http://baike.baidu.com/view/2221037.htm)的一个子协议，用于在IP[主机](http://baike.baidu.com/view/23880.htm)、[路由](http://baike.baidu.com/view/18655.htm)器之间传递控制消息。 IGMP协议是 Internet 组管理协议（Internet Group Management Protocol），是因特网协议家族中的一个组播协议。该协议运行在主机和组播路由器之间。 [ARP](http://baike.baidu.com/view/32698.htm)协议是正向[地址解析协议](http://baike.baidu.com/view/149421.htm)（Address Resolution Protocol），通过已知的IP，寻找对应主机的[MAC地址](http://baike.baidu.com/view/69334.htm)。 ## 分层模型 ### OSI七层模型 ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404021007234.jpg) OSI模型 1. **物理层**：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输，到达目的地后再转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。 2. **数据链路层**：定义了如何让格式化数据以帧为单位进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。如：串口通信中使用到的115200、8、N、1 3. **网络层**：在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。 4. **传输层**：定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。 5. **会话层**：通过传输层(端口号：传输端口与接收端口)建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。 6. **表示层**：可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。例如，PC程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码(EBCDIC)，而另一台则使用美国信息交换标准码（ASCII）来表示相同的字符。如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。 7. **应用层**：是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。 > 物数网传会表应 > > 网网传应 ### TCP/IP四层模型 TCP/IP网络协议栈分为应用层（Application）、传输层（Transport）、网络层（Network）和链路层（Link）四层。如下图所示： ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404021009884.png) TCP/IP模型 > 应用层: http ftp nfs ssh telnet, 处理应用的数据 > > 传输层: tcp udp, 处理端口 > > 网络层: IP ICMP IGMP, 主要是处理ip地址 > > 链路层: 以太网帧协议 ARP, 主要是处理MAC地址 > > 一般在应用开发过程中，讨论最多的是TCP/IP模型。 ## 通信过程 两台计算机通过TCP/IP协议通讯的过程如下所示： ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404021015622.jpg) > 发送一个信息的时候首先会被应用层进行封装, 比如如果是一个文件可能使用FTP协议 > > 之后是传输层, 网络层, 链路层依次增加他自己的协议 > > 封装之后就可以发送到网络里面了 > > 获取到信息以后反方向进行解封 数据没有封装是不能在网络里面传输的, 用户层协议是我们实际需要实现的 ### TCP/IP通信过程 上图对应两台计算机在同一网段中的情况，如果两台计算机在不同的网段中，那么数据从一台计算机到另一台计算机传输过程中要经过一个或多个路由器，如下图所示： ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404021015657.jpg) ### 跨路由通信 **链路层**有以太网、令牌环网等标准，链路层负责网卡设备的驱动、帧同步（即从网线上检测到什么信号算作新帧的开始）、冲突检测（如果检测到冲突就自动重发）、数据差错校验等工作。交换机是工作在链路层的网络设备，可以在不同的链路层网络之间转发数据帧（比如十兆以太网和百兆以太网之间、以太网和令牌环网之间），由于不同链路层的帧格式不同，交换机要将进来的数据包拆掉链路层首部重新封装之后再转发。 **网络层**的IP协议是构成Internet的基础。Internet上的主机通过IP地址来标识，Inter net上有大量路由器负责根据IP地址选择合适的路径转发数据包，数据包从Internet上的源主机到目的主机往往要经过十多个路由器。路由器是工作在第三层的网络设备，同时兼有交换机的功能，可以在不同的链路层接口之间转发数据包，因此路由器需要将进来的数据包拆掉网络层和链路层两层首部并重新封装。IP协议不保证传输的可靠性，数据包在传输过程中可能丢失，可靠性可以在上层协议或应用程序中提供支持。 网络层负责点到点（ptop，point to point）的传输（这里的“点”指主机或路由器），而传输层负责端到端（etoe，end to end）的传输（这里的“端”指源主机和目的主机）。传输层可选择TCP或UDP协议。 TCP是一种面向连接的、可靠的协议，有点像打电话，双方拿起电话互通身份之后就建立了连接，然后说话就行了，这边说的话那边保证听得到，并且是按说话的顺序听到的，说完话挂机断开连接。也就是说TCP传输的双方需要首先建立连接，之后由TCP协议保证数据收发的可靠性，丢失的数据包自动重发，上层应用程序收到的总是可靠的数据流，通讯之后关闭连接。 UDP是无连接的传输协议，不保证可靠性，有点像寄信，信写好放到邮筒里，既不能保证信件在邮递过程中不会丢失，也不能保证信件寄送顺序。使用UDP协议的应用程序需要自己完成丢包重发、消息排序等工作。 目的主机收到数据包后，如何经过各层协议栈最后到达应用程序呢？其过程如下图所示： ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404021015660.jpg) 以太网驱动程序首先根据以太网首部中的“上层协议”字段确定该数据帧的有效载荷（payload，指除去协议首部之外实际传输的数据）是IP、ARP还是RARP协议的数据报，然后交给相应的协议处理。假如是IP数据报，IP协议再根据IP首部中的“上层协议”字段确定该数据报的有效载荷是TCP、UDP、ICMP还是IGMP，然后交给相应的协议处理。假如是TCP段或UDP段，TCP或UDP协议再根据TCP首部或UDP首部的“端口号”字段确定应该将应用层数据交给哪个用户进程。IP地址是标识网络中不同主机的地址，而端口号就是同一台主机上标识不同进程的地址，IP地址和端口号合起来标识网络中唯一的进程。 虽然IP、ARP和RARP数据报都需要以太网驱动程序来封装成帧，但是从功能上划分，ARP和RARP属于链路层，IP属于网络层。虽然ICMP、IGMP、TCP、UDP的数据都需要IP协议来封装成数据报，但是从功能上划分，ICMP、IGMP与IP同属于网络层，TCP和UDP属于传输层。 > 具体的数据传输过程如下： > > 1. 应用层：应用程序生成需要发送的数据。 > 2. 传输层：TCP将应用数据进行分段并进行序列化。 > 3. 网络层：IP将每个TCP段封装到IP数据包中，并添加源IP地址和目标IP地址。 > 4. 数据链路层：在发送数据之前，网络层的IP数据包会被封装到以太网帧中。以太网帧包含了以太网的目标MAC地址和源MAC地址。 > 5. 物理层：以太网帧在物理层被转换为比特流，并通过物理介质（如以太网电缆）发送出去。 ## 协议格式 ### 数据包封装 传输层及其以下的机制由内核提供，应用层由用户进程提供（后面将介绍如何使用socket API编写应用程序），应用程序对通讯数据的含义进行解释，而传输层及其以下处理通讯的细节，将数据从一台计算机通过一定的路径发送到另一台计算机。应用层数据通过协议栈发到网络上时，每层协议都要加上一个数据首部（header），称为封装（Encapsulation），如下图所示： ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404021244635.jpg) TCP/TP数据包封装 不同的协议层对数据包有不同的称谓，在传输层叫做段（segment），在网络层叫做数据报（datagram），在链路层叫做帧（frame）。数据封装成帧后发到传输介质上，到达目的主机后每层协议再剥掉相应的首部，最后将应用层数据交给应用程序处理。 ### 以太网帧格式(链路层) 以太网的帧格式如下所示： ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404021242758.png) > 这一个图是如何把一个数据封装为实际发送的信息, 无论是TIP/IP发送的IP数据报还是APR请求, 最后都要加上这几个然后进行发送 其中的源地址和目的地址是指网卡的硬件地址（也叫MAC地址），长度是48位，是在网卡出厂时固化的。可在shell中使用ifconfig命令查看，“HWaddr 00:15:F2:14:9E:3F”部分就是硬件地址。协议字段有三种值，分别对应IP、ARP、RARP。帧尾是CRC校验码。 > ARP协议: 通过ip地址获取MAC地址 > > ![image 20240402125241576](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404021252635.png) 以太网帧中的数据长度规定最小46字节，最大1500字节，ARP和RARP数据包的长度不够46字节，要在后面补填充位。 最大值1500称为以太网的最大传输单元（MTU) ，不同的网络类型有不同的MTU，如果一个数据包从以太网路由到拨号链路上，数据包长度大于拨号链路的MTU，则需要对数据包进行分片（fragmentation）。ifconfig命令输出中也有“MTU:1500”。注意，MTU这个概念指数据帧中有效载荷的最大长度，不包括帧头长度。 > 无论是ARP协议还是TCP，在TCP/IP协议栈中，数据都是通过以太网帧进行传输的。以太网帧是一种在以太网（Ethernet）上传输数据的标准格式。 ### ARP数据报格式 > ARP协议用于获取目标主机的MAC地址，发生在三次握手之前，确保在TCP连接建立时源主机已经知道目标主机的MAC地址。之后，TCP三次握手建立连接，然后才进行数据的传输。ARP和三次握手是在TCP/IP通信过程中的不同阶段，但都是确保数据通信的可靠性和正确性的重要步骤。 在网络通讯时，源主机的应用程序知道目的主机的IP地址和端口号，却不知道目的主机的硬件地址，而数据包首先是被网卡接收到再去处理上层协议的，如果接收到的数据包的硬件地址与本机不符，则直接丢弃。因此在通讯前必须获得目的主机的硬件地址。ARP协议就起到这个作用。源主机发出ARP请求，询问“IP地址是192.168.0.1的主机的硬件地址是多少”，并将这个请求广播到本地网段（以太网帧首部的硬件地址填FF:FF:FF:FF:FF:FF表示广播），目的主机接收到广播的ARP请求，发现其中的IP地址与本机相符，则发送一个ARP应答数据包给源主机，将自己的硬件地址填写在应答包中。 每台主机都维护一个ARP缓存表，可以用arp a命令查看。缓存表中的表项有过期时间（一般为20分钟），如果20分钟内没有再次使用某个表项，则该表项失效，下次还要发ARP请求来获得目的主机的硬件地址。想一想，为什么表项要有过期时间而不是一直有效？ ARP数据报的格式如下所示： ![image 20240402131227491](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404021312516.png) ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404021250602.png) > 下面的这一个图里面没有PAD, 上面的这一个少了目的和源地址 ARP数据报格式 源MAC地址、目的MAC地址在以太网首部和ARP请求中各出现一次，对于链路层为以太网的情况是多余的，但如果链路层是其它类型的网络则有可能是必要的。硬件类型指链路层网络类型，1为以太网，协议类型指要转换的地址类型，0x0800为IP地址，后面两个地址长度对于以太网地址和IP地址分别为6和4（字节），op字段为1表示ARP请求，op字段为2表示ARP应答。 看一个具体的例子。 > [以太网协议 ARP协议详解 ARP报文结构解析 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/648270097) 请求帧如下（为了清晰在每行的前面加了字节计数，每行16个字节）： 以太网首部（14字节） 0000: ff ff ff ff ff ff 00 05 5d 61 58 a8 08 06 > ff ff ff ff ff ff : 表示广播 > > 00 05 5d 61 58 a8 : 自己的MAC地址 > > 08 06 : ARP类型 ARP帧（28字节） 000e: 00 01 0010: 08 00 06 04 00 01 00 05 5d 61 58 a8 c0 a8 00 37 0020: 00 00 00 00 00 00 c0 a8 00 02 > 00 01: 硬件为以太网 > > 08 00 : 解析一个IP地址 > > 06 :硬件地址长度 > > 04 :协议地址长度, 表示ip地址长度 > > 00 01 : op字段为1表示ARP请求，op字段为2表示ARP应答。 > > 00 05 5d 61 58 a8 : 自己的MAC地址 > > c0 a8 00 37 : IP地址192.168.0.55 > > 00 00 00 00 00 00 : 目的MAC地址, 未知填0 > > c0 a8 00 02 : 目的地ip地址 填充位（18字节） 002a: 00 77 31 d2 50 10 0030: fd 78 41 d3 00 00 00 00 00 00 00 00 > ARP的填充位用于满足最小帧长度的要求。在以太网帧中，最小帧长度为64字节，如果ARP请求或应答数据包的长度不足64字节，则需要用填充位将其填充到最小帧长度。(其中的数据长度为46字节) > 应答的时候 > > 1. 源和目的反向(IP和AMC) > 2. 把之前的掩码和未知填充位自己的MAC地址 以太网首部：目的主机采用广播地址，源主机的MAC地址是00:05:5d:61:58:a8，上层协议类型0x0806表示ARP。 ARP帧：硬件类型0x0001表示以太网，协议类型0x0800表示IP协议，硬件地址（MAC地址）长度为6，协议地址（IP地址）长度为4，op为0x0001表示请求目的主机的MAC地址，源主机MAC地址为00:05:5d:61:58:a8，源主机IP地址为c0 a8 00 37（192.168.0.55），目的主机MAC地址全0待填写，目的主机IP地址为c0 a8 00 02（192.168.0.2）。 由于以太网规定最小数据长度为46字节，ARP帧长度只有28字节，因此有18字节填充位，填充位的内容没有定义，与具体实现相关。 应答帧如下： 以太网首部 0000: 00 05 5d 61 58 a8 00 05 5d a1 b8 40 08 06 > 00 05 5d 61 58 a8 : 获取的对方的MAC地址 > > 00 05 5d a1 b8 40 : 自己的MAC地址 > > 08 06 : 模式 ARP帧 0000: 00 01 0010: 08 00 06 04 00 02 00 05 5d a1 b8 40 c0 a8 00 02 0020: 00 05 5d 61 58 a8 c0 a8 00 37 > 00 01 : 以太网 > > 08 00 : 解析ip > > 06 04 : 两个长度 > > 00 02 : 应答 > > 00 05 5d a1 b8 40 : 发送端地址(自己的地址) > > c0 a8 00 02 : 自己的IP地址 > > 00 05 5d 61 58 a8 : 这一个是对方的MAC(请求MAC的那一方) > > c0 a8 00 37 对方的IP 填充位 0020: 00 77 31 d2 50 10 0030: fd 78 41 d3 00 00 00 00 00 00 00 00 以太网首部：目的主机的MAC地址是00:05:5d:61:58:a8，源主机的MAC地址是00:05:5d:a1:b8:40，上层协议类型0x0806表示ARP。 ARP帧：硬件类型0x0001表示以太网，协议类型0x0800表示IP协议，硬件地址（MAC地址）长度为6，协议地址（IP地址）长度为4，op为0x0002表示应答，源主机MAC地址为00:05:5d:a1:b8:40，源主机IP地址为c0 a8 00 02（192.168.0.2），目的主机MAC地址为00:05:5d:61:58:a8，目的主机IP地址为c0 a8 00 37（192.168.0.55）。 ### IP段格式 > IP协议主要用于IP地址的保存 ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404022254601.jpg) IP数据报格式 + IP数据报的首部长度和数据长度都是可变长的，但总是4字节的整数倍。 + 对于IPv4，4位版本字段是4。 + 4位首部长度的数值是以4字节为单位的，最小值为5，也就是说首部长度最小是4x5 20字节，也就是不带任何选项的IP首部，4位能表示的最大值是15，也就是说首部长度最大是60字节。 + 8位TOS字段有3个位用来指定IP数据报的优先级（目前已经废弃不用），还有4个位表示可选的服务类型（最小延迟、最大?吐量、最大可靠性、最小成本），还有一个位总是0。 + 总长度是整个数据报（包括IP首部和IP层payload）的字节数。 + 每传一个IP数据报，16位的标识加1，可用于分片和重新组装数据报。 + 3位标志和13位片偏移用于分片。 + TTL（Time to live)是这样用的：源主机为数据包设定一个生存时间，比如64，每过一个路由器就把该值减1，如果减到0就表示路由已经太长了仍然找不到目的主机的网络，就丢弃该包，因此这个生存时间的单位不是秒，而是跳（hop）。 + 协议字段指示上层协议是TCP、UDP、ICMP还是IGMP。 + 然后是校验和，只校验IP首部，数据的校验由更高层协议负责。IPv4的IP地址长度为32位。 > [TCP/IP协议详解 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/33889997) > IP地址: 标识唯一的一台主机 > > 端口号: 一台主机标识唯一的进程 ### UDP数据报格式 > 和TCP协议的主要作用是端口号的选择 ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404032022936.jpg) UDP数据段 下面分析一帧基于UDP的TFTP协议帧。 以太网首部 0000: 00 05 5d 67 d0 b1 00 05 5d 61 58 a8 08 00 IP首部 0000: 45 00 0010: 00 53 93 25 00 00 80 11 25 ec c0 a8 00 37 c0 a8 0020: 00 01 UDP首部 0020： 05 d4 00 45 00 3f ac 40 TFTP协议 0020: 00 01 'c'':''\\''q' 0030: 'w''e''r''q''.''q''w''e'00 'n''e''t''a''s''c''i' 0040: 'i'00 'b''l''k''s''i''z''e'00 '5''1''2'00 't''i' 0050: 'm''e''o''u''t'00 '1''0'00 't''s''i''z''e'00 '0' 0060: 00以太网首部：源MAC地址是00:05:5d:61:58:a8，目的MAC地址是00:05:5d:67:d0:b1，上层协议类型0x0800表示IP。 IP首部：每一个字节0x45包含4位版本号和4位首部长度，版本号为4，即IPv4，首部长度为5，说明IP首部不带有选项字段。服务类型为0，没有使用服务。16位总长度字段（包括IP首部和IP层payload的长度）为0x0053，即83字节，加上以太网首部14字节可知整个帧长度是97字节。IP报标识是0x9325，标志字段和片偏移字段设置为0x0000，就是DF 0允许分片，MF 0此数据报没有更多分片，没有分片偏移。TTL是0x80，也就是128。上层协议0x11表示UDP协议。IP首部校验和为0x25ec，源主机IP是c0 a8 00 37（192.168.0.55），目的主机IP是c0 a8 00 01（192.168.0.1）。 UDP首部：源端口号0x05d4（1492）是客户端的端口号，目的端口号0x0045（69）是TFTP服务的well known端口号。UDP报长度为0x003f，即63字节，包括UDP首部和UDP层pay load的长度。UDP首部和UDP层payload的校验和为0xac40。 TFTP是基于文本的协议，各字段之间用字节0分隔，开头的00 01表示请求读取一个文件，接下来的各字段是： c:\\qwerq.qwe netascii blksize 512 timeout 10 tsize 0 一般的网络通信都是像TFTP协议这样，通信的双方分别是客户端和服务器，客户端主动发起请求（上面的例子就是客户端发起的请求帧），而服务器被动地等待、接收和应答请求。客户端的IP地址和端口号唯一标识了该主机上的TFTP客户端进程，服务器的IP地址和端口号唯一标识了该主机上的TFTP服务进程，由于客户端是主动发起请求的一方，它必须知道服务器的IP地址和TFTP服务进程的端口号，所以，一些常见的网络协议有默认的服务器端口，例如HTTP服务默认TCP协议的80端口，FTP服务默认TCP协议的21端口，TFTP服务默认UDP协议的69端口（如上例所示）。在使用客户端程序时，必须指定服务器的主机名或IP地址，如果不明确指定端口号则采用默认端口，请读者查阅ftp、tftp等程序的man page了解如何指定端口号。/etc/services中列出了所有well known的服务端口和对应的传输层协议，这是由IANA（Internet Assigned Numbers Authority）规定的，其中有些服务既可以用TCP也可以用UDP，为了清晰，IANA规定这样的服务采用相同的TCP或UDP默认端口号，而另外一些TCP和UDP的相同端口号却对应不同的服务。 很多服务有well known的端口号，然而客户端程序的端口号却不必是well known的，往往是每次运行客户端程序时由系统自动分配一个空闲的端口号，用完就释放掉，称为ephemeral的端口号，想想这是为什么？ 前面提过，UDP协议不面向连接，也不保证传输的可靠性，例如： 发送端的UDP协议层只管把应用层传来的数据封装成段交给IP协议层就算完成任务了，如果因为网络故障该段无法发到对方，UDP协议层也不会给应用层返回任何错误信息。 接收端的UDP协议层只管把收到的数据根据端口号交给相应的应用程序就算完成任务了，如果发送端发来多个数据包并且在网络上经过不同的路由，到达接收端时顺序已经错乱了，UDP协议层也不保证按发送时的顺序交给应用层。 通常接收端的UDP协议层将收到的数据放在一个固定大小的缓冲区中等待应用程序来提取和处理，如果应用程序提取和处理的速度很慢，而发送端发送的速度很快，就会丢失数据包，UDP协议层并不报告这种错误。 因此，使用UDP协议的应用程序必须考虑到这些可能的问题并实现适当的解决方案，例如等待应答、超时重发、为数据包编号、流量控制等。一般使用UDP协议的应用程序实现都比较简单，只是发送一些对可靠性要求不高的消息，而不发送大量的数据。例如，基于UDP的TFTP协议一般只用于传送小文件（所以才叫trivial的ftp），而基于TCP的FTP协议适用于 各种文件的传输。TCP协议又是如何用面向连接的服务来代替应用程序解决传输的可靠性问题呢。 ### TCP数据报格式 ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404032022193.jpg) TCP数据段 + 与UDP协议一样也有源端口号和目的端口号，通讯的双方由IP地址和端口号标识。 + 32位序号: 以一个随机数为起始, 每一次加上数据的长度 + 32位确认序号: 发送期望得到的数据的起始位置 + 4位首部长度和IP协议头类似，表示TCP协议头的长度，以4字节为单位，因此TCP协议头最长可以是4x15 60字节，如果没有选项字段，TCP协议头最短20字节。 + URG、ACK、PSH、RST、SYN、FIN是六个控制位 > ACK：确认序号有效 > RST：重置连接 > SYN：发起了一个新连接 > FIN：释放一个连接 > PSH: 当 PSH 1 的时候，表示该报文段高优先级 + 16位窗口: 告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据 + 16位检验和将TCP协议头和数据都计算在内。 + 紧急指针: 仅在 URG 1 时才有意义，它指出本报文段中的紧急数据的字节数。 + 各种选项 ## TCP协议 发送数据的时候, 每一个数据都必须得到对方的应答, 有超时重传, 错误校验以及流量管理 在传输指之前需要建立连接 ### TCP通信时序 下图是一次TCP通讯的时序图。TCP连接建立断开。包含大家熟知的**三次握手**和四次挥手。 <img src \"https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404042155205.png\" alt \"img\" style \"zoom:200%;\" /> #### 三次握手 ![image 20240404220524603](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404042205645.png) > SYN: 请求建立连接 > > 1000(0), 一个随机的额起始位置, 以及数据的大小为0 > > <mss 1460>可以接受的信息的大小, 这一个1460是一个以太网帧减去各种头部以后实际可以携带的数据大小 > SYN请求建立连接 > > 8000(0)一个随机的起始位置, 数据大小为1 > > ACK应答标志位 > > 1001表示下一次希望获取的数据 > ASK请求8001 在这个例子中，首先客户端主动发起连接、发送请求，然后服务器端响应请求，然后客户端主动关闭连接。两条竖线表示通讯的两端，从上到下表示时间的先后顺序，注意，数据从一端传到网络的另一端也需要时间，所以图中的箭头都是斜的。双方发送的段按时间顺序编号为1 10，各段中的主要信息在箭头上标出 建立连接（三次握手）的过程： 1. 客户端发送一个带SYN标志的TCP报文到服务器。这是三次握手过程中的段1。 客户端发出段1，SYN位表示连接请求。序号是1000，这个序号在网络通讯中用作临时的地址，每发一个数据字节，这个序号要加1，这样在接收端可以根据序号排出数据包的正确顺序，也可以发现丢包的情况，另外，规定SYN位和FIN位也要占一个序号，这次虽然没发数据，但是由于发了SYN位，因此下次再发送应该用序号1001。mss表示最大段尺寸，如果一个段太大，封装成帧后超过了链路层的最大帧长度，就必须在IP层分片，为了避免这种情况，客户端声明自己的最大段尺寸，建议服务器端发来的段不要超过这个长度。 2. 服务器端回应客户端，是三次握手中的第2个报文段，同时带ACK标志和SYN标志。它表示对刚才客户端SYN的回应；同时又发送SYN给客户端，询问客户端是否准备好进行数据通讯。 服务器发出段2，也带有SYN位，同时置ACK位表示确认，确认序号是1001，表示“我接收到序号1000及其以前所有的段，请你下次发送序号为1001的段”，也就是应答了客户端的连接请求，同时也给客户端发出一个连接请求，同时声明最大尺寸为1024。 3. 客户必须再次回应服务器端一个ACK报文，这是报文段3。 客户端发出段3，对服务器的连接请求进行应答，确认序号是8001。在这个过程中，客户端和服务器分别给对方发了连接请求，也应答了对方的连接请求，其中服务器的请求和应答在一个段中发出，因此一共有三个段用于建立连接，称为“三方握手（three way handshake）”。在建立连接的同时，双方协商了一些信息，例如双方发送序号的初始值、最大段尺寸等。**这一次是可以带数据的, 但是通常情况不会带** > 这三次的操作是内核完成的, 实际的用户对用的函数是accept和connect, 这两个成功执行返回 > > 建立三次握手主要是因为A发送了再一次的确认，那么A为什么会再确认一次呢，主要是为了防止已失效的连接请求报文段又突然传送给B，从而产生了错误。 > > 如果采用两次握手会出现以下情况： > 客户端向服务器端发送的请求报文由于网络等原因滞留，未能发送到服务器端，此时连接请求报文失效，客户端会再次向服务器端发送请求报文，之后与服务器端建立连接，当连接释放后，由于网络通畅了，第一次客户端发送的请求报文又突然到达了服务器端，这条请求报文本该失效了，但此时服务器端误认为客户端又发送了一次连接请求，两次握手建立好连接，此时客户端忽略服务器端发来的确认，也不发送数据，造成不必要的错误和网络资源的浪费。 > > 如果采用三次握手的话，就算那条失效的报文发送到服务器端，服务器端确认并向客户端发送报文，但此时客户端不会发出确认，由于客户端没有确认，由于服务器端没有接收到确认，就会知道客户端没有请求连接。 > > 在TCP通讯中，如果一方收到另一方发来的段，读出其中的目的端口号，发现本机并没有任何进程使用这个端口，就会应答一个包含RST位的段给另一方。例如，服务器并没有任何进程使用8080端口，我们却用telnet客户端去连接它，服务器收到客户端发来的SYN段就会应答一个RST段，客户端的telnet程序收到RST段后报告错误Connection refused： > > ```bash > $ telnet 192.168.0.200 8080 > > Trying 192.168.0.200... > > telnet: Unable to connect to remote host: Connection refused > ``` #### 数据传输的过程 ![image 20240404220957665](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404042209704.png) 1. 客户端发出段4，包含从序号1001开始的20个字节数据。 2. 服务器发出段5，确认序号为1021，对序号为1001 1020的数据表示确认收到，同时请求发送序号1021开始的数据，服务器在应答的同时也向客户端发送从序号8001开始的10个字节数据，这称为piggyback。 3. 客户端发出段6，对服务器发来的序号为8001 8010的数据表示确认收到，请求发送序号8011开始的数据。 在数据传输过程中，ACK和确认序号是非常重要的，应用程序交给TCP协议发送的数据会暂存在TCP层的发送缓冲区中，发出数据包给对方之后，只有收到对方应答的ACK段才知道该数据包确实发到了对方，可以从发送缓冲区中释放掉了，如果因为网络故障丢失了数据包或者丢失了对方发回的ACK段，经过等待超时后TCP协议自动将发送缓冲区中的数据包重发。 ##### 滑动窗口 (TCP流量控制) > 实际使用的时候不需要对每一次的信息都回应 > > <img src \"https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404042258827.png\" alt \"img\" style \"zoom:150%;\" /> 1. 发送端发起连接，声明最大段尺寸是1460，初始序号是0，窗口大小是4K，表示“我的接收缓冲区还有4K字节空闲，你发的数据不要超过4K”。 2. 接收端应答连接请求，声明最大段尺寸是1024，初始序号是8000，窗口大小是6K。发送端应答，三方握手结束。发送端发出段4 9，每个段带1K的数据，发送端根据窗口大小知道接收端的缓冲区满了，因此停止发送数据。 > 在回应之前客户端已经发送了很多数据, 回应6145, 表示在这之前的所有数据都收到了, 不需要回应每一次发送 3. 接收端的应用程序提走2K数据，接收缓冲区又有了2K空闲，接收端发出段10，在应答已收到6K数据的同时声明窗口大小为2K。 4. 接收端的应用程序又提走2K数据，接收缓冲区有4K空闲，接收端发出段11，重新声明窗口大小为4K。 5. 发送端发出段12 13，每个段带2K数据，段13同时还包含FIN位。 6. 接收端应答接收到的2K数据（6145 8192），再加上FIN位占一个序号8193，因此应答序号是8194，连接处于半关闭状态，接收端同时声明窗口大小为2K。 7. 接收端的应用程序提走2K数据，接收端重新声明窗口大小为4K。 8. 接收端的应用程序提走剩下的2K数据，接收缓冲区全空，接收端重新声明窗口大小为6K。 9. 接收端的应用程序在提走全部数据后，决定关闭连接，发出段17包含FIN位，发送端应答，连接完全关闭。 > 上图在接收端用小方块表示1K数据，实心的小方块表示已接收到的数据，虚线框表示接收缓冲区，因此套在虚线框中的空心小方块表示窗口大小，从图中可以看出，随着应用程序提走数据，虚线框是向右滑动的，因此称为滑动窗口。 > 从这个例子还可以看出，发送端是一K一K地发送数据，而接收端的应用程序可以两K两K地提走数据，当然也有可能一次提走3K或6K数据，或者一次只提走几个字节的数据。也就是说，应用程序所看到的数据是一个整体，或说是一个流（stream），在底层通讯中这些数据可能被拆成很多数据包来发送，但是一个数据包有多少字节对应用程序是不可见的，因此TCP协议是面向流的协议。而UDP是面向消息的协议，每个UDP段都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据，这一点和TCP是很不同的。 #### 关闭连接 ![image 20240404230622514](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404042306557.png) 由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。 1. 客户端发出段7，FIN位表示关闭连接的请求。 2. 服务器发出段8，应答客户端的关闭连接请求。 3. 服务器发出段9，其中也包含FIN位，向客户端发送关闭连接请求。 4. 客户端发出段10，应答服务器的关闭连接请求。 建立连接的过程是三方握手，而关闭连接通常需要4个段，服务器的应答和关闭连接请求通常不合并在一个段中，因为有连接半关闭的情况，这种情况下客户端关闭连接之后就不能再发送数据给服务器了，但是服务器还可以发送数据给客户端，直到服务器也关闭连接为止。 > 这一个协议支持半关闭, 这个时候信息的传递是单向的 > > ![image 20240405101403060](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404051014315.png) > > 这两次会关闭发起者的读缓冲区, 以及接受者的写缓冲区, 关闭的不是套接字, 所以还可以发送信息 > > 所以需要关闭两次 ##### 半关闭 当TCP链接中A发送FIN请求关闭，B端回应ACK后（A端进入FIN_WAIT_2状态），B没有立即发送FIN给A时，A方处在半链接状态，此时A可以接收B发送的数据，但是A已不能再向B发送数据。 从程序的角度，可以使用API来控制实现半连接状态。 ```c #include <sys/socket.h> int shutdown(int sockfd, int how); ``` > sockfd: 需要关闭的socket的描述符 > > how: 允许为shutdown操作选择以下几种方式: > > SHUT_RD(0)： 关闭sockfd上的读功能，此选项将不允许sockfd进行读操作。 > > ​ 该套接字**不再接收数据**，任何当前在套接字接受缓冲区的数据将被无声的丢弃掉。 > > SHUT_WR(1): 关闭sockfd的写功能，此选项将不允许sockfd进行写操作。进程不能在对此套接字发出写操作。 > > SHUT_RDWR(2): 关闭sockfd的读写功能。相当于调用shutdown两次：首先是以SHUT_RD,然后以SHUT_WR。 使用close中止一个连接，但它只是减少描述符的引用计数，并不直接关闭连接，只有当描述符的引用计数为0时才关闭连接。 **shutdown** **不考虑描述符的引用计数，直接关闭描述符**。也可选择中止一个方向的连接，只中止读或只中止写。 注意: 1. 如果有多个进程共享一个套接字，close每被调用一次，计数减1，直到计数为0时，也就是所用进程都调用了close，套接字将被释放。 2. 在多进程中如果一个进程调用了shutdown(sfd, SHUT_RDWR)后，其它的进程将无法进行通信。但，如果一个进程close(sfd)将不会影响到其它进程。 ### TCP状态转换 这个图N多人都知道，它排除和定位网络或系统故障时大有帮助，但是怎样牢牢地将这张图刻在脑中呢？那么你就一定要对这张图的每一个状态，及转换的过程有深刻的认识，不能只停留在一知半解之中。下面对这张图的11种状态详细解析一下，以便加强记忆！不过在这之前，先回顾一下TCP建立连接的三次握手过程，以及 关闭连接的四次握手过程。 ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404061029712.jpg) TCP状态转换图 **CLOSED：**表示初始状态。 **LISTEN：**该状态表示服务器端的某个SOCKET处于监听状态，可以接受连接。 **SYN_SENT：**这个状态与SYN_RCVD遥相呼应，当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，随即进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。 **SYN_RCVD:** 该状态表示接收到SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂。此种状态时，当收到客户端的ACK报文后，会进入到ESTABLISHED状态。 **ESTABLISHED：**表示连接已经建立。 **FIN_WAIT_1:** FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。区别是： FIN_WAIT_1状态是当socket在ESTABLISHED状态时，想主动关闭连接，向对方发送了FIN报文，此时该socket进入到FIN_WAIT_1状态。 FIN_WAIT_2状态是当对方回应ACK后，该socket进入到FIN_WAIT_2状态，正常情况下，对方应马上回应ACK报文，所以FIN_WAIT_1状态一般较难见到，而FIN_WAIT_2状态可用netstat看到。 **FIN_WAIT_2**：主动关闭链接的一方，发出FIN收到ACK以后进入该状态。称之为半连接或半关闭状态。该状态下的socket只能接收数据，不能发。 **TIME_WAIT:** 表示收到了对方的FIN报文，并发送出了ACK报文，等2MSL后即可回到CLOSED可用状态。如果FIN_WAIT_1状态下，收到对方同时带 FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。 > 发完最后一个ASK以后, 需要等待看对方有没有收到, 没有收到的话, 对方会一直发送FIN信号过来 > > 在这一个等待的时长的时候可以使用setsockopt函数进行端口的复用, 提高用户体验 **CLOSING:** 这种状态较特殊，属于一种较罕见的状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到（或同时收到）对方的 ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢？如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。 **CLOSE_WAIT:** 此种状态表示在等待关闭。当对方关闭一个SOCKET后发送FIN报文给自己，系统会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，察看是否还有数据发送给对方，如果没有可以 close这个SOCKET，发送FIN报文给对方，即关闭连接。所以在CLOSE_WAIT状态下，需要关闭连接。 **LAST_ACK:** 该状态是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，即可以进入到CLOSED可用状态。 > ![image 20240406110413693](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404061104813.png) > 可以使用命令`netstate grep 端口号`查看对应端口的端口号 > > ![image 20240406110828198](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404061108232.png) ## C/S模型 client server:客户端 服务器模型 ### 优缺点 可以缓存大量数据, 加载快, 可以自定义协议, 方便迭代 安转的程序不可控, 安全性比较低 ## B/S模型 browser server: 浏览器服务器 ### 优缺点 不能缓存大量的数据, 严格遵循http, 可以跨平台, 开发的工作量比较小 ## TCP/UDP优缺点 TCP: 面向连接, 可靠的数据包传输 对不稳定的网络层, 采取完全弥补的通信方式 丢包重传 + 优点 稳定, 数据流量稳定, 数据传输的速度稳定, 传输的顺序稳定 + 缺点 发送的速度慢, 效率比较低, 系统资源开销比较大 + 使用场景 对数据的完整性要求比较高, 不追求效率 > 大数据传输, 文件传输 UDP: 无连接的, 不可靠的传输 对网络不稳定的网络层, 采用完全不弥补的方式 默认还原网络状况 + 优点 速度快, 效率高, 系统开销小 + 缺点 不稳定, 数据的流量以及速度, 顺序不一定正确 + 使用场景 时效性比较高的, 稳定性其次 > 游戏, 直播, 视频电话 > 企业使用的时候, 一般会直接使用TCP协议, 通过提高服务器的性能之类的方法达到提高效率的作用 > > 但是腾讯, 华为, 阿里之类的公司会使用UDP, 在应用层校验来弥补UDP的不足 ## 网络通信过程 + 最简单的网络 使用网络的时候, 使用两根线把两台电脑连接起来, 之后设置一个ip地址, 两个设备之间就可以通信了 > ip地址: 电脑的身份证 > > 掩码: ip mask获取的数字如果是一样的话这两个电脑在同一个局域网里面, 可以直接通信 如果电脑只有一个网卡的时候, 只有两个电脑可以通过这一个方式进行通信 + 交换机 把很多的网线连接到这一个交换机, 直到这一个交换机的上限 这个时候使用ping命令和另一个交换机进行通信, 首先发送一个ARP信息给交换机, 这一个ARP会被叫交换机发送给每一个连接的机器去获取目标机器的MAC地址(这个时候只知道对方的ip地址) 网络在通信的时候需要有对方的网卡的物理地址, 目标的网卡收到数据以后会使用这一个MAC地址判断是不是发送给自己的数据, 因为不同的局域网里面可能会由相同的ip地址 之后这一个电脑就可以给对方发送ICMP数据包从而进行通信, 一般来说一次ping会发送4次ICMP数据包 > 交换机: 可以把多个设备连接为一个局域网, 但是不能连接多个局域网 + 路由器 用于连接不同的局域网, 一个路由器可以处于不同的局域网里面, 使用不同的网卡进入不同的局域网, 从一个网卡收数据, 另一个网卡把数据发送出去, 从而实现不同局域网之间的通信 实际使用的时候需要把交换机的网卡ip设置为它连接的那一个局域网里面的一个ip 在发送的时候如果发现这一个ip地址不是在这一个局域网里面, 会发送给默认网关(Gateway) 在实际ping的时候ARP命令获取的是路由器的MAC地址, 之后发送ICMP信号的时候传给路由器之后路由器会把这一个信息丢弃, 然后发送一个ARP信号去获取实际对象的MAC地址, 路由器获取以后会记录获取到的MAC地址 第二个ICMP信息才会发送给目标对象 > 不同的路由器之间可以直接连接, 但是需要记录其他的路由器的ip以及对应的局域网的范围 > > 在实际的数据传输的时候MAC地址记录的是下一站的地址, ip地址记录是最终的目的地的IP地址, MAC地址会随着路由器的通信而变化 ### 服务器功能 + DHCP 用于自动分配ip地址 + TFTP 文件传输 + DNS 域名解析, 记录域名以及对应的ip地址 这一个记录的ip地址的主机号一般为0, 代表网络号 + HTTP 网页处理 ### 访问网页的过程 1. 发送一个DNS数据包, 会把这一个数据包发送给DNS服务器 ![image 20240513230919005](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405132309145.png) 2. 如果路由器里面没有记录这一个DNS服务的MAC地址, 会丢弃数据转而发送ARP命令 3. 浏览器发现超时以后会再次发送DNS, DNA服务器收到以后会回复一个DNS信息, 里面有对应的ip地址 4. 获取以后开始进行三次握手 5. 之后发送http信息(依附于TCP协议)"},"/note/Linux/李述铜手写操作系统/2024-3-5-磁盘.html":{"title":"磁盘","content":" layout: post title: \"磁盘\" date: 2024 3 5 15:39:08 +0800 tags: 李述铜 # 磁盘 [ATA PIO Mode OSDev Wiki](https://wiki.osdev.org/ATA_PIO_Mode) + 下面的大部分来自这一个网址的翻译 在磁盘的第一个扇区里面可以有4个描述分区的描述符 电脑有两个总线, Primary Bus, Secondary Bus, 这两个都有一个Msater Driver和一个Slave Driver ![image 20240305231011813](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403052310005.png) > According to the ATA specs, PIO mode must always be supported by all ATA compliant drives as the default data transfer mechanism. > > PIO mode uses a tremendous amount of CPU resources because every byte of data transferred between the disk and the CPU must be sent through the CPU's [IO port bus](https://wiki.osdev.org/Inline_Assembly/Examples#I.5CO_access) (not the memory). On some CPUs, PIO mode can still achieve actual transfer speeds of 16MB per sec, but no other processes on the machine will get any CPU time. > > 这里使用的是PIO模式, 这是ATA规定的模式, 这是一个使用CPU进行读取的模式, 这时候CPU不能处理其他的事情 > > 这是一个简单的读取的模式 > There is only one wire dedicated to selecting which drive on each bus is active. It is either electrically \"high\" or \"low\", which means that there can never be more than two devices operational on any ATA bus. They are called the master and the slave devices, for no particular reason. The terms 'master' and 'slave' have largely been abandoned as they inaccurately portray the master drive as having some kind of superiority over the slave drive, or that the latter is dependent on the master. However, these terms will be used in this document. The functionality of the master and slave drives is almost completely identical. There is a special IO port bit that allows a driver to select either drive as the target drive for each command byte. > > 这一段的大致意思是主磁盘和从磁盘的区分是因为只有一条线进行选择这两个磁盘, 这两个磁盘的速度之类的属性基本没有区别, 没有依附关系 ### 使用的寄存器 > An ATA bus typically has ten I/O ports which control its behavior. For the primary bus, these I/O ports are usually 0x1F0 (the \"I/O\" port base) through 0x1F7 and 0x3F6 (the \"Control\" port base) through 0x3F7. For the secondary bus, they are usually 0x170 through 0x177 and 0x376 through 0x377. > > 每一个总线使用10个端口, Primary使用0x1F0 0x1F7(IO)和0x3F6 0x3F7(控制寄存器) > > Secondary使用的是0x170 0x177 and 0x376 0x377. ![image 20240305232923123](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403052329169.png) > The standard IRQ for the Primary bus is IRQ14 and IRQ15 for the Secondary bus. > > 这两个磁盘使用的中断是IRQ14,15 > ![image 20240305232942147](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403052329183.png) ![image 20240306185047418](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403061850585.png) > 状态寄存器 ## 检测磁盘是不是存在 ### IDENTIFY command To use the IDENTIFY command, select a target drive by sending 0xA0 for the master drive, or 0xB0 for the slave, to the \"drive select\" IO port. On the Primary bus, this would be port 0x1F6. Then set the Sectorcount, LBAlo, LBAmid, and LBAhi IO ports to 0 (port 0x1F2 to 0x1F5). Then send the IDENTIFY command (0xEC) to the Command IO port (0x1F7). Then read the Status port (0x1F7) again. If the value read is 0, the drive does not exist. For any other value: poll the Status port (0x1F7) until bit 7 (BSY, value 0x80) clears. Because of some ATAPI drives that do not follow spec, at this point you need to check the LBAmid and LBAhi ports (0x1F4 and 0x1F5) to see if they are non zero. If so, the drive is not ATA, and you should stop polling. Otherwise, continue polling one of the Status ports until bit 3 (DRQ, value 8) sets, or until bit 0 (ERR, value 1) sets. At that point, if ERR is clear, the data is ready to read from the Data port (0x1F0). Read 256 16 bit values, and store them. > 可以使用这一个命令选择一个磁盘, 或者检测一个磁盘是不是存在 > > 向一个磁盘的0x1F6(0x176)写入0xA0或者0xB0选择主机和从机 > > ![image 20231015131611883](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402141246164.png) > > > 这里使用的时候最好使能一下LBA, 用于读取数据 > > 之后把LBAlo, LBAmid, and LBAhi IO ports to 0 (port 0x1F2 to 0x1F5)这几个寄存器设置为0 > > 向0x1F7端口发送命令0xEC去检测这一个磁盘是不是存在, 可以通过读取0x1F7, 如果是0, 不存在, 如果是其他的值, 等待bit7清零 > > 这个时候你可以看一看0x1F4 and 0x1F5是不是非零的值, 如果是的话这不是一个ATA设备, 如果是的话, 等待bit 3 为1, 或bit 0为1(出错). At that point, if ERR is clear, the data is ready to read from the Data port (0x1F0). Read 256 16 bit values, and store them. > 如果没有出错, 从0x1F0读取256字节的磁盘信息 ### 错误处理 These devices will also write specific values to the IO ports, that can be read. Seeing ATAPI specific values on those ports after an IDENTIFY is definitive proof that the device is ATAPI on the Primary bus, IO port 0x1F4 will read as 0x14, and IO port 0x1F5 will read as 0xEB. If a normal ATA drive should ever happen to abort an IDENTIFY command, the values in those two ports will be 0. A SATA device will report 0x3c, and 0xc3 instead > 如果是其他的设备的话, 这几个端口会被设置为对应的值, 如果是一个普通的ATA设备, 端口为0 ### 获取的数据 uint16_t 100 through 103 taken as a uint64_t contain the total number of 48 bit addressable sectors on the drive. (Probably also proof that LBA48 is supported.) > 主要关注这64位, 记录的是这一个磁盘的扇区数 ### 实际的实现 ```c static int identify_disk (disk_t * disk) { outb(0x1F6(状态寄存器), 根据盘符设置); outb(命令端口, 0xEC); // 检测状态，如果为0，则控制器不存在 int err inb(DISK_STATUS(disk)); if (err 0) { log_printf(\"%s doesn't exist\\n\", disk >name); return 1; } // 等待数据就绪, 此时中断还未开启，因此暂时可以使用查询模式 err ata_wait_data(disk);//检测一下BUSY以及ERR位 if (err < 0) { log_printf(\"disk[%s]: read failed!\\n\", disk >name); return err; } uint16_t buf[256]; ata_read_data(disk, buf, sizeof(buf));//使用inw从DATA端口获取数据 disk >sector_count *(uint32_t *)(buf + 100); disk >sector_size SECTOR_SIZE; // 固定为512字节大小 return 0; } ``` ## 进一步读取磁盘 这时候由于不能使用BIOS, 所以需要用到LBA模式 这个模式将所有的扇区当做是线性排列的, 没有磁盘柱头等模式, 访问起来更加简单 访问使用的序列 ### 设置读取模式 ![image 20231015131611883](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402141246164.png) > 主要是bit4驱动器号(使用主盘的时候使用0), 以及使用LBA模式, 这里设置为0xE0, 根据实际使用的是哪一个盘设置bit4, 0为主盘 ### 实际的代码实现 ![image 20231015131554050](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402141245144.png) ```c //sector开始的扇区, sector_count扇区的个数 outb(0x1F6, (uint8_t) (0xE0)); //选则硬盘, 主盘或者从盘, 设置为LBA模式进行读取 //一次记录一下各个位的值 outb(0x1F2, (uint8_t) (sector_count >> 8)); outb(0x1F3, (uint8_t) (sector >> 24));\t\t// LBA4参数的24~31位 outb(0x1F4, (uint8_t) (0));\t\t\t\t\t// LBA5参数的32~39位 这里这个程序只使用了32位 outb(0x1F5, (uint8_t) (0));\t\t\t\t\t// LBA6参数的40~47位 outb(0x1F2, (uint8_t) (sector_count)); outb(0x1F3, (uint8_t) (sector));\t\t\t// LBA1参数的0~7位 outb(0x1F4, (uint8_t) (sector >> 8));\t\t// LBA2参数的8~15位 outb(0x1F5, (uint8_t) (sector >> 16));\t\t// LBA3参数的16~23位 outb(0x1F7, (uint8_t) 0x24); ``` > (Notes: A sector count of 0 means 65536 sectors 32MB. Try not to send bytes to the same IO port twice in a row. Doing so is **much** slower than doing two outb() commands to **different** IO ports. The important thing is that the high byte of the sector count, features and LBA bytes 4, 5, & 6 go to their respective ports **before the low bytes**.) > > 使用一个16位的数字保存一次读取的扇区的个数, 一共可以用65535块, 32Mde大小 > > Assume you have a sectorcount uint16_t and a 6 byte LBA value. Mentally number the LBA bytes as 1 to 6, from low to high. Send the 2 byte sector count to port 0x1F2 (high byte first), and the six LBA byte pairs to ports 0x1F3 through 0x1F5 in some appropriate order. > > 使用16位的扇区个数以及48位的扇区起始位置, 按照这个顺序发送, 最后发送读取的命令0x24 > > 这是一个48位的扇区号以及读取的大小 > > ```c > An example: > > Send 0x40 for the \"master\" or 0x50 for the \"slave\" to port 0x1F6: outb(0x1F6, 0x40 (slavebit << 4)) > outb (0x1F2, sectorcount high byte) > outb (0x1F3, LBA4) > outb (0x1F4, LBA5) > outb (0x1F5, LBA6) > outb (0x1F2, sectorcount low byte) > outb (0x1F3, LBA1) > outb (0x1F4, LBA2) > outb (0x1F5, LBA3) > Send the \"READ SECTORS EXT\" command (0x24) to port 0x1F7: outb(0x1F7, 0x24) > ``` > > To use the IDENTIFY command, select a target drive by sending 0xA0 for the master drive, or 0xB0 for the slave, to the \"drive select\" IO port. On the Primary bus, this would be port 0x1F6. Then set the Sectorcount, LBAlo, LBAmid, and LBAhi IO ports to 0 (port 0x1F2 to 0x1F5). Then send the IDENTIFY command (0xEC) to the Command IO port (0x1F7). Then read the Status port (0x1F7) again. If the value read is 0, the drive does not exist. For any other value: poll the Status port (0x1F7) **until bit 7 (BSY, value 0x80)** clears. Because of some ATAPI drives that do not follow spec, at this point you need to check the LBAmid and LBAhi ports (0x1F4 and 0x1F5) to see if they are non zero. If so, the drive is not ATA, and you should stop polling. Otherwise, continue polling one of the Status ports until bit 3 (DRQ, value 8) sets, or until bit 0 (ERR, value 1) sets. ```c uint16_t *data_buf (uint16_t*) buf; while (sector_count > 0) { // 每次扇区读之前都要检查，等待数据就绪 while ((inb(0x1F7) & 0x88) ! 0x8) {} // 读取并将数据写入到缓存中 for (int i 0; i < SECTOR_SIZE / 2; i++) { *data_buf++ inw(0x1F0); } } ``` > 发送命令以后可以读取0x1f0, 获取对应的数据 ## 识别分区 磁盘的第一个扇区里面记录有四条信息, 这里面记录的这一个磁盘里面的不同的分区里面的文件系统以及一个分区的大小 第一个扇区的前一部分用来做引导代码(开机的时候执行的第一段用户代码), 可以使用466字节, 之后是64字节的分区表, 然后是0x55, 0xAA标记这一个扇区是一个可以启动的系统盘 ![image 20240306202353381](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403062023460.png) > 这里的CHS和LBA是不同的读取方式 > > [Partition types: List of partition identifiers for PCs (tue.nl)不同的分区对应的数值](https://www.win.tue.nl/~aeb/partitions/partition_types 1.html) > > [MBR (x86) OSDev Wiki](https://wiki.osdev.org/MBR_(x86)) > > [Partition Table OSDev Wiki](https://wiki.osdev.org/Partition_Table) ![image 20240306203104755](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403062031821.png)"},"/note/Linux/李述铜手写操作系统/2024-3-3-Shell.html":{"title":"Shell","content":" layout: post title: \"Shell\" date: 2024 2 29 15:39:08 +0800 tags: 李述铜 # Shell ## getopt(argc, argv, ) [C/C++ 命令解析：getopt 方法详解和使用示例_c++ getopt CSDN博客](https://blog.csdn.net/afei__/article/details/81261879) ```c int getopt(int argc, char * const argv[], const char *optstring); extern char *optarg; extern int optind, opterr, optopt; ``` > 使用的时候如果有一个参数是不需要选项的, 会被最后保存在optind里面, 每一次使用optget之前需要把optind设置为1, 这是为了可以从第一个参数开始读取"},"/note/Linux/李述铜手写操作系统/2024-2-17-07进程切换.html":{"title":"进程切换","content":" layout: post title: \"进程切换\" date: 2024 2 17 15:39:08 +0800 tags: 李述铜 # 进程切换 ## TSS ### 数据类型 使用TSS记录任务的当前的信息 ![image 20240217150338939](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402171503993.png) ```c typedef struct _tss_t { uint32_t pre_link; uint32_t esp0, ss0, esp1, ss1, esp2, ss2; uint32_t cr3; uint32_t eip, eflags, eax, ecx, edx, ebx, esp, ebp, esi, edi; uint32_t es, cs, ss, ds, fs, gs; uint32_t ldt; uint32_t iomap; }tss_t; ``` > Previous Task Link: 任务的连接, 没有用到 > > 之后是几个不同优先级的时候使用的不同的额栈, ss是栈的段寄存器 > > cr3记录的是页表的值 > > 再往后是寄存器的信息 > > LDT, 记录LDT的选择子 > > IO图, SSP没有使用 ![image 20240217155639448](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402171556508.png) > 这里主要设置的是IF和bit1, IF为0的时候中断关闭 ### 初始化 ```c #define EFLAGS_DEFAULT (1<<1) #define EFLAGS_IF (1<<9) static int tss_init(task_t *task, uint32_t entry, uint32_t esp){ kernel_memset(&task >tss, 0, sizeof(tss_t)); //设置一下执行的函数 task >tss.eip entry; //设置一下栈 task >tss.esp task >tss.esp0 esp; task >tss.ss task >tss.ss0 KERNEL_SELECTOR_DS; //其他的段寄存器 task >tss.es task >tss.ds task >tss.fs task >tss.gs KERNEL_SELECTOR_DS; task >tss.cs KERNEL_SELECTOR_CS; task >tss.eflags EFLAGS_DEFAULT EFLAGS_IF; return 0; } int task_init(task_t *task, uint32_t entry, uint32_t esp){ ASSERT(task ! (task_t*)0); tss_init(task, entry, esp); } ``` ### 使用TSS进行切换 在GDT表里面加一个TSS的描述符, 之后使用jmp指令跳转TSS就可以了 ![image 20240217160851827](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402171608881.png) > 使用Task Register保存现在的任务 ![image 20240217161020017](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402171610059.png) > 这里直接使用段描述符 ```c static int tss_init(task_t *task, uint32_t entry, uint32_t esp){ //获取GDT表里面的空闲表项 int tss_sel gdt_alloc_desc(); if(tss_sel 1) { log_printf(\"alloc tss from gdt failed\"); } //填入GDT表里面 segment_desc_set(tss_sel, (uint32_t)&task >tss, sizeof(tss_t), SEG_P SEG_DPL0 SEG_TYPE_TSS ); kernel_memset(&task >tss, 0, sizeof(tss_t)); //设置一下执行的函数 task >tss.eip entry; //设置一下栈 task >tss.esp task >tss.esp0 esp; task >tss.ss task >tss.ss0 KERNEL_SELECTOR_DS; //其他的段寄存器 task >tss.es task >tss.ds task >tss.fs task >tss.gs KERNEL_SELECTOR_DS; task >tss.cs KERNEL_SELECTOR_CS; task >tss.eflags EFLAGS_DEFAULT EFLAGS_IF; //记录一下 task >tss_sel tss_sel; return 0; } ``` 在第一次切换之前需要设置一下Task Register ```c void init_main(void){ log_printf(\"Kernel is running...\"); log_printf(\"Version: %s %s\", OS_VERSION, \"my os\"); int count 0; //初始化任务的tss task_init(&init_task, (uint32_t)init_task_entry, (uint32_t)&init_task_stack[1024]); task_init(&first_task, 0, 0); //记录当前的任务 write_tr(first_task.tss_sel); for(;;){ log_printf(\"int main %d\", count++); } } ``` 之后直接jmp就可以了 ```c void task_switch_from_to (task_t * from, task_t * to){ switch_to_tss(to >tss_sel); } ``` ```c //任务切换 void switch_to_tss (int tss_sel){ far_jump(tss_sel, 0); } ``` ### 另一种切换方法(非硬件) 使用TSS的话会使得任务切换的效率比较低 > 7.3 TASK SWITCHING 可以自己手动保存和记录状态 可以直接使用这一个任务的栈进行保存 在[abi386 4.pdf](file:///E:/李述铜Linux/自己动手写x86操作系统/参考资料/abi386 4.pdf)这里面记录了函数调用的时候需要保存的寄存器P37 ![image 20240217172138884](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402171721935.png) ![image 20240217172240960](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402171722003.png) > All registers on the Intel386 are global and thus visible to both a calling and a called function. Registers %ebp, %ebx, %edi, %esi, and %esp ‘‘belong’’ to the calling function. In other words, a called function must preserve these registers’ values for its caller. Remaining registers ‘‘belong’’ to the called function. If a calling function wants to preserve such a register value across a function call, it must save the value in its local stack frame. > > 在这个架构里面这部分寄存器属于私有的寄存器, 如果被调函数想要使用需要把这部分函数保存起来, eip会自动保存, esp栈需要单独放在task里面 ![image 20240217173249485](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402171732541.png) ```assembly //simple_switch(&from, to) .text .global simple_switch simple_switch: mov 4(%esp), %eax mov 8(%esp), %edx push %ebp push %ebx push %esi push %edi # 记录当前的栈地址 mov %esp, (%eax) # 栈的切换 mov %edx, %esp pop %edi pop %esi pop %ebx pop %ebp ret ``` ```c void simple_switch(uint32_t ** from, uint32_t * to); void task_switch_from_to (task_t * from, task_t * to){ //switch_to_tss(to >tss_sel); simple_switch(&from >stack, to >stack); } ``` 初始化的时候需要设置一下栈 ```c int task_init(task_t *task, uint32_t entry, uint32_t esp){ ASSERT(task ! (task_t*)0); //tss_init(task, entry, esp); uint32_t *pesp (uint32_t *)esp; if(pesp) { //设置函数 *( pesp) entry; //初始化一下需要的寄存器 *( pesp) 0; *( pesp) 0; *( pesp) 0; *( pesp) 0; task >stack pesp; } return 0; } ```"},"/note/Linux/李述铜手写操作系统/2023-9-7-2x86保护模式下的编程.html":{"title":"x86保护模式下的编程","content":" layout: post title: \"x86保护模式下的编程\" date: 2023 9 7 15:39:08 +0800 tags: 李述铜 # x86保护模式下的编程 ![总体框图](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242301008.jpg) 实现一个小型的操作系统 实模式 >BIOS中断 >保护模式 >GDT/LDT表 ​\t\t\t\t\t\t\t\t\t\t\t\t >TSS任务状态 ​\t\t\t\t\t\t\t\t\t\t\t\t >调用门(系统调用) ## 创建工程 + Makefile文件 ```makefile # 功能：工程目标创建的makefile文件 # # 创建时间：2022年8月31日 # 作者：李述铜 # 联系邮箱: 527676163@qq.com # 相关信息：此工程为《从0写x86 Linux操作系统》的前置课程，用于帮助预先建立对32位x86体系结构的理解 # 课程请见：https://study.163.com/course/introduction.htm?courseId 1212765805&_trace_c_p_k2_ 0bdf1e7edda543a8b9a0ad73b5100990 # 工具链前缀，如果是windows和mac，使用x86_64 elf # 如果是linux，使用x86_64 linux gnu # 工具链前缀，如果是windows和mac，使用x86_64 elf # 如果是linux，使用x86_64 linux gnu ifeq ($(LANG),) \tTOOL_PREFIX x86_64 linux gnu else \tTOOL_PREFIX x86_64 elf endif # GCC编译参数 CFLAGS g c O0 m32 fno pie fno stack protector nostdlib nostdinc # 目标创建:涉及编译、链接、二进制转换、反汇编、写磁盘映像 all: source/os.c source/os.h source/start.S \t$(TOOL_PREFIX)gcc $(CFLAGS) source/start.S \t$(TOOL_PREFIX)gcc $(CFLAGS) source/os.c\t \t$(TOOL_PREFIX)ld m elf_i386 Ttext 0x7c00 start.o os.o o os.elf \t${TOOL_PREFIX}objcopy O binary os.elf os.bin \t${TOOL_PREFIX}objdump x d S os.elf > os_dis.txt\t \t${TOOL_PREFIX}readelf a os.elf > os_elf.txt\t \tdd if os.bin of ../image/disk.img conv notrunc # 清理 clean: \trm f *.elf *.o ``` > 首先进行编译, 之后进行链接文件, 对链接的文件转化为二进制, 二进制的文件最后反汇编, 还有对elf文件进行解析, dd命令会把二进制文件写入磁盘映像文件, 磁盘映像文件会被之后的qemu调用执行 > > 这个命令的作用是将 `os.bin` 文件的内容写入到 `../image/disk.img` 文件中，不截断（`notrunc`）原有的内容。 > > `dd`: 用于复制文件或转换文件格式的命令。 > `if os.bin`: 指定输入文件为 `os.bin`。 > `of ../image/disk.img`: 指定输出文件为 `../image/disk.img`，即磁盘映像文件。 > `conv notrunc`: 指定不截断原有的内容，即在磁盘映像文件中保留原有的内容。 ```json { // See https://go.microsoft.com/fwlink/?LinkId 733558 // for the documentation about the tasks.json format \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"启动qemu\", \"type\": \"shell\", \"command\": \"bash ${workspaceRoot}/script/qemu debug osx.sh\", \"windows\": { // windows下特殊一些 \"command\": \"${workspaceRoot}/script/qemu debug win.bat\", }, \"linux\":{ \"command\": \"bash ${workspaceRoot}/script/qemu debug linux.sh\", }, \"options\": { \"cwd\": \"${workspaceRoot}/../image/\" } }, ] } ``` > 在这里设置了启动qemu的命令 + c文件 ```c /** * 功能：32位代码，完成多任务的运行 * *创建时间：2022年8月31日 *作者：李述铜 *联系邮箱: 527676163@qq.com *相关信息：此工程为《从0写x86 Linux操作系统》的前置课程，用于帮助预先建立对32位x86体系结构的理解。整体代码量不到200行（不算注释） *课程请见：https://study.163.com/course/introduction.htm?courseId 1212765805&_trace_c_p_k2_ 0bdf1e7edda543a8b9a0ad73b5100990 */ #include \"os.h\" ``` + h文件 ```c /** * 功能：公共头文件 * *创建时间：2022年8月31日 *作者：李述铜 *联系邮箱: 527676163@qq.com *相关信息：此工程为《从0写x86 Linux操作系统》的前置课程，用于帮助预先建立对32位x86体系结构的理解。整体代码量不到200行（不算注释） *课程请见：https://study.163.com/course/introduction.htm?courseId 1212765805&_trace_c_p_k2_ 0bdf1e7edda543a8b9a0ad73b5100990 */ #ifndef OS_H #define OS_H #endif // OS_H ``` + 汇编 ```assembly /** * 功能：16位与32位的启动混合代码 * *创建时间：2022年8月31日 *作者：李述铜 *联系邮箱: 527676163@qq.com *相关信息：此工程为《从0写x86 Linux操作系统》的前置课程，用于帮助预先建立对32位x86体系结构的理解。整体代码量不到200行（不算注释） *课程请见：https://study.163.com/course/introduction.htm?courseId 1212765805&_trace_c_p_k2_ 0bdf1e7edda543a8b9a0ad73b5100990 */ \t#include \"os.h\" \t// 声明本地以下符号是全局的，在其它源文件中可以访问 \t.global _start \t// 指定以下的代码生成16位的机器指令，这样才能在启动时的实模式下运行 \t.code16 \t// 以下是代码区 \t.text _start: \tjmp . ``` + qemu ```bash start qemu system i386 m 128M s S drive file disk.img,index 0,media disk,format raw ``` > `qemu system i386`: 这是 QEMU 模拟器的命令，用于启动一个 x86 架构的虚拟机。 > ` m 128M`: 指定虚拟机的内存大小为 128MB。 > ` s`: 启用 GDB 调试，允许在虚拟机运行时进行调试。 > ` S`: 在启动时停止 CPU，等待调试器连接。这样可以在虚拟机启动前设置调试器。 > ` drive`: 指定虚拟机的磁盘映像文件。 > `file disk.img`: 指定磁盘映像文件的名称为 `disk.img`。 > `index 0`: 指定磁盘的索引为 0。 > `media disk`: 指定磁盘的介质类型为磁盘。 > `format raw`: 指定磁盘映像文件的格式为原始格式，即未经过任何压缩或编码的二进制数据。 > > 总之，这个命令的作用是启动一个 x86 架构的虚拟机，并加载一个名为 `disk.img` 的磁盘映像文件，同时启用 GDB 调试功能。 ## 启动方式 首先使用的是16位的模式, 之后会启用BIOS, BIOS进行自检, 运行引导代码, 之后进入操作系统 前三部分是不能控制的, 但是后面的引导代码等是可以自己写的 ### 启动流程 这一堂课使用了一块硬盘, disk.img硬盘, 一般的情况下硬盘是按照数据块512字节进行的, 这是读取的最小单位 还有一块自己的内存, 可以在任意位置进行读取 ![Screenshot_20230908_100954_com.xiaoe.client](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001637.png) BIOS会检查硬盘的第一个扇区的最后两个字节如果是上面的两个数据, 就会进行拷贝, 之后进行执行, 拷贝到0x7c00位置, os.bin文件会通过dd命令写入disk.img文件的开头 ![image 20230908102628762](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001638.png) 没有加载有效字节的结果 ```c \t#include \"os.h\" \t// 声明本地以下符号是全局的，在其它源文件中可以访问 \t.global _start \t// 指定以下的代码生成16位的机器指令，这样才能在启动时的实模式下运行 \t.code16 \t// 以下是代码区 \t.text _start: \tjmp . \t.org 0x1fe\t\t\t\t//十进制是510,在这里跳转到对应的位置 \t.byte 0x55, 0xaa ``` ![image 20230908103332365](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001639.png) > 识别成功 ![image 20230908103606213](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001640.png) > 指令执行的位置到达对应的位置 ## x86处理器编程模型 ### 内核寄存器 + 通用寄存器 ![Screenshot_20230908_104010_com.xiaoe.client](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001641.png) > 可以利用不同的名字对各个寄存器的不同位置进行操作 > > ABCD寄存器是通用寄存器, 16位的时候BX可以用来寻址, 32位的时候都可以 > > BP:基指针寄存器 > > SP和SS指向栈 > > SI和DI一般用于传递数据 + 段寄存器 ![Screenshot_20230908_104329_com.xiaoe.client](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001642.png) > CS和IP指向下一条指令 > > DS数据段寄存器 早期的十六位CPU访问的范围比较小, 所以设置一个起始位置, 之后在上面进行叠加访问 ![Screenshot_20230908_104618_com.xiaoe.client](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001643.png) > 段寄存器的值会进行左移四位, 用来扩大储存数据的位置 > 在这时候把这些全部设置为0, 为了简化操作, 之后直接进行访问就可以了, 这里只设置上面的几个寄存器DS, SS, ES(附加扩展段) > > CS不可以用mov直接写, 可以用jmp设置 > 写操作时，会写入96位，其中源操作数的16位写入到段寄存器的段选择子部分，另外80位会根据段选择子从GDT表（全局描述表）中获取. + EIP 指定当前的程序运行到的位置 + 状态寄存器EFLAGS ![image 20240126145805261](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401261458367.png) 有一些标志位 ![image 20240126145850827](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401261458886.png) ```assembly \t#include \"os.h\" \t// 声明本地以下符号是全局的，在其它源文件中可以访问 \t.global _start \t// 指定以下的代码生成16位的机器指令，这样才能在启动时的实模式下运行 \t.code16 \t// 以下是代码区 \t.text _start: \tjmp $0, $offset\t\t\t//这个是用来设置cs寄存器的, 可以不加,因为会自动跳转 offset: \tmov $0, %ax\t\t\t\t//不能直接对段寄存器进行写入,通过ax进行中转 \tmov %ax, %ds \tmov %ax, %es \tmov %ax, %ss \tmov %ax, %gs \tmov %ax, %fs \tjmp . \t.org 0x1fe\t\t\t\t//十进制是510,在这里跳转到对应的位置 \t.byte 0x55, 0xaa ``` ![image 20230908123951948](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001644.png) + 配置栈空间 设置为栈空间的末尾地址 ```c \t#include \"os.h\" \t// 声明本地以下符号是全局的，在其它源文件中可以访问 \t.global _start \t// 指定以下的代码生成16位的机器指令，这样才能在启动时的实模式下运行 \t.code16 \t// 以下是代码区 \t.text _start: \tjmp $0, $offset\t\t\t//设置cs为0 offset: \tmov $0, %ax \tmov %ax, %ds \tmov %ax, %es \tmov %ax, %ss \tmov %ax, %gs \tmov %ax, %fs \tmov $_start, %esp\t\t//在这里设置栈顶指针 \tjmp . \t.org 0x1fe\t\t\t\t//十进制是510,在这里跳转到对应的位置 \t.byte 0x55, 0xaa ``` ## 加载自己的剩余程序 由于第一块的内存太小, 不够存储所有的代码, 所以需要加载后面的程序 BIOS会提供一些中断, 这里使用的中断是INT 13, 在0地址会有一个中断向量表, 跳转到BIOS的处理函数 入口参数: + ah 2表示读扇区、3表示写扇区 + al 读取/写入的扇区数 + ch 磁道号 + cl 扇区号 + dh 磁头号(对于软盘即面号，对软盘—个面用一个磁头来读写) + dl 驱动器号软驱从0开始，0:软驱A、1:软驱B。硬盘从80H开始，80H:硬盘C、81H:硬盘D + es:bx指向接收从扇区读入数据的内存区/指向将写入磁盘的数据 之前将es设置为0, 所以这里需要设置bx的保存的位置 读取失败的话会把EFLAGS里面的CF设置为1 ```assembly _start: \tmov $0, %ax \tmov %ax, %ds \tmov %ax, %es \tmov %ax, %ss \tmov %ax, %gs \tmov %ax, %fs \tmov $_start, %esp read_self_all: \t//首先设置读取到的位置 \tmov $0x7E00, %bx \t//在这里设置开始的扇区数 \tmov $0x2, %cx \t//在这里设置的是读取的数量,以及是使用的读取模式, 低位是64个扇区, 高位的2是读取磁盘 \tmov $0x240, %ax \t//在这里设置读取的是C盘, 第一块磁盘 \tmov $0x80, %dx \t/调用中断 \tint $0x13 \t//读取失败再次读取 \tjc read_self_all \tjmp . ``` + 测试 ```assembly \tjmp . \t//以下是标志位 \t.org 0x1fe\t\t\t\t//十进制是510,在这里跳转到对应的位置 \t.byte 0x55, 0xaa \t.fill 64*1024, 1, 0x25 ``` > 在后面填进去一些数据 ![image 20230908193552168](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001645.png) ![image 20230908193533914](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001646.png) > img文件以及运行时候内存的文件, 在运行的时候使用这一个命令可以查看对应位置的内存 ## 进入保护模式 在进入系统的时候进入的实际上是16位的CPU工作模式(实模式), 之后需要进入32位的模式 通过段寄存器记录一个基地址, 之后通过偏移量进行访问数据, 这一种模式是比较危险的, 可以随意设置段寄存器的位置, 但是进入保护模式之后对于存储的访问会进行一些检查, 还会检查是否超过边界, 还会有中断向量表以及多任务运行的功能 ### GDT表 > 这一部分在手册第三章 CPU需要一些设置, 首先需要一个GDP表, 还需要修改一个寄存器, 还需要修改段寄存器的设置, 这时候存放的是索引, 这个表的位置保存在GDTR寄存器里面, 表里面记录有大小, 位置, 权限等 在进入32位的模式以后段寄存器记录的值实际上是这一个表里面的偏移, 使用某一段记录的信息进行寻址 每一个字段是8字节 > 这一个表里面的信息除了可以用来记录地址段, 还可以用来进行记录任务切换信息TSS表的位置等 ### 表项的格式 ![image 20230911165013102](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001647.png) > Base: 指明段的地址 > > limit: 段的长度 > > S: 0的时候是系统段, TSS/LDT等, 1的时候表示这一段是数据段或者代码段 > > DPL: 段的访问权限, 0 3 > > > **DPL 0**: 最高特权级，通常用于内核态或操作系统核心。 > > **DPL 1**: 次高特权级，可以用于某些特权操作或驱动程序。 > > **DPL 2**: 较低的特权级，通常用于一些特定的应用程序。 > > **DPL 3**: 最低特权级，通常用于用户态程序。 > > P: 这一个段是否有效 > > D/B: 代码段的时候制定了操作数和地址是32位还是16位, 栈的时候指定了栈是32位还是16位 > > G: 指定limit的单位是byte还是4KB > > L: 64位下面使用 > > AVL: 保留 > > type: 段的类型 > > ![image 20230911170239279](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001648.png) > TSS（任务状态段，Task State Segment）和LDT（局部描述符表，Local Descriptor Table）是处理器在保护模式下管理任务和内存的重要结构。它们各自扮演着不同的角色。 > > ### TSS（任务状态段） > > 1. **定义**：TSS 是一种特殊的段描述符，用于存储与特定任务（或线程）状态相关的信息。 > 2. **作用**： > **保存上下文**：TSS 包含了一些必要的状态信息，如CPU寄存器的值、堆栈指针、段选择子等。这使得操作系统能够在任务切换时保存当前任务的状态并恢复另一个任务的状态。 > **任务切换**：当处理器执行任务切换时，会加载新的TSS，这样处理器就可以从正确的状态继续执行。 > **特权级**：TSS可以用于管理任务的特权级（如内核模式和用户模式），确保不同任务之间的隔离和安全。 > 3. **结构**：TSS 包含多个字段，例如： > 堆栈指针（SS0、ESP0）：用于不同特权级之间的切换。 > I/O 权限位图：用于定义该任务可以访问的I/O端口。 > > ### LDT（局部描述符表） > > 1. **定义**：LDT 是一种描述符表，允许一个进程（或任务）拥有自己的段描述符，用于定义私有代码段和数据段。 > 2. **作用**： > **私有段**：LDT允许每个进程有自己的段描述符，进程可以使用这些描述符访问自己的代码和数据而不干扰其他进程的内存空间。 > **分段支持**：通过LDT，可以实现更灵活的分段管理，使每个任务能够使用不同的段而不影响全局描述符表（GDT）的内容。 > 3. **结构**：LDT类似于GDT，但其描述符只对特定的进程或任务可见，每个任务可以有自己的LDT。 > > ### 总结 > > **TSS** 主要用于任务的状态管理和上下文保存，适用于任务切换。 > **LDT** 提供了一个机制，使每个任务能够拥有自己的段描述符，支持更细粒度的内存管理和保护。 > > 这两者在操作系统的实现中是非常重要的，尤其是在多任务环境中，帮助实现对任务的有效管理和资源的隔离。 + 第一个表段必须为0 + 进入模式的时候需要指定一个代码段和一个数据段 ### 实际使用(设置一个代码段一个数据段) 0xcf9a: 1100 1111 1001 1010 ```c // 各选择子 #define KERNEL_CODE_SEG (1 * 8) #define KERNEL_DATA_SEG (2 * 8) //任务段, 设置任务等级为3 之后由于使用LDT便不再使用 #define APP_CODE_SEG ((3 * 8) 3) #define APP_DATA_SEG ((4 * 8) 3) //任务的TSS保存位置 #define TASK0_TSS_SEG ((5 * 8)) #define TASK1_TSS_SEG ((6 * 8)) //系统调用 #define SYSCALL_SEG ((7 * 8)) //保存两个LDT的描述 #define TASK0_LDT_SEG ((8 * 8)) #define TASK1_LDT_SEG ((9 * 8)) //这里是任务的LDT的配置 #define TASK_CODE_SEG (0 * 8 0x4 3) #define TASK_DATA_SEG (1 * 8 0x4 3) ``` ```c typedef unsigned char uint8_t; typedef unsigned short uint16_t; typedef unsigned int uint32_t; //这一个表需要进行八字节对齐 struct {uint16_t limit_l, base_l, basehl_attr, base_limit;}gdt_table[256] __attribute__((aligned(8))) { // 0x00cf9a000000ffff 从0地址开始，P存在，DPL 0，Type 非系统段，32位代码段（非一致代码段），界限4G， [KERNEL_CODE_SEG / 8] {0xffff, 0x0000, 0x9a00, 0x00cf}, // 0x00cf93000000ffff 从0地址开始，P存在，DPL 0，Type 非系统段，数据段，界限4G，可读写 [KERNEL_DATA_SEG/ 8] {0xffff, 0x0000, 0x9200, 0x00cf}, }; ``` > 这里是初步初始化一个GDT表 ### 开启使用 + 设置GDT的位置之后需要将CR0的最低位PE设置为1(335592 sdm vol 4.pdf) ![image 20240204212101934](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402042121029.png) > lmsw: 将源操作数加载到机器状态字，即寄存器 CR0 的位 0 到 15。源操作数可以是 16 位通用寄存器或内存位置。只有源操作数的低 4 位（也就是 PE、MP、EM 及 TS 标志）会加载到 CR0。CR0 的 PG、CD、NW、AM、WP、NE 及 ET 标志不受影响。操作数大小属性不影响此指令。 + 之后需要进行一次跳转, 跳转位置是选择子+偏移量, 用于清除流水线(335592 sdm vol 4.pdf 9.9) ![image 20240204212645492](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402042126603.png) ```assembly \t//进入保护模式 \t//关中断 \tcli \t//加载新的GDT表 \tlgdt gdt_desc \t//设置CR0的0位, 操作的时候使用16位的操作寄存器 \tmov $1, %eax \tlmsw %ax \t//跳转到内核代码段,进入32位模式,第二个数字是偏移量,也就是C语言程序被复制到的位置, 这一个会改变cs \tjmp $(KERNEL_CODE_SEG),$_start_32 \tjmp . \t//以下是标志位 \t.org 0x1fe\t\t\t\t//十进制是510,在这里跳转到对应的位置 \t.byte 0x55, 0xaa \t \t//标记下面是32位, 以及是代码段 \t.code32 \t.text _start_32: \t//在这里设置段地址 \tmov $KERNEL_DATA_SEG, %ax \tmov %ax, %ds \tmov %ax, %es \tmov %ax, %ss \tmov %ax, %gs \tmov %ax, %fs \tmov $_start, %esp \tjmp . //这里记录的是GDT表的数据,包括32位的基地址以及16位的大小界限 gdt_desc: \t//界限+地址 \t.word (256*8) 1 \t.long gdt_table ``` > 这个gdt_desc的值会放到GDTR寄存器里面, 是一个48位的寄存器, 用来描述GDT表的格式 > > ![image 20240204211734186](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402042117309.png) + 调试 ![image 20230911213220046](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001649.png) ![image 20230911213417535](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001650.png) > 使用命令`info registers` ![image 20230911213826872](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001651.png) > 进入32位模式 ## 分页机制 > 这一部分在手册第四章 在不使用分页机制的时候, 我们看到的是物理内存, 物理内存有多大, 我们就可以使用多大的内存 使用内存分页机制, 我们就可以扩充访问的地址范围, 也可以实现权限的细分, 实际上就是实现虚拟内存, 将地址进行映射, 看到的内存更大了, 但是实际上可以使用的内存的大小还是不变的 访问过程: 根据段寄存器找到对应的记录的GDT表, 之后根据表找到自己的使用的内存, 加上偏移量之后就是实际的地址, 这一个地址会通过分页机制里面的页表, 页表的地址放在CR3的寄存器里面 > 这样会使得用户使用内存的时候感觉是一块连续的内存, 但是实际的内存可能是不连续的 > > 处理器在访问数据、获取指令时，使用的都是线性地址，只要它是连续的就可以了，最终都能够通过映射表找到实际的物理地址。 > > ![image 20240204214518458](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402042145583.png) + 使用4KB的模式, 使用二级页表 ![image 20230912091325312](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001652.png) > 实际的位置使用不同的位进行索引不同的表 + 使用4M的模式: 使用一级页表 ![image 20240204221949465](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402042219580.png) > 这个是现在使用的 > 会根据传过来的数据的地址(逻辑地址)分段之后进行访问不同的页表, 获得一个4KB的空间的地址, 最后通过偏移量进行实际的访问, \"页表（Page Table）\" 或 \"页面目录（Page Directory）\" > > 页表有好几级, 这里的图像是两级, 使用逻辑地址的不同位进行索引 > > 这一个表的地址在CR3里面 > > ![image 20240204220942889](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402042209996.png) > > > CR3以及使用4M模式的一级页表(只有这一个表, 不需要二级页表) > > > > ![image 20250301155653454](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202503011556590.png) > > ![image 20240204221254066](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402042212168.png) > > ![image 20240204221129884](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402042211993.png) > > > 使用4KB模式的时候的一二级页表 > > ![image 20240204215743557](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402042157676.png) > > > 1. **PWT (Page level Write Through)**: > > 该位控制是否使用“直写（Write Through）”缓存策略。 > > 当 PWT 位被设置时，CPU 使用直写缓存策略，这意味着数据会同时写入缓存和主存。 > > 如果 PWT 位未设置，则可能使用回写（Write Back）缓存策略，数据先写入缓存，稍后再写回主存。 > > 2. **PCD (Page level Cache Disable)**: > > 该位控制是否禁用缓存。 > > 当 PCD 位被设置时，页面目录的访问将绕过缓存，直接访问主存。 > > 如果 PCD 位未设置，则允许缓存页面目录的访问。 > > > > 地址是4096对齐的, 所以低位都是0 > > 使用CR4以及CR0控制实际使用的模式 > > ![image 20240205141932827](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402051419994.png) > > > 这一个位控制使用分页 > > ![image 20240204220801499](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402042208601.png) > > ![image 20240204220257786](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402042202892.png) > > > 使用这一个位开启4MB的模式 > > ![image 20240204221645335](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402042216439.png) ### 实际的实现 第一级映射(页目录表PDE)有两种的格式, 一种是4MB的映射, 一种是4KB的映射使用4MB模式的时候, 就不需要二级页表了, 只有一个表, 最后可以使用的内存实际上是4MB, 使用4KB模式的时候会使用两级页表, 最后实际控制的内存大小是4GB 第二级映射(页表PTE) #### 实际实现一级映射(4MB) 需要在打开页表之前实现映射, 否则CPU会找不到对应的内存, 直接映射到0地址的位置 ```c //这个表是否有效 #define PDE_P (1<<0) //是否可写 #define PDE_W (1<<1) //是否可以被低权限访问 #define PDE_U (1<<2) //设置使用的模式(4M模式) #define PDE_PS (1<<7) //定义一个页表的结构体,需要设置低0的表项 //这一个设置的是逻辑地址0地址的分页, 是一个恒等的映射, 使得代码的访问正常, 映射 的地址还是0 uint32_t pg_dir[1024] __attribute__((aligned(4096))) { [0] (0) PDE_P PDE_W PDE_U PDE_PS; }; ``` > ![image 20240204220553713](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402042205861.png) ```assembly _start_32: \t//在这里设置段地址 \tmov $KERNEL_DATA_SEG, %ax \tmov %ax, %ds \tmov %ax, %es \tmov %ax, %ss \tmov %ax, %gs \tmov %ax, %fs \tmov $_start, %esp \t//打开页表, 记录位置 \tmov $pg_dir, %eax \tmov %eax, %cr3 \t//CR4里面有一个位控制是否允许这一个模式 \tmov %cr4, %eax \torl $(1<<4), %eax \tmov %eax, %cr4 \t//还需要控制PR0最高位w为1 \tmov %cr0, %eax \torl $(1<<31), %eax \tmov %eax, %cr0 \tjmp . ``` ![image 20230912100752988](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001653.png) ![image 20230912100916065](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001654.png) > 分页打开后, 可以使用这一个命令查看映射关系, 权限是u: 用户 r: 读 w: 写 #### 实际实现二级映射 ![image 20240204223228835](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402042232954.png) ![image 20240205143304590](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402051433652.png) > 一级表, bit7为0 ![image 20240205143202219](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402051432287.png) > 二级表, bit7为1 ```c //一级页表 //使用位字段的语法 typedef union _pdet_t { uint32_t v; struct { uint32_t present : 1; uint32_t write_enable : 1; uint32_t user_mode_acc : 1; uint32_t write_through : 1; uint32_t cache_disable :1; uint32_t access : 1; uint32_t : 1; uint32_t ps : 1; uint32_t : 4; uint32_t phy_paddr : 20; }; }pdet_t; typedef union _pet_t { uint32_t v; struct { uint32_t present : 1; uint32_t write_enable : 1; uint32_t user_mode_acc : 1; uint32_t write_through : 1; uint32_t cache_disable :1; uint32_t access : 1; uint32_t dirty : 1; uint32_t pat : 1; uint32_t global : 1; uint32_t : 3; uint32_t phy_paddr : 20; }; }pte_t; ``` ```c //这个表是否有效 #define PDE_P (1<<0) //是否可写 #define PDE_W (1<<1) //是否可以被低权限访问 #define PDE_U (1<<2) //设置使用的模式4KB/4MB #define PDE_PS (1<<7) //新建另一个映射的地址 #define MAG_ADDR 0x80000000 //使用二级表进行控制内存测试, 这里是实际上的地址 uint8_t map_phy_buffer[4096] __attribute__((aligned(4096))) {0x36}; //创建一个二级表项,随便给一个值,在后面会进行设置,随便初始化一个值连接器会把其他的位置设置为0,否则会为随机的 static uint32_t page_table[1024] __attribute__((aligned(4096))) {PDE_U}; //定义一个页表的结构体,需要设置低0的表项 uint32_t pg_dir[1024] __attribute__((aligned(4096))) { [0] (0) PDE_P PDE_W PDE_U PDE_PS, }; void os_init(void){ //设置一级表,使用的是表的高10位,这里会找到想要的虚拟地址所在的位置,设置为二级表的位置 /********************************************************************************/ //计算一下4KB的话对应的表项 二级表项地址+权限(这里没有使用4M的映射(PDE_PS)) pg_dir[MAG_ADDR>>22] (uint32_t)page_table PDE_P PDE_W PDE_U; /********************************************************************************/ //初始化表的二级,这里是实际的地址,之后需要设置对应的位置,这里会设置二级表指向的是上面的数组 page_table[(MAG_ADDR>>12)&0x3ff] (uint32_t)map_phy_buffer PDE_P PDE_W PDE_U; } ``` > 实际的地址计算 > > ![image 20240204223356678](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402042233790.png) ```assembly _start_32: \t//在这里设置段地址 \tmov $KERNEL_DATA_SEG, %ax \tmov %ax, %ds \tmov %ax, %es \tmov %ax, %ss \tmov %ax, %gs \tmov %ax, %fs \tmov $_start, %esp \t//在这里调用设置4KB的分页表 \tcall os_init \t# 打开页表机制 \tmov $pg_dir, %eax \tmov %eax, %cr3 \t//CR4里面有一个位控制是否允许这一个模式(这一个没用上) \tmov %cr4, %eax \torl $(1<<4), %eax \tmov %eax, %cr4 \t//还需要控制PR0最高位w为1 \tmov %cr0, %eax \torl $(1<<31), %eax \tmov %eax, %cr0 \tjmp . ``` ![image 20240205144130516](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402051441552.png) ![image 20230912144435370](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001655.png) ![image 20230912144527920](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001656.png) > 在修改之后发现两个位置是同步的, 可以直接操控第二个映射地址或者采用第一个映射的地址 ### 总结 也就是说，在没有开启分页机制时，由程序员给出的**逻辑地址**，需要先通过分段机制转换成物理地址。但在开启分页机制后，逻辑地址仍然要先通过分段机制进行转换，只不过转换后不再是最终的物理地址，而是**线性地址**，然后再通过一次分页机制转换，得到最终的物理地址。 ## 开启定时器 8253定时器, 频率1193180, 16位计数器 一般情况下是内置在CPU里面的, 不需要了解所有的, 因为现在已经内置在CPU里面很多并不需要了解 ![image 20230913092705738](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001657.png) 定时器连接在IRQ0, 一共有三个定时器,其他的中断进行屏蔽 ### IDT表(中断向量表) > 手册6.11 IDTR寄存器进行控制, 中断发生的时候会参考这一个表进行进行处理, 表里面记录的值是段的选择子以及偏移, 用于查找一个一个GDT表的表项, 应该是代码段的描述符, 之后使用offset进行偏移 定时器的中断会使用0x20位置的中断 ![image 20230913093734029](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001658.png) > Segment Selector 这里记录是段选择子, 指向GDT表的某一个段, 这里应该是代码段 > > Offset 偏移, 具体的处理函数所在的位置 > > D 表示是否是32位模式 > > P 存在的标志位 > > 通过中断门进入中断服务程序时cpu会自动将中断关闭，也就是将cpu中eflags寄存器中IF标志复位，防止嵌套中断的发生；而通过陷阱门进入服务程序时则维持IF标志不变。 ### 实际的实现 对于intel架构的CPU在操控外设的寄存器的时候使用命令out, ARM的时候直接操控寄存器映射 中断在使用的时候需要设置具体的表项,前面的表项已经被CPU使用了 > 手册6.3章节 > > 时钟实际使用的是IRQ0, 需要查找的位置是0x20, 从片使用的位置是0x28开始 ```assembly \t#include \"os.h\" \t// 声明本地以下符号是全局的，在其它源文件中可以访问,在这里声明中断处理函数 \t.global _start, timer_int \t// 指定以下的代码生成16位的机器指令，这样才能在启动时的实模式下运行 \t.code16 \t// 以下是代码区 \t.text \t \t... \t \t//关中断 \tcli \t//加载新的GDT表 \tlgdt gdt_desc \t//加载中断向量表 \tlidt idt_desc \t... \t _start_32: \t... \t//在这里跳转到C文件初始化中断以及初始化段 \tcall os_init \t//打开页表 \tmov $pg_dir, %eax \tmov %eax, %cr3 \t//CR4里面有一个位控制是否允许这一个模式 \tmov %cr4, %eax \torl $(1<<4), %eax \tmov %eax, %cr4 \t//还需要控制PR0最高位w为1 \tmov %cr0, %eax \torl $(1<<31), %eax \tmov %eax, %cr0 \t//打开中断 \tsti \tjmp . //中断处理函数 timer_int: \t//对寄存器进行保护 \tpush %ds \tpusha \t//清除中断 \tmov $0x20, %al \toutb %al, $0x20 \t \tpopa \tpop %ds \t \tiret //这里记录的是GDT表的数据,包括32位的基地址以及16位的大小界限 gdt_desc: \t//界限+地址 \t.word (256*8) 1 \t.long gdt_table //描述中断的数据 idt_desc: \t//界限+地址 \t.word (256*8) 1 \t.long idt_table ``` ```c //中断向量表 struct {uint16_t offset_l, selector, attr, offset_h;}idt_table[256] __attribute__((aligned(8))); //对汇编指令进行一个封装 void outb(uint8_t data,uint16_t port){ //这里传入两个数据,第一个数据是data,第二个数据是port,之后进行数据的关联,\"d\"会识别为%dx,之后会把port放进去 __asm__ __volatile__(\"outb %[v], %[p]\"::[p]\"d\"(port), [v]\"a\"(data)); } //在汇编文件中实现的中断处理函数 void timer_int(void); //初始化一个页表,并在之后设置为0x80000000映射到这一个数组的位置 void os_init(void){ //初始化定时器 //初始化中断控制器(使用0x20 0x21控制主片以及使用0xA0和0xA1控制从片) outb(0x11, 0x20); outb(0x11, 0xA0); //设置主片的中断起始位置 outb(0x20, 0x21); //设置从片的中断起始位置 outb(0x28, 0xa1); //设置从片连接主片的位置 outb((1<<2), 0x21); //设置从片连接主片使用的引脚 outb(2, 0xa1); //设置连接的模式 outb(0x1,0x21); outb(0x1,0xa1); //设置中断的屏蔽, 这里只打开定时器的中断 outb(0xfe,0x21); outb(0xff,0xa1); //配置外部时钟源,是一个16位的计数器,减到0的时候会产生中断,这里计算每秒产生100次中断大概需要的数值 int tmo 1193180 / 100;//使用实际的频率除以100使得每秒100次中断 //写入数值 //设置使用的时钟以及自动加载 outb(0x36, 0x43); //中断频率的设置 outb((uint8_t)tmo, 0x40); outb(tmo>>8, 0x40); //记录中断处理函数的地址 idt_table[0x20].offset_l (uint32_t)timer_int & 0xffff; idt_table[0x20].offset_h (uint32_t)timer_int >> 16; idt_table[0x20].selector KERNEL_CODE_SEG; //设置为中断门,32位模式 idt_table[0x20].attr 0x8e00; //设置一级表,使用的是表的高10位 pg_dir[MAG_ADDR>>22] (uint32_t)page_table PDE_P PDE_W PDE_U; //初始化表的二级,这里是实际的地址,之后需要设置对应的位置 page_table[(MAG_ADDR>>12)&0x3ff] (uint32_t)map_phy_buffer PDE_P PDE_W PDE_U; } ``` + 任务门(task gate) 当中断信号发生时，必须取代当前进程的那个进程的TSS选择符存放在任务门中。 + 中断门(interruptgate) 包含段选择符和中断或异常处理程序的段内偏移量.当控制权转移到一个适当的段 时，处理器 清IF标志，从而关闭将来会发生的可屏蔽中断., 主要是为了INTR中断(计算机系统中的一种机制，用于在CPU执行程序时，暂停当前程序的执行，转而执行其他程序或处理器的中断请求)。 + 陷阱门(Trap gate) 与中断门相似，只是控制权传递到一个适当的段时处理器不修改IF标志.所以依旧会产生INTR中断 ### 总结 在使用分页以后在进行访问内存的时候, 首先会进行分页表找到实际的物理地址, 之后在根据GDT表对实际的物理地址权限等进行分类, 最后在进行操作 ## 切换到低特权模式 ![image.png](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001659.png) 最高等级一般是操作系统, 可以访问所有的资源Level 0, 应用一般使用最低等级 只允许访问相同等级或者低权限的代码或者数据 用户级不允许执行一些命令, 以及不允许访问一些区域, 方便操作系统对其进行检测, 杀掉或者进行其他处理 ![image 20240206194427159](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402061944137.png) CPU会执行CS指针指向的代码段, CS的最低两位CPL代表的是访问的时候的特权等级, GDT表里面的DPL设置的是这一个段的访问权限, 其他的段寄存器最低位存放的是RPL进行特权级的检查 > 段选择子是8byte为单位的, 所以低两位没有使用 ![image 20240220175154923](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402201751004.png) > 这个时候的权限只有DPL> Max(CPL, RPL)的时候才可以访问, 自己的权限要高, 不能主动把自己的权限降低 > > 访问SS(栈段寄存器)的时候需要CPL DPL RPL 在GDP里还有一个C位(Type里面) + C 0(用的这一个) CPL必须等于DPL, 并且RPL< CPL的时候才可以访问 + C 1 CPL> DPL, RPL不检查, 访问者的权限比较低的时候可以访问 ### 设计一段进程 进程不可以使用内核段的数据段以及数据段, 这里给它添加两个段 ```c struct {uint16_t limit_l, base_l, basehl_attr, base_limit;}gdt_table[256] __attribute__((aligned(8))) { // 0x00cf9a000000ffff 从0地址开始，P存在，DPL 0，Type 非系统段，32位代码段（非一致代码段），界限4G， [KERNEL_CODE_SEG / 8] {0xffff, 0x0000, 0x9a00, 0x00cf}, // 0x00cf93000000ffff 从0地址开始，P存在，DPL 0，Type 非系统段，数据段，界限4G，可读写 [KERNEL_DATA_SEG/ 8] {0xffff, 0x0000, 0x9200, 0x00cf}, //这里是进程使用的段, 这里使用的是重合的模式, 设置优先级为3 [APP_CODE_SEG /8] {0xffff, 0x0000, 0xfa00, 0x00cf}, [APP_DATA_SEG /8] {0xffff, 0x0000, 0xf300, 0x00cf}, }; ``` + 实际的特权切换 在切换的时候不能使用jmp指令, 而是应该使用iret命令从中断返回的指令, 需要对栈进行配置(模拟从中断返回) ![image.png](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001660.png) ![image 20240206200132789](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001909.png) > 手册6.12 这里相当于从一个中断函数进行返回, 在进入中断的时候会自动保存上面右侧显示的寄存器内容, SS栈的段寄存器, ESP栈的指针, CS代码段段寄存器, EIP指令对应的地址, 返回的时候会自动设置这些值 > 为了进行特权级的切换, 需要把这两个段寄存器的最低位设置为3, 标志使用用户等级的段 ![image 20230920130514065](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001661.png) > 这设置设个的时候主要是需要设置中断标志位为使能中断,设置为0x202(0010 0000 0010) ### 实际实现的代码 ```c //任务段, 设置任务等级为3 之后由于使用LDT便不再使用 #define APP_CODE_SEG ((3 * 8) 3) #define APP_DATA_SEG ((4 * 8) 3) ``` ```assembly \t//打开中断, 由于在进入任务的时候会设置IF位, 所以在这里的时候不再进行设置 \t//sti \t \t//设置进入低特权级时候的所需要的栈 \tpush $APP_DATA_SEG \t//设置栈的指针 \tpush $0 \t//设置EFLAGS, 主要是设置中断的状态 \tpush $0x202 \t//这是代码段 \tpush $APP_CODE_SEG \tpush $task_0_entry \t//在这里进入低特权级 \tiret \tjmp . //进程0 task_0_entry: \tjmp . ``` > 这时候会出现异常, 这是因为CPU在出战的时候会进行检查, 这时候发现代码段数据段的最低位没有设置为对应的权限 ```c // 各选择子 #define KERNEL_CODE_SEG (1 * 8) #define KERNEL_DATA_SEG (2 * 8) #define APP_CODE_SEG ((3 * 8) 3) #define APP_DATA_SEG ((4 * 8) 3) ``` ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001662.png) > 进入特权级3的模式 + 之后需要给这一个特权级的任务定义一个数组作为栈 ![image 20230920230330223](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001663.png) > 最好先把中断关掉, 否则会死机(先push一个0给EFLOG), 这是因为没有设置TSS, 进入中断的话没有可以使用的栈 ## 实现任务切换(使用TSS) > • The current program, task, or procedure executes a JMP or CALL instruction to a TSS descriptor in the GDT. > > • The current program, task, or procedure executes a JMP or CALL instruction to a task gate descriptor in the GDT or the current LDT. x86实现了任务切换的硬件上的支持, 只需要给每一个任务一个TSS就可以方便的使用一条指令进行任务切换 ![image.png](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001664.png) > x86使用一个这样的结构进行保存任务的状态 > > 这里面存放的是当前任务的状态, CPU会自动把寄存器的状态存放在这里面 > > 这里面的SS, ESP等有多个是给不同特权级的时候使用不同的段, 在处理终中断的时候使用不同的栈 > > 在使用的时候可以使用一个jmp指令进行跳转 > > 使用**TR寄存器**指向当前的任务 ![image 20230920232807856](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001665.png) > 在产生中断的时候会从特权级0的位置找到栈, 之后执行中断相关的内容 ![image 20230921083651573](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001666.png) 需要在GDT里面使用两个段来记录两个任务的TSS, 通过GDT的描述符进行区分 ![image.png](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001667.png) > Base: 起始地址 > > Segment Limit: 界限 1 > > DPL: 段的访问权限, 0 3 > > P: 这一个段是否有效 > > G: 指定limit的单位是byte还是4KB > > AVL: 保留 > > type: 段的类型 > > B: 忙标志 ```c //任务的TSS保存位置 #define TASK0_TSS_SEG ((5 * 8)) #define TASK1_TSS_SEG ((6 * 8)) //这一个表需要进行八字节对齐 struct {uint16_t limit_l, base_l, basehl_attr, base_limit;}gdt_table[256] __attribute__((aligned(8))) { \t.... //TSS表, 由于直接使用一个数组作为TSS会导致报错,这里基地址初始化为0, 后面在C语言里面加地址 [TASK0_TSS_SEG /8] {0x68, 0, 0xe900, 0}, [TASK1_TSS_SEG /8] {0x68, 0, 0xe900, 0}, }; .... //初始化几个32位的栈, 使用模式为特权级3 uint32_t task0_dpl3_stack[1024];//用户级的栈 uint32_t task1_dpl3_stack[1024]; uint32_t task0_dpl0_stack[1024];//系统级的栈 uint32_t task1_dpl0_stack[1024]; //定义一个TSS结构 //任务切换的时候栈之类的寄存器不会保存, 需要初始化设置 uint32_t task0_tss[] { // prelink, esp0, ss0, esp1, ss1, esp2, ss2 0, (uint32_t)task0_dpl0_stack + 4*1024, KERNEL_DATA_SEG , /* 后边不用使用 */ 0x0, 0x0, 0x0, 0x0, // cr3, eip, eflags, eax, ecx, edx, ebx, esp, ebp, esi, edi, (uint32_t)pg_dir, (uint32_t)task_0/*入口地址*/, 0x202, 0xa, 0xc, 0xd, 0xb, (uint32_t)task0_dpl3_stack + 4*1024/* 栈 */, 0x1, 0x2, 0x3, // es, cs, ss, ds, fs, gs, ldt, iomap APP_DATA_SEG, APP_CODE_SEG, APP_DATA_SEG, APP_DATA_SEG, APP_DATA_SEG, APP_DATA_SEG, 0x0, 0x0, }; //设置要切换的任务的栈以及任务的入口 uint32_t task1_tss[] { // prelink, esp0, ss0, esp1, ss1, esp2, ss2 0, (uint32_t)task1_dpl0_stack + 4*1024, KERNEL_DATA_SEG , /* 后边不用使用 */ 0x0, 0x0, 0x0, 0x0, // cr3, eip, eflags, eax, ecx, edx, ebx, esp, ebp, esi, edi, (uint32_t)pg_dir, (uint32_t)task_1/*入口地址*/, 0x202, 0xa, 0xc, 0xd, 0xb, (uint32_t)task1_dpl3_stack + 4*1024/* 栈 */, 0x1, 0x2, 0x3, // es, cs, ss, ds, fs, gs, ldt, iomap APP_DATA_SEG, APP_CODE_SEG, APP_DATA_SEG, APP_DATA_SEG, APP_DATA_SEG, APP_DATA_SEG, 0x0, 0x0, }; ..... \t//这里使用的内存比较小 gdt_table[TASK0_TSS_SEG / 8].base_l (uint16_t)(uint32_t)task0_tss; gdt_table[TASK1_TSS_SEG / 8].base_l (uint16_t)(uint32_t)task1_tss; ``` + 使用TR寄存器保存当前的任务的TSS对应的GDT位置, 需要使用汇编指令设置这一个值 ````assembly \t//告诉CPU正在运行的任务 \tmov $TASK0_TSS_SEG, %ax \tltr %ax ```` ```assembly //中断处理函数 timer_int: \t//对寄存器进行保护 \tpush %ds \tpusha \t//清除中断 \tmov $0x20, %al \toutb %al, $0x20 \t//配置使用的数据段, 因为处于特权级0, 需要访问 \tmov $KERNEL_DATA_SEG, %ax \tmov %ax, %ds \t//调用切换任务的函数 \tcall task_sched \tpopa \tpop %ds \t \tiret ``` ```c void task_sched(void){ static int task_tss TASK0_TSS_SEG; task_tss (task_tss TASK0_TSS_SEG) ? TASK1_TSS_SEG : TASK0_TSS_SEG; uint32_t addr[] {0, task_tss};//偏移以及选择子 __asm__ __volatile__(\"ljmpl *(%[a])\"::[a]\"r\"(addr)); } ``` > `*()` 是通过间接寻址方式访问内存中的内容。在这段代码中，`*(%[a])` 表示将 `%[a]` 所代表的地址作为一个指针，然后访问这个指针指向的内存位置。 > > 在远跳指令 `ljmp` 中，需要跳转的目标地址是通过一个指针来指定的。所以，使用 `*()` 来对指针进行间接寻址，以获取指针所指向的内容（即跳转目标地址），并将该地址作为参数传递给 `ljmp` 指令。 > > 在这段代码中，`*(%[a])` 中的 `%[a]` 是一个占位符，用来表示汇编代码中的输入变量 `[a]`，即地址数组 addr 的地址。所以 `*(%[a])` 表示获取 addr 数组的地址所对应的内容，即跳转的目标地址。 ![image 20230921100950824](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001668.png) > 跳转之前的任务1 ![image 20230921101039232](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001669.png) ![image 20230921101421193](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001670.png) > 跳转之后, 有一些寄存器会发生自动的更改, 这时候的段寄存器发生了变化, 由于是在中断中发生的 ![image 20230921101010695](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001671.png) > 这是任务1没有开始执行的时候的数据 ![image 20230921101832319](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001672.png) > 进入任务1以后会写入寄存器里面 ## 增加系统调用 允许应用调用操作系统的一些函数, 主要是由于权限, 需要在特区级下面运行一些操作 页表相关设置的时候有一个设置是PDE_U位, 这时候用户就可以访问这一段地址, 否则就是需要系统操作级来进行操作 实现系统调用的话使用的是系统调用门, 也是GDT表里面的一项 ![image 20240207134441751](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402071344960.png) ![image.png](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001673.png) > 这里填写的是选择子, 指向一个代码段, 也是注册在GDT表里面, 以及一个函数位置的偏移 > > 1. 调用门描述符给出了代码段的选择子，有了段选择子，就可以访问GDT或者LDT得到代码段的基地址, 需要选择内核代码段, 用于进行权限的切换 > 2. 指的是偏移量, 实际指向的就是要运行的函数 > 3. TYPE字段用于标识门的类型，1100表示调用门。 > 4. P: 描述符中的P位是有效位，通常是1。当它为0时，调用这样的门会导致处理器产生异常。 > 5. DPL字段指明调用门的特权级，从而指定通过调用门访问特定过程所要求的特权级。 > 6. Param Count: 参数个数字段指明在发生堆栈切换时从调用者堆栈复制到新堆栈中的参数个数。 > > ```c > //这里是系统调用,首先不初始化任务的函数地址, 之后是系统代码段, 权限设置为3, 使用三个参数 > [SYSCALL_SEG / 8] {0x0000, KERNEL_CODE_SEG, 0xec03, 0}, > > //设置系统调用函数的地址 > gdt_table[SYSCALL_SEG / 8].limit_l (uint16_t)(uint32_t)syscall_handler; > ``` > ![image 20240222115654303](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402221156534.png) ![image 20240222115814460](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402221158524.png) > 栈里面的参数的传递 需要的权限 ![image 20240222120542064](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402221205111.png) ![image 20240222120318424](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402221203487.png) ![image 20240222120338844](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402221203899.png) ### 在屏幕显示 ```c void task_0(void) { uint8_t color 0; unsigned short *dest (unsigned short *)0xb8000; dest [0] 'a' 0x3500;//在这个地址写入一个'a'字符 for(;;){ color++; } } ``` > 显示一个字符, 这一块是内存的位置, 这是一个80列25行的位置 > > ![image 20230921161254909](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001674.png) > > 有80列25行 ```c //系统调用 void do_syscall(int func, char * str, char color) { static int row 1; if(func 2) { //显示一个字符串 //计算一下实际写入的位置 unsigned short *dest (unsigned short *)0xb8000 + 80*row; while(*str){ *dest ++ *str ++ (color<<8); } row (row> 25)?0:row+1; for(int i 0;i<0xffffff;i++); } } ``` ### 实现系统调用的参数传递 在使用的时候需要人工传递一下参数 ![image 20230921165941136](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001675.png) > 会按照之前设置的参数, 会自动从栈里面取出来三个参数到系统的栈里面, 这个三是系统调用设置的那一个 > > 之后人工把这三个值复制到系统栈最前面, 用于C语言的函数调用 ```c //这一个函数给用户使用 void sys_show(char *str, char color) { //这个是调用门的跳转位置, 偏移量不需要, 需要一个系统调用门的GDT偏移 uint32_t addr[] {0, SYSCALL_SEG}; \t//把这几个参数记录一下, 然后调用系统调用门 __asm__ __volatile__(\"push %[color];push %[str];push %[id];lcalll *(%[a])\":: [a]\"r\"(addr), [color]\"m\"(color), [str]\"m\"(str), [id]\"r\"(2)); } ``` > 传入使用的三个参数, 之后跳转到对应的GDT对应的位置 > > ```c > //设置系统调用函数的地址 > gdt_table[SYSCALL_SEG / 8].limit_l (uint16_t)(uint32_t)syscall_handler; > ``` > > 这个函数是在汇编文件里面实现的 之后再由汇编到C的时候传递参数使用的栈 ```assembly syscall_handler: \t//对寄存器进行保护 \tpush %ds \tpusha \t//使用内核数据段 \tmov $KERNEL_DATA_SEG, %ax \tmov %ax, %ds \t//获取传进来的参数, 之后再次入栈 \tmov %esp, %ebp \tpush 13*4(%ebp) \tpush 12*4(%ebp) \tpush 11*4(%ebp) \tcall do_syscall \t//把之前的三个参数取出来 \tadd $(3*4), %esp \tpopa \tpop %ds \t//由于这时候使用的特权级的栈, 返回的时候用使用这一个, 后面的参数是需要从栈里面取出来的参数个数 \tretf $(3*4) ``` ```c //这是系统调用在高权限的时候执行的函数 void do_syscall(int func, char * str, char color) { static int row 1; if(func 2) { unsigned short *dest (unsigned short *)0xb8000 + 80*row; while(*str){ *dest ++ *str ++ (color<<8); } row (row> 25)?0:row+1; for(int i 0;i<0xffffff;i++); } } ``` ```c //任务1 void task_0(void) { char * str \"task1 a:1234\"; uint8_t color 0; for(;;){ \t//在这里可以调用系统接口 sys_show(str, color++); } } ``` ### 另一种系统调用int $0x80 可以使用命令int $num的方式进行调用一个中断 ![image 20240222150221562](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402221502627.png) ## LDT GDT: Global Descriptor Table LDT: Local Descriptor Table GDT可以被多个进程使用, LDT是每一个进程都有属于自己的一个表, 这会记录在TSS和GDT里面, TSS里面记录的是GDT里面的位置 + LDT的作用 之前使用的时候直接把段设置为同一个代码段, 所以进程空间被两个进程同时使用, 相互之间的数据可以被看到 ![image 20230922142341114](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001676.png) > CS和DS使用相同的值但是访问的内存的位置是不同的 > > ![image 20240207150405514](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402071504563.png) ![image 20230922142400371](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402062001677.png) > 使用LDTR保存当前使用的LDT表, 每一个进程的LDT存在他的TSS里面 > > ![image 20240207144407930](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402071444008.png) CPU会根据段寄存器的第2位来选择从GDT还是LDT获取信息, 1的时候是LDT, 0和1位设置的是权限 ```c //保存两个LDT的描述, 这个是GDT表里面使用的 #define TASK0_LDT_SEG ((8 * 8)) #define TASK1_LDT_SEG ((9 * 8)) //这里是任务的LDT的配置 #define TASK_CODE_SEG (0 * 8 0x4 3) #define TASK_DATA_SEG (1 * 8 0x4 3) ``` ```assembly \t//打开中断, 由于在进入任务的时候会设置IF位, 所以在这里的时候不再进行设置 \t//sti \t \t//告诉CPU正在运行的任务 \tmov $TASK0_TSS_SEG, %ax \tltr %ax \t//设置任务的LDT \tmov $TASK0_LDT_SEG, %ax \tlldt %ax \t//设置进入低特权级时候的所需要的栈, 这时候在使用的就是LDT的位置了 \tpush $TASK_DATA_SEG \t//设置栈的指针 \tpush $task0_dpl3_stack + 1024*4 \t//设置EFLAGS, 主要是设置中断的状态 \tpush $0x202 \t//这是代码段 \tpush $TASK_CODE_SEG \tpush $task_0_entry \t//在这里进入低特权级 \tiret \tjmp . ``` ![image 20240207145219679](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402071452732.png) ```c //定义一个TSS结构, 这个是任务一的表 uint32_t task0_tss[] { // prelink, esp0, ss0, esp1, ss1, esp2, ss2 0, (uint32_t)task0_dpl0_stack + 4*1024, KERNEL_DATA_SEG , /* 后边不用使用 */ 0x0, 0x0, 0x0, 0x0, // cr3, eip, eflags, eax, ecx, edx, ebx, esp, ebp, esi, edi, (uint32_t)pg_dir, (uint32_t)task_0/*入口地址*/, 0x202, 0xa, 0xc, 0xd, 0xb, (uint32_t)task0_dpl3_stack + 4*1024/* 栈 */, 0x1, 0x2, 0x3, // es, cs, ss, ds, fs, gs, ldt, iomap TASK_DATA_SEG, TASK_CODE_SEG, TASK_DATA_SEG, TASK_DATA_SEG, TASK_DATA_SEG, TASK_DATA_SEG, TASK0_LDT_SEG, 0x0, }; //这个是任务二的表 uint32_t task1_tss[] { // prelink, esp0, ss0, esp1, ss1, esp2, ss2 0, (uint32_t)task1_dpl0_stack + 4*1024, KERNEL_DATA_SEG , /* 后边不用使用 */ 0x0, 0x0, 0x0, 0x0, // cr3, eip, eflags, eax, ecx, edx, ebx, esp, ebp, esi, edi, (uint32_t)pg_dir, (uint32_t)task_1/*入口地址*/, 0x202, 0xa, 0xc, 0xd, 0xb, (uint32_t)task1_dpl3_stack + 4*1024/* 栈 */, 0x1, 0x2, 0x3, // es, cs, ss, ds, fs, gs, ldt, iomap TASK_DATA_SEG, TASK_CODE_SEG, TASK_DATA_SEG, TASK_DATA_SEG, TASK_DATA_SEG, TASK_DATA_SEG, TASK1_LDT_SEG, 0x0, }; ``` ![image 20240207145829919](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402071458978.png) ![image 20250304153737379](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202503041537535.png) ```c //任务的LDT [TASK0_LDT_SEG / 8] {sizeof(task0_ldt_table 1), 0x0, 0xe200, 0x00c0}, [TASK1_LDT_SEG / 8] {sizeof(task1_ldt_table 1), 0x0, 0xe200, 0x00c0}, //设置LDT的起始位置 gdt_table[TASK0_LDT_SEG / 8].base_l (uint16_t)(uint32_t)task0_ldt_table; gdt_table[TASK1_LDT_SEG / 8].base_l (uint16_t)(uint32_t)task1_ldt_table; ``` ## 总结 + 首先BIOS会把磁盘第一部分加载到0x7c00的位置,加载512字节, 之后在这一段运行之后把其他的应用加载到内存 + 之后了解了通用寄存器和段寄存器, 段寄存器用于内存的访问, 还有EIP和EFLAG寄存器 + 之后使用了一些数据结构, GDT: 指示某一个内存区域的作用, LDT: 记录进程自己的区域, TSS: 进程的运行状态保存的位置, IDT: 中断向量表 + 几个不同的特权级, 特权级切换: 中断发生的时候, 使用系统调用的时候 + 分页机制: 使用之后, CPU操控的就不再是实际的内存空间, 会把地址分为三部分, 之后根据这个进行地址的索引"},"/note/Linux/李述铜手写操作系统/2023-9-6-01补充知识2.html":{"title":"补充知识2","content":" layout: post title: \"补充知识2\" date: 2023 9 6 15:39:08 +0800 tags: 李述铜 # 补充知识2 ## CMake ### 文件 特征 `.mk` 文件（micropython.mk） `.cmake` 文件（micropython.cmake） 适配工具 Make（GNU Make） CMake 语法 Makefile 语法（变量、规则） CMake 专属指令（更接近高级语言） 核心变量 / 指令 `SRC_USERMOD_C`、`CFLAGS_USERMOD` `add_library`、`target_link_libraries` 适用移植版 STM32、Unix、ESP8266 ESP32、RP2040、ESP32 S3 核心目标 给 Make 加编译规则 给 CMake 加编译规则并链接到 usermod ### 注释 #### 注释行 `CMake` 使用 `#` 进行`行注释`，可以放在任何位置。 ```cmake # 这是一个 CMakeLists.txt 文件 cmake_minimum_required(VERSION 3.0.0) ``` #### 注释块 `CMake` 使用 `#[[ ]]` 形式进行`块注释`。 ```cmake #[[ 这是一个 CMakeLists.txt 文件。 这是一个 CMakeLists.txt 文件 这是一个 CMakeLists.txt 文件]] cmake_minimum_required(VERSION 3.0.0) ``` ### 命令 #### 必要声明 + cmake_minimum_required : 所需要的最低的版本, 这个是非必要的 ````cmake cmake_minimum_required(VERSION 3.0.0) ```` + `project`：定义工程名称，并可指定工程的版本、工程描述、web主页地址、支持的语言（默认情况支持所有语言），如果不需要这些都是可以忽略的，只需要指定出工程名字即可。 ```cmake # PROJECT 指令的语法是： project(<PROJECT NAME> [<language name>...]) project(<PROJECT NAME> [VERSION <major>[.<minor>[.<patch>[.<tweak>]]]] [DESCRIPTION <project description string>] [HOMEPAGE_URL <url string>] [LANGUAGES <language name>...]) ``` #### 构建文件命令 默认情况下，`make` 会构建： **所有未标记为 `EXCLUDE_FROM_ALL` 的可执行文件** **所有未标记为 `EXCLUDE_FROM_ALL` 的库** **标记了 `ALL` 参数的自定义目标** + `add_executable`：定义工程会生成一个可执行程序 ```cmake add_executable(<target> [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL] source1 [source2 ...]) ``` > 在指定原文件的时候可以使用空格或者使用;进行间隔 > > EXCLUDE_FROM_ALL: 默认构建的时候不构建这个文件 + add_custom_target 用于**创建自定义构建目标**的命令，这些目标不是编译输出（如库或可执行文件），而是用于执行特定任务的\"伪目标\", 在每一次构建目标的时候调用, 不产生具体的文件 ```cmake add_custom_target(Name [ALL] [command1 [args1...]] [COMMAND command2 [args2...] ...] [DEPENDS depend depend depend ... ] [BYPRODUCTS [files...]] [WORKING_DIRECTORY dir] [COMMENT comment] [VERBATIM] [USES_TERMINAL] [SOURCES src1 [src2...]]) ``` > + ``ALL` `: 默认的构建目标, make的时候自动运行 > + ``DEPENDS` `: 依赖关系管理 > + ``BYPRODUCTS` `: 指定生成的文件 + add_custom_command 用于**添加自定义构建规则**的命令，它可以生成文件或执行特定的构建任务。 ```cmake # 构建事件, 在目标构建的特定阶段执行命令 add_custom_command( TARGET target PRE_BUILD PRE_LINK POST_BUILD COMMAND command1 [ARGS] [args1...] [COMMAND command2 [ARGS] [args2...] ...] [BYPRODUCTS [files...]] [WORKING_DIRECTORY dir] [COMMENT comment] [VERBATIM] [USES_TERMINAL] [COMMAND_EXPAND_LISTS] ) # 生成文件 add_custom_command( OUTPUT output1 [output2 ...] COMMAND command1 [ARGS] [args1...] [COMMAND command2 [ARGS] [args2...] ...] [MAIN_DEPENDENCY depend] [DEPENDS [depends...]] [BYPRODUCTS [files...]] [IMPLICIT_DEPENDS <lang1> depend1 [<lang2> depend2] ...] [WORKING_DIRECTORY dir] [COMMENT comment] [DEPFILE depfile] [JOB_POOL job_pool] [VERBATIM] [APPEND] [USES_TERMINAL] [COMMAND_EXPAND_LISTS] ) ``` > PRE_BUILD: 构建前, PRE_LINK: 链接前, POST_BUILD: 构建以后 > > WORKING_DIRECTORY: 指定命令执行的工作目录 特性 add_custom_target add_custom_command : : : 目标类型 总是构建的伪目标 特定文件的构建规则 执行时机 每次构建目标时 文件不存在或依赖更新时 输出 不产生具体文件 产生具体输出文件 典型用途 文档生成、测试、打包 代码生成、文件处理 依赖管理 可以依赖其他目标 通常被其他目标依赖 示例 ```cmake # 1. 自定义命令生成文件 add_custom_command( OUTPUT generated_sources.cpp COMMAND generator_tool input.xml generated_sources.cpp DEPENDS input.xml generator_tool ) # 2. 自定义目标触发生成（可选） add_custom_target(generate_sources DEPENDS generated_sources.cpp COMMENT \"Forcing source generation\" ) # 3. 主目标使用生成的文件 add_executable(main main.cpp generated_sources.cpp) ``` + set_target_properties `set_target_properties` 是 CMake 中用于**设置目标属性**的命令，它可以修改或配置已创建目标的各种行为和特性。 ```cmake set_target_properties(target1 [target2 ...] PROPERTIES prop1 value1 prop2 value2 ...) ``` > OUTPUT_NAME: 输出文件名（不含扩展名） > > RUNTIME_OUTPUT_DIRECTORY: 可执行文件输出目录 > > LIBRARY_OUTPUT_DIRECTORY: 库文件输出目录 > > ARCHIVE_OUTPUT_DIRECTORY: 静态库输出目录 #### 基本使用 ```cmake cmake_minimum_required(VERSION 3.0.0) project(jiao) add_executable(result main.c add.c sub.c) ``` > 在想要生成文件的文件夹里面使用命令`cmake CMakeList.txt所在的文件夹的路径`, 之后会生成Makefile文件, 然后使用命令make就可以生成目标文件 ### 命令2 + set: 定义变量, 这时候存储的数据都是字符串 ```cmake # SET 指令的语法是： # [] 中的参数为可选项, 如不需要可以不写 SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]]) ``` > `VAR`：变量名`VALUE`：变量值 ```cmake set(SRC_LIST main.c add.c sub.c) add_executable(result ${SRC_LIST}) ``` + 指定c++的标准 ```cmake #增加 std c++11 set(CMAKE_CXX_STANDARD 11) #增加 std c++14 set(CMAKE_CXX_STANDARD 14) #增加 std c++17 set(CMAKE_CXX_STANDARD 17) ``` > 直接设置使用的版本 ```shell #增加 std c++11 cmake CMakeLists.txt文件路径 DCMAKE_CXX_STANDARD 11 #增加 std c++14 cmake CMakeLists.txt文件路径 DCMAKE_CXX_STANDARD 14 #增加 std c++17 cmake CMakeLists.txt文件路径 DCMAKE_CXX_STANDARD 17 ``` > 在执行 cmake 命令的时候指定出这个宏的值, 使用 D再加上要改变的变量名字就可以 + 指定输出的路径也对应一个宏，叫做`EXECUTABLE_OUTPUT_PATH`，它的值还是通过`set`命令进行设置 ```cmake set(HOME /home/robin/Linux/Sort) set(EXECUTABLE_OUTPUT_PATH ${HOME}/bin) ``` > 这个只有最终生成的文件才会放在这里面, 路径不存在的时候会进行创建 + 搜索指定目录下的文件 使用`aux_source_directory` 命令可以查找某个路径下的`所有源文件` ```cmake aux_source_directory(< dir > < variable >) ``` > `dir`：要搜索的目录 > `variable`：将从`dir`目录下搜索到的源文件列表存储到该变量中 ```cmake cmake_minimum_required(VERSION 3.0) project(CALC) include_directories(${PROJECT_SOURCE_DIR}/include) # 搜索 src 目录下的源文件 aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR}/src SRC_LIST) add_executable(app ${SRC_LIST}) ``` 在CMake中为我们提供了搜索文件的命令，他就是`file（当然，除了搜索以外通过 file 还可以做其他事情）`。 > ```cmake > message(${CMAKE_CURRENT_BINARY_DIR}) > message(${CMAKE_CURRENT_SOURCE_DIR}) > ``` > > ```bash > jiao@LAPTOP BJF9EUQH:~/c_language/2023 9 27 cmake/output$ cmake ../src/ > /home/jiao/c_language/2023 9 27 cmake/output > /home/jiao/c_language/2023 9 27 cmake/src > ``` ```cmake file(GLOB/GLOB_RECURSE 变量名 要搜索的文件路径和文件类型) ``` > `GLOB`: 将指定目录下搜索到的满足条件的所有文件名生成一个列表，并将其存储到变量中。 > `GLOB_RECURSE`：递归搜索指定目录，将搜索到的满足条件的文件名生成一个列表，并将其存储到变量中。 ```cmake file(GLOB MAIN_SRC ${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp) file(GLOB MAIN_HEAD ${CMAKE_CURRENT_SOURCE_DIR}/include/*.h) ``` + 添加头文件include_directories(头文件所在的路径) ### 制作库 #### 制作静态库 在linux里面为`lib+库名字+.a`, Windows为.lib ```cmake add_library(库名称 STATIC 源文件1 [源文件2] ...) ``` > 在这里不需要给出生生的库文件的后缀名, 只需要给出库文件的名字就行了 #### 动态库 ```cmake add_library(库名称 SHARED 源文件1 [源文件2] ...) ``` > 同上面 #### 指定生成的路径 由于在Linux下生成的动态库默认是有执行权限的，所以可以按照生成可执行程序的方式去指定它生成的目录 ```cmake # 设置动态库生成路径 set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib) ``` 在Linux下生成的静态库默认不具有可执行权限，所以在指定静态库生成的路径的时候就不能使用`EXECUTABLE_OUTPUT_PATH`宏了，而应该使用`LIBRARY_OUTPUT_PATH`，这个宏对应静态库文件和动态库文件都适用。 #### 链接库文件 在cmake中，链接静态库的命令如下： ```cmake link_libraries(<static lib> [<static lib>...]) ``` > 可以是库的名字, 也可以是`lib名字.a` > 如果不是系统提供的库, 需要指定路径, 这个路径不只适用于静态库 ```cmake link_directories(<lib path>) ``` > **注**: 这两个的连接顺序是先添加库之后增加库的位置 > > ```cmake > # 链接对应的库文件 > link_libraries(calc) > link_directories(${CMAKE_CURRENT_SOURCE_DIR}/lib) > ``` + 链接库, 链接方式取决于库的类型 ```cmake target_link_libraries( <target> <PRIVATEPUBLICINTERFACE> <item>... [<PRIVATEPUBLICINTERFACE> <item>...]...) ``` > **target**：指定要加载动态库的文件的名字 > 该文件可能是一个源文件 > 该文件可能是一个动态库文件 > 该文件可能是一个可执行文件 > > **PRIVATEPUBLICINTERFACE**：动态库的访问权限，默认为`PUBLIC` > > 如果各个动态库之间没有依赖关系，无需做任何设置，三者没有没有区别，一般无需指定，使用默认的 PUBLIC 即可。 > `动态库的链接具有传递性`，如果动态库 A 链接了动态库B、C，动态库D链接了动态库A，此时动态库D相当于也链接了动态库B、C，并可以使用动态库B、C中定义的方法。(public状态时候的连接方式) > 当有多个动态库的时候, 只需要包含其中一个库, 这个库链接的其他库也会被加入到整个程序中 > > > `PUBLIC`：在public后面的库会被Link到前面的target中，并且里面的符号也会被导出，提供给第三方使用。可以使用你以及你调用的库里面的所有函数 > > `PRIVATE`：在private后面的库仅被link到前面的target中，并且终结掉，第三方不能感知你调了啥库, 只能调用你本身的函数 > > `INTERFACE`：在interface后面引入的库不会被链接到前面的target中，只会导出符号。target只知道有一个函数, 但是不知道这个函数的所在的库, 连接的属性是最差的 > **注**: 动态库文件的添加一般放在文件的最后, 因为加载动态库与加载应用时间不同, 首先生成文件之后再进行连接 ```cmake link_directories(${CMAKE_CURRENT_SOURCE_DIR}/lib) add_executable(app ${SRC_LIST}) target_link_libraries(app calc) ``` ### 消息 在CMake中可以用用户显示一条消息，该命令的名字为`message`： ```cmake message([STATUSWARNINGAUTHOR_WARNINGFATAL_ERRORSEND_ERROR] \"message to display\" ...) ``` > `(无) `：重要消息 > `STATUS` ：非重要消息 > `WARNING`：CMake 警告, 会继续执行 > `AUTHOR_WARNING`：CMake 警告 (dev), 会继续执行 > `SEND_ERROR`：CMake 错误, 继续执行，但是会跳过生成的步骤 > `FATAL_ERROR`：CMake 错误, 终止所有处理过程 CMake的命令行工具会在stdout上显示`STATUS`消息，在stderr上显示其他所有消息。CMake的GUI会在它的log区域显示所有消息。 CMake警告和错误消息的文本显示使用的是一种简单的标记语言。文本没有缩进，超过长度的行会回卷，段落之间以新行做为分隔符。 ### 查找库文件 ```cmake include(FindPkgConfig) # 必须先包含这个模块 # REQUIRED: 是不是必须的包, QUIET是否为静默输出 pkg_check_modules(<PREFIX> [REQUIRED] [QUIET] <MODULE> [<MODULE>...]) ``` 执行后会自动设置一系列变量，如： `<PREFIX>_FOUND` 是否找到 `<PREFIX>_LIBRARIES` 库文件列表 `<PREFIX>_INCLUDE_DIRS` 头文件目录 `<PREFIX>_LDFLAGS` 链接器标志 `<PREFIX>_CFLAGS` 编译器标志 ## 使用内敛汇编实现显示字符串 ### 基本格式 ```c asm(汇编语句 :输出操作数(可选) :输入操作数(可选) :被破坏的寄存器(可选) ); ``` + 示例 ```c int a 10, b; asm(\"movl %1, %%eax; movl %%eax, %0;\" :\" r\"(b)\t\t/*输出*/ :\"r\"(a)\t\t/*输入*/ :\"%eax\"\t\t/*破坏的寄存器*/ ) ``` > 实现的是b a的功能 ### 具体格式说明 + 只有一条汇编语句 ```assembly asm(\"hlt\")\t\t//CPU进行休眠 ``` + 多条汇编 ```assembly asm(\"sti;hlt\"); asm(\"sti\\n\\thlt\"); asm(\"sti\\n\\t\" \t\"hlt\"); ``` > 多条语句的时候使用\\n\\t或者使用;进行分割 + 有输出操作数 有些时候有的数据需要将数据输出到C语言里面的某一些变量里面, 可以使用输出操作数 ```c char c; asm(\"mov $3, %[out]\":[out]\" r\"(c)); ``` > %[out]是定义的一个输出约束, 名称和后面的out相同, \" r\"(c)制定了c变量映射到某一个寄存器 > + r: 任意寄存器 > + a: %eax, %ax, %al > + b: > + c: > + d: > + S: %esi, %si > + D: %edi, %di + 有输入操作数 当需要从C语言中读取变量的值到汇编语句中时，则需要使用输入操作数。例如，下面的代码中,mov %[ch], %%al用于将c变量中的字符写到al中。因此，在输入操作数中使用了[ch]\"r\"(c)，即c变量映射到某个寄存器上(见上文中输出操作数的类似设置)。最终的效果为: mov$0xe,%%ah、mov %[c]， %%al ```c char c 'a'; asm(\"mov $0xe, %%ah\\n\\t\" \"mov %[ch], %%al\\n\\t\" \"int $0x10\"::[ch]\"r\"(c)); ``` > 在这个时候所有的寄存器前面使用的是%% + 参数保存在内存里面 ```assembly asm(\"sidt %0\\n\" : :\"m\"(loc) ); ``` > 这条语句将 IDTR 寄存器的值，保存在内存位置 loc 处。 + 匹配约束符(数字) 一个变量既要当做输入操作数又要当做输出操作数。这种情况下，在 asm 中使用匹配约束来指定。 ```assembly asm (\"incl %0\" :\" a\"(var) :\"0\"(var) ); ``` > 寄存器 %eax 既用来保存输入操作数，也用来保存输出操作数。输入变量 var 被存进 %eax，在 %eax 中完成自增。**\"0\"** 在这里表示与第 0 号输入操作数有相同的约束（既 **\"a\"**） > > 从一个变量读取输入，修改后结果存进同一个变量的情况 > 输入操作数和输出操作数没必要分开的情况。 ### 避免优化 使用`__asm__ __volatile__`代替原来的asm ## gcc汇编伪代码 ### 标记段的开始 伪操作：.text，.data，.bss 分别表示代码段，数据段，未初始化数据段的开始。 ### 定义段指定段的属性 伪操作：.section 格式为：.section name attr 例如：.section .data,\"a\" a：可分配 ； w：可写段；x：执行段；M：可合并；S：包含零个终止的字符串；G：段组成员；T：用于线程本地存储 ### symbol:(符号) 当前位置的一个别称, **.**也表示当前位置。 ### .weak names 伪指令在符号名称的逗号分隔列表上设置弱属性。 如果符号不存在，将创建它们。(弱定义，如果有其他强定义则用强定义替代) ### .type name , % ELF格式下隐含的标识一个段的开始）此伪指令用于设置符号的类型。 %function： Mark the symbol as being a function name.符号是函数名 %object： Mark the symbol as being a data object.符号为数据对象 %tls_object：Mark the symbol as being a thead local data object.将符号标记为线程本地数据对象。 %common： Mark the symbol as being a common data object.将符号标记为公共数据对象。 ### .org 定义一个内存地址 ### .byte 填充一个字节 ## GDB调试 gcc编译的时候需要 g选项 ### 开始调试 ```bash jiao@ubuntu:~/Desktop/C language/2024 2 9 test$ gdb a.out GNU gdb (Ubuntu 8.1 0ubuntu3.2) 8.1.0.20180409 git Copyright (C) 2018 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html> This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type \"show copying\" and \"show warranty\" for details. This GDB was configured as \"x86_64 linux gnu\". Type \"show configuration\" for configuration details. For bug reporting instructions, please see: <http://www.gnu.org/software/gdb/bugs/>. Find the GDB manual and other documentation resources online at: <http://www.gnu.org/software/gdb/documentation/>. For help, type \"help\". Type \"apropos word\" to search for commands related to \"word\"... Reading symbols from a.out...done. (gdb) ``` ### 基础使用 #### 显示代码 ```bash list 或 l # 显示一下代码, 之后再使用l显示下一部分 list 行号 # 可以显示对应行 ``` > ![image 20240211193852367](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402111938397.png) #### 设置断点 ```bash break 或 b + 行号 ``` > ![image 20240211194025451](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402111940479.png) #### 全速运行 ```bash run 或 r ``` > ![image 20240211194147247](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402111941275.png) #### 单步调试 ```bash n next # 下一个, 遇到函数执行完这一个函数 s step # 单步, 进入函数 ``` #### 运行到 ```bash until + 行号 ``` #### 显示一个变量 ```bash p print + 变量名 p *数组名 @显示的个数 p 数组名[n] p 数组名[n]@m 打印n以后得m个数字 ``` #### 继续执行 ```bash continue ``` #### 退出 ```bash q quit ``` ### 其他使用 #### 段错误 直接全速运行, 停止的位置是实际错误的位置 ![image 20240211195750110](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402111957144.png) #### 运行到第一句 ```bash start ``` #### 运行结束当前函数 ```bash finish ``` > 可以是库函数或者自己的函数吗返回调用点 #### 文件有命令行参数 ```bash set arges 参数 ``` > 这一个是在启动之前 > > ![image 20240211201305737](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402112013770.png) ```bash run + 参数 ``` #### 看有几个断点(以及删除) ```bash info b / info breakpoints # 查看GDB内部局部变量的数值 delate + 第几个 进行删除断点 ``` ![image 20240211202056668](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402112020701.png) ![image 20240211210225099](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402112102133.png) #### 获取所有的局部变量 ```bash info locals ``` #### 条件断点 ```c b 41 if i 5 ``` > 这一个判断语句实际上会被执行, 比如使用'b 10 if i 2'的时候i会被运行到这一句的时候设置为2 #### 看一个参数的类型 ```bash ptype 参数名 # 看一个变量的类型 ``` #### 查看函数的栈帧以及调用关系(查看其他函数未覆盖的参数) ```bash bt backtrace ``` > 可以和frame一起使用 > > ```bash > f frame 切换函数的栈帧 > ``` > > ![image 20240211205452384](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402112054426.png) > > ![image 20240211205429044](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402112054088.png) > > > 在add函数里面查看其他变量的值 #### 跟踪一个变量 ```bash display + 变量名 undisplay + 变量名 ``` ![image 20240211210353674](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402112103713.png) ```bash watch 被设置观察点的变量发生修改时，打印显示 i watch 显示观察点 ``` ![image 20240211210900722](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402112109766.png) #### 查看内存 ```bash x/<n/f/u><addr> ``` > n、f、u是可选的参数。 > > n 是一个正整数， 表示显示内存的长度 ，也就是说从当前地址向后显示几个地址的内容。 > f 表示显示的格式 ，参见上面。如果地址所指的是 字符串 ，那么格式可以是 s ，如果 地址是指令 地址 ，那么格式可以是 i 。 > u 表示从当前地址往后请求的字节数，如果不指定的话，GDB默认是4个bytes 。 u 参数可以用下面的字符来代替， b 表示单字节， h 表示双字节， w 表示四字 节， g 表示八字节。当我们指定了字节长度后， GDB 会从指内存定的内存地址开始，读写指定字节，并把其当作一个值取出来。 > > <addr>表示一个内存地址。 > n/f/u三个参数可以一起使用。例如： > > 命令： x/3uh 0x54320 表示，从内存地址 0x54320读取内容， h表示以双字节为一个单位， 3表示三个单位， u表示按十六进制显示。 > > 输出格式 > 一般来说，GDB会根据变量的类型输出变量的值。但你也可以自定义GDB的输出的格式。例如，你想输出一个整数的十六进制，或是二进制来查看这个整型变量的中的位的情况。要做到这样，你可以使用GDB的数据显示格式： > > x 按十六进制格式显示变量。 > d按十进制格式显示变量。 > u按十六进制格式显示无符号整型。 > o按八进制格式显示变量。 > t按二进制格式显示变量。 > a按十六进制格式显示变量。 > c按字符格式显示变量。 > f按浮点数格式显示变量。 > > 所以查看十进制地址的方法即为： > > (gdb) x/9db 0x00001fa4 > 从内存地址0x00001fa4读取内容，b表示以单字节为一个单位，9表示九个单位，d表示按十进制显示。 > > > > 还有另外一种方法是直接print，由于0xBFFFFAA0是指针的指针所指向的地址，所以查看其内容即为 > > (gdb) p/d**(char**) 0xBFFFFAA0@9 > 从内存地址0xBFFFFAA0读取内容，d表示以十进制显示，@9表示读取一片连续的长度为9的地址 > > 原文链接：https://blog.csdn.net/angus_monroe/article/details/78515887 #### 选择进程 使用gdb调试的时候，gdb只能跟踪一个进程。可以在fork函数调用之前，通过指令设置gdb调试工具跟踪父进程或者是跟踪子进程。默认跟踪父进程。 set follow fork mode child 命令设置gdb在fork之后跟踪子进程。 set follow fork mode parent 设置跟踪父进程。 注意，一定要在fork函数调用之前设置才有效。 ### 出错 1. 显示没有文件符号表 > 退出执行一个带 g的gcc命令 > > ```bash > file a.out > ```"},"/note/Linux/李述铜手写操作系统/2024-2-17-08链表.html":{"title":"链表","content":" layout: post title: \"链表\" date: 2024 2 17 15:39:08 +0800 tags: 李述铜 # 链表 就绪队列, 等待队列等分别记录不同的任务 ![image 20240217180331612](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402171803644.png) ## 简单的操作 ```c #ifndef LIST_H #define LIST_H typedef struct _list_node_t{ struct _list_node_t *pre; struct _list_node_t *next; }list_node_t; __attribute__((used)) static inline void list_node_init (list_node_t *node) { node >next (list_node_t *)0; node >pre (list_node_t *)0; } __attribute__((used)) static inline list_node_t* list_node_pre (list_node_t *node) { return node >pre; } __attribute__((used)) static inline list_node_t* list_node_next (list_node_t *node) { return node >next; } //这是一个管理使用的节点 typedef struct _list_t{ list_node_t *first; list_node_t *last; int count; }list_t; void list_init(list_t * list); __attribute__((used)) static inline int list_is_empty(list_t *list) { return list >count 0; } __attribute__((used)) static inline int list_count(list_t *list) { return list >count; } __attribute__((used)) static inline list_node_t * list_first(list_t *list) { return list >first; } __attribute__((used)) static inline list_node_t * list_last(list_t *list) { return list >last; } void list_insert_last(list_t * list, list_node_t *node); void list_insert_first(list_t * list, list_node_t *node); list_node_t * list_remove_first(list_t * list); list_node_t * list_remove(list_t * list, list_node_t *node); #endif // !LIST_H ``` ```c #include \"tools/list.h\" void list_init(list_t * list){ list >first list >last (list_node_t *)0; } //插入函数 void list_insert_first(list_t * list, list_node_t *node){ node >next list >first; node >pre (list_node_t *)0; if(list_is_empty(list)){ list >last list >first node; }else{ list >first >pre node; list >first node; } list >count++; } void list_insert_last(list_t * list, list_node_t *node){ node >pre list >last; node >next (list_node_t *)0; if(list_is_empty(list)){ list >last list >first node; }else{ list >last >next node; list >last node; } list >count++; } //移除链表节点 list_node_t * list_remove_first(list_t * list){ if(list_is_empty(list)){ return (list_node_t *)0; } list_node_t *remove_node list >first; list >first remove_node >next; if(list >first (list_node_t *)0){ //这里面只有这一个节点 list >last (list_node_t *)0; }else{ //清空下一个节点的pre remove_node >next >pre (list_node_t *)0; } remove_node >pre (list_node_t *)0;; remove_node >next (list_node_t *)0; list >count ; return remove_node; } list_node_t * list_remove(list_t * list, list_node_t *node){ if(node list >first){ list >first node >next; } if(node list >last){ list >last node >pre; } if(node >pre){ node >pre >next node >next; } if(node >next){ node >next >pre node >pre; } node >pre (list_node_t *)0;; node >next (list_node_t *)0; list >count ; return node; } ``` ## 获取链表所在的结构 使用链表所在的结构体里面的地址减去它的偏移 ```c #define offset_in_parent(parent_type, node_name) \\ ((uint32_t)&(((parent_type *)0) >node_name)) //获取某一个结构体成员所在结构体的指针 //node: 成员的名字 //parent_type: 所在结构体的类型 //node_name: 他在结构体里面的名字 #define parent_addr(node, parent_type, node_name) \\ ((uint32_t)node offset_in_parent(parent_type, node_name)) #define list_node_parent(node, parent_type, node_name) \\ ((parent_type *)(node ? parent_addr(node, parent_type, node_name) : 0)) ``` ## 测试 ```c void list_test(){ list_node_t nodes[5]; list_t list; list_init(&list); log_printf(\"List: first 0x%x, last 0x%x, count %d\", list_first(&list), list_last(&list), list_count(&list)); for(int i 0 ;i<5;i++){ list_node_t *node nodes + i; log_printf(\"insert first to list: %d, 0x%x\", i, (uint32_t) node); list_insert_first(&list, node); } for(int i 0 ;i<5;i++){ list_node_t *node list_remove_first(&list); log_printf(\"remove first to list: %d, 0x%x\", i, (uint32_t) node); } for(int i 0 ;i<5;i++){ list_node_t *node nodes + i; log_printf(\"insert first to list: %d, 0x%x\", i, (uint32_t) node); list_insert_last(&list, node); } for(int i 0 ;i<5;i++){ list_node_t *node list_remove(&list, &nodes[i]); log_printf(\"remove first to list: %d, 0x%x\", i, (uint32_t) node); } struct type_t { int i; list_node_t node; }v {0x123456}; list_node_t *v_node &v.node; struct type_t * p list_node_parent(v_node, struct type_t, node); log_printf(\"get parent 0x%x\", p >i); } ```"},"/note/Linux/李述铜手写操作系统/2024-3-7-Fat16.html":{"title":"Fat16","content":" layout: post title: \"Fat16\" date: 2024 3 7 15:39:08 +0800 tags: 李述铜 # Fat16 记录文件的存储的时候使用了一个Fat表, 里面记录的是一个文件不同部分之间的关系 ![image 20240307110309473](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403071103521.png) ![image 20240307110326883](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403071103913.png) > 这里的两个FAT表实际是一样的 ![image 20240307120448991](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403071204018.png) > 这一个是配置信息 ## 文件顶层目录的读取 有一个根目录区, 里面有各一个区域的文件信息, 这一个里面有这些文件的信息"},"/note/Linux/李述铜手写操作系统/2024-2-26-移植Newlib库.html":{"title":"移植Newlib库","content":" layout: post title: \"移植Newlib库\" date: 2024 2 26 15:39:08 +0800 tags: 李述铜 # 移植Newlib库 这是一个面向嵌入式的C库, 现在由Red Hat维护, 兼容GNU C运行库 这一个库移植的时候需要实现的函数有 ```c //这几个是文件操作 int open(const char *name, int flags, ...); int read(int file, char * ptr, int len); int write(int file, char * pte, int len); int close(int file); int lseek(int file, int ptr, int dir); int isatty(int file); int fstat(int file, struct stat *st); void *sbrk (ptrdiff_t incr); ``` > 问题: 会出现数据类型的冲突 > > ```c > // 基本整数类型，下面的写法和视频中的不同，加了一些宏处理 > // 主要是因为将要使用newlib库，newlib有同样使用typedef定义uint8_t类型 > // 为了避免冲突，加上_UINT8_T_DECLARED的配置 > #ifndef _UINT8_T_DECLARED > #define _UINT8_T_DECLARED > typedef unsigned char uint8_t; > #endif > > #ifndef _UINT16_T_DECLARED > #define _UINT16_T_DECLARED > typedef unsigned short uint16_t; > #endif > > #ifndef _UINT32_T_DECLARED > #define _UINT32_T_DECLARED > typedef unsigned long uint32_t; > #endif > ``` ## 实际接口的实现 ### sbrk() 这是一个分配内存的函数, 用于堆的管理 当内存使用的堆不够用的时候, 会使用这一个函数 这一个函数的返回值是之前的可以使用的内存的起始位置, 参数为0的时候不进行内存的分配, 返回当前位置, 失败的话返回 1 合理的设计堆的大小, 可以使得系统调用减少 ```c //这是一个内存分配使用的函数 //Newlib使用 char *sys_sbrk(int incr){ task_t * task task_current(); int pre_incr incr; char * pre_heap_end (char *)task >heap_end; ASSERT(incr > 0); if(incr 0){ log_printf(\"sbrk(0) end 0x%x\", pre_heap_end); return pre_heap_end; } uint32_t start task >heap_end; uint32_t end start + incr; int start_offset start % MEM_PAGE_SIZE;//获取一下偏移 if(start_offset) { //之前分配的页还可以使用 if(start_offset + incr < MEM_PAGE_SIZE){ //已经分配的内存足够使用 task >heap_end end; return pre_heap_end; }else { //这一个页很大,超过这一个页了 uint32_t curr_size MEM_PAGE_SIZE start_offset; start + curr_size; incr curr_size; } } if(incr){ //需要分配新的内存 uint32_t curr_size end start; int err memory_alloc_page_for(start, curr_size, PTE_P PTE_U PTE_W); if(err < 0){ log_printf(\"sbbrk : alloc mem failed\"); return (void *) 1; } } task >heap_end end; log_printf(\"sbrk(%d): end 0x%x\", pre_incr, end); return (char *)pre_heap_end; } ``` ## 实现printf 这一个函数会调用函数sys_write, 把这一个字符串写入stdout的文件里面 标准输入stdin: 0 标准输出stdout : 1 标准错误输出: 2 实际使用的sys_write向文件里面操作 ```c int sys_write(int file, char *ptr, int len) { if(file 1){ //标准输出 ptr[len] '\\0'; log_printf(\"%s\", ptr); } return 1; } ```"},"/note/Linux/李述铜手写操作系统/2024-2-27-屏幕显示信息.html":{"title":"屏幕显示信息","content":" layout: post title: \"屏幕显示信息\" date: 2024 2 26 15:39:08 +0800 tags: 李述铜 # 屏幕显示信息 开机的时候这一个屏幕会被BIOS设置为一个80列25行的显示模式 使用内存0xb8000到0xA0000的32KB的位置为显存 实际显示的时候, 使用一个字节显示字符, 一个字节描述颜色, 一个显示屏使用4000字节的内存, 实际可以控制8屏的显示器, 也可以实现滚屏的效果 显示颜色的时候使用字节低几位为前景色, 高位为背景色, 有一个颜色表 > The most used VGA video mode for a text UI is \"VGA mode 3\". This is the most commonly used, as it allows direct memory access to a linear address containing each character and its associated attributes. VGA mode 3 provides a text interface 80 characters wide and 25 characters lines per screen, although on modern computers [Drawing In a Linear Framebuffer](https://wiki.osdev.org/Drawing_In_a_Linear_Framebuffer) is preferrable, and often mandatory. > Each character takes up two bytes of space in memory. The first byte is split into two segments, the forecolour, and the backcolour. The second byte is an 8 bit ASCII value of the character to print. > > ``` > Bit 76543210 > > ^^^ fore colour > ^ fore colour bright bit > ^^^ back colour > ^ back colour bright bit OR enables blinking Text > ``` ![image 20240227145947560](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402271459727.png) 直接使用这一个方式的时候, 不可以改变光标的位置, 光标使用两个字节表示自己的位置, 当前的显示是80*25, 一共有2000个位置, 0 1999这一个主要是使用两个端口, 0x3d4, 0x3d5 0x3d4写入0xf表示0x3d5写入的是低八位, 0x3d5写入0xe, 可以写入高八位, 也可以使用in进行读取 ![image 20240228104956647](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402281049690.png) [Text Mode Cursor OSDev Wiki](https://wiki.osdev.org/Text_Mode_Cursor) ## 特殊字符 /b: 光标退回到上一个位置 /x7f: 删除字符 还有一些其他的字符, 可以控制字符的颜色以及控制光标的位置 这一部分以一个Esc开始(0x1b/27), 第二个字节是0x40 0x5f范围里面吗的字符 CSI序列是ESC[若干个(可以是0)参数, 若干个中间字符, 以及一个最终字符 ### 显示颜色 ```c printf(\"\\033[显示方式；字背景颜色;字体颜色m…\\033[0m\") ``` > 控制命令以`\\033[`开头，以`m`结尾，而中间则是属性码，属性代码之间使用`;`分隔，如`\\033[1;34;42m`，最后以默认颜色`\\033[0m`结尾，以避免影响后面正常打印！ ```c #define LOG_CLRSTR_NONE \"\\033[0m\" // 默认显示 #define LOG_CLRSTR_RED \"\\033[0;42;31m\" // 绿红色 #define LOG_CLRSTR_GREEN \"\\033[0;32m\" // 绿色 #define LOG_CLRSTR_BLUE \"\\033[0;32;34m\" // 蓝色 #define LOG_CLRSTR_DARK_GRAY \"\\033[1;30m\" // 灰色 #define LOG_CLRSTR_CYAN \"\\033[0;36m\" // 青色 #define LOG_CLRSTR_PURPLE \"\\033[0;35m\" // 紫色 #define LOG_CLRSTR_BROWN \"\\033[0;33m\" // 棕色 #define LOG_CLRSTR_YELLOW \"\\033[5;42;33m\" // 绿黄色 #define LOG_CLRSTR_WHITE \"\\033[1;37m\" // 白色 ``` ```c \\033[0m 关闭所有属性 \\033[1m 设置高亮度 \\03[4m 下划线 \\033[5m 闪烁 \\033[7m 反显 \\033[8m 消隐 \\033[30m \\033[37m 设置前景色 \\033[40m \\033[47m 设置背景色 \\033[nA 光标上移n行 \\03[nB 光标下移n行 \\033[nC 光标右移n行 \\033[nD 光标左移n行 \\033[nE 移至下一行 \\033[nF移到上一行 \\033[n;mH 把光标一到(n,m)的位置 \\033[y;xH设置光标位置 \\033[2J 清屏 \\033[K 清除从光标到行尾的内容 \\033[s 保存光标位置 \\0337 \\033[u 恢复光标位置 \\0338 \\033[?25l 隐藏光标 \\033[?25h 显示光标 ``` ![image 20240228204128890](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402282041954.png) ![image 20240228231440819](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402282314870.png) ![image 20240228231511833](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402282315895.png) > 0无属性, 1加粗高亮, 4下划线, 5闪烁, 7反色, 22非粗体, 24无下划线, 25无闪, 27正显, 39默认前显, 49默认的背景色 ## 切换屏幕 实际设置的时候改变两个寄存器的值, 这一个是实际的显存的物理内存 ```c uint16_t pos idx * console >display_cols * console >display_rows; outb(0x3d4, 0xc); outb(0x3d5, (uint8_t)(pos >> 8) & 0xff); outb(0x3d4, 0xd); outb(0x3d5, (uint8_t)(pos & 0xff)); ``` > 这一个记录的是像素的偏移的个数"},"/note/Linux/李述铜手写操作系统/2024-2-17添加任务管理器.html":{"title":"添加任务管理器","content":" layout: post title: \"添加任务管理器\" date: 2024 2 17 15:39:08 +0800 tags: 李述铜 # 添加任务管理器 使用前面实现的链表进行任务的管理 使用三个链表进行管理 + 延时链表 + 就绪链表 + 进程链表(所有状态的进程) ```c typedef struct _task_t { //任务的状态 enum { TASK_CREATED, TASK_RUNNING, TASK_SLEEP, TASK_READY, TASK_WAITING, }state; //名字 char name[TASK_NAME_SIZE]; //uint32_t *stack; tss_t tss; //记录一下在GDT表里面的位置 int tss_sel; list_node_t run_node;//运行时候使用的节点 list_node_t all_node;//总的记录节点 }task_t; ``` ## 实现切换的时候不需要指定目标 > sys_sched_yield可以直接切换 ```c //获取第一个任务的控制块 task_t *task_first_task(void){ return &task_manager.first_task; } //启动一个任务, 更新状态 void task_set_ready(task_t *task){ list_insert_last(&task_manager.ready_list, &task >run_node); task >state TASK_READY; } //移除一个任务, 不更新状态 void task_set_block(task_t *task){ list_remove(&task_manager.ready_list, &task >run_node); task >state TASK_READY; } //获取下一个运行的任务, 现在使用的是获取链表的第一个任务 task_t * task_next_run (void){ list_node_t * task_node list_first(&task_manager.ready_list); return list_node_parent(task_node, task_t, run_node); } //获取在运行的任务 task_t * task_current(void){ return task_manager.curr_task; } int sys_sched_yield(void){ if(list_count(&task_manager.ready_list)>1){ task_t *curr_task task_current(); //把当前的任务加入等待 task_set_block(curr_task); task_set_ready(curr_task); task_dispatch(); } return 0; } //获取下一个需要切换的任务, 进行切换以及状态设置 void task_dispatch(void){ task_t * to task_next_run(); if(to ! task_manager.curr_task){ //不一样, 需要进行切换 //获取当前的任务 task_t * from task_current(); task_manager.curr_task to; to >state TASK_RUNNING; //进行切换 task_switch_from_to(from, to); } } ``` ## 使用计数器切换 ```c typedef struct _task_t { \t... int slice_ticks; //可以使用的最大的时间 int time_ticks; //递减计数器, 用于计数 \t... }task_t; ``` ```c void task_time_tick(void){ task_t * curr_task task_current(); if( curr_task >time_ticks 0){ curr_task >time_ticks curr_task >slice_ticks; //把当前的任务加入等待 task_set_block(curr_task); task_set_ready(curr_task); task_dispatch(); } } ``` ## 临界资源保护 实现方法 + 禁用中断 ```c __attribute__((used)) static inline uint32_t read_eflags (void){ uint32_t eflags; ASM_V(\"pushf\\n\\tpop %%eax\":\" a\"(eflags)); return eflags; } __attribute__((used)) static inline void write_eflags (uint32_t eflags){ ASM_V(\"push %%eax\\n\\tpopf\"::\"a\"(eflags)); } ``` > EFLAGS的位9是IF位, 为1的时候开启中断, 0屏蔽中断 ```c //临界区管理 irq_state_t irq_enter_protection (void){ //记录一下之前的中断是开启的还是关闭的 \tirq_state_t state read_eflags(); \tstate EFLAGS_IF; \tirq_disable_global(); \treturn state; } void irq_leave_protection (irq_state_t state){ //恢复之前的IF状态 \tstate read_eflags(); \twrite_eflags(state); } ``` ### 实际使用 ```c //打印的时候串口是一个临界资源 void log_printf(const char * fmt, ...){ char str_buf[128]; va_list args; //格式化处理 kernel_memset(str_buf, '\\0', sizeof(str_buf)); va_start(args, fmt); kernel_vsprintf(str_buf, fmt, args); va_end(args); const char *p str_buf; irq_state_t state irq_enter_protection(); //进入临界 while(*p ! '\\0') { //等待串口忙标志 while((inb(COM1_PORT+ 5) & (1<<6)) 0); outb(COM1_PORT, *p++); } //自动换行 outb(COM1_PORT, '\\r'); outb(COM1_PORT, '\\n'); irq_leave_protection(state);//退出临界区 } ``` ## 实现一个延时 睡眠的时候把任务加入延时队列里面, 同时使用一个变量记录睡眠的剩余时间 ```c //时钟相关的任务处理 void task_time_tick(void){ task_t * curr_task task_current(); if( curr_task >time_ticks 0){ curr_task >time_ticks curr_task >slice_ticks; //把当前的任务加入等待 task_set_block(curr_task); task_set_ready(curr_task); task_dispatch(); } //定时相关的 list_node_t * curr list_first(&task_manager.sleep_list); while(curr){ list_node_t * next curr >next; task_t * task list_node_parent(curr, task_t, run_node); if( task >sleep_ticks 0){ task_set_wakeup(task); task_set_ready(task); } curr next; } task_dispatch(); } void task_set_sleep(task_t * task, uint32_t ticks){ if(ticks 0){ return; } task >sleep_ticks ticks; task >state TASK_SLEEP; list_insert_last(&task_manager.sleep_list, &task >run_node); } void task_set_wakeup(task_t * task){ list_remove(&task_manager.sleep_list, &task >run_node); } void sys_sleep(uint32_t ms){ irq_state_t state irq_enter_protection(); task_set_block(task_manager.curr_task); task_set_sleep(task_manager.curr_task, (ms + OS_TICKS_MS 1) / OS_TICKS_MS); task_dispatch(); irq_leave_protection(state); } ``` ## 空闲任务 创建一个空闲任务, 以便在所有任务睡眠的时候可以做一部分其他的处理 ## 进程通信 ### 信号量 如果有在等待这个信号的进程, 唤醒进程, 没有的话增加计数器"},"/note/Linux/李述铜手写操作系统/2024-2-18-内存管理.html":{"title":"内存管理","content":" layout: post title: \"内存管理\" date: 2024 2 17 15:39:08 +0800 tags: 李述铜 # 内存管理 1. 各个系统进程加载的位置 2. 任务的存放的位置 3. 分配以及回收 4. 多个进程之间共享内存 4. 进程之间看不到相互之间 4. 禁止访问不存在的内存 4. 进程不能访问系统的内存 > 问题: > > + 程序链接的时候有一个加载地址, 多个程序想要在同一个位置的时候会出现问题 > + 某一个任务的加载需要多个不连续的内存 ## 页表 x86硬件的虚拟内存会把内存看做相同大小的页进行管理, 在使用的时候也是按照页的形式进行分配的 ![image 20240219114324443](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402191143161.png) > 实际的物理内存是不连续的, 但是应用是看不到的, 通过一个页表进行转换(虚拟内存) ## 管理 使用位图的方式进行管理, 使用一位代表一个页表的项 ![image 20240219114800329](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402191148371.png) ### 位图的实现 会使用位图里面的一位代表一段物理地址是否被分配 ```c /** * 项目名: 位图 * * 项目描述: 使用位图进行内存管理 * *\t作者：XvSenfeng *\t联系邮箱: 1458612070@qq.com *\tdate: 2024 02 19 *\ttime: 11:49:59 */ #include \"tools/bitmap.h\" #include \"tools/klib.h\" // 记录一下实际需要的字节个数 int bitmap_byte_count(int bit_count) { return (bit_count + 7) / 8; } // 初始化一个位表 // bitmap: 要初始化的目标 // count: 初始化的个数 // bits: 记录数据的位置 // init_bits:1 所有位设置为1, 0:所有位清零 void bitmap_init(bitmap_t *bitmap, int count, uint8_t *bits, int init_bits) { bitmap >bit_count count; bitmap >bits bits; int bytes bitmap_byte_count(bitmap >bit_count); kernel_memset(bitmap >bits, init_bits ? 0xff : 0, bytes); } // 获取某一位的状态 int bitmap_get_bit(bitmap_t *bitmap, int index) { return bitmap >bits[index / 8] & (1 << (index % 8)); } // 设置位图的某一位 void bitmap_set_bit(bitmap_t *bitmap, int index, int count, int bit) { for (int i 0; i < count && (index < bitmap >bit_count); i++, index++) { if (bit) { bitmap >bits[index / 8] (1 << (index % 8)); } else { bitmap >bits[index / 8] & ~(1 << (index % 8)); } } } int bitmap_is_set(bitmap_t *bitmap, int index) { return bitmap_get_bit(bitmap, index) ? 1 : 0; } //获取一段连续的空间并且标志为bit //bit检测的位的标志, 找到连续count个bit之后清除 //返回的是设置的地址的起始标号 int bitmap_alloc_nbits(bitmap_t *bitmap, int bit, int count) { int search_idx 0; //用于遍历 int ok_index 1; //记录有效的起始位置 int i; while (search_idx < bitmap >bit_count) { //获取一个空闲的位置 if (bitmap_get_bit(bitmap, search_idx) ! bit) { search_idx++; continue; } // 检测之后的位置是不是连续的有效 ok_index search_idx; for (i 1; (i < count) && (search_idx < bitmap >bit_count); i++) { if (bitmap_get_bit(bitmap, search_idx++) ! bit) { ok_index 1; break; } } if (i > count) { bitmap_set_bit(bitmap, ok_index, count, ~bit); return ok_index; } } return 1; } ``` ```c #ifndef BITMAP_H #define BITMAP_H #include \"types.h\" typedef struct _bitmap_t { int bit_count; uint8_t * bits; }bitmap_t; void bitmap_init(bitmap_t * bitmap, int count, uint8_t *bits, int init_bits); int bitmap_byte_count (int bit_count); int bitmap_get_bit (bitmap_t *bitmap, int index); void bitmap_set_bit(bitmap_t * bitmap, int index, int count, int bit); int bitmap_is_set (bitmap_t *bitmap, int index); int bitmap_alloc_nbits (bitmap_t *bitmap, int bit, int count); #endif // !BITMAP_H ``` ## 内存管理 ### 实现内存的分配 实际是在位图里面进行标记 ```c typedef struct _addr_alloc_t{ mutex_t mutex; uint32_t start; uint32_t size; uint32_t page_size; bitmap_t bitmap; }addr_alloc_t; ``` ```c //初始化一个内存管理器 //bits: 位图使用的数组 //start: 管理的内存的起始位置 //size: 管理的大小 //page_size: 内存一页的大小 static void addr_alloc_init(addr_alloc_t * alloc, uint8_t *bits, uint32_t start, uint32_t size, uint32_t page_size){ mutex_init(&alloc >mutex); alloc >start start; alloc >size size; alloc >page_size page_size; //把位图的这一块清零 bitmap_init(&alloc >bitmap, alloc >size / page_size, bits, 0); } //获取page_count个连续的页, 返回这一片地址的起始位置 static uint32_t addr_alloc_page(addr_alloc_t * alloc, int page_count){ uint32_t addr 0; mutex_lock(&alloc >mutex); int page_index bitmap_alloc_nbits(&alloc >bitmap, 0, page_count); if(page_index > 0){ addr alloc >start + page_index * alloc >page_size; } mutex_unlock(&alloc >mutex); return addr; } //释放某一位以后得page_count页 static void addr_free_page(addr_alloc_t * alloc, uint32_t addr, int page_count){ mutex_lock(&alloc >mutex); uint32_t pg_index (addr alloc >start) / alloc >page_size; bitmap_set_bit(&alloc >bitmap, pg_index, page_count, 0); mutex_unlock(&alloc >mutex); } void memory_init(boot_info_t *bootinfo){ addr_alloc_t addr_alloc; uint8_t bits[8]; //使用4KB开始的64个4KB的大小 addr_alloc_init(&addr_alloc, bits, 0x1000, 64*4096, 4096); for(int i 0; i < 32; i ++){ uint32_t addr addr_alloc_page(&addr_alloc, 2); log_printf(\"alloc addr: 0x%x\", addr); } uint32_t addr 0x1000; for(int i 0; i < 32; i ++){ addr_free_page(&addr_alloc, addr, 2); addr + 8192; log_printf(\"free addr: 0x%x\", addr); } } ``` ### 内存规划 ![image 20240219135759939](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402191357996.png) ![image 20240219144026313](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402191440337.png) > 获取位图可以使用的内存地址 > > ```c > //从链接脚本里面获取这一个地址 > extern uint8_t * mem_free_start; > ``` ## 虚拟内存 ![image 20240219152817023](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402191528074.png) ![image 20240220124750674](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402201247816.png) ![image 20240220134306147](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402201343207.png) ## 实现文件的地址分离 ![image 20240220144455984](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402201444027.png) ![image 20240220144726593](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402201447652.png) > data区域使用的时候设置了一个使用的虚拟地址0x2000, 实际的物理地址是在.text后面, .bss放在0x3000位置 ![image 20240220145442345](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402201454371.png) ```json SECTIONS { PROVIDE(kernel_base .); . 0x10000; PROVIDE(s_text .); .text : { *(EXCLUDE_FILE(*first_task*) .text)\t\t//这个时候连接这两个文件 } .rodata : { *(EXCLUDE_FILE(*first_task*) .rodata) } PROVIDE(e_text .); . ALIGN(4096); PROVIDE(s_data .); .data : { *(EXCLUDE_FILE(*first_task*) .data) } .bss : { *(EXCLUDE_FILE(*first_task*) .bss) } e_data .; . 0x80000000;//虚拟地址 .first_task : AT(e_data) { //物理地址 *first_task_entry*(.text .rodata .bss .data) *first_task*(.text .rodata .bss .data) } e_first_task LOADADDR(.first_task) + SIZEOF(.first_task);//计算物理地址的结束位置 PROVIDE(mem_free_start e_first_task); } ``` 可以使用AT设置防止的物理地址, 直接使用.设置的位置是虚拟地址 ## 独立用户程序 在链接脚本的位置把用户程序单独盛放 ```lds /* 参考文档： https://ftp.gnu.org/old gnu/Manuals/ld 2.9.1/html_chapter/ld_3.html */ SECTIONS { \tPROVIDE(kernel_base 0x0); \t. 0x00010000; \tPROVIDE(s_text .); \t.text : { \t\t*(EXCLUDE_FILE(*first_task*) .text) \t} \t.rodata : { \t\t*(EXCLUDE_FILE(*first_task*) .rodata) \t} \tPROVIDE(e_text .); \t. ALIGN(4096); \tPROVIDE(s_data .); \t.data : { \t\t*(EXCLUDE_FILE(*first_task*) .data) \t} \t.bss : { \t\t*(EXCLUDE_FILE(*first_task*) .bss) \t} \te_data .; \t/* 初始进程的配置：接紧着在低端1MB内存开始存储，但是运行时搬运到0x80000000处 */ \t. 0x80000000; \tPROVIDE(s_first_task LOADADDR(.first_task)); \t.first_task : AT(e_data) { \t\t*first_task_entry*(.text .data. rodata .data) \t\t*first_task*(.text .data. rodata .data) \t} \tPROVIDE(e_first_task LOADADDR(.first_task) + SIZEOF(.first_task)); \tPROVIDE(mem_free_start e_first_task); } ``` 使用这个方法可以把程序的虚拟地址放在0x80000000位置, 同时实际的物理地址还在原来的内存地址后边, 使用这个方式进行存放的时候需要受到的把代码移动到0x80000000的虚拟地址, 这里采用的方式是在任务的LDT表切换以后申请一段内存, 然后把虚拟内存的地址映射过去 映射以后要把实际的代码拷贝过去 ```c /// @brief 初始化第一个任务 void task_first_init(){ \t// xxxxx // 申请内存, 在进程的页表里面 memory_alloc_page_for(first_start, alloc_size, PTE_P PTE_W); kernel_memcpy((void *)first_start, s_first_task, copy_size); } int memory_alloc_page_for(uint32_t addr, uint32_t size, uint32_t perm){ return memory_alloc_for_page_dir(task_current() >tss.cr3, addr, size, perm); } int memory_alloc_for_page_dir(uint32_t page_dir, uint32_t vaddr, uint32_t size, uint32_t perm){ uint32_t curr_vaddr vaddr; int page_count up2(size, MEM_PAGE_SIZE) / MEM_PAGE_SIZE; for(int i 0; i < page_count; i++){ uint32_t paddr addr_alloc_page(&paddr_alloc, 1); if(paddr (uint32_t) 1){ log_printf(\"alloc page failed!\"); return 1; } int err memory_create_map((pde_t *)page_dir, curr_vaddr, paddr, 1, perm); if(err 1){ log_printf(\"create map failed!\"); addr_alloc_free(&paddr_alloc, paddr, 1); return 1; } curr_vaddr + MEM_PAGE_SIZE; } return 0; } ```"},"/note/Linux/李述铜手写操作系统/2023-9-6-1操作系统准备.html":{"title":"操作系统准备","content":" layout: post title: \"操作系统准备\" date: 2023 9 6 15:39:08 +0800 tags: 李述铜 # 操作系统准备 编译器GCC GDB调试器, PC和虚拟机进行连接 Binutils工具集 使用VSCode和CMake进行控制 虚拟机使用的是qemu 附加工具: 对于磁盘映像进行读写 ## 具体的配置 1. 安装gcc工具链以及配置路径,这里安装在C盘根目录 2. 安装cmake工具用于包管理,直接使用提供的安装包就可以了 2. 安装qemu,必须这一个版本, 并且默认路径 2. 安装git, 添加./usr/bin文件, 因为要使用dd命令 2. vscode安装各种插件 2. ![image 20230907184743751](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242301387.png)![image 20230907184744239](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242301388.png) 2. 调试之后F5进行运行"},"/note/Linux/李述铜手写操作系统/2024-2-29-键盘初始化.html":{"title":"键盘的初始化","content":" layout: post title: \"键盘的初始化\" date: 2024 2 29 15:39:08 +0800 tags: 李述铜 # 键盘的初始化 键盘开启以后通过PIC1的IRQ1中断通知电脑, 之后通过端口获取信息 ![image 20240229113738899](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402291137950.png) ![image 20240229121451774](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402291214808.png) > ![image 20240229121512808](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402291215850.png) > > 状态寄存器 ## 按键的获取 键盘的中断链连接外的是IRQ1的位置, 使用0x21的中断号 获取的时候判断一下状态寄存器的位0, 之后读取数值 这一个数值的bit7为表示这一个按键是按下, 反之是抬起 > A按下0x1E, 抬起0x9E, 其他的位是一样的表示是同一个按键 键盘的扫描码有三种, Scan Code Set 1, 2, 3, 现在的计算机会自动的转换为扫描码1 按键可能有多个字节 + 单字节 + E0开头的的两个字节或者四个字节 + E1开头的六个字节 [键盘扫描码（表格）_键盘扫描码对照表 CSDN博客](https://blog.csdn.net/deniece1/article/details/103588428)"},"/note/Linux/李述铜手写操作系统/2024-3-4-文件系统.html":{"title":"文件系统","content":" layout: post title: \"文件系统\" date: 2024 3 4 15:39:08 +0800 tags: 李述铜 # 文件系统 需要处理的问题 + 通过路径区分不同的设备 + 添加一个设备的时候改变的代码尽可能的少 + 硬盘分区的处理 ![image 20240304191020953](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403041910064.png) ![image 20240304193517572](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403041935661.png) > fs_op_t里面有各种操作系统的操控函数, 用于处理不同的操作系统 ![image 20240304213740127](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403042137209.png)"},"/note/Linux/李述铜手写操作系统/2023-9-6-0补充知识.html":{"title":"补充知识1","content":" layout: post title: \"补充知识1\" date: 2023 9 6 15:39:08 +0800 tags: 李述铜 # 补充知识 ![总体框图](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242301008.jpg) ## qemu 开源的托管虚拟机, 纯软件虚拟化模拟器, 几乎可以模拟任何硬件设备, 电视性能比较低 预备篇使用的命令是`qemu system i386 daemonize m 128M s S drive file disk.img,index 0,media disk,format raw` > 这条命令是用来启动一个 QEMU 虚拟机的。我们可以逐个解析命令的各个部分。 > > 1. `qemu system i386`： > 这是命令的主程序，表示你要启动一个支持 i386 架构的 QEMU 虚拟机。i386 是指 Intel 的 32 位架构。 > 2. ` daemonize`： > 这个选项告诉 QEMU 在后台运行，而不是在前台占用终端窗口。这样你可以继续使用你的终端。 > 3. ` m 128M`： > 这个选项指定虚拟机的内存大小为 128MB。你可以根据需要调整这个值，更多内存可以提高虚拟机的性能。 > 4. ` s`： > 这个选项启用 GDB (GNU Debugger) 监视。启动后，你可以用 GDB 调试虚拟机。 > 5. ` S`： > 这个选项指定在启动时停止虚拟机。这样你可以在启动后通过 GDB 进行调试，手动启动虚拟机。 > 6. ` drive file disk.img,index 0,media disk,format raw`： > 这个选项用来指定虚拟机要使用的磁盘镜像文件。详细解析如下： > `file disk.img`：指定虚拟机使用的硬盘镜像文件名为 `disk.img`。 > `index 0`：这个参数指定这是第一个硬盘（有时可以同时指定多个硬盘）。 > `media disk`：指定媒介的类型为磁盘。 > `format raw`：指定镜像文件的格式为 raw（原始格式），即没有任何额外的元数据。 > > 总结一下，这条命令会启动一个后台运行的 i386 架构的 QEMU 虚拟机，使用 128MB 的内存，加载 `disk.img` 作为硬盘，启动时暂停等待调试。 ### 两种运行模式 + 用户模式(User mode)：利用动态代码翻译机制来执行不同主机架构的代码，例如：在x86平台上模拟执行ARM代码，也就是说：我们写一条ARM指令，传入整个模拟器中，模拟器会把整个指令翻译成x86平台的指令，然后在x86的CPU中执行。 + 系统模式(System mode)：模拟整个电脑系统，利用其它VMM(Xen, KVM)来使用硬件提供的虚拟化支持，创建接近于主机性能的全功能虚拟机。 计算机的组成 + 运算器 + 控制器 + 存储器 + 输入设备 + 输出设备 创建一个存储器 ``` qemu img creat f qcow2 drive 16G ``` > 创建一个16G的硬盘 虚拟硬件环境 ## VSCode 是一个免费的跨平台的开源轻量级编译器 有一个稳定版和一个体验版 ### 环境 下载编译器并且配置路径 ### 创建项目 创建一个文件夹 打开文件夹, 之后信任文件夹, 之后可以在里面新建文件 ### 运行 设置编译选项 Ctrl+Shift+P, 之后选择配置C/C++环境, 选择编译器以及高亮提示 ### 创建任务 终端 >配置任务 >选择编译器 生成task.json文件 ```json { \t\"version\": \"2.0.0\", \t\"tasks\": [ \t\t{ \t\t\t\"type\": \"cppbuild\", \t\t\t\"label\": \"C/C++: gcc.exe 生成活动文件\", \t\t\t\"command\": \"E:\\\\alearn\\\\gcc\\\\mingw64\\\\bin\\\\gcc.exe\",\t//使用的编译器 \t\t\t\"args\": [ \t\t\t\t\" fdiagnostics color always\", \t\t\t\t\" g\", \t\t\t\t\"${file}\",\t\t\t//被编译的文件 \t\t\t\t\" o\", \t\t\t\t\"${fileDirname}\\\\${fileBasenameNoExtension}.exe\"\t//生成的可执行文件的路径 \t\t\t], \t\t\t\"options\": { \t\t\t\t\"cwd\": \"${fileDirname}\" \t\t\t}, \t\t\t\"problemMatcher\": [ \t\t\t\t\"$gcc\" \t\t\t], \t\t\t\"group\": \"build\", \t\t\t\"detail\": \"编译器: E:\\\\alearn\\\\gcc\\\\mingw64\\\\bin\\\\gcc.exe\" \t\t} \t] } ``` > 之后直接在终端 >运行生成任务就行了 ### 调试 ```json { // 使用 IntelliSense 了解相关属性。 // 悬停以查看现有属性的描述。 // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid 830387 \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"(gdb) 启动\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"输入程序名称，例如 ${workspaceFolder}/a.exe\",\t//被调试的程序 \"args\": [], \"stopAtEntry\": false, \"cwd\": \"${fileDirname}\", \"environment\": [], \"externalConsole\": false, \"MIMode\": \"gdb\", \"miDebuggerPath\": \"/path/to/gdb\",\t\t//使用的调试工具 \"setupCommands\": [ { \"description\": \"为 gdb 启用整齐打印\", \"text\": \" enable pretty printing\", \"ignoreFailures\": true }, { \"description\": \"将反汇编风格设置为 Intel\", \"text\": \" gdb set disassembly flavor intel\", \"ignoreFailures\": true } ] } ] } ``` 在调试界面选择添加配置, 选择gdb启动 ## Makefile ### gcc 常见的组成部分 + **c++：** gcc 的一个版本，默认语言设置为 C++，而且在链接的时候自动包含标准 C++ 库。这和 g++ 一样 + **configure：** GCC 源代码树根目录中的一个脚本。用于设置配置值和创建 GCC 编译程序必需的 make 程序文件 + **g++：** gcc 的一个版本，默认语言设置为 C++，而且在链接的时候自动包含标准 C++库。这和 c++ 一样 + **gcc：** 该驱动程序等同于执行编译程序和连接程序以产生需要的输出 + **libgcc：** 该库包含的例程被作为编译程序的一部分，是因为它们可被链接到实际的可执行程序中。它们是特殊的例程，链接到可执行程序，来执行基本的任务，例如浮点运算。这些库中的例程通常都是平台相关的 + **libstdc++：** 运行时库，包括定义为标准语言一部分的所有的 C++类和函数 包含的常见的软件 **ar：** 这是一个程序，可通过从文档中增加、删除和析取文件来维护库文件。通常使用该工具是为了创建和管理连接程序使用的目标库文档。该程序是 binutils 包的一部分 **as：** GNU 汇编器。实际上它是一族汇编器，因为它可以被编译或能够在各种不同平台上工作。该程序是 binutjls 包的一部分 autoconf：产生的 shell 脚本自动配置源代码包去编译某个特定版本的 UNIX **gdb：** GNU 调试器，可用于检查程序运行时的值和行为 GNATS：GNU 的调试跟踪系统（GNU Bug Tracking System）。一个跟踪 GCC和其他 GNU 软件问题的在线系统 **gprof：** 该程序会监督编译程序的执行过程，并报告程序中各个函数的运行时间，可以根据所提供的配置文件来优化程序。该程序是 binutils 包的一部分 **ld：** GNU 连接程序。该程序将目标文件的集合组合成可执行程序。该程序是 binutils 包的一部分 **libtool：** 一个基本库，支持 make 程序的描述文件使用的简化共享库用法的脚本 **make：** 一个工具程序，它会读 makefile 脚本来确定程序中的哪个部分需要编译和连接，然后发布必要的命令。它读出的脚本（叫做 makefile 或 Makefile）定义了文件关系和依赖关系 默认的搜索路径 查看命令 ``` echo gcc v x c E ``` /usr/lib/gcc/x86_64 linux gnu/7/include /usr/local/include /usr/lib/gcc/x86_64 linux gnu/7/include fixed /usr/include/x86_64 linux gnu /usr/include #### 简单的编译原理 ![image 20230909101423089](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402051511874.png) 预处理阶段, 把.c结尾的文件的#开头的命令进行预处理, 直接把对应的文本内容放到对应的位置 编译器, 把预处理之后的文件修改为汇编文件 汇编器, 汇编文件转换为二进制文件 连接器, 把所有的.o文件连接在一起形成一个可执行文件 #### 各种文件的后缀 .a 静态库文件 .c C语言文件 .h 头文件 .i 预处理之后的文件 .o 目标文件 .s 汇编文件 .so 共享的库 #### 实际使用gcc进行编译 + 预处理 ```bash gcc E mian.c ``` > 这一个会进行预处理但是没有生成一个文件 ```bash gcc E main.c o main.i ``` + 生成汇编文件(编译, 使用的资源最多) ```bash gcc S main.c gcc S main.c o main.s ``` + 生成目标文件(汇编) ```bash gcc c main.c gcc c main.c o main.o ``` + 之间编译成可执行文件 ```bash gcc main.c ``` #### 静态库编译以及链接 1. 把c文件编译成o文件 2. 编译静态库 ```bash ar r [lib库名.a] [.o] [.o] ``` > ```bash > ar rcs libmylib.a file1.o file2.o > ``` > > file2.o以上表示要把目标码file1.o和file2.o加入到静态库libmylib.a中(ar的参数 r)。若libmylib.a不存在，会自动创建(ar的参数c)。然后更新.a文件的索引，使之包含新 加入的.o文件的内容(ar的参数s)。 3. 连接成可执行文件 ```bash gcc [.c] [.a] o [输出的文件名] gcc [.c] o [输出的文件名] l [库的名字] L [库所在的位置] ``` > **注: windows下面为.lib文件, 但是测试的时候.a文件才可以使用** #### 编译动态库 ```bash gcc c fpic [.c/.cpp] ... ``` > 编译成 o文件, 这样编译出来的文件使用都是相对地址 ```bash gcc shared [.o] [.o] ... o [lib.so] ``` > 创建动态库 ```bash gcc [.c/.cpp] o [自定义可执行文件] l[库名] L[库路径] wl, rpath [库路径] ``` > 链接动态库到可执行文件 + 出错 ![image 20240210202755651](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402102027691.png) > 这一个是动态链接器的错误, 这一个是程序的运行的阶段, 运行的时候需要提供库的位置 > > LD_LIBRARY_PATH这一个变量默认的时候是空的 > > ![image 20240210203103841](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402102031877.png) > > > 这一个只能在这一个进程里面使用 > > > > 永久的时候使用文件./bashrc, 之后可以 . ./bashrc 或者source .bashrc 或者重启终端 > > > > 还可以把这一个库放在/lib目录里面 > > > 查看一个库可不可以用可以使用ldd a.out获取使用的动态库以及路径 > > > > ![image 20240210204433393](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402102044431.png) > > > > ![image 20240210204527685](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402102045722.png) > > > 还可以使用配置文件, 在文件/etc/ld.so.conf文件里面加入路径 > > > > 之后使用命令`sudo ldconfig v` > **注: windows下面为dll文件** ##### 实际的使用 ```c gcc main.c I./lib ./lib/libfunc.a ``` > 静态库需要直接编译进去, 使用的时候库在c文件前面 #### 其他常用命令 ```bash gcc I路径 # 头文件不在一个文件夹下面 gcc I./include hello.c o hello gcc c main.c # 只做一个预处理,编译,以及汇编,获取一个.o文件 gcc g hello.c # 获取的文件可以进行调试(gdb) gcc Wall hello.c # 获取更多的警告信息 gcc O2 main.c # 一个优化的等级(默认是第二级) gcc M main.c # 生成与.c文件有依赖关系的头文件, 用于Makefile(包括系统库头文件) gcc MM main.c # 生成与.c文件有依赖关系的头文件, 用于Makefile(不包括系统库头文件) gcc D HELLO main.c# 动态注册定义一个宏HELLO(一般使用#ifdef的时候可以用这一个) ``` > 宏定义的使用 > > ![image 20240210183751938](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402101837069.png) > > ![image 20240210183927270](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402101839304.png) #### 静态库和动态库的区别 静态库在编译时会被完整地复制到可执行文件中，因此它们会增加可执行文件的大小。在链接时刻，编译器会将静态库的代码与可执行文件的代码合并，生成一个完整的可执行文件。由于静态库已经被完整地复制到可执行文件中，因此程序在运行时不需要再加载静态库，这样可以提高程序的运行速度。但是，如果多个可执行文件都使用同一个静态库，那么静态库的代码会被复制多次，浪费空间。 动态库则是在程序运行时才被加载到内存中，因此它们不会增加可执行文件的大小。在链接时刻，编译器只会将动态库的引用信息添加到可执行文件中，而不会将动态库的代码复制到可执行文件中。程序在运行时会动态地加载动态库，并将其映射到内存中。由于多个可执行文件可以共享同一个动态库，因此动态库可以节省内存空间。但是，由于动态库需要在程序运行时才能加载，因此程序的启动速度可能会受到影响。 总的来说，静态库适用于需要高效运行的小型程序，而动态库适用于需要共享代码和节省内存空间的大型程序。 + 动态库实现的原理 如果静态的时候在main里面使用了两个函数func1和func2, 这两个函数的地址是以main函数来定义的, 如func1 main + 100, 在生成可执行文件的时候初始化main函数的地址 ![image 20240210201323865](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402102013923.png) > add是静态库里面的, printf是动态库的, 这一个地址有一个@plt, 他的地址是根据动态库加载到内存里面的位置 #### C++编译文件的过程 + .a 静态库文件 + .c .c++ .cc .cp .cpp .cxx 源代码的文件 + .h 头文件 + .i 预处理文件 + .o 目标文件 + .s 汇编文件 ```bash g++ E main.c g++ E main.c o maim.i ``` > 预处理文件 ```bash g++ S main.c o mian.s ``` > 生成汇编文件 ```bash g++ c main.c o main.o ``` > 生成预处理文件 ```bash g++ main.c o main.exe ``` > 生成可执行文件 ```bash ar cr [lib库的名字.a] [.o] [.o] ``` ```bash g++ [.c] [.a] o [输出的文件名] g++ [.c] o [输出的文件名] l[库的名字] L[库所在的位置] ``` > 静态库文件 ```bash g++ c fpic [.c/.cpp] ... ``` > 编译成 o文件 ```bash g++ shared [.o] [.o] ... o [lib库的名字.lib] ``` > 创建动态库 ```bash g++ [.c/.cpp] o [自定义可执行文件] l[库名] L[库路径] wl, rpath [库路径] ``` > 链接动态库到可执行文件 ### Makefile语法 #### 使用 使用make编译目标文件, 使用make n会显示如果使用make的话使用的命令 `make f 文件名`, 使用者一个文件的规则 #### 基本的格式 ```makefile targets : prerequisties [tab键]command ``` target：目标文件，可以是 OjectFile，也可以是执行文件，还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述。 prerequisite：要生成那个 target 所需要的文件或是目标。依赖文件, 使用的时候如果没有会去找他的生成规则 command：是 make 需要执行的命令 ![image 20230909194637856](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402051511875.png) ![image 20230909194651591](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402051511876.png) > 这样的话会输出使用的命令, 可以在前面添加@使得输出隐藏 ```makefile debug : \t@echo hello ``` ```bash PS E:\\桌面\\c_test> make hello PS E:\\桌面\\c_test> ``` #### 格式的补充 + commend前面加一个` `, 出错依旧执行 + @commend: 命令不显示执行 ```makefile $(obj) : targets : prerequisties [tab键]command ``` > 对于obj里面的文件使用这一个规则 #### Makefile规则 + 会在文件夹里面找到Makefile文件或者makefile文件 + 会找到文件中的第一个目标文件(target), 把这个文件作为目标文件, 可以使用`ALL: a.out`的方式改变目标文件 + target文件不存在或者依赖的.o文件修改时间比这个文件新的话会执行定义的commang命令生成这个文件 + 如果.o文件也存在, 会找到.o文件的依赖, 依据规则生成.o文件 #### 伪目标 为了避免 target 和 Makefile 同级目录下 `文件/文件夹` 重名的这种情况，我们可以使用一个特殊的标记 `.PHONY` 来显式地指明一个目标是 \"伪目标\"，向 make 说明，不管是否有这个文件/文件夹，这个目标就是 \"伪目标\" ``` .PHONY : clean ``` > 如果有一个名字叫clean的文件在这个文件夹下面, 就不会执行这一个命令 > > ![image 20230909195857917](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402051511878.png) > > 这个时候就会输出 > > ```makefile > debug : world > \t@echo hello > > world : > \t@echo world > > clean : > \t@rm *.o > ``` > > ```bash > PS E:\\桌面\\c_test> make clean > make: 'clean' is up to date. > PS E:\\桌面\\c_test> > ``` 只要有这个声明，不管是否有 \"clean\" 文件/文件夹，要运行 \"clean\" 这个目标，只有\"make clean\" 这个命令 > 注意 对于有 prerequisties 的 target ```makefile debug : world \t@echo hello world : \t@echo world clean : \t@rm *.o .PHONY : clean ``` > 这个时候就会执行这一个命令了 #### 变量 变量有自己定义的和默认定义的 ##### 变量的定义 ```makefile cpp : src/main.cpp obj : objs/main.o ``` ##### 变量的引用 + 可以使用()或者{} ```makefile cpp : src/main.cpp obj : objs/main.o $(obj) : ${cpp} \t@g++ c $(cpp) o $(obj) compile : $(obj) ``` ```makefile compiler : cpp debug : \t@echo $(compiler) ``` ```bash PS E:\\桌面\\c_test> make cpp ``` > 变量会被转化为在上面输入的变量 #### 预定义的变量$@等 `$@`: 目标(target)的完整名称 `$<`: 第一个依赖文件（prerequisties）的名称 `$^`: 所有的依赖文件（prerequisties），以空格分开，不包含重复的依赖文件 ```makefile cpp : src/main.cpp obj : objs/main.o $(obj) : ${cpp} \t@g++ c $< o $@ \t@echo $^ compile : $(obj) .PHONY : compile ``` #### 常用的符号 1. + 简单的赋值 + 在后面的语句里面重新定义该变量, 会使用新的值 ```makefile HOST_ARCH arrch64 TARGET_ARCH $(HOST_ARCH) HOST_ARCH amd64 debug : \t@echo $(TARGET_ARCH) ``` ```bash PS E:\\桌面\\c_test> make debug amd64 PS E:\\桌面\\c_test> ``` > 会随时更新使用 的变量 2. : 赋值了之后就不会进行更改 ```makefile HOST_ARCH : arrch64 TARGET_ARCH : $(HOST_ARCH) HOST_ARCH : amd64 debug : \t@echo $(TARGET_ARCH) \t@echo $(HOST_ARCH) ``` ```bash PS E:\\桌面\\c_test> make debug arrch64 amd64 PS E:\\桌面\\c_test> ``` 3. ? + 默认赋值运算符 + 如果变量已经定义就不进行任何操作 + 如果没有定义就求值并进行分配 ```makefile HOST_ARCH : arrch64 TARGET_ARCH : $(HOST_ARCH) HOST_ARCH ? amd64 debug : \t@echo $(TARGET_ARCH) \t@echo $(HOST_ARCH) ``` ```bash PS E:\\桌面\\c_test> make debug arrch64 arrch64 ``` 4. + + 累加符号 ```makefile HOST_ARCH : arrch64 TARGET_ARCH : $(HOST_ARCH) HOST_ARCH + amd64 debug : \t@echo $(TARGET_ARCH) \t@echo $(HOST_ARCH) ``` ```bash PS E:\\桌面\\c_test> make debug arrch64 arrch64 amd64 PS E:\\桌面\\c_test> ``` 5. \\ + 续行符 ```makefile HOST_ARCH : arrch64 \\ \t\t\t arm63 x86 TARGET_ARCH : $(HOST_ARCH) HOST_ARCH + amd64 debug : \t@echo $(TARGET_ARCH) \t@echo $(HOST_ARCH) ``` ```bash PS E:\\桌面\\c_test> make debug arrch64 arm63 x86 arrch64 arm63 x86 amd64 PS E:\\桌面\\c_test> ``` #### 常用的函数 函数的调用 `$(fn , argument) or ${fn, argument}` + fn: 函数名 + argument: 函数的参数 ##### shell ```makefile $(shell <commend> <argument>) ``` > 名称: shell > > 功能: 调用shell 使用commend > > 返回: shell执行commend的结果 ```makefile pwd : $(shell pwd) debug : \t@echo $(pwd) ``` ```bash PS E:\\桌面\\c_test> make debug /e/妗岄潰/c_test PS E:\\桌面\\c_test> ``` ##### subst字符串替换 ```makefile $(subst <from>,<to>,<text>) ``` + 名称: 字符串替换函数 + 功能: 把字符串<text> 中的 <from> 替换为 <to> + 返回的是替换之后的字符串 ```makefile cpp_src : $(shell ls *.c) cpp_objs : $(subst .c,.exe, $(cpp_src)) debug : \t@echo $(cpp_src) \t@echo $(cpp_objs) ``` ```bash PS E:\\桌面\\c_test> make add.c main.c add.exe main.exe PS E:\\桌面\\c_test> ``` ##### patsubst替换字符串 ```makefile $(patsubst <pattern>,<replacement>,<text>) ``` > 通配符替换字符串 > > 通配符%把要替换的文字分割开来, 可以一次性替换多个不同的字符串 ```makefile cpp_src : $(shell pwd) cpp_objs : $(patsubst /e%/c_test,/c%/jiao, $(cpp_src)) debug : \t@echo $(cpp_src) \t@echo $(cpp_objs) .PHONY : debug ``` ```bash PS E:\\桌面\\c_test> make debug /e/妗岄潰/c_test /c/妗岄潰/jiao PS E:\\桌面\\c_test> ``` ##### foreach循环函数 ```makefile $(foreach <var>,<list>,<text>) ``` 名称：循环函数——foreach。 功能：把字串<list>中的元素逐一取出来，执行<text>包含的表达式 返回：<text>所返回的每个字符串所组成的整个字符串（以空格分隔） ```makefile library_paths : /datav/shared/100_du/03.08/lean/protobuf 3.11.4/lib \\ /usr/local/cuda 10.1/lib64 library_paths : $(foreach item,$(library_paths), L$(item)) debug : \t@echo $(library_paths) ``` ```bash PS E:\\桌面\\c_test> make debug L/datav/shared/100_du/03.08/lean/protobuf 3.11.4/lib L/usr/local/cuda 10.1/lib64 PS E:\\桌面\\c_test> ``` + 可以使用下面的方式进行代替 ``` I_flag : $(include_paths:% I%) ``` ```makefile library_paths : /datav/shared/100_du/03.08/lean/protobuf 3.11.4/lib \\ /usr/local/cuda 10.1/lib64 # library_paths : $(foreach item,$(library_paths), L$(item)) library_paths : $(library_paths:% L%) debug : \t@echo $(library_paths) ``` ```bash PS E:\\桌面\\c_test> make debug L/datav/shared/100_du/03.08/lean/protobuf 3.11.4/lib L/usr/local/cuda 10.1/lib64 PS E:\\桌面\\c_test> ``` ##### dir文件名序列中取出目录部分 ```makefile $(dir <names...>) ``` > 名称：取目录函数——dir。 > 功能：从文件名序列中取出目录部分。目录部分是指最后一个反斜杠（“/”）之前 的部分。如果没有反斜杠，那么返回“./”。 > 返回：返回文件名序列的目录部分。 ```makefile .PHONY : debug cpp_srcs : $(shell ls *.c) # 在文件名前面加上路径 cpp_objs : $(foreach item,$(cpp_srcs),./output/$(item)) # 获取输出的文件的文件名 cpp_objs : $(subst .c,.o,$(cpp_objs)) debug : \t@echo $(cpp_srcs) \t@echo $(cpp_objs) # 生成所有的.o文件 ./output/%.o : %.c \t@mkdir p $(dir $@) \tgcc c $^ o $@ compile : $(cpp_objs) ``` ```bash PS E:\\桌面\\c_test> make compile gcc c add.c o output/add.o gcc c main.c o output/main.o PS E:\\桌面\\c_test> ``` 使用makedir p可以在没有文件夹的时候创建文件夹 > In a Makefile, the % symbol is used as a wildcard character to match any string. It is often used in conjunction with pattern rules to specify a set of targets and dependencies that follow a certain pattern. ##### notdir去路径名 ```makefile $(notdir <names...>) ``` > 如果输入的文件里面有文件夹的路径名, 就会去掉 ```makefile libs : $(notdir $(shell find /usr/lib name lib*)) ``` > 会寻找这里面的所有的库文件, 之后会把所有的文件的文件路径去除 ##### filter过滤掉一些文件 ```makefile $(filter <names...>) ``` > 根据自己的需求过滤掉一些文件 ```makefile libs : $(notdir $(shell find /usr/lib name lib*)) a_libs : $(filter %.a,$(libs)) so_libs : $(filter %.so,$(libs)) ``` > 在这里面可以会找到两种不同格式的库文件 ##### basename去文件的后缀 会把文件的后缀去掉 ```makefile $(basename <names...>) ``` ```makefile libs : $(notdir $(shell find /usr/lib name lib*)) a_libs : $(subst lib,,$(basename $(filter %.a,$(libs)))) so_libs : $(subst lib,,$(basename $(filter %.so,$(libs)))) ``` > 会去除.o和.so的文件后缀名,在之后就是去掉文件的前缀 ##### filter out剔除字符串 剔除不想要的字符串 ```makefile objs : objs/add.o objs/minus.o objs/main.o cpp_objs : $(filter out objs/main.o, $(objs)) ``` ##### wildcard匹配文件 The wildcard function expands to a space separated list of filenames that match the given patterns ```makefile cpp_srcs : $(wildcard src/*.cc src/*.cpp src/*.c) ``` > 获取所有的.cc, .cpp以及.c文件 #### 实战教程 ```makefile .PHONY : debug compile c_srcs : $(shell ls *.c) # 添加输出的文件的文件夹名字 c_objs : $(foreach item,$(c_srcs),./output/$(item)) # 获取要输出的各种文件的名字 c_objs : $(subst .c,.o,$(c_objs)) c_i : $(subst .o,.i,$(c_objs)) c_s : $(subst .o,.s,$(c_objs)) run : output/result.exe \t@.\\$< debug : \t@echo $(c_objs) \t@echo $(c_i) output/%.o : %.c \t@mkdir p $(dir $@) \tgcc c $^ o $@ output/%.i : %.c \t@mkdir p $(dir $@) \tgcc E $^ o $@ output/%.s : %.c \t@mkdir p $(dir $@) \tgcc S $^ o $@ output/result.exe : $(c_objs) \t@mkdir p $(dir $@) \tgcc $^ o $@ clean : \trm rf output compile : $(c_objs) $(c_i) $(c_s) output/result.exe ``` #### 编译的选项 > 编译选项 ` m64`: 指定编译为 64 位应用程序 ` std `: 指定编译标准，例如： std c++11、 std c++14 ` g`: 包含调试信息 ` w`: 不显示警告 ` O`: 优化等级，通常使用： O3 ` I`: 加在头文件路径前 `fPIC`: (Position Independent Code), 产生的没有绝对地址，全部使用相对地址，代码可以被加载到内存的任意位置，且可以正确的执行。这正是共享库所要求的，共享库被加载时，在内存的位置不是固定的 > 链接选项 ` l`: 加在库名前面 ` L`: 加在库路径前面 ` Wl,<选项>`: 将逗号分隔的 <选项> 传递给链接器 ` rpath `: \"运行\" 的时候，去找的目录。运行的时候，要找 .so 文件，会从这个选项里指定的地方去找 #### 通常使用的变量名 CC: Program for compiling C programs; default cc CXX: Program for compiling C++ programs; default g++ CFLAGS: Extra flags to give to the C compiler CXXFLAGS: Extra flags to give to the C++ compiler CPPFLAGS: Extra flags to give to the C preprocessor LDFLAGS: Extra flags to give to compilers when they are supposed to invoke the linker #### 编译带头文件的程序 ```makefile c_srcs : $(shell ls ./src//*.c) c_objs : $(patsubst ./src%.c,./output%.o, $(c_srcs)) in_path : ./inc I_flags : $(foreach item,$(in_path), I$(item)) compile_options : g O1 w $(I_flags) output/%.o : src/%.c \t@mkdir p $(dir $@) \t@gcc c $^ o $@ $(compile_options) output/result : $(c_objs) \t@mkdir p $(dir $@) \t@gcc $^ o $@ $(compile_options) run : output/result \t@./output/result clean : \t@rm rf ./output gdb : output/result \tgdb debug : \t@echo $(I_flags) .PHOHY : debug run gdb clean ```"},"/note/Linux/李述铜手写操作系统/2024-2-24-系统调用.html":{"title":"系统调用","content":" layout: post title: \"系统调用\" date: 2024 2 24 15:39:08 +0800 tags: 李述铜 # 系统调用 这一个文件目前只是记录一下实现的API ## 权限 实际使用权限管理的时候需要查看三个位置, 代码段的CPL, 段选择子的RPL和数据段的DPL, 要求CPL RPL> DPL的时候才可以访问 自己的代码权限足够高, 并且实际使用的段选择子不可以把权限放低 描述符里面有一个C字段, 如果C 0的时候CPL必须等于DPL, 并且RPL< CPL, 权限需要一致, C 1的时候CPL> DPL, RPL不检查(不使用, 不能访问高权限的地址) 这里使用的实际的内存权限控制是在页表里面, 如果在用户级别的时候发送中断, 会自动跳入系统权限的栈里面进行错误码的压入, 同时压入的数据更多把用户的sep和ss寄存器压入 > 空闲任务在设置额度时候需要在特权级0 在任务初始化的时候需要把任务的段寄存器的低位设置为3, 同时需要使用iret指令使用函数返回的方式进行任务的切换, 这个命令通常用于中断的返回, 所以可以实现从高特权级回到用户特权级的作用 > 在使用这个方法的时候, 栈里面从高到低依次是一下的数值ss, esp, eflags, cs, eip, errcode ## msleep(int ms) 实现一个毫秒级的延时 ## getpid() 获取当前的任务的id ## print_msg(char *fmt, int num); 一个打印信息的临时函数, 可以打印一个数字 ## fork() [Linux系统——fork()函数详解(看这一篇就够了！！！)_fork函数 CSDN博客](https://blog.csdn.net/cckluv/article/details/109169941) > 实际的使用可以看这一个, 我主要是原理分析 ### 大致思路 在这一个调用函数的位置创建一个子进程, 之后两个进程一起向下执行 成功返回的id是一个大于0的数字给父进程, 子进程从这个位置开始获取的数字是0 目前的实现的时候使用一个静态的数组为任务描述符 这一个子进程的栈设置的时候不能有使用系统调用的时候的压入的参数(主程序使用retf取出来了) > 问题: 这两个进程不能使用同一块页表 > > 需要给这一个子进程一个相同的内存空间, 映射的位置不同 ### 实际实现 1. 使用GDT里面的系统调用门进入特权级0,这一段不再概述,前面的文章有 2. 新的任务空间准备 ```c int sys_fork(void){ task_t *parent_task task_current();//获取当前的任务 task_t *child_task alloc_task();//获取一个新的任务描述符 if(child_task (task_t *)0){ goto fork_failed; //获取失败 } //这一个任务进入的时候会使用esp会记录一下当前的任务的各个寄存器里面的值(push) //这里计数一下压入以后的esp的值 //这里tss记录的是进入特权级0的时候他的位置 //syscall_frame_t是按照push的顺序记录一下各个寄存器 //之后改变这一个可以在任务返回的时候寄存器里面的状态改变 syscall_frame_t * frame (syscall_frame_t *)(进来时候记录的特权级的esp sizeof(syscall_frame_t)); //初始化这一个新的任务,使用父任务的数据 //函数的入口使用这一个函数调用系统调用时候记录的esp指针 //这里最后一个参数使用的这一个进程的栈是压入了几个参数以后的结果,从这里返回以后实际回到的位置没有这几个参数 int err task_init(child_task, 父进程名字, 用户级任务的标志, frame >eip, frame >esp + sizeof(uint32_t) * 参数的个数T; if(err < 0){ goto fork_failed; } tss_t *tss &child_task >tss; tss >eax 0;//这一个是子进程的返回值(C语言使用eax为返回值) tss >ebx frame >ebx; \t...依次记录各个寄存器 tss >eflags frame >eflags; child_task >parent parent_task; //这里是处理页表的位置, 给子进程申请一块相同的内存虚拟地址, 但是是不同的物理地址 //这一个函数会把任务使用的页表项复制到新的页表虚拟地址对应的物理地址 //这一个子进程寄页表没有启用, 需要从页表里面获取实际的物理地址之后使用 if((子进程页表 memory_copy_uvm(父进程页表)) < 0){ goto fork_failed; } \t//这一个是父任务的返回值 return child_task >pid; fork_failed: \t//失败处理 return 1; } ``` ## execve(const char *filename, char *const argv[ ], char *const envp[ ]) 这一个是一个Linux下面的标准接口 这一个的实际作用的是执行一个可执行文件 把当前程序替换成要执行的程序, 而同时保留原程序运行的方法是，fork+exec 第二个参数是利用数组指针来传递给执行文件，并且需要以空指针(NULL)结束，最后一个参数则为传递给执行文件的新环境变量数组。 函数执行成功时没有返回值，执行失败时的返回值为 1. ```c #include<unistd.h> main() { 　　char *argv[ ] {\"ls\", \" al\", \"/etc/passwd\", NULL}; 　　char *envp[ ] {\"PATH /bin\", NULL} 　　execve(\"/bin/ls\", argv, envp); } ``` ## 实现的思路 ### CPU寄存器的初始化 在使用的时候需要一个新的页表, 记录这一个新的进程使用的地址信息 由于使用系调用的时候会记录进入的时候的CPU寄存器信息, 返回的时候弹出信息, 这一个新的进程再返回的时候, 首先使用是栈里面的记录的信息, 而不是tss表里面的信息 ![image 20240225191306270](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402251913513.png) > 返回的时候这里面的信息也需要进行更改, 如果不改变的话会返回之前的页表对应的位置 该变信息的时候可以使用tss里面的记录的esp0的值进行计算, 使用结构体syscall_frame_t(一个记录压栈时候寄存器顺序的结构体, 定位到对应的位置) ### 栈的初始化(参数传递) 在使用新的栈的时候, 设置esp需要减去一下系统调用的参数的位置(系统调用返回的时候使用retf会把栈里面的参数弹出来, 新的任务进入的时候栈里面没有这几个参数, 需要预留空间), 以及初始化一下main函数的参数在栈里面 ![image 20240225202348872](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402252023922.png) 这里可以使用把所有的信息放在栈里面 ## 实际的实现 ```c //执行一个可执行文件 int sys_execve(char *name, char ** argv, char ** env){ task_t *task task_current();//获取当前的任务 uint32_t new_page_dir memory_create_uvm();//获取一个新的页表给任务使用 uint32_t old_page_dir task >tss.cr3;//记录一下现在使用的页表 //使用这一个新的文件的名字初始化任务名字 kernel_strncpy(task >name, get_file_name(name), TASK_NAME_SIZE); if(! new_page_dir) { goto exec_failed; } //获取这一个的入口, 以及加载这一个文件到新的页表里面 //这里实际是加载一个elf文件, 以及从文件头获取他的入口地址 //这里需要注意的是实际使用的虚拟地址是还未使用的页表里面的 //实际加载的时候需要对使用的内存申请, 映射, 复制 uint32_t entry load_elf_file(task, name, new_page_dir); if(entry 0){ goto exec_failed; } //预留一段空间放参数(main函数的参数) uint32_t stack_top 栈的顶部虚拟地址 预留的参数保存地址; //为这一个任务的新页表申请一下栈空间 int err memory_alloc_for_page_dir(new_page_dir, MEM_TASK_STACK_TOP MEM_TASK_STACK_SIZE(实际的虚拟地址最小值), MEM_TASK_STACK_SIZE()大小, 权限(用户可使用, 可写)); if(err < 0){ goto exec_failed; } int argc strings_count(argv);//获取参数的个数 //把这一个参数按照之前图里面的格式复制到栈里面预留的空间 //之后main函数可以直接使用 err copy_args((char *)stack_top, new_page_dir, argc, argv); if(err < 0) { goto exec_failed; } //获取记录了栈里信息的地址 syscall_frame_t * frame (syscall_frame_t *)(系统调用的时候记录的特权级esp sizeof(syscall_frame_t)(实际压入的信息的大小)); //改变特权级0的栈里面的信息用于返回 frame >eip entry; frame >eax frame >ebx frame >ecx frame >edx 0; frame >esi frame >edi frame >ebp 0; frame >eflags EFLAGS_DEFAULT EFLAGS_IF; //预留一下栈里面参数的位置 frame >esp stack_top sizeof(uint32_t) * SYSCALL_PARAM_COUNT; //栈里面需要有初始的参数的值 task >tss.cr3 new_page_dir; mmu_set_page_dir(new_page_dir); //销毁之前的页表 memory_destroy_uvm(old_page_dir); return 0; exec_failed: if(new_page_dir){ \t\t/错误处理 } return 1; } ```"},"/note/Linux/李述铜手写操作系统/2023-10-26-05中断和异常处理.html":{"title":"中断和异常处理","content":" layout: post title: \"中断和异常处理\" date: 2023 10 26 15:39:08 +0800 tags: 李述铜 # 中断和异常处理 ## 创建GDT表 <img src \"https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242255489.png\" alt \"image 20231026191938627\" style \"zoom:150%;\" /> > 分段存储 Global Descriptor Table是一个结构体数组, 有一定的格式 > A segment descriptor is a data structure in a GDT or LDT that provides the processor with the size and location of a segment, as well as access control and status information. Segment descriptors are typically created by compilers, linkers, loaders, or the operating system or executive, but not application programs. Figure 3 8 illustrates the general descriptor format for all types of segment descriptors. > > ![image 20231026192405708](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242255490.png) > > + Base: 指明段的地址 > + limit: 段的长度 > + S: 0的时候是系统段, TSS/LDT等, 1的时候表示这一段是数据段或者代码段 > + DPL: 段的访问权限, 0 3 > + P: 这一个段是否有效 > + D/B: 代码段的时候制定了操作数和地址是32位还是16位, 栈的时候指定了栈是32位还是16位 > + G: 指定limit的单位是byte还是4KB > + L: 64位下面使用 > + AVL: 保留 > + type: 段的类型 > + ![image 20230911170239279](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242255491.png) ### 内存查找方式 32位的CPU存储架构有两种, 首先是分段机制, 还有一个分页机制 ![image 20240215163154368](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402151631466.png) + 分段机制 将线性的地址空间转换为多个段 每一个段有保护机制 有多种类型的段, 数据, 代码, 门, tss 使用的地址为逻辑地址: 段选择子+偏移 + 分页机制 将线性的地址转换为逻辑地址 在较小的内存上面实现较大的虚拟内存 按需加载等功能 ![image 20231029194028686](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310291940743.png) > 也就是说，在没有开启分页机制时，由程序员给出的**逻辑地址**，需要先通过分段机制转换成物理地址。但在开启分页机制后，逻辑地址仍然要先通过分段机制进行转换，只不过转换后不再是最终的物理地址，而是**线性地址**，然后再通过一次分页机制转换，得到最终的物理地址。 ![image 20231029194446670](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310291944713.png) > 段寄存器里面保存的是段的选择子 > > CS: 代码段, 指定执行代码的空间 > > SS: 栈段, 指定的栈的空间, 访问的时候使用的是SS:ESP > > DS/ES/FS/GS: 数据指定数据段的控制 ![image 20231029194858297](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310291948331.png) ![image 20231029194913978](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310291949010.png) > Intel给出的建议使用方法, 简单的平坦模型 > 逻辑地址比如0x8:1234会从GDT表项里1中基地址为0x10000, 则线性地址为0x11234 ![image 20231029195444801](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310291954836.png) > If paging is not used, the processor maps the linear address directly to a physical address (that is, the linear address goes out on the processor’s address bus). If the linear address space is paged, a second level of address translation is used to translate the linear address into a physical address. > > gdt表没有使用的时候会直接跳转物理地址, 否则的话使用的地址是表项的地址加偏移 ![image 20231029195713941](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310291957973.png) > 在查询GDP表的时候最下面的三位实际用作其他的作用, 所以查询的时候需要乘8, bit0, 1是设置特权级的 > > (Bits 0 and 1) — Specifies the privilege level of the selector. The privilege level can range from 0 to 3, with 0 being the most privileged level. See Section 5.5, “Privilege Levels”, for a description of the relationship of the RPL to the CPL of the executing program (or task) and the descriptor privilege level (DPL) of the descriptor the segment selector points to. > > bit2用来确定是什么表 > > (Bit 2) — Specifies the descriptor table to use: clearing this flag selects the GDT; setting this flag selects the current LDT. ### 总结 首先取线性地址, 查找GDT表项, 在取表项的基地址, 加上偏移, 没有分页机制的时候就是物理地址 ### 实际设置 初始化GDT表项, 之后进行一个远跳转, 加载CS寄存器 ![image 20231030220730961](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310302207028.png) > 这是进入保护模式的时候使用的那一个GDT表 ![image 20231030220811261](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310302208300.png) > 这是新的GDT表 ```c #define GDT_TABLE_SIZE 256 /************各个段*************/ //代码段 #define KERNEL_SELECTOR_CS (1 * 8) //数据段 #define KERNEL_SELECTOR_DS (2 * 8) /*************权限**************/ //开启4KB模式 #define SEG_G (1 << 15) //32位模式 #define SEG_D (1 << 14) //是否有效 #define SEG_P (1 << 7) //权限 #define SEG_DPL0 (0 << 5) #define SEG_DPL3 (3 << 5) //0的时候是系统段, TSS/LDT等, 1的时候表示这一段是数据段或者代码段 #define SEG_S_SYSTEM (0 << 4) #define SEG_S_NORMAL (1 << 4) //类型(可读可写) #define SEG_TYPE_CODE (1 << 3) #define SEG_TYPE_DATA (0 << 3) #define SEG_TYPE_RW (1 << 1) /************数据格式*************/ #define KERNEL_STACK_SIZE (8*1024) ``` > 头文件 ```c static segment_desc_t gdt_table_s[GDT_TABLE_SIZE]; //参数1选择表项, 基地址, 界限 void segment_desc_set (int selector, uint32_t base, uint32_t limit, uint16_t attr) { segment_desc_t * desc gdt_table_s + selector / sizeof(segment_desc_t); if(limit>0xfffff){ //这时候的界限是4KB的 limit/ 0x1000; attr SEG_G; } desc >limit15_0 limit & 0xffff; \tdesc >base15_0 base & 0xffff; \tdesc >base23_16 (base >> 16) & 0xff; \tdesc >attr attr (((limit >> 16) & 0xf) << 8); \tdesc >base31_24 (base >> 24) & 0xff; } //初始化一下GDT表 void init_gdt(void){ int i; for(i 0;i<GDT_TABLE_SIZE;i++){ segment_desc_set(i<<3, 0, 0, 0); } //设置代码段 segment_desc_set(KERNEL_SELECTOR_CS, 0, 0xffffffff, (SEG_P_PRESENT SEG_DPL_0 SEG_D SEG_S_NORMAL SEG_TYPE_CODE SEG_TYPE_RW)); //数据段 segment_desc_set(KERNEL_SELECTOR_DS, 0, 0xffffffff, (SEG_P_PRESENT SEG_DPL_0 SEG_D SEG_S_NORMAL SEG_TYPE_DATA SEG_TYPE_RW)); //重新加载 lgdt((uint32_t)gdt_table_s, sizeof(gdt_table_s)); } void cpu_init(void){ init_gdt(); } ``` ```assembly #include \"os_cfg.h\" .text .extern kernel_init .extern init_main .global _start # void start (boot_info_t *bootinfo) _start: \t... \t # 加载过gdt表以后需要一个远跳转 jmp $KERNEL_SELECTOR_CS, $gdt_reload gdt_reload: mov $KERNEL_SELECTOR_DS, %ax \tmov %ax, %ds \tmov %ax, %ss \tmov %ax, %es \tmov %ax, %fs \tmov %ax, %gs # 返回C函数 jmp init_main jmp . ``` > 这里使用的头文件里面不能有typedef之类的符号 ## 触发异常与异常简介 异常: 由于CPU内部的事件所引起的中断, 比如程序出错(非法指令, 地址越界, 除0等), 通常是由于执行了现行指令引起的 中断: 外部事件所引起的中断, 通常的有磁盘中断, 打印机中断, 通常与现行的指令无关 ![image 20231030223740916](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310302237977.png) ![image 20231030223755594](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310302237642.png) > 1. 除法错误（Divide Error）：当执行除法指令时，除数为0时触发。 > 2. 调试异常（Debug Exception）：用于调试目的，由调试器触发。 > 3. 非屏蔽中断（Non Maskable Interrupt）：由硬件触发，用于处理紧急情况。 > 4. 断点异常（Breakpoint Exception）：由调试器触发，用于在程序中设置断点。 > 5. 溢出（Overflow）：当执行有符号整数运算时，结果超出了所能表示的范围。 > 6. 边界检查（Bound Range Exceeded）：当执行BOUND指令时，索引超出了指定的边界。 > 7. 无效操作码（Invalid Opcode）：当执行无效的指令时触发。 > 8. 设备不可用（Device Not Available）：当执行浮点运算指令时，协处理器不可用。 > 9. 双重故障（Double Fault）：当处理器在处理异常时发生了另一个异常。 > 10. 协处理器段超限（Coprocessor Segment Overrun）：当协处理器访问超出了段界限时触发。 > 11. 无效TSS（Invalid TSS）：当任务状态段（TSS）的字段无效时触发。 > 12. 段不存在（Segment Not Present）：当访问一个不存在的段时触发。 > 13. 堆栈段错误（Stack Segment Fault）：当堆栈段无效或溢出时触发。 > 14. 通用保护错误（General Protection Fault）：当执行受保护的指令或访问受保护的内存时触发。 > 15. 页面错误（Page Fault）：当访问一个不存在的页面或无法访问的页面时触发。 > 16. 浮点异常（Floating Point Exception）：当执行浮点运算时发生异常。 > 17. 对齐检查（Alignment Check）：当执行对齐要求的指令时，操作数不满足对齐要求时触发。 > 18. 机器检查（Machine Check）：由硬件检测到的硬件错误触发。 > 19. SIMD浮点异常（SIMD Floating Point Exception）：当执行SIMD浮点运算时发生异常。 > 20. 虚拟化异常（Virtualization Exception）：当执行虚拟化指令时发生异常。 > 20. 一种异常，它在执行控制保护指令时触发。控制保护指令用于控制特权级别和访问权限，以保护系统资源和确保安全性。CPE的作用是提供一种机制，用于检测和处理控制保护指令的错误或违规操作。 使用一个数字除以0会产生一个异常, 这时候qemu由于在保护模式, 还没有配置中断系统, 中断处理出问题就会重启 ### 中断向量门 ![image 20240215185744216](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402151857333.png) 也是有一个寄存器指向(IDTR) ![image 20231030224609387](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310302246424.png) > IDTR寄存器的格式 ![image 20231030224830271](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310302248317.png) 有任务门, 中断门, 陷阱门 任务门：任务门主要用于任务切换，即从当前任务切换到另一个任务。当发生任务切换时，处理器会使用任务门中定义的任务段描述符加载新任务的上下文。(7.2.5 ) 任务门和TSS是协同工作的组件，任务门负责任务的切换，TSS存储任务的状态信息，两者结合在一起实现操作系统的多任务处理和任务调度。 中断门：中断门用于处理外部中断和硬件异常。当一个中断事件发生时，处理器会通过中断门中定义的中断或异常处理程序来响应并处理中断事件。 陷阱门：陷阱门类似于中断门，主要用于软件陷阱（软中断）的处理。当程序需要主动陷入内核态并执行某个特定任务时，可以通过陷阱门来触发相应的软中断处理程序 > Segment Selector 这里记录是段选择子, 指向GDT表的某一个段, 这里应该是代码段 > > Offset 偏移, 具体的处理函数所在的位置 > > D 表示是否是32位 > > P 存在的标志位 ```c //中断门 typedef struct _gate_desc_t { uint16_t offset15_0; uint16_t selector; uint16_t attr; uint16_t offset31_16; } gate_desc_t; /* * @brief 初始化一个GDT表的门表项(IDT表的中断描述符) * @param desc: 要设置的表项 * @param selector: 段选择子 * @param offset: 偏移 * @param attr: 属性 */ void gate_desc_set (gate_desc_t *desc, uint32_t selector, uint32_t offset, uint16_t attr){ desc >offset15_0 offset & 0xffff; desc >offset31_16 offset >> 16; desc >attr attr; desc >selector selector; } ``` ![image 20231030225110654](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310302251700.png) ### 实际设置 首先需要把段设置为之前保存的代码段的选择子, offset设置为偏移 ```c /************IDT表权限************/ //有效 #define GATE_P_PRESENT (1 << 15) //权限 #define GATE_DPL0 (0 << 13) #define GATE_DPL3 (3 << 13) //使用的是32位的中断门 #define GATE_TYPE_INT (0xe << 8) //IDT表 static gate_desc_t idt_table[IDT_TABLE_NR]; void irq_init(void){ for(int i 0;i<IDE_TABLE_NR;i++) { //设置所有的中断进入默认的处理函数 gate_desc_set(idt_table+i, KERNEL_SELECTOR_CS, (uint32_t)exception_handler_unknow, (GATE_P_PERSENT GATE_DPL0 GATE_TYPE_INT)); } //加载到内存里面 lidt((uint32_t)idt_table, sizeof(idt_table)); } ``` > 这一个处理的函数使用汇编的代码, 因为返回的时候使用iret > > ```assembly > # 默认的中断处理函数 > exception_handler_unknow: > iret > ``` ### 寄存器保护 ![image 20231101102620987](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311011026111.png) > 这两种分别是有没有特权级变换的时候保存到栈里面额寄存器, 其他的寄存器需要保护 ![image 20231101225740682](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311012257739.png) > 这是需要保护的寄存器 ```assembly # 默认的中断处理函数 exception_handler_unknow: pusha push %ds push %es push %fs push %gs call do_handler_unknown pop %gs pop %fs pop %es pop %ds popa iret ``` ### 解析异常栈信息 通过栈里面保存的EIP寄存器的数值可以获取到具体发生问题的位置 ![image 20231101230902900](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311012309949.png) ![image 20231101230931408](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311012309463.png) > 中断自动压入 > > + EFLAGS > + CS > + IP > + 错误码 > > pusha > > + EAX > + ECX > + EDX > + EBX > + 使用pusha之前的ESP > + EBP > + ESI > + EDI > > push手工压入的 > > + DS > + ES > + FS > + GS > > CALL指令压入的 > > + 返回地址 ![image 20231017143347597](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402141401915.png) C语言在进行参数传递的时候会把参数放在返回值前面, 这时候的这个函数可以理解为 ```c void do_handler_unknown(gs, fs, es, ds, edi, esi, ebp, esp, ebx, edx, ecx, ea, err, eip, cs, eflags) ``` 可以把上面的结构定义为一个结构体, 之后再call之间压入一个指针, 使用的时候直接使用那一个指针进行操控寄存器信息, 错误码暂时不处理 ```assembly //中断处理函数 exception_handler_unknow: pusha push %ds push %es push %fs push %gs # 传递参数 push %esp call do_handler_unknow add %(1*4), %esp pop %gs pop %fs pop %es pop %ds popa iret ``` ```c typedef struct _exception_frame_t { uint32_t gs, fs, es, ds; uint32_t edi, esi, ebp, esp, ebx, edx, ecx, eax; uint32_t eip, cs, eflags; }exception_frame_t; ``` ![image 20231102191656764](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311021916911.png) ### 使用宏定义重用中断处理函数 ```assembly //这是一个宏, 用来进行中断函数的重用,可以给出参数,名字,第几个,是否会传入错误码 .macro exception_handler name num with_err_code .text .extern do_handler_\\name .global exception_handler_\\name //中断处理函数 exception_handler_\\name: //传入一些参数(error_code, 序号) .if \\with_err_code 0 push 0 .endif push $\\num pusha push %ds push %es push %fs push %gs push %esp call do_handler_\\name //还原传入的数字 add $(1*4), %esp pop %gs pop %fs pop %es pop %ds popa //在弹出的时候由于不会处理errcode所以手动进行弹出 add $(2*4), %esp iret .endm exception_handler unknown, 1, 0 ``` ![image 20231102202340876](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311022023039.png) #### 添加一个中断处理函数 1. 汇编文件里面添加一个汇编处理 2. C语言里面添加到IDT表里面 3. 一个C语言的处理函数 ## 处理中断 ### 8259中断管理芯片 早期的x86使用8259控制器来管理中断, 由于一个支持8个中断所以使用两片, 现在被APIC代替了, 但是依旧可以使用这一种方法进行管理 在使用的时候需要自己设置一些寄存器, 早期x86使用的是两个8259芯片进行管理整个系统里面的中断 ![image 20231103222801814](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311032228969.png) ![image 20231103222817353](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311032228429.png) 对于寄存器的初始化的话需要对上述的master和slave进行初始化, master对应的端口起始地址为0x20, slave对应的端口起始地址是0xA0 #### 具体配置 ![image 20240216144449099](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402161444394.png) > 不考虑中断嵌套 > > + 主片: 边沿触发, 级联, 起始中断号为0x20, IRQ2上有从片, 普通全嵌套, 非缓冲, 非自动结束, 8086模式 >+ 从片: 边沿触发, 级联, 起始中断序号为0x28, 连接到主片IRQ2上, 普通全嵌套, 非缓冲, 非自动结束, 8086模式 ![image 20231103223710590](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311032237684.png) > 主要是D4和D0需要设置为1, 设置使用ICW4, SNGL设置为0是和其他的芯片连接 ![image 20231103224025749](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311032240820.png) > 这个主要是用来控制中断向量号的起始地址的 ![image 20231103225115276](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311032251437.png) > 这个是控制连接其他8259从片的时候的相关设置, 如果有的话对应位为1 ![image 20231103225255315](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311032252399.png) > 设置模式, 这里是设置0位为1 > 之后把中断屏蔽寄存器设置为屏蔽所有的中断 > 实际设置的时候是有两个端口, 使用第一个端口写入命令, 另一个端口写入实际的数据 ```c /****************中断控制器的端口******************/ #define PIC0_ICW1\t\t\t0x20 #define PIC0_ICW2\t\t\t0x21 #define PIC0_ICW3\t\t\t0x21 #define PIC0_ICW4\t\t\t0x21 #define PIC0_OCW2\t\t\t0x20 #define PIC0_IMR\t\t\t0x21 #define PIC1_ICW1\t\t\t0xa0 #define PIC1_ICW2\t\t\t0xa1 #define PIC1_ICW3\t\t\t0xa1 #define PIC1_ICW4\t\t\t0xa1 #define PIC1_OCW2\t\t\t0xa0 #define PIC1_IMR\t\t\t0xa1 #define PIC_ICW1_ICW4\t\t(1 << 0)\t\t// 1 需要初始化ICW4 #define PIC_ICW1_ALWAYS_1\t(1 << 4)\t\t// 总为1的位 #define PIC_ICW4_8086\t (1 << 0) // 8086工作模式 #define IRQ_PIC_START\t\t0x20\t\t\t// PIC中断起始号 //初始化中断处理函数 static void init_pic(void){ // 边缘触发，级联，需要配置icw4, 8086模式 outb(PIC0_ICW1, PIC_ICW1_ALWAYS_1 PIC_ICW1_ICW4); // 对应的中断号起始序号0x20 outb(PIC0_ICW2, IRQ_PIC_START); // 主片IRQ2有从片 outb(PIC0_ICW3, 1 << 2); // 普通全嵌套、非缓冲、非自动结束、8086模式 outb(PIC0_ICW4, PIC_ICW4_8086); // 边缘触发，级联，需要配置icw4, 8086模式 outb(PIC1_ICW1, PIC_ICW1_ICW4 PIC_ICW1_ALWAYS_1); // 起始中断序号，要加上8 outb(PIC1_ICW2, IRQ_PIC_START + 8); // 没有从片，连接到主片的IRQ2上 outb(PIC1_ICW3, 2); // 普通全嵌套、非缓冲、非自动结束、8086模式 outb(PIC1_ICW4, PIC_ICW4_8086); // 禁止所有中断, 允许从PIC1传来的中断 outb(PIC0_IMR, 0xFF & ~(1 << 2)); outb(PIC1_IMR, 0xFF); } ``` ### 中断开关 8259控制器的IMR寄存器可以单独控制某一个中断的开启或者关闭 之后就是EFLAGS寄存器的IF位可以控制全局中断, 设置为1的时候会打开所有的中断 ```c void irq_enable(int irq_num){ \tif(irq_num < IRQ_PIC_START irq_num > IRQ_PIC_START + 15){ \t\treturn; \t} \tirq_num IRQ_PIC_START; \tif(irq_num < 8){ \t\tuint8_t mask inb(PIC0_IMR) & ~(1<<irq_num); \t\toutb(PIC0_IMR, mask); \t}else{ \t\tirq_num 8; \t\tuint8_t mask inb(PIC1_IMR) & ~(1<<irq_num); \t\toutb(PIC0_IMR, mask); \t} } void irq_disable(int irq_num){ \tif(irq_num < IRQ_PIC_START irq_num > IRQ_PIC_START + 15){ \t\treturn; \t} \tirq_num IRQ_PIC_START; \tif(irq_num < 8){ \t\tuint8_t mask inb(PIC0_IMR) (1<<irq_num); \t\toutb(PIC0_IMR, mask); \t}else{ \t\tirq_num 8; \t\tuint8_t mask inb(PIC1_IMR) (1<<irq_num); \t\toutb(PIC0_IMR, mask); \t} } //全局中断开启以及关闭 void irq_disable_global (void){ \tcli(); } void irq_enable_global (void){ \tsti(); } ``` ### 定时器 早期使用的是8253芯片, 里面有三个定时器, 有一个1.193182MHz的时钟输入, 一个是操作系统定时IRQ0, 一个控制蜂鸣器, 还有一个作为其他用途 对这个芯片进行控制, 有一个控制端口一个数据端口 + 0x40 定时器0数据端口 + 0x41 定时器1数据端口 + 0x42 定时器2数据端口 + 0x43 模式和命令端口 ![image 20231107142812585](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311071428656.png) > 选择一个定时器 ![image 20240216155848387](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402161558470.png) > 模式 ![image 20231107142827511](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311071428576.png) > 选择计数的模式 ![image 20231107142839643](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311071428699.png) > 这个是写入0x43的控制命令 > > SC1,0: 选择定时器 > > MOOE: 选择工作的模式, 使用模式3 > > READ/LOAD: 加载的模式使用第三个 > > BDC: 是使用BCD还是16进制进行设置 > > > BCD码（Binary Coded Decimal‎），用4位二进制数来表示1位十进制中的0~9这10个数码，是一种二进制的数字编码形式，用二进制编码的十进制代码。 写入命令以后需要设置一个计数值, 根据设置上面为先加载低位, 之后加载高位的数据 ### 具体的实现 有一个初始化函数, 一个中断处理函数, 加载到IDT里面 ```c //系统时钟的计数 static uint32_t sys_tick; void do_handler_time(exception_frame_t *frame){ sys_tick ++ ; //清除标志位 pic_send_eoi(); } static void init_pic(void){ int32_t reload_count PIT_OSC_FREQ / (1000.0 / OS_TICKS_MS); //配置模式16位计数 outb(PIT_COMMEND_MODE_PORT, PIT_CHANNEL PIT_LOAD_LOHIPIT_MODE3); //写入计数值 outb(PIT_CHANNEL0_DATA_PORT, reload_count & 0xff); outb(PIT_CHANNEL0_DATA_PORT, (reload_count >> 8) & 0xff); //注册中断 irq_install(IRQ0_TIMER, (irq_handler_t)exception_handler_time); irq_enable(IRQ0_TIMER); } //初始化 void time_init(void){ sys_tick 0; init_pic(); } ``` 在中断里面的时候需要进行一次中断的清除 ```c //清除中断 void pic_send_eoi(int irq_num){ \tirq_num IRQ_PIC_START; \tif(irq_num> 8){ \t\toutb(PIC1_OCW2, PIC_OCW2_EOI); \t} \toutb(PIC0_OCW2, PIC_OCW2_EOI); } ``` ## 错误的处理 发生Page Fault的时候需要额外的处理从而获取更多的数据 ![image 20240220191054469](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402201910543.png) > The contents of the CR2 register. The processor loads the CR2 register with the 32 bit linear address that generated the exception. The page fault handler can use this address to locate the corresponding page directory and page table entries. Another page fault can potentially occur during execution of the page fault handler; the handler should save the contents of the CR2 register before a second page fault can occur.1 If a page fault is caused by a page level protection violation, the access flag in the page directory entry is set when the fault occurs. The behavior of IA 32 processors regarding the access flag in the corresponding page table entry is model specific and not architecturally defined. > > 使用CR2获取实际的位置 ### GP异常 这是一个重入的异常, 这一个异常的的原因是这一个模式在处理中断的时候是不可以重入的, 如果重入的话进入这一个中断 ![image 20240220191446921](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402201914954.png) ![image 20240220191427024](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402201914070.png)"},"/note/Linux/李述铜手写操作系统/2023-11-10-06日志与printf输出.html":{"title":"日志与printf输出","content":" layout: post title: \"日志与printf输出\" date: 2023 10 26 15:39:08 +0800 tags: 李述铜 # 日志与printf输出 ## 串口 使用C程序的时候, 应用会调用printf之后会调用操作系统的文件输出接口, 由操作系统进行输出, 现在需要我们自己进行实现 早期的时候计算机使用的是RS232串行接口 由于屏幕的控制需要一些设置, 但是使用串口的话控制起来就简单多了 ![image 20231110092255054](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311100922152.png) ![image 20231110195119492](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311101951544.png) ### 初始化 [Serial Ports OSDev Wiki](https://wiki.osdev.org/Serial_Ports) ![image 20231110201253314](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311102012338.png) ```c void log_init(void){ outb(COM1_PORT + 1, 0x00); // Disable all interrupts outb(COM1_PORT + 3, 0x80); // Enable DLAB (set baud rate divisor) outb(COM1_PORT + 0, 0x03); // Set divisor to 3 (lo byte) 38400 baud outb(COM1_PORT + 1, 0x00); // (hi byte) outb(COM1_PORT + 3, 0x03); // 8 bits, no parity, one stop bit outb(COM1_PORT + 2, 0xC7); // Enable FIFO, clear them, with 14 byte threshold // If serial is not faulty set it in normal operation mode // (not loopback with IRQs enabled and OUT#1 and OUT#2 bits enabled) outb(COM1_PORT + 4, 0x0F); } ``` > 初始化 ![image 20231110201320677](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311102013715.png) ![image 20231110201410367](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311102014392.png) ### 打印信息 ![image 20231110202242962](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311102022988.png) > 重定向到一个终端里面 ```c void log_printf(const char * fmt, ...){ const char *p fmt; while(*p ! '\\0') { while(inb(COM1_PORT+ 5) & (1<<6) 0); outb(COM1_PORT, *p++); } outb(COM1_PORT, '\\r'); outb(COM1_PORT, '\\n'); } ``` ### 格式化的输出 #### 字符串和内存管理函数 ```c //字符串的复制 void kernel_strcpy (char * dest, const char * src) { if (!dest !src) { return; } while (*dest && *src) { *dest++ *src++; } *dest '\\0'; } //字符串的复制 void kernel_strncpy(char * dest, const char * src, int size) { if (!dest !src !size) { return; } char * d dest; const char * s src; while ((size > 0) && (*s)) { *d++ *s++; } if (size 0) { *(d 1) '\\0'; } else { *d '\\0'; } } //计算字符串的长度 int kernel_strlen(const char * str) { if (str (const char *)0) { return 0; } \tconst char * c str; \tint len 0; \twhile (*c++) { \t\tlen++; \t} \treturn len; } //比较两个字符串, 只比较存在字符的位置 //\"abc\"和\"abcde\"是一样的 //一样的话返回0, 不一样返回1 int kernel_strncmp (const char * s1, const char * s2, int size) { if (!s1 !s2) { return 1; } // 2023 3 18 这里size没有用到 while (*s1 && *s2 && (*s1 *s2) && size) { \ts1++; \ts2++; \tsize ; } return !((*s1 '\\0') (*s2 '\\0') (*s1 *s2)); } //复制一块内存 void kernel_memcpy (void * dest, void * src, int size) { if (!dest !src !size) { return; } uint8_t * s (uint8_t *)src; uint8_t * d (uint8_t *)dest; while (size ) { *d++ *s++; } } //把一块内存里面全部设置为一个字符 void kernel_memset(void * dest, uint8_t v, int size) { if (!dest !size) { return; } uint8_t * d (uint8_t *)dest; while (size ) { *d++ v; } } //比较内存, 一样的话返回一个0, 不一样返回一个1 int kernel_memcmp (void * d1, void * d2, int size) { if (!d1 !d2) { return 1; } \tuint8_t * p_d1 (uint8_t *)d1; \tuint8_t * p_d2 (uint8_t *)d2; \twhile (size ) { \t\tif (*p_d1++ ! *p_d2++) { \t\t\treturn 1; \t\t} \t} \treturn 0; } ``` #### 可变参数 使用一个头文件stdarg.h ```c typedef char * va_list; // 把 n 圆整到 sizeof(int) 的倍数 #define _INTSIZEOF(n) ( (sizeof(n)+sizeof(int) 1) & ~(sizeof(int) 1) ) // 初始化 ap 指针，使其指向第一个可变参数。v 是变参列表的前一个参数 #define va_start(ap,v) ( ap (va_list)&v + _INTSIZEOF(v) ) // 该宏返回当前变参值,并使 ap 指向列表中的下个变参 #define va_arg(ap, type) ( *(type *)((ap + _INTSIZEOF(type)) _INTSIZEOF(type)) ) // /将指针 ap 置为无效，结束变参的获取 #define va_end(ap) ( ap (va_list)0 ) ``` > > [C语言可变参数详解_c语音 可变参数 CSDN博客](https://blog.csdn.net/longintchar/article/details/85490103) > > 在函数定义中创建一个 **va_list** 类型变量，该类型是在 stdarg.h 头文件中定义的。 > 使用 **int** 参数和 **va_start()** 宏来初始化 **va_list** 变量为一个参数列表。宏 **va_start()** 是在 stdarg.h 头文件中定义的。 > 使用 **va_arg()** 宏和 **va_list** 变量来访问参数列表中的每个项。 > 使用宏 **va_end()** 来清理赋予 **va_list** 变量的内存。 > > **va_start(ap, last_arg)**：初始化可变参数列表。`ap` 是一个 `va_list` 类型的变量，`last_arg` 是最后一个固定参数的名称（也就是可变参数列表之前的参数）。该宏将 `ap` 指向可变参数列表中的第一个参数。 > **va_arg(ap, type)**：获取可变参数列表中的下一个参数。`ap` 是一个 `va_list` 类型的变量，`type` 是下一个参数的类型。该宏返回类型为 `type` 的值，并将 `ap` 指向下一个参数。 > **va_end(ap)**：结束可变参数列表的访问。`ap` 是一个 `va_list` 类型的变量。该宏将 `ap` 置为 `NULL`。 > 实际是从栈里面依次获取下一个字符串的指针地址 ### 实际的实现 ```c //实际使用的打印函数 void log_printf(const char * fmt, ...){ char str_buf[128]; va_list args; //格式化处理 kernel_memset(str_buf, '\\0', sizeof(str_buf)); va_start(args, fmt); kernel_vsprintf(str_buf, fmt, args); va_end(args); const char *p str_buf; while(*p ! '\\0') { //等待串口忙标志 while((inb(COM1_PORT+ 5) & (1<<6)) 0); outb(COM1_PORT, *p++); } //自动换行 outb(COM1_PORT, '\\r'); outb(COM1_PORT, '\\n'); } ``` ```c //格式字符串的解析 void kernel_vsprintf(char * buf, const char *fmt, va_list args){ enum {NORMAL, READ_FMT} state NORMAL; char * curr buf; char ch; while((ch *fmt++)){ switch(state) { case NORMAL: if(ch '%') { //需要处理这一个格式字符 state READ_FMT; }else{ //普通字符直接复制 *curr++ ch; } break; case READ_FMT: if(ch 's') { const char * str va_arg(args, char *); int len kernel_strlen(str); while(len ){ *curr++ *str++; } }else if(ch 'd'){ //处理一下十进制 int num va_arg(args, int); kernel_itoa(curr, num, 10); //计算一下偏移 curr + kernel_strlen(curr); }else if(ch 'x'){ //处理一下十进制 int num va_arg(args, int); kernel_itoa(curr, num, 16); //计算一下偏移 curr + kernel_strlen(curr); }else if(ch 'c'){ //处理一下十进制 char c va_arg(args, int); //计算一下偏移 *curr++ c; } state NORMAL; break; } } *curr '\\0'; } ``` ```c //把一个数字转换为字符串, 只支持2, 8, 10, 16进制 void kernel_itoa(char*buf, int num, int base){ static const char *num2ch \"fedcba9876543210123456789abcdef\"; char *p buf; int old_num num; //看一看是不是支持的进制数 if((base ! 2)&&(base ! 16)&&(base ! 8)&&(base ! 10)){ *p '\\0'; return ; } //处理一下负数 int signed_num 0; if((num < 0) && (base 10)){ *p++ ' '; signed_num 1; } if(signed_num){ //除了十进制不支持负数 do{ *p++ num2ch[num % base + 15]; num / base; }while (num); }else{ uint32_t u_num num; do{ *p++ num2ch[u_num % base + 15]; u_num / base; }while (u_num); } *p '\\0'; char *start (old_num>0)? buf : buf+1; //把这一整个进行对调 while(start < p){ char ch *start; *start *p; *p ch; p , start++; } } ``` ### 使用这一个输出调试信息 ```c //显示中断里面的时候的寄存器信息 static void dump_core_meg(exception_frame_t *frame){ \tlog_printf(\"IRQ: %d, error code %d\", frame >errnum, frame >err_code); \tlog_printf(\"CS: %d\\tDS: %d\\tES: %d\\r\\nSS: %d\\tFS: %d\\tGS: %d\\r\\n\", \tframe >cs, frame >ds, frame >es, frame >ds, frame >fs, frame >gs); \tlog_printf(\"EAX: 0x%x\\t\" \t\t\"EBX: 0x%x\\t\" \t\t\"ECX: 0x%x\\r\\n\"\t\t \t\t\"EDX: 0x%x\\t\"\t \t\t\"EDI: 0x%x\\t\"\t \t\t\"ESI: 0x%x\\r\\n\"\t \t\t\"EBP: 0x%x\\t\"\t \t\t\"ESP: 0x%x\\t\"\t \t, frame >eax, frame >ebx, frame >ecx, frame >edx, frame >edi, frame >esi, \tframe >ebp, frame >esp); \tlog_printf(\"EIP: 0x%x\\tEFLAGS: %x\", frame >eip, frame >eflags); } //默认的中断处理函数 static void do_default_handler(exception_frame_t *frame, const int8_t * message){ \t//显示一下各项参数 \tlog_printf(\" \"); \tlog_printf(\"IRQ/Exception happend: %s\", message); \tdump_core_meg(frame); \tfor(;;) { \t\thlt(); \t} } ``` ![image 20240217135011278](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402171350306.png) > 还可以使用qemu的一个参数int > > ```bash > @REM 适用于windows > start qemu system i386 m 128M s S serial stdio drive file disk1.vhd,index 0,media disk,format raw drive file disk2.vhd,index 1,media disk,format raw d int,pcall,page,mmu,cpu_reset,guest_errors,page,trace:ps2_keyboard_set_translation > ``` > > ![image 20240217134908232](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402171349392.png) > > > 使用这一个的时候如果发生异常的次数比较多的时候会使得速度变慢, 以及信息杂乱等 ### 使用assert辅助调试 这里面的条件是成立的话继续执行, 否则退出 ```c #ifndef RELEASE #define ASSERT(expr) \\ if(!(expr)) pannic(__FILE__, __LINE__, __func__, #expr); void pannic(const char *file, int line, const char *func, const char *cond); #else #define ASSERT(expr) ((void) 0) #endif void pannic(const char *file, int line, const char *func, const char *cond){ log_printf(\"assert failed! %s\", cond); log_printf(\"file: %s line %d func: %s\", file, line, func); for(;;){ hlt(); } } ``` > 可以使用 D RELEASE添加宏定义"},"/note/Linux/李述铜手写操作系统/2024-3-1-设备管理.html":{"title":"设备管理","content":" layout: post title: \"设备管理\" date: 2024 2 29 15:39:08 +0800 tags: 李述铜 # 设备管理 操作系统里面可能有很多不同的设备, 操作系统进行抽象以后形成一个设备管理层 ![image 20240301085148158](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403010851210.png) ## tty设备 tty: 电传打字机的缩写 [Linux 黑话解释：TTY 是什么？ Linux 中国 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/447014333) 键盘是一个只读的设备, 屏幕是一个只写的设备, 把这两种结合为一个tty设备 有两种模式 + raw模式: 输入输出不做处理 + cooked模式: 做一些处理, 然后输出 ### 实际的使用 任务使用tty的时候 open() >系统调用 >sys_open >dev_open 1. 调用文件系统 2. 文件系统调用dev系统 3. dev系统调用实际的驱动 由于C库里面会使用stdin, stdout, stderr为012文件描述符, 所以可以把这几个文件全部重定向到tty"},"/note/Linux/李述铜手写操作系统/2023-9-28-04加载器loader的实现.html":{"title":"加载器loader的实现","content":" layout: post title: \"加载器loader的实现\" date: 2023 9 28 15:39:08 +0800 tags: 李述铜 # 加载器loader的实现 ## 实现一个内敛汇编的显示 ```c static void show_msg(const char * msg) { char c; while((c *msg++) ! '\\0') { asm( \t \"mov $0xe, %%ah\\n\\t\" \t \"mov %[ch], %%al\\n\\t\" \t \"int $0x10\"::[ch]\"r\"(c) ); \t } } static void show_msg(const char *msg){ char c; while((c *msg++) ! '\\0'){ __asm__ __volatile__( \"int $0x10\" : :\"a\"(0x0E00 c) ); } } ``` > 具体的写法参照补充知识2 ## 获取内存信息 在这1M的内存里面实际上不是所有的内存都是可以使用的 ![Screenshot_20230923_103210_com.xiaoe.client (1)](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402121700791.png) [Detecting Memory (x86) OSDev Wiki](https://wiki.osdev.org/Detecting_Memory_(x86)) 这篇文章有详细介绍个汇总内存检测方式 For the first call to the function, point ES:DI at the destination buffer for the list. Clear EBX. Set EDX to the magic number 0x534D4150. Set EAX to 0xE820 (note that the upper 16 bits of EAX should be set to 0). Set ECX to 24. Do an INT 0x15. > 清除EBX, EDX为0x534D4150, EAX为0xE820, ECX为24, 使用INT 15 If the first call to the function is successful, EAX will be set to 0x534D4150, and the Carry flag will be clear. EBX will be set to some non zero value, which must be preserved for the next call to the function. CL will contain the number of bytes actually stored at ES:DI (probably 20). > 检测一下EAX是不是0x534D4150, CF标志为0, EBX的值为下一次使用的值, CL是实际的读取到的字节个数 For the subsequent calls to the function: increment DI by your list entry size, reset EAX to 0xE820, and ECX to 24. When you reach the end of the list, EBX may reset to 0. If you call the function again with EBX 0, the list will start over. If EBX does not reset to 0, the function will return with Carry set when you try to access the entry after the last valid entry. > DI的数值需要加上size, EAX设置为0xE820, ECX to 24 > > 到达最后的时候EBX设置为0, 再次调用的时候重新开始 > 调用的时候按照上面进行设置, 会把内容保存在ES:DI的地址里面, 之后再次调用知道EBX 0表示读取完成 > > First uint64_t Base address > > Second uint64_t Length of \"region\" (if this value is 0, ignore the entry) > > Next uint32_t Region \"type\" > Type 1: Usable (normal) RAM 没有使用的 > Type 2: Reserved unusable 不可以使用的 > Type 3: ACPI reclaimable memory > Type 4: ACPI NVS memory > Type 5: Area containing bad memory > > Next uint32_t ACPI 3.0 Extended Attributes bitfield (if 24 bytes are returned, instead of 20) > Bit 0 of the Extended Attributes indicates if the entire entry should be ignored (if the bit is clear). This is going to be a huge compatibility problem because most current OSs won't read this bit and won't ignore the entry. > Bit 1 of the Extended Attributes indicates if the entry is non volatile (if the bit is set) or not. The standard states that \"Memory reported as non volatile may require characterization to determine its suitability for use as conventional RAM.\" > The remaining 30 bits of the Extended Attributes are currently undefined. > > ```c > // 内存检测信息结构 > typedef struct SMAP_entry { > uint32_t BaseL; // base address uint64_t > uint32_t BaseH; > uint32_t LengthL; // length uint64_t > uint32_t LengthH; > uint32_t Type; // entry Type > uint32_t ACPI; // extended > }__attribute__((packed)) SMAP_entry_t; > ``` ### 实际的获取 ```c #define BOTT_RAM_REGION_MAX 10 typedef struct _boot_info_t{ struct { uint32_t start; uint32_t size; }ram_region_cfg[BOTT_RAM_REGION_MAX]; //实际有效的数目 int32_t ram_region_count; }boot_info_t; ``` > 使用这一个记录获取到的信息 ```c static void detect_memory(void){ uint32_t contID 0;//记录下一次需要的数据 SMAP_entry_t smap_entry; int signature, bytes; show_msg(\"try to detect memory: \\n\"); boot_info.ram_region_count 0; \tfor (int i 0; i < BOOT_RAM_REGION_MAX; i++) { \t\tSMAP_entry_t * entry &smap_entry; \t\t__asm__ __volatile__(\"int $0x15\" \t\t\t: \" a\"(signature), \" c\"(bytes), \" b\"(contID) \t\t\t: \"a\"(0xE820), \"b\"(contID), \"c\"(24), \"d\"(0x534D4150), \"D\"(entry)); \t\tif (signature ! 0x534D4150) { show_msg(\"failed.\\r\\n\"); \t\t\treturn; \t\t} \t\t// todo: 20字节 \t\tif (bytes > 20 && (entry >ACPI & 0x0001) 0){ \t\t\tcontinue;//这一个是1的时候需要被忽略 \t\t} // 保存RAM信息，只取32位，空间有限无需考虑更大容量的情况 if (entry >Type 1) { boot_info.ram_region_cfg[boot_info.ram_region_count].start entry >BaseL; boot_info.ram_region_cfg[boot_info.ram_region_count].size entry >LengthL; boot_info.ram_region_count++; } \t\tif (contID 0) { \t\t\tbreak; \t\t} \t} show_msg(\"ok.\\r\\n\"); } ``` ![image 20240212175213763](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402121752794.png) > ![image 20240212175456895](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402121754928.png) > > ![image 20240212175531172](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402121755207.png) ## 进入保护模式 ![image 20240212175817724](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402121758772.png) > 主要有四种模式, 实模式, 保护模式, 虚拟8086模式, AI32模式, 这里主要使用的模式是实模式和保护模式 > > 虚拟8086模式是用于调试16为程序的 > > AI32模式是64位的 只有在实模式才能使用BIOS, 进入保护模式之后扩大寄存器的范围 ### 实际的实现 + 切换的流程 关闭中断 > 打开A20地址线 > 加载GDT表 > 设置CR0使能保护模式 > 远跳转, 清空流水线 远跳转会清空流水线, 清空掉16位的流水线(经一个指令的执行分开为好几部分) > 这时候对常见的汇编应用进行封装, 在头文件中使用关键字static inline, 因为inline只是建议使用内联函数, 不一定会执行, 如果函数被当做正常的函数运行, static会使得函数不会被重复包含 + 打开A20 > 这一个不是必须打开的, 不打开的话可以使用的地址A20只为0, 也就是说访问的地址是1M为间隔的不连续的 但这种方式引起了新的问题，通过上述分段模式，能够表示的最大内存为：FFFFh:FFFFh FFFF0h+FFFFh 10FFEFh 1M+64K 16Bytes（1M多余出来的部分被称做高端内存区HMA）。但8086/8088只有20位地址线，如果访问100000h~10FFEFh之间的内存，则必须有第21根地址线。所以当程序员给出超过1M（100000H 10FFEFH）的地址时，系统并不认为其访问越界而产生异常，而是自动从重新0开始计算，也就是说系统计算实际地址的时候是按照对1M求模的方式进行的，这种技术被称为wrap around。 到了80286，系统的地址总线发展为24根，这样能够访问的内存可以达到2^24 16M。Intel在设计80286时提出的目标是，在实模式下，系统所表现的行为应该和8086/8088所表现的完全一样，也就是说，在实模式下，80286以及后续系列，应该和8086/8088完全兼容。但最终，80286芯片却存在一个BUG：如果程序员访问100000H 10FFEFH之间的内存，系统将实际访问这块内存，而不是象过去一样重新从0开始。 > 原文链接：https://blog.csdn.net/ruyanhai/article/details/7181842 [A20 Line OSDev Wiki](https://wiki.osdev.org/A20#Fast_A20_Gate) ```assembly in al, 0x92 or al, 2 out 0x92, al ``` On most newer computers starting with the IBM PS/2, the chipset has a FAST A20 option that can quickly enable the A20 line. To enable A20 this way, there is no need for delay loops or polling, just 3 simple instructions. + 设置GDT表 使用lgdt命令, 设置GDT表的大小以及位置 + 进入保护模式 设置CR0的最低位为1 + 进行远跳转 ```c //远跳转 static inline void far_jump(uint32_t selector, uint32_t offset) { \tuint32_t addr[] {offset, selector }; \t__asm__ __volatile__(\"ljmpl *(%[a])\"::[a]\"r\"(addr)); } ``` > 这段代码是一个使用汇编指令`ljmpl`进行远跳转的函数。`ljmpl`是x86架构中的一条汇编指令，用于在实模式和保护模式之间进行跳转。 > > 函数`far_jump`接受两个参数：`selector`和`offset`，分别表示目标代码段的选择子和偏移量。 ```c //进入保护模式 static void enter_protect_mode(void){ //关中断 cli(); uint8_t v inb(0x92); outb(0x92, v 0x2); lgdt((uint32_t)gdt_table, sizeof(gdt_table)); //修改控制寄存器 uint32_t cr0 read_cr0(); write_cr0(cr0 (1<<0)); far_jump(8, (uint32_t) protect_mode_entry); //sti(); } ``` ![image 20231015125808816](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402151317301.png) + 修改其他的寄存器, 之后跳转到32位的C语言程序 ```assembly protect_mode_entry: \t// 重新加载所有的数据段描述符 \tmov $16, %ax\t\t// 16为数据段选择子 \tmov %ax, %ds mov %ax, %ss mov %ax, %es mov %ax, %fs mov %ax, %gs \tjmp $8, $load_kernel ``` ## 进一步读取磁盘 [ATA PIO Mode OSDev Wiki](https://wiki.osdev.org/ATA_PIO_Mode) 这时候由于不能使用BIOS, 所以需要用到LBA模式 这个模式将所有的扇区当做是线性排列的, 没有磁盘柱头等模式, 访问起来更加简单 访问使用的序列 ### 设置读取模式 ![image 20250311155220796](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202503111552944.png) ![image 20231015131611883](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402141246164.png) > 主要是bit4驱动器号(使用主盘的时候使用0), 以及使用LBA模式, 这里设置为0xE0 ### 读取的扇区的个数 ![image 20231015131554050](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402141245144.png) ```c //sector开始的扇区, sector_count扇区的个数 outb(0x1F6, (uint8_t) (0xE0)); //选则硬盘, 主盘或者从盘, 设置为LBA模式进行读取 //一次记录一下各个位的值 outb(0x1F2, (uint8_t) (sector_count >> 8)); outb(0x1F3, (uint8_t) (sector >> 24));\t\t// LBA4参数的24~31位 outb(0x1F4, (uint8_t) (0));\t\t\t\t\t// LBA5参数的32~39位 这里这个程序只使用了32位 outb(0x1F5, (uint8_t) (0));\t\t\t\t\t// LBA6参数的40~47位 outb(0x1F2, (uint8_t) (sector_count)); outb(0x1F3, (uint8_t) (sector));\t\t\t// LBA1参数的0~7位 outb(0x1F4, (uint8_t) (sector >> 8));\t\t// LBA2参数的8~15位 outb(0x1F5, (uint8_t) (sector >> 16));\t\t// LBA3参数的16~23位 outb(0x1F7, (uint8_t) 0x24); ``` > (Notes: A sector count of 0 means 65536 sectors 32MB. Try not to send bytes to the same IO port twice in a row. Doing so is **much** slower than doing two outb() commands to **different** IO ports. The important thing is that the high byte of the sector count, features and LBA bytes 4, 5, & 6 go to their respective ports **before the low bytes**.) > > 使用一个16位的数字保存读取的扇区的个数, 一共可以用65535块, 32Mde大小 > > Assume you have a sectorcount uint16_t and a 6 byte LBA value. Mentally number the LBA bytes as 1 to 6, from low to high. Send the 2 byte sector count to port 0x1F2 (high byte first), and the six LBA byte pairs to ports 0x1F3 through 0x1F5 in some appropriate order. > > 使用16位的扇区个数以及48位的扇区起始位置, 按照这个顺序发送 > > 这是一个48位的扇区号以及读取的大小 > > ```c > An example: > > Send 0x40 for the \"master\" or 0x50 for the \"slave\" to port 0x1F6: outb(0x1F6, 0x40 (slavebit << 4)) > outb (0x1F2, sectorcount high byte) > outb (0x1F3, LBA4) > outb (0x1F4, LBA5) > outb (0x1F5, LBA6) > outb (0x1F2, sectorcount low byte) > outb (0x1F3, LBA1) > outb (0x1F4, LBA2) > outb (0x1F5, LBA3) > Send the \"READ SECTORS EXT\" command (0x24) to port 0x1F7: outb(0x1F7, 0x24) > ``` > > To use the IDENTIFY command, select a target drive by sending 0xA0 for the master drive, or 0xB0 for the slave, to the \"drive select\" IO port. On the Primary bus, this would be port 0x1F6. Then set the Sectorcount, LBAlo, LBAmid, and LBAhi IO ports to 0 (port 0x1F2 to 0x1F5). Then send the IDENTIFY command (0xEC) to the Command IO port (0x1F7). Then read the Status port (0x1F7) again. If the value read is 0, the drive does not exist. For any other value: poll the Status port (0x1F7) **until bit 7 (BSY, value 0x80)** clears. Because of some ATAPI drives that do not follow spec, at this point you need to check the LBAmid and LBAhi ports (0x1F4 and 0x1F5) to see if they are non zero. If so, the drive is not ATA, and you should stop polling. Otherwise, continue polling one of the Status ports until bit 3 (DRQ, value 8) sets, or until bit 0 (ERR, value 1) sets. ### 检测状态 ![image 20231015131621187](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402141246477.png) > 之后读取0x1f7, 对忙标志位进行判断 > > At that point, if ERR is clear, the data is ready to read from the Data port (0x1F0). Read 256 16 bit values, and store them. > > 进行读取 ### 实际的实现 ```c //进行磁盘的读取 static void read_disk(int sector, int sector_count, uint8_t *buf) { //设置为主驱动器, 同时使用LBA模式进行读取 outb(0x1f6, 0xe0); //读取的字节数高字节 outb(0x1f2, (uint8_t)(sector_count >> 8)); //读取的扇区的地址4, 5, 6字节, 这里只使用32位的扇区地址 outb(0x1f3, (uint8_t)(sector >> 24)); outb(0x1f4, (uint8_t)(0)); outb(0x1f5, (uint8_t)(0)); //读取的字节数低字节 outb(0x1f2, (uint8_t)sector_count); //读取的扇区的地址1, 2, 3字节 outb(0x1f3, (uint8_t)(sector)); outb(0x1f4, (uint8_t)(sector >> 8)); outb(0x1f5, (uint8_t)(sector >> 16)); //读取 outb(0x1f7, 0x24); //检查状态寄存器 uint16_t * data_buf (uint16_t *)buf; while(sector_count ) { //等待忙标志位结束 while ((inb(0x1f7) & 0x88 ! 0x8)){}//数据没有就绪, 进行等待 for(int i 0;i<SECTOR_SIZE/2; i++) { //一次两字节, 读取256次 *data_buf++ inw(0x1f0); } } } void load_kernel(void) { //进行读取 read_disk(100, 500, (uint8_t)(SYS_KERNEL_LOAD_ADDR)); for(;;) { } } ``` > 这时候假设把内核的代码放在磁盘的100个扇区的位置, 之后读取500个扇区的数据, 放在1M字节的位置 ## 测试 ### 添加一段内核代码 ```c project(kernel LANGUAGES C) # 使用自定义的链接器 set(CMAKE_EXE_LINKER_FLAGS \" m elf_i386 Ttext 0x100000\") set(CMAKE_C_LINK_EXECUTABLE \"${LINKER_TOOL} <OBJECTS> ${CMAKE_EXE_LINKER_FLAGS} o ${PROJECT_BINARY_DIR}/${PROJECT_NAME}.elf\") # 将所有的汇编、C文件加入工程 # 注意保证start.asm在最前头，这样对应的程序会放在bin文件开头，从而在加载到0x7c00时能在开头处 file(GLOB_RECURSE C_LIST \"*.c\" \"*.h\") add_executable(${PROJECT_NAME} init/start.S ${C_LIST}) # bin文件生成，写入到image目录下 add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD COMMAND ${OBJCOPY_TOOL} O binary ${PROJECT_NAME}.elf ${CMAKE_SOURCE_DIR}/../../image/${PROJECT_NAME}.bin COMMAND ${OBJDUMP_TOOL} x d S m i386 ${PROJECT_BINARY_DIR}/${PROJECT_NAME}.elf > ${PROJECT_NAME}_dis.txt COMMAND ${READELF_TOOL} a ${PROJECT_BINARY_DIR}/${PROJECT_NAME}.elf > ${PROJECT_NAME}_elf.txt ) ``` > 改变一下链接的位置, 以及反汇编的时候使用32位的模式, 以及遍历文件的时候使用递归的方式 ```bash dd if kernel.elf of %DISK1_NAME% bs 512 conv notrunc seek 100 ``` > 写入脚本加这一行 Gcc 编译出来的是ELF文件。通常gcc –o test test.c,生成的test文件就是ELF格式的，在linuxshell下输入 ./test就可以执行。 Bin 文件是经过压缩的可执行文件，去掉ELF格式的东西。是直接的内存映像的表示。在系统没有加载操作系统的时候可以执行。 elf（executable and link format）文件里面包含了符号表，汇编等。 BIN文件是将elf文件中的代码段，数据段，还有一些自定义的段抽取出来做成的一个内存的镜像。 > 添加修改CMake文件, 之后修改脚本文件, 将对应的文件写到镜像对应的位置 ## 向内核传递信息 之前获取的内存信息需要进行传递 + 方式一 约定一个地址, 之后从这个地址进行读取, 但是内存规划一旦改变就会出现问题 + 方式二 作为一个函数的参数进行传递, 使用栈进行传递信息 ![image 20231016181026938](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402151317302.png) > 在x86架构中，`ebp`寄存器（Base Pointer Register）通常用作栈帧指针。它的主要作用包括： > > 1. **栈帧管理**：在函数调用过程中，`ebp`常被用来标记当前函数栈帧的基址。函数开始时，通常会将旧的`ebp`值压入栈中，然后将`ebp`设置为当前栈指针`esp`的值，从而建立新的栈帧。 > 2. **访问局部变量和函数参数**：通过`ebp`，可以方便地访问函数的局部变量和传递给函数的参数。局部变量通常位于`ebp`的负偏移处，而函数参数则位于`ebp`的正偏移处。 > 3. **调试和堆栈回溯**：由于`ebp`链记录了函数调用的嵌套关系，在调试程序或进行堆栈回溯时非常有用。 ![image 20231017143347597](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402141401915.png) ```c ((void (*) (boot_info_t *))SYS_KERNEL_LOAD_ADDR)(&boot_info); ``` > 改变指针, 传递一个参数给内核 > > ![image 20240214141403517](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402141414594.png) ### 实际使用 ```c ((void (*)(boot_info_t *))SYS_KERNEL_LOAD_ADDR)(&boot_info); ``` ```assembly .text .extern kernel_init .global _start # void start (boot_info_t *bootinfo) _start: # push %ebp # mov %esp, %ebp # 获取参数 # mov 0x8(%ebp), %eax # 也可以使用这一个, 不返回不需要保存参数 mov 4(%esp), %eax # 传递参数 push %eax call kernel_init jmp . ``` > 不需要返回, 所以不保存现场 ## 深入了解链接 ![image 20231017145727209](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402151317303.png) > 在这一点设置的是连接的地址 ![image 20231020215210952](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402151317304.png) ![image 20231020215130304](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402151317305.png) > 编译器默认使用四个段对数据进行存放, .text放置代码, .rodata字符串以及常量等这一些是不允许修改的, .data保存全局变量已经初始化的代码以及函数内部的初始化为static, .bss变量没有初始化的全局变量(或者初始化为0的变量), stack存储的是局部变量 > > 目标文件链接的时候同类型的值会进行合并 ### 链接文件 需要创建一个配置文件, 这一个文件的结尾是.lds ![image 20231020221354878](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402151317306.png) ![image 20240215131715014](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402151317049.png) > 把之前的设置改为选择使用的链接文件 [Using LD, the GNU linker Command Language](https://ftp.gnu.org/old gnu/Manuals/ld 2.9.1/html_chapter/ld_3.html) [Linker Scripts OSDev Wiki](https://wiki.osdev.org/Linker_Scripts) [6. Linker (bravegnu.org)](http://www.bravegnu.org/gnu eprog/linker.html) [Top (LD) (sourceware.org)](https://sourceware.org/binutils/docs/ld/) ![image 20240215130744013](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402151307117.png) ```json SECTIONS { . 0x100000; .test : { *(.text) } .rodata : { *(.rodata) } .data : { *(.data) } .bss : { *(.bss) } } ``` > 在这里可以设置文件的位置, 以及各个数据段的数据的位置前后, *是通配符, 这里是把所有的相同的段放在一起 ## 加载ELF内核映像文件 ### 使用ELF文件的原因 ![image 20231020223202664](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402151317307.png) > 在这里把文件转化为二进制文件格式, 这里面没有其他的附加的信息, 但是把文件名改为elf结尾, 实际上是bin文件 > > ``` > SECTIONS { > . 0x100000; > .text : { > *(.text) > } > .rodata : { > *(.rodata) > } > . 0x200000; > .data : { > *.(data) > } > .bss : { > *.(bss) > } > } > ``` > > 链接文件的时候有一大块的空白区域 > > ![image 20240215132859178](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402151328210.png) > > > 转换前elf文件的大小 > > ![image 20240215133156701](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402151331730.png) > > > 转换后bin文件的大小(这一个后缀不对) > > 这样会有一个问题, 当把文件的数据段代码段分开存放, 通过链接脚本进行更改, 这时候两段数据之间的数据就也会初始化为0之后被保存在elf文件中, 会导致elf文件变大, 加载的时候还会修改中间的文件, 并且不容易设置文件的权限, 因为没有记录段配置的信息, 这时候就需要使用elf文件了, 相当于exe文件 > > 而且内核加载这一种文件的时候只能全部进行加载, 如果没有使用的内存位置有数据的话会被覆盖, 并且不利于权限的处理(不知道各个段的位置) ### elf文件 ELF文件用于存放二进制文件, 可执行文件, 目标代码, 共享库和核心转储存文件的文件格式 主要有三个字段 > An ELF header resides at the beginning and holds a ‘‘road map’’ describing the file’s organization. Sections hold the bulk of object file information for the linking view: instructions, data, symbol table, relocation information, and so on. Descriptions of special sections appear later in Part 1. Part 2 discusses segments and the program execution view of the file > > A program header table, if present, tells the system how to create a process image. Files used to build a process image (execute a program) must have a program header table; relocatable files do not need one. A section header table contains information describing the file’s sections. Every section has an entry in the table; each entry gives information such as the section name, the section size, etc. Files used during linking must have a section header table; other object files may or may not have one 大致的意思是有一个文件头记录一些基础信息, program header table记录生成一个可执行文件的时候需要的信息, section header table记录的是各个段的信息, 一般用于链接文件的时候使用, 其他的文件可能没有 ![image 20231020224403287](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402151317309.png) > 左边是给链接器使用的, 我们只需要关心右侧的数据 #### 文件头 ELF格式, 有一个文件头, 相当于一个结构体 ![image 20231020224452753](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402151317310.png) 头部里面保存有指针, 指向一个表, 表里面有需要加载的数据的位置等信息 ![image 20231020224851539](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402151317311.png) > p_offset文件记录的是这一块内容在elf文件里面的偏移, 将数据加载到对应的指定的位置p_addr, 大小是p_filesz #### 文件加载用的表 ![image 20240215144828523](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402151448561.png) > p_offset记录实际加载的时候的信息相对ELF的偏移位置(原地址) > > p_paddr: 实际加载的位置(目标地址) > > p_filesz: 文件的大小 > > p_memsz: 加上需要清零的bss段的大小 ### 实际的实现(格式) ![image 20231020225133496](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402151317312.png) > 把这一个生成为二进制的参数删去, 可以加上参数 S把调试使用的代码进行删去 这个时候就不能直接进行跳转然后进行执行了, 所以设置为在解析之后把数据放到64K的位置, 然后进行运行 主要是修改链文件把数据放到0x10000的位置, 之后就是获取函数跳转的地址, 在1M地址的数据是暂时加载到的位置 ![image 20231020230307421](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402151317313.png) > ELF数据手册的文件里面有各种数据大小的描述 > > 为了不让编译器进行字节对齐, 添加一行指令`#pragma pack(1)` > > 这一个指令会让结构体里面的对齐方式是所有的项是相连的 ```c /** * ELF相关头文件及配置 * * 作者：李述铜 * 联系邮箱: 527676163@qq.com */ #ifndef OS_ELF_H #define OS_ELF_H #include \"types.h\" // ELF相关数据类型 typedef uint32_t Elf32_Addr; typedef uint16_t Elf32_Half; typedef uint32_t Elf32_Off; typedef uint32_t Elf32_Sword; typedef uint32_t Elf32_Word; #pragma pack(1) // ELF Header #define EI_NIDENT 16 #define ELF_MAGIC 0x7F //这一个是ELF的文件头部的数据结构, 在文件的开头, 从这里可以获取文件的各个段的位置以及其他信息 typedef struct { char e_ident[EI_NIDENT];\t//一些标志位, 是一个字符串 Elf32_Half e_type;\t\t\t//文件的类型 Elf32_Half e_machine; \t //使用的机器的类型 Elf32_Word e_version;\t\t//文件的版本号 Elf32_Addr e_entry;\t\t\t//虚拟地址, 实际程序需要跳转的位置(可执行入口地址) Elf32_Off e_phoff;\t\t\t//这一点是文件的第一段的数据表的位置, 虚拟地址 Elf32_Off e_shoff;\t\t\t//这一个是段表记录的偏移 Elf32_Word e_flags; Elf32_Half e_ehsize;\t\t//记录一下ELF头的大小 Elf32_Half e_phentsize;\t\t//单个段表的大小 Elf32_Half e_phnum;\t\t\t//表的数量 Elf32_Half e_shentsize;\t\t//记录段表的信息 Elf32_Half e_shnum; Elf32_Half e_shstrndx; }Elf32_Ehdr; #define PT_LOAD 1 typedef struct { Elf32_Word p_type; Elf32_Off p_offset;\t\t//偏移位置 Elf32_Addr p_vaddr;\t\t//虚拟地址用于使用虚拟地址的操作系统 Elf32_Addr p_paddr;\t\t//要加载的地址(物理地址) Elf32_Word p_filesz;\t//记录文件需要拷贝的大小 Elf32_Word p_memsz;\t\t//记录全部的大小(bss段未初始化的全局变量也加上了, 需要清零) Elf32_Word p_flags;\t\t//记录了可不可以加载的信息, 是PT_LOAD的时候是可以加载的 Elf32_Word p_align; } Elf32_Phdr; #pragma pack() #endif //OS_ELF_H ``` > ![image 20240215145406347](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402151454442.png) > > PT_LOAD The array element specifies a loadable segment, described by p_filesz and p_memsz. The bytes from the file are mapped to the beginning of the memory segment. If the segment’s memory size (p_memsz) is larger than the file size (p_filesz), the ‘‘extra’’ bytes are defined to hold the value 0 and to follow the segment’s initialized area. The file size may not be larger than the memory size. Loadable segment entries in the program header table appear in ascending order, sorted on the p_vaddr member ### 实际的处理 #### 检测是不是elf文件 ![image 20231020232315988](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402151317314.png) > 读取前几个字节进行比较, 看一看是不是elf文件 #### 获取数据以及进行转移 从e_phoff段里面获取Program header Table的位置 之后获取数据具体位置进行拷贝, bss段由于没有初始化所以不需要进行拷贝, 只需要初始化为0, 判断p_filesz和p_memsz的大小, p_memsz p_filesz + 清零的区域 ```c //加载elf文件, 同时返回需要跳转的文件的地址 static uint32_t reload_elf_file(uint8_t * file_buffer){ Elf32_Ehdr *elf_hdr (Elf32_Ehdr *)file_buffer; //检测文件类型 if((elf_hdr >e_ident[0] ! 0x7f) (elf_hdr >e_ident[1] ! 'E') (elf_hdr >e_ident[2] ! 'L') (elf_hdr >e_ident[3] ! 'F')){ return 0; } for(int i 0;i<elf_hdr >e_phnum;i++) { //获取第i个表的位置 Elf32_Phdr *phdr (Elf32_Phdr *)(file_buffer + elf_hdr >e_phoff) + i; if(phdr >p_type ! PT_LOAD){ //内容不能加载 continue; } //获取源文件地址以及需要加载的位置 uint8_t *src file_buffer + phdr >p_offset; uint8_t *dest (uint8_t *)phdr >p_paddr; for(int j 0; j < phdr >p_filesz;j++) //进行文件的复制 { *dest++ *src++; } //计算结束地址, 对bss区域进行清零 dest (uint8_t *)phdr >p_paddr + phdr >p_filesz; for(int j 0;j<phdr >p_memsz phdr >p_filesz;j++) { *dest++ 0; } } //返回进入的地址 return elf_hdr >e_entry; } ``` ![image 20231020235804103](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402151317315.png) ![image 20231020235733770](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402151317316.png)"},"/note/Linux/李述铜手写操作系统/2023-9-23-03引导程序接管控制权.html":{"title":"引导程序:接管控制权","content":" layout: post title: \"引导程序:接管控制权\" date: 2023 9 23 15:39:08 +0800 tags: 李述铜 # 引导程序:接管控制权 首先工作在16位实模式, 分页机制保护模式被禁止, 只可以使用1MB的内存, 之后会跳转到BIOS, 入口地址是0xffff:0x0000, BIOS这时候会进行自检, 检查硬盘,显卡,内存等,并保存一些参数,之后会加载引导程序到内存中, 运行引导代码, 之后按照引导代码进入操作系统 首先BIOS会加载磁盘的第一个扇区 > 实模式: 16位代码, 1M内存的开发, 没有保护模式, 用来兼容 **引导程序: ** + 硬件检测: 检测内存容量, 检测硬盘的数量 + 进入保护模式: 16位实模式到32位保护模式, 实现4G内存的访问 + 加载操作系统 > 因为只加载了512字节, 内存比较小, 所以难以完成 > > + 把部分文件放在操作系统里面 > + 使用二级加载, 首先加载一个loader, 负责完成其他工作, 之后再由loader加载操作系统 + 实模式: 是为了兼容比较老的CPU, 只能使用16位, 没有页操作等保护模式内容, 只可以使用1MB的内存 **使用的寄存器** 在实模式的时候只能使用16位的寄存器, 8086 CPU 中寄存器总共为 14 个，且均为 16 位 。即 AX，BX，CX，DX，SP，BP，SI，DI，IP，FLAG，CS，DS，SS，ES ![Screenshot_20230923_103346_com.xiaoe.client](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242301335.png) > 在实模式的时候只可以使用16位的寄存器 ![Screenshot_20230923_103556_com.xiaoe.client](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242301337.png) 缩写 含义 : : : : AX，BX，CX，DX称作为数据寄存器 AX (Accumulator)：累加寄存器，也称之为累加器；BX (Base)：基地址寄存器；CX (Count)：计数器寄存器；DX (Data)：数据寄存器； SP 和 BP又称作为指针寄存器 SP (Stack Pointer)：堆栈指针寄存器；BP (Base Pointer)：基指针寄存器； SI 和 DI又称作为变址寄存器 SI (Source Index)：源变址寄存器；DI (Destination Index)：目的变址寄存器； 控制寄存器   IP (Instruction Pointer)：指令指针寄存器；   FLAG：标志寄存器； 段寄存器   CS (Code Segment)：代码段寄存器；   DS (Data Segment)：数据段寄存器；   SS (Stack Segment)：堆栈段寄存器；   ES (Extra Segment)：附加段寄存器； ![Screenshot_20230923_103210_com.xiaoe.client (1)](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242301338.png) ## 程序的加载 有两种硬盘, 机械硬盘以及固态硬盘 机械硬盘有几个部分, 扇区 >磁道 >盘面, 不同盘面的相同磁道叫做柱面, 使用磁头进行读取 固态硬盘使用扇区进行存储, 从零开始每一个块是512字节 + BIOS如何知道磁盘第一扇区是引导代码 ```bash start qemu system i386 m 128M s S drive file disk.img,index 0,media disk,format raw ``` > 如果去掉两个 s S qemu就不会与VSCode进行连接 > 在启动的时候会检查磁盘第一扇区最后的两个字节, 应该是0x55 AA, 否则不会进行引导 ## 程序分布 + .vscode + + launch.json 调试的时候使用的文件 + settings.json vsCode配置文件 + tasks.json 运行任务的时候会执行的任务配置 + build + script + source + + applib系统调用库 + boot引导程序 + comm + init 初始进程 + kernel操作系统内核 + loader加载程序 + loop应用程序 + shell命令行应用 ![Screenshot_20230924_093052_com.xiaoe.client](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242301339.png) 编译整个工程会生成elf文件, 有一部分写入磁盘里面, 还有一部分转换之后再写入 ## 引导程序的作用 检测硬件(内存以及硬盘的个数), 从16位的实模式进入32位的保护模式, 加载操作系统跳转到操作系统 > [INT10](https://blog.csdn.net/qq_28256699/article/details/121103977) ### 启动初始化 ```assembly \t#include \"boot.h\" \t// 16位代码，务必加上 \t.code16 \t.text \t.global _start _start: \t//初始化一下各个寄存器 \tmov $0, %ax \tmov %ax, %ds \tmov %ax, %ss \tmov %ax, %es \tmov %ax, %fs \tmov %ax, %gs \t//栈 \tmov $_start, %esp \tmov $0xe, %ah \tmov $'L', %al \tint $0x10 \tjmp . \t \t// 引导结束段 \t.section boot_end, \"ax\" \t//下面这一段的地址使用的是在编译的时候指定的标识符 boot_sig: .byte 0x55, 0xaa ``` ```cmake # 使用自定义的链接器 # 这一个是链接的地址, 以及给出boot_end的位置 set(CMAKE_EXE_LINKER_FLAGS \" m elf_i386 Ttext 0x7c00 section start boot_end 0x7dfe\") set(CMAKE_C_LINK_EXECUTABLE \"${LINKER_TOOL} <OBJECTS> ${CMAKE_EXE_LINKER_FLAGS} o ${PROJECT_BINARY_DIR}/${PROJECT_NAME}.elf\") ``` ![image 20240208141307872](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402081413151.png) ### 引导程序使用BIOS打印字符 调用INT软中断 BIOS生成了一个中断向量表, 其中一部分被BIOS使用, 通过寄存器传递数据 AH 0xE, 显示字符 AL 字符, BL 前景色, BH 页码, 图形模式下BH必须为0, 图形模式模式下BL设置文字的颜色, 文字模式下不行 > AH 00H > AH 00/INT 10H 是用来设定显示模式的服务程序，AL 寄存器表示欲设定的模式 > AH 01H > 可以把光标想成一个小的矩形，平时这个矩形扁平位于某字底部，但藉由此功能可以改变其大小与位置。光标起始处与终止处分别由 CL 与 CH 的 0 到 4 位表示 > AH 02H > 此功能是设定光标位置，位置用 DH、DL 表示，DH 表示列号，DL 表示行号。由左至右称之为『列』，屏幕最上面一列为第零列，紧靠第零列的下一列称为第一列……；由上而下称之为『行』，屏幕最左边一行称之为第零行，紧靠第零行右边的一行为第一行。故最左边，最上面的位置为 DH 0 且 DL 0；最左边第二列，DH 1，DL 0。如果是文字模式时，BH 为欲改变光标位置的显示页，如果是图形模式，BH 要设为 0。 > > 以行列来说明 DH、DL 之意义，小木偶常常搞混，底下以座标方式解释。在文字模式下，字符的位置类似数学直角座标系的座标，但是 Y 轴方向相反，Y 轴是以屏幕最上面为零，越下面越大，直到 24 为止，存于 DH 内。X 轴和直角座标系相同，越右边越大，存于 DL 内，其最大值视显示模式而变。 > AH 03H > AH 03H/INT 10H 这个中断服务程序返回时，会在 DX 里面有光标的行列位置，CX 内有光标的大小，DX、CX 之数值所代表的意义和 AH 02H/INT 10H、AH 01H/INT 10H 相同。 > AH 04H > 此功能是探测光笔之位置，似乎只有 CGA 卡有接上光笔 > AH 05H > 这个功能是把指定的显示页显示于屏幕上，欲显示的显示页于 AL 寄存器中指定。此功能只能在文字模式下才能发生作用。 > AH 06H/07H > 这个服务程序的功用是把某一个设定好的矩形区域内的文字向上或向下移动。先说明向上移动，即调用 AH 06H/INT 10H。当此服务程序工作时，会使矩形区域的文字向上移动，而矩形区域底端移进空格列。向上移动的列数存入 AL 中 ( 如果 AL 为零，表示使矩形区域的所有列均向上移 )，底端移入空格列的属性存于 BH，矩形区域是藉由 CX、DX 来设定左上角与右上角的座标，左上角的行与列分别由 CL、CH 设定，右下角的行与列由 DL、DH 设定。 > > AH 07H/INT 10H 和 AH 06H/INT 10H 相似，只是卷动方像不同而已。 > > AH 08H > 这个服务程序是用来取得光标所在位置的字符及属性，调用前，BH 表示欲读取之显示页，返回时，AL 为该位置之 ASCII 字符，AH 为其属性。 > AH 09H > 这个功能是在光标位置显示字符，所要显示字符的 ASCII 码存于 AL 寄存器，字符重复次数存于 CX 寄存器，显示页存于 BH 寄存器，属性存于 BL 寄存器，其属性使用与 AH 08/INT 10H 一样。 > > AH 0AH > 这个功能和 AH 09H/INT 10H 一样，差别在 AH 0AH 只能写入一个字符，而且不能改变字符属性。 > > AH 0BH > 这个服务程序是选择调色盘。显示模式 5 是 320*200 的图形模式，最多可以显示 4 种颜色，这四种颜色的意思是最多可以『同时』显示一种背景色及三种前景色，而这三种前景色有两种方式可供选择，因此事实上，在显示模式 5 有两种调色盘可供选择。就好像您去买 12 种颜色的水彩，但可在调色盘上以任意比例搭配出许多种颜色。 > > 调色盘 0 的三色是绿、红、黄；调色盘 1 的三色是青、紫红、白。背景色有 16 六种可供选择，这 16 种就是注一的 16 色。调用此中断时，先决定要设定背景色抑或调色盘， > > 要设定背景色时，则使 BH 为 0，再使 BL 之数值为 0 到 0fh 之间表示注一的 16 色之一。 > 要设定调色盘时，则使 BH 为 1。再设定 BL 为零或一表示选择那一种调色盘。 > 背景色只有在前景色为 0 时才会显现出来。 > > AH 0CH > AH 0Ch/INT 10H 是在绘图模式中显示一点 ( 也就是写入点像，write graphics pixel )，而 AH 0DH/INT 10H 则是读取点像 ( read graphics pixel )。 > > 写入时，要写入位置 X 座标存于 CX 寄存器，Y 座标存于 DX 寄存器，颜色存于 AL 寄存器。和文字模式相同，萤光幕上的 Y 座标是最上面一列为零，越下面越大，X 座标则和数学的定义相同。CX、DX、AL 值之范围与显示模式有关. > AH 0DH/INT 10H 则是读取某一位置之点像，您必须指定 CX、DX，而 INT 10H 会传回该位置点像之颜色。 > > AH 0EH > 这个子程序是使显示器像打字机一样的显示字符来，在前面用 AH 09H/INT 10H 和 AH 0AH/INT 10H 都可以在萤光幕上显示字符，但是这两奘方式显示字符之后，光标位置并不移动，而 AH 0EH/INT 10H 则会使光标位置移动，每显示一个字符，光标会往右移一格，假如已经到最右边了，则光标会移到最左边并移到下一列，假如已经移到最下面一列的最右边，则屏幕会向上卷动。 > > AL 寄存器存要显示的字符，BH 为目前的显示页，如果是在图形模式，则 BH 须设为 0，假如是在图形模式下，也可以设定 BL 来表示文字的颜色，文字模式下的 BL 则无功能。 > > AH 0FH > 这个服务程序是得到目前的显示模式，调用前只需使 AH 设为 0fh，当由 INT 10H 返回时，显示模式存于 AL 寄存器 ( 参考 AH 00H/INT 10H 的显示模式表 )，目前的显示页存于 BH 寄存器，总字符行数存于 AH 寄存器。 > > [BIOS INT 10中断功能详解_bios int10是什么意思_rhxznp的博客 CSDN博客 ```assembly mov $0xe, %ah mov $'L', %al int $0x10 ``` > 显示一个L > > ![image 20240208142520169](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402081425209.png) ### 加载磁盘中的loader + 这里设计为加载到0x8000这个位置 在这里使用的INT 13 AH 02H AL 扇区数 CH 柱面cx ch:cl CL 扇区 DH 磁头 DL 驱动器, 00H 7FH, 软盘 80H 0FFH:硬盘 ES:BX 缓冲区地址, 之前已经把ES设置为0了 出口参数: CF 0, 操作成功, AH 00H, AL 传输的扇区数量, 否则AH 状态码 ![image 20230924113125617](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242301340.png) ![image 20240208145143935](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402081451979.png) > 查看磁盘文件是否成功加载 > 使用命令x可以进行查看内存 > > 命令的格式是 x / <n/f/u> <addr> > > + n是一个正整数, 表示显示的长度 > + f表示显示的格式 > + + x十六进制 > + d十进制 > + u按照十六进制显示无符号 > + o按照八进制显示 > + t按照二进制显示 > + a按照十六进制显示 > + c按照字符格式 > + f按照浮点数格式 > + u显示的单元大小, 默认是4bytes, b表示单字节, h双字节, w四字节, g八字节 ```assembly read_loader: \t//偏移 \tmov $0x8000, %bx \t//这个是必须的值 \tmov $0x2, %ah \t//高位0: 柱面 低位2:扇区 \tmov $0x2, %cx \t//扇区数 \tmov $64, %al \t//使用磁盘 \tmov $0x0080, %dx \tint $0x13 \tjc read_loader ``` > 汇编语言中的JC（Jump if Carry）指令用于在发生进位时跳转到指定的地址。它是根据条件码中的进位标志（CF）来判断是否发生进位 ### 跳转到boot_loader的C函数 这个函数不再返回, 直接使用jmp指令就可以了 ```assembly jmp boot_entry ``` ## loader程序 这一部分的工作是16位 32位以及保护模式的设置 ![image 20240211220450630](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402112204654.png) ### 修改编译文件 + 顶层的CMakeList.txt ```cmake # 底层的若干子项目：含内核及应用程序, 加这一个 add_subdirectory(./source/loader) ``` + 脚本文件 ```bash if not exist \"disk1.vhd\" ( echo \"disk1.vhd not found in image directory\" notepad win_error.txt exit 1 ) if not exist \"disk2.vhd\" ( echo \"disk2.vhd not found in image directory\" notepad win_error.txt exit 1 ) set DISK1_NAME disk1.vhd dd if boot.bin of %DISK1_NAME% bs 512 conv notrunc count 1 dd if loader.bin of %DISK1_NAME% bs 512 conv notrunc seek 1 dd: 命令行工具，用于复制和转换文件 if boot.bin: 指定输入文件为 boot.bin of %DISK1_NAME%: 指定输出文件为 %DISK1_NAME%，%DISK1_NAME% 是一个环境变量，表示磁盘的名称 bs 512: 指定每次读取和写入的块大小为 512 字节 conv notrunc: 指定不截断输出文件，即保留输出文件中原有的数据 count 1: 指定只复制一个块，即 512 字节 第二条命令： dd: 命令行工具，用于复制和转换文件 if loader.bin: 指定输入文件为 loader.bin of %DISK1_NAME%: 指定输出文件为 %DISK1_NAME%，%DISK1_NAME% 是一个环境变量，表示磁盘的名称 bs 512: 指定每次读取和写入的块大小为 512 字节 conv notrunc: 指定不截断输出文件，即保留输出文件中原有的数据 seek 1: 指定从输出文件的第二个块开始写入，即跳过第一个块 ``` > 在调试的时候需要加上loader.elf文件的描述符 ```cmake project(loader LANGUAGES C) # 使用自定义的链接器 set(CMAKE_EXE_LINKER_FLAGS \" m elf_i386 Ttext 0x8000\") set(CMAKE_C_LINK_EXECUTABLE \"${LINKER_TOOL} <OBJECTS> ${CMAKE_EXE_LINKER_FLAGS} o ${PROJECT_BINARY_DIR}/${PROJECT_NAME}.elf\") # 将所有的汇编、C文件加入工程 # 注意保证start.asm在最前头，这样对应的程序会放在bin文件开头，从而在加载到0x7c00时能在开头处 file(GLOB C_LIST \"*.c\" \"*.h\") add_executable(${PROJECT_NAME} start.S ${C_LIST}) # bin文件生成，写入到image目录下 add_custom_command(TARGET ${PROJECT_NAME} POST_BUILD COMMAND ${OBJCOPY_TOOL} O binary ${PROJECT_NAME}.elf ${CMAKE_SOURCE_DIR}/../../image/${PROJECT_NAME}.bin COMMAND ${OBJDUMP_TOOL} x d S m i8086 ${PROJECT_BINARY_DIR}/${PROJECT_NAME}.elf > ${PROJECT_NAME}_dis.txt COMMAND ${READELF_TOOL} a ${PROJECT_BINARY_DIR}/${PROJECT_NAME}.elf > ${PROJECT_NAME}_elf.txt ) ``` > 对文件进行编译, 设置一下程序的位置是0x80000, 会生成一个bin文件在image目录下面, Start.S在其它代码前面 ### 进入loader目录的Start.S里面 ```c __asm__(\".code16gcc\"); #include \"boot.h\" #define LOADER_START_ADDR 0x8000 /** * Boot的C入口函数 * 只完成一项功能，即从磁盘找到loader文件然后加载到内容中，并跳转过去 */ void boot_entry(void) { ((void (*)(void))LOADER_START_ADDR)(); } ``` ![image 20240211221721076](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402112217135.png) ![image 20240211221846759](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402112218783.png) > 已经跳转过去了, 但是gdb不知道这一部分的代码是什么 ```c { \"description\": \"加载load符号文件\", \"text\": \"add symbol file ./build/source/loader/loader.elf 0x8000\", \"ignoreFailures\": false }, ``` > launch.json里面加这一段"},"/note/Linux/泰山派/2025-12-26-09-拍照.html":{"title":"拍照","content":"# 拍照 使用命令`v4l2 ctl list devices`列出所有的摄像头设备, 默认的摄像头是video0, 可以使用`v4l2 ctl list formats ext device /dev/video0`查看支持的格式 命令行拍照：`gst launch 1.0 v4l2src num buffers 1 device /dev/video0 ! jpegenc ! filesink location /tmp/picture.jpg` `gst launch 1.0 v4l2src device /dev/video0 ! video/x raw,format NV12,width 1920,height 1080,framerate 30/1 ! kmssink `"},"/note/Linux/泰山派/2025-12-25-08-OpenCV.html":{"title":"OpenCV","content":"# OpenCV ## 下载 [buildroot环境下，手动安装编译opencv，cmake gui方式 惊觉](https://leheavengame.com/article/678d995ad203af4dd97cf1a1) ## 编译 ```bash sudo cmake D CMAKE_BUILD_TYPE RELEASE D CMAKE_C_COMPILER /usr/bin/aarch64 linux gnu gcc D CMAKE_CXX_COMPILER /usr/bin/aarch64 linux gnu g++ D BUILD_SHARED_LIBS ON D CMAKE_CXX_FLAGS fPIC D CMAKE_C_FLAGS fPIC D CMAKE_EXE_LINKER_FLAGS lpthread ldl D ENABLE_PIC ON D WITH_1394 OFF D WITH_ARAVIS OFF D WITH_ARITH_DEC ON D WITH_ARITH_ENC ON D WITH_CLP OFF D WITH_CUBLAS OFF D WITH_CUDA OFF D WITH_CUFFT OFF D WITH_FFMPEG ON D WITH_GSTREAMER ON D WITH_GSTREAMER_0_10 OFF D WITH_HALIDE OFF D WITH_HPX OFF D WITH_IMGCODEC_HDR ON D WITH_IMGCODEC_PXM ON D WITH_IMGCODEC_SUNRASTER ON D WITH_INF_ENGINE OFF D WITH_IPP OFF D WITH_ITT OFF D WITH_JASPER ON D WITH_JPEG ON D WITH_LAPACK ON D WITH_LIBREALSENSE OFF D WITH_NVCUVID OFF D WITH_OPENCL OFF D WITH_OPENCLAMDBLAS OFF D WITH_OPENCLAMDFFT OFF D WITH_OPENCL_SVM OFF D WITH_OPENEXR OFF D WITH_OPENGL OFF D WITH_OPENMP OFF D WITH_OPENNNI OFF D WITH_OPENNNI2 OFF D WITH_OPENVX OFF D WITH_PNG ON D WITH_PROTOBUF OFF D WITH_PTHREADS_PF ON D WITH_PVAPI OFF D WITH_QT OFF D WITH_QUIRC OFF D WITH_TBB OFF D WITH_TIFF ON D WITH_VULKAN OFF D WITH_WEBP ON D WITH_XIMEA OFF D CMAKE_INSTALL_PREFIX ./install D WITH_GTK ON WITH_GTK_2_X ON .. ``` ![image 20251225231959625](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512252319690.png) ![image 20251225232019458](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512252320498.png) ![image 20251225232230554](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512252322623.png) ![image 20251225232519377](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512252325439.png) ![image 20251225232623382](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512252326441.png)"},"/note/Linux/泰山派/2025-12-24-06-二维码识别.html":{"title":"二维码识别","content":"# 二维码识别 ```bash sudo apt update && sudo apt install libopencv dev sudo apt get install libzbar dev ``` ```cpp #include <zbar.h> #include <opencv2/opencv.hpp> #include <string> #include <vector> #include <iostream> // 补充iostream头文件（cerr/cout需要） using namespace cv; using namespace std; using namespace zbar; int main() { // 1. 读取图像（替换为你的图片路径） Mat img imread(\"test.jpg\"); if (img.empty()) { cerr << \"错误：无法读取图片 test.jpg，请检查路径！\" << endl; return 1; } // 2. 转换为灰度图 Mat Gray; cvtColor(img, Gray, COLOR_BGR2GRAY); // 3. 准备ZBar图像数据 int width Gray.cols; int height Gray.rows; uchar* raw_data Gray.data; Image image(width, height, \"Y800\", raw_data, width * height); // 4. 初始化扫描器 ImageScanner scanner; scanner.set_config(ZBAR_NONE, ZBAR_CFG_ENABLE, 1); // 5. 扫描条码/二维码 int scan_result scanner.scan(image); if (scan_result < 0) { cerr << \"错误：扫描图像过程中发生错误！\" << endl; return 1; } else if (scan_result 0) { cout << \"提示：未识别到任何条码/二维码！\" << endl; return 0; } // 6. 定义结果结构体 struct Result { string type; string content; vector<Point2f> points; }; vector<Result> results; // 7. 遍历识别结果 for (Image::SymbolIterator symbol image.symbol_begin(); symbol ! image.symbol_end(); ++symbol) { Result res; res.type symbol >get_type_name(); res.content symbol >get_data(); for (int i 0; i < symbol >get_location_size(); i++) { res.points.push_back(Point2f( symbol >get_location_x(i), symbol >get_location_y(i) )); } results.push_back(res); } // 8. 仅控制台输出结果（移除图形界面） for (size_t i 0; i < results.size(); i++) { cout << \" 识别结果 \" << i+1 << \" \" << endl; cout << \"类型：\" << results[i].type << endl; cout << \"内容：\" << results[i].content << endl; cout << \"顶点坐标：\" << endl; for (size_t j 0; j < results[i].points.size(); j++) { cout << \" 点\" << j+1 << \"：(\" << results[i].points[j].x << \", \" << results[i].points[j].y << \")\" << endl; } } // 9. 释放ZBar资源 image.set_data(nullptr, 0); return 0; } ``` 使用findpackage的前提是包在安装时提供了一个名为`findXXX.cmake`或者`xxxconfig.cmake`的文件且加到环境变量中。 但zbar等以下轻量库并没有提供这个文件，是一个后缀为`.pc`的文件。`pkgconfig`是linux下的一个包管理器，与cmake类似，它通过`.pc`后缀文件来去管理包，获取包的相关信息。因此我们可以通过cmake调用`pkgconfig`来找到zbar的相关信息 ```cmake cmake_minimum_required(VERSION 3.5.1) project(ZbarTest) find_package(OpenCV REQUIRED) find_package(PkgConfig REQUIRED) # 找到pkgconfig pkg_search_module(ZBAR REQUIRED zbar) # 通过pkgconfig查找zbar，然后就可以使用ZBAR_INCLUDE_DIRS和ZBAR_LIBRARIES变量了 add_executable(main test.cpp) target_include_directories(main PRIVATE ${OpenCV_INCLUDE_DIRS} ${ZBAR_INCLUDE_DIRS}) target_link_libraries(main PRIVATE ${OpenCV_LIBS} ${ZBAR_LIBRARIES}) ```"},"/note/Linux/泰山派/2025-12-20-05-lvgl程序.html":{"title":"lvgl程序","content":"# lvgl程序 ```txt TARGET_ARCH arm64 TARGET_PLATFORM rk356x TARGET_UBOOT_CONFIG rk3566 TARGET_SPL_CONFIG TARGET_KERNEL_CONFIG rockchip_linux_defconfig TARGET_KERNEL_DTS tspi rk3566 user v10 linux TARGET_TOOLCHAIN_CONFIG TARGET_BUILDROOT_CONFIG rockchip_rk3566 TARGET_RECOVERY_CONFIG rockchip_rk356x_recovery TARGET_PCBA_CONFIG TARGET_RAMBOOT_CONFIG Start building uboot TARGET_UBOOT_CONFIG rk3566 ``` ## 编译器 ```bash set(CMAKE_C_COMPILER /home/jiao/Taishan/rope/prebuilts/gcc/linux x86/aarch64/gcc linaro 6.3.1 2017.05 x86_64_aarch64 linux gnu/bin/aarch64 linux gnu gcc) set(CMAKE_CXX_COMPILER /home/jiao/Taishan/rope/prebuilts/gcc/linux x86/aarch64/gcc linaro 6.3.1 2017.05 x86_64_aarch64 linux gnu/bin/aarch64 linux gnu g++) # Specify the sysroot (if available) set(CMAKE_SYSROOT /home/jiao/Taishan/rope/buildroot/output/rockchip_rk3566/host/aarch64 buildroot linux gnu/sysroot) ``` ### 添加组件 [立创·泰山派：Buildroot开启libcurl+OpenSSL教程_buildroot openssl CSDN博客](https://blog.csdn.net/m0_64657422/article/details/146468551) 在编译的时候需要一些使用到的组件需要从buildroot里面编译进去 ```bash make menuconfig # 保存配置文件 make savedefconfig # 手动将生成在 buildroot/defconfig 文件内容复制到 ./configs/rockchip_rk3566_defconfig 文件里面 # 全量编译（首次） ./build.sh all # 只编译buildroot ./build.sh rootfs ./mkfirmware.sh ./build.sh updateimg ``` ### 添加curl ```bash Target packages > Libraries \t >Networking \t > libcurl [*] # y 选择 \t SSL/TLS library to use (OpenSSL) > \t # 可进去以选择ssl类型，如果没有，则需要开启openssl # 若找不到，可以使用 ‘/’ 进行搜索 # 按下 ‘/’ 进入，打上 libcurl 搜索，打上 openssl 搜索 Target packages > Libraries > Crypto > openssl [*] # 选中OpenSSL # 确保zlib启用（libcurl需要） Target packages > Libraries > Compression > zlib [*] ``` #### 验证 ```bash ls /usr/lib/libcurl.so* # 应看到.so文件 ls /usr/lib/libssl.so* # 检查OpenSSL curl v https://httpbin.org/get ``` ### json c ```bash Target packages > Libraries \t > JSON/XML \t > json c ``` ### libdrm ``` > Target packages > Libraries > Graphics > libdrm (BR2_PACKAGE_LIBDRM [ y]) ``` 这个库是新加进来的所以需要指定链接一下 ```cmake find_package(PkgConfig REQUIRED) pkg_check_modules(LIBDRM REQUIRED libdrm) target_include_directories(lvgl PRIVATE ${LIBDRM_INCLUDE_DIRS}) target_compile_options(lvgl PRIVATE ${LIBDRM_CFLAGS_OTHER}) ``` ## Wifi ```bash # 在这个文件里面添加需要连接的Wifi的地址 vi /data/cfg/wpa_supplicant.conf wpa_supplicant B i wlan0 c /data/cfg/wpa_supplicant.conf ``` ## 关闭原有桌面 ```bash chmod x /etc/init.d/S49weston ``` ## 开机自启动 ```bash root@RK356X:/# cat /etc/init.d/S49lvgl #!/bin/sh case \"$1\" in start\"\") #while true #do # list iodomain.sh # sleep $(( 60 * 2 )) #done & cd /root/bin ./main & ;; restartreloadforce reload) echo \"Error: argument '$1' not supported\" >&2 exit 3 ;; stopstatus) # No op ;; *) echo \"Usage: [startstop]\" >&2 exit 3 ;; esac root@RK356X:/# chmod +x /etc/init.d/S49lvgl ``` ## 屏幕 ```bash screen height: 480 screen width: 800 ``` ## ffmpeg移植 ### 下载x264 ```bash git clone https://code.videolan.org/videolan/x264.git cd x264/ mkdir x264build vim autoConfig.sh ``` ```bash #!/bin/bash # 定义变量 # 设置x264的安装位置 PREFIX \"./x264build\" # 交叉编译器bin路径 TOOLCHAIN_DIR \"/home/jiao/Taishan/rope/prebuilts/gcc/linux x86/aarch64/gcc linaro 6.3.1 2017.05 x86_64_aarch64 linux gnu/bin\" # 工具链前缀，用于指定交叉编译工具的路径 TOOLCHAIN \"$TOOLCHAIN_DIR/aarch64 linux gnu \" # 运行 configure 脚本 echo \"正在配置 x264...\" ./configure \\ prefix $PREFIX \\ disable asm \\ enable shared \\ enable static \\ host aarch64 linux gnu \\ cross prefix $TOOLCHAIN \\ enable pic # 检查 configure 的返回状态 if [ $? ne 0 ]; then echo \"错误：配置 x264 失败。\" exit 1 else echo \"配置成功。\" fi # 编译 x264 echo \"正在编译 x264...\" # 使用 nproc 获取处理器核心数，以确定并行编译的进程数 make j$(nproc) # 检查编译的返回状态 if [ $? ne 0 ]; then echo \"错误：编译 x264 失败。\" exit 1 else echo \"编译成功。\" fi # 安装 x264 echo \"正在安装 x264...\" make install # 检查安装的返回状态 if [ $? ne 0 ]; then echo \"错误：安装 x264 失败。\" exit 1 else echo \"安装成功。\" fi # 清理构建目录 echo \"正在清理...\" make clean # 检查清理的返回状态 if [ $? ne 0 ]; then echo \"警告：清理构建目录失败。\" else echo \"构建过程完成。\" fi # 脚本正常退出 exit 0 ``` ### 编译ffmpeg ```bash git clone https://gitclone.com/github.com/nyanmisaka/ffmpeg rockchip.git cd ffmpeg rockchip mkdir ffmpeg_rk_build vim autoConfig.sh ``` ```bash # 定义前缀目录 PREFIX \"./ffmpeg_rk_build\" # x264安装目录的绝对路径 X264_BUILD_DIR \"/home/jiao/app/x264/x264build\" # x264安装目录中include目录绝对路径 X264_INCLUDE_DIR \"$X264_BUILD_DIR/include\" # x264安装目录中lib目录绝对路径 X264_LIB_DIR \"$X264_BUILD_DIR/lib\" # 设置 PKG_CONFIG_PATH 环境变量 export PKG_CONFIG_PATH $X264_LIB_DIR/pkgconfig:$PKG_CONFIG_PATH echo \"配置环境变量：\" echo \"export PKG_CONFIG_PATH $X264_LIB_DIR/pkgconfig:$PKG_CONFIG_PATH\" echo \"正在配置./configure...\" ./configure \\ prefix $PREFIX \\ enable shared \\ disable static \\ enable cross compile \\ arch arm64 \\ disable stripping \\ target os linux \\ cc /home/jiao/Taishan/rope/prebuilts/gcc/linux x86/aarch64/gcc linaro 6.3.1 2017.05 x86_64_aarch64 linux gnu/bin/aarch64 linux gnu gcc \\ enable libx264 \\ extra cflags I$X264_INCLUDE_DIR \\ extra ldflags L$X264_LIB_DIR \\ pkg config flags \" static\" \\ extra libs \" lpthread lm\" \\ enable gpl \\ enable pic \\ enable nonfree \\ enable pthreads # 检查 ./configure 是否成功 if [ $? eq 0 ]; then echo \"./configure配置成功！\" else echo \"./configure配置失败！请检查您的环境！！！\" fi # 运行 make echo \"正在编译 ffmpeg rockchip...\" # 使用 nproc 获取处理器核心数，以确定并行编译的进程数 make j$(nproc) if [ $? eq 0 ]; then echo \"Make成功！！！\" else echo \"Make失败！！请检查错误信息，清除错误之后再次尝试！！\" exit 1 fi # 运行 make install echo \"正在安装 ffmpeg rockchip...\" make install if [ $? eq 0 ]; then echo \"Make intall 安装成功！！！！\" echo \" \" echo \"ffmpeg_rk 被安装在$PREFIX!\" echo \" \" else echo \"Make install 安装失败！！请检查错误信息，清除错误之后再次尝试！！\" exit 1 fi # 清理构建目录 echo \"正在清理...\" make clean # 检查清理的返回状态 if [ $? ne 0 ]; then echo \"警告：清理构建目录失败。\" else echo \"构建过程完成。\" fi # 脚本正常退出 exit 0 ``` 将 **/x264/x264build/bin** 文件夹中的所有内容全部复制到开发板的 **/usr/bin/** 目录下 **/x264/x264build/lib** 文件夹中的所有内容全部复制到开发板的 **/usr/lib/** 目录下 将 **/ffmpeg rockchip/ffmpeg_rk_build/bin** 文件夹中的所有内容全部复制到开发板的 **/usr/bin/** 目录下 **/ffmpeg rockchip/ffmpeg_rk_build/lib** 文件夹中的所有内容全部复制到开发板的 **/usr/lib/** 目录下 ## 编译SDL ```bash wget https://www.libsdl.org/projects/SDL_image/release/SDL2_image 2.6.3.tar.gz tar xzf SDL2_image 2.6.3.tar.gz cd SDL2_image 2.6.3 # 2. 设置环境变量 export PATH \"/home/jiao/Taishan/rope/prebuilts/gcc/linux x86/aarch64/gcc linaro 6.3.1 2017.05 x86_64_aarch64 linux gnu/bin:$PATH\" export CC /home/jiao/Taishan/rope/prebuilts/gcc/linux x86/aarch64/gcc linaro 6.3.1 2017.05 x86_64_aarch64 linux gnu/bin/aarch64 linux gnu gcc export CXX /home/jiao/Taishan/rope/prebuilts/gcc/linux x86/aarch64/gcc linaro 6.3.1 2017.05 x86_64_aarch64 linux gnu/bin/aarch64 linux gnu g++ export SDL2_CONFIG /home/jiao/app/sdl2_build/bin/sdl2 config # 3. 配置 ./configure \\ host aarch64 linux gnu \\ prefix /home/jiao/app/sdl2_build \\ with sdl prefix /home/jiao/app/sdl2_build \\ enable static no \\ enable shared yes \\ disable jpg \\ disable png \\ disable tif \\ disable webp \\ disable imageio # 4. 编译并安装 make j$(nproc) sudo make install # 5. 验证安装 ls la /opt/rv1106 libs/lib/libSDL2_image* file /opt/rv1106 libs/lib/libSDL2_image.so ``` ## update.img 可以在文件`./tools/linux/Linux_Pack_Firmware/rockdev/rk356x package file`里面修改实际打包的update.img文件 > 试了一下好像不行 ## 自定义文件 Buildroot源码的overlay目录存放在buildroot源码/board/xxx厂商/xxx型号/overlay目录 ``` System configuration \t > System configuration ``` 添加`$(TOPDIR)/board/rockchip/rk356x/taishan overlay`"},"/note/Linux/泰山派/2026-1-27-ROS.html":{"title":"ROS","content":"# ROS ![image 20260128095835281](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601280958349.png) 泰山派默认的使用的是linux4.19的版本, 需要源码下载的文件在[这里](https://github.com/ros2/ros2/archive/refs/tags/release humble 20230724.tar.gz) 在文件buildroot/configs/rockchip/ros2_dep.config ```bash BR2_PACKAGE_LTTNG_TOOLS y BR2_PACKAGE_LTTNG_LIBUST y ``` 在文件buildroot/configs/rockchip_rk356x_robot_defconfig 添加`#include \"ros2_dep.config\"` 修改使用的库的版本号 ```bash cd 你的SDK根目录/buildroot/package/ # 检查 lttng tools 版本 cat lttng tools/lttng tools.mk grep VERSION # 检查 lttng libust 版本 cat lttng libust/lttng libust.mk grep VERSION # 检查 liburcu 版本 cat liburcu/liburcu.mk grep VERSION ``` lttng tools：`PKG_VERSION 2.12.3` lttng libust：`PKG_VERSION 2.12.3` liburcu：`PKG_VERSION 0.13.0` 如果版本不符，需要修改对应 `.mk` 文件中的 `PKG_VERSION` 数值，同时确认文件中的 `PKG_SOURCE`（下载链接）也对应该版本（避免下载错误的源码包）。 下载包出错, 手动下载 ```bash wget https://sourceware.org/pub/bzip2/bzip2 1.0.6.tar.gz O /home/lckfb/rope/buildroot/dl/bzip2 1.0.6.tar.gz ``` 编译buildroot ```bash ``` ## 编译 使用镜像 ```bash gunzip jammy ros2 build.tar.gz docker image load i jammy ros2 build.tar docker run it mount type bind,source /home/jiao/Taishan/rope/buildroot/output/rockchip_rk3566/,target /buildroot focal ros2 build ``` 把两个文件复制到docker里面, 分别是源码以及编译脚本 ```bash (base) jiao@jiao virtual machine:~/Taishan/rope/buildroot/output/rockchip_rk356x_recovery$ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 3dc7725ce204 focal ros2 build \"/bin/bash\" 20 seconds ago Up 19 seconds trusting_elgamal 827a46042c12 taishan_build \"/bin/bash\" 5 weeks ago Up 19 minutes taishan (base) jiao@jiao virtual machine:~/Taishan/app/ROS$ docker container cp ros2 sources.tar.gz 3dc7725ce204:/tmp/ (base) jiao@jiao virtual machine:~/Taishan/app/ROS$ docker container cp ros2 build scripts.tar.gz 3dc7725ce204:/tmp/ ``` 在容器里面解压缩 ```bash sudo tar zxf /tmp/ros2 build scripts.tar.gz C / sudo tar zxf /tmp/ros2 sources.tar.gz C / ``` 替换脚本里面的python版本 ```bash vim /opt/ros/cross compile/cross compile.mixin vim /opt/ros/foxy/build_ros2.sh # 里面的3.10 > 3.8 # 里面的310 > 38 ``` ```bash ls /opt/ros cross compile foxy galactic humble iron cd /opt/ros/iron ./prepare source.sh ./build ros2.sh # 编译成功后，应有类似提示: ... Summary: 317 packages finished [15min 37s] ... build ros quit & cleanup ``` 编译的时候出现错误 在buildroot配置添加`BR2_PACKAGE_TINYXML2 y`"},"/note/Linux/泰山派/2025-12-26-10-Qt.html":{"title":"Qt","content":"# Qt ## 手动编译 下载到/opt文件夹里面 ```bash wget https://download.qt.io/archive/qt/5.12/5.12.10/single/qt everywhere src 5.12.10.tar.xz ``` ```bash sudo vim ./qtbase/mkspecs/linux aarch64 gnu g++/qmake.conf ``` 这个文件是配置交叉编译的, 改为 ``` # # qmake configuration for building with aarch64 linux gnu g++ # MAKEFILE_GENERATOR UNIX CONFIG + incremental QMAKE_INCREMENTAL_STYLE sublib QT_QPA_DEFAULT_PLATFORM linuxfb QMAKE_CFLAGS_RELEASE + O2 march armv8 a lts QMAKE_CXXFLAGS_RELEASE + O2 march armv8 a lts include(../common/linux.conf) include(../common/gcc base unix.conf) include(../common/g++ unix.conf) # modifications to g++.conf QMAKE_CC aarch64 linux gnu gcc QMAKE_CXX aarch64 linux gnu g++ QMAKE_LINK aarch64 linux gnu g++ QMAKE_LINK_SHLIB aarch64 linux gnu g++ # modifications to linux.conf QMAKE_AR aarch64 linux gnu ar cqs QMAKE_OBJCOPY aarch64 linux gnu objcopy QMAKE_NM aarch64 linux gnu nm P QMAKE_STRIP aarch64 linux gnu strip load(qt_config) ``` > **QT_QPA_DEFAULT_PLATFORM linuxfb**： > > 这一行设置了 Qt Quick/QML 应用程序的默认平台插件。`linuxfb` 是 Linux Framebuffer 的缩写，它是一种在嵌入式系统上直接控制显示设备的方法。设置为 `linuxfb` 表明 Qt 应用程序将使用 Linux Framebuffer 作为默认的图形平台，这适用于一些嵌入式系统。 > > **QMAKE_CFLAGS_RELEASE + O2 march armv8 a lts**： > > 这一行设置了在 Release 模式下编译 C 代码时的编译标志。 ` O2` 表示启用优化级别 2，这会使编译器对代码进行更多的优化，以提高执行效率。 ` march armv8 a` 表示生成适用于 ARMv8 A 架构的代码。ARMv8 A 是支持 64 位指令集的 ARM 架构的一种实现，常见于现代的 ARM 处理器。 > > **QMAKE_CXXFLAGS_RELEASE + O2 march armv8 a lts**： > > 这一行设置了在 Release 模式下编译 C++ 代码时的编译标志，与上一行类似。它也会将相同的优化级别和目标架构应用于 C++ 代码。 创建一个编译脚本 ```bash #!/bin/sh mkdir install ./configure \\ prefix /home/jiao/Taishan/app/qt/install \\ confirm license \\ opensource \\ release \\ make libs \\ xplatform linux aarch64 gnu g++ \\ pch \\ qt libjpeg \\ qt libpng \\ qt zlib \\ no opengl \\ no sse2 \\ no openssl \\ no cups \\ no glib \\ no dbus \\ no separate debug info \\ sudo make j12 sudo make install ``` > ` prefix /opt/qt5.12.10 arm`：指定 Qt 的安装路径为 `/opt/qt5.12.10 arm`。这意味着编译完成后 Qt 库和工具将安装到这个目录下。 > ` confirm license`：确认接受 Qt 的许可协议。 > ` opensource`：使用开源许可证编译 Qt。 > ` release`：编译 Qt 为发布版本，而非调试版本。 > ` make libs`：只编译 Qt 库，而不编译示例程序等。 > ` xplatform linux aarch64 gnu g++`：指定目标平台为 Linux，并使用 `aarch64` 架构进行编译。`gnu g++` 表示使用 GNU 工具链进行编译。 > ` pch`：启用预编译头文件功能，以加快编译速度。 > ` qt libjpeg`、` qt libpng`、` qt zlib`：指定 Qt 在编译时使用系统中已安装的 libjpeg、libpng 和 zlib 库。 > ` no opengl`：不编译 Qt 的 OpenGL 模块。 > ` no sse2`：禁用 SSE2 指令集优化。 > ` no openssl`：不编译 Qt 的 OpenSSL 模块。 > ` no cups`：不编译 Qt 的 CUPS 模块（用于打印支持）。 > ` no glib`：不编译 Qt 的 GLib 模块。 > ` no dbus`：不编译 Qt 的 D Bus 模块。 > ` no separate debug info`：不生成单独的调试信息文件。 这些产物是**专门针对 ARM64（aarch64）架构 Linux 嵌入式设备的 Qt 5.12.10 核心开发 / 运行文件**（不是可直接用的 Qt Creator 编辑器，也不是示例程序） 之后可以使用`/home/jiao/Taishan/app/qt/install/bin/qmake`进行编译 ### 手动移植库 可以吧install这个文件里面的文件转移到开发板的/opt目录下 ```bash sudo vi /etc/profile export QTEDIR /opt/qt5.12.10 arm/ export LD_LIBRARY_PATH /opt/qt5.12.10 arm/lib:$LD_LIBRARY_PATH export QT_QPA_PLATFORM_PLUGIN_PATH $QTEDIR/plugins export QT_QPA_PLATFORM linuxfb export QT_QPA_FONTDIR /usr/share/fonts/truetype/ubuntu ``` ### buildroot添加 **1. 基础版本（必选）**：`Toolchain gcc version` → 选择 ≥5.0 的版本（如`gcc 8.x`/`gcc 9.x`，避免选 4.x）； **2. C++ 支持（必选）**：勾选 `C++ support`（Qt5 是 C++ 库，无此选项直接屏蔽）； **3. wchar 支持（必选）**：勾选 `WCHAR support`（老版本 Buildroot 可能显示为`Enable WCHAR support`）； **4. NPTL 线程支持（必选）**：找到 `thread support` → 选择 `NPTL`（不要选`linuxthreads`，Qt5 不兼容）； Qt5：选择编译 Qt5 库。 gui module：选择编译 Qt5 的 GUI 模块。 widgets module：选择编译 Qt5 的 Widgets 模块。 fontconfig support：Fontconfig 是一个用于配置和自定义字体的库，它提供了一种统一的方式来管理系统上安装的字体。启用这个选项可以让 Qt5 库在运行时使用 Fontconfig 来管理字体，这样可以更好地支持字体的配置和渲染。 GIF support：启用对 GIF 图像格式的支持。 JPEG support：启用对 JPEG 图像格式的支持。 PNG support：启用对 PNG 图像格式的支持。 syslog support：启用系统日志支持。 Enable Tslib support：启用对 Tslib 的支持，Tslib 是一个用于触摸屏设备的抽象库。 qt5serialport：选择编译 Qt5 的串口通信模块。 qt5virtualkeyboard：选择编译 Qt5 的虚拟键盘模块。 (en_GB) language layouts：选择英国英语作为默认语言布局。 bash BR2_TOOLCHAIN_BUILDROOT_WCHAR y BR2_TOOLCHAIN_BUILDROOT_CXX y BR2_PACKAGE_QT5 y BR2_PACKAGE_QT5BASE_WIDGETS y BR2_PACKAGE_QT5BASE_FONTCONFIG y BR2_PACKAGE_QT5BASE_GIF y BR2_PACKAGE_QT5BASE_JPEG y BR2_PACKAGE_QT5BASE_PNG y BR2_PACKAGE_QT5BASE_SYSLOG y BR2_PACKAGE_QT5BASE_TSLIB y BR2_PACKAGE_QT5SERIALPORT y BR2_PACKAGE_QT5VIRTUALKEYBOARD y BR2_PACKAGE_LIBDRM y 可以使用的qmake在/buildroot/output/rockchip_rk3566/build/qt5base 5.15.2/bin/qmake ## windows [【保姆级图文教程】最新Windows系统QT下载、安装、入门、配置VS Qt环境，图文详细、内容充实 CSDN博客](https://blog.csdn.net/qq_62888264/article/details/132645054) [Download Qt OSS: Get Qt Online Installer](https://www.qt.io/development/download qt installer oss) 下载安装器 下载以后使用下面的命令设置镜像启动 ```bash .\\qt online installer windows x64 4.8.0.exe mirror https://mirrors.ustc.edu.cn/qtproject/ ``` 一直下一步 ## 编译代码 创建一个qt项目, 使用qmake编译 ```bash ~/Taishan/app/qt/install/bin/qmake ./untitled.pro make ``` 在开发板运行, 需要基于weston ```bash export QT_QPA_PLATFORM wayland egl && export QT_WAYLAND_DISPLAY wayland 0 && ./untitled ```"},"/note/Linux/泰山派/2025-5-14-03屏幕驱动.html":{"title":"屏幕驱动","content":"# 屏幕驱动 ![image 20250514094741854](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202505140947938.png) ### 屏幕参数 前面铺垫了这么多主要为了屏幕参数做准备，后面我们的mipi和edp屏幕大家要求调试的也是这些屏幕参数，驱动官方已经给我们写好了，我们只需要根据不同屏幕厂商给的参数修改对应的屏参就行。 **哪些参数是我们必须关注的呢？** 屏幕有效显示区域，比如我下面举例的1366x768就是他的有效显示区域也是分辨率。 1. `VSYNC（垂直同步信号）`：VSYNC 是用于同步显示器刷新的信号。当 VSYNC 信号跳变时，显示器会开始显示新的一帧画面。 2. `Vertical Total（垂直总宽度）`：下面所有的参数之和 3. `VSYNC宽（vsync len，垂直触发信号宽）`：信号脉冲会有个宽度，要不然都检查不到，这个宽度是根据芯片手册来决定的。 4. `VFP（vfront porch，垂直前肩期）`：一帧图片显示完成以后要过多久才会来VSYNC信号。 5. `VBP（vback porch，垂直后肩期）`：VSYNC信号发生以后要过多久才会来图片数据。 6. `HSYNC（水平同步信号）`：HSYNC 用于同步每行像素的扫描。当 HSYNC 信号跳变时，显示器会开始扫描下一行像素。 7. `Horizontal Total（水平总宽度）`：下面所有的参数之和 8. `HSYNC宽（hsync len，水平信号触发宽）`：信号脉冲会有个宽度，要不然都检查不到，这个宽度是根据芯片手册来决定的。 9. `HFP（hfront porch，水平前肩期）`：一行像素显示完成以后要过多久才会来HSYNC信号。 10. `HBP（hback porch，水平后肩期）`：HSYNC信号发生以后要过多久才会来下一行数据。 **为什么有这些参数？** 最主要的参数是VSYNC和HSYNC这两个，他们控制了屏幕什么时候换行以及什么时候扫描完成一帧图片。 VFP和VBP以及HFP和HBP都是辅助这两个信号的，为什么会有这几个辅助信号？因为屏幕反应需要时间，当你给他发VSYNC和HSYNC信号以后他不是马上就开始下一行或者下一帧。 hsync len和vsync len这两个是来决定HSYNC和VSYNC两个信号线触发脉冲时候的宽度，这个宽度要符合屏幕芯片要求值 hsync active和vsync active这两个是来决定HSYNC和VSYNC两个信号触发时候的电平状态，就和大家学stm32中断一样是高电平触发还是低电平触发 这就是我们为什么要调试屏幕参数的原因，因为每个屏幕对应的控制芯片不一样，所有给到值自然就不一样。 ![img](https://wiki.lckfb.com/storage/images/zh hans/tspi rk3566/project case/fat little cell phone/screen selection debugging/screen selection debugging_20240902_215831.png) **参数不对会怎么样？** 如果参数不对，最严重的是屏幕只点亮了背光但没有数据输出，轻一点的就是图像撕裂，闪屏等。 **刷新率怎么计算？** 刷新率 时钟 / ((总宽度Horizontal Total) * (总高度Vertical Total)) 刷新率 时钟 / ((有效宽度+HSYNC宽+HBP+HFP) * (有效高度+VSYNC宽+VBP+VFP)) 刷新率 72300000 / ((1366+32+160+48) * (768+6+32+3)) **泰山派点几种接口屏幕？最大分辨率是多少？是否支持同屏显示？** 泰山派支持hdmi，mipi，edp三种屏幕接口，hdmi最大支持4k，mipi最大支持1k，edp最大支持2k（泰山派2lane群友实测试2k 45），支持双屏同显。 泰山派支持的显示相关参数可以查看数据手册： > 【Rockchip_RK3566_Datasheet_V1.2 20220601.pdf】下载 > > 📌 [下载中心（点击跳转）](https://wiki.lckfb.com/zh hans/tspi rk3566/download center.html) > > 📌 在 `下载中心` >`百度网盘` >`第04章.【立创·泰山派】参考资料` >`【瑞芯微】官方资料` >`Linux` >`RK356X` >`Datasheet` `Rockchip_RK3566_Datasheet_V1.2 20220601.pdf`。 rk3566有两个输出通道分别是 `Video output 0` 和 `Video output 1` 他们分别能够输出的最大分辨率如下 ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202505141014016.png) 泰山派三个接口支持两个同屏幕显示，但是他们是同源的，如果做同屏显示的时候要保证屏幕方向一致，下面接口中划线是没有引出的接口 ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202505141014745.png) rk3566平台只有一 VOP，但是分出不同的 PORT，2 个 PORT 分别为 VP0、VP1。所以可以把 VP 理解为是一个 VOP。因为只有 VP0 支持 4K 及 HDR 等，所以 HDMI 默认绑定 VP0。显示接口连接关系。 ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202505141014714.png) ## HDMI屏 HDMI是一种比较通用的视频接口，支持热拔插，比如我们电脑显示器等大多数都是用的HDMI接口，相信大家在生活中都有使用过，相比eDP、MIPI等接口它基本不需要调试任何屏幕参数，即插即用且显示质量也非常高。 ## eDP屏 eDP是嵌入式显示端口，具有高数据传输速率，高带宽，高分辨率、高刷新率、低电压、简化接口数量等特点。现大多数笔记本电脑都是用的这种接口。整个eDP是很复杂的，这里我们不讲底层原理，我们先掌握如何用泰山派来驱动各种常见的eDP屏幕，eDP在使用上来讲也会比上面的HDMI复杂很多，HDMI屏幕基本不需要适配即插即用，虽然大多数eDP屏幕参数基本差不多，但是有些eDP还是需要我配置屏参的，如果屏幕参数不正确可能无法点亮。泰山派eDP接口位于板载顶部位置。 #### 分辨率与尺寸： 最大支持分辨率是主控决定的，通过数据手册可知RK3566的eDP接口最大支持2560x1600@60Hz，所以所选的eDP屏幕分辨率不大于这个分辨率就行，大于了点不亮，详细参考`Rockchip_RK3566_Datasheet_V1.2 20220601.pdf`。 常见的尺寸有11.6寸，13.3寸，15.6寸等，屏幕对尺寸没有太大要求可以根据自己的项目和喜好来选择。 #### 引脚接口： 接口线序要和泰山派一样，否则需要自己画转接板，泰山派的eDP接口用的是30Pin 0.5mm的FPC座，30Pin引脚大多数线序都是通用的，但大家不能盲目的看见一个30Pin的eDP屏幕就直接怼上去，还需要确定一下它的引脚顺序他用的排线是**正排线还是反排线，电源电源是否匹配**，还有**背光供电电压是否匹配**等。详情查看原理图第24页 **注意：接口不匹配会有烧屏和烧开发板的风险，不确定的情况下可以把这个表发给卖家，问他你的屏幕我这个接口是否可以点啊？** 引脚编号 名称 描述 注释 : : : : 1 CABC_ENIN CABC input 屏幕亮度自适应控制输入，可不接 2 H_GND High Speed Ground 高速地线 3 Lane1_N Complement Signal Link Lane 1 负极性信号链 1 4 Lane1_P True Signal Link Lane 1 正极性信号链 1 5 H_GND High Speed Ground 高速地线 6 Lane0_N Complement Signal Link Lane 0 负极性信号链 0 7 Lane0_P True Signal Link Lane 0 正极性信号链 0 8 H_GND High Speed Ground 高速地线 9 AUX_CH_P True Signal Auxiliary Channel 辅助信道正极性信号 10 AUX_CH_N Complement Signal Auxiliary Channel 辅助信道负极性信号 11 H_GND High Speed Ground 高速地线 12 LCD_VCC LCD logic power (3.3V) LCD 逻辑电源（3.3V） 13 LCD_VCC LCD logic power (3.3V) LCD 逻辑电源（3.3V） 14 BIST enable 自检测试使能 15 LCD_GND LCD Ground LCD 地线 16 LCD_GND LCD Ground LCD 地线 17 HPD HPD signal pin HPD 信号引脚 18 BL_GND Backlight ground 背光地线 19 BL_GND Backlight ground 背光地线 20 BL_GND Backlight ground 背光地线 21 BL_GND Backlight ground 背光地线 22 BL_ENABLE BL_PWR 背光电源使能 23 PWM_DIM System PWM signal input 背光PWM 信号输入 24 Hsync Hsync 水平同步信号 25 NC No Connection 未连接 26 BL_PWR Backlight 背光电源（典型5 21V）具体需根据屏幕手册确定 27 BL_PWR Backlight 背光电源（典型5 21V）具体需根据屏幕手册确定 28 BL_PWR Backlight 背光电源（典型5 21V）具体需根据屏幕手册确定 29 BL_PWR Backlight 背光电源（典型5 21V）具体需根据屏幕手册确定 30 NC No Connection 未连接 31 32 FPC的焊盘 大家不要误解了，接口是30Pin的这里31和32是FPC座的焊盘 ## MIPI屏 MIPI屏大家可能不是很熟悉，但如果提起智能机或者平板大家就耳熟能详了，对没错你每天看的智能手机基本上都是用的mipi接口的屏幕，mipi协议分为很多种，而且整个协议非常复杂，所以这里我们不讲底层原理，因为底层芯片原厂已经帮我实现了，我们先掌握如何通过修改泰山派的设备树来驱动mipi屏幕，点mipi屏幕比上面的eDP和HMDI都要复杂，eDP屏幕只需要配置屏参，mipi在屏还需要发送初始化序列。泰山派开发板板载了mipi dsi显示接口，位于板载背部位置，通过31PIN 0.3间距下接FPC接口引出。 #### 分辨率与尺寸： 最大支持分辨率是主控决定的，通过数据手册可知RK3566的mipi接口最大支持1920x1080@60Hz，所以所选的mipi屏幕分辨率不大于这个分辨率就行，详细参考`Rockchip_RK3566_Datasheet_V1.2 20220601.pdf` #### 引脚接口(重要)： 接口线序要和泰山派一样，否则需要自己画转接板，泰山派的mipi接口用的是31Pin 0.3mm的FPC座，31Pin引脚大多数线序都是通用的，但大家不能盲目的看见一个31Pin的mipi屏幕就直接怼上去，还需要确定一下它的引脚顺序，以及他用的排线是正排线还是反排线，还有背光供电电流等。详情查看[立创·泰山派开发板 嘉立创EDA开源硬件平台 (oshwhub.com)原理图第22页（点击跳转）](https://oshwhub.com/li chuang kai fa ban/li chuang tai shan pai kai fa ban) 注意：接口不匹配会有烧屏和烧开发板的风险 Pin No. Pin Name Description 描述 : : : : 1 MIPI_DSI_VCC_LED+ Power supply for LED[Anode] LED正极电源 2 MIPI_DSI_VCC_LED+ Power supply for LED[Anode] LED正极电源 3 MIPI_DSI_VCC_LED+ Power supply for LED[Anode] LED正极电源 4 NC No Connect 不连接 5 MIPI_DSI_VCC_LED Power supply for LED[Cathode] LED负极电源 6 MIPI_DSI_VCC_LED Power supply for LED[Cathode] LED负极电源 7 MIPI_DSI_VCC_LED Power supply for LED[Cathode] LED负极电源 8 MIPI_DSI_VCC_LED Power supply for LED[Cathode] LED负极电源 9 GND Ground 地线 10 GND Ground 地线 11 MIPI_DSI_2P MIPI data positive signal(2P) MIPI数据正极信号(2P) 12 MIPI_DSI_2N MIPI data negative signal(2N) MIPI数据负极信号(2N) 13 GND Ground 地线 14 MIPI_DSI_1P MIPI data positive signal(1P) MIPI数据正极信号(1P) 15 MIPI_DSI_1N MIPI data positive signal(1N) MIPI数据负极信号(1N) 16 GND Ground 地线 17 MIPI_DSI_CLKP MIPI CLK positive signal(CLKP) MIPI时钟正极信号(CLKP) 18 MIPI_DSI_CLKN MIPI CLK positive signal(CLKN) MIPI时钟负极信号(CLKN) 19 GND Ground 地线 20 MIPI_DSI_0P MIPI data positive signal(0P) MIPI数据正极信号(0P) 21 MIPI_DSI_0N MIPI data positive signal(0N) MIPI数据负极信号(0N) 22 GND Ground 地线 23 MIPI_DSI_3P MIPI data positive signal(3P) MIPI数据正极信号(3P) 24 MIPI_DSI_3N MIPI data negative signal(3N) MIPI数据负极信号(3N) 25 GND Ground 地线 26 NC No Connect 不连接 27 RESET Reset Pin 3.3V 复位引脚 3.3V 28 NC NC 不连接 29 VDDIO Logic power 3.3V 逻辑电源3.3V 30 VDD Logic power 3.3V 逻辑电源3.3V 31 VDD Logic power 3.3V 逻辑电源3.3V 原理图： ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202505151014632.png) #### lanes 泰山派最高支持4lanes的mipi屏幕，分别对于下面的、lane0(20,21)、lane1(14,15)、lane2(11,12)、lane3(23,24)四对引脚，mipi屏幕lanes的多少跟屏幕的分辨率有直接关系，屏幕分辨率越高lanes数量就越多，所以大家看有些小尺寸分辨率屏幕数据手册上面只有一条lanes差分对也是正常的，lanes的差分对个数在设备树中可以配置。 ![img](https://wiki.lckfb.com/storage/images/zh hans/tspi rk3566/project case/fat little cell phone/screen selection debugging/screen selection debugging_20240902_151638.png) #### 背光电路 屏幕大小不同对电流的要求不同，可以理解为大一点的屏幕里面窜的背光LED相对会多一点，所以我们选择屏幕以后需要去确定屏幕的数据手册，它的背光典型电流是多少，如果我们背光驱动电流超出很多会有屏幕背光发烫和烧背光的风险。 背光驱动电路电流： 数据手册：SY7201ABC数据手册.pdf 通过SY7201ABC来实现背光控制和恒流输出。 PWM5_LCD_BL 引脚是芯片输出的PWM引脚用来调屏幕亮度的。 MIPI_DSI_VCC_LED+和MIPI_DSI_VCC_LED 分别对应LED正极电源和LED负极电源，这里很重要，我们所要确定的电流大小就是这两个点的电流大小 在PWM引脚为高电平的情况下，SY7201ABC到底输出多大的电流是由芯片的FB脚来决定的它的 IOUT计算公式，IOUT 0.2V/R（R (R95xR96)/(R95+R96)），最终得出IOUT 0.2V/1.8≈110mA 注意：上面我们得出LED的背光电流输出的电流是110mA，所以我们选屏幕的时候要确定背光电路允许电流在110mA以上如果屏幕背光电流在我们背光电路电流以下轻则屏幕发烫重则烧屏，那背光电路我们为什么选择110mA这个值呢，因为8寸的mipi屏幕普遍是在130mA左右，而且8寸屏是做广告机的最常用的，所以我们就选了这个典型值。 ![img](https://wiki.lckfb.com/storage/images/zh hans/tspi rk3566/project case/fat little cell phone/screen selection debugging/screen selection debugging_20240902_141301.png) 确定屏幕背光电流： 找到数据手册中的LED cureent：我们可以发现这款屏幕它的典型电流就是140mA，刚好我们上面的背光驱动电流没有超过所以可以正常驱动 ![img](https://wiki.lckfb.com/storage/images/zh hans/tspi rk3566/project case/fat little cell phone/screen selection debugging/screen selection debugging_20240902_094647.png)"},"/note/Linux/泰山派/2025-5-17-04触摸驱动.html":{"title":"触摸驱动","content":"# 触摸驱动 ## 转接板 由于不同的触摸驱动使用的引脚是不同的, 所以需要更具引脚的顺序画一个转接板 ## 驱动 > Z:\\rope\\kernel\\drivers\\input\\touchscreen\\gt9xx ![image 20250518105451463](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202505181054619.png) 在上一级的配置文件里面可以找到有个这个芯片的配置 ![image 20250518105611926](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202505181056010.png) ![image 20250518105641491](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202505181056544.png) > ~/Taishan/rope/kernel$ make ARCH arm64 menuconfig > > 使用这个命令可以进入配置页面 > > 1. / : 进入搜索界面 > 2. 找到gt9xx > 3. ![image 20250518110104218](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202505181101311.png) > 4. 选1 > 5. 因为我们刚刚保存的是.config每次编译的时候脚本都会去组合生产.config所以你的配置就会被覆盖掉，这也是很多小伙伴经常提问的为什么配置没生效，正确的方式是生成defconfig然后并覆盖到之前的`arch/arm64/configs/`下代替我们使用的defconfig `make ARCH arm64 savedefconfig` > 6. 我们SDK使用的是`rockchip_linux_defconfig`，所以把生成的defconfig复制过去代替`rockchip_linux_defconfig`我用的是repo带git版本所有我就直接复制过去了，如果你没有git管理就先备份一个然后在代替过去，避免搞坏了回不去了。`mv defconfig arch/arm64/configs/rockchip_linux_defconfig` ### 设备树 泰山触摸相关的设备树`SDK\\kernel\\arch\\arm64\\boot\\dts\\rockchip\\tspi rk3566 dsi v10.dtsi`中添加，根据`GT9xx_Driver_for_Android_V2.4_2014112801dtsi\\goodix gt9xx.dtsi`参考修改而来 ```shell &i2c1 { status \"okay\"; ts@5d { compatible \"goodix,gt9xx\"; reg <0x5d>; tp size <89>; max x <1280>; max y <800>; touch gpio <&gpio1 RK_PA0 IRQ_TYPE_LEVEL_LOW>; reset gpio <&gpio1 RK_PA1 GPIO_ACTIVE_LOW>; }; }; ``` #### I2C1 ``` //i2c1 节点追加 &i2c1 { status \"okay\"; /*加触摸*/ }; ``` 硬件部分通过原理图可以知道触摸接口用的是i2c1所以我们就直接在i2c1中写触摸。我们原理图中已经对数据线和时钟先进行了上拉。 ## 自定义 ### 驱动测试 ```c #include <linux/kernel.h> #include <linux/hrtimer.h> #include <linux/i2c.h> #include <linux/input.h> #include <linux/module.h> #include <linux/delay.h> #include <linux/i2c.h> #include <linux/proc_fs.h> #include <linux/string.h> #include <linux/uaccess.h> #include <linux/vmalloc.h> #include <linux/interrupt.h> #include <linux/io.h> #include <linux/of_gpio.h> #include <linux/gpio.h> #include <linux/slab.h> #include <linux/timer.h> #include <linux/input/mt.h> #include <linux/random.h> #if 1 #define MY_DEBUG(fmt,arg...) printk(\"MY_TOUCH:%s %d \"fmt\"\",__FUNCTION__,__LINE__,##arg); #else #define MY_DEBUG(fmt,arg...) #endif struct input_dev *input_dev; static struct timer_list my_timer; void my_timer_callback(struct timer_list *timer) { unsigned int x, y; // 定义无符号整型变量 x 和 y static bool isDown false; // 定义静态布尔变量 isDown，并初始化为 false // 生成随机数 x，取模得到的值在 [0, 1279] 范围内 get_random_bytes(&x, sizeof(x)); x % 1280; // 生成随机数 y，取模得到的值在 [0, 1279] 范围内 get_random_bytes(&y, sizeof(y)); y % 800; // 打印调试信息，包括 isDown 的值、x 和 y 的值 MY_DEBUG(\"isDown:%d x:%d y:%d!\\n\", isDown, x, y); // 设定输入设备的触摸槽位 input_mt_slot(input_dev, 0); // 报告输入设备的触摸槽位状态，MT_TOOL_FINGER 表示手指状态，isDown 表示是否按下 input_mt_report_slot_state(input_dev, MT_TOOL_FINGER, isDown); // 翻转 isDown 的值模仿手抬起和按下 isDown !isDown; // 报告输入设备的绝对位置信息：x、y 坐标，触摸面积，触摸宽度 input_report_abs(input_dev, ABS_MT_POSITION_X, x); input_report_abs(input_dev, ABS_MT_POSITION_Y, y); // 报告输入设备的指针仿真信息 input_mt_report_pointer_emulation(input_dev, true); // 同步输入事件 input_sync(input_dev); // 重新设置定时器，2 秒后再次触发 mod_timer(timer, jiffies + msecs_to_jiffies(200)); } static int my_touch_ts_probe(struct i2c_client *client, const struct i2c_device_id *id) { int ret; // 打印调试信息 MY_DEBUG(\"locat\"); // 分配输入设备对象 input_dev devm_input_allocate_device(&client >dev); if (!input_dev) { dev_err(&client >dev, \"Failed to allocate input device.\\n\"); return ENOMEM; } // 设置输入设备的名称和总线类型 input_dev >name \"my touch screen\"; input_dev >id.bustype BUS_I2C; /*设置触摸 x 和 y 的最大值*/ // 设置输入设备的绝对位置参数 input_set_abs_params(input_dev, ABS_MT_POSITION_X, 0, 1280, 0, 0); input_set_abs_params(input_dev, ABS_MT_POSITION_Y, 0, 800, 0, 0); // 初始化多点触摸设备的槽位 ret input_mt_init_slots(input_dev, 5, INPUT_MT_DIRECT); if (ret) { dev_err(&client >dev, \"Input mt init error\\n\"); return ret; } // 注册输入设备 ret input_register_device(input_dev); if (ret) return ret; // 初始化定时器 timer_setup(&my_timer, my_timer_callback, 0); // 设置定时器，5 秒后第一次触发 mod_timer(&my_timer, jiffies + msecs_to_jiffies(5000)); return 0; } static int my_touch_ts_remove(struct i2c_client *client) { MY_DEBUG(\"locat\"); return 0; } static const struct of_device_id my_touch_of_match[] { { .compatible \"my,touch\", }, { /* sentinel */ } }; MODULE_DEVICE_TABLE(of, my_touch_of_match); static struct i2c_driver my_touch_ts_driver { .probe my_touch_ts_probe, .remove my_touch_ts_remove, .driver { .name \"my touch\", .of_match_table of_match_ptr(my_touch_of_match), }, }; static int __init my_ts_init(void) { MY_DEBUG(\"locat\"); return i2c_add_driver(&my_touch_ts_driver); } static void __exit my_ts_exit(void) { MY_DEBUG(\"locat\"); i2c_del_driver(&my_touch_ts_driver); } module_init(my_ts_init); module_exit(my_ts_exit); MODULE_LICENSE(\"GPL\"); MODULE_DESCRIPTION(\"My touch driver\"); MODULE_AUTHOR(\"1458612070@qq.com\"); ``` ### 实际实现 ```c #include \"linux/stddef.h\" #include <linux/kernel.h> #include <linux/hrtimer.h> #include <linux/i2c.h> #include <linux/input.h> #include <linux/module.h> #include <linux/delay.h> #include <linux/i2c.h> #include <linux/proc_fs.h> #include <linux/string.h> #include <linux/uaccess.h> #include <linux/vmalloc.h> #include <linux/interrupt.h> #include <linux/io.h> #include <linux/of_gpio.h> #include <linux/gpio.h> #include <linux/slab.h> #include <linux/timer.h> #include <linux/input/mt.h> #include <linux/random.h> #define MY_SWAP(x, y) do{\\ typeof(x) z x;\\ x y;\\ y z;\\ }while (0) #if 1 #define MY_DEBUG(fmt,arg...) printk(\"MY_TOUCH:%s %d \"fmt\"\",__FUNCTION__,__LINE__,##arg); #else #define MY_DEBUG(fmt,arg...) #endif struct my_touch_dev { struct i2c_client *client; struct input_dev *input_dev; int rst_pin; int irq_pin; u32 abs_x_max; u32 abs_y_max; int irq; }; s32 my_touch_i2c_read(struct i2c_client *client,u8 *addr,u8 addr_len, u8 *buf, s32 len) { struct i2c_msg msgs[2]; s32 ret 1; msgs[0].flags !I2C_M_RD; msgs[0].addr client >addr; msgs[0].len addr_len; msgs[0].buf &addr[0]; msgs[1].flags I2C_M_RD; msgs[1].addr client >addr; msgs[1].len len; msgs[1].buf &buf[0]; ret i2c_transfer(client >adapter, msgs, 2); if(ret 2)return 0; if(addr_len 2){ MY_DEBUG(\"I2C Read: 0x%04X, %d bytes failed, errcode: %d! Process reset.\", (((u16)(addr[0] << 8)) addr[1]), len, ret); }else { MY_DEBUG(\"I2C Read: 0x%02X, %d bytes failed, errcode: %d! Process reset.\", addr[0], len, ret); } return 1; } s32 my_touch_i2c_write(struct i2c_client *client, u8 *addr, u8 addr_len, u8 *buf,s32 len) { struct i2c_msg msg; s32 ret 1; u8 *temp_buf; msg.flags !I2C_M_RD; msg.addr client >addr; msg.len len+addr_len; temp_buf kzalloc(msg.len, GFP_KERNEL); if (!temp_buf){ goto error; } // 装填地址 memcpy(temp_buf, addr, addr_len); // 装填数据 memcpy(temp_buf + addr_len, buf, len); msg.buf temp_buf; ret i2c_transfer(client >adapter, &msg, 1); if (ret 1) { kfree(temp_buf); return 0; } error: if(addr_len 2){ MY_DEBUG(\"I2C Read: 0x%04X, %d bytes failed, errcode: %d! Process reset.\", (((u16)(addr[0] << 8)) addr[1]), len, ret); }else { MY_DEBUG(\"I2C Read: 0x%02X, %d bytes failed, errcode: %d! Process reset.\", addr[0], len, ret); } if (temp_buf) kfree(temp_buf); return 1; } static irqreturn_t my_touch_irq_handler(int irq, void *dev_id) { s32 ret 1; struct my_touch_dev *ts dev_id; u8 addr[2] {0x81,0x4E}; u8 clear_buf[1] {0}; u8 point_data[1+8*1] {0};//1个状态位置+10个触摸点，一个点是8个数据组成 u8 touch_num 0; u8 buf_stats 0; u8 *coor_data; int id,input_x,input_y,input_w; MY_DEBUG(\"irq\"); ret my_touch_i2c_read(ts >client, addr,sizeof(addr), point_data, sizeof(point_data)); if (ret < 0){ MY_DEBUG(\"I2C write end_cmd error!\"); } touch_num point_data[0]&0x0f; buf_stats point_data[0]&0x80>>7; MY_DEBUG(\"0x814E :%0x,touch_num:%d,buf_stats:%d\",point_data[0],touch_num,buf_stats); //获取 if (touch_num){ coor_data &point_data[1]; id coor_data[0] & 0x0F; input_x coor_data[1] (coor_data[2] << 8); input_y coor_data[3] (coor_data[4] << 8); input_w coor_data[5] (coor_data[6] << 8); MY_DEBUG(\"id:%d,x:%d,y:%d,w:%d\",id,input_x,input_y,input_w); // // 设定输入设备的触摸槽位 input_mt_slot(ts >input_dev, 0); // 报告输入设备的触摸槽位状态，MT_TOOL_FINGER 表示手指状态，isDown 表示是否按下 input_mt_report_slot_state(ts >input_dev, MT_TOOL_FINGER, true); // 翻转 isDown 的值模仿手抬起和按下 MY_SWAP(input_x, input_y); // 报告输入设备的绝对位置信息：x、y 坐标，触摸面积，触摸宽度 input_report_abs(ts >input_dev, ABS_MT_POSITION_X, 800 input_x); input_report_abs(ts >input_dev, ABS_MT_POSITION_Y, input_y); }else { input_mt_report_slot_state(ts >input_dev, MT_TOOL_FINGER, false); } // 清除寄存器，要不然回反复触发 ret my_touch_i2c_write(ts >client, addr,sizeof(addr), clear_buf, sizeof(clear_buf)); if (ret < 0){ MY_DEBUG(\"I2C write end_cmd error!\"); } // 报告输入设备的指针仿真信息 input_mt_report_pointer_emulation(ts >input_dev, true); // 同步输入事件 input_sync(ts >input_dev); return IRQ_HANDLED; } s32 gt9271_read_version(struct i2c_client *client) { s32 ret 1; u8 addr[2] {0x81,0x40}; u8 buf[6] {0}; ret my_touch_i2c_read(client, addr,sizeof(addr), buf, sizeof(buf)); if (ret < 0){ MY_DEBUG(\"GTP read version failed\"); return ret; } if (buf[5] 0x00){ MY_DEBUG(\"IC Version: %c%c%c_%02x%02x\", buf[0], buf[1], buf[2], buf[5], buf[4]); } else{ MY_DEBUG(\"IC Version: %c%c%c%c_%02x%02x\", buf[0], buf[1], buf[2], buf[3], buf[5], buf[4]); } return ret; } static int my_touch_ts_probe(struct i2c_client *client, const struct i2c_device_id *id) { int ret; struct my_touch_dev *ts; struct device_node *np client >dev.of_node; // 打印调试信息 MY_DEBUG(\"locat\"); // ts kzalloc(sizeof(*ts), GFP_KERNEL); ts devm_kzalloc(&client >dev, sizeof(*ts), GFP_KERNEL); if (ts NULL){ dev_err(&client >dev, \"Alloc GFP_KERNEL memory failed.\"); return ENOMEM; } ts >client client; i2c_set_clientdata(client, ts); if (of_property_read_u32(np, \"max x\", &ts >abs_x_max)) { dev_err(&client >dev, \"no max x defined\\n\"); return EINVAL; } MY_DEBUG(\"abs_x_max:%d\",ts >abs_x_max); if (of_property_read_u32(np, \"max y\", &ts >abs_y_max)) { dev_err(&client >dev, \"no max y defined\\n\"); return EINVAL; } MY_DEBUG(\"abs_x_max:%d\",ts >abs_y_max); //找复位gpio ts >rst_pin of_get_named_gpio(np, \"reset gpio\", 0); //申请复位gpio ret devm_gpio_request(&client >dev,ts >rst_pin,\"my touch touch gpio\"); if (ret < 0){ dev_err(&client >dev, \"gpio request failed.\"); return ENOMEM; } //找中断引进 ts >irq_pin of_get_named_gpio(np, \"touch gpio\", 0); /* 申请使用管脚 */ ret devm_gpio_request_one(&client >dev, ts >irq_pin, GPIOF_IN, \"my touch touch gpio\"); if (ret < 0) return ret; gpio_direction_output(ts >rst_pin,0); msleep(20); gpio_direction_output(ts >irq_pin,0); msleep(2); gpio_direction_output(ts >rst_pin,1); msleep(6); gpio_direction_output(ts >irq_pin, 0); gpio_direction_output(ts >irq_pin, 0); msleep(50); //申请中断 ts >irq gpio_to_irq(ts >irq_pin); if(ts >irq){ ret devm_request_threaded_irq(&(client >dev), ts >irq, NULL, my_touch_irq_handler, IRQF_TRIGGER_FALLING IRQF_ONESHOT , client >name, ts); if (ret ! 0) { MY_DEBUG(\"Cannot allocate ts INT!ERRNO:%d\\n\", ret); return ret; } } // 分配输入设备对象 ts >input_dev devm_input_allocate_device(&client >dev); if (!ts >input_dev) { dev_err(&client >dev, \"Failed to allocate input device.\\n\"); return ENOMEM; } // 设置输入设备的名称和总线类型 ts >input_dev >name \"my touch screen\"; ts >input_dev >id.bustype BUS_I2C; /*设置触摸 x 和 y 的最大值*/ // 设置输入设备的绝对位置参数 input_set_abs_params(ts >input_dev, ABS_MT_POSITION_X, 0, 800, 0, 0); input_set_abs_params(ts >input_dev, ABS_MT_POSITION_Y, 0, 1280, 0, 0); // 初始化多点触摸设备的槽位 ret input_mt_init_slots(ts >input_dev, 5, INPUT_MT_DIRECT); if (ret) { dev_err(&client >dev, \"Input mt init error\\n\"); return ret; } // 注册输入设备 ret input_register_device(ts >input_dev); if (ret) return ret; gt9271_read_version(client); return 0; } static int my_touch_ts_remove(struct i2c_client *client) { struct my_touch_dev *ts i2c_get_clientdata(client); MY_DEBUG(\"locat\"); input_unregister_device(ts >input_dev); return 0; } static const struct of_device_id my_touch_of_match[] { { .compatible \"my,touch\", }, { /* sentinel */ } }; MODULE_DEVICE_TABLE(of, my_touch_of_match); static struct i2c_driver my_touch_ts_driver { .probe my_touch_ts_probe, .remove my_touch_ts_remove, .driver { .name \"my touch\", .of_match_table of_match_ptr(my_touch_of_match), }, }; static int __init my_ts_init(void) { MY_DEBUG(\"locat\"); return i2c_add_driver(&my_touch_ts_driver); } static void __exit my_ts_exit(void) { MY_DEBUG(\"locat\"); i2c_del_driver(&my_touch_ts_driver); } module_init(my_ts_init); module_exit(my_ts_exit); MODULE_LICENSE(\"GPL\"); MODULE_DESCRIPTION(\"My touch driver\"); MODULE_AUTHOR(\"wucaicheng@qq.com\"); ``` ### 设备树 ``` &i2c1 { status \"okay\"; my_touch@5d { compatible \"my,touch\"; reg <0x5d>; tp size <89>; max x <1280>; max y <800>; touch gpio <&gpio1 RK_PA0 IRQ_TYPE_LEVEL_LOW>; reset gpio <&gpio1 RK_PA1 GPIO_ACTIVE_HIGH>; }; }; ``` ##### 编译进入内核 前面我们my_touch目录下的Makefile中是obj y所以是编入到内核的，我们只需要重新编译内核并单独烧录内核就可以生效。单独编译和烧录内核的方法我们前面介绍了很多次了所以不在演示 ##### 编译成模块 编译进内核并单独烧入Boot带emmc操作起来很方便，如果没有emmc的可以生成模块ko并把ko传到泰山派上加载，编译成模块需要把my_touch目录下Makefile改成obj m ``` #如果编译成.ko的话就选obj m,如果编译到内核就obj y obj m + my_touch.o ``` 单独编译驱动没有报错成功会生成my_touch.ko ``` kernel$ make ARCH arm64 C . M ./drivers/input/touchscreen/my_touch ``` `make` 命令用于构建 Linux 内核或内核模块。 `ARCH arm64` 指定了目标架构为 64 位 ARM 架构 ` C` . 指定了内核源代码目录为当前目录 `M ./drivers/input/touchscreen/my_touch/` 指定了我们触摸也就是要构建的内核模块所在的相对路径为 `./drivers/input/touchscreen/my_touch/`。 ![img](https://wiki.lckfb.com/storage/images/zh hans/tspi rk3566/project case/fat little cell phone/touch drive/touch drive_20240902_090627.png) ##### 加载my_touch.ko 通过adb把my_touch.ko push到泰山派里面去 ``` adb root && adb remount && adb push Z:\\tspi\\Android11_20231007\\PublicVersion\\kernel\\drivers\\input\\touchscreen\\my_touch\\my_touch.ko /vendor/lib/modules ``` `adb root`: 这个命令会尝试获取 Android 设备的 root 权限。在有些设备上，访问 `/vendor/lib/modules` 目录需要 root 权限。 `adb remount`: 这个命令会重新挂载文件系统，通常用于将文件系统从只读模式切换为可读写模式。因为你要往 `/vendor/lib/modules` 目录写入文件，所以需要将其挂载为可读写。 `adb push Z:\\tspi\\Android11_20231007\\PublicVersion\\kernel\\drivers\\input\\touchscreen\\my_touch\\my_touch.ko /vendor/lib/modules: 这个命令的格式是 adb push <本地路径> <目标路径>`，它会将本地路径下的文件推送到目标路径。在这里，`my_touch.ko` 是你要推送的文件，它位于 `Z:\\tspi\\Android11_20231007\\PublicVersion\\kernel\\drivers\\input\\touchscreen\\my_touch\\` 这个本地路径下。它将被推送到 Android 设备的 `/vendor/lib/modules` 目录中。 ![img](https://wiki.lckfb.com/storage/images/zh hans/tspi rk3566/project case/fat little cell phone/touch drive/touch drive_20240902_165340.png) adb进入shell ![img](https://wiki.lckfb.com/storage/images/zh hans/tspi rk3566/project case/fat little cell phone/touch drive/touch drive_20240902_112457.png) 安装驱动 ``` rk3566_tspi:/ # insmod /vendor/lib/modules/my_touch.ko ``` 查看驱动是否安装成功 ``` rk3566_tspi:/ # lsmod Module Size Used by my_touch 16384 0 bcmdhd 1175552 0 ``` ![img](https://wiki.lckfb.com/storage/images/zh hans/tspi rk3566/project case/fat little cell phone/touch drive/touch drive_20240902_052017.png) 查看日志可以看到我们模拟的驱动在上报数据了 ![img](https://wiki.lckfb.com/storage/images/zh hans/tspi rk3566/project case/fat little cell phone/touch drive/touch drive_20240902_205136.png)"},"/note/Linux/泰山派/2025-5-11-02设备树.html":{"title":"设备树","content":"# 设备树 通俗的讲设备树就是用于描述硬件信息的一个配件文件，因为他描述的时候的拓扑结构很像树，所以就叫做设备树。详细的讲设备树是一种树状的结构，由`节点（Node）`和`属性（Property）`组成。每个节点描述一个硬件设备或资源，节点通过父子关系和兄弟关系进行连接。如下所示以一个根节点开始。根节点可以包含一些全局属性和设备节点。每个设备节点以一个路径标识符（例如/cpu@0）和多个属性（键值对）组成。设备节点可以包含子节点，形成嵌套的层次结构。属性描述了设备的特性，例如设备的名称、类型、寄存器地址、中断信息等。设备节点的路径和属性组合在一起提供了设备树的完整描述，以描绘硬件系统中各个设备的层次结构和配置信息。 ![image 20250511232743629](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202505112327817.png) ### [常见的设备树术语：](https://wiki.lckfb.com/zh hans/tspi rk3566/project case/fat little cell phone/device tree.html#常见的设备树术语) `设备树（Device Tree）`：一种用于描述硬件设备和资源连接的数据结构，是一种中立、可移植的设备描述方法。 `DTS（设备树源文件 Device Tree Source）`：设备树的源码文件，可以理解成c语言的.c文件。 `DTSI （设备树包含文件 Device Tree Include）`：包含了设备树源文件中的可重复使用的部分，可以通过 `#include` 指令在其他设备树源文件中引用。通常用于共享公共的设备树定义和配置，可以理解成c语言的.h文件。 `DTC（设备树编译器 Device Tree Compiler）`：用于将设备树源文件（DTS）编译成设备树二进制文件（DTB）的工具，可以理解成c语言的gcc编译器。 `DTB（设备树二进制文件 Device Tree Blob）`：设备树源文件编译生成的二进制文件，可以理解成c语言的.hex或者bin。 `节点（Node）`：在设备树中用来描述硬件设备或资源的一个独立部分。每个节点都有一个唯一的路径和一组属性。 `属性（Property）`：用于描述节点的特征和配置信息，包括设备的名称、地址、中断号、寄存器配置等。 `属性值（Property Value）`：属性中的具体数据，可以是整数、字符串、布尔值等各种类型。 `父节点和子节点（Parent Node and Child Node）`：在设备树中，每个节点都可以有一个父节点和多个子节点，用于描述设备之间的连接关系。 我们通常使用`.dts`（设备树源文件）或`.dtsi`（设备树源文件包含文件）来写设备树。编写完成以后通过DTC工具编译生成 `.dtb`（设备树二进制）文件，内核在启动时加载这个二进制文件来获得必要的硬件信息。DTS、DTSI、DTC、DTB之间的关系如下图： ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202505122054365.png) > Y:\\rope\\kernel\\arch\\arm64\\boot\\dts\\rockchip > > ![image 20250512211030941](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202505122110034.png) ``` rk3568.dtsi：主控相关配置 rk3566.dtsi：包含了rk3568.dtsi头文件 tspi rk3566 core v10.dtsi：tspi核心配置层，这里是几乎后期不需要怎么改动 tspi rk3566 edp v10.dtsi：edp显示屏幕相关的配置 tspi rk3566 dsi v10.dtsi：mipi显示屏幕相关的配置 tspi rk3566 hdmi v10.dtsi: hdmi显示屏相关的配置 tspi rk3566 csi v10.dtsi：mipi摄像头相关配置 tspi rk3566 gmac1 v10.dtsi： 网口相关配置 tspi rk3566 user v10.dts：用户自定义相关配置他会去包含前面的所有 ``` ``` tspi rk3566 user v10.dts rk3566.dtsi rk3568.dtsi rk3568 dram default timing.dtsi rk3568 android.dtsi tspi rk3566 core v10.dtsi tspi rk3566 edp v10.dtsi tspi rk3566 dsi v10.dtsi tspi rk3566 hdmi v10.dtsi tspi rk3566 csi v10.dtsi tspi rk3566 gmac1 v10.dtsi ``` 使用`Y:\\rope\\kernel\\scripts\\dtc`文件里面的dtc进行编译, 是内核编译出来的工具 > kernel/.config文件里面 > > ![image 20250512211916503](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202505122119579.png) ### 编译（从 .dts 和 .dtsi到 .dtb） 将 Device Tree 源文件（.dts）编译为 Device Tree Blob（.dtb）编译命令格式如下： ``` dtc I dts O dtb o output_file.dtb input_file.dts ``` ` I dts` 指定输入文件格式是 Device Tree Source。 ` O dtb` 指定输出文件格式是 Device Tree Blob。 ` o output_file.dtb` 设定输出文件的名称。 `input_file.dts` 是你想编译的 .dts 文件。 ### 反编译（从 .dtb 到 .dts） 将 Device Tree Blob（.dtb）反编译为 Device Tree 源文件（.dts）： ``` dtc I dtb O dts o output_file.dts input_file.dtb ``` ` I dtb` 指定输入文件格式是 Device Tree Blob。 ` O dts` 指定输出文件格式是 Device Tree Source。 ` o output_file.dts` 设定输出文件的名称。 input_file.dtb 是你想反编译的 .dtb 文件。 ### 基础语法 前面我们已经知道设备树主要是由节点和属性构成，这里为方便理解可以把设备树类比成旅游景区的姻缘树。 1. `节点（Node）`： + 在设备树中，节点代表了硬件中的一个逻辑单元或部件，它可以是一个复杂的组件，比如一个CPU，也可以是简单的对象，如一个I/O端口。 + 比喻姻缘树，节点可以对应到姻缘树的树根、主干和支干。树根可以看作是整个姻缘树的起点，对应到设备树中的根节点，它代表了整个硬件系统的起始点。主干和支干则分别对应到设备树中的各级子节点，它们代表了各个不同的设备和子系统。 1. `属性（Property）`： + 在设备树中，属性是节点的一部分，它们为节点提供了额外的描述信息。 + 比喻姻缘树，属性可以对应到姻缘绳（即红色祈福牌）。这些祈福牌上写有的信息（如名字、年龄等）就如同设备树中的属性，为游客（即设备和子系统）提供了额外的信息或配置。 + 祈福牌（属性）可以绑定在姻缘树（设备树）的任何一个树干（节点）上，这意味着不同的设备和子系统可以有不同的属性集，这些属性集描述了它们各自的特性和配置需求。 #### 版本 在设备树文件中通过 `/dts v1/`;来指定版本，一般写在dts的第一行，这个声明非常重要的，因为他描述了了设备树文件所使用的语法和规范版本。如果没有这个声明，设备树编译器可能会无法正确解释文件中的语法，导致编译错误或者设备树在加载时出现问题。 ``` /dts v1/; // 指定这是一个设备树文件的版本（v1） ``` #### 注释 和C语言一样，有两种方法分别如下： ``` /* 这是一个注释 */ // 这是一个注释 ``` #### 头文件 前面我们已经讲了dts是源文件，头文件是dtsi，在设备树中主要有两种方法去包含头文件 **方法一：** 通过设备树的语法包含头文件 ``` /include/ \"xxxx.dtsi\" //xxxx是你要包含的文件名称 ``` **方法二** 通过c语言语法包含头文件，他不止能包含dtsi文件还可以包含.h文件, 这种包含的文件可以使用C语言里面的宏定义 ``` #include \"xxxx.dtsi\" //xxxx是你要包含的dtsi文件名称 或者 #include \"xxxx.h\" //xxxx是你要包含的.h文件名称 ``` 不过需要注意的是`#include`是非设备树语法他是c语言语法，所以直接用dts编译是会报错的，我们需要先用cpp编译生成一个预编译文件，然后在用dtc编译这个预编译文件生成dtb，瑞芯微的设备树就是这么干的。 ##### 预编译命令 使用`cpp`工具将xxxx`.dts`文件中的头文件展开，生成一个临时文件xxxx`.dtb.dts.tmp` ``` cpp nostdinc I[dir_with_dts_includes] x assembler with cpp [src_dts_file] > [tmp_dts_file] ``` ` nostdinc`：不使用标准的系统头文件目录，避免不必要的报错。 ` I[dir_with_dts_includes]`：这里是头文件的目录，如果就是在当前目录就用` I.`。 `[src_dts_file]` 是你的源设备树文件（`.dts`）。 `[tmp_dts_file]` 是预处理后的输出文件，为了和瑞芯微保持统一我们到时候命名后最写成 `xxxxxxxxxxxx.dtb.dts.tmp`。 ![image 20250512215252304](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202505122152546.png) > 这里的根节点使用model名字 > cpp nostdinc I. x assembler with cpp input_file.dts > device_tree.dtb.dts.tmp > > dtc I dts O dtb o device_tree.dtb device_tree.dtb.dts.tmp #### 根节点 设备树的根节点是设备树结构中的顶层节点，也是整个设备树的入口点，类比成前面姻缘树的根，根节点的名字是`/` ```json /dts v1/; // 指定这是一个设备树文件的版本（v1） / {// 根节点定义开始 /* 这里是根节点，它代表整个设备树的基础。 在这里可以定义一些全局属性或者包含更多的子节点。 */ }; // 根节点定义结束 ``` ### 子节点 子节点格式通常由以下几个基本元素组成： **节点名和可选的单元地址**：节点名通常是相关硬件设备或功能的名称，可选的单元地址表示设备的特定实例或资源，如内存地址、设备ID等。 **一对花括号** {}：花括号用于封装节点的属性和子节点内容，包括开始花括号和结束花括号。 **属性定义**：节点中定义了一系列属性，属性有名称和值，具体的值可以是数字、字符串或者数据数组等。属性和值之间使用等号 相连。 **子节点定义**：一个节点可以包含多个子节点，这些子节点又可以进一步定义更为详细的属性或包含它们自己的子节点，从而创建一个层次结构。 ```json 标签: 节点名[@单元地址] { // 标签: 和 @单元地址不是必须 子节点名1 { 子节点1的子节点 { }; }; 子节点名2 { }; }; ``` #### 命名 节点的名称应该描述节点所代表的硬件设备或者功能，让人能够容易理解节点的作用，见面知意。 ##### 小写字母，下划线或连字符（习惯）： 节点名通常全使用小写字母，反正我看官方的案例里面全部用的都是小写所以我们也保持风格统一。如果节点名包含多个单词，通常使用下划线(_)或连字符( )来分隔这些单词。 ##### 遵循已有的约定（习惯）： 如果你要描述的硬件信息是已经有现有描述过的，就尽量不要自己命名，可以去设备树文件里面复制参考官方的。 ##### 避免特殊字符（规则）： 名称中应避免使用空格、点（.）、斜杠（/）、反斜杠（\\）等特殊字符。前面习惯你不注意还是可以用的但是，这个如果你不注意可能会直接报错 错误演示： > 最后一行要有一个空行 ##### 唯一性（规则）： 在设备树的同一级别层次内，节点名称应唯一。如果相同类型的节点有多个实例，通常在节点名称后附加一个索引号或实例特有的信息来区分。 可以使用地址区分不同的子节点 ##### 地址和类型（可选）： 节点名称中可以包含节点所代表的硬件的地址信息和类型。例如，i2c@1c2c0000指的是位于1c2c0000位置的I2C控制器。注意注意：这个并不是实际寄存器只是拿来看的增加可读性和避免命名冲突的，实际的地址我们后面属性会讲reg属性才是实际描述的寄存器地址。 #### 标签(重要) 上面子节点格式中我们还提到了标签，标签在节点名中不是必须的，但是我们可以通过他来更方便的操作节点，在设备树文件中有大量使用到。下面例子中定义了标签，并通过引用uart1标签方式往serial@80000000中追加一个node_add2节点。 创建一个名为device_tree.dts的文件并填入以下内容 ```json /dts v1/; / { // 串口设备示例，地址不同，uart1是标签 uart1: serial@80000000 { node_add1{ }; }; // 串口设备示例，地址不同，uart2是标签 uart2: serial@90000000 { }; // I2C 控制器及设备示例，i2c1是标签 i2c1: i2c@91000000 { }; // USB 控制器示例，USB是标签 usb1: usb@92000000 { }; }; &uart1{ // 通过引用标签的方式往 serial@80000000 中追加一个节点非覆盖。 node_add2{ }; }; ``` > 反编译的结果里面没有标签, 并且回答数据加到实际的节点里面 #### 别名(特殊节点,了解即可) aliases是一种在设备树中提供简化标识符的方式。它们主要用来为复杂的节点提供一个简单的别名，目的是为了方便引用，和标签有异曲同工之妙，但他们的作用是用途都不同，标签是针对特定设备节点的命名，而别名是针对设备节点路径的命名。 ```json //通过aliases来定义别名 aliases{ //这里面描述的都是别名 [别名] [标签] [别名] [节点路径] }; ``` > **标签** 是**源码级**的引用，用于在设备树源文件（`.dts`、`.dtsi`）内部方便地引用节点。它允许你在一个地方定义节点，然后在另一个地方通过`&label`来引用它并覆盖或添加属性。在设备树源文件（`.dts`）被编译成二进制文件（`.dtb`）的过程中，所有对标签的引用（`&label`）都会被替换成该节点的完整路径。**最终生成的`.dtb`文件中不包含任何标签信息** > **别名** 是**内核级**的引用，为节点提供一个固定的、短的名称，方便驱动在运行时通过标准API查找设备。驱动代码可以使用`of_alias_get_id()`等函数，根据设备节点获取其在别名中定义的ID。实际在/dev文件下面显示的也是这个别名 ```json /dts v1/; / { // 别名定义 aliases { uart1 &uart1; // uart1 别名指向名为 uart1 的设备节点 uart2 &uart2; // uart2 别名指向名为 uart2 的设备节点 uart3 \"/serial@10000000\"; // uart3 别名指向路径为 /serial@10000000 的设备节点,这里的/表示根目录 }; // 串口设备示例，地址不同，uart1 是标签 uart1: serial@80000000 { // 可在此处添加串口设备的配置信息 }; // 串口设备示例，地址不同，uart2 是标签 uart2: serial@90000000 { // 可在此处添加串口设备的配置信息 }; // 串口设备示例，地址不同，uart3 是标签，通过路径方式定义 serial@10000000 { // 可在此处添加串口设备的配置信息 }; }; ``` #### chosen传递参数 要是为了 uboot 向 Linux 内核传递数据，重点是bootargs参数。一般.dts 文件中 chosen节点通常为空或者内容很少 ```json chosen { stdout path &uart1; }; ``` 定义的时候只有这一个属性, 但是之后会添加bootargs等 在uboot源码中全局搜索`chosen`这个字符串，在 common/fdt_support.c文件中发现了`chosen`的身影，fdt_support.c文件中有个 `fdt_chosen`函数, 在设备树的chosen节点中加入了bootargs属性，并且还设置了 bootargs属性值 ![image 20251108101612778](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251108101612778.png) 实际是在bootz命令调用的时候创建的mnbj ### 设备树属性 属性是键值对，定义了节点的硬件相关参数，属性有很多种我们下面只讲常用的标准属性，其他属性大家用到的时候再查。属性有对应的值，其中值的类型也有好几种，各种属性我们等会一一列举，我们先把属性能填哪些值搞明白。在设备树中，属性的值类型可以有多种，这些类型通常用于描述设备或子系统的各种特性和配置需求。以下是一些常见的属性值类型： 1. **字符串（String）**: > 属性名称：`compatible` > 示例值：`compatible \"lckfb,tspi v10\", \"rockchip,rk3566\";` > 描述：指定该设备或节点与哪些设备或驱动兼容。 2. **整数（Integer）**: > 属性名称：`reg` > 示例值：`reg <0x1000>;`。 > 描述：定义设备的物理地址和大小，通常用于描述内存映射的I/O资源。 3. **数组（Array）**: > 属性名称：`reg` > 示例值：`reg <0x1000,0x10>;`。 > 描述：定义设备的物理地址和大小，通常用于描述内存映射的I/O资源。 4. **列表（List）**: > 属性名称：`interrupts` > 示例值：`interrupts <0 39 4>, <0 41 4>,<0 40 4>;`。 > 描述：用于定义例如中断列表，其中每个元组可以表示不同的中断属性（如编号和触发类型）。 5. **空值（Empty）**: > 属性名称：`regulator always on;` > 示例值：`regulator always on;` > 描述：表示该节点下的regulator是永久开启的，不需要动态控制。 6. **引用（Reference）**: > 属性名称：`gpios` > 示例值：`gpios <&gpio1 RK_PB0 GPIO_ACTIVE_LOW>;` > 描述：提供一个句柄（通常是一个节点的路径或标识符），用于在其他节点中引用该节点。 #### model属性(字符串) model的值是字符串，主要是用于描述开发板型号，有助于用户和开发人员识别硬件。 ``` /{ model \"lckfb tspi V10 Board\"; } ``` #### compatible属性(字符串或字符串列表) `compatible`：这是**最最最最最关键**的属性之一，它用于标识设备的兼容性字符串。操作系统使用这个属性来匹配设备与相应的驱动程序。一般是只有一个驱动名或者使用`厂商,驱动名`的形式 ``` rk_headset: rk headset { compatible \"rockchip_headset\"，\"rockchip_headset2\"; }; ``` 耳机检测驱动中会通过`\"rockchip_headset\"`来匹配驱动 `kernel/drivers/headset_observe/rockchip_headset_core.c` ```c static const struct of_device_id rockchip_headset_of_match[] { { .compatible \"rockchip_headset\", }, // 定义设备树匹配项，指定兼容性字符串，与上面的设备树匹配 {}, // 结束符号 }; MODULE_DEVICE_TABLE(of, rockchip_headset_of_match); // 定义设备树匹配表供内核使用 static struct platform_driver rockchip_headset_driver { .probe rockchip_headset_probe, // 注册设备探测函数, 驱动的入口函数 .remove rockchip_headset_remove, // 注册设备移除函数 .resume rockchip_headset_resume, // 注册设备恢复函数 .suspend rockchip_headset_suspend, // 注册设备挂起函数 .driver { .name \"rockchip_headset\", // 设备名称 .owner THIS_MODULE, // 持有模块的指针 .of_match_table of_match_ptr(rockchip_headset_of_match), // 设备树匹配表指针 }, }; ``` #### reg属性(地址,长度对) 描述了设备的物理地址范围，包括基址与大小，与`address cells`和`size cells`结合使用。 ``` gmac1: ethernet@fe010000 { reg <0x0 0xfe010000 0x0 0x10000>; } ``` ##### address cells属性（整数）和#size cells属性（整数） 用于说明父节点如何解释它的子节点中的reg属性(影响子节点)。 reg 属性的一般格式： ``` reg <[address1] [length1] [address2] [length2] ...>; ``` `[addressN]`：表示区域的起始物理地址。用多少个无符号整数来表示这个地址取决于父节点定义的#address cells的值。例如，如果#address cells为1，则使用一个32位整数表示地址；如果#address cells为2，则使用两个32位整数表示一个64位地址。 `[lengthN]`：表示区域的长度（或大小）。用多少个无符号整数来表示这个长度同样取决于父节点定义的`#size cells`的值。 根据`#address cells`和`#size cells`的定义，单个[address, length]对可能会占用2、3、4个或更多的元素。 例如，如果一个设备的寄存器空间位于地址`0x03F02000`上，并且占用`0x1000`字节的大小，假设其父节点定义了`#address cells <1>` 和 `#size cells <1>`，`reg` 属性的表达方式如下： ``` reg <0x03F02000 0x1000>; ``` 如果地址是64位的，父节点#address cells <2> 和 #size cells <1>，那么reg属性可能会这样写，以表示地址0x00000001 0x03F02000和大小0x1000: ``` reg <0x00000001 0x03F02000 0x1000>; ``` ![image 20250513210617372](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202505132106436.png) ``` / { #address cells <2>; #size cells <2>; cpus { #address cells <2>; #size cells <0>; cpu0: cpu@0 { 受cpus节点的影响 #address cells <2>; #size cells <0>; 所以地址就是0x0，大小就是 0x0 */ reg <0x0 0x0>; }; }; gmac1: ethernet@fe010000 { /* 受根节点的影响 #address cells <2>; #size cells <2>; 所以地址就是0xfe010000 ，大小就是 0x10000 */ reg <0x0 0xfe010000 0x0 0x10000>; }; }; ``` #### status属性（字符串） 这个属性非常重要，我们设备树中其实修改的最大的就是打开某个节点或者关闭某个节点，status属性的值是字符串类型的，他可以有以下几个值，最常用的是okay和disabled。 `status` 属性值包括： `\"okay\"`：表示设备是可操作的，即设备当前处于正常状态，可以被系统正常使用。 `\"disabled\"`：表示设备当前是不可操作的，但在未来可能变得可操作。这通常用于表示某些设备（如热插拔设备）在插入后暂时不可用，但在驱动程序加载或系统配置更改后可能会变得可用。 `\"fail\"`：表示设备不可操作，且设备检测到了一系列错误，且设备不太可能变得可操作。这通常表示设备硬件故障或严重错误。 `\"fail sss\"`：与 `\"fail\"` 含义相同，但后面的 `sss` 部分提供了检测到的错误内容的详细信息。 ``` //用户三色灯 &leds { status \"okay\"; }; //耳机插入检测，不使用扩展板情况需关闭，否则默认会检测到耳机插入 &rk_headset { status \"disabled\"; }; ``` #### device_type属性(字符串) `device_type`属性通常只用于`cpu`节点或`memory`节点。例如，在描述一个CPU节点时，`device_type`可能会被设置为`\"cpu\"`，而在描述内存节点时，它可能会被设置为`\"memory\"`。 ``` device_type \"cpu\"; ``` #### ranges ranges 属性值可以为空或者按照(child bus address,parent bus address,length)格式编写的数字矩阵，ranges是一个地址映射/转换表，ranges属性每个项目由子地址、父地址和地址空间长度这三部分组成 + **child bus address**：子总线地址空间的物理地址，由父节点的#address cells确定此物理地址所占用的字长。 + **parent bus address**：父总线地址空间的物理地址，同样由父节点的#address cells确定此物理地址所占用的字长 + **length**：子地址空间的长度，由父节点的#size cells确定此地址长度所占用的字长。 如果ranges属性值为空值，说明子地址空间和父地址空间完全相同，不需要进行地址转换 ```json ranges <0x0 0xe0000000 0x100000>; // 将本地地址0x0映射到物理地址0xe0000000 ``` 在实际映射的时候可以进行多级映射 ```json // 第一级映射 soc { ranges <0x0 0xf0000000 0x1000000>; // 第二级映射 bus@100000 { ranges <0x0 0x100000 0x1000>; device@200 { reg <0x200 0x10>; // 最终物理地址: 0xf0010200 }; }; }; ``` #### 自定义属性 自定义属性需要注意不要和标准属性冲突，而且尽量做到见名知意 ``` / { my_custom_node { /* 自定节点 */ compatible \"myvendor,my custom device\"; /* 兼容性属性 */ my_custom_property <1>; /* 自定义属性，假设为整数类型 */ my_custom_string_property \"My custom value\"; /* 自定义字符串属性 */ }; }; ```"},"/note/Linux/泰山派/2025-5-11-01环境搭建.html":{"title":"环境搭建","content":"# 环境搭建 [2. SDK编译 立创开发板技术文档中心](https://wiki.lckfb.com/zh hans/tspi rk3566/project case/fat little cell phone/sdk compile.html) ## 代码校验 ``` md5sum tspi_linux_sdk_repo_20240131.tar.gz ``` > 可以校验下载的代码是不是完整的 ``` tar xvzf tspi_linux_sdk_repo_20240131.tar.gz ``` > 解压 ## 编译 ``` .repo/repo/repo sync l j88 ``` > 同步代码 这时候的build里面的ld文件需要代理, 可以使用资料里面的另一个文件 需要安装编译环境 ``` sudo apt get install git ssh make gcc libssl dev liblz4 tool expect g++ patchelf chrpath gawk texinfo chrpath diffstat binfmt support qemu user static live build bison flex fakeroot cmake gcc multilib g++ multilib unzip device tree compiler ncurses dev ``` 编译的时候需要选择泰山派的板子 ``` ./build.sh lunch ``` ![image 20250511194414258](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202505111944432.png) 使用buildroot系统 ``` export RK_ROOTFS_SYSTEM buildroot ``` > [Buildroot简介与快速上手 CSDN博客](https://blog.csdn.net/yanceylu/article/details/108524573) 编译所有 ``` ./build.sh all ``` ``` ./build.sh kernel ``` 之后需要选择一下电源IO4和6是1.8V其他的是3.3V ``` ./mkfirmware.sh ``` 固件打包, 所有的成品放在rockdev目录里边 ![image 20250511215325412](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202505112153513.png) ## 编译Android ``` cd kernel/ && git clean xdf && cd .. && repo forall c \"git checkout lckfb tspi v1.0.0\" sudo apt get update && sudo apt get install y git python make openjdk 8 jdk git core gnupg flex bison gperf build essential zip curl zlib1g dev libgl1 mesa dev gcc multilib g++ multilib libc6 dev i386 lib32ncurses5 dev x11proto core dev libx11 dev lib32z1 dev libxml2 utils xsltproc unzip python bc imagemagick ccache schedtool libssl dev libncursesw5 dbg libncursesw5 dev libncurses5 libncursesw5 libncursesada5 dev libncurses5 dbg libncurses5 dev libncursesada doc libncursesada5 libncurses dev libncurses gst libncurses5 dev clang cd u boot && ./make.sh rk3566 && cd ../kernel && make clean && make distclean && make ARCH arm64 tspi_defconfig rk356x_evb.config android 11.config && make ARCH arm64 tspi rk3566 user v10.img j16 && cd .. && source build/envsetup.sh && lunch rk3566_tspi userdebug && make installclean j16 && make j16 && ./mkimage.sh ``` #### 下载镜像 我们全编译的时候有执行下面这个命令，这个命令是用来生成打散的升级镜像.img的 ``` ./mkimage.sh ``` 注意：如果你执行了单独编译kernel命令的话，需要先执行下面命令重新生成一些boot.img否则会有无法正常启动问题, 在kernel目录 ``` make ARCH arm64 tspi_defconfig rk356x_evb.config android 11.config && make ARCH arm64 tspi rk3566 user v10.img j16 ``` 我们可以在SDK/rockdev/Image rk3566_tspi#目录下查看所有生成的img ``` SDK/rockdev/Image rk3566_tspi# ls baseparameter.img boot.img dtbo.img misc.img pcba_small_misc.img recovery.img super.img vbmeta.img boot debug.img config.cfg MiniLoaderAll.bin parameter.txt pcba_whole_misc.img resource.img uboot ``` ### 单独编译kernel（只适合带emmc版本） 前面我们都是走的全编译，因为需要编译和下载很多东西所以非常慢，而且占用空间也很大，如果你只是单纯的修改一些配置、驱动或者设备树（新手同学可以理解为内核的xml配置文件，后面我们会去讲）单独编译和烧录内核就行这样速度快有利于调试。 编译命令【执行全编译命令成功之后，编译内核】 ``` make ARCH arm64 BOOT_IMG ../rockdev/Image rk3566_tspi/boot.img tspi rk3566 user v10.img j72 ``` 编译命令【 没有执行全编译命令，直接编译内核】【进入kernel目录】 ``` make ARCH arm64 tspi_defconfig rk356x_evb.config android 11.config && make ARCH arm64 tspi rk3566 user v10.img j$(nproc) && cd .. && source build/envsetup.sh && lunch rk3566_tspi userdebug && make installclean j$(nproc) && make j$(nproc) && ./mkimage.sh ``` 编译完成 ![img](https://wiki.lckfb.com/storage/images/zh hans/tspi rk3566/project case/fat little cell phone/sdk compile/sdk compile_20240830_042347.png) 单独烧录boot.img固件，在win10中打开RKDevTool.exe工具，下载配置文件： Android_Tspi_Kernel.cfg配置文件下载 📌 [下载中心（点击跳转）](https://wiki.lckfb.com/zh hans/tspi rk3566/download center.html) 📌 在 `下载中心` >`百度网盘` >`第06章.【立创·泰山派】系统镜像` >`【镜像】Android` >`Android_Tspi_Kernel.cfg` 导入Android_Tspi_Kernel.cfg配置文件，勾选boot选项其他去掉，在把boot选项路径切换到kernel下的boot.img，接着操作按住泰山派REC按键不松，轻触一下RST按键等待进入Loader模式后松开REC按键，当工具发现一个LOADER设备后点击执行升级，演示如下： ![img](https://wiki.lckfb.com/storage/images/zh hans/tspi rk3566/project case/fat little cell phone/sdk compile/sdk compile_20240830_215638.png) ## 下载 [【立创·泰山派RK3566开发板】镜像烧录教程 立创开发板技术文档中心](https://wiki.lckfb.com/zh hans/tspi rk3566/system usage/img download.html) 泰山派开发板下面板载了三个按键，进入Loader升级模式主要用到两个按键分别是RST与REC，进入Loader升级模式方法，先按住REC按钮不放，接着按下RST复位按键并松开，当烧录软件中出现“发现一个LOADER设备”后松开REC按钮，下面就可以进行升级操作了。 使用RKDevTool进行下载 ![image 20250511215210937](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202505112152028.png) > 单独下载的时候需要导入驱动文件"},"/note/Linux/泰山派/2025-12-24-07-yolo部署.html":{"title":"YOLO部署","content":"# YOLO部署 ## V5 ## 训练 使用`python train.py data ./data/my_dest.yaml`进行训练 ### 导出 导出的时候需要更改一下模型的样式 使用下面的函数代替原本的forward函数在`yolov5/models/yolo.py`文件里面(只有导出的时候使用, 记得改回去), 原本的函数会在这个函数里面处理模型输出到实际的图片坐标转换, 这里不使用 ```python # RKNN 使用的forward def forward(self, x): z [] for i in range(self.nl): # 只使用一个激活函数 sigmoid, 对每一个输出通道使用相同的激活函数 # 直接获取预测结果 # 输出 (bs, na*ny*nx, no) 的“原始预测值”（还没乘 grid、没乘 anchor、没算 xywh 到像素坐标） x[i] torch.sigmoid(self.m[i](x[i])) return x ``` 使用`python export.py opset 12`, 如此即可获取到beat.onnx模型 可以使用工具再次简化模型 ```bash python m onnxsim weights/best.onnx weights/best sim.onnx ``` 导出的模型记录在best sim.onnx ## 模型转换 使用的工具是[airockchip/rknn_model_zoo](https://github.com/airockchip/rknn_model_zoo/) 手册在[rknn_model_zoo/examples/yolov5 at main · airockchip/rknn_model_zoo](https://github.com/airockchip/rknn_model_zoo/tree/main/examples/yolov5) ```bash cd model ./download_model.sh ``` 可以使用这个下载默认的模型, 使用的模型是`yolov5s_relu.onnx` ```python python convert.py ../model/yolov5s_relu.onnx rk3566 ``` > 使用自己模型的时候量化使用的图片文件要改一下 > > ```python > DATASET_PATH '../../../datasets/mydataset/dataset.txt' > DEFAULT_RKNN_PATH '../model/yolov5_my.rknn' > DEFAULT_QUANT True > ``` > > 在`examples/yolov5/python/convert.py`文件里面, 这个txt文件里面记录的一系列的图片目录 模型转换, 自己的模型使用的时候需要自己转换 使用的编译工具是`aarch64 linux gnu gcc`, 直接使用apt get安装即可`sudo apt install y gcc aarch64 linux gnu g++ aarch64 linux gnu` ```python export GCC_COMPILER /usr/bin/aarch64 linux gnu ./build linux.sh t rk3566 a aarch64 d yolov5 ``` 输出的文件在`./install/rk356x_linux_aarch64/rknn_yolov5_demo/` ### 板级文件 examples/yolov5/cpp/postprocess.cc这个文件里面有加载的label文件 ```cpp #define LABEL_NALE_TXT_PATH \"./model/coco_80_labels_list.txt\" ``` 修改cpp代码`examples/yolov5/cpp/postprocess.h`里面的实际的分类的类型 ```cpp #define OBJ_NAME_MAX_SIZE 64 #define OBJ_NUMB_MAX_SIZE 128 #define OBJ_CLASS_NUM 3 // 你实际使用的类型数量 #define NMS_THRESH 0.45 #define BOX_THRESH 0.25 #define PROP_BOX_SIZE (5 + OBJ_CLASS_NUM) ``` 默认的CMake复制的文件是coco的分类 ```cmake install(FILES ${CMAKE_CURRENT_SOURCE_DIR}/../model/coco_80_labels_list.txt DESTINATION ./model) ``` 可以改成自己的分类文件 ## 使用gcc11 需要更改buildroot系统 ``` > Toolchain \t > GCC compiler Version (<choice> [ y]) ``` ![image 20251225184819507](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512251848625.png) ```bash ./build.sh rootfs ./mkfirmware.sh ./build.sh updateimg ``` ## 编译使用的参数 ```bash BUILD_DEMO_NAME yolov5 BUILD_DEMO_PATH examples/yolov5/cpp TARGET_SOC rk356x TARGET_ARCH aarch64 BUILD_TYPE Release ENABLE_ASAN OFF DISABLE_RGA OFF DISABLE_LIBJPEG OFF INSTALL_DIR /home/jiao/sknn/rknn_model_zoo/install/rk356x_linux_aarch64/rknn_yolov5_demo BUILD_DIR /home/jiao/sknn/rknn_model_zoo/build/build_rknn_yolov5_demo_rk356x_linux_aarch64_Release CC aarch64 linux gnu gcc CXX aarch64 linux gnu g++ ``` ```bash cd ${BUILD_DIR} cmake ../../${BUILD_DEMO_PATH} \\ DTARGET_SOC rk356x \\ DCMAKE_SYSTEM_NAME Linux \\ DCMAKE_SYSTEM_PROCESSOR aarch64 \\ DCMAKE_BUILD_TYPE Release \\ DENABLE_ASAN OFF \\ DDISABLE_RGA OFF \\ DDISABLE_LIBJPEG OFF \\ DCMAKE_INSTALL_PREFIX 输出的 make j4 make install ```"},"/note/Linux/泰山派/2026-1-30-Ubuntu22.html":{"title":"Ubuntu22","content":"# Ubuntu22 [编译Ubuntu22.04笔记 VR小杰的技术文档中心](https://wiki.vrxiaojie.top/TSPI tai shan pai RK3566/立创泰山派RK3566开发板/泰山派编译Ubuntu22.04/编译Ubuntu22.04笔记.html) ## 替换Kernel 需要使用5.10.0 1012.12的kernel 下载完成后，解压 ``` unzip jammy.zip ``` 将tspi目录下原来的kernel重命名为kernel_old。 ``` mv ./tspi/kernel ./tspi/kernel_old ``` 将解压出的文件夹移动到泰山派SDK目录下，并重命名为kernel ``` mv linux rockchip jammy/ tspi/kernel ``` ### 复制泰山派设备树文件 将之前的kernel_old 下的tspi开头的设备树文件复制到新的kernel下 ``` cp ~/tspi/kernel_old/arch/arm64/boot/dts/rockchip/tspi* ~/tspi/kernel/arch/arm64/boot/dts/rockchip ``` ``` cd ~/tspi/kernel/arch/arm64/boot/dts/rockchip ``` 编辑Makefile， ``` vim ~/tspi/kernel/arch/arm64/boot/dts/rockchip/Makefile ``` 新增一行： ``` dtb $(CONFIG_ARCH_ROCKCHIP) + tspi rk3566 user v10 linux.dtb ``` 并保存退出 ### 修改menuconfig ```bash make ARCH arm64 menuconfig # 使用这个进行menuconfig ``` 搜索 **AP6**，按下1进入对应配置页面 修改固件以及NVRAM路径，这里是指Ubuntu系统内的路径，后文会说如何将固件复制进去。 Firmware path和NVRAM path分别修改为 ``` /lib/firmware/fw_bcm43438a1.bin /lib/firmware/nvram_ap6212a.txt ``` ![alt text](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601301910487.png) > **博通（Broadcom）AP6212A WiFi + 蓝牙模块（基于 BCM43438 芯片）** 运行的核心配套文件，是 WiFi 驱动能正常工作的 “刚需文件”，缺一不可, 是运行在 WiFi 芯片自身微处理器上的底层程序, Linux 内核驱动（比如博通的`brcmfmac.ko`）加载后，会把这个固件文件 “下载” 到 WiFi 芯片的内存中，芯片才能从 “裸硬件” 变成能工作的 WiFi 模块 > > txt文件里包含驱动必须读取的关键参数（不同批次 / 型号的模块参数不同），比如： > > 射频参数：发射功率、信道频率校准值（保证 WiFi 信号强度和稳定性，避免信号过弱 / 干扰）； > 硬件标识：默认 MAC 地址、模块型号、天线配置（单天线 / 双天线）； > 功能限制：支持的 WiFi 频段（2.4G/5G）、蓝牙配对参数（AP6212A 是 WiFi + 蓝牙二合一模块）； > 厂商校准值：生产时对模块的硬件校准参数（保证不同模块的兼容性）。 #### GPU （1）将`Device Drivers > Graphics support > Direct Rendering Manager (XFree86 4.1.0 and higher DRI support)下的Ignore drm ioctl permission `标记为 **N** ![image 20260130191249487](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601301912539.png) （2）将`Device Drivers > Graphics support > Search (Panfros) > Graphics support下的Panfrost (DRM support for ARM Mali Midgard/Bifrost GPUs)` 标记为 **Y** ![image 20260130191307144](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601301913188.png) 打开`~/tspi/kernel/arch/arm64/boot/dts/rockchip/tspi rk3566 core v10.dtsi `将cursor win id <ROCKCHIP_VOP2_CLUSTER0>; 这一行**注释掉**。 ![image 20260130191337852](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601301913892.png) 在GPU图像处理下新增两行： ``` clock names \"gpu\", \"bus\"; interrupt names \"gpu\", \"mmu\", \"job\"; ``` ![image 20260130191401774](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601301914831.png) 完成后保存 ![alt text](https://wiki.vrxiaojie.top/assets/image8.B_yM8NWx.png) ![alt text](https://wiki.vrxiaojie.top/assets/image9.CyvfTSKH.png) 退出后输入 ```bash make ARCH arm64 savedefconfig mv defconfig arch/arm64/configs/rockchip_linux_defconfig ``` ### 复制触摸驱动 ### 安装GCC交叉编译工具 前往https://developer.arm.com/downloads/ /gnu a/10 2 2020 11 下载`gcc arm 10.2 2020.11 x86_64 aarch64 none linux gnu.tar.xz` ```bash wget https://developer.arm.com/ /media/Files/downloads/gnu a/10.2 2020.11/binrel/gcc arm 10.2 2020.11 x86_64 aarch64 none linux gnu.tar.xz ``` 并将其解压至 ~/ 目录下 ```bash tar xvf gcc arm 10.2 2020.11 x86_64 aarch64 none linux gnu.tar.xz vim ~/.bashrc # 在文件最后新增三行 export ARCH arm64 export CROSS_COMPILE aarch64 none linux gnu export PATH $PATH:/home/vrxiaojie/gcc arm 10.2 2020.11 x86_64 aarch64 none linux gnu/bin # 执行 source ~/.bashrc ``` 之后编译系统 显示lz4版本不合适 ```bash git clone https://github.com/lz4/lz4.git cd lz4 make j$(nproc) sudo make install ``` ## rootfs文件系统 从[这里](https://mirrors.aliyun.com/ubuntu cdimage/ubuntu base/releases/22.04/release/)下载镜像`https://mirrors.aliyun.com/ubuntu cdimage/ubuntu base/releases/22.04/release/ubuntu base 22.04 base amd64.tar.gz` ```bash mkdir ~/ubuntu_rootfs tar xzvf ubuntu base 22.04.5 base arm64.tar.gz C ~/ubuntu_rootfs/ ``` ### 将WIFI固件复制进Ubuntu 为了使上面配置menuconfig的WIFI模块生效 ``` sudo cp ~/tspi/external/rkwifibt/firmware/broadcom/AP6212A1/wifi/nvram_ap6212a.txt ~/ubuntu_rootfs/lib/firmware sudo cp ~/tspi/external/rkwifibt/firmware/broadcom/AP6212A1/wifi/fw_bcm43438a1.bin ~/ubuntu_rootfs/lib/firmware ``` ### 安装模块至rootfs中 在 `~/tspi/kernel`目录下编译模块 ```bash make modules ``` ![alt text](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601301917412.png) 接着安装模块至ubuntu rootfs, 这个变量决定了内核模块将被安装到**哪个目录的 `lib/modules/` 子目录下** ```bash make ARCH arm64 modules_install INSTALL_MOD_PATH ../../ubuntu_rootfs ``` ![alt text](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601301917367.png) 用`ls`命令能看到`ubuntu_rootfs/lib/modules`目录下多出了一个带数字的文件夹`5.10.209`，文件夹内包含了刚安装的模块 ![alt text](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601301917553.png) 以下内容参考 https://www.jlc bbs.com/platform/a/310346 （1）在当前编译环境中安装仿真开发环境， ```c sudo apt install qemu user static ``` （2）将当前编译环境中的仿真开发环境复制到目标系统文件夹 ```c sudo cp /usr/bin/qemu aarch64 static ubuntu_rootfs/usr/bin/ ``` （3）将当前编译环境中的网络配置文件复制到目标系统文件夹 ``` sudo cp /etc/resolv.conf ubuntu_rootfs/etc/ ``` （4）修改目标系统中的软件源配置文件 ``` sudo vim ubuntu_rootfs/etc/apt/sources.list ``` 将该文件原先的内容删掉，替换为以下内容： ``` deb http://mirrors.aliyun.com/ubuntu ports/ jammy main restricted universe multiverse deb src http://mirrors.aliyun.com/ubuntu ports/ jammy main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu ports/ jammy security main restricted universe multiverse deb src http://mirrors.aliyun.com/ubuntu ports/ jammy security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu ports/ jammy updates main restricted universe multiverse deb src http://mirrors.aliyun.com/ubuntu ports/ jammy updates main restricted universe multiverse # deb http://mirrors.aliyun.com/ubuntu ports/ jammy proposed main restricted universe multiverse # deb src http://mirrors.aliyun.com/ubuntu ports/ jammy proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu ports/ jammy backports main restricted universe multiverse deb src http://mirrors.aliyun.com/ubuntu ports/ jammy backports main restricted universe multiverse ``` （5）编写挂载脚本 ``` sudo vim mount.sh ``` 加入以下内容： ```bash #!/bin/bash function mnt() { echo \"MOUNTING\" sudo mount t proc /proc ${2}proc sudo mount t sysfs /sys ${2}sys sudo mount o bind /dev ${2}dev #sudo mount t devpts o gid 5,mode 620 devpts ${2}dev/pts sudo mount o bind /dev/pts ${2}dev/pts sudo chroot ${2} } function umnt() { echo \"UNMOUNTING\" sudo umount ${2}proc sudo umount ${2}sys sudo umount ${2}dev/pts sudo umount ${2}dev } if [ \"$1\" \" m\" ] && [ n \"$2\" ]; then mnt $1 $2 elif [ \"$1\" \" u\" ] && [ n \"$2\" ]; then umnt $1 $2 else echo \"\" echo \"Either 1'st, 2'nd or both parameters were missing\" echo \"\" echo \"1'st parameter can be one of these: m(mount) OR u(umount)\" echo \"2'nd parameter is the full path of rootfs directory(with tralling '/')\" echo \"\" echo \"For example: ch mount m /media/sdcard\" echo \"\" echo 1st parameter : ${1} echo 2nd parameter : $[2] fi ``` （6）添加脚本执行权限 ``` sudo chmod +x mount.sh ``` （7）挂载根文件系统 ``` ./mount.sh m ubuntu_rootfs/ ``` 注意: 当完成根文件系统挂载后，后续命令将在根文件系统中执行，直至根文件系统被卸载（后文会提及如何卸载） ### 2.6 在根文件系统中安装必要的软件 （1）更新安装软件包列表 ``` apt update ``` 若在使用该命令时遇到问题： ![alt text](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601301921760.png) 其原因是/tmp文件夹的权限错误，只需使用chmod为/tmp赋777权限 ``` chmod 777 /tmp apt clean apt update ``` （2）更新和升级软件包 ``` apt upgrade ``` （3）在目标系统中安装必要的软件 ``` apt install y sudo vim udev net tools ethtool udhcpc netplan.io language pack en base iputils ping openssh sftp server ntp usbutils alsa utils libmtp9 language pack zh han* bluetooth* bluez* blueman* wireless tools network manager dialog chromium browser ``` 安装过程中会提示配置地区和时区，输入`6` 选择Asia![alt text](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601301921576.png) 接着输入`70`选择Shanghai![alt text](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601301921630.png) （4）为了实现屏幕显示，安装桌面环境 ubuntu desktop 注意，此过程相当耗时，如有提示缺少依赖，可用apt单独安装依赖后，继续安装桌面环境。 ``` apt install ubuntu desktop y ``` 中途会让选择键盘布局，这里输入`19`，选择Chinese![alt text](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601301921884.png) 继续选择中文键盘布局 `1`![alt text](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601301921009.png) （5）卸载办公套件并清除相关配置文件 ``` apt get remove purge libreoffice* y ``` （6）清理无用的软件 ``` sudo apt autoremove ``` （7）清理apt ``` sudo apt clean ``` ### 2.7 添加用户及启动配置 （1）在目标系统中添加用户 ``` adduser jiao ``` （2）为用户添加管理员权限 ``` adduser jiao sudo ``` （3）修改root用户密码 ``` passwd root ``` ### 修改开机等待网络延迟时间 默认情况下，系统启动过程中会出现“A start job is running for wait for network to be Configured”的提示信息，然后开始倒计时5分钟，需要等待倒计时结束后才能继续启动系统，通过修改配置文件，将倒计时时间缩短到5秒或关闭倒计时。 ``` vim /etc/systemd/system/network online.target.wants/systemd networkd wait online.service ``` 修改的配置文件内容： ``` ExecStart /usr/bin/nm online s q timeout 0 ``` ### 添加分区释放的系统服务（重要） 默认情况下，rootfs分区烧录后，只有固件本身大小。通过添加系统服务，实现分区释放。 （1）修改配置文件 ``` vim /etc/init.d/resize2fs.sh ``` 修改的配置文件内容： ```bash #!/bin/bash e # resize filesystem mmcblk0p6 if [ ! e \"/usr/local/boot_flag\" ] ; then echo \"Resizing /dev/mmcblk0p6...\" resize2fs /dev/mmcblk0p6 touch /usr/local/boot_flag fi ``` （2）添加配置文件执行权限 ```bash chmod +x /etc/init.d/resize2fs.sh ``` （3）创建执行上述脚本的系统服务 ```bash vim lib/systemd/system/resize2fs.service ``` 添加内容： ``` #start [Unit] Description Setup rockchip platform environment Before lightdm.service After resize helper.service [Service] Type simple ExecStart /etc/init.d/resize2fs.sh [Install] WantedBy multi user.target #end ``` > 实际需要自己运行 > > ```bash > sudo systemctl enable resize2fs.service > # 立即启动服务（执行扩容操作） > sudo systemctl start resize2fs.service > ``` > > ### 退出并卸载根文件系统 退出根文件系统 ``` exit ``` 卸载根文件系统 ``` sudo ./mount.sh u ubuntu_rootfs/ ``` ## 制作rootfs.img并烧录 ```bash sudo dd if /dev/zero of ubuntu_rootfs.img bs 1M count 8192 sudo mkfs.ext4 ubuntu_rootfs.img sudo mkdir ubuntu_base_rootfs sudo chmod 777 ubuntu_base_rootfs sudo mount ubuntu_rootfs.img ubuntu_base_rootfs sudo cp rfp ubuntu_rootfs/* ubuntu_base_rootfs/ sudo umount ubuntu_base_rootfs/ sudo e2fsck p f ubuntu_rootfs.img # 修复及检测镜像文件系统 sudo resize2fs M ubuntu_rootfs.img # 压缩镜像文件的大小 sudo du sh ubuntu_rootfs.img # 查看镜像文件的大小 rm ~/tspi/rockdev/rootfs.* # 删除原rockdev下的rootfs.ext4和rootfs.img # 将刚刚创建的ubuntu_rootfs.img 移动到rockdev下并重命名为rootfs.img mv ubuntu_rootfs.img ~/tspi/rockdev/rootfs.img ``` > 也可以通过修改复制脚本的方式实现, 目标是在这个位置放上rootfs文件 ```bash ./build.sh updateimg ``` 合成update.img文件 ## 网络连接 [立创泰山派学习01 ubuntn系统的WIFI配置及SSH的安装 zbl1118 博客园](https://www.cnblogs.com/zblblog/p/18075528) ```bash nmcli dev wifi list sudo nmcli device wifi connect \"TP LINK_5G_2B18\" password \"13838106970\" sudo nmcli device wifi connect \"jiao\" password \"11111111\" ``` ## 硬盘处理 ```bash sudo fdisk l /dev/mmcblk0 Disk /dev/mmcblk0: 14.56 GiB, 15634268160 bytes, 30535680 sectors Units: sectors of 1 * 512 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: gpt Disk identifier: 25590000 0000 4648 8000 196800006884 Device Start End Sectors Size Type /dev/mmcblk0p1 16384 24575 8192 4M unknown /dev/mmcblk0p2 24576 32767 8192 4M unknown /dev/mmcblk0p3 32768 163839 131072 64M unknown /dev/mmcblk0p4 163840 294911 131072 64M unknown /dev/mmcblk0p5 294912 360447 65536 32M unknown /dev/mmcblk0p6 360448 12943359 12582912 6G unknown /dev/mmcblk0p7 12943360 13205503 262144 128M unknown /dev/mmcblk0p8 13205504 30535615 17330112 8.3G unknown sudo mkfs.ext4 /dev/mmcblk0p8 sudo mkdir /data sudo mount /dev/mmcblk0p8 /data df h /data ``` 临时挂载在重启后会失效。我们需要将其信息添加到 `/etc/fstab` 文件中。 1. 首先，获取分区的 **UUID**（最可靠的标识方式）： ``` sudo blkid /dev/mmcblk0p8 ``` 输出中会显示类似 `UUID \"xxxxxxxx xxxx xxxx xxxx xxxxxxxxxxxx\"` 的信息。 2. 编辑 `fstab` 文件： ``` sudo nano /etc/fstab ``` 3. 在文件末尾**新起一行**，添加以下内容（请将 `UUID xxxx...` 替换为上一步命令输出的**实际UUID**）： ``` UUID xxxxxxxx xxxx xxxx xxxx xxxxxxxxxxxx /data ext4 defaults,noatime 0 2 ``` 4. 按 `Ctrl+O` 保存，按 `Ctrl+X` 退出。 + 验证 fstab 配置 可以运行以下命令测试配置是否正确，这不会破坏现有挂载： ```bash sudo mount a ``` 如果命令执行没有报错，并且再次运行 `df h /data` 显示正常，就说明配置成功。下次开机时会自动挂载。 ```bash # 实际的文件移植 sudo rsync av /opt/ /data/opt/ # 复制内容 sudo mv /opt /opt.old # 将原目录重命名备份 sudo ln s /data/opt /opt # 创建指向新位置的软链接 sudo reboot # 重启后，检查新 /opt 工作是否正常，若正常可删除 /opt.old ```"},"/note/Linux/瑞芯微Linux/2025-12-8-04-内核.html":{"title":"内核","content":"# 内核 ## 设备树 ### 屏幕 [Home · notro/fbtft Wiki](https://github.com/notro/fbtft/wiki) 对应的驱动是drivers/staging/fbtft/fb_st7789v.c, 使用的fb设备 ```json &spi0 { \tpinctrl 0 <&spi0m0_clk &spi0m0_miso &spi0m0_mosi &spi0m0_cs0>; \t#address cells <1>; \t#size cells <0>; \tspidev@0 { \tcompatible \"rockchip,spidev\"; \t\tspi max frequency <60000000>; \t\treg <0>; \t}; \tfbtft@0{ \t\tcompatible \"sitronix,st7789v\"; \t\treg <0>; \t\tspi max frequency <60000000>; \t\tfps <60>; \t\tbuswidth <8>; \t\tdebug <0x7>; \t\trotate <270>; \t\t//bgr <1>;\t//RGB >BGR \t\t//led gpios <&gpio1 RK_PC5 GPIO_ACTIVE_HIGH>;\t\t//BL \t\tdc gpios <&gpio1 RK_PD0 GPIO_ACTIVE_HIGH>;\t\t//DC \t\treset gpios <&gpio1 RK_PC4 GPIO_ACTIVE_LOW>;\t\t//RES \t}; }; ``` ### 触摸 对应的驱动是drivers/input/touchscreen/focaltech_touch ```json &i2c3 { \tstatus \"okay\"; \tclock frequency <100000>; focaltech@38 { \t\tcompatible \"focaltech,fts\";\t \t\treg <0x38>; \t\t\t\t\t \t\tinterrupt parent <&gpio1>;\t\t\t\t \t\tinterrupts <RK_PC7 IRQ_TYPE_EDGE_FALLING>; \t\tfocaltech,reset gpio <&gpio1 RK_PC6 GPIO_ACTIVE_LOW>; \t\tfocaltech,irq gpio <&gpio1 RK_PC7 IRQ_TYPE_LEVEL_LOW>; \t\tfocaltech,max touch number <5>;\t\t\t \t\tfocaltech,display coords <0 0 240 320>; \t\tfocaltech,rotate <270>; \t}; }; ```"},"/note/Linux/瑞芯微Linux/2025-12-9-05-模型.html":{"title":"模型","content":"# 模型 ## 服务器 ### TTS DashScope是阿里云推出的**模型即服务**（Model as a Service, MaaS）平台，旨在为AI开发者提供多模态模型的API服务 ### asr 使用的是SenseVoice的模型部署"},"/note/Linux/瑞芯微Linux/2025-12-10-Cpp提供C接口.html":{"title":"CpptigsC接口","content":"# CpptigsC接口 C++ 和 C 的编译规则、函数名修饰（Name Mangling）、类型系统存在本质差异： C++ 会对函数名进行**名字修饰**（如`void func(int)`可能被编译为`_Z4funci`），导致 C 编译器无法识别； C++ 支持重载、类、异常等特性，而 C 不支持，直接暴露 C++ 接口给 C 调用会导致编译 / 链接错误。 因此，C++ 库要给 C 调用，核心是**屏蔽 C++ 特性、让接口符合 C 的编译 / 链接规则**，并通过特定方式封装 C++ 的类 / 对象。 ## 用`extern \"C\"`屏蔽 C++ 名字修饰 + 头文件 ```cpp // 头文件（供C/C++调用） #ifdef __cplusplus extern \"C\" { #endif // C风格接口声明（无类、无重载、无异常） void* create_obj(int param); void obj_do_something(void* obj); void destroy_obj(void* obj); #ifdef __cplusplus } #endif ``` ## 封装 C++ 类 C 不支持 C++ 类，因此需要将 C++ 对象的指针**隐式转换为`void\\*`**（通用指针）暴露给 C，C 侧仅持有指针，不感知对象内部结构。 ```c // cpp_lib.h（仅C++可见，C不包含） class MyClass { private: int value; public: MyClass(int param) : value(param) {} void doSomething() { printf(\"MyClass::doSomething, value %d\\n\", value); } ~MyClass() { printf(\"MyClass destroyed\\n\"); } }; ``` ```c // c_api.h（C/C++兼容） #ifndef C_API_H #define C_API_H #ifdef __cplusplus extern \"C\" { #endif // 创建对象：返回void*（C侧仅持有指针） void* my_class_create(int param); // 调用对象方法：接收void*，内部转换为MyClass* void my_class_do_something(void* obj); // 销毁对象：释放内存，避免泄漏 void my_class_destroy(void* obj); #ifdef __cplusplus } #endif #endif // C_API_H ``` ```cpp // c_api.cpp #include \"c_api.h\" #include \"cpp_lib.h\" #include <cstdio> // 创建对象：C++侧new对象，返回void* void* my_class_create(int param) { // 异常安全：C不支持异常，需捕获并返回NULL try { return new MyClass(param); } catch (...) { return nullptr; } } // 调用方法：将void*转回MyClass* void my_class_do_something(void* obj) { if (obj nullptr) return; // 空指针检查 MyClass* cls static_cast<MyClass*>(obj); cls >doSomething(); } // 销毁对象：delete C++对象 void my_class_destroy(void* obj) { if (obj nullptr) return; MyClass* cls static_cast<MyClass*>(obj); delete cls; } ``` **禁止 C 侧直接操作指针**：C 侧只能通过接口传递`void*`，不能强制转换为 C++ 类指针（破坏封装）； **异常处理**：C 不支持异常，C++ 接口实现中必须捕获所有异常，转为错误码 / NULL 返回； **数据类型兼容**：接口中仅使用 C 兼容类型（`int`/`char`/`void*`等），避免 C++ 特有类型（`std::string`/`std::vector`）； **链接规则**：确保`extern \"C\"`包裹所有 C 接口声明，否则 C 编译器无法解析 C++ 修饰的函数名。 ## 不透明指针 **不透明指针**是一种设计模式，它通过指针来隐藏数据结构的实现细节，只暴露操作该数据结构的接口。在C语言中，它通常表现为一个未完全定义的结构体指针, 相比`void*`，不透明指针是强类型（如`MyObj*`），避免错误的指针类型转换 #### 1. static_cast：编译期语义转换 `static_cast` 是最常用的转换方式，用于**编译器可验证的、语义上合理的类型转换**，本质是 “模拟编译器的隐式转换，或反向执行隐式转换”。 ##### 适用场景 **基础数据类型转换**（隐式转换的显式化，或反向）： ```cpp // 隐式转换的显式化（int→double） int a 10; double b static_cast<double>(a); // 等价于隐式转换，但更清晰 // 反向转换（double→int，会丢失精度，编译器允许但需显式） double c 3.14; int d static_cast<int>(c); // d 3，精度丢失（编译期无警告，需程序员负责） ``` **父子类向上转型**（安全，等价于隐式转换）： ```cpp class Base {}; class Derived : public Base {}; Derived d; // 向上转型（子类→父类），static_cast 等价于隐式转换 Base* b_ptr static_cast<Base*>(&d); ``` **父子类向下转型**（不安全，无运行时检查）：注意：仅当父类指针确实指向子类对象时，转换才合法；否则会导致未定义行为（UB）。 ```cpp Base* base_ptr new Derived(); // 父类指针指向子类对象（合法） Derived* der_ptr static_cast<Derived*>(base_ptr); // 转换成功 Base* pure_base new Base(); Derived* bad_der static_cast<Derived*>(pure_base); // 编译通过，但解引用会UB ``` **void\\* 与具体类型指针的转换**： ```cpp // void* → int*（static_cast 语义更贴合“类型转换”，而非底层重解释） void* void_ptr new int(100); int* int_ptr static_cast<int*>(void_ptr); // 合法 // int* → void*（隐式转换也可，static_cast 显式化） void* v_ptr static_cast<void*>(int_ptr); ``` **类的构造 / 转换函数调用**： ```cpp class MyInt { public: explicit MyInt(int x) : val(x) {} // explicit 禁止隐式转换 operator int() const { return val; } // 转换函数：MyInt→int private: int val; }; MyInt mi(10); int x static_cast<int>(mi); // 调用转换函数，合法 MyInt mi2 static_cast<MyInt>(20); // 调用explicit构造函数，合法（隐式则报错） ``` ##### 关键特点 编译期检查，无运行时开销； 不支持 “无关类型” 转换（如 `int*`→`double*`），需用 `reinterpret_cast`； 不能修改 `const/volatile` 限定符（需用 `const_cast`）。 #### 2. const_cast：修改常量性限定符 `const_cast` 是**唯一能添加 / 移除 `const`/`volatile` 限定符**的转换运算符，仅作用于指针、引用、成员指针，不改变类型本身。 ##### 适用场景 **临时移除 const 调用非 const 接口**（仅当原对象实际非 const 时合法）： ```cpp void func(int* ptr) { *ptr 20; } int main() { // 场景1：原对象非 const，仅指针是 const → 转换合法 int val 10; const int* const_ptr &val; int* non_const_ptr const_cast<int*>(const_ptr); func(non_const_ptr); // 合法，val 被修改为 20 // 场景2：原对象是 const → 转换后修改会导致UB const int const_val 100; const int* cp &const_val; int* np const_cast<int*>(cp); *np 200; // UB！const_val 是只读内存，修改会崩溃/数据错乱 return 0; } ``` **添加 const 限定符**（较少用，隐式转换也可）： ```cpp int x 10; int* p &x; const int* cp const_cast<const int*>(p); // 等价于隐式转换 ``` ##### 关键特点 编译期检查，仅修改限定符，不改变指针 / 引用指向的类型； 若修改 `const` 限定符后操作原对象（且原对象是 `const`），会触发 UB； 不能用于普通数值类型（如 `const_cast<int>(10)` 非法）。 #### 3. dynamic_cast：运行时安全的继承体系转换 `dynamic_cast` 专为**多态类（含虚函数）的继承体系转换**设计，核心是**运行时检查类型合法性**，是最安全的继承体系转换方式。 ##### 适用前提 转换的目标类型必须是 “多态类”（类中有至少一个虚函数，包括虚析构函数）； 仅支持指针或引用的转换（不支持普通类型）。 ##### 适用场景 **父子类向下转型**（安全，运行时验证）： ```cpp class Base { virtual void func() {} }; // 多态类（有虚函数） class Derived : public Base { void func() override {} }; Base* base_ptr new Derived(); // 父类指针指向子类 // 向下转型：运行时检查，返回非空指针 Derived* der_ptr dynamic_cast<Derived*>(base_ptr); if (der_ptr) { // 转换成功，非空 der_ptr >func(); } Base* pure_base new Base(); // 父类指针指向父类对象 Derived* bad_der dynamic_cast<Derived*>(pure_base); // 转换失败，返回null ``` **交叉转型**（同一基类的不同子类之间转换）： ```cpp class Base { virtual void func() {} }; class A : public Base {}; class B : public Base {}; A* a_ptr new A(); // 交叉转型：A* → B*，运行时检查（a_ptr 指向A，转换失败） B* b_ptr dynamic_cast<B*>(a_ptr); // b_ptr nullptr ``` **引用的向下转型**（失败时抛异常）：指针转换失败返回 `nullptr`，但引用不能为空，因此失败时抛出 `std::bad_cast` 异常。 ```cpp #include <typeinfo> // 包含 bad_cast 定义 Base& base_ref *new Base(); try { Derived& der_ref dynamic_cast<Derived&>(base_ref); // 转换失败 } catch (const std::bad_cast& e) { std::cout << \"转换失败：\" << e.what() << std::endl; } ``` ##### 关键特点 运行时检查，有一定性能开销（需查询类型信息 RTTI）； 仅支持多态类，非多态类使用会编译报错； 转换失败时：指针返回 `nullptr`，引用抛 `std::bad_cast`； 不能用于 `void*` 转换，也不能修改 `const` 限定符。 #### 4. reinterpret_cast：底层二进制重解释 `reinterpret_cast` 是最 “暴力” 的转换方式，核心是**忽略类型语义，仅对内存二进制位进行重新解释**，无任何类型检查，完全依赖程序员保证安全性。 ##### 适用场景 **指针 ↔ 整数类型**（存储 / 打印指针地址）： ```cpp #include <cstdint> // uintptr_t：可存储指针的整数类型 int x 10; int* p &x; // 指针→整数：存储指针的二进制值 uintptr_t addr reinterpret_cast<uintptr_t>(p); // 整数→指针：重新解释整数为指针 int* p2 reinterpret_cast<int*>(addr); ``` **无关类型指针 / 引用转换**（底层内存操作）： ```cpp // int* → double*：仅重解释内存，无类型检查 int val 0x4048f5c3; // 对应 double 的 3.14（小端序） int* ip &val; double* dp reinterpret_cast<double*>(ip); std::cout << *dp << std::endl; // 输出 3.14（内存布局匹配时合法） ``` **函数指针转换**（适配跨语言回调）： ```cpp // C 回调签名 typedef void (*C_Callback)(int); // C++ 函数签名不匹配 void MyFunc(double d) { std::cout << d << std::endl; } // 函数指针转换：double(*)() → int(*)() C_Callback cb reinterpret_cast<C_Callback>(MyFunc); cb(10); // 输出 10.0（需确保参数传递兼容，否则UB） ``` **结合跨语言接口（如 C++ 暴露 C 接口）**： ```cpp // void* → MyClass*：重解释内存，语义更贴合“底层转换” void* void_obj new MyClass(); MyClass* cls reinterpret_cast<MyClass*>(void_obj); ``` ##### 关键特点 编译期转换，无运行时开销； 无类型检查，转换结果完全依赖平台（指针大小、字节序、内存对齐），移植性差； 解引用转换后的指针 / 引用极易触发 UB，仅用于底层编程（跨语言、硬件操作）； 不能用于普通数值类型转换（如 `int→char` 需用 `static_cast`）。 ### 三、C 风格转换 vs C++ 显式转换 C 风格转换（`(T)val`）是 “万能转换”，编译器会根据场景自动选择 `static_cast`/`const_cast`/`reinterpret_cast` 的组合，缺点是： 语义模糊，阅读代码时无法判断转换意图； 缺乏针对性检查，容易隐藏风险（如误将 `const` 转换 + 底层重解释）。 **建议**： 优先使用 C++ 显式转换，让转换语义清晰； 日常开发：`static_cast` 为主，`dynamic_cast` 用于多态类向下转型，`const_cast` 仅临时移除 const，`reinterpret_cast` 尽量不用。 ### 四、使用原则总结 1. **能不用转换就不用**：优先通过合理的类型设计避免强制转换； 2. **优先选安全的转换**：`dynamic_cast`（多态转型）> `static_cast`（语义转型）> `const_cast`（仅改限定符）> `reinterpret_cast`（底层重解释）； 3. **reinterpret_cast 仅用于底层场景**：跨语言接口、硬件内存操作、序列化，且必须加详细注释； 4. **const_cast 不修改 const 对象**：仅当原对象非 const 时，移除 const 后修改才合法； 5. **dynamic_cast 检查返回值**：指针转换后必须判空，引用转换需捕获 `bad_cast` 异常。"},"/note/Linux/瑞芯微Linux/2025-12-7-03-添加板子.html":{"title":"添加板子","content":"# 添加板子 ## mk文件 从build.sh文件里面可以获取到 ```bash \tRK_TARGET_BOARD_ARRAY ($( \t\tcd ${TARGET_PRODUCT_DIR}/ \t\tls BoardConfig_*/BoardConfig*.mk sort \t)) ``` 他会获取这个文件夹下面的所有文件 ![image 20251207223158783](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512072231867.png) 在函数`choose_target_board`里面进行实际的开发板选择, 以及选择使用的存储媒介, 使用的根文件系统, 最终根据使用的配置获取到上面的板子文件 最终这个文件被链接到./.BoardConfig.mk文件上面 ```bash jiao@jiao virtual machine:~/rv/echo mate/Echo Mate/SDK/rv1106 sdk$ ls ./.BoardConfig.mk l lrwxrwxrwx 1 jiao jiao 87 12月 4 17:42 ./.BoardConfig.mk > project/cfg/BoardConfig_IPC/BoardConfig SPI_NAND Buildroot RV1106_Echo_Mate DeskMate.mk ``` ### 文件内容 所有的配置可以在`project/cfg all items introduction.txt`里面看到 这个文件里面配置开发板实际使用的配置 + 芯片: rv1106 + 使用的设备树: rv1106g echo mate.dts + 使用的uboot默认配置: echo_rv1106_uboot_defconfig + 内核基础配置: echo_rv1106_linux_defconfig + 使用Wifi ## build.sh脚本 传入的命令解析 ```bash num $# option \"\" # 遍历所有的命令 while [ $# ne 0 ]; do \tcase $1 in \tDEBUG) export RK_BUILD_VERSION_TYPE DEBUG ;; \tall) option build_all ;; \tsave) option build_save ;; \tallsave) option build_allsave ;; \tcheck) option build_check ;; \tclean) \t\toption \"build_clean $2\" \t\tbreak # 后面的参数忽略 \t\t;; \tfirmware) option build_firmware ;; \tota) option build_ota ;; \tupdateimg) option build_updateimg ;; \tunpackimg) option build_unpack_updateimg ;; \tfactory) option build_factory ;; \trecovery) option build_recovery ;; \tenv) option build_env ;; \tmeta) option build_meta ;; \tdriver) option build_driver ;; \tsysdrv) option build_sysdrv ;; \tuboot) option build_uboot ;; \tkernel) option build_kernel ;; \trootfs) option build_rootfs ;; \tmedia) option build_media ;; \tapp) option build_app ;; \tinfo) option build_info ;; \ttool) option build_tool ;; \tbuildrootconfig) option buildroot_config ;; \tkernelconfig) option kernel_config ;; \t*) option usage ;; \tesac \tif [ $((num)) gt 0 ]; then \t\t# shift 会将参数列表左移一位，每次处理完 $1 后 \t\t# 下一个参数变成新的 $1 \t\tshift \tfi done # 如果 option 非空（已匹配到有效参数），则使用 option 的值； # 如果 option 为空（如仅传 DEBUG、或未传任何参数），则使用默认值 build_allsave。 eval \"${option: build_allsave}\" ``` 默认执行的是build_allsave ```bash function build_allsave() { \t# rm rf ${RK_PROJECT_OUTPUT_IMAGE} ${RK_PROJECT_OUTPUT} \tbuild_all \tbuild_save \tbuild_check_power_domain \tfinish_build } ``` ### build_recovery升级分区 特性 update.img update_ota.tar 核心定位 瑞芯微标准全量系统镜像包 OTA（空中升级）专用压缩包 格式 / 结构 瑞芯微定制的镜像格式（含分区表、烧录引导信息、所有分区镜像） 标准 tar 压缩包（仅含升级必需的镜像 + 脚本） 生成逻辑 由 `build_updateimg` 生成，整合 `uboot.img`/`boot.img`/ `rootfs.img`/`recovery.img`/ `oem.img`/`userdata.img` 等**所有分区镜像**，是系统的 “完整备份” 由 `build_ota` 生成，仅打包升级必需的镜像（默认 `uboot.img`/`boot.img`/ `rootfs.img`，或自定义 `RK_OTA_RESOURCE`）+ `RK_OTA_update.sh` 升级脚本，是 “最小升级集” 依赖条件 无需依赖设备现有系统（裸机 / 砖机均可烧录） 依赖设备已启用 `Recovery` 模式（需 `recovery.img` 正常运行） 体积 大（包含全部分区，通常数百 MB~ 数 GB） 小（仅含核心升级镜像，可按需精简） [Rockchip_Developer_Guide_Linux_Recovery_CN.pdf](https://lo01.g77k.com/aeb/docs/cn/Linux/Recovery/Rockchip_Developer_Guide_Linux_Recovery_CN.pdf) 这个脚本是**瑞芯微（RK）嵌入式平台下 Recovery 镜像（recovery.img）的完整构建流程**，Recovery 是嵌入式系统的 “恢复模式”（用于系统升级、分区修复、出厂恢复等），脚本的核心目标是编译 Recovery 依赖组件、生成配套的操作脚本、打包根文件系统，并最终生成可烧录的 recovery.img 用于进行OTA升级, 需要在配置文件里面加入RK_ENABLE_RECOVERY(未使用) ![image 20251208100103532](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512081001646.png) > 官方的编译示例 > > rootfs 需要打开update 的支持，configs 文件配置 BR2_PACKAGE_UPDATE y > > ```bash > source envsetup.sh > #choose a combo number to build rootfs according to platform chip > make menuconfig > > Target packages > > [*] Rockchip BSP packages > > [*] Rockchip OTA update for linux > ``` > > buildroot/configs/rockchip/recovery.config 中已经将不同平台的recovery配置抽取出来 了。 只需系统根目录下执行 > > ```bash > ./build.sh recovery > ``` > > 成功后，会生成文件 buildroot/output/rockchip_rkxxxx_recovery/images/recovery.img > > ```bash > ./mkfirmware.sh > ``` > > 会将生成的固件拷贝至 rockdev/目录下 > > + 升级固件 > > 修改 tools/linux/Linux_Pack_Firmware/rockdev/package file ，根据需要升级的分区配置，修改 该文件, 可以指定实际需要升级的分区而不是所有的分区 > > ```bash > ./build.sh updateimg > ``` > > 命令执行成功后，会将package file指定的分区镜像打包生成update.img 升级固件，放在 rockdev/目录下。 使用该update.img 升级 > > + 实际的升级 > > 将升级固件 update.img 放在 SD 卡或 U 盘根目录或者设备的/userdata 目录下 > > Normal 系统下执行升级程序 update ota /xxx/update.img，设备将会进入 recovery 模式，并进 行升级。 > > > U 盘的挂载路径： /udisk sdcard 的挂载路径： /mnt/sdcard/ 或/sdcard flash 的挂载路径： /userdata/ > > > > 放在/userdata分区的升级的时候, 这个分区不要打包在update.img文件里面 > > 查看脚本有RkLunch recovery.sh脚本可以用于使用使用update_ota.tar升级, 但未找到相关资料 > > + 恢复出厂设置 > > 我们把可以读写的配置文件保存在 userdata 分区，出厂固件会默认一些配置参数，用户使用一 段时间后 会生成或修改配置文件，有时用户需要清除这些数据，我们就需要恢复到出厂配置。直接运行 update 后面不加任何参数或者加 factory/reset 参数均可进入 recovery 后恢复出厂配置 Recovery 依赖精简版内核和 Busybox（嵌入式基础命令集，如 `dd`/`sh`/`flash_eraseall` 等）, 所以需要编译出来 ```bash # 创建必要目录 mkdir p $RK_PROJECT_PATH_RAMDISK_TINY_ROOTFS $RK_PROJECT_PATH_RAMDISK # 清理旧的Busybox编译产物 → 编译Busybox+内核 → 再次清理临时产物 make busybox_clean C ${SDK_SYSDRV_DIR} make C ${SDK_SYSDRV_DIR} \\ OUTPUT_SYSDRV_RAMDISK_TINY_ROOTFS_DIR $RK_PROJECT_PATH_RAMDISK_TINY_ROOTFS \\ OUTPUT_SYSDRV_RAMDISK_DIR $RK_PROJECT_PATH_RAMDISK \\ busybox kernel make busybox_clean C ${SDK_SYSDRV_DIR} ``` 初始化一系列的变量 ```bash # 内核镜像路径（按架构区分zImage/Image） local kernel_image # 设备树文件（.dts编译后生成.dtb） local kernel_dtb_file \"$RK_PROJECT_PATH_RAMDISK/${RK_KERNEL_DTS/%.dts/.dtb}\" # OTA升级脚本路径 local ota_script \"$OTA_SCRIPT_PATH/RK_OTA_update.sh\" # 擦除misc分区脚本 local erase_misc_script \"$RK_PROJECT_PATH_RAMDISK_TINY_ROOTFS/usr/bin/RK_OTA_erase_misc.sh\" # 根文件系统默认打包格式（cpio） local ramdisk_file \"rootfs.cpio\" ``` Recovery 依赖精简版内核和 Busybox, 需要编译出来 ```bash # 创建必要目录 mkdir p $RK_PROJECT_PATH_RAMDISK_TINY_ROOTFS $RK_PROJECT_PATH_RAMDISK # 清理旧的Busybox编译产物 → 编译Busybox+内核 → 再次清理临时产物 make busybox_clean C ${SDK_SYSDRV_DIR} make C ${SDK_SYSDRV_DIR} \\ OUTPUT_SYSDRV_RAMDISK_TINY_ROOTFS_DIR $RK_PROJECT_PATH_RAMDISK_TINY_ROOTFS \\ OUTPUT_SYSDRV_RAMDISK_DIR $RK_PROJECT_PATH_RAMDISK \\ busybox kernel make busybox_clean C ${SDK_SYSDRV_DIR} ``` + `DK_SYSDRV_DIR`：平台系统驱动 / 基础组件的编译目录； + 编译产物输出到 `RK_PROJECT_PATH_RAMDISK`（Recovery 根文件系统目录）。 之后就是在生成的根文件系统里面生成使用的脚本 ### build_sysdrv > `build_all` 没有直接调用 `build_kernel`，而是通过调用 `build_sysdrv`，由 `build_sysdrv` 执行 `${SDK_SYSDRV_DIR}` 目录下的 `Makefile`，间接触发内核编译 > > 实际的编译文件是sysdrv/Makefile 这段脚本是**Luckfox（瑞芯微）SDK 中「系统驱动 / 基础组件（sysdrv）」的构建核心流程**，核心目标是完成 sysdrv 组件编译，并将编译生成的根文件系统（rootfs）压缩包解压到指定输出目录，同时给出自定义文件的添加指引，最终完成整个 sysdrv 构建阶段 ```bash mkdir p ${RK_PROJECT_OUTPUT_IMAGE} # 实际的编译命令sysdrv, 在这个文件夹里面执行make命令 make C ${SDK_SYSDRV_DIR} # output/out/sysdrv_out/rootfs_uclibc_rv1106.tar rootfs_tarball \"$RK_PROJECT_PATH_SYSDRV/rootfs_${RK_LIBC_TPYE}_${RK_CHIP}.tar\" # output/out/rootfs_uclibc_rv1106 rootfs_out_dir \"$RK_PROJECT_OUTPUT/rootfs_${RK_LIBC_TPYE}_${RK_CHIP}\" # 创建文件夹 if ! [ d $RK_PROJECT_OUTPUT ]; then mkdir p $RK_PROJECT_OUTPUT fi # 解压文件 if [ f $rootfs_tarball ]; then if [ d $rootfs_out_dir ]; then rm rf $rootfs_out_dir fi tar xf $rootfs_tarball C $RK_PROJECT_OUTPUT else msg_error \"Not found rootfs tarball: $rootfs_tarball\" exit 1 fi msg_info \"If you need to add custom files, please upload them to <Luckfox Sdk>/output/out/rootfs_${RK_LIBC_TPYE}_${RK_CHIP}.\" # 打印一行提示返回 finish_build ``` 编译 sysdrv 下的所有组件（包括内核驱动、精简版根文件系统 rootfs、Busybox 等基础工具），编译完成后会自动生成 rootfs 的 tar 压缩包（后续要解压的文件） ### build_media 在media文件夹下面执行make命令 ### build_app **Luckfox / 瑞芯微（RK）嵌入式平台应用层（App）构建流程的核心片段**，主要包含两大核心逻辑：**WiFi 自动连接配置生成（可选）** 和 **应用层代码编译**，整体服务于 “定制化配置 + 应用编译” 的完整流程，适配嵌入式设备的应用开发场景 ```bash # 配置使用WIFI if [ \"$RK_ENABLE_WIFI\" \"y\" ]; then echo \"Set Wifi SSID and PASSWD\" # 检查 LF_WIFI_PSK（WiFi密码）、 # LF_WIFI_SSID（WiFi名称）配置项是否定义，未定义则退出 check_config LF_WIFI_PSK LF_WIFI_SSID return 0 touch $WIFI_NEW_CONF # 写入wpa_supplicant格式的WiFi配置 # （嵌入式WiFi连接核心配置） cat >$WIFI_NEW_CONF <<EOF ctrl_interface /var/run/wpa_supplicant ap_scan 1 update_config 1 network { \tssid \"$LF_WIFI_SSID\" \tpsk \"$LF_WIFI_PSK\" \tkey_mgmt WPA PSK } EOF # 将临时配置文件移动到正式的WiFi配置路径（覆盖/替换原有配置） # /wifi_app/wpa_supplicant.conf mv $WIFI_NEW_CONF $WIFI_CONF fi # 查看应用的类型, 设置设置的是RKIPC_RV1106 check_config RK_APP_TYPE return 0 echo \" Start building app \" echo \"TARGET_APP_CONFIG $RK_APP_DEFCONFIG $RK_APP_DEFCONFIG_FRAGMENT $RK_APP_TYPE\" echo \" \" # 导出meta层头文件（供应用编译依赖，比如硬件抽象层、系统接口的头文件） build_meta export # export meta header files #build_meta export media_dir $RK_PROJECT_PATH_MEDIA # for rtl8723bs # 检查应用代码目录是否存在，存在则进入目录执行make编译 test d ${SDK_APP_DIR} && make C ${SDK_APP_DIR} ``` 在 Luckfox/RK 嵌入式平台中，“meta” 是设备的「核心元数据组件」，常见用途包括： 1. 存储设备硬件信息（芯片型号、内存大小、外设配置）； 2. 定义系统分区表（比如 boot/rootfs/recovery/meta 分区的大小、偏移）； 3. 保存系统版本号、出厂配置、加密密钥等； 4. 为应用层 / 驱动层提供统一的配置接口（比如之前应用编译时 `build_meta export` 就是导出 meta 的头文件，让应用能读取这些配置）。 ```bash function build_meta() { \tmsg_info \" Start building meta \" \tif [ n \"$RK_META_SIZE\" ]; then \t\t# 查看这个文件是不是存在(判断失败返回) \t\tif [ d \"${RK_PROJECT_TOP_DIR}/make_meta\" ]; then \t\t\t${RK_PROJECT_TOP_DIR}/make_meta/build_meta.sh $@ \t\tfi \tfi \tfinish_build } ``` > 实际这个文件不存在 ### build_firmware ```bash # 查看分区表配置是不是有效 #\"256K(env),256K@256K(idblock),512K(uboot),4M(boot),30M(oem),10M(userdata),210M(rootfs)\" check_config RK_PARTITION_CMD_IN_ENV return 0 # 构建环境变量镜像（env.img，存储uboot/env参数、系统启动配置） build_env # 没有使用 build_meta mkdir p ${RK_PROJECT_OUTPUT_IMAGE} # 启用Rercovery升级的话 if [ \"$RK_ENABLE_RECOVERY\" \"y\" a f $PROJECT_TOP_DIR/scripts/${RK_MISC: recovery misc.img} ]; then cp fv $PROJECT_TOP_DIR/scripts/$RK_MISC ${RK_PROJECT_OUTPUT_IMAGE}/misc.img fi # 打包根文件系统（rootfs）：将解压后的rootfs目录打包为镜像/压缩包 # 在这个函数里面写入一些配置文件 __PACKAGE_ROOTFS # 打包OEM分区：OEM分区用于存储厂商自定义配置、应用、资源文件 __PACKAGE_OEM # 生成“核心转储（coredump）启用脚本”：方便调试程序崩溃问题 __BUILD_ENABLE_COREDUMP_SCRIPT # 执行OEM打包前的自定义脚本：支持厂商在OEM打包前插入定制逻辑（如修改配置、添加文件） __RUN_PRE_BUILD_OEM_SCRIPT # 是否将应用打包到独立 OEM 分区 if [ \"$RK_BUILD_APP_TO_OEM_PARTITION\" \"y\" ]; then \t# 将应用单独打包到OEM镜像（OEM分区独立） rm rf $RK_PROJECT_PACKAGE_ROOTFS_DIR/oem/* mkdir p $RK_PROJECT_PACKAGE_ROOTFS_DIR/oem build_mkimg $GLOBAL_OEM_NAME $RK_PROJECT_PACKAGE_OEM_DIR else \t# 将OEM文件合并到rootfs的oem目录（无独立OEM分区） mkdir p $RK_PROJECT_PACKAGE_ROOTFS_DIR/oem __COPY_FILES $RK_PROJECT_PACKAGE_OEM_DIR $RK_PROJECT_PACKAGE_ROOTFS_DIR/oem rm rf $RK_PROJECT_PACKAGE_OEM_DIR fi # 执行打包后的自定义脚本：如修改镜像权限、添加校验、清理临时文件 __RUN_POST_BUILD_SCRIPT # 叠加自定义配置/文件：将SDK中“overlay目录”的自定义文件覆盖到镜像中（无需修改原始rootfs） post_overlay # 启用INITRAMFS启动（内存根文件系统）→ 打包boot.img if [ n \"$GLOBAL_INITRAMFS_BOOT_NAME\" ]; then build_mkimg boot $RK_PROJECT_PACKAGE_ROOTFS_DIR fi # 根据Fastboot配置选择打包目标 if [ \"$RK_ENABLE_FASTBOOT\" \"y\" ]; then \t# Fastboot模式打包boot.img build_mkimg boot $RK_PROJECT_PACKAGE_ROOTFS_DIR else \t# 普通模式打包rootfs.img build_mkimg $GLOBAL_ROOT_FILESYSTEM_NAME $RK_PROJECT_PACKAGE_ROOTFS_DIR fi # package a empty userdata parition image # 打包空的 userdata 分区镜像 mkdir p $RK_PROJECT_PACKAGE_USERDATA_DIR build_mkimg userdata $RK_PROJECT_PACKAGE_USERDATA_DIR # 构建TFTP/SD卡升级包：支持通过TFTP（网络）或SD卡刷机 build_tftp_sd_update # 启用Recovery/OTA时，构建OTA升级包 [ \"$RK_ENABLE_RECOVERY\" \"y\" o \"$RK_ENABLE_OTA\" \"y\" ] && build_ota # 构建统一更新镜像（update.img）：瑞芯微标准刷机镜像，支持RKDevTool工具烧录 build_updateimg # Spi_nand mklink # SPI NAND 是嵌入式常用的闪存介质，其镜像格式 / 路径有特殊要求 if [ \"${RK_BOOT_MEDIUM}\" \"spi_nand\" ]; then msg_info \"MEDIUM SPI_NAND relink Image\" files (\"${RK_PROJECT_OUTPUT_IMAGE}/oem.img\" \"${RK_PROJECT_OUTPUT_IMAGE}/rootfs.img\" \"${RK_PROJECT_OUTPUT_IMAGE}/userdata.img\") for file in \"${files[@]}\"; do if [ e \"$file\" ]; then \t# 获取镜像的实际路径（可能是软链接） filename $(basename \"$file\") target $(readlink f \"$file\") # 删除原软链接 rm \"$file\" # 将实际文件移到输出目录 mv \"$target\" \"$RK_PROJECT_OUTPUT_IMAGE/$filename\" fi done # 删除所有.ubi格式文件（SPI NAND不使用UBI镜像，清理冗余） find \"${RK_PROJECT_OUTPUT_IMAGE}\" type f name \"*.ubi\" exec rm {} + fi finish_build ``` ### build_ota 这段脚本是 **Luckfox / 瑞芯微（RK）嵌入式平台中「OTA 升级包（update_ota.tar）的构建逻辑」**，核心作用是：仅当启用 Recovery 或 OTA 功能时，将系统升级所需的核心镜像（如 uboot/boot/rootfs.img）和 Recovery 模式下的 OTA 升级脚本打包成 `update_ota.tar` 压缩包 —— 该包是设备 OTA 升级的核心载体，Recovery 模式下解压此包并执行脚本即可完成系统升级。 ```bash check_config RK_ENABLE_RECOVERY check_config RK_ENABLE_OTA return 0 # update_img：存储要打包到 OTA 包中的镜像列表（如 uboot.img、boot.img）； # update_script：存储要打包的 OTA 升级脚本（RK_OTA_update.sh）； # tar_cmd：存储最终执行的 tar 打包命令。 local update_img update_script tar_cmd if [ z \"$RK_OTA_RESOURCE\" ]; then \t# 使用默认镜像（uboot.img/boot.img/rootfs.img） for img in uboot.img boot.img rootfs.img; do if [ f \"$RK_PROJECT_OUTPUT_IMAGE/$img\" ]; then update_img \"$update_img $img\" else msg_warn \"Not found $img, check again!!!\" fi done else \t# 自定义了OTA镜像列表（RK_OTA_RESOURCE）→ 使用自定义列表 update_img \"$RK_OTA_RESOURCE\" fi [[ \"$RK_ENABLE_RECOVERY\" \"y\" ]] && update_script \" C $OTA_SCRIPT_PATH RK_OTA_update.sh\" tar_cmd \"tar cvhf $RK_PROJECT_OUTPUT_IMAGE/update_ota.tar \\ C $RK_PROJECT_OUTPUT_IMAGE $update_img \\ $update_script\" eval $tar_cmd finish_build ``` tar命令参数说明： ` c`：创建新的 tar 包； ` v`：可视化输出打包过程（打印包含的文件）； ` h`：跟随软链接（打包软链接指向的实际文件，避免打包空链接）； ` f`：指定输出的 tar 包文件名（update_ota.tar）； ` C $RK_PROJECT_OUTPUT_IMAGE`：先进入镜像输出目录，再打包 `$update_img`（确保 tar 包内镜像无绝对路径）。 `eval $tar_cmd`：执行构造的 tar 命令，最终在 `${RK_PROJECT_OUTPUT_IMAGE}` 目录生成 `update_ota.tar`。 ## 编译脚本 所有文件的编译文件是sysdrv/Makefile 核心目标是自动化编译、打包嵌入式系统所需的 UBoot、Linux 内核、根文件系统（rootfs）、UBoot 环境配置等核心组件，同时提供灵活的配置适配和清理 / 调试辅助功能。 1. **环境与参数初始化** 定义基础路径（`SYSDRV_DIR`为当前目录）、编译环境（强制 C 语言环境、指定 bash shell）、构建版本（RELEASE/DEBUG）、交叉编译工具链（支持外部传入`RK_TOOLCHAIN_CROSS`覆盖）、C 库类型（默认 glibc）。 支持**外部参数覆盖默认配置**（如`RK_BOOT_MEDIUM`指定启动介质、`RK_KERNEL_DTS`指定内核设备树、`RK_ROOTFS_FS_TYPE`指定根文件系统格式），适配不同硬件 / 构建需求。 配置启动介质（默认 emmc，支持 spi_nor/spi_nand/sd_card 等）、分区信息（通过脚本`get_part_info.sh`获取 rootfs/env 分区的大小 / 编号）。 2. **输出目录与工具配置** 划分清晰的输出目录结构：`out/`下分镜像（image）、板端工具（board）、PC 端工具（pc）、根文件系统（rootfs）子目录，区分 PC / 板端产物。 关联镜像制作工具（如`mkfs_ext4.sh`/`mkfs_ubi.sh`）、分区解析脚本，适配 ext4/ubi/jffs2/squashfs/erofs 等根文件系统格式。 编译的目标 ```makefile all: uboot kernel rootfs env ``` 在使用buildroot的时候rootfs依赖于 ```makefile ROOTFS_BUILD_ENV : rootfs_prepare pctools buildroot boardtools drv ``` ### 编译uboot > 可以使用./build.sh info查看使用的参数 ```makefile uboot: prepare \t@echo e \"$(C_GREEN) sysdrv build uboot $(C_NORMAL)\" \t# 根据配置文件生成配置文件 \t# make C $(UBOOT_DIR)echo_rv1106_uboot_defconfig rk sfc.config \t@$(MAKE) C $(UBOOT_DIR) $(UBOOT_CFG) $(UBOOT_CFG_FRAGMENT) \t# 切换目录, 同时把目录名压栈, 之后执行实际的编译命令 \t# 执行结束返回 \tpushd $(UBOOT_DIR);$(UBOOT_COMPILE_MAKE) $(UBOOT_COMPILE_MAKE_OPTS) CROSS_COMPILE $(CROSS_COMPILE);popd \t# 编译成功的时候输出uboot.img到输出目录里面 \t$(AT)test ! f $(UBOOT_DIR)/uboot.img cp fv $(UBOOT_DIR)/uboot.img $(SYSDRV_DIR_OUT_IMAGE) \t# 复制BOOT 目录下的原始 IDBLOCK 文件为idblock.img \t$(AT)cp fv $(UBOOT_DIR)/$(IDBLOCK_SRC_BIN) $(SYSDRV_DIR_OUT_IMAGE)/$(IDBLOCK_IMG) \t# download.bin \t$(AT)cp fv $(UBOOT_DIR)/$(DOWNLOAD_SRC_BIN) $(SYSDRV_DIR_OUT_IMAGE)/$(DOWNLOAD_BIN) \t# 批量拷贝 \t$(call MAROC_COPY_PKG_TO_SYSDRV_OUTPUT, $(OUTPUT_IMAGE_PATH), \\ \t\t$(SYSDRV_DIR_OUT_IMAGE)/$(IDBLOCK_IMG) \\ \t\t$(SYSDRV_DIR_OUT_IMAGE)/uboot.img \\ \t\t$(SYSDRV_DIR_OUT_IMAGE)/$(DOWNLOAD_BIN)) ``` ```bash cd /home/jiao/rv/echo mate/Echo Mate/SDK/rv1106 sdk/sysdrv/source/uboot/u boot make echo_rv1106_uboot_defconfig rk sfc.config ./make.sh spl new CROSS_COMPILE arm rockchip830 linux uclibcgnueabihf cp fv ./*_idblock_v*.img idblock.img cp fv ./*_download_v*.bin download.bin ``` ### 编译kernel ```makefile kernel: prepare \t@echo e \"$(C_GREEN) sysdrv build kernel $(C_NORMAL)\" ifeq ($(RK_ENABLE_FASTBOOT), y) \t# fastboot 模式下需确保驱动模块完整 \t$(call MACRO_CHK_DRIVER_MODULE, $(SYSDRV_DIR)/drv_ko/rockit/, rockit ko) \t$(call MACRO_CHK_DRIVER_MODULE, $(SYSDRV_DIR)/drv_ko/kmpp/, kmpp) endif \t# 删除旧的 DTB 文件（设备树） \t@rm rf $(KERNEL_DTB) \t# 生成.config文件 \t$(MAKE) C $(KERNEL_DIR) ARCH $(ARCH) CROSS_COMPILE $(CROSS_COMPILE) $(KERNEL_CFG) $(KERNEL_CFG_FRAGMENT) \t# 编译内核, 设备树(img后缀), 指定 U Boot 的镜像描述文件（ITS） \t# 用于打包内核镜像为 U Boot 可识别的格式 \t$(MAKE) C $(KERNEL_DIR) ARCH $(ARCH) CROSS_COMPILE $(CROSS_COMPILE) $(KERNEL_DTS:dts img) BOOT_ITS boot.its j$(SYSDRV_JOBS) ifeq ($(RK_ENABLE_FASTBOOT), y) \t$(call MACRO_CLEAN_DRIVER_MODULE, rockit ko) \t$(call MACRO_CLEAN_DRIVER_MODULE, kmpp) endif \t# 复制vmlinux镜像 \tcp fv $(KERNEL_DIR)/vmlinux $(SYSDRV_DIR_OUT_BOARD) \t# RK 平台自定义脚本，修改 DTB 文件中的内核启动参数 \tupdate_dtb_bootargs.sh cmdline '$(KERNEL_CMDLINE_FRAGMENT)' dtb $(KERNEL_DTB) output $(KERNEL_DTB) ifneq ($(RK_ENABLE_FASTBOOT), y) \t# 将修改后的 DTB重新整合到resource.img/boot.img中 \t# 手动修改 DTB 后，DTB 的时间戳更新，但 Makefile 无法关联 “DTB 更新→需要重新打包 img” \t$(MAKE) C $(KERNEL_DIR) ARCH $(ARCH) CROSS_COMPILE $(CROSS_COMPILE) $(KERNEL_DTS:dts img) BOOT_ITS boot.its j$(SYSDRV_JOBS) endif ifneq ($(KERNEL_DTB),) \t# 有dtb的时候, 复制dtb \tcp fv $(KERNEL_DTB) $(SYSDRV_DIR_OUT_BOARD) endif \t# Start install kernel drivers \t# 分场景拷贝内核产物 ifeq ($(SYSDRV_BUILD_RAMDISK_FLAG),YES) \t$(call MAROC_COPY_PKG_TO_SYSDRV_OUTPUT, $(OUTPUT_SYSDRV_RAMDISK_DIR), \\ \t\t$(KERNEL_DIR)/arch/$(ARCH)/boot/Image* \\ \t\t$(KERNEL_DTB) \\ \t\t$(KERNEL_DIR)/arch/$(ARCH)/boot/zImage \\ \t\t$(KERNEL_DIR)/resource.img) else ifneq ($(RK_ENABLE_FASTBOOT), y) \tcp fv $(KERNEL_DIR)/boot.img $(SYSDRV_DIR_OUT_IMAGE)/boot.img endif ifneq ($(OUTPUT_FASTBOOT_IMAGE_PATH),) \t$(call MAROC_COPY_PKG_TO_SYSDRV_OUTPUT, $(OUTPUT_FASTBOOT_IMAGE_PATH), $(KERNEL_DIR)/arch/$(ARCH)/boot/Image) \t$(call MAROC_COPY_PKG_TO_SYSDRV_OUTPUT, $(OUTPUT_FASTBOOT_IMAGE_PATH), $(KERNEL_DIR)/resource.img) \t$(call MAROC_COPY_PKG_TO_SYSDRV_OUTPUT, $(OUTPUT_FASTBOOT_IMAGE_PATH), $(KERNEL_DTB)) endif \t$(call MAROC_COPY_PKG_TO_SYSDRV_OUTPUT, $(OUTPUT_IMAGE_PATH), $(SYSDRV_DIR_OUT_IMAGE)/boot.img) \t$(call MAROC_COPY_PKG_TO_SYSDRV_OUTPUT, $(OUTPUT_BOARD_BIN_PATH), \\ \t\t$(SYSDRV_DIR_OUT_BOARD)/$(KERNEL_DTS:dts dtb) $(SYSDRV_DIR_OUT_BOARD)/vmlinux) endif ``` ```bash cd /home/jiao/rv/echo mate/Echo Mate/SDK/rv1106 sdk/sysdrv/source/kernel make ARCH arm CROSS_COMPILE arm rockchip830 linux uclibcgnueabihf echo_rv1106_linux_defconfig make ARCH arm CROSS_COMPILE arm rockchip830 linux uclibcgnueabihf BOOT_ITS boot.its rv1106g echo mate.img j15 ``` ### rootfs ```bash rootfs: $(ROOTFS_BUILD_ENV) \t@echo e \"$(C_GREEN) sysdrv build rootfs $(C_NORMAL)\" \t# make strip裁剪二进制文件(可执行程序、.so 库)的符号表,调试信息 \tmake C $(SYSDRV_DIR) strip \t# 切换到 sysdrv/out 目录 \t# 将 rootfs 目录打包为单个 tar 包, 返回 \tpushd $(SYSDRV_DIR)/out;tar cf $(OUT_ROOTFS).tar $(OUT_ROOTFS);popd \t@# RK_PARTITION_FS_TYPE_CFG is defined outside of sysdrv, \t@# so if defined RK_PARTITION_FS_TYPE_CFG, we ignore SYSDRV_ROOTFS_BUILD_TARGET \t@test \"$(ROOTFS_PART_SIZE)\" \"FAIL\" \\ \t\ttest \"$(RK_PARTITION_FS_TYPE_CFG)x\" ! \"x\" \\ \t\tmake C $(SYSDRV_DIR) $(SYSDRV_ROOTFS_BUILD_TARGET) \t$(call MAROC_COPY_PKG_TO_SYSDRV_OUTPUT, $(OUTPUT_ROOTFS_SOURCE_DIR), $(SYSDRV_DIR)/out/$(OUT_ROOTFS).tar ) \t$(call MAROC_COPY_PKG_TO_SYSDRV_OUTPUT, $(OUTPUT_ROOTFS_TOOLS_DIR), $(SYSDRV_DIR)/out/bin ) \t@echo e \"$(C_GREEN) sysdrv finish sysdrv build $(C_NORMAL)\" ``` #### prepare ```makefile rootfs_prepare: prepare \t@echo e \"$(C_GREEN) sysdrv prepare rootfs $(C_NORMAL)\" \trm rf $(SYSDRV_DIR_OUT_ROOTFS) \tmkdir p $(SYSDRV_DIR_OUT_ROOTFS) \t# 解压 rootfs 基础脚本 / 配置, 解压到指定的 rootfs 目录 \t# sysdrv/out/rootfs_uclibc_rv1106, 里面是一个基础的rootfs框架 \ttar xf $(SYSDRV_DIR)/tools/board/rootfs_script.tar C $(SYSDRV_DIR_OUT_ROOTFS) \t# 解压交叉编译器运行时库 \ttar xjf $(TOOLCHAIN_DIR)/$(TOOLCHAIN_RUNTIME_LIB)/$(TOOLCHAIN_RUNTIME_LIB_C) C $(SYSDRV_DIR_OUT_ROOTFS) \t# 这些调试库体积大且量产时无用，迁移到SYSDRV_DIR_OUT_BOARD(板级调试目录) \tpushd $(SYSDRV_DIR_OUT_ROOTFS)/lib/ ; mv fv \\ \t\tlibasan_preinit.o \\ \t\tlibasan.so* \\ \t\tlibtsan.so* \\ \t\tlibubsan.so* \\ \t\tlibSegFault.so \\ \t\tlibmemusage.so* \\ \t\tlibpcprofile.so* \\ \t\tlibthread_db*.so* \\ \t\tlibBrokenLocale* \\ \t\tlibinproctrace.so \\ \t\t$(SYSDRV_DIR_OUT_BOARD); \\ \tpopd ``` 实际的rootfs_script.tar里面的结构如下 ```bash . ├── bin ├── data > userdata ├── dev ├── etc │ ├── fstab │ ├── group │ ├── hostname │ ├── hosts │ ├── init.d │ │ ├── rcK │ │ ├── rcS │ │ └── S20urandom │ ├── inittab │ ├── mtab > ../proc/self/mounts │ ├── network │ │ ├── if down.d │ │ ├── if post down.d │ │ ├── if pre up.d │ │ │ └── wait_iface │ │ ├── if up.d │ │ └── interfaces │ ├── nsswitch.conf │ ├── os release > ../usr/lib/os release │ ├── passwd │ ├── profile │ ├── profile.d │ │ ├── RkEnv.sh │ │ └── umask.sh │ ├── protocols │ ├── resolv.conf > ../tmp/resolv.conf │ ├── services │ └── shadow ├── lib ├── lib32 > lib ├── lib64 > lib ├── media ├── mnt │ └── sdcard ├── oem ├── opt ├── proc ├── root ├── run ├── sbin ├── sys ├── tmp ├── userdata ├── usr │ ├── bin │ ├── lib │ ├── lib32 > lib │ ├── lib64 > lib │ ├── sbin │ └── share │ └── udhcpc │ ├── default.script │ └── default.script.d └── var ├── cache > ../tmp ├── lib │ └── misc > ../../tmp ├── lock > ../tmp ├── log > ../tmp ├── run > ../run ├── spool > ../tmp ├── tmp > ../tmp └── www ``` 库名 作用（为什么迁移） libasan/tsan/ubsan 内存 / 线程 / 未定义行为检测的调试库（ASAN/TSAN/UBSAN），仅调试用，量产无需 libSegFault.so 段错误调试库（打印段错误堆栈），量产不需要 libmemusage.so 内存使用分析库，调试性能用 libpcprofile.so 性能分析库，调试用 libthread_db*.so 线程调试库（gdb 调试线程用），量产无需 libBrokenLocale 兼容旧字符集的库，嵌入式系统通常不用 libinproctrace.so 进程跟踪调试库，调试用 #### pctools 实际是给out/bin/pc下面的文件执行权限 #### buildroot 条件化初始化 Buildroot 环境（解压源码 + 定制配置 / 补丁）→ 配置 Buildroot（适配开发板）→ 优化镜像源（加速下载）→ 下载依赖源码 → 多核编译 Buildroot ```makefile buildroot: prepare \t@echo e \"$(C_GREEN) sysdrv build buildroot $(C_NORMAL)\" \t# 目录不存在才执行 \ttest d $(BUILDROOT_DIR)/$(BUILDROOT_VER) (\\ \t\t# 创建对应的buildroot目录 \t\tmkdir p $(BUILDROOT_DIR) ;\\ \t\t# 解压指定版本的 Buildroot 源码包到 Buildroot 根目录 \t\ttar xzf $(SYSDRV_DIR)/tools/board/buildroot/$(BUILDROOT_VER).tar.gz C $(BUILDROOT_DIR) ;\\ \t\t# 拷贝 Luckfox Pico/W 开发板的定制配置到 Buildroot 的 configs 目录 \t\tcp $(SYSDRV_DIR)/tools/board/buildroot/luckfox_pico_defconfig $(BUILDROOT_DIR)/$(BUILDROOT_VER)/configs/ ;\\ \t\tcp $(SYSDRV_DIR)/tools/board/buildroot/luckfox_pico_w_defconfig $(BUILDROOT_DIR)/$(BUILDROOT_VER)/configs/ ;\\ \t\t# 替换 Buildroot 默认的 Busybox 配置，定制嵌入式工具集 \t\tcp $(SYSDRV_DIR)/tools/board/buildroot/busybox.config $(BUILDROOT_DIR)/$(BUILDROOT_VER)/package/busybox/ ;\\ \t\t# 拷贝蓝牙工具（bluez5_utils）的编译修复补丁 \t\t# 解决原版 Buildroot 中 bluez5 编译报错的问题 \t\tcp ${HCITOOL_TOOL_PATH}/0001 Fixed header file errors.patch $(BUILDROOT_DIR)/$(BUILDROOT_VER)/package/bluez5_utils/ ;\\ \t\tcp ${HCITOOL_TOOL_PATH}/0002 Fix build errors.patch $(BUILDROOT_DIR)/$(BUILDROOT_VER)/package/bluez5_utils/ ;\\ \t\tcp ${HCITOOL_TOOL_PATH}/0003 fix compat wordexp.patch $(BUILDROOT_DIR)/$(BUILDROOT_VER)/package/bluez5_utils/ ;\\ \t\t# 拷贝 MPV 播放器的编译补丁（调整编译线程数为 1，避免多核编译冲突） \t\tcp ${MPV_PATCH_PATH}/0002 change j1.patch $(BUILDROOT_DIR)/$(BUILDROOT_VER)/package/mpv/ ;\\ \t); \t# 加载编译的配置文件 \t$(MAKE) ARCH $(ARCH) CROSS_COMPILE $(CROSS_COMPILE) $(BUILDROOT_DEFCONFIG) C $(BUILDROOT_DIR)/$(BUILDROOT_VER) \t# 核心功能是修改.config文件中的下载源 \t# (如将http://ftp.gnu.org替换为国内镜像站, 如清华/阿里源) \t$(SYSDRV_DIR)/tools/board/mirror_select/buildroot_mirror_select.sh $(BUILDROOT_DIR)/$(BUILDROOT_VER)/.config \t# 下载所有依赖包的源码 \t$(MAKE) ARCH $(ARCH) CROSS_COMPILE $(CROSS_COMPILE) source C $(BUILDROOT_DIR)/$(BUILDROOT_VER) \t# 多核编译 Buildroot \t$(MAKE) ARCH $(ARCH) CROSS_COMPILE $(CROSS_COMPILE) j$(SYSDRV_JOBS) C $(BUILDROOT_DIR)/$(BUILDROOT_VER) ``` #### boardtools ```bash boardtools: tools_board builds \t@echo e \"$(C_GREEN) sysdrv build tools which run on board $(C_NORMAL)\" ``` ```makefile tools_board builds: \\ \t\tboard build toolkits \\ \t\tboard build gdb \\ \t\tboard build eudev \\ \t\tboard build rndis \\ \t\tboard build adbd \\ \t\tboard build rk_ota \\ \t\tboard build rockchip_test \\ \t\tboard build e2fsprogs \\ \t\tboard build sysstat \\ \t\tboard build mtd_utils \t@echo \"build tools board done\" \t board build toolkits: \t$(MAKE) C $(SYSDRV_DIR)/tools/board/toolkits board build gdb: ifeq ($(ENABLE_GDB),y) \t$(MAKE) C $(SYSDRV_DIR)/tools/board/gdb; endif ``` 编译使用的工作, 在文件sysdrv/tools/board/Makefile.tools.board.mk里面 #### drv **嵌入式系统中「内核驱动（.ko 模块）」构建与部署的 Makefile 核心脚本**（目标`drv`），核心逻辑是：清理旧驱动文件 → 编译并安装内核原生驱动（裁剪符号表精简体积）→ 收集所有`.ko`文件到统一目录 → 编译自定义驱动 → 最终将驱动模块分发到根文件系统源码目录 ```makefile drv: prepare \t@echo e \"$(C_GREEN) sysdrv build drv $(C_NORMAL)\" \t# 清除之前的编译 \t@ rm rf $(SYSDRV_KERNEL_MOD_PATH) $(KERNEL_DIR_DRV_KO) \t# 创建输出目录 \t@ mkdir p $(SYSDRV_KERNEL_MOD_PATH) \t# modules_install：内核 Makefile 的专属目标 \t# 作用是编译所有已配置的内核驱动(CONFIG_XXX m的模块)，并安装到指定目录 \t# INSTALL_MOD_STRIP 1：核心优化—— 裁剪.ko文件的符号表 / 调试信息 \t# 指定驱动安装的临时目录 \t$(MAKE) C $(KERNEL_DIR) ARCH $(ARCH) CROSS_COMPILE $(CROSS_COMPILE) j$(SYSDRV_JOBS) \\ \t\tmodules_install INSTALL_MOD_STRIP 1 \\ \t\tINSTALL_MOD_PATH $(KERNEL_DIR_DRV_KO) \t# 递归查找临时安装目录下所有.ko（内核驱动模块）文件 \t# 将分散在临时目录中的驱动模块（按内核子系统分类存放，如 \t# drivers/net/drivers/usb）集中到SYSDRV_KERNEL_MOD_PATH \t$(AT)find $(KERNEL_DIR_DRV_KO)/lib/modules/*/kernel \\ \t\t name \"*.ko\" type f exec cp fav {} $(SYSDRV_KERNEL_MOD_PATH) \\; # 如果drv_ko目录存在，则执行括号内的编译操作 \t@test ! d drv_ko ($(MAKE) C $(SYSDRV_DIR)/drv_ko KERNEL_DRV_KO_INSTALL_PATH $(SYSDRV_KERNEL_MOD_PATH)) \t$(call MAROC_COPY_PKG_TO_SYSDRV_OUTPUT, $(OUTPUT_ROOTFS_SOURCE_DIR), $(SYSDRV_KERNEL_MOD_PATH), SELF) ``` ## 输出文件 ``` out ├── bin │   ├── board_xxx 运行在单板端的文件 │   └── pc 运行在PC服务器端的工具 ├── image_xxx 生成的烧录固件 │   ├── download.bin 烧录工具升级通讯的设备端程序，只会下载到板子内存 │   ├── env.img 包含分区表和启动参数 │   ├── idblock.img loader镜像 │   ├── uboot.img uboot镜像 │   ├── boot.img kernel镜像 │   └── rootfs_base.img rootfs镜像 │ ├── rootfs_xxx 生成的根文件系统目录 └── rootfs_xxx.tar 生成的根文件系统目录的tar文件包 ``` env.img UBOOT 配置文件 BIOS 设置（启动项、串口） 256KB idblock.img RK 芯片启动钥匙 主板 BIOS 固件（底层初始化） 181KB uboot.img 第一阶段引导程序 BIOS/UEFI（硬件初始化） 256KB boot.img 内核 + 设备树 Windows 内核（ntoskrnl.exe） 3.08MB oem.img 厂商定制内容 品牌机预装软件 / 驱动 20MB userdata.img 用户数据区 我的文档 / 桌面 1.875MB rootfs.img 根文件系统（用户空间） Windows C 盘（系统文件） 78MB + env.img 存储 UBOOT 的「环境变量配置」，是 UBOOT 的 “配置文件”, UBOOT 启动时会先读取该分区，按配置执行后续流程（如加载 uboot.img、boot.img） + idblock.img 瑞芯微平台专属的「底层启动块」，是芯片启动的 “钥匙”, 芯片底层初始化代码（SPI NAND 控制器、DDR、时钟等硬件的最基础配置）, 签名 / 校验信息（RK 芯片启动时验证，防止非法镜像） + uboot.img 嵌入式系统的「第一阶段引导程序」，是连接硬件和内核的桥梁, 初始化核心硬件（DDR、串口、网口、SPI NAND 等） + boot.img：内核 + 设备树镜像 包含 Linux 内核(Image/zImage)+ 设备树(DTB), 部分场景含 ramdisk(内存根文件系统) + oem.img：OEM 定制分区镜像 存储「厂商定制化内容」，非系统核心但影响设备功能, 设备型号配置、出厂校准数据(如屏幕、摄像头参数), OEM专属驱动、应用(如厂商自研的控制程序) + userdata.img：用户数据分区镜像 存储「用户动态数据」，是系统运行的 “可写分区”，包含 + rootfs.img：根文件系统镜像"},"/note/Linux/瑞芯微Linux/2025-12-5-02-EchoAI代码.html":{"title":"EchoAI代码","content":"# EchoAI代码 ## 文件 + AIChat_demo: 对话相关 + assets + DeskBot_demo: 桌面控制 + + bin: 输出文件 + build: 中间文件 + common: 控制组件 + + event_manager: + gpio_manager: 引脚控制 + sys_manager: + ## 唤醒词 [Snowboy Personal Wake Word](https://snowboy.hahack.com/) 可以在这个网页生成.pmdl文件, 使用的是Snowboy ```c void IdleState::Run(Application* app) { USER_LOG_INFO(\"Idle state run.\"); SnowboyDetect* detector SnowboyDetectConstructor(\"third_party/snowboy/resources/common.res\", \"third_party/snowboy/resources/models/echo.pmdl\"); SnowboyDetectSetSensitivity(detector, \"0.5\"); SnowboyDetectSetAudioGain(detector, 1); SnowboyDetectApplyFrontend(detector, false); std::vector<int16_t> data; while (state_running_.load() true) { if(app >audio_processor_.recordedQueueIsEmpty() false) { app >audio_processor_.getRecordedAudio(data); // 检测唤醒词 int result SnowboyDetectRunDetection(detector, data.data(), data.size(), false); if (result > 0) { // 发生唤醒事件 USER_LOG_INFO(\"Wake detected.\"); app >eventQueue_.Enqueue(static_cast<int>(AppEvent::wake_detected)); break; } } } SnowboyDetectDestructor(detector); } ``` Snowboy 是一个基于深度神经网络（DNN）的唤醒词检测引擎，最初由 Kitt.AI 开发，旨在为语音激活应用提供高效的解决方案。它允许设备在检测到特定唤醒词（如“Hey Siri”或“OK Google”）时启动语音处理，而无需依赖云端服务 Snowboy 提供了多种语言的 SDK，包括 Python、C++、Java 等 > [snowboy/README_ZH_CN.md at master · Kitt AI/snowboy](https://github.com/Kitt AI/snowboy/blob/master/README_ZH_CN.md) 这里使用的是他的树莓派的库文件 ```bash jiao@jiao virtual machine:~/rv/echo mate/Echo Mate/Demo$ file AIChat_demo/Client/third_party/snowboy/lib/rpi/libsnowboy detect.a AIChat_demo/Client/third_party/snowboy/lib/rpi/libsnowboy detect.a: current ar archive jiao@jiao virtual machine:~/rv/echo mate/Echo Mate/Demo$ file *.o head 1 afe stream.o: ELF 32 bit LSB relocatable, ARM, EABI5 version 1 (SYSV), not stripped ``` **ARMv8**（64位）：通常**不兼容** ARMv6/ARMv7 的二进制 **ARMv8**（32位模式/AArch32）：可以运行 ARMv7 编译的程序 **ARMv7**：通常**兼容** ARMv6（但某些特性可能缺失） **ARMv6**：**不能**在 ARMv7/ARMv8 上保证运行（如果编译时用了更高版本特性） **32位 ARM 架构**（不是 64 位） RV1106 是基于 **Cortex A7** 的 SoC，特性包括： **ARMv7 A** 架构 支持 **32位** 和 **Thumb 2** 指令集 支持 **VFPv4** 浮点单元 支持 **NEON** SIMD 扩展 ## 引脚控制 通过 sysfs 方式控制 GPIO，先访问 /sys/class/gpio 目录，向 export 文件写入 GPIO 编号，使得该 GPIO 的操作接口从内核空间暴露到用户空间，GPIO 的操作接口包括 direction 和 value 等，direction 控制 GPIO 方向，而 value 可控制 GPIO 输出或获得 GPIO 输入 这个功能需要在内核里面使能 ```bash Device Drivers > GPIO Support > /sys/class/gpio/… (sysfs interface) ``` 1、gpio_operation 通过 /sys/ 文件接口操作 IO 端口 GPIO 到文件系统的映射。 2、控制 GPIO 的目录位于 /sys/class/gpio。 3、/sys/class/gpio/export 文件用于通知系统需要导出控制的 GPIO 引脚编号。 4、/sys/class/gpio/unexport 用于通知系统取消导出。 5、/sys/class/gpio/gpiochipX 目录保存系统中 GPIO 寄存器的信息，包括每个寄存器控制引脚的起始编号 base，寄存器名称，引脚总数。 在使用的时候可以使用`calculate_gpio_pin`计算实际的引脚的位置 ```c int calculate_gpio_pin(int bank, int group, int x) { return bank * 32 + (group * 8 + x); } #define LED_BLUE calculate_gpio_pin(0, 0, 4) // GPIO0_A4 ``` ## 系统控制 ### 背光 控制的文件是`/sys/class/backlight/backlight/brightness` ### 音量 + 打开一个混音器, 绑定到对应的声卡 + 注册混音器元素类 + 加载指定声卡上的所有混音器控件 + 使用控件的标号以及名字获取控制句柄 + 使用控制句柄设置实际的属性 ### 设置以及获取时间 在Linux系统中，settimeofday函数用于设置系统时间。这个函数可以精确到微秒，允许用户根据需要调整系统时间, 一般需要是root权限的用户 ### 查看网络是不是连通 使用连接8.8.8.8服务器的方式进行 ```c bool is_internet_reachable(void) { int sockfd; struct sockaddr_in servaddr; // 创建socket if ((sockfd socket(AF_INET, SOCK_STREAM, 0)) < 0) { perror(\"Socket creation failed\"); return false; } // 设置socket为非阻塞 int flags fcntl(sockfd, F_GETFL, 0); if (fcntl(sockfd, F_SETFL, flags O_NONBLOCK) 1) { perror(\"Failed to set socket as non blocking\"); close(sockfd); return false; } servaddr.sin_family AF_INET; servaddr.sin_port htons(53); // Google DNS服务端口 servaddr.sin_addr.s_addr inet_addr(\"8.8.8.8\"); // Google Public DNS IP地址 // 尝试连接, 非阻塞的模式一般极少数时候出现直接连接成功 if (connect(sockfd, (struct sockaddr*)&servaddr, sizeof(servaddr)) < 0) { if (errno ! EINPROGRESS) { close(sockfd); return false; } // 后台在连接 // 使用select等待连接完成或超时 // 写文件描述符集合。TCP 连接完成时，socket 会变为「可写」状态 fd_set writefds; FD_ZERO(&writefds); FD_SET(sockfd, &writefds); // 把sockfd加入集合 struct timeval timeout; timeout.tv_sec 2; // 超时时间为2秒 timeout.tv_usec 0; // 使用多路IO检测函数查看IO可写状态 int ret select(sockfd + 1, NULL, &writefds, NULL, &timeout); if (ret 0) { // 超时 fprintf(stderr, \"Connection timed out\\n\"); close(sockfd); return false; } else if (ret < 0) { // 错误发生 perror(\"Select failed\"); close(sockfd); return false; } // 检查是否成功连接 // select 检测到 socket 可写，不代表连接成功（比如对方拒绝连接时，socket 也会可写），必须通过 getsockopt 检查具体的错误码 int so_error; socklen_t len sizeof(so_error); // 获取 socket 的选项，这里取 SO_ERROR（socket 错误状态） if (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &so_error, &len) < 0 so_error ! 0) { if (so_error ! 0) { errno so_error; } perror(\"Connect failed\"); close(sockfd); return false; } } close(sockfd); return true; } ``` ### 获取ip地址 使用的是库libcurl「easy 接口」, 是 C 语言的跨平台网络传输库，支持几乎所有主流网络协议 easy 句柄（`CURL*`）**非线程安全**，一个句柄只能在一个线程中使用；若需多线程并发，建议用 libcurl 的 multi 接口（`curl_multi_*`） #### libcurl库 [libcurl curl_easy_setopt()](https://curl.se/libcurl/c/curl_easy_setopt.html) + API ```c // 创建句柄 curl_easy_init() // 设置参数 CURLcode curl_easy_setopt(CURL *handle, CURLoption option, ...); ``` libcurl 预定义的配置选项宏（数百个），覆盖网络请求的所有维度，比如： `CURLOPT_URL`：设置请求的 URL（核心选项）； `CURLOPT_TIMEOUT`：设置请求超时时间（秒）； `CURLOPT_HTTPGET`/`CURLOPT_POST`：指定 HTTP 请求方法； `CURLOPT_WRITEFUNCTION`：设置响应数据的回调函数； `CURLOPT_SSL_VERIFYPEER`：是否验证服务器 SSL 证书（测试时可设为 0 跳过）； `CURLOPT_PROXY`：设置代理地址。 下面是一个简单的使用流程 ```c #include <curl/curl.h> #include <stdio.h> int main() { // 1. 初始化 easy 句柄 CURL *curl curl_easy_init(); if (!curl) { fprintf(stderr, \"curl_easy_init failed\\n\"); return 1; } // 2. 核心：通过 curl_easy_setopt 配置参数 // 2.1 设置请求 URL curl_easy_setopt(curl, CURLOPT_URL, \"https://www.baidu.com\"); // 2.2 设置超时时间（10 秒） curl_easy_setopt(curl, CURLOPT_TIMEOUT, 10L); // 2.3 跳过 SSL 证书验证（仅测试用，生产环境禁用） curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L); // 3. 执行请求 CURLcode res curl_easy_perform(curl); if (res ! CURLE_OK) { fprintf(stderr, \"curl_easy_perform failed: %s\\n\", curl_easy_strerror(res)); } // 4. 清理句柄 curl_easy_cleanup(curl); return 0; } ``` + 使用POST请求 ```c // POST 数据 const char *post_data \"username test&password 123456\"; curl_easy_setopt(curl, CURLOPT_POST, 1L); // 启用 POST 方法 curl_easy_setopt(curl, CURLOPT_POSTFIELDS, post_data); // 设置 POST 数据 curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, strlen(post_data)); // 数据长度 ``` + libcurl 会把响应数据打印到 stdout，通过回调可自定义处理（比如写入内存 / 文件） ```c // 回调函数：接收响应数据（size*nmemb 是数据长度，ptr 是数据指针，userdata 是自定义参数） size_t write_callback(char *ptr, size_t size, size_t nmemb, void *userdata) { // userdata 传入的是字符串缓冲区，拼接数据 char *buffer (char*)userdata; strcat(buffer, ptr); return size * nmemb; // 必须返回实际处理的字节数，否则 libcurl 会认为出错 } // 配置回调 char response[1024] {0}; curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback); // 设置回调函数 curl_easy_setopt(curl, CURLOPT_WRITEDATA, response); // 传给回调的自定义参数 ``` + 设置头 ```c // 构造请求头（比如指定 User Agent、Content Type） struct curl_slist *headers NULL; headers curl_slist_append(headers, \"User Agent: MyCurl/1.0\"); headers curl_slist_append(headers, \"Content Type: application/json\"); curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers); // 设置请求头 // 注意：请求结束后要释放 headers curl_slist_free_all(headers); ``` #### json c库 Debian/Ubuntu：`sudo apt install libjson c dev` CentOS/RHEL：`sudo yum install json c devel` ```c #include <json c/json.h> #include <stdio.h> int main() { // 创建 JSON 对象 json_object *obj json_object_new_object(); json_object_object_add(obj, \"name\", json_object_new_string(\"json c\")); json_object_object_add(obj, \"version\", json_object_new_string(\"0.17\")); // 序列化为字符串并打印 const char *json_str json_object_to_json_string(obj); printf(\"JSON: %s\\n\", json_str); // 释放内存 json_object_put(obj); return 0; } ``` 解析实例 ```c #include <stdio.h> #include <stdlib.h> // 引入 json c 核心头文件（新版本路径） #include <json c/json.h> int main() { // 1. 定义待解析的 JSON 字符串（标准格式，键必须用双引号） const char *json_str \"{\\\"name\\\":\\\"张三\\\",\\\"age\\\":25,\\\"is_student\\\":false}\"; printf(\"原始 JSON 字符串：%s\\n\\n\", json_str); // 2. 解析 JSON 字符串为 json_object 对象（核心步骤） struct json_object *root_obj json_tokener_parse(json_str); // 检查解析是否失败（比如 JSON 格式错误） if (root_obj NULL) { fprintf(stderr, \"JSON 解析失败！请检查字符串格式\\n\"); return 1; } // 3. 提取字段（按类型分别处理，避免类型不匹配出错） // 3.1 提取字符串类型字段：name struct json_object *name_obj; // 从根对象中获取 \"name\" 对应的 value if (json_object_object_get_ex(root_obj, \"name\", &name_obj)) { // 转为 C 语言字符串 const char *name json_object_get_string(name_obj); printf(\"姓名：%s\\n\", name); } else { fprintf(stderr, \"未找到 name 字段\\n\"); } // 3.2 提取整数类型字段：age struct json_object *age_obj; if (json_object_object_get_ex(root_obj, \"age\", &age_obj)) { // 转为 C 语言整数 int age json_object_get_int(age_obj); printf(\"年龄：%d\\n\", age); } else { fprintf(stderr, \"未找到 age 字段\\n\"); } // 3.3 提取布尔类型字段：is_student struct json_object *is_student_obj; if (json_object_object_get_ex(root_obj, \"is_student\", &is_student_obj)) { // 转为 C 语言布尔值（json c 中 0 为 false，1 为 true） int is_student json_object_get_boolean(is_student_obj); printf(\"是否学生：%s\\n\", is_student ? \"是\" : \"否\"); } else { fprintf(stderr, \"未找到 is_student 字段\\n\"); } // 4. 释放内存（关键！避免内存泄漏） json_object_put(root_obj); return 0; } ``` #### 实际使用 ```c // 回调函数用于处理CURL接收到的数据 size_t WriteCallback(void* contents, size_t size, size_t nmemb, void* userp) { size_t realsize size * nmemb; char** response_string (char**)userp; \t// 重新拓展一下字符串 char* new_string realloc(*response_string, realsize + 1); if(new_string NULL) { // 内存分配失败 fprintf(stderr, \"Failed to allocate memory\\n\"); return 0; } *response_string new_string; memcpy(*response_string + strlen(*response_string), contents, realsize); (*response_string)[realsize] '\\0'; return realsize; } // 使用高德地图API根据IP地址获取自动定位信息 int sys_get_auto_location_by_ip(LocationInfo_t* location, const char *api_key) { CURL* curl_handle; CURLcode res; char url[256]; snprintf(url, sizeof(url), \"https://restapi.amap.com/v3/ip?key %s\", api_key); char* response_string malloc(1); // 初始化为空字符串 if (!response_string) { fprintf(stderr, \"Failed to allocate memory\\n\"); return 1; } response_string[0] '\\0'; curl_global_init(CURL_GLOBAL_ALL); curl_handle curl_easy_init(); if (!curl_handle) { fprintf(stderr, \"Failed to initialize CURL\\n\"); free(response_string); curl_global_cleanup(); return 1; } curl_easy_setopt(curl_handle, CURLOPT_URL, url); // 设置回调函数 curl_easy_setopt(curl_handle, CURLOPT_WRITEFUNCTION, WriteCallback); curl_easy_setopt(curl_handle, CURLOPT_WRITEDATA, &response_string); // 指定使用的证书, HTTPS证书文件 curl_easy_setopt(curl_handle, CURLOPT_CAINFO, \"cacert.pem\"); // 设置超时时间为5秒 curl_easy_setopt(curl_handle, CURLOPT_TIMEOUT, 5L); \t// 实际的执行 res curl_easy_perform(curl_handle); if(res ! CURLE_OK) { fprintf(stderr, \"curl_easy_perform() failed: %s\\n\", curl_easy_strerror(res)); free(response_string); curl_easy_cleanup(curl_handle); curl_global_cleanup(); return 1; } \t// 解析json字符串 struct json_object *parsed_json json_tokener_parse(response_string); if (!parsed_json) { printf(\"Failed to parse JSON\\n\"); free(response_string); curl_easy_cleanup(curl_handle); curl_global_cleanup(); return 1; } struct json_object *province_obj, *city_obj, *adcode_obj; json_object_object_get_ex(parsed_json, \"province\", &province_obj); json_object_object_get_ex(parsed_json, \"city\", &city_obj); json_object_object_get_ex(parsed_json, \"adcode\", &adcode_obj); // 检查province, city, adcode是否为空数组 if(json_object_is_type(province_obj, json_type_array) && json_object_array_length(province_obj) 0 && json_object_is_type(city_obj, json_type_array) && json_object_array_length(city_obj) 0 && json_object_is_type(adcode_obj, json_type_array) && json_object_array_length(adcode_obj) 0) { printf(\"Location information is empty. This might be due to an invalid or foreign IP address.\\n\"); json_object_put(parsed_json); // 释放JSON对象 free(response_string); curl_easy_cleanup(curl_handle); curl_global_cleanup(); return 2; // 自定义错误码表示位置信息为空 } \t// 记录信息 strncpy(location >city, json_object_get_string(city_obj), sizeof(location >city) 1); location >city[sizeof(location >city) 1] '\\0'; // 确保字符串以null结尾 strncpy(location >adcode, json_object_get_string(adcode_obj), sizeof(location >adcode) 1); location >adcode[sizeof(location >adcode) 1] '\\0'; // 确保字符串以null结尾 printf(\"City: %s\\n\", location >city); printf(\"Adcode: %s\\n\", location >adcode); json_object_put(parsed_json); // 释放JSON对象 free(response_string); curl_easy_cleanup(curl_handle); curl_global_cleanup(); return 0; } ``` #### 加载配置文件 ## 页面管理"},"/note/Linux/瑞芯微Linux/2025-12-5-01-EchoAI编译代码.html":{"title":"EchoAI编译代码","content":"# EchoAI编译代码 ## 下载 在下载的时候需要个vmware关了!!! ## 编译程序 修改Cmake文件添加ARM平台的库文件 ```c if(TARGET_ARM) if(NOT DEFINED CMAKE_TOOLCHAIN_FILE) set(CMAKE_TOOLCHAIN_FILE \"${CMAKE_CURRENT_SOURCE_DIR}/toolchain.cmake\" CACHE FILEPATH \"Default toolchain file for ARM builds\") message(STATUS \"No toolchain file specified; using default: ${CMAKE_TOOLCHAIN_FILE}\") endif() message(STATUS \"Building for ARM using toolchain file: ${CMAKE_TOOLCHAIN_FILE}\") # 设置自定义库路径 set(ARM_LIBS_PATH \"/opt/rv1106 libs\" CACHE PATH \"Path to ARM libraries\") set(ARM_BOOST_PATH \"/opt/arm boost\" CACHE PATH \"Path to ARM Boost libraries\") # 设置库查找路径 set(CMAKE_PREFIX_PATH \"${ARM_LIBS_PATH};${ARM_BOOST_PATH};${CMAKE_PREFIX_PATH}\") set(CMAKE_MODULE_PATH \"${ARM_LIBS_PATH}/cmake;${CMAKE_MODULE_PATH}\") # 设置 pkg config 路径 set(ENV{PKG_CONFIG_PATH} \"${ARM_LIBS_PATH}/lib/pkgconfig:$ENV{PKG_CONFIG_PATH}\") set(ENV{PKG_CONFIG_LIBDIR} \"${ARM_LIBS_PATH}/lib/pkgconfig\") else() message(STATUS \"Building for x86 native architecture.\") endif() ... # 修改 SDL2 查找部分 if(TARGET_ARM) # 对于 ARM 交叉编译，手动设置 SDL2 路径 set(SDL2_DIR \"${ARM_LIBS_PATH}/cmake/SDL2\") set(SDL2_INCLUDE_DIR \"${ARM_LIBS_PATH}/include\") set(SDL2_LIBRARY \"${ARM_LIBS_PATH}/lib/libSDL2.so\") # 手动设置 SDL2_image 路径 set(SDL2_IMAGE_INCLUDE_DIR \"${ARM_LIBS_PATH}/include\") set(SDL2_IMAGE_LIBRARY \"${ARM_LIBS_PATH}/lib/libSDL2_image.so\") # 设置库变量 set(SDL2_INCLUDE_DIRS ${SDL2_INCLUDE_DIR}) set(SDL2_LIBRARIES ${SDL2_LIBRARY}) set(SDL2_IMAGE_INCLUDE_DIRS ${SDL2_IMAGE_INCLUDE_DIR}) set(SDL2_IMAGE_LIBRARIES ${SDL2_IMAGE_LIBRARY}) message(STATUS \"SDL2 include dir: ${SDL2_INCLUDE_DIR}\") message(STATUS \"SDL2 library: ${SDL2_LIBRARY}\") else() # 原生编译使用 find_package find_package(SDL2 REQUIRED) find_package(SDL2_image REQUIRED) endif() ``` 编译SDL2使之可以在ARM平台使用 ```bash cd /tmp wget https://www.libsdl.org/release/SDL2 2.26.5.tar.gz tar xzf SDL2 2.26.5.tar.gz cd /tmp/SDL2 2.26.5 # 方法一：使用环境变量（推荐） export CC \"/home/jiao/rv/echo mate/Echo Mate/SDK/rv1106 sdk/tools/linux/toolchain/arm rockchip830 linux uclibcgnueabihf/bin/arm rockchip830 linux uclibcgnueabihf gcc\" export CXX \"/home/jiao/rv/echo mate/Echo Mate/SDK/rv1106 sdk/tools/linux/toolchain/arm rockchip830 linux uclibcgnueabihf/bin/arm rockchip830 linux uclibcgnueabihf g++\" export AR \"/home/jiao/rv/echo mate/Echo Mate/SDK/rv1106 sdk/tools/linux/toolchain/arm rockchip830 linux uclibcgnueabihf/bin/arm rockchip830 linux uclibcgnueabihf ar\" export LD \"/home/jiao/rv/echo mate/Echo Mate/SDK/rv1106 sdk/tools/linux/toolchain/arm rockchip830 linux uclibcgnueabihf/bin/arm rockchip830 linux uclibcgnueabihf ld\" # 创建构建目录 mkdir build arm && cd build arm # 配置（注意： host 只需要前缀，不是完整路径） ../configure \\ host arm rockchip830 linux uclibcgnueabihf \\ prefix /opt/arm libs \\ disable video x11 \\ disable video wayland \\ enable video kmsdrm \\ enable video opengles \\ disable alsa \\ disable pulseaudio # 编译和安装 make j$(nproc) sudo make install ``` 需要自己编译一个SDL2_image在ram平台里面使用 ```c wget https://www.libsdl.org/projects/SDL_image/release/SDL2_image 2.6.3.tar.gz tar xzf SDL2_image 2.6.3.tar.gz cd SDL2_image 2.6.3 # 2. 设置环境变量 export PATH \"/home/jiao/rv/echo mate/Echo Mate/SDK/rv1106 sdk/tools/linux/toolchain/arm rockchip830 linux uclibcgnueabihf/bin:$PATH\" export CC arm rockchip830 linux uclibcgnueabihf gcc export CXX arm rockchip830 linux uclibcgnueabihf g++ export SDL2_CONFIG /opt/rv1106 libs/bin/sdl2 config # 3. 配置 ./configure \\ host arm rockchip830 linux uclibcgnueabihf \\ prefix /opt/rv1106 libs \\ with sdl prefix /opt/rv1106 libs \\ enable static no \\ enable shared yes \\ disable jpg \\ disable png \\ disable tif \\ disable webp \\ disable imageio # 4. 编译并安装 make j$(nproc) sudo make install # 5. 验证安装 ls la /opt/rv1106 libs/lib/libSDL2_image* file /opt/rv1106 libs/lib/libSDL2_image.so ``` 实际使用的库在 ```bash ls /opt/rv1106 libs/lib/ ```"},"/note/Linux/瑞芯微Linux/配置网络.html":{"title":"配置网络","content":"# 配置网络 ![image 20250901155622714](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509011556788.png) 实际的登录使用这个ip ![image 20250901160200912](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509011602945.png) ### WIFI连接[](https://no chicken.com/content/Echo Mate/5.开发板操作.html#_2 wifi连接) 1. 开启wifi ``` ifconfig wlan0 up ``` 2. 进入wpa conf，`vi /etc/wpa_supplicant.conf`，配置wifi名和密码。(可以网上搜一下参数配置) ``` ctrl_interface /var/run/wpa_supplicant ap_scan 1 update_config 1 network { ssid \"wifi name\" psk \"12345678\" key_mgmt WPA PSK scan_ssid 1 #为链接隐藏的网络 } ``` 3. 创建一个socket文件 ``` mkdir p /var/run/wpa_supplicant ``` 4. 然后使用`wpa_supplicant B c /etc/wpa_supplicant.conf i wlan0`连接wifi，然后需要等待一会，如果是串口调试，会输出以下内容（SSH调试不会自动出现，需要使用dmesg命令查看更多log）： bash ``` [root@root ]# wpa_supplicant B c /etc/wpa_supplicant.conf i wlan0 Successfully initialized wpa_supplicant rfkill: Cannot open RFKILL control device [ 670.124975] RTL8723BS: rtw_set_802_11_connect(wlan0) fw_state 0x00000008 [ 678.988193] RTL8723BS: rtw_set_802_11_connect(wlan0) fw_state 0x00000008 [ 688.127631] RTL8723BS: rtw_set_802_11_connect(wlan0) fw_state 0x00000008 [ 697.804890] RTL8723BS: rtw_set_802_11_connect(wlan0) fw_state 0x00000008 [ 698.446240] RTL8723BS: start auth [ 698.466241] RTL8723BS: auth success, start assoc [ 698.521065] RTL8723BS: rtw_cfg80211_indicate_connect(wlan0) BSS not found !! [ 698.521119] RTL8723BS: assoc success [ 698.598174] RTL8723BS: send eapol packet [ 698.643221] RTL8723BS: send eapol packet [ 698.644951] RTL8723BS: set pairwise key camid:4, addr:9e:a4:d3:f5:da:8d, kid:0, type:AES [ 698.647953] RTL8723BS: set group key camid:5, addr:9e:a4:d3:f5:da:8d, kid:1, type:AES ``` 5. 上面的wpa_supplicant服务启动后，建议等待一会，再配置IP bash ``` udhcpc i wlan0 ``` 1 6. 然后你就可以ping一下baidu等网站测下网络了 7. 如果想要切换`WiFi`，需要重启 `wpa_supplicant` 服务，需要运行 bash ``` killall 9 wpa_supplicant ```"},"/note/Linux/Linux就该这么学/2022-8-23-.html":{"title":"","content":""},"/note/Linux/Linux就该这么学/鸟哥的linux私房菜/2022-9-10-计算机概论.html":{"title":"计算机概论","content":" layout: post title: \"计算机概论\" date: 2022 9 5 15:39:08 +0800 tags: 嵌入式 《鸟哥的Linux私房菜》 # 计算机概论 ## 计算机基础知识 ### 五大单元 输入输出单元, CPU内部控制单元和算术逻辑单元, 内存 ### CPU种类 主要有两种常见的, 精简指令集以及复杂指令集 #### 精简指令集RISC 执行时间短, 操作单纯 常见的有SPARC, PowerPC和ARM系列的 #### 复杂指令集 指令数量多复杂, 花费时间长, 个别指令处理的工作更为复杂, 常见的有AMD, Inter, VIA等x86架构的 不同的x86机器的区别主要就是微指令集的不同, 可以优化性能, 减少能源使用 ### 接口设备 最重要的是主板 ### 计算机的分类 超级计算机, 大型计算机, 迷你计算机, 工作站, 微型计算机 工作站的特点是稳定, 其速度不一定高于微型计算机 ### 常见的单位 #### 大小 1B 8bit K 1024 M 1024K G 1024M T 1024G P 1024T #### 速度 在网络上常见的计数单位是bit, 存储的单位是B, 相差了八倍 在硬盘的制造厂商使用十进制制硬盘, 但是实际格式化之后使用的是1024所以容量会变小 ## 架构与接口 Intel架构的主板芯片组通常通过两个桥接器进行通讯, 南桥和北桥, 北桥速度较快, 南桥速度较慢 后来由于内存的读取限制北桥速度, 所以把内存控制器集成到CPU之中, CPU不再需要考虑同步外频 AMD架构的主板内存直接和CPU通讯不通过北桥 主板的主要组件: CPU, 内存, 磁盘设备(IDE/SATA), 总线芯片组(南桥北桥), 显卡接口(PIC Express), 其他的适配卡(PCI) 计算机的32位64位主要是由每次能够处理的数据的位数决定, 还有总线的宽度也分为32位64位, 两者可以不匹配 由于存在不统一的引脚的的设计, 为了规范等级出现i386, i586, i686, 64位的都是x86_64, 有的软件对CPU做了优化处理, 只能向下兼容 双通道设计, 使用两个内存同时读写用来加快数据读写的速度 只读存储器, 烧写有BIOS等程序, 后面为了适应更新换代改为使用EEPRAM或闪存 ### 超线程 现在的CPU 指令周期都太快了，因此运算核心经常处于闲置状态下, 把重要的缓存器分为两组, 程序分别使用, 虽然大部分i7 等级的CPU 其实只有四个实体核心，但透过HT 的机制，则操作系统可以抓到八个核心"},"/note/Linux/Linux就该这么学/鸟哥的linux私房菜/2022-9-25-文件权限以及目录.html":{"title":"文件权限以及目录配置","content":" layout: post title: \"文件权限以及目录配置\" date: 2022 9 5 15:39:08 +0800 tags: 嵌入式 《鸟哥的Linux私房菜》 # 文件权限以及目录配置 可以使用命令 ``` ls l full time jiao@ubuntu:~/c++/test$ ls l full time 总用量 20 rw rw r 1 jiao jiao 95 2022 09 27 21:24:41.480689945 +0800 01.cpp ``` 进行查看准确的时间 + chgrp ：改变文件所属群组 + chown ：改变文件拥有者 + chmod ：改变文件的权限, SUID, SGID, SBIT等等的特性 ## 权限 + r 有读权限, 有查看目录的权限, 可以查看目录下面的文件名和文件的数据 + w 对于目录来说可以在目录下面创建新的目录, 删除已经存在的目录(不论已经存在文件的权限), 把已经存在的目录进行更改, 搬移目录中的文件目录位置 + x 指的是用户是否可以进入这个目录称为当前的工作目录"},"/note/Linux/Linux就该这么学/鸟哥的linux私房菜/2022-9-20-安装CentOS.html":{"title":"安装CentOS","content":" layout: post title: \"安装CentOS\" date: 2022 9 5 15:39:08 +0800 tags: 嵌入式 《鸟哥的Linux私房菜》 # 安装CentOS ## 主要的安装过程 1. 调整开机媒体(BIOS) 2. 选择开机模式, 图形文字接口 3. 选择语言 4. 选择软件 5. 硬盘分区 6. 开机管理程序, 网络, 时区 7. 安装后的设定 在创建的时候创建了四个分区, /, /boot, /home, swap 在安装的过程中可以创建LVM(逻辑卷)"},"/note/Linux/Linux就该这么学/鸟哥的linux私房菜/2022-9-20-主机规划与磁盘分区.html":{"title":"主机规划与磁盘分区","content":" layout: post title: \"主机规划与磁盘分区\" date: 2022 9 5 15:39:08 +0800 tags: 嵌入式 《鸟哥的Linux私房菜》 # 主机规划与磁盘分区 所有的设备都被当做一个文件进行管理, 使用SATA接口的硬盘会使用/dev/sd[a d]进行管理 设备对应的文件名 设备 文件名 : : : : SCSI/SATA/USB硬盘机 /dev/sd[a p] USB闪存盘 /dev/sd[a p] （与SATA相同） VirtI/O界面 /dev/vd[a p] （用于虚拟机内） 软盘机 /dev/fd[0 7] 打印机 /dev/lp[0 2] （25针打印机） /dev/usb/lp[0 15] （USB 接口） 鼠标 /dev/input/mouse[0 15] （通用） /dev/psaux （PS/2界面）/dev/mouse （当前鼠标） CDROM/DVDROM /dev/scd[0 1] （通用） /dev/sr[0 1] （通用，CentOS 较常见）/dev/cdrom （当前 CDROM） 磁带机 /dev/ht0 （IDE 界面） /dev/st0 （SATA/SCSI界面） /dev/tape（当前磁带） IDE硬盘机 /dev/hd[a d] （旧式系统才有） 虚拟机内的磁盘是使用仿真器产生，该仿真器产生的磁盘文件名为 /dev/vd[a p] 系列的文件名喔 使用侦测到的顺序来决定设备文件名，并非与实际插槽代号有关 ## 磁盘分区 所有盘片的同一个磁道我们称为柱面（Cylinder），通常那是文件系统的最小单位, 因为近来有 GPT 这个可达到 64bit 纪录功能的分区表，现在我们甚至可以使用扇区（sector）号码来作为分区单位 ### MSDOS （MBR）分区表格式与限制 使用的是支持 Windows 的MBR（Master Boot Record, 主要开机纪录区）的方式来处理开机管理程序与分区表！而开机管理程序纪录区与分区表则通通放在磁盘的第一个扇区 + 主要存放的信息有两种 1. 主要开机记录区: 安装开机管理程序的地方，有446Bytes 2. 分区表（partition table）：记录整颗硬盘分区的状态，有64 Bytes 仅有64 Bytes容量，因此最多仅能有四组记录区，每组记录区记录了该区段的启始与结束的柱面号码, 这四个分区的记录被称为主要（Primary）或延伸（Extended）分区 + 分区的作用 在进行系统整改的时候不会影响其他的分区 加快读取的速度 + 延伸分区 延伸分区并不是只占一个区块，而是会分佈在每个分区的最前面几个扇区来记载分区信息 硬盘的四个分区记录区仅使用到两个，P1为主要分区，而P2则为延伸分区, 延伸分区最多只能有一个, 延伸分区无法格式化 由于逻辑分区是由延伸分区继续分区出来的，所以他可以使用的柱面范围就是延伸分区所设置的范围 文件名前面四个号码都是保留给Primary或Extended用的, 所以逻辑分区的设备名称号码就由5号开始了 延伸分区之间可以直接融合, 但是某一个延伸分区不能直接和主分区进行融合 由于每组分区表仅有16Bytes 而已，因此可纪录的信息真的是相当有限的 + 问题 没有办法抓取到 2.2T 以上的磁盘容量 MBR 仅有一个区块，若被破坏后，经常无法或很难救援 MBR 内的存放开机管理程序的区块仅 446Bytes，无法容纳较多的程序码 ### GPT格式的分区 目前已经有 4K 的扇区设计出现！为了相容于所有的磁盘，因此在扇区的定义上面，大多会使用所谓的逻辑区块位址（Logical BlockAddress, LBA）来处理, GPT 将磁盘所有区块以此 LBA（默认为 512Bytes ）来规划，而第一个 LBA 称为 LBA0 使用了 34 个 LBA 区块来纪录分区信息 GPT 除了前面 34 个LBA 之外，整个磁盘的最后 33 个 LBA 也拿来作为另一个备份 + LBA0 （MBR 相容区块） 这个相容区块也分为两个部份，一个就是跟之前 446 Bytes 相似的区块，储存了第一阶段的开机管理程序, 放入一个特殊标志的分区，用来表示此磁盘为 GPT 格式之意 + LBA1 纪录了分区表本身的位置与大小，同时纪录了备份用的 GPT 分区, 同时放置了分区表的检验机制码, 若有错误，还可以通过这个纪录区来取得备份的 GPT + LBA2 33 每个 LBA 都可以纪录 4 笔分区纪录, GPT 在每笔纪录中分别提供了 64bits 来记载开始/结束的扇区号码GPT 分区表对於单一分区来说，他的最大容量限制就会在“ 264 512Bytes 263 1KBytes 233TB 8 ZB, 1ZB 230TB 没有所谓的主、延伸、逻辑分区的概念，既然每笔纪录都可以独立存在，当然每个都可以视为是主分区！每一个分区都可以拿来格式化使用 并不是所有的操作系统都可以读取到 GPT 的磁盘分区格式, 否能够读写 GPT 格式又与开机的检测程序有关 ## 开机流程中的BIOS 与 UEFI 开机检测程序 BIOS就是在开机的时候，计算机系统会主动执行的第一个程序, 会去分析计算机里面有哪些储存设备, BIOS会依据使用者的设置去取得能够开机的硬盘，并且到该硬盘里面去读取第一个扇区的MBR位置, 之后会执行保存的开机程序, 可读取核心文件来执行的软件 如果你使用类似 grub 的开机管理程序的话，那么就得要额外分区出一个“ BIOS boot ”的分区 BIOS与MBR都是硬件本身会支持的功能，至于Boot loader则是操作系统安装在MBR上面的一套软件 + boot loader的主要任务 提供菜单：使用者可以选择不同的开机项目，这也是多重开机的重要功能 载入核心文件：直接指向可开机的程序区段来开始操作系统 转交其他loader：将开机管理功能转交给其他loader负责 开机管理程序除了可以安装在MBR之外，还可以安装在每个分区的开机扇区 + 多重开机的工作情况 每个分区都拥有自己的开机扇区（boot sector） 实际可开机的核心文件是放置到各分区内的 loader只会认识自己的系统盘内的可开机核心文件，以及其他loader loader可直接指向或者是间接将管理权转交给另一个管理程序 Linux在安装的时候，你可以选择将开机管理程序安装在MBR或各别分区的开机扇区，而且Linux的loader可以手动设置菜单, 你可以在Linux的bootloader里面加入Windows开机的选项 Windows在安装的时候，他的安装程序会主动的覆盖掉MBR以及自己所在分区的开机扇区，你没有选择的机会，而且他没有让我们自己选择菜单的功能 + UEFI BIOS 搭配 GPT 开机的流程 BIOS 其实不懂 GPT 通过 GPT 提供相容模式才能够读写这个磁盘设备 因此这个 UEFI 大多用来作为启动操作系统之前的硬件检测、开机管理、软件设置等目的 ## 挂载 使用的是设备树, 可以吧对应的磁盘挂载到任意的位置, 比如根目录, 家目录等位置 ## 硬件相关的服务 + NAT 使用Linux达到对于IP地址共享的功能, 可以用来控制用户的联网 + SAMBA和Windows进行连接 进行用用户间的文件传输 对于系统的网卡与硬盘的大小及速度就比较重要，如果你还针对不同的使用者提供文件服务器功能，那么/home这个目录可以考虑独立出来，并且加大容量 + Mail Web接口的传输、大于2GB以上的容量空间及全年无休的服务等等 + Web(WWW服务器) 使用的是Apache这套软件来达成WWW网站的功能 + DHCP(提供用户端自动取得IP的功能) + FTP ### 主机硬盘规划 当电脑的硬件出现问题的时候, 文件数据的保护 + 最简单的 最简单的就是仅分区出根目录与内存交换空间（ / & swap ）即可 交换空间就是当内存不够用的时候会用硬盘进行内存数据保存的空间, 一般情况下使用的空间会比内存大, ubuntu等的休眠会使用这个空间进行对于内存内容的备份 + 稍微复杂 先分析这部主机的未来用途，然后根据用途去分析需要较大容量的目录，以及读写较为频繁的目录，将这些重要的目录分别独立出来而不与根目录放在一起"},"/note/Linux/Linux就该这么学/鸟哥的linux私房菜/2022-9-20-首次登录.html":{"title":"首次登录","content":" layout: post title: \"首次登录\" date: 2022 9 5 15:39:08 +0800 tags: 嵌入式 《鸟哥的Linux私房菜》 # 首次登录 ## 使用终端出现乱码 local查看当前的语言, `LANG en_US.utf8 # 语言语系的输出` ## 其他的常用命令 使用命令startx进入图形界面 cal:显示日历 使用bc进入计算器, 使用命令scale number可以设置小数的位数, 使用quit退出计算器 可以使用Ctrl+d进行退出, 相当于exit ![QQ图片20220920223323](https://xingqiu tuchuang 1256524210.cos.ap shanghai.myqcloud.com/1082/202301261334532.png) ## 帮助文档 使用`man f`会找到更多与man相关的信息, 可以查看某一个指令的所有文档 可以使用`man 1 man`查看标号为1的文档 使用`man k`会找到所有出现这个关键字的文档 + whatis相当于指令man f + apropos相当于指令man k 这两个特殊指令要能使用，必须要有建立whatis 数据库才行, 使用命令mandb进行建立数据库 info命令 和man命令的作用差不多, 但是会把数据差分成多个数据段文件默认是放置在/usr/share/info/这个目录当中 ``` File: info.info, Node: Top, Next: Getting Started, Up: (dir) Info: An Introduction ********************* ... ``` + File：代表这个info page的资料是来自info.info文件所提供的； + Node：代表目前的这个页面是属于Top节点。意思是info.info内含有很多信息，而Top仅是info.info文件内的一个节点内容而已； + Next：下一个节点的名称为Getting Started，你也可以按『N』到下个节点去； + Up：回到上一层的节点总揽画面，你也可以按下『U』回到上一层； + Prev：前一个节点。但由于Top是info.info的第一个节点，所以上面没有前一个节点的信息。 可以使用回车键进行节点的跳转, 选中对应的节点然后回车, 使用back可以返回上一个界面, 使用tab可以在节点之间进行跳转 ![QQ图片20220925204447](https://xingqiu tuchuang 1256524210.cos.ap shanghai.myqcloud.com/1082/202301261338308.png) 还可以在/usr/share/doc目录下面找到需要的文档 ## 关机 + 观察系统的使用状态 看目前有谁在在线，可以下达『who』这个指令，而如果要看网络的联机状态，可以下达『netstat a 』, 看背景执行的程序可以执行『ps aux 』这个指令 要关机前总得给在线的使用者一些时间来结束他们的工作，所以，这个时候你可以使用shutdown 的特别指令来达到此一功能 例如shutdown 与reboot 两个指令 将数据同步写入硬盘中的指令：sync 惯用的关机指令：shutdown 重新启动，关机：reboot, halt, poweroff sync也可以被一般账号使用喔！只不过一般账号用户所更新的硬盘数据就仅有自己的数据，不像root可以更新整个系统中的数据了 除了你是在主机前面以实体终端机(tty1~tty7) 来登入系统时，不论用什么身份都能够关机之外，若你是使用远程管理工具(如透过pietty使用ssh服务来从其他计算机登入主机)，那关机就只有root有权力而已 + 可以自由选择关机模式：是要关机或重新启动均可； + 可以设定关机时间: 可以设定成现在立刻关机, 也可以设定某一个特定的时间才关机。 + 可以自定义关机讯息：在关机之前，可以将自己设定的讯息传送给在线user 。 + 可以仅发出警告讯息：有时有可能你要进行一些测试，而不想让其他的使用者干扰，或者是明白的告诉使用者某段时间要注意一下！这个时候可以使用shutdown 来吓一吓使用者，但却不是真的要关机啦！ ``` k ：不要真的关机，只是发送警告讯息出去！ r ：在将系统的服务停掉之后就重新启动(常用) h ：将系统的服务停掉后，立即关机。(常用) c ：取消已经在进行的shutdown 指令内容。时间：指定系统关机的时间！时间的范例底下会说明。若没有这个项目，则默认1 分钟后自动进行 ``` halt, poweroff, reboot, shutdown 等等，其实都是呼叫这个systemctl 指令 ``` 指令项目包括如下： halt 进入系统停止的模式，屏幕可能会保留一些讯息，这与你的电源管理模式有关 poweroff 进入系统关机模式，直接关机没有提供电力喔！ reboot 直接重新启动 suspend 进入休眠模式 ```"},"/note/Linux/问题处理/2023-6-28-vscode配置.html":{"title":"设备文件设置","content":"# 设备文件设置 ``` { \"configurations\": [ { \"name\": \"Linux\", \"includePath\": [ \"${workspaceFolder}/**\", \"/home/jiao/linux/IMX6ULL/linux/linux imx ...\", //这里是头文件路径 \"/home/jiao/linux/IMX6ULL/linux/linux imx ...\", \"/home/jiao/linux/IMX6ULL/linux/linux imx ...\" ], \"defines\": [\"__KERNEL__\"],\t\t\t//添加结构体的补全 \"compilerPath\": \"/usr/bin/gcc\", \"cStandard\": \"c11\", \"cppStandard\": \"c++17\", \"intelliSenseMode\": \"clang x64\" } ], \"version\": 4 } ```"},"/note/Linux/问题处理/2022-9-9-ubuntu移植问题处理.html":{"title":"","content":"```c deb http://old releases.ubuntu.com/ubuntu/ cosmic main restricted universe multiverse deb http://old releases.ubuntu.com/ubuntu/ cosmic security main restricted universe multiverse deb http://old releases.ubuntu.com/ubuntu/ cosmic updates main restricted universe multiverse deb http://old releases.ubuntu.com/ubuntu/ cosmic proposed main restricted universe multiverse deb http://old releases.ubuntu.com/ubuntu/ cosmic backports main restricted universe multiverse deb src http://old releases.ubuntu.com/ubuntu/ cosmic main restricted universe multiverse deb src http://old releases.ubuntu.com/ubuntu/ cosmic security main restricted universe multiverse deb src http://old releases.ubuntu.com/ubuntu/ cosmic updates main restricted universe multiverse deb src http://old releases.ubuntu.com/ubuntu/ cosmic proposed main restricted universe multiverse deb src http://old releases.ubuntu.com/ubuntu/ cosmic backports main restricted universe multiverse ``` /etc/apt/sourcer.list源改为上面的 之后更改tmp文件的权限 在文件/etc/porfile中加入网络设置 模块加载的时候不能添加最后的ko 视频播放 mplayer ./Piper800x480_23fps.avi vo fbdev fs python: + pip apt get insatll python3 pip 之后安装的时候出错, 是由于源的问题 ``` pip install requests i http://pypi.douban.com/simple trusted host pypi.douban.com ``` 或者`~/.pip/pip.conf`(没有就创建一个文件夹及文件。 ``` [global] index url https://pypi.tuna.tsinghua.edu.cn/simple [install] trusted host mirrors.aliyun.com ``` # 联网 ```c #!/bin/bash modprobe 8188eu ifconfig wlan0 up ifconfig eth0 down #iwlist wlan0 scan wpa_supplicant D wext c /etc/wpa_supplicant.conf i wlan0 & sleep 5 udhcpc i wlan0 ```"},"/note/Linux/问题处理/2022-8-27-根文件系统被删除.html":{"title":"","content":"1. 下载一个新的系统, 拨码开关01000000 2. emmc启动10100110 3. 设置uboot: ``` //首先是联网 > setenv ipaddr 192.168.137.164 > setenv ethaddr 00:04:9f:04:d2:25 > saveenv //其他的网络设置 > setenv gatewayip 192.168.137.1 > setenv netmask 255.255.255.0 > setenv serverip 192.168.31.187 > saveenv ``` > 测试这一步已经可以启动内核了 ``` > setenv bootargs 'console ttymxc0,115200 root /dev/mmcblk1p2 rootwait rw' > setenv bootcmd 'tftp 80800000 zImage; tftp 83000000 imx6ull alientek emmc.dtb; bootz 80800000 83000000' > saveenv ``` > 可以正常启动 ``` //Linux设置 修改文件/etc/init.d/rcS 加入内容设置网络 ifconfig eth0 up ifconfig eth0 192.168.137.164 netmask 255.255.255.0 route add default gw 192.168.137.1 ``` > 设备驱动配置 ``` /lib # modprobe modprobe: can't change directory to '/lib/modules': No such file or directory /lib # mkdir modules /lib # modprobe modprobe: can't change directory to '4.1.15': No such file or directory /lib # modprobe cd modul /lib # mkdir 4.1.15 ```"},"/note/Linux/问题处理/2023-8-27-开发板网络设置.html":{"title":"","content":"![image 20220826224825958](https://blog 1308522872.cos.ap beijing.myqcloud.com/jhy/202212312356450.png) <img src \"https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/822362819179c4aff8cba66d152f458e.png\" alt \"822362819179c4aff8cba66d152f458e\" style \"zoom:50%;\" />"},"/note/Linux/问题处理/2022-9-7-备份根文件.html":{"title":"","content":"Linux下的SD卡, emmc的文件系统一般是ext4格式, 会提示格式化 Device driver >[*] USB support ><\\*> USB Gadget Support ><M> USB Gadget Drivers (Mass Storage Gadget) >(X) Mass Storage Gadget ```c cd drivers/usb/gadget///进入gadget目录下 sudo cp libcomposite.ko /home/zuozhongkai/linux/nfs/rootfs/lib/modules/4.1.15/ sudo cp function/usb_f_mass_storage.ko /home/zuozhongkai/linux/nfs/rootfs/lib/modules/4.1.15/ sudo cp legacy/g_mass_storage.ko /home/zuozhongkai/linux/nfs/rootfs/lib/modules/4.1.15/ ``` ```c depmod modprobe libcomposite.ko modprobe usb_f_mass_storage.ko modprobe g_mass_storage.ko file /dev/root removable 1 ``` ``` rmmod g_mass_storage.ko ```"},"/note/Linux/问题处理/2022-11-20-Linux图形界面.html":{"title":"主频","content":"# 主频 CPU Power Mangagement >CPU Frequency scaling > Default CPUFreq governor (ondemand) >进行设置主频的模式 # 网络驱动 Device Drivers >[\\*] Network device support > * PHY Device support and infrastructure ><*> Drivers for SMSC PHYs # 系统频率 > Kernel Features > Timer frequency (<choice> [ y]) # 音频驱动 图形界面, 取消ALSA模拟OSS Device dirver >Sound card support > <*> Advanced Linux Sound Architecture 之后使能对应的驱动 Device dirver >Sound card support > <*> Advanced Linux Sound Architecture ><\\*> ALSA for SoC audio support > SoC Audio for Freescale CPUs >< > SoC Audio support for i.MX boards with wm8960 # LED驱动 >Device Driver >LED Support > LED Support for GPIO connected LEDs # logo显示 Device Drivers >Graphics support >logo # 按键驱动 Device driver > Input device support > * Generic input layer (needed for keyboard, mouse, ...) , keyboard > GPIO Buttons"},"/note/Linux/问题处理/2023-11-11-树莓派.html":{"title":"","content":"sudo apt key adv keyserver keyserver.ubuntu.com recv keys 9165938D90FDDD2E sudo apt key adv keyserver keyserver.ubuntu.com recv keys 9165938D90FDDD2E > 更新密钥 ![image 20231111105335453](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311111053717.png) ![image 20231111105405884](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311111054131.png) > ``` > jiao@raspberrypi:~ $ sudo vim /etc/apt/sources.list > jiao@raspberrypi:~ $ sudo vi /etc/apt/sources.list.d/raspi.list > ```"},"/note/Linux/问题处理/2023-6-14-打不开gpedit-msc.html":{"title":"","content":"建立脚本 ··· ```text @echo off pushd \"%~dp0\" dir /b C:\\Windows\\servicing\\Packages\\Microsoft Windows GroupPolicy ClientExtensions Package~3*.mum >List.txt dir /b C:\\Windows\\servicing\\Packages\\Microsoft Windows GroupPolicy ClientTools Package~3*.mum >>List.txt for /f %%i in ('findstr /i . List.txt 2^>nul') do dism /online /norestart /add package:\"C:\\Windows\\servicing\\Packages\\%%i\" pause ``` 后缀.bat运行"},"/note/Linux/问题处理/2022-8-5-没有release文件.html":{"title":"没有release文件","content":" layout: post title: \"没有release文件\" date: 2022 8 4 15:03:08 +0800 tags: 问题处理 Linux 在`sudo apt get update ` [处理方案来源][http://t.csdn.cn/ZkiXF] ```bash 错误:8 http://cn.archive.ubuntu.com/ubuntu impish backports Release 404 Not Found [IP: 91.189.91.39 80] 正在读取软件包列表... 完成 E: 仓库 “http://security.ubuntu.com/ubuntu impish security Release” 不再含有 Release 文件。 N: 无法安全地用该源进行更新，所以默认禁用该源。 N: 参见 apt secure(8) 手册以了解仓库创建和用户配置方面的细节。 E: 仓库 “http://cn.archive.ubuntu.com/ubuntu impish updates Release” 没有 Release 文件。 N: 无法安全地用该源进行更新，所以默认禁用该源。 N: 参见 apt secure(8) 手册以了解仓库创建和用户配置方面的细节。 E: 仓库 “http://cn.archive.ubuntu.com/ubuntu impish Release” 没有 Release 文件。 N: 无法安全地用该源进行更新，所以默认禁用该源。 N: 参见 apt secure(8) 手册以了解仓库创建和用户配置方面的细节。 E: 仓库 “http://cn.archive.ubuntu.com/ubuntu impish backports Release” 不再含有 Release 文件。 N: 无法安全地用该源进行更新，所以默认禁用该源。 N: 参见 apt secure(8) 手册以了解仓库创建和用户配置方面的细节 ``` ```bash sudo vim /etc/apt/sources.list 改为 deb http://old releases.ubuntu.com/ubuntu/ cosmic main restricted universe multiverse deb http://old releases.ubuntu.com/ubuntu/ cosmic security main restricted universe multiverse deb http://old releases.ubuntu.com/ubuntu/ cosmic updates main restricted universe multiverse deb http://old releases.ubuntu.com/ubuntu/ cosmic proposed main restricted universe multiverse deb http://old releases.ubuntu.com/ubuntu/ cosmic backports main restricted universe multiverse deb src http://old releases.ubuntu.com/ubuntu/ cosmic main restricted universe multiverse deb src http://old releases.ubuntu.com/ubuntu/ cosmic security main restricted universe multiverse deb src http://old releases.ubuntu.com/ubuntu/ cosmic updates main restricted universe multiverse deb src http://old releases.ubuntu.com/ubuntu/ cosmic proposed main restricted universe multiverse deb src http://old releases.ubuntu.com/ubuntu/ cosmic backports main restricted universe multiverse # 之后更新 错误:1 http://old releases.ubuntu.com/ubuntu cosmic InRelease 由于没有公钥，无法验证下列签名： NO_PUBKEY 3B4FE6ACC0B21F32 获取:2 http://old releases.ubuntu.com/ubuntu cosmic security InRelease [88.7 kB] 错误:2 http://old releases.ubuntu.com/ubuntu cosmic security InRelease 由于没有公钥，无法验证下列签名： NO_PUBKEY 3B4FE6ACC0B21F32 获取:3 http://old releases.ubuntu.com/ubuntu cosmic updates InRelease [88.7 kB] 错误:3 http://old releases.ubuntu.com/ubuntu cosmic updates InRelease 由于没有公钥，无法验证下列签名： NO_PUBKEY 3B4FE6ACC0B21F32 获取:4 http://old releases.ubuntu.com/ubuntu cosmic proposed InRelease [92.5 kB] 错误:4 http://old releases.ubuntu.com/ubuntu cosmic proposed InRelease 由于没有公钥，无法验证下列签名： NO_PUBKEY 3B4FE6ACC0B21F32 获取:5 http://old releases.ubuntu.com/ubuntu cosmic backports InRelease [74.6 kB] 错误:5 http://old releases.ubuntu.com/ubuntu cosmic backports InRelease 由于没有公钥，无法验证下列签名： NO_PUBKEY 3B4FE6ACC0B21F32 # 出现没有公钥 sudo apt key adv keyserver keyserver.ubuntu.com recv keys 公钥 # 示例 sudo apt key adv keyserver keyserver.ubuntu.com recv keys 3B4FE6ACC0B21F32 ``` # 处理方法2 [处理方法2][http://t.csdn.cn/7osap] 输入命令` sudo apt get update`, 报错 这里可以看到有两个问题，一个是 ubuntu自己的源连不上了[第二三个红框框] ，一个是 `vmware `这个软件 [第一个红框框]。 首先解决第一个问题。archive.ubuntu.com是ubuntu的默认源，也是官网的源。但是现在连不上，那就换个其他的源，用阿里的。 首先打开 软件和更新，设置选择 阿里的服务器 这时候，点击关闭，会要求重新载入，点击重新载入会报错，这是因为`sources.list`里面对阿里这个源配置的这个artful 属性不对。 打开文件`/etc/apt/sources.list` 删除里面的所有内容，替换成： ```bash deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe deb http://mirrors.aliyun.com/ubuntu/ bionic security main restricted universe deb http://mirrors.aliyun.com/ubuntu/ bionic updates main restricted universe deb http://mirrors.aliyun.com/ubuntu/ bionic proposed main restricted universe deb http://mirrors.aliyun.com/ubuntu/ bionic backports main restricted universe ``` **出现的问题, 文件自动添加一行, 需要手动删除** 这样第一个源的问题就解决了。然后 解决第二个`vmware`的问题，打开文件夹` /etc/apt/sources.list.d` `cd /etc/apt/sources.list.d` 用 ls 命令查看这个文件夹里的所有内容 由于出问题的是`vmware`， 我们就把`vmware tools.list `删除（建议不要直接删除，而是改成` vmware tools.list.bak`。同理要修改某个配置文件xxx时，先备份成 `xxx.bak`文件，然后再修改）。这里删除不用担心软件无法更新，系统会自动再生成一个可用的 .list文件 `sudo mv vmware tools.list vmware tools.list.bak` 然后再执行 sudo apt get update 就没有错误了 ———————————————— 版权声明：本文为CSDN博主「titake」的原创文章，遵循CC 4.0 BY SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/qq_22498427/article/details/104345138 # 之后出现 ```c root@jiao virtual machine:/# apt update Get:1 http://old releases.ubuntu.com/ubuntu cosmic InRelease [242 kB] 0% [1 InRelease gpgv 242 kB] [Waiting for headers]Couldn't create tempfiles for splitting up /var/lib/apErr:1 http://old releases.ubuntu.com/ubuntu cosmic InReleaseInRelease Could not execute 'apt key' to verify signature (is gnupg installed?) Get:2 http://old releases.ubuntu.com/ubuntu cosmic security InRelease [88.7 kB] 0% [2 InRelease gpgv 88.7 kB] [Waiting for headers] 354 B/s 11min 23sCouldn't create tempfiles for splitting up /var/lib/apt/lists/partial/old releases.ubuntu.com_ubuntu_distErr:2 http://old releases.ubuntu.com/ubuntu cosmic security InRelease Could not execute 'apt key' to verify signature (is gnupg installed?) Get:3 http://old releases.ubuntu.com/ubuntu cosmic updates InRelease [88.7 kB] 0% [3 InRelease gpgv 88.7 kB] [Waiting for headers] 354 B/s 15min 34sCouldn't create tempfiles for splitting up /var/lib/apt/lists/partial/old releases.ubuntu.com_ubuntu_distErr:3 http://old releases.ubuntu.com/ubuntu cosmic updates InRelease Could not execute 'apt key' to verify signature (is gnupg installed?) Get:4 http://old releases.ubuntu.com/ubuntu cosmic proposed InRelease [92.5 kB] 0% [4 InRelease gpgv 92.5 kB] [Waiting for headers] 354 B/s 19min 45sCouldn't create tempfiles for splitting up /var/lib/apt/lists/partial/old releases.ubuntu.com_ubuntu_distErr:4 http://old releases.ubuntu.com/ubuntu cosmic proposed InRelease Could not execute 'apt key' to verify signature (is gnupg installed?) Get:5 http://old releases.ubuntu.com/ubuntu cosmic backports InRelease [74.6 kB] 0% [5 InRelease gpgv 74.6 kB] 354 B/s 24min 6sCouldn't create tempfiles for splitting up /var/lib/apt/lists/partial/old releases.ubuntu.com_ubuntu_distErr:5 http://old releases.ubuntu.com/ubuntu cosmic backports InRelease Could not execute 'apt key' to verify signature (is gnupg installed?) Reading package lists... Done W: GPG error: http://old releases.ubuntu.com/ubuntu cosmic InRelease: Could not execute 'apt key' to verify signature (is gnupg installed?) E: The repository 'http://old releases.ubuntu.com/ubuntu cosmic InRelease' is not signed. N: Updating from such a repository can't be done securely, and is therefore disabled by default. N: See apt secure(8) manpage for repository creation and user configuration details. W: GPG error: http://old releases.ubuntu.com/ubuntu cosmic security InRelease: Could not execute 'apt key' to verify signature (is gnupg installed?) E: The repository 'http://old releases.ubuntu.com/ubuntu cosmic security InRelease' is not signed. N: Updating from such a repository can't be done securely, and is therefore disabled by default. N: See apt secure(8) manpage for repository creation and user configuration details. W: GPG error: http://old releases.ubuntu.com/ubuntu cosmic updates InRelease: Could not execute 'apt key' to verify signature (is gnupg installed?) E: The repository 'http://old releases.ubuntu.com/ubuntu cosmic updates InRelease' is not signed. N: Updating from such a repository can't be done securely, and is therefore disabled by default. N: See apt secure(8) manpage for repository creation and user configuration details. W: GPG error: http://old releases.ubuntu.com/ubuntu cosmic proposed InRelease: Could not execute 'apt key' to verify signature (is gnupg installed?) E: The repository 'http://old releases.ubuntu.com/ubuntu cosmic proposed InRelease' is not signed. N: Updating from such a repository can't be done securely, and is therefore disabled by default. N: See apt secure(8) manpage for repository creation and user configuration details. W: GPG error: http://old releases.ubuntu.com/ubuntu cosmic backports InRelease: Could not execute 'apt key' to verify signature (is gnupg installed?) E: The repository 'http://old releases.ubuntu.com/ubuntu cosmic backports InRelease' is not signed. N: Updating from such a repository can't be done securely, and is therefore disabled by default. N: See apt secure(8) manpage for repository creation and user configuration details. ``` ``` //原因没有权限 root@jiao virtual machine:/# chmod 777 /tmp ```"},"/note/Linux/问题处理/2022-8-24-tftp下载.html":{"title":"不能下载","content":"# 不能下载 首先查看ip地址, 检查主机是不是可以正常的上网, 排除主机的错误 如果可以ping ubuntu单数不可以下载 之后测试是不是有两个设备使用同一个ip, 检查开发板以及主机是不是可以正常使用 # 下载启动 ``` setenv bootcmd 'tftp 80800000 zImage; tftp 83000000 imx6ull 14x14 emmc 7 1024x600 c.dtb; bootz 80800000 83000000' saveenv boot ``` # linux下使用 ``` /lib/modules # tftp g r chardevbase.ko 192.168.31.187 chardevbase.ko 100% ******************************** 2827 0:00:00 ETA 上传 tftp p l c:\\User\\Administrator\\Download 1.2.3.4 ```"},"/note/Linux/问题处理/2022-8-26-uboot设置.html":{"title":"","content":"```C > print baudrate 115200 board_name EVK board_rev 14X14 boot_fdt try bootargs console ttymxc0,115200 root /dev/mmcblk1p2 rootwait rw bootcmd tftp 80800000 zImage; tftp 83000000 imx6ull alientek emmc.dtb; bootz 80800000 83000000 bootcmd_mfg run mfgtool_args;bootz ${loadaddr} ${initrd_addr} ${fdt_addr}; bootdelay 3 bootfile imx6ull alientek emmc.dtb bootscript echo Running bootscript from mmc ...; source console ttymxc0 ethact FEC1 ethaddr 00:04:9f:04:d2:25 ethprime FEC fdt_addr 0x83000000 fdt_file undefined fdt_high 0xffffffff fileaddr 83000000 filesize 8d32 findfdt if test $fdt_file undefined; then if test $board_name EVK && test $board_rev 9X9; then setenv fdt_file imx6ull 9x9 evk.dtb; fi; if test $board_name EVK && test $board_rev 14X14; then setenv fdt_file imx6ull 14x14 evk.dtb; fi; if test $fdt_file undefined; then echo WARNING: Could not determine dtb to use; fi; fi; gatewayip 192.168.137.164 image zImage initrd_addr 0x83800000 initrd_high 0xffffffff ip_dyn yes ipaddr 192.168.137.164 loadaddr 0x80800000 loadbootscript fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script}; loadfdt fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file} loadimage fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image} mfgtool_args setenv bootargs console ${console},${baudrate} rdinit /linuxrc g_mass_storage.stall 0 g_mass_storage.removable 1 g_mass_storage.file /fat g_mass_storage.ro 1 g_mass_storage.idVendor 0x066F g_mass_storage.idProduct 0x37FF g_mass_storage.iSerialNumber \"\" clk_ignore_unused mmcargs setenv bootargs console ${console},${baudrate} root ${mmcroot} mmcautodetect yes mmcboot echo Booting from mmc ...; run mmcargs; if test ${boot_fdt} yes test ${boot_fdt} try; then if run loadfdt; then bootz ${loadaddr} ${fdt_addr}; else if test ${boot_fdt} try; then bootz; else echo WARN: Cannot load the DT; fi; fi; else bootz; fi; mmcdev 1 mmcpart 1 mmcroot /dev/mmcblk1p2 rootwait rw netargs setenv bootargs console ${console},${baudrate} root /dev/nfs ip dhcp nfsroot ${serverip}:${nfsroot},v3,tcp netboot echo Booting from net ...; run netargs; if test ${ip_dyn} yes; then setenv get_cmd dhcp; else setenv get_cmd tftp; fi; ${get_cmd} ${image}; if test ${boot_fdt} yes test ${boot_fdt} try; then if ${get_cmd} ${fdt_addr} ${fdt_file}; then bootz ${loadaddr} ${fdt_addr}; else if test ${boot_fdt} try; then bootz; else echo WARN: Cannot load the DT; fi; fi; else bootz; fi; netmask 255.255.255.0 panel TFT7016 script boot.scr serverip 192.168.31.187 Environment size: 2589/8188 bytes ``` # emmc启动 ``` > setenv bootargs 'console tty1 console ttymxc0,115200 root /dev/mmcblk1p2 rootwait rw' ``` ``` bootcmd fatinfo mmc 1:1;fatload mmc 0:1 80800000 zImage; fatload mmc 0:1 83000000 imx6ull alientek emmc.dtb; bootz 80800000 83000000 ```"},"/note/Linux/Linux命令行与shell脚本编程大全/2022-8-7-控制脚本.html":{"title":"控制脚本《Linux命令行与Shell脚本编程大全》","content":" layout: post title: \"控制脚本《Linux命令行与Shell脚本编程大全》\" date: 2022 8 7 15:39:08 +0800 tags: 《Linux命令行与Shell脚本编程大全》 Linux # 控制脚本 ## 处理信号 Linux利用信号在系统进程之间进行通讯, 用这些信号来停止、启动、终止进程。可以通过对脚本进行编程, 使其在收到特定信号时执行某些命令，从而控制shell脚本的操作 默认情况下，bash shell会忽略收到的任何SIGQUIT (3)和SIGTERM (5)信号（正因为这样，交互式shell才不会被意外终止）。但是bash shell会处理收到的SIGHUP (1)和SIGINT (2)信号 如果bash shell收到了SIGHUP信号，比如当你要离开一个交互式shell，它就会退出。但在退出之前，它会将SIGHUP信号传给所有由该shell所启动的进程 通过SIGINT信号，可以中断shell。Linux内核会停止为shell分配CPU处理时间。这种情况发生时，shell会将SIGINT信号传给所有由它所启动的进程，以此告知出现的状况 shell会将这些信号传给shell脚本程序来处理。而shell脚本的默认行为是忽略这些信号。它们可能会不利于脚本的运行。要避免这种情况，你可以脚本中加入识别信号的代码，并执行命令来处理信号 ### 生成信号 #### 中断进程 Ctrl+C发送SIGINT信号, 停止shell当前的进程 #### 暂停进程 在进程运行期间暂停 尽管有时这可能会比较危险（比如，脚本打开了一个关键的系统文件的文件锁），但通常它可以在不终止进程的情况下使你能够深入脚本内部一窥究竟 Ctrl+Z组合键会生成一个SIGTSTP信号，停止shell中运行的任何进程 停止进程会让程序继续保留在内存中，并能从上次停止的位置继续运行 既然你已经知道了已停止作业的PID，就可以用kill命令来发送一个SIGKILL信号来终止它 但下次如果你做了能够产生shell提示符的操作（比如按回车键），你就会看到一条消息，显示作业已经被终止了。每当shell产生一个提示符时，它就会显示shell中状态发生改变的作业的状态。在你终止一个作业后，下次强制shell生成一个提示符时，shell会显示一条消息，说明作业在运行时被终止了 ### 捕获信号 trap命令允许你来指定shell脚本要监看并从shell中拦截的Linux信号。如果脚本收到了trap命令中列出的信号，该信号不再由shell处理，而是交由本地处理 ```bash trap commnd signals ``` 你只要列出想要shell执行的命令，以及一组用空格分开的待捕获的信号。你可以用数值或Linux信号名来指定信号 ```bash 1 #!/bin/bash 2 3 trap \"echo 'Sorry! I have trapped Ctrl+C'\" SIGINT 4 echo This is a test script 5 6 count 1 7 while [ $count le 10 ] 8 do 9 echo \"Loop #$count\" 10 sleep 1 11 count $[ $count + 1 ] 12 done 13 14 echo \"This is the end of the test script\" ``` ### 捕获脚本退出 在shell脚本退出的时候进行捕获, 在shell完成任务时候执行命令的简便方法 ```bash 1 #!/bin/bash 2 3 trap \"echo Goodbye...\" EXIT 4 5 count 1 6 while [ $count le 5 ] 7 do 8 echo \"Loop #$count\" 9 sleep 1 10 count $[ $count +1 ] 11 done ``` > 在退出之前执行的程序 ### 修改或移除捕获 要想在脚本中的不同位置进行不同的捕获处理，只需重新使用带有新选项的trap命令 ```bash 1 #!/bin/bash 2 3 trap \"echo 'Sorry... Ctrl C is traped...'\" SIGINT 4 count 1 5 while [ $count le 5 ] 6 do 7 echo \"Loop #$count\" 8 sleep 1 9 count $[ $count + 1 ] 10 done 11 trap \"echo 'I modified the trap!'\" SIGINT 12 count 1 13 while [ $count le 5 ] 14 do 15 echo \"Second Loop #$count\" 16 sleep 1 17 count $[ $count + 1 ] 18 done ``` 也可以删除已设置好的捕获。只需要在trap命令与希望恢复默认行为的信号列表之间加上两个破折号就行了 ```bash 1 #!/bin/bash 2 3 trap \"echo 'Sorry ...Ctrl + C is trapped.'\" SIGINT 4 count 1 5 while [ $count le 5 ] 6 do 7 echo \"Loop #count \" 8 sleep 1 9 count $[ $count + 1 ] 10 done 11 12 trap SIGINT 13 echo \"I just removed the trap\" 14 count 1 15 while [ $count le 5 ] 16 do 17 echo \"Second Loop #$count\" 18 sleep 1 19 count $[ $count + 1 ] 20 done ``` > 也可以在trap命令后使用单破折号来恢复信号的默认行为。单破折号和双破折号都可以正常发挥作用。 ## 在后台运行脚本 有的脚本运行在shell之中不怎么方便, 有的脚本运行需要很长时间 在后台运行的时候不会和终端会话上的STDIN、STDOUT以及STDERR关联 ### 后台运行脚本 当&符放到命令后时，它会将命令和bash shell分离开来，将命令作为系统中的一个独立的后台进程运行。显示的第一行是 ```bash jiao@jiao virtual machine:~/桌面/linux shell/16$ test5.sh & [1] 3419 jiao@jiao virtual machine:~/桌面/linux shell/16$ [1]+ 已完成 test5.sh ``` > 当后台进程运行时，它仍然会使用终端显示器来显示STDOUT和STDERR消息 ```bash jiao@jiao virtual machine:~/桌面/linux shell/16$ test6.sh & [1] 3464 jiao@jiao virtual machine:~/桌面/linux shell/16$ Start the test scrip Loop #1 Loop #2 Loop #3 Loop #4 Loop #5 test scrip is complete ``` 最好是将后台运行的脚本的STDOUT和STDERR进行重定向，避免这种杂乱的输出 ### 运行多个后台作业 **注意**，在ps命令的输出中，每一个后台进程都和终端会话（pts/0）终端联系在一起。如果终端会话退出，那么后台进程也会随之退出 ## 在非控制台下运行脚本 在终端会话中启动shell脚本，然后让脚本一直以后台模式运行到结束，即使你退出了终端会话。这可以用nohup命令来实现 nohup命令运行了另外一个命令来阻断所有发送给该进程的SIGHUP信号。这会在退出终端会话时阻止进程退出 ```bash jiao@jiao virtual machine:~/桌面/linux shell/16$ nohup test6.sh & [1] 3484 jiao@jiao virtual machine:~/桌面/linux shell/16$ nohup: 忽略输入并把输出追加到'nohup.out' jiao@jiao virtual machine:~/桌面/linux shell/16$ ls nohup.out teset1 test1.sh test2.sh test3.sh test4.sh test5.sh test6.sh jiao@jiao virtual machine:~/桌面/linux shell/16$ cat nohup.out Start the test scrip Loop #1 Loop #2 Loop #3 Loop #4 Loop #5 test scrip is complete [1]+ 已完成 nohup test6.sh ``` > 会把输出重定向到nohup.out文件之中 ## 作业控制 暂停的进程可以选择是停止还是继续运行, 可以使用kill命令终止进程, 重新运行, 需要发送一个SIGCONT信号 启动、停止、终止以及恢复作业的这些功能统称为**作业控制** ### 查看作业 关键命令jobs命令, 允许查看当前运行的作业的状态 ```bash jiao@jiao virtual machine:~/桌面/linux shell/16$ jobs [1] 已停止 test7.sh [2]+ 已停止 test7.sh > test7out [3] 运行中 test7.sh > test7out & ``` > jobs命令输出中的加号和减号。带加号的作业会被当做默认作业。在使用作业控制命令时，如果未在命令行指定任何作业号 > > 带减号的作业成为下一个默认作业。任何时候都只有一个带加号的作业和一个带减号的作业 > > 默认进程（带有加号的那个）是最后启动的那个进程 参数 描述 : : : : l(小写L) 列出进程的PID以及作业号 n 只列出上次shell发出的通知后改变了状态的作业 p 只列出作业的PID r 只列出运行中的作业 s 只列出已停止的作业 ### 重启停止的作业 可以将已停止的作业作为后台进程或前台进程重启。前台进程会接管你当前工作的终端 要以后台模式重启一个作业，可用bg命令加上作业号 ```bash jiao@jiao virtual machine:~/桌面/linux shell/16$ jobs [1] 已停止 test7.sh [2]+ 已停止 test7.sh > test7out jiao@jiao virtual machine:~/桌面/linux shell/16$ bg [2]+ test7.sh > test7out & jiao@jiao virtual machine:~/桌面/linux shell/16$ jobs [1]+ 已停止 test7.sh [2] 运行中 test7.sh > test7out & ``` > 默认任务不需要加任务号 > 可以使用bg加上任务号进行启动`bg 2` 以前台模式启动一个作业fg ```bash $ fg 2 ./test12.sh This is the script's end... ``` ## 调整谦让度 CPU分配给每一个任务的时间 调度优先级是整数, 从 20（最高优先级）到+19（最低优先级） bash shell默认会以0启动所有进程 ### nice命令 让命令以更低的优先级运行, n 命令 ```bash jiao@jiao virtual machine:~/桌面/linux shell/16$ nice n 10 test7.sh > test7out & [1] 3957 jiao@jiao virtual machine:~/桌面/linux shell/16$ ps p 3957 o pid,ppid,ni,cmd PID PPID NI CMD 3957 2840 10 /bin/bash ./test7.sh ``` + 命令会禁止普通用户提高等级 ```nash jiao@jiao virtual machine:~/桌面/linux shell/16$ nice n 10 test7.sh > test7out & [2] 4044 [1] 已完成 nice n 10 test7.sh > test7out jiao@jiao virtual machine:~/桌面/linux shell/16$ nice: 无法设置优先级: 权限不够 ``` + nice命令的 n选项并不是必须的，只需要在破折号后面跟上优先级就行了 ```bash jiao@jiao virtual machine:~/桌面/linux shell/16$ nice 10 test7.sh > test7out & [3] 4083 jiao@jiao virtual machine:~/桌面/linux shell/16$ ps p 4083 o pid,ppid,ni,cmd PID PPID NI CMD 4083 2840 10 /bin/bash ./test7.sh ``` ### renice命令 改变正在运行的程序的优先级, 它允许你指定运行进程的PID来改变它的优先级 ```bash jiao@jiao virtual machine:~/桌面/linux shell/16$ test7.sh > test7out & [5] 4188 jiao@jiao virtual machine:~/桌面/linux shell/16$ ps p 4188 o pid,ppid,ni,cmd PID PPID NI CMD 4188 2840 0 /bin/bash ./test7.sh jiao@jiao virtual machine:~/桌面/linux shell/16$ renice n 10 p 4188 4188 (process ID) 旧优先级为 0，新优先级为 10 jiao@jiao virtual machine:~/桌面/linux shell/16$ ps p 4188 o pid,ppid,ni,cmd PID PPID NI CMD 4188 2840 10 /bin/bash ./test7.sh ``` + 只能对属于你的进程执行renice； + 只能通过renice降低进程的优先级； + root用户可以通过renice来任意调整进程的优先级 ## 定时运行作业 at命令和cron表。每个方法都使用不同的技术来安排脚本的运行时间和频率。接下来会依次介绍这些方法 ### 使用at命令执行作业 允许指定Linux何时运行命令, 把作业提交到队列中, 指定shell何时运行作业 at的守护进程atd会以后台模式运行，检查作业队列来运行作业 atd守护进程会检查系统上的一个特殊目录（通常位于/var/spool/at）来获取用at命令提交的作业。默认情况下，atd守护进程会每60秒检查一下这个目录, 如果时间跟当前时间匹配，atd守护进程就会运行此作业 #### at命令格式 ```bash at [ f filename] time ``` > at命令会将STDIN的输入放到队列中。你可以用 f参数来指定用于读取命令（脚本文件）的文件名 > > time参数指定了Linux系统何时运行该作业。如果你指定的时间已经错过，at命令会在第二天的那个时间运行指定的作业 识别的格式 + 标准的小时和分钟格式，比如10:15 + AM/PM指示符，比如10:15 PM + 特定可命名时间，比如now、noon、midnight或者teatime（4 PM） 除了指定运行作业的时间，也可以通过不同的日期格式指定特定的日期 + 标准日期格式，比如MMDDYY、MM/DD/YY或DD.MM.YY。 + 文本日期比如Jul 4或Dec 25，加不加年份均可 + 指定时间增量 > 明天10:15 PM > > 10:15+7天 > > 当前时间+25 min 该作业会被提交到**作业队列** 作业队列会保存通过at命令提交的待处理的作业。针对不同优先级，存在26种不同的作业队列。作业队列通常用小写字母a\\~z和大写字母A\\~Z来指代 > 在几年前，也可以使用batch命令在指定时间执行某个脚本。batch命令很特别，你可以安排脚本在系统处于低负载时运行。但现在batch命令只不过是一个脚本而已（/usr/bin/batch），它会调用at命令并将作业提交到b队列中 作业队列的字母排序越高，作业运行的优先级就越低（更高的nice值） 一般情况作业会被提交到a作业队列。如果想以更高优先级运行作业，可以用 q参数指定不同的队列字母 #### 获取作业输出 Linux系统会将提交该作业的用户的电子邮件地址作为STDOUT和STDERR。任何发到STDOUT或STDERR的输出都会通过邮件系统发送给该用户 ```bash jiao@jiao virtual machine:~/桌面/linux shell/16$ at f test8.sh now warning: commands will be executed using /bin/sh job 1 at Mon Aug 8 14:06:00 2022 ``` 使用e mail作为at命令的输出极其不便。at命令利用sendmail应用程序来发送邮件。如果你的系统中没有安装sendmail，那就无法获得任何输出 最好在脚本中对STDOUT和STDERR进行重定向 ```bash 1 #!/bin/bash 2 3 echo \"This script run at $(date +%B%d,%T)\" > test9out 4 echo >> test9out 5 sleep 5 6 echo \"This is the script's end...'\" >> test9out jiao@jiao virtual machine:~/桌面/linux shell/16$ at f test9.sh now warning: commands will be executed using /bin/sh job 3 at Mon Aug 8 14:15:00 2022 jiao@jiao virtual machine:~/桌面/linux shell/16$ cat test9out This script run at 八月08,14:15:50 This is the script's end...' ``` + 如果不想在at命令中使用邮件或重定向，最好加上 M选项来屏蔽作业产生的输出信息 #### 列出等待的作业 atq命令 ```bash jiao@jiao virtual machine:~/桌面/linux shell/16$ at M f test9.sh teatime warning: commands will be executed using /bin/sh job 4 at Mon Aug 8 16:00:00 2022 jiao@jiao virtual machine:~/桌面/linux shell/16$ at M f test9.sh tommorow syntax error. Last token seen: t Garbled time jiao@jiao virtual machine:~/桌面/linux shell/16$ at M f test9.sh tomorrow warning: commands will be executed using /bin/sh job 5 at Tue Aug 9 14:22:00 2022 jiao@jiao virtual machine:~/桌面/linux shell/16$ at M f test9.sh 13:30 warning: commands will be executed using /bin/sh job 6 at Tue Aug 9 13:30:00 2022 jiao@jiao virtual machine:~/桌面/linux shell/16$ atq 4\tMon Aug 8 16:00:00 2022 a jiao 5\tTue Aug 9 14:22:00 2022 a jiao 6\tTue Aug 9 13:30:00 2022 a jiao ``` #### 删除作业 ```bash atrm 编号 ``` ```bash jiao@jiao virtual machine:~/桌面/linux shell/16$ atq 4\tMon Aug 8 16:00:00 2022 a jiao 5\tTue Aug 9 14:22:00 2022 a jiao 6\tTue Aug 9 13:30:00 2022 a jiao jiao@jiao virtual machine:~/桌面/linux shell/16$ atrm 4 jiao@jiao virtual machine:~/桌面/linux shell/16$ atrm 5 jiao@jiao virtual machine:~/桌面/linux shell/16$ atq 6\tTue Aug 9 13:30:00 2022 a jiao ``` ### 安排需要定期执行的脚本 Linux系统使用cron程序来安排要定期执行的作业。cron程序会在后台运行并检查一个特殊的表（被称作cron时间表），以获知已安排执行的作业 #### cron时间表 cron时间表采用一种特别的格式来指定作业何时运行。其格式如下： ```bash min hour dayofmonth month dayofweek command ``` cron时间表允许你用特定值、取值范围（比如1~5）或者是通配符（星号）来指定条目 ```bash 15 10 * * * command ``` > 可以用三字符的文本值（mon、tue、wed、thu、fri、sat、sun）或数值（0为周日，6为周六）来指定dayofweek表项 > 如何设置一个在每个月的最后一天执行的命令，因为你无法设置dayofmonth的值来涵盖所有的月份。这个问题困扰着Linux和Unix程序员，也激发了不少解决办法。常用的方法是加一条使用date命令的if then语句来检查明天的日期是不是01：00 12 * * * if [`date +%d d tomorrow` 01 ] ; then ; command它会在每天中午12点来检查是不是当月的最后一天，如果是，cron将会运行该命令 命令列表必须指定要运行的命令或脚本的全路径名。你可以像在普通的命令行中那样，添加任何想要的命令行参数和重定向符号 会用提交作业的用户账户运行该脚本。因此，你必须有访问该命令和命令中指定的输出文件的权限 #### 创建crno表 crontab命令来处理cron时间表。要列出已有的cron时间表，可以用 l选项。 ```bash jiao@jiao virtual machine:~/桌面/linux shell/16$ crontab l no crontab for jiao ``` 默认情况下，用户的cron时间表文件并不存在。要为cron时间表添加条目，可以用 e选项。在添加条目时，crontab命令会启用一个文本编辑器（参见第10章），使用已有的cron时间表作为文件内容（或者是一个空文件，如果时间表不存在的话）。 #### 浏览cron目录 如果你创建的脚本对精确的执行时间要求不高，用预配置的cron脚本目录会更方便。有4个基本目录：hourly、daily、monthly和weekly ```bash' jiao@jiao virtual machine:~/桌面/linux shell/16$ ls /etc/cron.*ly /etc/cron.daily: 0anacron apport apt compat aptitude cracklib runtime dpkg logrotate man db /etc/cron.hourly: /etc/cron.monthly: 0anacron /etc/cron.weekly: 0anacron man db ``` > 脚本每天都要运行就把他复制到daily目录 #### anacron程序 唯一的问题是, 它的假设是Linux二十四小时运行 如果某个作业在cron时间表中安排运行的时间已到，但这时候Linux系统处于关机状态，那么这个作业就不会被运行。当系统开机时，cron程序不会再去运行那些错过的作业 要解决这个问题，许多Linux发行版还包含了anacron程序。如果anacron知道某个作业错过了执行时间，它会尽快运行该作业。这意味着如果Linux系统关机了几天，当它再次开机时，原定在关机期间运行的作业会自动运行 anacron程序只会处理位于cron目录的程序，比如/etc/cron.monthly。它用时间戳来决定作业是否在正确的计划间隔内运行了。每个cron目录都有个时间戳文件，该文件位于/var/spool/ anacron。 ```bash jiao@jiao virtual machine:~/桌面/linux shell/16$ sudo cat /var/spool/anacron/cron.monthly [sudo] jiao 的密码： 20220719 ``` anacron程序使用自己的时间表（通常位于/etc/anacrontab）来检查作业目录 ```bash jiao@jiao virtual machine:~/桌面/linux shell/16$ sudo cat /etc/anacrontab # /etc/anacrontab: configuration file for anacron # See anacron(8) and anacrontab(5) for details. SHELL /bin/sh HOME /root LOGNAME root # These replace cron's entries 1\t5\tcron.daily\trun parts report /etc/cron.daily 7\t10\tcron.weekly\trun parts report /etc/cron.weekly @monthly\t15\tcron.monthly\trun parts report /etc/cron.monthly ``` anacron时间表的基本格式和cron时间表略有不同： ```bash period delay identifier command ``` > period条目定义了作业多久运行一次，以天为单位。anacron程序用此条目来检查作业的时间戳文件。delay条目会指定系统启动后anacron程序需要等待多少分钟再开始运行错过的脚本。command条目包含了run parts程序和一个cron脚本目录名。run parts程序负责运行目录中传给它的任何脚本 anacron不会运行位于/etc/cron.hourly的脚本。这是因为anacron程序不会处理执行时间需求小于一天的脚本 ### 使用新的shell启动脚本 基本上，依照下列顺序所找到的第一个文件会被运行，其余的文件会被忽略： + $HOME/.bash_profile + $HOME/.bash_login + $HOME/.profile 因此，应该将需要在登录时运行的脚本放在上面第一个文件中 每次启动一个新shell时，bash shell都会运行.bashrc文件。 .bashrc文件通常也是通过某个bash启动文件来运行的。因为.bashrc文件会运行两次：一次是当你登入bash shell时，另一次是当你启动一个bash shell时。如果你需要一个脚本在两个时刻都得以运行，可以把这个脚本放进该文件中"},"/note/Linux/Linux命令行与shell脚本编程大全/2022-8-6-更多结构化命令.html":{"title":"更多结构化命令《Linux命令行与Shell脚本编程大全》","content":" layout: post title: \"更多结构化命令《Linux命令行与Shell脚本编程大全》\" date: 2022 8 6 15:39:08 +0800 tags: 《Linux命令行与Shell脚本编程大全》 Linux # 更多结构化命令 ## for命令 ```bash for var in list do \tcommands done ``` 在每次迭代中，变量var会包含列表中的当前值。第一次迭代会使用列表中的第一个值，第二次迭代使用第二个值，以此类推，直到列表中的所有值都过一遍 和python中的迭代一样 ### 读取列表中的值 读取自己定义的列表 ```bash 1 #!/bin/bash 2 for test in Alabama Alaska Arizona Arkansas California Colorado 3 do 4 echo The next state is $test 5 done jiao@jiao virtual machine:~/桌面/linux shell/13$ test.sh The next state is Alabama The next state is Alaska The next state is Arizona The next state is Arkansas The next state is California The next state is Colorado ``` > test会保留最后一次循环的值 ### 读取列表的复杂值 ```bash 1 #!/bin/bash 2 3 for test in I don't know if this'll work 4 do 5 echo \"word:$test\" 6 done 7 #another example of how not to use the 8 for test in I don\\'t know if \"this'll\" work 9 do 10 echo \"word:$test\" 11 done jiao@jiao virtual machine:~/桌面/linux shell/13$ test2.sh word:I word:dont know if thisll word:work word:I word:don't word:know word:if word:this'll word:work ``` > 会把存在的引号当做分割的符号, 可以使用转义字符, 或者使用另一种引号引起来 > for循环假定所有的分割都使用的空格, 如果有的值中间存在空格要使用引号引起来 ```bash 1 #!/bin/bash 2 for test in Nevada \"New Hampshire\" \"New Mexico\" \"New York\" \"North Carolina\" 3 do 4 echo $test 5 done jiao@jiao virtual machine:~/桌面/linux shell/13$ test3.sh Nevada New Hampshire New Mexico New York North Carolina ``` ### 从变量读取列表 把值存放在一份列表之中 ```bash 1 #!/bin/bash 2 list \"Alabama Alaska Arizona Arkansas Colorado\" 3 for test in $list 4 do 5 echo \"Have you ever visted $test\" 6 done jiao@jiao virtual machine:~/桌面/linux shell/13$ test4.sh Have you ever visted Alabama Have you ever visted Alaska Have you ever visted Arizona Have you ever visted Arkansas Have you ever visted Colorado ``` ### 从命令读取值 生成列表中所需值的另外一个途径就是使用命令的输出。可以用命令替换来执行任何能产生输出的命令，然后在for命令中使用该命令的输出 ```bash 1 #!/bin/bash 2 file \"state\" 3 for state in $(cat $file) 4 do 5 echo \"Visit beautiful $state\" 6 done # state文件 1 Alabama 2 Alaska 3 Arizona 4 Arkansas 5 Colorado 6 Connecticut 7 Delaware 8 Florida 9 Georgia jiao@jiao virtual machine:~/桌面/linux shell/13$ test5.sh Visit beautiful Alabama Visit beautiful Alaska Visit beautiful Arizona Visit beautiful Arkansas Visit beautiful Colorado Visit beautiful Connecticut Visit beautiful Delaware Visit beautiful Florida Visit beautiful Georgia ``` ### 更换字段的分隔符 环境变量IFS, 叫做**内部字段分隔符**, 定义了bash shell作为分隔符的一些列字符, 通常为 + 空格 + 制表符 + 换行符 要想只识别换行符, `IFS $'\\n'` ```bash 1 #!/bin/bash 2 # reading values from a file 3 file \"states\" 4 IFS $'\\n' 5 for state in $(cat $file) 6 do 7 echo $state 8 done jiao@jiao virtual machine:~/桌面/linux shell/13$ test6.sh Visit beautiful Alabama Visit beautiful Alaska Visit beautiful Arizona Visit beautiful Arkansas Visit beautiful Colorado Visit beautiful Connecticu Visit beautiful Delaware Visit beautiful Florida Visit beautiful Georgia Visit beautiful New York Visit beautiful New Hampshire Visit beautiful North Carolina ``` > 最好再更改之前对IFS的值进行保存 ```bash IFS.OLD $IFS IFS $'\\n' <在代码中使用新的IFS值> IFS $IFS.OLD ``` > 可以设置多个分隔符, 只需要串起来 ```bash IFS $'\\n':;\" ``` > 使用换行符, 冒号, 分号, 双引号为分隔符 ### 用通配符读取目录 可以使用for命令来遍历目录中的文件, 进行此操作时，必须在文件名或路径名中使用通配符。它会强制shell使用文件扩展匹配。 ```bash 1 #!/bin/bash 2 for file in /home/jiao/* 3 do 4 if [ d \"$file\" ] 5 then echo \"$file is a dictory\" 6 elif [ f \"$file\" ] 7 then echo \"$file is a dictory\" 8 fi 9 done jiao@jiao virtual machine:~/桌面/linux shell/13$ test7.sh /home/jiao/01_Python is a dictory /home/jiao/公共的 is a dictory /home/jiao/模板 is a dictory /home/jiao/视频 is a dictory /home/jiao/图片 is a dictory /home/jiao/文档 is a dictory /home/jiao/下载 is a dictory /home/jiao/音乐 is a dictory /home/jiao/桌面 is a dictory /home/jiao/Makefile is a dictory /home/jiao/snap is a dictory ``` > 在Linux文件名包含空格是合法的, 所以为了适应, 用引号括起来 > 也可以在for命令中列出多个目录通配符，将目录查找和列表合并进同一个for语句 ```bash for file in /home/rich/.b* /home/rich/badtest ``` ## C语言风格的for语句 ```bash for (( variableassignment ; condition ; iterationprocess )) ``` ```bash 1 #!/bin/bash 2 for (( i 1 ; i<10 ; i++ )) 3 do 4 echo \"The next is $i\" 5 done jiao@jiao virtual machine:~/桌面/linux shell/13$ test8.sh The next is 1 The next is 2 The next is 3 The next is 4 The next is 5 The next is 6 The next is 7 The next is 8 The next is 9 ``` ### 使用多个变量 也允许为迭代使用多个变量。循环会单独处理每个变量，你可以为每个变量定义不同的迭代过程。尽管可以使用多个变量，但你只能在for循环中定义一种条件 for (( a 1, b 10; a < 10; a++, b )) ## while命令 只要定义的测试命令的代码返回值是0, 就一直进行循环 ### while的基本格式 ```bash while testcommand do \tothercommands done ``` while命令中定义的test command和if then语句中的格式一模一样, 可以使用任何普通的bash shell命令，或者用test命令进行条件测试 ```bash 1 #!/bin/bash 2 val1 10 3 while [ $val1 gt 0 ] # 这里用的是test命令的中括号 4 do 5 echo $val1 6 val1 $[ $val1 1 ] # 这里使用的是浮点数计算时候讲的中括号 7 done ``` ### 使用多个测试命令 while命令允许你在while语句行定义多个测试命令。只有最后一个测试命令的退出状态码会被用来决定什么时候结束循环。 ```bash 1 #!/bin/bash 2 var1 10 3 while echo $var1 4 [ $var1 ge 0 ] 5 do 6 echo \"This is inside loop\" 7 var1 $[ $var1 1 ] 8 done jiao@jiao virtual machine:~/桌面/linux shell/13$ test10.sh 10 This is inside loop 9 This is inside loop 8 This is inside loop 7 This is inside loop 6 This is inside loop 5 This is inside loop 4 This is inside loop 3 This is inside loop 2 This is inside loop 1 This is inside loop 0 This is inside loop 1 ``` > **注意**，每个测试命令都出现在单独的一行上 ## until命令 测试命令码不为0的时候进行循环, 不为0的时候退出循环 ```bash until test command do \tother commands done ``` ```bash 1 #!/bin/bash 2 3 var1 100 4 until [ $var1 eq 0 ] 5 do 6 echo $var1 7 var1 $[ $var1 25 ] 8 done ``` ## 嵌套循环 ```bash 10 for (( a 1; a < 3; a++ )) 11 do 12 echo \"Start loop $a:\" 13 for (( b 1; b< 3; b++ )) 14 do echo \" Inside loop: $b\" 15 done 16 done ``` ## 循环处理文件数据 ```bash 1 #!/bin/bash 2 3 IFS.OLD $IFS 4 IFS $'\\n' 5 for entry in $(cat /etc/passwd) # 这里已经把结果分割为多个值了 6 do 7 echo \"Value in $entry \" 8 IFS : 9 for value in $entry 10 do 11 echo \" $value\" 12 done 13 done Value in jiao:x:1000:1000:jiao,,,:/home/jiao:/bin/bash jiao x 1000 1000 jiao,,, /home/jiao /bin/bash ``` ## 控制循环 + break + continue ### break #### 跳出单次循环 略 #### 跳出内层循环 略 #### 跳出外层循环 有时你在内部循环，但需要停止外部循环。break命令接受单个命令行参数值 ```bash break n ``` > n为1, 跳出挡圈循环, 2跳出下一层 ```bash 1 #!/bin/bash 2 3 for ((a 0;a<4;a++)) 4 do 5 echo \"Outer loop $a\" 6 for ((b 1;b<100;b++)) 7 do 8 if [ $b gt 4 ] 9 then 10 break 2 11 fi 12 echo \" Inner loop $b\" 13 done 14 done jiao@jiao virtual machine:~/桌面/linux shell/13$ test14.sh Outer loop 0 Inner loop 1 Inner loop 2 Inner loop 3 Inner loop 4 ``` ### continue命令 也可以使用数字, 用来停止外部的循环 ## 处理循环输出 ```bash 1 #!/bin/bash 2 for ((a 1;a<10;a++)) 3 do 4 echo \"The number is $a\" 5 done > test.txt\t\t\t\t# 输出到一个文件中 6 echo \"The command is finish\" ``` + 同样使用于管道 ```bash 1 #!/bin/bash 2 3 for state in \"North Dakota\" Connecticut Illinois Alabama Tennessee 4 do 5 echo \"$state is the next place to go\" 6 done sort 7 echo \"This conplete our travel\" ``` ## 实例 ### 查找可执行的文件 查找PATH下的所有可执行文件 ```bash 1 #!/bin/bash 2 IFS : 3 for floder in $PATH 4 do 5 for file in $floder/* 6 do 7 if [ x $file ] 8 then 9 echo \" $file\" 10 fi 11 done 12 done ``` ### 创建多个用户账户 csv格式保存用户的id以及用户的名字 ```bash 1 #!/bin/bash 2 3 input \"users.csv\" 4 while IFS ',' read r userid name\t\t# 下一 5 do 6 echo \"add $userid\" 7 useradd c \"$name\" m $userid 8 done < \"$input\" ```"},"/note/Linux/Linux命令行与shell脚本编程大全/2022-8-1-初认识Linux_shell.html":{"title":"初认识《Linux命令行与Shell脚本编程大全》","content":" layout: post title: \"初认识《Linux命令行与Shell脚本编程大全》\" date: 2022 8 1 11:29:08 +0800 tags: 《Linux命令行与Shell脚本编程大全》 Linux # 初认识 ## 什么是Linux Linux可以划分为四部分 + Linux内核 + GUN工具 + 图形化桌面环境 + 应用软件 ![QQ图片20220801135328](https://blog 1308522872.cos.ap beijing.myqcloud.com/jhy/202212312348645.png) ### 深入研究内核 内核的功能, 系统内存管理, 软件程序管理, 硬件设备管理, 文件系统管理 #### 系统内存管理 可用的物理内存, 创建管理虚拟内存, 虚拟内存是物理内存和交换空间的总和 通过**硬盘**上的存储空间来实现虚拟内存, 被称为交换空间 内核不断地在交换空间和实际的物理内存之间交换虚拟内存的内容, 内存存储单元被分为页面, 存储于物理内存或者交换空间, 然后建立页表, 指明不同的页面使用情况 当一些页面一段时间没有使用, 就会存入交换空间, 称为**换出**, 即便还有可用的内存, 使用已经换出的内存的时候, 会从内存腾出空间 #### 软件程序管理 Linux把运行中的程序叫做进程, 内核控制着Linux系统如何管理运行的进程 内核创建第一个进程, 名为`init进程`, 用来启动所有其他进程, 启动的时候把`init`加载到虚拟内存, 启动其他的进程的时候会在虚拟内存给新的进程分配专有内存 一些Linux发行版使用一个表来管理在系统开机时要自动启动的进程。在Linux系统上，这个表通常位于专门文件`/etc/inittab`中, 还有一些放在`/etc/init.d`, 开机的时候启动或停止应用的脚本就放在这里, 这些脚本通过`/etc/rcX.d`目录下的入口（entry）启动，这里的X代表运行级, 其实是脚本的符号链接 `init`采用了运行级, 决定了目录中进程类型 有五个运行级: + 为1的时候只启动基本系统进程和控制中断, 单用户模式, 系统有问题时维护, 只有一个人可以登陆 + 3是标准的启动级, 大多数应用软件，比如网络支持程序，都会启动 + 5级启动图形化的X Window系统，允许用户通过图形化桌面窗口登录系统 #### 硬件设备管理 任何Linux系统需要与之通信的设备，都需要在内核代码中加入其驱动程序代码, 允许内核与设备之间交换数据. 有两种方式插入: + 编译进内核的设备驱动代码 + 可插入内核的设备驱动代码: 内核模块概念 **Linux系统将硬件设备当成特殊的文件** + 字符型设备文件: 处理数据时只能处理一个字节, 如: 调制解调器, 终端 + 块设备文件: 每次处理大块的数据, 如: 硬盘 + 网络设备文件: 以数据包的形式发送接收数据, 如: 网卡, 回环设备 Linux为系统上的每个设备都创建一种称为**节点**的特殊文件。与设备的所有通信都通过设备节点完成。每个节点都有唯一的数值对供Linux内核标识它。数值对包括一个主设备号和一个次设备号。类似的设备被划分到同样的主设备号下。次设备号用于标识主设备组下的某个特定设备。 #### 文件系统管理 比必须在编译的时候加入 支持自身的特有的以及其他平台的文件系统 采用虚拟文件系统VFS作为每一个文件系统交换的接口, 提供一个标准的接口 ## GUN工具 操作系统还需要工具来执行一些标准功能，比如控制文件和程序 GNU组织（GNU是GNU’s Not Unix的缩写）开发了一套完整的Unix工具，但没有可以运行它们的内核系统 尽管通常将Linux内核和GNU工具的结合体称为Linux，但你也会在互联网上看到一些Linux纯粹主义者将其称为GNU/Linux系统 ### 核心GNU工具 称为`coreutils`软件包 包括三部分 + 处理文件 + 操作文件 + 管理进程 ### shell 特殊的交互工具, 它为用户提供了启动程序、管理文件系统中的文件以及运行在Linux系统上的进程的途径。shell的核心是命令行提示符 包含一组命令, 用来操作文件, 操控进程等 你也可以将多个shell命令放入文件中作为程序执行。这些文件被称作shell脚本 通常有好几种Linux shell可用。不同的shell有不同的特性, 所有Linux发行版默认的shell都是bash shell 常见的shell shell 描述 : : : : ash 一种运行在内存受限环境中简单的轻量级shell，但与bash shell完全兼容 korn 一种与Bourne shell兼容的编程shell，但支持如关联数组和浮点运算等一些高级的编程特性 tcsh 一种将C语言中的一些元素引入到shell脚本中的shell zsh 一种结合了bash、tcsh和korn的特性，同时提供高级编程特性、共享历史文件和主题化提示符的高级shell 大多数发行版有多种shell ## 桌面系统 ### X Window 视频环境的决定 + 显示器 + 显卡 为了和两者互通, X Window软件是图形显示的核心部分 X Window软件是直接和PC上的显卡及显示器打交道的底层程序。它控制着Linux程序如何在电脑上显示出漂亮的窗口和图形, 有多种软件包, 最流行的是X.org, Wayland, Mir显示服务器 在首次安装Linux发行版时，它会检测显卡和显示器，然后创建一个含有必要信息的X Window配置文件。 核心的X Window软件可以产生图形化显示环境，但仅此而已, 它没有桌面环境供用户操作文件或是开启程序 ### KDE桌面 和Windows类似, 有相关的运行程序 ### GNOME桌面 不再使用Windows标准观感, 但是还是继承了一些习惯, 也开发了运行程序 ### Unity桌面 Ubuntu公司开发的, 为不同的设备提供一致的桌面体验 ### 其他桌面 由于要占用一定的资源保证运行, 而上面的桌面又占用较大的空间, 所以开发出一些小型的桌面, 也已运行基本功能 ## Linux发行版 完整的Linux系统, 大多是是为了特殊的用户定制的, 通常归为三类 + 完整的核心Linux发行版 + 特定用途的发行版 + LiveCD测试发行版 ### 核心Linux发行版 含有内核, 一个或多个桌面, 编译好的几乎所有Linux应用 有大量的可选配置 发 行 版 描 述 : : : : Slackware 最早的Linux发行版中的一员，在Linux极客中比较流行 Red Hat 主要用于Internet服务器的商业发行版 Fedora 从Red Hat分离出的家用发行版 Gentoo 为高级Linux用户设计的发行版，仅包含Linux源代码 openSUSE 用于商用和家用的发行版 Debian 在Linux专家和商用Linux产品中流行的发行版 ### 特定用途的Linux发行版 基于某个主流的发行版, 但是仅包含主流发行版中的一小部分用于某些特定的应用程序 提供特定软件, 自动检测常见的硬件 许多特定用途的发行版都是基于Debian的 ### Linux LiveCD 含有Linux样本系统（称为Linux LiveCD）的可引导CD。由于单张CD容量的限制，这个样本并非完整的Linux系统，不过令人惊喜的是，你可以自己加入各种软件。结果就是，你可以通过CD来启动PC，并且无需在硬盘安装任何东西就能运行Linux发行版。"},"/note/Linux/Linux命令行与shell脚本编程大全/2022-8-1-基本bashshell命令.html":{"title":"基本bash shell命令《Linux命令行与Shell脚本编程大全》","content":" layout: post title: \"基本bash shell命令《Linux命令行与Shell脚本编程大全》\" date: 2022 8 1 11:29:08 +0800 tags: 《Linux命令行与Shell脚本编程大全》 Linux # 基本bash shell命令 大多数的Linux默认的都是GUN bash shell, 在ubuntu6.1之后大部分是dash ## 启动shell GUN bash shell能提供对Linux的交互式访问.它是作为普通程序运行的, 通常在用户登录的时候启动.登录时启动依赖于用户的账户设置 `/etc/passwd`包含了所有系统用户账户列表以及每个用户的基本信息 > `jiao:x:1000:1000:jiao,,,:/home/jiao:/bin/bash` 有七个字段, 每个字段用冒号分割, 系统利用数据赋予用户特定的属性, 最后代表使用的shell程序 最后一个是bash, 在启动之后使用`/bin/bash`作为默认的shell程序, 启动之后bash shell自动启动, 是否出现命令界面(CLI), 取决于登录的方式是不是图形界面 ## shell提示符 默认的提示符是$, 表明正在等待用户输入, 出现的时候可以输入新的命令 > jiao@jiao virtual machine:~$ 除了用户名还有用户的系统名 bash中还有bash手册大有帮助 ## bash手册 查找shell命令以及其他GUN工具信息的在线手册, 可以帮你查找参数 > man命令: 访问手册页面, 在想要查找的工具之前输入man可以找到对应的手册条目 + 手册把不同的信息分为不同的节 节 描述 : : : : Name 显示命令名和一段简短的描述 Synopsis 命令的语法 Confi guration 命令配置信息 Description 命令的一般性描述 Options 命令选项描述 Return Value 命令的返回值 Errors 命令的错误消息 Environment 描述所使用的环境变量 Files 命令用到的文件 Versions 命令的版本信息 Conforming To 命名所遵从的标准 Notes 其他有帮助的资料 Bugs 提供提交bug的途径 Example 展示命令的用法 Authors 命令开发人员的信息 Copyright 命令源代码的版权状况 See Also 与该命令类型的其他命令 > 如果不记得命令名怎么办？可以使用关键字搜索手册页。语法是：man k 关键字。例如，要查找与终端相关的命令，可以输入man k terminal 还为每一个区域都分配了一个数字 1. 可执行的shell命令 2. 系统调用 3. 库调用 4. 特殊文件 5. 文件格式与约定 6. 游戏 7. 概览、约定及杂项 8. 超级用户和管理员命令 9. 内核例程 一个命令有时候会在多个区域, 要查看不同区域的 ```bash $ man section# topic 例如hostname同时在1和7 $ man 1 hostname $ man 7 hostname ``` ### 大多数命令都接受 help或 help 可以使用help help查看, 有中文 ### info **info [选项] 参数** 参数：指定需要获得帮助的主题，可以是指令、函数以及配置文件。 > d：添加包含info格式帮助文档的目录； > f：指定要读取的info格式的帮助文档； > n：指定首先访问的info帮助文件的节点； > o：输出被选择的节点内容到指定文件。 快捷键 > ?键：它就会显示info的常用快捷键。 > N键：显示（相对于本节点的）下一节点的文档内容。 > P键：显示（相对于本节点的）前一节点的文档内容。 > U键：进入当前命令所在的主题。 > M键：敲M键后输入命令的名称就可以查看该命令的帮助文档了。 > G键：敲G键后输入主题名称，进入该主题。 > L键：回到上一个访问的页面。 > SPACE键：向前滚动一页。 > BACKUP或DEL键：向后滚动一页。 > Q：退出info。 常用指令 > ？ 显示帮助窗口 > > 在帮助窗口中： > Ctrl x 0 关闭帮助窗口 > Ctrl x Ctrl c 关闭整个 Info > > q 退出 info > n 打开与本 Node 关联的下一个 Node > p 打开与本 Node 关联的前一个 Node > u 打开与本 Node 关联的上一个 Node > l 回到上一次访问的 Node > m或g 选择一个菜单项（Node 的名字） > 输入指定菜单的名字后按回车，打开指定菜单项关联的 Node > 空格键 下一页（PageDown 也可以，下一页从当前页的最后两行开始算起） > 下一个 Node （若当前页在 Node 文档的末尾） > Del 键 上一页（PageUp 也可以，上一页从当前页的开始两行开始算起） > 上一个 Node （若当前页 Node 文档的开始） > > b 或 t 或 Home 文档的开始（b 是 begining 的意思） > e 或 End 文档的末尾（b 是 ending 的意思） > Ctrl l 刷新当前页，若当前文档显示情况有问题时 > Ctrl g 取消所键入的指令 ## 浏览文件系统 ### Linux文件系统 不使用驱动盘符, windows会为每一个物理磁盘驱动器分配一个盘符 Linux把文件存储在单个文件目录之中, 这个目录叫**虚拟目录** 虚拟目录把所有存储设备的文件目录路径纳入单个文件目录之中 Linux虚拟目录结构只包含一个称为根（root）目录的基础目录。根目录下的目录和文件会按照访问它们的目录路径一一列出，这点跟Windows类似 在Linux上安装的第一块硬盘为**根驱动器**, 包含了虚拟内存的核心, 其他目录都是从那里开始挂载的 Linux会在根驱动器上创建一些特别的目录，我们称之为**挂载点**（mount point）。挂载点是虚拟目录中用于分配额外存储设备的目录。虚拟目录会让文件和目录出现在这些挂载点目录中，然而实际上它们却存储在另外一个驱动器中 > 通常系统文件会存储在根驱动器中，而用户文件则存储在另一驱动器中 + 在Linux之中通用的目录名用于一些常见的功能 目录 用途 : : : : / 虚拟目录的根目录。通常不会在这里存储文件 /bin 二进制目录，存放许多用户级的GNU工具 /boot 启动目录，存放启动文件 /dev 设备目录，Linux在这里创建设备节点 /etc 系统配置文件目录 /home 主目录，Linux在这里创建用户目录 /lib 库目录，存放系统和应用程序的库文件 /media 媒体目录，可移动媒体设备的常用挂载点 /mnt 挂载目录，另一个可移动媒体设备的常用挂载点 /opt 可选目录，常用于存放第三方软件包和数据文件 /proc 进程目录，存放现有硬件及当前进程的相关信息 /root root用户的主目录 /sbin 系统二进制目录，存放许多GNU管理员级工具 /run 运行目录，存放系统运作时的运行时数据 /srv 服务目录，存放本地服务的相关文件 /sys 系统目录，存放系统硬件信息的相关文件 /tmp 临时目录，可以在该目录中创建和删除临时工作文件 /usr 用户二进制目录，大量用户级的GNU工具和数据文件都存储在这里 /var 可变目录，用以存放经常变化的文件，比如日志文件 常见的目录名均基于文件系统层级标准（filesystem hierarchy standard，FHS）。很多Linux发行版都遵循了FHS。这样一来，你就能够在任何兼容FHS的Linux系统中轻而易举地查找文件 ## 遍历目录 切换目录`cd destination` 没有参数的时候返回用户的主目录 #### 绝对文件目录 从根目录开始 > 提示符中的~表示位于自己的主目录之中 > 切换出主目录以后会显示绝对路径 检查目录`pwd` #### 相对文件路径 直接以目录名开头 + 单点符（.），表示当前目录； + 双点符（..），表示当前目录的父目录 ## 文件和目录列表 ### 基本列表功能 > `ls`按列以及字母顺序进行排列 > `ls F`在目录的后面加上斜杠, 用于区分目录, 可用于没有颜色区分的仿真器 > `ls a`显示隐藏文件, 通常以\" . \"开头 > `ls R`递归显示子目录中的文件 > `ls d`只列出目录本身的信息(在查找的时候使用名字显示文件内容) > `ls i`查看文件的编号, 每一个文件都有唯一的编号 ### 显示长列表 > `ls l`显示文件的附加信息 `drwxrwxr x 2 jiao jiao 4096 3月 18 20:04 01_Python` + 文件类型，比如目录（d）、文件（ ）、字符型文件（c）或块设备（b）； + 文件的权限（参见第6章）； + 文件的硬链接总数； + 文件属主的用户名； + 文件属组的组名； + 文件的大小（以字节为单位）； + 文件的上次修改时间； + 文件名或目录名。 ### 过滤输出列表 过滤器: 进行简单文本匹配的字符串 `ls l my_script`匹配对应的文件名 文件扩展匹配, 使用元字符通配符 + 问号（?）代表一个字符； + 星号（*）代表零个或多个字符 + 中括号[eleect] 进行选择[a i]区间, [! a]进行排除 ## 处理文件 ### 创建文件 `touch`创建空文件, 并使用你的用户名作为文件的属主 > 还可以用来改变文件的修改时间, 但是不修改文件的内容 > 也可以使用 a来改变访问时间`ls l time atime test`查看文件的访问时间 ### 复制文件 ```bash cp source destination ``` 如果新文件的文件名已经存在可能不会提示, 最好加上 i, 显示提示 要是想要复制到一个目录要在最后加上/, 否则可能会创建一个文件和目录同名(测试的时候复制到文件中了) R 递归的复制一个文件夹 也可以在复制文件的时候使用通配符 ### 制表键自动补全 按一下补全, 如果有多个满足的文件按两下显示所有 ### 链接文件 如果需要维护一个文件的多个副本, 除了单独的物理副本, 还有虚拟副本, 有两种链接 + 符号链接: 一个实实在在的文件, 指向存放在虚拟目录结构某一个地方的另一个文件 + 硬链接: 创建单独的虚拟文件, 包含源文件的信息以及位置 符号链接: `ln s 原文件名 链接名`, 创建的是一个指针, 但是属于另一个文件, 可以使用`ls i `查看文件编号 ```bash //源文件 811102 drwxrwxr x 2 jiao jiao 4.0K 8月 2 14:36 abb //链接 800794 lrwxrwxrwx 1 jiao jiao 3 8月 2 14:21 baa > abb ``` > 文件的大小不同, 文件编号不同, 源文件的链接数是2 **硬链接**: `ls 原文件名 链接名` ```bash //链接出来的文件 800795 rw rw r 2 jiao jiao 4 8月 2 13:27 acc //源文件 800795 rw rw r 2 jiao jiao 4 8月 2 13:27 test ``` > 文件大小相同, 文件的编号相同, 显示的链接数都是2 > **注: **对于硬链接只能处于一个存储媒体的文件 > > **我的理解:**硬链接是指向源文件的存储的另一个指针, 符号链接是指向源文件存储的二级指针 > > > > 删除硬链接的源文件不会造成影响, 但是删除符号链接的源文件会造成影响 ### 重命名 称为文件的移动 ```bash mv 源文件 目标地址 ``` 文件的编号时间戳都不变 > 可以使用 i来使得在覆盖文件的时候有提示 ### 删除文件 ```bash rm 文件名 ``` > i: 显示是否要删除的提示 bash shell没有回收站或垃圾桶 > 可以使用通配符 > f: 取消所有的提示 ## 处理目录 ### 创建目录 ```bash mkdir 文件夹的名字 ``` > p: 创建多个文件目录和子目录 ### 删除目录 ```bash redir 文件名 ``` > 只能删除空目录, 没有 i选项 ```bash rm r 文件名 ``` 删除整个文件, 可以和 i命令配合使用选择删除, 和 f配合使用直接删除 ## 查看文件内容 ### 查看文件类型 ```bash file 文件名 ``` 确定文件的信息以及编码, 可以返回二进制文件面向的平台以及需要的各种类型的库 ### 查看整个文件 #### cat ```bash cat 文件名 //查看文件 ``` > n: 加上行号 > b: 只给有文本的行加上行号 > T: 禁止制表符出现, 把所有的制表符转换为`^I` #### more 显示文本的内容, 但是每次只显示一页的内容 回车一次显示一行, 空额下一行, 和手册的使用一样 Ctrl+B往上翻 Ctrl+F往下翻 #### less more的升级版 ### 查看部分文件 #### tail ```bash tail 文件名 ``` > 显示文件的最后几行 ```bash tail n 数字 文件名 tail 数字 文件名 ``` > 显示文件最后n行 > f: 在其他进程添加信息的时候实时显示 #### head ```bash head 文件名 ``` > 显示文件的前几行 > n: 显示的行数"},"/note/Linux/Linux命令行与shell脚本编程大全/2022-8-4-安装软件程序.html":{"title":"安装软件程序《Linux命令行与Shell脚本编程大全》","content":" layout: post title: \"安装软件程序《Linux命令行与Shell脚本编程大全》\" date: 2022 8 4 15:03:08 +0800 tags: 《Linux命令行与Shell脚本编程大全》 Linux # 安装软件程序 包管理系统（package management system，PMS） ## 包管理基础 主流的Linux都采用了某种形式的包管理系统来控制软件和库的安装, PSM利用一个数据库来记录各种相关的内容: + Linux上已安装了什么软件包 + 每个包安装了什么文件 + 每个已安装的软件包版本 软件包存储在服务器上，可以利用本地Linux系统上的PMS工具通过互联网访问。这些服务器称为仓库（repository）。可以用PMS工具来搜索新的软件包，或者是更新系统上已安装软件包 软件包通常会依赖其他的包，为了前者能够正常运行，被依赖的包必须提前安装在系统中。PMS工具将会检测这些依赖关系，并在安装需要的包之前先安装好所有额外的软件包 PMS没有统一的标准工具, 在不同Linux版本上有很大不同, 常见的有dpkg和rpm 基于Debian的发行版（如Ubuntu和Linux Mint）使用的是dpkg命令，这些发行版的PMS工具也是以该命令为基础的。dpkg会直接和Linux系统上的PMS交互，用来安装、管理和删除软件包 基于Red Hat的发行版（如Fedora、openSUSE及Mandriva）使用的是rpm命令，该命令是其PMS的底层基础。类似于dpkg命令，rmp命令能够列出已安装包、安装新包和删除已有软件 ## 基于Debine的系统 dpkg命令是基于Debian的PMS工具的核心 + apt get + apt cache + aptitude 最常用的是aptitude, 本质上是apt工具和dpkg的前端, dpkg是软件包管理系统工具，而aptitude则是完整的软件包管理系统 可以避免一系列的麻烦 ```dash aptitude ``` 进入aptitude软件可以用来查看软件的安装状态 ```bash aptitude show 软件包名 示例: jiao@jiao virtual machine:~/桌面$ aptitude show python3 软件包： python3 版本号： 3.9.4 1build1 状态: 已安装 自动安装: 是 Multi Arch: allowed 优先级： 重要 部分： python 维护者： Ubuntu Developers <ubuntu devel discuss@lists.ubuntu.com> 体系： amd64 未压缩尺寸： 91.1 k 依赖于: python3.9 (> 3.9.4 0~), libpython3 stdlib ( 3.9.4 1build1) 预依赖于: python3 minimal ( 3.9.4 1build1) 建议: python3 doc (> 3.9.4 1build1), python3 tk (> 3.9.4 0~), python3 venv (> 3.9.4 1build1) 冲突: python3:i386 代替: python3 minimal (< 3.1.2 2), python3 minimal:i386 (< 3.1.2 2) 提供: python3 profiler, python3 profiler:any, python3:any ( 3.9.4 1build1) 描述： interactive high level object oriented language (default python3 version) Python, the high level, interactive object oriented language, includes an extensive class library with lots of goodies for network programming, system administration, sounds and graphics. This package is a dependency package, which depends on Debian's default Python 3 version (currently v3.9). 主页： https://www.python.org/ ``` > 查看一个软件包如果软件还没有安装到系统, 就会从软件仓库获取软件仓库 使用aptitude命令, 不能查看某一个特定的软件包相关的软件列表, 要得到这个列表, 使用dpkg ```bash jiao@jiao virtual machine:~/桌面$ dpkg L python3 /. /usr /usr/bin /usr/lib /usr/lib/valgrind /usr/lib/valgrind/python3.supp /usr/share /usr/share/doc /usr/share/doc/python3 /usr/share/doc/python3/copyright /usr/share/doc/python3/python policy.txt.gz ... ``` 同样可以进行反向操作，查找某个特定文件属于哪个软件包。`dpkg search absolute_file_name`注意，在使用的时候必须用绝对文件路径。 ```bash jiao@jiao virtual machine:~/桌面$ dpkg search /usr/share/doc/python3 python3, python3 dev: /usr/share/doc/python3 ``` ### 使用aptitude安装软件包 ```bash jiao@jiao virtual machine:~/桌面$ aptitude search wine p fonts wine Windows API implementation fonts v fonts wine:i386 p gnome wine icon theme red variation of the GNOME Colors icon theme p libkwineffects11 KDE window manager effects library p libkwineffects11:i386 KDE window manager effects library v librust winapi+winefs dev v librust winapi+winefs dev:i386 v librust winapi+winerror dev v librust winapi+winerror dev:i386 v librust winapi+winevt dev v librust winapi+winevt dev:i386 v librust winapi 0+winefs dev ... ``` 每一个包前面都有一个p或i, 如果看到一个i, 表明已经安装, p和v表示可用但是没有安装, 这个软件还没有安装 软件的安装 ```bash sudo aptitude install 软件包名 ``` ### 用aptitude更新软件 ```bash aptitude safe upgrade ``` > 会把已经安装的包, 更新为最新为软件仓库的最新版本 还有一些不太保守的更新方式 + aptitude full upgrade + aptitude dist upgrade > 不会检查包与包之间的依赖关系 ### aptitude卸载软件 唯一要做的选择就是要不要保留软件的数据和配置文件 删除软件包不删除数据和配置文件 >`aptitude remove` 都删除 >`aptitude purge` ### aptitude卸载软件 在安装Linux发行版的时候被设置存储在/etc/apt/sources.list 在文件中 ```bash deb (or deb src) address distribution_name package_type_list ``` > deb或者deb src表明了软件包的类型, deb说明这是一个已经编译过的软件, deb src说明是源码的源 > > address是软件仓库的web地址 > > distribution_name是软件仓库发行版的名字 > > package_type_list可能不止一个, 表明仓库有什么类型的包 当需要给你的source_list文件添加软件仓库时，你可以自己发挥，但一般会带来问题。通常软件仓库网站或各种包开发人员网站上都会有一行文本，你可以直接复制，然后粘贴到sources.list文件中。最好选择较安全的途径并且只复制/粘贴 ## 基于Red Het的系统 有几种常见的发行版 + yum：在Red Hat和Fedora中使用。 + urpm：在Mandriva中使用。 + zypper：在openSUSE中使用。 ### 列出已经安装包 `yum list installed` 可以吧导出的信息用别的文本软件打开`yum list installed > installed_software` Mandriva中采用的urpm工具无法生成当前已安装软件列表。因此，你需要转向底层的rpm工具 版本 前端工具 命令 : : : : : : Mandriva urpm rpm qa > installed_software openSUSE zypper zypper search I > installed_software yum擅长找出某个特定软件包的详细信息。它能给出关于包的非常详尽的描述，另外你还可以通过一条简单的命令查看包是否已安装 ```bash # yum list xterm Loaded plugins: langpacks, presto, refresh packagekit Adding en_US to language list Available Packages xterm.i686 253 1.el6 # # yum list installed xterm Loaded plugins: refresh packagekit Error: No matching Packages to list ``` 查看各种包的信息 信息类型 前段工具 命令 : : : : : : 包信息 urpm urpmq i package_name 是否安装 urpm rpm q package_name 包信息 zypper zypper search s package_nam 是否安装 zypper 同样的命令，注意在Status列查找i 最后，如果需要找出系统上的某个特定文件属于哪个软件包，万能的yum可以做到！只要输入命令：\\ ```bash\\ yum provides file_name ``` ### yum安装软件 ```bash yum install package_name ``` 也可以手动下载rpm安装文件并用yum安装，这叫作本地安装。基本的命令是： ```bash yum localinstall package_name.rpm ``` 如何用zypper和urpm安装软件 前端工具 命 令 : : : : urpm urpmi package_name zypper zypper install package_name ### yum更新软件 ```bash yum list updates ``` 但如果发现某个特定软件包需要更新，输入如下命令 ```bash yum update package_name ``` 想对更新列表中的所有包进行更新，只要输入如下命令 ```bash yum update ``` + urpm > urpmi auto update update + zypper >zypper update ### 卸载 只删除软件包而保留配置文件和数据文件，就用如下命令： `yum remove package_name` 要删除软件和它所有的文件，就用erase选项： `yum erase package_name` + urpm > urpme package_name + zypper > zypper remove package_name ### 处理损坏的包依赖关系 某个包的软件依赖关系可能会被另一个包的安装覆盖掉。这叫作**损坏的包依赖关系** ```bash yum clean all ``` > 然后试着用yum命令的update选项。有时，只要清理了放错位置的文件就可以了 如果这还解决不了问题，试试下面的命令：`yum deplist package_name` 显示了所有包的库依赖关系以及什么软件可以提供这些库依赖关系。一旦知道某个包需要的库，你就能安装它们了 最后手段 ```bash yum update skip broken ``` > 允许你忽略依赖关系损坏的那个包，继续去更新其他软件包。这可能救不了损坏的包，但至少可以更新系统上的其他包。 用zypper时，只有一个命令能够用来验证和修复损坏的依赖关系。 用urpm时，如果clean选项不工作，你可以跳过更新那些有问题的包。要这么做的话，就必须将有问题包的名字添加到文件/etc/urpmi/skip.list。 + urpm > urpmi –clean + Zipper > zypper verify ### yum仓库 > 坚持使用通过审核的仓库。通过审核的仓库是指该发行版官方网站上指定的库。如果你添加了未通过审核的库，就失去了稳定性方面的保证，可能陷入损坏的依赖关系惨剧中 要想知道你现在正从哪些仓库中获取软件，输入如下命令：`yum repolist` yum的仓库定义文件位于/etc/yum.repos.d 像rpmfusion.org这种优秀的仓库站点会列出必要的使用步骤。有时这些仓库网站会提供一个可下载的rpm文件，可以用yum localinstall命令进行安装。这个rpm文件在安装过程会为你完成所有的仓库设置工作。 > urpm称它的仓库为媒体。查看urpm媒体和zypper仓库的命令列在了表9 7中。注意，用这两个前端工具时不需要编辑配置文件, 只需要输入命令就可以添加媒体或仓库 + 显示仓库 > urpm > urpmq list media + 添加仓库 > urpm > urpmi.addmedia path_name + 显示仓库 > zypper > zypper repos + 添加仓库 > zypper > zypper addrepo path_name ## 从源码安装 遇到tarball形式的软件 + 解压 ```bash # tar zxvf sysstat 11.1.1.tar.gz ``` + 进入解压的文件 + 查看reeademe文件 + 按照建议下一步进行系统配置 ```bash # ./configure Check programs: . checking for gcc... gcc checking whether the C compiler works... yes checking for C compiler default output file name... a.out [...] ``` + 使用make命令构建各种二进制文件 + make install把软件安装到对应的地址 ## 软件包 LInux软脚包一般都有相同的结构 文件类型 目录 普通程序 /usr/bin root用户程序 /usr/sbin 配置文件 /etc 日志文件 /var/log 文档 /usr/share/doc 安装的时候有两种, 分别是源码包以及二进制包, 源码包需要进行编译 ### deb包 Debian,Ubuntn,Deepin等发行版使用的软件包 #### 使用dpkg工具进行管理 ![image 20250622194729037](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506221947186.png) dpkg常用命令 ``` 安装软件:dpkg i xxxx.deb ``` ``` 查看安装目录:dpkg L xxxx ``` ``` 显示版本:dpkg l xxxx ``` ``` 详细信息:dpkg s xxxx ``` ``` 罗列内容:dpkg c xxxx.deb ``` ``` 卸载软件:dpkg r xxxx ``` #### deb包文件结构分析 一个模拟的根目录以及需要放到对应位置的文件, 比如 ./usr/bin/可执行文件 **必要的文件** DEBIAN目录: control文件: Package:软件名称 Version:版本 Section:软件类别 Priority:对系统的重要性 Architecture:支持的硬件平台 Maintainer:软件包的维护者 Description:对软件的描述 **可选的文件** preinst文件 : 安装之前执行的shell脚本 postinst文件 : 安装之后执行的shell脚本 prerm文件：卸载之前执行的shell脚本 postrm文件: 卸载之后执行的shell脚本 copyright文件:版权声明 changlog文件: 修改记录 下面是一个可以使用快速创建的脚本文件 ```sh #!/bin/bash version \"0.1.2\" author \"Emdebfire\" # 获取创建的包名字以及创建的目录 package_name \"$2\" package_dir \"$1\" # 建立一个目录文件 mkdir p ./$package_dir/DEBIAN/ # \"Here Document\"（常简称为 \"heredoc\"）是一种在 Shell 脚本中嵌入多行文本输入的特殊语法。它的核心作用是将一个文本块作为命令的标准输入，通常用于生成文件内容或向交互式命令提供输入。 cat <<EOF > ./$package_dir/DEBIAN/changelog AUTHOR:$author VERSION:$version DATE:$(date R) EOF cat <<EOF > ./$package_dir/DEBIAN/copyright ****************************************************************** * @attention * * 实验平台:野火 i.MX6ULL开发板 * 公司 :http://www.embedfire.com * 论坛 :http://www.firebbs.cn * 淘宝 :https://fire stm32.taobao.com * * * ****************************************************************** EOF # 写入详细的信息, 平台版本等 cat <<EOF > ./$package_dir/DEBIAN/control Source:embedfire Package:${package_name%.*} Version:$version Section: debug Priority: optional Architecture: amd64 Maintainer:$author Description: Embedfire Tools EOF # 安装以后得脚本 cat <<EOF > ./$package_dir/DEBIAN/postinst #!/bin/sh echo \"******************************************************************\" echo \"welcome to use $package_name!\" echo \"******************************************************************\" EOF sudo chmod 775 ./$package_dir/DEBIAN/postinst # 打包脚本 dpkg b $package_dir $package_name ``` > heredoc关键特性解析： > > 1. **分隔符（Delimiter）** > 使用 `<<` 后指定的标识符（如示例中的 `EOF`） > 文本内容从下一行开始，直到遇到**单独一行**的结束分隔符（必须完全匹配） > 常用 `EOF`（End Of File），但可以是任意字符串（如 `END`、`MYMARKER`） > 2. **文本处理规则** > **变量扩展**：`$author`、`$version` 会被替换为实际值 > **命令替换**：`$(date R)` 会执行并替换为命令输出 > **保留格式**：换行/缩进等空白字符会原样保留 > **特殊字符**：默认会解释 `$`、`\\` 等（除非禁用解释） > 3. **输出重定向** > 结合 `>` 将输出重定向到文件（覆盖写入） > 若需追加写入可使用 `>>` > > ```sh > # 使用 heredoc > cat <<EOF > file > 内容 > EOF > > # 等效于 > echo \"内容\" > file > ``` ##### 构建一个helloworld的deb包 ![image 20250622194446964](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506221944101.png) 演示:dpkg b 其他: dpkg buildpackage checkinstall ##### apt命令和apt get命令 apt是新版的包管理工具 解决apt get命令过于分散的问题 apt默认属性对用户友好(进度条、提示升级包数) ### rpn包 RedHat, Fedora使用的软件包"},"/note/Linux/Linux命令行与shell脚本编程大全/2022-8-9-认识sed和gawk.html":{"title":"认识sed和gawk《Linux命令行与Shell脚本编程大全》","content":" layout: post title: \"认识sed和gawk《Linux命令行与Shell脚本编程大全》\" date: 2022 8 9 23:39:08 +0800 tags: 《Linux命令行与Shell脚本编程大全》 Linux # 认识sed和gawk 处理文本文件内容 ## 文本处理 自动处理大量文件的时候, 使用命令行编辑器会方便一些 ### sed编辑器 被称为**流编辑器**, 流编辑器会在编辑器处理数据之前基于预先提供的一组规则来编辑数据流 这些命令要么从命令行中输入，要么存储在一个命令文本文件中。sed编辑器会执行下列操作 (1) 一次从输入中读取一行数据。 (2) 根据所提供的编辑器命令匹配数据。 (3) 按照命令修改流中的数据。 (4) 将新的数据输出到STDOUT。 ```bash sedoptions script file ``` 选项 描述 : : : : e script 在处理输入时，将script中指定的命令添加到已有的命令中 f file 在处理输入时，将file中指定的命令添加到已有的命令中 n 不产生命令输出，使用print命令来完成输出 script参数指定了应用于流数据上的单个命令。如果需要用多个命令，要么使用 e选项在命令行中指定，要么使用 f选项在单独的文件中指定。 #### 在命令行定义编辑器命令 ```bash jiao@jiao virtual machine:~/桌面/linux shell/18$ echo \"This is a test\" sed 's/test/big test/' This is a big test ``` ```bash jiao@jiao virtual machine:~/桌面/linux shell/19$ cat data1.txt The quick brown fox jumps over the lazy dog. The quick brown fox jumps over the lazy dog. The quick brown fox jumps over the lazy dog. The quick brown fox jumps over the lazy dog. jiao@jiao virtual machine:~/桌面/linux shell/19$ sed 's/dog/cat/' data1.txt The quick brown fox jumps over the lazy cat. The quick brown fox jumps over the lazy cat. The quick brown fox jumps over the lazy cat. The quick brown fox jumps over the lazy cat. ``` > sed编辑器并不会修改文本文件的数据。它只会将修改后的数据发送到STDOUT #### 在命令行上使用多个命令 ```bash jiao@jiao virtual machine:~/桌面/linux shell/19$ sed e 's/dog/cat/; s/brown/green/' data1.txt The quick green fox jumps over the lazy cat. The quick green fox jumps over the lazy cat. The quick green fox jumps over the lazy cat. The quick green fox jumps over the lazy cat. ``` > 命令之间必须用分号隔开，并且在命令末尾和分号之间不能有空格 + 如果不想用分号，也可以用bash shell中的次提示符来分隔命令。只要输入第一个单引号标示出sed程序脚本的起始（sed编辑器命令列表），bash会继续提示你输入更多命令，直到输入了标示结束的单引号 ```bash $ sed e ' > s/brown/green/ > s/fox/elephant/ > s/dog/cat/' data1.txt The quick green elephant jumps over the lazy cat. The quick green elephant jumps over the lazy cat. The quick green elephant jumps over the lazy cat. The quick green elephant jumps over the lazy cat. ``` #### 从文件中读取编辑器命令 最后，如果有大量要处理的sed命令，那么将它们放进一个单独的文件中通常会更方便一些。可以在sed命令中用 f选项来指定文件 ```bash jiao@jiao virtual machine:~/桌面/linux shell/19$ cat scrip1.sad s/brown/green/ s/fox/elephant/ s/dog/cat/ jiao@jiao virtual machine:~/桌面/linux shell/19$ sed f scrip1.sad data1.txt The quick green elephant jumps over the lazy cat. The quick green elephant jumps over the lazy cat. The quick green elephant jumps over the lazy cat. The quick green elephant jumps over the lazy cat. ``` ### gawk程序 通常你需要一个用来处理文件中的数据的更高级工具，它能提供一个类编程环境来修改和重新组织文件中的数据。这正是gawk能够做到的 它提供了一种编程语言而不只是编辑器命令。 + 定义变量来保存数据； + 使用算术和字符串操作符来处理数据； + 使用结构化编程概念（比如if then语句和循环）来为数据处理增加处理逻辑； + 通过提取数据文件中的数据元素，将其重新排列或格式化，生成格式化报告 #### gawk命令格式 ```bash gawkoptions program file ``` 选项 描述 : : : : F fs 指定行中划分数据字段的字段分隔符 f file 从指定的文件中读取程序 v var value 定义gawk程序中的一个变量及其默认值 mf N 指定要处理的数据文件中的最大字段数 mr N 指定数据文件中的最大数据行数 W keyword 指定gawk的兼容模式或警告等级 #### 从命令读取程序脚本 gawk程序脚本用一对花括号来定义。你必须将脚本命令放到两个花括号（{}）中 ```bash jiao@jiao virtual machine:~/桌面/linux shell/19$ gawk '{print \"hello world\"}' 123 hello world 321 hello world 456 hello world ``` > 没有在命令行上指定文件名，所以gawk程序会从STDIN接收数据。在运行这个程序时，它会一直等待从STDIN输入的文本 > > gawk程序会针对数据流中的每行文本执行程序脚本。由于程序脚本被设为显示一行固定的文本字符串，因此不管你在数据流中输入什么文本，都会得到同样的文本输出 bash shell提供了一个组合键来生成EOF（End of File）字符。Ctrl+D组合键会在bash中产生一个EOF字符。这个组合键能够终止该gawk程序并返回到命令行界面提示符下 #### 使用数据字段变量 gawk的主要特性之一是其处理文本文件中数据的能力。它会自动给一行中的每个数据元素分配一个变量 + $0代表整个文本行； + $1代表文本行中的第1个数据字段； + $2代表文本行中的第2个数据字段； + $n代表文本行中的第n个数据字段。 > gawk在读取一行文本时，会用预定义的字段分隔符划分每个数据字段。gawk中默认的字段分隔符是任意的空白字符（例如空格或制表符） ```bash jiao@jiao virtual machine:~/桌面/linux shell/19$ gawk '{print $1}' data2.txt One Two Three Fore Five jiao@jiao virtual machine:~/桌面/linux shell/19$ cat data2.txt One Line of test text Two Line of test text Three Line of test text Fore Line of test text Five Line of test text ``` > 如果你要读取采用了其他字段分隔符的文件，可以用 F选项指定 ```bash jiao@jiao virtual machine:~/桌面/linux shell/19$ gawk F: '{print $1}' /etc/passwd root daemon bin sys sync games man ... ``` #### 使用多个命令 ```bash jiao@jiao virtual machine:~/桌面/linux shell/19$ echo \"My name is dhx\" gawk '{$4 \"2b\"; print $0}' My name is 2b ``` > 也可以用次提示符一次一行地输入程序脚本命令 > 没有在命令行中指定文件名，gawk程序会从STDIN中获得数据 #### 从文件中读取程序 ```bash jiao@jiao virtual machine:~/桌面/linux shell/19$ cat scrip2.sed {print $1 \"'s home direction is'\" $6} jiao@jiao virtual machine:~/桌面/linux shell/19$ gawk F: f scrip2.sed /etc/passwd root's home direction is'/root daemon's home direction is'/usr/sbin bin's home direction is'/bin sys's home direction is'/dev ... ``` > 可以在程序文件中指定多条命令。要这么做的话，只要一条命令放一行即可，不需要用分号, 在一个大括号中 ```bash jiao@jiao virtual machine:~/桌面/linux shell/19$ cat scrip2.sed { \ttext \"'s home direction is'\" \tprint $1 text $6 } ``` #### 在处理数据前运行脚本 默认情况下，gawk会从输入中读取一行文本，然后针对该行的数据执行程序脚本。有时可能需要在处理数据前运行脚本，比如为报告创建标题 BEGIN关键字就是用来做这个的。它会强制gawk在读取数据前执行BEGIN关键字后指定的程序脚本 但在它显示了文本后，它会快速退出，不等待任何数据。如果想使用正常的程序脚本中处理数据，必须用另一个脚本区域来定义程序 ```bash jiao@jiao virtual machine:~/桌面/linux shell/19$ gawk 'BEGIN {print \"The data1 File Contents\"} > {print $0}' data1.txt The data1 File Contents The quick brown fox jumps over the lazy dog. The quick brown fox jumps over the lazy dog. The quick brown fox jumps over the lazy dog. ``` #### 在处理数据后运行脚本 END关键字允许你指定一个程序脚本，gawk会在读完数据后执行它 ```bash jiao@jiao virtual machine:~/桌面/linux shell/19$ gawk 'BEGIN {print \"The data1 File Contents\"} {print $0} END { printf \"End of file\"}' data1.txt The data1 File Contents The quick brown fox jumps over the lazy dog. The quick brown fox jumps over the lazy dog. The quick brown fox jumps over the lazy dog. The quick brown fox jumps over the lazy dog. End of file ``` ```bash 1 BEGIN { 2 print \"The latest list of user and shell\" 3 print \"UserID \\t shell\" 4 print \" \\t \" 5 FS \":\" 6 } 7 { 8 print $1 \" \\t \" $7 9 } 10 11 END { 12 print \"This conclude the listing\" 13 } jiao@jiao virtual machine:~/桌面/linux shell/19$ gawk f scrip4.gawk /etc/passwd The latest list of user and shell UserID \t shell \t root \t /bin/bash daemon \t /usr/sbin/nologin bin \t /usr/sbin/nologin ``` ## sed编辑器基础 ### 更多替换选项 #### 替换标记 替换命令在替换多行中的文本时能正常工作，但默认情况下它只替换每行中出现的第一处。要让替换命令能够替换一行中不同地方出现的文本必须使用**替换标记** 替换标记会在替换命令字符串之后设置 ```bash s/pattern/replacement/flags ``` 有4种可用的替换标记： + 数字，表明新文本将替换第几处模式匹配的地方； + g，表明新文本将会替换所有匹配的文本； + p，表明原先行的内容要打印出来； + w file，将替换的结果写到文件中。 ```bash jiao@jiao virtual machine:~/桌面/linux shell/19$ sed 's/test/trail/' data3.txt # 替换第一个 Line1 trail test Line2 trail test jiao@jiao virtual machine:~/桌面/linux shell/19$ sed 's/test/trail/2' data3.txt # 替换第二个 Line1 test trail Line2 test trail jiao@jiao virtual machine:~/桌面/linux shell/19$ sed 's/test/trail/g' data3.txt # 替换第三个 Line1 trail trail Line2 trail trail ``` + p替换标记会打印与替换命令中指定的模式匹配的行。这通常会和sed的 n选项一起使用。 n选项将禁止sed编辑器输出。但p替换标记会输出修改过的行。将二者配合使用的效果就是只输出被替换命令修改过的行 ```bash jiao@jiao virtual machine:~/桌面/linux shell/19$ cat data3.txt Line1 test test Line2 trial trial jiao@jiao virtual machine:~/桌面/linux shell/19$ sed n 's/test/trial/p' data3.txt Line1 trial test ``` + w替换标记会产生同样的输出，不过会将输出保存到指定文件中 ```bash jiao@jiao virtual machine:~/桌面/linux shell/19$ sed 's/test/trial/w test.txt' data3.txt Line1 trial test Line2 trial trial jiao@jiao virtual machine:~/桌面/linux shell/19$ cat test.txt Line1 trial test ``` > 而只有那些包含匹配模式的行才会保存在指定的输出文件中 #### 替换字符 时你会在文本字符串中遇到一些不太方便在替换模式中使用的字符。Linux中一个常见的例子就是正斜线（/） ```bash sed 's/\\/bin\\/bash/\\/bin\\/csh/' /etc/passwd ``` > 要解决这个问题，sed编辑器允许选择其他字符来作为替换命令中的字符串分隔符 ```bash sed 's!/bin/bash!/bin/csh!' /etc/passwd ``` ### 使用地址 如果只想将命令作用于特定行或某些行，则必须用行寻址 有两种方法可以指定地址 ```bash [address]command ``` ```bash address { \tcommand1 command2 command3 } ``` #### 数字方式寻址 ```bash jiao@jiao virtual machine:~/桌面/linux shell/19$ sed '2s/dog/cat/' data1.txt The quick brown fox jumps over the lazy dog. The quick brown fox jumps over the lazy cat. The quick brown fox jumps over the lazy dog. The quick brown fox jumps over the lazy dog. ``` + sed编辑器只修改地址指定的第二行的文本。这里有另一个例子，这次使用了行地址区间 ```bash sed '2,3s/dog/cat/' data1.txt ``` + 如果想将命令作用到文本中从某行开始的所有行，可以用特殊地址——美元符 ```bash sed '2,$s/dog/cat/' data1.txt ``` #### 使用文本模式过滤器 sed编辑器允许指定文本模式来过滤出命令要作用的行 ```bash /pattern/command ``` 必须用正斜线将要指定的pattern封起来。sed编辑器会将该命令作用到包含指定文本模式 ```bash jiao@jiao virtual machine:~/桌面/linux shell/19$ sed '/jiao/s/bash/csh/' /etc/passwd gdm:x:126:132:Gnome Display Manager:/var/lib/gdm3:/bin/false jiao:x:1000:1000:jiao,,,:/home/jiao:/bin/csh systemd coredump:x:999:999:systemd Core Dumper:/:/usr/sbin/nologin sshd:x:127:65534::/run/sshd:/usr/sbin/nologin ``` > sed编辑器在文本模式中采用了一种称为正则表达式（regular expression）的特性来帮助你创建匹配效果更好的模式 #### 命令组合 在单行上处理多个命令 ```bash jiao@jiao virtual machine:~/桌面/linux shell/19$ sed '2{ > s/fox/elephant/ > s/dog/cat/ > }' data1.txt The quick brown fox jumps over the lazy dog. The quick brown elephant jumps over the lazy cat. The quick brown fox jumps over the lazy dog. The quick brown fox jumps over the lazy dog. ``` ### 删除行 删除命令d名副其实，它会删除匹配指定寻址模式的所有行。使用该命令时要特别小心，如果你忘记加入寻址模式的话，流中的所有文本行都会被删除 当和指定地址一起使用时，删除命令显然能发挥出最大的功用。可以从数据流中删除特定的文本行，通过行号指定 ```bash jiao@jiao virtual machine:~/桌面/linux shell/19$ sed '3d' data2.txt One Line of test text Two Line of test text Four Line of test text Five Line of test text ``` sed编辑器的模式匹配特性也适用于删除命令 ```bash $ sed '/number 1/d' data6.txt This is line number 2. This is line number 3. This is line number 4 ``` 也可以使用两个文本模式来删除某个区间内的行，但这么做时要小心。你指定的第一个模式会“打开”行删除功能，第二个模式会“关闭”行删除功能。sed编辑器会删除两个指定行之间的所有行（包括指定的行） ```bash sed '/1/,/3/d' data6.txt ``` > 删除一到三行 + 因为只要sed编辑器在数据流中匹配到了开始模式，删除功能就会打开。这可能会导致意外的结果 ```bash $ cat data7.txt This is line number 1. This is line number 2. This is line number 3. This is line number 4. This is line number 1 again. This is text you want to keep. This is the last line in the file. $ $ sed '/1/,/3/d' data7.txt This is line number 4 ``` ### 插入和附加文本 + 插入（insert）命令（i）会在指定行前增加一个新行； + 附加（append）命令（a）会在指定行后增加一个新行。 它们不能在单个命令行上使用。你必须指定是要将行插入还是附加到另一行。格式如下 ```bash sed '[address]command\\new line' ``` new line中的文本将会出现在sed编辑器输出中你指定的位置。记住，当使用插入命令时，文本会出现在数据流文本的前面 当使用附加命令时，文本会出现在数据流文本的后面 ```bash jiao@jiao virtual machine:~/桌面/linux shell/19$ echo \"Test Line 2\" sed 'a\\Test Line 1' Test Line 2 Test Line 1 jiao@jiao virtual machine:~/桌面/linux shell/19$ echo \"Test Line 2\" sed 'i\\Test Line 1' Test Line 1 Test Line 2 ``` 要向数据流行内部插入或附加数据，你必须用寻址来告诉sed编辑器你想让数据出现在什么位置 可以在用这些命令时只指定一个行地址。可以匹配一个数字行号或文本模式，但不能用地址区间。 ```bash $ sed '3i\\ > This is an inserted line.' data6.txt This is line number 1. This is line number 2. This is an inserted line. This is line number 3. This is line number 4. $ $sed '3a\\ > This is an appended line.' data6.txt This is line number 1. This is line number 2. This is line number 3. This is an appended line. This is line number 4. ``` 想要将新行附加到数据流的末尾，只要用代表数据最后一行的美元符就可以了 ```bash sed '$a\\ > This is a new line of text.' data6.txt ``` 同样的方法也适用于要在数据流起始位置增加一个新行。只要在第一行之前插入新行即可。 要插入或附加多行文本，就必须对要插入或附加的新文本中的每一行使用反斜线，直到最后一行。 ```bash $ sed '1i\\ > This is one line of new text.\\ > This is another line of new text.' data6.txt ``` ### 修改行 允许修改整行的文本内容 跟插入和附加命令的工作机制一样，你必须在sed命令中单独指定新行 ```bash $ sed '3c\\ > This is a changed line of text.' data6.txt This is line number 1. This is line number 2. This is a changed line of text. This is line number 4. ``` 文本模式修改命令会修改它匹配的数据流中的任意文本行 你可以在修改命令中使用地址区间，但结果未必如愿。sed编辑器会用这一行文本来替换数据流中的两行文本，而不是逐一修改这两行文本。 ```bash $ sed '2,3c\\ > This is a new line of text.'data6.txt This is line number 1. This is a new line of text. This is line number 4. ``` ### 转换命令 命令（y）是唯一可以处理单个字符的sed编辑器命令 ```bash [address]y/inchars/outchars/ ``` 转换命令会对inchars和outchars值进行一对一的映射。inchars中的第一个字符会被转换为outchars中的第一个字符, 第二个字符会被转换成outchars中的第二个字符。这个映射过程会一直持续到处理完指定字符。如果inchars和outchars的长度不同，则sed编辑器会产生一条错误消息 ```bash $ sed 'y/123/789/' data8.txt This is line number 7. This is line number 8. This is line number 9. This is line number 4. This is line number 7 again. This is yet another line. This is the last line in the file. ``` > 会转换所有匹配得上的字符, 所有的数据都会被进行转换 ### 回顾打印 有几个命令用来作用于打印的数据流中 + p用来打印文本行 + 等号用来打印行号 + l(小写L)用来列出行 #### 打印行 和替换命令中的p标记类似, 可以打印输出的一行, 通常用来打印匹配的行 ```bash $ cat data6.txt This is line number 1. This is line number 2. This is line number 3. This is line number 4. $ $ sed n '/number 3/p' data6.txt This is line number 3. ``` 也可以用它来快速打印数据流中的某些行 ```bash $ sed n '2,3p' data6.txt This is line number 2. This is line number 3. ``` 可以在对行进行修改之前打印一遍行 ```bash $ sed n '/3/{ > p > s/line/test/p > }'data6.txt This is line number 3. This is test number 3. ``` #### 打印行号 使用等号会在每一行打印出当前的行号 行号由当前的换行符决定 ```bash jiao@jiao virtual machine:~/桌面/linux shell/19$ sed ' ' data1.txt 1 The quick brown fox jumps over the lazy dog. 2 The quick brown fox jumps over the lazy dog. 3 The quick brown fox jumps over the lazy dog. 4 The quick brown fox jumps over the lazy dog. ``` 可以用在数据流中查找对应的行 ```bash jiao@jiao virtual machine:~/桌面/linux shell/19$ sed n '/Three/{ > > p > }' data2.txt 3 Three Line of test text ``` #### 列出行 打印出不可见的ASCII字符 ```bash jiao@jiao virtual machine:~/桌面/linux shell/19$ sed n 'l' data4.txt This is\\t\\ta\\ttest$ ``` ### 使用sed处理文件 替换命令包含一些可以用于文件的标记。还有一些sed编辑器命令也可以实现同样的目标，不需要非得替换文本 #### 写入文件 w命令用来向文件写入行。该命令的格式如下 ```bash [address]w filename ``` > 运行sed编辑器的用户都必须有文件的写权限。 > 地址可以是sed中支持的任意类型的寻址方式，例如单个行号、文本模式、行区间或文本模式 ```bash jiao@jiao virtual machine:~/桌面/linux shell/19$ sed '1,2w test.txt' data2.txt One Line of test text Two Line of test text Three Line of test text Fore Line of test text Five Line of test text jiao@jiao virtual machine:~/桌面/linux shell/19$ cat test.txt One Line of test text Two Line of test text ``` #### 从文件读取数据 读取（read）命令（r）允许你将一个独立文件中的数据插入到数据流中 ```bash [address]r filename ``` 你在读取命令中使用地址区间，只能指定单独一个行号或文本模式地址。sed编辑器会将文件中的文本插入到指定地址后 ```bash $ cat data12.txt This is an added line. This is the second added line. $ $ sed '3r data12.txt' data6.txt This is line number 1. This is line number 2. This is line number 3. This is an added line. This is the second added line. This is line number 4. ``` + 可以和删除符号一起使用用来处理占位符 ```bash $ cat notice.std Would the following people: LIST # 占位符 please report to the ship's captain. $ sed '/LIST/{ > r data11.txt \t\t\t\t\t\t # 加入文本 > d \t\t\t\t\t\t\t\t # 删除原来的 > }' notice.std Would the following people: Blum, R Browncoat McGuiness, A Alliance Bresnahan, C Browncoat Harken, C Alliance please report to the ship's captain. ```"},"/note/Linux/Linux命令行与shell脚本编程大全/2022-8-1-走进shell.html":{"title":"走进shell《Linux命令行与Shell脚本编程大全》","content":" layout: post title: \"走进shell《Linux命令行与Shell脚本编程大全》\" date: 2022 8 1 11:29:08 +0800 tags: 《Linux命令行与Shell脚本编程大全》 Linux # 走进shell 最早的linux只能使用shell工作 ## 进入命令行 图形化桌面出现之前, 唯一交互方式是shell提供的文本命令界面(CLI) ### 控制台终端 退出图形化桌面, 进入文本模式, 只有一个简单的shell CLI, 和图形界面出现之前一样, 称为Linux控制台 Linux启动之后会自动创建一些虚拟的终端, 大多数会启动多个 ### 图形化终端 图形化桌面中的**终端仿真包**, 在桌面模拟终端的使用 图形化终端只负责Linux图形化体验的一部分, 完整的体验要借助多个组件来实现 可以把图形化终端仿真器看作GUI中（in the GUI）的CLI终端，将虚拟控制台终端看作GUI以外（outside the GUI）的CLI终端 **图形界面组成** 名 称 描 述 : : : : 客户端 请求图形化服务的应用 显示服务器 负责管理显示（屏幕）和输入设备（键盘、鼠标、触摸屏） 窗口管理器 为窗口加入边框，提供窗口移动和管理功能 部件库 为桌面环境中的客户端添加菜单以及外观项 ## 通过Linux控制台访问CLI 按下Ctrl+Alt组合键，然后按功能键（F1~F7）进入要使用的虚拟控制台。 分别进入不同的虚拟控制台 Linux通常使用F1或者F7为图形界面 > tty2: 虚拟控制台2, tty含义为电传打字机 > login: 用户ID > > passwd: 密码 虚拟控制台之中不能运行图形应用 > `setterm inversescreen on `启用终端背景设置, off关闭 > > `setterm –background white`背景为白色 > > `setterm –foreground black`字体黑色 > > 可以使用的: black、red、green、yellow、blue、magenta、cyan和white 选项 参数 描述 : : : : : : background black、red、green、yellow、blue、magenta、cyan或white 将终端的背景色改为指定颜色 foreground black、red、green、yellow、blue、magenta、cyan或white 将终端的前景色改为指定颜色 inversescreen on或off 交换背景色和前景色 reset \\ 将终端外观恢复成默认设置并清屏 store \\ 将终端当前的前景色和背景色设置成 reset选项的值 ### 图形化中断仿真访问CLI 有大量的图形化终端仿真器, 每一个都有自己的特性 常用的GNOME Terminal、Konsole Terminal、xterm ## 使用GNOME Terminal Ubuntu默认的仿真器 ### 访问GNOME Ternmial + 在Application >System Tools >Terminal + Ctrl+ Alt+T + 创建一个启动器(桌面上的图标) ### 菜单栏 包含配置选项和定制选项 名称 快捷键 描述 : : : : : : Open Terminal Shift+Ctrl+N 在新的GNOME Terminal窗口中启动一个新的shell会话 Open Tab Shift+Ctrl+T 在现有的GNOME Terminal窗口的新标签中启动一个新的shell会话 New Profile 无 定制会话并将其保存为配置文件（profile），以备随后再次使用 Save Contents 无 将回滚缓冲区（scrollback buffer）中的内容保存到文本文件中 Close Tab Shift+Ctrl+W 关闭当前标签中的会话 Close Window Shift+Ctrl+Q 关闭当前的GNOME Terminal会话 Zoom In Ctrl++ 逐步增大窗口显示字号 Zoom Out Ctrl+ 逐步减小窗口显示字号 Normal Size Ctrl+0 恢复默认字号 Find Shift+Ctrl+H 查找 Find Next Shift+Ctrl+F 上一个 Find Previous Shift+Ctrl+N 下一个 Shift+Ctrl+J 清除高亮 Ctrl+PageDown 下一个标签页 Ctrl+PageUp 上一个 Shift+Ctrl+PageUp 把标签页前移 Shift+Ctrl+PageDown 后移 ## Konsole Teria KDE桌面自带的默认仿真器, 除了终端的基本仿真, 还有高级的图形应用程序 ## xterm终端仿真器 最古老最基础的仿真软件, 不需要太多资源"},"/note/Linux/Linux命令行与shell脚本编程大全/2022-8-10-sed进阶.html":{"title":"sed进阶《Linux命令行与Shell脚本编程大全》","content":" layout: post title: \"sed进阶《Linux命令行与Shell脚本编程大全》\" date: 2022 8 10 23:39:08 +0800 tags: 《Linux命令行与Shell脚本编程大全》 Linux # `sed`进阶 未必会用到但是最好理解 ## 多行命令 `sed`处理的时候只对一行进行处理, 有些短语会被分割为多行 三个用来处理多行文本的特殊命令 + N: 将数据流中的下一行加进来创建一个多行组（multiline group）来处理。 + D：删除多行组中的一行。 + P：打印多行组中的一行。 ### next命令 #### 单行的next命令 小写的n会告诉`sed`编辑器移动到数据流中的下一文本行，而不用重新回到命令的最开始再执行一遍 `sed`编辑器在移动到数据流中的下一文本行之前，会在当前行上执行完所有定义好的命令。单行next命令改变了这个流程 > **个人理解:**对数据进行查找, 找到之后对下一行进行处理 ```bash $ cat data1.txt This is the header line. This is a data line. This is the last line. $ sed '/header/{n ; d}' data1.txt This is the header line. This is a data line. This is the last line. ``` #### 合并文本行 单行next命令会将数据流中的下一文本行移动到`sed`编辑器的工作空间（称为模式空间）。多行版本的next命令（用大写N）会将下一文本行添加到模式空间中已有的文本后。 > **注: **每两行为一组, 不进行重复的测试 ```bash jiao@jiao virtual machine:~/桌面/linux shell/20$ sed 'N; s/3\\n/ /' data1.txt Line 1 Line 2 Line Line 4 Line 5 jiao@jiao virtual machine:~/桌面/linux shell/20$ sed 'N; s/4\\n/ /' data1.txt Line 1 Line 2 Line 3 Line 4 Line 5 ``` 文本行仍然用换行符分隔，但`sed`编辑器现在会将两行文本当成一行来处理 ```bash sed '/first/{ N ; s/\\n/ / }' data2.txt This is the header line. This is the first data line. This is the second data line. This is the last line. ``` > 合并两行 如果要在数据文件中查找一个可能会分散在两行中的文本短语的话，这是个很实用的应用程序。这里有个例子 ```bash $ cat data3.txt On Tuesday, the Linux System Administrator's group meeting will be held. All System Administrators should attend. Thank you for your attendance. sed 'N ; s/System.Administrator/Desktop User/' data3.txt\t\t# 使用.代表空格或者换行符 On Tuesday, the Linux Desktop User's group meeting will be held. All Desktop Users should attend. Thank you for your attendance. ``` > 如果是换行符, 会把他替换为空格, 导致两行合并为一行 > > 可以使用多种替换方式 ```bash $ sed 'N > s/System\\nAdministrator/Desktop\\nUser/ > s/System Administrator/Desktop User/ > ' data3.txt ``` 这个脚本总是在执行`sed`编辑器命令前将下一行文本读入到模式空间。当它到了最后一行文本时，就没有下一行可读了，所以N命令会叫`sed`编辑器停止。如果要匹配的文本正好在数据流的最后一行上，命令就不会发现要匹配的数据 可以把处理单行的格式放在N前面 ```bash $ sed ' > s/System Administrator/Desktop User/ > N > s/System\\nAdministrator/Desktop\\nUser/ > ' data4.txt ``` ### 多行删除命令 单行删除命令（d）。`sed`编辑器用它来删除模式空间中的当前行。但和N命令一起使用时，使用单行删除命令就要小心了 会把两行全部删除, 如果只想删除第一行, 应该使用D命令, 只删除到换行符 可以用来结合删除特定位置的空白行 ### 多行打印命令 P命令, 只打印第一行的内容 ## 保持空间 **模式空间**是一块活跃的缓冲区, `sed`编辑器会检查他保存的文本 有另一块称作**保持空间**（hold space）的缓冲区域。在处理模式空间中的某些行时，可以用保持空间来临时保存一些行。 有5条命令可用来操作保持空间 命令 描述 : : : : h 将模式空间复制到保持空间 H 将模式空间附加到保持空间 g 将保持空间复制到模式空间 G 将保持空间附加到模式空间 x 交换模式空间和保持空间的内容 可以用来反向输出两行 ```bash $ sed n '/first/ {h ; n ; p ; g ; p }' data2.txt This is the second data line. This is the first data line. ``` ## 排除命令 可以使用命令来通过地址排除某些行 使用( ! )来排除某些行时候调用的命令 在处理N命令的时候不能识别最后一行, 可以使用排除命令 ```bash $ sed '$!N; > s/System\\nAdministrator/Desktop\\nUser/ > s/System Administrator/Desktop User/ > ' data4.txt ``` 可用来反转一段对话的输出顺序 把每一行的先放入保持空间, 然后在下一行的时候把他放到模式空间后面, 在最后一行的时候进行打印 ```bash jiao@jiao virtual machine:~/桌面/linux shell/20$ sed n '1!G; h ; $p' data1.txt Line 5 Line 4 Line 3 Line 2 Line 1 ``` > tac命令会倒序显示一个文本文件。你也许已经注意到了，这个命令的名字很巧妙，它执行的正好是与cat命令相反的功能。 ## 改变流 通常，`sed`编辑器会从脚本的顶部开始，一直执行到脚本的结尾（D命令是个例外，它会强制sed编辑器返回到脚本的顶部，而不读取新的行） ### 分支 `sed`编辑器提供了一种方法，可以基于地址、地址模式或地址区间排除一整块命令。 使用命令b ```bash [address]b [label] ``` address参数决定了哪些行的数据会触发分支命令。label参数定义了要跳转到的位置。如果没有加label参数，跳转命令会跳转到脚本的结尾 ```bash jiao@jiao virtual machine:~/桌面/linux shell/20$ sed '2,3b ; s/Line/line/; s/[15]/?/' data1.txt line ? Line 2 Line 3 line 4 line ? ``` > 不对2,3行进行处理 要是不想直接跳到脚本的结尾，可以为分支命令定义一个要跳转到的标签。标签以冒号开始，最多可以是7个字符长度 ```bash : label ``` ```bash jiao@jiao virtual machine:~/桌面/linux shell/20$ sed '2,3b jump; s/Line/line/;: jump; s/[135]/?/' data1.txt line ? Line 2 Line ? line 4 line ? ``` > 可以向前跳跳转形成循环 ```bash $ echo \"This, is, a, test, to, remove, commas.\" sed n '{ > :start > s/,//1p > /,/b start \t\t\t# 加一个条件防止形成死循环 > }' ``` ### 测试 t命令, 测试命令会根据替换命令的结果跳转到某个标签，而不是根据地址进行跳转 替换命令成功匹配并替换了一个模式，测试命令就会跳转到指定的标签。如果替换命令未能匹配指定的模式，测试命令就不会跳转 ```bash [address]t [label] ``` 跟分支命令一样，在没有指定标签的情况下，如果测试成功，`sed`会跳转到脚本的结尾 ```bash $ echo \"This, is, a, test, to, remove, commas. \" sed n '{ > :start > s/,//1p > t start \t\t# 只有在上面替换成功的时候进行循环, 去除所有的',' > }' ``` ## 模式替代 在使用通配符的时候很难知道什么文本会被匹配 ### &符号 `sed`编辑器提供了一个解决办法。&符号可以用来代表替换命令中的匹配的模式。不管模式匹配的是什么样的文本，你都可以在替代模式中使用&符号来使用这段文本。 ```bash jiao@jiao virtual machine:~/桌面/linux shell/20$ echo \"The cat set in its hat\" sed 's/.at/\"&\"/g' The \"cat\" set in its \"hat\" ``` ### 替代单独的单词 有时候你只想使用一部分 `sed`编辑器用圆括号来定义替换模式中的子模式。你可以在替代模式中使用特殊字符来引用每个子模式。替代字符由反斜线和数字组成。数字表明子模式的位置。`sed`编辑器会给第一个子模式分配字符\\1，给第二个子模式分配字符\\2，依此类推 ```bash jiao@jiao virtual machine:~/桌面/linux shell/20$ echo \"This is a test text\" sed 's/a \\(test\\)/\\1/' This is test text ``` > 用来处理替换的对象有一部分为原数据 + 用来在大串的数字中插入逗号 ```bash jiao@jiao virtual machine:~/桌面/linux shell/20$ echo \"123456789\" sed '{:start; s/\\(.*[0 9]\\)\\([0 9]\\{3\\}\\)/\\1,\\2/; t start}'\t\t# 匹配的字符串是最起码有四个数字, 把后面的三个数字分为一组 123,456,789 ``` ## 在脚本中使用`sed` ### 使用包装脚本 实现`sed`脚本的过程十分繁琐, 尤其是脚本很长的话, 可以把脚本放到包装脚本中 包装脚本充当着`sed`编辑器脚本和命令行之间的中间人角色 ```bash 1 #!/bin/bash 2 3 sed n '{ 1!G; h ; $p }' $1 jiao@jiao virtual machine:~/桌面/linux shell/20$ test2.sh data1.txt Line 5 Line 4 Line 3 Line 2 Line 1 ``` ### 重定向`sed`输出 正常情况下会出出到STDOUT上 ## 创建实用工具 ### 加倍行间距 加倍行间距 ```bash jiao@jiao virtual machine:~/桌面/linux shell/20$ sed 'G' data1.txt Line 1 Line 2 Line 3 Line 4 Line 5 jiao@jiao virtual machine:~/桌面/linux shell/20$ ``` > 可以使用`!$G`不添加最后一行 ### 对可能已经存在空行的文件加倍行距 ```bash jiao@jiao virtual machine:~/桌面/linux shell/20$ sed '/^$/d ;$!G' data1.txt Line 1 Line 2 Line 3 Line 4 Line 5 ``` ### 给文件的行标号 使用等号进行编号有些难看 ```bash jiao@jiao virtual machine:~/桌面/linux shell/20$ sed ' ' data1.txt sed 'N; s/\\n/ /' 1 Line 1 2 Line 2 3 Line 3 4 Line 4 5 Line 5 jiao@jiao virtual machine:~/桌面/linux shell/20$ nl data1.txt 1\tLine 1 2\tLine 2 3\tLine 3 4\tLine 4 5\tLine 5 jiao@jiao virtual machine:~/桌面/linux shell/20$ cat n data1.txt 1\tLine 1 2\tLine 2 3\tLine 3 4\tLine 4 5\tLine 5 ``` > 其他的方式有可能会增加额外的参数 ### 打印末尾行 ```bash jiao@jiao virtual machine:~/桌面/linux shell/20$ sed n '$p' data1.txt Line 5 ``` 显示后几行 ```bash jiao@jiao virtual machine:~/桌面/linux shell/20$ sed '{ :start $q; N; 3,$D # 退出循环; 再插新的入一行 ; 如果已经读取的大于第三行, 删除最上面(只留下两行) b start }' data1.txt Line 4 Line 5 ``` ### 删除行 #### 删除连续的空白行 ```bash jiao@jiao virtual machine:~/桌面/linux shell/20$ sed '/./,/^$/!d' data1.txt Line 1 Line 2 Line 3 Line 4 Line 5 ``` > 在匹配时候会匹配到有空行以及一个和它相连的行, 不会进行删除, 其他的都删除了, 没有空行的时候会一直进行匹配 #### 删除文件开头的行 ```bash /./,$!d ``` #### 删除结尾 ```bash sed '{ :start /^\\n*$/{$d; N ; b start} }' ``` > 会匹配只有一个换行的行, 检查是不是最后一行, 是的话删除最后一行, 不是的话会添加新的一行, 进行循环 ### 删除html标签 ```bash s/<.*>//g ``` > 会删除一行中离得最远的大于小于号之间的 ```bash s/<[^>]*>//g ``` > 删除两个中间没有大于号的尖括号之间的所有东西 > > 会导致出现空行 ```bash sed 's/<[^>]*>//g ; /^$/d' data11.txt ```"},"/note/Linux/Linux命令行与shell脚本编程大全/2022-8-6-使用结构初始化.html":{"title":"使用结构化命令《Linux命令行与Shell脚本编程大全》","content":" layout: post title: \"使用结构化命令《Linux命令行与Shell脚本编程大全》\" date: 2022 8 6 15:52:08 +0800 tags: 《Linux命令行与Shell脚本编程大全》 Linux # 使用结构化命令 许多的程序要求对shell命令进行一些逻辑化的控制, 这些命令称为结构化命令 ## 使用if then命令 ```bash if command then \tcommands fi ``` > 会运行if后面的哪那一个命令, 如果退出的状态码是0(运行成功), 就执行then > > fi标志语句的结束 ```bash if command; then \tcommands fi ``` 示例: 查找用户是否存在 ```bash 1 #!/bin/bash 2 testuser jiao 3 if grep $testuser /etc/passwd 4 then 5 echo \"This is my first command\" 6 echo \"second\" 7 echo \"Third\" 8 ls a /home/$testuser 9 fi ``` ### if then else语句 ```bash if command then \tcommends else \tcommands fi ``` ```bash 1 #!/bin/bash 2 testuser NoSuchUser 3 if grep $testuser /etc/passwd 4 then 5 echo \"The bash file for user $testuser are:\" 6 ls a /home/$testuser 7 echo 8 else 9 echo \"The user $testuser does not exit on this system\" 10 fi jiao@jiao virtual machine:~/桌面/linux shell/12$ test4.sh The user NoSuchUser does not exit on this system ``` ## 嵌套if ```bash 1 #!/bin/bash 2 testuser NoSuchUser 3 if grep $testuser /etc/passwd 4 then 5 echo \"The bash file for user $testuser are:\" 6 ls a /home/$testuser 7 echo 8 else 9 echo \"The user $testuser does not exit on this system\" 10 if ls d /home/NoSuchUser 11 then echo \"Hower $testuser has a directory\" 12 fi 13 fi ``` ```bash if command1 then \tcommands elif command2 then \tmore commands fi ``` ```bash 1 #!/bin/bash 2 testuser NoSuchUsers 3 if grep $testuser /etc/passwd 4 then 5 echo \"The bash file for user $testuser are:\" 6 ls a /home/$testuser 7 echo 8 elif ls d /home/$testuser 9 echo \"The user $testuser does not exit on this system\" 10 then echo \"Hower $testuser has a directory\" 11 else 12 echo \"The user $testuser dose not exit in this system\" 13 echo \"And don't have a dictory \" 14 fi ``` ## test命令 if then语句不能测试命令退出状态码之外的条件 test命令提供了在if then语句中测试不同条件的途径。如果test命令中列出的条件成立，test命令就会退出并返回退出状态码0。这样if then语句就与其他编程语言中的if then语句以类似的方式工作了 ```bash test condition ``` 使用在if then语句之中 ```bash if test condition then \tcommands fi ``` > 如果不写test的condition就会以0退出 ```bash 1 #!/bin/bash 2 if test 3 then echo \"No expression return a true\" 4 else echo \"return a False\" 5 fi 6 jiao@jiao virtual machine:~/桌面/linux shell/12$ test7.sh return a False ``` 可以用来检测变量之中是不是有变量 ```bash #!/bin/bash my_variable \"Full\" if test $my_variable then \techo \"The $my_variable expression returns a True\" else \techo \"The $my_variable expression returns a False\" fi ``` 还有另一种测试的方法 ```bash if [ condition ] then \tcondition fi ``` > **注意:**第一个方括号之后和第二个方括号之前必须加上一个空格，否则就会报错 test命令可以判断三类条件： + 数值比较字 + 符串比较 + 文件比较 ### 数值比较 比较 描述 : : : : n1 eq n2 检查n1是否与n2相等 n1 ge n2 检查n1是否大于或等于n2 n1 gt n2 检查n1是否大于n2 n1 le n2 检查n1是否小于或等于n2 n1 lt n2 检查n1是否小于n2 n1 ne n2 检查n1是否不等于n2 + 数值变量可以使用在数值或变量之上 ```bash 1 #!/bin/bash 2 value1 10 3 value2 11 4 if [ $value1 gt 5 ] 5 then echo \"the test value $value1 is greater than 5\" 6 fi 7 if [ $value1 eq $value2 ] 8 then 9 echo \"The value are equal\" 10 else 11 echo \"The value are different\" 12 fi ``` ```bash #!/bin/bash # Using floating point numbers in test evaluations value1 5.555 echo \"The test value is $value1\" if [ $value1 gt 5 ] then \techo \"The test value $value1 is greater than 5\" fi jiao@jiao virtual machine:~/桌面/linux shell/12$ test9.sh The test value is 5.555 ./test9.sh: 第 8 行： [: 5.555：需要整数表达式 ``` > bash shell只能处理整数, 但是在$显示的时候没有问题, 在基于数字的函数中就不行了 ### 字符串比较 比较 描述 : : : : str1 str2 检查str1是否和str2相同 str1 ! str2 检查str1是否和str2不同 str1 < str2 检查str1是否比str2小 str1 > str2 检查str1是否比str2大 n str1 检查str1的长度是否非0 z str1 检查str1的长度是否为0 #### 字符串相等 ```bash 1 #!/bin/bash 2 # 测试字符串是否相等 3 testuser jiao 4 if [ $testuser $USER ] 5 then 6 echo \"Welcome $testuser\" 7 fi ``` #### 字符串顺序 + 大于号和小于号必须转义，否则shell会把它们当作重定向符号，把字符串值当作文件名； + 大于和小于顺序和sort命令所采用的不同 ```bash jiao@jiao virtual machine:~/桌面/linux shell/12$ cat test11.sh #!/bin/bash val1 baseball val2 honkey if [ $val1 > $val2 ] then echo \"$val1 is greater than $val2\" else echo \"$val1 is less than $val2\" fi jiao@jiao virtual machine:~/桌面/linux shell/12$ test11.sh baseball is greater than honkey jiao@jiao virtual machine:~/桌面/linux shell/12$ ls honkey test10.sh test2.sh test4.sh test6.sh test8.sh test.py test1 test11.sh test3.sh test5.sh test7.sh test9.sh ``` > 把大于号解释为输出重定向 > 要解决这个问题应该使用转义字符 ```bash 1 #!/bin/bash 2 val1 baseball 3 val2 honkey 4 if [ $val1 \\> $val2 ] 5 then echo \"$val1 is greater than $val2\" 6 else echo \"$val1 is less than $val2\" 7 fi ``` > 排序的时候会认为是大写字母小于小写字母 > > 比较测试中使用的是标准的ASCII顺序，根据每个字符的ASCII数值来决定排序结果。sort命令使用的是系统的本地化语言设置中定义的排序顺序。对于英语，本地化设置指定了在排序顺序中小写字母出现在大写字母前 #### 字符串的大小 ```bash jiao@jiao virtual machine:~/桌面/linux shell/12$ cat test12.sh #!/bin/bash # 测试字符串的长度 val1 testing val2 '' if [ n $val1 ] then echo \"The string '$val1' is not empty\" else echo \"The string '$val1' is empty\" fi if [ z $val2 ] then echo \"The string '$val2' is empty\" else echo \"The string '$val2' is not empty\" fi if [ n $val3 ] then echo \"The string '$val3' is not empty\" else echo \"The string '$val3' is empty\" fi jiao@jiao virtual machine:~/桌面/linux shell/12$ test12.sh The string 'testing' is not empty The string '' is empty The string '' is not empty ``` > 没有定义的变量会被认为是空的, 但是没有定义的或空的字符串会对脚本产生巨大的影响, 所以最好进行检查 ### 文件比较 允许你测试文件目录的状态 比较 描述 : : : : d file 检查file是否存在并是一个目录 e file 检查file是否存在 f file 检查file是否存在并是一个文件 r file 检查file是否存在并可读 s file 检查file是否存在并非空 w file 检查file是否存在并可写 x file 检查file是否存在并可执行 O file 检查file是否存在并属当前用户所有 G file 检查file是否存在并且默认组与当前用户相同 file1 nt file2 检查file1是否比file2新 file1 ot file2 检查file1是否比file2旧 #### 检查目录 打算把文件写入某一个目录或者切换到某一个目录最好检查目录是否存在 ```bash 1 #!/bin/bash 2 jump_dictory /home/jiao 3 if [ d $jump_dictory ] 4 then 5 echo \"This $jump_dictory exists\" 6 cd $jump_dictory 7 ls 8 else 9 echo \"This $jump_dictory dictory does not exit\" 10 fi jiao@jiao virtual machine:~/桌面/linux shell/12$ test13.sh This /home/jiao exists 01_Python 公共的 模板 视频 图片 文档 下载 音乐 桌面 Makefile snap ``` #### 检查对象是否存在 ```bash if [ e $location ] then ... ``` #### 检查文件 ```bash if [ f $location ] then ... ``` #### 检查是否可读 ```bash 1 #!/bin/bash 2 pwfile /etc/shadow 3 if [ f $pwfile ] 4 then 5 if [ r $pwfile ] 6 then tail $pwfile 7 else echo \"Sorry I am un able to read the $pwfile\" 8 fi 9 else 10 echo \"Sory the file $pwfile does'n exit\" 11 fi jiao@jiao virtual machine:~/桌面/linux shell/12$ test14.sh # 没有权限 Sorry I am un able to read the /etc/shadow jiao@jiao virtual machine:~/桌面/linux shell/12$ sudo ./test14.sh # 有权限 colord:*:18912:0:99999:7::: geoclue:*:18912:0:99999:7::: pulse:*:18912:0:99999:7::: gnome initial setup:*:18912:0:99999:7::: hplip:*:18912:0:99999:7::: gdm:*:18912:0:99999:7::: jiao:$6$apS9G8HD6duUAyqr$2e81915XsZW02XwXRuyWzo9GVElzwo3kr7X9JUDUlPMDdDCuiJT7mqbV1y6rc1C1EFcF1HeS6dt5dvFUv0Y0/1:19062:0:99999:7::: systemd coredump:!*:19063:::::: sshd:*:19064:0:99999:7::: test:$6$57tVSKi5Obpm5cUj$cPcjBFM7iQtsLMOPMj8wsGvLpLGWEQDNDKnm.jDwOAE3RmiKbcIG7FqPF0924JUarmKU2yKy.L6BIwuG8Lrnt/:19207:0:99999:7::: ``` #### 检查空文件 ```bash 1 #!/bin/bash 2 file_name ./test_file 3 if [ f $file_name ] 4 then 5 if [ s $file_name ] 6 then 7 echo \"The file $file_name is existing and date in it\" 8 echo \"Will not remove it\" 9 else 10 echo \"The file $file_name is empty and will remove\" 11 rm $file_name 12 fi 13 else 14 echo \"the file dose not exit\" 15 fi jiao@jiao virtual machine:~/桌面/linux shell/12$ test15.sh # 没有创建的时候 the file dose not exit jiao@jiao virtual machine:~/桌面/linux shell/12$ touch test_file # 创建空文件 jiao@jiao virtual machine:~/桌面/linux shell/12$ test15.sh The file ./test_file is empty and will remove jiao@jiao virtual machine:~/桌面/linux shell/12$ ls honkey test10.sh test12.sh test14.sh test2.sh test4.sh test6.sh test8.sh test.py test1 test11.sh test13.sh test15.sh test3.sh test5.sh test7.sh test9.sh jiao@jiao virtual machine:~/桌面/linux shell/12$ touch test_file #创建非空文件 jiao@jiao virtual machine:~/桌面/linux shell/12$ vim test_file jiao@jiao virtual machine:~/桌面/linux shell/12$ test15.sh The file ./test_file is existing and date in it Will not remove it ``` #### 检查文件是否可写 ```bash if [ w $location ] then ... ``` #### 检查文件是否可执行 ```bash if [ x test16.sh ] then echo \"You can run the script: \" ./test16.sh ``` #### 检查文件的所属关系 ```bash if [ O /etc/passwd ] then \techo \"You are the owner of the /etc/passwd file\" else echo \"Sorry, you are not the owner of the /etc/passwd file\" fi ``` #### 比较文件所属的组 ```bash #!/bin/bash check file group test if [ G $HOME/testing ] then \techo \"You are in the same group as the file\" else \techo \"The file is not owned by your group\" fi ``` > 只会比较用户的默认组, 不会比较其他的组 #### 检查日期文件 在编写软件安装脚本的时候有用, 判断是不是新的版本 nt比较会判定一个文件是否比另一个文件新。如果文件较新，那意味着它的文件创建日期更近。 ot比较会判定一个文件是否比另一个文件旧。如果文件较旧，意味着它的创建日期更早 ```bash 1 #!/bin/bash 2 if [ test2.sh nt test5.sh ] 3 then echo \"test2 is newer than test5\" 4 else echo \"test2 is older than test5\" 5 fi 6 if [ test7.sh ot test5.sh ] 7 then echo \"test7 is older than test5\" 8 else echo \"test7 is nower than test5\" 9 fi jiao@jiao virtual machine:~/桌面/linux shell/12$ test16.sh test2 is older than test5 test7 is nower than test5 ``` ## 复合条件测试 有两种bool运算 + [ condition1 ] && [ condition2 ] + [ condition1 ] [ condition2 ] ## if then的高级特性 ### 使用双括号 除了test命令使用的标准数学运算符, 双括号允许使用更高级的运算 + ++ + + ! + ~ + ** + << + $>>$ + & + + && + 可以在if语句中用双括号命令，也可以在脚本中的普通命令里使用来赋值 ```bash 1 #!/bin/bash 2 if ((1+1 2)) 3 then echo \"True\" 4 else echo \"False\" 5 fi ``` ### 使用双括号 可以使用针对字符串的高级操作, 比如和正则表达式进行比较 ```bash 1 #!/bin/bash 2 if [[ $USER j* ]] 3 then echo \"Hello $USER\" 4 else echo \"GUN\" 5 fi jiao@jiao virtual machine:~/桌面/linux shell/12$ test18.sh Hello jiao ``` ## case命令 ```bash case variable in pattern1 pattern2) commands1;; pattern3) commands2;; *) default commands;; esac ``` 将变量和不同的模式进行比较, 可以通过 分割出多个模式, *会匹配所有的值 ```bash 1 #!/bin/bash 2 3 case $USER in 4 jiao dong) 5 echo \"Welcome $USER\" 6 echo \"Enjoy your visit\";; 7 testing) 8 echo \"Do your test\";; 9 *) 10 echo \"Gun\";; 11 esac jiao@jiao virtual machine:~/桌面/linux shell/12$ test19.sh Welcome jiao Enjoy your visit ```"},"/note/Linux/Linux命令行与shell脚本编程大全/2022-8-9-正则表达式.html":{"title":"图形化桌面环境中的脚本编程《Linux命令行与Shell脚本编程大全》","content":" layout: post title: \"图形化桌面环境中的脚本编程《Linux命令行与Shell脚本编程大全》\" date: 2022 8 9 23:39:08 +0800 tags: 《Linux命令行与Shell脚本编程大全》 Linux 通用 # 正则表达式 [正则表达式 (xusenfeng.github.io)](https://xusenfeng.github.io/2022/07/zhengzebiaodashi/) ## 什么是正则表达式 ### 定义 正则表达式是你所定义的**模式模板**，Linux工具可以用它来过滤文本。 正则表达式模式利用通配符来描述数据流中的一个或多个字符。Linux中有很多场景都可以使用通配符来描述不确定的数据。 ### 正则表达式的类型 正则表达式是通过**正则表达式引擎**实现的。正则表达式引擎是一套底层软件，负责解释正则表达式模式并使用这些模式进行文本匹配 常见的引擎: + POSIX基础正则表达式（basic regular expression，BRE）引擎 + POSIX扩展正则表达式（extended regular expression，ERE）引擎 大多数Linux工具都至少符合POSIX BRE引擎规范，能够识别该规范定义的所有模式符号。遗憾的是，有些工具（比如sed编辑器）只符合了BRE引擎规范的子集。这是出于速度方面的考虑导致的，因为sed编辑器希望能尽可能快地处理数据流中的文本 gawk程序用ERE引擎来处理它的正则表达式模式 ## 定义BRE模式 ### 纯文本 正则表达式 + 不关心模式在数据流中的位置 + 也不关心次数 + 匹配大小写 + 不用写出整个单词, 只要能够匹配就行 + 可以有空格数字等 ### 特殊字符 有些字符在正则表达式中有特别的含义。如果要在文本模式中使用这些字符，结果会超出你的意料 正则表达式识别的特殊字符包括 ``` *[]^${}\\+?() ``` > 不能在文本模式中单独使用这些字符 如果要用某个特殊字符作为文本字符，就必须转义。在转义特殊字符时，你需要在它前面加一个特殊字符来告诉正则表达式引擎应该将接下来的字符当作普通的文本字符。这个特殊字符就是反斜线（\\） ```bash jiao@jiao virtual machine:~/桌面/linux shell/19$ sed n '/\\$/p' data5.txt The cost is $4.00 jiao@jiao virtual machine:~/桌面/linux shell/19$ cat data5.txt The cost is $4.00 ``` ```bash echo \"3 / 2\" sed n '///p' sed: e expression #1, char 2: No previous regular expression ``` > 尽管/不是正则表达式的特殊字符，但如果它出现在sed编辑器或gawk程序的正则表达式中，你就会得到一个错误 > > 要使用正斜线，也需要进行转义 ### 锚字符 有两个特殊字符可以用来将模式锁定在数据流中的行首或行尾 #### 锁定在行首 脱字符（^）定义从数据流中文本行的行首开始的模式。如果模式出现在行首之外的位置，正则表达式模式则无法匹配。 脱字符会在每个由换行符决定的新数据行的行首检查模式 ```bash jiao@jiao virtual machine:~/桌面/linux shell/19$ echo \"Books are great\" sed n '/^Book/p' Books are great ``` 如果你将脱字符放到模式开头之外的其他位置，那么它就跟普通字符一样，不再是特殊字符了 > 如果指定正则表达式模式时只用了脱字符，就不需要用反斜线来转义。但如果你在模式中先指定了脱字符，随后还有其他一些文本，那么你必须在脱字符前用转义字符 ```bash jiao@jiao virtual machine:~/桌面/linux shell/19$ echo \"This is ^ a test\" sed n '/^/p' This is ^ a test jiao@jiao virtual machine:~/桌面/linux shell/19$ echo \"This is ^ a test\" sed n '/^ a/p' jiao@jiao virtual machine:~/桌面/linux shell/19$ echo \"This is ^ a test\" sed n '/\\^ a/p' This is ^ a test ``` #### 锁定在行尾 特殊字符美元符（$）定义了行尾锚点。 #### 组合锚点 + 把两种合起来使用, 查找整行 + 直接相连查找空白的行 ```bash $ cat data5 This is one test line. This is another test line. $ sed '/^$/d' data5 \t\t\t# 删除空白行 This is one test line. This is another test line. ``` ### 点号字符 特殊字符点号用来匹配除换行符之外的任意单个字符。它必须匹配一个字符，如果在点号字符的位置没有字符，那么模式就不成立 ### 字符组 但如果你想要限定待匹配的具体字符呢？在正则表达式中，这称为字符组 ``` [ch]at # 匹配cat和hat ``` 使用方括号来定义一个字符组。方括号中包含所有你希望出现在该字符组中的字符 在不太确定某个字符的大小写时，字符组会非常有用 也可以用来排除输入错误的单词 ### 排除型字符组 反转字符组的作用, 寻找组中没有的字符 ``` [^ch]at 除了cat和hat以外的 ``` ### 区间 使用单破折号 ``` [0 9][a z][a ch m] ``` 可用于数字、字母 ### 特殊的字符组 BRE还包含了一些特殊的字符组，可用来匹配特定类型的字符 组 描述 : : : : [[:alpha:]] 匹配任意字母字符，不管是大写还是小写 [[:alnum:]] 匹配任意字母数字字符0\\~9、A\\~Z或a\\~z [[:blank:]] 匹配空格或制表符 [[:digit:]] 匹配0~9之间的数字 [[:lower:]] 匹配小写字母字符a~z [[:print:]] 匹配任意可打印字符 [[:punct:]] 匹配标点符号 [[:space:]] 匹配任意空白字符：空格、制表符、NL、FF、VT和CR [[:upper:]] 匹配任意大写字母字符A~Z ### 星号 在字符后面放置星号表明该字符必须在匹配模式的文本中出现0次或多次 ``` $ echo \"ik\" sed n '/ie*k/p' ik $ echo \"ieeeek\" sed n '/ie*k/p' ieeeek ``` 将点号特殊字符和星号特殊字符组合起来。这个组合能够匹配任意数量的任意字符。它通常用在数据流中两个可能相邻或不相邻的文本字符串之间 星号还能用在字符组上。它允许指定可能在文本中出现多次的字符组或字符区间 ## 扩展正则表达式 POSIX ERE模式包括了一些可供Linux应用和工具使用的额外符号。gawk程序能够识别ERE模式，但sed编辑器不能 > ed编辑器和gawk程序的正则表达式引擎之间是有区别的。gawk程序可以使用大多数扩展正则表达式模式符号，并且能提供一些额外过滤功能，而这些功能都是sed编辑器所不具备的。但正因为如此，gawk程序在处理数据流时通常才比较慢 ### 问号 类似于星号, 但是只能重复0或1次 可以和字符组一块使用 ### 加号 前面的字符可以出现一次或者多次, 但是最少出现一次 使用于字符组 ### 花括号 你为可重复的正则表达式指定一个上限。这通常称为间隔 + m：正则表达式准确出现m次。 + m, n：正则表达式至少出现m次，至多n次 > 默认情况下，gawk程序不会识别正则表达式间隔。必须指定gawk程序的 re interval命令行选项才能识别正则表达式间隔 当为一的时候只能出现一次才能匹配得上 ```bash jiao@jiao virtual machine:~/桌面/linux shell/19$ echo \"bt\" gawk re interval '/be{1}t/{print $0}' jiao@jiao virtual machine:~/桌面/linux shell/19$ echo \"bet\" gawk re interval '/be{1}t/{print $0}' bet ``` 可以匹配字符组 ### 管道符号 OR方式指定正则表达式引擎要用的两个或多个模式。如果任何一个模式匹配了数据流文本，文本就通过测试。如果没有模式匹配，则数据流文本匹配失败 ```bash expr1expr2... ``` 正则表达式和管道符号之间不能有空格，否则它们也会被认为是正则表达式模式的一部分 ### 表达式分组 正则表达式模式也可以用圆括号进行分组。当你将正则表达式模式分组时，该组会被视为一个标准字符。可以像对普通字符一样给该组使用特殊字符。 ```bash $ echo \"Sat\" gawk '/Sat(urday)?/{print $0}' Sat $ echo \"Saturday\" gawk '/Sat(urday)?/{print $0}' Saturday ``` 将分组和管道符号一起使用来创建可能的模式匹配组是很常见的做 ## 正则表达式实战 ### 目录文件计数 ```bash 1 #!/bin/bash 2 3 mypath $( echo $PATH sed 's/:/ /g' ) 4 count 1 5 for directory in $mypath\t\t# 获取文件目录 6 do 7 check $(ls $directory)\t\t# 获取文件列表 8 for item in $check 9 do 10 count $[ $count+1 ] 11 done 12 echo \"$directory $count\" 13 count 0 14 done ``` ### 解析邮箱地址 `username@hostname`值可用字母数字字符以及以下特殊字符 + 点 + 单破折号 + 加号 + 下划线 服务器名和域名也必须遵照严格的命名规则，只允许字母数字字符以及以下特殊字符 + 点 + 下划线 ```bash ^([a zA Z0 9_\\+\\ \\.]+)@([a zA Z0 9_\\.\\ ]+)\\.([a zA Z]{2,5})$ ```"},"/note/Linux/Linux命令行与shell脚本编程大全/2022-8-7-呈现数据.html":{"title":"呈现数据《Linux命令行与Shell脚本编程大全》","content":" layout: post title: \"呈现数据《Linux命令行与Shell脚本编程大全》\" date: 2022 8 7 15:39:08 +0800 tags: 《Linux命令行与Shell脚本编程大全》 Linux # 呈现数据 ## 理解输入输出 + 在显示器上输出 + 输出重定向到文件之中 都是对于全部的操作 ### 标准文件描述 Linux把每一个对象当做文件处理, 包括输入输出进程, Linux使用文件描述符来表示每一个文件, 文件描述是一个非负数 可以唯一标识会话中打开的文件。每个进程一次最多可以有九个文件描述符 bash shell保留了前三个文件描述符（0、1和2） 文件描述符 缩写 描述 : : : : : : 0 STDIN 标准输入 1 STDOUT 标准输出 2 STDERR 标准错误 #### STDIN 标准输入, 为键盘shell从STDIN得到的数据对应键盘的输入, 在使用重定向符号<的时候, Linux会用文件替换标准输入 没有指定输入的话, cat接收键盘上的输入 可以使用重定向把数据输入到任何接收标准输入的地方 #### STDOUT 标准输出, 在终端上就是显示器, 所有的输出都会定义为标准输出 通过输出重定向符号，通常会显示到显示器的所有输出会被shell重定向到指定的重定向文件。你也可以将数据追加到某个文件。这可以用>>符号来完成 输出的错误信息不会输入到文件中 ```bash jiao@jiao virtual machine:~/桌面/linux shell/15$ myts.sh test1.sh > testout ./test1.sh: 行 2: asd：未找到命令 ./test1.sh: 行 3: das：未找到命令 jiao@jiao virtual machine:~/桌面/linux shell/15$ cat testout ``` #### STDERR 代表描述符的标准错误输出, 运行中的错误都会输出到这里, 通常情况下指向的是显示器, 不会随着重定向符号发生改变 ### 重定向错误 在重定向的时候使用STDERR的描述符 #### 只重定向错误 错误信号的文件描述符紧挨着重定向符号放置 ```bash jiao@jiao virtual machine:~/桌面/linux shell/15$ myts.sh test1.sh 2> testout jiao@jiao virtual machine:~/桌面/linux shell/15$ cat testout ./test1.sh: 行 2: asd：未找到命令 ./test1.sh: 行 3: das：未找到命令 ``` > 可以用来区分正确的输出以及错误的输出 #### 重定向错误和数据 如果想重定向错误和正常的信息, 要使用两个重定向符号 ```bash jiao@jiao virtual machine:~/桌面/linux shell/15$ ls test1.sh testout jiao@jiao virtual machine:~/桌面/linux shell/15$ ls ah test1.sh badtest 2>test2 1>test3 jiao@jiao virtual machine:~/桌面/linux shell/15$ cat test2 ls: 无法访问 'badtest': 没有那个文件或目录 jiao@jiao virtual machine:~/桌面/linux shell/15$ cat test3 test1.sh ``` + 如果要输出到一个文件, 可以使用&> ```bash jiao@jiao virtual machine:~/桌面/linux shell/15$ ls ah test1.sh badtest &>test2 jiao@jiao virtual machine:~/桌面/linux shell/15$ cat test2 ls: 无法访问 'badtest': 没有那个文件或目录 test1.sh ``` > 相较于标准输出, 这种方式会把错误信息的优先级设置为高于普通输出, 显示在最上边 ## 在脚本中重定向输出 在脚本中可以使用STDOUT和STDIN文件描述在多个位置生成输出, 只要简单地重定向相应的文件就可以了 + 临时重定向 + 永久重定向脚本所有命令 ### 临时重定向 有意在脚本中生成错误信息, 使用输出重定向符来将输出信息重定向到STDERR文件描述符, 必须在文件描述符数字之前加一个& ```bash echo\"This is an error message\" >&2 ``` ```bash 1 #!/bin/bash 2 3 echo \"This is an error\" >&2 4 echo \"This is an normal output\" jiao@jiao virtual machine:~/桌面/linux shell/15$ myts.sh test2.sh This is an error This is an normal output jiao@jiao virtual machine:~/桌面/linux shell/15$ test2.sh > test2 This is an error jiao@jiao virtual machine:~/桌面/linux shell/15$ test2.sh 2> test2 This is an normal output ``` ### 永久重定向 脚本中有大量的需要重定向的内容就会很麻烦, 但是你可以使用exec命令告诉shell在脚本执行期间重定向某个特定文件描述符 ```bash 1 #!/bin/bash 2 3 exec 2>testerror 4 5 echo \"This is the start of script\" 6 echo \"now redirecting all output to another location\" 7 8 exec 1>testout 9 10 echo \"This output should go to the testout file\" 11 echo \"but this should go to the testerror file\" >&2 12 jiao@jiao virtual machine:~/桌面/linux shell/15$ myts.sh test4.sh This is the start of script now redirecting all output to another location jiao@jiao virtual machine:~/桌面/linux shell/15$ cat testerror but this should go to the testerror file jiao@jiao virtual machine:~/桌面/linux shell/15$ cat testout This output should go to the testout file ``` > 一旦重定向了STDOUT或STDERR，就很难再将它们重定向回原来的位置。 ## 在脚本中重定向输入 exec命令允许你将STDIN重定向到Linux系统上的文件中 ```bash 1 #!/bin/bash 2 3 exec 0< testfile 4 count 1 5 while read line 6 do 7 echo \"Line #$count: $line\" 8 count $[ $count + 1 ] 9 done jiao@jiao virtual machine:~/桌面/linux shell/15$ test5.sh Line #1: 11111 Line #2: 2222222 Line #3: 33333333333 Line #4: 44444444444444444 ``` ## 创建自己的重定向 可以吧文件描述符中的其他几个分配给其他的文件 ### 创建输出文件描述符 ```bash 1 #!/bin/bash 2 3 exec 3>test6out 4 echo \"This shoulf display on the monitor\" 5 echo \"stored in the file \" >&3 6 echo \"back\" jiao@jiao virtual machine:~/桌面/linux shell/15$ myts.sh test6.sh This shoulf display on the monitor back jiao@jiao virtual machine:~/桌面/linux shell/15$ cat test6out stored in the file ``` > 也可以使用追加`exec 3>>testfile`, 在文件切换之后使用 ### 重定向文件描述符 你可以分配另外一个文件描述符给标准文件描述符，反之亦然。这意味着你可以将STDOUT的原来位置重定向到另一个文件描述符，然后再利用该文件描述符重定向回STDOUT。 ```bash 1 #!/bin/bash 2 3 exec 3>&1 4 exec 1>test7out 5 echo \"This shoule store in the output file\" 6 echo \"along with this line\" 7 8 exec 1>&3 9 echo \"Now thing should back\" jiao@jiao virtual machine:~/桌面/linux shell/15$ myts.sh test7.sh Now thing should back jiao@jiao virtual machine:~/桌面/linux shell/15$ cat test7out This shoule store in the output file along with this line ``` ### 创建文件输入描述符 ```bash $ cat test15 #!/bin/bash # redirecting input file descriptors exec 6<&0 exec 0< testfile count 1 while read line do \techo \"Line #$count: $line\" \tcount $[ $count + 1 ] done exec 0<&6 read p \"Are you done now? \" answer case $answer in Yy) echo \"Goodbye\";; Nn) echo \"Sorry, this is the end.\";; esac ``` ### 创建读写文件描述符 打开单个文件描述符来作为输入和输出 > shell会维护一个内部指针，指明在文件中的当前位置。任何读或写都会从文件指针上次的位置开始。 ```bash 1 #!/bin/bash 2 exec 3<> testfile 3 read line <&3 4 echo \"line: $line\" 5 echo \"This is a test line \" >&3 jiao@jiao virtual machine:~/桌面/linux shell/15$ myts.sh test8.sh line: 11111 jiao@jiao virtual machine:~/桌面/linux shell/15$ cat testfile 11111 This is a test line 4444444444444444 ``` ### 关闭文件描述符 shell会在脚本退出时自动关闭它们。然而在有些情况下，你需要在脚本结束前手动关闭文件描述符 要关闭文件描述符，将它重定向到特殊符号& 。脚本中看起来如下： ```bash exec 3>& ``` 一旦关闭了文件描述符，就不能在脚本中向它写入任何数据，否则shell会生成错误消息 如果随后你在脚本中打开了同一个输出文件，shell会用一个新文件来替换已有文件。这意味着如果你输出数据，它就会覆盖已有文件 ## 列出打开的文件描述符 ```bash lsof ``` > 许多Linux系统隐藏了该命令，这样用户就不会一不小心就发现了 有大量的命令行选项和参数可以用来帮助过滤lsof的输出。最常用的有 p和 d，前者允许指定进程ID（PID），后者允许指定要显示的文件描述符编号 要想知道进程的当前PID，可以用特殊环境变量$$（shell会将它设为当前PID）。 a选项用来对其他两个选项的结果执行布尔AND运算，这会产生如下输出 ```bash jiao@jiao virtual machine:~/桌面/linux shell/15$ lsof a p $$ d 0,1,2 COMMAND PID USER FD TYPE DEVICE SIZE/OFF NODE NAME bash 5039 jiao 0u CHR 136,0 0t0 3 /dev/pts/0 bash 5039 jiao 1u CHR 136,0 0t0 3 /dev/pts/0 bash 5039 jiao 2u CHR 136,0 0t0 3 /dev/pts/0 ``` > 因为STDIN、STDOUT和STDERR文件描述符都指向终端，所以输出文件的名称就是终端的设备名 + COMMAND 正在运行的命令名的前9个字符 + PID 进程的PID + USER 进程属主的登录名 + FD 文件描述符号以及访问类型（r代表读，w代表写，u代表读写） + TYPE 文件的类型（CHR代表字符型，BLK代表块型，DIR代表目录，REG代表常规文件） + DEVICE 设备的设备号（主设备号和从设备号） + SIZE/OFF 如果有的话，表示文件的大小 + NODE 本地文件的节点号 + NAME 文件名 ## 阻止命令输出 如果在运行在后台的脚本出现错误消息，shell会通过电子邮件将它们发给进程的属主 可以将STDERR重定向到一个叫作null文件的特殊文件 在Linux系统上null文件的标准位置是/dev/null。你重定向到该位置的任何数据都会被丢掉，不会显示 也可以在输入重定向中将/dev/null作为输入文件。由于/dev/null文件不含有任何内容，程序员通常用它来快速清除现有文件中的数据，而不用先删除文件再重新创建 ```bash jiao@jiao virtual machine:~/桌面/linux shell/15$ cat testfile 11111 This is a test line 4444444444444444 jiao@jiao virtual machine:~/桌面/linux shell/15$ cat /dev/null > testfile jiao@jiao virtual machine:~/桌面/linux shell/15$ cat testfile ``` ## 创建临时文件 Linux使用/tmp文件夹存放不需要永久保存的文件, 大多数Linux发行版配置了系统在启动时自动删除/tmp目录的所有文件 任何用户账户都有权限在读写/tmp目录中的文件。这个特性为你提供了一种创建临时文件的简单方法，而且还不用操心清理工作 mktemp命令可以在/tmp目录中创建一个唯一的临时文件。shell会创建这个文件，但不用默认的umask值（参见第7章）。它会将文件的读和写权限分配给文件的属主，并将你设成文件的属主。一旦创建了文件，你就在脚本中有了完整的读写权限，但其他人没法访问它（当然，root用户除外） ### 创建本地临时文件 mktemp会在本地目录中创建一个文件。要用mktemp命令在本地目录中创建一个临时文件，你只要指定一个文件名模板就行了。模板可以包含任意文本文件名，在文件名末尾加上6个X就行了 ```bash jiao@jiao virtual machine:~/桌面/linux shell/15$ mktemp testing.XXXXXX testing.FaEYfs ``` 输出的就是创建的文件名, 可以保存在变量之中在后面使用 ### 在/tmp目录创建临时文件 t选项会强制mktemp命令来在系统的临时目录来创建该文件。在用这个特性时，mktemp命令会返回用来创建临时文件的全路径，而不是只有文件名 ```bash 1 #!/bin/bash 2 3 tempfile $(mktemp t tmp.XXXXXX) 4 echo \"This is a test file.\" > $tempfile 5 echo \"This is the second line.\" >> $tempfile 6 7 echo \"The temp file is located at: $tempfile\" 8 cat $tempfile 9 rm f $tempfile ``` ### 创建临时目录 d选项告诉mktemp命令来创建一个临时目录而不是临时文件。这样你就能用该目录进行任何需要的操作了，比如创建其他的临时文件 ```bash 1 #!/bin/bash 2 3 tempdir $(mktemp d dir.XXXXXX)\t\t# 在本地创建一个文件夹 4 cd $tempdir 5 tempfile1 $(mktemp temp.XXXXXX) 6 tempfile2 $(mktemp temp.XXXXXX) 7 exec 7> $tempfile1 8 exec 8> $tempfile2 9 10 echo \"Sending data to dictory $tempdir\" 11 echo \"This is a test line of data for $tempfile1\" >&7 12 echo \"This is a test line of data for $tempfile2\" >&8 ``` ## 记录消息 把输出的信息同时发送到显示器以及日志文件 ```bash tee filename ``` > 它将从STDIN过来的数据同时发往两处。一处是STDOUT，另一处是tee命令行所指定的文件名 > 写入的时候会覆盖原来的内容, 要是追加的话用 a ```bash jiao@jiao virtual machine:~/桌面/linux shell/15$ who tee testfile jiao tty2 2022 08 07 21:10 (tty2) jiao@jiao virtual machine:~/桌面/linux shell/15$ cat testfile jiao tty2 2022 08 07 21:10 (tty2) ``` ```bash 1 #!/bin/bash 2 3 tempfile test12out 4 5 echo $(date) tee $tempfile 6 echo $(ls alh) tee a $tempfile 7 echo $(who) tee a $tempfile ``` ## 示例 ```bash $cat test23 #!/bin/bash # read file and create INSERT statements for MySQL outfile 'members.sql' IFS ',' while read lname fname address city state zip do \tcat >> $outfile << EOF INSERT INTO members (lname,fname,address,city,state,zip) VALUES ('$lname', '$fname', '$address', '$city', '$state', '$zip'); EOF done < ${1}\t\t# 读取文件 ``` > cat >> $outfile << EOF 先把输入的内容使用cat打印, 然后输入到文件中"},"/note/Linux/Linux命令行与shell脚本编程大全/2022-8-6-处理用户输入.html":{"title":"处理用户输入《Linux命令行与Shell脚本编程大全》","content":" layout: post title: \"处理用户输入《Linux命令行与Shell脚本编程大全》\" date: 2022 8 6 15:39:08 +0800 tags: 《Linux命令行与Shell脚本编程大全》 Linux # 处理用户输入 bash shell提供了一系列的方法从用户处获取参数 ## 命令行参数 最基本的方法, 在使用命令行的时候传递参数 ### 读取参数 bash shell会将一些称为**位置参数**的特殊变量分配给命令行中的所有参数, 包括shell的脚本名 位置参数的变量名是标准的数字: \\$0 程序名, \\$1 第一个参数, $9: 最后一个参数 ```bash 1 #!/bin/bash 2 factorial 1 3 for ((number 1;number< $1;number++)) 4 do 5 factorial $[$factorial*$number] 6 done 7 echo The factorial of $1 is $factorial ``` > 在输入的是字符串的时候, 如果一个值之间有空格, 要用引号引起来 > 如果脚本的参数不止九个, 可以使用大括号把数字引起来 `${10}` ### 读取脚本名 读取脚本名的时候会把路径一同传递最为第一个参数 有一个命令会返回正确的程序 ```bash basename ``` ```bash 1 #!/bin/bash 2 3 name $(basename $0) 4 echo 5 echo The name is $name ``` + 处理多个文件名的文件 ```bash 1 #!/bin/bash 2 3 name $(basename $0) 4 if [ $name \"addem\" ] 5 then 6 total $[ $1 + $2 ] 7 elif [ $name \"multem\" ] 8 then 9 total $[ $1 * $2 ] 10 fi 11 echo 12 echo The calculated value is $total jiao@jiao virtual machine:~/桌面/linux shell/14$ ln s test4.sh addem jiao@jiao virtual machine:~/桌面/linux shell/14$ ln s test4.sh multem jiao@jiao virtual machine:~/桌面/linux shell/14$ addem 1 2 The calculated value is 3 jiao@jiao virtual machine:~/桌面/linux shell/14$ multem 3 4 The calculated value is 12 ``` ### 测试参数 在使用参数之前应该测试参数是不是为空 ```bash 1 #!/bin/bash 2 3 if [ n \"$1\" ]\t\t# 字符串非空 4 then 5 echo Hello $1, glod to meet you 6 else 7 echo \"Sorry, you did not identify yourself\" 8 fi ``` ## 特殊参数变量 bash shell 会有一些特殊的参数记录命令行的参数 ### 参数统计 可以统计一下输入了多少个参数, 用$# ```bash 1 #!/bin/bash 2 echo There were $# parameter supplied ``` > 参数的计数不算文件名 ```bash 1 #!/bin/bash 2 3 if [ $# ne 2 ] 4 then 5 echo 6 echo Usage: test9.sh a b 7 echo 8 else 9 total $[ $1+$2 ] 10 echo 11 echo The total is $total 12 echo 13 fi ``` + 获取最后一个参数, 在{}中不能使用$, 要把他换成! ```bash ${!#} ``` ```bash 1 #!/bin/bash 2 params $# 3 echo 4 echo The last parameter is $params # 打印参数的数量 5 echo The last parameter is ${!#}\t\t\t\t\t\t\t# 打印最后一个参数 6 echo ``` ### 抓取所有的数据 使用#@ 和 #* 可以轻松的访问所有的数据, 在单个变量中存储所有的命令行参数 + $*会把所有的参数当做一个存储, 视为一个整体 + $@会把所有的参数当做一个字符串的多个独立的单词, 这样你就可以遍历所有参数 ```bash 1 #!/bin/bash 2 echo 3 echo \"Using the \\$* method: $*\" 4 echo \"Using the \\$@ method: $@\" 5 echo jiao@jiao virtual machine:~/桌面/linux shell/14$ test9.sh 123 321 432 234 jjj Using the $* method: 123 321 432 234 jjj Using the $@ method: 123 321 432 234 jjj ``` ```bash 1 #!/bin/bash 2 3 echo 4 cout 1 5 for param in \"$*\" 6 do 7 echo \"\\$* parameter #$cout $param\" 8 cout $[ $cout+1 ] 9 done 10 echo 11 for param in \"$@\" 12 do 13 echo \"\\$@ Parameter #$count $param\" 14 count $[ $count + 1 ] 15 done jiao@jiao virtual machine:~/桌面/linux shell/14$ test10.sh 123 321 234 432 \"New Year\" $* parameter #1 123 321 234 432 New Year $@ Parameter # 123 $@ Parameter #1 321 $@ Parameter #2 234 $@ Parameter #3 432 $@ Parameter #4 New Year ``` ## 移动变量 shift命令能够用来操作命令行参数。 默认情况下它会将每个参数变量向左移动一个位置。所以，变量\\$3的值会移到\\$2中，变量\\$2的值会移到\\$1中，而变量$1的值则会被删除（注意，变量\\$0的值，也就是程序名，不会改变） 当不知道有多少个参数的时候, 可以移位然后只是用第一个参数 ```bash 1 #!/bin/bash 2 echo 3 count 1 4 while [ n \"$1\" ] 5 do 6 echo \"Parameter #$count $1\" 7 count $[ $count + 1 ] 8 shift 9 done jiao@jiao virtual machine:~/桌面/linux shell/14$ test11.sh 123 321 \"Hello world\" Parameter #1 123 Parameter #2 321 Parameter #3 Hello world ``` > 移出的参数被丢弃, 无法再次使用 > > 可以用数字指明移动的位置 ```bash 1 #!/bin/bash 2 3 echo 4 echo \"The original parameter: $*\" 5 shift 2 6 echo \"Here the new : $*\" jiao@jiao virtual machine:~/桌面/linux shell/14$ test12.sh 123 321 234 432 The original parameter: 123 321 234 432 Here the new : 234 432 ``` ## 处理选型 ### 查找选项 可以像处理命令行参数一样处理命令行选项 #### 处理简单选项 ```bash 1 #!/bin/bash 2 echo 3 while [ n \"$1\" ] 4 do 5 case \"$1\" in 6 a) echo \"Find the a option\";; 7 b) echo \"Find the b option\";; 8 c) echo \"Find the c option\";; 9 d) echo \"Find the d option\";; 10 *) echo \"$1 is not an option\";; 11 esac 12 shift 13 done jiao@jiao virtual machine:~/桌面/linux shell/14$ test13.sh 123 321 a b c 123 is not an option 321 is not an option Find the a option Find the b option Find the c option ``` #### 分离参数和选项 在shell脚本中同时使用选项和参数的情况。Linux中处理这个问题的标准方式是用特殊字符来将二者分开，该字符会告诉脚本何时选项结束以及普通参数何时开始 特殊字符是双破折线（ ）。在双破折线之后，脚本就可以放心地将剩下的命令行参数当作参数，而不是选项来处理了 > 在case中对参数进行判断, 如果参数是 就退出循环 #### 处理带值的选项 在case之中对参数进行处理, 并用shift进行移位 ### 使用`getopt`命令 在处理命令行选项和参数的时候非常的方便 #### 命令的格式 `getopt`命令可以接受一系列各种形式的命令行选项以及参数 ```bash getopt optstring parameters ``` `optstring`定义了命令行有效的选项字母, 还定义了哪些选项字母需要参数值 在`optstring`中列出你要在脚本中用到的每个命令行选项字母。然后，在每个需要参数值的选项字母后加一个冒号。`getopt`命令会基于你定义的`optstring`解析提供的参数 > 有一个高级的版本叫做`optstrings` ```bash jiao@jiao virtual machine:~/桌面/linux shell/14$ getopt ab:cd a b test1 cd test1 test2 a b test1 c d test1 test2 ``` > 输入了不存在的参数, 就会报错, 可以使用 q参数进行屏蔽 ```bash jiao@jiao virtual machine:~/桌面/linux shell/14$ getopt ab:cd a b test1 cd test1 test2 e getopt: 不适用的选项 e a b test1 c d test1 test2 jiao@jiao virtual machine:~/桌面/linux shell/14$ getopt q ab:cd a b test1 cd test1 test2 e a b 'test1' c d 'test1' 'test2' ``` > 命令选项必须出现在`optdtrings`之前 #### 在脚本中使用getopt 使用`getopt`处理后的参数替换原来的参数, 使用set命令 ```bash set $(getopt q ab:cd \"$@\") ``` ```bash 1 #!/bin/bash 2 3 set $(getopt q ab:cd \"$@\") 4 echo 5 while [ n \"$1\" ] 6 do 7 case \"$1\" in 8 a) echo \"Found the a option\";; 9 b) param $2 10 echo \"Found the b, with parameter value $param\" 11 shift;; 12 c) echo \"Found the c\";; 13 ) shift 14 break;; 15 *) echo \"$1 is not an option\" 16 esac 17 shift 18 done 19 count 1 20 for param in \"$@\" 21 do 22 echo \"Parameter #$count: $param\" 23 count $[ $count+1 ] 24 done jiao@jiao virtual machine:~/桌面/linux shell/14$ test14.sh 123 312 a b 43 c d Found the a option Found the b, with parameter value '43' Found the c d is not an option Parameter #1: '123' Parameter #2: '312' ``` > getopt命令并不擅长处理带空格和引号的参数值。它会将空格当作参数分隔符，而不是根据双引号将二者当作一个参数。 ### 使用getopts命令 每次调用它时，它一次只处理命令行上检测到的一个参数。处理完所有的参数后，它会退出并返回一个大于0的退出状态码。这让它非常适合用解析命令行所有参数的循环中 ```bash getopts optstring variable ``` > 有效的选项字母都会列在optstring中，如果选项字母要求有个参数值，就加一个冒号, 要去掉错误消息的话，可以在optstring之前加一个冒号 > > getopts命令将当前参数保存在命令行中定义的variable中 > > 如果选项需要跟一个参数值, OPTARG环境变量就会保存这个值。 > > OPTIND环境变量保存了参数列表中getopts正在处理的参数位置。这样你就能在处理完选项之后继续处理其他命令行参数了, 使用`shift $OPIND` ```bash 1 #!/bin/bash 2 echo 3 while getopts :ab:c opt 4 do 5 case \"$opt\" in 6 a) echo \"Found the a option\";; 7 b) echo \"Found the b option, with value $OPTARG\";; 8 c) echo \"Found the c option\";; 9 *) echo \"Unknow konw option: $opt\";; 10 esac 11 done jiao@jiao virtual machine:~/桌面/linux shell/14$ test15.sh b test c Found the b option, with value test Found the c option ``` > 会自动减去参数前的 + 可以处理参数中的空格 ```bash jiao@jiao virtual machine:~/桌面/linux shell/14$ test15.sh b \"Hello world\" Found the b option, with value Hello world ``` + 可以吧字母和参数放在一起 ```bash jiao@jiao virtual machine:~/桌面/linux shell/14$ test15.sh ab\"Hello world\" Found the a option Found the b option, with value Hello world ``` + 把没有定义的值统一转换为? ```bash jiao@jiao virtual machine:~/桌面/linux shell/14$ test15.sh d Unknow konw option: ? ``` + 处理之后的参数 ```bash 1 #!/bin/bash 2 echo 3 while getopts :ab:c opt 4 do 5 case \"$opt\" in 6 a) echo \"Found the a option\";; 7 b) echo \"Found the b option, with value $OPTARG\";; 8 c) echo \"Found the c option\";; 9 *) echo \"Unknow konw option: $opt\";; 10 esac 11 done 12 shift $[ $OPTIND 1 ] 13 echo 14 count 1 15 for param in \"$@\" 16 do 17 echo \"Parameter $count : $param\" 18 count $[ $count + 1 ] 19 done jiao@jiao virtual machine:~/桌面/linux shell/14$ test15.sh b test a c d 123 321 Found the b option, with value test Found the a option Found the c option Unknow konw option: ? Parameter 1 : 123 Parameter 2 : 321 ``` ## 将选项标准化 Linux定义了一些常用的选型的含义 选项 描述 : : : : a 显示所有对象 c 生成一个计数 d 指定一个目录 e 扩展一个对象 f 指定读入数据的文件 h 显示命令的帮助信息 i 忽略文本大小写 l(小写L) 产生输出的长格式版本 n 使用非交互模式（批处理） o 将所有输出重定向到的指定的输出文件 q 以安静模式运行 r 递归地处理目录和文件 s 以安静模式运行 v 生成详细输出 x 排除某个对象 y 对所有问题回答yes ## 获得用户的输入 交互性更强一些, 使用read命令 ### 基本的读取 收到输入之后, read会把数据放到一个变量 ```bash 1 #!/bin/bash 2 3 echo n \"Enter your name: \" 4 read name 5 echo \"Hello $name, welcome to my program\" jiao@jiao virtual machine:~/桌面/linux shell/14$ myts.sh test16.sh Enter your name: niubi Hello niubi, welcome to my program ``` > 可以使用 p直接在删除 > > 之中输入提示 > 输入的参数会依次放入之后的变量之中, 多出来的参数放入最后一个变量 > 要是不指定变量, 最后都会被放入环境变量REPLY中 ### 超时 > 可以使用 t来给脚本加入一个定时器, 确定了输入的秒数, 计时器过期之后返回一个非0的状态码 ```bash 1 #!/bin/bash 2 if read t 5 p \"Please enter your name: \" name 3 then 4 echo \"Hello $name, welcome\" 5 else 6 echo 7 echo \"Sorry , too slow\" 8 fi ``` > 也可以设置字符的上限, 超过之后自动退出并赋值 ```bash 1 #!/bin/bash 2 read n1 p \"Do you want to continue [Y/N]\" answer 3 case $answer in 4 Y y) echo 5 echo \"fine, continue on ...\";; 6 N n) echo 7 echo OK, Googbye 8 exit;; 9 esac 10 echo \"End\" ``` ### 隐藏方式读取 在输入密码的时候, s, 会把字体显示为背景的颜色 ```bash 1 #!/bin/bash 2 3 read s p \"Enter your passwd: \" pass 4 echo 5 echo \"Is you passwd reallu $pass?\" jiao@jiao virtual machine:~/桌面/linux shell/14$ myts.sh test21.sh Enter your passwd: Is you passwd reallu 123456? ``` ### 从文件中读取数据 每次会读取一行的内容, 没有内容的时候返回一个非零的返回值 最常用的是是使用管道把cat的参数传递 ```bash 1 #!/bin/bash 2 3 count 1 4 cat test while read line 5 do 6 echo \"Line $count: $line\" 7 count $[ $count+1 ] 8 done 9 echo \"Finish processing the file\" ```"},"/note/Linux/Linux命令行与shell脚本编程大全/2022-8-11-实例.html":{"title":"实例《Linux命令行与Shell脚本编程大全》","content":" layout: post title: \"实例《Linux命令行与Shell脚本编程大全》\" date: 2022 8 11 23:39:08 +0800 tags: 《Linux命令行与Shell脚本编程大全》 Linux # 实例 ## 创建归档脚本 ```bash 1 #!/bin/bash 2 DATE $(date +%y%m%d) 3 4 FILE archive$DATE.tar.gz 5 CONFIG_FILE /archive/File_To_Back 6 DESTINATION /archive/$FILE 7 8 if [ f $CONFIG_FILE ] # 检查需要存储的文件用的目录存在不存在 9 then 10 echo 11 else 12 echo 13 echo \"$CONFIG_FILE dose not exits\" 14 echo \"Backup not completed due to missing Configuration File\" 15 echo 16 exit 17 fi 18 19 FILE_NO 1 20 exec < $CONFIG_FILE 21 read FILE_NAME 22 while [ $? eq 0 ] 23 do 24 if [ f $FILE_NAME o d $FILE_NAME ] 25 then 26 FILE_LIST \"$FILE_LIST $FILE_NAME\"\t\t# 生成打包的文件的列表 27 28 else 29 echo 30 echo \"$FILE_NAME doesn't exit\" 31 echo \"Obviously, I will not include it in this archive.\" 32 echo \"It is listed on line $FILE_NO of the config file.\" 33 echo \"Continuing to build archive list...\" 34 echo 35 fi 36 FILE_NO $[ $FILE_NO + 1 ] 37 read FILE_NAME 38 done 39 40 echo \"Starting archive...\" 41 echo 42 tar czf $DESTINATION $FILE_LIST 2> /dev/null\t\t# 打包 43 echo \"$FILE_LIST\" 44 echo \"Archive complete\" 45 echo \"Resulting archive file is: $DESTINATION\"\t 46 echo 47 exit ```"},"/note/Linux/Linux命令行与shell脚本编程大全/2022-8-3-使用Linux环境变量.html":{"title":"使用Linx环境变量《Linux命令行与Shell脚本编程大全》","content":" layout: post title: \"使用Linx环境变量《Linux命令行与Shell脚本编程大全》\" date: 2022 8 3 14:26:08 +0800 tags: 《Linux命令行与Shell脚本编程大全》 Linux # 使用Linux环境变量 可以帮助提升Linuxshell的使用体验, 很多程序以及脚本都可以使用环境变量来获取系统信息, 存储临时的数据以及配置 ## 什么是环境变量 bash shell用一个环境变量的特性来储存有关shell会话和工作环境的信息, 允许你在内存中存储数据, 以便程序、脚本可以找到 有两种环境变量 + 全局变量 + 局部变量 > 不同版本的Linux可能会有不同的环境变量, 可以从发行版文档上查看 ### 全局环境变量 全局环境变量对于shell会话和所有的shell都是可见的, 局部变量则只是创建他的shell可见, 对于创建子shell需要父shell信息的时候有用 有很多的变量是在登陆的时候设置的, 登录的方式也会有影响 查看全局变量: ```bash $ printenv $ env ``` 要显示个别的环境变量可以使用`printenv`命令 ```C jiao@jiao virtual machine:~/桌面$ printenv HOME /home/jiao jiao@jiao virtual machine:~/桌面$ env HOME env: “HOME”: 没有那个文件或目录 ``` 也可以使用echo来显示某一个环境变量的值, 在变量名字之前加上$ ```bash jiao@jiao virtual machine:~/桌面$ echo $HOME /home/jiao ``` > 加上一个$可以让环境变量的值变成命令的参数 > > ```bash > jiao@jiao virtual machine:~/桌面$ ls $HOME > 01_Python 公共的 模板 视频 图片 文档 下载 音乐 桌面 Makefile snap > ``` ### 局部环境变量 局部变量只有在设置的进程可见, Linux定义了标准的环境变量, 但是你可以设置属于自己的局部变量, 叫做**用户定义局部变量** 没有专门显示局部变量的命令, set命令显示所有某一个特定进程的所有环境变量, 全局变量+局部变量+用户定义局部变量 > 说明命令env、printenv和set之间的差异很细微。set命令会显示出全局变量、局部变量以及用户定义变量。它还会按照字母顺序对结果进行排序。env和printenv命令同set命令的区别在于前两个命令不会对变量排序，也不会输出局部变量和用户定义变量。在这种情况下，env和printenv的输出是重复的。不过env命令有一个printenv没有的功能，这使得它要更有用一些 ## 设置用户定义变量 可以直接在bash之中设置自己的变量 ### 设置局部用户定义变量 一旦启动bash shell或一个bash脚本, 就能创建在这个进程shell内部可见的局部变量, 使用等号进行赋值, 可以是数字或字符串 ```bash jiao@jiao virtual machine:~/桌面$ echo $my_varible jiao@jiao virtual machine:~/桌面$ my_varible Hello jiao@jiao virtual machine:~/桌面$ echo $my_varible Hello ``` 只要使用$my_varible就可以使用 如果要给他一个有空格的字符串, 就要用双引号, 否则就会把第二个当做新的命令 ```bash jiao@jiao virtual machine:~/桌面$ my_varible hello ls 1.py algorithm begin.txt c_langage helloworld helloworld_1.0_i386.deb linux shell ll_env ``` > 所有的环境变量都使用大写, 但是在创建局部变量或者shell脚本的时候要使用小写 > **注:**变量名、等号和值之间没有空格 > 设置的局部变量在子shell之中不能使用 ### 设置全局的环境变量 设置的全局变量在所有的子程序之中都可以使用 设置的方法: 首先设置一个局部变量, 然后导出到全局变量, 使用export命令 ```bash jiao@jiao virtual machine:~/桌面$ my_variable \"I an jhy\" jiao@jiao virtual machine:~/桌面$ export my_variable jiao@jiao virtual machine:~/桌面$ dash $ echo my_variable my_variable $ echo $my_variable I an jhy $ exit ``` > 修改子shell中全局环境变量并不会影响到父shell中该变量的值 > > 子shell甚至无法使用export命令改变父shell中全局环境变量的值 > > ```bash > jiao@jiao virtual machine:~$ my_variable \"I am JHY\" > jiao@jiao virtual machine:~$ export my_variable\t\t//全局变量 > jiao@jiao virtual machine:~$ bash //进入子shell > jiao@jiao virtual machine:~$ ps forest > PID TTY TIME CMD > 2331 pts/0 00:00:00 bash > 2372 pts/0 00:00:00 \\_ bash > 2379 pts/0 00:00:00 \\_ ps > jiao@jiao virtual machine:~$ echo $my_variable\t\t//可以读取 > I am JHY > jiao@jiao virtual machine:~$ my_variable \"NULL\"\t\t//更改 > jiao@jiao virtual machine:~$ echo $my_variable > NULL > jiao@jiao virtual machine:~$ export my_variable\t\t//设置为全局 > jiao@jiao virtual machine:~$ exit > exit > jiao@jiao virtual machine:~$ echo $my_variable > I am JHY > ``` ## 删除环境变量 ```bash jiao@jiao virtual machine:~$ echo $my_variable I am JHY jiao@jiao virtual machine:~$ unset my_variable jiao@jiao virtual machine:~$ echo $my_variable ``` > 如果要用到变量，使用$；如果要操作变量，不使用$。这条规则的一个例外就是使用printenv显示某个变量的值 > > 在处理全局环境变量时，如果你是在子进程中删除了一个全局环境变量，这只对子进程有效。该全局环境变量在父进程中依然可用。 ## 默认的环境变量 有部分的环境变量和之前的Unix Bourne shell 兼容 ![QQ图片20220803162113](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242301974.png) 还有一些自有的变量 ![QQ图片20220803162136](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242301975.png) ![QQ图片20220803162205](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242301976.png) ![QQ图片20220803162217](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242301977.png) 不是每一个都会在set的时候列出, 也不是每一个都有对应的值 ## 设置PATH环境变量 在shell输入一个外部命令的时候, shell搜索系统来找到对应的程序, PATH定义的路径就是查找的路径 ```bash jiao@jiao virtual machine:~$ echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin ``` > 使用冒号分割, 如果命令或者程序没有保存在对应的路径, 就必须使用绝对路径来查找 ```bash jiao@jiao virtual machine:~$ PATH $PATH:/home/jiao/桌面 jiao@jiao virtual machine:~$ PATH $PATH:. ``` > 把桌面以及当前目录加入到搜索列表 ## 定位系统环境变量 已经知道了怎么实质环境变量, 下一步是进行永久保存 当你登陆一个Linux系统的时候, 默认情况下bash会在几个文件夹中查找命令, 这些文件夹叫**启动文件夹**或者**环境文件**, 检查的文件取决于登录的方式 + 登录时作为默认登录的shell + 作为非登录的交互式shell + 作为运行脚本的非交互shell ### 登录shell 登陆的时候启动的bash shell会从五个不同的文件夹读取数据 + /etc/profile + $HOME/.bash_profile + $HOME/.bashrc + $HOME/.bash_login + $HOME/.profile /etc/profile是默认的bash shell主启动文件, 每一个用户都会调用, ubuntu里面会在这个文件里面调用/etc/bash.bashrc文件, 之后依次执行/etc/profile.d/*.sh文件$HOME/.bashrc 家目录的$HOME/.profile文件里面会调用 > 要留意的是有些Linux发行版使用了可拆卸式认证模块（Pluggable Authentication Modules ，PA M）。在这种情况下，PA M文件会在bash shell启动之前处理，这些文件中可能会包含环境变量。PA M文件包括/etc/environment文件和$HOME/.pam_environment文件。PA M更多的相关信息可以在http://linux pam.org中找到 另外的四个文件是针对用户的, 可根据个人需求定制 #### /etc/profile文件 只要你登录就会执行其中的命令, 所有的用户, 启动终端也会运行 启动文件中会使用for语句来迭代/etc/profile.d目录下的所有文件, 这为Linux系统提供了一个放置特定应用程序启动文件的地方 ```bash jiao@jiao virtual machine:~/桌面$ ls /etc/profile.d/ hl 总用量 40K rw r r 1 root root 96 2月 26 2021 01 locale fix.sh rw r r 1 root root 835 10月 8 2021 apps bin path.sh rw r r 1 root root 726 9月 3 2020 bash_completion.sh rw r r 1 root root 1003 8月 13 2019 cedilla portuguese.sh rw 1 root root 241 10月 13 2021 debuginfod.csh rw 1 root root 132 10月 13 2021 debuginfod.sh rw r r 1 root root 349 12月 18 2020 im config_wayland.sh rw r r 1 root root 1.4K 6月 27 2021 vte 2.91.sh rw r r 1 root root 967 6月 27 2021 vte.csh rw r r 1 root root 954 9月 21 2021 xdg_dirs_desktop_session.sh ``` 有些文件与系统中的特定应用有关。大部分应用都会创建两个启动文件：一个供bash shell使用（使用.sh扩展名），一个供c shell使用（使用.csh扩展名） #### $HOME目录下的启动文件 剩下的启动文件都起着同一个作用, 提供一个用户的专属启动文件, 定义用户专用的环境变量 大多数的Linux只用四个启动文件的一到两个 + $HOME/.bash_profile + $HOME/.bashrc + $HOME/.bash_login + $HOME/.profile 启动的顺序, 找到一个剩下的忽略 + $HOME/.bash_profile + $HOME/.bash_login + $HOME/.profile 没有$HOME/.bashrc, 因为该文件通常通过其他文件来运行 ### 交互式shell 不是系统启动的时候启动的shell, 那么你启动的shell叫做交互式shell, 他不会像登录的shell一样运行, 但是提供了命令行提示符来输入命令 如果是交互式shell启动的文件, 就不会访问/etc/profile只会检查用户HOME目录中的.bashrc文件 ### 非交互式shell 系统执行shell脚本的时候, 没有命令提示符, 当你在系统上运行脚本时，也许希望能够运行一些特定启动的命令 为了处理这种情况，bash shell提供了BASH_ENV环境变量, 它会检查这个环境变量来查看要执行的启动文件, 这通常包括shell脚本变量设置 如果没有, 脚本的变量会来自, 父shell设置的变量 > 父shell设置但是没有导出的都是局部变量, 不能被继承 ### 环境变量持久化 放在/etc/profile中会在系统升级的时候更改 最好在/etc/profile.d目录中创建一个.sh结尾的文件 储存个人用户的shell变量是~/.bashrc文件, 但如果设置了BASH_ENV变量，那么记住，除非它指向的是$HOME/.bashrc，否则你应该将非交互式shell的用户变量放在别的地方 > 图形化界面组成部分（如GUI客户端）的环境变量可能需要在另外一些配置文件中设置，这和设置bash shell环境变量的地方不一样 ## 数组变量 环境变量可以当做数组使用, 数组可以存储多个变量, 这些值可以单独引用也可以整个使用 ```bash jiao@jiao virtual machine:/home$ mytest (one two three four five) jiao@jiao virtual machine:/home$ echo ${mytest[2]} three ``` 可以使用通配符*, 显示所有的值 ```bash jiao@jiao virtual machine:/home$ echo ${mytest[*]} one two three four five ``` 可以使用索引改变某一个位置的值 ```bash jiao@jiao virtual machine:/home$ mytest[2] seven jiao@jiao virtual machine:/home$ echo ${mytest[2]} seven ``` 可以使用unset删除某个位置的值 ```bash jiao@jiao virtual machine:/home$ unset mytest[2] jiao@jiao virtual machine:/home$ echo ${mytest[*]} one two four five jiao@jiao virtual machine:/home$ echo ${mytest[2]} jiao@jiao virtual machine:/home$ ```"},"/note/Linux/Linux命令行与shell脚本编程大全/2022-8-2-理解shell.html":{"title":"理解shell《Linux命令行与Shell脚本编程大全》","content":" layout: post title: \"理解shell《Linux命令行与Shell脚本编程大全》\" date: 2022 8 2 11:29:08 +0800 tags: 《Linux命令行与Shell脚本编程大全》 Linux # 理解shell shell不只是一种简单的CLI, 他是一个时刻在运行的复杂的交互式程序 ## shell的类型 启动什么样的shell取决于个人用户ID的设置, 在`/etc/passwd`文件中 ```bash 6jiao:x:1000:1000:jiao,,,:/home/jiao:/bin/bash rwxr xr x 1 root root 1392424 10月 7 2021 /bin/bash* ``` 是一个可执行文件, 一般还包含有其他的shell, 但是由于bash shell广为流传, 所以很少使用别的shell作为默认的shell 默认的shell会在用户登录的时候启动, 不过还有一个默认的shell是/bin/sh, 作为默认的系统shell, 用于那些需要启动时候使用的系统shell脚本 有的发行版会把默认的系统shell使用软连接设置为bash shell, 在有的发行版上默认的系统shell和交互shell并不相同 ````bash lrwxrwxrwx 1 root root 4 3月 11 21:38 /bin/sh > dash //Ubuntu使用dash ```` > 对于shell脚本来说, 由于shell的不同, 会导致问题 可以更改默认的交互shell, 直接输入文件名就可以了, 使用exit退出 ```bash jiao@jiao virtual machine:~/桌面/linux shell/3$ /bin/dash $ ls 3 abb\tacc baa num.txt.gz test.tar.gz tset $ cd .. $ ls 1 3 test.tar $ exit ``` ## shell的父子关系 用于登录某个虚拟控制器终端或在GUI中运行终端仿真器时所启动的默认的交互shell，是一个父shell。父shell提供CLI提示符，然后等待命令输入。 在CLI提示符后输入/bin/bash命令或其他等效的bash命令时，会创建一个新的shell程序。这个shell程序被称为子shell（child shell）。子shell也拥有CLI提示符，同样会等待命令输入 ```bash $ ps forest PID TTY TIME CMD 2753 pts/0 00:00:00 bash 6135 pts/0 00:00:00 \\_ dash 6139 pts/0 00:00:00 \\_ ps ``` bash shell程序可以使用命令行参数修改shell的启动方式 参数 描述 : : : : c string 从string中读取命令并进行处理 i 启动一个能够接收用户输入的交互shell l(小写L) 以登录shell的形式启动 r 启动一个受限shell，用户会被限制在默认目录中 s 从标准输入中读取命令 ### 进程列表 你可以在一行中指定要依次运行的一系列命令。这可以通过命令列表来实现，只需要在命令之间加入分号（;）即可 > 进程列表是一种命令分组（command grouping）。另一种命令分组是将命令放入花括号中，并在命令列表尾部加上分号（;）。语法为{ command; }。使用花括号进行命令分组并不会像进程列表那样创建出子shell。 ```bash pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls ``` > 这不是一个进程列表 ```bash (pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls ) ``` > 这是一个进程列表, 会产生一个子shell来运行 ```bash (pwd ; ls ; cd /etc ; pwd ; cd ; pwd ; ls ; echo $BASH_SUBSHELL) ``` > 最后一个命令可以显示运行的shell数量 可以使用多个括来创建子shell的子shell, 在脚本中经常使用子shell来进行多进程处理, 但是采用子shell的成本不菲，会明显拖慢处理速度。在交互式的CLI shell会话中，子shell同样存在问题。它并非真正的多进程处理，因为终端控制着子shell的I/O ### 别出心裁的shell用法 在交互式的shell CLI中还有很多用法, 进程列表, 协程, 管道等 #### 后台模式 在后台模式运行命令可以在处理命令的同时让出CLI, 想要进入后台模式, 可以在末尾加上& ```bash jiao@jiao virtual machine:~$ sleep 3000 & [1] 2778 ``` 显示为后台作业一号, 任务标号为2778 ```bash $ jobs [1]+ 运行中 sleep 3000 & ``` > 显示所有的后台任务 > > l(小写L): 显示详细的信息, 显示任务号 #### 把进程列表置入后台 进程列表是运行在子shell中的一条或多条命令 ```bash jiao@jiao virtual machine:~$ (sleep 2 ; echo $BASH_SUBSHELL ; sleep 2) 1 jiao@jiao virtual machine:~$ (sleep 2 ; echo $BASH_SUBSHELL ; sleep 2)& [2] 2818 jiao@jiao virtual machine:~$ 1 [2]+ 已完成 ( sleep 2; echo $BASH_SUBSHELL; sleep 2 ) jiao@jiao virtual machine:~$ ``` 把进程;列表放入后台就可以在子shell中处理繁重的任务, 也可以让子shell的I/O受到终端控制 #### 协程 同时做两件事, 后台生成一个子shell, 并在子shell中执行任务 ```bash $ coproc sleep 10 [1] 2544 [2] 2850 $ jobs [1] 运行中 sleep 3000 & [2]+ 运行中 coproc COPROC sleep 10 & ``` `coproc COPROC sleep`是`coproc`进程起的名字, 可以使用扩展语法来对其命名 ```bash jiao@jiao virtual machine:~$ coproc My_Job { sleep 10; } [2] 2874 jiao@jiao virtual machine:~$ jobs [1] 运行中 sleep 3000 & [2]+ 运行中 coproc Myjob { sleep 10; } & jiao@jiao virtual machine:~$ [2]+ 已完成 coproc Myjob { sleep 10; } ``` > 必须确保在第一个花括号（{）和命令名之间有一个空格。还必须保证命令以分号（;）结尾。另外，分号和闭花括号（}）之间也得有一个空格。 生成子shell的成本不低，而且速度还慢。创建嵌套子shell更是火上浇油 ## 理解shell的内建命令 ### type命令 用来查看命令是内部命令还是外部 > t: 监测种类 > > + 别名: alias > + 内部命令: builtin > + 外部命令: file > p: 是外部命令才会显示文件名 > a: 会在环境变量中把文件找出来, 包括别名 ### 外部命令 也称为文件系统命令, 存在于bash shell之外的程序, 不是bash shell的一部分, 外部命令通常位于/bin, /usr/bin, /sbin, /usr/sbin中 可以使用which和type命令查看 ```bash jiao@jiao virtual machine:~/桌面$ which ps /usr/bin/ps jiao@jiao virtual machine:~/桌面$ type a ps ps 是 /usr/bin/ps ps 是 /bin/ps ``` 当外部的命令执行的时候会创建一个新的子进程, 需要花费精力来配置新的子进程的环境 > 创建的进程之间可以使用信号来通讯 ### 内建命令 不需要子进程来进行, 已经和shell编译为一个整体, 作为shell的工具 ```bash jiao@jiao virtual machine:~/桌面$ type exit exit 是 shell 内建 jiao@jiao virtual machine:~/桌面$ type cd cd 是 shell 内建 ``` 内建命令的效率更高 有的命令会有多种实现 ```bash jiao@jiao virtual machine:~/桌面$ type a echo echo 是 shell 内建 echo 是 /usr/bin/echo echo 是 /bin/echo ``` #### history 显示使用过的命令列表 可以修改HISTSIZE环境变量来确定保存的记录数量 > 使用!!可以再次使用上一条命令 使用过的命令保存在`.bash_history`, 位于用户的主目录之中, 历史记录先存放在内存之中shell退出的时候才会写入 > 可以使用`history a`命令强制写入 > 如果打开了多个终端, 使用 a添加之后其他的终端不会更新, .bash_history只有在第一次被打开的时候才会被读取, 可以使用`history n`更新 > 使用!n, 可以再次使用记录中的第n个命令 #### 命名别名 alias是shell的内建命令, 允许你为常用的命令起别名 ```bash alias p ``` 查看已经存在的别名 ```bash alias li 'ls l' ``` > 由于是内部命令, 所以可以在脚本中使用, 但是只能在定义他的shell中, 命令是暂时有效的, 保存在~/.bashrc或者/etc/bashrc之后使用source ~/.bashrc就可以"},"/note/Linux/Linux命令行与shell脚本编程大全/2022-8-9-图形化桌面环境中的脚本编程.html":{"title":"图形化桌面环境中的脚本编程《Linux命令行与Shell脚本编程大全》","content":" layout: post title: \"图形化桌面环境中的脚本编程《Linux命令行与Shell脚本编程大全》\" date: 2022 8 9 23:39:08 +0800 tags: 《Linux命令行与Shell脚本编程大全》 Linux # 图形化桌面中的脚本编程 ## 创建文件菜单 ### 创建菜单布局 默认情况下，echo命令只显示可打印文本字符。在创建菜单项时，非可打印字符通常也很有用，比如制表符和换行符。要在echo命令中包含这些字符，必须用 e选项 最后一行的 en选项会去掉末尾的换行符。这让菜单看上去更专业一些，光标会一直在行尾等待用户的输入 ```bash 1 #!/bin/bash 2 clear 3 echo e \"\\t\\t\\tSys Admin Menu\\n\" 4 echo e \"\\t1. Display disk space\" 5 echo e \"\\t2. Display logged on users\" 6 echo e \"\\t3. Display memory usage\" 7 echo e \"\\t0. Exit menu\\n\\n\" 8 echo en \"\\t\\tEnter option: \" 9 read n 1 option ``` ### 创建菜单函数 ```bash 1 #!/bin/bash 2 function diskspace { 3 clear 4 df h 5 } 6 function whoseon { 7 clear 8 who 9 } 10 function menusage { 11 clear 12 cat /proc/meminfo 13 } 14 function diskspace { 15 clear 16 echo e \"\\t\\t\\tSys Admin Menu\\n\" 17 echo e \"\\t1. Display disk space\" 18 echo e \"\\t2. Display logged on users\" 19 echo e \"\\t3. Display memory usage\" 20 echo e \"\\t0. Exit menu\\n\\n\" 21 echo en \"\\t\\tEnter option: \" 22 read n 1 option 23 } 24 while [ 1 ] 25 do 26 diskspace 27 df h 28 case $option in 29 0) 30 break;; 31 1) 32 diskspace;; 33 2) 34 whoseon;; 35 3) 36 menusage;; 37 *) 38 clear 39 echo \"Sorry, wrong selection\" 40 esac 41 echo en \"\\n\\n\\t\\t\\tHit any key to continue\" 42 read n 1 line 43 done 44 clear ``` ### 使用select命令 ```bash select variable in list do \tcommand done ``` > select命令只需要一条命令就可以创建出菜单，然后获取输入的答案并自动处理 list参数是由空格分隔的文本选项列表，这些列表构成了整个菜单。select命令会将每个列表项显示成一个带编号的选项，然后为选项显示一个由**PS3**环境变量定义的特殊提示符 ```bash 15 PS3 \"Enter option\" # 设置选项选择的提示语 16 select option in \"Display disk space\" \"Display logged on users\" \"Display memory usage\" \"Exit program\" 17 do 18 case $option in 19 \"Exit program\") 20 break ;; 21 \"Display disk space\") 22 diskspace ;; 23 \"Display logged on users\") 24 whoseon ;; 25 \"Display memory usage\") 26 memusage ;; 27 *) 28 clear 29 echo \"Sorry, wrong selection\";; 30 esac 31 done 32 clear ``` > 在使用select命令时，记住，存储在变量中的结果值是整个文本字符串而不是跟菜单选项相关联的数字。文本字符串值才是你要在case语句中进行比较的内容 ## 制作窗口 ### dialog包 部件 描述 : : : : `calendar` 提供选择日期的日历 `checklist` 显示多个选项（其中每个选项都能打开或关闭） `form` 构建一个带有标签以及文本字段（可以填写内容）的表单 `fselect` 提供一个文件选择窗口来浏览选择文件 `gauge` 显示完成的百分比进度条 `infobox` 显示一条消息，但不用等待回应 `inputbox` 提供一个输入文本用的文本表单 `inputmenu` 提供一个可编辑的菜单 `menu` 显示可选择的一系列选项 `msgbox` 显示一条消息，并要求用户选择OK按钮 `pause` 显示一个进度条来显示暂定期间的状态 `passwordbox` 显示一个文本框，但会隐藏输入的文本 `passwordform` 显示一个带标签和隐藏文本字段的表单 `radiolist` 提供一组菜单选项，但只能选择其中一个 `tailbox` 用tail命令在滚动窗口中显示文件的内容 `tailboxbg` 跟`tailbox`一样，但是在后台模式中运行 `textbox` 在滚动窗口中显示文件的内容 `timebox` 提供一个选择小时、分钟和秒数的窗口 `yesno` 提供一条带有Yes和No按钮的简单消息 要在命令行上指定某个特定的部件，需使用双破折线格式。 ```bash dialog widget parameters ``` 其中widget是表中的部件名，parameters定义了部件窗口的大小以及部件需要的文本 dialog部件都提供了两种形式的输出： + 使用STDERR + 使用退出状态码 可以通过dialog命令的退出状态码来确定用户选择的按钮。如果选择了Ye s或OK按钮，dialog命令会返回退出状态码0。如果选择了Cancel或No按钮，dialog命令会返回退出状态码1。可以用标准的$?变量来确定dialog部件中具体选择了哪个按钮 如果部件返回了数据，比如菜单选择，那么dialog命令会将数据发送到STDERR。可以用标准的bash shell方法来将STDERR输出重定向到另一个文件或文件描述符中 ```bash dialog inputbox \"Enter your age: \" 10 20 2>age.txt ``` #### `msgbox`部件 会在窗口中显示一条简单的信息, 用户单击OK之后退出 ```bash dialog msgbox text height width ``` > dialog命令会根据由height和width参数创建的窗口的大小来自动换行。如果想在窗口顶部放一个标题，也可以用 title参数，后接作为标题的文本 ```bash jiao@jiao virtual machine:~/桌面/linux shell/18$ dialog title \"Plase answer\" yesno \"Is this thing on?\" 10 20 ``` > dialog命令的退出状态码会根据用户选择的按钮来设置。如果用户选择了No按钮，退出状态码是1；如果选择了Ye s按钮，退出状态码就是0。 #### `inputbox`部件 dialog命令会将文本字符串的值发给STDERR。你必须重定向STDERR来获取用户输入 ```bash jiao@jiao virtual machine:~/桌面/linux shell/18$ echo $? 0 jiao@jiao virtual machine:~/桌面/linux shell/18$ cat age.txt 45jiao@jiao virtual machine:~/桌面/linux shell/18$ ``` #### `testbox`部件 在窗口中显示大量的信息 出现一个有滚动条的窗口 ```bash dialog textbox /etc/passwd 15 45 ``` #### menu部件 创建我们之前所制作的文本菜单的窗口版本。只要为每个选项提供一个选择标号和文本就行了 ```bash jiao@jiao virtual machine:~/桌面/linux shell/18$ dialog menu \"Sys Admin Menu\" 20 30 10 1 \"Display disk space\" 2 \"Display users\" 3 \"Display memory usage\" 4 \"Exit\" 2> test.txt ``` > 第一个参数: 窗口名 > > 二三: 窗口大小 > > 四: 显示的菜单总数, 要是数量多的话可以使用方向键滚动 > > 之后的第一个是编号, 第二个是文本 #### `fslect`部件 在处理文件名的时候 不用强制用户键入文件名，你就可以用`fselect`部件来浏览文件的位置并选择文件 ```bash jiao@jiao virtual machine:~/桌面/linux shell/18$ dialog title \"Select a file\" fselect $HOME/ 10 50 2>file.txt ``` ### dialog选项 ![QQ图片20220809125022](https://blog 1308522872.cos.ap beijing.myqcloud.com/jhy/202212312350860.png) ![QQ图片20220809125216](https://blog 1308522872.cos.ap beijing.myqcloud.com/jhy/202212312350861.png) > dialog命令支持运行时配置。该命令会根据配置文件模板创建一份配置文件。dialog启动时会先去检查是否设置了DIALOGRC环境变量，该变量会保存配置文件名信息。如果未设置该变量或未找到该文件，它会将`$HOME/.dialogrc`作为配置文件。如果这个文件还不存在的话，就尝试查找编译时指定的GLOBALRC文件，也就是`/etc/dialogrc`如果这个文件也不存在的话，就用编译时的默认值 ### 在脚本中使用dialog命令 + 如果有Cancel或者No 检查退出状态码 + 重定向STDERR获取输出值 ```bash 1 #!/bin/bash 2 3 temp $(mktemp t test.XXXXXX) 4 5 temp2 $(mktemp t test2.XXXXXX) 6 7 function diskspace { 8 df k > $temp 9 dialog textbox $temp 20 60 10 } 11 function whoseon { 12 who > $temp 13 dialog textbox $temp 20 50 14 } 15 16 function memusage 17 { 18 cat /proc/meminfo > $temp 19 dialog textbox $temp 20 50 20 } 21 22 while [ 1 ] 23 do 24 dialog menu \"Sys Admin Menu\" 20 30 10 1 \"Display disk space\" 2 \"Display users\" 3 \"Display memory usage\" 0 \"Exit\" 2> $temp2 25 if [ $? eq 1 ] 26 then 27 break 28 fi 29 30 selection $(cat $temp2) 31 case $selection in 32 1) 33 diskspace ;; 34 2) 35 whoseon ;; 36 3) 37 memusage ;; 38 0) 39 break ;; 40 *) 41 dialog msgbox \"Sorry, invalid selection\" 10 30 42 esac 43 done 44 rm f $temp 2> /dev/null 45 rm f $temp2 2> /dev/null ``` ## 使用图形 ### KDE环境 KDE图形化环境默认包含kdialog包。kdialog包使用kdialog命令在KDE桌面上生成类似于dialog式部件的标准窗口 ### kdialog部件 ```bash kdialog display options window options arguments ``` > window options选项允许指定使用哪种类型的窗口部件。可用的选项如表18 3所示 选项 描述 : : : : checklist title [tag item status] 带有状态的多选列表菜单，可以表明选项是否被选定 error text 错误消息框 inputbox text [init] 输入文本框。可以用init值来指定默认值 menu title [tagitem] 带有标题的菜单选择框，以及用tag标识的选项列表 msgbox text 显示指定文本的简单消息框 password text 隐藏用户输入的密码输入文本框 radiolist title [tag item status] 带有状态的单选列表菜单，可以表明选项是否被选定 separate output 为多选列表和单选列表菜单返回按行分开的选项 sorry text “对不起”消息框 textbox file [width] [height] 显示file的内容的文本框，可以指定width和height title title 为对话窗口的TitleBar区域指定一个标题 warningyesno text 带有Yes和No按钮的警告消息框 warningcontinuecancel text 带有Continue和Cancel按钮的警告消息框 warningyesnocancel text 带有Yes、No和Cancel按钮的警告消息框 yesno text 带有Yes和No按钮的提问框 yesnocancel text 带有Yes、No和Cancel按钮的提问框 ```bash jiao@jiao virtual machine:~/桌面/linux shell/18$ kdialog checklist \"Items I need\" 1 \"Toothbrush\" on 2 \"Toothpaste\" off 3 \"Hair brush\" on 4 \"Deodorant\" off 5 \"Slippers\" off \"1\" \"3\" \"5\" ``` > 允许你在列表中定义单独的选项以及它们默认是否选定, 如果选择了OK按钮，kdialog就会将标号值发到STDOUT上 ```bsah 1 #!/bin/bash 2 3 temp $(mktemp t test.XXXXXX) 4 5 temp2 $(mktemp t test2.XXXXXX) 6 7 function diskspace { 8 df k > $temp 9 kdialog textbox $temp 1000 10 10 } 11 function whoseon { 12 who > $temp 13 kdialog textbox $temp 500 10 14 } 15 16 function memusage 17 { 18 cat /proc/meminfo > $temp 19 kdialog textbox $temp 300 500 20 } 21 22 while [ 1 ] 23 do 24 kdialog menu \"Sys Admin Menu\" 1 \"Display disk space\" 2 \"Display users\" 3 \"Displ ay memory usage\" 0 \"Exit\" > $temp2 25 if [ $? eq 1 ] 26 then 27 break 28 fi 29 30 selection $(cat $temp2) 31 case $selection in 32 1) 33 diskspace ;; 34 2) 35 whoseon ;; 36 3) 37 memusage ;; 38 0) 39 break ;; 40 *) 41 kdialog msgbox \"Sorry, invalid selection\" 10 30 42 esac 43 done 44 rm f $temp 2> /dev/null 45 rm f $temp2 2> /dev/null ``` ### GNOME环境 支持两种流行的可执行窗口包 + gdialog + zenity zenity是大多数GNOME桌面Linux发行版上最常见的包（在Ubuntu和Fedora上默认安装） #### zenity部件 选项 描述 : : : : calenda 显示一整月日历 entry 显示文本输入对话窗口 error 显示错误消息对话窗口 file selection 显示完整的路径名和文件名对话窗口 info 显示信息对话窗口 list 显示多选列表或单选列表对话窗口 notification 显示通知图标 progress 显示进度条对话窗口 question 显示yes/no对话窗口 scale 显示可调整大小的窗口 text info 显示含有文本的文本框 warning 显示警告对话窗口 zenity命令行程序与kdialog和dialog程序的工作方式有些不同。许多部件类型都用另外的命令行选项定义，而不是作为某个选项的参数 ```bash jiao@jiao virtual machine:~/桌面/linux shell/18$ zenity calendar 2022年08月25日 ``` > 显示日历 ```bash jiao@jiao virtual machine:~/桌面/linux shell/18$ zenity file selection /home/jiao/桌面/linux shell/18/age.txt ``` > 文件选择 #### 在脚本中使用 ```bash 1 #!/bin/bash 2 3 temp $(mktemp t test.XXXXXX) 4 5 temp2 $(mktemp t test2.XXXXXX) 6 7 function diskspace { 8 df k > $temp 9 zenity text info title \"Disk spacce\" filename $temp width 750 height 400 10 } 11 function whoseon { 12 who > $temp 13 zenity text info title \"Logged in users\" filename $temp width 500 height 400 14 } 15 16 function memusage 17 { 18 cat /proc/meminfo > $temp 19 zenity text info title \"Memory usage\" filename $temp width 300 height 50 0 20 } 21 22 while [ 1 ] 23 do 24 zenity list radiolist title \"Sys Admin Menu\" column \"Select\" column \"Menu It em\" FALSE \"Display diskspace\" FALSE \"Display users\" FALSE \"Display memory usage\" FALSE \"Exit\" > $temp2 width 600 height 400 # 设置有两列内容, 第一列为选项 25 if [ $? eq 1 ] 26 then 27 break 28 fi 29 30 selection $(cat $temp2) 31 case $selection in 32 \"Display diskspace\") 33 diskspace ;; 34 \"Display users\") 35 whoseon ;; 36 \"Display memory usage\") 37 memusage ;; 38 Exit) 39 break ;; 40 *) 41 zenity info \"Sorry, invalid selection\" 42 esac 43 done 44 rm f $temp 2> /dev/null 45 rm f $temp2 2> /dev/null ```"},"/note/Linux/Linux命令行与shell脚本编程大全/2022-8-5-构建基本脚本.html":{"title":"构建基本脚本《Linux命令行与Shell脚本编程大全》","content":" layout: post title: \"构建基本脚本《Linux命令行与Shell脚本编程大全》\" date: 2022 8 5 15:52:08 +0800 tags: 《Linux命令行与Shell脚本编程大全》 Linux # 构建基本脚本 ## 使用多个命令 shell脚本的关键在于输入多个命令并处理命令的结果 如果要一次使用多个命令可以放在一行中, 用冒号分割 ```bash jiao@jiao virtual machine:~/桌面/linux shell/10$ date; who 2022年 08月 05日 星期五 18:54:26 CST jiao tty2 2022 08 05 15:37 (tty2) ``` 只要不超过命令行最大字符数225就行 有一个很大的缺陷：每次运行之前，你都必须在命令提示符下输入整个命令。可以将这些命令组合成一个简单的文本文件，这样就不需要在命令行中手动输入了。在需要运行这些命令时，只用运行这个文本文件就行了 ## 创建shell脚本文件 在创建脚本文件的时候要在第一行指定要使用的shell ```bash 1 #!bin/bash 2 # 这个脚本展示了谁登陆了以及展示时间 3 date 4 who ``` > #为注释, 但是会解释#! 要让命令行找到shell脚本, 要采用两种方法之一 + 将shell脚本文件所处的目录添加到PATH环境变量中； + 在提示符中用绝对或相对文件路径来引用shell脚本文件 > 有些Linux发行版将$HOME/bin目录添加进了PATH环境变量。它在每个用户的HOME目录下提供了一个存放文件的地方，shell可以在那里查找要执行的命令 更改权限, 添加文件可执行权限 ```bash jiao@jiao virtual machine:~/桌面/linux shell/11$ chmod u+x shelljb1 jiao@jiao virtual machine:~/桌面/linux shell/11$ shelljb1 2022年 08月 05日 星期五 19:14:35 CST jiao tty2 2022 08 05 15:37 (tty2) ``` ## 显示信息 大多数的shell命令都会产生自己的输出, 这些输出会显示在运行的控制台显示器上, 如果想输出你在干什么, 可以使用 ```bash jiao@jiao virtual machine:~/桌面/linux shell/11$ echo this is a string this is a string ``` > 通常情况下不需要加引号, 但是当字符串中出现引号的时候就可Python处理一样, 文本中使用其中一种引号，而用另外一种来将字符串划定起来 ```bash 1 #!/bin/bash 2 # 这个脚本展示了谁登陆了以及展示时间 3 echo The tme and the date are 4 date 5 echo \"Let's see who log in the system\" 6 who jiao@jiao virtual machine:~/桌面/linux shell/11$ shelljb1 The tme and the date are 2022年 08月 05日 星期五 19:27:28 CST Let's see who log in the system jiao tty2 2022 08 05 15:37 (tty2) ``` 如果要输出没有换行的语句 ```bash echo n \"string\" ``` 使用双引号把对应的句子使用引号括起来 ## 使用变量 用shell命令使用其他数据来处理信息, 变量允许临时性的储存信息 ### 环境变量 在脚本中你可以使用环境变量,名再加上$来使用环境变量 ```bash 1 #!/bin/bash 2 # 打印操作系统使用者的信息 3 echo \"User info for userid: $USER\" 4 echo UID: $UID 5 echo HOME: $HOME jiao@jiao virtual machine:~/桌面/linux shell/11$ chmod u+x shelljb2 jiao@jiao virtual machine:~/桌面/linux shell/11$ shelljb2 User info for userid: jiao UID: 1000 HOME: /home/jiao ``` > 可以在字符串中使用$来输出变量 > 如果想输出一个美元符号, 需要输入`\\$` > 你可能还见过通过${variable}形式引用的变量。变量名两侧额外的花括号通常用来帮助识别美元符后的变量名 ### 用户变量 允许在shell脚本中定义自己的变量, 定义变量允许临时存放数据在整个脚本使用 用户变量可以是任何由字母、数字或下划线组成的文本字符串，长度不超过20个。用户变量区分大小写 使用等号将值赋给用户变量。在变量、等号和值之间不能出现空格 ```bash var1 10 var2 57 var3 testing var4 \"still more testing ``` > 全局变量, 使用$引用 ```bash 1 #!/bin/bash 2 # 测试变量 3 days 10 4 guest \"Katie\" 5 echo \"$guest check in $days days ago\" 6 days 5 7 guest \"Jessica\" 8 echo \"$guest check in $days days ago\" jiao@jiao virtual machine:~/桌面/linux shell/11$ shelljb3 Katie check in 10 days ago Jessica check in 5 days ago ``` > 变量每次被引用时，都会输出当前赋给它的值。重要的是要记住，引用一个变量值时需要使用美元符，而引用变量来对其进行赋值时则不要使用美元符 > > 这里使用的是`\"\"`会进行解引用, 使用`''`不会解引用 ### 替换命令 shell最有用的特性之一就是可以从命令中提取信息, 并把值赋值给变量, 然后可以在脚本之中使用 有两种方法 + 反引号字符（`） + $()格式 命令替换允许你将shell命令的输出赋给变量。尽管这看起来并不那么重要，但它却是脚本编程中的一个主要组成部分 + 用一对反引号把整个命令行命令围起来 ```bash testing `data` ``` + 要么使用$()格式 ```bash testing $(date) ``` shell会运行命令替换符号中的命令，并将其输出赋给变量testing > 也可以直接把上面的格式加入到字符串中, 直接输出 ```bash 1 #!/bin/bash 2 testing `date` 3 echo \"the date is $testing\" 4 5 testing2 $(date) 6 echo \"the date is $testing2\" jiao@jiao virtual machine:~/桌面/linux shell/11$ shelljb4 the date is 2022年 08月 05日 星期五 20:04:38 CST the date is 2022年 08月 05日 星期五 20:04:38 CST ``` 在脚本中通过命令替换获得当前日期并用它来生成唯一文件名 ```bash 1 #!/bin/bash 2 # copy the /usr/bin directory listing to a log file 3 today $(date +%y%m%d) 4 ls /usr/bin al > log.$today ``` > **注:(存疑)**命令替换会创建一个子**shell来运行对应的命令。子shell（subshell）是由运行该脚本的shell所创建出来的一个独立的子shell（child shell）。正因如此，由该子shell所执行命令是无法使用脚本中所创建的变量的 > > 在命令行提示符下使用路径./运行命令的话，也会创建出子shell；要是运行命令的时候不加入路径，就不会创建子shell。如果你使用的是内建的shell命令，并不会涉及子shell。在命令行提示符下运行脚本时一定要留心 > > ```bash > 1 #!/bin/bash > 2 # copy the /usr/bin directory listing to a log file > 3 today $(date +%y%m%d) > 4 ls /usr/bin al > log.$today > 5 ps forest > 6 echo \"$(ps forest)\" > 7 echo \"$(echo \"$today\")\" > > > > jiao@jiao virtual machine:~/桌面/linux shell/11$ shelljb5 > PID TTY TIME CMD > 2349 pts/0 00:00:00 bash > 4583 pts/0 00:00:00 \\_ shelljb5 > 4586 pts/0 00:00:00 \\_ ps > PID TTY TIME CMD > 2349 pts/0 00:00:00 bash > 4583 pts/0 00:00:00 \\_ shelljb5 > 4587 pts/0 00:00:00 \\_ ps > 220805 > ``` ## 重定向输入输出 命令输出不只显示在显示器上 bash shell提供了几个操作符，可以将命令的输出重定向到另一个位置（比如文件） 重定向可以用于输入，也可以用于输出，可以将文件重定向到命令输入。 ### 输出重定向 ```bash command > outputfile ``` 之前显示器上输出的命令会被保存到指定的文件 ```bash jiao@jiao virtual machine:~/桌面/linux shell/11.5$ date > test jiao@jiao virtual machine:~/桌面/linux shell/11.5$ ls l 总用量 4 rw rw r 1 jiao jiao 43 8月 5 20:58 test jiao@jiao virtual machine:~/桌面/linux shell/11.5$ cat test 2022年 08月 05日 星期五 20:58:45 CST ``` > 创建的文件通过umask设置 如果输出的文件已经存在, 会覆盖之前的内容 > 追加: 使用>> ### 输入重定向 将文件的内容输出到重定向的命令之中 wc命令可以对对数据中的文本进行计数。默认情况下，它会输出3个值： + 文本的行数 + 文本的词数 + 文本的字节数 ```bash jiao@jiao virtual machine:~/桌面/linux shell/11.5$ wc < test 3 16 135 ``` 还有另外一种输入重定向的方法，称为内联输入重定向 内联输入重定向符号是远小于号（<<）。除了这个符号，你必须指定一个文本标记来划分输入数据的开始和结尾。任何字符串都可作为文本标记，但在数据的开始和结尾文本标记必须一致 ```bash command << marker data marker ``` ```bash jiao@jiao virtual machine:~/桌面/linux shell/11.5$ wc << EOF > 123 > 321 > 213 > EOF 3 3 12 ``` > 次提示符会持续提示，以获取更多的输入数据，直到你输入了作为文本标记的那个字符串 ## 管道 把一个命令的输出当成另一个命令的输入 ```bash command1 command2 ``` 把第一个命令的输出传给第二个 > 通常使用把输出导入到more, 分页查看 ## 执行数学运算 ## expr命令 可以识别少量的数学和字符串操作符 ![QQ图片20220805213450](https://blog 1308522872.cos.ap beijing.myqcloud.com/jhy/202212312349205.png) ```bash #!/bin/bash # An example of using the expr command var1 10 var2 20 var3 $(expr $var2 / $var1) echo The result is $var3 ``` 对于那些容易被shell错误解释的字符，在它们传入expr命令之前，需要使用shell的转义字符（反斜线）将其标出来 ```bash expr 5 \\* 2 ``` ### 使用方括号 在传递变量的时候可以把他和$一同使用`$[ operation ]` ```bash 1 #!/bin/bash 2 var1 100 3 var2 50 4 var3 45 5 var4 $[$var1 * ($var2 $var3)] 6 echo The final result id $var4 ``` > 只支持整数的运算 > > z shell（zsh）提供了完整的浮点数算术操作。如果需要在shell脚本中进行浮点数运算，可以考虑看看z shell ### 浮点数解决方案 bash内建的计算器 #### bc基本用法 计算器实际上是一种编程语言 bash计算器能够识别： + 数字（整数和浮点数） + 变量（简单变量和数组） + 注释（以#或C语言中的/* */开始的行） + 表达式 + 编程语句（例如if then语句） + 函数 quit退出 ```bash jiao@jiao virtual machine:~/桌面/linux shell$ bc bc 1.07.1 Copyright 1991 1994, 1997, 1998, 2000, 2004, 2006, 2008, 2012 2017 Free Software Foundation, Inc. This is free software with ABSOLUTELY NO WARRANTY. For details type `warranty'. 3.14 * 5 +0.01 15.71 ``` > 浮点运算是由内建变量scale控制的。必须将这个值设置为你希望在计算结果中保留的小数位数，否则无法得到期望的结果 ```bash jiao@jiao virtual machine:~/桌面/linux shell$ bc q 3.14/5 0 scale 5 3.14/5 .62800 ``` > q: 不显示欢迎信息 ```bash jiao@jiao virtual machine:~/桌面/linux shell$ bc q var1 10 var2 20 var2/var1 2 var2 var1/4 vr2 0 print var2 2 ``` > 使用print输出变量 #### 在脚本中使用 可以用命令替换运行bc命令，并将输出赋给一个变量。基本格式如下： ```bash variable $(echo \"options; expression\" bc) ``` > 第一部分options允许你设置变量。如果你需要不止一个变量，可以用分号将其分开。expression参数定义了通过bc执行的数学表达式。 ```bash 1 #!/bin/bash 2 var1 $(echo \"scale 4; 3.44/5\" bc) 3 echo The answer is $var1 jiao@jiao virtual machine:~/桌面/linux shell/11.5$ test3 The answer is .6880 ``` > 括号中的echo是为了把整个句子输出为参数 ```bash 1 #!/bin/bash 2 var1 100 3 var2 45 4 var3 $(echo \"scale 4; $var1 / $var2\" bc) 5 echo The answer for this is $var3 jiao@jiao virtual machine:~/桌面/linux shell/11.5$ test4 The answer for this is 2.2222 ``` > 使用变量 上面的办法使用于比较短的运算 长运算时候bc可以识别重定向, 允许你把一个文件重定向到bc处理 ```bash variable $(bc<<EOF options statements expressions EOF ) ``` ```bash 1 #!/bin/bash 2 var1 10.46 3 var2 43.67 4 var3 33.2 5 var4 71 6 var5 $(bc<<EOF 7 scale 4 8 a1 ($var1 * $var2) 9 b1 ($var3 * $var4) 10 a1+b1 11 EOF 12 ) 13 echo The final answer for this mess is $var5 ``` ## 退出脚本 shell中的每一个命令都使用**退出状态码**（exit status）告诉shell它已经运行完毕。退出状态码是一个0～255的整数值，在命令结束运行时由命令传给shell。可以捕获这个值并在脚本中使用 ### 查看退出状态码 Linux提供了一个专门的变量$?来保存上个已执行命令的退出状态码。 ```bash jiao@jiao virtual machine:~/桌面/linux shell/11.5$ date 2022年 08月 05日 星期五 23:11:06 CST jiao@jiao virtual machine:~/桌面/linux shell/11.5$ echo $? 0 jiao@jiao virtual machine:~/桌面/linux shell/11.5$ asd Command 'asd' not found, but there are 22 similar ones. jiao@jiao virtual machine:~/桌面/linux shell/11.5$ echo $? 127 ``` > 退出的时候出错, 就会产生一个大于零的状态码 > > 无效命令127 没有特别的规定, 但是有一定的参考值 状态码 描述 : : : : 0 命令成功结束 1 一般性未知错误 2 不适合的shell命令 126 命令不可执行 127 没找到命令 128 无效的退出参数 128+x 与Linux信号x相关的严重错误 130 通过Ctrl+C终止的命令 255 正常范围之外的退出状态码 > 126 没有相关的权限 > > 1 参数错误 ### exit命令 默认情况下, shell会以脚本中最后一条命令状态码退出 exit命令允许你在脚本结束时指定一个退出状态码。 ```bash 1 #!/bin/bash 2 # 测试退出码 3 var1 10 4 var2 30 5 var3 $[$var1 + $var2] 6 echo The answer is $var3 7 exit 5 jiao@jiao virtual machine:~/桌面/linux shell/11.5$ test6 The answer is 40 jiao@jiao virtual machine:~/桌面/linux shell/11.5$ echo $? 5 ``` > **注:**输出的参数最大为255"},"/note/Linux/Linux命令行与shell脚本编程大全/2022-8-12-邮件相关.html":{"title":"邮件相关《Linux命令行与Shell脚本编程大全》","content":" layout: post title: \"邮件相关《Linux命令行与Shell脚本编程大全》\" date: 2022 8 11 23:39:08 +0800 tags: 《Linux命令行与Shell脚本编程大全》 Linux # 邮件相关 ## MySQL数据库 #### 连接到服务器 允许你通过用户账户和密码连到网络中任何地方的MySQL数据库服务器 默认情况下，如果你在命令行上输入`mysql`，且不加任何参数，它会试图用Linux登录用户名连接运行在同一Linux系统上的MySQL服务器 通常还是创建一个应用程序专用的账户比较安全，不要用MySQL服务器上的标准用户账户。这样可以针对应用程序用户实施访问限制，即便应用程序出现了偏差，在必要时你也可以删除或重建 使用 u参数指定登录用户名"},"/note/Linux/Linux命令行与shell脚本编程大全/2022-8-11-使用其他shell.html":{"title":"使用其他shell《Linux命令行与Shell脚本编程大全》","content":" layout: post title: \"使用其他shell《Linux命令行与Shell脚本编程大全》\" date: 2022 8 11 23:39:08 +0800 tags: 《Linux命令行与Shell脚本编程大全》 Linux # 使用其他shell ## 什么是dash shell 它是ash shell的直系后代，而ash shell则是Unix系统上原来的Bourne shell的简化版本 ash shell最早的版本体积极小、速度奇快，但缺乏许多高级功能，比如命令行编辑或命令使用记录功能，这使它很难用作交互式shell Debian Linux发行版创建了它自己的ash shell版本（称作Debian ash，或dash）以供自用。dash复制了ash shell的NetBSD版本的大多数功能，提供了一些高级命令行编辑能力\\ Ubuntu Linux发行版将bash shell用作默认的交互shell，但将dash shell用作默认的/bin/sh shell。这个“特性”着实让shell脚本程序员一头雾水 在Unix世界中，默认shell一直是/bin/sh。在大多数Linux发行版上，/bin/sh文件是链接到shell程序/bin/bash的一个符号链接 Ubuntu Linux发行版将/bin/sh文件链接到了shell程序/bin/dash。由于dash shell只含有原来Bourne shell中的一部分命令，这可能会（而且经常会）让有些shell脚本无法正确工作 ## dash shell的特性 dash shell使用命令行参数来控制其行为。表23 1列出了命令行参数，并介绍了每个参数的用途 参数 描述 : : : : a 导出分配给shell的所有变量 c 从特定命令字符串中读取命令 e 如果是非交互式shell的话，在有未经测试的命令失败时立即退出 f 显示路径名通配符 n 如果是非交互式shell的话，读取命令但不执行它们 u 在尝试展开一个未设置的变量时，将错误消息写出到STDERR v 在读取输入时将输入写出到STDERR x 在执行命令时将每个命令写出到STDERR I(大写i) 在交互式模式下，忽略输入中的EOF字符 i 强制shell运行在交互式模式下 m 启用作业控制（在交互式模式下默认开启） s 从STDIN读取命令（在没有指定文件参数时的默认行为） E 启用emacs命令行编辑器 v 启用vi命令行编辑器 "},"/note/Linux/Linux命令行与shell脚本编程大全/2022-8-11-gawk进阶.html":{"title":"gawk进阶《Linux命令行与Shell脚本编程大全》","content":" layout: post title: \"gawk进阶《Linux命令行与Shell脚本编程大全》\" date: 2022 8 11 23:39:08 +0800 tags: 《Linux命令行与Shell脚本编程大全》 Linux # gawk进阶 是一门丰富的编程语言 ## 使用变量 + 内建变量 + 自定义变量 ### 内建变量 #### 字段和记录分隔符变量 数据字段变量, \\$和数字引用记录对应的字段, 第一个\\$1, 第二个\\$2 命令行下使用命令行参数 F或者在gawk程序中使用特殊的内建变量FS来更改字段分隔符 变量 描述 : : : : FIELDWIDTHS 由空格分隔的一列数字，定义了每个数据字段确切宽度 FS 输入字段分隔符 RS 输入记录分隔符 OFS 输出字段分隔符 ORS 输出记录分隔符 OFS和FS的功能相似, 但是作用于输出, 默认情况下为空格 ```bash print $1,$2,$3 # 会看到如下输出： field1 field2 field3 ``` ```bash jiao@jiao virtual machine:~/桌面/linux shell/22$ gawk 'BEGIN{FS \",\"} {print $1,$2,$4}' data1.txt data11 data12 data14 data21 data22 data24 data31 data32 data34 jiao@jiao virtual machine:~/桌面/linux shell/22$ gawk 'BEGIN{FS \",\"; OFS \" \"} {print $1,$2,$4}' data1.txt data11 data12 data14 data21 data22 data24 data31 data32 data34 ``` FIELDWIDTHS变量允许你不依靠字段分隔符来读取记录。 一旦设置了FIELDWIDTH变量，gawk就会忽略FS变量，并根据提供的字段宽度来计算字段 ```bash jiao@jiao virtual machine:~/桌面/linux shell/22$ cat data2.txt 1005.3247596.37 115 2.349194.00 05810.1298100.1 jiao@jiao virtual machine:~/桌面/linux shell/22$ gawk 'BEGIN{FIELDWIDTHS \"3 5 2 5\"}{print $1,$2,$3, $4}' data2.txt 100 5.324 75 96.37 115 2.34 91 94.00 058 10.12 98 100.1 ``` 变量RS和ORS定义了gawk程序如何处理数据流中的字段。默认情况下，gawk将RS和ORS设为换行符。 每行新文本就是一条新纪录 可以把RS变量设置成空字符串，然后在数据记录间留一个空白行。gawk会把每个空白行当作一个记录分隔符 ```bash jiao@jiao virtual machine:~/桌面/linux shell/22$ cat data3.txt Riley Mullen 123 Main Street Chicago, IL 60601 (312)555 1234 Frank Williams 456 Oak Street Indianapolis, IN 46201 (317)555 9876 Haley Snell 4231 Elm Street Detroit, MI 48201 (313)555 4938 jiao@jiao virtual machine:~/桌面/linux shell/22$ gawk 'BEGIN{FS \"\\n\"; RS \"\"} {print $1,$4}' data3.txt Riley Mullen (312)555 1234 Frank Williams (317)555 9876 Haley Snell (313)555 4938 ``` #### 数据变量 变量 描述 : : : : ARGC 当前命令行参数个数 ARGIND 当前文件在ARGV中的位置 ARGV 包含命令行参数的数组 CONVFMT 数字的转换格式（参见printf语句），默认值为%.6 g ENVIRON 当前shell环境变量及其值组成的关联数组 ERRNO 当读取或关闭输入文件发生错误时的系统错误号 FILENAME 用作gawk输入数据的数据文件的文件名 FNR 当前数据文件中的数据行数 IGNORECASE 设成非零值时，忽略gawk命令中出现的字符串的字符大小写 NF 数据文件中的字段总数 NR 已处理的输入记录数 OFMT 数字的输出格式，默认值为%.6 g RLENGTH 由match函数所匹配的子字符串的长度 RSTART 由match函数所匹配的子字符串的起始位置 ```bash jiao@jiao virtual machine:~/桌面/linux shell/22$ gawk \"BEGIN{print ARGC,ARGV[1],ARGV[0]}\" data1.txt 2 data1.txt gawk ``` > gawk并不会将程序脚本当成命令行参数的一部分。 > 在脚本中引用gawk变量时，变量名前不加美元符 ENVIRON变量看起来可能有点陌生。它使用关联数组来提取shell环境变量。关联数组用文本作为数组的索引值，而不是数值 ```bash jiao@jiao virtual machine:~/桌面/linux shell/22$ gawk ' BEGIN{ print ENVIRON[\"HOME\"] print ENVIRON[\"PATH\"] }' /home/jiao /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin:/snap/bin:.:/home/jiao/桌面 ``` NF变量可以让你在不知道具体位置的情况下指定记录中的最后一个数据字段 NF变量含有数据文件中最后一个数据字段的数字值。可以在它前面加个美元符将其用作字段变量。 ```bash jiao@jiao virtual machine:~/桌面/linux shell/22$ gawk 'BEGIN{FS \":\"; OFS \":\"}{print $1,$NF}' /etc/passwd root:/bin/bash daemon:/usr/sbin/nologin ... ``` FNR变量含有当前数据文件中已处理过的记录数，NR变量则含有已处理过的记录总数。 ```bash jiao@jiao virtual machine:~/桌面/linux shell/22$ gawk 'BEGIN{FS \",\"}{print $1,\"FNR \"FNR} ' data1.txt data2.txt data11 FNR 1 data21 FNR 2 data31 FNR 3 1005.3247596.37 FNR 1 115 2.349194.00 FNR 2 05810.1298100.1 FNR 3 ``` ```bash jiao@jiao virtual machine:~/桌面/linux shell/22$ gawk 'BEGIN{FS \",\"}{print $1,\"NR \"NR} ' data1.txt data2.txt data11 NR 1 data21 NR 2 data31 NR 3 1005.3247596.37 NR 4 115 2.349194.00 NR 5 05810.1298100.1 NR 6 ``` ### 自定义变量 变量名可以是任意数目的字母、数字和下划线，但不能以数字开头 #### 在脚本中给变量赋值 ```bash jiao@jiao virtual machine:~/桌面/linux shell/22$ gawk 'BEGIN{test \"This is a test\"; print test; test 1; print test}' This is a test 1 ``` gawk编程语言包含了用来处理数字值的标准算数操作符。其中包括求余符号（%）和幂运算符号（^或**） ```bash jiao@jiao virtual machine:~/桌面/linux shell/22$ gawk 'BEGIN{test 5 ; test test*3+2; print test}' 17 ``` #### 在命令行上给变量赋值 允许你在正常的代码之外更改变量 ```bash jiao@jiao virtual machine:~/桌面/linux shell/22$ cat test1.sh BEGIN{FS \",\"} {print $n} jiao@jiao virtual machine:~/桌面/linux shell/22$ gawk f test1.sh n 1 data1.txt data11 data21 data31 jiao@jiao virtual machine:~/桌面/linux shell/22$ gawk f test1.sh n 2 data1.txt data12 data22 data32 ``` 在你设置了变量后，这个值在代码的BEGIN部分不可用。 ```bash jiao@jiao virtual machine:~/桌面/linux shell/22$ cat test2.sh BEGIN{print \"n \",n; FS \",\"} {print $n} jiao@jiao virtual machine:~/桌面/linux shell/22$ gawk f test2.sh n 2 data1.txt n data12 data22 data32 ``` 可以用 v命令行参数来解决这个问题。它允许你在BEGIN代码之前设定变量。在命令行上， v命令行参数必须放在脚本代码之前 ```bash jiao@jiao virtual machine:~/桌面/linux shell/22$ gawk v n 2 f test2.sh data1.txt n 2 data12 data22 data32 ``` ### 定义数组变量 ```bash var[index] element ``` > 其中var是变量名，index是关联数组的索引值，element是数据元素值 ```bash jiao@jiao virtual machine:~/桌面/linux shell/22$ gawk 'BEGIN{capital[\"Illinois\"] \"Spr\" > print capital[\"Illinois\"] > }' Spr ``` ```bash $ gawk 'BEGIN{ > var[1] 34 > var[2] 3 > total var[1] + var[2] > print total > }' 37 $ ``` ### 遍历数组变量 ```bash for (var in array) { \tstatements } ``` > 记住这个变量中存储的是索引值而不是数组元素值。可以将这个变量用作数组的索引，轻松地取出数据元素值 在遍历的时候是不按照顺序的 ### 删除数组变量 ```bash delete array[index] ``` ## 使用模式 ### 正则表达式 在使用正则表达式时，正则表达式必须出现在它要控制的程序脚本的左花括号前 ```bash jiao@jiao virtual machine:~$ gawk 'BEGIN{FS \":\"} /jiao/{print $0}' /etc/passwd jiao:x:1000:1000:jiao,,,:/home/jiao:/bin/bash ``` gawk程序会用正则表达式对记录中所有的数据字段进行匹配，包括字段分隔符 ### 匹配操作符 **匹配操作符**允许将正则表达式限定在记录中的特定数据字段。匹配操作符是波浪线（~）。可以指定匹配操作符、数据字段变量以及要匹配的正则表达式 ```bash $1 ~ /^data/ ``` > 这个表达式会过滤出第一个字段以文本data开头的所有记录。 你也可以用!符号来排除正则表达式的匹配 ```bash jiao@jiao virtual machine:~$ gawk F, '$1 !~ /data1/{print $0}' data1.txt data21, data22, data23, data24 data31, data32, data33, data34 jiao@jiao virtual machine:~$ gawk F, '$1 ~ /data1/{print $0}' data1.txt data11, data12, data13, data14 ``` ### 数学表达式 + x y：值x等于y。 + x < y：值x小于等于y。 + x < y：值x小于y。 + x > y：值x大于等于y。 + x > y：值x大于y。 > 跟正则表达式不同，表达式必须完全匹配。数据必须跟模式严格匹配 ```bash jiao@jiao virtual machine:~$ gawk F, '$1 \"data11\"{print $0}' data1.txt data11, data12, data13, data14 ``` ## 结构化命令 ### if语句 ```bash if (condition) \tstatement1 ``` ```bash if (condition) statement1 ``` 如果需要在if语句中执行多条语句，就必须用花括号将它们括起来 if语句也支持else子句，允许在if语句条件不成立的情况下执行一条或多条语句。 ```bash if (condition) statement1; else statement2 ``` ### while语句 ```bash while (condition) { \tstatements } ``` gawk编程语言支持在while循环中使用break语句和continue语句，允许你从循环中跳出 ### do while语句 ```bash do { \ttotal + $i \ti ++ } while (condition) ``` ### for语句 有C语言的风格 ## 格式化打印 print语句在gawk如何显示数据上并未提供多少控制。你能做的只是控制输出字段分隔符（OFS）。如果要创建详尽的报表，通常需要为数据选择特定的格式和位置 `printf`。如果你熟悉C语言编程的话，gawk中的`printf`命令用法也是一样，允许指定具体如何显示数据的指令 ```bash printf \"format string\", var1, var2 . . . ``` ```bash %[modifier]control letter ``` > control letter是一个单字符代码，用于指明显示什么类型的数据，而modifier则定义了可选的格式化特性 和C语言一样 还有3种修饰符可以用来进一步控制输出 + width：指定了输出字段最小宽度的数字值。如果输出短于这个值，`printf`会将文本右对齐，并用空格进行填充。如果输出比指定的宽度还要长，则按照实际的长度输出。 + `prec`：这是一个数字值，指定了浮点数中小数点后面位数，或者文本字符串中显示的最大字符数。 + （减号）：指明在向格式化空间中放入数据时采用左对齐而不是右对齐 你需要在`printf`命令的末尾手动添加换行符来生成新行。没添加的话，`printf`命令会继续在同一行打印后续输出 ```bash $ gawk 'BEGIN{FS \"\\n\"; RS \"\"} {printf \"% 16s %s\\n\", $1, $4}' data2 Riley Mullen (312)555 1234 Frank Williams (317)555 9876 Haley Snell (313)555 4938 ``` # 后面的感觉暂时用不上, 懒得看了"},"/note/Linux/Linux命令行与shell脚本编程大全/2022-8-4-管理文件系统.html":{"title":"管理文件系统《Linux命令行与Shell脚本编程大全》","content":" layout: post title: \"管理文件系统《Linux命令行与Shell脚本编程大全》\" date: 2022 8 4 15:03:08 +0800 tags: 《Linux命令行与Shell脚本编程大全》 Linux # 管理文件系统 使用Linux的时候可以选择使用的文件系统, 大多数的发行版会贴心的提供默认的文件系统 ## 探究Linuxwe年系统 Linux文件系统为我们在硬盘中存储的01和应用之间搭建起一座桥梁 Linux支持多种类型的文件系统管理文件和目录。每种文件系统都在存储设备上实现了虚拟目录结构，仅特性略有不同 ### 基本的Linux文件系统 Linux最初采用的简单的文件系统, 模仿了Unix文件系统 #### ext文件系统 Linux最早的文件系统, 叫做**扩展文件系统(简写ext)**, 提供了一个基本的类Unix系统: 使用**虚拟目录**来操控硬件设备,在物理设备上按照定长的块来存储数据 ext文件系统采用名为**索引节点**的系统来存放虚拟目录中所存储文件的信息, 在每个物理设备中创建一个单独的表（称为索引节点表）来存储这些文件的信息 储在虚拟目录中的每一个文件在索引节点表中都有一个条目 其跟踪的每个文件的额外数据: + 文件名 + 文件大小 + 文件的属主 + 文件的属组 + 文件的访问权限 + 指向存有文件数据的每个硬盘块的指针 Linux通过记录每一个索引节点的数值来寻找文件 #### ext2文件系统 最早的系统有限制, 比如文件大小不能超过2G ext2的保存了同样的结构, 但是索引方式发生了更改, 可以保存更多的信息 增加了创建时间, 修改时间, 最后访问时间帮助追踪, 最大的文件扩展为2T以上 还改变了数据块的存储方式, 按组分配硬盘减少碎片化 但它也有一些限制。索引节点表虽然支持文件系统保存有关文件的更多信息，但会对系统造成致命的问题。文件系统每次存储或更新文件，它都要用新信息来更新索引节点表。问题在于这种操作并非总是一气呵成的。如果计算机系统在存储文件和更新索引节点表之间发生了什么，这二者的内容就不同步了。ext2文件系统由于容易在系统崩溃或断电时损坏而臭名昭著。即使文件数据正常保存到了物理设备上，如果索引节点表记录没完成更新的话，ext2文件系统甚至都不知道那个文件存在 ### 日志文件系统(JFS) 它不再使用之前先将数据直接写入存储设备再更新索引节点表的做法，而是先将文件的更改写入到临时文件（称作日志，journal）中。在数据成功写到存储设备和索引节点表之后，再删除对应的日志条目 有三种传统的日志 方法 描述 : : : : 数据模式 索引节点和文件都会被写入日志；丢失数据风险低，但性能差 有序模式 只有索引节点数据会被写入日志，但只有数据成功写入后才删除；在性能和安全性之间取得了良好的折中 回写模式 只有索引节点数据会被写入日志，但不控制文件数据何时写入；丢失数据风险高，但仍比不用日志好 数据模式是最安全的, 也是最慢的, 要写入两次, 第一次写入日志, 第二次写入真正的存储设备 #### ext3 采用和ect2相同的索引节点表结构, 但给每个存储设备增加了一个日志文件 默认情况下，ext3文件系统用有序模式的日志功能, 你可以在创建文件系统时用简单的一个命令行选项将ext3文件系统的日志方法改成数据模式或回写模式 > 缺陷: > > + 无法恢复误删的文件 > + 没有任何内建的数据压缩功能 > + 不支持加密文件 #### ext4 几乎是所有发行版的默认文件系统 支持数据压缩和加密 ext4文件系统还支持一个称作区段（extent）的特性, 设备上按块分配空间，但在索引节点表中只保存起始块的位置。由于无需列出所有用来存储文件中数据的数据块，它可以在索引节点表中节省一些空间 ext4还引入了块预分配技术, 在存储设备上给一个你知道要变大的文件预留空间，ext4文件系统可以为文件分配所有需要用到的块，而不仅仅是那些现在已经用到的块 #### Reiser文件系统 只支持回写日志模式, 最快的日志文件系统之一 + 你可以在线调整已有文件系统的大小 + 尾部压缩（tailpacking）的技术，该技术能将一个文件的数据填进另一个文件的数据块中的空白空间 #### JFS文件系统 在使用的最古老的文件系统, 从Unix上移植 采用的是有序日志方法 JFS文件系统采用基于区段的文件分配，即为每个写入存储设备的文件分配一组块。这样可以减少存储设备上的碎片 #### XFS文件系统 最初用于Unix后来移植到Linux 采用回写模式的日志 ### 写时复制文件系统(COW) 兼顾了安全性以及性能 利用快照兼顾了安全性和性能。如果要修改数据，会使用克隆或可写快照。修改过的数据并不会直接覆盖当前数据，而是被放入文件系统中的另一个位置上。即便是数据修改已经完成，之前的旧数据也不会被重写 #### ZFS文件系统 稳定的文件系统, 但是没有采用GPL许可 #### Btrf文件系统 出现在许多的Linux系统之中, 但不是默认 ## 操作文件系统 ### 创建分区 一开始你需要创建一个分区来容纳文件系统, 可以是整个硬盘或部分硬盘 fdisk工具帮助管理安装在任何设备上的分区 要启动fdisk命令，你必须指定要分区的存储设备的设备名 > 有时候，创建新磁盘分区最麻烦的事情就是找出安装在Linux系统中的物理磁盘。Linux采用了一种标准格式来为硬盘分配设备名称，但是你得熟悉这种格式。对于老式的IDE驱动器，Linux使用的是/dev/hdx。其中x表示一个字母，具体是什么要根据驱动器的检测顺序（第一个驱动器是a，第二个驱动器是b，以此类推）。对于较新的SATA驱动器和SCSI驱动器，Linux使用/dev/sdx。其中的x具体是什么也要根据驱动器的检测顺序（和之前一样，第一个驱动器是a，第二个驱动器是b，以此类推）。在格式化分区之前，最好再检查一下是否正确指定了驱动器 可以采用交互命令告诉fdisk你要做什么 命令 描述 : : : : a 设置活动分区标志 b 编辑BSD Unix系统用的磁盘标签 c 设置DOS兼容标志 d 删除分区 l 显示可用的分区类型 m 显示命令选项 n 添加一个新分区 o 创建DOS分区表 p 显示当前分区表 q 退出，不保存更改 s 为Sun Unix系统创建一个新磁盘标签 t 修改分区的系统ID u 改变使用的存储单位 v 验证分区表 w 将分区表写入磁盘 x 高级功能 ```bash jiao@jiao virtual machine:~/桌面/linux shell/7/test2$ sudo fdisk /dev/sda 欢迎使用 fdisk (util linux 2.36.1)。 更改将停留在内存中，直到您决定将更改写入磁盘。 使用写入命令前请三思。 命令(输入 m 获取帮助)： p Disk /dev/sda：20 GiB，21474836480 字节，41943040 个扇区 Disk model: VMware Virtual S 单元：扇区 / 1 * 512 512 字节 扇区大小(逻辑/物理)：512 字节 / 512 字节 I/O 大小(最小/最佳)：512 字节 / 512 字节 磁盘标签类型：gpt 磁盘标识符：7D46A08B AB29 4475 889D 2477A5B44D51 设备 起点 末尾 扇区 大小 类型 /dev/sda1 2048 4095 2048 1M BIOS 启动 /dev/sda2 4096 1054719 1050624 513M EFI 系统 /dev/sda3 1054720 41940991 40886272 19.5G Linux 文件系统 ``` > 进入并查看 ```bash 命令(输入 m 获取帮助)： n 分区号 (4 128, 默认 4): 4 第一个扇区 (34 41943006, 默认 41940992): Last sector, +/ sectors or +/ size{K,M,G,T,P} (41940992 41943006, 默认 41943006): +512k 创建了一个新分区 4，类型为“Linux filesystem”，大小为 512 KiB。 命令(输入 m 获取帮助)： p Disk /dev/sda：20 GiB，21474836480 字节，41943040 个扇区 Disk model: VMware Virtual S 单元：扇区 / 1 * 512 512 字节 扇区大小(逻辑/物理)：512 字节 / 512 字节 I/O 大小(最小/最佳)：512 字节 / 512 字节 磁盘标签类型：gpt 磁盘标识符：7D46A08B AB29 4475 889D 2477A5B44D51 设备 起点 末尾 扇区 大小 类型 /dev/sda1 2048 4095 2048 1M BIOS 启动 /dev/sda2 4096 1054719 1050624 513M EFI 系统 /dev/sda3 1054720 41940991 40886272 19.5G Linux 文件系统 /dev/sda4 41940992 41940993 2 512K Linux 文件系统 命令(输入 m 获取帮助)： ``` > 创建一个512k的分区 分区可以按主分区（primary partition）或扩展分区（extended partition）创建. 主分区可以直接被系统格式化, 扩展分区只能容纳其他逻辑分区 扩展分区出现的原因是每个存储设备上只能有4个分区。可以通过创建一个扩展分区，然后在扩展分区内创建逻辑分区进行扩展。 fdisk允许创建多种分区类型。使用l命令列出可用的不同类型。默认创建一个Linux文件系统 ```bash 命令(输入 m 获取帮助)： w 分区表已调整。 正在同步磁盘。 ``` > 退出 ### 创建文件系统 在把数据存储到分区之前, 你必须对文件系统进行格式化, 这样Linux才能使用 工具 用途 : : : : mkefs 创建一个ext文件系统 mke2fs 创建一个ext2文件系统 mkfs.ext3 创建一个ext3文件系统 mkfs.ext4 创建一个ext4文件系统 mkreiserfs 创建一个ReiserFS文件系统 jfs_mkfs 创建一个JFS文件系统 mkfs.xfs 创建一个XFS文件系统 mkfs.zfs 创建一个ZFS文件系统 mkfs.btrfs 创建一个Btrfs文件系统 > 不是所有的都默认安装, 可以使用type命令查看 不同的文件系统都有不同的命令用来创建不同类型的文件系统, 但是都允许通过没有参数的命令创建一个默认的文件系统 ```bash jiao@jiao virtual machine:~/桌面/linux shell/7/test2$ sudo mkfs.ext4 /dev/sda4 [sudo] jiao 的密码： mke2fs 1.46.3 (27 Jul 2021) 文件系统太小，无法容纳日志 创建含有 128 个块（每块 4k）和 64 个inode的文件系统 正在分配组表： 完成 正在写入inode表： 完成 写入超级块和文件系统账户统计信息： 已完成 ``` > 创建的第一步是构建一个日志 下一步是把分区挂载到某一个虚拟目录下的挂载点, 你可以把它挂载到任何位置 ```bash jiao@jiao virtual machine:~/桌面/linux shell/7/test2$ ls /mnt hgfs jiao@jiao virtual machine:~/桌面/linux shell/7/test2$ sudo mkdir /mnt/my_partition #创建挂载的文件夹 jiao@jiao virtual machine:~/桌面/linux shell/7/test2$ ls la /mnt/ 总用量 16 drwxr xr x 4 root root 4096 8月 4 18:11 . drwxr xr x 20 root root 4096 3月 11 21:39 .. drwxr xr x 2 root root 4096 7月 18 22:00 hgfs drwxr xr x 2 root root 4096 8月 4 18:11 my_partition jiao@jiao virtual machine:~/桌面/linux shell/7/test2$ ls la /mnt/my_partition 总用量 8 drwxr xr x 2 root root 4096 8月 4 18:11 . drwxr xr x 4 root root 4096 8月 4 18:11 .. jiao@jiao virtual machine:~/桌面/linux shell/7/test2$ ls dF /mnt/my_partition /mnt/my_partition/ jiao@jiao virtual machine:~/桌面/linux shell/7/test2$ sudo mount t ext4 /dev/sda4 /mnt/my_partition\t\t\t\t\t#进行挂载, 类型是ext4 ``` 可以投入日常使用了 > 这种挂载是临时挂载, 重启的时候不会自动挂载, 要强制挂载可以把它添加到/etc/fstab文件 ### 文件系统的检查与修复 碰上突然断电或者某个不规矩的程序在访问文件时锁定了系统，也会出现错误。幸而有一些命令行工具可以帮你将文件系统恢复正常 fsck命令能够检查和修复大部分类型的Linux文件系统，包括本章早些时候讨论过的ext、ext2、ext3、ext4、ReiserFS、JFS和XFS。 ```bash fsck options filesystem ``` > 文件系统可以通过设备名、在虚拟目录中的挂载点以及分配给文件系统的唯一UUID值来引用 日志文件系统需要用到fsck检查, 但是COW文件系统是否需要仍然存在争议, 甚至ZFS文件系统没有提供接口 fsck命令使用/etc/fstab文件来自动决定正常挂载到系统上的存储设备的文件系统。如果存储设备尚未挂载（比如你刚刚在新的存储设备上创建了个文件系统），你需要用 t命令行选项来指定文件系统类型。 选项 描述 : : : : a 如果检测到错误，自动修复文件系统 A 检查/etc/fstab文件中列出的所有文件系统 C 给支持进度条功能的文件系统显示一个进度条（只有ext2和ext3） N 不进行检查，只显示哪些检查会执行 r 出现错误时提示 R 使用 A选项时跳过根文件系统 s 检查多个文件系统时，依次进行检查 t 指定要检查的文件系统类型 T 启动时不显示头部信息 V 在检查时产生详细输出 y 检测到错误时自动修复文件系统 > 有些命令行选项是重复的。这是为多个命令实现通用的前端带来的部分问题。有些文件系统修复命令有一些额外的可用选项。如果要做更高级的错误检查，就需要查看这个文件系统修复工具的手册页面来确定是不是有该文件系统专用的扩展选项 > 只能在未挂载的文件系统上运行fsck命令。对大多数文件系统来说，你只需卸载文件系统来进行检查，检查完成之后重新挂载就好了。但因为根文件系统含有所有核心的Linux命令和日志文件，所以你无法在处于运行状态的系统上卸载它 ## 逻辑卷管理 如果用标准分区在硬盘上创建文件系统, 为已有的文件系统添加额外的空间就只能在同一个物理硬盘上调整可用的分区大小, 没有地方了觉需要弄一个更大的硬盘，然后手动将已有的文件系统移动到新的硬盘上 通过将另外一个硬盘上的分区加入已有文件系统，动态地添加存储空间。Linux逻辑卷管理器（logical volume manager，LV M）软件包正好可以用来做这个。它可以让你在无需重建整个文件系统的情况下，轻松地管理磁盘空间 > **个人理解:** 把硬件进行抽象成一个整体, 在抽象的整体上进行文件系统操作 ### 逻辑卷管理分布 核心在于如何处理安装在系统上的硬盘分区 硬盘 >物理卷 每一个物理卷映射到特定的物理分区, 多个物理卷可以组成一个卷组 逻辑卷管理系统将卷组视为一个物理硬盘，但事实上卷组可能是由分布在多个物理硬盘上的多个物理分区组成的。卷组提供了一个创建逻辑分区的平台，而这些逻辑分区则包含了文件系统。 整个结构中的最后一层是逻辑卷（logical volume，LV）。逻辑卷为Linux提供了创建文件系统的分区环境，作用类似于到目前为止我们一直在探讨的Linux中的物理硬盘分区。Linux系统将逻辑卷视为物理分区 可以使用任意一种标准Linux文件系统来格式化逻辑卷，然后再将它加入Linux虚拟目录中的某个挂载点 ![QQ图片20220804184439](https://blog 1308522872.cos.ap beijing.myqcloud.com/jhy/202212312349267.png) 第三个物理硬盘有一个未使用的分区。通过逻辑卷管理，你随后可以轻松地将这个未使用分区分配到已有卷组：要么用它创建一个新的逻辑卷，要么在需要更多空间时用它来扩展已有的逻辑卷 如果你给系统添加了一块硬盘，逻辑卷管理系统允许你将它添加到已有卷组，为某个已有的卷组创建更多空间，或是创建一个可用来挂载的新逻辑卷 ### Linux中的LVM 允许你使用简单的命令来控制一个完整的逻辑卷环境 有两个可行的版本: + LVM1: 可用于Linux2.4 + LVM2: 更新的版本, 提供格外功能 #### 快照 你在逻辑卷在线的状态下将其复制到另一个设备 快照允许你在复制的同时，保证运行关键任务的Web服务器或数据库服务器继续工作 LVM1只允许拍摄快照, 之后就不能写入了 LVM2允许在创建在线逻辑卷的可读写快照。有了可读写的快照，就可以删除原先的逻辑卷，然后将快照作为替代挂载上 #### 条带化 可跨多个物理硬盘创建逻辑卷。文件中的数据块会被分散到多个硬盘上。每个后继数据块会被写到下一个硬盘上 因为Linux可以将一个文件的多个数据块同时写入多个硬盘，而无需等待单个硬盘移动读写磁头到多个不同位置 > LV M条带化不同于RAID条带化。LV M条带化不提供用来创建容错环境的校验信息。事实上，LV M条带化会增加文件因硬盘故障而丢失的概率。单个硬盘故障可能会造成多个逻辑卷无法访问 #### 镜像 镜像是一个实时更新的逻辑卷的完整副本。当你创建镜像逻辑卷时，LV M会将原始逻辑卷同步到镜像副本中。根据原始逻辑卷的大小，这可能需要一些时间才能完成 一旦原始同步完成，LV M会为文件系统的每次写操作执行两次写入——一次写入到主逻辑卷，一次写入到镜像副本。可以想到，这个过程会降低系统的写入性能。就算原始逻辑卷因为某些原因损坏了，你手头也已经有了一个完整的最新副本 ### 使用Linux LVM 有些Linux开发出了图形界面 #### 定义物理卷 使用的第一步就是把硬盘上的物理分区转化为Linux LVm使用的物理卷区段, fdisk命令可以帮忙, 在创建了基本的Linux分区之后, 通过t命令改变分区类型 ```bash 命令(输入 m 获取帮助)： t 分区号 (1 4, 默认 4): 4 Partition type or alias (type L to list all): 30 //进行类型的设置, 30代表Linux LVM系统一部分 已将分区“Linux filesystem”的类型更改为“Linux LVM”。 命令(输入 m 获取帮助)： p Disk /dev/sda：20 GiB，21474836480 字节，41943040 个扇区 Disk model: VMware Virtual S 单元：扇区 / 1 * 512 512 字节 扇区大小(逻辑/物理)：512 字节 / 512 字节 I/O 大小(最小/最佳)：512 字节 / 512 字节 磁盘标签类型：gpt 磁盘标识符：7D46A08B AB29 4475 889D 2477A5B44D51 设备 起点 末尾 扇区 大小 类型 /dev/sda1 2048 4095 2048 1M BIOS 启动 /dev/sda2 4096 1054719 1050624 513M EFI 系统 /dev/sda3 1054720 41940991 40886272 19.5G Linux 文件系统 /dev/sda4 41940992 41942015 1024 512K Linux LVM ``` 然后利用分区创建实际的物理卷, 这可以通过pvcreate命令来完成。 ```bash jiao@jiao virtual machine:/mnt$ sudo pvcreate /dev/sdb1 WARNING: ext4 signature detected on /dev/sdb1 at offset 1080. Wipe it? [y/n]: y Wiping ext4 signature on /dev/sdb1. Physical volume \"/dev/sdb1\" successfully created. jiao@jiao virtual machine:/mnt$ sudo pvdisplay /dev/sdb1 \"/dev/sdb1\" is a new physical volume of \"<7.50 GiB\" NEW Physical volume PV Name /dev/sdb1 VG Name PV Size <7.50 GiB Allocatable NO PE Size 0 Total PE 0 Free PE 0 Allocated PE 0 PV UUID 7sSerG a3fu LAEG l2Yl SH6R 6L7s PDhJyk ``` > dev_is_mpath: failed to get device for 8:17或类似的消息唬住了。只要看到了successfully created就没问题。pvcreate命令会检查分区是否为多路（multi path，mpath）设备。如果不是的话，就会发出上面那段消息。 可以使用`pvdisplay`显示创建列表的过程, 方式和上面一样 #### 创建卷组 从物理卷中创建一个或多个卷组。究竟要为系统创建多少卷组并没有既定的规则，你可以将所有的可用物理卷加到一个卷组，也可以结合不同的物理卷创建多个卷组 需要使用vgcreate命令。vgcreate命令需要一些命令行参数来定义卷组名以及你用来创建卷组的物理卷名 ```bash jiao@jiao virtual machine:/mnt$ sudo vgcreate Voll /dev/sdb1 Volume group \"Voll\" successfully created ``` 可以使用vgdisplay查看细节 ```bash jiao@jiao virtual machine:/mnt$ sudo vgdisplay Voll Volume group VG Name Voll System ID Format lvm2 Metadata Areas 1 Metadata Sequence No 1 VG Access read/write VG Status resizable MAX LV 0 Cur LV 0 Open LV 0 Max PV 0 Cur PV 1 Act PV 1 VG Size <7.50 GiB PE Size 4.00 MiB Total PE 1919 Alloc PE / Size 0 / 0 Free PE / Size 1919 / <7.50 GiB VG UUID VY2MLY 9GTP sYlX KOqf Tm1T H9OE E2szgu ``` 创建一个或多个卷组后，就可以创建逻辑卷了 ### 创建逻辑卷 Linux系统使用逻辑卷来模拟物理分区，并在其中保存文件系统。Linux系统会像处理物理分区一样处理逻辑卷，允许你定义逻辑卷中的文件系统，然后将文件系统挂载到虚拟目录上 使用lvcreate命令 **选项** 选项 长选项名 描述 : : : : : : c chunksize 指定快照逻辑卷的单位大小 C contiguous 设置或重置连续分配策略 i stripes 指定条带数 I(大写i) stripesiz 指定每个条带的大小 l(小写L) extents 指定分配给新逻辑卷的逻辑区段数，或者要用的逻辑区段的百分比 L size 指定分配给新逻辑卷的硬盘大小 minor 指定设备的次设备号 m mirrors 创建逻辑卷镜像 M persistent 让次设备号一直有效 n name 指定新逻辑卷的名称 p permission 为逻辑卷设置读/写权限 r readahead 设置预读扇区数 R regionsize 指定将镜像分成多大的区 s snapshot 创建快照逻辑卷 z zero 将新逻辑卷的前1 KB数据设置为零 ```bash jiao@jiao virtual machine:/mnt$ sudo lvcreate l 100%FREE n lvtest Voll Logical volume \"lvtest\" created. ``` > 创建一个逻辑卷 ```bash jiao@jiao virtual machine:/mnt$ sudo lvdisplay Voll Logical volume LV Path /dev/Voll/lvtest LV Name lvtest VG Name Voll LV UUID 2YteJ1 jhw0 2ttQ WB24 AWFP IilC qmBvLs LV Write Access read/write LV Creation host, time jiao virtual machine, 2022 08 05 12:23:08 +0800 LV Status available # open 0 LV Size <7.50 GiB Current LE 1919 Segments 1 Allocation inherit Read ahead sectors auto currently set to 256 Block device 253:0 ``` #### 创建文件系统 ```bash $ sudo mkfs.ext4 /dev/Vol1/lvtest mke2fs 1.41.12 (17 May 2010) Filesystem label OS type: Linux Block size 4096 (log 2) Fragment size 4096 (log 2) Stride 0 blocks, Stripe width 0 blocks 131376 inodes, 525312 blocks 26265 blocks (5.00%) reserved for the super user First data block 0 Maximum filesystem blocks 541065216 17 block groups 32768 blocks per group, 32768 fragments per group 7728 inodes per group Superblock backups stored on blocks: 32768, 98304, 163840, 229376, 294912 Writing inode tables: done Creating journal (16384 blocks): done Writing superblocks and filesystem accounting information: done This filesystem will be automatically checked every 28 mounts or 180 days, whichever comes first.Use tune2fs c or i to override. ``` 挂载 ```bash $ sudo mount /dev/Vol1/lvtest /mnt/my_partition $ $ mount /dev/mapper/vg_server01 lv_root on / type ext4 (rw) [...] /dev/mapper/Vol1 lvtest on /mnt/my_partition type ext4 (rw) $ $ cd /mnt/my_partition $ $ ls al total 24 drwxr xr x. 3 root root 4096 Jun 12 10:22 . drwxr xr x. 3 root root 4096 Jun 11 09:58 .. drwx . 2 root root 16384 Jun 12 10:22 lost+found ``` > **注意**，mkfs.ext4和mount命令中用到的路径都有点奇怪。路径中使用了卷组名和逻辑卷名，而不是物理分区路径。文件系统被挂载之后，就可以访问虚拟目录中的这块新区域了 #### 修改LVM Linux LVM的好处在于能够动态修改文件系统，因此最好有工具能够让你实现这些操作。在Linux有一些工具允许你修改现有的逻辑卷管理配置 也有对应的命令 命令 功能 : : : : vgchange 激活和禁用卷组 vgremove 删除卷组 vgextend 将物理卷加到卷组中 vgreduce 从卷组中删除物理卷 lvextend 增加逻辑卷的大小 lvreduce 减小逻辑卷的大小 > **注:**在手动增加或减小逻辑卷的大小时，要特别小心。逻辑卷中的文件系统需要手动修整来处理大小上的改变。大多数文件系统都包含了能够重新格式化文件系统的命令行程序，比如用于ext2、ext3和ext4文件系统的resize2fs程序"},"/note/Linux/Linux命令行与shell脚本编程大全/2022-8-3-理解Linux的文件权限.html":{"title":"理解Linux的文件权限《Linux命令行与Shell脚本编程大全》","content":" layout: post title: \"理解Linux的文件权限《Linux命令行与Shell脚本编程大全》\" date: 2022 8 3 20:03:08 +0800 tags: 《Linux命令行与Shell脚本编程大全》 Linux # 理解Linux的文件权限 系统要有一套保护文件免受非授权用户浏览修改的机制, 沿用Unix的办法, 允许用户和组根据文件和目录的安全设置来访问 ## Linux的安全性 Linux安全的核心是用户的账户, 每个进入Linux系统的用户都会被分配唯一的用户账户, 用户的权限取决于登陆的时候使用的账户 权限是通过创建用户时候分配的ID来跟踪的, 每个用户的UID是数字, 而在登陆的时候使用的是用户名, 同时关联一个密码 Linux系统使用特定的文件和工具来跟踪和管理系统上的用户账户 ## /etc/passwd文件 专门的文件来将用户的登录名匹配到对应的UID值 ```bash 1 root:x:0:0:root:/root:/bin/bash 2 daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin ``` root >管理员 Linux会为了各种各样的功能创建不同的账户用户, 叫做系统账户, 是系统上运行的各种服务进程访问资源用的特殊账户。所有运行在后台的服务都需要用一个系统用户账户登录到Linux系统上 > 作用: 防止因为某一个用户被攻克导致可以访问所有的文件 Linux为系统账户预留了500以下的UID值, 有些服务甚至要用特定的UID才能正常工作 文件包含的信息如下 + 登录用户名 + 用户密码 + 用户账户的UID（数字形式） + 用户账户的组ID（GID）（数字形式） + 用户账户的文本描述（称为备注字段） + 用户HOME目录的位置 + 用户的默认shell 所有的密码用x代替, 用户的密码被存放在/etc/shadow, 只有特定的程序才可以访问 ### /etc/shadow文件 ```bash jiao:$6$apS9G8HD6duUAyqr$2e81915XsZW02XwXRuyWzo9GVElzwo3kr7X9JUDUlPMDdDCuiJT7mqbV1y6rc1C1EFcF1HeS6dt5dvFUv0Y0/1:19062:0:99999:7::: ``` + 与/etc/passwd文件中的登录名字段对应的登录名 + 加密后的密码 + 自上次修改密码后过去的天数密码（自1970年1月1日开始计算） + 多少天后才能更改密码 + 多少天后必须更改密码 + 密码过期前提前多少天提醒用户更改密码 + 密码过期后多少天禁用用户账户 + 用户账户被禁用的日期（用自1970年1月1日到当天的天数表示） + 预留字段给将来使用 使用shadow密码系统后，Linux系统可以更好地控制用户密码。它可以控制用户多久更改一次密码，以及什么时候禁用该用户账户，如果密码未更新的话 ### 添加新用户 添加新用户的主要工具是useradd。这个命令简单快捷，可以一次性创建新用户账户及设置用户HOME目录结构。 useradd命令使用系统的默认值以及命令行参数来设置用户账户。系统默认值被设置在/etc/default/useradd文件中 ```bash root@jiao virtual machine:~# /usr/sbin/useradd D GROUP 100 HOME /home INACTIVE 1 EXPIRE SHELL /bin/sh SKEL /etc/skel CREATE_MAIL_SPOOL no ``` + 新用户会被添加到GID为100的公共组； + 新用户的HOME目录将会位于/home/loginname； + 新用户账户密码在过期后不会被禁用； + 新用户账户未被设置过期日期； + 新用户账户将bash shell作为默认shell； + 系统会将/etc/skel目录下的内容复制到用户的HOME目录下； + 系统不会为该用户账户在mail目录下创建一个用于接收邮件的文件 /etc/skel文件夹 ```bash root@jiao virtual machine:~# ls /etc/skel al 总用量 28 drwxr xr x 2 root root 4096 10月 13 2021 . drwxr xr x 132 root root 12288 8月 3 20:33 .. rw r r 1 root root 220 10月 7 2021 .bash_logout rw r r 1 root root 3771 10月 7 2021 .bashrc rw r r 1 root root 807 10月 7 2021 .profile ``` ```bash root@jiao virtual machine:~# useradd m test root@jiao virtual machine:~# ls al /home/test/ 总用量 20 drwxr x 2 test test 4096 8月 3 20:47 . drwxr xr x 4 root root 4096 8月 3 20:47 .. rw r r 1 test test 220 10月 7 2021 .bash_logout rw r r 1 test test 3771 10月 7 2021 .bashrc rw r r 1 test test 807 10月 7 2021 .profile ``` > m会创建一个HOME目录 其他命令 参数 描述 : : : : c comment 给新用户添加备注 d home_dir 为主目录指定一个名字（如果不想用登录名作为主目录名的话） e expire_data 用YYYY MM DD格式指定一个账户过期的日期 f inactive_days 指定这个账户密码过期后多少天这个账户被禁用；0表示密码一过期就立即禁用，1表示禁用这个功能 g initial_group 指定用户登录组的GID或组名 G group... 指定用户除登录组之外所属的一个或多个附加组 k 必须和 m一起使用，将/etc/skel目录的内容复制到用户的HOME目录 m 创建用户的HOME目录 M 不创建用户的HOME目录（当默认设置里要求创建时才使用这个选项） n 创建一个与用户登录名同名的新组 r 创建系统账户 p passwd 为用户账户指定默认密码 s shell 指定默认的登录shell u uid 为账户指定唯一的UID 对于默认值的修改, 在`useradd D`之后加上参数 参数 描述 : : : : b default_home 更改默认的创建用户HOME目录的位置 e expiration_date 更改默认的新账户的过期日期 f inactive 更改默认的新用户从密码过期到账户被禁用的天数 g group 更改默认的组名称或GID s shell 更改默认的登录shell ```bash jiao@jiao virtual machine:~$ sudo useradd D s /bin/dash jiao@jiao virtual machine:~$ sudo useradd D GROUP 100 HOME /home INACTIVE 1 EXPIRE SHELL /bin/dash SKEL /etc/skel CREATE_MAIL_SPOOL no ``` ### 删除用户 ```bash userdel 用户名 ``` > 默认情况下只会删除passwd文件中的记录, 不会删除文件 > r: 删除HONE目录以及邮件目录 ### 修改用户 工具 命令 描述 : : : : usermod 修改用户账户的字段，还可以指定主要组以及附加组的所属关系 passwd 修改已有用户的密码 chpasswd 从文件中读取登录名密码对，并更新密码 chage 修改密码的过期日期 chfn 修改用户账户的备注信息 chsh 修改用户账户的默认登录shell #### usermod 可以修改passwd文件中的大部分 参数大部分和useradd一样, 如: c修改备注字段， e修改过期日期， g修改默认的登录组 + l修改用户账户的登录名。 + L锁定账户，使用户无法登录。 + p修改账户的密码。 + U解除锁定，使用户能够登录 #### passwd和chpasswd 只有root可以修改其他人的密码 > e: 强制用户在下一次登陆的时候改密码 chpasswd对大量用户更改密码 chpasswd命令能从标准输入自动读取登录名和密码对（由冒号分割）列表，给密码加密，然后为用户账户设置 可以用重定向命令来将含有userid:passwd对的文件重定向给该命令 ```bash # chpasswd < users.txt ``` #### chsh, chfn, chage 专门用来修改特定的用户信息 > chsh命令用来快速修改默认的用户登录shell。使用时必须用shell的全路径名作为参数 > > ```bash > chsh s /bin/csh test > ``` > chfn命令提供了在/etc/passwd文件的备注字段中存储信息的标准方法, 用于Unix的finger命令的信息存进备注字段 > > ```bash > jiao@jiao virtual machine:~$ sudo chfn test > 正在改变 test 的用户信息 > 请输入新值，或直接敲回车键以使用默认值 > \t全名 []: 较 焦浩洋 > \t房间号码 []: 01 > \t工作电话 []: 18790676335 > \t家庭电话 []: 110 > \t其它 []: 天才 > chfn：名称中有非 ASCII 字符：“焦浩洋” > chfn：“天才”包含非 ASCII 字符 > $ vim /etc/passwd > 49 test:x:1001:1001:焦浩洋,01,18790676335,110,天才:/home/test:/bin/bash > ``` 最后，chage命令用来帮助管理用户账户的有效期 参数 描述 : : : : d 设置上次修改密码到现在的天数 E 设置密码过期的日期 I(大写的i) 设置密码过期到锁定账户的天数 m 设置修改密码之间最少要多少天 W 设置密码过期前多久开始出现提醒信息 > chage命令的日期值可以用下面两种方式中的任意一种： > > YYYY MM DD格式的日期代表从1970年1月1日起到该日期天数的数值 > 过期的账户跟锁定的账户很相似：账户仍然存在，但用户无法用它登录。 ## 使用Linux组 为了处理在共享文件的安全性 组允许多个用户对系统中的队对象, 如文件, 目录或者设备, 共享一组权限 有些Linux发行版会创建一个组，把所有用户都当作这个组的成员。遇到这种情况要特别小心，因为文件很有可能对其他用户也是可读的。有些发行版会为每个用户创建单独的一个组 每个组都有唯一的UID以及组名 ### /etc/group文件 用来保存每一个组的信息 ```bash 1 root:x:0: 2 daemon:x:1: 3 bin:x:2: 4 sys:x:3: ``` + 组名 + 组密码 + GID + 属于该组的用户列表 千万不能通过直接修改/etc/group文件来添加用户到一个组，要用usermod命令（在7.1节中介绍过）。在添加用户到不同的组之前，首先得创建组 > 有些组并没有列出用户。这并不是说这些组没有成员。当一个用户在/etc/passwd文件中指定某个组作为默认组时，用户账户不会作为该组成员再出现在/etc/group文件中 > ```bash > jiao@jiao virtual machine:~$ sudo usermod G test jiao > 76 test:x:1001:jiao > ``` ### gpasswd ```bash sudo gpasswd a jiao test\t\t//添加, 不改变之前的\t sudo gpasswd d jiao test //删除 ``` > 添加一个或删除一个组, 不改变其他的 ### 创建新组 groupadd ```bash jiao@jiao virtual machine:~$ sudo groupadd share jiao@jiao virtual machine:~$ tail /etc/group sambashare:x:134: systemd coredump:x:999: test:x:1001: share:x:1002: ``` 默认没有用户被分配到该组。groupadd命令没有提供将用户添加到组中的选项，但可以用usermod命令来弥补这一点 ```bash jiao@jiao virtual machine:~$ sudo usermod G share jiao jiao@jiao virtual machine:~$ sudo usermod G share test jiao@jiao virtual machine:~$ tail /etc/group systemd coredump:x:999: test:x:1001: share:x:1002:jiao,test ``` > 对于更改登录组的必须重新登录 > 注意区分 g和 G, 前者修改默认组, 后者修改附加组, 但是会导致组的其他的被清空 > > > sudo gpasswd d jiao test: 不清空添加 ### 修改组 ```bash groupmod n 新组名 旧组名 groupmod g 新的GID 旧的 ``` 修改组名时，GID和组成员不会变，只有组名改变。由于所有的安全权限都是基于GID的，你可以随意改变组名而不会影响文件的安全性 ## 理解文件权限 用户是否拥有根权限保存在/etc/sudoers ### 使用文件权限符 ```bash drwxr x 22 jiao jiao 4096 8月 3 23:44 jiao drwxr x 13 test test 4096 8月 3 21:21 test ``` 第一个字段, 目录文件权限 + 代表文件 + d代表目录 + l代表链接 + c代表字符型设备 + b代表块设备 + n代表网络设备 之后有三组字符编码 + r: 可读 + w: 可写 + x: 可执行 没有某一项权限会显示 会有三个安全级别 + 对象的属主 + 对象的属组 + 系统其他用户 ### 默认文件权限 ```bash jiao@jiao virtual machine:~/桌面$ umask 0002 ``` > 显示默认的权限 > > + 第一位代表了**粘着位**特别的安全性 > + 后三位对应umask八进制 > + r 4 w 2 x 1 首先取得权限的八进制, 然后把这三组安全级别输出（属主、属组和其他用户） umask输出的是一个掩码, 会屏蔽掉不想授予的安全等级, 要把umask从对象的全权限之中减去, 对于文件来时是666, 对于目录是777 通常umask的值会设置在`/etc/profile`文件之中, 有一些是设置在`/etc/login.defs`文件中 ```bash jiao@jiao virtual machine:~$ umask 022 jiao@jiao virtual machine:~$ touch test2 jiao@jiao virtual machine:~$ ls la test2 rw r r 1 jiao jiao 0 8月 4 12:40 test2 ``` > 使用命令进行设置默认的权限, 设置的只是本人的 ## 改变安全性 ```bash chmod options mode file ``` > 八进制改变文件的权限 ```bash [ugoa...][[+ ][rwxXstugo...] ``` + u代表用户 + g代表组 + o代表其他 + a代表上述所有 + 在现有权限基础上增加权限（+） + 还是在现有权限基础上移除权限（ ） + 或是将权限设置成后面的值（ ） **除了twx之外的参数** + X：如果对象是目录或者它已有执行权限，赋予执行权限。 + s：运行时重新设置UID或GID。 + t：保留文件或目录。 + u：属主权限设置 + g：属组权限设置 + o：用户权限设置 可以配合使用`o+r`拥有除了其他用户权限之外还有读权限 > R: 让权限递归的传递到文件和子目录 > > 可以使用通配符 ### 改变所属的关系 ```bash chown options owner[.group] file ``` > 可以使用登录名或者UID来指定新的属主 ```bash jiao@jiao virtual machine:~/桌面/linux shell/7$ ls l 总用量 0 rw r r 1 jiao jiao 0 8月 4 14:23 test jiao@jiao virtual machine:~/桌面/linux shell/7$ sudo chown test test\t\t\t\t//更换属主 [sudo] jiao 的密码： jiao@jiao virtual machine:~/桌面/linux shell/7$ ls l 总用量 0 rw r r 1 test jiao 0 8月 4 14:23 test jiao@jiao virtual machine:~/桌面/linux shell/7$ sudo chown test.share test \t//更换属主以及属组 jiao@jiao virtual machine:~/桌面/linux shell/7$ ls l 总用量 0 rw r r 1 test share 0 8月 4 14:23 test jiao@jiao virtual machine:~/桌面/linux shell/7$ sudo chown .jiao test\t\t\t\t//更换属组 jiao@jiao virtual machine:~/桌面/linux shell/7$ ls l 总用量 0 rw r r 1 test jiao 0 8月 4 14:23 test ``` > R: 递归的更改子目录以及文件 > > h: 改变文件所有符号链接文件文件的属性 ```bash jiao@jiao virtual machine:~/桌面/linux shell/7$ sudo chgrp share test jiao@jiao virtual machine:~/桌面/linux shell/7$ ls l 总用量 0 rw r r 1 test share 0 8月 4 14:23 test ``` > 更改组 ## 共享文件 共享文件的方法是创建一个组, 当你创建文件的时候会把你自己的GID和UID交给文件 改变其他用户所在安全组的访问权限，要么就给文件分配一个包含其他用户的新默认属组 Linux还为每个文件和目录存储了3个额外的信息位。 + 设置用户ID（SUID）：当文件被用户使用时，程序会以文件属主的权限运行。 + 设置组ID（SGID）：对文件来说，程序会以文件属组的权限运行；对目录来说，目录中创建的新文件会以目录的默认属组作为默认属组。 + 粘着位：进程结束后文件还驻留（粘着）在内存中 SGID位对文件共享非常重要。启用SGID位后，你可以强制在一个共享目录下创建的新文件都属于该目录的属组，这个组也就成为了每个用户的属组 SGID可通过`chmod`命令设置。它会加到标准3位八进制值之前（组成4位八进制值），或者在符号模式下用符号s。 ```bash jiao@jiao virtual machine:~/桌面/linux shell/7$ mkdir testdir jiao@jiao virtual machine:~/桌面/linux shell/7$ ls l 总用量 8 rw r r 1 jiao jiao 4 8月 4 14:42 test drwxrwxr x 2 jiao jiao 4096 8月 4 15:04 testdir jiao@jiao virtual machine:~/桌面/linux shell/7$ chgrp test testdir jiao@jiao virtual machine:~/桌面/linux shell/7$ chmod g+s testdir \t\t//使用s添加属性 jiao@jiao virtual machine:~/桌面/linux shell/7$ cd testdir jiao@jiao virtual machine:~/桌面/linux shell/7/testdir$ touch t1 jiao@jiao virtual machine:~/桌面/linux shell/7/testdir$ ls l 总用量 0 rw rw r 1 jiao test 0 8月 4 15:05 t1\t\t\t\t\t\t\t //文件的组发生改变 ``` 八进制方式 二进制 八进制 描述 : : : : : : 000 0 所有位都清零 001 1 粘着位置位 010 2 SGID位置位 011 3 SGID位和粘着位都置位 100 4 SUID位置位 101 5 SUID位和粘着位都置位 110 6 SUID位和SGID位都置位 111 7 所有位都置位 ```bash jiao@jiao virtual machine:~/桌面/linux shell/7$ mkdir test2 jiao@jiao virtual machine:~/桌面/linux shell/7$ chown .test test2\t\t\t//改变所属的组 jiao@jiao virtual machine:~/桌面/linux shell/7$ ls l 总用量 12 rw r r 1 jiao jiao 4 8月 4 14:42 test drwxrwxr x 2 jiao test 4096 8月 4 15:12 test2 drwxrwsr x 3 jiao test 4096 8月 4 15:10 testdir jiao@jiao virtual machine:~/桌面/linux shell/7$ chmod 2775 test2\t\t\t//设置组粘连 jiao@jiao virtual machine:~/桌面/linux shell/7$ cd test2 jiao@jiao virtual machine:~/桌面/linux shell/7/test2$ touch t2\t\t jiao@jiao virtual machine:~/桌面/linux shell/7/test2$ ls l 总用量 0 rw rw r 1 jiao test 0 8月 4 15:12 t2 jiao@jiao virtual machine:~/桌面/linux shell/7/test2$ ```"},"/note/Linux/Linux命令行与shell脚本编程大全/2022-8-2-更多命令.html":{"title":"更多bash shell命令《Linux命令行与Shell脚本编程大全》","content":" layout: post title: \"更多bash shell命令《Linux命令行与Shell脚本编程大全》\" date: 2022 8 2 11:29:08 +0800 tags: 《Linux命令行与Shell脚本编程大全》 Linux # 更多命令 Linux的系统管理命令 ## 检测程序 跟踪运行在系统中的程序 ### 探测进程 程序运行在系统之上的时候被称为进程 ```bash ps PID TTY TIME CMD 2753 pts/0 00:00:00 bash 4496 pts/0 00:00:00 ps ``` > 输出系统上所有程序的许多信息, 默认情况下没有那么多的信息, 控制台下属于当前用户的进程 > > 显示了程序进程的ID, 运行的终端: TTY, 已经用的CPU时间 Linux中的GUN ps支持三种不同类型的命令分行参数 + Unix风格 加单破折线 + BSD风格 不加破折线 + GUN风格 双破折线 #### Unix风格 原有的Unix系统上继承而来的 ![QQ图片20220802163459](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259846.png) ![QQ图片20220802163548](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259847.png) **常用:** > ef: 显示所有的进程 > > ```bash > UID PID PPID C STIME TTY TIME CMD > root 1 0 0 12:22 ? 00:00:01 /sbin/init splash > ``` > > + UID：启动这些进程的用户。 > + PID：进程的进程ID。 > + PPID：父进程的进程号（如果该进程是由另一个进程启动的）。 > + C：进程生命周期中的CPU利用率。 > + STIME：进程启动时的系统时间。 > + TTY：进程启动时的终端设备。 > + TIME：运行进程需要的累计CPU时间。 > + CMD：启动的程序名称 > l: 获得更多 > > ```bash > F S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD > 0 S 1000 2753 2727 0 80 0 3713 do_wai pts/0 00:00:00 bash > ``` > > + F：内核分配给进程的系统标记。 > + S：进程的状态（O代表正在运行；S代表在休眠；R代表可运行，正等待运行；Z代表僵化，进程已结束但父进程已不存在；T代表停止）。 > + PRI：进程的优先级（越大的数字代表越低的优先级）。 > + NI：谦让度值用来参与决定优先级。 > + ADDR：进程的内存地址。 > + SZ：假如进程被换出，所需交换空间的大致大小。 > + WCHAN：进程休眠的内核函数的地址。 #### BSD风格 ![QQ图片20220802164612](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259848.png) ![QQ图片20220802164651](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259849.png) 大部分的和Unix的是重合的, 但是在使用的时候会使用不同的格式输出 ```bash $ ps l F UID PID PPID PRI NI VSZ RSS WCHAN STAT TTY TIME COMMAND 4 1000 1088 988 20 0 165480 6104 do_pol Ssl+ tty2 0:00 /usr/libexec/gdm wayland sessi ``` + VSZ：进程在内存中的大小，以千字节（KB）为单位。 + RSS：进程在未换出时占用的物理内存。 + STAT：代表当前进程状态的双字符状态码。可以比Unix的单字节码更加仔细的显示进程的状态, > 第一字节和Unix的一样 > > + O代表正在运行； > + S代表在休眠； > + R代表可运行，正等待运行； > + Z代表僵化，进程已结束但父进程已不存在； > + T代表停止 > 第二字节进一步说明进程的状态 > > + <：该进程运行在高优先级上。 > + N：该进程运行在低优先级上。 > + L：该进程有页面锁定在内存中。 > + s：该进程是控制进程。 > + l：该进程是多线程的。 > + +：该进程运行在前台。 #### GUN长参数 ![QQ图片20220802165734](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259850.png) ![QQ图片20220802165756](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259851.png) ```bash ps forest 1981 ? 00:00:00 sshd 3078 ? 00:00:00 \\_ sshd 3080 ? 00:00:00 \\_ sshd 3081 pts/0 00:00:00 \\_ bash 16676 pts/0 00:00:00 \\_ ps ``` 显示进程之间的层级关系 ### 检测实时进程 ps检测的进程是瞬时的 ```bash $ top top 17:21:22 up 4:58, 1 user, load average: 0.00, 0.00, 0.00 任务: 295 total, 1 running, 294 sleeping, 0 stopped, 0 zombie %Cpu(s): 0.3 us, 0.3 sy, 0.0 ni, 99.3 id, 0.0 wa, 0.0 hi, 0.0 si, 0.0 st MiB Mem : 3889.2 total, 733.1 free, 1354.1 used, 1802.0 buff/cache MiB Swap: 923.2 total, 923.2 free, 0.0 used. 2253.2 avail Mem 进程号 USER PR NI VIRT RES SHR %CPU %MEM TIME+ COMMAND 1186 jiao 20 0 4194532 308732 131592 S 0.7 7.8 0:40.73 gnome shell 1490 jiao 20 0 290508 38508 29908 S 0.3 1.0 0:16.65 vmtoolsd 2727 jiao 20 0 650708 70520 54540 S 0.3 1.8 0:07.45 gnome terminal 1 root 20 0 166048 12312 7668 S 0.0 0.3 0:01.80 systemd 2 root 20 0 0 0 0 S 0.0 0.0 0:00.02 kthreadd ``` > 输出的第一部分显示的是系统的概况：第一行显示了当前时间、系统的运行时间、登录的用户数以及系统的平均负载, 平均负载有三个值, 一分钟, 五分钟, 十五分钟 > 第二行显示了进程概要信息——top命令的输出中将进程叫作任务（task）：有多少进程处在运行、休眠、停止或是僵化状态（僵化状态是指进程完成了，但父进程没有响应）。 > 下一行显示了CPU的概要信息。top根据进程的属主（用户还是系统）和进程的状态（运行、空闲还是等待）将CPU利用率分成几类输出。 > 紧跟其后的两行说明了系统内存的状态。第一行说的是系统的物理内存：总共有多少内存，当前用了多少，还有多少空闲。后一行说的是同样的信息，不过是针对系统交换空间（如果分配了的话）的状态而言的。 > 最后一部分显示了当前运行中的进程的详细列表，有些列跟ps命令的输出类似。 > > + PID：进程的ID。 > + USER：进程属主的名字。 > + PR：进程的优先级。 > + NI：进程的谦让度值。 > + VIRT：进程占用的虚拟内存总量。 > + RES：进程占用的物理内存总量。 > + SHR：进程和其他进程共享的内存总量。 > + S：进程的状态（D代表可中断的休眠状态，R代表在运行状态，S代表休眠状态，T代表跟踪状态或停止状态，Z代表僵化状态）。 > + %CPU：进程使用的CPU时间比例。 > + %MEM：进程使用的内存占可用内存的比例 > + TIME+：自进程启动到目前为止的CPU时间总量。 > + COMMAND：进程所对应的命令行名称，也就是启动的程序名。 ### 结束进程 在Linux之中进程之间通过信号来通讯, 信号就是事先预定好的一个消息, 进程来进行处理, 大多数完善的程序都可以处理标准的Unix信号 信号 名称 描述 : : : : : : 1 HUP 挂起 2 INT 中断 3 QUIT 结束运行 9 KILL 无条件终止 11 SEGV 段错误 15 TERM 尽可能终止 17 STOP 无条件停止运行, 但是不终止 18 TSTP 停止或暂停, 但在后台运行 19 CONT 在STOP和TSTP之后恢复运行 #### kill命令 可以通过进程ID给进程发送信号, 默认为TERM 要发送你必须是进程的属主或者root用户 > s: 支持其他信号 #### killall命令 支持通过进程名来结束, 也支持通配符 > **注:**root用户使用通配符的时候要小心 ## 检测磁盘空间 ### 挂载存储媒体 Linux文件系统将所有的磁盘都并入一个虚拟目录下。在使用新的存储媒体之前，需要把它放到虚拟目录下。这项工作称为**挂载** 大多数的多支持自动挂载特定类型的可移动存储媒体 #### mount命令 默认情况下会输出当前挂载的设备 ```bash jiao@jiao virtual machine:~/桌面/linux shell/3$ mount sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime) proc on /proc type proc (rw,nosuid,nodev,noexec,relatime) ``` 提示信息: + 媒体的设备文件名 + 媒体挂载到虚拟目录的挂载点 + 文件系统类型 + 已挂载媒体的访问状态 挂载命令 ```bash mount t type device directory ``` > 管理员权限 > > type: 格式化的文件系统类型 > > + vfat：Windows长文件系统, 大部分的U盘和软盘 > + ntfs：Windows NT、XP、Vista以及Windows 7中广泛使用的高级文件系统。 > + iso9660：标准CD ROM文件系统。 `mount t vfat /dev/sdb1 /media/disk`: 把U盘`/dev/sdb1`挂载到`/media/disk` 常用命令 参数 描述 : : : : a 挂载/etc/fstab文件中指定的所有文件系统 f 使mount命令模拟挂载设备，但并不真的挂载 F 和 a参数一起使用时，会同时挂载所有文件系统 v 详细模式，将会说明挂载设备的每一步 I(大写的i) 不启用任何/sbin/mount.filesystem下的文件系统帮助文件 l(小写的L) 给ext2、ext3或XFS文件系统自动添加文件系统标签 n 挂载设备，但不注册到/etc/mtab已挂载设备文件中 p num 进行加密挂载时，从文件描述符num中获得密码短语 s 忽略该文件系统不支持的挂载选项 r 将设备挂载为只读的 w 将设备挂载为可读写的（默认参数） L label 将设备按指定的label挂载 U uuid 将设备按指定的uuid挂载 O 和 a参数一起使用，限制命令只作用到特定的一组文件系统上 o 给文件系统添加特定的选项 o参数允许在挂载文件系统时添加一些以逗号分隔的额外选项。以下为常用的选项。 + ro：以只读形式挂载。 + rw：以读写形式挂载。 + user：允许普通用户挂载文件系统。 + check none：挂载文件系统时不进行完整性校验。 + loop：挂载一个文件。 #### umount 从Linux上删除一个设备, 不能直接从系统上移除, 应该先卸载 ```bash umount [directory device ] ``` > umount命令支持通过设备文件或者是挂载点来指定要卸载的设备。如果有任何程序正在使用设备上的文件，系统就不会允许你卸载它 > > 可以使用lsof命令查看谁在使用: `lsof /path/to/device/node` `lsof /path/to/mount/point` > > ### df命令 检查设备还有多少磁盘空间 ```bash jiao@jiao virtual machine:~/桌面/linux shell/3$ df 文件系统 1K 块 已用 可用 已用% 挂载点 tmpfs 398260 2036 396224 1% /run /dev/sda3 19946096 16341272 2566284 87% / tmpfs 1991288 0 1991288 0% /dev/shm tmpfs 5120 4 5116 1% /run/lock ``` + 设备的设备文件位置； + 能容纳多少个1024字节大小的块； + 已用了多少个1024字节大小的块； + 还有多少个1024字节大小的块可用； + 已用空间所占的比例； + 设备挂载到了哪个挂载点上。 常用的参数 > h: 使用用户便于理解的方式显示 ### du命令 发现存储的空间快要使用完了, 可以使用du命令来查看某一个特定的目录, 默认情况下是当前目录 ```bash jiao@jiao virtual machine:~/桌面/linux shell$ du 4\t./3/abb 20\t./3 8\t./1 32\t. ``` 左侧的是文件或者目录占用的目录的磁盘块数, 这个列表是从目录底层开始, 然后按文件, 子目录, 目录逐级向上 > c: 显示已经列出的文件的总大小 > h: 用户易读的格式输出 > s: 只显示每个输出参数总计 > max depth : 设置计算文件的层数 ## 处理数据文件 ### 排序数据 处理大量数据的时候, 使用sort, 按照默认的语言排序规则对文本文件进行排序 一般情况会把数字当做字符进行排序 > n: 把数字识别为数字而不是字符串 > M: 按照月份排序 单破折号 双破折号 描述 : : : : : : b ignore leading blanks 排序时忽略起始的空白 C check quiet 不排序，如果数据无序也不要报告 c check 不排序，但检查输入数据是不是已排序；未排序的话，报告 d dictionary order 仅考虑空白和字母，不考虑特殊字符 f ignore case 默认情况下，会将大写字母排在前面；这个参数会忽略大小写 g general number sort 按通用数值来排序（跟 n不同，把值当浮点数来排序，支持科学计数法表示的值） i ignore nonprinting 在排序时忽略不可打印字符 k key POS1[,POS2] 排序从POS1位置开始；如果指定了POS2的话，到POS2位置结束 M month sort 用三字符月份名按月份排序 m merge 将两个已排序数据文件合并 n numeric sort 按字符串数值来排序（并不转换为浮点数） o output file 将排序结果写出到指定的文件中 R random sort 或 random source FILE 按随机生成的散列表的键值排序 r reverse 反序排序（升序变成降序） S buffer size SIZE 指定使用的内存大小 s stable 禁用最后重排序比较 T temporary directory DIR 指定一个位置来存储临时工作文件 t field separator SEP 指定一个用来区分键位置的字符 u unique 和 c参数一起使用时，检查严格排序；不和 c参数一起用时，仅输出第一例相似的两行 z zero terminated 用NULL字符作为行尾，而不是用换行符 > t 和 k: 对字段进行分割然后排序 > > `sort t ':' k 3 n /etc/passwd` > > 按照:进行分割, 对第三项进行排列 > r: 降序排列 > > `du sh * sort nr` > 认为大写字母大于小写字母 ### 搜索数据 ```bash grep [options] pattern [file] ``` > 在指定的文件中查找, 返回的是包含传入的字符串的行 > v: 反向输入 > n: 显示行号 > c: 输出有多少各行包括有 > e: 指定多个匹配` grep e t e f file1 ` > 可以使用正则表达式 + egrep支持POSIX扩展的正则表达式 + fgrep支持将匹配模式指定为用换行符分隔的一列固定长度的字符串。这样就可以把这列字符串放到一个文件中，然后在fgrep命令中用其在一个大型文件中搜索字符串了 ### 压缩数据 Linux集成了多种压缩工具 工具 文件扩展名 描述 : : : : : : bzip2 .bz2 采用Burrows Wheeler块排序文本压缩算法和霍夫曼编码 compress .Z 最初的Unix文件压缩工具，已经快没人用了 gzip .gz GNU压缩工具，用Lempel Ziv编码 zip .zip Windows上PKZIP工具的Unix实现 > compress文件压缩工具已经很少在Linux系统上看到了。如果下载了带.Z扩展名的文件，通常可以用第9章中介绍的软件包安装方法来安装compress包(在很多Linux发行版上叫作ncompress), 再用uncompress命令来解压文件 gzip是Linux上最流行的压缩工具 + gzip: 压缩文件 + gzcat:查看压缩过的文本文件 + gunzip: 解压 ```bash gzip 文件名 ``` > 最文件进行压缩, 可以使用通配符批量操作, 但是只能处理单个文件 ### 归档数据 最常用的归档工具是tar ```bash tar function [options] object1 object2 ... ``` > function: 定义了tar命令应该做什么 功能 长名称 描述 : : : : : : A concatenate 将一个已有tar归档文件追加到另一个已有tar归档文件 c create 创建一个新的tar归档文件 d diff 检查归档文件和文件系统的不同之处 r append 从已有tar归档文件中删除 t list 追加文件到已有tar归档文件末尾 u update 列出已有tar归档文件的内容 x extract 将tar归档文件中已有的同名文件新的文件追加到该tar归档文件中 delete 从已有tar归档文件中提取文件 命令选项; 选项 描述 : : : : C dir 切换到指定目录 f file 输出结果到文件或设备file j 将输出重定向给bzip2命令来压缩内容 p 保留所有文件权限 v 在处理文件时显示文件 z 将输出重定向给gzip命令来压缩内容 > `tar cvf test.tar test/ test2/`创建了名为test.tar的归档文件，含有test和test2目录内容 > `tar tf test.tar`列出tar文件test.tar的内容 > `tar xvf test.tar`通过这一命令从tar文件test.tar中提取内容 > > 下载了开源软件之后，你会经常看到文件名以.tgz结尾。这些是gzip压缩过的tar文件可以用命令tar zxvf filename.tgz来解压 ## xargs命令 会把管道输入的参数作为函数的参数来使用, kill和rm等命令不可以使用管道直接输入可以使用这个命令 > d: 设置分隔符 > > p: 输出是否要立即执行的提示 > > n: 每次传递的个数"},"/note/Linux/Linux命令行与shell脚本编程大全/2022-8-8-创建函数.html":{"title":"创建函数《Linux命令行与Shell脚本编程大全》","content":" layout: post title: \"创建函数《Linux命令行与Shell脚本编程大全》\" date: 2022 8 7 15:39:08 +0800 tags: 《Linux命令行与Shell脚本编程大全》 Linux # 创建函数 ## 基本的脚本函数 ### 创建函数 有两种格式 ```bash function name { \tcommands } ``` > 注意空格 ```bash name() { \tcommands } ``` ### 使用函数 要使用函数直接指定函数名就可以了 ```bash 1 #!/bin/bash 2 3 function func1 { 4 echo \"This is an example of an function\" 5 } 6 count 1 7 while [ $count le 5 ] 8 do 9 func1 10 count $[ $count+1 ] 11 done 12 13 echo \"This is the end of the loop\" 14 func1 15 echo \"This is the end of the scrip\" jiao@jiao virtual machine:~/桌面/linux shell/17$ test1.sh This is an example of an function This is an example of an function This is an example of an function This is an example of an function This is an example of an function This is the end of the loop This is an example of an function This is the end of the scrip ``` 函数名必须是唯一的，否则也会有问题。如果你重定义了函数，新定义会覆盖原来函数的定义，这一切不会产生任何错误消息 ## 返回值 bash shell 会把函数当成一个小的脚本, 运行结束返回退出状态码 ### 默认退出状态码 默认情况下，函数的退出状态码是函数中最后一条命令返回的退出状态码。在函数执行结束后，可以用标准变量$?来确定函数的退出状态码 函数中的其他命令出现错误没有体现 ### 使用return命令 l使用return命令来退出函数并返回特定的退出状态码 + 函数一结束就取返回值； + 退出状态码必须是0~255 ### 使用函数输出 把要输出的值放在变量中 ```bash result 'dbl' ``` 新函数会用echo语句来显示计算的结果。该脚本会获取dbl函数的输出，而不是查看退出状态码 bash shell脚本非常聪明，并不将其作为STDOUT输出的一部分，并且忽略掉它。如果你用echo语句生成这条消息来向用户查询，那么它会与输出值一起被读进shell变量中 > 可以通过这种方法返回各种值 ```bash 1 #!/bin/bash 2 3 function db1 { 4 read p \"Enter a value: \" value 5 echo \"value is $[ value * 2 ]\" 6 } 7 result $(db1) 8 echo \"The new $result\" jiao@jiao virtual machine:~/桌面/linux shell/17$ test4.sh Enter a value: 34 The new value is 68 ``` ## 在函数中使用变量 ### 向函数传递参数 可以吧函数当做小型的脚本, 可以直接传递参数 ```bash func1 $value1 10 ``` ```bash 1 #!/bin/bash 2 3 function addem { 4 if [ $# eq 0 ] [ $# gt 2 ] 5 then 6 echo 1 7 elif [ $# eq 1 ] 8 then 9 echo $[ $1+$1 ] 10 else 11 echo $[ $1 + $2 ] 12 fi 13 14 } 15 16 echo n \"Add 10 and 15: \" 17 value $(addem 10 15) 18 echo $value 19 echo n \"Let's try adding just one number: \" 20 value $(addem 10) 21 echo $value 22 echo n \"Now trying adding no numbers: \" 23 value $(addem) 24 echo $value 25 echo n \"Finally, try adding three numbers: \" 26 value $(addem 10 15 20) 27 echo $value jiao@jiao virtual machine:~/桌面/linux shell/17$ test5.sh Add 10 and 15: 25 Let's try adding just one number: 20 Now trying adding no numbers: 1 Finally, try adding three numbers: 1 ``` > 由于函数使用特殊参数环境变量作为自己的参数值，因此它无法直接获取脚本在命令行中的参数值, 它们和脚本主体中的$1和$2变量并不相同。 ### 在函数中处理变量 函数使用两种类型的变量： + 全局变量 + 局部变量 #### 全局变量 默认情况下, 在脚本中定义的变量都是全局变量, 函数外定义的变量都可以在函数中正常访问 ```bash 1 #!/bin/bash 2 3 function db1 { 4 value $[ $value*2 ] 5 } 6 read p \"Enter a value: \" value 7 db1 8 echo \"The new value is : $value\" jiao@jiao virtual machine:~/桌面/linux shell/17$ myts.sh test6.sh Enter a value: 45 The new value is : 90 ``` #### 局部变量 在变量之前加上local, 一般是在函数内使用 ## 数组变量和函数 ### 向函数传递数组变量 + 错误示范 ```bash 1 #!/bin/bash 2 3 function testit { 4 echo \"The parameters are: $@\" 5 thisarray $1 6 echo \"The receive array is ${thisarray[*]}\" 7 8 } 9 myarray (1 2 3 4 5) 10 echo \"The original array is: ${myarray[*]}\" 11 testit $myarray 12 echo $myarray jiao@jiao virtual machine:~/桌面/linux shell/17$ myts.sh test7.sh The original array is: 1 2 3 4 5 The parameters are: 1 The receive array is 1 1 ``` > 传递的只是第一个参数 ```bash 1 #!/bin/bash 2 3 function testit { 4 local newarray 5 newarray $( echo \"$@\" ) 6 echo \"The new array value is: ${newarray[*]}\" 7 } 8 myarray (1 2 3 4 5) 9 echo \"The original array is: ${myarray[*]}\" 10 testit ${myarray[*]} jiao@jiao virtual machine:~/桌面/linux shell/17$ test7.sh The original array is: 1 2 3 4 5 The new array value is: 1 2 3 4 5 ``` ### 从函数返回数组 函数用echo语句来按正确顺序输出单个数组值，然后脚本再将它们重新放进一个新的数组变量中 ```bash 1 #!/bin/bash 2 3 function arrayblr { 4 local origarray 5 local newarray 6 local elements 7 local i 8 origarray ($(echo \"$@\")) 9 newarray ($(echo \"$@\")) 10 elements $[ $# 1 ] 11 for ((i 0 ; i< elements; i++)) 12 { 13 newarray[$i] $[ ${origarray[$i]} * 2 ] 14 } 15 echo ${newarray[*]} 16 } 17 myarray (1 2 3 4 5) 18 echo \"The original array is: ${myarray[*]}\" 19 arg1 $(echo ${myarray[*]}) 20 result ($(arrayblr $arg1)) 21 echo \"The new array is: ${result[*]}\" jiao@jiao virtual machine:~/桌面/linux shell/17$ test8.sh The original array is: 1 2 3 4 5 The new array is: 2 4 6 8 10 ``` ## 函数递归 ```bash 1 #!/bin/bash 2 function factorial { 3 if [ $1 eq 1 ] 4 then 5 echo 1 6 else 7 local temp $[ $1 1 ] 8 local result ` factorial $temp ` 9 echo $[ $result * $1 ] 10 fi 11 } 12 13 read p \"Enter your value: \" value 14 result $(factorial $value ) 15 echo $result ``` ## 创建库 source命令会在当前shell上下文中执行命令，而不是创建一个新shell。可以用source命令来在shell脚本中运行库文件脚本。 source命令有个快捷的别名，称作点操作符（dot operator）。要在shell脚本中运行myfuncs库文件，只需添加下面这行： ```bash . ./myfuncs ``` ```bash 1 #/bin/bash 2 . ./myfunc 3 value1 10 4 value2 5 5 result1 $(addem $value1 $value2) 6 result2 $(multem $value1 $value2) 7 result3 $(diven $value1 $value2) 8 echo $result1 9 echo $result2 10 echo $result3 jiao@jiao virtual machine:~/桌面/linux shell/17$ test11.sh 15 50 2 ``` ## 在命令行上使用函数 因为一旦在shell中定义了函数，你就可以在整个系统中使用它了，无需担心脚本是不是在PATH环境变量里。重点在于让shell能够识别这些函数。有几种方法可以实现 ### 在命令行上创建函数 因为shell会解释用户输入的命令，所以可以在命令行上直接定义一个函数。有两种方法。一种方法是采用单行方式定义函数 ```bash jiao@jiao virtual machine:~/桌面/linux shell/17$ function divem { echo $[ $1 / $2 ]; } jiao@jiao virtual machine:~/桌面/linux shell/17$ divem 8 4 2 ``` > 当在命令行上定义函数时，你必须记得在每个命令后面加个分号，这样shell就能知道在哪里是命令的起止了。 另一种方法是采用多行方式来定义函数。在定义时，bash shell会使用次提示符来提示输入更多命令。用这种方法，你不用在每条命令的末尾放一个分号，只要按下回车键就行 ```bash jiao@jiao virtual machine:~/桌面/linux shell/17$ function multem { > echo $[ $1 * $2 ] > } jiao@jiao virtual machine:~/桌面/linux shell/17$ multem 5 4 20 ``` > 在命令行上创建函数时要特别小心。如果你给函数起了个跟内建命令或另一个命令相同的名字，函数将会覆盖原来的命令 ### 在.bashrc文件中定义函数 + 直接定义函数 + 读取函数文件 更好的是，shell还会将定义好的函数传给子shell进程，这样一来，这些函数就自动能够用于该shell会话中的任何shell脚本了 ## 实例 你可以下载大量各式各样的函数，并将其用于自己的应用程序中 使用GNU shtool库下载并安装到你的系统中 ```bash wget ftp://ftp.gnu.org/gnu/shtool/shtool 2.0.8.tar.gz tar zxvf shtool 2.0.8.tar.gz ``` ### 库函数 函数 描述 : : : : Arx 创建归档文件(包含一些扩展功能) Echo 显示字符串，并提供了一些扩展构件 fixperm 改变目录树中的文件权限 install 安装脚本或文件 mdate 显示文件或目录的修改时间 mkdir 创建一个或更多目录 Mkln 使用相对路径创建链接 mkshadow 创建一棵阴影树 move 带有替换功能的文件移动 Path 处理程序路径 platform 显示平台标识 Prop 显示一个带有动画效果的进度条 rotate 转置日志文件 Scpp 共享的C预处理器 Slo 根据库的类别，分离链接器选项 Subst 使用sed的替换操作 Table 以表格的形式显示由字段分隔（field separated）的数据 tarball 从文件和目录中创建tar文件 version 创建版本信息文件 ```bash jiao@jiao virtual machine:~/shtool 2.0.8$ test12.sh shtool prop p \"Waiting...\" Waiting... ``` > 会显示一个简单的动画, 并且不输出原来的内容, 输出定义的内容 能看到多少进度条取决于CPU能以多快的速度列出/usr/bin中的文件！ p选项允许你定制输出文本，这段文本会出现在进度条字符之前 ```bash jiao@jiao virtual machine:~/shtool 2.0.8$ shtool platform Ubuntu 21.10 (AMD64) ```"},"/note/Linux/Linux命令行与shell脚本编程大全/2022-8-5-使用编辑器.html":{"title":"使用编辑器《Linux命令行与Shell脚本编程大全》","content":" layout: post title: \"使用编辑器《Linux命令行与Shell脚本编程大全》\" date: 2022 8 5 15:52:08 +0800 tags: 《Linux命令行与Shell脚本编程大全》 Linux # 使用编辑器 <u>我使用vim, 其他的编辑器大部分跳过了</u> ## vim编辑器 vi编辑器是Unix最早的编辑器, vim是他的升级版 ### 检查vim软件包 有些Linux安装的是vim完整版还有一个vi的别名 Ubuntu发行版中没有这个别名, 而且拥有vi ```bash jiao@jiao virtual machine:~/桌面$ which vi /usr/bin/vi jiao@jiao virtual machine:~/桌面$ ls l /usr/bin/vi lrwxrwxrwx 1 root root 20 3月 11 21:38 /usr/bin/vi > /etc/alternatives/vi jiao@jiao virtual machine:~/桌面$ ls l /etc/alternatives/vi lrwxrwxrwx 1 root root 18 3月 13 19:31 /etc/alternatives/vi > /usr/bin/vim.basic jiao@jiao virtual machine:~/桌面$ ls l /usr/bin/vim.basic rwxr xr x 1 root root 3491928 12月 18 2021 /usr/bin/vim.basic ``` > 可以使用readlink f查找最后一项 ```bash jiao@jiao virtual machine:~/桌面$ readlink f /usr/bin/vi /usr/bin/vim.basic jiao@jiao virtual machine:~/桌面$ readlink f /usr/bin/vim /usr/bin/vim.basic ``` > 安装之后会指向一样的文件 ### vim基础 [vim文本编译器 (xusenfeng.github.io)](https://xusenfeng.github.io/2022/07/vim/) #### 移动命令 + h：左移一个字符。 + j：下移一行（文本中的下一行）。 + k：上移一行（文本中的上一行）。 + l：右移一个字符。 高速移动 + PageDown（或Ctrl+F）：下翻一屏。 + PageUp（或Ctrl+B）：上翻一屏。 + G：移到缓冲区的最后一行。 + num G：移动到缓冲区中的第num行。 + gg：移到缓冲区的第一行。 #### 其他 + q：如果未修改缓冲区数据，退出。 + q!：取消所有对缓冲区数据的修改并退出。 + w filename：将文件保存到另一个文件中。 + wq：将缓冲区数据保存到文件中并退出 ### 编辑数据 + x: 删除当前光标所在位置的字符 + dd: 删除当前光标所在行 + dw: 删除当前光标所在位置的单词 + d$: 删除当前光标所在位置至行尾的内容 + J: 删除当前光标所在行行尾的换行符（拼接行） + u:撤销前一编辑命令 + a:在当前光标后追加数据 + A:在当前光标所在行行尾追加数据 + r char: 用char替换当前光标所在位置的单个字符 + R text: 用text覆盖当前光标所在位置的数据，直到按下ESC键 ### 复制粘贴 > 使用d命令删除的相当于剪切 > y复制, 可以使用和d一样的参数 > p: 粘贴 > v: 可视模式, 进行选择, y复制p粘贴 ### 查找替换 > 查找:斜杠/然后输入要查找的文字回车 > > n: 下一个, 或者只输入一个/回车 > 替换:`:s/old/new/`替换第一个 > > `:s/old/new/g`: 替换所有 > > `:n,ms/old/new/g`:替换第n行和第m行之间的文本 > > `:%s/old/new/g`：替换整个文件中的所有old > > `:%s/old/new/gc：`替换整个文件中的所有old，但在每次出现时提示 ## nano编辑器 比较简单, 是Unix的克隆版, 因为他没有GPL协议 脱字符（^）表示Ctrl键。因此，^X表示的就是组合键Ctrl+X + CTRL+C 显示光标在文本编辑缓冲区中的位置 + CTRL+G 显示nano的主帮助窗口 + CTRL+J 调整当前文本段落 + CTRL+K 剪切文本行，并将其保存在剪切缓冲区 + CTRL+O 将当前文本编辑缓冲区的内容写入文件 + CTRL+R 将文件读入当前文本编辑缓冲区 + CTRL+T 启动可用的拼写检查器 + CTRL+U 将剪切缓冲区中的内容放入当前行 + CTRL+V 翻动到文本编辑缓冲区中的下一页内容 + CTRL+W 在文本编辑缓冲区中搜索单词或短语 + CTRL+X 关闭当前文本编辑缓冲区，退出nano，返回shell + CTRL+Y 翻动到文本编辑缓冲区中的上一页内容 ## emasc编辑器 早期是控制台编辑器, 后来迁移到图形界面, 依旧提供最早的命令行编辑器 一般不自动安装 emacs编辑器使用包括控制键（PC键盘上的Ctrl键）和Meta键的按键组合。在大多数终端仿真器中，Meta键被映射到了Alt键。emacs官方文档将Ctrl键缩写为C ，而Meta键缩写为M ## KDE系列编辑器 + Kwrite: 单屏幕文本编辑程序 + Kate: 功能全面的多窗口文本编辑程序 ### Kwrite编辑器 图形界面, 高亮, 代码折叠等 ### kate编辑器 软件包的名字是kdesdk 分屏, 保存之前打开的文件地址 ## GNOME编辑器 ### 启动gedit"},"/note/Linux/野火Linux/2025-9-17-23-iomux节点(应用).html":{"title":"iomux应用","content":"# iomux应用 ## pinctrl子系统实验：RGB灯引脚初始化 #### platform设备引脚初始化 注册平台设备或者平台驱动, 实际执行的函数是really_probe这个函数, 在这里面在实际调用我们的prob函数之前已经对**引脚初始化过了** #### really_probe()函数 drivers/base/dd.c ```c static int really_probe(struct device *dev, struct device_driver *drv) { \tint ret EPROBE_DEFER; ... re_probe: \tdev >driver drv; \t// 这里进行引脚的初始化 \tret pinctrl_bind_pins(dev); ... \tif (dev >bus >probe) { \t\tret dev >bus >probe(dev); \t\tif (ret) \t\t\tgoto probe_failed; \t} else if (drv >probe) { \t\tret drv >probe(dev); // 这个是平台驱动里面的prob指针 \t\tif (ret) \t\t\tgoto probe_failed; \t} ... \t} ``` #### pinctrl_bind_pins()函数 drivers/base/pinctrl.c ```c int pinctrl_bind_pins(struct device *dev) { \tint ret; ... \tdev >pins devm_kzalloc(dev, sizeof(*(dev >pins)), GFP_KERNEL); \tif (!dev >pins) \t\treturn ENOMEM; ... // 查找一下default状态 \tdev >pins >default_state pinctrl_lookup_state(dev >pins >p,PINCTRL_STATE_DEFAULT); \tif (IS_ERR(dev >pins >default_state)) { \t\tdev_dbg(dev, \"no default pinctrl state\\n\"); \t\tret 0; \t\tgoto cleanup_get; \t} \tdev >pins >init_state pinctrl_lookup_state(dev >pins >p,PINCTRL_STATE_INIT); \tif (IS_ERR(dev >pins >init_state)) { \t\t/* Not supplying this state is perfectly legal */ \t\tdev_dbg(dev, \"no init pinctrl state\\n\"); \t\t// 如果获取到init状态, 设置为默认的default状态 \t\tret pinctrl_select_state(dev >pins >p, \t\t\t\t\t dev >pins >default_state); \t} else { \t\tret pinctrl_select_state(dev >pins >p, dev >pins >init_state); \t} \t... } ``` #### RGB灯引脚状态初始化 ##### iomuxc节点添加引脚配置信息 ```json pinctrl_rgb_led:rgb_led{ fsl,pins < MX6UL_PAD_GPIO1_IO04__GPIO1_IO04 0x000010B1 MX6UL_PAD_CSI_HSYNC__GPIO4_IO20 0x000010B1 MX6UL_PAD_CSI_VSYNC__GPIO4_IO19 0x000010B1 >; }; ``` ##### rgb_led节点添加引脚状态 ```c pinctrl names \"default\"; pinctrl 0 <&pinctrl_rgb_led>; ```"},"/note/Linux/野火Linux/2025-9-17-25-并发硬件同步原语.html":{"title":"","content":"## 硬件同步原语 #### 并发的根源 多线程、多进程调度 各种中断 #### 并发对程序的不良影响 篡改共享数据 动作不完整 同步、死锁、数据竞争、系统调度开销... #### 硬件同步原语 由计算机硬件提供的一组原子操作，具有不可分割性，避免并行运算执行错误。 #### 案例 ```c //C语言代码 进程一：i 10 进程二：i 20 //汇编代码 进程一： ldr r0, 0X30000000 /* i 变量的内存地址 */ ldr r1, 10 /* 要写入的值 */ str r1, [r0] /* 将 10 写入到 i 变量中 */ 进程二： ldr r0, 0X30000000 /* i 变量的内存地址 */ ldr r1, 20 /* 要写入的值 */ str r1, [r0] /* 将 10 写入到 i 变量中 */ ``` #### 原子整型操作接口 ![image 20251109230746286](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251109230746286.png) ##### 原子整型变量 ```c typedef struct { int counter; } atomic_t; ``` ##### ATOMIC_INIT() 定义整型原子变量并设置初始值 ```c atomic_t data ATOMIC_INIT(int i) ``` ##### atomic_set() 用于设置整型原子变量的值 ```c atomic_set(atomic_t *v,int i) ``` ##### atomic_read() 获取原子变量的值 ```c atomic_read(atomic_t *v) ``` ##### atomic_add()/atomic_sub() 整型原子变量的加/减 ```c static inline void atomic_add(int i, atomic_t *v) //整型原子变量加i static inline void atomic_sub(int i, atomic_t *v) //整型原子变量减i ``` ##### atomic_inc()/atomic_dec() 整型原子变量自增/自减 ```c static inline void atomic_inc(atomic_t *v) //整型原子变量自增1 static inline void atomic_dec(atomic_t *v)//整型原子变量自减1 ``` #### 位原子操作函数 ![image 20251109230728218](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251109230728218.png) ##### set_bit() 将某一位置1 ```c set_bit(int nr, unsigned long *addr) ``` ##### clear_bit() 将某一位置0 ```c clear_bit(int nr, unsigned long *addr) ``` ##### change_bit() 反转某一位的值 ```c int test_bit(int nr, unsigned long \\*addr) ``` ## 实际使用 ```c static atomic_t test_atomic ATOMIC_INIT(1); /*字符设备操作函数集，open函数*/ static int led_chr_dev_open(struct inode *inode, struct file *filp) { \tif(atomic_read(&test_atomic)) \t{ \t\tatomic_set(&test_atomic,0); \t} else { \t\tprintk(\"\\n driver on using! open failed !!!\\n\"); \t\treturn EBUSY; } \tprintk(\"\\n open form driver \\n\"); \treturn 0; } static int led_chrdev_release(struct inode *inode, struct file *filp) { atomic_set(&test_atomic,1); \tprintk(\"KERN_ALERT \\n finished !!!\\n\"); \treturn 0; } ``` ```c #include <stdio.h> #include <unistd.h> #include <fcntl.h> #include <string.h> int main(int argc, char *argv[]) { /*判断输入的命令是否合法*/ if(argc ! 2) { printf(\" commend error ! \\n\"); return 1; } /*打开文件*/ int fd open(\"/dev/rgb_led\", O_RDWR); if(fd < 0) { \t\tprintf(\"\\n open file : /dev/rgb_led failed !!!\\n\"); \t\treturn 1; \t} /*写入命令*/ int error write(fd,argv[1],sizeof(argv[1])); if(error < 0) { printf(\"write file error! \\n\"); close(fd); /*判断是否关闭成功*/ } sleep(10); //休眠10秒 /*关闭文件*/ error close(fd); if(error < 0) { printf(\"close file error! \\n\"); } return 0; } ``` ## 自旋锁 ![image 20251109230831252](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251109230831252.png)![image 20251109231005523](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251109231005523.png)![image 20251109231243851](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251109231243851.png) 在实际使用的时候, 中断里面尝试获取自旋锁会出现问题, 所以实际的应用的时候可可以关闭中断, 还有针对于下半部的关闭函数 在实际应用的时候有一个情况是可以多个进行读取, 但是只有一个可以改, 延伸出来读写锁 ![image 20251109231649061](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251109231649061.png)![image 20251109231711601](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251109231711601.png) 顺序锁在读写锁的基础上衍生而来的，使用读写锁的时候读操作和写操作不能同时进行。使用顺序锁的话可以允许在写的时候进行读操作，也就是实现同时读写，但是不允许同时进行并发的写操作。 但是如果在读的过程中发生了写操作，最好重新进行读取，保证数据完整性。顺序锁保护的资源不能是指针，因为如果在写操作的时候可能会导致指针无效 ![image 20251109232007083](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251109232007083.png)![image 20251109232026756](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251109232026756.png) #### 原子操作 简单易用 只能作计数操作，保护的东西太少 #### 自旋锁 主要用于多核处理器, 短时间轻量级的等待, 被自旋锁保护的临界区一定不能调用任何能够引起睡眠和阻塞的 API 函数 短时期的轻量级加锁 加锁失败时，原地打转、忙等待 避免上下文调度、系统开销较小 **加锁步骤**： 1. 查看锁的状态，如果锁是空闲的 2. 将锁设置为当前线程持有 ##### 存在问题 在没有 **CAS 函数**前，多个线程同时执行这 2 个步骤是会出错的。 ##### 解决方案 CAS 函数把这 2 个步骤**合并为一条硬件级指令**。这样第 1 步比较锁状态和第 2 步锁变量赋值，将变为不可分割的原子指令(硬件同步原语) #### CAS 函数 自旋锁使用CPU 提供的 CAS 函数（Compare And Swap），在用户态代码中完成加锁与解锁操作 #### PAUSE 指令 自旋锁并不一直\"忙等待\"，会与 CPU紧密配合 ，它通过 CPU 提供的 PAUSE 指令，**减少循环等待时的耗电量**；对于单核CPU，忙等待并没有意义，此时它会主动把线程休眠。 #### 自旋锁原理 设自旋锁为变量 lock，整数 0 表示锁是空闲状态，整数 pid 表示线程 ID CAS(lock, 0, pid) 就表示自旋锁的**加锁**操作 CAS(lock, pid,0) 则表示自旋锁的**解锁**操作 ##### 自旋锁伪代码 ```c while (true) { //因为判断lock变量的值比CAS操作更快，所以先判断lock再调用CAS效率更高 if (lock 0 && CAS(lock, 0, pid) 1) return; if (CPU_count > 1 ) { //如果是多核CPU，“忙等待”才有意义 for (n 1; n < 2048; n << 1) { //pause的时间，应当越来越长 for (i 0; i < n; i++) pause();//CPU专为自旋锁设计了pause指令 if (lock 0 && CAS(lock, 0, pid)) return;//pause后再尝试获取锁 } } sched_yield();//单核CPU，或者长时间不能获取到锁，应主动休眠，让出CPU } ``` #### 自旋锁相关API ##### 定义自旋锁 ```c spinlock_t s_lock ; ``` ##### 初始化自旋锁 ```c int spin_lock_init(spinlock_t *lock); ``` ##### 获取自旋锁函数 ```c void spin_lock(spinlock_t *lock) ``` > 这个函数在尝试的时候会进行忙等待 ##### 尝试获取自旋锁函数 ````c int spin_trylock(spinlock_t *lock) ```` > 尝试获取一次，获取成功返回“true”,获取失败返回“false”。程序继续往下执行 ##### 释放自旋锁 ```c void spin_unlock(spinlock_t *lock) ``` ## 信号量 ![image 20251109232105762](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251109232105762.png) #### 本质 计数器，用来控制对公共资源的访问, 不可以使用在中断里面, 因为会进入休眠 #### 特点 长时期的资源占用 获取信号量失败，触发上下文调度 当前进程(线程)陷入休眠，系统开销大 #### 信号量相关API ##### 定义信号量 ```c struct semaphore sem; ``` ##### 初始化信号量 ```c static inline void sema_init(struct semaphore *sem, int val) ``` 参数： sem：指定要初始化的信号量 val：信号量的初始值 ##### 获取信号量 ```c void down(struct semaphore *sem); ``` 参数： sem：指定要初始化的信号量 ##### 尝试获取信号量 ```c int down_trylock(struct semaphore *sem) ``` 尝试获取一次信号量，获取成功返回0,获取失败返回非0值。 ##### 释放信号量 ```c void up(struct semaphore *sem) ``` 参数： sem：指定要初始化的信号量 ## 互斥锁 ![image 20251109232135269](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251109232135269.png) #### 信号量与互斥锁：同步还是独占？ ##### 信号量 强调信号机制(同步) 生产者 消费者模型 获取信号量失败，触发上下文调度 ##### 互斥锁 强调互斥机制 独占共享资源 获取互斥锁失败，触发上下文调度 ``` 服务于多个线程间的执行的逻辑顺序的选信号量, 可以有多个资源 服务于共享资源的选互斥锁, 只可以使用一个资源 ``` #### 自旋锁与互斥锁：休眠还是“忙等待”？ ##### 自旋锁 加锁成本低，不释放cpu使用权 ##### 互斥锁 加锁成本更高(上下文切换耗时在几十纳秒到几微秒之间)，加锁失败时会释放 CPU 给其他线程 ``` 无法判断锁住的代码会执行多久时，首选互斥锁 确定被锁住的代码执行时间很短，使用自旋锁取代互斥锁 ``` #### 互斥锁相关API ##### 定义互斥锁 ```c struct mutex lock; ``` ##### 初始化互斥锁 ```c void mutex_init(mutex *lock); ``` 参数： lock：指定要初始化的互斥锁 ##### 互斥锁加锁 ```c void mutex_lock(struct mutex *lock); ``` 参数： lock：指定要加锁的互斥锁 ##### 尝试获取互斥锁 ```c int mutex_trylock(struct mutex *lock); ``` 尝试获取一次互斥锁，获取成功返回“true”,获取失败返回“false”。程序继续往下执行 ##### 互斥锁解锁 ```c void mutex_unlock(struct mutex *lock); ``` 参数： lock：指定要解锁的互斥锁"},"/note/Linux/野火Linux/2025-9-29-41-Linux系统构成.html":{"title":"Linux系统构成","content":"# Linux系统构成 ## Uboot U Boot 是一个主要用于嵌入式系统的引导加载程序，可以支持多种不同的计算机系统结构，包括 PPC、ARM、AVR32、MIPS、x86、68k、Nios与MicroBlaze。 用来启动操作系统内核，它分为两个阶段，即boot+loader，**boot**阶段启动系统，**初始化硬件设备**，建立内存空间映射图，将系统的软硬件带到一个**合适的状态**，**loader**阶段将操作系统**内核文件加载**至内存，之后跳转到内核所在地址运行。 ![image 20250929175526182](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509291755243.png) ## 内核 Linux内核的主要模块（或组件）分以下几个部分：进程管理子系 统、内存管理子系统、文件子系统、网络子系统、设备子系统等 ![image 20250929182622435](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509291826703.png) ## 设备树 Uboot 和 Linux 不能直接识别DTS文件，而DTB可以被内核与BootLoader识别解析，通常在制 作NANDFlash、SDCard启动镜像时，通常会为DTB文件留下一部分存储区域以存储DTB，在 BootLoader 启动内核时，会先读取DTB到内存，再提供给内核使用。 ![image 20250929182827788](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509291828829.png) ## 根文件系统 根文件系统（rootfs）是linux在初始化时加载的第一个文件系统，根文件系统包括根目录和真实 文件系统，它包含系统引导和使其他文件系统得以挂载（mount）所必要的文件。根文件系统包 函Linux 启动时所必须的目录和关键性的文件，例如Linux启动时必要的初始化文件，它在init 目录下，此外根文件系统中还包括了许多的应用程序bin目录等，任何包括这些Linux系统启动 所必须的文件都可以成为根文件系统。 在Linux 内核启动的初始阶段，首先内核会初始化一个基于内存的文件系统，如initramfs，initrd 等，然后以只读的方式去加载根文件系统（loadrootfs），读取并且运行/sbin/init初始化文件，根 据/etc/inittab 配置文件完成系统的初始化工作（提示：/sbin/init是一个二进制可执行文件，为系统 的初始化程序，而/etc/inittab是它的配置文件），在初始化的过程中，还会以读写的方式重新挂载 根文件系统，在系统启动后，根文件系统就可用于存储数据了，存在根文件系统是Linux启动时 的必要条件 ![image 20250929183041495](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509291830534.png) ## image builder项目 移植自 BeagleBone 公司的 image builder, 基于 qemu 和 debootstrap 等工具来生成和定制 arm 架构的debian 文件系统。 debootstrap 是 Debian 官方提供的，适用于生成不同架构、不同版本的debian文件 系统 > https://github.com/beagleboard/image builder ### 原理 在使用debootstrap 工具生成debian文件系统后，然后qemu使用新构建的debian文件系统作为文 件系统，在qemu模拟arm架构的处理器并启动后，就可以用apt install命令预装各种应用软件， linux 内核和设备树都是在这个阶段中安装更新的。安装完毕后，使用dd命令把得到的文件系统 和u boot 一起打包到img文件中，即可生成用于sd卡烧录的debian系统镜像。 ### 下载 ```c git clone https://gitee.com/Embedfire/ebf image builder.git ``` + configs 目录:主要是Debian文件系统的一些配置项，主要有:预安装软件列表、镜像源地址 等。 + doc 目录:说明文档。 + env 目录:设置环境设置相关脚本。 + local_directory 目录: 读者可在这个目录下创建或添加一些想要的文件或者目录，最终会被 添加到根文件系统/usr/share目录下。 + local_pkg 目录：读者可在这个目录下放一些想要打包进镜像的软件包。 + publish 目录: 这个目录下存放着编译debian固件的起始脚本，是整个项目的编译入口。 + scripts 目录: 存放了一些执行特殊功能的脚本，在编译过程中会被调用。 + target 目录: 这里面放置的内容比较杂散，有启动参数的说明文档、systemd的启动服务和 deb 镜像源的密钥等等。 + tools 目录: 主要是打包脚本，完成把文件系统和uboot打包成img镜像的功能。 在执行编译镜像之后，在该目录下会增加几个新的目录 + build 目录: 编译得到的uboot、内核、以及内核安装包。 + deploy 目录: 编译的到的完整镜像目录。 + ebf_linux_kernel 目录: 编译需要的内核源码路径。 + ebf_linux_uboot 目录: 编译需要的uboot 源码路径。 ### 使用 ```base jiao@jiao virtual machine:~/yh linux/image builder/ebf image builder$ source env/setenv.sh Choose install type: 1. ALL 2. NAND 3. eMMC/SD Which install type would you like? [1] 1 Choose fire board: 1. ebf_imx_6ull_mini 2. ebf_imx_6ull_pro 3. ebf_imx_8m_mini 4. ebf_rockchip_3328 5. ebf_rockchip_3399 6. ebf_stm_mp157_star Which board would you like? [1] 2 Skiping tfa... Choose uboot version: 1. uboot 2020.10 Which uboot version would you like? [1] 1 Choose uboot tag: 1. uboot latest Which uboot tag would you like? [1] 1 Choose linux version: 1. linux 4.19.35 2. linux 4.19.35 rt19 3. linux 4.19.71 Which linux version would you like? [1] 1 Choose linux tag: 1. linux latest 2. linux ebf_imx_4.19_2020_12_09 Which linux tag would you like? [1] 1 Choose distribution: 1. Debian 2. Ubuntu Which distribution would you like? [1] 1 Choose Debian release: 1. buster Which Debian release would you like? [1] 1 Choose Debian type: 1. console 2. qt 3. desktop Which Debian type would you like? [1] 1 #FIRE_BOARD ebf_imx_6ull_pro #TFA #LINUX 4.19.35 #UBOOT 2020.10 #DISTRIBUTION Debian #DISTRIB_RELEASE buster #DISTRIB_TYPE console #INSTALL_TYPE ALL Environment setup done. Type 'make' to build. ``` 配置完成之后打印信息，若有想要修改配置信息，重新执行source env/setenv.sh即可 ```bash make DOWNLOAD_MIRROR china ``` 当重复多次编译镜像时，uboot、内核并不会反复编译。如果需要重新编译uboot、内核，可加入 `FORCE_UPDATE enable` 生成的image镜像位于deploy/lubancat carp xxx armhf 202x xx xx/目录下，后缀名为.img，可使用 sd 卡烧录工具将其烧录到sd卡中 #### 编译uboot 在ebf image builder 目录下，可使用以下命令只编译 `make uboot` 生成uboot文件位于build目录下 #### 编译内核 在ebf image builder目录下，可使用以下命令只编译内核 `make kernel` 生成文件位于build/images目录下 #### 编译内核安装包 `make kernel deb` 生成deb包位于build/debs目录下 ### 原理 ![image 20250929191305694](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509291913832.png) ### 配置 用户若想要对编译出来的镜像做些调整，主要需要涉及到的目录为configs目录 ![image 20250929191448290](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509291914323.png) + boards: 该目录主要存放板级相关配置信息，在后面将逐渐添加新的板子。在通常情况下这个目录下的配置文 件不需要用户修改，仅做为了解即可 + common.conf: 通用的配置信息，包括软件源、需要预安装的软件包等信息。 + function: 编译相关脚本，实现uboot、kernel等编译，用户可以不关心。 + user.conf: 用户的配置文件，用户账号密码、以及上电时打印提示信息等 > 用户若想要往板子里添加一些自己的文件，可将这些文件放在local_directory目录下，在构建完 整的镜像时，这些文件将被拷贝到/usr/share/目录下 #### config/boards ```python ## [Git Remote Repository] \tSUPPORTED_UBOOT (\"2020.10\") \tSUPPORTED_UBOOT_TAGS (\"latest\") ## 记录UBOOT,LINUX内核以及git信息 \tSUPPORTED_LINUX ( \"4.19.35\" \"4.19.35 rt19\" \"4.19.71\") \tSUPPORTED_LINUX_TAGS (\"latest\" \"ebf_imx_4.19_2020_12_09\") \t## UBOOT相关的信息 \tcase \"$UBOOT\" in \t\t2020.10) \t\t\tUBOOT_GIT_BRANCH \"ebf_v2020_10_imx\" \t\t\tUBOOT_COMPILER \"arm none eabi \" \t\t\tUBOOT_DIR \"$ROOT/ebf_linux_uboot\" \t\t\tUBOOT_BUILD_FILE \"u boot dtb.imx\" \t\t\tNUBOOT_FILE \"u boot nand.imx\" \t\t\tMUBOOT_FILE \"u boot mmc.imx\" \t\t\tUBOOT_MMC_DEFCONFIG \"mx6ull_fire_mmc_defconfig\" \t\t\tUBOOT_NAND_DEFCONFIG \"mx6ull_fire_nand_defconfig\" \t\t\t;; \tesac \tcase \"$UBOOT_TAGS\" in \t\tlatest) \t\t\tUBOOT_GIT_TAGS \"\" \t\t\t;; \t\tebf_imx_4.19_2020_12_09) \t\t\tUBOOT_GIT_TAGS \"ebf_imx_4.19_2020_12_09\" \t\t\t;; \tesac \t## 关于内核设备树文件，git仓库分支，编译工具链，内核仓库分支，内核配置文件，以及生成的deb包文件 \tcase \"$LINUX\" in \t\t4.19.71) \t\t\tLINUX_MMC_DTB \"imx6ull mmc npi.dtb\" \t\t\tLINUX_NAND_DTB \"imx6ull nand npi.dtb\" \t\t\tLINUX_GIT_BRANCH \"ebf_4.19_imx\" \t\t\tLINUX_DEFCONFIG \"npi_v7_defconfig\" \t\t\tKERNEL_COMPILER \"arm linux gnueabihf \" \t\t\tLINUX_DIR \"$ROOT/ebf_linux_kernel\" \t\t\tLOCAL_VERSION \" imx6\" \t\t\tKERNEL_DEB \"linux image ${LINUX}${LOCAL_VERSION}_${KDEB_VERSION}_armhf.deb\" \t\t\t;; \t\t \t\t4.19.35) \t\t\tLINUX_MMC_DTB \"imx6ull mmc npi.dtb\" \t\t\tLINUX_NAND_DTB \"imx6ull nand npi.dtb\" \t\t\tLINUX_GIT_BRANCH \"ebf_4.19.35_imx6ul\" \t\t\tLINUX_DEFCONFIG \"npi_v7_defconfig\" \t\t\tKERNEL_COMPILER \"arm linux gnueabihf \" \t\t\tLINUX_DIR \"$ROOT/ebf_linux_kernel\" \t\t\tLOCAL_VERSION \" imx6\" \t\t\tKERNEL_DEB \"linux image ${LINUX}${LOCAL_VERSION}_${KDEB_VERSION}_armhf.deb\" \t\t\t;; \t\t4.19.35 rt19) \t\t\tLINUX_MMC_DTB \"imx6ull mmc npi.dtb\" \t\t\tLINUX_NAND_DTB \"imx6ull nand npi.dtb\" \t\t\tLINUX_GIT_BRANCH \"ebf_4.19.35 rt19_imx6ul\" \t\t\tLINUX_DEFCONFIG \"npi_v7_defconfig\" \t\t\tKERNEL_COMPILER \"arm linux gnueabihf \" \t\t\tLINUX_DIR \"$ROOT/ebf_linux_kernel\" \t\t\tLOCAL_VERSION \" imx6\" \t\t\tKERNEL_DEB \"linux image ${LINUX}${LOCAL_VERSION}_${KDEB_VERSION}_armhf.deb\" \t\t\t;; \tesac \tcase \"$LINUX_TAGS\" in \t\tlatest) \t\t\tLINUX_GIT_TAGS \"\" \t\t\t;; \t\tebf_imx_4.19_2020_12_09) \t\t\tLINUX_GIT_TAGS \"ebf_imx_4.19_2020_12_09\" \t\t\t;; \tesac ## [Image Build Info]，关于uboot需要烧录到sd卡的位置，其中dd_uboot_seek表示块偏移，dd_uboot_bs ## 表示块大小(单位为字节)，imx6ull规定若想从sd启动u boot.imx要有一个1Kbyte的偏移 \tARCH \"arm\" \tebf_repo_dist \"carp imx6\"\t \tdeb_arch \"armhf\" \ttime $(date +%Y %m %d) \timage_name \"${deb_distribution} ${release} ${DISTRIB_TYPE} ${deb_arch} ${time}\" \ttarget_name \"imx6ull\" \toptions \" img 2gb ${target_name} ${image_name} enable fat partition\" \toptions \"${options} enable uboot cape overlays force device tree ${LINUX_MMC_DTB} \" \toptions \"${options} backup device tree ${LINUX_NAND_DTB} bootloader ${BUILD}\" \tconf_board \"fire imx6ull npi\" \tchroot_COPY_SETUP_SDCARD \"enable\" \tchroot_bootPart_logo \"enable\" \tchroot_custom_setup_sdcard \"imxv7_setup_sdcard.sh\" \tinclude_firmware \"enable\" ## [Bootloader Partition]设置boot分区大小以及文件系统类型等。其中conf_boot_endm表示boot分区的 ## 大小，conf_boot_startmb表示整个uboot的起始地址，两个单位都是mb \tbootloader_location \"dd_uboot_boot\" \tboot_name \"$MUBOOT_FILE\" \tdd_uboot_count \"\" \tdd_uboot_seek \"2\" \tdd_uboot_conf \"\" \tdd_uboot_bs \"512\" \tconf_boot_startmb \"4\" \tconf_boot_endmb \"40\" \tconf_boot_fstype \"fat\" \tconf_root_device \"/dev/mmcblk0\" \tUSE_LOCAL_BOOT \"yes\" ## Extra software \tboard_deb_include \"ebf gst\" \tother_pk \"ebf gst\" ## [Firmware] \tROOT_FIRMWARE_PATH \"\" \tNEED_EXT4_IMG \"false\"\t ##\t[Device Tree Overlays] 镜像默认配置的设备树插件 OVERLAYS \" dtoverlay /usr/lib/linux image ${LINUX}${LOCAL_VERSION}/overlays/imx fire i2c1.dtbo dtoverlay /usr/lib/linux image ${LINUX}${LOCAL_VERSION}/overlays/imx fire i2c2.dtbo dtoverlay /usr/lib/linux image ${LINUX}${LOCAL_VERSION}/overlays/imx fire 74hc595.dtbo #dtoverlay /usr/lib/linux image ${LINUX}${LOCAL_VERSION}/overlays/imx fire 485r1.dtbo #dtoverlay /usr/lib/linux image ${LINUX}${LOCAL_VERSION}/overlays/imx fire 485r2.dtbo dtoverlay /usr/lib/linux image ${LINUX}${LOCAL_VERSION}/overlays/imx fire adc1.dtbo dtoverlay /usr/lib/linux image ${LINUX}${LOCAL_VERSION}/overlays/imx fire hdmi.dtbo #dtoverlay /usr/lib/linux image ${LINUX}${LOCAL_VERSION}/overlays/imx fire cam.dtbo #dtoverlay /usr/lib/linux image ${LINUX}${LOCAL_VERSION}/overlays/imx fire btwifi.dtbo #dtoverlay /usr/lib/linux image ${LINUX}${LOCAL_VERSION}/overlays/imx fire can1.dtbo #dtoverlay /usr/lib/linux image ${LINUX}${LOCAL_VERSION}/overlays/imx fire can2.dtbo #dtoverlay /usr/lib/linux image ${LINUX}${LOCAL_VERSION}/overlays/imx fire dht11.dtbo #dtoverlay /usr/lib/linux image ${LINUX}${LOCAL_VERSION}/overlays/imx fire ecspi3.dtbo dtoverlay /usr/lib/linux image ${LINUX}${LOCAL_VERSION}/overlays/imx fire key.dtbo dtoverlay /usr/lib/linux image ${LINUX}${LOCAL_VERSION}/overlays/imx fire lcd.dtbo dtoverlay /usr/lib/linux image ${LINUX}${LOCAL_VERSION}/overlays/imx fire touch capacitive goodix.dtbo #dtoverlay /usr/lib/linux image ${LINUX}${LOCAL_VERSION}/overlays/imx fire touch capacitive gt1151.dtbo dtoverlay /usr/lib/linux image ${LINUX}${LOCAL_VERSION}/overlays/imx fire led.dtbo dtoverlay /usr/lib/linux image ${LINUX}${LOCAL_VERSION}/overlays/imx fire sound.dtbo #dtoverlay /usr/lib/linux image ${LINUX}${LOCAL_VERSION}/overlays/imx fire sound aic3106.dtbo dtoverlay /usr/lib/linux image ${LINUX}${LOCAL_VERSION}/overlays/imx fire uart2.dtbo #dtoverlay /usr/lib/linux image ${LINUX}${LOCAL_VERSION}/overlays/imx fire uart3.dtbo dtoverlay /usr/lib/linux image ${LINUX}${LOCAL_VERSION}/overlays/imx fire mpu6050.dtbo #dtoverlay /usr/lib/linux image ${LINUX}${LOCAL_VERSION}/overlays/imx fire bluetooth.dtbo #dtoverlay /usr/lib/linux image ${LINUX}${LOCAL_VERSION}/overlays/imx fire otg1.dtbo \" ``` #### config/common.conf 通用的配置文件，在通常情况下该配置文件不需要用户修 改 ```python ## [Project Path] 工程路径 \tROOT \"$(dirname \"$(dirname \"$(readlink fm \"$0\")\")\")\" \tCONFIG \"$ROOT/configs\" \tBOARD_CONFIG \"$CONFIG/boards\" \tBUILD \"$ROOT/build\" \tBUILD_IMAGES \"$BUILD/images\" \tBUILD_DEBS \"$BUILD/debs\" \tBUILD_SCRIPT \"$ROOT/scripts\" \tLOCAL_PKG \"$ROOT/local_pkg\" \tLOCAL_DIR \"$ROOT/local_directory\" ## [download mirror] 默认的镜像源 \tDEBIAN_MIRROR 'archive.debian.org/debian' \tUBUNTU_MIRROR 'ports.ubuntu.com/' \tif [[ $DOWNLOAD_MIRROR china ]] ; then \t\t# DEBIAN_MIRROR 'mirrors.tuna.tsinghua.edu.cn/debian' \t\t# UBUNTU_MIRROR 'mirrors.tuna.tsinghua.edu.cn/ubuntu ports/' \t\t# DEBIAN_MIRROR 'mirrors.bfsu.edu.cn/debian' \t\t# UBUNTU_MIRROR 'mirrors.bfsu.edu.cn/ubuntu ports/' \t\tDEBIAN_MIRROR 'mirrors.aliyun.com/debian archive/debian' \t\tUBUNTU_MIRROR 'mirrors.ustc.edu.cn/ubuntu ports/'\t\t \tfi \t#repo_external_server \"https://Embedfire.github.io\" \trepo_external_server \"https://cloud.embedfire.com/mirrors/ebf debian\" \t#repo_external_server \"https://cloud.embedfire.com/mirrors/ebf test\" \trepo_external_server_backup1 \"https://Embedfire.github.io/\" \trepo_external_server_backup2 \"https://sourceforge.net/projects/embedfire debian sources/files/\" ## [pakage features] 系统版本定义 \tif [[ $DISTRIBUTION Debian ]]; then \t\trelease \"carp\" \t\tdeb_distribution \"lubancat\" \t\tdeb_codename $DISTRIB_RELEASE \t\t#deb_arch \"armhf\" \t\tdeb_components \"main contrib non free\" \t\tdeb_mirror $DEBIAN_MIRROR \t\trepo_external_dist $DISTRIB_RELEASE \t\trepo_external_components \"main\" \t\t#KDEB_VERSION \"2.2LubanCat\" \t\tKDEB_VERSION \"1.$(date +%g%m)stable\" \telse \t\tdeb_distribution \"ubuntu\" \t\tdeb_codename $DISTRIB_RELEASE \t\t#deb_arch \"armhf\" \t\tdeb_components \"main universe multiverse\" \t\trepo_external_dist $DISTRIB_RELEASE \t\trepo_external_components \"main\" \t\tdeb_mirror $UBUNTU_MIRROR \t\tif [[ $DISTRIB_RELEASE bionic ]]; then \t\trelease \"18.04\" \t\t#KDEB_VERSION \"18.04 Ubuntu\" \t\tKDEB_VERSION \"1.$(date +%g%m)stable\" \t\tfi \t\tif [[ $DISTRIB_RELEASE focal ]]; then \t\trelease \"20.04\" \t\t#KDEB_VERSION \"20.04 Ubuntu\" \t\tKDEB_VERSION \"1.$(date +%g%m)stable\" \t\tfi \t\t \tfi \tchroot_tarball \"enable\" ## [install default pakage] 默认的软件包 \tdeb_arch \"armhf\" \tdeb_include \"apt transport https ca certificates connman curl dosfstools\\ \t\t\t\tgnupg gnupg2 ifupdown initramfs tools isc dhcp client nano \\ \t\t\t\tnet tools netcat rsync sudo udhcpd parted mtd utils mmc utils\\ \t\t\t\trng tools haveged wpasupplicant udhcpc openssh server avahi daemon\\ \t\t\t\tgpiod kpartx jq libgpiod dev rfkill usbutils exfat fuse exfat utils \\ \t\t\t\tssh alsa utils\" \tdeb_exclude \"aptitude aptitude common groff base info install info man db manpages\\ \t\t\t\tmanpages dev tasksel tasksel data\" ## [install extern pakage] 不同的版本安装不同的软件包(Qt等) \trepo_external_arch \"armhf\" \trepo_external \"enable\" \trepo_external_key \"keyfile\" \trepo_local_file \"enable\" \tcase $DISTRIB_TYPE in \tconsole) \t\trepo_external_pkg_list \"kobs ng for imx6ull fire config v2 wifi depent libatomic1 \" \t\tsystem_directory \"/usr/share\" \t;; \tqt) \t\trepo_external_pkg_list \"kobs ng for imx6ull fire config v2 wifi depent ebf qtdemo libatomic1\" \t\tsystem_directory \"/usr/share\" \t;; \tdesktop) \t\trepo_external_pkg_list \"kobs ng for imx6ull fire config v2 wifi depent xfce4\" \t\tsystem_directory \"/usr/share\" \t;; \tesac ## [TFA & U boot & Linux GitHub info] 是否使用国内路径下载 \tif [[ $DOWNLOAD_MIRROR china ]] ; then \t\t#LINUX_SOURCE_URL \"https://e.coding.net/embedfire/lubancat/ebf_linux_kernel.git\" \t\tLINUX_SOURCE_URL \"https://github.com/Embedfire/ebf_linux_kernel\" \t\tUBOOT_SOURCE_URL \"https://gitee.com/Embedfire/ebf_linux_uboot\" \t\tTFA_SOURCE_URL \"https://gitee.com/Embedfire/ebf_linux_tfa\" \telse \t\tLINUX_SOURCE_URL \"https://github.com/Embedfire/ebf_linux_kernel\" \t\tUBOOT_SOURCE_URL \"https://github.com/Embedfire/ebf_linux_uboot\" \t\tTFA_SOURCE_URL \"https://github.com/Embedfire/ebf_linux_tfa/\" \tfi \tif [[ $SOURCE_URL gitlab ]] ; then\t \t\tLINUX_SOURCE_URL \"git@gitlab.ebf.local:st mp1/ebf_linux_kernel.git\" \t\tUBOOT_SOURCE_URL \"git@gitlab.ebf.local:st mp1/ebf_linux_uboot.git\" \tfi \tGIT_CLONE_OPTIONS \" depth 1\" \tFENIX_BRANCH \"master\" \tROOTFSCACHE_VERSION 6 \tDATE $(date +%F sed 's/ //g') \tIMAGE_RELEASE_VERSION \"${DATE:2}\" ## [CPU info] \tNR_JOBS_MAX 20 \tNR_CPUS $(grep c processor /proc/cpuinfo) \tif [ ${NR_CPUS} le ${NR_JOBS_MAX} ]; then \t\tNR_JOBS ${NR_CPUS} \telse \t\tNR_JOBS ${NR_JOBS_MAX} fi ## [Define colors] \tBLACK \"\\e[0;30m\" \tBOLDBLACK \"\\e[1;30m\" \tRED \"\\e[0;31m\" \tBOLDRED \"\\e[1;31m\" \tGREEN \"\\e[0;32m\" \tBOLDGREEN \"\\e[1;32m\" \tYELLOW \"\\e[0;33m\" \tBOLDYELLOW \"\\e[1;33m\" \tBLUE \"\\e[0;34m\" \tBOLDBLUE \"\\e[1;34m\" \tMAGENTA \"\\e[0;35m\" \tBOLDMAGENTA \"\\e[1;35m\" \tCYAN \"\\e[0;36m\" \tBOLDCYAN \"\\e[1;36m\" \tWHITE \"\\e[0;37m\" \tBOLDWHITE \"\\e[1;37m\" \tENDCOLOR \"\\e[0m\" ## [Enable Proxy?] \t#apt_proxy localhost:3142/ ## [info colors] \tERROR \"${RED}Error:${ENDCOLOR}\" \tWARNING \"${YELLOW}Warning:${ENDCOLOR}\" \tINFO \"${GREEN}Info:${ENDCOLOR}\" ``` #### configs/user.conf debian和ubuntu版本的用户配置信息，其中包括用户账号密码、本地语 言、以及上电时打印提示信息等 ```python ## [user setting] if [[ $FIRE_BOARD ebf_imx_6ull_pro ]] [[ $FIRE_BOARD ebf_imx_6ull_mini ]]; then \t \t## the system information of imx6ull 用户名密码 \tif [[ $DISTRIBUTION Debian ]]; then \t rfs_username \"debian\" \t rfs_fullname \"lubancat\" \t rfs_password \"temppwd\" \t rfs_hostname \"npi\" \t rfs_default_locale \"en_US.UTF 8\" ## 语言 \t rfs_etc_dogtag \"embedfire.com Debian Image\" ## 提示信息 \t rfs_console_banner \"Support/FAQ: www.firebbs.cn/forum.php\" ## 提示信息 \t rfs_console_user_pass \"enable\" \t rfs_ssh_banner \"Support/FAQ: www.firebbs.cn/forum.php\" ## ssh提示信息 \t rfs_ssh_user_pass \"enable\" \telse \t rfs_username \"ubuntu\" \t rfs_fullname \"lubancat\" \t rfs_password \"temppwd\" \t rfs_hostname \"npi\" \t rfs_default_locale \"en_US.UTF 8\" \t rfs_etc_dogtag \"embedfire.com Debian Image\" \t rfs_console_banner \"Support/FAQ: www.firebbs.cn/forum.php\" \t rfs_console_user_pass \"enable\" \t rfs_ssh_banner \"Support/FAQ: www.firebbs.cn/forum.php\" \t rfs_ssh_user_pass \"enable\" \tfi else \tif [[ $DISTRIBUTION Debian ]]; then \t rfs_username \"debian\" \t rfs_fullname \"lubancat\" \t rfs_password \"temppwd\" \t rfs_hostname \"lubancat\" \t rfs_default_locale \"en_US.UTF 8\" \t rfs_etc_dogtag \"embedfire.com Debian Image\" \t rfs_console_banner \"Support/FAQ: www.firebbs.cn/forum.php\" \t rfs_console_user_pass \"enable\" \t rfs_ssh_banner \"Support/FAQ: www.firebbs.cn/forum.php\" \t rfs_ssh_user_pass \"enable\" \telse \t rfs_username \"ubuntu\" \t rfs_fullname \"lubancat\" \t rfs_password \"temppwd\" \t rfs_hostname \"lubancat\" \t rfs_default_locale \"en_US.UTF 8\" \t rfs_etc_dogtag \"embedfire.com Debian Image\" \t rfs_console_banner \"Support/FAQ: www.firebbs.cn/forum.php\" \t rfs_console_user_pass \"enable\" \t rfs_ssh_banner \"Support/FAQ: www.firebbs.cn/forum.php\" \t rfs_ssh_user_pass \"enable\" \tfi fi ```"},"/note/Linux/野火Linux/2025-11-1-62-linux移植.html":{"title":"Linux移植","content":"# Linux移植 默认的配置文件记录在`/arch/arm/configs`文件夹下面, 官方使用的是`imx_v7_mfg_defconfig`这个文件, 这个文件是适配了官方烧录工具的 可以直接使用官方的文件进行编译获取到zImage文件, 以及/arch/arm/boot/dts/imx6ulll 14 14 evk emmc.dtb文件进行启动 在实际启动之前需要设置一下bootargs这个参数 ```bash console ttymxc0,115200 root /dev/mmcblk1p2 rootwait rw ``` ## 移植 在移植的时候, 把配置文件以及设备树文件复制一份 配置文件里面的`CONFIG_ARCH_MULTI_V6 y`删除, 因为这个板子使用的ARMV7 在`/arch/arm/boot/dts/Makefile`文件里面添加自己使用的设备树文件 ### 设置CPU频率 目录/sys/bus/cpu/devices/cpu0/cpufreq可以查看CPU的各项属性 + cpuinfo_cur_freq：当前 cpu 工作频率，从CPU寄存器读取到的工作频率。 + cpuinfo_max_freq：处理器所能运行的最高工作频率(单位: KHz）。 + cpuinfo_min_freq ：处理器所能运行的最低工作频率(单位: KHz）。 + cpuinfo_transition_latency：处理器切换频率所需要的时间(单位:ns)。 + scaling_available_frequencies：处理器支持的主频率列表(单位: KHz）。 + scaling_available_governors：当前内核中支持的所有governor(调频)类型。 + scaling_cur_freq：保存着 cpufreq 模块缓存的当前 CPU 频率，不会对 CPU 硬件寄存器进 行检查。 + scaling_driver：该文件保存当前CPU所使用的调频驱动。 + scaling_governor：governor(调频)策略，Linux 内核一共有 5中调频策略， > ①、Performance，最高性能，直接用最高频率，不考虑耗电。 ②、Interactive，一开始直接用最高频率，然后根据CPU负载慢慢降低。 ③、Powersave，省电模式，通常以最低频率运行，系统性能会受影响，一般不会用这个！ ④、Userspace，可以在用户空间手动调节频率。 ⑤、Ondemand，定时检查负载，然后根据负载来调节频率。负载低的时候降低CPU频率， 这样省电，负载高的时候提高CPU频率，增加性能。 > > 这几种策略可以在配置文件里面进行使能, 使能以后才可以使用, 也可以设置默认的模式 + scaling_max_freq：governor(调频)可以调节的最高频率。 + cpuinfo_min_freq：governor(调频)可以调节的最低频率。 ​ 可以在图形化界面的`CPU Power Management > CPU Frequency scaling`里面进行配置 ### 8线EMMC 驱动里面EMMC默认是4线模式的，4线模式肯定没有8线模式的速度快，所 以本节我们将EMMC的驱动修改为8线模式 ```json &usdhc2 { \tpinctrl names \"default\"; \tpinctrl 0 <&pinctrl_usdhc2>; \tnon removable; \tno 1 8 v; \tstatus \"okay\"; }; ``` 使用的引脚配置是 ```json pinctrl_usdhc2: usdhc2grp { fsl,pins < MX6UL_PAD_NAND_RE_B__USDHC2_CLK 0x10069 MX6UL_PAD_NAND_WE_B__USDHC2_CMD 0x17059 MX6UL_PAD_NAND_DATA00__USDHC2_DATA0 0x17059 MX6UL_PAD_NAND_DATA01__USDHC2_DATA1 0x17059 MX6UL_PAD_NAND_DATA02__USDHC2_DATA2 0x17059 MX6UL_PAD_NAND_DATA03__USDHC2_DATA3 0x17059 >; }; ``` 改为设置 ```json &usdhc2 { pinctrl names \"default\", \"state_100mhz\", \"state_200mhz\"; pinctrl 0 <&pinctrl_usdhc2_8bit>; pinctrl 1 <&pinctrl_usdhc2_8bit_100mhz>; pinctrl 2 <&pinctrl_usdhc2_8bit_200mhz>; bus width <8>; non removable; status \"okay\"; }; ``` 由于之前的节点里面有`no 1 8 v; `所以实际还是不会使用1.8v进行驱动的 ### 网络驱动 引脚的属性设置为 ```json pinctrl_spi4: spi4grp { fsl,pins < MX6ULL_PAD_BOOT_MODE0__GPIO5_IO10 0x70a1 MX6ULL_PAD_BOOT_MODE1__GPIO5_IO11 0x70a1 MX6ULL_PAD_SNVS_TAMPER7__GPIO5_IO07 0x70a1 MX6ULL_PAD_SNVS_TAMPER8__GPIO5_IO08 0x80000000 >; }; ``` 需要GPIO5_IO07和GPIO5_IO08分别作为ENET1和ENET2的复位引脚，而不 是SPI4的功能引脚, 删除下面的两个设置 ```json spi4 { compatible \"spi gpio\"; pinctrl names \"default\"; pinctrl 0 <&pinctrl_spi4>; pinctrl assert gpios <&gpio5 8 GPIO_ACTIVE_LOW>; status \"disabled\"; gpio sck <&gpio5 11 0>; gpio mosi <&gpio5 10 0>; cs gpios <&gpio5 7 0>; num chipselects <1>; #address cells <1>; #size cells <0>; gpio_spi: gpio_spi@0 { compatible \"fairchild,74hc595\"; gpio controller; #gpio cells <2>; reg <0>; registers number <1>; registers default /bits/ 8 <0x57>; spi max frequency <100000>; }; }; ``` 这里面使用这两个引脚的配置也要删除 设置为 ```json pinctrl_fec1_reset: fec1_resetgrp { fsl,pins < MX6ULL_PAD_SNVS_TAMPER7__GPIO5_IO07\t0x79 >; }; pinctrl_fec2_reset: fec2_resetgrp { fsl,pins < MX6ULL_PAD_SNVS_TAMPER8__GPIO5_IO08\t0x79 >; }; ``` 设置一下时钟引脚的配置 ```json pinctrl_enet1: enet1grp { fsl,pins < MX6UL_PAD_ENET1_RX_EN__ENET1_RX_EN\t0x1b0b0 MX6UL_PAD_ENET1_RX_ER__ENET1_RX_ER\t0x1b0b0 MX6UL_PAD_ENET1_RX_DATA0__ENET1_RDATA00\t0x1b0b0 MX6UL_PAD_ENET1_RX_DATA1__ENET1_RDATA01\t0x1b0b0 MX6UL_PAD_ENET1_TX_EN__ENET1_TX_EN\t0x1b0b0 MX6UL_PAD_ENET1_TX_DATA0__ENET1_TDATA00\t0x1b0b0 MX6UL_PAD_ENET1_TX_DATA1__ENET1_TDATA01\t0x1b0b0 MX6UL_PAD_ENET1_TX_CLK__ENET1_REF_CLK1\t0x4001B009 >; }; pinctrl_enet2: enet2grp { fsl,pins < MX6UL_PAD_GPIO1_IO07__ENET2_MDC\t\t0x1b0b0 MX6UL_PAD_GPIO1_IO06__ENET2_MDIO\t0x1b0b0 MX6UL_PAD_ENET2_RX_EN__ENET2_RX_EN\t0x1b0b0 MX6UL_PAD_ENET2_RX_ER__ENET2_RX_ER\t0x1b0b0 MX6UL_PAD_ENET2_RX_DATA0__ENET2_RDATA00\t0x1b0b0 MX6UL_PAD_ENET2_RX_DATA1__ENET2_RDATA01\t0x1b0b0 MX6UL_PAD_ENET2_TX_EN__ENET2_TX_EN\t0x1b0b0 MX6UL_PAD_ENET2_TX_DATA0__ENET2_TDATA00\t0x1b0b0 MX6UL_PAD_ENET2_TX_DATA1__ENET2_TDATA01\t0x1b0b0 MX6UL_PAD_ENET2_TX_CLK__ENET2_REF_CLK2\t0x4001B009 >; }; ``` 这两个属性放在`fec1`和`fec2`里面 ```json &fec2 { \tpinctrl names \"default\"; \tpinctrl 0 <&pinctrl_enet2 \t\t &pinctrl_fec2_reset>; \tphy mode \"rmii\"; \tphy handle <&ethphy1>; \tphy reset gpios <&gpio5 8 GPIO_ACTIVE_LOW>; \tphy reset duration <200>; \tstatus \"okay\"; \tmdio { \t\t#address cells <1>; \t\t#size cells <0>; \t\tethphy0: ethernet phy@2 { \t\t\tcompatible \"ethernet phy ieee802.3 c22\"; \t\t\treg <2>; \t\t}; \t\tethphy1: ethernet phy@1 { \t\t\tcompatible \"ethernet phy ieee802.3 c22\"; \t\t\treg <1>; \t\t}; \t}; }; ``` 使用mdio记录的是ENET1 和ENET2的PHY地址信息, ethernet phy@后面的数字是PHY地址, 修改以后通用的驱动已经是可以使用的了, 但是为了稳定, 需要设置以下的 内容 修改驱动文件`drivers/net/ethernet/freescale/fec_main.c` 在函数`fec_probe`里面添加 ```c IMX6U_ENET1_TX_CLK ioremap(0x020E00DC, 4); writel(0x14, IMX6U_ENET1_TX_CLK); IMX6U_ENET2_TX_CLK ioremap(0x020E00FC, 4); writel(0x14, IMX6U_ENET2_TX_CLK); ``` 这两个设置引脚复位寄存器的SION位为1 在图形界面里面把`Device Drivers > Network device support > PHY Device support and infrastructure > Device for SMSC PHYs` SMSC是我们使用的芯片的生产厂商"},"/note/Linux/野火Linux/2025-9-25-31-kthread_worker.html":{"title":"","content":"## kthread_worker：怎么把内核线程当工人？ #### 驱动传输数据 低速数据：驱动同步传输 简单直接、传输效率低 高速数据：驱动交给内核来异步传输 机制复杂、无阻塞 #### kthread_worker结构体 include/linux/kthread.h 表示把内核线程抽象为流水线工人，按序处理其他线程/进程交付的批量工作 ```c struct kthread_worker { \tunsigned int\t\tflags; \tspinlock_t\t\tlock; \tstruct list_head\twork_list; // 批量不延时工作 \tstruct list_head\tdelayed_work_list; // 延时的工作 \tstruct task_struct\t*task; // Linux下面的一个线程 \tstruct kthread_work\t*current_work; // 当前的具体工作 }; ``` lock：自旋锁 work_list：链表节点，按序记录工作 delayed_work_list： task：内核线程 current_work：指向正在处理的具体工作 #### kthread_work结构体 include/linux/kthread.h 表示等待内核线程处理的具体工作 ```c struct kthread_work { \tstruct list_head\tnode; // 记录在work_list里面 \tkthread_work_func_t\tfunc; // 需要处理的回调函数 \tstruct kthread_worker\t*worker; \t/* Number of canceling calls that are running at the moment. */ \tint\t\t\tcanceling; }; ``` node：链表节点 func：函数指针 worker：处理该工作的内核线程工人 ##### kthread_work_func_t数据类型定义 ``` typedef void (*kthread_work_func_t)(struct kthread_work *work); ``` #### kthread_flush_work结构体 kernel/kthread.c 表示等待某个内核线程工人处理完所有工作 ```c struct kthread_flush_work { \tstruct kthread_work\twork; \tstruct completion\tdone; }; ``` work：具体内核线程工人 done：完成量，等待所有工作处理完毕 #### 初始化kthread_worker ##### kthread_init_worker函数 ```c struct kthread_worker hi_worker; kthread_init_worker(&hi_worker); ``` 先定义，后初始化 #### 为kthread_worker创建内核线程 ```c struct task_struct *kworker_task; kworker_task kthread_run(kthread_worker_fn, &hi_worker, \"nvme%d\", 1); ``` 先定义，后初始化 kthread_worker_fn：内核线程一直运行的函数 hi_worker：已初始化的kthread_worker结构体变量 \"nvme%d\"：为内核线程设置名字 #### 初始化kthread_work ```c struct kthread_work hi_work; kthread_init_work(&hi_work, xxx_work_fn); ``` 先定义，后初始化 xxx_work_fn：处理该工作的具体函数，自定义实现 #### 启动工作 交付工作给内核线程工人 ```c kthread_queue_work(&hi_worker, &hi_work); ``` hi_worker：具体内核线程工人 hi_work：具体工作 #### FLUSH工作队列 刷新指定 kthread_worker上所有 work ```c kthread_flush_worker(&hi_worker); ``` hi_worker：具体内核线程工人 #### 停止内核线程 ```c kthread_stop(kworker_task); ``` ## 使用 ```c /* 字符设备内容 */ #define DEV_NAME \"rgb_led\" #define DEV_CNT (1) int rgb_led_red; int rgb_led_green; int rgb_led_blue; /*定义 led 资源结构体，保存获取得到的节点信息以及转换后的虚拟寄存器地址*/ struct led_resource { \tstruct device_node *device_node; //rgb_led_red的设备树节点 \tvoid __iomem *virtual_CCM_CCGR; \tvoid __iomem *virtual_IOMUXC_SW_MUX_CTL_PAD; \tvoid __iomem *virtual_IOMUXC_SW_PAD_CTL_PAD; \tvoid __iomem *virtual_DR; \tvoid __iomem *virtual_GDIR; }; static dev_t led_devno;\t\t\t\t\t //定义字符设备的设备号 static struct cdev led_chr_dev;\t\t\t //定义字符设备结构体chr_dev struct class *class_led;\t\t\t\t //保存创建的类 struct device *device;\t\t\t\t\t // 保存创建的设备 struct device_node *rgb_led_device_node; //rgb_led的设备树节点结构体 /*定义 R G B 三个灯的led_resource 结构体，保存获取得到的节点信息*/ struct led_resource led_red; struct led_resource led_green; struct led_resource led_blue; struct kthread_worker hi_worker; struct kthread_work hi_work; struct task_struct *kworker_task; //用于保存接收到的数据,应使用链表结构存储每一次用户空间写入的值 unsigned int write_data; /*字符设备操作函数集，open函数*/ static int led_chr_dev_open(struct inode *inode, struct file *filp) { \tprintk(\"\\n open form driver \\n\"); \tkworker_task kthread_run(kthread_worker_fn, &hi_worker, \"nvme%d\",1 ); \treturn 0; } void rgb_control(struct kthread_work *work) { \t/*设置 GPIO1_04 输出电平*/ \tif (write_data & 0x04) \t{ \t\tgpio_set_value(rgb_led_red,0); \t} \telse \t{ \t\tgpio_set_value(rgb_led_red,1); \t} \t/*设置 GPIO4_20 输出电平*/ \tif (write_data & 0x02) \t{ \t\tgpio_set_value(rgb_led_green,0); \t} \telse \t{ \t\tgpio_set_value(rgb_led_green,1); \t} \t/*设置 GPIO4_19 输出电平*/ \tif (write_data & 0x01) \t{ \t\tgpio_set_value(rgb_led_blue,0); \t} \telse \t{ \t\tgpio_set_value(rgb_led_blue,1); \t} \treturn; } /*字符设备操作函数集，write函数*/ static ssize_t led_chr_dev_write(struct file *filp, const char __user *buf, size_t cnt, loff_t *offt) { \tint ret,error; \tunsigned char receive_data[10]; //用于保存接收到的数据 \tif(cnt>10) \t\t\tcnt 10; \terror copy_from_user(receive_data, buf, cnt); \tif (error < 0) \t{ \t\treturn 1; \t} \tret kstrtoint(receive_data, 16, &write_data); \tif (ret) { \t\treturn 1; } \tkthread_init_work(&hi_work, rgb_control); \tkthread_queue_work(&hi_worker, &hi_work); \treturn cnt; } /*字符设备操作函数集*/ static struct file_operations led_chr_dev_fops \t{ \t\t.owner THIS_MODULE, \t\t.open led_chr_dev_open, \t\t.write led_chr_dev_write, }; /* 平台驱动函数集 */ static int led_probe(struct platform_device *pdv) { \tint ret 1; //保存错误状态码 \tprintk(KERN_ALERT \"\\t match successed \\n\"); \t/*获取rgb_led的设备树节点*/ \trgb_led_device_node of_find_node_by_path(\"/rgb_led\"); \tif (rgb_led_device_node NULL) \t{ \t\tprintk(KERN_ERR \"\\t get rgb_led failed! \\n\"); \t\treturn 1; \t} \trgb_led_red of_get_named_gpio(rgb_led_device_node,\"rgb_led_red\",0); \tif (rgb_led_red < 0) \t{ \t\tprintk(KERN_ERR \"\\t rgb_led_red failed! \\n\"); \t\treturn 1; \t} \trgb_led_green of_get_named_gpio(rgb_led_device_node,\"rgb_led_green\",0); \tif (rgb_led_green < 0) \t{ \t\tprintk(KERN_ERR \"\\t rgb_led_green failed! \\n\"); \t\treturn 1; \t} \trgb_led_blue of_get_named_gpio(rgb_led_device_node,\"rgb_led_blue\",0); \tif (rgb_led_blue < 0) \t{ \t\tprintk(KERN_ERR \"\\t rgb_led_blue failed! \\n\"); \t\treturn 1; \t} gpio_direction_output(rgb_led_red,1); gpio_direction_output(rgb_led_green,1); gpio_direction_output(rgb_led_blue,1); \t/* 注册 字符设备部分 */ \t//第一步 \t//采用动态分配的方式，获取设备编号，次设备号为0， \t//设备名称为rgb leds，可通过命令cat /proc/devices查看 \t//DEV_CNT为1，当前只申请一个设备编号 \tret alloc_chrdev_region(&led_devno, 0, DEV_CNT, DEV_NAME); \tif (ret < 0) \t{ \t\tprintk(\"fail to alloc led_devno\\n\"); \t\tgoto alloc_err; \t} \t//第二步 \t//关联字符设备结构体cdev与文件操作结构体file_operations \tled_chr_dev.owner THIS_MODULE; \tcdev_init(&led_chr_dev, &led_chr_dev_fops); \t//第三步 \t//添加设备至cdev_map散列表中 \tret cdev_add(&led_chr_dev, led_devno, DEV_CNT); \tif (ret < 0) \t{ \t\tprintk(\"fail to add cdev\\n\"); \t\tgoto add_err; \t} \t//第四步 \t/*创建类 */ \tclass_led class_create(THIS_MODULE, DEV_NAME); \t/*创建设备*/ \tdevice device_create(class_led, NULL, led_devno, NULL, DEV_NAME); \treturn 0; add_err: \t//添加设备失败时，需要注销设备号 \tunregister_chrdev_region(led_devno, DEV_CNT); \tprintk(\"\\n error! \\n\"); alloc_err: \treturn 1; } static const struct of_device_id rgb_led[] { \t{.compatible \"fire,rgb_led\"}, \t{/* sentinel */}}; /*定义平台设备结构体*/ struct platform_driver led_platform_driver { \t.probe led_probe, \t.driver { \t\t.name \"rgb leds platform\", \t\t.owner THIS_MODULE, \t\t.of_match_table rgb_led, \t}}; /* *驱动初始化函数 */ static int __init led_platform_driver_init(void) { \tint DriverState; \tkthread_init_worker(&hi_worker); \tDriverState platform_driver_register(&led_platform_driver); \tprintk(KERN_ALERT \"\\tDriverState is %d\\n\", DriverState); \treturn 0; } /* *驱动注销函数 */ static void __exit led_platform_driver_exit(void) { \tkthread_flush_worker(&hi_worker); \tkthread_stop(kworker_task); \tdevice_destroy(class_led, led_devno);\t\t //清除设备 \tclass_destroy(class_led);\t\t\t\t\t //清除类 \tcdev_del(&led_chr_dev);\t\t\t\t\t\t //清除设备号 \tunregister_chrdev_region(led_devno, DEV_CNT); //取消注册字符设备 \t/*注销字符设备*/ \tplatform_driver_unregister(&led_platform_driver); \tprintk(KERN_ALERT \"led_platform_driver exit!\\n\"); } module_init(led_platform_driver_init); module_exit(led_platform_driver_exit); ``` ## 彻底掌握kthread_worker队列化机制 ![image 20250925223027063](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509252230164.png) #### kthread_init_worker()宏 include/linux/kthread.h 初始化kthread_worker ```c #define kthread_init_worker(worker)\t\t\t\t\t\\ \tdo {\t\t\t\t\t\t\t\t\\ \t\tstatic struct lock_class_key __key;\t\t\t\\ \t\t__kthread_init_worker((worker), \"(\"#worker\") >lock\", &__key); \\ \t} while (0) ``` ##### __kthread_init_worker()函数 include/linux/kthread.h ```c void __kthread_init_worker(struct kthread_worker *worker, \t\t\t\tconst char *name, \t\t\t\tstruct lock_class_key *key) { \tmemset(worker, 0, sizeof(struct kthread_worker)); \tspin_lock_init(&worker >lock); // 初始化自旋锁 \tlockdep_set_class_and_name(&worker >lock, key, name); \tINIT_LIST_HEAD(&worker >work_list); \tINIT_LIST_HEAD(&worker >delayed_work_list); } ``` #### kthread_worker_fn()函数 kernel/kthread.c 线程的处理函数 ```c int kthread_worker_fn(void *worker_ptr) { \tstruct kthread_worker *worker worker_ptr; \tstruct kthread_work *work; \t... \tworker >task current; // 记录当前的线程 \tif (worker >flags & KTW_FREEZABLE) \t\tset_freezable(); repeat: // 设置为可以接受中断 \tset_current_state(TASK_INTERRUPTIBLE);\t/* mb paired w/ kthread_stop */ \t// 判断一下是不是需要停止(判断线程标志位kthread_stop函数进行设置) \tif (kthread_should_stop()) { \t\t__set_current_state(TASK_RUNNING); \t\tspin_lock_irq(&worker >lock); \t\tworker >task NULL; \t\tspin_unlock_irq(&worker >lock); \t\t// 线程退出 return 0; \t} \t \twork NULL; \tspin_lock_irq(&worker >lock); \tif (!list_empty(&worker >work_list)) { // 获取第一个工作 \t\twork list_first_entry(&worker >work_list, \t\t\t\t\tstruct kthread_work, node); \t\tlist_del_init(&work >node); \t} \tworker >current_work work; \tspin_unlock_irq(&worker >lock); \tif (work) { \t\t__set_current_state(TASK_RUNNING); \t\t// 具体工作 work >func(work); \t} else if (!freezing(current)) \t\tschedule(); \ttry_to_freeze(); \tcond_resched(); \tgoto repeat; } ``` ##### kthread_should_stop()函数 kernel/kthread.c ```c bool kthread_should_stop(void) { \treturn test_bit(KTHREAD_SHOULD_STOP, &to_kthread(current) >flags); } ``` 调用kthread_stop()函数后，设置线程flags为KTHREAD_SHOULD_STOP #### kthread_init_work()函数 include/linux/kthread.h 初始化kthread_work ```c #define kthread_init_work(work, fn)\t\t\t\t\t\\ \tdo {\t\t\t\t\t\t\t\t\\ \t\tmemset((work), 0, sizeof(struct kthread_work));\t\t\\ \t\tINIT_LIST_HEAD(&(work) >node);\t\t\t\t\\ \t\t(work) >func (fn);\t\t\t\t\t\\ \t} while (0) ``` #### kthread_queue_work()函数 kernel/kthread.c ```c bool kthread_queue_work(struct kthread_worker *worker, \t\t\tstruct kthread_work *work) { \tbool ret false; \tunsigned long flags; \tspin_lock_irqsave(&worker >lock, flags); \tif (!queuing_blocked(worker, work)) { // 判断一下这个任务是不是已经被挂载, 以及这个任务是不是取消了 \t\tkthread_insert_work(worker, work, &worker >work_list); \t\tret true; \t} \tspin_unlock_irqrestore(&worker >lock, flags); \treturn ret; } ``` ##### queuing_blocked()函数 kernel/kthread.c ```c static inline bool queuing_blocked(struct kthread_worker *worker, \t\t\t\t struct kthread_work *work) { \tlockdep_assert_held(&worker >lock); \treturn !list_empty(&work >node) work >canceling; } ``` ##### kthread_insert_work()函数 kernel/kthread.c ```c static void kthread_insert_work(struct kthread_worker *worker, \t\t\t\tstruct kthread_work *work, \t\t\t\tstruct list_head *pos) { \tkthread_insert_work_sanity_check(worker, work); \tlist_add_tail(&work >node, pos); \twork >worker worker; \tif (!worker >current_work && likely(worker >task)) \t\twake_up_process(worker >task); } ``` #### kthread_flush_worker()函数 kernel/kthread.c 实际是在工作链表上面加一个具体的工作, 位于链表的末尾 ```c void kthread_flush_worker(struct kthread_worker *worker) { \tstruct kthread_flush_work fwork { // 初始化一下参数 \t\tKTHREAD_WORK_INIT(fwork.work, kthread_flush_work_fn), \t\t// 初始化completion COMPLETION_INITIALIZER_ONSTACK(fwork.done), \t}; \tkthread_queue_work(worker, &fwork.work); // 阻塞等待当前所有任务结束 \twait_for_completion(&fwork.done); } ``` ##### KTHREAD_WORK_INIT()宏 ```c #define KTHREAD_WORK_INIT(work, fn)\t{\t\t\t\t\\ \t.node LIST_HEAD_INIT((work).node),\t\t\t\t\\ \t.func (fn),\t\t\t\t\t\t\t\\ \t} ``` ##### COMPLETION_INITIALIZER_ONSTACK()宏 include/linux/completion.h ``` (*({ init_completion(&work); &work; })) ``` ##### kthread_flush_work_fn()函数 kernel/kthread.c ```c static void kthread_flush_work_fn(struct kthread_work *work) { \tstruct kthread_flush_work *fwork \t\tcontainer_of(work, struct kthread_flush_work, work); // 释放阻塞 \tcomplete(&fwork >done); } ```"},"/note/Linux/野火Linux/2025-11-16-69-串口.html":{"title":"串口","content":"# 串口 Linux 下通常通过串口和其他设备或传感器进行通信，根据电平的不同，串口分为TTL和RS232。不管是什么样的接口电平，其驱动程序都是一样的，通过外接RS485这样的芯片就可以将串口转换为 RS485信号 同 I2C、SPI一样，Linux也提供了串口驱动框架，我们只需要按照相应的串口框架编写驱动程序即可, 默认厂商会实现这一部分代码 ```c struct uart_driver { \tstruct module\t\t*owner; \tconst char\t\t*driver_name; \tconst char\t\t*dev_name; \tint\t\t\t major; \tint\t\t\t minor; \tint\t\t\t nr; \tstruct console\t\t*cons; \t/* \t * these are private; the low level driver should not \t * touch these; they should be initialised to NULL \t */ \tstruct uart_state\t*state; \tstruct tty_driver\t*tty_driver; }; ``` 在驱动里面需要实现并注册这个玩意 使用另一个结构体`uart_port`描述一个具体的串口的接口定义在 include/linux/serial_core.h 文件 可以使用这个函数给driver添加一个port ```c int uart_add_one_port(struct uart_driver *drv, struct uart_port *uport) ``` uart_port里面记录有ops, 保存相关的操作函数, 保存针对一个端口使用的所有操作, 实际记录的是`imx_pops`, Linux系统收发数据最终调用的都是ops中的函数 ```c static struct uart_ops imx_pops { \t.tx_empty\t imx_tx_empty, \t.set_mctrl\t imx_set_mctrl, \t.get_mctrl\t imx_get_mctrl, \t.stop_tx\t imx_stop_tx, \t.start_tx\t imx_start_tx, \t.stop_rx\t imx_stop_rx, \t.enable_ms\t imx_enable_ms, \t.break_ctl\t imx_break_ctl, \t.startup\t imx_startup, \t.shutdown\t imx_shutdown, \t.flush_buffer\t imx_flush_buffer, \t.set_termios\t imx_set_termios, \t.type\t\t imx_type, \t.config_port\t imx_config_port, \t.verify_port\t imx_verify_port, #if defined(CONFIG_CONSOLE_POLL) \t.poll_init imx_poll_init, \t.poll_get_char imx_poll_get_char, \t.poll_put_char imx_poll_put_char, #endif }; ``` 串口使用中断处理收发的数据, 接受数据以后, 把数据使用`tty_insert_filp_char`把数据给tty ## 串口协议 特性 UART (TTL) RS 232 RS 485 : : : : **本质** **协议** (数据格式) **电气与物理标准** **电气标准** **信号类型** 单端 (对GND) 单端 (对GND)，负逻辑 **差分** (A B线) **电平** 0V & 3.3V/5V **±3V ~ ±15V** **±1.5V ~ ±5V** (差分电压) **通信方式** 全双工 全双工 **半双工** (主流) **传输距离** 极短 (板级) 短 (<15m) **长 (<1200m)** **节点数量** 1对1 1对1 **1对多 (最多32/256)** **抗干扰性** 弱 一般 **强** **常见应用** 芯片间通信 PC串口、设备调试 工业总线、楼宇自动化 ### 485 引脚 名称 功能 1 RO 接收器输出 接RX 2 RE 接收器输出使能（低电平 接收使能） 3 DE 驱动器输出使能（高电平 发送使能） 4 DI 驱动器输入 接TX 5 GND 接地 6 A 驱动器输出/接收器输入（同相） 7 B 驱动器输出/接收器输入（反相） 8 VCC 芯片供电+3.3V ![img](https://pica.zhimg.com/v2 28e9b74fc39ac713813640be5c6a6be8_1440w.jpg) **RS485_EN 为高电平**，逻辑为1，发送使能，接收禁止。 **RS485_EN 为低电平**，逻辑为0，发送禁止，接收使能 > 在**发送数据前**，给RS485_EN 置高电平。 > 在**发送数据后**，给RS485_EN 置低电平。 ### 232 接收端有效的RS 232信号电平介于+3V至+15V之间，或者 3V至 15V之间。具体的讲，输出端当电压介于+5V至15V之间时，驱动器输出为逻辑0，当电压介于 5V至 15V之间，驱动器的输出逻辑是1 ## 设备树 ```json &uart3 { \tpinctrl names \"default\"; \tpinctrl 0 <&pinctrl_uart3>; \tstatus \"okay\"; }; ``` ```c pinctrl_uart3: uart3grp { fsl,pins < MX6UL_PAD_UART3_RX_DATA__UART3_DCE_RX\t0x1b0b1 MX6UL_PAD_UART3_TX_DATA__UART3_DCE_TX\t0x1b0b1 >; }; ``` ## 使用 一般是直接移植com控制软件 也可以自己写一个操控 ```c /** * serial_port.c Linux串口通信程序 * 编译: gcc o serial_port serial_port.c * 使用: ./serial_port /dev/ttyUSB0 115200 */ #include <stdio.h> #include <stdlib.h> #include <string.h> #include <unistd.h> #include <fcntl.h> #include <termios.h> #include <errno.h> #include <sys/ioctl.h> #include <signal.h> #include <time.h> #define BUFFER_SIZE 256 // 全局变量 int serial_fd 1; volatile int keep_running 1; // 信号处理函数，用于优雅退出 void signal_handler(int sig) { keep_running 0; printf(\"\\n程序退出中...\\n\"); } // 打印使用说明 void print_usage(const char *program_name) { printf(\"使用方法: %s <设备文件> <波特率>\\n\", program_name); printf(\"示例: %s /dev/ttyUSB0 115200\\n\", program_name); printf(\"示例: %s /dev/ttyS0 9600\\n\", program_name); } // 配置串口 int configure_serial_port(int fd, int baud_rate) { struct termios options; // 获取当前串口配置 if (tcgetattr(fd, &options) ! 0) { perror(\"tcgetattr失败\"); return 1; } // 设置输入输出波特率 speed_t speed; switch (baud_rate) { case 9600: speed B9600; break; case 19200: speed B19200; break; case 38400: speed B38400; break; case 57600: speed B57600; break; case 115200: speed B115200; break; case 230400: speed B230400; break; default: fprintf(stderr, \"不支持的波特率: %d\\n\", baud_rate); return 1; } cfsetispeed(&options, speed); cfsetospeed(&options, speed); // 设置串口参数 options.c_cflag (CLOCAL CREAD); // 本地连接，启用接收 options.c_cflag & ~CSIZE; // 清除数据位掩码 options.c_cflag CS8; // 8位数据位 options.c_cflag & ~PARENB; // 无奇偶校验 options.c_cflag & ~CSTOPB; // 1位停止位 options.c_cflag & ~CRTSCTS; // 无硬件流控制 // 设置输入模式 options.c_iflag & ~(IXON IXOFF IXANY); // 关闭软件流控制 options.c_iflag & ~(INLCR ICRNL); // 禁止特殊字符处理 // 设置输出模式 options.c_oflag & ~OPOST; // 原始输出 // 设置本地模式 options.c_lflag & ~(ICANON ECHO ECHOE ISIG); // 非规范模式，关闭回显 // 设置超时和最小字符数 options.c_cc[VMIN] 1; // 读取至少1个字符 options.c_cc[VTIME] 10; // 超时时间（单位：0.1秒） // 应用配置 if (tcsetattr(fd, TCSANOW, &options) ! 0) { perror(\"tcsetattr失败\"); return 1; } // 清空缓冲区 tcflush(fd, TCIOFLUSH); return 0; } // 打开串口 int open_serial_port(const char *device_path) { int fd open(device_path, O_RDWR O_NOCTTY O_SYNC); if (fd < 0) { perror(\"打开串口失败\"); return 1; } // 检查是否为tty设备 if (!isatty(fd)) { fprintf(stderr, \"%s 不是tty设备\\n\", device_path); close(fd); return 1; } return fd; } // 发送数据 int send_data(int fd, const unsigned char *data, size_t length) { ssize_t bytes_written write(fd, data, length); if (bytes_written < 0) { perror(\"写入串口失败\"); return 1; } // 等待所有数据发送完成 tcdrain(fd); return bytes_written; } // 接收数据（阻塞模式） int receive_data(int fd, unsigned char *buffer, size_t buffer_size) { fd_set read_fds; struct timeval timeout; int ret; // 设置文件描述符集合 FD_ZERO(&read_fds); FD_SET(fd, &read_fds); // 设置超时时间（5秒） timeout.tv_sec 5; timeout.tv_usec 0; // 等待数据可读 ret select(fd + 1, &read_fds, NULL, NULL, &timeout); if (ret < 0) { perror(\"select失败\"); return 1; } else if (ret 0) { printf(\"接收超时\\n\"); return 0; } // 读取数据 if (FD_ISSET(fd, &read_fds)) { ssize_t bytes_read read(fd, buffer, buffer_size 1); if (bytes_read < 0) { perror(\"读取串口失败\"); return 1; } buffer[bytes_read] '\\0'; // 添加字符串结束符 return bytes_read; } return 0; } // 交互式串口终端 void interactive_terminal(int fd) { unsigned char tx_buffer[BUFFER_SIZE]; unsigned char rx_buffer[BUFFER_SIZE]; printf(\"进入交互模式。输入 'quit' 退出，'hex' 切换十六进制模式。\\n\"); int hex_mode 0; while (keep_running) { printf(\"发送> \"); fflush(stdout); // 读取用户输入 if (fgets((char*)tx_buffer, BUFFER_SIZE, stdin) NULL) { break; } // 处理特殊命令 if (strncmp((char*)tx_buffer, \"quit\", 4) 0) { break; } if (strncmp((char*)tx_buffer, \"hex\", 3) 0) { hex_mode !hex_mode; printf(\"十六进制模式: %s\\n\", hex_mode ? \"开启\" : \"关闭\"); continue; } size_t input_length strlen((char*)tx_buffer); if (input_length > 0 && tx_buffer[input_length 1] '\\n') { tx_buffer[input_length 1] '\\r'; // 将换行符替换为回车符 tx_buffer[input_length] '\\n'; // 添加换行符 input_length++; } // 发送数据 int bytes_sent send_data(fd, tx_buffer, input_length); if (bytes_sent > 0) { printf(\"已发送 %d 字节\\n\", bytes_sent); } // 接收数据 int bytes_received receive_data(fd, rx_buffer, BUFFER_SIZE); if (bytes_received > 0) { printf(\"接收到 %d 字节: \", bytes_received); if (hex_mode) { // 十六进制显示 for (int i 0; i < bytes_received; i++) { printf(\"%02X \", rx_buffer[i]); } printf(\"\\n\"); } else { // 文本显示 for (int i 0; i < bytes_received; i++) { if (rx_buffer[i] > 32 && rx_buffer[i] < 126) { putchar(rx_buffer[i]); } else { printf(\"\\\\x%02X\", rx_buffer[i]); } } printf(\"\\n\"); } } } } int main(int argc, char *argv[]) { if (argc ! 3) { print_usage(argv[0]); return 1; } const char *device_path argv[1]; int baud_rate atoi(argv[2]); // 注册信号处理函数 signal(SIGINT, signal_handler); signal(SIGTERM, signal_handler); // 打开串口 serial_fd open_serial_port(device_path); if (serial_fd < 0) { return 1; } printf(\"成功打开串口: %s\\n\", device_path); // 配置串口 if (configure_serial_port(serial_fd, baud_rate) ! 0) { close(serial_fd); return 1; } printf(\"串口配置成功: %d 波特\\n\", baud_rate); // 进入交互模式 interactive_terminal(serial_fd); // 关闭串口 close(serial_fd); printf(\"串口已关闭\\n\"); return 0; } ```"},"/note/Linux/野火Linux/2025-9-30-46-根文件系统.html":{"title":"根文件系统","content":"# 根文件系统 根文件系统首先是内核启动时所mount的第一个文件系统，内核代码映像文件保存在根文件系 统中，而系统引导启动程序会在根文件系统挂载之后从中把一些基本的初始化脚本和服务等加 载到内存中去运行 [IMX6ULL Linux根文件系统(rootfs)构建 树·哥 博客园](https://www.cnblogs.com/zzssdd2/p/15485283.html) ## 目录简介 + **/bin** 目录, 该目录下的命令可以被root与一般账号所使用，由于这些命令在挂接其它文件系统之前就可以 使用，所以/bin 目录必须和根文件系统在同一个分区中。/bin目录下常用的命令有：cat、chgrp、 chmod、cp、ls、sh、kill、mount、umount、mkdir 等。我们之后在利用Busybox制作根文件系统时， 在生成的bin目录下，可以看到一些可执行的文件，也就是可用的一些命令。 + **/sbin** 目录: 该目录下存放系统命令，即只有系统管理员（俗称最高权限的root）能够使用的命令，系统命令 还可以存放在/usr/sbin,/usr/local/sbin 目录下，/sbin 目录中存放的是基本的系统命令，它们用于启 动系统和修复系统等，与/bin目录相似，在挂接其他文件系统之前就可以使用/sbin，所以/sbin目 录必须和根文件系统在同一个分区中。/sbin目录下常用的命令有：shutdown、reboot、fdisk、fsck、 init 等，本地用户自己安装的系统命令放在/usr/local/sbin目录下。 + **/dev** 目录 该目录下存放的是设备与设备接口的文件，设备文件是Linux中特有的文件类型，在Linux系 统下，以文件的方式访问各种设备，即通过读写某个设备文件操作某个具体硬件。比如通过” dev/ttySAC0”文件可以操作串口0，通过”/dev/mtdblock1”可以访问MTD设备的第2个分区。比 较重要的文件有/dev/null,/dev/zero, /dev/tty, /dev/lp* 等。 + **/etc** 目录 该目录下存放着系统主要的配置文件，例如人员的账号密码文件、各种服务的其实文件等。一般 来说，此目录的各文件属性是可以让一般用户查阅的，但是只有root有权限修改。对于PC上的 Linux 系统，/etc目录下的文件和目录非常多，这些目录文件是可选的，它们依赖于系统中所拥有 的应用程序，依赖于这些程序是否需要配置文件。在嵌入式系统中，这些内容可以大为精减。 + **/lib** 目录 该目录下存放共享库和可加载（驱动程序），共享库用于启动系统。运行根文件系统中的可执行 程序，比如：/bin/sbin目录下的程序。 + **/home** 目录 系统默认的用户文件夹，它是可选的，对于每个普通用户，在/home目录下都有一个以用户名命 名的子目录，里面存放用户相关的配置文件。 + **/root** 目录 系统管理员（root）的主文件夹，即是根用户的目录，与此对应，普通用户的目录是/home下的某 个子目录。 + **/usr** 目录 /usr 目录的内容可以存在另一个分区中，在系统启动后再挂接到根文件系统中的/usr目录下。里 面存放的是共享、只读的程序和数据，这表明/usr目录下的内容可以在多个主机间共享，这些主 要也符合FHS标准的。/usr中的文件应该是只读的，其他主机相关的，可变的文件应该保存在其 他目录下，比如/var。/usr目录在嵌入式中可以精减。 + **/var** 目录 与/usr 目录相反，/var目录中存放可变的数据，比如spool目录（mail,news），log文件，临时文件 + **/proc** 目录 这是一个空目录，常作为proc文件系统的挂接点，proc文件系统是个虚拟的文件系统，它没有 实际的存储设备，里面的目录，文件都是由内核临时生成的，用来表示系统的运行状态，也可以 操作其中的文件控制系统。 + **/mnt** 目录 用于临时挂载某个文件系统的挂接点，通常是空目录，也可以在里面创建一引起空的子目录，比 如/mnt/cdram /mnt/hda1 。用来临时挂载光盘、移动存储设备等。 + **/tmp** 目录 用于存放临时文件，通常是空目录，一些需要生成临时文件的程序用到的/tmp目录下，所以/tmp 目录必须存在并可以访问 + **/sys** 作为sysfs文件系统的挂载点，sysfs是一个类似于proc文件系统的特 殊文件系统，sysfs也是基于ram的文件系统，也就是说它也没有实际的存储设备。此目录是系 统设备管理的重要目录，此目录通过一定的组织结构向用户提供详细的内核数据结构信息 > 而/boot 这个目录则取决于你所使用的BootLoader是否能够重新获得内核映象从你的根文件系统在内核 启动之前。一般说来，只有/bin，/dev，/etc，/lib，/proc，/var，/usr这些需要的，而其他都是可选 的 ![image 20251001154501253](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510011545317.png) ## Ubuntu根文件系统 Ubuntu 针对不同的 CPU 架构提供相应的 ubuntu base 根文件系统，目前提供的架构有 amd64、 arm64、armhf、i386、s390x、ppc64 https://manpages.debian.org/bullseye/multistrap/multistrap.1.en.html ### 下载 [Ubuntu Base 20.04.5 LTS (Focal Fossa)](https://cdimage.ubuntu.com/ubuntu base/releases/20.04/release/) ![image 20251001154841521](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510011548576.png) ### 初始化 ```bash tar vxf ubuntu base 20.04.1 base armhf.tar.gz ls /usr/bin/qemu arm static ./usr/bin cp /usr/bin/qemu arm static ./usr/bin/ sudo cp ./etc/apt/sources.list ./etc/apt/sources.list.back sudo echo \"nameserver 8.8.8.8\" > ./etc/resolv.conf sudo vim ./etc/apt/sources.list ``` > ``` > deb https://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse > deb src https://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse > > deb https://mirrors.aliyun.com/ubuntu/ focal security main restricted universe multiverse > deb src https://mirrors.aliyun.com/ubuntu/ focal security main restricted universe multiverse > > deb https://mirrors.aliyun.com/ubuntu/ focal updates main restricted universe multiverse > deb src https://mirrors.aliyun.com/ubuntu/ focal updates main restricted universe multiverse > > # deb https://mirrors.aliyun.com/ubuntu/ focal proposed main restricted universe multiverse > # deb src https://mirrors.aliyun.com/ubuntu/ focal proposed main restricted universe multiverse > > deb https://mirrors.aliyun.com/ubuntu/ focal backports main restricted universe multiverse > deb src https://mirrors.aliyun.com/ubuntu/ focal backports main restricted universe multiverse > ``` > > 使用上面的 `sudo cp /usr/bin/qemu arm static ./usr/bin/` `sudo cp b /etc/resolv.conf ./etc/resolv.conf` 使用下面的脚本 ```bash #!/bin/bash function mnt() { echo \"MOUNTING\" sudo mount t proc /proc ${2}proc sudo mount t sysfs /sys ${2}sys sudo mount o bind /dev ${2}dev sudo mount o bind /dev/pts ${2}dev/pts sudo chroot ${2} } function umnt(){ echo \"UNMOUNTING\" sudo umount ${2}proc sudo umount ${2}sys sudo umount ${2}dev/pts sudo umount ${2}dev } if [ \"$1\" \" m\" ] && [ n \"$2\" ] ; then mnt $1 $2 elif [ \"$1\" \" u\" ] && [ n \"$2\" ]; then umnt $1 $2 else echo \"\" echo \"Either 1'st, 2'nd or bothparameters were missing\" echo \"\" echo \"1'st parameter can be one ofthese: m(mount) OR u(umount)\" echo \"2'nd parameter is the full pathof rootfs directory(with trailing '/')\" echo \"\" echo \"For example: ch mount m/media/sdcard/\" echo \"\" echo 1st parameter : ${1} echo 2nd parameter : ${2} fi ``` 使用命令进入 `sudo bashch mount.sh m ./` 之后可以使用`apt update`进行更新以及软件的安装 ## Debian ### multistrap 失败 我们这里使用目前Debian社区较为推荐的Multistrap构建Debian根文件系统，与传统的deboot strap 不同，multistrap 在包的选择上更具灵活性 ```bash touch ./config_file mkdir ./rootfs vim ./config_file ``` ```c [General] #directory target rootfs cleanup true noauth true unpack true debootstrap Debian Net Utils Ebf aptsources Debian noauth true # GPG error [Debian] packages apt kmod lsof #source https://mirrors.sjtug.sjtu.edu.cn/debian/ source https://mirrors.tuna.tsinghua.edu.cn/debian/ keyring debian archive keyring suite buster components main contrib non free [Net] # Basic packages to enable the networking packages netbase net tools ethtool udev iproute2 iputils ping ifupdownisc dhcp client ssh #source https://mirrors.sjtug.sjtu.edu.cn/debian/ source https://mirrors.tuna.tsinghua.edu.cn/debian/ [Utils] # General purpose utilities packages locales vim adduser less wget dialog usbutils #source https://mirrors.sjtug.sjtu.edu.cn/debian/ source https://mirrors.tuna.tsinghua.edu.cn/debian/ [Lhf] packages python3 mate desktop environment source http://mirrors.bfsu.edu.cn/debian suite buster components main contrib non free [Ebf] packages ifupdown rsyslog htop iputils ping source http://mirrors.bfsu.edu.cn/debian suite buster components main ``` > 其中之需要将需要的安装包添加到[Ebf]中的packages即可 > > ``` > directory target rootfs # 目标根文件系统目录 > cleanup true # 清理临时文件 > noauth true # 跳过GPG验证（可能因网络问题） > unpack true # 解压包文件 > debootstrap Debian Net Utils Ebf # 按顺序执行这些段 > aptsources Debian # 使用Debian段的配置作为APT源 > ``` > > **[Debian] 段** > > 基础系统包： > > `apt` 包管理工具 > `kmod` 内核模块管理 > `lsof` 列出打开文件 > > **[Net] 段** > > 网络相关包： > > `netbase` 基本网络配置 > `net tools`, `iproute2` 网络工具 > `ssh` SSH客户端/服务器 > `isc dhcp client` DHCP客户端 > > **[Utils] 段** > > 实用工具： > > `vim` 文本编辑器 > `wget` 下载工具 > `locales` 本地化支持 > > **[Lhf] 段** > > 桌面环境： > > `python3` > `mate desktop environment` MATE桌面 > > **[Ebf] 段** > > 额外系统工具： > > `rsyslog` 系统日志 > `htop` 进程查看器 运行下面的命令`multistrap a armhf d ./rootfs/ f ./config_file` ### debootstrap [debootstrap 制作根文件系统 红豆の布丁 博客园](https://www.cnblogs.com/huaibovip/p/debootstrap fs.html) ```bash sudo apt get install debian archive keyring sudo apt get install qemu qemu user static binfmt support debootstrap ``` 当前debootstrap支持的发行版本可以在`/usr/share/debootstrap/scripts`查看，而各发行版代号可以到`http://en.wikipedia.org/wiki/List_of_Ubuntu_releases`查看。 > Debian 发行版 > > Debian的代号来自《玩具总动员》角色： > > **稳定版 (按发布时间顺序)：** > > `potato` Debian 2.2 (2000年) > `woody` Debian 3.0 (2002年) > `sarge` Debian 3.1 (2005年) > `etch` Debian 4.0 (2007年) > `lenny` Debian 5.0 (2009年) > `squeeze` Debian 6.0 (2011年) > `wheezy` Debian 7 (2013年) > `jessie` Debian 8 (2015年) > `stretch` Debian 9 (2017年) > `buster` Debian 10 (2019年) > `bullseye` Debian 11 (2021年) > `bookworm` Debian 12 (2023年) > > **开发版本：** > > `sid` 不稳定版 (永远的代号) > `testing` 测试版 (滚动代号) > `unstable` 不稳定版 (同sid) > `stable` 稳定版 (滚动代号，当前指向bookworm) > `oldstable` 旧稳定版 (滚动代号，当前指向bullseye) > `oldoldstable` 旧旧稳定版 (滚动代号，当前指向buster) > > **特殊版本：** > > `jessie kfreebsd` 基于FreeBSD内核的Debian变体 > > Ubuntu 发行版 > > Ubuntu的代号采用\"形容词+动物\"格式，首字母相同： > > **按发布时间顺序：** > > `warty` Ubuntu 4.10 (2004年) > `hoary` Ubuntu 5.04 (2005年) > `breezy` Ubuntu 5.10 (2005年) > `dapper` Ubuntu 6.06 LTS (2006年) > `edgy` Ubuntu 6.10 (2006年) > `feisty` Ubuntu 7.04 (2007年) > `gutsy` Ubuntu 7.10 (2007年) > `hardy` Ubuntu 8.04 LTS (2008年) > `intrepid` Ubuntu 8.10 (2008年) > `jaunty` Ubuntu 9.04 (2009年) > `karmic` Ubuntu 9.10 (2009年) > `lucid` Ubuntu 10.04 LTS (2010年) > `maverick` Ubuntu 10.10 (2010年) > `natty` Ubuntu 11.04 (2011年) > `oneiric` Ubuntu 11.10 (2011年) > `precise` Ubuntu 12.04 LTS (2012年) > `quantal` Ubuntu 12.10 (2012年) > `raring` Ubuntu 13.04 (2013年) > `saucy` Ubuntu 13.10 (2013年) > `trusty` Ubuntu 14.04 LTS (2014年) > `utopic` Ubuntu 14.10 (2014年) > `vivid` Ubuntu 15.04 (2015年) > `wily` Ubuntu 15.10 (2015年) > `xenial` Ubuntu 16.04 LTS (2016年) > `yakkety` Ubuntu 16.10 (2016年) > `zesty` Ubuntu 17.04 (2017年) > `artful` Ubuntu 17.10 (2017年) > `bionic` Ubuntu 18.04 LTS (2018年) > `cosmic` Ubuntu 18.10 (2018年) > `disco` Ubuntu 19.04 (2019年) > `eoan` Ubuntu 19.10 (2019年) > > Kali Linux 发行版 > > Kali基于Debian，专门用于渗透测试： > > `kali` 早期版本 > `kali dev` 开发版 > `kali last snapshot` 最后快照 > `kali rolling` 滚动发行版 ```bash sudo debootstrap arch armhf bionic linux rootfs http://mirrors.ustc.edu.cn/ubuntu ports/ sudo cp a /usr/bin/qemu arm static ~/build/linux rootfs/usr/bin/qemu arm static ``` > 安装ubuntu18.4 > > –variant minbase：指定构建基础的ubuntu发行版本 > > include ${DEBOOTSTRAP_LIST// /,}：DEBOOTSTRAP_LIST为需要安装的包列表 > > ${PACKAGE_LIST_EXCLUDE:+ exclude ${PACKAGE_LIST_EXCLUDE// /,}}：PACKAGE_LIST_EXCLUDE为不需要安装的包列表 > > arch $DISTRIB_ARCH：DISTRIB_ARCH为构建的目标架构，针对arm架构可以选择：arm64, armhf > > components ${DEBOOTSTRAP_COMPONENTS}：DEBOOTSTRAP_COMPONENTS代表仓库中的：main restricted universe multiverse > > foreign $DISTRIB_RELEASE：DISTRIB_RELEASE为发行版本类型，如bionic focal > > $ROOTFS_TEMP：构建文件的生成地址 > > $apt_mirror：拉取包的源地址，如国内源：https://mirrors.tuna.tsinghua.edu.cn/ubuntu ports/ > ## 烧录 ### USB烧录 在使用mfgtool可以查看一下当前cfg.ini 使用的是哪一个根文件系统，我这里使用的是 console armhf rootfs lubancat buster.tar 我们将上面章节获得的根文件夹打包`tar cvf ./rootfs/./console armhf rootfs lubancat buster.tar` [6. 烧写系统 — [野火\\]快速使用手册——基于i.MX6ULL开发板 文档](https://doc.embedfire.com/linux/imx6/quick_start/zh/latest/quick_start/install_debian/install_debian.html) ### SD卡 `tar cvf ./rootfs/ ./rootfs.tar` 替换build_sd_img.sh文件夹里面的文件 等脚本运行完在当前目录会出现一个名为imx6ull.img.xz的文件"},"/note/Linux/野火Linux/2025-9-26-32-SPI.html":{"title":"","content":"## SPI物理总线 ## 基础知识 ### 信号线 SCK：时钟线，数据收发同步 MOSI：数据线，主设备数据发送、从设备数据接收 MISO：数据线，从设备数据发送，主设备数据接收 NSS、CS：片选信号线 支持一主多从，全双工通信，最大速率可达上百MHz ![image 20200912081954858](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509262016237.png) ### spi时序 ![image 20200912083029061](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509262016148.png) 起始信号：NSS 信号线由高变低 停止信号：NSS 信号由低变高 数据传输：在 SCK的每个时钟周期 MOSI和 MISO同时传输一位数据，高/低位传输没有硬性规定 传输单位： 8 位或 16 位 单位数量：不受限制 #### spi通信模式 总线空闲时 SCK 的时钟状态以及数据采样时刻 时钟极性 CPOL：指 SPI 通讯设备处于空闲状态时，SCK信号线的电平信号 CPOL 0时， SCK在空闲状态时为低电平 CPOL 1时， SCK在空闲状态时为高电平 时钟相位 CPHA：数据的采样的时刻 当 CPHA 0 时，数据在 SCK 时钟线的“奇数边沿”被采样 当 CPHA 1时，数据在 SCK 时钟线的“偶数边沿”被采样 ##### 案例 ![image 20200912084313769](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509262016794.png) SCK信号线在空闲状态为低电平时，CPOL 0；空闲状态为高电平时，CPOL 1 CPHA 0，数据在 SCK 时钟线的“奇数边沿”被采样 当 CPOL 0 的时候，时钟的奇数边沿是上升沿 当CPOL 1 的时候，时钟的奇数边沿是下降沿 ##### 四大模式 ![image 20200912084116532](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509262016704.png) ## SPI驱动框架简介 ### SPI框架图 ![image 20200904124712459](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509271037021.png) SPI核心层 提供SPI控制器驱动和设备驱动的注册方法、注销方法、SPI通信硬件无关接口 SPI主机驱动 主要包含SPI硬件体系结构中适配器(spi控制器)的控制，用于产生SPI 读写时序 主要数据结构：spi_master(spi_controller) SPI设备驱动 通过SPI主机驱动与CPU交换数据 主要数据结构：spi_device和spi_driver ### 核心数据结构 ##### spi_master include/linux/spi/spi.h ```c #define spi_master\t\t\tspi_controller ``` ##### spi_controller include/linux/spi/spi.h ```c struct spi_controller { \tstruct device\tdev; // 设备 \t... \tstruct list_head list; // 链表节点, 可能有多个控制器 \ts16\t\t\tbus_num; // 编号 \tu16\t\t\tnum_chipselect; // 片选信号的数量 \t... \tstruct spi_message\t\t*cur_msg; // 表示需要发送的信息 \t... \tint\t\t\t(*setup)(struct spi_device *spi); // 初始化使用的函数指针 \tint\t\t\t(*transfer)(struct spi_device *spi, \t\t\t\t\t\tstruct spi_message *mesg); // 传输消息(异步传输) \tvoid\t\t(*cleanup)(struct spi_device *spi); // 清理工作 \tstruct kthread_worker\t\tkworker; // 一个处理工人 \tstruct task_struct\t\t*kworker_task; // 指向实际的处理task \tstruct kthread_work\t\tpump_messages; // 具体的工作 \tstruct list_head\t\tqueue; // 一系列的消息 \tstruct spi_message\t\t*cur_msg; \t \t... \tint (*transfer_one)(struct spi_controller *ctlr, struct spi_device *spi,struct spi_transfer *transfer); \tint (*prepare_transfer_hardware)(struct spi_controller *ctlr); \tint (*transfer_one_message)(struct spi_controller *ctlr,struct spi_message *mesg); \tvoid (*set_cs)(struct spi_device *spi, bool enable); \t... \tint\t\t\t*cs_gpios; // 具体的片选信号 } ``` list：链表节点，芯片可能有多个spi控制器 bus_num：spi控制器编号 num_chipselect：片选信号的个数 cur_msg：当前正带处理的消息队列 transfer ：用于把数据加入控制器的消息链表中 cleanup：当spi_master被释放的时候，完成清理工作 kworker：内核线程工人，spi可以使用异步传输方式发送数据 pump_messages：具体传输工作 queue：所有等待传输的消息队列挂在该链表下 transfer_one_message：发送一个spi消息，类似IIC适配器里的algo >master_xfer，产生spi通信时序 相关API `int spi_register_master(struct spi_master *master)` 注册一个spi_controller `void spi_unregister_master(struct spi_master *master)` 注销一个spi_controller ##### spi_device include/linux/spi/spi.h ```c struct spi_device { \tstruct device\t\tdev; \tstruct spi_controller\t*controller; // 控制器 \tstruct spi_controller\t*master;\t/* compatibility layer */ \tu32\t\t\tmax_speed_hz; // 通信最大频率 \tu8\t\t\tchip_select; // 片选 \tu8\t\t\tbits_per_word; // 传输单位 \tu16\t\t\tmode; // 四种模式 #define\tSPI_CPHA\t0x01\t\t\t/* clock phase */ #define\tSPI_CPOL\t0x02\t\t\t/* clock polarity */ #define\tSPI_MODE_0\t(00)\t\t\t/* (original MicroWire) */ #define\tSPI_MODE_1\t(0SPI_CPHA) #define\tSPI_MODE_2\t(SPI_CPOL0) #define\tSPI_MODE_3\t(SPI_CPOLSPI_CPHA) #define\tSPI_CS_HIGH\t0x04\t\t\t/* chipselect active high? */ #define\tSPI_LSB_FIRST\t0x08\t\t\t/* per word bits on wire */ #define\tSPI_3WIRE\t0x10\t\t\t/* SI/SO signals shared */ #define\tSPI_LOOP\t0x20\t\t\t/* loopback mode */ #define\tSPI_NO_CS\t0x40\t\t\t/* 1 dev/bus, no chipselect */ #define\tSPI_READY\t0x80\t\t\t/* slave pulls low to pause */ #define\tSPI_TX_DUAL\t0x100\t\t\t/* transmit with 2 wires */ #define\tSPI_TX_QUAD\t0x200\t\t\t/* transmit with 4 wires */ #define\tSPI_RX_DUAL\t0x400\t\t\t/* receive with 2 wires */ #define\tSPI_RX_QUAD\t0x800\t\t\t/* receive with 4 wires */ ... \tchar\t\t\tmodalias[SPI_NAME_SIZE]; // 名字, 配对使用 ... } ``` ##### spi_driver include/linux/spi/spi.h ```c struct spi_driver { \tconst struct spi_device_id *id_table; // 名字 \tint\t\t\t(*probe)(struct spi_device *spi); \tint\t\t\t(*remove)(struct spi_device *spi); \tvoid\t\t\t(*shutdown)(struct spi_device *spi); \tstruct device_driver\tdriver; }; ``` probe：spi设备和spi驱动匹配后，回调该函数指针 相关API： `int spi_register_driver(struct spi_driver *sdrv)` 注册一个spi驱动 `void spi_unregister_driver(struct spi_driver *sdrv)` 注册一个spi驱动 ### 总线注册 #### spi_init函数 drivers/spi/spi.c 这个是自动调用的 ```c static int __init spi_init(void) { \tint\tstatus; \t... \tstatus bus_register(&spi_bus_type); // 生成/sys/bus/spi \t... \tstatus class_register(&spi_master_class); // 生成/sys/class/spi_master \t... } ``` #### spi总线定义 实际使用的匹配规则 ```c struct bus_type spi_bus_type { \t.name\t\t \"spi\", \t.dev_groups\t spi_dev_groups, \t.match\t\t spi_match_device, \t.uevent\t\t spi_uevent, }; ``` #### spi_match_device()函数 drivers/spi/spi.c 进行匹配的函数 ```c static int spi_match_device(struct device *dev, struct device_driver *drv) { \tconst struct spi_device\t*spi to_spi_device(dev); \tconst struct spi_driver\t*sdrv to_spi_driver(drv); \t/* Attempt an OF style match */ \tif (of_driver_match_device(dev, drv)) \t\treturn 1; \t/* Then try ACPI */ \tif (acpi_driver_match_device(dev, drv)) \t\treturn 1; \tif (sdrv >id_table) \t\treturn !!spi_match_id(sdrv >id_table, spi); \treturn strcmp(spi >modalias, drv >name) 0; } ``` #### 设备树节点 arch/arm/boot/dts/imx6ull.dtsi 4个spi控制器节点 ```json ecspi3: ecspi@2010000 { \t\t\t\t\t#address cells <1>; \t\t\t\t\t#size cells <0>; \t\t\t\t\tcompatible \"fsl,imx6ul ecspi\", \"fsl,imx51 ecspi\"; \t\t\t\t\treg <0x2010000 0x4000>; \t\t\t\t\tinterrupts <GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>; \t\t\t\t// 时钟体系 \t\t\t\t\tclocks <&clks IMX6UL_CLK_ECSPI3>, \t\t\t\t\t\t <&clks IMX6UL_CLK_ECSPI3>; \t\t\t\t\tclock names \"ipg\", \"per\"; \t\t\t\t\t// DMA传输 \t\t\t\tdmas <&sdma 7 7 1>, <&sdma 8 7 2>; \t\t\t\t\tdma names \"rx\", \"tx\"; \t\t\t\t\tstatus \"disabled\"; \t\t\t\t}; ``` ### 总线驱动 #### module_platform_driver()宏 include/linux/platform_device.h spi总线注册的时候调用的函数 ```c #define module_platform_driver(__platform_driver) \\ \tmodule_driver(__platform_driver, platform_driver_register, \\ \t\t\tplatform_driver_unregister) ``` ###### module_driver()宏 include/linux/device.h 定义一个函数同时定义为模块的入口函数 ```c #define module_driver(__driver, __register, __unregister, ...) \\ static int __init __driver##_init(void) \\ { \\ \treturn __register(&(__driver) , ##__VA_ARGS__); \\ } \\ module_init(__driver##_init); \\ ``` __driver：spi_imx_driver __register：platform_driver_register __unregister：platform_driver_unregister \\##\\__VA_ARGS__：可变参数 ###### module_platform_driver(spi_imx_driver) 对这个宏定义进行展开以后得结构 ``` static int __init spi_imx_driver_init(void) \\ { \\ \treturn platform_driver_register(&(spi_imx_driver) , ##__VA_ARGS__); \\ } \\ module_init(spi_imx_driver_init); \\ ``` #### SPI主控制器驱动 ##### spi_imx_probe()函数 获取设备树节点信息，初始化spi时钟、dma... 保存spi寄存器起始地址，填充spi控制器回调函数 drivers/spi/spi imx.c ![image 20250927113042133](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509271130213.png) ```c static int spi_imx_probe(struct platform_device *pdev) { \tstruct device_node *np pdev >dev.of_node; \tconst struct of_device_id *of_id \t\t\tof_match_device(spi_imx_dt_ids, &pdev >dev); \tstruct spi_imx_master *mxc_platform_info \t\t\tdev_get_platdata(&pdev >dev); \tstruct spi_master *master; \tstruct spi_imx_data *spi_imx; \tstruct resource *res; \tconst struct spi_imx_devtype_data *devtype_data of_id ? of_id >data : \t\t(struct spi_imx_devtype_data *)pdev >id_entry >driver_data; \tbool slave_mode; \t... \tslave_mode devtype_data >has_slavemode && \t\t\tof_property_read_bool(np, \"spi slave\"); // 获取主从模式 // 初始化一下结构的driver_data指针 \tif (slave_mode) // 从模式 \t\tmaster spi_alloc_slave(&pdev >dev, \t\t\t\t\t sizeof(struct spi_imx_data)); \telse // 主模式 \t\tmaster spi_alloc_master(&pdev >dev, \t\t\t\t\t sizeof(struct spi_imx_data)); \tif (!master) \t\treturn ENOMEM; \t... // 获取到driver_data这个对象 spi_imx spi_master_get_devdata(master); ... // 片选的数量 \t\tret of_property_read_u32(np, \"fsl,spi num chipselects\", &num_cs); if (ret < 0) { if (mxc_platform_info) { num_cs mxc_platform_info >num_chipselect; master >num_chipselect num_cs; } } else { master >num_chipselect num_cs; // 记录片选信号的数量 } \t// bitbang用于使用普通的GPIO模拟时序 \tspi_imx >bitbang.master master; \tspi_imx >dev &pdev >dev; \tspi_imx >slave_mode slave_mode; \tspi_imx >devtype_data devtype_data; \t// 初始化一个记录GPIO的数组 \tmaster >cs_gpios devm_kzalloc(&master >dev, \t\t\tsizeof(int) * master >num_chipselect, GFP_KERNEL); \t// 回调函数(模拟SPI) \tspi_imx >bitbang.chipselect spi_imx_chipselect; \tspi_imx >bitbang.setup_transfer spi_imx_setupxfer; \tspi_imx >bitbang.txrx_bufs spi_imx_transfer; \tspi_imx >bitbang.master >setup spi_imx_setup; \tspi_imx >bitbang.master >cleanup spi_imx_cleanup; \tspi_imx >bitbang.master >prepare_message spi_imx_prepare_message; \tspi_imx >bitbang.master >unprepare_message spi_imx_unprepare_message; \tspi_imx >bitbang.master >slave_abort spi_imx_slave_abort; \tspi_imx >bitbang.master >mode_bits SPI_CPOL SPI_CPHA SPI_CS_HIGH \\ \t... \tinit_completion(&spi_imx >xfer_done); \t// 获取SPI的基地址 \tres platform_get_resource(pdev, IORESOURCE_MEM, 0); \tspi_imx >base devm_ioremap_resource(&pdev >dev, res); \t... // 处理模拟SPI \tret spi_bitbang_start(&spi_imx >bitbang); \t... } ``` ##### spi_bitbang_start()函数 drivers/spi/spi bitbang.c ```c int spi_bitbang_start(struct spi_bitbang *bitbang) { \tstruct spi_master *master bitbang >master; \tint ret; \tif (!master !bitbang >chipselect) \t\treturn EINVAL; \tmutex_init(&bitbang >lock); \tif (!master >mode_bits) \t\tmaster >mode_bits SPI_CPOL SPI_CPHA bitbang >flags; \tif (master >transfer master >transfer_one_message) \t\treturn EINVAL; \tmaster >prepare_transfer_hardware spi_bitbang_prepare_hardware; \tmaster >unprepare_transfer_hardware spi_bitbang_unprepare_hardware; \tmaster >transfer_one spi_bitbang_transfer_one; \tmaster >set_cs spi_bitbang_set_cs; \tif (!bitbang >txrx_bufs) { \t\tbitbang >use_dma 0; \t\tbitbang >txrx_bufs spi_bitbang_bufs; \t\tif (!master >setup) { \t\t\tif (!bitbang >setup_transfer) \t\t\t\tbitbang >setup_transfer \t\t\t\t\t spi_bitbang_setup_transfer; \t\t\tmaster >setup spi_bitbang_setup; \t\t\tmaster >cleanup spi_bitbang_cleanup; \t\t} \t} \t/* driver may get busy before register() returns, especially \t * if someone registered boardinfo for devices \t */ // 注册到Linux里面 \tret spi_register_master(spi_master_get(master)); \tif (ret) \t\tspi_master_put(master); \treturn ret; } EXPORT_SYMBOL_GPL(spi_bitbang_start); ``` ## 核心API ![image 20250927123351813](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509271233908.png) ### 配置函数(设备树自动设置) #### spi_setup()函数 设置spi设备的片选信号、传输单位、最大传输速率... drivers/spi/spi.c ```c int spi_setup(struct spi_device *spi) { \tunsigned\tbad_bits, ugly_bits; \tint\t\tstatus; \t... // 初始化数据的长度 \tstatus __spi_validate_bits_per_word(spi >controller, \t\t\t\t\t spi >bits_per_word); \t... // 初始化一下数据的传输速率 \tspi >max_speed_hz spi >controller >max_speed_hz; \t... \tif (spi >controller >setup) // 调用spi_imx_setup函数 \t\tstatus spi >controller >setup(spi); \t... \treturn status; } ``` #### spi_imx_setup()函数 drivers/spi/spi imx.c ```c static int spi_imx_setup(struct spi_device *spi) { \tdev_dbg(&spi >dev, \"%s: mode %d, %u bpw, %d hz\\n\", __func__, \t\t spi >mode, spi >bits_per_word, spi >max_speed_hz); \t// 看一下是不是使用CS \tif (spi >mode & SPI_NO_CS) \t\treturn 0; \tif (gpio_is_valid(spi >cs_gpio)) // 设置为输出模式 \t\tgpio_direction_output(spi >cs_gpio, \t\t\t\t spi >mode & SPI_CS_HIGH ? 0 : 1); \tspi_imx_chipselect(spi, BITBANG_CS_INACTIVE); \treturn 0; } ``` #### spi_imx_chipselect()函数 drivers/spi/spi imx.c 进行设备的片选 ```c static void spi_imx_chipselect(struct spi_device *spi, int is_active) { \tint active is_active ! BITBANG_CS_INACTIVE; \tint dev_is_lowactive !(spi >mode & SPI_CS_HIGH); // 查找一下有效信号的电平 \tif (spi >mode & SPI_NO_CS) \t\treturn; \tif (!gpio_is_valid(spi >cs_gpio)) \t\treturn; \t// 设置电平 \tgpio_set_value(spi >cs_gpio, dev_is_lowactive ^ active); } ``` ### 数据传输(重要) ##### spi_message_init()函数 include/linux/spi/spi.h ```c static inline void spi_message_init(struct spi_message *m) { \tmemset(m, 0, sizeof *m); \tspi_message_init_no_memset(m); // 初始化两个链表 } ``` ###### spi_message_init_no_memset()函数 ```c static inline void spi_message_init_no_memset(struct spi_message *m) { \tINIT_LIST_HEAD(&m >transfers); \tINIT_LIST_HEAD(&m >resources); } ``` ###### spi_message结构体 include/linux/spi/spi.h ```c struct spi_message { \tstruct list_head\ttransfers; \tstruct spi_device\t*spi; // 属于的设备 \t... \tvoid\t\t\t(*complete)(void *context); // 传输成功回调 \tvoid\t\t\t*context; \tunsigned\t\tframe_length; \tunsigned\t\tactual_length; \tint\t\t\tstatus; \t... \tstruct list_head\tqueue; // 内核异步传输使用 \tvoid\t\t\t*state; \t/* list of spi_res reources when the spi message is processed */ \tstruct list_head resources; // 记录相关资源 }; ``` ##### spi_message_add_tail()函数 include/linux/spi/spi.h 添加节点到链表 ```c spi_message_add_tail(struct spi_transfer *t, struct spi_message *m) { \tlist_add_tail(&t >transfer_list, &m >transfers); } ``` ###### spi_transfer结构体 include/linux/spi/spi.h 是spi message里面的一个基础元素 ```c struct spi_transfer { \tconst void\t*tx_buf; // 发送的buf \tvoid\t\t*rx_buf; // 接收的buf \tunsigned\tlen; \t... \tu32\t\tspeed_hz; \tstruct list_head transfer_list; }; ``` ##### spi_sync()函数 drivers/spi/spi.c 同步传输数据，阻塞当前线程 ``` int spi_sync(struct spi_device *spi, struct spi_message *message) ``` ##### spi_async()函数 drivers/spi/spi.c 异步传输数据，不会阻塞当前线程 ```c int spi_async(struct spi_device *spi, struct spi_message *message) ``` ##### spi_read/write 上面的函数可以使用这两个内核封装以后得函数进行替代 ```c static inline int spi_read(struct spi_device *spi, void *buf, size_t len); static inline int spi_write(struct spi_device *spi, const void *buf, size_t len); int spi_write_then_read(struct spi_device *spi, \t\tconst void *txbuf, unsigned n_tx, \t\tvoid *rxbuf, unsigned n_rx); ``` 这两个函数使用的是sync ## SPI数据传输剖析：同步、异步 #### spi_register_master()函数 include/linux/spi/spi.h ```c #define spi_register_master(_ctlr)\tspi_register_controller(_ctlr) ``` ##### spi_register_controller()函数 drivers/spi/spi.c ```c int spi_register_controller(struct spi_controller *ctlr) { \tstruct device\t\t*dev ctlr >dev.parent; \tstruct boardinfo\t*bi; \tint\t\t\tstatus ENODEV; \tint\t\t\tid, first_dynamic; \t... \tdev_set_name(&ctlr >dev, \"spi%u\", ctlr >bus_num); // 初始化一下设备的名字 \tstatus device_add(&ctlr >dev); // 进行设备的添加 ... if (ctlr >transfer) { \t\tdev_info(dev, \"controller is unqueued, this is deprecated\\n\"); \t} else if (ctlr >transfer_one ctlr >transfer_one_message) { // 这里 \t\tstatus spi_controller_initialize_queue(ctlr); \t\t... \t} \t... \tlist_add_tail(&ctlr >list, &spi_controller_list); \t... } ``` ##### spi_controller_initialize_queue()函数 drivers/spi/spi.c ```c static int spi_controller_initialize_queue(struct spi_controller *ctlr) { \tint ret; \t// 初始化两个指针 \tctlr >transfer spi_queued_transfer; \tif (!ctlr >transfer_one_message) \t\tctlr >transfer_one_message spi_transfer_one_message; \t/* Initialize and start queue */ // 初始化一个内核线程以及具体的工作 \tret spi_init_queue(ctlr); \tif (ret) { \t\tdev_err(&ctlr >dev, \"problem initializing queue\\n\"); \t\tgoto err_init_queue; \t} \tctlr >queued true; // 启动工作 \tret spi_start_queue(ctlr); \tif (ret) { \t\tdev_err(&ctlr >dev, \"problem starting queue\\n\"); \t\tgoto err_start_queue; \t} \treturn 0; err_start_queue: \tspi_destroy_queue(ctlr); err_init_queue: \treturn ret; } ``` ##### spi_init_queue()函数 初始化内核线程工人 初始化内核具体工作 drivers/spi/spi.c ```c static int spi_init_queue(struct spi_controller *ctlr) { \tstruct sched_param param { .sched_priority MAX_RT_PRIO 1 }; \tctlr >running false; \tctlr >busy false; \t// 初始化工人以及使用的线程 \tkthread_init_worker(&ctlr >kworker); \tctlr >kworker_task kthread_run(kthread_worker_fn, &ctlr >kworker, \t\t\t\t\t \"%s\", dev_name(&ctlr >dev)); \tif (IS_ERR(ctlr >kworker_task)) { \t\tdev_err(&ctlr >dev, \"failed to create message pump task\\n\"); \t\treturn PTR_ERR(ctlr >kworker_task); \t} // 初始化一个具体的工作, 记录在ctlr >pump_messages里面 \tkthread_init_work(&ctlr >pump_messages, spi_pump_messages); \t... \treturn 0; } ``` ##### spi_start_queue()函数 启动内核具体工作 drivers/spi/spi.c ```c static int spi_start_queue(struct spi_controller *ctlr) { \tunsigned long flags; \tspin_lock_irqsave(&ctlr >queue_lock, flags); \tif (ctlr >running ctlr >busy) { \t\tspin_unlock_irqrestore(&ctlr >queue_lock, flags); \t\treturn EBUSY; \t} \tctlr >running true; \tctlr >cur_msg NULL; \tspin_unlock_irqrestore(&ctlr >queue_lock, flags); \t// 添加工作 \tkthread_queue_work(&ctlr >kworker, &ctlr >pump_messages); \treturn 0; } ``` ##### spi_pump_messages()函数 内核工作具体处理 drivers/spi/spi.c ```c static void spi_pump_messages(struct kthread_work *work) { // 从message获取到实际的spi控制器 \tstruct spi_controller *ctlr \t\tcontainer_of(work, struct spi_controller, pump_messages); \t__spi_pump_messages(ctlr, true); } ``` ##### __spi_pump_messages()函数 drivers/spi/spi.c ```c static void __spi_pump_messages(struct spi_controller *ctlr, bool in_kthread) { \tunsigned long flags; \tbool was_busy false; \tint ret; \t... // 获取到第一个spi_message结构体 \tctlr >cur_msg \t\tlist_first_entry(&ctlr >queue, struct spi_message, queue); \tlist_del_init(&ctlr >cur_msg >queue); \t... \tif (ctlr >prepare_message) { \t\tret ctlr >prepare_message(ctlr, ctlr >cur_msg); \t\t... \t\tctlr >cur_msg_prepared true; \t} \t... // 传输信息 \tret ctlr >transfer_one_message(ctlr, ctlr >cur_msg); \t... } \t ``` #### spi_sync()函数 同步传输数据 drivers/spi/spi.c ```c int spi_sync(struct spi_device *spi, struct spi_message *message) { \tint ret; \tmutex_lock(&spi >controller >bus_lock_mutex); \tret __spi_sync(spi, message); \tmutex_unlock(&spi >controller >bus_lock_mutex); \treturn ret; } ``` ##### __spi_sync()函数 drivers/spi/spi.c ```c static int __spi_sync(struct spi_device *spi, struct spi_message *message) { \tint status; \tstruct spi_controller *ctlr spi >controller; \tunsigned long flags; \tstatus __spi_validate(spi, message); // 校验通信参数 \tif (status ! 0) \t\treturn status; \t// 注册一个complete用于通知这一次通信的完成 \tmessage >complete spi_complete; \tmessage >context &done; \tmessage >spi spi; \t... \tif (ctlr >transfer spi_queued_transfer) { // 执行这里 \t\tspin_lock_irqsave(&ctlr >bus_lock_spinlock, flags); \t\ttrace_spi_message_submit(message); \t\tstatus __spi_queued_transfer(spi, message, false); \t\tspin_unlock_irqrestore(&ctlr >bus_lock_spinlock, flags); \t} else { \t\tstatus spi_async_locked(spi, message); \t} \t \t \tif (status 0) { \t\t... // 等待completion的完成 \t\twait_for_completion(&done); \t\tstatus message >status; \t} \tmessage >context NULL; \treturn status; } ``` ##### __spi_queued_transfer()函数 drivers/spi/spi.c ```c static int __spi_queued_transfer(struct spi_device *spi, \t\t\t\t struct spi_message *msg, \t\t\t\t bool need_pump) { \tstruct spi_controller *ctlr spi >controller; \tunsigned long flags; \tspin_lock_irqsave(&ctlr >queue_lock, flags); \t// 判断一下是不是被占用的 \tif (!ctlr >running) { \t\tspin_unlock_irqrestore(&ctlr >queue_lock, flags); \t\treturn ESHUTDOWN; \t} \tmsg >actual_length 0; \tmsg >status EINPROGRESS; \tlist_add_tail(&msg >queue, &ctlr >queue); \tif (!ctlr >busy && need_pump) // 添加具体的工资 \t\tkthread_queue_work(&ctlr >kworker, &ctlr >pump_messages); \tspin_unlock_irqrestore(&ctlr >queue_lock, flags); \treturn 0; } ``` ##### spi_transfer_one_message()函数 drivers/spi/spi.c ```c static int spi_transfer_one_message(struct spi_controller *ctlr, \t\t\t\t struct spi_message *msg) { \tstruct spi_transfer *xfer; \tbool keep_cs false; \tint ret 0; \tunsigned long long ms 1; \tstruct spi_statistics *statm &ctlr >statistics; \tstruct spi_statistics *stats &msg >spi >statistics; \t... \tlist_for_each_entry(xfer, &msg >transfers, transfer_list) { \t\t... \t\tif (xfer >tx_buf xfer >rx_buf) { \t\t\treinit_completion(&ctlr >xfer_completion); // 实际的发送函数 \t\t\tret ctlr >transfer_one(ctlr, msg >spi, xfer); \t\t\t... \t\t\tif (ret > 0) { \t\t\t\tret 0; \t\t\t\tms 8LL * 1000LL * xfer >len; \t\t\t\tdo_div(ms, xfer >speed_hz); \t\t\t\tms + ms + 200; /* some tolerance */ \t\t\t\tif (ms > UINT_MAX) \t\t\t\t\tms UINT_MAX; \t\t\t\tms wait_for_completion_timeout(&ctlr >xfer_completion, \t\t\t\t\t\t\t\t msecs_to_jiffies(ms)); \t\t\t} \t\t \t \t} \t... // 添加新的工作 \tspi_finalize_current_message(ctlr); \t... } ``` ##### spi_finalize_current_message()函数 drivers/spi/spi.c ```c void spi_finalize_current_message(struct spi_controller *ctlr) { \tstruct spi_message *mesg; \tunsigned long flags; \tint ret; \t \t... \tctlr >cur_msg NULL; \tctlr >cur_msg_prepared false; // 添加下一个处理任务 \tkthread_queue_work(&ctlr >kworker, &ctlr >pump_messages); \t... \tmesg >state NULL; \tif (mesg >complete) // 唤醒阻塞的线程 \t\tmesg >complete(mesg >context); } ``` #### spi_async()函数 异步传输数据 drivers/spi/spi.c ```c int spi_async(struct spi_device *spi, struct spi_message *message) { \t... \tret __spi_async(spi, message); \t... } ``` ##### __spi_async()函数 drivers/spi/spi.c ```c static int __spi_async(struct spi_device *spi, struct spi_message *message) { \tstruct spi_controller *ctlr spi >controller; \t... \treturn ctlr >transfer(spi, message); } ``` ##### spi_queued_transfer()函数 drivers/spi/spi.c ```c static int spi_queued_transfer(struct spi_device *spi, struct spi_message *msg) { \treturn __spi_queued_transfer(spi, msg, true); } ``` ##### __spi_queued_transfer()函数 drivers/spi/spi.c ```c static int __spi_queued_transfer(struct spi_device *spi, \t\t\t\t struct spi_message *msg, \t\t\t\t bool need_pump) { \tstruct spi_controller *ctlr spi >controller; \tunsigned long flags; \tspin_lock_irqsave(&ctlr >queue_lock, flags); \tif (!ctlr >running) { \t\tspin_unlock_irqrestore(&ctlr >queue_lock, flags); \t\treturn ESHUTDOWN; \t} \tmsg >actual_length 0; \tmsg >status EINPROGRESS; \tlist_add_tail(&msg >queue, &ctlr >queue); \tif (!ctlr >busy && need_pump) \t\tkthread_queue_work(&ctlr >kworker, &ctlr >pump_messages); \tspin_unlock_irqrestore(&ctlr >queue_lock, flags); \treturn 0; } ```"},"/note/Linux/野火Linux/2025-7-19-15-class设备管理.html":{"title":"","content":"## class：设备的大管家 硬件设备分类管理 与udev协作，自动创建设备文件, 不需要在使用mkmod命令 可以使用函数`class_create`创建一个类, 使用`device_create`创建一个设备 创建的设备里面默认会有一个dev属性, 记录设备的设备号, 实际是把设备号和kobject类型配合起来 > kobject用于设备文件的自动创建, cdev架构是实际的文件操控部分 创建的时候发送一个`kobject_uevent`的事件让实际的设备进行创建 > 之后可以使用MISC设备自动实现字符设备直接注册 ![image 20250719165123199](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507191651367.png) ## 使用 有两个函数(第一个起始是一个宏定义, 这个是展开以后的效果), owner一般可以使用的参数是`THIS_MODULE`, 之后创建的cdev在申请设备号以后把设备号添加到class里面, 添加的时候可以设置父设备, 父设备移除的时候子设备也移除, dev_t是设备号 ```c struct class *class_create (struct module *owner, const char *name) struct device *device_create(struct class *class, struct device *parent, \t\t\t dev_t devt, void *drvdata, const char *fmt, ...) void class_destroy(struct class *cls); ``` #### 创建一个class include/linux/device.h ##### class_create宏 ````c #define class_create(owner, name)\t\t\\ ({\t\t\t\t\t\t\t\t\t\t\\ \tstatic struct lock_class_key __key;\t\\ \t__class_create(owner, name, &__key);\\ }) ```` owner：一般设置为THIS_MODULE name：kobject对象的名字 ```c struct class *__class_create(struct module *owner, const char *name, \t\t\t struct lock_class_key *key) ``` 返回值: struct class里面\"继承\"了kobject对象 #### 在class下添加kobject对象 include/linux/device.h ##### device_create()函数 ```c struct device *device_create(struct class *class, struct device *parent, \t\t\t dev_t devt, void *drvdata, const char *fmt, ...) ``` class：class_create新构建的class parent：新kobject对象的上一层节点，一般为NULL dev_t：属性文件记录该设备号 drvdata：私有数据，一般为NULL fmt：变参参数，一般用来设置kobject对象的名字 ## 代码示例 ```c #include <linux/module.h> #include <linux/init.h> #include <linux/kernel.h> #include <linux/fs.h> #include <linux/uaccess.h> #include <asm/io.h> #include <linux/device.h> #define DEV_MAJOR\t\t0\t\t/* 动态申请主设备号 */ #define DEV_NAME\t\t\"red_led\" \t/*led设备名字 */ /* GPIO虚拟地址指针 */ static void __iomem *IMX6U_CCM_CCGR1; static void __iomem *SW_MUX_GPIO1_IO04; static void __iomem *SW_PAD_GPIO1_IO04; static void __iomem *GPIO1_DR; static void __iomem *GPIO1_GDIR; static int led_open(struct inode *inode, struct file *filp) { \treturn 0; } static ssize_t led_read(struct file *filp, char __user *buf, size_t cnt, loff_t *offt) { \treturn EFAULT; } static ssize_t led_write(struct file *filp, const char __user *buf, size_t cnt, loff_t *offt) { \tunsigned char databuf[10]; \tif(cnt >10) \t\tcnt 10; \t\t /*从用户空间拷贝数据到内核空间*/ if(copy_from_user(databuf, buf, cnt)){ \t\treturn EIO; \t} \t \tif(!memcmp(databuf,\"on\",2)) {\t \t\tiowrite32(0 << 4, GPIO1_DR);\t \t} else if(!memcmp(databuf,\"off\",3)) { \t\tiowrite32(1 << 4, GPIO1_DR); \t} \t/*写成功后，返回写入的字数*/ \treturn cnt; } static int led_release(struct inode *inode, struct file *filp) { \treturn 0; } /* 自定义led的file_operations 接口*/ static struct file_operations led_fops { \t.owner THIS_MODULE, \t.open led_open, \t.read led_read, \t.write led_write, \t.release \tled_release, }; int major 0; struct class *class_led; static int __init led_init(void) { \t \t/* GPIO相关寄存器映射 */ \tIMX6U_CCM_CCGR1 ioremap(0x20c406c, 4); \tSW_MUX_GPIO1_IO04 ioremap(0x20e006c, 4); \tSW_PAD_GPIO1_IO04 ioremap(0x20e02f8, 4); \tGPIO1_GDIR ioremap(0x0209c004, 4); \tGPIO1_DR ioremap(0x0209c000, 4); \t/* 使能GPIO1时钟 */ \tiowrite32(0xffffffff, IMX6U_CCM_CCGR1); \t/* 设置GPIO1_IO04复用为普通GPIO*/ \tiowrite32(5, SW_MUX_GPIO1_IO04); \t /*设置GPIO属性*/ \tiowrite32(0x10B0, SW_PAD_GPIO1_IO04); \t/* 设置GPIO1_IO04为输出功能 */ \tiowrite32(1 << 4, GPIO1_GDIR); \t/* LED输出高电平 */ \tiowrite32(1<< 4, GPIO1_DR); \t/* 注册字符设备驱动 */ \tmajor register_chrdev(DEV_MAJOR, DEV_NAME, &led_fops); printk(KERN_ALERT \"led major:%d\\n\",major); \t/*创建/sys/class/xxx目录项*/ \tclass_led class_create(THIS_MODULE, \"xxx\"); \t/* \t创建/sys/class/xxx/my_led目录项，并生成dev属性文件, 记录设备号 \t用户空间在/dev/my_led的文件 \t*/ \tdevice_create(class_led, NULL, MKDEV(major, 0), NULL,\"my_led\"); \treturn 0; } static void __exit led_exit(void) { \t/* 取消映射 */ \tiounmap(IMX6U_CCM_CCGR1); \tiounmap(SW_MUX_GPIO1_IO04); \tiounmap(SW_PAD_GPIO1_IO04); \tiounmap(GPIO1_DR); \tiounmap(GPIO1_GDIR); \t/* 注销字符设备驱动 */ \tunregister_chrdev(major, DEV_NAME); \t/*销毁/sys/class/xxx/my_led目录项*/ \tdevice_destroy(class_led, MKDEV(major, 0)); \t/*销毁/sys/class/xxx目录项*/ \tclass_destroy(class_led); } module_init(led_init); module_exit(led_exit); MODULE_LICENSE(\"GPL\"); MODULE_AUTHOR(\"embedfire \"); MODULE_DESCRIPTION(\"led_module\"); MODULE_ALIAS(\"led_module\"); ``` ![image 20250719170339182](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507191703246.png)"},"/note/Linux/野火Linux/2025-11-10-65-定时器.html":{"title":"Linux定时器","content":"# Linux定时器 ## 时钟节拍 可以在内核配置的时候选择使用的系统时钟的频率 `Kernel Features > Timer freaquency` Linux 内核使用全局变量 jiffies 来记录系统从启动以来的系统节拍数，系统启动的时候会将 jiffies初始化为0，jiffies定义在文件include/linux/jiffies.h中 jiffies_64和 jiffies其实是同一个东西， jiffies_64用于 64位系统，而jiffies用于32位系统。为了兼容不同的硬件，jiffies 其实就是 jiffies_64 的低 32 位 32位的 jiffies只需要49.7天就发生了绕回，对于64位的 jiffies来说大概需要5.8亿年才能绕回，因此 jiffies_64的绕回忽略不计。处理 32位jiffies的绕回显得尤为重要 ![image 20251110101907626](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251110101907626.png) 如果 unkown超过 known的话，time_after函数返回真，否则返回假。如果 unkown没有超过 known的话 time_before函数返回真，否则返回假。 time_after_eq函数和 time_after函数类似，只是多了判断等于这个条件, 在实际使用的时候需要自己计算超时的时间对应的节拍 ![image 20251110174455668](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251110174455668.png) 可以使用这部分函数实现时间的类型转换 ## 基础定时器 这个定时器不是周期性的, 所以可以在处理函数里面重新打开 ```c struct timer_list { \t/* \t * All fields that change during normal runtime grouped to the \t * same cacheline \t */ \tstruct list_head entry; \tunsigned long expires; // 超时时间记录的是节拍数 \tstruct tvec_base *base; \tvoid (*function)(unsigned long); // 处理函数 \tunsigned long data; // 个函数传递的值 \tint slack; #ifdef CONFIG_TIMER_STATS \tint start_pid; \tvoid *start_site; \tchar start_comm[16]; #endif #ifdef CONFIG_LOCKDEP \tstruct lockdep_map lockdep_map; #endif }; ``` ### 相关API ```c void init_timer(struct timer_list *timer); void add_timer(struct timer_list *timer); // 在多处理器系统上，定时器可能会在其他的处理器上运行，因此在调用del_timer函数删除定时 // 器之前要先等待其他处理器的定时处理器函数退出 // 返回值：0，定时器还没被激活；1，定时器已经激活 int del_timer(struct timer_list * timer); // del_timer函数的同步版，会等待其他处理器使用完定时器再删除，del_timer_sync // 不能使用在中断上下文 // 返回值：0，定时器还没被激活；1，定时器已经激活 int del_timer_sync(struct timer_list *timer); // 修改定时值，如果定时器还没有激活的话，mod_timer函数会激活定时器 // 返回值：0，调用 mod_timer 函数前定时器未被激活；1，调用 mod_timer 函数前定时器已 // 被激活。 int mod_timer(struct timer_list *timer, unsigned long expires) ``` ## 延时 ![image 20251110181452162](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251110181452162.png)"},"/note/Linux/野火Linux/2025-9-20-27-IIC驱动框架使用.html":{"title":"","content":"## IIC驱动实验：读取mpu6050数据 ## 使用 **总线驱动(官方实现)**: 初始化一个i2c_adapter, 设置 i2c_algorithm中的 master_xfer函数。完成以后通过 i2c_add_numbered_adapter或i2c_add_adapter这两个函数向系统注册设置好的i2c_adapter **设备驱动**: 关注两个结构体, 分别是`i2c_client`和`i2c_driver`, + `i2c_client`就是描述设备信息的(地址, 名字, 对应的适配器, 中断等, 从设备树获取), 一般在I2C的设备节点里面添加实际的I2C设备, 系统自动解析, 需要设置设备树里面的`compatible`以及`reg`属性 + 使用`i2c_driver`替换`platform_driver`, 需要实现里面的probe函数, 设置`device_driver`的 `of_match_table`成员变量, 也就是驱动的兼容(compatible)属性 + 在module_init的时候使用`i2c_register_driver/i2c_add_driver`进行注册, 在`probe`函数里面可以进行字符设备的一套 + 这个probe在匹配的时候可以获取到参数`struct i2c_client *client`, 使用client >adapter作为参数可以使用函数`i2c_transfer`传输数据, 需要初始化`send_msg`数据类型控制实际发送的顺序 #### MPU6050 空间运动传感器芯片 3轴加速度 3轴角速度 #### 硬件原理图 ![image 20200903171355402](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509201542093.png) #### 设备树节点 ##### iomuxc子节点 ```json pinctrl_i2c1: i2c1grp { \t\tfsl,pins < \t\t\tMX6UL_PAD_UART4_TX_DATA__I2C1_SCL 0x4001b8b0 \t\t\tMX6UL_PAD_UART4_RX_DATA__I2C1_SDA 0x4001b8b0 \t\t>; \t}; ``` ##### i2c1子节点 ```json &i2c1{ \tclock frequency <100000>; \tpinctrl names \"default\"; \tpinctrl 0 <&pinctrl_i2c1>; \tstatus \"okay\"; \t \ti2c_mpu6050@68 { \t \tcompatible \"fire,i2c_mpu6050\"; \t \treg <0x68>; \t \tstatus \"okay\"; \t }; }; ``` ## 实际使用 ```c #include <linux/init.h> #include <linux/module.h> #include <linux/fs.h> #include <linux/cdev.h> #include <linux/uaccess.h> #include <linux/i2c.h> #include <linux/types.h> #include <linux/kernel.h> #include <linux/delay.h> #include <linux/ide.h> #include <linux/errno.h> #include <linux/gpio.h> #include <asm/mach/map.h> #include <linux/of.h> #include <linux/of_address.h> #include <linux/of_gpio.h> #include <asm/io.h> #include <linux/device.h> #include <linux/platform_device.h> #define SMPLRT_DIV 0x19 #define CONFIG \t\t 0x1A #define GYRO_CONFIG 0x1B #define ACCEL_CONFIG 0x1C #define ACCEL_XOUT_H 0x3B #define ACCEL_XOUT_L 0x3C #define ACCEL_YOUT_H 0x3D #define ACCEL_YOUT_L 0x3E #define ACCEL_ZOUT_H 0x3F #define ACCEL_ZOUT_L 0x40 #define TEMP_OUT_H 0x41 #define TEMP_OUT_L 0x42 #define GYRO_XOUT_H 0x43 #define GYRO_XOUT_L 0x44 #define GYRO_YOUT_H 0x45 #define GYRO_YOUT_L 0x46 #define GYRO_ZOUT_H 0x47 #define GYRO_ZOUT_L 0x48 #define PWR_MGMT_1 0x6B #define WHO_AM_I 0x75 /* 字符设备内容 */ #define DEV_NAME \"I2C1_mpu6050\" #define DEV_CNT (1) /*定义 led 资源结构体，保存获取得到的节点信息以及转换后的虚拟寄存器地址*/ static dev_t mpu6050_devno;\t\t\t\t //定义字符设备的设备号 static struct cdev mpu6050_chr_dev;\t\t //定义字符设备结构体chr_dev struct class *class_mpu6050;\t\t\t //保存创建的类 struct device *device_mpu6050;\t\t\t // 保存创建的设备 struct device_node *mpu6050_device_node; //rgb_led的设备树节点结构体 /* IIC设备内容 */ struct i2c_client *mpu6050_client NULL; //保存mpu6050设备对应的i2c_client结构体，匹配成功后由.prob函数带回。 /*通过i2c 向mpu6050写入数据 *mpu6050_client：mpu6050的i2c_client结构体。 *address, 数据要写入的地址， *data, 要写入的数据 *返回值，错误， 1。成功，0 */ static int i2c_write_mpu6050(struct i2c_client *mpu6050_client, u8 address, u8 data) { \tint error 0; \tu8 write_data[2]; \tstruct i2c_msg send_msg; //要发送的数据结构体 \t/*设置要发送的数据*/ \twrite_data[0] address; \twrite_data[1] data; \t/*发送 iic要写入的地址 reg*/ \tsend_msg.addr mpu6050_client >addr; //mpu6050在 iic 总线上的地址 \tsend_msg.flags 0;\t\t\t\t\t //标记为发送数据 \tsend_msg.buf write_data;\t\t\t //写入的首地址 \tsend_msg.len 2;\t\t\t\t\t //reg长度 \t/*执行发送*/ \terror i2c_transfer(mpu6050_client >adapter, &send_msg, 1); \tif (error ! 1) \t{ \t\tprintk(KERN_DEBUG \"\\n i2c_transfer error \\n\"); \t\treturn 1; \t} \treturn 0; } /*通过i2c 向mpu6050写入数据 *mpu6050_client：mpu6050的i2c_client结构体。 *address, 要读取的地址， *data，保存读取得到的数据 *length，读长度 *返回值，错误， 1。成功，0 */ static int i2c_read_mpu6050(struct i2c_client *mpu6050_client, u8 address, void *data, u32 length) { \tint error 0; \tu8 address_data address; \tstruct i2c_msg mpu6050_msg[2]; \t/*设置读取位置msg*/ \tmpu6050_msg[0].addr mpu6050_client >addr; //mpu6050在 iic 总线上的地址 \tmpu6050_msg[0].flags 0;\t\t\t\t\t//标记为发送数据 \tmpu6050_msg[0].buf &address_data;\t\t\t//写入的首地址 \tmpu6050_msg[0].len 1;\t\t\t\t\t\t//写入长度 \t/*设置读取位置msg*/ \tmpu6050_msg[1].addr mpu6050_client >addr; //mpu6050在 iic 总线上的地址 \tmpu6050_msg[1].flags I2C_M_RD;\t\t\t//标记为读取数据 \tmpu6050_msg[1].buf data;\t\t\t\t\t//读取得到的数据保存位置 \tmpu6050_msg[1].len length;\t\t\t\t//读取长度 \terror i2c_transfer(mpu6050_client >adapter, mpu6050_msg, 2); \tif (error ! 2) \t{ \t\tprintk(KERN_DEBUG \"\\n i2c_read_mpu6050 error \\n\"); \t\treturn 1; \t} \treturn 0; } /*初始化i2c *返回值，成功，返回0。失败，返回 1 */ static int mpu6050_init(void) { \tint error 0; \t/*配置mpu6050电源管理，0x00,正常启动*/ \terror + i2c_write_mpu6050(mpu6050_client, PWR_MGMT_1, 0X00); \t/*设置MPU6050的采样频率*/ \terror + i2c_write_mpu6050(mpu6050_client, SMPLRT_DIV, 0X07); \t/*设置数字低通滤波器和帧同步引脚采样*/ \terror + i2c_write_mpu6050(mpu6050_client, CONFIG, 0X06); \t/*设置量程和 X、Y、Z 轴加速度自检*/ \terror + i2c_write_mpu6050(mpu6050_client, ACCEL_CONFIG, 0X01); \tif (error < 0) \t{ \t\t/*初始化错误*/ \t\tprintk(KERN_DEBUG \"\\n mpu6050_init error \\n\"); \t\treturn 1; \t} \treturn 0; } /*字符设备操作函数集，open函数实现*/ static int mpu6050_open(struct inode *inode, struct file *filp) { \t// printk(\"\\n mpu6050_open \\n\"); \t/*向 mpu6050 发送配置数据，让mpu6050处于正常工作状态*/ \tmpu6050_init(); \treturn 0; } /*字符设备操作函数集，.read函数实现*/ static ssize_t mpu6050_read(struct file *filp, char __user *buf, size_t cnt, loff_t *off) { \tchar data_H; \tchar data_L; \tint error; \t//保存mpu6050转换得到的原始数据 \tshort mpu6050_result[6]; \t/*读取3轴加速度原始值*/ \ti2c_read_mpu6050(mpu6050_client, ACCEL_XOUT_H, &data_H, 1); \ti2c_read_mpu6050(mpu6050_client, ACCEL_XOUT_L, &data_L, 1); \tmpu6050_result[0] data_H << 8; \tmpu6050_result[0] + data_L; \ti2c_read_mpu6050(mpu6050_client, ACCEL_YOUT_H, &data_H, 1); \ti2c_read_mpu6050(mpu6050_client, ACCEL_YOUT_L, &data_L, 1); \tmpu6050_result[1] data_H << 8; mpu6050_result[1] + data_L; \ti2c_read_mpu6050(mpu6050_client, ACCEL_ZOUT_H, &data_H, 1); \ti2c_read_mpu6050(mpu6050_client, ACCEL_ZOUT_L, &data_L, 1); \tmpu6050_result[2] data_H << 8; \tmpu6050_result[2] + data_L; \t/*读取3轴角速度原始值*/ \ti2c_read_mpu6050(mpu6050_client, GYRO_XOUT_H, &data_H, 1); \ti2c_read_mpu6050(mpu6050_client, GYRO_XOUT_L, &data_L, 1); \tmpu6050_result[3] data_H << 8; \tmpu6050_result[3] + data_L; \ti2c_read_mpu6050(mpu6050_client, GYRO_YOUT_H, &data_H, 1); \ti2c_read_mpu6050(mpu6050_client, GYRO_YOUT_L, &data_L, 1); \tmpu6050_result[4] data_H << 8; \tmpu6050_result[4] + data_L; \ti2c_read_mpu6050(mpu6050_client, GYRO_ZOUT_H, &data_H, 1); \ti2c_read_mpu6050(mpu6050_client, GYRO_ZOUT_L, &data_L, 1); \tmpu6050_result[5] data_H << 8; \tmpu6050_result[5] + data_L; \t// printk(\"AX %d, AY %d, AZ %d \\n\",(int)mpu6050_result[0],(int)mpu6050_result[1],(int)mpu6050_result[2]); \t// printk(\"GX %d, GY %d, GZ %d \\n \\n\",(int)mpu6050_result[3],(int)mpu6050_result[4],(int)mpu6050_result[5]); \t/*将读取得到的数据拷贝到用户空间*/ \terror copy_to_user(buf, mpu6050_result, cnt); \tif(error ! 0) \t{ \t\tprintk(\"copy_to_user error!\"); \t\treturn 1; \t} \treturn 0; } /*字符设备操作函数集，.release函数实现*/ static int mpu6050_release(struct inode *inode, struct file *filp) { \t// printk(\"\\n mpu6050_release \\n\"); \treturn 0; } /*字符设备操作函数集*/ static struct file_operations mpu6050_chr_dev_fops \t{ \t\t.owner THIS_MODULE, \t\t.open mpu6050_open, \t\t.read mpu6050_read, \t\t.release mpu6050_release, }; /* 平台驱动函数集 */ static int mpu6050_probe(struct i2c_client *client, const struct i2c_device_id *id) { \tint ret 1; //保存错误状态码 \tprintk(KERN_EMERG \"\\t match successed \\n\"); \t/* 注册 字符设备部分 */ \t//采用动态分配的方式，获取设备编号，次设备号为0， \t//设备名称为rgb leds，可通过命令cat /proc/devices查看 \t//DEV_CNT为1，当前只申请一个设备编号 \tret alloc_chrdev_region(&mpu6050_devno, 0, DEV_CNT, DEV_NAME); \tif (ret < 0) \t{ \t\tprintk(\"fail to alloc mpu6050_devno\\n\"); \t\tgoto alloc_err; \t} \t//关联字符设备结构体cdev与文件操作结构体file_operations \tmpu6050_chr_dev.owner THIS_MODULE; \tcdev_init(&mpu6050_chr_dev, &mpu6050_chr_dev_fops); \t// 添加设备至cdev_map散列表中 \tret cdev_add(&mpu6050_chr_dev, mpu6050_devno, DEV_CNT); \tif (ret < 0) \t{ \t\tprintk(\"fail to add cdev\\n\"); \t\tgoto add_err; \t} \t/*创建类 */ \tclass_mpu6050 class_create(THIS_MODULE, DEV_NAME); \t/*创建设备 DEV_NAME 指定设备名，*/ \tdevice_mpu6050 device_create(class_mpu6050, NULL, mpu6050_devno, NULL, DEV_NAME); \tmpu6050_client client; \treturn 0; add_err: \t// 添加设备失败时，需要注销设备号 \tunregister_chrdev_region(mpu6050_devno, DEV_CNT); \tprintk(\"\\n error! \\n\"); alloc_err: \treturn 1; } static int mpu6050_remove(struct i2c_client *client) { \t/*删除设备*/ \tdevice_destroy(class_mpu6050, mpu6050_devno);\t //清除设备 \tclass_destroy(class_mpu6050);\t\t\t\t\t //清除类 \tcdev_del(&mpu6050_chr_dev);\t\t\t\t\t\t //清除设备号 \tunregister_chrdev_region(mpu6050_devno, DEV_CNT); //取消注册字符设备 \treturn 0; } /*定义ID 匹配表*/ static const struct i2c_device_id gtp_device_id[] { \t{\"fire,i2c_mpu6050\", 0}, \t{}}; /*定义设备树匹配表*/ static const struct of_device_id mpu6050_of_match_table[] { \t{.compatible \"fire,i2c_mpu6050\"}, \t{/* sentinel */}}; /*定义i2c总线设备结构体*/ struct i2c_driver mpu6050_driver { \t.probe mpu6050_probe, \t.remove mpu6050_remove, \t.id_table gtp_device_id, \t.driver { \t\t.name \"fire,i2c_mpu6050\", \t\t.owner THIS_MODULE, \t\t.of_match_table mpu6050_of_match_table, \t}, }; /* *驱动初始化函数 */ static int __init mpu6050_driver_init(void) { \tint ret; \tpr_info(\"mpu6050_driver_init\\n\"); \tret i2c_add_driver(&mpu6050_driver); \treturn ret; } /* *驱动注销函数 */ static void __exit mpu6050_driver_exit(void) { \tpr_info(\"mpu6050_driver_exit\\n\"); \ti2c_del_driver(&mpu6050_driver); } module_init(mpu6050_driver_init); module_exit(mpu6050_driver_exit); MODULE_LICENSE(\"GPL\"); ```"},"/note/Linux/野火Linux/2025-6-11-01-入门.html":{"title":"入门","content":"# 入门 ## 推荐项目 两个C语言编译器的项目推荐 [Zik Saleeba / picoc · GitLab](https://gitlab.com/zsaleeba/picoc) [lotabout/write a C interpreter: Write a simple interpreter of C. Inspired by c4 and largely based on it.](https://github.com/lotabout/write a C interpreter)"},"/note/Linux/野火Linux/2025-11-2-64-mfgtool.html":{"title":"mfgtool烧录","content":"# mfgtool烧录 ![d4fdb59021efd8dac5a4285e8530f34d_720](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/d4fdb59021efd8dac5a4285e8530f34d_720.png) 需要关心的文件夹是Profiles文件夹里面的文件, 这个文件夹里面记录的文件是实际下载使用的文件 MfgTool2.exe 就是烧写软件，但是我们不会直接打开这个软件烧写, 而是使用下面的脚本进行使用 > 这个工具的原理是首先向DDR里面烧录一个系统, 之后使用这个系统进行进一步的下载烧录 mfgtool/Profiles/Linux/OS Firmware目录里面有两个子目录, 分别对应之前说的两个步骤, files是我们自己使用的系统, firmware文件夹里面是烧录使用的系统 ```bash wfjmSet wshShell CreateObject(\"WScript.shell\") wshShell.run \"mfgtool2.exe c \"\"linux\"\" l \"\"eMMC\"\" s \"\"ddr 512\"\" s \"\"board emmc\"\" s \"\"boot \"\" \" Set wshShell Nothing ``` 这个vbs文件里面主要运行的是这个命令 ### ucl2.xml 这个文件适用于配置实际下载到板子里面的文件 ucl2.xml以`<UCL>`开始，以`</UCL>`结束。`<CFG>`和`</CFG>`之间是配置相关内容，主要是判断当前是给I.MX系列的哪个芯片烧写系统。`<LIST>`和`</LIST>`之间的是针对不同存储芯片的烧写命令 ```xml <CFG> \t <STATE name \"BootStrap\" dev \"MX6UL\" vid \"15A2\" pid \"007D\"/> <STATE name \"BootStrap\" dev \"MX6ULL\" vid \"15A2\" pid \"0080\"/> <STATE name \"Updater\" dev \"MSC\" vid \"066F\" pid \"37FF\"/> </CFG> ``` > 不同芯片的芯片ID记录一下 ```xml <LIST name \"SDCard\" desc \"Choose SD Card as media\"> \t<CMD state \"BootStrap\" type \"boot\" body \"BootStrap\" file \"firmware/u boot imx6ull 14x14 sd.imx\" ifdev \"MX6ULL\">Loading U boot</CMD> \t\t \t<CMD state \"BootStrap\" type \"load\" file \"firmware/zImage\" address \"0x80800000\" \t\tloadSection \"OTH\" setSection \"OTH\" HasFlashHeader \"FALSE\" ifdev \"MX6ULL\">Loading Kernel.</CMD> \t<CMD state \"BootStrap\" type \"load\" file \"firmware/fsl image mfgtool initramfs imx_mfgtools.cpio.gz.u boot\" address \"0x83800000\" \t\tloadSection \"OTH\" setSection \"OTH\" HasFlashHeader \"FALSE\" ifdev \"MX6ULL\">Loading Initramfs.</CMD> \t<CMD state \"BootStrap\" type \"load\" file \"firmware/imx6ull 14x14 sd.dtb\" address \"0x83000000\" \t\tloadSection \"OTH\" setSection \"OTH\" HasFlashHeader \"FALSE\" ifdev \"MX6ULL\">Loading device tree.</CMD> \t<CMD state \"BootStrap\" type \"jump\" > Jumping to OS image. </CMD> \t<! create partition > \t<CMD state \"Updater\" type \"push\" body \"send\" file \"mksdcard.sh.tar\">Sending partition shell</CMD> \t<CMD state \"Updater\" type \"push\" body \"$ tar xf $FILE \"> Partitioning...</CMD> \t<CMD state \"Updater\" type \"push\" body \"$ sh mksdcard.sh /dev/mmcblk0\"> Partitioning...</CMD> \t<! burn uboot > \t<CMD state \"Updater\" type \"push\" body \"$ dd if /dev/zero of /dev/mmcblk0 bs 1k seek 768 conv fsync count 8\">clear u boot env</CMD> \t<CMD state \"Updater\" type \"push\" body \"send\" file \"files/boot/u boot imx6ull 14x14 ddr%ddr% %board%%boot%.imx\" ifdev \"MX6ULL\">Sending u boot.bin</CMD> \t<CMD state \"Updater\" type \"push\" body \"$ dd if $FILE of /dev/mmcblk0 bs 1k seek 1 conv fsync\">write u boot.bin to sd card</CMD> \t<! format and mount boot partition 制作一下SD卡分区 > \t<CMD state \"Updater\" type \"push\" body \"$ while [ ! e /dev/mmcblk0p1 ]; do sleep 1; echo \\\"waiting...\\\"; done \">Waiting for the partition ready</CMD> \t<CMD state \"Updater\" type \"push\" body \"$ mkfs.vfat F 32 n \\\"boot\\\" /dev/mmcblk0p1\">Formatting rootfs partition</CMD> \t<CMD state \"Updater\" type \"push\" body \"$ mkdir p /mnt/mmcblk0p1\"/> \t<CMD state \"Updater\" type \"push\" body \"$ mount t vfat /dev/mmcblk0p1 /mnt/mmcblk0p1\"/> \t<! burn logo > \t<! <CMD state \"Updater\" type \"push\" body \"send\" file \"files/alientek.bmp\">Sending logo</CMD> \t<CMD state \"Updater\" type \"push\" body \"$ cp $FILE /mnt/mmcblk0p1/alientek.bmp\">write boot logo to sd card</CMD> > \t<! burn zImage > \t<CMD state \"Updater\" type \"push\" body \"send\" file \"files/boot/zImage\">Sending kernel</CMD> \t<CMD state \"Updater\" type \"push\" body \"$ cp $FILE /mnt/mmcblk0p1/zImage\">write kernel image to sd card</CMD> \t<! burn dtb 烧写一下设备树文件 > \t<CMD state \"Updater\" type \"push\" body \"send\" file \"files/boot/imx6ull 14x14 %board% 4.3 480x272 c.dtb\" ifdev \"MX6ULL\">Sending Device Tree file</CMD> \t<CMD state \"Updater\" type \"push\" body \"$ cp $FILE /mnt/mmcblk0p1/imx6ull 14x14 %board% 4.3 480x272 c.dtb\" ifdev \"MX6ULL\">write device tree to sd card</CMD> \t \t<CMD state \"Updater\" type \"push\" body \"send\" file \"files/boot/imx6ull 14x14 %board% 4.3 800x480 c.dtb\" ifdev \"MX6ULL\">Sending Device Tree file</CMD> \t<CMD state \"Updater\" type \"push\" body \"$ cp $FILE /mnt/mmcblk0p1/imx6ull 14x14 %board% 4.3 800x480 c.dtb\" ifdev \"MX6ULL\">write device tree to sd card</CMD> \t<CMD state \"Updater\" type \"push\" body \"send\" file \"files/boot/imx6ull 14x14 %board% 7 800x480 c.dtb\" ifdev \"MX6ULL\">Sending Device Tree file</CMD> \t<CMD state \"Updater\" type \"push\" body \"$ cp $FILE /mnt/mmcblk0p1/imx6ull 14x14 %board% 7 800x480 c.dtb\" ifdev \"MX6ULL\">write device tree to sd card</CMD> \t<CMD state \"Updater\" type \"push\" body \"send\" file \"files/boot/imx6ull 14x14 %board% 7 1024x600 c.dtb\" ifdev \"MX6ULL\">Sending Device Tree file</CMD> \t<CMD state \"Updater\" type \"push\" body \"$ cp $FILE /mnt/mmcblk0p1/imx6ull 14x14 %board% 7 1024x600 c.dtb\" ifdev \"MX6ULL\">write device tree to sd card</CMD> \t<CMD state \"Updater\" type \"push\" body \"send\" file \"files/boot/imx6ull 14x14 %board% 10.1 1280x800 c.dtb\" ifdev \"MX6ULL\">Sending Device Tree file</CMD> \t<CMD state \"Updater\" type \"push\" body \"$ cp $FILE /mnt/mmcblk0p1/imx6ull 14x14 %board% 10.1 1280x800 c.dtb\" ifdev \"MX6ULL\">write device tree to sd card</CMD> \t \t<CMD state \"Updater\" type \"push\" body \"send\" file \"files/boot/imx6ull 14x14 %board% hdmi.dtb\" ifdev \"MX6ULL\">Sending Device Tree file</CMD> \t<CMD state \"Updater\" type \"push\" body \"$ cp $FILE /mnt/mmcblk0p1/imx6ull 14x14 %board% hdmi.dtb\" ifdev \"MX6ULL\">write device tree to sd card</CMD> \t \t<CMD state \"Updater\" type \"push\" body \"send\" file \"files/boot/imx6ull 14x14 %board% vga.dtb\" ifdev \"MX6ULL\">Sending Device Tree file</CMD> \t<CMD state \"Updater\" type \"push\" body \"$ cp $FILE /mnt/mmcblk0p1/imx6ull 14x14 %board% vga.dtb\" ifdev \"MX6ULL\">write device tree to sd card</CMD> \t<CMD state \"Updater\" type \"push\" body \"$ sleep 1\">delay</CMD> \t<CMD state \"Updater\" type \"push\" body \"$ sync\">Sync...</CMD> \t<CMD state \"Updater\" type \"push\" body \"$ umount /mnt/mmcblk0p1\">Unmounting vfat partition</CMD> \t<! format and mount rootfs partition 挂载第二个分区 > \t<CMD state \"Updater\" type \"push\" body \"$ mkfs.ext3 F j L \\\"rootfs\\\" /dev/mmcblk0p2\">Formatting rootfs partition</CMD> \t<CMD state \"Updater\" type \"push\" body \"$ mkdir p /mnt/mmcblk0p2\"/> \t<CMD state \"Updater\" type \"push\" body \"$ mount t ext3 /dev/mmcblk0p2 /mnt/mmcblk0p2\"/> \t<! burn rootfs > \t<CMD state \"Updater\" type \"push\" body \"pipe tar jxv C /mnt/mmcblk0p2\" file \"files/filesystem/rootfs.tar.bz2\" ifdev \"MX6ULL\">Sending and writting rootfs</CMD> \t<CMD state \"Updater\" type \"push\" body \"frf\">Finishing rootfs write</CMD> \t<CMD state \"Updater\" type \"push\" body \"$ mkdir p /mnt/mmcblk0p2/lib/modules\">Mkdir p /mnt/mmcblk0p2/lib/modules</CMD> \t<CMD state \"Updater\" type \"push\" body \"send\" file \"files/modules/modules.tar.bz2\" ifdev \"MX6ULL\">Sending Modules file</CMD> \t<CMD state \"Updater\" type \"push\" body \"$ tar jxf $FILE C /mnt/mmcblk0p2/lib/modules/\" ifdev \"MX6ULL\">tar Modules file</CMD> \t<CMD state \"Updater\" type \"push\" body \"$ sleep 1\">delay</CMD> \t<CMD state \"Updater\" type \"push\" body \"$ sync\">Sync...</CMD> \t<CMD state \"Updater\" type \"push\" body \"$ umount /mnt/mmcblk0p2\">Unmounting rootfs partition</CMD> \t<CMD state \"Updater\" type \"push\" body \"$ echo Update Complete!\">Done</CMD> </LIST> ``` > 向SD卡里面烧录Linux系统, 可以在这里配置实际烧录的文件以及烧录执行的, 烧录使用的镜像会使用Initramfs这个文件 > > > > > > Initramfs是Linux启动过程中的一个临时根文件系统，主要用于在内核完全启动并挂载真正的根文件系统之前，提供必要的设备驱动和启动环境"},"/note/Linux/野火Linux/2025-10-9-54-Uboot启动(三).html":{"title":"Uboot启动","content":"# Uboot启动 ## 第二阶段 ![image 20251009223704936](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510092237979.png) ### board_init_r函数 运行init_sequence_r里面的成员函数 ```c staticinit_fnc_t init_sequence_r[] { initr_trace, /*初始化与跟踪调试相关部分*/ initr_reloc, /*标记重定位完成*/ initr_caches, /*使能cache*/ initr_reloc_global_data, /*初始化重定位后的gd成员*/ initr_barrier, /*imx6ull未用到*/ initr_malloc, /*初始化malloc*/ log_init, /*log初始化*/ initr_bootstage, /*Needsmalloc() buthasitsowntimer*/ initr_console_record, /*初始化控台*/ bootstage_relocate, initr_dm, /*设备模型初始化, 加载设备树, \t\t绑定根节点到 gd >dm_root 中 \t\t获取soc下面的clocks节点以及firmware节点*/ board_init, /*板级初始化*/ efi_memory_init, /*efi_memory初始化*/ \tstdio_init_tables, /*标准输入输出及标准错误等初始化*/ \tinitr_serial, /*串口初始化*/ \tinitr_announce, /*跟调试相关*/ \tpower_init_board, /*电源芯片初始化*/ \tinitr_nand, /*nandflash初始化*/ \tinitr_mmc, /*mmc初始化*/ \tinitr_env, /*环境变量初始化 > env_relocate > env_load*/ \tinitr_secondary_cpu, /*其他cpu初始化，由于imx6ull为单核cpu故忽略*/ \tstdio_add_devices, /*输入输出设备初始化*/ \tinitr_jumptable, /*初始化跳转表*/ \tconsole_init_r, /*控制台初始化*/ \tinterrupt_init, /*中断初始化*/ \tinitr_enable_interrupts, /*中断使能*/ \t/* PPC has audelay(20)here datingfrom2002.Why?*/ \tinitr_ethaddr, /*网络初始化*/ \tboard_late_init, /*板子后续初始化*/ \tinitr_fastboot_setup, \tinitr_net, /*网络初始化*/ \tinitr_check_fastboot, \trun_main_loop, /*运行主循环*/ }; ``` run_main_loop > main_loop > uboot 启动以后会进入 3 秒倒计时，如果在3秒倒计时结束之前按下按下回车键，那么就 会进入uboot的命令模式，如果倒计时结束以后都没有按下回车键，那么就会自动启动Linux内 核，这个功能就是由run_main_loop函数来完成的 > > ```c > /* We come here after U Boot is initialised and ready to process commands */ > void main_loop(void) > { > \tconst char *s; > > \tbootstage_mark_name(BOOTSTAGE_ID_MAIN_LOOP, \"main_loop\"); > > #ifndef CONFIG_SYS_GENERIC_BOARD > \tputs(\"Warning: Your board does not use generic board. Please read\\n\"); > \tputs(\"doc/README.generic board and take action. Boards not\\n\"); > \tputs(\"upgraded by the late 2014 may break or be removed.\\n\"); > #endif > > #ifdef CONFIG_VERSION_VARIABLE > \tsetenv(\"ver\", version_string); /* set version variable */ > #endif /* CONFIG_VERSION_VARIABLE */ > > \tcli_init(); // 初始化hush_shell, 用于处理命令 > \t// 获取环境变量 perboot 的内容，perboot 是一些预启动命令，一般不使用这个环境变量 > \trun_preboot_environment_command(); > > #if defined(CONFIG_UPDATE_TFTP) > \tupdate_tftp(0UL, NULL, NULL); > #endif /* CONFIG_UPDATE_TFTP */ > \t// 此函数会读取环境变量 bootdelay 和 bootcmd 的内容， > \t// 然后将bootdelay 的值赋值给全局变量stored_bootdelay，返回值为环境变量bootcmd > \ts bootdelay_process(); > \tif (cli_process_fdt(&s)) // cli_process_fdt函数返回值为false > \t\tcli_secure_boot_cmd(s); > > \tautoboot_command(s); > > \tcli_loop(); > } > ``` > > #### bootdelay_process 环境变量中搜索bootdelay这个环境变量（字符串形式），如果有配置该环境变量则会将字符串转换成长整型数值 从环境变量中获取bootcmd 若stored_bootdelay! 1，且bootcmd有值，同时在启动过程中没有检测到任何 打断启动过程的输入，则运行启动命令列表`run_command_list`中的一系列命令,即默认的 `bootcmd`命令，其中`stored_bootdelay`会在`abortboot`函数主每过一秒钟减1 如果我们在启动倒计时bootdelay减为0之前 按下了按键打断其自启动过程，就会进入cli_loop函数，此函数负责不断循环检测并处理 用户输入的命令 #### autoboot_command 处理倒计时, 没有按键的时候进入命令行处理 ```c void autoboot_command(const char *s) { \tdebug(\"### main_loop: bootcmd \\\"%s\\\"\\n\", s ? s : \"<UNDEFINED>\"); \tif (stored_bootdelay ! 1 && s && !abortboot(stored_bootdelay)) { #if defined(CONFIG_AUTOBOOT_KEYED) && !defined(CONFIG_AUTOBOOT_KEYED_CTRLC) \t\tint prev disable_ctrlc(1);\t/* disable Control C checking */ #endif \t\trun_command_list(s, 1, 0); // 实际只有这个命令在执行 #if defined(CONFIG_AUTOBOOT_KEYED) && !defined(CONFIG_AUTOBOOT_KEYED_CTRLC) \t\tdisable_ctrlc(prev);\t/* restore Control C checking */ #endif \t} #ifdef CONFIG_MENUKEY \tif (menukey CONFIG_MENUKEY) { \t\ts getenv(\"menucmd\"); \t\tif (s) \t\t\trun_command_list(s, 1, 0); \t} #endif /* CONFIG_MENUKEY */ } ``` abortboot: 处理倒计时 ```c static int abortboot(int bootdelay) { #ifdef CONFIG_AUTOBOOT_KEYED \treturn abortboot_keyed(bootdelay); #else \treturn abortboot_normal(bootdelay); // 实际运行的函数 #endif } ``` ```c static int abortboot_normal(int bootdelay) { \tint abort 0; \tunsigned long ts; #ifdef CONFIG_MENUPROMPT \tprintf(CONFIG_MENUPROMPT); #else \tif (bootdelay > 0) \t\tprintf(\"Hit any key to stop autoboot: %2d \", bootdelay); #endif #if defined CONFIG_ZERO_BOOTDELAY_CHECK \t/* \t * Check if key already pressed \t * Don't check if bootdelay < 0 \t */ \tif (bootdelay > 0) { \t\tif (tstc()) {\t/* we got a key press\t*/ \t\t\t(void) getc(); /* consume input\t*/ \t\t\tputs(\"\\b\\b\\b 0\"); \t\t\tabort 1;\t/* don't auto boot\t*/ \t\t} \t} #endif \twhile ((bootdelay > 0) && (!abort)) { \t\t bootdelay; \t\t/* delay 1000 ms */ \t\tts get_timer(0); \t\tdo { \t\t\tif (tstc()) {\t/* we got a key press\t*/ \t\t\t\tabort 1;\t/* don't auto boot\t*/ \t\t\t\tbootdelay 0;\t/* no more delay\t*/ # ifdef CONFIG_MENUKEY \t\t\t\tmenukey getc(); # else \t\t\t\t(void) getc(); /* consume input\t*/ # endif \t\t\t\tbreak; \t\t\t} \t\t\tudelay(10000); \t\t} while (!abort && get_timer(ts) < 1000); \t\tprintf(\"\\b\\b\\b%2d \", bootdelay); \t} \tputc('\\n'); #ifdef CONFIG_SILENT_CONSOLE \tif (abort) \t\tgd >flags & ~GD_FLG_SILENT; #endif \treturn abort; } ``` #### cli_loop 命令行处理函数 ```c void cli_loop(void) { #ifdef CONFIG_SYS_HUSH_PARSER \tparse_file_outer(); // 运行这个 \t/* This point is never reached */ \tfor (;;); #else \tcli_simple_loop(); #endif /*CONFIG_SYS_HUSH_PARSER*/ } ``` ```c int parse_file_outer(void) #endif { \tint rcode; \tstruct in_str input; #ifndef __U_BOOT__ \tsetup_file_in_str(&input, f); #else \tsetup_file_in_str(&input); //这里, 初始化变量input的成员变量 #endif \trcode parse_stream_outer(&input, FLAG_PARSE_SEMICOLON); //hush shell的命令解释器 \treturn rcode; } ``` ```c /* most recursion does not come through here, the exeception is * from builtin_source() */ static int parse_stream_outer(struct in_str *inp, int flag) { \tstruct p_context ctx; \to_string temp NULL_O_STRING; \tint rcode; #ifdef __U_BOOT__ \tint code 1; #endif \tdo { // 处理输入命令 \t\tctx.type flag; \t\tinitialize_context(&ctx); \t\tupdate_ifs_map(); \t\tif (!(flag & FLAG_PARSE_SEMICOLON) (flag & FLAG_REPARSING)) mapset((uchar *)\";$&\", 0); \t\tinp >promptmode 1; \t\trcode parse_stream(&temp, &ctx, inp, \t\t\t\t flag & FLAG_CONT_ON_NEWLINE ? 1 : '\\n'); // 命令解析 #ifdef __U_BOOT__ \t\tif (rcode 1) flag_repeat 0; #endif \t\tif (rcode ! 1 && ctx.old_flag ! 0) { \t\t\tsyntax(); #ifdef __U_BOOT__ \t\t\tflag_repeat 0; #endif \t\t} \t\tif (rcode ! 1 && ctx.old_flag 0) { \t\t\tdone_word(&temp, &ctx); \t\t\tdone_pipe(&ctx,PIPE_SEQ); #ifndef __U_BOOT__ \t\t\trun_list(ctx.list_head); // 执行解析出来的命令, 最终通过调用cmd_process函数来处理命令 #else \t\t\tcode run_list(ctx.list_head); \t\t\tif (code 2) {\t/* exit */ \t\t\t\tb_free(&temp); \t\t\t\tcode 0; \t\t\t\t/* XXX hackish way to not allow exit from main loop */ \t\t\t\tif (inp >peek file_peek) { \t\t\t\t\tprintf(\"exit not allowed from main input shell.\\n\"); \t\t\t\t\tcontinue; \t\t\t\t} \t\t\t\tbreak; \t\t\t} \t\t\tif (code 1) \t\t\t flag_repeat 0; #endif \t\t} else { \t\t\tif (ctx.old_flag ! 0) { \t\t\t\tfree(ctx.stack); \t\t\t\tb_reset(&temp); \t\t\t} #ifdef __U_BOOT__ \t\t\tif (inp >__promptme 0) printf(\"<INTERRUPT>\\n\"); \t\t\tinp >__promptme 1; #endif \t\t\ttemp.nonnull 0; \t\t\ttemp.quote 0; \t\t\tinp >p NULL; \t\t\tfree_pipe_list(ctx.list_head,0); \t\t} \t\tb_free(&temp); \t/* loop on syntax errors, return on EOF */ \t} while (rcode ! 1 && !(flag & FLAG_EXIT_FROM_LOOP) && \t\t(inp >peek ! static_peek b_peek(inp))); #ifndef __U_BOOT__ \treturn 0; #else \treturn (code ! 0) ? 1 : 0; #endif /* __U_BOOT__ */ } ``` 最后的处理命令的函数是run_list >run_list_real >run_pipe_real >cmd_process ##### cmd_process uboot里面的命令存储使用的是一个宏定义的形式使用的是`U_BOOT_CMD` ```c #define ll_entry_declare(_type, _name, _list)\t\t\t\t\\ \t_type _u_boot_list_2_##_list##_2_##_name __aligned(4)\t\t\\ \t\t\t__attribute__((unused,\t\t\t\t\\ \t\t\tsection(\".u_boot_list_2_\"#_list\"_2_\"#_name))) #define U_BOOT_CMD_MKENT_COMPLETE(_name, _maxargs, _rep, _cmd,\t\t\\ \t\t\t\t_usage, _help, _comp)\t\t\t\\ \t\t{ #_name, _maxargs, _rep, _cmd, _usage,\t\t\t\\ \t\t\t_CMD_HELP(_help) _CMD_COMPLETE(_comp) } #define U_BOOT_CMD_MKENT(_name, _maxargs, _rep, _cmd, _usage, _help)\t\\ \tU_BOOT_CMD_MKENT_COMPLETE(_name, _maxargs, _rep, _cmd,\t\t\\ \t\t\t\t\t_usage, _help, NULL) #define U_BOOT_CMD_COMPLETE(_name, _maxargs, _rep, _cmd, _usage, _help, _comp) \\ \tll_entry_declare(cmd_tbl_t, _name, cmd) \t\t\t\\ \t\tU_BOOT_CMD_MKENT_COMPLETE(_name, _maxargs, _rep, _cmd,\t\\ \t\t\t\t\t\t_usage, _help, _comp); #define U_BOOT_CMD(_name, _maxargs, _rep, _cmd, _usage, _help)\t\t\\ \tU_BOOT_CMD_COMPLETE(_name, _maxargs, _rep, _cmd, _usage, _help, NULL) ``` 依次展开以后 ```c U_BOOT_CMD( dhcp, 3, 1, do_dhcp, \"boot image via network using DHCP/TFTP protocol\", \"[loadAddress] [[hostIPaddr:]bootfilename]\" ); U_BOOT_CMD_COMPLETE(dhcp, 3, 1, do_dhcp, \"boot image via network using DHCP/TFTP protocol\", \"[loadAddress] [[hostIPaddr:]bootfilename]\", NULL) ll_entry_declare(cmd_tbl_t, dhcp, cmd) \\ U_BOOT_CMD_MKENT_COMPLETE(dhcp, 3, 1, do_dhcp, \\ \"boot image via network using DHCP/TFTP protocol\", \\ \"[loadAddress] [[hostIPaddr:]bootfilename]\", \\ NULL); cmd_tbl_t _u_boot_list_2_cmd_2_dhcp __aligned(4) \\ __attribute__((unused,section(.u_boot_list_2_cmd_2_dhcp))) \\ { \"dhcp\", 3, 1, do_dhcp, \\ \"boot image via network using DHCP/TFTP protocol\", \\ \"[loadAddress] [[hostIPaddr:]bootfilename]\",\\ NULL} ``` + 定义了一个cmd_tbl_t类型的变量，变量名为_u_boot_list_2_cmd_2_dhcp，此变量4 字节对齐。 + 使用`__attribute__`关键字设置变量`_u_boot_list_2_cmd_2_dhcp`存储在`.u_boot_list_2_cmd_2_dhcp`段中。u boot.lds链接脚本中有一个名为`.u_boot_list`的段，所有.u_boot_list开 头的段都存放到.u_boot.list ```c struct cmd_tbl_s { \tchar\t\t*name;\t\t/* Command Name\t\t\t*/ \tint\t\tmaxargs;\t/* maximum number of arguments\t*/ \tint\t\trepeatable;\t/* autorepeat allowed?\t\t*/ \t\t\t\t\t/* Implementation function\t*/ \tint\t\t(*cmd)(struct cmd_tbl_s *, int, int, char * const []); // 处理函数 \tchar\t\t*usage;\t\t/* Usage message\t(short)\t*/ #ifdef\tCONFIG_SYS_LONGHELP \tchar\t\t*help;\t\t/* Help message\t(long)\t*/ #endif #ifdef CONFIG_AUTO_COMPLETE \t/* do auto completion on the arguments */ \tint\t\t(*complete)(int argc, char * const argv[], char last_char, int maxv, char *cmdv[]); #endif }; ``` ```c enum command_ret_t cmd_process(int flag, int argc, char * const argv[], \t\t\t int *repeatable, ulong *ticks) { \tenum command_ret_t rc CMD_RET_SUCCESS; \tcmd_tbl_t *cmdtp; \t/* Look up command in command table */ \tcmdtp find_cmd(argv[0]); // 从段里面查找这个命令 \tif (cmdtp NULL) { \t\tprintf(\"Unknown command '%s' try 'help'\\n\", argv[0]); \t\treturn 1; \t} \t/* found check max args */ \tif (argc > cmdtp >maxargs) \t\trc CMD_RET_USAGE; #if defined(CONFIG_CMD_BOOTD) \t/* avoid \"bootd\" recursion */ \telse if (cmdtp >cmd do_bootd) { \t\tif (flag & CMD_FLAG_BOOTD) { \t\t\tputs(\"'bootd' recursion detected\\n\"); \t\t\trc CMD_RET_FAILURE; \t\t} else { \t\t\tflag CMD_FLAG_BOOTD; \t\t} \t} #endif \t/* If OK so far, then do the command */ \tif (!rc) { \t\tif (ticks) \t\t\t*ticks get_timer(0); \t\trc cmd_call(cmdtp, flag, argc, argv); // 在这个函数直接调用处理函数 \t\tif (ticks) \t\t\t*ticks get_timer(*ticks); \t\t*repeatable & cmdtp >repeatable; \t} \tif (rc CMD_RET_USAGE) \t\trc cmd_usage(cmdtp); \treturn rc; } ``` ## 加载内核 ![image 20251028163225915](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510281632086.png) 因为内核是要运行在 DDR中的，因此就要将内核重定位到DDR中。前面我们讲了很多环境变量、设备树等，这些都 要传递给linux内核，Linux会读取这些参数，并且根据这些参数进行配置 对于linux内核而言， 这就不一样了，他需要u boot帮他搭建好内核运行所必须的环境，配置各种寄存器，和硬件紧密 联系的是u boot，而Linux地重定位也是由u boot完成 是u boot可以 从3个地方获取linux内核，如NAND启动/EMMC启动、SD卡启动、USB启动等。我们开发板 上板载了启动方式选择地拨码开关，根据下面表格设置拨码开关就可以实现从不同介质中加载 Linux 内核到DDR中运行, ，imx6ull在启动内核前会判断启动引脚地电平状态，根据启动引脚地电平状态选择不同的启动方式 不管是那种启动方式，最终都要将内核镜像加载到DDR中运行，当使用网络（tftp与nfs）启动时，还应该在u boot的命令终端上配置相应的环境变量，如本机ip、服务器ip、网关、子网掩码等，特别提示：需要设置板子ip与服务器ip在同一个网段上才可以实现网络数据访问 当u boot执行bootcmd的命令后，最终会调用do_bootz函数启动Linux内核 不管是bootz还是bootm命令，在启动Linux内核的时候都会用到一个重要的全局变量：images，images在文件cmd/bootm.c ```c /* * Legacy and FIT format headers used by do_bootm() and do_bootm_<os>() * routines. */ typedef struct bootm_headers { \t/* \t * Legacy os image header, if it is a multi component image \t * then boot_get_ramdisk() and get_fdt() will attempt to get \t * data from second and third component accordingly. \t */ \timage_header_t\t*legacy_hdr_os;\t\t/* image header pointer */ \timage_header_t\tlegacy_hdr_os_copy;\t/* header copy */ \tulong\t\tlegacy_hdr_valid; #if defined(CONFIG_FIT) \tconst char\t*fit_uname_cfg;\t/* configuration node unit name */ \tvoid\t\t*fit_hdr_os;\t/* os FIT image header */ \tconst char\t*fit_uname_os;\t/* os subimage node unit name */ \tint\t\tfit_noffset_os;\t/* os subimage node offset */ \tvoid\t\t*fit_hdr_rd;\t/* init ramdisk FIT image header */ \tconst char\t*fit_uname_rd;\t/* init ramdisk subimage node unit name */ \tint\t\tfit_noffset_rd;\t/* init ramdisk subimage node offset */ \tvoid\t\t*fit_hdr_fdt;\t/* FDT blob FIT image header */ \tconst char\t*fit_uname_fdt;\t/* FDT blob subimage node unit name */ \tint\t\tfit_noffset_fdt;/* FDT blob subimage node offset */ \tvoid\t\t*fit_hdr_setup;\t/* x86 setup FIT image header */ \tconst char\t*fit_uname_setup; /* x86 setup subimage node name */ \tint\t\tfit_noffset_setup;/* x86 setup subimage node offset */ #endif #ifndef USE_HOSTCC \timage_info_t\tos;\t\t/* os image info 为系统镜像信息 */ \tulong\t\tep;\t\t/* entry point of OS OS入口点 */ \tulong\t\trd_start, rd_end;/* ramdisk start/end */ \tchar\t\t*ft_addr;\t/* flat dev tree address 设备树地址 */ \tulong\t\tft_len;\t\t/* length of flat device tree 设备树长度 */ \tulong\t\tinitrd_start; \tulong\t\tinitrd_end; \tulong\t\tcmdline_start; \tulong\t\tcmdline_end; \tbd_t\t\t*kbd; #endif \tint\t\tverify;\t\t/* getenv(\"verify\")[0] ! 'n' */ // 定义表示BOOT的不同阶段 #define\tBOOTM_STATE_START\t(0x00000001) // 引导过程开始 #define\tBOOTM_STATE_FINDOS\t(0x00000002) // 查找操作系统镜像 #define\tBOOTM_STATE_FINDOTHER\t(0x00000004)// 查找其他组件（设备树、ramdisk等） #define\tBOOTM_STATE_LOADOS\t(0x00000008)// 加载操作系统到内存 #define\tBOOTM_STATE_RAMDISK\t(0x00000010)// 处理RAM磁盘（initrd/initramfs） #define\tBOOTM_STATE_FDT\t\t(0x00000020)// 处理设备树（Flattened Device Tree） #define\tBOOTM_STATE_OS_CMDLINE\t(0x00000040)// 准备内核命令行参数 #define\tBOOTM_STATE_OS_BD_T\t(0x00000080)// 准备板级信息表 #define\tBOOTM_STATE_OS_PREP\t(0x00000100)// 操作系统启动前准备 #define\tBOOTM_STATE_OS_FAKE_GO\t(0x00000200)\t/* 模拟运行OS 'Almost' run the OS */ #define\tBOOTM_STATE_OS_GO\t(0x00000400)// 实际跳转到操作系统入口点 \tint\t\tstate; #ifdef CONFIG_LMB \tstruct lmb\tlmb;\t\t/* for memory mgmt */ #endif } bootm_headers_t; ``` ```c typedef struct image_info { \tulong\t\tstart, end;\t\t/* start/end of blob blob开始和结束位置 */ \tulong\t\timage_start, image_len; /* start of image within blob, len of image \t\t\t\t\t\t\t\t\t镜像起始地址(包括blob)和长度 */ \tulong\t\tload;\t\t\t/* load addr for the image 系统镜像加载地址 */ \tuint8_t\t\tcomp, type, os;\t\t/* compression, type of image, os type 镜像压缩、类型，OS类型 */ \tuint8_t\t\tarch;\t\t\t/* CPU architecture CPU架构 */ } image_info_t; ``` ### bootz 启动命令是bootz, `bootz 80800000 83000000`, 第一个是镜像的加载地址, 第二个是设备树的地址 ```c int do_bootz(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[]) { \tint ret; \t/* Consume 'bootz' */ \targc ; argv++; \tif (bootz_start(cmdtp, flag, argc, argv, &images)) \t\treturn 1; \t/* \t * We are doing the BOOTM_STATE_LOADOS state ourselves, so must \t * disable interrupts ourselves \t */ \tbootm_disable_interrupts(); // 关闭中断 \timages.os.os IH_OS_LINUX; // 设置images.os.os为IH_OS_LINUX，也就是设置系统镜像为Linux // \tret do_bootm_states(cmdtp, flag, argc, argv, \t\t\t BOOTM_STATE_OS_PREP BOOTM_STATE_OS_FAKE_GO \t\t\t BOOTM_STATE_OS_GO, \t\t\t &images, 1); // 调用函数do_bootm_states来执行不同的BOOT阶段 \t\t\t\t//BOOTM_STATE_OS_PREP 、BOOTM_STATE_OS_FAKE_GO和BOOTM_STATE_OS_GO \treturn ret; } ``` #### bootz_start ```c /* * zImage booting support */ static int bootz_start(cmd_tbl_t *cmdtp, int flag, int argc, \t\t\tchar * const argv[], bootm_headers_t *images) { \tint ret; \tulong zi_start, zi_end; \t// 处理状态实际运行bootm_start, 对全局变量images清零 \tret do_bootm_states(cmdtp, flag, argc, argv, BOOTM_STATE_START, \t\t\t images, 1); \t/* Setup Linux kernel zImage entry point */ \tif (!argc) { \t\timages >ep load_addr; \t\tdebug(\"* kernel: default image load address 0x%08lx\\n\", \t\t\t\tload_addr); \t} else { // 设置images的ep成员变量，也就是系统镜像的入口点, 0x87800000 \t\timages >ep simple_strtoul(argv[0], NULL, 16); \t\tdebug(\"* kernel: cmdline image address 0x%08lx\\n\", \t\t\timages >ep); \t} \t//判断当前的系统镜像文件是否为Linux的镜像文件 // 判断一下zi_image的zimage是不是0x016f2818, 从zImage文件的第37位开始 \tret bootz_setup(images >ep, &zi_start, &zi_end); \tif (ret ! 0) \t\treturn 1; \tlmb_reserve(&images >lmb, images >ep, zi_end zi_start); \t/* \t * Handle the BOOTM_STATE_FINDOTHER state ourselves as we do not \t * have a header that provide this informaiton. \t * 在这里仅仅用于查找设备树(dtb)文件, 我们没有用到ramdisk, boot_get_fdt \t * 初始化images的ft_addr以及ft_len, images.ft_addr 0X83000000，长度根据具体的设备树文件而定 \t */ \tif (bootm_find_images(flag, argc, argv)) \t\treturn 1; #ifdef CONFIG_SECURE_BOOT \textern uint32_t authenticate_image( \t\t\tuint32_t ddr_start, uint32_t image_size); \tif (authenticate_image(images >ep, zi_end zi_start) 0) { \t\tprintf(\"Authenticate zImage Fail, Please check\\n\"); \t\treturn 1; \t} #endif \treturn 0; } ``` ##### bootz_setup ```c struct zimage_header { \tuint32_t\tcode[9]; \tuint32_t\tzi_magic; \tuint32_t\tzi_start; \tuint32_t\tzi_end; }; #define\tLINUX_ARM_ZIMAGE_MAGIC\t0x016f2818 int bootz_setup(ulong image, ulong *start, ulong *end) { \tstruct zimage_header *zi; \tzi (struct zimage_header *)map_sysmem(image, 0); \tif (zi >zi_magic ! LINUX_ARM_ZIMAGE_MAGIC) { // 判断幻数 \t\tputs(\"Bad Linux ARM zImage magic!\\n\"); \t\treturn 1; \t} \t*start zi >zi_start; // 记录zImage的大小 \t*end zi >zi_end; \tprintf(\"Kernel image @ %#08lx [ %#08lx %#08lx ]\\n\", image, *start, \t *end); \treturn 0; } ``` ### do_bootm_states 处理不同的启动启动状态, 进行不同的处理 使用到下面的几种状态 ```c BOOTM_STATE_OS_PREP BOOTM_STATE_OS_FAKE_GO BOOTM_STATE_OS_GO BOOTM_STATE_START ``` ```c int do_bootm_states(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[], \t\t int states, bootm_headers_t *images, int boot_progress) { \tboot_os_fn *boot_fn; \tulong iflag 0; \tint ret 0, need_boot_fn; \timages >state states; \t/* \t * Work through the states and see how far we get. We stop on \t * any error. \t */ \tif (states & BOOTM_STATE_START) \t\tret bootm_start(cmdtp, flag, argc, argv); \t/* From now on, we need the OS boot function */ \tif (ret) \t\treturn ret; \tboot_fn bootm_os_get_boot_func(images >os.os); // 获取到os的内核启动函数do_bootm_linux \tneed_boot_fn states & (BOOTM_STATE_OS_CMDLINE \t\t\tBOOTM_STATE_OS_BD_T BOOTM_STATE_OS_PREP \t\t\tBOOTM_STATE_OS_FAKE_GO BOOTM_STATE_OS_GO); \tif (boot_fn NULL && need_boot_fn) { \t\tif (iflag) \t\t\tenable_interrupts(); \t\tprintf(\"ERROR: booting os '%s' (%d) is not supported\\n\", \t\t genimg_get_os_name(images >os.os), images >os.os); \t\tbootstage_error(BOOTSTAGE_ID_CHECK_BOOT_OS); \t\treturn 1; \t} \t/* Call various other states that are not generally used */ \tif (!ret && (states & BOOTM_STATE_OS_PREP)) // 运行查找到的do_bootm_linux, 之后调用函数boot_prep_linux // 实际是把boot_args传递给内核, 通过设备树, 添加一个子节点 \t\tret boot_fn(BOOTM_STATE_OS_PREP, argc, argv, images); #ifdef CONFIG_TRACE \t/* Pretend to run the OS, then run a user command */ \tif (!ret && (states & BOOTM_STATE_OS_FAKE_GO)) { \t\tchar *cmd_list getenv(\"fakegocmd\"); \t\tret boot_selected_os(argc, argv, BOOTM_STATE_OS_FAKE_GO, \t\t\t\timages, boot_fn); \t\tif (!ret && cmd_list) \t\t\tret run_command_list(cmd_list, 1, flag); \t} #endif \t/* Check for unsupported subcommand. */ \tif (ret) { \t\tputs(\"subcommand not supported\\n\"); \t\treturn ret; \t} \t/* Now run the OS! We hope this doesn't return 开始运行OS还是使用do_bootm_linux */ \tif (!ret && (states & BOOTM_STATE_OS_GO)) \t\tret boot_selected_os(argc, argv, BOOTM_STATE_OS_GO, \t\t\t\timages, boot_fn); \t/* Deal with any fallout */ err: \tif (iflag) \t\tenable_interrupts(); \tif (ret BOOTM_ERR_UNIMPLEMENTED) \t\tbootstage_error(BOOTSTAGE_ID_DECOMP_UNIMPL); \telse if (ret BOOTM_ERR_RESET) \t\tdo_reset(cmdtp, flag, argc, argv); \treturn ret; } ``` #### do_bootm_linux ```c int do_bootm_linux(int flag, int argc, char * const argv[], \t\t bootm_headers_t *images) { \t/* No need for those on ARM */ \tif (flag & BOOTM_STATE_OS_BD_T flag & BOOTM_STATE_OS_CMDLINE) \t\treturn 1; \tif (flag & BOOTM_STATE_OS_PREP) { \t\tboot_prep_linux(images); \t\treturn 0; \t} \tif (flag & (BOOTM_STATE_OS_GO BOOTM_STATE_OS_FAKE_GO)) { \t\tboot_jump_linux(images, flag); \t\treturn 0; \t} \tboot_prep_linux(images); \tboot_jump_linux(images, flag); \treturn 0; } ``` ```c /* Subcommand: GO */ static void boot_jump_linux(bootm_headers_t *images, int flag) { \tunsigned long machid gd >bd >bi_arch_number; // 老版本使用 \tchar *s; \tvoid (*kernel_entry)(int zero, int arch, uint params); \tunsigned long r2; \tint fake (flag & BOOTM_STATE_OS_FAKE_GO); \tkernel_entry (void (*)(int, int, uint))images >ep; // 之前记录的0x80800000 zImage位置 \ts getenv(\"machid\"); \tif (s) { \t\tif (strict_strtoul(s, 16, &machid) < 0) { \t\t\tdebug(\"strict_strtoul failed!\\n\"); \t\t\treturn; \t\t} \t\tprintf(\"Using machid 0x%lx from environment\\n\", machid); \t} \tdebug(\"## Transferring control to Linux (at address %08lx)\" \\ \t\t\"...\\n\", (ulong) kernel_entry); \tbootstage_mark(BOOTSTAGE_ID_RUN_OS); \tannounce_and_cleanup(fake); // 输出最后一句话 \tif (IMAGE_ENABLE_OF_LIBFDT && images >ft_len) \t\tr2 (unsigned long)images >ft_addr; // 记录设备树的起始地址 \telse \t\tr2 gd >bd >bi_boot_params; \tif (!fake) { #ifdef CONFIG_ARMV7_NONSEC \t\tif (armv7_boot_nonsec()) { \t\t\tarmv7_init_nonsec(); \t\t\tsecure_ram_addr(_do_nonsec_entry)(kernel_entry, \t\t\t\t\t\t\t 0, machid, r2); \t\t} else #endif \t\t\tkernel_entry(0, machid, r2); // 运行内核 \t} } ```"},"/note/Linux/野火Linux/2025-9-29-44-添加驱动(设备树).html":{"title":"添加驱动","content":"# 添加驱动 是对于驱动的修改或者是对于设备树的修改，其中设备 树目录在arch/arm/boot/dts目录下，设备树插件目录在arch/arm/boot/dts/overlays目录下, 驱动目 录在ebf_linux_kernel/drivers每个不同的驱动占用一个子目录，如char、block、net、mtd、i2c 等 这里的驱动实际使用的是添加模块的形式进行的 ## 示例 在drivers/ebf_module目录的下面添加一个hello_module ```c #include <linux/module.h> #include <linux/init.h> #include <linux/kernel.h> static int __init hello_init(void){ printk(KERN_EMERG \"Hello world init\\n\"); printk(\"[default] Hello ModuleInit\\n\"); return 0; } static void __exit hello_exit(void){ printk(\"[ default ] Hello ModuleExit\\n\"); } module_init(hello_init); module_exit(hello_exit); MODULE_LICENSE(\"GPL2\"); MODULE_AUTHOR(\"jiao\"); MODULE_DESCRIPTION(\"helloworldmodule\"); MODULE_ALIAS(\"test_module\"); ``` 这个文件夹下面的配置文件 ```makefile obj $(CONFIG_HELLO_MODULE) : hello_module.o ``` 上一层的配置文件 ```makefile obj y + hello_module/ ``` 上一层的Kconfig文件 ```c config HELLO_MODULE \ttristate \"hello_module\" ``` 之后再编译之前进行选择 ## 设备树编译 在编写完设备树后，假设取名为（mmc：imx6ull mmc npi.dtsnand:imx6ull nand npi.dts） 在./ebf_linux_kernel/arch/arm/boot/dts/Makefile 文件中添加 ``` imx6ull mmc npi.dtb \\ imx6ull nand npi.dtb \\ ``` `make dtbs ARCH arm CROSS_COMPILE arm linux gnueabihf `全部编译 `make imx6ull mmc npi.dtb ARCH arm CROSS_COMPILE arm linux gnueabihf `单独编译 把编译出的设备树imx6ull mmc npi.dtb/imx6ull nand npi.dtb 下载到板子中的/usr/lib/linux image 4.19.35 imx6 即可"},"/note/Linux/野火Linux/2025-7-15-10-内核模块.html":{"title":"内核","content":"# 内核 ## 下载 1.下载linux内核源码 ​\tgithub: ``` git clone https://github.com/Embedfire/ebf buster linux.git ``` ​\tgitee: ``` git clone https://gitee.com/Embedfire/ebf buster linux.git ``` 2.安装必要环境工具库 ``` sudo apt install make gcc arm linux gnueabihf gcc bison flex libssl dev dpkg dev lzop ``` 3.一键编译内核 ``` sudo ./make_deb.sh ``` ## 内核模块 这是为了处理Linnux内核的可拓展性以及维护性比较差 ### 内核派系 宏内核：关键功能和服务功能均在内核空间提供, 服务是可以裁剪的 运行效率高 扩展性较差 微内核：内核空间只提供关键功能，服务功能在用户空间提供 运行效率较低 安全性、扩展性较高 ![image 20250715095014631](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507150950753.png) #### 内核模块加载/卸载 使用`insmod`命令加载 使用`rmmod`命令卸载 `lsmod` 查看当前的所有模块 #### 内核模块入口/出口 `module_init()`：加载模块式该函数自动执行，进行初始化操作 `module_exit()`：卸载模块时函数自动执行，进行清理操作 #### 内核模块信息声明 `MODULE_LICENSE()`：表示模块代码接受的软件许可协议，Linux内核遵循GPL V2开源协议，内核模块与linux内核保持一致即可。 `MODULE_AUTHOR()`：描述模块的作者信息 `MODULE_DESCRIPTION()`：对模块的简单介绍 `MODULE_ALIAS()`：给模块设置一个别名 #### 内核模块头文件 `#include <linux/module.h>`：包含内核模块信息声明的相关函数 `#include <linux/init.h>`：包含了 module_init()和 module_exit()函数的声明 `#include <linux/kernel.h>`：包含内核提供的各种函数，如printk #### 内核模块打印函数 printf：glibc实现的打印函数，工作于用户空间 printk：内核模块无法使用glibc库函数，内核自身实现的一个类printf函数，但是需要指定打印等级。 \\#define KERN_EMERG \t\"<0>\" 通常是系统崩溃前的信息 #define KERN_ALERT \"<1>\" 需要立即处理的消息 #define KERN_CRIT \"<2>\" 严重情况 #define KERN_ERR \"<3>\" 错误情况 #define KERN_WARNING \"<4>\" 有问题的情况 #define KERN_NOTICE \"<5>\" 注意信息 #define KERN_INFO \"<6>\" 普通消息 #define KERN_DEBUG \"<7>\" 调试信息 查看当前系统printk打印等级：`cat /proc/sys/kernel/printk` 当前控制台日志级别 默认消息日志级别 最小的控制台级别 默认控制台日志级别 打印内核所有打印信息：dmesg 内核log缓冲区大小有限制，缓冲区数据可能被冲掉 #### Makefile分析 `KERNEL_DIR`：指向linux内核具体路径 `export`：导出变量给子Makefile使用 `obj m` : <模块名>.o：定义要生成的模块 `$(MAKE)`：Makefile的默认变量，值为make `选项” C”`：让make工具跳转到linux内核目录下读取顶层Makefile `M `：表示内核模块源码目录 `$(CURDIR)`：Makefile默认变量，值为当前目录所在路径 `make modules`：执行Linux顶层Makefile的伪目标，它实现内核模块的源码读取并编译为.ko文件 #### 编译内核模块 ```makefile KERNEL_DIR /home/jiao/yh linux/driver/kernel/ebf buster linux master/build_image/build ARCH arm CROSS_COMPILE arm linux gnueabihf export ARCH CROSS_COMPILE obj m : helloworld.o all: \t$(MAKE) C $(KERNEL_DIR) M $(CURDIR) modules .PHONE:clean copy clean: \t$(MAKE) C $(KERNEL_DIR) M $(CURDIR) clean\t copy: \tsudo cp *.ko /home/embedfire/workdir ``` ## 示例 ```c #include <linux/module.h> #include <linux/init.h> #include <linux/kernel.h> static int __init hello_init(void) { printk(KERN_EMERG \"[ KERN_EMERG ] Hello World Module Init\\n\"); printk( \"[ default ] Hello World Module Init\\n\"); return 0; } static void __exit hello_exit(void) { printk(\"[ default ] goodbye\\n\"); } module_init(hello_init); module_exit(hello_exit); MODULE_LICENSE(\"GPL2\"); MODULE_AUTHOR(\"embedfire \"); MODULE_DESCRIPTION(\"hello world module\"); MODULE_ALIAS(\"test_module\"); ``` > 在Linux内核模块编程中，`__init`和`__exit`宏用于优化内存管理，具体作用如下： > > 1. `__init` 宏 > > **作用**：标记模块初始化函数（如`hello_init`），表示该函数仅在**模块加载时运行一次**。 > **内存优化**： > 内核会将标记为`__init`的函数代码放在特殊的内存区域（`.init.text`段）。初始化完成后，**内核会自动释放这部分内存**，减少长期内存占用。 > **使用场景**： > 只执行一次的函数（如资源分配、硬件初始化）。 > > 2. `__exit` 宏 > > **作用**：标记模块退出函数（如`hello_exit`），表示该函数仅在**模块卸载时运行**。 > **内存优化**： > 函数代码会被放在`.exit.text`段。对于**动态加载的模块**（非编译进内核），卸载时会释放这部分内存。 > **注意**：若模块编译进内核（非动态加载），`__exit`函数会被直接丢弃（因为永不卸载）。 > **使用场景**： > 清理函数（如释放资源、关闭设备）。 ```makefile KERNEL_DIR /home/pi/build ARCH arm CROSS_COMPILE arm linux gnueabihf export ARCH CROSS_COMPILE obj m : helloworld.o all: \t# C内核的目录, 找到他的Makefile, 使用他的伪目标modules, M是当前的模块的位置 \t$(MAKE) C $(KERNEL_DIR) M $(CURDIR) modules .PHONE:clean copy clean: \t$(MAKE) C $(KERNEL_DIR) M $(CURDIR) clean\t copy: \tsudo cp *.ko /home/embedfire/workdir ``` KERNEL_DIR：指向linux内核具体路径 export：导出变量给子Makefile使用 obj m : <模块名>.o：定义要生成的模块 $(MAKE)：Makefile的默认变量，值为make 选项” C”：让make工具跳转到linux内核目录下读取顶层Makefile M ：表示内核模块源码目录 $(CURDIR)：Makefile默认变量，值为当前目录所在路径 make modules：执行Linux顶层Makefile的伪目标，它实现内核模块的源码读取并编译为.ko文件 ## 使用参数 #### 模块参数 根据不同应用场合给内核模块传递不同参数，提高内核模块灵活性, 可以在加载模型的时候直接进行赋值 定义一个常见变量 使用module_param宏把传参值赋给变量 ```c module_param(name, type, perm) ``` name：参数名 type：参数类型，如int、byte、bool、charp... perm：读写权限 不允许设置可执行权限 在`/sys/module/模块名/parameters`目录下，会生成该参数对应的文件名 #### 符号共享 内核模块可以共享导出的符号表, 在其他的模块里面可以使用这部分的符号, 使用的时候需要加一个声明(函数声明和使用extern声明变量) 变量共享 函数共享 ``` EXPORT_SYMBOL(sym) ``` sym：变量名或者函数名 ##### 查看符号表 ```bash cat /proc/kallsyms grep xxx ``` ##### Makefile修改 有依赖关系的模块，放在一起进行编译 clean伪目标增加清除共享文件夹指令 ##### 模块手动加载 加载时，必须先加载相关依赖模块 卸载时，顺序相反 ##### 依赖模块自动加载 模块之间有依赖的时候加载以及卸载是比较复杂的 所有内核模块统一放到\"/lib/modules/内核版本\"目录下, 可以使用`uname r`查看版本 ``` cp *.ko /lib/modules/内核版本 ``` 建立模块依赖关系, 会自动查看前面的目录下面的ko文件： ``` depmod a ``` 查看模块依赖关系 ``` cat /lib/modules/内核版本/modules.dep ``` 加载模块及其依赖模块 ``` modprobe xxx ``` 卸载模块及其依赖模块 ``` modprobe r xxx ``` ### 代码实现 ```c #include <linux/module.h> #include <linux/init.h> #include <linux/kernel.h> static int itype 0; module_param(itype,int,0); static bool btype 0; module_param(btype,bool,0644); static char ctype 0; module_param(ctype,byte,0); static char *stype 0; module_param(stype,charp,0644); static int __init param_init(void) { printk(KERN_ALERT \"param init!\\n\"); printk(KERN_ALERT \"itype %d\\n\",itype); printk(KERN_ALERT \"btype %d\\n\",btype); printk(KERN_ALERT \"ctype %d\\n\",ctype); printk(KERN_ALERT \"stype %s\\n\",stype); return 0; } static void __exit param_exit(void) { printk(KERN_ALERT \"module exit!\\n\"); } // 导出几个符号, 可以在其他的文件里面使用 EXPORT_SYMBOL(itype); int my_add(int a, int b) { return a+b; } EXPORT_SYMBOL(my_add); int my_sub(int a, int b) { return a b; } EXPORT_SYMBOL(my_sub); module_init(param_init); module_exit(param_exit); MODULE_LICENSE(\"GPL2\"); MODULE_AUTHOR(\"jiao\"); MODULE_DESCRIPTION(\"module_param\"); MODULE_ALIAS(\"module_param\"); ``` ![image 20250715143634777](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507151436854.png) > 加载时候赋值 #### 其他文件使用 在头文件里面声明 ```h #ifndef __CALCULATION_H__ #define __CALCULATION_H__ extern int itype; int my_add(int a, int b); int my_sub(int a, int b); #endif ``` ```c #include <linux/module.h> #include <linux/init.h> #include <linux/kernel.h> #include \"calculation.h\" static int __init calculation_init(void) { itype 1; printk(KERN_ALERT \"calculation init!\\n\"); printk(KERN_ALERT \"itype+1 %d, itype 1 %d\\n\", my_add(itype,1), my_sub(itype,1)); return 0; } static void __exit calculation_exit(void) { printk(KERN_ALERT \"calculation exit!\\n\"); } module_init(calculation_init); module_exit(calculation_exit); MODULE_LICENSE(\"GPL2\"); MODULE_AUTHOR(\"embedfire \"); MODULE_DESCRIPTION(\"calculation module\"); MODULE_ALIAS(\"calculation_module\"); ```"},"/note/Linux/野火Linux/2025-10-2-49-deb包.html":{"title":"deb包","content":"# deb包 为了方便管理一些程序或脚本，可以将这些程序以及脚本都制作在一个deb包中 制作deb的方式很多，如使用dpkg deb方式、使用checkinstall方式、使用 dh_make 方式及修改原有的deb包 它是基于tar包的，所以同样会记录着文件的权限信息（读、写、可执行）、所有 者、用户组等, `dpkg l`来查看系统以及安装了哪些deb包 ## 组成 + 安装的内容，这部分类似linux的根目录，表示需要将软件安装到linux系统上的文件目录 + 控制信息（放在DEBIAN目录下），通常DEBIAN目录下有如下几个文件 + + **changelog**: 文件记录了deb包的作者、版本以及最后一次更新日期等信息 + **control**: 文件记录了包名、版本号、架构、维护者及描述等信息 + **copyright**: 文件记录了一些版权信息 + **postinst**: 软件在进行正常目录文件拷贝到系统后需要执行的脚本。 + **postrm**: 软件卸载后需要执行的脚本。 > 其中control、postinst、postrm 为必要文件 ## 示例 ``` hello_deb/ ├── DEBIAN │ ├── control │ ├── postinst │ └── postrm └── opt └── hello_deb └── hello_deb.sh ``` + control文件 ``` Package: hello deb Version: 1.0.0 Section: free Priority: optional Essential: no Architecture: armhf Maintainer: embedfire <embedfire@embedfire.com> Provides: hell_deb Description: deb test ``` + postinst文件 ```bash #!/bin/bash if [ \"$1\" \"upgrade\" ] [ \"$1\" \"install\" ];then \techo \"hello_deb installing\" fi ``` + postrm文件 ```bash # !/bin/bash if [ \"$1\" \"upgrade\" ] ; then \techo \"upgrade\" elif [ \"$1\" \"remove\" ] [ \"$1\" \"purge\" ] ; then \techo \"remove\" fi ``` + hello_deb.sh ```bash #! /bin/bash echo Hello deb! echo This is a test script!! ``` + 打包 `sudo dpkg deb b ../hello_deb ../hello_deb_1.0.0_armhf.deb`创建deb包, 可以使用命令` dpkg c hello_deb_1.0.0_armhf.deb`查看包的文件信息, 也可以使用``dpkg info hello_deb_1.0.0_armhf.deb`查看配置信息 + 安装 `sudo dpkg i hello_deb_1.0.0_armhf.deb`并且在安装完软件之后可以输入`dpkg s hello dev`命令查看是否安装了软件 ## 修改现有的包 `dpkg X`命令对deb包进行解压 ` pkg X hello_deb_1.0.0_armhf.deb update_deb/` 进入update_deb 目录下可看到并没DEBIAN相关目录，在update_deb目录下使用dpkg e解压出 控制相关信息`dpkg e ../hello_deb_1.0.0_armhf.deb`"},"/note/Linux/野火Linux/2025-9-27-36-工作队列.html":{"title":"工作队列","content":"# 工作队列 ## 使用 + 定义一个`work_struct`结构体变量 + `INIT_WORK(_work, _func)`初始化工作 + 也可以使用`DECLARE_WORK(n, f)`一个实现定义以及初始化 + 使用`schedule_work(struct work_struct *work)`触发工作 ## 工作队列实验 #### tasklet机制 软中断环境下执行、不允许休眠、降低系统实时性 ##### 工作队列机制 类似于kthread_worker 进程上下文环境执行、允许休眠、不影响实时性 #### 创建工作队列 ##### alloc_workqueue() include/linux/workqueue.h 默认的时候可以直接使用Linux创建的工作队列, 所以不需要调用这个函数 ```c #define alloc_workqueue(fmt, flags, max_active, args...)\t\t\\ \t__alloc_workqueue_key((fmt), (flags), (max_active),\t\t\\ \t\t\t NULL, NULL, ##args) ``` #### 使用工作队列 ##### work_struct结构体 include/linux/workqueue.h ```c struct work_struct { \tatomic_long_t data; \tstruct list_head entry; \twork_func_t func; // 回调函数 #ifdef CONFIG_LOCKDEP \tstruct lockdep_map lockdep_map; #endif }; ``` ##### INIT_WORK 宏 include/linux/workqueue.h 初始化工作 ```c #define INIT_WORK(_work, _func)\t\t\t\t\t\t\\ \t__INIT_WORK((_work), (_func), 0) ``` _work：具体工作 _func：工作处理函数 ##### schedule_work()函数 include/linux/workqueue.h 开始执行这个具体的工作 ```c static inline bool schedule_work(struct work_struct *work) ``` work：具体工作 ## 实际使用 ```c #include <linux/init.h> #include <linux/kernel.h> #include <linux/module.h> #include <linux/fs.h> #include <linux/cdev.h> #include <linux/uaccess.h> #include <linux/delay.h> #include <linux/ide.h> #include <linux/errno.h> #include <linux/gpio.h> #include <asm/mach/map.h> #include <linux/of.h> #include <linux/of_address.h> #include <linux/of_gpio.h> #include <asm/io.h> #include <linux/device.h> #include <linux/irq.h> #include <linux/of_irq.h> /* 字符设备内容 */ #define DEV_NAME \"button\" #define DEV_CNT (1) static dev_t button_devno;\t\t //定义字符设备的设备号 static struct cdev button_chr_dev; //定义字符设备结构体chr_dev struct class *class_button;\t\t //保存创建的类 struct device *device_button;\t\t // 保存创建的设备 struct device_node\t*button_device_node NULL; //定义按键设备节点结构体 unsigned button_GPIO_number 0; //保存button使用的GPIO引脚编号 u32 interrupt_number 0; // button 引脚中断编号 atomic_t button_status ATOMIC_INIT(0); //定义整型原子变量，保存按键状态 ，设置初始值为0 struct work_struct button_work; void work_hander(struct work_struct *work) { \tprintk(KERN_EMERG \"work_hander is running!\\r\\n\"); } static irqreturn_t button_irq_hander(int irq, void *dev_id) { \t// printk_green(\"button on \\n\"); \t/*按键状态加一*/ \tprintk(KERN_EMERG \"button_irq_hander is running!\"); \tatomic_inc(&button_status); \tschedule_work(&button_work); \tprintk(KERN_EMERG \"button_irq_hander is end!\"); \treturn IRQ_HANDLED; } static int button_open(struct inode *inode, struct file *filp) { \tint error 1; \t \t \t/*添加初始化代码*/ \t// printk_green(\"button_open\"); \t/*获取按键 设备树节点*/ \tbutton_device_node of_find_node_by_path(\"/button_interrupt\"); \tif(NULL button_device_node) \t{ \t\tprintk(\"of_find_node_by_path error!\"); \t\treturn 1; \t} \t/*获取按键使用的GPIO*/ \tbutton_GPIO_number of_get_named_gpio(button_device_node ,\"button_gpio\", 0); \tif(0 button_GPIO_number) \t{ \t\tprintk(\"of_get_named_gpio error\"); \t\treturn 1; \t} \t/*申请GPIO , 记得释放*/ \terror gpio_request(button_GPIO_number, \"button_gpio\"); \tif(error < 0) \t{ \t\tprintk(\"gpio_request error\"); \t\tgpio_free(button_GPIO_number); \t\treturn 1; \t} \terror gpio_direction_input(button_GPIO_number);//设置引脚为输入模式 \t/*获取中断号*/ \tinterrupt_number irq_of_parse_and_map(button_device_node, 0); \tprintk(\"\\n irq_of_parse_and_map! %d \\n\",interrupt_number); \t/*申请中断, 记得释放*/ \terror request_irq(interrupt_number,button_irq_hander,IRQF_TRIGGER_RISING,\"button_interrupt\",device_button); \tif(error ! 0) \t{ \t\tprintk(\"request_irq error\"); \t\tfree_irq(interrupt_number, device_button); \t\treturn 1; \t} \tINIT_WORK(&button_work,work_hander); \t/*申请之后已经开启了，切记不要再次打开，否则运行时报错*/ \t// // enable_irq(interrupt_number); \treturn 0; } static int button_read(struct file *filp, char __user *buf, size_t cnt, loff_t *offt) { \tint error 1; \tint button_countervc 0; \t/*读取按键状态值*/ \tbutton_countervc atomic_read(&button_status); \t/*结果拷贝到用户空间*/ \terror copy_to_user(buf, &button_countervc, sizeof(button_countervc)); \tif(error < 0) \t{ \t\tprintk(\"copy_to_user error\"); \t\treturn 1; \t} \t/*清零按键状态值*/ \tatomic_set(&button_status,0); \treturn 0; } /*字符设备操作函数集，.release函数实现*/ static int button_release(struct inode *inode, struct file *filp) { \t/*释放申请的引脚,和中断*/ \tgpio_free(button_GPIO_number); \tfree_irq(interrupt_number, device_button); \treturn 0; } /*字符设备操作函数集*/ static struct file_operations button_chr_dev_fops { \t.owner THIS_MODULE, \t.open button_open, \t.read button_read, \t.release button_release}; /* *驱动初始化函数 */ static int __init button_driver_init(void) { \tint error 1; \t/*采用动态分配的方式，获取设备编号，次设备号为0，*/ \terror alloc_chrdev_region(&button_devno, 0, DEV_CNT, DEV_NAME); \tif (error < 0) \t{ \t\tprintk(\"fail to alloc button_devno\\n\"); \t\tgoto alloc_err; \t} \t/*关联字符设备结构体cdev与文件操作结构体file_operations*/ \tbutton_chr_dev.owner THIS_MODULE; \tcdev_init(&button_chr_dev, &button_chr_dev_fops); \t/*添加设备至cdev_map散列表中*/ \terror cdev_add(&button_chr_dev, button_devno, DEV_CNT); \tif (error < 0) \t{ \t\tprintk(\"fail to add cdev\\n\"); \t\tgoto add_err; \t} \tclass_button class_create(THIS_MODULE, DEV_NAME); //创建类 \tdevice_button device_create(class_button, NULL, button_devno, NULL, DEV_NAME);//创建设备 DEV_NAME 指定设备名， \treturn 0; add_err: \tunregister_chrdev_region(button_devno, DEV_CNT); // 添加设备失败时，需要注销设备号 \tprintk(\"\\n error! \\n\"); \t alloc_err: \treturn 1; } /* *驱动注销函数 */ static void __exit button_driver_exit(void) { \tpr_info(\"button_driver_exit\\n\"); \t/*删除设备*/ \tdevice_destroy(class_button, button_devno);\t\t //清除设备 \tclass_destroy(class_button);\t\t\t\t\t //清除类 \tcdev_del(&button_chr_dev);\t\t\t\t\t //清除设备号 \tunregister_chrdev_region(button_devno, DEV_CNT); //取消注册字符设备 } module_init(button_driver_init); module_exit(button_driver_exit); MODULE_LICENSE(\"GPL\"); ```"},"/note/Linux/野火Linux/2025-9-30-45-图标.html":{"title":"图标","content":"# 图标 保存为256色（即8位色）的bpm格式的图片 ## 转换为ppm格式的图片 `sudo apt install netpbm` 在Linux下使用以下脚本将其转换为ppm格式的文件，为什么是ppm格式呢？因为这是编译 Linux内核必要的文件格式，想要修改logo，就要这种格式的文件，它必须是256色（即8位色） 的bpm格式的图片转换而成的 ```bash #!/bin/bash if [ \" $1\" \"\" ]; then echo \"usage:$0 bmp_file\" exit 0 fi if [ f \"$1\" ] then \techo $1 else \techo \"nofind file[$1]\" \texit 0 fi name ${1%%.*} bmptopnm $1 > $name.pnm pnmquant 224 $name.pnm > $name.clut224.pnm pnmtoplainpnm $name.clut224.pnm > $name.ppm rm $name.pnm $name.clut224.pnm ``` ` bmp2ppm.sh ubuntu.bmp ubuntu.ppm`\t 将其拷贝到 linux 内核源码的 ebf_linux_kernel/drivers/video/logo 目录下，因为我们的 logo 是存放在此处的，默 认使用的logo为logo_linux_clut224.ppm ## 开机背景图 启动开发板，内核启动后会执行文件系统的启动脚本，而此时文件系统的启动脚本中/opt/ scripts/boot/psplash.sh 会去执行相应的应用程序 /usr/bin/psplash ，显示开机时 的背景 `/usr/bin/psplash \"/lib/firmware/logo.bmp\"` 若只想显示开机logo可以将这行注释掉，或者将/lib/fireware/logo.bmp修改为其他的图 片路径(可以将自己的图片用windows系统自带画图软件另存为24位bmp放/lib/firmware里面)"},"/note/Linux/野火Linux/2025-9-29-43-Linux.html":{"title":"Linux","content":"# Linux ![image 20250930100823295](C:\\Users\\14586\\AppData\\Roaming\\Typora\\typora user images\\image 20250930100823295.png) NXP官方镜像(后简称官方镜像)与鲁班猫镜像(后简称lubancat)，我们将kernel，dtb,dtbo打包进 了rootfs 内，这样更为通用且更换其中如何一部分只需将文件替换即可。官方镜像则得烧写指定 地址需要更新其中一部分则较为困难 ![image 20250930101051141](C:\\Users\\14586\\AppData\\Roaming\\Typora\\typora user images\\image 20250930101051141.png) ```bash git clone https://github.com/Embedfire/ebf_linux_kernel.git ``` ## 目录 + **arch** ：主要包含和硬件体系结构相关的代码，如arm、x86、MIPS，PPC，每种CPU平台占一个 相应的目录，例如我们使用的imx系列CPU就在arch/arm/mach imx目录下，Linux内核目 前已经支持30种左右的CPU体系结构。arch中的目录下存放的是各个平台以及各个平台的芯片 对Linux 内核进程调度、内存管理、中断等的支持，以及每个具体的SoC和电路板的板级支持代 码 + **block** ：在Linux 中block 表示块设备（以块（多个字节组成的整体，类似于扇区）为单位来整体 访问），譬如说SD卡、Nand、硬盘等都是块设备，block目录下放的是一些Linux存储体系中关 于块设备管理的代码。 + **crypto** ：这个目录下存放的是常用加密和散列算法（如md5、AES、SHA等），还有一些压缩和 CRC校验算法 + **Documentation**：内核各部分的文档描述。 + **drivers** ：设备驱动程序，里面列出了linux内核支持的所有硬件设备的驱动源代码，每个不同的 驱动占用一个子目录，如char、block、net、mtd、i2c等。 + **fs** ：fs 就是filesystem，里面包含Linux所支持的各种文件系统，如EXT、FAT、NTFS、JFFS2等。 + **include** ：目录包括编译核心所需要的大部分头文件，例如与平台无关的头文件在include/ linux 子目录下，与cpu架构相关的头文件在include目录下对应的子目录中。 + **init** ：内核初始化代码，这个目录下的代码就是linux内核启动时初始化内核的代码。 + **ipc** ：ipc 就是 inter process commuication ，进程间通信，该目录下都是linux进程间通 信的代码。 + **kernel** ：kernel 就是 Linux 内核，是Linux中最核心的部分，包括进程调度、定时器等，而和平台 相关的一部分代码放在arch/*/kernel目录下。 + **lib** ：lib 是库的意思，lib目录下存放的都是一些公用的有用的库函数，注意这里的库函数和C语 言的库函数不一样的，因为在内核编程中是不能用C语言标准库函数的，所以需要使用lib中的 库函数，除此之外与处理器结构相关的库函数代码被放在arch/*/lib/目录下。 + **mm**：目录包含了所有独立于cpu体系结构的内存管理代码，如页式存储管理内存的分配和释放等，而与具体硬件体系结构相关的内存管理代码位于arch/*/mm目录下，例如arch/arm/mm/fault.c 。 + **net** ：网络协议栈相关代码，net目录下实现各种常见的网络协议。 + **scripts** ：这个目录下全部是脚本文件，这些脚本文件不是linux内核工作时使用的，而是用了配置编译linux内核的。 + **security** ：内核安全模型相关的代码，例如最有名的SELINUX + **sound** ：ALSA、OSS音频设备的驱动核心代码和常用设备驱动。 + **usr** ：实现用于打包和压缩的cpio等。 ## 配置 ### Makefile 分布在Linux内核源代码根目录及各层目录中，定义Linux内核的编译规则 ### 配置文件 给用户提供配置选择的功能，如Kconfig文件定义了配置项，使用make_deb.sh 脚本编译时，使用arch/arm/configs/npi_v7_defconfig文件对配置项进行赋值 ### 配置工具 包括配置命令解释器（对配置脚本中使用的配置命令进行解释）和配置用户界 面（linux 提供基于字符界面、基于Ncurses图形界面以及基于Xwindows图形界面的用户配 置界面，各自对应于makeconfig、makemenuconfig和makexconfig） ### 应用 ````bash make menuconfig KCONFIG_CONFIG arch/arm/configs/npi_v7_defconfig ARCH arm CROSS_COMPILE arm linux gnueabihf ```` 需要提前安装一下`sudo apt install libncurses dev` 可以使用/进行查找, 比如使用ds18b20温湿度传感器 ` > Device Drivers 选项下的 > Embedfire Modules下的 > Embedfire Modules (EBF_MODULE [ y])` 可使用y、n、m键更改ds18b20驱动的配置时，其中y表示编译进内核中，m表示编译成模块， n 表示不编译。 > #### 1. `y` 编译进内核 > > **工作方式**：当你选择 `y` 时，DS18B20 驱动的所有源代码都会被编译，并直接链接到最终生成的内核镜像文件里。这个驱动会成为内核不可分割的一部分。 > **加载时机**：在系统启动过程中，内核初始化时，会自动将该驱动初始化并注册到系统中。 > **使用场景**： > **基础/必需硬件**：例如，你正在为一个特定的嵌入式设备（比如一个智能温控器）构建内核，而 DS18B20 是这个设备的**核心、必需**的传感器。你必须保证它每次开机都能用。 > **根文件系统驱动**：如果该驱动是挂载根文件系统所必需的（虽然DS18B20通常不是），那么它必须编译进内核，否则内核无法启动。 > **简化部署**：你希望系统“开箱即用”，不想处理模块加载的脚本或依赖。 > > #### 2. `m` 编译成模块 > > **工作方式**：选择 `m` 时，DS18B20 驱动的源代码会被编译，但不会链接到主内核镜像中。它会生成一个或多个独立的 `.ko` 文件，这些文件通常存放在 `/lib/modules/$(uname r)/` 目录下。 > **加载时机**：内核启动时，这个驱动**不会自动加载**。你需要： > **手动加载**：在需要时，通过命令行 `sudo insmod /path/to/w1_therm.ko` 或 `sudo modprobe w1_therm`（推荐）来加载。 > **自动加载**：可以配置系统的 `modules` 文件，让系统在启动时或硬件插入时自动加载该模块。 > **使用场景**： > **非必需或可选功能**：DS18B20 在你的项目中是可选配件，或者只在特定情况下使用。不需要时可以不加载，节省内存。 > **驱动开发与调试**：在开发驱动时，编译成模块可以让你快速修改、编译、加载、测试，而无需每次都重启系统，极大提高效率。 > **通用发行版**：像 Ubuntu、Debian 这样的桌面或服务器发行版，它们的内核需要应对成千上万种不同的硬件。如果把所有驱动都编译进内核，内核会变得无比臃肿。因此，绝大多数驱动都以模块形式提供，系统会在检测到硬件时自动加载对应的模块。 > > #### 3. `n` 不编译 > > **工作方式**：选择 `n` 时，配置系统会完全跳过对 DS18B20 驱动源代码的编译。 > **加载时机**：无法加载，因为驱动根本不存在。 > **使用场景**： > **目标系统绝对不需要此功能**：你非常确定你的设备永远不会使用 DS18B20 温度传感器。 > **追求极致的精简**：你在为一个资源极其受限的嵌入式系统构建内核，需要剔除所有不必要的代码，哪怕一字节也要节省。 > **排除问题**：在排查内核冲突或问题时，可以暂时不编译某个驱动，以判断它是否是问题的根源。 ## 编译 编译Kernel有两种方法，一种是编译较为通用的zImage，常用于构建成镜像固件。另一种则是 编译成deb安装包，将其下载到板子上安装即可更新Kernel。 ### zImage ```bash # 清除之前编译环境 make mrproper # 编译内核 make ARCH arm npi_v7_defconfig make ARCH arm CROSS_COMPILE arm linux gnueabihf j8 ``` 使用的配置文件在`arch/arm/configs`文件夹下面 编译得到的zImage 内核在arch/arm/boot 目录下，设备树在 arch/arm/boot/dts 目录下设备树分为 emmc 版本imx6ull mmc npi.dtb 以及 nand 版本 imx6ull nand npi.dtb + zImage 生成简述 通过arm linux gnueabihf ld 命令将 vmlinux.lds head.o piggy.o misc.o decompress.o string.o hyp stub.o lib1funcs.o ashldi3.o bswapsdi2.o 链接成 vmlinux 再通过arm linux gnueabihf objcopy 命令将vmlinux以bin格式输出到zImage，期间删去了comment 等信息 ### deb包 想要编译内核的deb安装包，以sudo权限运行野火提供的make_deb.sh脚本即可，我们也推荐使 用这样的编译方式编译内核，构建出来的deb安装包可直接使用sudodpkg ixxx.deb命令安装在 鲁班猫系统上，然后重启使用cat/proc/version查看内核是否更新 ```c deb_distro bionic DISTRO stable build_opts \" j 16\" build_opts \"${build_opts} O build_image/build\" build_opts \"${build_opts} ARCH arm\" build_opts \"${build_opts} KBUILD_DEBARCH ${DEBARCH}\" build_opts \"${build_opts} LOCALVERSION imx6\" build_opts \"${build_opts} KDEB_CHANGELOG_DIST ${deb_distro}\" build_opts \"${build_opts} KDEB_PKGVERSION 1.$(date +%g%m)${DISTRO}\" build_opts \"${build_opts} CROSS_COMPILE arm linux gnueabihf \" build_opts \"${build_opts} KDEB_SOURCENAME linux upstream\" make ${build_opts} npi_v7_defconfig make ${build_opts} make ${build_opts} bindeb pkg ``` + `deb_distro bionic`: 设置了变量 deb_distro，用于指定生成的Debian包的目标发行版，这里设 置为bionic。 + `DISTRO stable`: 设置了变量DISTRO，用于指定Linux内核的目标发行版，这里设置为stable。标记构建的软件包为稳定版 + `build_opts ” j 16”`: 设置了编译选项， j16表示并行编译时使用16个线程。 + `build_opts ”${build_opts} O build_image/build”`: 添加了编译选项，指定编译输出目录为 build_image/build。 + `build_opts ”${build_opts} ARCH arm”`: 添加了编译选项，指定目标架构为ARM。 + `build_opts ”${build_opts} KBUILD_DEBARCH ${DEBARCH}”`: 添加了编译选项，指定deb包的架构为${DEBARCH}。 + `build_opts ”${build_opts} LOCALVERSION imx6”`: 添加了编译选项，设置了内核的本地 版本标识为 imx6。 + `build_opts ”${build_opts} KDEB_CHANGELOG_DIST ${deb_distro}”`: 添加了编译选项，指 定生成的deb包changelog的目标发行版为${deb_distro}。 + `build_opts ”${build_opts} KDEB_PKGVERSION 1.$(date +%g%m)${DISTRO}”`: 添加了编 译选项，指定生成的deb包的版本号为当前年份后两位加上当前月份，后跟${DISTRO}（在 这种情况下是stable）。 + `build_opts ”${build_opts} CROSS_COMPILE arm linux gnueabihf “`: 添加了编译选项，指定 交叉编译工具链为arm linux gnueabihf 。 + `build_opts ”${build_opts} KDEB_SOURCENAME linux upstream”`: 添加了编译选项，指定 生成的deb包的源名称为linux upstream。 + `make ${build_opts} npi_v7_defconfig`: 使用 make 命令加载了名为 npi_v7_defconfig 的预配置 文件。 + `make ${build_opts}`: 使用 make 命令编译 Linux 内核。 + `make ${build_opts} bindeb pkg`: 使用 make 命令生成内核 deb 包。 1. **交叉编译**：在x86主机上编译ARM目标平台的内核 2. **版本管理**：自动生成带时间戳的版本号 3. **包管理**：生成标准的Debian软件包，便于分发和安装 4. **定制化**：针对i.MX6平台进行专门配置 5. **高效编译**：使用多线程和独立输出目录 `build_opts ”${build_opts} KDEB_PKGVERSION 1.$(date +%g%m)${DISTRO}”`：设置了内 核deb 包的版本号，默认是数字+当前年份后两位加上当前月份后跟stable，如果是大版 本更新可修改前面的数字，如果是当月频繁更新，可以将`$(date+%g%m) 修改为 $(date +%g%m%d)`，添加具体日期，如果是测试版，可修改stable为beta等。 构成生成的deb包在内核源码/build_image目录下 > 将kernel，dtb,dtbo打包进 了rootfs内，这样更为通用且更换其中如何一部分只需将文件替换即可。官方镜像则是烧写指定 地址对于不同芯片存储的地址是不同的不利于移植于其他芯片 ## 烧录 ### USB烧录 烧写完毕后通过USBOTG连接电脑会存在一个BOOT分区 编译的zImage拷贝到BOOT\\kernel目录下，将zImage更名为vmlinuz 4.19.35 imx6 ``` ln s /lib/modules/4.19.35 imx6 /lib/modules/4.19.35+ reboot ``` ### DEB包 将编译出来的build_image/linux image 4.19.35 imx6_1.xxxstable_armhf.deb内核安装包拷贝到 开发板上面，使用dpkg命令即可替换板子上的内核 ```bash #查看当前的内核 dpkg l grep imx #卸载当前内核 sudo dpkg r linux image 4.19.35 imx6 #若使用dpkg安装内核deb包提示错误，删除/boot/kernel目录下所有文件 sudo rm /boot/kernel/* #安装新内核 sudo dpkg i linux image 4.19.35 imx6_1stable_armhf.deb ``` `cat /proc/version` 命令查看内核版本 ### 直接替换 将编译出来的ebf_linux_kernel/arch/arm/boot/zImage 的拷到板子上，重命名为 vmlinuz 4.19.35 imx6 并替换/boot/kernel/vmlinuz 4.19.35 imx6"},"/note/Linux/野火Linux/2025-9-16-21-iomux节点(中).html":{"title":"","content":"## pin function和pin group：iomuxc节点解析始末 #### imx_pinctrl_probe_dt()函数 drivers/pinctrl/freescale/pinctrl imx.c pinctrl_dev下面有三个基数树, 分别记录所有的引脚信息, function的信息以及group的信息 ![image 20250916105054851](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509161050929.png) ```c static int imx_pinctrl_probe_dt(struct platform_device *pdev, \t\t\t\tstruct imx_pinctrl *ipctl) { \t//iomux节点 \tstruct device_node *np pdev >dev.of_node; // 使用platform结构体进行获取实际的设备树描述 \tstruct device_node *child; \tstruct pinctrl_dev *pctl ipctl >pctl; \t// 遍历两层, 检查一下是不是有fsl,pins属性, 直接的下一层True, 下下层False \tflat_funcs imx_pinctrl_dt_is_flat_functions(np); \tif (flat_funcs) { \t\tnfuncs 1; // 没有function层, 但是设置这个变量为1, 至少使用一个function来进行管理所有的节点 \t} else { \t\tnfuncs of_get_child_count(np); \t\tif (nfuncs 0) { \t\t\tdev_err(&pdev >dev, \"no functions defined\\n\"); \t\t\treturn EINVAL; \t\t} \t} \t \tfor (i 0; i < nfuncs; i++) { \t\tstruct function_desc *function; \t\t// 申请一个function_desc \t\tfunction devm_kzalloc(&pdev >dev, sizeof(*function), \t\t\t\t\tGFP_KERNEL); \t\tif (!function) \t\t\treturn ENOMEM; \t\tmutex_lock(&ipctl >mutex); // 加入基数树里面 \t\tradix_tree_insert(&pctl >pin_function_tree, i, function); \t\tmutex_unlock(&ipctl >mutex); \t} \t \tpctl >num_functions nfuncs; // 1 \tipctl >group_index 0; // 初始化一下上一个节点里面的这个变量 \t \tif (flat_funcs) { // 记录一下所有的group的数量 \t\tpctl >num_groups of_get_child_count(np); \t} else { \t\tpctl >num_groups 0; \t\tfor_each_child_of_node(np, child) \t\t\tpctl >num_groups + of_get_child_count(child); \t} \t \tif (flat_funcs) { \t\timx_pinctrl_parse_functions(np, ipctl, 0); \t} else { \t\ti 0; \t\tfor_each_child_of_node(np, child) \t\t\timx_pinctrl_parse_functions(child, ipctl, i++); \t} ``` #### imx_pinctrl_dt_is_flat_functions()函数 drivers/pinctrl/freescale/pinctrl imx.c 遍历两层, 检查一下是不是有fsl,pins属性, 判断是在哪一层 ```c static bool imx_pinctrl_dt_is_flat_functions(struct device_node *np) { \tstruct device_node *function_np; \tstruct device_node *pinctrl_np; \t// 遍历所有的子节点 \tfor_each_child_of_node(np, function_np) { \t\t// 查看一下是不是有这个属性 \t\tif (of_property_read_bool(function_np, \"fsl,pins\")) \t\t\treturn true; \t\t\t \t\tfor_each_child_of_node(function_np, pinctrl_np) { \t\t\tif (of_property_read_bool(pinctrl_np, \"fsl,pins\")) \t\t\t\treturn false; \t\t} \t} \treturn true; } ``` #### imx_pinctrl_parse_functions()函数 drivers/pinctrl/freescale/pinctrl imx.c iomuxc节点的device_node结构体指针, ipctl, 0 初始化一下func的基数树, 之后创建一下group_desc这个基数树 ![image 20250916110157447](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509161101566.png) ```c static int imx_pinctrl_parse_functions(struct device_node *np, \t\t\t\t struct imx_pinctrl *ipctl, \t\t\t\t u32 index) { \tstruct pinctrl_dev *pctl ipctl >pctl; \tstruct device_node *child; \tstruct function_desc *func; \tstruct group_desc *grp; \tu32 i 0; \t// 获取之前挂载在基数树的func结构体 \tfunc pinmux_generic_get_function(pctl, index); \t... \tfunc >name np >name; // 设置为设备树节点的名字 \tfunc >num_group_names of_get_child_count(np); // 记录一下子节点(group)的数量 \t... // 根据group的数量分配名字指针 \tfunc >group_names devm_kcalloc(ipctl >dev, func >num_group_names, \t\t\t\t\t sizeof(char *), GFP_KERNEL); \tif (!func >group_names) \t\treturn ENOMEM; \t// 遍历节点 \tfor_each_child_of_node(np, child) { \t\tfunc >group_names[i] child >name; \t\t// 请求一个group_desc结构体, 用于记录每一个group里面的信息 \t\tgrp devm_kzalloc(ipctl >dev, sizeof(struct group_desc), \t\t\t\t GFP_KERNEL); \t\tif (!grp) \t\t\treturn ENOMEM; \t\tmutex_lock(&ipctl >mutex); // 会在这里imx_pinctrl++这个数据, 记录所有的group数量 \t\tradix_tree_insert(&pctl >pin_group_tree, \t\t\t\t ipctl >group_index++, grp); \t\tmutex_unlock(&ipctl >mutex); \t\timx_pinctrl_parse_groups(child, grp, ipctl, i++); \t} \treturn 0; } ``` #### pinmux_generic_get_function()函数 drivers/pinctrl/pinmux.c ```c struct function_desc *pinmux_generic_get_function(struct pinctrl_dev *pctldev, \t\t\t\t\t\t unsigned int selector) { \tstruct function_desc *function; \tfunction radix_tree_lookup(&pctldev >pin_function_tree, \t\t\t\t selector); \tif (!function) \t\treturn NULL; \treturn function; } ``` #### imx_pinctrl_parse_groups()函数 ```c static int imx_pinctrl_parse_groups(struct device_node *np, \t\t\t\t struct group_desc *grp, \t\t\t\t struct imx_pinctrl *ipctl, \t\t\t\t u32 index) { \tconst struct imx_pinctrl_soc_info *info ipctl >info; \tint size, pin_size; \tconst __be32 *list, **list_p; \tu32 config; \tint i; \t// flags未初始化, 所有是0 \tif (info >flags & IMX8_USE_SCU) \t\tpin_size FSL_IMX8_PIN_SIZE; \telse if (info >flags & SHARE_MUX_CONF_REG) \t\tpin_size FSL_PIN_SHARE_SIZE; \telse \t\tpin_size FSL_PIN_SIZE;//24一个引脚配置的长度 \t \tgrp >name np >name; // 记录group的名字 \t// 获取配置属性 \tlist of_get_property(np, \"fsl,pins\", &size); \t... // 记录设备树里面的所有节点的信息 \tlist_p &list; \t... \t/*该组引脚的配置个数*/ \tgrp >num_pins size / pin_size; \t// 为每一个引脚分配一个结构体 \tgrp >data devm_kcalloc(ipctl >dev, \t\t\t\t grp >num_pins, sizeof(struct imx_pin), \t\t\t\t GFP_KERNEL); \t \tgrp >pins devm_kcalloc(ipctl >dev, \t\t\t\t grp >num_pins, sizeof(unsigned int), \t\t\t\t GFP_KERNEL); \t... \tfor (i 0; i < grp >num_pins; i++) { \t\tstruct imx_pin *pin &((struct imx_pin *)(grp >data))[i]; \t\tif (info >flags & IMX8_USE_SCU) \t\t\timx_pinctrl_parse_pin_scu(ipctl, &grp >pins[i], \t\t\t\tpin, list_p, config); \t\telse // 实际的调用位置, 传入刚才申请的两个数组的对应位置 \t\t\timx_pinctrl_parse_pin_mem(ipctl, &grp >pins[i], \t\t\t\tpin, list_p, config); \t} \treturn 0; } ``` #### imx_pinctrl_parse_pin_mem()函数 drivers/pinctrl/freescale/pinctrl memmap.c ![image 20250916113744715](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509161137808.png) ![image 20250916113842266](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509161138411.png) ```c int imx_pinctrl_parse_pin_mem(struct imx_pinctrl *ipctl, \t\t\t unsigned int *grp_pin_id, struct imx_pin *pin, \t\t\t const __be32 **list_p, u32 generic_config) { \tstruct imx_pin_memmap *pin_memmap &pin >pin_conf.pin_memmap; \tconst struct imx_pinctrl_soc_info *info ipctl >info; // 解析一条数据 \tu32 mux_reg be32_to_cpu(*((*list_p)++)); \tu32 conf_reg; \tu32 config; \tunsigned int pin_id; \tstruct imx_pin_reg *pin_reg; \t \tif (info >flags & SHARE_MUX_CONF_REG) { \t\tconf_reg mux_reg; \t} else { \t\tconf_reg be32_to_cpu(*((*list_p)++)); \t\tif (!conf_reg) \t\t\tconf_reg 1; \t} \t// 使用复用寄存器的偏移获取引脚的编号 \tpin_id (mux_reg ! 1) ? mux_reg / 4 : conf_reg / 4; // 获取到imx_pin_reg用于记录实际的寄存器地址 \tpin_reg &ipctl >pin_regs[pin_id]; \tpin >pin pin_id; // 记录引脚的编号 \t*grp_pin_id pin_id; \tpin_reg >mux_reg mux_reg; \tpin_reg >conf_reg conf_reg; // 解析设备树数据 \tpin_memmap >input_reg be32_to_cpu(*((*list_p)++)); \tpin_memmap >mux_mode be32_to_cpu(*((*list_p)++)); \tpin_memmap >input_val be32_to_cpu((*(*list_p)++)); \t... // 获取硬件的配置属性 \tconfig be32_to_cpu(*((*list_p)++)); \t... \tif (config & IMX_PAD_SION) \t\tpin_memmap >mux_mode IOMUXC_CONFIG_SION; \tpin_memmap >config config & ~IMX_PAD_SION; \t... \treturn 0; } ``` ## pin state：pinctrl names的真相 #### iomuxc节点 存储全部所需的引脚配置信息 \"虚拟\"外设 设置pin state数量和类型 设置状态对应的pin group pin state >pin group，一对多 pin group >pin，一对多 #### pinctl_map 存储外设所有state下pin group的配置信息 #### 函数层次分析 `pinctrl_enable() >pinctrl_claim_hogs()` `create_pinctrl` 第一部分 `pinctrl_dt_to_map()` `for (state 0; ; state++)：`查找外设所有pin group的状态 `for (config 0; config < size; config++)：`查找状态的所有引脚组 第二部分 `dt_to_map_one_config` 创建一个`pinctrl_map`，负责初始化引脚组的所有引脚复用 创建多个`pinctrl_map`，每个pinctrl_map负责配置引脚中的一个引脚属性 第三部分 `add_setting` #### pinctrl_enable()函数 drivers/pinctrl/core.c ```c int pinctrl_enable(struct pinctrl_dev *pctldev) { \tint error; \terror pinctrl_claim_hogs(pctldev); \t... \t//将pctldev加入全局链表 \tlist_add_tail(&pctldev >node, &pinctrldev_list); \t... \treturn 0; } ``` #### pinctrl_claim_hogs()函数 drivers/pinctrl/core.c ```c static int pinctrl_claim_hogs(struct pinctrl_dev *pctldev) { \t \tpctldev >p create_pinctrl(pctldev >dev, pctldev); \t \t//第四部分 \tpctldev >hog_default \t\tpinctrl_lookup_state(pctldev >p, PINCTRL_STATE_DEFAULT); \tif (IS_ERR(pctldev >hog_default)) { \t\tdev_dbg(pctldev >dev, \t\t\t\"failed to lookup the default state\\n\"); \t} else { \t\t//设置为default状态 \t\tif (pinctrl_select_state(pctldev >p, \t\t\t\t\t pctldev >hog_default)) \t\t\tdev_err(pctldev >dev, \t\t\t\t\"failed to select default state\\n\"); \t} \t... \tpctldev >hog_sleep \t\tpinctrl_lookup_state(pctldev >p, \t\t \t... } ``` #### create_pinctrl()函数 drivers/pinctrl/core.c ![image 20250916142330628](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509161423704.png) ```c static struct pinctrl *create_pinctrl(struct device *dev, \t\t\t\t struct pinctrl_dev *pctldev) { \tstruct pinctrl *p; \tconst char *devname; \tstruct pinctrl_maps *maps_node; \tint i; \tconst struct pinctrl_map *map; \tint ret; \t \tp kzalloc(sizeof(*p), GFP_KERNEL); \t... \tp >dev dev; \tINIT_LIST_HEAD(&p >states); \tINIT_LIST_HEAD(&p >dt_maps); \t//第一部分 \tret pinctrl_dt_to_map(p, pctldev); \t \tdevname dev_name(dev); \t... \tfor_each_maps(maps_node, i, map) { \t\t/* Map must be for this device */ \t\tif (strcmp(map >dev_name, devname)) \t\t\tcontinue; \t\t\t if (pctldev && strcmp(dev_name(pctldev >dev), map >ctrl_dev_name)) continue; \t\t//第三部分 \t\tret add_setting(p, pctldev, map); \t\t... \t} \t... \tlist_add_tail(&p >node, &pinctrl_list); \t... } ``` #### pinctrl_dt_to_map()函数 drivers/pinctrl/devicetree.c ```c pinctrl names \"default\"，\"init\",\"sleep\"; pinctrl 0 <&pinctrl_hog_1 &aaa &bbb>; pinctrl 1 <&xxx>; pinctrl 2 <&yyy>; ``` ```c int pinctrl_dt_to_map(struct pinctrl *p, struct pinctrl_dev *pctldev) { \t/*iomux节点*/ \tstruct device_node *np p >dev >of_node; \tint state, ret; \tchar *propname; \tstruct property *prop; \tconst char *statename; \tconst __be32 *list; \tint size, config; \tphandle phandle; \tstruct device_node *np_config; \t \t... // 所有的初始化状态 \tfor (state 0; ; state++) { // 合成初始化属性的名字 \t\tpropname kasprintf(GFP_KERNEL, \"pinctrl %d\", state); \t\t// 查找是不是有这个对应的设置, 可以获取到实际的配置引用数组 prop of_find_property(np, propname, &size); \t\tkfree(propname); \t\t \t\tif (!prop) { \t\t\tif (state 0) { \t\t\t\tof_node_put(np); \t\t\t\treturn ENODEV; \t\t\t} \t\t\tbreak; \t\t} \t\tlist prop >value; \t\t// 获取当前state中的group数量 \t\tsize / sizeof(*list); \t\t// 读取对应的名字, 之后设置在对应的引脚组配置里面 \t\tret of_property_read_string_index(np, \"pinctrl names\",state, &statename); \t\t... // 遍历所有的引脚组 \t\tfor (config 0; config < size; config++) { //句柄 phandle be32_to_cpup(list++); //根据句柄查找子节点 np_config of_find_node_by_phandle(phandle); // 处理引脚组 ret dt_to_map_one_config(p, pctldev, statename, np_config); ... \t\t} ... } ``` #### dt_to_map_one_config()函数 drivers/pinctrl/devicetree.c 为每一个引脚创建一个pinctrl_map ![image 20250916143818909](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509161438040.png) ```c static int dt_to_map_one_config(struct pinctrl *p, \t\t\t\tstruct pinctrl_dev *hog_pctldev, \t\t\t\tconst char *statename, \t\t\t\tstruct device_node *np_config) { \tstruct pinctrl_dev *pctldev NULL; \tstruct device_node *np_pctldev; \tconst struct pinctrl_ops *ops; \tint ret; \tstruct pinctrl_map *map; \tunsigned num_maps; \tbool allow_default false; \t \tnp_pctldev of_node_get(np_config); \t \tfor (;;) { \t\t/*获取到iomuxc节点*/\t np_pctldev of_get_next_parent(np_pctldev); if (hog_pctldev && (np_pctldev p >dev >of_node)) { // 成立 pctldev hog_pctldev; break; } \t\t// 遍历数组里面的 pctldev get_pinctrl_dev_from_of_node(np_pctldev); if (pctldev) break; \t} \t... \t//imx_pctrl_ops \tops pctldev >desc >pctlops; \t... \t//imx_dt_node_to_map函数, 为每一个引脚组创建一个pinctrl_map数组, 并获取到对应的配置 \tret ops >dt_node_to_map(pctldev, np_config, &map, &num_maps); \t... // 初始化pinctrl_map的dev_name以及对应的配置名字, 创建pinctrl_dt_map \treturn dt_remember_or_free_map(p, statename, pctldev, map, num_maps); } ``` #### of_node_get()函数 include/linux/of.h ```c static inline struct device_node *of_node_get(struct device_node *node) { \treturn node; } ``` ## pinctl_map：引脚三千，只取一瓢 #### pinctrl_map数组 ![image 20250916144610707](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509161446912.png) pin group配置信息 `pinctrl_map[0]`：配置pin group的所有引脚复用 `pinctrl_map[1~n]`：配置pin group的每个引脚的属性 #### 函数层次分析 pinctrl_enable() >pinctrl_claim_hogs() create_pinctrl 第一部分 pinctrl_dt_to_map() for (state 0; ; state++)：查找外设所有pin group的状态 for (config 0; config < size; config++)：查找状态的所有引脚组 第二部分 dt_to_map_one_config 创建一个pinctrl_map，负责初始化配置pin group的所有引脚复用 创建多个pinctrl_map，每个pinctrl_map负责配置引脚中的一个引脚属性 第三部分 add_setting #### imx_dt_node_to_map()函数 drivers/pinctrl/freescale/pinctrl imx.c 把引脚的数据转移到pinctrl_map里面进行保存 ```c static int imx_dt_node_to_map(struct pinctrl_dev *pctldev, \t\t\tstruct device_node *np, \t\t\tstruct pinctrl_map **map, unsigned *num_maps) { // 获取到dirver_data记录的imx_pinctrl变量 \tstruct imx_pinctrl *ipctl pinctrl_dev_get_drvdata(pctldev); // 获取一下info指向的imx_pinctrl_soc_info变量 \tconst struct imx_pinctrl_soc_info *info ipctl >info; \tconst struct group_desc *grp; \tstruct pinctrl_map *new_map; \tstruct device_node *parent; \tint map_num 1; \tint i, j; \t// 基数树里面查找一下group \tgrp imx_pinctrl_find_group_by_name(pctldev, np >name); \t \tif (info >flags & IMX8_USE_SCU) { \t\tmap_num + grp >num_pins; \t} else { // 这里 \t\tfor (i 0; i < grp >num_pins; i++) { // 遍历所有的引脚 struct imx_pin *pin &((struct imx_pin *)(grp >data))[i]; \t\t // 查看一下是不是有这个标志, 在设备数里面设置, 一般是没有的, 取反, 获取到True \t\t if (!(pin >pin_conf.pin_memmap.config & IMX_NO_PAD_CTL)) \t\t\t\tmap_num++; // 计算一下有几个引脚需要建立pinctrl_map \t\t} \t} \t \tnew_map kmalloc_array(map_num, sizeof(struct pinctrl_map), \t\t\t\tGFP_KERNEL); \t\t\t\t \t*map new_map; \t*num_maps map_num; \t \t /*iomuxc节点*/ \t parent of_get_parent(np); \t ... // 初始化第一个元素 \t new_map[0].type PIN_MAP_TYPE_MUX_GROUP; \t new_map[0].data.mux.function parent >name; \t new_map[0].data.mux.group np >name; \t .. \t new_map++; \t \t for (i j 0; i < grp >num_pins; i++) { \t\tstruct imx_pin *pin &((struct imx_pin *)(grp >data))[i]; \t\tif (info >flags & IMX8_USE_SCU) { \t\t\tnew_map[j].type PIN_MAP_TYPE_CONFIGS_PIN; \t\t\tnew_map[j].data.configs.group_or_pin \t\t\t\t\tpin_get_name(pctldev, pin >pin); \t\t\tnew_map[j].data.configs.configs \t\t\t\t\t(unsigned long *)&pin >pin_conf.pin_scu; \t\t\tnew_map[j].data.configs.num_configs 2; \t\t\tj++; \t\t} else if (!(pin >pin_conf.pin_memmap.config & IMX_NO_PAD_CTL)) { // 实际运行的部分, 从基数树里面查找数据的信息 \t\t\tnew_map[j].type PIN_MAP_TYPE_CONFIGS_PIN; \t\t\tnew_map[j].data.configs.group_or_pin \t\t\t\t\tpin_get_name(pctldev, pin >pin); // 使用引脚的编号, 查找一下引脚的名字 \t\t\tnew_map[j].data.configs.configs \t\t\t\t\t&pin >pin_conf.pin_memmap.config; // 获取属性配置 \t\t\tnew_map[j].data.configs.num_configs 1; \t\t\tj++; \t\t} \t} \t... } ``` #### imx_pinctrl_find_group_by_name()函数 从基数树里面使用名字进行查找对应的group_desc结构 ```c static inline const struct group_desc *imx_pinctrl_find_group_by_name( \t\t\t\tstruct pinctrl_dev *pctldev, \t\t\t\tconst char *name) { \tconst struct group_desc *grp NULL; \tint i; \tfor (i 0; i < pctldev >num_groups; i++) { \t\tgrp pinctrl_generic_get_group(pctldev, i); \t\tif (grp && !strcmp(grp >name, name)) \t\t\tbreak; \t} \treturn grp; } ``` #### pinctrl_generic_get_group()函数 drivers/pinctrl/core.c 查找 ```c struct group_desc *pinctrl_generic_get_group(struct pinctrl_dev *pctldev, \t\t\t\t\t unsigned int selector) { \tstruct group_desc *group; \tgroup radix_tree_lookup(&pctldev >pin_group_tree, \t\t\t\t selector); \tif (!group) \t\treturn NULL; \treturn group; } ``` #### pin_get_name()函数 drivers/pinctrl/core.c 使用引脚的编号获取引脚的名字 ![image 20250916215138560](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509162151642.png) ```c const char *pin_get_name(struct pinctrl_dev *pctldev, const unsigned pin) { \tconst struct pin_desc *desc; \t// 获取对应的基数树里面的desc \tdesc pin_desc_get(pctldev, pin); \tif (!desc) { \t\tdev_err(pctldev >dev, \"failed to get pin(%d) name\\n\", \t\t\tpin); \t\treturn NULL; \t} \treturn desc >name; } ``` #### pin_desc_get函数 drivers/pinctrl/core.h ```c static inline struct pin_desc *pin_desc_get(struct pinctrl_dev *pctldev, \t\t\t\t\t unsigned int pin) { \treturn radix_tree_lookup(&pctldev >pin_desc_tree, pin); } ``` #### dt_remember_or_free_map()函数 drivers/pinctrl/devicetree.c 设置一下pinctrl_map数组, 设置名字以及对应的状态名字 ```c static int dt_remember_or_free_map(struct pinctrl *p, const char *statename,struct pinctrl_dev *pctldev,struct pinctrl_map *map, unsigned num_maps) { \tint i; \tstruct pinctrl_dt_map *dt_map; \t/* Initialize common mapping table entry fields */ \tfor (i 0; i < num_maps; i++) { // 初始化引脚组的名字以及对应的配置名字 \t\tmap[i].dev_name dev_name(p >dev); \t\tmap[i].name statename; \t\tif (pctldev) \t\t\tmap[i].ctrl_dev_name dev_name(pctldev >dev); \t} \t/* Remember the converted mapping table entries */ // 创建pinctrl_dt_map \tdt_map kzalloc(sizeof(*dt_map), GFP_KERNEL); \tif (!dt_map) { \t\tdt_free_map(pctldev, map, num_maps); \t\treturn ENOMEM; \t} \tdt_map >pctldev pctldev; \tdt_map >map map; \tdt_map >num_maps num_maps; \tlist_add_tail(&dt_map >node, &p >dt_maps); \treturn pinctrl_register_map(map, num_maps, false); } ``` #### pinctrl_register_map()函数 drivers/pinctrl/core.c ![image 20250916222454338](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509162224417.png) ```c int pinctrl_register_map(const struct pinctrl_map *maps, unsigned num_maps, \t\t\t bool dup) { \tint i, ret; \tstruct pinctrl_maps *maps_node; \t \tfor (i 0; i < num_maps; i++) { \t// 判断一下是不是有初始化值, 这里都是成功的 \tswitch (maps[i].type) { \t\tcase PIN_MAP_TYPE_DUMMY_STATE: \t\t\tbreak; \t\tcase PIN_MAP_TYPE_MUX_GROUP: // 0位置的进入这里 \t\t\tret pinmux_validate_map(&maps[i], i); \t\t\tif (ret < 0) \t\t\t\treturn ret; \t\t\tbreak; \t\tcase PIN_MAP_TYPE_CONFIGS_PIN: \t\tcase PIN_MAP_TYPE_CONFIGS_GROUP: // 其他位置的进入这里 \t\t\tret pinconf_validate_map(&maps[i], i); \t\t\tif (ret < 0) \t\t\t\treturn ret; \t\t\tbreak; \t\tdefault: \t\t\tpr_err(\"failed to register map %s (%d): invalid type given\\n\", \t\t\t maps[i].name, i); \t\t\treturn EINVAL; \t\t} \t} \t// 创建pinctrl_maps \tmaps_node kzalloc(sizeof(*maps_node), GFP_KERNEL); \tmaps_node >num_maps num_maps; \t \tif (dup) { \t\tmaps_node >maps kmemdup(maps, sizeof(*maps) * num_maps, \t\t\t\t\t GFP_KERNEL); \t\tif (!maps_node >maps) { \t\t\tkfree(maps_node); \t\t\treturn ENOMEM; \t\t} \t} else { // 实际执行的 \t\tmaps_node >maps maps; \t} \t... \tlist_add_tail(&maps_node >node, &pinctrl_maps); \t... } ``` #### pinmux_validate_map()函数 drivers/pinctrl/pinmux.c ```c int pinmux_validate_map(const struct pinctrl_map *map, int i) { // function记录的是iomux的名字, 所以这个判断是不成立的 \tif (!map >data.mux.function) { \t\tpr_err(\"failed to register map %s (%d): no function given\\n\", \t\t map >name, i); \t\treturn EINVAL; \t} \treturn 0; } ``` #### pinconf_validate_map()函数 drivers/pinctrl/pinmux.c ```c int pinconf_validate_map(const struct pinctrl_map *map, int i) { \tif (!map >data.configs.group_or_pin) { \t\tpr_err(\"failed to register map %s (%d): no group/pin given\\n\", \t\t map >name, i); \t\treturn EINVAL; \t} \tif (!map >data.configs.num_configs \t\t\t!map >data.configs.configs) { \t\tpr_err(\"failed to register map %s (%d): no configs given\\n\", \t\t map >name, i); \t\treturn EINVAL; \t} \treturn 0; } ```"},"/note/Linux/野火Linux/2025-10-12-57-Uboot编译脚本.html":{"title":"U-boot编译","content":"# U boot编译 ## 各种文件 + `.config`: 文件配置Makefile里面的实际编译的文件 + `*.cmd`: Makefile里面使用的命令 + `Kconfig`: 配置界面的配置 + `System.map`: 内存映射表 + `u boot`: elf文件 + `u boot.bin`: 压缩以后的二进制文件 + `u boot.imx`添加头以后的文件 + `u boot.sym`: 符号文件 ## 基础知识 ### 子目录调用 make 是支持递归调用的，也就是在 Makefile 中使用“make”命令来执行其他的 Makefile 文件，一般都是子目录中的Makefile文件。假如在当前目录下存在一个“subdir”子目录，这个 子目录中又有其对应的Makefile文件，那么这个工程在编译的时候其主目录中的Makefile就可 以调用子目录中的Makefile，以此来完成所有子目录的编译 ```makefile $(MAKE) C subdir ``` 有时候我们需要向子 make 传递变量， 这个时候使用“export”来导出要传递给子make的变量即可，如果不希望哪个变量传递给子m ake 的话就使用“unexport”来声明不导出 ```makefile export VARIABLE…… //导出变量给子make 。 unexport VARIABLE…… //不导出变量给子make。 ``` 有两个特殊的变量：`SHELL`和`MAKEFLAGS`，这两个变量除非使用“unexport”声 明，否则的话在整个make的执行过程中，它们的值始终自动的传递给子make ## 顶层Makefile ### 版本号 ```bash VERSION 2016 PATCHLEVEL 03 SUBLEVEL EXTRAVERSION NAME ``` VERSION 是主版本号，PATCHLEVEL是补丁版本号，SUBLEVEL是次版本号，这三个一 起构成了uboot的版本号 EXTRAVERSION附加信息, NAME名字一般不使用 ### 各种配置参数 #### 输出命令 uboot 默认编译是不会在终端中显示完整的命令，都是短命令 可以使用参数`V 1`输出完整的命令 ```makefile ifeq (\"$(origin V)\", \"command line\") KBUILD_VERBOSE $(V) endif ifndef KBUILD_VERBOSE KBUILD_VERBOSE 0 endif ifeq ($(KBUILD_VERBOSE),1) quiet Q else quiet quiet_ Q @ endif ``` > origin函数可以判断参数的来源, 使用这一句可以使得判断出来输入是在命令行里面, 之后就是两个判断赋值 之后在使用的时候会有如下的语句 ```bash $(Q)$(MAKE) $(build) tools ``` 如果V 0的话上述命令展开就是`@ make $(build) tools`， make在执行的时候默认会在 终端输出命令，但是在命令前面加上“@”就不会在终端输出命令了。当V 1 的时候 Q就为 空，上述命令就是`make $(build) tools`，因此在make执行的过程，命令会被完整的输出在终 端上。 ```bash quiet_cmd_sym ? SYM $@ cmd_sym ? $(OBJDUMP) t $< > $@ ``` 有些命令会有两个版本 `quiet_cmd_xxx` 命令输出信息少，也就是短命令， 而`cmd_xxx`命令输出信息多，也就是完整的命令。 如果变量quiet为空的话，整个命令都会输出。 如果变量quiet为`quiet_`的话，仅输出短版本。 如果变量quiet为`silent_`的话，整个命令都不会输出。 > 可以使用`make s`完全不输出` 这部分的参数最后会被export, 被子项目调用 #### 输出目录 可以使用`O 目录`的形式把输出放在这个文件, 变量KBUILD_OUTPUT就是输出目录 #### 代码检查 `C 1`使能代码检查，检查那些需要重新编译的文件, `C 2`检查所有的源码文件 #### 模块编译 使用`M dir`单独编译一个模块 #### 获取架构 变量`HOSTARCH`，用于保存主机架构,变量`HOSTOS`，此变量用于保存主机OS的值, 这里是Linux, 使用uname命令进行获取 #### 架构以及交叉编译器 设置 `ARCH` 和 `CROSS_COMPILE` 两个参数, 记录ARM以及使用的交叉编译器前缀 #### 添加参数文件 文件`scripts/Kbuild.include`，此文件里面定义了 很多变量 #### 配置文件加载 在文件config.mk文件里面进行各种`CONFIG_`开头的参数的配置 ` ARCH : $(CONFIG_SYS_ARCH:\"%\" %) `这里是从`CONFIG_SYS_ARCH \"arm\"`这个宏里面匹配`arm` ```makefile # If .config is newer than include/config/auto.conf, someone tinkered # with it and forgot to run make oldconfig. # if auto.conf.cmd is missing then we are probably in a cleaned tree so # we execute the config step to be sure to catch updated Kconfig files include/config/%.conf: $(KCONFIG_CONFIG) include/config/auto.conf.cmd \t$(Q)$(MAKE) f $(srctree)/Makefile silentoldconfig \t@# If the following part fails, include/config/auto.conf should be \t@# deleted so \"make silentoldconfig\" will be re run on the next build. \t$(Q)$(MAKE) f $(srctree)/scripts/Makefile.autoconf \\ \t\t{ rm f include/config/auto.conf; false; } \t@# include/config.h has been updated after \"make silentoldconfig\". \t@# We need to touch include/config/auto.conf so it gets newer \t@# than include/config.h. \t@# Otherwise, 'make silentoldconfig' would be invoked twice. \t$(Q)touch include/config/auto.conf ``` 这一段会自动判`KCONFIG_CONFIG(.config)`文件是不是比include/config/%.conf所有这些文件更新, 如果是的话, 更新一下这部分文件, 使用`scripts/Makefile.autoconf`, 这个文件里面会引用`.config`文件, 更新失败的话删除auto.conf文件, 保证下一次一定执行, 最后使用`touch include/config/auto.conf`更新时间戳 所以 `auto.conf` 本质上是一个**配置转换器**，让内核的配置系统能够驱动构建系统，是连接 Kconfig 和 Makefile 的关键桥梁, 里面的是Makefile文件可以直接读取的参数 ## 处理`make xxx_config` 实际是把这个配置文件里面的信息输入到.config文件里面 ![image 20251023223556587](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510232235660.png) ```makefile %config: scripts_basic outputmakefile FORCE \t$(Q)$(MAKE) $(build) scripts/kconfig $@ ``` 进行配置文件的时候会匹配这个 ### 依赖文件 #### scripts_basic ```makefile scripts_basic: \t$(Q)$(MAKE) $(build) scripts/basic \t$(Q)rm f .tmp_quiet_recordmcount ``` 第一个命令展开以后是`@make f ./scripts/Makefile.build obj scripts/basic` `build`是在`scripts/Kbuild.include`中定义为`build : f $(srctree)/scripts/Makefile.build obj` `build : f ./scripts/Makefile.build obj` #### outputmakefile ```makefile ifneq ($(KBUILD_SRC),) \t$(Q)ln fsn $(srctree) source \t$(Q)$(CONFIG_SHELL) $(srctree)/scripts/mkmakefile \\ \t $(srctree) $(objtree) $(VERSION) $(PATCHLEVEL) endif ``` `KBUILD_SRC`是一个make输入的变量, 但是不是用户使用的, 为空, 这部分不执行, 所以这个依赖是空的 #### FORCE FORCE是没有规则和依赖的，所以每次都会重新生成FORCE。当FORCE作为 其他目标的依赖时，由于FORCE总是被更新过的，因此依赖所在的规则总是会执行的 ### 实际执行命令 + 依赖里面的`@make f ./scripts/Makefile.build obj scripts/basic` + 以及`make xxxconfig`对应的`@make f ./scripts/Makefile.build obj scripts/kconfig xxx_defconfig` #### ./scripts/Makefile.build 这个文件负责根据不同的obj加载对应文件夹下面的Makefile之后编译对应的目标 ```makefile # Modified for U Boot prefix : tpl src : $(patsubst $(prefix)/%,%,$(obj)) ifeq ($(obj),$(src)) prefix : spl src : $(patsubst $(prefix)/%,%,$(obj)) ifeq ($(obj),$(src)) prefix : . endif endif ``` 开始的时候定义变量`src scripts/basic`和传入的obj进行比较获取到`prefix .` ```makefile kbuild dir : $(if $(filter /%,$(src)),$(src),$(srctree)/$(src)) kbuild file : $(if $(wildcard $(kbuild dir)/Kbuild),$(kbuild dir)/Kbuild,$(kbuild dir)/Makefile) ``` 定义`kbuild dir`为`kbuild dir ./scripts/basic`以及`kbuild file`为`./scripts/basic/Makefile`这个文件会被include进来 ```make __build: $(if $(KBUILD_BUILTIN),$(builtin target) $(lib target) $(extra y)) \\ \t $(if $(KBUILD_MODULES),$(obj m) $(modorder target)) \\ \t $(subdir ym) $(always) \t@: ``` 这个命令是默认的命令, 所以会执行, KBUILD_BUILTIN为1，KBUILD_MODULES为0, 所以实际执行的是 ```makefile __build:$(builtin target) $(lib target) $(extra y)) $(subdir ym) $(always) \t@: ``` 这里面的参数只有always有效为`scripts/basic/fixdep`这个依赖的是一个软件 #### xxx_defconfig obj变了, 所以`src scripts/kconfig`,`kbuild dir ./scripts/kconfig `, `kbuild file ./scripts/kconfig/Makefile `, 引用后面的文件 在这个文件里面, 有一个命令可以进行匹配 ```makefile %_defconfig: $(obj)/conf \t$(Q)$< $(silent) defconfig arch/$(SRCARCH)/configs/$@ $(Kconfig) ``` 依赖的文件是`scripts/kconfig/conf`这也是一个软件 下面的命令`@ scripts/kconfig/conf defconfig arch/../configs/xxx_defconfig Kconfig ` 这里会将 mx6ull_alientek_emmc_defconfig 中的配置输出到.config 文件中，最终生成 uboot 根目录下的.confi g 文件 ## 编译命令 ![image 20251025160820220](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510251608274.png) 在输入`make`没有参数的时候执行的是默认的目标 ```make # That's our default target when none is given on the command line PHONY : _all _all: ``` 默认的`all_`是依赖于`all`的, `all`依赖于`$(ALL y)` ```makefile # Always append ALL so that arch config.mk's can add custom ones ALL y + u boot.srec u boot.bin u boot.sym System.map u boot.cfg binary_size_check ``` 之后就是根据各种的配置选项进行文件的添加 ![image 20251025155013492](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510251550053.png) 我们主要需要关注的是u boot.bin文件 ```bash ifeq ($(CONFIG_OF_SEPARATE),y) u boot dtb.bin: u boot nodtb.bin dts/dt.dtb FORCE \t$(call if_changed,cat) u boot.bin: u boot dtb.bin FORCE \t$(call if_changed,copy) else u boot.bin: u boot nodtb.bin FORCE \t$(call if_changed,copy) endif ``` 实际是下面的那一个分支 ```bash u boot nodtb.bin: u boot FORCE \t$(call if_changed,objcopy) \t$(call DO_STATIC_RELA,$<,$@,$(CONFIG_SYS_TEXT_BASE)) \t$(BOARD_SIZE_CHECK) ``` ```bash u boot:\t$(u boot init) $(u boot main) u boot.lds FORCE \t$(call if_changed,u boot__) ifeq ($(CONFIG_KALLSYMS),y) \t$(call cmd,smap) \t$(call cmd,u boot__) common/system_map.o endif ``` 这两个依赖的变量是 ```bash u boot init : $(head y) u boot main : $(libs y) ``` `$(head y)`跟CPU架构有关，我们使用的是ARM芯片，所以`head y`在arch/arm/Makefile中 被指定`head y : arch/arm/cpu/$(CPU)/start.o`实际是`arch/arm/cpu/armv7/start.o` `$(libs y)`在顶层Makefile中被定义为uboot所有子目录下build in.o的集合, 记录所有的子目录, 最后面添加上`build in.o`文件 > 实际处理的工作就是把start.o以及所有的build in.o柑橘u boot.lds文件链接在一起, 所有的build in.o在进行链接的时候, 使用参数 r, 产生可重定向的输出, 所以实际的链接文件可以再一次被链接 u boot的链接首地址是0x87800000位置"},"/note/Linux/野火Linux/2025-11-1-63-Busybox.html":{"title":"BusyBox","content":"# BusyBox BusyBox 就是一个大的工具箱，这个工具箱里面集成了Linux的许多工具和命令, 是一个比较基础的构建根文件系统的工具 https://busybox.net/ ## Makefile 在Makefile文件里面加入`CROSS_COMPILE ? /usr/bin/arm linux/gnueabihf `以及`ARCH ? arm`这两个选项 ## 中文支持 打开文件`busybox 1.2 9.0/libbb/printable_string.c`，找到函数`printable_string` 把这个函数里面的对于大于0x7f跳出的判断注释掉 之后是文件busybox 1.29.0/libbb/unicode.c里面unicode_conv_to_printable2函数, 这个函数也是把关于0x7f的判断去除 后面的使能unicode编码在配置的时候进行 ## 配置 在配置busy的时候有三个可以使用的默认配置 + defconfig: 缺省的配置, 默认的配置 + allyesconfig: 使能所有的功能 + allnoconfig: 最小的配置 一般使用`make defconfig`加载默认的配置 之后可以使用`make menuconfig`进行配置的进一步控制 1. 使用动态编译, 文件系统里面有库的形式, 这个不要选择 `Settings > Build static binary no shared libs` 2. 使用vi style的命令行, 选中 `Settings > vi style line editing commands` 3. 不使用精简的命令集合, 这个不选择, 使用完整的命令 `Linux Module Utilities > Simplified modutils` 4. 使能mdev, 这个是用于动态的生成/dev文件夹下面的节点文件的, 全部选择 `Linux System Utilities > mdev (16kb)` 5. 使能Unicode, 选中下面的两个选项 `Settings > Support Unicode //选中 > Check $LC_ALL, $LC_CTYPE and $LANG environment variables` ## 编译 ```bash make make install CONFIG_PREFIX 实际生成的路径位置 ``` rootfs 目录下有bin、sbin 和usr 这三个目录，以及linuxrc这个文件, Linux 内核init 进程最后会查找用户空间的init 程序，找到以后就会运行这个用户空间的init程序，从而切换到用户态。如果bootargs设置init /linuxrc，那么linuxrc就是可以作为用户空间的init程序，所以用户态空间的init程序是busybox来生成的 ## 添加库文件 之前指定的交叉编译器使用了库文件, 所以需要把库文件加过来, 在生成的根目录下面创建一个lib目录, 交叉编译器的库目录在 `/usr/local/arm/gcc linaro 4.9.4 2017.01 x86_64_arm linux gnueabihf/arm linux gnueabihf/libc/lib`里面 `cp *so* *.a ./lib/ d `主要作用是“保持符号链接本身不跟随（不解引用）”，把链接文件本身复制，而不是复制链接指向的目标文件 > 有个比较特殊的库文件：ld linux armhf.so.3，此库文件也是个符号链接。会链接到库ld 2.19 2014.08 1 git.so 上 > > ld linu x armhf.so.3 不能作为符号链接，否则的话在根文件系统中执行程序无法执行, 使用`cp ld linux armhf.so.3 ./lib` `/usr/local/arm/gcc linaro 4.9.4 2017.01 x86_64_arm linux gnueabihf/arm linux gnueabihf/lib`这个目录里面的也需要复制 之后创建`/usr/lib`, 复制`/usr/local/arm/gcc linaro 4.9.4 2017.01 x86_64_arm linux gnueabihf/arm linux gnueabihf/libc/ usr/lib`目录里面的文件 之后在根文件系统中创建其他文件夹，如dev、proc、mnt、sys、tmp和root等 ## 添加初始化文件 ### /etc/fstab 这个文件用于配置fstab在Linux启动以后需要自动挂载的分区 ```bash <file system> <mount point> <type> <options> <dump> <pass> ``` + `<file system>`：要挂载的特殊的设备，也可以是块设备，比如/dev/sda等等。 + ` <mount point>`：挂载点。 + `<type>`：文件系统类型，比如ext2、ext3、proc、romfs、tmpfs等等。 + `<options>`：挂载选项，在Ubuntu中输入“man mount”命令可以查看具体的选项。一般使用defaults，也就是默认选项，defaults包含了rw、suid、 dev、 exec、 auto、 nouser和 asyn c。 + `<dump>`：为1的话表示允许备份，为0不备份，一般不备份，因此设置为0。 + `<pass>`：磁盘检查设置，为0表示不检查。根目录‘/’设置为1，其他的都不能设置为1，其他的分区从2开始。一般不在fstab中挂载根目录，因此这里一般设置为0。 实际的文件示例如下 ``` #<file system> <mount point> <type> <options> <dump> <pass> proc /proc proc defaults 0 0 tmpfs /tmp tmpfs defaults 0 0 sysfs /sys sysfs defaults 0 0 ``` > proc 是进程管理的文件系统 > > tmpfs 可以使用您的内存或 swap 分区来存储文件。tmpfs 既可以使用物理内存，也可以使用交换分区，因为 tmpfs 使用的是 “ 虚拟内存 ” 。 Linux 内核的虚拟内存同时来源于物理内存和交换分区，主要由内核中的 VM 子系统进行调度，进行内存页和 SWAP 的换入和换出操作， tmpfs 自己并不知道这些页面是在交换分区还是在物理内存中 > > Sysfs 连接在系统上的设备和总线组织成为一个分级的文件，它们可以被从用户的空间存取到 ### /etc/init.d/rcS Linux内核启动以后需要启动一些服务，而rcS就是规定启动哪些文件的脚本文件 ```bash #!/bin/sh PATH /sbin:/bin:/usr/sbin:/usr/bin:$PATH # 设置环境变量 D_LIBRARY_PATH $LD_LIBRARY_PATH:/lib:/usr/lib # 设置库文件的位置 export PATH LD_LIBRARY_PATH mount a # 使用/etc/fstab 挂载所有的文件系统 mkdir /dev/pts mount t devpts devpts /dev/pts echo /sbin/mdev > /proc/sys/kernel/hotplug # 使用mdev管理热插拔设备 mdev s ``` > 这个文件需要可执行权限 ### /etc/inittab 可以参考 busybox 下的文件 examples/inittab。init 程序会读取/etc/inittab这个文件，inittab由若干条指令组成。每条指令的结构都是一样的，由以“:”分隔的4个段组成 `<id>:<runlevels>:<action>:<process> ` + `<id>`：每个指令的标识符，不能重复。但是对于busybox的init来说，`<id>`有着特殊意义。对于busybox 而言`<id>`用来指定启动进程的控制 tty，一般我们将串口或者LCD 屏幕设置为控制tty。 + ` <runlevels>`：对 busybox 来说此项完全没用，所以空着。 + ` <action>`：动作，用于指定`<process>`可能用到的动作。 ![image 20251102110959211](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251102110959211.png) ![image 20251102111023394](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251102111023394.png) + `<process>`：具体的动作，比如程序、脚本或命令等 ``` #etc/inittab ::sysinit:/etc/init.d/rcS console::askfirst: /bin/sh ::restart:/sbin/init ::ctrlaltdel:/sbin/reboot ::shutdown:/bin/umount a r ::shutdown:/sbin/swapoff a ``` ## 测试 使用的是nfs的测试方式 把bootargs里面的root改为下面的形式即可从nfs启动 ```bash root /dev/nfs nfsroot [<server ip>:]<root dir>[,<nfs options>] ip <client ip>:<server ip>:<gw ip>:<netmask>:<hostname>:<device>:<autoconf>:<dns0 ip>:<dns1 ip> ``` > <server ip>：服务器 IP 地址，也就是存放根文件系统主机的IP地址，那就是Ubuntu的I P 地址，比如我的Ubuntu主机IP地址为192.168.1.250。 > > <root dir>：根文件系统的存放路径，比如我的就是/home/zuozhongkai/linux/nfs/rootfs。 > > <nfs options>：NFS 的其他可选选项，一般不设置。 > > <client ip>：客户端 IP 地址，也就是我们开发板的IP地址，Linux内核启动以后就会使用此IP地址来配置开发板。此地址一定要和Ubuntu主机在同一个网段内，并且没有被其他的设备使用，在Ubuntu中使用ping命令ping一下就知道要设置的IP地址有没有被使用，如果不能ping 通就说明没有被使用，那么就可以设置为开发板的IP地址，比如我就可以设置为192.168. 1.251。 > > <server ip>：服务器 IP 地址，前面已经说了。 > > <gw ip>：网关地址，我的就是192.168.1.1。 > > <netmask>：子网掩码，我的就是255.255.255.0。 > > <hostname>：客户机的名字，一般不设置，此值可以空着。 > > <device>：设备名，也就是网卡名，一般是eth0，eth1….，正点原子的I.MX6U ALPHA开发板的ENET2为eth0，ENET1 为eth1。如果你的电脑只有一个网卡，那么基本只能是eth0。这里我们使用ENET2，所以网卡名就是eth0。 > > <autoconf>：自动配置，一般不使用，所以设置为off。 > > <dns0 ip>：DNS0 服务器IP地址，不使用。 > > <dns1 ip>：DNS1 服务器IP地址，不使用。 测试的示例是 ```bash root /dev/nfs nfsroot 192.168.1.250:/home/zuozhongkai/linux/nfs/rootfs,proto tcp rw ip 192.168.1.251:192.168.1.250:192.168.1.1:255.255.255.0::eth0:off ``` ## 网络获取 在使用这个根文件系统连接网络的时候, 首先使用`ifconfig eth0 up`开启网卡 之后使用`udhcp i eth0`动态获取ip(需要尾灯的配置) 连接电脑的时候可以使用`ifconfig eth0 ip地址 netmask 子网掩码`的方式进行设置, 可以使用`route add default gw ip地址`的方式添加默认的网关"},"/note/Linux/野火Linux/2025-7-20-19-DeviceTreeOverlay.html":{"title":"","content":"## Device Tree Overlays：”插件“设备树 #### 传统设备树 批量管理硬件资源，机制僵化, 新的设备添加的时候需要重启, 使用二进制文件, 修改复杂 #### ”插件“设备树 模块化管理硬件资源，灵活定制, 之前的设备树只需要描述关键的信息, 其他的可以使用插件的形式描述 #### 使用前提 内核配置 CONFIG_OF_OVERLAY y CONFIG_OF_CONFIGFS y 挂载ConfigFS ``` mount x /sys/kernel/config t configfs ``` #### 案例说明 ##### 设备树：foo.dts ```c \t/ { \t\tcompatible \"corp,foo\"; \t\t \t\t/* On chip peripherals */ \t\tocp: ocp { \t\t\t/* peripherals that are always instantiated */ \t\t\tperipheral1 { ... }; \t\t} \t}; ``` ##### “插件”设备树：bar.dts ```c /dts v1/; // 使用的版本 /plugin/; // 允许使用未定义的节点 / { \t....\t \tfragment@0 { \t\ttarget <&ocp>; \t\t__overlay__ { // 新插入的节点 \t\t\t/* bar peripheral */ \t\t\tbar { \t\t\t\tcompatible \"corp,bar\"; \t\t\t\t... /* various properties and child nodes */ \t\t\t} \t\t}; \t}; }; ``` /dts v1/ ：指定dts版本号 /plugin/：允许设备树中引用未定义的节点 **`fragment@0`**: 这是一个“片段”的标准命名方式。数字 `0` 是一个序列号，如果有多个修改片段，可以依次命名为 `fragment@1`, `fragment@2` 等等。这个数字本身没有特殊含义，只是用于区分。 它的唯一目的是包裹住两个非常重要的子部分：`target` 和 `__overlay__`。 **指定节点的插入位置** target <&xxx>：指定\"插件\"设备树的父节点 target path “xxx”：指定\"插件\"设备树的父节点路径 ##### 设备树+\"插件设备树\"：foo.dts + bar.dts ```c / { \t\tcompatible \"corp,foo\"; \t\t/* shared resources */ \t\tres: res { \t\t}; \t\t/* On chip peripherals */ \t\tocp: ocp { \t\t\t/* peripherals that are always instantiated */ \t\t\tperipheral1 { ... }; \t\t\t/* bar peripheral */ \t\t\tbar { \t\t\t\tcompatible \"corp,bar\"; \t\t\t\t... /* various properties and child nodes */ \t\t\t} \t\t} \t}; ``` #### 编译方式 ````bash ./scripts/dtc/dtc I dts O dtb o xxx.dtbo arch/arm/boot/dts/xxx.dts # 编译 dts 为 dtbo ./scripts/dtc/dtc I dtb O dts o xxx.dts arch/arm/boot/dts/xxx.dtbo # 反编译 dtbo 为 dts ```` #### APT下载dtc工具 ``` sudo apt install device tree compiler ``` #### 使用方式 ##### 内核运行状态加载(通用) 1. 在/sys/kernel/config/device tree/overlays/下创建一个新目录, 这个目录的名字可以随便起： ```bash mkdir /sys/kernel/config/device tree/overlays/xxx ``` 2. 将dtbo固件cat到dtbo属性文件中 将dtbo的内容cat到dtbo属性文件 ```bash cat xxx.dtbo > /sys/kernel/config/device tree/overlays/xxx/dtbo ``` 3. 节点将被创建，查看内核设备树 ```bash ls /proc/device tree ``` 4. 删除\"插件\"设备树 ```bash rmdir /sys/kernel/config/device tree/overlays/xxx ``` ##### uboot加载(野火linux开发板) 修改/boot/uEnv.txt"},"/note/Linux/野火Linux/2025-11-15-68-RTC.html":{"title":"RTC","content":"# RTC RTC设备驱动是一个标准的字符设备驱动，应用程序通过 open、release、read、write和ioctl等函数完成对RTC设备的操作 Linux内核将 RTC设备抽象为`rtc_device`结构体，因此 RTC设备驱动就是申请并初始化`rtc_device` 这个记录在设备树的snvs节点里面 ```json snvs_rtc: snvs rtc lp { compatible \"fsl,sec v4.0 mon rtc lp\"; regmap <&snvs>; offset <0x34>; interrupts <GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>, <GIC_SPI 20 IRQ_TYPE_LEVEL_HIGH>; }; ``` 这个lp指的是指的是掉电以后还是有效的 根据这个配置可以找到对应的文件是`drivers/rtc/rtc snvs.c` ## 驱动 关键的结构体是`rtc_device`, 这个结构体里面记录欧帕斯的变量是需要关注的重点, rtc_class_ops ```c struct rtc_class_ops { \tint (*open)(struct device *); \tvoid (*release)(struct device *); \tint (*ioctl)(struct device *, unsigned int, unsigned long); \tint (*read_time)(struct device *, struct rtc_time *); \tint (*set_time)(struct device *, struct rtc_time *); \tint (*read_alarm)(struct device *, struct rtc_wkalrm *); \tint (*set_alarm)(struct device *, struct rtc_wkalrm *); \tint (*proc)(struct device *, struct seq_file *); \tint (*set_mmss64)(struct device *, time64_t secs); \tint (*set_mmss)(struct device *, unsigned long secs); \tint (*read_callback)(struct device *, int data); \tint (*alarm_irq_enable)(struct device *, unsigned int enabled); }; ``` 初始化以后使用rtc_device_register函数进行注册这个结构体, 实际这侧的操作函数是`snvs_rtc_ops`结构体 ```c static const struct rtc_class_ops snvs_rtc_ops { \t.read_time snvs_rtc_read_time, \t.set_time snvs_rtc_set_time, \t.read_alarm snvs_rtc_read_alarm, \t.set_alarm snvs_rtc_set_alarm, \t.alarm_irq_enable snvs_rtc_alarm_irq_enable, }; ``` 这部分的函数不是fileops直接控制的函数 这部分的调用在文件的`rtc_dev.c`文件里面, 所有RTC设备共用 file_operations函数操作集 ![image 20251115172252707](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251115172252707.png) rtc_dev_ioctl操作接口里面提供很多的操控命令, 相关的命令记录在`include/uapi/linux/rtc.h`文件里面 ## 使用 可以使用`data`命令进行获取时间以及设置等操作, 使用`data s`进行设置, 设置以后使用`hwclock w`把时间记录在rtc芯片里面"},"/note/Linux/野火Linux/2025-11-21-75-网络设备.html":{"title":"网络设备","content":"# 网络设备 嵌入式网络硬件分为两部分：MAC 和 PHY，大家都是通过看数据手册来判断一款SOC是否支持网络，如果一款芯片数据手册说自己支持网络，一般都是说的这款 SOC 内置 MAC，MAC 类似 I2C 控制器、SPI 控制器一样的外设。但是光有 MAC还不能直接驱动网络，还需要另外一个芯片：PHY，因此对于内置 MAC的 SOC，其外部必须搭配一个PHY芯片。但是有些 SOC内部没有 MAC，那也就没法搭配PHY芯片了 + 不支持的联网 我们一般说某个 SOC 不支持网络，说的就是它没有网络 MAC。那么这个芯片就不能上网了吗？显然不是的，既然没有内部 MAC，那么可以找个外置的 MAC芯片啊，不过一般这种外置的网络芯片都是 MAC+PHY 一体的。比如三星 linux 开发板里面用的最多的 DM9000，因为三星的芯片基本没有内部MAC(比如 S3C2440、S5PV210，4412等)，所以三星的开发板都是通过外置的DM9000来完成有线网络功能的，DM9000对 SOC提供了一个 SRAM接口，SOC会以 SRAM的方式操作DM9000 有些外置的网络芯片更强大，内部甚至集成了硬件 TCP/IP 协议栈，对外提供一个 SPI 接口，比如 W5500。优点就是让不支持网络的 SOC能够另辟蹊径，实现网络功能，但是缺点就是网络效率不高，因为一般芯片内置的 MAC会有网络加速引擎，比如网络专用DMA，网络处理效率会很高。而且此类芯片网速都不快 ![image 20251121222544496](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251121222544496.png) + 支持的联网 我们一般说某个 SOC支持网络，说的就是他内部集成网络MAC外设，此时我们还需要外接一个网络PHY芯片 一般常见的通用 SOC 都会集成网络 MAC 外设，比如 STM32F4/F7/H7 系列、NXP 的 I.MX系列，内部集成网络MAC的优点如下： 1. 内部MAC外设会有专用的加速模块，比如专用的DMA，加速网速数据的处理。 2. 网速快，可以支持 10/100/1000M网速。 3. 外接PHY可选择性多，成本低 内部的MAC外设会通过MII或者RMII接口来连接外部的 PHY芯片， MII/RMII接口用来传输网络数据。另外主控需要配置或读取 PHY芯片，也就是读写PHY的内部寄存器，所以还需要一个控制接口，叫做MIDO，MDIO很类似 IIC，也是两根线 ![image 20251121222749054](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251121222749054.png) ## 通信协议 ### **MII/RMII** 接口 #### MII MII全称是Media Independent Interface，直译过来就是介质独立接口，它是 IEEE 802.3定义的以太网标准接口，MII接口用于以太网 MAC 连接 PHY 芯片 ![image 20251121223102079](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251121223102079.png) MII接口一共有 16根信号线，含义如下： + **TX_CLK**：发送时钟，如果网速为 100M的话时钟频率为 25MHz，10M网速的话时钟频率为 2.5MHz，此时钟由 PHY产生并发送给MAC。 + **TX_EN**：发送使能信号。 + **TX_ER**：发送错误信号，高电平有效，表示 TX_ER有效期内传输的数据无效。10Mpbs网速下TX_ER不起作用。 + **TXD[3:0]**：发送数据信号线，一共 4根。 + **RXD[3:0]**：接收数据信号线，一共 4根。 + **RX_CLK**：接收时钟信号，如果网速为 100M的话时钟频率为25MHz，10M网速的话时钟频率为2.5MHz，RX_CLK也是由PHY产生的。 + **RX_ER**：接收错误信号，高电平有效，表示RX_ER有效期内传输的数据无效。10Mpbs网速下RX_ER不起作用。 + **RX_DV**：接收数据有效，作用类似TX_EN。 + **CRS**：载波侦听信号。 + **COL**：冲突检测信号。 MII 接口的缺点就是所需信号线太多 #### RMII 全称是 Reduced Media Independent Interface，翻译过来就是精简的介质独立接口 ![image 20251121223228703](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251121223228703.png) + **TX_EN**：发送使能信号。 + **TXD[1:0]**：发送数据信号线，一共 2根。 + **RXD[1:0]**：接收数据信号线，一共 2根。 + **CRS_DV**：相当于 MII接口中的RX_DV和 CRS这两个信号的混合 + **REF_CLK**：参考时钟，由外部时钟源提供， 频率为50MHz。这里与 MII不同，MII的接收和发送时钟是独立分开的，而且都是由PHY芯片提供的。 ### **MDIO** 接口 MDIO全称是Management Data Input/Output，直译过来就是管理数据输入输出接口，是一个简单的两线串行接口，一根 MDIO数据线，一根MDC时钟线。驱动程序可以通过 MDIO和MDC 这两根线访问 PHY 芯片的任意一个寄存器。 MDIO 接口支持多达 32 个 PHY。同一时刻内只能对一个PHY进行操作，那么如何区分这 32个PHY芯片呢？和IIC一样，使用器件地址即可。同一 MDIO 接口下的所有 PHY 芯片，其器件地址不能冲突，必须保证唯一 ### **RJ45** 接口 网络设备是通过网线连接起来的，插入网线的叫做RJ45座 RJ45 座要与 PHY 芯片连接在一起，但是中间需要一个网络变压器，网络变压器用于隔离以及滤波等，网络变压器也是一个芯片, 现在很多RJ45座子内部已经集成了网络变压器 RJ45 座子上一般有两个灯，一个黄色(橙色)，一个绿色，绿色亮的话表示网络连接正常黄色闪烁的话说明当前正在进行网络通信。这两个灯由 PHY 芯片控制，PHY 芯片会有两个引脚来连接 RJ45 座上的这两个灯。内部 MAC+外部 PHY+RJ45 座(内置网络变压器)就组成了一个完整的嵌入式网络接口硬件 ![image 20251121223620264](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251121223620264.png) ## IMX6ULL ENet I.MX6ULL有两个网络接口，也就是两个 10/100Mbit/S的MAC外设, 符合IEEE802.3 2002标准, 实际我们不需要关注太多 我们需要关注的是PHY芯片的连接部分 ## PHY芯片 PHY是IEEE 802.3规定的一个标准模块，前面说了，SOC可以对PHY进行配置或者读取PHY相关状态，这个就需要 PHY内部寄存器去实现了。PHY芯片寄存器地址空间为 5位，地址 0~31共 32个寄存器，IEEE定义了0~15这 16个寄存器的功能，16~31这16个寄存器由厂商自行实现。也就是说不管你用的哪个厂家的 PHY 芯片，其中 0~15 这 16 个寄存器是一模一样的。仅靠这16个寄存器是完全可以驱动起 PHY芯片的，至少能保证基本的网络数据通信 着现在的 PHY 芯片性能越来越强大，32 个寄存器可能满足不了厂商的需求，因此很多厂商采用分页技术来扩展寄存器地址空间，以求定义更多的寄存器, 这个时候就需要 PHY厂商提供相应的驱动源码了，所以大家也会在 Linux内核里面看到很多具体的PHY芯片驱动源码。 ![image 20251121225233117](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251121225233117.png) ### LAN8720 低功耗的 10/100M 单以太网 PHY 层芯片, 合 IEEE802.3 2005标准, 支持RMII LAN8720A 可以通过自协商的方式选择与目的主机最佳的连接方式(速度和双工模式) LAN8720A通过设置 RXER/PHYAD0引脚来设置其PHY地址，默认情况下为 0 ![image 20251121225906463](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251121225906463.png) ## Linux网络驱动 ### 数据结构 #### net_device Linux内核使用 net_device结构体表示一个具体的网络设备，net_device是整个网络驱动的灵魂。网络驱动的核心就是初始化 net_device 结构体中的各个成员变量 需要关注的变量: + etdev_ops 是网络设备的操作集函数，包含了一系列的网络设备操作回调函数，类似字符设备中的file_operations，稍后会讲解 netdev_ops结构体。 + ethtool_ops是网络管理工具相关函数集，用户空间网络管理工具会调用此结构体中的相关函数获取网卡状态或者配置网卡 + header_ops是头部的相关操作函数集，比如创建、解析、缓冲等 #### 操作函数 ```c #define alloc_netdev(sizeof_priv, name, name_assign_type, setup) \\ \talloc_netdev_mqs(sizeof_priv, name, name_assign_type, setup, 1, 1) struct net_device * alloc_netdev_mqs ( int sizeof_priv, const char *name, void (*setup) (struct net_device *)) unsigned int txqs, unsigned int rxqs); ``` + **sizeof_priv**：私有数据块大小。 + **name**：设备名字。 + **setup**：回调函数，初始化设备的设备后调用此函数。 + **txqs**：分配的发送队列数量。 + **rxqs**：分配的接收队列数量。 Linux 内核内核支持的网络接口有很多，比如光纤分布式数据接口(FDDI)、以太网设备(Ethernet)、红外数据接口(InDA)、高性能并行接口(HPPI)、CAN 网络等。内核针对不同的网络设备在 alloc_netdev 的基础上提供了一层封装 针对以太网封装的 net_device申请函数是 alloc_etherdev ```c #define alloc_etherdev(sizeof_priv) alloc_etherdev_mq(sizeof_priv, 1) #define alloc_etherdev_mq(sizeof_priv, count) alloc_etherdev_mqs(sizeo f_priv, count, count) ``` 实际是对`alloc_netdev_mqs`的进一步封装设置网卡的名字为“eth%d”，这是格式化字符串，大家进入开发板的 linux系统以后看到的“eth0”、“eth1”这样的网卡名字就是从这里来的 这里设置了以太网的 setup 函数为 ether_setup，不同的网络设备其 setup函数不同, 这个函数里面实现了对于net_dev里面参数的设置 ```c void free_netdev(struct net_device *dev); int register_netdev(struct net_device *dev); void unregister_netdev(struct net_device *dev); ``` #### net_device_ops 网络设备的操作集。net_device_ops 结构体定义在 include/linux/netdevice.h 文件中, 需要网络驱动编写人员去实现 + ndo_open函数，打开网络设备的时候此函数会执行，网络驱动程序需要实现此函数，非常重要！以NXP的 I.MX系列 SOC网络驱动为例，会在此函数中做如下工作： 1. 使能网络外设时钟。 2. 申请网络所使用的环形缓冲区。 3. 初始化MAC外设。 4. 绑定接口对应的 PHY。 5. 如果使用NAPI的话要使能NAPI模块，通过 napi_enable函数来使能。 6. 开启PHY。 7. 调用netif_tx_start_all_queues来使能传输队列，也可能调用netif_start_queue函数。 + ndo_stop 函数，关闭网络设备的时候此函数会执行 + ndo_start_xmit函数，当需要发送数据的时候此函数就会执行，此函数有一个参数为 sk_buff结构体指针，sk_buff结构体在Linux的网络驱动中非常重要，sk_buff保存了上层传递给网络驱动层的数据。也就是说，要发送出去的数据都存在了sk_buff中 + ndo_select_queue函数，当设备支持多传输队列的时候选择使用哪个队列 + ndo_tx_timeout函数，当发送超时的时候函数会执行，一般都是网络出问题了导致发送超时。一般可能会重启 MAC和PHY，重新开始数据发送等 #### **sk_buff** 结构体 网络是分层的，对于应用层而言不用关心具体的底层是如何工作的，只需要按照协议将要发送或接收的数据打包好即可。打包好以后都通过dev_queue_xmit函数将数据发送出去，接收数据的话使用netif_rx函数即可 + tstamp表示数据包接收时或准备发送时的时间戳 + sk表示当前 sk_buff所属的Socket + dev表示当前 sk_buff从哪个设备接收到或者发出的 + cb为控制缓冲区，不管哪个层都可以自由使用此缓冲区，用于放置私有数据 + destructor函数，当释放缓冲区的时候可以在此函数里面完成某些动作 + len 为实际的数据长度，包括主缓冲区中数据长度和分片中的数据长度。data_len为数据长度，只计算分片中数据的长度 + mac_len为连接层头部长度，也就是MAC头的长度 + protocol协议 + transport_header为传输层头部 + network_header为网络层头部 + mac_header为链接层头部 + tail指向实际数据的尾部 + end指向缓冲区的尾部 + head 指向缓冲区的头部，data 指向实际数据的头部。data 和 tail 指向实际数据的头部和尾部，head和 end指向缓冲区的头部和尾部 ![image 20251121233122232](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251121233122232.png) ##### dev_queue_xmit应用层发送 ```c static inline int dev_queue_xmit(struct sk_buff *skb) ``` **skb**：要发送的数据，这是一个sk_buff结构体指针，sk_buff是Linux网络驱动中一个非常重要的结构体，网络数据就是以 sk_buff 保存的，各个协议层在 sk_buff 中添加自己的协议头，最终由底层驱动将 sk_buff中的数据发送出去。网络数据的接收过程恰好相反，网络底层驱动将接收到的原始数据打包成 sk_buff，然后发送给上层协议，上层会取掉相应的头部，然后将最终的数据发送给用户。 最终是通过 net_device_ops 操作集里面的 ndo_start_xmit 函数来完成最终发送 ![image 20251121232718400](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251121232718400.png) ##### netif_rx驱动层接收 ```c int netif_rx(struct sk_buff *skb); ``` ##### 其他API ```c // 申请 static inline struct sk_buff *alloc_skb(unsigned int size, gfp_t priority); ``` + **size**：要分配的大小，也就是skb数据段大小。 + **priority**：为GFP MASK宏，比如GFP_KERNEL、GFP_ATOMIC等。 + 返回值：分配成功的话就返回申请到的 sk_buff首地址，失败的话就返回 NULL。 ```c static inline struct sk_buff *netdev_alloc_skb(struct net_device *dev,unsigned int length) ``` 在网络设备驱动中常常使用 netdev_alloc_skb 来为某个设备申请一个用于接收的 skb_buff ```c // 释放 void kfree_skb(struct sk_buff *skb) ``` + 缓冲区相关 ```c unsigned char *skb_put(struct sk_buff *skb, unsigned int len); ``` ![image 20251122101050213](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251122101050213.png) ```c unsigned char *skb_push(struct sk_buff *skb, unsigned int len) ``` ![image 20251122101119154](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251122101119154.png) ```c unsigned char *skb_pull(struct sk_buff *skb, unsigned int len) ``` ![image 20251122101153939](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251122101153939.png) ```c static inline void skb_reserve(struct sk_buff *skb, int len) ``` 将skb_buff的data和tail同时后移 n个字节即可 ### NAPI机制 收数据有两种方法：轮询或中断。Linux在这两个处理方式的基础上提出了另外一种网络数据接收的处理方法：NAPI(New API)，NAPI是一种高效的网络处理技术。NAPI的核心思想就是不全部采用中断来读取网络数据，而是采用中断来唤醒数据接收服务程序，在接收服务程序中采用 POLL的方法来轮询处理数据 #### API函数 ```c /* 初始化一个 napi_struct 实例 napi：要初始化的 NAPI实例 poll： NAPI所使用的轮询函数，非常重要，一般在此轮询函数中完成网络数据接收的工作 NAPI默认权重(weight)，一般为NAPI_POLL_WEIGHT */ void netif_napi_add(struct net_device *dev, struct napi_struct *napi, int (*poll)(struct napi_struct *, int), int weight); void netif_napi_del(struct napi_struct *napi); inline void napi_enable(struct napi_struct *n); void napi_disable(struct napi_struct *n); // 查看是不是可以调度 inline bool napi_schedule_prep(struct napi_struct *n); // 完成一次调度 void __napi_schedule(struct napi_struct *n) // 可以使用 napi_schedule 函数来一次完成 napi_schedule_prep 和__napi_schedule ``` #### 简单示例 ```c #include <linux/netdevice.h> #include <linux/interrupt.h> struct my_private { struct napi_struct napi; struct net_device *dev; void __iomem *mmio; // 其他驱动私有数据 }; /* NAPI 轮询函数 */ int my_poll(struct napi_struct *napi, int budget) { struct my_private *priv container_of(napi, struct my_private, napi); struct net_device *dev priv >dev; int work_done 0; /* 处理接收的数据包，最多处理 budget 个 */ work_done process_receive_packets(priv, budget); if (work_done < budget) { /* 所有数据包处理完毕，退出轮询模式 */ napi_complete_done(napi, work_done); /* 重新启用接收中断 */ enable_rx_interrupt(priv); } return work_done; } /* 中断处理函数 */ irqreturn_t my_interrupt(int irq, void *dev_id) { struct net_device *dev dev_id; struct my_private *priv netdev_priv(dev); u32 status; status readl(priv >mmio + INT_STATUS); /* 如果是接收中断且NAPI可调度 */ if ((status & RX_INT) && napi_schedule_prep(&priv >napi)) { /* 禁用硬件中断 */ writel(0, priv >mmio + INT_ENABLE); /* 调度NAPI轮询 */ __napi_schedule(&priv >napi); } /* 清除中断标志 */ writel(status, priv >mmio + INT_STATUS); return IRQ_HANDLED; } /* 设备初始化 */ int my_dev_init(struct net_device *dev) { struct my_private *priv netdev_priv(dev); /* 初始化NAPI结构 */ netif_napi_add(dev, &priv >napi, my_poll, 64); // budget 64 return 0; } ``` ## 设备树 XP的 I.MX系列SOC网络绑定文档为 Documentation/devicetree/bindings/net/fsl fec.txt ```json fec1: ethernet@02188000 { compatible \"fsl,imx6ul fec\", \"fsl,imx6q fec\"; reg <0x02188000 0x4000>; interrupts <GIC_SPI 118 IRQ_TYPE_LEVEL_HIGH>, <GIC_SPI 119 IRQ_TYPE_LEVEL_HIGH>; clocks <&clks IMX6UL_CLK_ENET>, <&clks IMX6UL_CLK_ENET_AHB>, <&clks IMX6UL_CLK_ENET_PTP>, <&clks IMX6UL_CLK_ENET_REF>, <&clks IMX6UL_CLK_ENET_REF>; clock names \"ipg\", \"ahb\", \"ptp\", \"enet_clk_ref\", \"enet_out\"; stop mode <&gpr 0x10 3>; fsl,num tx queues <1>; fsl,num rx queues <1>; fsl,magic packet; fsl,wakeup_irq <0>; status \"disabled\"; }; &fec2 { \tpinctrl names \"default\"; \tpinctrl 0 <&pinctrl_enet2 \t\t &pinctrl_fec2_reset>; \tphy mode \"rmii\"; \tphy handle <&ethphy1>; \tphy reset gpios <&gpio5 8 GPIO_ACTIVE_LOW>; \tphy reset duration <200>; \tstatus \"okay\"; \tmdio { \t\t#address cells <1>; \t\t#size cells <0>; \t\tethphy0: ethernet phy@2 { \t\t\tcompatible \"ethernet phy ieee802.3 c22\"; \t\t\treg <0>; \t\t}; \t\tethphy1: ethernet phy@1 { \t\t\tcompatible \"ethernet phy ieee802.3 c22\"; \t\t\treg <1>; \t\t}; \t}; }; ``` > 必要属性 > > + **compatible**：这个肯定是必须的，一般是“fsl,<soc> fec”，比如I.MX6ULL的 compatible属性就是\"fsl,imx6ul fec\",和\"fsl,imx6q fec\"。 > + **reg**：SOC网络外设寄存器地址范围。 > + **interrupts**：网络中断。 > + **phy mode**：网络所使用的PHY接口模式，是 MII还是RMII。 > > 可选 > > + **phy reset gpios**：PHY芯片的复位引脚。 > + **phy reset duration**：PHY复位引脚复位持续时间，单位为毫秒。只有当设置了 phy reset gpios属性此属性才会有效，如果不设置此属性的话PHY芯片复位引脚的复位持续时间默认为1毫秒，数值不能大于 1000毫秒，大于1000毫秒的话就会强制设置为1毫秒。 > + **phy supply**：PHY芯片的电源调节。 > + **phy handle**：连接到此网络设备的 PHY芯片句柄。 > + **fsl,num tx queues**：此属性指定发送队列的数量，如果不指定的话默认为 1。 > + **fsl,num rx queues**：此属性指定接收队列的数量，如果不指定的话默认为 2。 > + **fsl,magic packet**：此属性不用设置具体的值，直接将此属性名字写到设备树里面即可，表示支持硬件魔术帧唤醒。 > + **fsl,wakeup_irq**：此属性设置唤醒中断索引。 > + **stop mode**：如果此属性存在的话表明 SOC需要设置GPR位来请求停止模式。 > > 可选节点 > > + mdio：可以设置名为“mdio”的子节点，此子节点用于指定网络外设所使用的 MDIO总线，主要作为 PHY 节点的容器，也就是在 mdio 子节点下指定 PHY 相关的属性信息，具体信息可以参考PHY的绑定文档Documentation/devicetree/bindings/net/phy.txt。 > > + PHY节点相关属性内容如下： > + + **interrupts**：中断属性，可以不需要。 > + **interrupt parent**：中断控制器句柄，可以不需要。 > + **reg**：PHY芯片地址，必须的！ > + **compatible**：兼容性列表，一般为`ethernet phy ieee802.3 c22`或`ethernet phy ieee802.3 c45`，分别对应IEEE802.3 的22簇和45簇，默认是 22簇。也可以设置为其他值，如果 PHY的 ID不知道的话可以 compatible属性可以设置为`ethernet phy idAAAA.BBBB`，AAAA和BBBB的含义如下： > + + AAAA：PHY的16位 ID寄存器1值，也就是 OUI的bit3~18，16进制格式。 > + + BBBB：PHY的 16位 ID寄存器2值，也就是 OUI的bit19~24，16进制格式。 > + **max speed**：PHY支持的最高速度，比如 10、100或1000。 ## 网络驱动 ### fec_probe I.MX6ULL 而言网络驱动主要分两部分：I.MX6ULL 网络外设驱动以及 PHY 芯片驱动，网络外设驱动是NXP编写的，PHY芯片有通用驱动文件, 在文件drivers/net/ethernet/freescale/fec_main.c里面 + 请求一个net_device结构, 实际请求的时候后面有添加自己的私有数据 + 初始化各种变量, 寄存器地址, 处理各种配置信息 + 初始化`net_device`的`netdev_ops`和`ethtool_ops`成员为`fec_netdev_ops`以及`fec_enet_ethtool_ops` + 初始化NAPI, 使用`fec_enet_rx_napi`进行轮训 + 完成 MII/RMII 接口的初始化, 记录`mii_bus`的操作函数read/write为 `fec_enet_mdio_read`和`fec_enet_mdio_write` + 从设备树中获取 mdio节点，如果节点存在的话就会通过 of_mdiobus_register 来向内核注册 MDIO 总线 ### **MDIO** 总线 fec_probe 函数会调用 fec_enet_mii_init函数完成 MII接口的初始化，其中就包括初始化mii_bus下的read和write这两个函数。最终通过 of_mdiobus_register或者 mdiobus_register 函数将初始化以后的 mii_bus 注册到 Linux 内核 调用的 mdiobus_register 函数来完成 mii_bus 注册, 调用of_mdiobus_register_phy函数向 Linux内核注册 phy ```c struct mii_bus { \tconst char *name; \tchar id[MII_BUS_ID_SIZE]; \tvoid *priv; \tint (*read)(struct mii_bus *bus, int phy_id, int regnum); \tint (*write)(struct mii_bus *bus, int phy_id, int regnum, u16 val); \tint (*reset)(struct mii_bus *bus); \t/* \t * A lock to ensure that only one thing can read/write \t * the MDIO bus at a time \t */ \tstruct mutex mdio_lock; \tstruct device *parent; \tenum { \t\tMDIOBUS_ALLOCATED 1, \t\tMDIOBUS_REGISTERED, \t\tMDIOBUS_UNREGISTERED, \t\tMDIOBUS_RELEASED, \t} state; \tstruct device dev; \t/* list of all PHYs on bus */ \tstruct phy_device *phy_map[PHY_MAX_ADDR]; \t/* PHY addresses to be ignored when probing */ \tu32 phy_mask; \t/* \t * Pointer to an array of interrupts, each PHY's \t * interrupt at the index matching its address \t */ \tint *irq; }; ``` ![image 20251122113447040](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251122113447040.png) ### PHY驱动 通用 PHY 驱动名字为“Generic PHY”，打开drivers/net/phy/phy_device.c，phy_init函数 行会调用 phy_drivers_register函数向内核直接注册一个通用 PHY 驱动：genphy_driver，也就是通用 PHY 驱动 ## 使用LAN8720A ``` > Device Drivers > Network device support > PHY Device support and infrastructure > Drivers for SMSC PHYs ```"},"/note/Linux/野火Linux/2025-11-19-72-CAN.html":{"title":"CAN协议","content":"# CAN协议 ## 基础概念 CAN 的全称为 Controller Area Network，也就是控制局域网络，简称为 CAN ![image 20251119124349660](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251119124349660.png) 各个单元通过 CAN总线连接在一起，每个单元都是独立的 CAN节点。同一个 CAN网络中所有单元的通信速度必须一致，不同的网络之间通信速度可以不同。比如图中125Kbps的CAN网络下所有的节点速度都是 125Kbps的，整个网络由一个网关与其他的网络连接 1. 多主控制 在总线空闲时，所有单元都可以发送消息（多主控制），而两个以上的单元同时开始发送消息时，根据标识符（Identifier 以下称为 ID）决定优先级。ID 并不是表示发送的目的地址，而是表示访问总线的消息的优先级。两个以上的单元同时开始发送消息时，对各消息 ID 的每个位进行逐个仲裁比较。仲裁获胜（被判定为优先级最高）的单元可继续发送消息，仲裁失利的单元则立刻停止发送而进行接收工作 2. 系统的柔软性 与总线相连的单元没有类似于“地址”的信息。因此在总线上增加单元时，连接在总线上的其它单元的软硬件及应用层都不需要改变 3. 信速度快，距离远 最高 1Mbps（距离小于 40M），最远可达 10KM（速率低于5Kbps）。 4. 具有错误检测、错误通知和错误恢复功能 所有单元都可以检测错误（错误检测功能），检测出错误的单元会立即同时通知其他所有单元（错误通知功能），正在发送消息的单元一旦检测出错误，会强制结束当前的发送。强制结束发送的单元会不断反复地重新发送此消息直到成功发送为止（错误恢复功能）。 5. 故障封闭功能 CAN 可以判断出错误的类型是总线上暂时的数据错误（如外部噪声等）还是持续的数据错误（如单元内部故障、驱动器故障、断线等）。由此功能，当总线上发生持续数据错误时，可将引起此故障的单元从总线上隔离出去。 6. 连接节点多 CAN 总线是可同时连接多个单元的总线。可连接的单元总数理论上是没有限制的。但实际上可连接的单元数受总线上的时间延迟及电气负载的限制。降低通信速度，可连接的单元数增加；提高通信速度，则可连接的单元数减少 ### 电器属性 CAN 总线使用两根线来连接各个单元：CAN_H 和 CAN_L，CAN 控制器通过判断这两根线上的**电位差**来得到总线电平，CAN总线电平分为显性电平和隐性电平两种。显性电平表示逻辑“0”，此时 CAN_H 电平比 CAN_L 高，分别为 3.5V 和 1.5V，电位差为 2V。隐形电平表示逻辑“1”，此时 CAN_H和 CAN_L电压都为 2.5V左右，电位差为 0V。CAN总线就通过显性和隐形电平的变化来将具体的数据发送出去 ![image 20251119124924683](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251119124924683.png) CAN总线上没有节点传输数据的时候一直处于隐性状态，也就是说总线空闲状态的时候一直处于隐性。CAN 网络中的所有单元都通过 CAN_H 和 CAN_L 这两根线连接在一起 ![image 20251119125032080](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251119125032080.png) ### 协议内容 过 CAN总线传输数据是需要按照一定协议进行的，CAN协议提供了 5种帧格式来传输数据：数据帧、遥控帧、错误帧、过载帧和帧间隔 中数据帧和遥控帧有标准格式和扩展格式两种，标准格式有 11位标识符(ID)，扩展格式有 29个标识符(ID) ![image 20251119125239882](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251119125239882.png) ### 速率 CAN总线以帧的形式发送数据，但是最终到总线上的就是“0”和“1”这样的二进制数据，这里就涉及到了通信速率，也就是每秒钟发送多少位数据，前面说了CAN2.0最高速度为 1Mbps/S。对于CAN总线，一个位分为 4段 1. 同步段(SS) 2. 传播时间段(PTS) 3. 相位缓冲段 1(PBS1) 4. 相位缓冲段 2(PBS2) 这些段由Tq(Time Quantum)组成，Tq是CAN总线的最小时间单位。帧由位构成，一个位由 4个段构成，每个段又由若干个Tq组成，这个就是位时序。1 位由多少个Tq 构成、每个段又由多少个 Tq 构成等，可以任意设定位时序。通过设定位时序，多个单元可同时采样，也可任意设定采样点。 ![image 20251119131956760](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251119131956760.png) ![image 20251119132219801](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251119132219801.png) ## IMX6ULL CAN I.MX6ULL 带有 CAN 控制器外设，叫做 FlexCAN，FlexCAN 符合 CAN2.0B 协议。FlexCAN 完全符合 CAN 协议，支持标准格式和扩展格式，支持 64 个消息缓冲。 1. 支持CAN2.0B协议，数据帧和遥控帧支持标准和扩展两种格式，数据长度支持 0~8字节，可编程速度，最高 1Mbit/S。 2. 灵活的消息邮箱，最高支持 8个字节。 3. 每个消息邮箱可以配置为接收或发送，都支持标准和扩展这两种格式的消息。 4. 每个消息邮箱都有独立的接收掩码寄存器。 5. 强大的接收 FIFO ID过滤。 6. 未使用的空间可以用作通用 RAM。 7. 可编程的回测模式，用于进行自测。 8. 可编程的优先级组合。 FlexCAN 支持四种模式：正常模式(Normal)、冻结模式(Freeze)、仅监听模式(Listen Only)和回环模式(Loop Back)，另外还有两种低功耗模式：禁止模式(Disable)和停止模式(Stop)。 1. 正常模式**(Normal)**在正常模式下，FlexCAN正常接收或发送消息帧，所有的CAN协议功能都使能。 2. 冻结模式**(Freeze)**当 MCR 寄存器的 FRZ 位置 1 的时候使能此模式，在此模式下无法进行帧的发送或接收，CAN总线同步丢失。 3. 仅监听模式**(Listen Onley)**当 CTRL 寄存器的 LOM 位置 1 的时候使能此模式，在此模式下帧发送被禁止，所有错误 计数器被冻结， CAN控制器工作在被动错误模式，此时只会接收其他CAN单元发出的ACK消息。 4. 回环模式**(Loop Back)**当 CTRL 寄存器的 LPB 位置 1 的时候进入此模式，此模式下 FlexCAN 工作在内部回环模式，一般用来进行自测。从模式下发送出来的数据流直接反馈给内部接收单元。 FlexCAN支持CAN协议的这些位时序，控制寄存器CTRL用于设置这些位时序，CTRL寄存器中的PRESDIV、PROPSEG、PSEG1、PSEG2和RJW这5个位域用于设置CAN位时序 + PRESDIV为CAN分频值，也即是设置CAN协议中的Tq值![image 20251119132911456](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251119132911456.png) + **SS**：同步段(Synchronization Segment)，在 I.MX6ULL 参考手册中叫做 SYNC_SEG，此段固定为1个 Tq长度，因此不需要我们去设置。 + **PTS**：传播时间段(Propagatin Segment)，FlexCAN的 CTRL寄存器中的 PROPSEG位域设置此段，可以设置为 0\\~7，对应1\\~8个Tq。 + **PBS1**：相位缓冲段 1(Phase Buffer Segment 1)，FlexCAN 的 CRTL 寄存器中的 PSEG1 位域设置此段，可以设置为0\\~7，对应1\\~8个 Tq。 + **PBS2**：相位缓冲段 2(Phase Buffer Segment 2)，FlexCAN 的 CRTL 寄存器中的 PSEG2 位域设置此段，可以设置为1\\~7，对应2\\~8个 Tq。 + **SJW**：再同步补偿宽度(reSynchronization Jump Width)，FlexCAN的 CRTL寄存器中的RJW位域设置此段，可以设置 0\\~3，对应1\\~4个Tq。 `SYNC+SEG+(PROP_SEG+PSEG1+2)+(PSEG2+1)`就是总的Tq ![image 20251119133458374](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251119133458374.png) ![image 20251119133518569](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251119133518569.png) ## 设备树 Documentation/devicetree/bindings/net/can/fsl flexcan.txt ### 引脚 ```json pinctrl_flexcan1: flexcan1grp{ fsl,pins < MX6UL_PAD_UART3_RTS_B__FLEXCAN1_RX\t0x1b020 MX6UL_PAD_UART3_CTS_B__FLEXCAN1_TX\t0x1b020 >; }; ``` 配置两个引脚的复用 ```json flexcan1: can@02090000 { compatible \"fsl,imx6ul flexcan\", \"fsl,imx6q flexcan\"; reg <0x02090000 0x4000>; interrupts <GIC_SPI 110 IRQ_TYPE_LEVEL_HIGH>; clocks <&clks IMX6UL_CLK_CAN1_IPG>, <&clks IMX6UL_CLK_CAN1_SERIAL>; clock names \"ipg\", \"per\"; stop mode <&gpr 0x10 1 0x10 17>; status \"disabled\"; }; &flexcan1 { \tpinctrl names \"default\"; \tpinctrl 0 <&pinctrl_flexcan1>; \txceiver supply <&reg_can_3v3>; \tstatus \"okay\"; }; ``` > CAN收发器的电压为 3.3V ### 对应驱动 NXP 官方提供的 linux 内核默认已经集成了 I.MX6ULL 的 FlexCAN 驱动 ``` > Networking support \t > <*> CAN bus subsystem support //打开CAN总线子系统 ``` 接着使能Freescale系CPU的 FlexCAN外设驱动 ``` > Networking support > CAN bus subsystem support > CAN Device Drivers > Platform CAN drivers with Netlink support > <*> Support for Freescale FLEXCAN based chips //选中 ``` 在使能以后可以在网络部分查看到这个网卡 ```c ifconfig a //查看所有网卡 ``` ## 使用 busybox自带的 ip命令并不支持对can的操作, can实际被虚拟出一个网卡，因此我们需要重新移植 ip命令，也就是iproute2 使用can utils这个工具来对 can0网卡进行测试, 编程里面使用的是socket编程"},"/note/Linux/野火Linux/2025-7-19-16-xbus和platform.html":{"title":"xbus驱动总线","content":"# xbus驱动总线 ## xbus：打造自属的驱动总线 #### 驱动总线 软件与硬件代码分离，提高程序的复用性 device 关联硬件代码, 寄存器相关的 driver_devices 关联软件代码 bus_type 统一管理、设置match匹配规则, 使用链表进行关联上面两个 > 在进行添加的时候, 会使用match函数进行匹配, 添加一个的时候会去匹配另一个进行合作 设备驱动模型体现分离思想, 如果自定义以及xbus总线会被记录在sys/xbus目录下面, 有两个目录分别管理 /bus/xbus/devices drivers > 默认的总线是在/bus目录下边的 #### 总线管理 ![image 20250719171651745](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507191716837.png) ##### buses_init()函数 内核启动默认执行 创建/sys/bus目录 ```c int __init buses_init(void) { // 默认的bus目录项 \tbus_kset kset_create_and_add(\"bus\", &bus_uevent_ops, NULL); \tif (!bus_kset) \t\treturn ENOMEM; \t// 创建一个system目录项 \tsystem_kset kset_create_and_add(\"system\", NULL, &devices_kset >kobj); \tif (!system_kset) \t\treturn ENOMEM; \treturn 0; } ``` #### 总线注册 ##### bus_register()函数 添加新的总线类型 ```c int bus_register(struct bus_type *bus) ``` 在/sys/bus下建立xbus目录项(xbus为自定义的名字)，并创建属性文件 在/sys/bus/xbus下建立devices目录项，并创建属性文件 在/sys/bus/xbus下建立drivers目录项，并创建属性文件 > 记录在bustype里面的subsys_private里面, 有三个kset对应目录, 属性记录在bustype里面 初始化 priv >klist_devices链表头 初始化priv >klist_drivers链表头 > 记录一系列的驱动代码 #### 设备注册 ##### device_register()函数 添加设备，关联硬件相关代码, 添加设备的同时记录在链表里面, 不管有没有匹配到driver都会在/dev/建立这个文件 ```c int device_register(struct device *dev) ``` 在/sys/bus/xbus/devices下建立yyy目录项 加入bus > priv >devices_kset链表 加入bus > priv >klist_devices链表 遍历bus > priv >klist_drivers，执行bus >match()寻找合适的drv dev关联driv，执行drv >probe() #### 驱动注册 ##### driver_register()函数 添加驱动，关联软件相关代码 ```c int driver_register(struct device_driver *drv) ``` 在/sys/bus/xbus/drivers下建立zzz目录项 加入bus > priv >drivers_kset链表 加入bus > priv >klist_drivers链表 遍历bus > priv >klist_klist_devices链表，执行bus >match()寻找合适的dev dev关联dev，执行drv >probe() #### 设备驱动模型框图 ![image 20250719171845725](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507191718818.png) ## 代码实现 注册的时候需要先注册总线, 之后注册设备和驱动, 使用总线里面的match函数进行匹配, 匹配以后执行driver里面的probe函数 ```c /* * Struct used for matching a device */ struct of_device_id { \tchar\tname[32]; \tchar\ttype[32]; \tchar\tcompatible[128]; \tconst void *data; }; /** * struct device_driver The basic device driver structure * @name:\tName of the device driver. * @bus:\tThe bus which the device of this driver belongs to. * @owner:\tThe module owner. * @mod_name:\tUsed for built in modules. * @suppress_bind_attrs: Disables bind/unbind via sysfs. * @probe_type:\tType of the probe (synchronous or asynchronous) to use. * @of_match_table: The open firmware table. * @acpi_match_table: The ACPI match table. * @probe:\tCalled to query the existence of a specific device, *\t\twhether this driver can work with it, and bind the driver *\t\tto a specific device. * @remove:\tCalled when the device is removed from the system to *\t\tunbind a device from this driver. * @shutdown:\tCalled at shut down time to quiesce the device. * @suspend:\tCalled to put the device to sleep mode. Usually to a *\t\tlow power state. * @resume:\tCalled to bring a device from sleep mode. * @groups:\tDefault attributes that get created by the driver core *\t\tautomatically. * @pm:\t\tPower management operations of the device which matched *\t\tthis driver. * @coredump:\tCalled when sysfs entry is written to. The device driver *\t\tis expected to call the dev_coredump API resulting in a *\t\tuevent. * @p:\t\tDriver core's private data, no one other than the driver *\t\tcore can touch this. * * The device driver model tracks all of the drivers known to the system. * The main reason for this tracking is to enable the driver core to match * up drivers with new devices. Once drivers are known objects within the * system, however, a number of other things become possible. Device drivers * can export information and configuration variables that are independent * of any specific device. */ struct device_driver { \tconst char\t\t*name; \tstruct bus_type\t\t*bus; \tstruct module\t\t*owner; \tconst char\t\t*mod_name;\t/* used for built in modules */ \tbool suppress_bind_attrs;\t/* disables bind/unbind via sysfs */ \tenum probe_type probe_type; \tconst struct of_device_id\t*of_match_table; \tconst struct acpi_device_id\t*acpi_match_table; \tint (*probe) (struct device *dev); \tint (*remove) (struct device *dev); \tvoid (*shutdown) (struct device *dev); \tint (*suspend) (struct device *dev, pm_message_t state); \tint (*resume) (struct device *dev); \tconst struct attribute_group **groups; \tconst struct dev_pm_ops *pm; \tvoid (*coredump) (struct device *dev); \tstruct driver_private *p; }; ``` ### 总线 ```c #include <linux/init.h> #include <linux/module.h> #include <linux/device.h> // 使用的匹配函数 int xbus_match(struct device *dev, struct device_driver *drv) { \tprintk(KERN_ALERT \"%s %s\\n\", __FILE__, __func__); \tif (!strncmp(dev_name(dev), drv >name, strlen(drv >name))) { \t\tprintk(KERN_ALERT \"dev & drv match\\n\"); \t\treturn 1; \t} \treturn 0; } static struct bus_type xbus { \t.name \"xbus\", \t.match xbus_match, }; // 共享参数 EXPORT_SYMBOL(xbus); static __init int xbus_init(void) { int ret; \tprintk(KERN_ALERT \"xbus init\\n\"); \tret bus_register(&xbus); if(ret ! 0){ return 1; } \treturn 0; } module_init(xbus_init); static __exit void xbus_exit(void) { \tprintk(KERN_ALERT \"xbus exit\\n\"); \tbus_unregister(&xbus); } module_exit(xbus_exit); MODULE_AUTHOR(\"embedfire\"); MODULE_LICENSE(\"GPL\"); ``` ### 设备 ```c #include <linux/init.h> #include <linux/module.h> #include <linux/device.h> extern struct bus_type xbus; void xdev_release(struct device *dev) { \tprintk(KERN_ALERT \"%s %s\\n\", __FILE__, __func__); } static struct device xdev { \t.init_name \"xdev\", \t.bus &xbus, // 之前构建的总线 \t.release xdev_release, }; static __init int xdev_init(void) { int ret; \tprintk(KERN_ALERT \"xdev init\\n\"); \tret device_register(&xdev); if(ret ! 0){ return 1; } \treturn 0; } static __exit void xdev_exit(void) { \tprintk(KERN_ALERT \"xdev exit\\n\"); \tdevice_unregister(&xdev); } module_init(xdev_init); module_exit(xdev_exit); MODULE_AUTHOR(\"embedfire\"); MODULE_LICENSE(\"GPL\"); ``` ### 驱动 ```c #include <linux/init.h> #include <linux/module.h> #include <linux/device.h> extern struct bus_type xbus; int xdrv_probe(struct device *dev) { \tprintk(KERN_ALERT \"%s %s\\n\", __FILE__, __func__); \treturn 0; } int xdrv_remove(struct device *dev) { \tprintk(KERN_ALERT \"%s %s\\n\", __FILE__, __func__); \treturn 0; } static struct device_driver xdrv { \t.name \"xdev\", \t.bus &xbus, \t.probe xdrv_probe, \t.remove xdrv_remove, }; static __init int xdrv_init(void) { int ret; \tprintk( KERN_ALERT\"xdrv init\\n\"); \tret driver_register(&xdrv); if(ret ! 0){ return 1; } \treturn 0; } static __exit void xdrv_exit(void) { \tprintk(KERN_ALERT \"xdrv exit\\n\"); \tdriver_unregister(&xdrv); } module_init(xdrv_init); module_exit(xdrv_exit); MODULE_AUTHOR(\"embedfire\"); MODULE_LICENSE(\"GPL\"); ``` ![image 20250719222449450](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507192224545.png) # platform:虚拟的平台总线 ## 使用 + 初始化`platform_driver`结构体里面的`driver`对应的`name`以及`of_match_table`, 和probe以及remove对应的函数句柄 + 在`module_init`函数里面使用`platform_driver_register`注册上面的结构体, 也可以直接使用`module_platform_driver`实现`module`的初始化以及注册驱动 + 在注册到probe函数里面初始化字符设备 > `name`一般是没有使用设备树的时候匹配使用的, `of_match_table`是使用设备树以后使用的 ## 定义 在 Linux 设备驱动模型中，`platform_device` 是一种**描述片上系统 (SoC) 或固定连接的非总线设备**的核心机制。它用于管理那些 不通过标准硬件总线（如 I2C、PCI、USB）连接，但由 CPU 直接控制或集成在芯片内部的设备。 platform_device：继承device，关联硬件代码, 记录相关的硬件资源信息 platform_driver：继承device_driver，重设probe函数指针, 实际使用device记录的硬件资源进行初始化, 这个prob实际会调用driver里面的probe函数 platform(bus_type)：统一管理、设置match匹配规则 适用设备： SoC 内部外设（如 UART、GPIO 控制器、时钟模块） 固定连接的硬件（如板载 Flash、专用硬件加速器） 无法自动检测的旧式设备（如 ISA 设备） **不依赖物理总线**：无需实现总线协议（如 I2C 的 `i2c_driver`），直接由内核管理。 ![image 20250719230755520](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507192307614.png) 在实际的驱动开发中，一般 I2C主机控制器驱动已经由半导体厂家编写好了，而设备驱动一般也由设备器件的厂家编写好了，我们只需要提供设备信息即可，比如 I2C 设备的话提供设备连接到了哪个 I2C 接口上，I2C 的速度是多少等等。相当于将设备信息从设备驱动中剥离开来，驱动使用标准方法去获取到设备信息(比如从设备树中获取到设备信息) ## API ### 系统处理 #### 平台总线注册 drivers/base/platform.c 可以在/sys/bus/platform看到这个总线里面的设备 ##### platform_bus_init()函数 这个函数是自动调用的 ```c struct bus_type platform_bus_type { \t.name\t\t \"platform\", \t.dev_groups\t platform_dev_groups, \t.match\t\t platform_match, \t.uevent\t\t platform_uevent, \t.dma_configure\t platform_dma_configure, \t.pm\t\t &platform_dev_pm_ops, }; int __init platform_bus_init(void) { ... \terror bus_register(&platform_bus_type); ... \treturn error; } ``` ###### platform_match()函数 设置匹配规则 ```c static int platform_match(struct device *dev, struct device_driver *drv) { \tstruct platform_device *pdev to_platform_device(dev); \tstruct platform_driver *pdrv to_platform_driver(drv); \t/* When driver_override is set, only bind to the matching driver */ \tif (pdev >driver_override) \t\treturn !strcmp(pdev >driver_override, drv >name); \t/* Attempt an OF style match first 设备树的匹配 */ \tif (of_driver_match_device(dev, drv)) \t\treturn 1; \t/* Then try ACPI style match 比较少用 */ \tif (acpi_driver_match_device(dev, drv)) \t\treturn 1; \t/* Then try to match against the id table 进行名字和名字列表的匹配 */ \tif (pdrv >id_table) \t\treturn platform_match_id(pdrv >id_table, pdev) ! NULL; \t/* fall back to driver name match */ \treturn (strcmp(pdev >name, drv >name) 0); } ``` of_driver_match_device：设备树匹配 acpi_driver_match_device：ACPI匹配 platform_match_id：id_table匹配, platform_device里面的device_id记录一系列的name, 和platform里面的name进行匹配 strcmp(pdev >name, drv >name)：设备名和驱动名匹配 #### 平台设备注册 drivers/base/platform.c 设备树里面的配置会被系统处理以后调用注册 ##### platform_device_register()函数 ```c int platform_device_register(struct platform_device *pdev) ``` 继承device ###### resources结构体 描述驱动的硬件资源 start：资源的开始值 end：资源的结束值 flasg：资源的类型 IORESOURCE_MEM：内存地址 IORESOURCE_IO：IO端口 IORESOURCE_DMA：DMA传输 IORESOURCE_IRQ：中断 ### 驱动处理 #### 平台驱动注册 include/linux/platform_device.h ##### platform_driver_register()宏 ```c #define platform_driver_register(drv) \\ \t__platform_driver_register(drv, THIS_MODULE) extern int __platform_driver_register(struct platform_driver *, \t\t\t\t\tstruct module *); ``` ```c struct platform_driver { // 匹配以后执行 \tint (*probe)(struct platform_device *); \tint (*remove)(struct platform_device *); \tvoid (*shutdown)(struct platform_device *); \tint (*suspend)(struct platform_device *, pm_message_t state); \tint (*resume)(struct platform_device *); // 继承 \tstruct device_driver driver; \tconst struct platform_device_id *id_table; \tbool prevent_deferred_probe; }; ``` 实际匹配使用是`driver >of_device_id >compatible` ##### platform_driver_unregister ```c void platform_driver_unregister(struct platform_driver *drv) ``` #### 平台驱动获取资源 drivers/base/platform.c 对应的是比较早期的device配对方式, 之后使用设备树以后可以直接使用之前的of函数获取设备树信息 ##### platform_get_resource()函数 获取一个device的资源信息 ```c struct resource *platform_get_resource(struct platform_device *dev, unsigned int type, unsigned int num); struct resource *platform_get_resource_byname(struct platform_device *, unsigned int type, const char *name); ``` dev：平台设备 type：资源类型 num：resources数组中资源编号 > ```c > /* > * Resources are tree like, allowing > * nesting etc.. > */ > struct resource { > \tresource_size_t start; > \tresource_size_t end; > \tconst char *name; > \tunsigned long flags; > \tstruct resource *parent, *sibling, *child; > }; > ``` > > start 和 end 分别表示资源的起始和终止信息，对于内存类的资源，就表示内存起始和终止地址，name表示资源名字，flags表示资源类型, 记录在`/include/linux/ioport.h`里面 #### 获取设备树节点 ```c struct device_node *np pdev >dev.of_node; ``` ## 代码实现 ### device ```c #include <linux/init.h> #include <linux/module.h> #include <linux/mod_devicetable.h> #include <linux/platform_device.h> #define CCM_CCGR1 \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t 0x20C406C\t\t//时钟控制寄存器 #define IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO04 \t\t\t 0x20E006C\t //GPIO1_04复用功能选择寄存器 #define IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO04 \t\t\t 0x20E02F8\t //PAD属性设置寄存器 #define GPIO1_GDIR \t\t\t\t\t\t\t\t\t0x0209C004\t//GPIO方向设置寄存器（输入或输出） #define GPIO1_DR \t\t\t\t\t\t\t\t\t0x0209C000 //GPIO输出状态寄存器 #define REGISTER_LENGTH\t\t \t\t\t\t\t\t4\t\t\t//寄存器长度 /*定义平台设备的硬件资源列表*/ static struct resource rled_resource[] { \t \t[0] { \t\t.start \t GPIO1_DR, \t\t.end \t (GPIO1_DR + REGISTER_LENGTH 1), \t\t.flags \t IORESOURCE_MEM, \t},\t \t[1] { \t\t.start\t GPIO1_GDIR, \t\t.end\t (GPIO1_GDIR + REGISTER_LENGTH 1), \t\t.flags\t IORESOURCE_MEM, \t}, \t[2] { \t\t.start\t IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO04, \t\t.end\t (IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO04 + REGISTER_LENGTH 1), \t\t.flags\t IORESOURCE_MEM, \t}, \t[3] { \t\t.start\t CCM_CCGR1, \t\t.end\t (CCM_CCGR1 + REGISTER_LENGTH 1), \t\t.flags\t IORESOURCE_MEM, \t}, \t[4] { \t\t.start\t IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO04, \t\t.end\t (IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO04 + REGISTER_LENGTH 1), \t\t.flags\t IORESOURCE_MEM, \t}, }; /*释放paltform设备模块时执行*/ static void\trled_release(struct device *dev) { \tprintk(KERN_ALERT \"led device released!\\r\\n\");\t } /*定义平台设备*/ static struct platform_device rled_pdev { \t.name \"imx6ull rled\", // 使用名字进行匹配 \t.id 1, // 防止有多个同名的设备 \t.dev.release rled_release, \t.num_resources ARRAY_SIZE(rled_resource), // 记录元素的大小 \t.resource rled_resource, }; /*模块入口函数，注册平台设备*/ static __init int leddevice_init(void) { \tprintk(KERN_ALERT \"leddevice_init\\r\\n\"); \tplatform_device_register(&rled_pdev); \treturn 0; } /*模块退出函数，注销平台设备*/ static __exit void leddevice_exit(void) { \tplatform_device_unregister(&rled_pdev); } module_init(leddevice_init); module_exit(leddevice_exit); MODULE_LICENSE(\"GPL\"); MODULE_AUTHOR(\"embedfire \"); MODULE_DESCRIPTION(\"led_module\"); MODULE_ALIAS(\"led_module\"); ``` ### driver ```c #include <linux/module.h> #include <linux/init.h> #include <linux/kernel.h> #include <linux/fs.h> #include <linux/uaccess.h> #include <asm/io.h> #include <linux/mod_devicetable.h> #include <linux/platform_device.h> #include <linux/device.h> #define DEV_MAJOR\t\t0\t\t/* 动态申请主设备号 */ #define DEV_NAME\t\t\"red_led\" \t/*led设备名字 */ /* GPIO虚拟地址指针 */ static void __iomem *IMX6U_CCM_CCGR1; static void __iomem *SW_MUX_GPIO1_IO04; static void __iomem *SW_PAD_GPIO1_IO04; static void __iomem *GPIO1_DR; static void __iomem *GPIO1_GDIR; static int led_open(struct inode *inode, struct file *filp) { \treturn 0; } static ssize_t led_read(struct file *filp, char __user *buf, size_t cnt, loff_t *offt) { \treturn EFAULT; } static ssize_t led_write(struct file *filp, const char __user *buf, size_t cnt, loff_t *offt) { \tunsigned char databuf[10]; \tif(cnt >10) \t\tcnt 10; \t\t /*从用户空间拷贝数据到内核空间*/ if(copy_from_user(databuf, buf, cnt)){ \t\treturn EIO; \t} \t \tif(!memcmp(databuf,\"on\",2)) {\t \t\tiowrite32(0 << 4, GPIO1_DR);\t \t} else if(!memcmp(databuf,\"off\",3)) { \t\tiowrite32(1 << 4, GPIO1_DR); \t} \t/*写成功后，返回写入的字数*/ \treturn cnt; } static int led_release(struct inode *inode, struct file *filp) { \treturn 0; } /* 自定义led的file_operations 接口*/ static struct file_operations led_fops { \t.owner THIS_MODULE, \t.open led_open, \t.read led_read, \t.write led_write, \t.release \tled_release, }; int major 0; struct class *class_led; static int led_probe(struct platform_device *pdev) { \tstruct resource *mem_dr; \tstruct resource *mem_gdir; \tstruct resource *mem_iomuxc_mux; \tstruct resource *mem_ccm_ccgrx; \tstruct resource *mem_iomux_pad; \tprintk(KERN_ALERT \"led_probe\\r\\n\"); // 获取资源的地址 \tmem_dr platform_get_resource(pdev, IORESOURCE_MEM, 0); \tmem_gdir platform_get_resource(pdev, IORESOURCE_MEM, 1); \tmem_iomuxc_mux platform_get_resource(pdev, IORESOURCE_MEM, 2); \tmem_ccm_ccgrx platform_get_resource(pdev, IORESOURCE_MEM, 3); \tmem_iomux_pad platform_get_resource(pdev, IORESOURCE_MEM, 4); \t/* GPIO相关寄存器映射 */ \tIMX6U_CCM_CCGR1 ioremap(mem_ccm_ccgrx >start,resource_size(mem_ccm_ccgrx)); \tSW_MUX_GPIO1_IO04 ioremap(mem_iomuxc_mux >start,resource_size(mem_iomuxc_mux)); \tSW_PAD_GPIO1_IO04 ioremap(mem_iomux_pad >start,resource_size(mem_iomux_pad)); \tGPIO1_GDIR ioremap(mem_gdir >start, resource_size(mem_gdir)); \tGPIO1_DR ioremap(mem_dr >start, resource_size(mem_dr));\t \t\t \t\t \t/* 使能GPIO1时钟 */ \tiowrite32(0xffffffff, IMX6U_CCM_CCGR1); \t/* 设置GPIO1_IO04复用为普通GPIO*/ \tiowrite32(5, SW_MUX_GPIO1_IO04); \t /*设置GPIO属性*/ \tiowrite32(0x10B0, SW_PAD_GPIO1_IO04); \t/* 设置GPIO1_IO04为输出功能 */ \tiowrite32(1 << 4, GPIO1_GDIR); \t/* LED输出高电平 */ \tiowrite32(1<< 4, GPIO1_DR);\t \t/* 注册字符设备驱动 */ \tmajor register_chrdev(DEV_MAJOR, DEV_NAME, &led_fops); printk(KERN_ALERT \"led major:%d\\n\",major); \t/*创建/sys/class/xxx目录项*/ \tclass_led class_create(THIS_MODULE, \"xxx\"); \t/*创建/sys/class/xxx/my_led目录项，并生成dev属性文件*/ \tdevice_create(class_led, NULL, MKDEV(major, 0), NULL,\"my_led\"); \treturn 0; } static int led_remove(struct platform_device *dev) { \t\t/* 取消映射 */ \tiounmap(IMX6U_CCM_CCGR1); \tiounmap(SW_MUX_GPIO1_IO04); \tiounmap(SW_PAD_GPIO1_IO04); \tiounmap(GPIO1_DR); \tiounmap(GPIO1_GDIR); \t/* 注销字符设备驱动 */ \tunregister_chrdev(major, DEV_NAME); \t/*销毁/sys/class/xxx/my_led目录项*/ \tdevice_destroy(class_led, MKDEV(major, 0)); \t/*销毁/sys/class/xxx目录项*/ \tclass_destroy(class_led); \treturn 0; } /*与平台设备文件名匹配*/ static struct platform_device_id led_ids[] { \t{.name \"imx6ull rled\"}, \t{} }; /*定义平台驱动*/ static struct platform_driver led_driver { \t.driver.name \"imx6ull rled\", \t.probe\t led_probe, \t.remove\t led_remove, \t.id_table led_ids, // 匹配的一系列id }; /*模块入口函数，注册平台驱动*/ static int __init leddriver_init(void) { \tprintk(KERN_ALERT \"leddriver_init\\r\\n\"); \treturn platform_driver_register(&led_driver); } /*模块退出函数，注销平台驱动*/ static void __exit leddriver_exit(void) { \tplatform_driver_unregister(&led_driver); } module_init(leddriver_init ); module_exit(leddriver_exit); MODULE_LICENSE(\"GPL\"); MODULE_AUTHOR(\"embedfire \"); MODULE_DESCRIPTION(\"led_module\"); MODULE_ALIAS(\"led_module\"); ``` ![image 20250903203244949](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509032032049.png)"},"/note/Linux/野火Linux/2025-11-12-66-信号.html":{"title":"信号","content":"# 信号 ## 使用 + 初始化afsync操作函数, 初始化fasync_struct, 记录可以通知的进程 + 使用kill_fasync函数发送信号 + 应用注册对应的信号处理函数 + 使用fcntl通知驱动开启捕获 ## 介绍 使用阻塞或者非阻塞的方式来读取驱动中按键值都是应用程序主动读取的，对于非阻塞方式来说还需要应用程序通过 poll函数不断的轮询。最好的方式就是驱动程序能主动向应用程序发出通知，报告自己可以访问，然后应用程序在从驱动程序中读取或写入数据，类似于我们在裸机例程中讲解的中断 驱动可以通过主动向应用程序发送信号的方式来报告自己可以访问了，应用程序获取到信号以后就可以从驱动设备中读取或者写入数据了。整个过程就相当于应用程序收到了驱动发送过来了的一个中断，然后应用程序去响应这个中断 可以使用的中断如下 ```c #define SIGHUP\t\t 1 \t/* 终端挂起或控制进程终止 */ #define SIGINT\t\t 2\t/* 终端中断(Ctrl+C组合键) */ #define SIGQUIT\t\t 3\t/* 终端退出(Ctrl+\\组合键) */ #define SIGILL\t\t 4\t/* 非法指令 */ #define SIGTRAP\t\t 5\t/* debug使用，有断点指令产生 */ #define SIGABRT\t\t 6\t/* 由 abort(3)发出的退出指令 */ #define SIGIOT\t\t 6\t/* IOT指令 */ #define SIGBUS\t\t 7\t/* 总线错误 */ #define SIGFPE\t\t 8\t/* 浮点运算错误 */ #define SIGKILL\t\t 9\t/* 杀死、终止进程 */ #define SIGUSR1\t\t10\t/* 用户自定义信号 1 */ #define SIGSEGV\t\t11\t/* 段违例(无效的内存段) */ #define SIGUSR2\t\t12\t/* 用户自定义信号 2 */ #define SIGPIPE\t\t13\t/* 向非读管道写入数据 */ #define SIGALRM\t\t14\t/* 闹钟 */ #define SIGTERM\t\t15\t/* 软件终止 */ #define SIGSTKFLT\t16\t/* 栈异常 */ #define SIGCHLD\t\t17\t/* 子进程结束 */ #define SIGCONT\t\t18\t/* 进程继续 */ #define SIGSTOP\t\t19\t/* 停止进程的执行，只是暂停 */ #define SIGTSTP\t\t20\t/* 停止进程的运行(Ctrl+Z组合键) */ #define SIGTTIN\t\t21\t/* 后台进程需要从终端读取数据 */ #define SIGTTOU\t\t22\t/* 后台进程需要向终端写数据 */ #define SIGURG\t\t23\t/* 有\"紧急\"数据 */ #define SIGXCPU\t\t24\t/* 超过 CPU资源限制 */ #define SIGXFSZ\t\t25\t/* 文件大小超额 */ #define SIGVTALRM\t26\t/* 虚拟时钟信号 */ #define SIGPROF\t\t27\t/* 时钟信号描述 */ #define SIGWINCH\t28\t/* 窗口大小改变 */ #define SIGIO\t\t29\t\t/* 可以进行输入/输出操作 */ #define SIGPOLL\t\tSIGIO /* #define SIGLOST\t\t29 */ #define SIGPWR\t\t30\t/* 断点重启 */ #define SIGSYS\t\t31\t/* 非法的系统调用 */ #define\tSIGUNUSED\t31\t/* 未使用信号 */ /* These should not be considered constants from userland. */ #define SIGRTMIN\t32 #define SIGRTMAX\t(_NSIG 1) ``` 除了 SIGKILL(9)和 SIGSTOP(19)这两个信号不能被忽略外，其他的信号都可以忽略。这些信号就相当于中断号，不同的中断号代表了不同的中断，不同的中断所做的处理不同，因此，驱动程序可以通过向应用程序发送不同的信号来实现不同的功能 ## 使用的API ### 应用 #### 设置处理函数 ```c sighandler_t signal(int signum, sighandler_t handler) ``` + **signum**：要设置处理函数的信号。 + **handler**：信号的处理函数。 设置成功的话返回信号的前一个处理函数，设置失败的话返回 SIG_ERR > ```c > typedef void (*sighandler_t)(int) > ``` #### 通知驱动开启 ```c fcntl(fd, F_SETOWN, getpid()); // 通知进程的pid flags fcntl(fd, F_GETFL); /* 获取当前的进程状态 */ fcntl(fd, F_SETFL, flags FASYNC); /* 开启当前进程异步通知功能 */ ``` 之后就可以设置信号捕获 ### 驱动 #### fasync_struct结构体 每个 `fasync_struct` 节点都包含了关键信息——**需要接收信号的进程的进程ID（PID）**。这样当事件发生时，驱动就知道该向谁发信号 ```c struct fasync_struct { spinlock_t fa_lock; int magic; int fa_fd; struct fasync_struct *fa_next; struct file *fa_file; struct rcu_head fa_rcu; }; ``` #### fasync开启异步通知 异步通知，需要在设备驱动中实现 file_operations 操作集中的 fasync 函数 驱动程序中的 `fasync` 函数是一个\"**注册与注销**\"函数。当应用程序希望启用或禁用异步 I/O 通知时，它通过 `fcntl` 系统调用间接地触发驱动中的这个函数，其核心任务就是更新驱动内部维护的\"订阅者列表\"（即 `fasync_struct` 链表） ```c int (*fasync) (int fd, struct file *filp, int on) ``` fasync 函数里面一般通过调用 fasync_helper 函数来初始化前面定义的 fasync_struct 结构体指针 ```c int fasync_helper(int fd, struct file * filp, int on, struct fasync_struct **fapp) ``` fasync_helper函数的前三个参数就是 fasync 函数的那三个参数，第四个参数就是要初始化的 fasync_struct 结构体指针变量。当应用程序通过`fcntl(fd, F_SETFL, flags FASYNC)`改变 fasync标记的时候，驱动程序 file_operations操作集中的fasync函数就会执行 在关闭驱动文件的时候需要在 file_operations 操作集中的 release 函数中释放 fasync_struct ```c xxx_fasync( 1, filp, 0); ``` ### 发送信号 ```c void kill_fasync(struct fasync_struct **fp, int sig, int band) ``` + **fp**：要操作的fasync_struct。 + **sig**：要发送的信号。 + **band**：可读时设置为POLL_IN，可写时设置为 POLL_OUT。"},"/note/Linux/野火Linux/2025-9-16-22-iomux节点(下).html":{"title":"","content":"## pinctl_setting：如何统一管理pin state ![image 20250916232218271](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509162322383.png) #### pinctl_map 保存了所有`pin state`所需要的`pin group`信息 #### pinctl_setting 把`pin group`信息按`pin state`分类保存 #### 目的 `pinctl_map` >`pinctl_setting` #### for_each_maps()宏 drivers/pinctrl/core.h ```c #define for_each_maps(_maps_node_, _i_, _map_) \\ \tlist_for_each_entry(_maps_node_, &pinctrl_maps, node) \\ \t\tfor (_i_ 0, _map_ &_maps_node_ >maps[_i_]; \\ \t\t\t_i_ < _maps_node_ >num_maps; \\ \t\t\t_i_++, _map_ &_maps_node_ >maps[_i_]) ``` > 一个两层的循环, 第一层的循环里面遍历所有的pinctrl_maps, 第二次遍历所有的pinctrl_map的所有引脚 #### add_setting()函数 drivers/pinctrl/core.c ```c static int add_setting(struct pinctrl *p, struct pinctrl_dev *pctldev, \t\t const struct pinctrl_map *map) {\t \tstruct pinctrl_state *state; \tstruct pinctrl_setting *setting; \t// 查找一下和map名字一样的pinctrl_state \tstate find_state(p, map >name); // 返回NULL \tif (!state) \t\tstate create_state(p, map >name); // 创建一下 \t... \tsetting kzalloc(sizeof(*setting), GFP_KERNEL); \tif (!setting) \t\treturn ENOMEM; \tsetting >type map >type; \tif (pctldev) \t\tsetting >pctldev pctldev; \telse \t\tsetting >pctldev \t\t\tget_pinctrl_dev_from_devname(map >ctrl_dev_name); \t setting >dev_name map >dev_name; switch (map >type) { \tcase PIN_MAP_TYPE_MUX_GROUP: // 第一个 \t\tret pinmux_map_to_setting(map, setting); \t\tbreak; \tcase PIN_MAP_TYPE_CONFIGS_PIN: \tcase PIN_MAP_TYPE_CONFIGS_GROUP: \t\tret pinconf_map_to_setting(map, setting); \t\tbreak; \tdefault: \t\tret EINVAL; \t\tbreak; \t} \t... \tlist_add_tail(&setting >node, &state >settings); \t \treturn 0; } ``` #### find_state()函数 drivers/pinctrl/core.c ```c static struct pinctrl_state *find_state(struct pinctrl *p, \t\t\t\t\tconst char *name) { \tstruct pinctrl_state *state; \t// 这个遍历的时候是没有数据的 \tlist_for_each_entry(state, &p >states, node) \t\tif (!strcmp(state >name, name)) \t\t\treturn state; \treturn NULL; } ``` #### create_state()函数 drivers/pinctrl/core.c ```c static struct pinctrl_state *create_state(struct pinctrl *p,const char *name) { \tstruct pinctrl_state *state; \tstate kzalloc(sizeof(*state), GFP_KERNEL); \tif (!state) \t\treturn ERR_PTR( ENOMEM); \tstate >name name; \tINIT_LIST_HEAD(&state >settings); \tlist_add_tail(&state >node, &p >states); \treturn state; } ``` #### pinmux_map_to_setting()函数 drivers/pinctrl/pinmux.c ![image 20250916233056589](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509162330628.png) 对一个map里面的节点的group和基数树里面的function以及对应的group进行对应 ```c int pinmux_map_to_setting(const struct pinctrl_map *map,struct pinctrl_setting *setting) { \tstruct pinctrl_dev *pctldev setting >pctldev; \t//imx_pmx_ops, 对应的是pinmux_ops \tconst struct pinmux_ops *pmxops pctldev >desc >pmxops; \tchar const * const *groups; \tunsigned num_groups; \tint ret; \tconst char *group; \t... // 使用map的function名字获取对应的function的编号 \tret pinmux_func_name_to_selector(pctldev, map >data.mux.function); \t... \t/*function的索引*/ \tsetting >data.mux.func ret; \t// 对应pinmux_generic_get_function_groups函数, 获取对应的所有group的名字以及总数 \tret pmxops >get_function_groups(pctldev, setting >data.mux.func,&groups, &num_groups); \t \tif (map >data.mux.group) { \t\t// map节点的group节点名进行比对 \t\tgroup map >data.mux.group; \t\tret match_string(groups, num_groups, group); \t\t... \t\t} \t} else { \t\tgroup groups[0]; \t} \t// 获取一下group在基数树的对应编号 \tret pinctrl_get_group_selector(pctldev, group); \t... \tsetting >data.mux.group ret; \t... } ``` #### pinmux_func_name_to_selector()函数 drivers/pinctrl/pinmux.c 使用map记录的function名字获取对应的function的编号, 这里获取的是唯一的一个function编号0 ```c static int pinmux_func_name_to_selector(struct pinctrl_dev *pctldev, \t\t\t\t\tconst char *function) { \tconst struct pinmux_ops *ops pctldev >desc >pmxops; \t//imx_pmx_ops, 实际对应的函数是pinmux_generic_get_function_count \tunsigned nfuncs ops >get_functions_count(pctldev); // 获取到function层的数量, 是1 \tunsigned selector 0; \twhile (selector < nfuncs) { // 对应pinmux_generic_get_function_name, 获取基数树上面的function的名字 \t\tconst char *fname ops >get_function_name(pctldev, selector); // 实际是对比一下iomux节点的名字, 对比是成立的, 返回0 \t\tif (!strcmp(function, fname)) \t\t\treturn selector; \t\tselector++; \t} \treturn EINVAL; } ``` #### pinmux_generic_get_function_count()函数 drivers/pinctrl/pinmux.c ```c int pinmux_generic_get_function_count(struct pinctrl_dev *pctldev) { \treturn pctldev >num_functions; } ``` #### pinmux_generic_get_function_name()函数 drivers/pinctrl/pinmux.c ```c const char * pinmux_generic_get_function_name(struct pinctrl_dev *pctldev, \t\t\t\t unsigned int selector) { \tstruct function_desc *function; \tfunction radix_tree_lookup(&pctldev >pin_function_tree, \t\t\t\t selector); \tif (!function) \t\treturn NULL; \treturn function >name; } ``` #### pinmux_generic_get_function_groups()函数 drivers/pinctrl/pinmux.c 查找function里面对应的group的名字链表 ```c int pinmux_generic_get_function_groups(struct pinctrl_dev *pctldev, \t\t\t\t unsigned int selector, \t\t\t\t const char * const **groups, \t\t\t\t unsigned * const num_groups) { \tstruct function_desc *function; \tfunction radix_tree_lookup(&pctldev >pin_function_tree,selector); \tif (!function) { \t\tdev_err(pctldev >dev, \"%s could not find function%i\\n\",__func__, selector); \t\treturn EINVAL; \t} \t*groups function >group_names; \t*num_groups function >num_group_names; \treturn 0; } ``` #### pinctrl_get_group_selector()函数 drivers/pinctrl/core.c 依据引脚group的名字获取一下group在基数树的对应编号 ![image 20250916234626214](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509162346264.png) ```c int pinctrl_get_group_selector(struct pinctrl_dev *pctldev,const char *pin_group) { \tconst struct pinctrl_ops *pctlops pctldev >desc >pctlops; // pinctrl_generic_get_group_count函数, 获取所有的group的数量 \tunsigned ngroups pctlops >get_groups_count(pctldev); \tunsigned group_selector 0; \twhile (group_selector < ngroups) { // 遍历所有的group, pinctrl_generic_get_group_name, 在基数树使用编号获取名字 \t\tconst char *gname pctlops >get_group_name(pctldev, \t\t\t\t\t\t\t group_selector); \t\tif (gname && !strcmp(gname, pin_group)) { \t\t\tdev_dbg(pctldev >dev, \t\t\t\t\"found group selector %u for %s\\n\", \t\t\t\tgroup_selector, \t\t\t\tpin_group); \t\t\treturn group_selector; \t\t} \t\tgroup_selector++; \t} \tdev_err(pctldev >dev, \"does not have pin group %s\\n\", \t\tpin_group); \treturn EINVAL; } ``` #### pinctrl_generic_get_group_count()函数 ```c int pinctrl_generic_get_group_count(struct pinctrl_dev *pctldev) { \treturn pctldev >num_groups; } ``` #### pinctrl_generic_get_group_name()函数 ```c const char *pinctrl_generic_get_group_name(struct pinctrl_dev *pctldev, \t\t\t\t\t unsigned int selector) { \tstruct group_desc *group; \tgroup radix_tree_lookup(&pctldev >pin_group_tree, \t\t\t\t selector); \tif (!group) \t\treturn NULL; \treturn group >name; } ``` #### pinconf_map_to_setting()函数 其他的引脚的处理函数 ```c int pinconf_map_to_setting(const struct pinctrl_map *map, \t\t\t struct pinctrl_setting *setting) { \tstruct pinctrl_dev *pctldev setting >pctldev; \tint pin; \tswitch (setting >type) { \tcase PIN_MAP_TYPE_CONFIGS_PIN: // 使用引脚名字获取引脚的编号 \t\tpin pin_get_from_name(pctldev, \t\t\t\t\tmap >data.configs.group_or_pin); \t\tif (pin < 0) { \t\t\tdev_err(pctldev >dev, \"could not map pin config for \\\"%s\\\"\", \t\t\t\tmap >data.configs.group_or_pin); \t\t\treturn pin; \t\t} \t\tsetting >data.configs.group_or_pin pin; \t\tbreak; \t\t... \t} \tsetting >data.configs.num_configs map >data.configs.num_configs; \tsetting >data.configs.configs map >data.configs.configs; \t... } ``` ```c int pin_get_from_name(struct pinctrl_dev *pctldev, const char *name) { \tunsigned i, pin; \t/* The pin number can be retrived from the pin controller descriptor */ \tfor (i 0; i < pctldev >desc >npins; i++) { \t\tstruct pin_desc *desc; \t\tpin pctldev >desc >pins[i].number; \t\tdesc pin_desc_get(pctldev, pin); \t\t/* Pin space may be sparse */ \t\tif (desc && !strcmp(name, desc >name)) \t\t\treturn pin; \t} \treturn EINVAL; } ``` ```c static inline struct pin_desc *pin_desc_get(struct pinctrl_dev *pctldev, \t\t\t\t\t unsigned int pin) { \treturn radix_tree_lookup(&pctldev >pin_desc_tree, pin); } ``` ## pinctrl子系统的引脚设置接口 #### pinctrl子系统对外接口 ##### 状态查询接口 pinctrl_lookup_state ##### 状态设置接口 pinctrl_select_state ##### 状态类型 ``` #define PINCTRL_STATE_DEFAULT \"default\" #define PINCTRL_STATE_INIT \"init\" #define PINCTRL_STATE_IDLE \"idle\" #define PINCTRL_STATE_SLEEP \"sleep\" ``` #### 函数原型 #### pinctrl_lookup_state()函数 drivers/pinctrl/core.c 查找一下这个状态是不是存在, 不是的话, 创建一下, 是的话返回这个结构体 ```c struct pinctrl_state *pinctrl_lookup_state(struct pinctrl *p, \t\t\t\t\t\t const char *name) { \tstruct pinctrl_state *state; \tstate find_state(p, name); \tif (!state) { \t\tif (pinctrl_dummy_state) { \t\t\t/* create dummy state */ \t\t\tdev_dbg(p >dev, \"using pinctrl dummy state (%s)\\n\", \t\t\t\tname); \t\t\tstate create_state(p, name); \t\t} else \t\t\tstate ERR_PTR( ENODEV); \t} \treturn state; } ``` #### find_state()函数 drivers/pinctrl/core.c 实际的查找函数 ```c static struct pinctrl_state *find_state(struct pinctrl *p,const char *name) { \tstruct pinctrl_state *state; \tlist_for_each_entry(state, &p >states, node) \t\tif (!strcmp(state >name, name)) \t\t\treturn state; \treturn NULL; } ``` #### pinctrl_select_state()函数 drivers/pinctrl/core.c ```c int pinctrl_select_state(struct pinctrl *p, struct pinctrl_state *state) { \tif (p >state state) \t\treturn 0; \treturn pinctrl_commit_state(p, state); } ``` #### pinctrl_commit_state()函数 drivers/pinctrl/core.c ```c static int pinctrl_commit_state(struct pinctrl *p, struct pinctrl_state *state) { \tstruct pinctrl_setting *setting, *setting2; \tstruct pinctrl_state *old_state p >state; \tint ret; \t \t... \t \tlist_for_each_entry(setting, &state >settings, node) { // 遍历所有的谁知 \t\tswitch (setting >type) { \t\tcase PIN_MAP_TYPE_MUX_GROUP: // 设置复用 \t\t\tret pinmux_enable_setting(setting); \t\t\tbreak; \t\tcase PIN_MAP_TYPE_CONFIGS_PIN: \t\tcase PIN_MAP_TYPE_CONFIGS_GROUP: \t\t\t// 设置实际的属性 ret pinconf_apply_setting(setting); \t\t\tbreak; \t\tdefault: \t\t\tret EINVAL; \t\t\tbreak; \t\t} ``` #### pinmux_enable_setting()函数 处理一个Setting的第一项, 是一个group的设置 ![image 20250917143615707](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509171436757.png) ![image 20250917143407593](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509171434643.png) ```c int pinmux_enable_setting(const struct pinctrl_setting *setting) { \tstruct pinctrl_dev *pctldev setting >pctldev; \tconst struct pinctrl_ops *pctlops pctldev >desc >pctlops; \tconst struct pinmux_ops *ops pctldev >desc >pmxops; \tint ret 0; \tconst unsigned *pins NULL; \tunsigned num_pins 0; \tint i; \tstruct pin_desc *desc; \t \tif (pctlops >get_group_pins) // 获取对应的group里面的引脚的编号以及数量 \t\tret pctlops >get_group_pins(pctldev, setting >data.mux.group,&pins, &num_pins); \t... // \tret ops >set_mux(pctldev, setting >data.mux.func, \t\t\t setting >data.mux.group); \t... } ``` #### pinctrl_generic_get_group_pins()函数 drivers/pinctrl/pinmux.c 获取对应的group里面的引脚的编号以及数量 ```c int pinctrl_generic_get_group_pins(struct pinctrl_dev *pctldev, \t\t\t\t unsigned int selector, \t\t\t\t const unsigned int **pins, \t\t\t\t unsigned int *num_pins) { \tstruct group_desc *group; \tgroup radix_tree_lookup(&pctldev >pin_group_tree, \t\t\t\t selector); \tif (!group) { \t\tdev_err(pctldev >dev, \"%s could not find pingroup%i\\n\", \t\t\t__func__, selector); \t\treturn EINVAL; \t} \t*pins group >pins; \t*num_pins group >num_pins; \treturn 0; } ``` #### imx_pmx_set()函数 drivers/pinctrl/freescale/pinctrl imx.c ```c static int imx_pmx_set(struct pinctrl_dev *pctldev, unsigned selector,unsigned group) { \tstruct imx_pinctrl *ipctl pinctrl_dev_get_drvdata(pctldev); \tunsigned int npins; \tconst struct imx_pinctrl_soc_info *info ipctl >info; \tint i, err; \tstruct group_desc *grp NULL; \tstruct function_desc *func NULL; \t/* \t * Configure the mux mode for each pin in the group for a specific \t * function. \t */ // 基数树获取一下对应的group \tgrp pinctrl_generic_get_group(pctldev, group); \tif (!grp) \t\treturn EINVAL; \t// 基数树获取对应的function结构体 \tfunc pinmux_generic_get_function(pctldev, selector); \tif (!func) \t\treturn EINVAL; \tnpins grp >num_pins; \tdev_dbg(ipctl >dev, \"enable function %s group %s\\n\", \t\tfunc >name, grp >name); \tfor (i 0; i < npins; i++) { // 遍历group的所有引脚 \t\tstruct imx_pin *pin &((struct imx_pin *)(grp >data))[i]; \t\tif (info >flags & IMX8_USE_SCU) \t\t\terr imx_pmx_set_one_pin_scu(ipctl, pin); \t\telse // 实际执行的位置 \t\t\terr imx_pmx_set_one_pin_mem(ipctl, pin); \t\tif (err) \t\t\treturn err; \t} \treturn 0; } ``` #### imx_pmx_set_one_pin_mem()函数 drivers/pinctrl/freescale/pinctrl memmap.c ```c int imx_pmx_set_one_pin_mem(struct imx_pinctrl *ipctl, struct imx_pin *pin) { \tconst struct imx_pinctrl_soc_info *info ipctl >info; // 获取引脚的编号 \tunsigned int pin_id pin >pin; \tstruct imx_pin_reg *pin_reg; \tstruct imx_pin_memmap *pin_memmap; // 获取他的对应的寄存器描述数组, 复用寄存器以及属性寄存器 \tpin_reg &ipctl >pin_regs[pin_id]; // 获取各项具体的值 \tpin_memmap &pin >pin_conf.pin_memmap; \t \tif (info >flags & SHARE_MUX_CONF_REG) { \t\tu32 reg; \t\treg readl(ipctl >base + pin_reg >mux_reg); \t\treg & ~info >mux_mask; \t\treg (pin_memmap >mux_mode << info >mux_shift); \t\twritel(reg, ipctl >base + pin_reg >mux_reg); \t\tdev_dbg(ipctl >dev, \"write: offset 0x%x val 0x%x\\n\", \t\t\tpin_reg >mux_reg, reg); \t} else { // 执行的位置, 写入数据 \t\twritel(pin_memmap >mux_mode, ipctl >base + pin_reg >mux_reg); \t\tdev_dbg(ipctl >dev, \"write: offset 0x%x val 0x%x\\n\", \t\t\tpin_reg >mux_reg, pin_memmap >mux_mode); \t} \t... } ``` #### 引脚的部分 ![image 20250917191649873](C:\\Users\\14586\\AppData\\Roaming\\Typora\\typora user images\\image 20250917191649873.png) ```c int pinconf_apply_setting(const struct pinctrl_setting *setting) { \tstruct pinctrl_dev *pctldev setting >pctldev; \tconst struct pinconf_ops *ops pctldev >desc >confops; \tint ret; \tif (!ops) { \t\tdev_err(pctldev >dev, \"missing confops\\n\"); \t\treturn EINVAL; \t} \tswitch (setting >type) { \tcase PIN_MAP_TYPE_CONFIGS_PIN: \t\tif (!ops >pin_config_set) { \t\t\tdev_err(pctldev >dev, \"missing pin_config_set op\\n\"); \t\t\treturn EINVAL; \t\t} // 写入实际的寄存器 \t\tret ops >pin_config_set(pctldev, \t\t\t\tsetting >data.configs.group_or_pin, \t\t\t\tsetting >data.configs.configs, \t\t\t\tsetting >data.configs.num_configs); \t\tif (ret < 0) { \t\t\tdev_err(pctldev >dev, \t\t\t\t\"pin_config_set op failed for pin %d\\n\", \t\t\t\tsetting >data.configs.group_or_pin); \t\t\treturn ret; \t\t} \t\tbreak; \tcase PIN_MAP_TYPE_CONFIGS_GROUP: \t\tif (!ops >pin_config_group_set) { \t\t\tdev_err(pctldev >dev, \t\t\t\t\"missing pin_config_group_set op\\n\"); \t\t\treturn EINVAL; \t\t} \t\tret ops >pin_config_group_set(pctldev, \t\t\t\tsetting >data.configs.group_or_pin, \t\t\t\tsetting >data.configs.configs, \t\t\t\tsetting >data.configs.num_configs); \t\tif (ret < 0) { \t\t\tdev_err(pctldev >dev, \t\t\t\t\"pin_config_group_set op failed for group %d\\n\", \t\t\t\tsetting >data.configs.group_or_pin); \t\t\treturn ret; \t\t} \t\tbreak; \tdefault: \t\treturn EINVAL; \t} \treturn 0; } ``` ```c static int imx_pinconf_set(struct pinctrl_dev *pctldev, \t\t\t unsigned pin_id, unsigned long *configs, \t\t\t unsigned num_configs) { \tstruct imx_pinctrl *ipctl pinctrl_dev_get_drvdata(pctldev); \tconst struct imx_pinctrl_soc_info *info ipctl >info; \tif (info >flags & IMX8_USE_SCU) \t\treturn imx_pinconf_backend_set_scu(pctldev, pin_id, configs, num_configs); \telse \t\treturn imx_pinconf_backend_set_mem(pctldev, pin_id, configs, num_configs); } ``` ```c int imx_pinconf_backend_set_mem(struct pinctrl_dev *pctldev, \t\t\t unsigned pin_id, unsigned long *configs, \t\t\t unsigned num_configs) { \tstruct imx_pinctrl *ipctl pinctrl_dev_get_drvdata(pctldev); \tconst struct imx_pinctrl_soc_info *info ipctl >info; \tconst struct imx_pin_reg *pin_reg &ipctl >pin_regs[pin_id]; \tint i; \tif (pin_reg >conf_reg 1) { \t\tdev_err(ipctl >dev, \"Pin(%s) does not support config function\\n\", \t\t\tinfo >pins[pin_id].name); \t\treturn EINVAL; \t} \tdev_dbg(ipctl >dev, \"pinconf set pin %s\\n\", \t\tinfo >pins[pin_id].name); \tfor (i 0; i < num_configs; i++) { \t\tif (info >flags & SHARE_MUX_CONF_REG) { \t\t\tu32 reg; \t\t\treg readl(ipctl >base + pin_reg >conf_reg); \t\t\treg & info >mux_mask; \t\t\treg configs[i]; \t\t\twritel(reg, ipctl >base + pin_reg >conf_reg); \t\t\tdev_dbg(ipctl >dev, \"write: offset 0x%x val 0x%x\\n\", \t\t\t\tpin_reg >conf_reg, reg); \t\t} else { \t\t\twritel(configs[i], ipctl >base + pin_reg >conf_reg); \t\t\tdev_dbg(ipctl >dev, \"write: offset 0x%x val 0x%lx\\n\", \t\t\t\tpin_reg >conf_reg, configs[i]); \t\t} \t} /* for each config */ \treturn 0; } ```"},"/note/Linux/野火Linux/2025-7-14-09-串口.html":{"title":"串口通信实验","content":"# 串口通信实验 ## 相关寄存器 UART1时钟源 CCM_CSCDR1 初始化 UART1 UART1_UCR1：使能uart1、自动波特率 UART1_UCR2：设置串口的发送帧格式 奇偶校验位、软件复位 数据长度 发送完成标志、数据接受标志 发送使能、接收使能 UART1_UCR3：bit2置1，官方要求设置 UART1_UFCR：时钟分频、发送与接收的 fifo大小 UART1_UBIR、UART1_UBMR：波特率 ![image 20250714182046876](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507141820901.png) 收发数据 UART1_UTXD ：发送一个字符 UART1_URXD ：接受一个字符 #### makefile修改 官方sdk的设置波特率函数使用了除法，需要提供gcc除法库 ``` LIBPATH : lgcc static L/usr/lib/gcc/arm none eabi/6.3.1 ``` lgcc 表示会链接“libgcc.a”库 static L 表示静态库所在路径"},"/note/Linux/野火Linux/2025-9-28-39-PWM.html":{"title":"","content":"## Linux PWM驱动实验 ##### PWM控制 脉冲宽度调制 ##### PWM信号 ![image 20200924141256029](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509281948036.png) ##### 相关寄存器 Chapter 40 Pulse Width Modulation(PWM)主要需要关注的部分如下 PWMx_PWMPR：频率 PWMx_PWMSAR：占空比 #### 硬件原理图 EBF6ULL pro开发板 RGB红灯 #### 设备树节点 pwm1~pwm8 ##### pwm3子节点 arch/arm/boot/dts/imx6ull.dtsi ```json pwm3: pwm@2088000 { \t\t\t\tcompatible \"fsl,imx6ul pwm\", \"fsl,imx27 pwm\"; \t\t\t\treg <0x2088000 0x4000>; \t\t\t\tinterrupts <GIC_SPI 85 IRQ_TYPE_LEVEL_HIGH>; \t\t\t\tclocks <&clks IMX6UL_CLK_PWM3>, \t\t\t\t\t <&clks IMX6UL_CLK_PWM3>; \t\t\t\tclock names \"ipg\", \"per\"; \t\t\t\t#pwm cells <2>; \t\t\t}; ``` ##### iomuxc子节点 ```c red_led_pwm: ledsgrp { \t \tfsl,pins < \t \t\tMX6UL_PAD_GPIO1_IO04__PWM3_OUT 0x1b0b0 \t \t>; \t\t\t}; ``` ##### red_led_pwm子节点 arch/arm/boot/dts/imx6ull seeed npi.dts ```c red_led_pwm { \t \tcompatible \"red_led_pwm\"; \t \tpinctrl names \"default\"; \t \tpinctrl 0 <&red_led_pwm>; \t \txxx { \t\t\t\t\tpwm names \"red_led_pwm3\"; // 起一个别名 \t \t\tpwms <&pwm3 0 50000>; // 指定使用的pwm3, 使用端口0, 周期是50000 \t \t}; }; ``` pwm names：给指定一路pwm起别名 pwms： pwm3：指定使用第3路pwm信号 0：pwm3引脚端口号 50000：设置周期，单位ns #### pwm_device结构体 include/linux/pwm.h ```c struct pwm_device { \tconst char *label; \tunsigned long flags; \tunsigned int hwpwm; \tunsigned int pwm; \tstruct pwm_chip *chip; \tvoid *chip_data; \tstruct pwm_args args; \tstruct pwm_state state; // 记录状态 }; ``` ##### pwm_state结构体 include/linux/pwm.h ```c struct pwm_state { \tunsigned int period; // 周期us \tunsigned int duty_cycle; // 占空比 \tenum pwm_polarity polarity; // 模式 \tbool enabled; // 使能 }; ``` period：pwm的周期 duty_cycle：pwm占空比 polarity：是否反相输出 enable：使能标志位 ##### pwm_polarity枚举变量 include/linux/pwm.h ```c enum pwm_polarity { PWM_POLARITY_NORMAL,\t//正常模式，不反相 PWM_POLARITY_INVERSED,\t//反相输出 }; ``` #### 获取pwm_device ##### devm_of_pwm_get()函数 drivers/pwm/core.c 解析pwm设备树节点信息，生成pwm_device对象 ```c struct pwm_device *devm_of_pwm_get(struct device *dev, struct device_node *np,const char *con_id) ``` 参数： dev：使用pwm的设备 np：pwm设备子节点 (这个示例里面是那个xxx的子节点) con_id：设备树节点\"pwm names\"匹配名 返回值： 成功：pwm_device结构体指针 失败：负数 #### 配置pwm频率和占空比 ##### pwm_config()函数 include/linux/pwm.h ```c static inline int pwm_config(struct pwm_device *pwm, int duty_ns, \t\t\t int period_ns) ``` 参数： pwm：pwm_device对象 duty_ns：高电平持续时间，单位ns period_ns：周期时间，单位ns 返回值： 成功：0 失败：负数 #### 配置pwm极性 ```c static inline int pwm_set_polarity(struct pwm_device *pwm, \t\t\t\t enum pwm_polarity polarity) ``` 参数： pwm：pwm_device对象 polarity： 返回值： 成功：0 失败：负数 #### 使能pwm输出 ```c static inline int pwm_enable(struct pwm_device *pwm) ``` 参数： pwm：pwm_device对象 返回值： 成功：0 失败：负数 #### 禁止pwm输出 ```c static inline void pwm_disable(struct pwm_device *pwm) ``` 参数： pwm：pwm_device对象 返回值：无"},"/note/Linux/野火Linux/2025-10-28-58-Uboot移植.html":{"title":"Uboot移植","content":"# Uboot移植 需要关注mx6ull_14x14_evk_emmc_defconfig 和 mx6ull_1 4x14_evk_nand_defconfig 这两个配置文件, 这两个是官方的启动文件 默认的时候, uboot是可以运行的, 但是屏幕的显示以及网络的连接是不可使用的 一般来说要可以使用SD卡, DRAM, 串口, EMMC, NAND等 ## 默认配置文件 复制一下mx6ull_14x14_evk_emmc_defconfig 这个文件, ```c CONFIG_SYS_EXTRA_OPTIONS \"IMX_CONFIG board/freescale/mx6ullevk/imximage.cfg,MX6ULL_EVK_EMMC_REWORK\" CONFIG_ARM y CONFIG_ARCH_MX6 y CONFIG_TARGET_MX6ULL_ALIENTEK_EMMC y CONFIG_CMD_GPIO y ``` 第一行使用的这个文件是镜像的头部的信息, 里面有DDR初始化之类的内容, 所以需要复制这个文件所在的文件夹, 改为自己的板子, 下面的板子选项也改一下 ```c CONFIG_SYS_EXTRA_OPTIONS \"IMX_CONFIG board/freescale/mx6ullevk/imximage ddr512.cfg,MX6ULL_EVK_EMMC_REWORK\" CONFIG_ARM y CONFIG_ARCH_MX6 y CONFIG_TARGET_MX6ULL_14X14_EVK y CONFIG_CMD_GPIO y ``` ## 对应的头文件 在目录`include/configs`下添加I.MX6ULL ALPHA开发板对应的头文件，复制`include/configs/mx6ullevk.h`，并重命名为`mx6ull_alientek_emmc.h` 主要功能就是配置或者裁剪uboot。如果需 要某个功能的话就在里面添加这个功能对应的CONFIG_XXX宏即可，如果不需要某个功能的 话就删除掉对应的宏即可 这个文件引用了mx6_common.h文件 ## 板级文件夹 所有板级文件夹都存放在`board/freescale`目录下, 复制mx6ullevk，将其重命名为mx6ull_alientek_emmc ### c文件 mx6ull_alientek_emmc目录中，将其中的`mx6ullevk.c`文件重命名为`mx6ull_alientek_emmc.c` ### Makefile 修改一下Makefile里面的配置, 设置为编译自己板子的.o文件 ### cfg文件 将imximage.cfg中的下面一句： `PLUGIN board/freescale/mx6ullevk/plugin.bin 0x00907000` 改为： `PLUGIN board/freescale/mx6ull_alientek_emmc /plugin.bin 0x00907000 ` ### Kconfig文件 使用` if TARGET_MX6ULL_ALIENTEK_EMMC` ```c if TARGET_MX6ULL_14X14_EVK TARGET_MX6ULL_9X9_EVK config SYS_BOARD \tdefault \"mx6ull_alientek_emmc\" config SYS_VENDOR \tdefault \"freescale\" config SYS_CONFIG_NAME \tdefault \"mx6ull_alientek_emmc\" endif ``` ### MAINTAINERS ``` MX6ULL_ALIENTEK_EMMC BOARD M: Peng Fan <peng.fan@nxp.com> S: Maintained F: board/freescale/mx6ull_alientek_emmc/ F: include/configs/mx6ull_alientek_emmc.h ``` ## 图形配置文件 修改文件`arch/arm/cpu/armv7/mx6/Kconfig`, 配置的是开始时候的config文件里面的板子名字00 ``` config TARGET_MX6ULL_ALIENTEK_EMMC bool \"Support mx6ull_alientek_emmc\" select MX6ULL select DM select DM_THERMAL ``` 在最后一行的endif的前一行添加`source \"board/freescale/mx6ull_alientek_emmc/Kconfig\" ` ## 驱动 主要需要关注的文件是在`board/freescale/mx6ullevk/`路径下面的.c文件以及在`include/configs`的.h文件 ### 显示 lcd_pads: 记录所有的 引脚使用的配置, 复用以及电器属性, 这部分不需要修改, 使用和官方一样的 ```c struct display_info_t const displays[] { { \t.bus MX6UL_LCDIF1_BASE_ADDR, // 外设寄存器的首地址 \t.addr 0, \t.pixfmt 24, \t.detect NULL, \t.enable\t do_enable_parallel_lcd, \t.mode\t { \t\t.name \"ATK LCD 10.1 1280x800\", \t\t.xres 1280, \t\t.yres 800, \t\t.pixclock 27123, // 是一个分频pixclock,51.2MHz的计算是pixclock (1/51200000)*10^12 19531 \t\t.left_margin 70, \t\t.right_margin 80, \t\t.upper_margin 10, \t\t.lower_margin 10, \t\t.hsync_len 10, \t\t.vsync_len 3, \t\t.sync 0, \t\t.vmode FB_VMODE_NONINTERLACED } }, \t... }; ``` > 这个结构体里面记录的一系列的屏幕的配置信息, 记录的是一系列的屏幕的参数, 改了以后烧录启动 > > 这个驱动需要和屏幕进行匹配, 设备的名字记录在环境变量里面, 需要把`panel`改为屏幕设置的名字, 可以在.h文件里面配置默认的环境变量 ### 网络 I.MX6UL/ULL 内部有个以太网MAC外设，也就是ENET，需要外接一个PHY芯片来实 现网络通信功能, 通信的速度比较快 在一些没有内部MAC的CPU中，比如三星的2440，4412等，就会采用DM9000来实 现联网功能。DM9000提供了一个类似SRAM的访问接口，主控CPU通过这个接口即可与DM9000进行通信, DM9000就是一个MAC+PHY芯片。 I.MX6UL/ULL 有两个网络接口ENET1和ENET2，正点原子的I.MX6U ALPHA开发板提供了这两个网络接口，其中ENET1和ENET2都使用LAN8720A作为PHY芯片 LAN8720A 内部是有寄存器的，I.MX6ULL 会读取 LAN8720 内部寄存器来判断当前的物 理链接状态、连接速度(10M还是100M)和双工状态(半双工还是全双工)。I.MX6ULL通过`MDIO`接口来读取PHY芯片的内部寄存器，`MDIO`接口有两个引脚，`ENET_MDC和ENET_MDIO`， `ENET_MDC`提供时钟，`ENET_MDIO`进行数据传输。一个MDIO接口可以管理32个PHY 芯片，同一个MDIO接口下的这些PHY使用不同的器件地址来做区分，MIDO接口通过不同的器件地址即可访问到相应的PHY芯片 I.MX6U ALPHA开发板ENET1上连接的LAN8720A器件地址为0X0, 另一个是0x1 还需要处理的是两个芯片使用的复位引脚和原来的开发板不同 ![image 20251028200957916](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510282010061.png) `ENET1`复位引脚 `ENET1_RST` 接到了I.M6ULL的`SNVS_TAMPER7`这个引脚, `ENET2`的复位引脚`ENET2_RST`接到了 I.MX6ULL 的`SNVS_TAMPER8`上 > 默认PHY芯片的前16位寄存器是一样的, 所以可以使用通用的驱动 + 更改一下使用的开发板的网络地址 ```c #define CONFIG_FEC_ENET_DEV\t\t1\t\t// 使用ENET2 #if (CONFIG_FEC_ENET_DEV 0) #define IMX_FEC_BASE\t\t\tENET_BASE_ADDR #define CONFIG_FEC_MXC_PHYADDR 0x2 /* alientek imx6ull alpha board version < 2.2, mini board < 1.8, CONFIG_FEC_MXC_PHYADDR 0x0 */ /* #define CONFIG_FEC_MXC_PHYADDR 0x0 */ #define CONFIG_FEC_XCV_TYPE RMII #elif (CONFIG_FEC_ENET_DEV 1) #define IMX_FEC_BASE\t\t\tENET2_BASE_ADDR #define CONFIG_FEC_MXC_PHYADDR\t\t0x1 // 使用这个网卡, 这里的数字是1 #define CONFIG_FEC_XCV_TYPE\t\tRMII #endif #define CONFIG_ETHPRIME\t\t\t\"FEC\" #define CONFIG_PHYLIB #define CONFIG_PHY_REALTEK #define CONFIG_PHY_SMSC #endif ``` 原厂的板子使用74LV595拓展引脚, 这里删除 ```c #define IOX_SDI IMX_GPIO_NR(5, 10) #define IOX_STCP IMX_GPIO_NR(5, 7) #define IOX_SHCP IMX_GPIO_NR(5, 11) #define IOX_OE IMX_GPIO_NR(5, 8) ``` 添加使用的复位引脚 ```c #define ENET1_RESET IMX_GPIO_NR(5, 7) #define ENET2_RESET IMX_GPIO_NR(5, 8) ``` > 使用这两个设备引脚的位置 同时把iox74lv_init相关的代码删除, 在函数setup_iomux_fec里面进行复位, 使用控制引脚的方式进行 uboot中的LAN8720A驱动有点问题，打开文件drivers/ net/phy/phy.c，找到函数genphy_update_link，这是个通用PHY驱动函数，此函数用于更新PHY的连接状态和速度。 在函数`genphy_update_link`添加一个软件复位 ```c #ifdef CONFIG_PHY_SMSC static int lan8720_flag 0; int bmcr_reg 0; if (lan8720_flag 0) { bmcr_reg phy_read(phydev, MDIO_DEVAD_NONE, MII_BMCR); // 获取一下寄存器 phy_write(phydev, MDIO_DEVAD_NONE, MII_BMCR, BMCR_RESET); // 软件复位 while(phy_read(phydev, MDIO_DEVAD_NONE, MII_BMCR) & 0X8000) { // 判断是否成功 udelay(100); } phy_write(phydev, MDIO_DEVAD_NONE, MII_BMCR, bmcr_reg); // 写回去之前的数值 lan8720_flag 1; } #endif ``` ### DDR u boot.imx会被添加镜像头, 在这部分进行DDR的初始化 使用的是./tool/mkimage的文件, 使用board/freescale/mu6ullevk/imximage.cfg.cfgtmp + u boot.bin生成, 从而获取u boot.imx文件 实际是根据`uboot\\board\\freescale\\mx6ullevk\\imximage.cfg`进行生成的, 使用NXP的DDR测试工具可以获取到DDR的校准参数 ## 其他 ### 板子的名字 在板子的.c文件里面, checkboard返回的是板子的名字 ## .h配置文件 可以在这个文件里面添加宏定义以及删除宏定义达到功能配置的作用, 同时还有配置一部分板子配置的作用 ## 配置项 + CONFIG_DISPLAY_CPUINFO: 显示CPU的信息 + PHYS_SDRAM_SIZE: 配置DDRAM的大小 + CONFIG_DISPLAY_BOARDINFO: 输出板子信息 + CONFIG_SYS_MALLOC_LEN: 内存池的大小 + CONFIG_BOARD_EARLY_INIT_F: 会调用`board_early_init_f`函数 + CONFIG_BOARD_LATE_INIT: 调用`board_late_init`函数 + CONFIG_MFG_ENV_SETTINGS: 使用Mfgtool烧录的时候使用的 + CONFIG_SYS_LOAD_ADDR: linux加载时候的地址 + CONFIG_SYS_HZ: 系统时钟的频率 + CONFIG_STACKSIZE: 栈大小 + CONFIG_SYS_MMC_ENV_DEV: 默认的MMC设备 + CONFIG_MMCROOT: 根文件系统在的分区 + CONFIG_ENV_SIZE: 环境变量的大小 + CONFIG_ENV_OFFSET: 环境变量的地址, 这个位置默认是啥也没有的, 在使用saveenv以后才记录在这里 + CONFIG_VIDEO: 开启LCD + CONFIG _VIDEO_LOGO: 使能LOGO显示 + CONFIG_CMD_BMP: 使能BMP图片显示指令 ### 环境变量 在.h文件里面可以设置板子的环境变量, `CONFIG_EXTRA_ENV_SETTINGS`这个变量定义默认的环境变量, 从SD卡或者EMMC之类的设备没有读取到的时候, 使用这个默认的环境变量 这部分会被记录在default_environment这个结构体里面 倒计时结束以后使用命令bootcmd #### bootcmd > ``` > Only needed when CONFIG_BOOTDELAY is enabled; > define a command string that is automatically executed > when no character is read on the console interface > within \"Boot Delay\" after reset. > ``` ```c #define CONFIG_BOOTCOMMAND \\ \t \"run findfdt;\" \\ \t \"mmc dev ${mmcdev};\" \\\t\t\t\t// 切换emmc1 \t \"mmc dev ${mmcdev}; if mmc rescan; then \" \\\t// 扫描判断设备是不是存在 \t\t \"if run loadbootscript; then \" \\ // 运行这里加载一下boot.src文件失败 \t\t\t \"run bootscript; \" \\\t \t\t \"else \" \\ \t\t\t \"if run loadimage; then \" \\ \t\t\t\t \"run mmcboot; \" \\ \t\t\t \"else run netboot; \" \\ \t\t\t \"fi; \" \\ \t\t \"fi; \" \\ \t \"else run netboot; fi\" // 使用网络启动 #endif ``` ```c \"findfdt \"\\ \"if test $fdt_file undefined; then \" \\ \"if test $board_name EVK && test $board_rev 9X9; then \" \\ \t\"setenv fdt_file imx6ull 9x9 evk.dtb; fi; \" \\ \"if test $board_name EVK && test $board_rev 14X14; then \" \\ \t\"setenv fdt_file imx6ull 14x14 evk.dtb; fi; \" \\ \"if test $fdt_file undefined; then \" \\ \t\"echo WARNING: Could not determine dtb to use; fi; \" \\ \"fi;\\0\" \\ ``` 根据板子的设置配置一下fdt_file设备树文件的名字, 如果board_name为EVK并且board_rev 14x14的话fdt_file就设置为imx6ull 14x14 evk.dtb ```c \"loadbootscript \" \\ \"fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${script};\\0\" \\ ``` > mmcdev 1，mmcpart 1，loadaddr 0x80800000，script boot.scr, 所以这个命令是`loadbootscript fatload mmc 1:1 0x80800000 boot.scr; `, 因为boot.src文件不存在，所以bootscript也就不会运行 此后运行 ```c \"loadimage fatload mmc ${mmcdev}:${mmcpart} ${loadaddr} ${image}\\0\" \\ ``` > `loadimage fatload mmc 1:1 0x80800000 zImage`加载设备的镜像文件 ```c \t\"mmcboot echo Booting from mmc ...; \" \\ \t\t\"run mmcargs; \" \\ \t\t\"if test ${boot_fdt} yes test ${boot_fdt} try; then \" \\ \t\t\t\"if run loadfdt; then \" \\ \t\t\t\t\"bootz ${loadaddr} ${fdt_addr}; \" \\ // 运行这里 \t\t\t\"else \" \\ \t\t\t\t\"if test ${boot_fdt} try; then \" \\ \t\t\t\t\t\"bootz; \" \\ \t\t\t\t\"else \" \\ \t\t\t\t\t\"echo WARN: Cannot load the DT; \" \\ \t\t\t\t\"fi; \" \\ \t\t\t\"fi; \" \\ \t\t\"else \" \\ \t\t\t\"bootz; \" \\ \t\t\"fi;\\0\" \\ ``` ```c \"mmcargs setenv bootargs console ${console},${baudrate} \" \\ CONFIG_BOOTARGS_CMA_SIZE \\ CONFIG_MFG_NAND_PARTITION \\ \"root ${mmcroot}\\0\" \\ ``` > 设置bootargs, 设置之后启动以后Linux使用的设备 ```c \"loadfdt fatload mmc ${mmcdev}:${mmcpart} ${fdt_addr} ${fdt_file}\\0\" \\ ``` > `loadfdt fatload mmc 1:1 0x83000000 imx6ull 14x14 evk.dtb`加载设备树文件 #### bootargs bootargs 保存着uboot传递给 Linux 内核的参数，在上一小节讲解bootcmd的时候说过，bootargs环境变量是由mmcargs设置的 ```c \"mmcargs setenv bootargs console ${console},${baudrate} \" \\ CONFIG_BOOTARGS_CMA_SIZE \\ CONFIG_MFG_NAND_PARTITION \\ \"root ${mmcroot}\\0\" \\ ``` ````c \"mmcargs setenv bootargs console ttymxc0,115200\" \\ \"\" \\ \"\" \\ \"root /dev/mmcblk1p2 rootwait rw\\0\" \\ ```` > console: 用来设置linux终端(或者叫控制台)，也就是通过什么设备来和Linux进行交互, 是串口还是LCD屏幕, 设置ttymxc0(串口1)作为Linux的终端，并且串口波特率设置为115200 > > root: 根文件系统存放在mmcblk1设备的分区2中 > > rootwait 表示等待 mmc设备初始化完成以后再挂载，否则的话 mmc设备还没初始化完成就挂载根文件系统会出错的。rw表示根文件系统是可以读写的 > > rootfstype: 于指定根文件系统类型，如果根文件系统为e xt 格式的话此选项无所谓。如果根文件系统是yaffs、jffs或ubifs的话就需要设置此选项"},"/note/Linux/野火Linux/2025-9-28-38-电容触摸屏.html":{"title":"","content":"## 电容触摸屏驱动简介 ## 使用 使用i2c驱动, 初始化中断引脚, 读取设备数据, 在中断里面上报input子系统 ## 简介 #### 硬件接口 SCL、SDA信号线：IIC接口，读取坐标信息 INT信号线：检测触摸信号，产生外部中断 RST信号线：复位触摸芯片 #### 驱动核心 i2c驱动框架 中断机制 input子系统 多点触摸协议 #### 多点触摸(Multi touch) 协议 Documentation/input/multi touch protocol.rst TypeA ：触摸点不能被区分，哪怕是两次相同的触摸数据信息，一律上报, 使用的是点的原始数据, 系统里面计算点是不是同一个序列(很少使用) TypeB：触摸点能够被硬件追踪区分，两次相同的触摸数据不上报，而是缓存在slot对象中。 触摸点的信息通过一系列的 ABS_MT 事件(有的资料也叫消息)上报给 linux 内核，只有 ABS_MT 事件是用于多点触摸的，ABS_MT 事件定义在文件 include/uapi/linux/input.h 中 ##### 多点触摸事件类型 include/uapi/linux/input event codes.h / include/uapi/linux/input.h ```c #define ABS_RESERVED\t\t0x2e #define ABS_MT_SLOT\t\t0x2f\t/* MT slot being modified */ #define ABS_MT_TOUCH_MAJOR\t0x30\t/* Major axis of touching ellipse */ #define ABS_MT_TOUCH_MINOR\t0x31\t/* Minor axis (omit if circular) */ #define ABS_MT_WIDTH_MAJOR\t0x32\t/* Major axis of approaching ellipse */ #define ABS_MT_WIDTH_MINOR\t0x33\t/* Minor axis (omit if circular) */ #define ABS_MT_ORIENTATION\t0x34\t/* Ellipse orientation */ #define ABS_MT_POSITION_X\t0x35\t/* Center X touch position */ #define ABS_MT_POSITION_Y\t0x36\t/* Center Y touch position */ #define ABS_MT_TOOL_TYPE\t0x37\t/* Type of touching device */ #define ABS_MT_BLOB_ID\t\t0x38\t/* Group a set of packets as a blob */ #define ABS_MT_TRACKING_ID\t0x39\t/* Unique ID of initiated contact */ #define ABS_MT_PRESSURE\t\t0x3a\t/* Pressure on contact area */ #define ABS_MT_DISTANCE\t\t0x3b\t/* Contact hover distance */ #define ABS_MT_TOOL_X\t\t0x3c\t/* Center X tool position */ #define ABS_MT_TOOL_Y\t\t0x3d\t/* Center Y tool position */ ``` ABS_MT_SLOT：上报触点序号 ABS_MT_TRACKING_ID：为触摸点分配ID，用于轨迹跟踪 ABS_MT_POSITION_X：上报触摸点X轴坐标信息 ABS_MT_POSITION_Y：上报触摸点Y轴坐标信息 ABS_MT_TOUCH_MAJOR：上报触摸区域长轴信息（触点椭圆形） ABS_MT_WIDTH_MAJOR：上报触摸区域短轴信息（触点椭圆形） ### 触摸时序 #### TypeA 对于 Type A 类型的设备，通过 input_mt_sync()函数来隔离不同的触摸点数据信息, 会触发 SYN_MT_REPORT 事件 ```c void input_mt_sync(struct input_dev *dev) ``` ```c ABS_MT_POSITION_X x[0] // input_report_abs ABS_MT_POSITION_Y y[0] SYN_MT_REPORT // input_mt_sync ABS_MT_POSITION_X x[1] ABS_MT_POSITION_Y y[1] SYN_MT_REPORT SYN_REPORT // input_sync ``` #### TypeB设备上报时序 上报触摸点信息的时候需要通过 input_mt_slot()函数区分是哪一个触摸点, 函数会触发 ABS_MT_SLOT 事件 ```c void input_mt_slot(struct input_dev *dev, int slot) ``` ```c ABS_MT_SLOT 0\t\t\t\t//上报触摸点序号(一次读取里面的点的序号) input_mt_slot ABS_MT_TRACKING_ID 45\t\t//为触摸点分配ID(动态分配) input_mt_report_slot_state ABS_MT_POSITION_X x[0]\t\t//上报触摸点X轴坐标信息 input_report_abs ABS_MT_POSITION_Y y[0]\t\t//上报触摸点Y轴坐标信息 ABS_MT_SLOT 1\t\t\t\t//以下同上 ABS_MT_TRACKING_ID 46\t\t ABS_MT_POSITION_X x[1] ABS_MT_POSITION_Y y[1] SYN_REPORT\t\t\t\t\t//同步事件 input_sync ``` Type B设备驱动需要给每个识别出来的触摸点分配一个 slot，后面使用这个 slot来上报触摸点信息。可以通过 slot 的 ABS_MT_TRACKING_ID 来新增、替换或删除触摸点。一个非负数的ID表示一个有效的触摸点， 1这个ID表示未使用 slot。一个以前不存在的 ID表示这是一个新加的触摸点，一个 ID如果再也不存在了就表示删除了 ### API #### input_mt_init_slots()函数 drivers/input/input mt.c 初始化所有触摸点slot对象, 在初始化的时候进行设置, 指定可以使用的触摸点的最大数量 ```c int input_mt_init_slots(struct input_dev *dev, unsigned int num_slots, \t\t\tunsigned int flags) ``` 参数： dev：具体输入设备 num_slots：设备要使用触摸点数量，由触摸芯片决定, 在初始化的时候设置一下这个设备支持的最多的点数 flags：触摸输入设备的flags信息 INPUT_MT_POINTER：触控板 INPUT_MT_DIRECT：触摸屏 ... 返回值： 成功：0 失败：负数 #### input_mt_slot()函数 include/linux/input/mt.h 上报触摸点的序号, 在TypeB里面的一次上报里面处理不同的触摸点 ```c static inline void input_mt_slot(struct input_dev *dev, int slot) { \tinput_event(dev, EV_ABS, ABS_MT_SLOT, slot); } ``` 参数： dev ： 具体输入设备 slot：slot对象的序号，也就是哪个触摸点 返回值： 成功：0 失败：负数 #### 为触摸点分配ID ##### input_mt_report_slot_state()函数 drivers/input/input mt.c 在TypeB里面用于产生 ABS_MT_TRACKING_ID, 给 slot 关联一个 ABS_MT_TRACKING_ID ```c bool input_mt_report_slot_state(struct input_dev *dev, \t\t\t\tunsigned int tool_type, bool active) ``` 参数： dev ： 具体输入设备 tool_type：触摸类型 MT_TOOL_FINGER：手指 MT_TOOL_PEN：笔 MT_TOOL_PALM：手掌 active： true：连续触摸，动态分配id false：触摸点离开，表示触摸点无效，id为 1 #### 上报触摸点坐标信息 ```c static inline void input_report_abs(struct input_dev *dev, unsigned int code, int value) ``` #### 上报点数 将多个触控点\"降级\"为传统的单点鼠标指针事件 如果追踪到的触摸点数量多于当前上报的数量，驱动程序使用 BTN_TOOL_TAP 事件来通知用户空间当前追踪到的触摸点总数量, 然后调用 input_mt_report_pointer_emulation 函数将 use_count参数设置为 false。否则的话将use_count参数设置为true，表示当前的触摸点数量(此函数会获取到具体的触摸点数量，不需要用户给出) ```c void input_mt_report_pointer_emulation(struct input_dev *dev, \tbool use_count) ``` **dev**： MT设备对应的 input_dev。 **use_count**：true，有效的触摸点数量；false，追踪到的触摸点数量多于当前上报的数量。 返回值：无。 ### 上报时序案例 drivers/input/touchscreen/ili210x.c ##### ili210x_report_events()函数 ```c static bool ili210x_report_events(struct ili210x *priv, u8 *touchdata) { \tstruct input_dev *input priv >input; \tint i; \tbool contact false, touch false; \tunsigned int x 0, y 0; \tfor (i 0; i < priv >max_touches; i++) { \t\t... touch touchdata >status & (1 << i); // 判断这个触摸点的状态 // 每个触摸点处理 \t\tinput_mt_slot(input, i); \t\tinput_mt_report_slot_state(input, MT_TOOL_FINGER, touch); \t\tif (!touch) \t\t\tcontinue; \t\ttouchscreen_report_pos(input, &priv >prop, x, y, \t\t\t\t true); \t} \tinput_mt_report_pointer_emulation(input, false); // 同步 \tinput_sync(input); \tif (priv >model MODEL_ILI210X) \t\tcontact touchdata[0] & 0xf3; \treturn contact; } ``` ##### touchscreen_report_pos()函数 drivers/input/touchscreen/of_touchscreen.c ```c void touchscreen_report_pos(struct input_dev *input, \t\t\t const struct touchscreen_properties *prop, \t\t\t unsigned int x, unsigned int y, \t\t\t bool multitouch) { \ttouchscreen_apply_prop_to_x_y(prop, &x, &y); \tinput_report_abs(input, multitouch ? ABS_MT_POSITION_X : ABS_X, x); \tinput_report_abs(input, multitouch ? ABS_MT_POSITION_Y : ABS_Y, y); } ``` #### 多点触摸屏驱动框架 I2C驱动入口 ```c /* i2c设备驱动*/ static struct i2c_driver ft5x06_ts_driver { .driver { .owner THIS_MODULE, .name \"xxx\", .of_match_table of_match_ptr(xxx_of_match), }, .probe yyy_probe, .remove zzz_remove, }; /* 模块入口函数 */ static int __init xxx_init(void) { int ret 0; ret i2c_add_driver(&xxx_ts_driver); return ret; } ``` ##### yyy_probe()函数 初始化触摸芯片、外部中断、input子系统 ```c static int yyy_probe(struct i2c_client *client, const struct i2c_device_id *id) { \tstruct input_dev *input; \t//初始化触摸芯片，iic配置相关寄存器 \t... \t//申请中断 \tdevm_request_threaded_irq(&client >dev, client >irq, NULL, \tzzz_handler, IRQF_TRIGGER_FALLING IRQF_ONESHOT, \tclient >name, &XXX); \t \t//分配外部输入设备并初步初始化 \tinput devm_input_allocate_device(&client >dev); \t \tts >input_dev >name \"Goodix Capacitive TouchScreen\"; \tts >input_dev >phys \"input/ts\"; \tts >input_dev >id.bustype BUS_I2C; \t \t//配置输入设备的事件类型 \tinput_set_capability(ts >input_dev, EV_ABS, ABS_MT_POSITION_X); \tinput_set_capability(ts >input_dev, EV_ABS, ABS_MT_POSITION_Y); \t \t//初始化所有触摸点slot对象 \tinput_mt_init_slots(input, MAX_SUPPORT_POINTS, 0); \t \t//注册输入设备 \tinput_register_device(input); \t... } ``` > devm_开始的中断可以自动释放 > > devm_request_threaded_irq处理的函数是作为一个内核线程进行的 #### 中断处理函数上报坐标 zzz_handler()函数 按时序上报多点触摸屏信息 ## 电容触摸屏驱动实验 #### 硬件原理图 ![image 20200923115400613](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509281035079.png) #### 设备树节点 ##### iomuxc子节点 ```json pinctrl_i2c1: i2c1grp { fsl,pins < MX6UL_PAD_UART4_TX_DATA__I2C1_SCL 0x4001b8b0 MX6UL_PAD_UART4_RX_DATA__I2C1_SDA 0x4001b8b0 >; }; pinctrl_tsc_reset: tscresetgrp { fsl,pins < /* used for tsc reset */ MX6UL_PAD_LCD_RESET__GPIO3_IO04 0x10b0 >; }; ``` ##### iomuxc_snvs子节点 ```json pinctrl_tsc_irq: tsc_irq { fsl,pins < MX6ULL_PAD_SNVS_TAMPER9__GPIO5_IO09 0x4001b8b0 >; }; ``` > snvs开头的节点属于是电源管理相关的引脚, 在这一个节点里面配置 ##### i2c1子节点 ```c gtxx_tsc@5d { compatible \"fire,gt9xx_test\"; \t\t\t\t\t\tpinctrl names \"default\"; pinctrl 0 <&pinctrl_tsc_reset &pinctrl_tsc_irq>; reg <0x5d>; status \"okay\"; /*gpio*/ reset gpios <&gpio3 4 GPIO_ACTIVE_LOW>; irq gpios <&gpio5 9 GPIO_ACTIVE_HIGH>; /*中断*/ interrupt parent <&gpio5>; interrupts <9 IRQ_TYPE_EDGE_FALLING>; irq flags <2>; /*1:rising 2: falling*/ }; ``` #### GT9157触摸芯片介绍 《STM32 HAL库开发实战指南》 >第29章 电容触摸屏 触摸画板 ##### 上电时序与 I2C设备地址 ##### 寄存器配置 版本寄存器 X、Y坐标范围 触点个数 模式切换 配置校验 状态寄存器 #### 电容触摸屏驱动 drivers/input/touchscreen/goodix.c ##### goodix_ts_data结构体 ```c struct goodix_ts_data { struct i2c_client *client; //i2c 从设备结构体 struct input_dev *input_dev; //输入设备结构体 const struct goodix_chip_data *chip; //goodix相关内容 struct touchscreen_properties prop; //未知内容 unsigned int max_touch_num; //做大支持的触摸点 unsigned int int_trigger_type; //触摸类型 struct gpio_desc *gpiod_int; //触摸中断引脚 struct gpio_desc *gpiod_rst; //触摸芯片复位引脚 u16 id; //触摸芯片, 从寄存器里面进行读取 u16 version; //版本 const char *cfg_name; //名字 struct completion firmware_loading_complete; //固件加载完成标志, 从用户空间读取寄存器加载的内容 unsigned long irq_flags; //中断标记 }; ``` ##### goodix_chip_data结构体 ```c struct goodix_chip_data { \tu16 config_addr;\t\t//寄存器配置地址 \tint config_len;\t\t\t//寄存器配置长度 \tint (*check_config)(struct goodix_ts_data *, const struct firmware *); // 校验 }; ``` ##### hexdump命令 Linux下的一个二进制文件查看工具 ```c hexdump xxx\t//十六进制显示文件内容 ``` ##### 触摸屏数据显示格式说明 数据编号 时间戳s 时间戳us type code value 0000000 eeec 5f6a 580c 000e 0003 0039 0000 0000 0000010 eeec 5f6a 580c 000e 0003 0035 0006 0000 ... ##### input_event结构体 include/uapi/linux/input.h ```c struct input_event { \tstruct timeval time; \t__u16 type; \t__u16 code; \t__s32 value; }; ``` 两个错误： 触摸芯片名字 cfg_name ## 驱动 ```c /* * Driver for Goodix Touchscreens * * Copyright (c) 2014 Red Hat Inc. * Copyright (c) 2015 K. Merker <merker@debian.org> * * This code is based on gt9xx.c authored by andrew@goodix.com: * * 2010 2012 Goodix Technology. */ /* * This program is free software; you can redistribute it and/or modify it * under the terms of the GNU General Public License as published by the Free * Software Foundation; version 2 of the License. */ #include <linux/kernel.h> #include <linux/dmi.h> #include <linux/firmware.h> #include <linux/gpio/consumer.h> #include <linux/i2c.h> #include <linux/input.h> #include <linux/input/mt.h> #include <linux/input/touchscreen.h> #include <linux/module.h> #include <linux/delay.h> #include <asm/io.h> #include <linux/irq.h> #include <linux/interrupt.h> #include <linux/slab.h> #include <linux/acpi.h> #include <linux/of.h> #include <asm/unaligned.h> struct goodix_ts_data; struct goodix_chip_data { \tu16 config_addr; \tint config_len; \tint (*check_config)(struct goodix_ts_data *, const struct firmware *); }; struct goodix_ts_data { \tstruct i2c_client *client; \tstruct input_dev *input_dev; \tconst struct goodix_chip_data *chip; \tstruct touchscreen_properties prop; \tunsigned int max_touch_num; \tunsigned int int_trigger_type; \tstruct gpio_desc *gpiod_int; \tstruct gpio_desc *gpiod_rst; \tu16 id; \tu16 version; \tconst char *cfg_name; \tstruct completion firmware_loading_complete; \tunsigned long irq_flags; }; #define GOODIX_GPIO_INT_NAME\t\t\"irq\" #define GOODIX_GPIO_RST_NAME\t\t\"reset\" #define GOODIX_MAX_HEIGHT\t\t4096 #define GOODIX_MAX_WIDTH\t\t4096 #define GOODIX_INT_TRIGGER\t\t1 #define GOODIX_CONTACT_SIZE\t\t8 #define GOODIX_MAX_CONTACTS\t\t10 #define GOODIX_CONFIG_MAX_LENGTH\t242 //fire 修改 #define GOODIX_CONFIG_917_LENGTH\t242 //fire 新增 #define GOODIX_CONFIG_5688_LENGTH\t242 //fire 新增 #define GOODIX_CONFIG_911_LENGTH\t186 #define GOODIX_CONFIG_967_LENGTH\t228 /* Register defines */ #define GOODIX_REG_COMMAND\t\t0x8040 #define GOODIX_CMD_SCREEN_OFF\t\t0x05 #define GOODIX_READ_COOR_ADDR\t\t0x814E #define GOODIX_GT1X_REG_CONFIG_DATA\t0x8050 #define GOODIX_GT5688_REG_CONFIG_DATA\t0x8050 //fire 新增 #define GOODIX_GT917_REG_CONFIG_DATA\t0x8050 //fire 新增 #define GOODIX_GT9X_REG_CONFIG_DATA\t0x8047 #define GOODIX_REG_ID\t\t\t0x8140 #define GOODIX_BUFFER_STATUS_READY\tBIT(7) #define GOODIX_BUFFER_STATUS_TIMEOUT\t20 #define RESOLUTION_LOC\t\t1 #define MAX_CONTACTS_LOC\t5 #define TRIGGER_LOC\t\t6 static int goodix_check_cfg_8(struct goodix_ts_data *ts, \t\t\tconst struct firmware *cfg); static int goodix_check_cfg_16(struct goodix_ts_data *ts, \t\t\tconst struct firmware *cfg); static const struct goodix_chip_data gt1x_chip_data { \t.config_addr\t\t GOODIX_GT1X_REG_CONFIG_DATA, \t.config_len\t\t GOODIX_CONFIG_MAX_LENGTH, \t.check_config\t\t goodix_check_cfg_16, }; static const struct goodix_chip_data gt911_chip_data { \t.config_addr\t\t GOODIX_GT9X_REG_CONFIG_DATA, \t.config_len\t\t GOODIX_CONFIG_911_LENGTH, \t.check_config\t\t goodix_check_cfg_8, }; static const struct goodix_chip_data gt967_chip_data { \t.config_addr\t\t GOODIX_GT9X_REG_CONFIG_DATA, \t.config_len\t\t GOODIX_CONFIG_967_LENGTH, \t.check_config\t\t goodix_check_cfg_8, }; static const struct goodix_chip_data gt9x_chip_data { \t.config_addr\t\t GOODIX_GT9X_REG_CONFIG_DATA, \t.config_len\t\t GOODIX_CONFIG_MAX_LENGTH, \t.check_config\t\t goodix_check_cfg_8, }; /*fire 新增 2020/7/14*/ static const struct goodix_chip_data gt917_chip_data { \t.config_addr\t\t GOODIX_GT917_REG_CONFIG_DATA, \t.config_len\t\t GOODIX_CONFIG_917_LENGTH, \t.check_config\t\t goodix_check_cfg_16, }; /*fire 新增 2020/7/14*/ static const struct goodix_chip_data gt5688_chip_data { \t.config_addr\t\t GOODIX_GT917_REG_CONFIG_DATA, \t.config_len\t\t GOODIX_CONFIG_5688_LENGTH, \t.check_config\t\t goodix_check_cfg_16, }; static const unsigned long goodix_irq_flags[] { \tIRQ_TYPE_EDGE_RISING, \tIRQ_TYPE_EDGE_FALLING, \tIRQ_TYPE_LEVEL_LOW, \tIRQ_TYPE_LEVEL_HIGH, }; /* * Those tablets have their coordinates origin at the bottom right * of the tablet, as if rotated 180 degrees */ static const struct dmi_system_id rotated_screen[] { #if defined(CONFIG_DMI) && defined(CONFIG_X86) \t{ \t\t.ident \"WinBook TW100\", \t\t.matches { \t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"WinBook\"), \t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TW100\") \t\t} \t}, \t{ \t\t.ident \"WinBook TW700\", \t\t.matches { \t\t\tDMI_MATCH(DMI_SYS_VENDOR, \"WinBook\"), \t\t\tDMI_MATCH(DMI_PRODUCT_NAME, \"TW700\") \t\t}, \t}, #endif \t{} }; /** * goodix_i2c_read read data from a register of the i2c slave device. * * @client: i2c device. * @reg: the register to read from. * @buf: raw write data buffer. * @len: length of the buffer to write */ static int goodix_i2c_read(struct i2c_client *client, \t\t\t u16 reg, u8 *buf, int len) { \tstruct i2c_msg msgs[2]; \t__be16 wbuf cpu_to_be16(reg); \tint ret; \tmsgs[0].flags 0; \tmsgs[0].addr client >addr; \tmsgs[0].len 2; \tmsgs[0].buf (u8 *)&wbuf; \tmsgs[1].flags I2C_M_RD; \tmsgs[1].addr client >addr; \tmsgs[1].len len; \tmsgs[1].buf buf; \tret i2c_transfer(client >adapter, msgs, 2); \treturn ret < 0 ? ret : (ret ! ARRAY_SIZE(msgs) ? EIO : 0); } /** * goodix_i2c_write write data to a register of the i2c slave device. * * @client: i2c device. * @reg: the register to write to. * @buf: raw data buffer to write. * @len: length of the buffer to write */ static int goodix_i2c_write(struct i2c_client *client, u16 reg, const u8 *buf, \t\t\t unsigned len) { \tu8 *addr_buf; \tstruct i2c_msg msg; \tint ret; \taddr_buf kmalloc(len + 2, GFP_KERNEL); \tif (!addr_buf) \t\treturn ENOMEM; \taddr_buf[0] reg >> 8; \taddr_buf[1] reg & 0xFF; \tmemcpy(&addr_buf[2], buf, len); \tmsg.flags 0; \tmsg.addr client >addr; \tmsg.buf addr_buf; \tmsg.len len + 2; \tret i2c_transfer(client >adapter, &msg, 1); \tkfree(addr_buf); \treturn ret < 0 ? ret : (ret ! 1 ? EIO : 0); } static int goodix_i2c_write_u8(struct i2c_client *client, u16 reg, u8 value) { \treturn goodix_i2c_write(client, reg, &value, sizeof(value)); } static const struct goodix_chip_data *goodix_get_chip_data(u16 id) { \tswitch (id) { \tcase 1151: \t\treturn &gt1x_chip_data; \tcase 911: \tcase 9271: \tcase 9110: \tcase 927: \tcase 928: \t\treturn &gt911_chip_data; \t \tcase 912: \tcase 9157: // fire 新增 2020/7/14 \t\treturn &gt9x_chip_data; \tcase 917: // fire 新增 2020/7/14 \t\treturn &gt917_chip_data; \tcase 5688: // fire 新增 2020/7/14 \t\treturn &gt5688_chip_data;\t \tcase 967: \t\treturn &gt967_chip_data; \tdefault: \t\treturn &gt9x_chip_data; \t} } static int goodix_ts_read_input_report(struct goodix_ts_data *ts, u8 *data) { \tunsigned long max_timeout; \tint touch_num; \tint error; \t/* \t * The 'buffer status' bit, which indicates that the data is valid, is \t * not set as soon as the interrupt is raised, but slightly after. \t * This takes around 10 ms to happen, so we poll for 20 ms. \t */ \tmax_timeout jiffies + msecs_to_jiffies(GOODIX_BUFFER_STATUS_TIMEOUT); \tdo { \t\terror goodix_i2c_read(ts >client, GOODIX_READ_COOR_ADDR, \t\t\t\t\tdata, GOODIX_CONTACT_SIZE + 1); \t\tif (error) { \t\t\tdev_err(&ts >client >dev, \"I2C transfer error: %d\\n\", \t\t\t\t\terror); \t\t\treturn error; \t\t} \t\tif (data[0] & GOODIX_BUFFER_STATUS_READY) { \t\t\ttouch_num data[0] & 0x0f; \t\t\tif (touch_num > ts >max_touch_num) \t\t\t\treturn EPROTO; \t\t\tif (touch_num > 1) { \t\t\t\tdata + 1 + GOODIX_CONTACT_SIZE; \t\t\t\terror goodix_i2c_read(ts >client, \t\t\t\t\t\tGOODIX_READ_COOR_ADDR + \t\t\t\t\t\t\t1 + GOODIX_CONTACT_SIZE, \t\t\t\t\t\tdata, \t\t\t\t\t\tGOODIX_CONTACT_SIZE * \t\t\t\t\t\t\t(touch_num 1)); \t\t\t\tif (error) \t\t\t\t\treturn error; \t\t\t} \t\t\treturn touch_num; \t\t} \t\tusleep_range(1000, 2000); /* Poll every 1 2 ms */ \t} while (time_before(jiffies, max_timeout)); \t/* \t * The Goodix panel will send spurious interrupts after a \t * 'finger up' event, which will always cause a timeout. \t */ \treturn 0; } static void goodix_ts_report_touch(struct goodix_ts_data *ts, u8 *coor_data) { \tint id coor_data[0] & 0x0F; \tint input_x get_unaligned_le16(&coor_data[1]); \tint input_y get_unaligned_le16(&coor_data[3]); \tint input_w get_unaligned_le16(&coor_data[5]); \tinput_mt_slot(ts >input_dev, id); \tinput_mt_report_slot_state(ts >input_dev, MT_TOOL_FINGER, true); \ttouchscreen_report_pos(ts >input_dev, &ts >prop, \t\t\t input_x, input_y, true); \tinput_report_abs(ts >input_dev, ABS_MT_TOUCH_MAJOR, input_w); \tinput_report_abs(ts >input_dev, ABS_MT_WIDTH_MAJOR, input_w); } /** * goodix_process_events Process incoming events * * @ts: our goodix_ts_data pointer * * Called when the IRQ is triggered. Read the current device state, and push * the input events to the user space. */ static void goodix_process_events(struct goodix_ts_data *ts) { \tu8 point_data[1 + GOODIX_CONTACT_SIZE * GOODIX_MAX_CONTACTS]; \tint touch_num; \tint i; \ttouch_num goodix_ts_read_input_report(ts, point_data); \tif (touch_num < 0) \t\treturn; \t/* \t * Bit 4 of the first byte reports the status of the capacitive \t * Windows/Home button. \t */ \tinput_report_key(ts >input_dev, KEY_LEFTMETA, point_data[0] & BIT(4)); \tfor (i 0; i < touch_num; i++) \t\tgoodix_ts_report_touch(ts, \t\t\t\t&point_data[1 + GOODIX_CONTACT_SIZE * i]); \t } /** * goodix_ts_irq_handler The IRQ handler * * @irq: interrupt number. * @dev_id: private data pointer. */ static irqreturn_t goodix_ts_irq_handler(int irq, void *dev_id) { \tstruct goodix_ts_data *ts dev_id; \tgoodix_process_events(ts); \tif (goodix_i2c_write_u8(ts >client, GOODIX_READ_COOR_ADDR, 0) < 0) \t\tdev_err(&ts >client >dev, \"I2C write end_cmd error\\n\"); \treturn IRQ_HANDLED; } static void goodix_free_irq(struct goodix_ts_data *ts) { \tdevm_free_irq(&ts >client >dev, ts >client >irq, ts); } static int goodix_request_irq(struct goodix_ts_data *ts) { \treturn devm_request_threaded_irq(&ts >client >dev, ts >client >irq, \t\t\t\t\t NULL, goodix_ts_irq_handler, \t\t\t\t\t ts >irq_flags, ts >client >name, ts); } static int goodix_check_cfg_8(struct goodix_ts_data *ts, \t\t\tconst struct firmware *cfg) { \tint i, raw_cfg_len cfg >size 2; \tu8 check_sum 0; \tfor (i 0; i < raw_cfg_len; i++) \t\tcheck_sum + cfg >data[i]; \tcheck_sum (~check_sum) + 1; \tif (check_sum ! cfg >data[raw_cfg_len]) { \t\tdev_err(&ts >client >dev, \t\t\t\"The checksum of the config fw is not correct\"); \t\treturn EINVAL; \t} \tif (cfg >data[raw_cfg_len + 1] ! 1) { \t\tdev_err(&ts >client >dev, \t\t\t\"Config fw must have Config_Fresh register set\"); \t\treturn EINVAL; \t} \treturn 0; } static int goodix_check_cfg_16(struct goodix_ts_data *ts, \t\t\tconst struct firmware *cfg) { \tint i, raw_cfg_len cfg >size 3; \tu16 check_sum 0; \tfor (i 0; i < raw_cfg_len; i + 2) \t\tcheck_sum + get_unaligned_be16(&cfg >data[i]); \tcheck_sum (~check_sum) + 1; \tdev_err(&ts >client >dev,\"goodix_check_cfg_16\"); \tif (check_sum ! get_unaligned_be16(&cfg >data[raw_cfg_len])) { \t\tdev_err(&ts >client >dev, \t\t\t\"The checksum of the config fw is not correct\"); \t\treturn EINVAL; \t} \tif (cfg >data[raw_cfg_len + 2] ! 1) { \t\tdev_err(&ts >client >dev, \t\t\t\"Config fw must have Config_Fresh register set\"); \t\treturn EINVAL; \t} \treturn 0; } /** * goodix_check_cfg Checks if config fw is valid * * @ts: goodix_ts_data pointer * @cfg: firmware config data */ static int goodix_check_cfg(struct goodix_ts_data *ts, \t\t\t const struct firmware *cfg) { \tdev_err(&ts >client >dev,\"cfg >size %d,GOODIX_CONFIG_MAX_LENGTH %d\",cfg >size,GOODIX_CONFIG_MAX_LENGTH); \tif (cfg >size > GOODIX_CONFIG_MAX_LENGTH) { \t\tdev_err(&ts >client >dev, \t\t\t\"The length of the config fw is not correct\"); \t\treturn EINVAL; \t} \treturn ts >chip >check_config(ts, cfg); } /** * goodix_send_cfg Write fw config to device * * @ts: goodix_ts_data pointer * @cfg: config firmware to write to device */ static int goodix_send_cfg(struct goodix_ts_data *ts, \t\t\t const struct firmware *cfg) { \tint error; \terror goodix_check_cfg(ts, cfg); \tif (error) \t\treturn error; \terror goodix_i2c_write(ts >client, ts >chip >config_addr, cfg >data, \t\t\t\t cfg >size); \tif (error) { \t\tdev_err(&ts >client >dev, \"Failed to write config data: %d\", \t\t\terror); \t\treturn error; \t} \tdev_dbg(&ts >client >dev, \"Config sent successfully.\"); \t/* Let the firmware reconfigure itself, so sleep for 10ms */ \tusleep_range(10000, 11000); \treturn 0; } static int goodix_int_sync(struct goodix_ts_data *ts) { \tint error; \terror gpiod_direction_output(ts >gpiod_int, 0); \tif (error) \t\treturn error; \tmsleep(50);\t\t\t\t/* T5: 50ms */ \terror gpiod_direction_input(ts >gpiod_int); \tif (error) \t\treturn error; \treturn 0; } /** * goodix_reset Reset device during power on * * @ts: goodix_ts_data pointer */ // 处理复位事件 static int goodix_reset(struct goodix_ts_data *ts) { \tint error; \t/* begin select I2C slave addr */ \terror gpiod_direction_output(ts >gpiod_rst, 0); \tif (error) \t\treturn error; \tmsleep(20);\t\t\t\t/* T2: > 10ms */ \t/* HIGH: 0x28/0x29, LOW: 0xBA/0xBB */ \terror gpiod_direction_output(ts >gpiod_int, ts >client >addr 0x14); \tif (error) \t\treturn error; \tusleep_range(100, 2000);\t\t/* T3: > 100us */ \terror gpiod_direction_output(ts >gpiod_rst, 1); \tif (error) \t\treturn error; \tusleep_range(6000, 10000);\t\t/* T4: > 5ms */ \t/* end select I2C slave addr */ \terror gpiod_direction_input(ts >gpiod_rst); \tif (error) \t\treturn error; \t// int引脚设置一下默认电平 \terror goodix_int_sync(ts); \tif (error) \t\treturn error; \treturn 0; } /** * goodix_get_gpio_config Get GPIO config from ACPI/DT * * @ts: goodix_ts_data pointer */ static int goodix_get_gpio_config(struct goodix_ts_data *ts) { \tint error; \tstruct device *dev; \tstruct gpio_desc *gpiod; \tif (!ts >client) \t\treturn EINVAL; \tdev &ts >client >dev; \t/* Get the interrupt GPIO pin number */ // 获取int引脚 \tgpiod devm_gpiod_get_optional(dev, GOODIX_GPIO_INT_NAME, GPIOD_IN); \tif (IS_ERR(gpiod)) { \t\terror PTR_ERR(gpiod); \t\tif (error ! EPROBE_DEFER) \t\t\tdev_dbg(dev, \"Failed to get %s GPIO: %d\\n\", \t\t\t\tGOODIX_GPIO_INT_NAME, error); \t\treturn error; \t} \tts >gpiod_int gpiod; \t/* Get the reset line GPIO pin number */ // 获取reset引脚 \tgpiod devm_gpiod_get_optional(dev, GOODIX_GPIO_RST_NAME, GPIOD_IN); \tif (IS_ERR(gpiod)) { \t\terror PTR_ERR(gpiod); \t\tif (error ! EPROBE_DEFER) \t\t\tdev_dbg(dev, \"Failed to get %s GPIO: %d\\n\", \t\t\t\tGOODIX_GPIO_RST_NAME, error); \t\treturn error; \t} \tts >gpiod_rst gpiod; \treturn 0; } /** * goodix_read_config Read the embedded configuration of the panel * * @ts: our goodix_ts_data pointer * * Must be called during probe */ static void goodix_read_config(struct goodix_ts_data *ts) { \tu8 config[GOODIX_CONFIG_MAX_LENGTH]; \tint x_max, y_max; \tint error; \terror goodix_i2c_read(ts >client, ts >chip >config_addr, \t\t\t\tconfig, ts >chip >config_len); \tif (error) { \t\tdev_warn(&ts >client >dev, \"Error reading config: %d\\n\", \t\t\t error); \t\tts >int_trigger_type GOODIX_INT_TRIGGER; \t\tts >max_touch_num GOODIX_MAX_CONTACTS; \t\treturn; \t} \tts >int_trigger_type config[TRIGGER_LOC] & 0x03; \tts >max_touch_num config[MAX_CONTACTS_LOC] & 0x0f; \tx_max get_unaligned_le16(&config[RESOLUTION_LOC]); \ty_max get_unaligned_le16(&config[RESOLUTION_LOC + 2]); \tif (x_max && y_max) { \t\tinput_abs_set_max(ts >input_dev, ABS_MT_POSITION_X, x_max 1); \t\tinput_abs_set_max(ts >input_dev, ABS_MT_POSITION_Y, y_max 1); \t} } /** * goodix_read_version Read goodix touchscreen version * * @ts: our goodix_ts_data pointer */ static int goodix_read_version(struct goodix_ts_data *ts) { \tint error; \tu8 buf[6]; \tchar id_str[5]; \terror goodix_i2c_read(ts >client, GOODIX_REG_ID, buf, sizeof(buf)); \tif (error) { \t\tdev_err(&ts >client >dev, \"read version failed: %d\\n\", error); \t\treturn error; \t} \tmemcpy(id_str, buf, 4); \tdev_info(&ts >client >dev, \"id_str %s\\n\",id_str); \t/** \t * 处理ID为917S的情况 \t * 将917S替换为917 \t*/ \tdo \t{ \t\tif((id_str[0] '9')&&(id_str[1] '1')&&(id_str[2] '7')&&(id_str[3] 'S')) \t\t{ \t\t\tid_str[0] '0'; \t\t\tid_str[1] '9'; \t\t\tid_str[2] '1'; \t\t\tid_str[3] '7'; \t\t} \t} while (0); \t \tid_str[4] 0; \tif (kstrtou16(id_str, 10, &ts >id)) \t\tts >id 0x1001; \tts >version get_unaligned_le16(&buf[4]); \tdev_info(&ts >client >dev, \"ID %d, version: %04x\\n\", ts >id, \t\t ts >version); \treturn 0; } /** * goodix_i2c_test I2C test function to check if the device answers. * * @client: the i2c client */ static int goodix_i2c_test(struct i2c_client *client) { \tint retry 0; \tint error; \tu8 test; \twhile (retry++ < 2) { // 读取一下ID \t\terror goodix_i2c_read(client, GOODIX_REG_ID, \t\t\t\t\t&test, 1); \t\tif (!error) \t\t\treturn 0; \t\tdev_err(&client >dev, \"i2c test failed attempt %d: %d\\n\", \t\t\tretry, error); \t\tmsleep(20); \t} \treturn error; } /** * goodix_configure_dev Finish device initialization * * @ts: our goodix_ts_data pointer * * Must be called from probe to finish initialization of the device. * Contains the common initialization code for both devices that * declare gpio pins and devices that do not. It is either called * directly from probe or from request_firmware_wait callback. */ // 初始化上报的事件以及中断 static int goodix_configure_dev(struct goodix_ts_data *ts) { \tint error; \tts >int_trigger_type GOODIX_INT_TRIGGER; \tts >max_touch_num GOODIX_MAX_CONTACTS; \tts >input_dev devm_input_allocate_device(&ts >client >dev); \tif (!ts >input_dev) { \t\tdev_err(&ts >client >dev, \"Failed to allocate input device.\"); \t\treturn ENOMEM; \t} \tts >input_dev >name \"Goodix Capacitive TouchScreen\"; \tts >input_dev >phys \"input/ts\"; \tts >input_dev >id.bustype BUS_I2C; \tts >input_dev >id.vendor 0x0416; \tts >input_dev >id.product ts >id; \tts >input_dev >id.version ts >version; \t/* Capacitive Windows/Home button on some devices */ \tinput_set_capability(ts >input_dev, EV_KEY, KEY_LEFTMETA); \tinput_set_capability(ts >input_dev, EV_ABS, ABS_MT_POSITION_X); \tinput_set_capability(ts >input_dev, EV_ABS, ABS_MT_POSITION_Y); \tinput_set_abs_params(ts >input_dev, ABS_MT_WIDTH_MAJOR, 0, 255, 0, 0); \tinput_set_abs_params(ts >input_dev, ABS_MT_TOUCH_MAJOR, 0, 255, 0, 0); \t/* Read configuration and apply touchscreen parameters */ \tgoodix_read_config(ts); \t/* Try overriding touchscreen parameters via device properties */ \ttouchscreen_parse_properties(ts >input_dev, true, &ts >prop); \tif (!ts >prop.max_x !ts >prop.max_y !ts >max_touch_num) { \t\tdev_err(&ts >client >dev, \"Invalid config, using defaults\\n\"); \t\tts >prop.max_x GOODIX_MAX_WIDTH 1; \t\tts >prop.max_y GOODIX_MAX_HEIGHT 1; \t\tts >max_touch_num GOODIX_MAX_CONTACTS; \t\tinput_abs_set_max(ts >input_dev, \t\t\t\t ABS_MT_POSITION_X, ts >prop.max_x); \t\tinput_abs_set_max(ts >input_dev, \t\t\t\t ABS_MT_POSITION_Y, ts >prop.max_y); \t} \tif (dmi_check_system(rotated_screen)) { \t\tts >prop.invert_x true; \t\tts >prop.invert_y true; \t\tdev_dbg(&ts >client >dev, \t\t\t\"Applying '180 degrees rotated screen' quirk\\n\"); \t} \terror input_mt_init_slots(ts >input_dev, ts >max_touch_num, \t\t\t\t INPUT_MT_DIRECT INPUT_MT_DROP_UNUSED); \tif (error) { \t\tdev_err(&ts >client >dev, \t\t\t\"Failed to initialize MT slots: %d\", error); \t\treturn error; \t} \terror input_register_device(ts >input_dev); \tif (error) { \t\tdev_err(&ts >client >dev, \t\t\t\"Failed to register input device: %d\", error); \t\treturn error; \t} \tts >irq_flags goodix_irq_flags[ts >int_trigger_type] IRQF_ONESHOT; \terror goodix_request_irq(ts); \tif (error) { \t\tdev_err(&ts >client >dev, \"request IRQ failed: %d\\n\", error); \t\treturn error; \t} \treturn 0; } /** * goodix_config_cb Callback to finish device init * * @ts: our goodix_ts_data pointer * * request_firmware_wait callback that finishes * initialization of the device. */ static void goodix_config_cb(const struct firmware *cfg, void *ctx) { \tstruct goodix_ts_data *ts ctx; \tint error; \t \tif (cfg) { \t\t/* send device configuration to the firmware */ \t\terror goodix_send_cfg(ts, cfg); // 实际的配置写入函数 \t\t \t\tif (error) \t\t\tgoto err_release_cfg; \t} \tgoodix_configure_dev(ts); err_release_cfg: \trelease_firmware(cfg); \tcomplete_all(&ts >firmware_loading_complete); } // 匹配以后得处理函数 static int goodix_ts_probe(struct i2c_client *client, \t\t\t const struct i2c_device_id *id) { // 描述的结构体 \tstruct goodix_ts_data *ts; \tint error; \tdev_dbg(&client >dev, \"I2C Address: 0x%02x\\n\", client >addr); \tif (!i2c_check_functionality(client >adapter, I2C_FUNC_I2C)) { \t\tdev_err(&client >dev, \"I2C check functionality failed.\\n\"); \t\treturn ENXIO; \t} \tts devm_kzalloc(&client >dev, sizeof(*ts), GFP_KERNEL); \tif (!ts) \t\treturn ENOMEM; \t// 记录i2c \tts >client client; \ti2c_set_clientdata(client, ts); \tinit_completion(&ts >firmware_loading_complete); \t// 读取GPIO的配置 \terror goodix_get_gpio_config(ts); \tif (error) \t\treturn error; \tif (ts >gpiod_int && ts >gpiod_rst) { \t\t/* reset the controller */ \t\terror goodix_reset(ts); \t\tif (error) { \t\t\tdev_err(&client >dev, \"Controller reset failed.\\n\"); \t\t\treturn error; \t\t} \t} \telse \t{ \t\tdev_err(&client >dev,\"\\n requst gpio filed! \\n\"); \t} \t \t// 测试一下, 读取ID \terror goodix_i2c_test(client); \tif (error) { \t\tdev_err(&client >dev, \"I2C communication failure: %d\\n\", error); \t\treturn error; \t} \t// 读取版本 \terror goodix_read_version(ts); \tif (error) { \t\tdev_err(&client >dev, \"Read version failed.\\n\"); \t\treturn error; \t} \t// 获取一系列的寄存器配置 \tts >chip goodix_get_chip_data(ts >id); \tif (ts >gpiod_int && ts >gpiod_rst) \t{ \t\t/* update device config */ \t\tts >cfg_name devm_kasprintf(&client >dev, GFP_KERNEL, \t\t\t\t\t \"goodix_%d_cfg.bin\", ts >id); // 设置一下名字 \t\tdev_err(&client >dev, \"ts >cfg_name %s \\n\",ts >cfg_name); \t\tif (!ts >cfg_name) \t\t\treturn ENOMEM; // 用户空间加载指定的 \t\terror request_firmware_nowait(THIS_MODULE, true, ts >cfg_name, \t\t\t\t\t\t&client >dev, GFP_KERNEL, ts, \t\t\t\t\t\tgoodix_config_cb); \t\tif (error) { \t\t\tdev_err(&client >dev, \t\t\t\t\"Failed to invoke firmware loader: %d\\n\", \t\t\t\terror); \t\t\treturn error; \t\t} \t\treturn 0; \t} \telse \t{ \t\tdev_err(&client >dev,\"\\n requst gpio filed! \\n\");//fire 新增 \t\tdev_err(&client >dev,\"\\n requst gpio filed! \\n\"); \t\tdev_err(&client >dev,\"\\n requst gpio filed! \\n\"); \t\tdev_err(&client >dev,\"\\n requst gpio filed! \\n\"); \t\tdev_err(&client >dev,\"\\n requst gpio filed! \\n\"); \t\tdev_err(&client >dev,\"\\n requst gpio filed! \\n\"); \t\tdev_err(&client >dev,\"\\n requst gpio filed! \\n\"); \t\terror goodix_configure_dev(ts); \t\tif (error) \t\t\treturn error; \t} \treturn 0; } static int goodix_ts_remove(struct i2c_client *client) { \tstruct goodix_ts_data *ts i2c_get_clientdata(client); \tif (ts >gpiod_int && ts >gpiod_rst) \t\twait_for_completion(&ts >firmware_loading_complete); \treturn 0; } static int __maybe_unused goodix_suspend(struct device *dev) { \tstruct i2c_client *client to_i2c_client(dev); \tstruct goodix_ts_data *ts i2c_get_clientdata(client); \tint error; \t/* We need gpio pins to suspend/resume */ \tif (!ts >gpiod_int !ts >gpiod_rst) { \t\tdisable_irq(client >irq); \t\treturn 0; \t} \twait_for_completion(&ts >firmware_loading_complete); \t/* Free IRQ as IRQ pin is used as output in the suspend sequence */ \tgoodix_free_irq(ts); \t/* Output LOW on the INT pin for 5 ms */ \terror gpiod_direction_output(ts >gpiod_int, 0); \tif (error) { \t\tgoodix_request_irq(ts); \t\treturn error; \t} \tusleep_range(5000, 6000); \terror goodix_i2c_write_u8(ts >client, GOODIX_REG_COMMAND, \t\t\t\t GOODIX_CMD_SCREEN_OFF); \tif (error) { \t\tdev_err(&ts >client >dev, \"Screen off command failed\\n\"); \t\tgpiod_direction_input(ts >gpiod_int); \t\tgoodix_request_irq(ts); \t\treturn EAGAIN; \t} \t/* \t * The datasheet specifies that the interval between sending screen off \t * command and wake up should be longer than 58 ms. To avoid waking up \t * sooner, delay 58ms here. \t */ \tmsleep(58); \treturn 0; } static int __maybe_unused goodix_resume(struct device *dev) { \tstruct i2c_client *client to_i2c_client(dev); \tstruct goodix_ts_data *ts i2c_get_clientdata(client); \tint error; \tif (!ts >gpiod_int !ts >gpiod_rst) { \t\tenable_irq(client >irq); \t\treturn 0; \t} \t/* \t * Exit sleep mode by outputting HIGH level to INT pin \t * for 2ms~5ms. \t */ \terror gpiod_direction_output(ts >gpiod_int, 1); \tif (error) \t\treturn error; \tusleep_range(2000, 5000); \terror goodix_int_sync(ts); \tif (error) \t\treturn error; \terror goodix_request_irq(ts); \tif (error) \t\treturn error; \treturn 0; } static SIMPLE_DEV_PM_OPS(goodix_pm_ops, goodix_suspend, goodix_resume); #ifdef CONFIG_ACPI static const struct acpi_device_id goodix_acpi_match[] { \t{ \"GDIX1001\", 0 }, \t{ \"GDIX1002\", 0 }, \t{ } }; MODULE_DEVICE_TABLE(acpi, goodix_acpi_match); #endif static const struct of_device_id goodix_of_match[] { \t{ .compatible \"goodix,gt1151\" }, \t{ .compatible \"goodix,gt911\" }, \t{ .compatible \"goodix,gt9110\" }, \t{ .compatible \"goodix,gt912\" }, \t{ .compatible \"goodix,gt927\" }, \t{ .compatible \"goodix,gt9271\" }, \t{ .compatible \"goodix,gt928\" }, \t{ .compatible \"goodix,gt967\" }, \t{ .compatible \"fire,gt9xx_test\" },// 对应的芯片驱动 \t{ } }; MODULE_DEVICE_TABLE(of, goodix_of_match); static struct i2c_driver goodix_ts_driver { \t.probe goodix_ts_probe, \t.remove goodix_ts_remove, \t// .id_table goodix_ts_id, \t.driver { \t\t.name \"Goodix TS CHANGE\", \t\t.acpi_match_table ACPI_PTR(goodix_acpi_match), \t\t.of_match_table of_match_ptr(goodix_of_match), \t\t.pm &goodix_pm_ops, \t}, }; module_i2c_driver(goodix_ts_driver); MODULE_AUTHOR(\"Benjamin Tissoires <benjamin.tissoires@gmail.com>\"); MODULE_AUTHOR(\"Bastien Nocera <hadess@hadess.net>\"); MODULE_DESCRIPTION(\"Goodix touchscreen driver\"); MODULE_LICENSE(\"GPL v2\"); ```"},"/note/Linux/野火Linux/2025-10-30-60-Linux编译脚本.html":{"title":"Linux 编译脚本","content":"# Linux 编译脚本 使用下面的命令进行编译 ```bash #!/bin/sh make ARCH arm CROSS_COMPILE arm linux gnueabihf distclean make ARCH arm CROSS_COMPILE arm linux gnueabihf imx_v7_defconfig make ARCH arm CROSS_COMPILE arm linux gnueabihf menuconfig make ARCH arm CROSS_COMPILE arm linux gnueabihf all j16 ``` 编译以后, zImage文件记录在`arch/arm/boot/zImage` 设备树文件记录在`arch/arm/boot/dts/xxx_.dtb` ## 文件 ![image 20251030214012497](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510302140562.png) ![image 20251030214024413](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510302140471.png) 需要关注的文件有 + `arch/arm/boot/dts`里面有设备树文件 + `Documentation/devicetree/bindings`设备树绑定相关的文件 + `arch/arm/configs` 目录是不同平台的默认配置 ## Makefile 和uboot的顶层Makefile文件比较类似 起始的时候是版本号, 命令输出的是否缩减, 静默输出, 代码检查, 输出的目录, 模块编译, 引用文件, 设置交叉编译器等变量 初始化一下使用的头文件 ```c # Use USERINCLUDE when you must reference the UAPI directories only. USERINCLUDE : \\ \t\t I$(srctree)/arch/$(hdr arch)/include/uapi \\ \t\t Iarch/$(hdr arch)/include/generated/uapi \\ \t\t I$(srctree)/include/uapi \\ \t\t Iinclude/generated/uapi \\ include $(srctree)/include/linux/kconfig.h # Use LINUXINCLUDE when you must reference the include/ directory. # Needed to be compatible with the O option LINUXINCLUDE : \\ \t\t I$(srctree)/arch/$(hdr arch)/include \\ \t\t Iarch/$(hdr arch)/include/generated/uapi \\ \t\t Iarch/$(hdr arch)/include/generated \\ \t\t$(if $(KBUILD_SRC), I$(srctree)/include) \\ \t\t Iinclude \\ \t\t$(USERINCLUDE) // 展开以后是下面的文件 USERINCLUDE : \\ I./arch/arm/include/uapi \\ Iarch/arm/include/generated/uapi \\ I./include/uapi \\ Iinclude/generated/uapi \\ include ./include/linux/kconfig.h LINUXINCLUDE : \\ I./arch/arm/include \\ Iarch/arm/include/generated/uapi \\ Iarch/arm/include/generated \\ Iinclude \\ I./arch/arm/include/uapi \\ Iarch/arm/include/generated/uapi \\ I./include/uapi \\ Iinclude/generated/uapi \\ include ./include/linux/kconfig.h ``` 经过判断可以获取到这三个变量的值 ```c config targets 1 mixed targets 0 dot config 1 ``` > config targets：是否请求了“配置类”目标的标志。为 1 表示本次 make 目标中含有 config/%config（如 menuconfig、oldconfig、defconfig 等）；否则为 0。用于把“仅配置流程”分支到 scripts/kconfig 执行。 > > mixed targets：是否“混合目标”标志。为 1 表示本次命令同时包含配置目标和普通构建目标（例如 make oldconfig all）；此时会逐个目标顺序调用，避免在处理 *config 时误读 .config。 > > dot config：是否需要读取配置文件的标志。初始为 1；若本次目标只属于 no dot config targets（如 clean、help、headers_* 等），则置 0，从而跳过包含 include/config/auto.conf，避免在这些场景强依赖 .config。 因为config targets 1，引用arch/arm/Makefile这个文 件，这个文件很重要，因为zImage、uImage等这些文件就是由arch/arm/Makefile来生成的 ## make xxx_defconfig ```makefile %config: scripts_basic outputmakefile FORCE \t$(Q)$(MAKE) $(build) scripts/kconfig $@ \t # 这个编译命令如下 \t@make f ./scripts/Makefile.build obj scripts/kconfig xxx_defconfig ``` 可以获取到以下的参数 ```c src scripts/kconfig kbuild dir ./scripts/kconfig kbuild file ./scripts/kconfig/Makefile include ./scripts/kconfig/Makefile ``` 加载`scripts/kconfig/Makefile`获取到实际的可以对应的编译命令 ```makefile %_defconfig: $(obj)/conf \t$(Q)$< $(silent) defconfig arch/$(SRCARCH)/configs/$@ $(Kconfig) # 展开获得 %_defconfig: scripts/kconfig/conf \t@ scripts/kconfig/conf defconfig arch/arm/configs/%_defconfig Kconfig ``` 软件`scripts/kconfig/conf`会将%_defconfig中的配置输出到.config文件中，最终生成Linux kernel根目录下 的.config文件 ### scripts_basic 依赖的文件编译如下 ```makefile scripts_basic: \t$(Q)$(MAKE) $(build) scripts/basic \t$(Q)rm f .tmp_quiet_recordmcount \t # 实际执行的命令是 \t@make f ./scripts/Makefile.build obj scripts/basic ``` 在执行的时候根据obj可以获取到两个参数] ```makefile kbuild dir ./scripts/basic kbuild file ./scripts/basic/Makefile ``` 使用include引用后面的这个文件进行下面的编译, 由于没有指定实际编译的文件, 所以在这里运行默认的编译命令 ```makefile __build: $(if $(KBUILD_BUILTIN),$(builtin target) $(lib target) $(extra y)) \\ \t $(if $(KBUILD_MODULES),$(obj m) $(modorder target)) \\ \t $(subdir ym) $(always) \t@: # 展开以后是 __build:$(builtin target) $(lib target) $(extra y)) $(subdir ym) $(always) \t@: ``` 只有always不为空, `always scripts/basic/fixdep scripts/basic/bin2c` > scripts_basic目标的作用就是编译出`scripts/basic/fixdep`和`scripts/basic/bin2c`这 两个软件 ## make 可以使用`make`或者`make all`编译内核 ```makefile # That's our default target when none is given on the command line PHONY : _all _all ``` ```makefile PHONY + all ifeq ($(KBUILD_EXTMOD),) _all: all # 运行的这个依赖 else _all: modules endif ``` ```makefile # The all: target is the default when no target is given on the # command line. # This allow a user to issue only 'make' to build a kernel including modules # Defaults to vmlinux, but the arch makefile usually adds further targets all: vmlinux ``` ```makefile # Include targets which we want to # execute if the rest of the kernel build went well. vmlinux: scripts/link vmlinux.sh $(vmlinux deps) FORCE ifdef CONFIG_HEADERS_CHECK \t$(Q)$(MAKE) f $(srctree)/Makefile headers_check endif ifdef CONFIG_SAMPLES \t$(Q)$(MAKE) $(build) samples endif ifdef CONFIG_BUILD_DOCSRC \t$(Q)$(MAKE) $(build) Documentation endif ifdef CONFIG_GDB_SCRIPTS \t$(Q)ln fsn `cd $(srctree) && /bin/pwd`/scripts/gdb/vmlinux gdb.py endif \t+$(call if_changed,link vmlinux) # 运行这一个, 依赖文件 ``` > `vmlinux deps $(KBUILD_LDS) $(KBUILD_VMLINUX_INIT) $(KBUILD_VMLINUX_MAIN)` > > + `KBUILD_LDS arch/$(SRCARCH)/kernel/vmlinux.lds` > + `KBUILD_VMLINUX_INIT $(head y) $(init y)` > + `KBUILD_VMLINUX_MAIN $(core y) $(libs y) $(drivers y) $(net y)` > > ```makefile > head y arch/arm/kernel/head.o > init y init/built in.o > drivers y drivers/built in.o sound/built in.o firmware/built in.o > net y net/built in.o > libs y arch/arm/lib/lib.a lib/lib.a arch/arm/lib/built in.o lib/built in.o > ``` > > core y: 依据不同的宏定义添加不同的模块 > > ```makefile > core y usr/built in.o arch/arm/vfp/built in.o \\ > arch/arm/vdso/built in.o arch/arm/kernel/built in.o \\ > arch/arm/mm/built in.o arch/arm/common/built in.o \\ > arch/arm/probes/built in.o arch/arm/net/built in.o \\ > arch/arm/crypto/built in.o arch/arm/firmware/built in.o \\ > arch/arm/mach imx/built in.o kernel/built in.o\\ > mm/built in.o fs/built in.o \\ > ipc/built in.o security/built in.o \\ > crypto/built in.o block/built in.o > ``` > > 最终将这些built in.o和.a文 件进行链接即可形成ELF格式的可执行文件，也就是vmlinux, `arch/arm/kernel/vmlinux.lds`就是整个Linux的链接脚本 `$(call if_changed,link vmlinux)`是调用函数`if_changed`，`link vmlinux`是函数`if_changed`的参数， 函数`if_changed`定义在文件`scripts/Kbuild.include` ```makefile # Execute command if command has changed or prerequisite(s) are updated. # if_changed $(if $(strip $(any prereq) $(arg check)), \\ \t@set e; \\ # 结果不对直接退出 \t$(echo cmd) $(cmd_$(1)); \\ \tprintf '%s\\n' 'cmd_$@ : $(make cmd)' > $(dot target).cmd) ``` > `any prereq`用于检查依赖文件是否有变化，如果依赖文件有变化那么`any prereq`就不为空，否则就为空。`arg check`用于检查参数是否有变化，如果没有变化那么`arg check`就为空 > > `$(echo cmd)`用于打印命令执行过程, `$(cmd_$(1)`表示执行`cmd_link vmlinux`的内容 > > ```makefile > # Final link of vmlinux > cmd_link vmlinux $(CONFIG_SHELL) $< $(LD) $(LDFLAGS) $(LDFLAGS_vmlinux) > quiet_cmd_link vmlinux LINK $@ > > # 展开以后是 > cmd_link vmlinux /bin/bash scripts/link vmlinux.sh arm linux gnueabihf ld EL p no u > ndefined X pic veneer build id > ``` > > ```bash > # Link of vmlinux > # ${1} optional extra .o files > # ${2} output file > vmlinux_link() > { > \tlocal lds \"${objtree}/${KBUILD_LDS}\" > > \tif [ \"${SRCARCH}\" ! \"um\" ]; then > \t\t${LD} ${LDFLAGS} ${LDFLAGS_vmlinux} o ${2} \\ > \t\t\t T ${lds} ${KBUILD_VMLINUX_INIT} \\ > \t\t\t start group ${KBUILD_VMLINUX_MAIN} end group ${1} > \telse > \t\t${CC} ${CFLAGS_vmlinux} o ${2} \\ > \t\t\t Wl, T,${lds} ${KBUILD_VMLINUX_INIT} \\ > \t\t\t Wl, start group \\ > \t\t\t\t ${KBUILD_VMLINUX_MAIN} \\ > \t\t\t Wl, end group \\ > \t\t\t lutil ${1} > \t\trm f linux > \tfi > } > ``` > > 运行的是前面的半段, `lds ./arch/arm/kernel/v mlinux.lds` ### built in.o文件 `$(sort $(vmlinux deps)): $(vmlinux dirs) ;`: `vmlinux deps`里面的文件是依赖于vmlinux dirs的, 同时可以并且去掉重复的单词 ```makefile vmlinux dirs\t: $(patsubst %/,%,$(filter %/, $(init y) $(init m) \\ \t\t $(core y) $(core m) $(drivers y) $(drivers m) \\ \t\t $(net y) $(net m) $(libs y) $(libs m))) # 展开 vmlinux dirs init usr arch/arm/vfp \\ arch/arm/vdso arch/arm/kernel arch/arm/mm \\ arch/arm/common arch/arm/probes arch/arm/net \\ arch/arm/crypto arch/arm/firmware arch/arm/mach imx\\ kernel mm fs \\ ipc security crypto \\ block drivers sound \\ firmware net arch/arm/lib \\ \tlib ``` ```c $(vmlinux dirs): prepare scripts \t$(Q)$(MAKE) $(build) $@ ``` > `build \" f ./scripts/Makefile.build obj\"`, 所以实际是替换为`@ make f ./scripts/Makefile.build obj $@` > > 会运行比如`@ make f ./scripts/Makefile.build obj init `的代码 使用的还是默认目标, __build 默认的目标可以简化为 ```makefile __build: $(builtin target) $(lib target) $(extra y)) $(subdir ym) $(always) @: ``` > 主要需要关注的是buildin target, 把一系列的文件打包成一个.o文件 > > ```makefile > builtin target : $(obj)/built in.o > > cmd_link_o_target $(if $(strip $(obj y)),\\ > \t\t $(LD) $(ld_flags) r o $@ $(filter $(obj y), $^) \\ > \t\t $(cmd_secanalysis),\\ > \t\t rm f $@; $(AR) rcs$(KBUILD_ARFLAGS) $@) > > $(builtin target): $(obj y) FORCE > \t$(call if_changed,link_o_target) > ``` > > 这里的obj y来自于使用kbuild file引用进来的对应文件夹下面的Makefile文件 ## zImage文件 vmlinux是ELF格式的文件，但是在实际中我们不会使用vmlinux，而是使用zImage或uImage这样的Linux内核镜像文件 + vmlinux: 是编译出来的最原始的内核文件，是未压缩的 + Image: 是使 用objcopy 取消掉 vmlinux 中的一些其他信息，比如符号表什么的。但是Image 是没有压缩过 的，Image保存在arch/arm/boot 目录下 + zImage 是经过gzip压缩后的Image + uImage 是老版本 uboot 专用的镜像文件，uImag 是在 zImage 前面加了一个长度为 64 字节的“头”，这个头信息描述了该镜像文件的类型、加载位置、生成时间、大小等信息。但是 新的uboot已经支持了zImage启动 在arch/arm/Makefile 中有`BOOT_TARGETS zImage Image xipImage bootpImage uImage ` ```makefile $(BOOT_TARGETS): vmlinux \t$(Q)$(MAKE) $(build) $(boot) MACHINE $(MACHINE) $(boot)/$@ \t # zImage使用的 @ make f ./scripts/Makefile.build obj arch/arm/boot MACHINE arch/arm/boot/zImage ```"},"/note/Linux/野火Linux/2025-11-22-77-PWM.html":{"title":"PWM","content":"# PWM I.MX6ULL有8路PWM输出，因此对应8个PWM控制器，所有在设备树下就有 8个PWM控制器节点。这8路PWM都属于 I.MX6ULL的AIPS 1域，但是在设备树imx6ull.dtsi中分为了两部分，PWM1~PWM4在一起，PWM5~PWM8在一起，这8路PWM并没有全部放到一起 ## 驱动 ### 设备树 对应的文档是`Documentation/devicetree/bindings/pwm/imx pwm.txt`, 查找到的驱动文件是`drivers/pwm/pwm imx.c` ```json pwm3: pwm@02088000 { compatible \"fsl,imx6ul pwm\", \"fsl,imx27 pwm\"; reg <0x02088000 0x4000>; interrupts <GIC_SPI 85 IRQ_TYPE_LEVEL_HIGH>; clocks <&clks IMX6UL_CLK_DUMMY>, <&clks IMX6UL_CLK_DUMMY>; clock names \"ipg\", \"per\"; #pwm cells <2>; }; pinctrl_pwm3: pwm3grp { fsl,pins < MX6UL_PAD_GPIO1_IO04__PWM3_OUT 0x110b0 >; }; &pwm3 { pinctrl names \"default\"; pinctrl 0 <&pinctrl_pwm3>; clocks <&clks IMX6UL_CLK_PWM3>, <&clks IMX6UL_CLK_PWM3>; status \"okay\"; }; ``` ### PWM子系统 Linux内核提供了个 PWM子系统框架，编写 PWM驱动的时候一定要符合这个框架 #### 数据结构 ```c /** * struct pwm_chip abstract a PWM controller * @dev: device providing the PWMs * @list: list node for internal use * @ops: callbacks for this PWM controller * @base: number of first PWM controlled by this chip * @npwm: number of PWMs controlled by this chip * @pwms: array of PWM devices allocated by the framework * @can_sleep: must be true if the .config(), .enable() or .disable() * operations may sleep */ struct pwm_chip { \tstruct device\t\t*dev; \tstruct list_head\tlist; \tconst struct pwm_ops\t*ops; \tint\t\t\tbase; \tunsigned int\t\tnpwm; \tstruct pwm_device\t*pwms; \tstruct pwm_device *\t(*of_xlate)(struct pwm_chip *pc, \t\t\t\t\t const struct of_phandle_args *args); \tunsigned int\t\tof_pwm_n_cells; \tbool\t\t\tcan_sleep; }; ``` pwm_ops结构体就是 PWM外设的各种操作函数集合，编写 PWM外设驱动的时候需要开发人员实现 ```c /** * struct pwm_ops PWM controller operations * @request: optional hook for requesting a PWM * @free: optional hook for freeing a PWM * @config: configure duty cycles and period length for this PWM * @set_polarity: configure the polarity of this PWM * @enable: enable PWM output toggling * @disable: disable PWM output toggling * @dbg_show: optional routine to show contents in debugfs * @owner: helps prevent removal of modules exporting active PWMs */ struct pwm_ops { \tint\t\t\t(*request)(struct pwm_chip *chip, \t\t\t\t\t struct pwm_device *pwm); \tvoid\t\t\t(*free)(struct pwm_chip *chip, \t\t\t\t\tstruct pwm_device *pwm); \tint\t\t\t(*config)(struct pwm_chip *chip, \t\t\t\t\t struct pwm_device *pwm, \t\t\t\t\t int duty_ns, int period_ns); \tint\t\t\t(*set_polarity)(struct pwm_chip *chip, \t\t\t\t\t struct pwm_device *pwm, \t\t\t\t\t enum pwm_polarity polarity); \tint\t\t\t(*enable)(struct pwm_chip *chip, \t\t\t\t\t struct pwm_device *pwm); \tvoid\t\t\t(*disable)(struct pwm_chip *chip, \t\t\t\t\t struct pwm_device *pwm); #ifdef CONFIG_DEBUG_FS \tvoid\t\t\t(*dbg_show)(struct pwm_chip *chip, \t\t\t\t\t struct seq_file *s); #endif \tstruct module\t\t*owner; }; ``` 初始化以后使用下面的函数进行注册 ```c int pwmchip_add(struct pwm_chip *chip); int pwmchip_remove(struct pwm_chip *chip); ``` #### 驱动文件 ```c /* * simple driver for PWM (Pulse Width Modulator) controller * * This program is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License version 2 as * published by the Free Software Foundation. * * Derived from pxa PWM driver by eric miao <eric.miao@marvell.com> */ #include <linux/module.h> #include <linux/kernel.h> #include <linux/platform_device.h> #include <linux/slab.h> #include <linux/err.h> #include <linux/clk.h> #include <linux/delay.h> #include <linux/io.h> #include <linux/pwm.h> #include <linux/of.h> #include <linux/of_device.h> /* i.MX1 and i.MX21 share the same PWM function block: */ #define MX1_PWMC\t\t\t0x00 /* PWM Control Register */ #define MX1_PWMS\t\t\t0x04 /* PWM Sample Register */ #define MX1_PWMP\t\t\t0x08 /* PWM Period Register */ #define MX1_PWMC_EN\t\t\t(1 << 4) /* i.MX27, i.MX31, i.MX35 share the same PWM function block: */ #define MX3_PWMCR\t\t\t0x00 /* PWM Control Register */ #define MX3_PWMSR\t\t\t0x04 /* PWM Status Register */ #define MX3_PWMSAR\t\t\t0x0C /* PWM Sample Register */ #define MX3_PWMPR\t\t\t0x10 /* PWM Period Register */ #define MX3_PWMCR_PRESCALER(x)\t\t((((x) 1) & 0xFFF) << 4) #define MX3_PWMCR_DOZEEN\t\t(1 << 24) #define MX3_PWMCR_WAITEN\t\t(1 << 23) #define MX3_PWMCR_DBGEN\t\t\t(1 << 22) #define MX3_PWMCR_CLKSRC_IPG_HIGH\t(2 << 16) #define MX3_PWMCR_CLKSRC_IPG\t\t(1 << 16) #define MX3_PWMCR_SWR\t\t\t(1 << 3) #define MX3_PWMCR_EN\t\t\t(1 << 0) #define MX3_PWMSR_FIFOAV_4WORDS\t\t0x4 #define MX3_PWMSR_FIFOAV_MASK\t\t0x7 #define MX3_PWM_SWR_LOOP\t\t5 struct imx_chip { \tstruct clk\t*clk_per; \tstruct clk\t*clk_ipg; \tvoid __iomem\t*mmio_base; \tstruct pwm_chip\tchip; \tint (*config)(struct pwm_chip *chip, \t\tstruct pwm_device *pwm, int duty_ns, int period_ns); \tvoid (*set_enable)(struct pwm_chip *chip, bool enable); }; #define to_imx_chip(chip)\tcontainer_of(chip, struct imx_chip, chip) static int imx_pwm_config_v1(struct pwm_chip *chip, \t\tstruct pwm_device *pwm, int duty_ns, int period_ns) { \tstruct imx_chip *imx to_imx_chip(chip); \t/* \t * The PWM subsystem allows for exact frequencies. However, \t * I cannot connect a scope on my device to the PWM line and \t * thus cannot provide the program the PWM controller \t * exactly. Instead, I'm relying on the fact that the \t * Bootloader (u boot or WinCE+haret) has programmed the PWM \t * function group already. So I'll just modify the PWM sample \t * register to follow the ratio of duty_ns vs. period_ns \t * accordingly. \t * \t * This is good enough for programming the brightness of \t * the LCD backlight. \t * \t * The real implementation would divide PERCLK[0] first by \t * both the prescaler (/1 .. /128) and then by CLKSEL \t * (/2 .. /16). \t */ \tu32 max readl(imx >mmio_base + MX1_PWMP); \tu32 p max * duty_ns / period_ns; \twritel(max p, imx >mmio_base + MX1_PWMS); \treturn 0; } static void imx_pwm_set_enable_v1(struct pwm_chip *chip, bool enable) { \tstruct imx_chip *imx to_imx_chip(chip); \tu32 val; \tval readl(imx >mmio_base + MX1_PWMC); \tif (enable) \t\tval MX1_PWMC_EN; \telse \t\tval & ~MX1_PWMC_EN; \twritel(val, imx >mmio_base + MX1_PWMC); } // 配置对应的pwmv2, 设置占空比以及输出频率 // 根据参数duty_ns和period_ns来计算出应该写入到寄存器里面的值duty_cycles和period_cycles // duty_ns占空比, period_ns周期时间 static int imx_pwm_config_v2(struct pwm_chip *chip, \t\tstruct pwm_device *pwm, int duty_ns, int period_ns) { \tstruct imx_chip *imx to_imx_chip(chip); \tstruct device *dev chip >dev; \tunsigned long long c; \tunsigned long period_cycles, duty_cycles, prescale; \tunsigned int period_ms; \tbool enable test_bit(PWMF_ENABLED, &pwm >flags); \tint wait_count 0, fifoav; \tu32 cr, sr; \t/* \t * i.MX PWMv2 has a 4 word sample FIFO. \t * In order to avoid FIFO overflow issue, we do software reset \t * to clear all sample FIFO if the controller is disabled or \t * wait for a full PWM cycle to get a relinquished FIFO slot \t * when the controller is enabled and the FIFO is fully loaded. \t */ \tif (enable) { \t\tsr readl(imx >mmio_base + MX3_PWMSR); \t\tfifoav sr & MX3_PWMSR_FIFOAV_MASK; \t\tif (fifoav MX3_PWMSR_FIFOAV_4WORDS) { \t\t\tperiod_ms DIV_ROUND_UP(pwm >period, NSEC_PER_MSEC); \t\t\tmsleep(period_ms); \t\t\tsr readl(imx >mmio_base + MX3_PWMSR); \t\t\tif (fifoav (sr & MX3_PWMSR_FIFOAV_MASK)) \t\t\t\tdev_warn(dev, \"there is no free FIFO slot\\n\"); \t\t} \t} else { \t\twritel(MX3_PWMCR_SWR, imx >mmio_base + MX3_PWMCR); \t\tdo { \t\t\tusleep_range(200, 1000); \t\t\tcr readl(imx >mmio_base + MX3_PWMCR); \t\t} while ((cr & MX3_PWMCR_SWR) && \t\t\t (wait_count++ < MX3_PWM_SWR_LOOP)); \t\tif (cr & MX3_PWMCR_SWR) \t\t\tdev_warn(dev, \"software reset timeout\\n\"); \t} \tc clk_get_rate(imx >clk_per); \tc c * period_ns; \tdo_div(c, 1000000000); \tperiod_cycles c; \tprescale period_cycles / 0x10000 + 1; \tperiod_cycles / prescale; \tc (unsigned long long)period_cycles * duty_ns; \tdo_div(c, period_ns); \tduty_cycles c; \t/* \t * according to imx pwm RM, the real period value should be \t * PERIOD value in PWMPR plus 2. \t */ \tif (period_cycles > 2) \t\tperiod_cycles 2; \telse \t\tperiod_cycles 0; \twritel(duty_cycles, imx >mmio_base + MX3_PWMSAR); \twritel(period_cycles, imx >mmio_base + MX3_PWMPR); \tcr MX3_PWMCR_PRESCALER(prescale) \t\tMX3_PWMCR_DOZEEN MX3_PWMCR_WAITEN \t\tMX3_PWMCR_DBGEN MX3_PWMCR_CLKSRC_IPG_HIGH; \tif (enable) \t\tcr MX3_PWMCR_EN; \twritel(cr, imx >mmio_base + MX3_PWMCR); \treturn 0; } // 使能 static void imx_pwm_set_enable_v2(struct pwm_chip *chip, bool enable) { \tstruct imx_chip *imx to_imx_chip(chip); \tu32 val; \tval readl(imx >mmio_base + MX3_PWMCR); \tif (enable) \t\tval MX3_PWMCR_EN; \telse \t\tval & ~MX3_PWMCR_EN; \twritel(val, imx >mmio_base + MX3_PWMCR); } static int imx_pwm_config(struct pwm_chip *chip, \t\tstruct pwm_device *pwm, int duty_ns, int period_ns) { \tstruct imx_chip *imx to_imx_chip(chip); \tint ret; \tret clk_prepare_enable(imx >clk_ipg); \tif (ret) \t\treturn ret; \tret imx >config(chip, pwm, duty_ns, period_ns); // 配置pwm的周期 \tclk_disable_unprepare(imx >clk_ipg); \treturn ret; } static int imx_pwm_enable(struct pwm_chip *chip, struct pwm_device *pwm) { \tstruct imx_chip *imx to_imx_chip(chip); \tint ret; \tret clk_prepare_enable(imx >clk_per); \tif (ret) \t\treturn ret; \timx >set_enable(chip, true); // 调用实际的enable函数 \treturn 0; } static void imx_pwm_disable(struct pwm_chip *chip, struct pwm_device *pwm) { \tstruct imx_chip *imx to_imx_chip(chip); \timx >set_enable(chip, false); \tclk_disable_unprepare(imx >clk_per); } static struct pwm_ops imx_pwm_ops { \t.enable imx_pwm_enable, \t.disable imx_pwm_disable, \t.config imx_pwm_config, \t.owner THIS_MODULE, }; struct imx_pwm_data { \tint (*config)(struct pwm_chip *chip, \t\tstruct pwm_device *pwm, int duty_ns, int period_ns); \tvoid (*set_enable)(struct pwm_chip *chip, bool enable); }; static struct imx_pwm_data imx_pwm_data_v1 { \t.config imx_pwm_config_v1, \t.set_enable imx_pwm_set_enable_v1, }; static struct imx_pwm_data imx_pwm_data_v2 { \t.config imx_pwm_config_v2, \t.set_enable imx_pwm_set_enable_v2, }; static const struct of_device_id imx_pwm_dt_ids[] { \t{ .compatible \"fsl,imx1 pwm\", .data &imx_pwm_data_v1, }, \t{ .compatible \"fsl,imx27 pwm\", .data &imx_pwm_data_v2, }, // 使用v2版本 \t{ /* sentinel */ } }; MODULE_DEVICE_TABLE(of, imx_pwm_dt_ids); static int imx_pwm_probe(struct platform_device *pdev) { \tconst struct of_device_id *of_id \t\t\tof_match_device(imx_pwm_dt_ids, &pdev >dev); \tconst struct imx_pwm_data *data; \tstruct imx_chip *imx; \tstruct resource *r; \tint ret 0; \tif (!of_id) \t\treturn ENODEV; \timx devm_kzalloc(&pdev >dev, sizeof(*imx), GFP_KERNEL); \tif (imx NULL) \t\treturn ENOMEM; \timx >clk_per devm_clk_get(&pdev >dev, \"per\"); \tif (IS_ERR(imx >clk_per)) { \t\tdev_err(&pdev >dev, \"getting per clock failed with %ld\\n\", \t\t\t\tPTR_ERR(imx >clk_per)); \t\treturn PTR_ERR(imx >clk_per); \t} \t \timx >clk_ipg devm_clk_get(&pdev >dev, \"ipg\"); \tif (IS_ERR(imx >clk_ipg)) { \t\tdev_err(&pdev >dev, \"getting ipg clock failed with %ld\\n\", \t\t\t\tPTR_ERR(imx >clk_ipg)); \t\treturn PTR_ERR(imx >clk_ipg); \t} \t// 初始化pwm子系统 \timx >chip.ops &imx_pwm_ops; \timx >chip.dev &pdev >dev; \timx >chip.base 1; \timx >chip.npwm 1; \timx >chip.can_sleep true; \t// 寄存器 \tr platform_get_resource(pdev, IORESOURCE_MEM, 0); \timx >mmio_base devm_ioremap_resource(&pdev >dev, r); \tif (IS_ERR(imx >mmio_base)) \t\treturn PTR_ERR(imx >mmio_base); \tdata of_id >data; \timx >config data >config; \timx >set_enable data >set_enable; \t// 添加pwm子系统 \tret pwmchip_add(&imx >chip); \tif (ret < 0) \t\treturn ret; \tplatform_set_drvdata(pdev, imx); \treturn 0; } static int imx_pwm_remove(struct platform_device *pdev) { \tstruct imx_chip *imx; \timx platform_get_drvdata(pdev); \tif (imx NULL) \t\treturn ENODEV; \treturn pwmchip_remove(&imx >chip); } static struct platform_driver imx_pwm_driver { \t.driver\t\t { \t\t.name\t \"imx pwm\", \t\t.of_match_table imx_pwm_dt_ids, \t}, \t.probe\t\t imx_pwm_probe, \t.remove\t\t imx_pwm_remove, }; module_platform_driver(imx_pwm_driver); MODULE_LICENSE(\"GPL v2\"); MODULE_AUTHOR(\"Sascha Hauer <s.hauer@pengutronix.de>\"); ``` ## 实际使用 ```c > Device Drivers > Pulse Width Modulation (PWM) Support > <*> i.MX PWM support ``` 我们可以直接在用户层来配置PWM，进入目录/sys/class/pwm中里面是不同的pwmchip, 之前配置的是pwm3 ```c echo 0 > /sys/class/pwm/pwmchip2/export ``` 执行完成会在pwmchip2目录下生成一个名为`pwm0`的子目录 使能以及设置 ```bash echo 1 > /sys/class/pwm/pwmchip2/pwm0/enable # 周期以及高电平时间都是us echo 50000 > /sys/class/pwm/pwmchip2/pwm0/period echo 10000 > /sys/class/pwm/pwmchip2/pwm0/duty_cycle ``` ## 其他设备使用 有时候我们需要在某个外设上添加 PWM功能，比如，LCD的背光控制就是PWM来完成的 可以查看背光的文档Documentation/devicetree/bindings/video/backlight/pwm backlight.txt ```json \tbacklight { \t\tcompatible \"pwm backlight\"; \t\tpwms <&pwm1 0 5000000>; \t\tbrightness levels <0 4 8 16 32 64 128 255>; \t\tdefault brightness level <7>; \t\tstatus \"okay\"; \t}; ``` > + **compatible**：内容必须为“pwm backlight”，通过这个可以匹配到内核自带的 PWM背光驱动，驱动文件为drivers/video/backlight/pwm_bl.c，这里就不去分析驱动源码了。 > + **pwms**：此属性指定背光使用哪一路 PWM，以及PWM相关的属性。pwm1只有一个通道所以使用0 > + **brightness levels**：背光等级数组，范围0\\~255，对应占空比为0%\\~100%。数组内的值必须从 0 开始，也就是 0%占空比，最后一个值必须是 255，也就是 100%占空比。数组中间值的个数以及值大小可以自行定义。 > + **default brightness level**：默认的背光等级，也就是brightness levels属性中第几个值，注意这里是数索引编号，不是具体的数值！ > + **power supply**：支持的电压，此属性可以不需要。"},"/note/Linux/野火Linux/2025-7-12-04-镜像文件.html":{"title":"镜像文件","content":"# 镜像文件 ## boot ROM文件 选择一下内部的启动方式, 启动boot ROM程序 + 初始化时钟以及外部DDR3 > DDR3是一种计算机内存（随机存取存储器，DRAM）的类型，全称为“Double Data Rate 3 Synchronous Dynamic Random Access Memory”。它是DDR系列内存的第三代技术，广泛用于台式机、笔记本电脑和服务器中。 + 从外部的存储介质加载代码 > + 空偏移: 实际的代码的偏移位置, 和不同的存储介质有关 > + Image vector table: 记录关键数据的位置, IVT表, 记录Boot Data数据以及Device Configeration Data两个的位置 > + Boot data: 启动数据, 镜像的加载地址以及大小 > + Device Configeration Data: 记录代码的外设寄存器配置信息, 时钟以及DDR3的配置 > + bin: 实际的程序 > > 启动的时候首先获取一下Image vector table的信息 ![image 20250712191220612](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507121912720.png) 空偏移, 不同介质不同, 第一次读取的大小也不同 ![image 20250712191354310](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507121913350.png) IVT表 ![image 20250712191526735](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507121915797.png) header: 表的长度 entry: 代码的入口 dcd: dcd数据的位置 self: 自己的位置 ![image 20250712191707037](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507121917088.png) ![image 20250712202052912](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507122020969.png) Header记录大小以及版本 ![image 20250712202154430](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507122021517.png) Tag: DCD命令, 一般是写寄存器 Length: 命令的大小 Parameter: 写寄存器的方法(写值, 清除, 设置位) Address: 寄存器地址 Value: 具体的值 ## 烧录方法 这里使用官方的SDK镜像文件进行测试 他的SDk工具里面可以在bin文件上面加入上一章提到的数据结构 [Applications Processors with Power Efficient ARM Cortex A7 NXP Semiconductors](https://www.nxp.com/products/i.MX6ULL?&tab Design_Tools_Tab&) ![image 20250712204339487](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507122043555.png) ![image 20250712211439833](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507122114873.png) 可以使用`tools/imgutil`工具进行 ![image 20250712212323469](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507122123532.png) ![image 20250712212740426](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507122127467.png) ```bash #!/bin/bash # 帮助信息 function usage() { echo \"Usage: $0 target\" echo \" target: ram the image will be loaded to RAM and run, the application must be built with ram link file\" echo \" target: flash the image will be run on flash directly, the application must be build with flash link file\" echo \" target: sd the image will be loaded from SD to RAM and run, the application must be build with ram link file\" echo \"Example: $0 ram\" } # 参数不匹配的时候 if [ \"$#\" ne 1 ]; then usage $0 exit 1 fi # 获取一下实际的系统 SYSTEM `uname s` if [ $SYSTEM \"Linux\" ]; then DCD_BUILDER dcdgen.bin IMG_BUILDER imgutil.bin else DCD_BUILDER dcdgen.exe IMG_BUILDER imgutil.exe fi # dcd.config是寄存器的配置, 生成bin文件 ../bin/$DCD_BUILDER dcd.config dcd.bin # 不同的设备使用不同的配置 if [ \"$1\" \"ram\" ]; then ../bin/$IMG_BUILDER combine base_addr 0x80000000 ivt_offset 0x1000 app_offset 0x2000 dcd_file dcd.bin app_file sdk20 app.bin ofile sdk20 app.img image_entry_point 0x80002000 elif [ \"$1\" \"flash\" ]; then ../bin/$IMG_BUILDER combine base_addr 0x60000000 ivt_offset 0x1000 app_offset 0x2000 dcd_file dcd.bin app_file sdk20 app.bin ofile sdk20 app.img image_entry_point 0x60002000 elif [ \"$1\" \"sd\" ]; then ../bin/$IMG_BUILDER combine base_addr 0x80000000 ivt_offset 0x400 app_offset 0x2000 dcd_file dcd.bin app_file sdk20 app.bin ofile sdk20 app.img image_entry_point 0x80002000 else echo \"Unsupported target $1\" usage $0 fi ``` 野火重新这部分, 加入烧录部分 ```bash #!/bin/bash function usage() { echo \"Usage: $0 file\" echo \"\tfile : the image which you want to burn \" echo \"Example: $0 helloworld.bin\" } # 根据使用的用户, 如果是root报错 cur_user `env grep USER cut d \" \" f 2` echo $cur_user if [ $cur_user \"root\" ]; then \techo e \"\\033[31mThe cur_user is $cur_user. Please run the script with a normal user.\\033[0m\" \texit 1 fi if [ \"$#\" ne 1 ]; then usage $0 exit 1 fi SYSTEM `uname s` if [ $SYSTEM \"Linux\" ]; then DCD_BUILDER dcdgen.bin IMG_BUILDER imgutil.bin else \t\texit 1 fi cat /proc/partitions while true do # 读取实际的SD卡路径 read p \"Please Input the card ID [a~z]: (Input 'exit' for quit):\" dev_index case $dev_index in [[:lower:]]) break ;; exit) exit 0 ;; * ) echo e \"\\033[31mInvalid parameter!\\033[0m\" \t\t\t\techo e \"\\033[31mThe parameter should be between a~z, enter 'exit' to quit.\\033[0m\" \t\t\t\techo e \"\\033[34mUsage: If the SD card device corresponds to /dev/sdd, enter d\\033[0m\" \t\tcontinue ;; esac done sd_idnex sd$dev_index echo $sd_index # 查看磁盘是不是存在 if [ ! e /dev/$sd_idnex ]; then \techo \"mkimage : /dev/$sd_idnex : No such file or directory\" \texit 1 fi # 查看一下程序是不是可以执行 if [ ! x $DCD_BUILDER ]; then \tchmod +x $DCD_BUILDER fi if [ ! x $IMG_BUILDER ]; then \tchmod +x $IMG_BUILDER fi ./$DCD_BUILDER dcd.config dcd.bin ./$IMG_BUILDER combine base_addr 0x80000000 ivt_offset 0x400 app_offset 0x2000 dcd_file dcd.bin app_file $1 ofile sdk20 app.img image_entry_point 0x80002000 # 下载 sudo dd if sdk20 app.img of /dev/$sd_idnex bs 512 conv fsync ``` > 1. **` combine`** > 指定操作模式为\"组合\"，表示将多个组件合并成一个完整镜像 > 2. **`base_addr 0x80000000`** > 内存加载基地址（Load Address） > 表示镜像将被加载到内存的 `0x80000000` 位置 > 这是 i.MX6ULL 的 DDR SDRAM 起始地址 > 3. **`ivt_offset 0x400`** > IVT（中断向量表）在镜像中的偏移量 > 计算实际内存地址：`0x80000000 + 0x400 0x80000400` > IVT 是 i.MX 启动过程的核心数据结构 > 4. **`app_offset 0x2000`** > 应用程序在镜像中的偏移量（8KB 位置） > 计算实际内存地址：`0x80000000 + 0x2000 0x80002000` > 这是应用程序代码的起始位置 > 5. **`dcd_file dcd.bin`** > DCD（设备配置数据）文件路径 > 包含 DDR 控制器、时钟等外设的初始化配置 > 由 BootROM 在启动阶段自动加载执行 > 6. **`app_file $1`** > 输入的应用程序二进制文件（通常是编译后的 `.bin` 文件） > `$1` 表示脚本的第一个命令行参数 > 7. **`ofile sdk20 app.img`** > 输出的完整镜像文件名 > 8. **`image_entry_point 0x80002000`** > 程序入口点地址 > 必须与 `app_offset` 计算出的地址一致：`0x80000000 + 0x2000` > > ### 生成的镜像结构： > > 内存地址 偏移量 内容 大小 > : : : : > 0x80000000 0x0000 镜像起始 > ... ... (填充区) > 0x80000400 0x0400 **IVT 结构** 32字节 > 0x80000420 0x0420 **DCD 数据** 可变 > ... ... (填充区) > **0x80002000** 0x2000 **应用程序代码** 可变 > ... ... 镜像结束 ![image 20250712215445997](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507122154054.png) > 断开连接的SD卡识别到虚拟机里面 > > ![image 20250712215525817](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507122155864.png)"},"/note/Linux/野火Linux/2025-9-17-24-GPIO子系统.html":{"title":"GPIO子系统","content":"# GPIO子系统 ## 使用 1. 在iomuxc节点里面配置引脚的复用以及引脚的属性 2. 在实际使用的设备里面添加`pinctrl 0`属性, 进行引脚的初始化 3. 添加对应的gpio的描述 4. 代码里面使用register等实际使用 ## gpio1节点 GPIO1控制器的寄存器基地址 类似的还有gpio2~5 **imx6ull.dtsi**, 对应的驱动在gpio mxc.c文件里面 ```json gpio1: gpio@209c000 { \t\t\t\tcompatible \"fsl,imx6ul gpio\", \"fsl,imx35 gpio\"; \t\t\t\treg <0x209c000 0x4000>; \t\t\t\tinterrupts <GIC_SPI 66 IRQ_TYPE_LEVEL_HIGH>, \t\t\t\t\t <GIC_SPI 67 IRQ_TYPE_LEVEL_HIGH>; \t\t\t\tclocks <&clks IMX6UL_CLK_GPIO1>; \t\t\t\tgpio controller; \t\t\t\t#gpio cells <2>; \t\t\t\tinterrupt controller; \t\t\t\t#interrupt cells <2>; \t\t\t\tgpio ranges <&iomuxc 0 23 10>, \t\t\t\t\t\t\t<&iomuxc 10 17 6>, \t\t\t\t\t <&iomuxc 16 33 16>; \t\t\t}; ``` compatible：与GPIO子系统的平台驱动做匹配 reg：GPIO寄存器的基地址 ![image 20200709145109364](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509172223429.png) ![image 20200709145133580](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509172223440.png) interrupts：GPIO中断相关 clocks：GPIO外设时钟相关 gpio controller：表示 gpio1 节点是个 GPIO 控制器 #gpio cells：表示要用2个cell描述一个 GPIO引脚, 其他节点引用该 GPIO 时需提供 2 个参数，通常格式为`<引脚号 标志>`： interrupt controller：表示 gpio1 节点是个中断控制器, GPIO 控制器可以转发其下 GPIO 引脚产生的中断（如外部设备通过 GPIO 引脚触发的中断）。 #interrupt cells：表示要用2个cell描述一个中断, 表示其他节点通过该 GPIO 控制器声明中断时需提供 2 个参数，通常格式为`<引脚号 触发类型>` gpio ranges：gpio编号转换成pin编号, gpio子系统和pin子系统之间的关系, `<&iomuxc 0 23 10>`, 该 GPIO 控制器的`0~9`号引脚（共 10 个），对应`iomuxc`（引脚复用控制器）的`23~32`号物理引脚。 **imx6ull seeed npi.dts** 新增rgb_led节点，使用gpio子系统 ```json rgb_led{ #address cells <1>; #size cells <1>; pinctrl names \"default\"; compatible \"fire,rgb_led\"; pinctrl 0 <&pinctrl_rgb_led>; rgb_led_red <&gpio1 4 GPIO_ACTIVE_LOW>; rgb_led_green <&gpio4 20 GPIO_ACTIVE_LOW>; rgb_led_blue <&gpio4 19 GPIO_ACTIVE_LOW>; status \"okay\"; }; ``` rgb_led_red：自定义属性，&gpio1 4表示GPIO1_IO04，GPIO_ACTIVE_LOW表示低电平有效, 格式遵循 GPIO 控制器节点（如`gpio1`）中`#gpio cells <2>`的定义，每个 GPIO 描述为 `<&gpio控制器 引脚号 有效电平标志>` , rgb_led_red是这个引脚的属性名, 可以使用这个属性名进行查找这个GPIO 一个名字里面可以设置多个不同的gpio ## 常用函数 ### of_get_named_gpio()函数 函数原型： ```c static inline int of_get_named_gpio(struct device_node *np, const char *propname, int index) ``` 参数： np：指定的设备树节点 propname：GPIO属性名, 设备数里面设定的, 比如rgb_led_red index：这一组引脚里面的引脚索引值 返回值： 成功：GPIO编号 失败：负数 ### gpio_request()函数 进行引脚的注册, 避免通一个引脚被重复使用 函数原型： ```c static inline int gpio_request(unsigned gpio, const char *label) ``` 参数： gpio：要申请的GPIO编号 label：给 gpio 设置个名字\\ > 内核会记录每个 GPIO 引脚的 `label` 信息，开发者可通过调试接口（如 `/sys/kernel/debug/gpio` 或 `/proc/gpio`）查看哪个驱动 / 功能占用了该 GPIO > > ![image 20250917230750582](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509172307654.png) 返回值： 成功：0 失败：负数 ### gpio_free()函数 释放申请的gpio 函数原型： ```c static inline void gpio_free(unsigned gpio); ``` 参数： gpio：要释放的GPIO编号 返回值： 无 ### gpio_direction_output()函数 设置引脚为输出模式 函数原型： ```c static inline int gpio_direction_output(unsigned gpio , int value)； ``` 参数： gpio：要操作的GPIO编号 value：设置默认输出值 返回值： 成功：0 失败：负数 ### gpio_direction_input()函数 设置引脚为输入模式 函数原型： ```c int gpio_direction_input(unsigned gpio) ``` 参数： gpio：要操作的GPIO编号 返回值： 成功：0 失败：负数 ### gpio_get_value()函数 函数原型： ```c #define gpio_get_value __gpio_get_value int __gpio_get_value(unsigned gpio) ``` 参数： gpio：要操作的GPIO编号 返回值： 成功： GPIO的电平值 失败：负数 ### gpio_set_value()函数 函数原型： ```c #define gpio_set_value __gpio_set_value void __gpio_set_value(unsigned gpio, int ;) ``` 参数： gpio：要操作的GPIO编号 value：要设置的输出值 返回值： 无 ## 实际使用 ```c #include <linux/init.h> #include <linux/module.h> #include <linux/fs.h> #include <linux/cdev.h> #include <linux/uaccess.h> #include <linux/string.h> #include <linux/types.h> #include <linux/kernel.h> #include <linux/delay.h> #include <linux/ide.h> #include <linux/errno.h> #include <linux/gpio.h> #include <asm/mach/map.h> #include <linux/of.h> #include <linux/of_address.h> #include <linux/of_gpio.h> #include <asm/io.h> #include <linux/device.h> #include <linux/platform_device.h> /* 字符设备内容 */ #define DEV_NAME \"rgb_led\" #define DEV_CNT (1) int rgb_led_red; int rgb_led_green; int rgb_led_blue; /*定义 led 资源结构体，保存获取得到的节点信息以及转换后的虚拟寄存器地址*/ struct led_resource { \tstruct device_node *device_node; //rgb_led_red的设备树节点 \tvoid __iomem *virtual_CCM_CCGR; \tvoid __iomem *virtual_IOMUXC_SW_MUX_CTL_PAD; \tvoid __iomem *virtual_IOMUXC_SW_PAD_CTL_PAD; \tvoid __iomem *virtual_DR; \tvoid __iomem *virtual_GDIR; }; static dev_t led_devno;\t\t\t\t\t //定义字符设备的设备号 static struct cdev led_chr_dev;\t\t\t //定义字符设备结构体chr_dev struct class *class_led;\t\t\t\t //保存创建的类 struct device *device;\t\t\t\t\t // 保存创建的设备 struct device_node *rgb_led_device_node; //rgb_led的设备树节点结构体 /*定义 R G B 三个灯的led_resource 结构体，保存获取得到的节点信息*/ struct led_resource led_red; struct led_resource led_green; struct led_resource led_blue; /*字符设备操作函数集，open函数*/ static int led_chr_dev_open(struct inode *inode, struct file *filp) { \tprintk(\"\\n open form driver \\n\"); \treturn 0; } /*字符设备操作函数集，write函数*/ static ssize_t led_chr_dev_write(struct file *filp, const char __user *buf, size_t cnt, loff_t *offt) { \tint ret,error; \tunsigned int register_data 0; //暂存读取得到的寄存器数据 \tunsigned char receive_data[10]; //用于保存接收到的数据 \tunsigned int write_data; //用于保存接收到的数据 \tif(cnt>10) \t\t\tcnt 10; \terror copy_from_user(receive_data, buf, cnt); \tif (error < 0) \t{ \t\treturn 1; \t} \tret kstrtoint(receive_data, 16, &write_data); \tif (ret) { \t\treturn 1; } \t/*设置 GPIO1_04 输出电平*/ \tif (write_data & 0x04) \t{ \t\tgpio_set_value(rgb_led_red,0); \t} \telse \t{ \t\tgpio_set_value(rgb_led_red,1); \t} \t/*设置 GPIO4_20 输出电平*/ \tif (write_data & 0x02) \t{ \t\tgpio_set_value(rgb_led_green,0); \t} \telse \t{ \t\tgpio_set_value(rgb_led_green,1); \t} \t/*设置 GPIO4_19 输出电平*/ \tif (write_data & 0x01) \t{ \t\tgpio_set_value(rgb_led_blue,0); \t} \telse \t{ \t\tgpio_set_value(rgb_led_blue,1); \t} \treturn cnt; } /*字符设备操作函数集*/ static struct file_operations led_chr_dev_fops \t{ \t\t.owner THIS_MODULE, \t\t.open led_chr_dev_open, \t\t.write led_chr_dev_write, }; /* 平台驱动函数集 */ static int led_probe(struct platform_device *pdv) { \tint ret 1; //保存错误状态码 \tunsigned int register_data 0; \tprintk(KERN_ALERT \"\\t match successed \\n\"); \t/*获取rgb_led的设备树节点*/ \trgb_led_device_node of_find_node_by_path(\"/rgb_led\"); \tif (rgb_led_device_node NULL) \t{ \t\tprintk(KERN_ERR \"\\t get rgb_led failed! \\n\"); \t\treturn 1; \t} \trgb_led_red of_get_named_gpio(rgb_led_device_node,\"rgb_led_red\",0); \tif (rgb_led_red < 0) \t{ \t\tprintk(KERN_ERR \"\\t rgb_led_red failed! \\n\"); \t\treturn 1; \t} \trgb_led_green of_get_named_gpio(rgb_led_device_node,\"rgb_led_green\",0); \tif (rgb_led_green < 0) \t{ \t\tprintk(KERN_ERR \"\\t rgb_led_green failed! \\n\"); \t\treturn 1; \t} \trgb_led_blue of_get_named_gpio(rgb_led_device_node,\"rgb_led_blue\",0); \tif (rgb_led_blue < 0) \t{ \t\tprintk(KERN_ERR \"\\t rgb_led_blue failed! \\n\"); \t\treturn 1; \t} \tgpio_request(rgb_led_red, \"rgb_led:red\"); \tgpio_request(rgb_led_green, \"rgb_led:green\"); \tgpio_request(rgb_led_blue, \"rgb_led:blue\"); \tgpio_direction_output(rgb_led_red,1); \tgpio_direction_output(rgb_led_green,1); \tgpio_direction_output(rgb_led_blue,1); \t/* 注册 字符设备部分 */ \t//第一步 \t//采用动态分配的方式，获取设备编号，次设备号为0， \t//设备名称为rgb leds，可通过命令cat /proc/devices查看 \t//DEV_CNT为1，当前只申请一个设备编号 \tret alloc_chrdev_region(&led_devno, 0, DEV_CNT, DEV_NAME); \tif (ret < 0) \t{ \t\tprintk(\"fail to alloc led_devno\\n\"); \t\tgoto alloc_err; \t} \t//第二步 \t//关联字符设备结构体cdev与文件操作结构体file_operations \tled_chr_dev.owner THIS_MODULE; \tcdev_init(&led_chr_dev, &led_chr_dev_fops); \t//第三步 \t//添加设备至cdev_map散列表中 \tret cdev_add(&led_chr_dev, led_devno, DEV_CNT); \tif (ret < 0) \t{ \t\tprintk(\"fail to add cdev\\n\"); \t\tgoto add_err; \t} \t//第四步 \t/*创建类 */ \tclass_led class_create(THIS_MODULE, DEV_NAME); \t/*创建设备*/ \tdevice device_create(class_led, NULL, led_devno, NULL, DEV_NAME); \treturn 0; add_err: \t//添加设备失败时，需要注销设备号 \tunregister_chrdev_region(led_devno, DEV_CNT); \tprintk(\"\\n error! \\n\"); alloc_err: \treturn 1; } static const struct of_device_id rgb_led[] { \t{.compatible \"fire,rgb_led\"}, \t{/* sentinel */}}; /*定义平台设备结构体*/ struct platform_driver led_platform_driver { \t.probe led_probe, \t.driver { \t\t.name \"rgb leds platform\", \t\t.owner THIS_MODULE, \t\t.of_match_table rgb_led, \t}}; /* *驱动初始化函数 */ static int __init led_platform_driver_init(void) { \tint DriverState; \tDriverState platform_driver_register(&led_platform_driver); \tprintk(KERN_ALERT \"\\tDriverState is %d\\n\", DriverState); \treturn 0; } /* *驱动注销函数 */ static void __exit led_platform_driver_exit(void) { \t/*删除设备*/ \tdevice_destroy(class_led, led_devno);\t\t //清除设备 \tclass_destroy(class_led);\t\t\t\t\t //清除类 \tcdev_del(&led_chr_dev);\t\t\t\t\t\t //清除设备号 \tunregister_chrdev_region(led_devno, DEV_CNT); //取消注册字符设备 \tgpio_free(rgb_led_red); \tgpio_free(rgb_led_green); \tgpio_free(rgb_led_blue); \t/*注销字符设备*/ \tplatform_driver_unregister(&led_platform_driver); \tprintk(KERN_ALERT \"led_platform_driver exit!\\n\"); } module_init(led_platform_driver_init); module_exit(led_platform_driver_exit); MODULE_LICENSE(\"GPL\"); ```"},"/note/Linux/野火Linux/2025-9-27-35-软中断和tasklet.html":{"title":"","content":"## 软中断和tasklet基础概念 ## 使用 1. 内核编译时候 + `open_softirq`注册使用的函数, 这个中断必须在内核编译的时候静态的注册!!! + `raise_softirq` 触发 2. 驱动使用 + `struct tasklet_struct`初始化一个软中断的各个数据, 使用函数`tasklet_init`, 可以使用`DECLARE_TASKLET(name, func, data)`实现定义以及初始化 + 在上半部函数里面触发`tasklet_schedule` + `request_irq`注册中断 #### 中断函数 软中断上下文具有以下关键特征，这些特征决定了它能做什么和不能做什么： a) 执行时机：在中断的\"下半部\"执行 软中断处理函数不是在硬件中断发生的那一刻立即执行的（那是上半部）。 它们是在上半部完成后，由内核在**相对安全**的时机调度的，比如： 从硬件中断处理程序返回时 在特定的内核线程（如 `ksoftirqd`）中 由内核代码显式调用（如 `local_bh_enable`） b) 不能睡眠（最关键的约束！） **与硬件中断上下文相同**：软中断处理函数**绝对不能调用任何可能引起睡眠的函数**（如 `kmalloc(GFP_KERNEL)`、`mutex_lock`、`wait_event` 等）。 **原因**：软中断上下文没有属于自己的进程控制块（`task_struct`），它只是在\"借用\"被中断进程的内核栈。如果它睡眠，调度器将无法正确地保存和恢复上下文，可能导致系统崩溃或严重错误。 c) 可以被硬件中断打断，但不会自我嵌套 **可以被硬件中断打断**：当一个CPU正在执行软中断时，新的硬件中断可以发生，CPU会转去执行硬件中断的上半部。 **但通常不会自我嵌套**：在同一个CPU上，内核会防止软中断重入。即一个软中断处理函数在执行时，不会再次被同一个类型的软中断打断。这简化了编程。 d) 当前进程（current宏）指向被中断的进程 就像硬件中断上下文一样，`current` 宏指向的是被中断时正在运行的进程。 **但请注意**：软中断处理函数与这个进程**没有直接关系**，它只是碰巧在这个进程的内核栈上运行。你不能也不应该访问该进程的用户空间内存。 e) 运行时间不宜过长 虽然软中断是为了处理比上半部更耗时的任务，但如果一个软中断处理函数运行时间过长，会导致： 用户进程响应延迟 其他软中断得不到及时处理 如果软中断负载很高，内核会唤醒 `ksoftirqd` 内核线程来协助处理 ##### 设计原则 执行越快越好 ##### 根源 打断其他重要代码的执行 中断函数通常在关中断情况下执行 #### 中断上下半部机制 ##### 上半部 传统的中断处理函数 表明中断已经被系统捕获 对响应时间有苛刻要求的操作 执行速度快的操作 硬件信号控制 ... 下半部 非中断处理函数，由上半部设置工作任务 数据复制 数据包装和转发 计算时间长的数据处理 读取外部数据 ... #### 软中断 中断下半部的一种机制, 触发软中断的CPU也要处理这个软中断 ##### softirq_action结构体 include/linux/interrupt.h ```c struct softirq_action { \tvoid (*action)(struct softirq_action *); // 处理的具体工作 }; ``` ##### softirq_vec数组 kernel/softirq.c 默认有十种软中断, 记录在数组里面 ```c static struct softirq_action softirq_vec[NR_SOFTIRQS]; ``` ##### NR_SOFTIRQS变量 ```c enum { HI_SOFTIRQ 0, /* 最高优先级软中断 */ TIMER_SOFTIRQ, /* 定时器软中断 */ NET_TX_SOFTIRQ, /* 网络数据发送软中断 */ NET_RX_SOFTIRQ, /* 网络数据接收软中断 */ BLOCK_SOFTIRQ,\t/*块设备软中断*/ BLOCK_IOPOLL_SOFTIRQ, TASKLET_SOFTIRQ, /* tasklet 软中断 */ SCHED_SOFTIRQ, /* 调度软中断 */ HRTIMER_SOFTIRQ, /* 高精度定时器软中断 */ RCU_SOFTIRQ, /* RCU服务软中断 */ NR_SOFTIRQS }; ``` 内核已经规定了所有软中断的用法, 默认可以使用的tasklet这个软中断 #### open_softirq()函数 include/linux/interrupt.h 注册一个软中断 ```c void open_softirq(int nr, void (*action)(struct softirq_action *)); ``` 参数： nr：要开启的软中断编号 action：相应的处理函数 返回值：无 #### raise_softirq()函数 include/linux/interrupt.h 主动触发指定软中断 ```c void raise_softirq(unsigned int nr); ``` 参数： nr：指定激活的软中断 返回值：无 #### tasklet机制 基于软中断实现的下半部机制，运行在软中断环境下 ##### softirq_init()函数 kernel/softirq.c 默认开机的时候会运行这一个代码 ```c void __init softirq_init(void) { \tint cpu; \tfor_each_possible_cpu(cpu) { \t\tper_cpu(tasklet_vec, cpu).tail \t\t\t&per_cpu(tasklet_vec, cpu).head; \t\tper_cpu(tasklet_hi_vec, cpu).tail \t\t\t&per_cpu(tasklet_hi_vec, cpu).head; \t} \t// 注册一下tasklet的处理函数 \topen_softirq(TASKLET_SOFTIRQ, tasklet_action); \topen_softirq(HI_SOFTIRQ, tasklet_hi_action); } ``` 内核在初始化时，通过 open_softirq 注册了两个专门用于处理 tasklet 的 softirq ##### tasklet_struct结构体 include/linux/interrupt.h ```c struct tasklet_struct { \tstruct tasklet_struct *next; \tunsigned long state; // 记录状态 \tatomic_t count; // 记录引用的次数 \tvoid (*func)(unsigned long); // 处理任务 \tunsigned long data; // function的参数 }; ``` next：下一个tasket state：tasklet状态 count：计数器，记录对tasket的引用数 func：tasklet执行的函数 data：函数参数 ##### tasklet_init()函数 初始化一个tasket对象 include/linux/interrupt.h ```c void tasklet_init(struct tasklet_struct *t, \t\t void (*func)(unsigned long), unsigned long data) ``` 参数： t：要初始化的tasket func：tasklet执行的函数 data：函数参数 返回值：无 ##### tasklet_schedule()函数 调度执行tasket对象, 设置这个任务的状态 include/linux/interrupt.h ```c static inline void tasklet_schedule(struct tasklet_struct *t) ``` 参数： t：要调度的tasket对象 返回值：无 ##### tasklet_kill()函数 注销tasket对象 include/linux/interrupt.h ```c void tasklet_kill(struct tasklet_struct *t); ``` 参数： t：要注销的tasket对象 返回值：无 ## 实际使用 ```c #include <linux/init.h> #include <linux/kernel.h> #include <linux/module.h> #include <linux/fs.h> #include <linux/cdev.h> #include <linux/uaccess.h> #include <linux/delay.h> #include <linux/ide.h> #include <linux/errno.h> #include <linux/gpio.h> #include <asm/mach/map.h> #include <linux/of.h> #include <linux/of_address.h> #include <linux/of_gpio.h> #include <asm/io.h> #include <linux/device.h> #include <linux/irq.h> #include <linux/of_irq.h> /* 字符设备内容 */ #define DEV_NAME \"button\" #define DEV_CNT (1) static dev_t button_devno;\t\t //定义字符设备的设备号 static struct cdev button_chr_dev; //定义字符设备结构体chr_dev struct class *class_button;\t\t //保存创建的类 struct device *device_button;\t\t // 保存创建的设备 struct device_node\t*button_device_node NULL; //定义按键设备节点结构体 unsigned button_GPIO_number 0; //保存button使用的GPIO引脚编号 u32 interrupt_number 0; // button 引脚中断编号 atomic_t button_status ATOMIC_INIT(0); //定义整型原子变量，保存按键状态 ，设置初始值为0 struct tasklet_struct button_tasklet; void tasklet_hander(unsigned long data) { \tprintk(KERN_EMERG \"tasklet_hander is running!\"); } static irqreturn_t button_irq_hander(int irq, void *dev_id) { \t// printk_green(\"button on \\n\"); \t/*按键状态加一*/ \tprintk(KERN_EMERG \"button_irq_hander is running!\"); \tatomic_inc(&button_status); \ttasklet_schedule(&button_tasklet); \tprintk(KERN_EMERG \"button_irq_hander is end!\"); \treturn IRQ_HANDLED; } static int button_open(struct inode *inode, struct file *filp) { \tint error 1; \t \t \t/*添加初始化代码*/ \t// printk_green(\"button_open\"); \t/*获取按键 设备树节点*/ \tbutton_device_node of_find_node_by_path(\"/button_interrupt\"); \tif(NULL button_device_node) \t{ \t\tprintk(\"of_find_node_by_path error!\"); \t\treturn 1; \t} \t/*获取按键使用的GPIO*/ \tbutton_GPIO_number of_get_named_gpio(button_device_node ,\"button_gpio\", 0); \tif(0 button_GPIO_number) \t{ \t\tprintk(\"of_get_named_gpio error\"); \t\treturn 1; \t} \t/*申请GPIO , 记得释放*/ \terror gpio_request(button_GPIO_number, \"button_gpio\"); \tif(error < 0) \t{ \t\tprintk(\"gpio_request error\"); \t\tgpio_free(button_GPIO_number); \t\treturn 1; \t} \terror gpio_direction_input(button_GPIO_number);//设置引脚为输入模式 \t/*获取中断号*/ \tinterrupt_number irq_of_parse_and_map(button_device_node, 0); \tprintk(\"\\n irq_of_parse_and_map! %d \\n\",interrupt_number); \t/*申请中断, 记得释放*/ \terror request_irq(interrupt_number,button_irq_hander,IRQF_TRIGGER_RISING,\"button_interrupt\",device_button); \tif(error ! 0) \t{ \t\tprintk(\"request_irq error\"); \t\tfree_irq(interrupt_number, device_button); \t\treturn 1; \t} \t/*申请之后已经开启了，切记不要再次打开，否则运行时报错*/ \t// // enable_irq(interrupt_number); \treturn 0; } static int button_read(struct file *filp, char __user *buf, size_t cnt, loff_t *offt) { \tint error 1; \tint button_countervc 0; \t/*读取按键状态值*/ \tbutton_countervc atomic_read(&button_status); \t/*结果拷贝到用户空间*/ \terror copy_to_user(buf, &button_countervc, sizeof(button_countervc)); \tif(error < 0) \t{ \t\tprintk(\"copy_to_user error\"); \t\treturn 1; \t} \t/*清零按键状态值*/ \tatomic_set(&button_status,0); \treturn 0; } /*字符设备操作函数集，.release函数实现*/ static int button_release(struct inode *inode, struct file *filp) { \t/*释放申请的引脚,和中断*/ \tgpio_free(button_GPIO_number); \tfree_irq(interrupt_number, device_button); \treturn 0; } /*字符设备操作函数集*/ static struct file_operations button_chr_dev_fops { \t.owner THIS_MODULE, \t.open button_open, \t.read button_read, \t.release button_release}; /* *驱动初始化函数 */ static int __init button_driver_init(void) { \tint error 1; \t/*采用动态分配的方式，获取设备编号，次设备号为0，*/ \terror alloc_chrdev_region(&button_devno, 0, DEV_CNT, DEV_NAME); \tif (error < 0) \t{ \t\tprintk(\"fail to alloc button_devno\\n\"); \t\tgoto alloc_err; \t} \t/*关联字符设备结构体cdev与文件操作结构体file_operations*/ \tbutton_chr_dev.owner THIS_MODULE; \tcdev_init(&button_chr_dev, &button_chr_dev_fops); \t/*添加设备至cdev_map散列表中*/ \terror cdev_add(&button_chr_dev, button_devno, DEV_CNT); \tif (error < 0) \t{ \t\tprintk(\"fail to add cdev\\n\"); \t\tgoto add_err; \t} \tclass_button class_create(THIS_MODULE, DEV_NAME); //创建类 \tdevice_button device_create(class_button, NULL, button_devno, NULL, DEV_NAME);//创建设备 DEV_NAME 指定设备名， \ttasklet_init(&button_tasklet,tasklet_hander,0); \treturn 0; add_err: \tunregister_chrdev_region(button_devno, DEV_CNT); // 添加设备失败时，需要注销设备号 \tprintk(\"\\n error! \\n\"); \t alloc_err: \treturn 1; } /* *驱动注销函数 */ static void __exit button_driver_exit(void) { \tpr_info(\"button_driver_exit\\n\"); \t/*删除设备*/ \ttasklet_kill(&button_tasklet); \tdevice_destroy(class_button, button_devno);\t\t //清除设备 \tclass_destroy(class_button);\t\t\t\t\t //清除类 \tcdev_del(&button_chr_dev);\t\t\t\t\t //清除设备号 \tunregister_chrdev_region(button_devno, DEV_CNT); //取消注册字符设备 } module_init(button_driver_init); module_exit(button_driver_exit); MODULE_LICENSE(\"GPL\"); ```"},"/note/Linux/野火Linux/2025-7-13-06-GPIO.html":{"title":"GPIO","content":"# GPIO ### GPIO控制原理 #### 了解GPIO ##### 数量 5 组 GPIO（GPIO1～GPIO5），每组最多32个，共124个 GPIO1_IO0~GPIO1_IO31 GPIO2_IO0~GPIO2_IO21 GPIO3_IO0~GPIO3_IO28 GPIO4_IO0~GPIO4_IO28 GPIO5_IO0~GPIO5_IO11 数据手册描述 28.2 External Signals ![image 20250713091051734](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507130910878.png) #### 时钟 clock controller module(CCM模块)用于配置芯片的各种外设时钟。跟GPIO相关的时钟主要有CCM_CCGR(0~3)寄存器。 ![image 20250713091326020](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507130913069.png) ![image 20251011222007900](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510112220986.png) ![image 20251011222018975](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510112220026.png) 数据手册描述 18.4 System Clocks ![image 20250713091607134](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507130916194.png) ![image 20250713091623936](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507130916026.png) 两个bit的不同取值，设置GPIO时钟的不同属性： 00：所有模式下都关闭外设时钟 01：只有在运行模式下打开外设时钟 10：保留 11：除了停止模式以外，该外设时钟全程使能 ![image 20250713091806028](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507130918063.png) #### 复用配置寄存器 ##### 引脚复用 相关寄存器：IOMUXC_SW\\_**MUX**_CTL_PAD_XXX 控制引脚的功能 数据手册： ![image 20250713094208279](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507130942405.png) ![image 20250713094443010](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507130944157.png) 0101：ALT5 >普通GPIO模式 ##### 引脚属性 相关寄存器：IOMUXC_SW\\_**PAD**_CTL_PAD_XXX 数据手册： ![image 20250713094723845](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507130947896.png) 注意：数据手册上对GPIO引脚的命令，不是严格按顺序命名的，而是根据Table 28来命名的 ![image 20250713094813412](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507130948484.png) ![image 20250713094828157](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507130948227.png) HYS（bit16）：用来使能迟滞比较器 PUS（bit15 bit14）：用来设置上下拉电阻大小 PUE（bit13）：当 IO 作为输入的时候，这个位用来设置 IO 使用上下拉还是状态保持器 PKE（bit12）：用来使能或者禁止上下拉/状态保持器功能 ODE（bit11）：IO 作为输出的时候，此位用来禁止或者使能开漏输出。 SPEED（bit7 bit6）：当 IO 用作输出的时候，此位用来设置 IO 速度。 DSE（bit5 bit3）：当 IO 用作输出的时候用来设置 IO 的驱动能力。 SRE（bit0）：设置压摆率 #### GPIO控制引脚 5组GPIO,每组GPIO有8个相关寄存器 GPIOx_GDIR：设置引脚方向 GPIOx_DR：设置输出引脚的电平 ... 每个寄存器有32位，分别控制每位的gpio ​\t数据手册描述： ​\t28.5.2 GPIO direction register (GPIOx_GDIR) ![image 20250713095048024](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507130950065.png) ​\t 0：输入 ​\t 1：输出 ![image 20250713095220504](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507130952572.png) 28.5.1 GPIO data register (GPIOx_DR) ![image 20250713095240001](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507130952139.png) 2.2 ARM Platform Memory Map ![image 20250713095428091](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507130954160.png) 可以用于计算GDIR之类的寄存器的位置 控制GPIO总结 使能GPIO时钟 设置引脚复用为GPIO 设置引脚属性(上下拉、速率、驱动能力) 控制GPIO引脚输出高低电平 硬件原理图： ![image 20250713095832730](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507130958784.png) ![image 20250713100121769](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507131001872.png) ### 汇编寄存器操作实例 ```assembly .global _start _start: @ start timer ldr r0, 0x20c406c ldr r1, 0xffffffff str r1, [r0] @ pin use as gpio ldr r0, 0x20e006c ldr r1, 5 str r1, [r0] \t@ 设置一下引脚的属性 ldr r0, 0x20e02f8 ldr r1, 0x10b0 str r1, [r0] \t@ 设置引脚方向 ldr r0, 0x2009c004 ldr r1, 16 str r1, [r0] \t@ 设置输出电平 ldr r0, 0x2009c000 ldr r1, 0 str r1, [r0] ``` > ```bash > arm none eabi gcc c ./led.s o led.o > arm none eabi ld Ttext 0x80000000 led.o o led.elf > arm none eabi objcopy O binary led.elf led.bin > ``` > ## C语言 ### 使用官方头文件 ![image 20250713122755020](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507131227104.png) > 需要注释掉他引用的其他头文件, 加入数据类型 > > ```c > #define __O volatile > #define __IO volatile > #define __I volatile const > > #define uint32_t unsigned int > #define uint16_t unsigned short > #define uint8_t unsigned char > ``` > > ![image 20250713123052192](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507131230249.png) ### 初始化C语音环境 + .bss段清零 + 初始化栈指针sp ```assembly .global _start _start: ldr sp, 0x84000000 b main ``` ### 实际的代码 ```c #include \"MCIMX6Y2.h\" #include \"fsl_iomuxc.h\" /*简单延时函数*/ void delay(uint32_t count) { volatile uint32_t i 0; for (i 0; i < count; ++i) { __asm(\"NOP\"); /* 调用nop空指令 */ } } int main(void) { /*使能GPIO1时钟*/ CCM >CCGR1 0xffffffff; /*设置 红灯 引脚的复用功能以及PAD属性*/ IOMUXC_SetPinMux(IOMUXC_GPIO1_IO04_GPIO1_IO04,0); IOMUXC_SetPinConfig(IOMUXC_GPIO1_IO04_GPIO1_IO04, 0X10B0); /*设置GPIO1_04为输出模式*/ GPIO1 >GDIR (1<<4); /*设置GPIO1_04输出电平为高电平*/ GPIO1 >DR (1<<4); while(1) { GPIO1 >DR & ~(1<<4); //红灯亮 delay(0xFFFFF); GPIO1 >DR (1<<4); //红灯灭 delay(0xFFFFF); } return 0; } ``` ```makefile ifeq ($(ARCH),x86) CC gcc else ##CC arm linux gnueabihf gcc CC arm none eabi gcc LD arm none eabi ld OBJCOPY arm none eabi objcopy endif TARGET led BUILD_DIR build SRC_DIR sources INC_DIR include CFLAGS $(patsubst %, I%, $(INC_DIR)) INCLUDES $(foreach dir,$(INC_DIR),$(wildcard $(dir)/*.h)) #源文件要加上汇编文件 SOURCES_c $(foreach dir,$(SRC_DIR),$(wildcard $(dir)/*.c)) SOURCES_s $(foreach dir,$(SRC_DIR),$(wildcard $(dir)/*.s)) OBJS $(patsubst %.c, $(BUILD_DIR)/%.o, $(notdir $(SOURCES_c))) OBJS + $(patsubst %.s, $(BUILD_DIR)/%.o, $(notdir $(SOURCES_s))) VPATH $(SRC_DIR) $(BUILD_DIR)/$(TARGET).bin: $(OBJS) \t$(LD) Tscript.lds o $(BUILD_DIR)/$(TARGET).elf $^ \t$(OBJCOPY) O binary $(BUILD_DIR)/$(TARGET).elf $@ $(BUILD_DIR)/%.o : %.c $(INCLUDES) create_build \t$(CC) c $< o $@ $(CFLAGS) #编译汇编文件 $(BUILD_DIR)/%.o : %.s $(INCLUDES) create_build \t$(CC) c $< o $@ $(CFLAGS) .PHONY:clean create_build burn clean: \trm r $(BUILD_DIR) create_build: \tmkdir p $(BUILD_DIR) # 烧录的部分 burn: \tcp $(BUILD_DIR)/$(TARGET).bin /home/embedfire/bare_mental/part_1/download_tool \tcd /home/embedfire/bare_mental/part_1/download_tool && ./mkimage.sh $(TARGET).bin ``` ``` SECTIONS{ . 0x80000000; .text ALIGN(4) : { build/start.o *(.text) } .rodata ALIGN(4) : { *(.rodata) } .data ALIGN(4) : { *(.data) } __bss_start .; .bss ALIGN(4) : { *(.bss) *(COMMON) } __bss_end .; } ``` ## 按键输入 ### 轮训 使用GPIO5_1这个引脚, 实际初始化的过程基本是一样的, 但是设置GPIO为输入, 从DR寄存器读取按键的状态 ### 中断 使用头文件CORTEXA/include/core_ca7.h 修改文件内容： 注销： ``` #include \"core_ca.h\" ``` 添加： ``` #define __STRINGIFY(x) #x /* C语言实现写cp15协处理器 */ #define __MCR(coproc, opcode_1, src, CRn, CRm, opcode_2) \\ __ASM volatile (\"MCR \" __STRINGIFY(p##coproc) \", \" __STRINGIFY(opcode_1) \", \" \\ \"%0, \" __STRINGIFY(c##CRn) \", \" __STRINGIFY(c##CRm) \", \" \\ __STRINGIFY(opcode_2) \\ : : \"r\" (src) ) /* C语言实现读cp15协处理器 */ #define __MRC(coproc, opcode_1, CRn, CRm, opcode_2) \\ ({ \\ uint32_t __dst; \\ __ASM volatile (\"MRC \" __STRINGIFY(p##coproc) \", \" __STRINGIFY(opcode_1) \", \" \\ \"%0, \" __STRINGIFY(c##CRn) \", \" __STRINGIFY(c##CRm) \", \" \\ __STRINGIFY(opcode_2) \\ : \" r\" (__dst) ); \\ __dst; \\ }) #define __ISB() #define __DSB() ```"},"/note/Linux/野火Linux/2025-11-20-74-块设备.html":{"title":"块设备","content":"# 块设备 同一个设备使用的协议是相同的, 所以在使用的时候可以直接套用, 不需要写驱动 块设备是针对存储设备的，比如 SD卡、EMMC、NAND Flash、Nor Flash、SPI Flash、机械硬盘、固态硬盘等。因此块设备驱动其实就是这些存储设备驱动，块设备驱动相比字符设备驱动的主要区别如下 1. 块设备只能以块为单位进行读写访问，块是 linux虚拟文件系统(VFS)基本的数据传输单位。字符设备是以字节为单位进行数据传输的，不需要缓冲。 2. 块设备在结构上是可以进行随机访问的，对于这些设备的读写都是按块进行的，块设备使用缓冲区来暂时存放数据，等到条件成熟以后再一次性将缓冲区中的数据写入块设备中。这么做的目的为了提高块设备寿命，大家如果仔细观察的话就会发现有些硬盘或者 NAND Flash就会标明擦除次数(flash的特性，写之前要先擦除)，比如擦除100000次等。因此，为了提高块设备寿命引入了缓冲区，数据先写入到缓冲区中，等满足一定条件后再一次性写入到真正的物理存储设备中，这样就减少了对块设备的擦除次数，提高了块设备寿命 > 字符设备是顺序的数据流设备，字符设备是按照字节进行读写访问的。字符设备不需要缓冲区，对于字符设备的访问都是实时的，而且也不需要按照固定的块大小进行访问 ## 驱动 ### 块设备 linux内核使用block_device表示块设备，block_device为一个结构体，定义在 include/linux/fs.h文件中 ```c struct block_device { \tdev_t\t\t\tbd_dev; /* not a kdev_t it's a search key */ \tint\t\t\tbd_openers; \tstruct inode *\t\tbd_inode;\t/* will die */ \tstruct super_block *\tbd_super; \tstruct mutex\t\tbd_mutex;\t/* open/close mutex */ \tstruct list_head\tbd_inodes; \tvoid *\t\t\tbd_claiming; \tvoid *\t\t\tbd_holder; \tint\t\t\tbd_holders; \tbool\t\t\tbd_write_holder; #ifdef CONFIG_SYSFS \tstruct list_head\tbd_holder_disks; #endif \tstruct block_device *\tbd_contains; \tunsigned\t\tbd_block_size; \tstruct hd_struct *\tbd_part; \t/* number of times partitions within this device have been opened. */ \tunsigned\t\tbd_part_count; \tint\t\t\tbd_invalidated; \tstruct gendisk *\tbd_disk; \tstruct request_queue * bd_queue; \tstruct list_head\tbd_list; \t/* \t * Private data. You must have bd_claim'ed the block_device \t * to use this. NOTE: bd_claim allows an owner to claim \t * the same device multiple times, the owner must take special \t * care to not mess up bd_private for that case. \t */ \tunsigned long\t\tbd_private; \t/* The counter of freeze processes */ \tint\t\t\tbd_fsfreeze_count; \t/* Mutex for freeze */ \tstruct mutex\t\tbd_fsfreeze_mutex; }; ``` 重点关注一下bd_disk成员变量，此成员变量为gendisk结构体指针类型。内核使用 block_device来表示一个具体的块设备对象，比如一个硬盘或者分区，如果是硬盘的话 bd_disk就指向通用磁盘结构 gendisk 注册和删除使用的函数如下 ```c int register_blkdev(unsigned int major, const char *name); void unregister_blkdev(unsigned int major, const char *name); ``` ### 磁盘设备 #### 数据结构 linux 内核使用 gendisk 来描述一个磁盘设备 ```c struct gendisk { \t/* major, first_minor and minors are input parameters only, \t * don't use directly. Use disk_devt() and disk_max_parts(). \t */ \tint major;\t\t\t/* major number of driver 主设备号 */ \tint first_minor; // 为磁盘的第一个次设备号 \tint minors; /* maximum number of minors, 1 for * disks that can't be partitioned. * 为磁盘的次设备号数量，也就是磁盘的分区数量 */ \tchar disk_name[DISK_NAME_LEN];\t/* name of major driver */ \tchar *(*devnode)(struct gendisk *gd, umode_t *mode); \tunsigned int events;\t\t/* supported events */ \tunsigned int async_events;\t/* async events, subset of all */ \t/* Array of pointers to partitions indexed by partno. \t * Protected with matching bdev lock but stat and other \t * non critical accesses use RCU. Always access through \t * helpers. \t */ \tstruct disk_part_tbl __rcu *part_tbl; // 磁盘对应的分区表 \tstruct hd_struct part0; \tconst struct block_device_operations *fops; // 块设备操作集 \tstruct request_queue *queue; // 磁盘对应的请求队列 \tvoid *private_data; \tint flags; \tstruct device *driverfs_dev; // FIXME: remove \tstruct kobject *slave_dir; \tstruct timer_rand_state *random; \tatomic_t sync_io;\t\t/* RAID */ \tstruct disk_events *ev; #ifdef CONFIG_BLK_DEV_INTEGRITY \tstruct blk_integrity *integrity; #endif \tint node_id; }; ``` ##### ops结构 file _operations 一样，块设备也有操作集，为结构体 block_device_operation ```c struct block_device_operations { \tint (*open) (struct block_device *, fmode_t); // 打开一个块设备 \tvoid (*release) (struct gendisk *, fmode_t); // 读写指定的页 \tint (*rw_page)(struct block_device *, sector_t, struct page *, int rw); // 块设备的 I/O控制 \tint (*ioctl) (struct block_device *, fmode_t, unsigned, unsigned long); // 和 ioctl函数一样(64位系统) \tint (*compat_ioctl) (struct block_device *, fmode_t, unsigned, unsigned long); \tlong (*direct_access)(struct block_device *, sector_t, \t\t\t\t\tvoid **, unsigned long *pfn, long size); \tunsigned int (*check_events) (struct gendisk *disk, \t\t\t\t unsigned int clearing); \t/* >media_changed() is DEPRECATED, use >check_events() instead */ \tint (*media_changed) (struct gendisk *); \tvoid (*unlock_native_capacity) (struct gendisk *); \tint (*revalidate_disk) (struct gendisk *); // 获取磁盘信息，包括磁头、柱面和扇区等信息 \tint (*getgeo)(struct block_device *, struct hd_geometry *); \t/* this callback is with swap_lock and sometimes page table lock held */ \tvoid (*swap_slot_free_notify) (struct block_device *, unsigned long); // 一般直接设置为THIS_MODULE \tstruct module *owner; }; ``` ##### 读写流程 ###### 初始化request_queue 内核将对块设备的读写都发送到请求队列 request_queue 中，request_queue 中是大量的 request(请求结构体)，而 request 又包含了 bio，bio 保存了读写相关数据，比如从块设备的哪个地址开始读取、读取的数据长度，读取到哪里，如果是写的话还包括要写入的数据等 1. 初始化请求队列 首先需要申请并初始化一个 request_queue，然后在初始化gendisk的时候将这个request_queue 地址赋值给 gendisk的 queue成员变量, 使用 blk_init_queue函数来完成 request_queue的申请与初始化 ```c request_queue *blk_init_queue(request_fn_proc *rfn, spinlock_t *lock) ``` + **rfn**：请求处理函数指针，每个 request_queue都要有一个请求处理函数，请求处理函数request_fn_proc原型如下`void (request_fn_proc) (struct request_queue *q)` + **lock**：自旋锁指针，需要驱动编写人员定义一个自旋锁，然后传递进来。，请求队列会使用这个自旋锁 2. 删除请求队列 卸载块设备驱动的时候我们还需要删除掉前面申请到的 request_queue，删除请求队列使用函数blk_cleanup_queue 3. 分配请求队列并绑定制造请求函数 我们使用blk_alloc_queue的原因主要是为了适应非机械设备（如EMMC、SD卡、SSD等）的I/O特性。这些设备没有机械硬盘的寻道延迟，可以随机访问，因此不需要复杂的I/O调度器来合并和排序请求。相反，直接处理请求（bio）效率更高。 ```c // 传统方式 有 I/O 调度开销 request_queue_t *q blk_init_queue(do_request, &lock); // 请求路径：bio → I/O调度器 → request → 驱动 // 优化方式 无 I/O 调度开销 request_queue_t *q blk_alloc_queue(GFP_KERNEL); blk_queue_make_request(q, my_make_request_fn); // 请求路径：bio → 制造请求函数 → 驱动 ``` ```c // gfp_mask：内存分配掩码，具体可选择的掩码值请参考 // include/linux/gfp.h 中的相关宏定义，一般为GFP_KERNEL struct request_queue *blk_alloc_queue(gfp_t gfp_mask); // 为blk_alloc_queue函数申请到的请求队列绑定一个“制造请求”函数 void blk_queue_make_request(struct request_queue *q, make_request_fn *mfn); void (make_request_fn) (struct request_queue *q, struct bio *bio) ``` ###### 请求处理request request里面有一个名为`bio`的成员变量，类型为`bio`结构体指针。前面说了，真正的数据就保存在 bio 里面，所以驱动程序需要从`request_queue`中取出一个一个的`request`，然后再从每个`request`里面取出`bio`，最后根据`bio`的描述讲数据写入到块设备, 或者读取数据 1. 获取请求 我们需要从`request_queue`中依次获取每个`request`，使用`blk_peek_request`函数完成此操作 ```c request *blk_peek_request(struct request_queue *q) ``` + **q**：指定request_queue。 + 返回值：request_queue中下一个要处理的请求(request)，如果没有要处理的请求就返回NULL。 2. 开启请求 使用`blk_peek_request`函数获取到下一个要处理的请求以后就要开始处理这个请求，这里要用到`blk_start_request`函数 ```c void blk_start_request(struct request *req) ``` > 我们也可以使用`blk_fetch_request`函数来一次性完成请求的获取和开启 ![image 20251121082851011](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251121082851011.png) ###### bio结构 每个 request里面会有多个`bio`, `bio`保存着最终要读写的数据、地址等信息。上层应用程序对于块设备的读写会被构造成一个或多个`bio`结构, `bio`结构描述了要读写的起始扇区、要读写的扇区数量、是读取还是写入、页偏移、数据长度等等信息。上层会将bio提交给I/O调度器，I/O调度器会将这些`bio`构造成`request`结构，而一个物理存储设备对应一个`request_queue`, `request_queue`里面顺序存放着一系列的`request`。新产生的 `bio`可能被合并到`request_queue`里现有的`request`中，也可能产生新的`request`, 然后插入到`request_queue`中合适的位置，这一切都是由 I/O调度器来完成的 ![image 20251121083724458](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251121083724458.png) ```c /* * main unit of I/O for the block layer and lower layers (ie drivers and * stacking drivers) */ struct bio { \tstruct bio\t\t*bi_next;\t/* request queue link 请求队列的下一个 bio */ \tstruct block_device\t*bi_bdev; /* 指向块设备 */ \tunsigned long\t\tbi_flags;\t/* status, command, etc 状态等信息 */ \tunsigned long\t\tbi_rw;\t\t/* bottom bits READ/WRITE, \t\t\t\t\t\t * top bits priority 操作,读或写 \t\t\t\t\t\t */ \tstruct bvec_iter\tbi_iter; \t/* Number of segments in this BIO after \t * physical address coalescing is performed. \t */ \tunsigned int\t\tbi_phys_segments; \t/* \t * To keep track of the max segment size, we account for the \t * sizes of the first and last mergeable segments in this bio. \t */ \tunsigned int\t\tbi_seg_front_size; \tunsigned int\t\tbi_seg_back_size; \tatomic_t\t\tbi_remaining; \tbio_end_io_t\t\t*bi_end_io; \tvoid\t\t\t*bi_private; #ifdef CONFIG_BLK_CGROUP \t/* \t * Optional ioc and css associated with this bio. Put on bio \t * release. Read comment on top of bio_associate_current(). \t */ \tstruct io_context\t*bi_ioc; \tstruct cgroup_subsys_state *bi_css; #endif \tunion { #if defined(CONFIG_BLK_DEV_INTEGRITY) \t\tstruct bio_integrity_payload *bi_integrity; /* data integrity */ #endif \t}; \tunsigned short\t\tbi_vcnt;\t/* how many bio_vec's 列表中元素数量 */ \t/* \t * Everything starting with bi_max_vecs will be preserved by bio_reset() \t */ \tunsigned short\t\tbi_max_vecs;\t/* max bvl_vecs we can hold 列表长度 */ \tatomic_t\t\tbi_cnt;\t\t/* pin count */ \tstruct bio_vec\t\t*bi_io_vec;\t/* the actual vec list */ \tstruct bio_set\t\t*bi_pool; \t/* \t * We can inline a number of vecs at the end of the bio, to avoid \t * double allocations for a small number of bio_vecs. This member \t * MUST obviously be kept at the very end of the bio. \t */ \tstruct bio_vec\t\tbi_inline_vecs[0]; }; ``` bvec_iter结构体描述了要操作的设备扇区等信息 ```c struct bvec_iter { \tsector_t\t\tbi_sector;\t/* device address in 512 byte sectors \t\t\t\t\t\t\t\t\t\t\t\t\t * I/O请求的设备起始扇区(512字节) */ \tunsigned int\t\tbi_size;\t/* residual I/O count 剩余的 I/O数量 */ \tunsigned int\t\tbi_idx;\t\t/* current index into bvl_vec 中当前索引 */ \tunsigned int bi_bvec_done;\t/* number of bytes completed in \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t * current bvec 已经处理完成的字节数 */ }; ``` ```c struct bio_vec { struct page *bv_page; /* 页 */ unsigned int bv_len; /* 长度 */ unsigned int bv_offset; /* 偏移 */ }; ``` 们对于物理存储设备的操作不外乎就是将 RAM 中的数据写入到物理存储设备中，或者将物理设备中的数据读取到 RAM 中去处理。数据传输三个要求：数据源、数据长度以及数据目的地，也就是你要从物理存储设备的哪个地址开始读取、读取到 RAM 中的哪个地址处、读取的数据长度是多少 bi_io_vec指向 bio_vec数组首地址，bio_vec数组就是RAM信息，比如页地址、页偏移以及长度，“页地址”是 linux 内核里面内存管理相关的概念 ![image 20251121093140382](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251121093140382.png) #### 对应的API函数 ```c struct gendisk *alloc_disk(int minors); void del_gendisk(struct gendisk *gp); void add_disk(struct gendisk *disk); // 设置 gendisk 容量, 使用的是扇区数量 // 不管物理扇区是多少，内核和块设备驱动之间的扇区都是 512字节 void set_capacity(struct gendisk *disk, sector_t size); // 调整 gendisk 引用计数, 增加磁盘的 kobject 引用计数，防止磁盘被意外释放 struct kobject *get_disk(struct gendisk *disk) void put_disk(struct gendisk *disk) ``` ## 应用 ### 使用请求队列 可以参考内核里面的z2ram.c文件, 这里是一个内存模拟磁盘的实验 ```c #include <linux/types.h> #include <linux/kernel.h> #include <linux/delay.h> #include <linux/ide.h> #include <linux/init.h> #include <linux/module.h> #include <linux/errno.h> #include <linux/gpio.h> #include <linux/cdev.h> #include <linux/device.h> #include <linux/of_gpio.h> #include <linux/semaphore.h> #include <linux/timer.h> #include <linux/i2c.h> #include <linux/genhd.h> #include <linux/blkdev.h> #include <linux/hdreg.h> #include <asm/mach/map.h> #include <asm/uaccess.h> #include <asm/io.h> /*************************************************************** Copyright © ALIENTEK Co., Ltd. 1998 2029. All rights reserved. 文件名\t\t: ramdisk.c 作者\t \t: 左忠凯 版本\t \t: V1.0 描述\t \t: 内存模拟硬盘，实现块设备驱动，本驱动使用请求队列。 其他\t \t: 无 论坛 \t \t: www.openedv.com 日志\t \t: 初版V1.0 2020/5/22 左忠凯创建 ***************************************************************/ #define RAMDISK_SIZE\t(2 * 1024 * 1024) \t/* 容量大小为2MB */ #define RAMDISK_NAME\t\"ramdisk\"\t\t\t/* 名字 */ #define RADMISK_MINOR\t3\t\t\t\t\t/* 表示有三个磁盘分区！不是次设备号为3！ */ /* ramdisk设备结构体 */ struct ramdisk_dev{ \tint major;\t\t\t\t\t/* 主设备号 */ \tunsigned char *ramdiskbuf;\t/* ramdisk内存空间,用于模拟块设备 */ \tspinlock_t lock;\t\t\t/* 自旋锁 */ \tstruct gendisk *gendisk; \t/* gendisk */ \tstruct request_queue *queue;/* 请求队列 */ }; struct ramdisk_dev ramdisk;\t\t/* ramdisk设备 */ /* * @description\t\t: 打开块设备 * @param dev \t: 块设备 * @param mode \t: 打开模式 * @return \t\t\t: 0 成功;其他 失败 */ int ramdisk_open(struct block_device *dev, fmode_t mode) { \tprintk(\"ramdisk open\\r\\n\"); \treturn 0; } /* * @description\t\t: 释放块设备 * @param disk \t: gendisk * @param mode \t: 模式 * @return \t\t\t: 0 成功;其他 失败 */ void ramdisk_release(struct gendisk *disk, fmode_t mode) { \tprintk(\"ramdisk release\\r\\n\"); } /* * @description\t\t: 获取磁盘信息 * @param dev \t: 块设备 * @param geo \t: 模式 * @return \t\t\t: 0 成功;其他 失败 */ int ramdisk_getgeo(struct block_device *dev, struct hd_geometry *geo) { \t/* 这是相对于机械硬盘的概念 */ \tgeo >heads 2;\t\t\t/* 磁头 */ \tgeo >cylinders 32;\t/* 柱面 */ \tgeo >sectors RAMDISK_SIZE / (2 * 32 *512); /* 一个磁道上的扇区数量 */ \treturn 0; } /* * 块设备操作函数 */ static struct block_device_operations ramdisk_fops { \t.owner\t THIS_MODULE, \t.open\t ramdisk_open, \t.release ramdisk_release, \t.getgeo ramdisk_getgeo, }; /* * @description\t: 处理传输过程 * @param req \t: 请求 * @return \t\t: 无 */ static void ramdisk_transfer(struct request *req) {\t \tunsigned long start blk_rq_pos(req) << 9; \t/* blk_rq_pos获取到的是扇区地址，左移9位转换为字节地址 */ \tunsigned long len blk_rq_cur_bytes(req);\t\t/* 大小 */ \t/* bio中的数据缓冲区 \t * 读：从磁盘读取到的数据存放到buffer中 \t * 写：buffer保存这要写入磁盘的数据 \t */ \tvoid *buffer bio_data(req >bio);\t\t \t \tif(rq_data_dir(req) READ) \t\t/* 读数据 */\t \t\tmemcpy(buffer, ramdisk.ramdiskbuf + start, len); \telse if(rq_data_dir(req) WRITE) \t/* 写数据 */ \t\tmemcpy(ramdisk.ramdiskbuf + start, buffer, len); } /* * @description\t: 请求处理函数 * @param q \t: 请求队列 * @return \t\t: 无 */ void ramdisk_request_fn(struct request_queue *q) { \tint err 0; \tstruct request *req; \t/* 循环处理请求队列中的每个请求 */ \treq blk_fetch_request(q); \twhile(req ! NULL) { \t\t/* 针对请求做具体的传输处理 */ \t\tramdisk_transfer(req); \t\t/* 判断是否为最后一个请求，如果不是的话就获取下一个请求 \t\t * 循环处理完请求队列中的所有请求。 \t\t */ \t\tif (!__blk_end_request_cur(req, err)) \t\t\treq blk_fetch_request(q); \t} } /* * @description\t: 驱动出口函数 * @param \t\t: 无 * @return \t\t: 无 */ static int __init ramdisk_init(void) { \tint ret 0; \tprintk(\"ramdisk init\\r\\n\"); \t/* 1、申请用于ramdisk内存 */ \tramdisk.ramdiskbuf kzalloc(RAMDISK_SIZE, GFP_KERNEL); \tif(ramdisk.ramdiskbuf NULL) { \t\tret EINVAL; \t\tgoto ram_fail; \t} \t/* 2、初始化自旋锁 */ \tspin_lock_init(&ramdisk.lock); \t/* 3、注册块设备 */ \tramdisk.major register_blkdev(0, RAMDISK_NAME); /* 由系统自动分配主设备号 */ \tif(ramdisk.major < 0) { \t\tgoto register_blkdev_fail; \t} \tprintk(\"ramdisk major %d\\r\\n\", ramdisk.major); \t/* 4、分配并初始化gendisk */ \tramdisk.gendisk alloc_disk(RADMISK_MINOR); \tif(!ramdisk.gendisk) { \t\tret EINVAL; \t\tgoto gendisk_alloc_fail; \t} \t/* 5、分配并初始化请求队列 */ \tramdisk.queue blk_init_queue(ramdisk_request_fn, &ramdisk.lock); \tif(!ramdisk.queue) { \t\tret EINVAL; \t\tgoto blk_init_fail; \t} \t/* 6、添加(注册)disk */ \tramdisk.gendisk >major ramdisk.major;\t\t/* 主设备号 */ \tramdisk.gendisk >first_minor 0;\t\t\t/* 第一个次设备号(起始次设备号) */ \tramdisk.gendisk >fops &ramdisk_fops; \t\t/* 操作函数 */ \tramdisk.gendisk >private_data &ramdisk;\t/* 私有数据 */ \tramdisk.gendisk >queue ramdisk.queue;\t\t/* 请求队列 */ \tsprintf(ramdisk.gendisk >disk_name, RAMDISK_NAME); /* 名字 */ \tset_capacity(ramdisk.gendisk, RAMDISK_SIZE/512);\t/* 设备容量(单位为扇区) */ \tadd_disk(ramdisk.gendisk); \treturn 0; blk_init_fail: \tput_disk(ramdisk.gendisk); \t//del_gendisk(ramdisk.gendisk); gendisk_alloc_fail: \tunregister_blkdev(ramdisk.major, RAMDISK_NAME); register_blkdev_fail: \tkfree(ramdisk.ramdiskbuf); /* 释放内存 */ ram_fail: \treturn ret; } /* * @description\t: 驱动出口函数 * @param \t\t: 无 * @return \t\t: 无 */ static void __exit ramdisk_exit(void) { \tprintk(\"ramdisk exit\\r\\n\"); \t/* 释放gendisk */ \tdel_gendisk(ramdisk.gendisk); \tput_disk(ramdisk.gendisk); \t/* 清除请求队列 */ \tblk_cleanup_queue(ramdisk.queue); \t/* 注销块设备 */ \tunregister_blkdev(ramdisk.major, RAMDISK_NAME); \t/* 释放内存 */ \tkfree(ramdisk.ramdiskbuf); } module_init(ramdisk_init); module_exit(ramdisk_exit); MODULE_LICENSE(\"GPL\"); MODULE_AUTHOR(\"zuozhongkai\"); ``` ### 不使用请求队列 使用 blk_alloc_queue和blk_queue_make_request这两个函数取代了上一个实验的blk_init_queue函数, 可以参考zram_drv.c ```c #include <linux/types.h> #include <linux/kernel.h> #include <linux/delay.h> #include <linux/ide.h> #include <linux/init.h> #include <linux/module.h> #include <linux/errno.h> #include <linux/gpio.h> #include <linux/cdev.h> #include <linux/device.h> #include <linux/of_gpio.h> #include <linux/semaphore.h> #include <linux/timer.h> #include <linux/i2c.h> #include <linux/genhd.h> #include <linux/blkdev.h> #include <linux/hdreg.h> #include <asm/mach/map.h> #include <asm/uaccess.h> #include <asm/io.h> /*************************************************************** Copyright © ALIENTEK Co., Ltd. 1998 2029. All rights reserved. 文件名\t\t: ramdisk.c 作者\t \t: 左忠凯 版本\t \t: V1.0 描述\t \t: 内存模拟硬盘，实现块设备驱动，本驱动使用\"制造请求\"。 \t\t : 参考：drivers/block/zram/zram_drv.c 其他\t \t: 无 论坛 \t \t: www.openedv.com 日志\t \t: 初版V1.0 2020/5/22 左忠凯创建 ***************************************************************/ #define RAMDISK_SIZE\t(2 * 1024 * 1024) \t/* 容量大小为2MB */ #define RAMDISK_NAME\t\"ramdisk\"\t\t\t/* 名字 */ #define RADMISK_MINOR\t3\t\t\t\t\t/* 表示有三个磁盘分区！不是次设备号为3！ */ /* ramdisk设备结构体 */ struct ramdisk_dev{ \tint major;\t\t\t\t\t/* 主设备号 */ \tunsigned char *ramdiskbuf;\t/* ramdisk内存空间,用于模拟块设备 */ \tspinlock_t lock;\t\t\t/* 自旋锁 */ \tstruct gendisk *gendisk; \t/* gendisk */ \tstruct request_queue *queue;/* 请求队列 */ }; struct ramdisk_dev ramdisk;\t\t/* ramdisk设备 */ /* * @description\t\t: 打开块设备 * @param dev \t: 块设备 * @param mode \t: 打开模式 * @return \t\t\t: 0 成功;其他 失败 */ int ramdisk_open(struct block_device *dev, fmode_t mode) { \tprintk(\"ramdisk open\\r\\n\"); \treturn 0; } /* * @description\t\t: 释放块设备 * @param disk \t: gendisk * @param mode \t: 模式 * @return \t\t\t: 0 成功;其他 失败 */ void ramdisk_release(struct gendisk *disk, fmode_t mode) { \tprintk(\"ramdisk release\\r\\n\"); } /* * @description\t\t: 获取磁盘信息 * @param dev \t: 块设备 * @param geo \t: 模式 * @return \t\t\t: 0 成功;其他 失败 */ int ramdisk_getgeo(struct block_device *dev, struct hd_geometry *geo) { \t/* 这是相对于机械硬盘的概念 */ \tgeo >heads 2;\t\t\t/* 磁头 */ \tgeo >cylinders 32;\t/* 柱面 */ \tgeo >sectors RAMDISK_SIZE / (2 * 32 *512); /* 一个磁道上的扇区数量 */ \treturn 0; } /* * 块设备操作函数 */ static struct block_device_operations ramdisk_fops { \t.owner\t THIS_MODULE, \t.open\t ramdisk_open, \t.release ramdisk_release, \t.getgeo ramdisk_getgeo, }; /* * @description\t: “制造请求”函数 * @param q \t: 请求队列 * @return \t\t: 无 */ void ramdisk_make_request_fn(struct request_queue *q, struct bio *bio) { \tint offset; \tstruct bio_vec bvec; \tstruct bvec_iter iter; \tunsigned long len 0; \toffset (bio >bi_iter.bi_sector) << 9;\t/* 获取要操作的设备的偏移地址 */ \t/* 处理bio中的每个段 */ \tbio_for_each_segment(bvec, bio, iter){ \t\tchar *ptr page_address(bvec.bv_page) + bvec.bv_offset; \t\tlen bvec.bv_len; \t\tif(bio_data_dir(bio) READ)\t/* 读数据 */ \t\t\tmemcpy(ptr, ramdisk.ramdiskbuf + offset, len); \t\telse if(bio_data_dir(bio) WRITE)\t/* 写数据 */ \t\t\tmemcpy(ramdisk.ramdiskbuf + offset, ptr, len); \t\toffset + len; \t} \tset_bit(BIO_UPTODATE, &bio >bi_flags); \tbio_endio(bio, 0); } /* * @description\t: 驱动出口函数 * @param \t\t: 无 * @return \t\t: 无 */ static int __init ramdisk_init(void) { \tint ret 0; \tprintk(\"ramdisk init\\r\\n\"); \t/* 1、申请用于ramdisk内存 */ \tramdisk.ramdiskbuf kzalloc(RAMDISK_SIZE, GFP_KERNEL); \tif(ramdisk.ramdiskbuf NULL) { \t\tret EINVAL; \t\tgoto ram_fail; \t} \t/* 2、初始化自旋锁 */ \tspin_lock_init(&ramdisk.lock); \t/* 3、注册块设备 */ \tramdisk.major register_blkdev(0, RAMDISK_NAME); /* 由系统自动分配主设备号 */ \tif(ramdisk.major < 0) { \t\tgoto register_blkdev_fail; \t} \tprintk(\"ramdisk major %d\\r\\n\", ramdisk.major); \t/* 4、分配并初始化gendisk */ \tramdisk.gendisk alloc_disk(RADMISK_MINOR); \tif(!ramdisk.gendisk) { \t\tret EINVAL; \t\tgoto gendisk_alloc_fail; \t} \t/* 5、分配请求队列 */ \tramdisk.queue blk_alloc_queue(GFP_KERNEL); \tif(!ramdisk.queue){ \t\tret EINVAL; \t\tgoto blk_allo_fail; \t} \t/* 6、设置“制造请求”函数 */ \tblk_queue_make_request(ramdisk.queue, ramdisk_make_request_fn); \t/* 7、添加(注册)disk */ \tramdisk.gendisk >major ramdisk.major;\t\t/* 主设备号 */ \tramdisk.gendisk >first_minor 0;\t\t\t/* 第一个次设备号(起始次设备号) */ \tramdisk.gendisk >fops &ramdisk_fops; \t\t/* 操作函数 */ \tramdisk.gendisk >private_data &ramdisk;\t/* 私有数据 */ \tramdisk.gendisk >queue ramdisk.queue;\t\t/* 请求队列 */ \tsprintf(ramdisk.gendisk >disk_name, RAMDISK_NAME); /* 名字 */ \tset_capacity(ramdisk.gendisk, RAMDISK_SIZE/512);\t/* 设备容量(单位为扇区) */ \tadd_disk(ramdisk.gendisk); \treturn 0; blk_allo_fail: \tput_disk(ramdisk.gendisk); \t//del_gendisk(ramdisk.gendisk); gendisk_alloc_fail: \tunregister_blkdev(ramdisk.major, RAMDISK_NAME); register_blkdev_fail: \tkfree(ramdisk.ramdiskbuf); /* 释放内存 */ ram_fail: \treturn ret; } /* * @description\t: 驱动出口函数 * @param \t\t: 无 * @return \t\t: 无 */ static void __exit ramdisk_exit(void) { \tprintk(\"ramdisk exit\\r\\n\"); \t/* 释放gendisk */ \tdel_gendisk(ramdisk.gendisk); \tput_disk(ramdisk.gendisk); \t/* 清除请求队列 */ \tblk_cleanup_queue(ramdisk.queue); \t/* 注销块设备 */ \tunregister_blkdev(ramdisk.major, RAMDISK_NAME); \t/* 释放内存 */ \tkfree(ramdisk.ramdiskbuf); } module_init(ramdisk_init); module_exit(ramdisk_exit); MODULE_LICENSE(\"GPL\"); MODULE_AUTHOR(\"zuozhongkai\"); ```"},"/note/Linux/野火Linux/2025-11-19-73-USB.html":{"title":"USB","content":"# USB USB 只能主机与设备之间进行数据通信，USB 主机与主机、设备与设备之间是不能通信的。因此两个正常通信的USB接口之间必定有一个主机，一个设备。为此使用了不同的插头和插座来区分主机与设备，比如主机提供 USB A 插座，从机提供 Mini USB、Micro USB 等插座。 在一个 USB 系统中，仅有一个 USB 主机，但是可以有多个 USB 设备，包括 USB 功能设备和USB HUB，最多支持 127个设备。一个USB主控制器支持128个地址，地址 0是默认地址，只有在设备枚举的时候才会使用，地址0不会分配给任何一个设备。所以一个 USB主控制器最多可以分配127个地址。整个USB的拓扑结构就是一个分层的金字塔形 ![image 20251119155250924](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251119155250924.png) > 从 Root Hub 开始，一共有 7 层，金字塔顶部是 Root Hub，这个是USB控制器内部的。图中的 Hub就是连接的USB集线器，Func就是具体的USB设备 > > USB 主机和从机之间的通信通过管道(Pipe)来完成，管道是一个逻辑概念，任何一个 USB设备一旦上电就会存在一个管道，也就是默认管道，USB 主机通过管道来获取从机的描述符、配置等信息。在主机端管道其实就是一组缓冲区，用来存放主机数据，在设备端管道对应一个特定的端点 USB分为HOST(主机)和从机(或DEVICE)，有些设备可能有时候需要做HOST，有时候又需要做 DEVICE，配两个USB口当然可以实现，但是太浪费资源了。如果一个USB 接口既可以做 HOST又可以做 DEVICE那就太好了，使用起来就方便很多。为此，USBOTG 应运而生，OTG 是 On The Go 的缩写，支持 USB OTG 功能的 USB 接口既可以做 HOST，也可以做 DEVICE。那么问题来了，一个 USB 接口如何知道应该工作在 HOST 还是 DEVICE呢？这里就引入了 ID线这个概念 + **ID 1**：OTG设备工作在从机模式。 + **ID 0**：OTG设备工作在主机模式。 > TypcC使用的是新增的C1C2引脚确定主机从机的 ## IMX6ULL I.MX6ULL内部集成了两个独立的 USB控制器，这两个 USB控制器都支持 OTG功能。I.MX6ULL内部USB控制器特性如下： 1. 有两个 USB2.0控制器内核分别为 Core0和 Core1，这两个 Core分别连接到 OTG1 和OTG2。 2. 两个USB2.0控制器都支持HS、FS和 LS模式，不管是主机还是从机模式都支持 HS/FS/LS，硬件支持OTG信号、会话请求协议和主机协商协议，支持8个双向端点。 3. 支持低功耗模式，本地或远端可以唤醒。 4. 每个控制器都有一个DMA。 每个 USB OTG 控制器都可以运行在高速模式(HS 480Mbps)、全速模式(LS 12Mbps)和低速模式(1.5Mbps)。正常模式下每个 OTG 控制器都可以工作在主机(HOST)或从机(DEVICE)模式下，每个 USB 控制器都有其对应的接口 + 正常模式下每个 OTG 控制器都可以工作在主机(HOST)或从机(DEVICE)模式下，每个 USB 控制器都有其对应的接口。 + 低功耗模式顾名思义就是为了节省功耗，USB2.0 协议中要求，设备在上行端口检测到空闲状态以后就可以进入挂起状态。在从机(DEVICE)模式下，端口停止活动3ms以后OTG控制器内核进入挂起状态。在主机(HOST)模式下，OTG控制器内核不会自动进入挂起状态，但是可以通过软件设置。不管是本地还是远端的USB主从机都可以通过产生唤醒序列来重新开始 USB通信 两个USB控制器都兼容**EHCI** **EHCI**：全称是 Enhanced Host Controller Interface，是 Inter主导的一个用于 USB2.0 的 USB控制器标准。I.MX6ULL的两个USB控制器都是2.0的，因此兼容EHCI标准。EHCI仅提供 USB2.0的高速功能，至于全速和低速功能就由OHCI或UHCI来提供 ## 电路 Mini USB 插头有 5 个触点，也就是 5 根线，线序从左往右依次是 1~5。第 1根线为 VCC(5V)，第2根线为D ，第 3根线为 D+，第 4根线为ID，第5根线为GND。可以看出Mini USB插头相比 USB A插头多了一个 ID线，这个ID线用于实现OTG功能，通过 ID线来判断当前连接的是主设备(HOST)还是从设备(SLAVE)。 ![image 20251119175034944](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251119175034944.png) ![image 20251119175110790](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251119175110790.png) 从机**(DEVICE)**模式：图67.2.2.1中USB_OTG_VBUS是Mini USB的电源线，只有插入 Mini USB 线以后 USB_OTG_VBUS 才有效(5V)。插入 Mini USB 线就表示开发板此时要做从机(此时不考虑接OTG线的情况)，USB_OTG_VBUS就是电脑供的5V电压，由于分压电阻 R111和 R31 的作用，此时 USB_OTG1_ID 的电压就是 4.5V 左右，很明显这一个高电平。前面我们讲了，当ID线为高的时候就表示 OTG工作在从机模式。 主机**(HOST)**模式：主机模式下必须将 Mini USB 线拔出来，将 USB 设备连接到对应的 USB HOST接口上。Mini USB线拔出来以后USB_OTG_VBUS就没有电压了，此时USB_OTG1_ID线就被R31这个 100K电阻下拉到地，因此USB_OTG1_ID线的电压就为 0，当ID线为0的时候就表示OTG工作在主机模式。 ![image 20251119175235613](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251119175235613.png) 当OTG作为从机(DEVICE)的时候USB线接入此接口。当OTG作为主机的时候需要使用 Type C OTG线, Type C 的 CC1 和 CC2 引脚就是完成传统的 USB ID 线功能的 从机**(DEVICE)**模式：图 67.2.3.1中R111这一个 49.9K的电阻，默认将 USB_OTG1_ID线拉高，前面我们讲了，当 ID 线为高的时候就表示 OTG 工作在从机模式。此时由于 USB_OTG1_ID为高电平，因此 MOS1(SI2302)导通，因此 MT9700HT5的EN脚就接地，此时 MT9700HT5的OUT引脚就没有输出，所以 USB_OTG_VBUS电压关闭。USB_OTG_VBUS电压用于在OTG 做 HOST 功能的时候，向外部设备提供 5V 电源。很明显，在 OTG 做从机的时候，OTG就不需要向外界提供 USB_OTG_VBUS电源了。这里使用 MT9700HT5这个芯片来实 VBUS电源的开关控制。 主机**(HOST)**模式：如果要使用 OTG 的 HOST 功能，那么必须要使用到 Type C OTG 线。**Type C OTG线会将CC1和CC2拉低**，因此USB_OTG1_ID线也会被拉低，当ID线为0的时候就表示 OTG 工作在主机模式。此时由于 USB_OTG1_ID 为低，因此 MOS1(SI2302)不导通，因此 MT9700HT5 的 EN 脚就会被 R31 这个 10K 电阻上拉到 5V，所以 MT9700HT5 的 OUT引脚就会输出5V电压，也就是说USB_OTG_VBUS此时是5V，可以向外部设备提供5V电源。 ## 使用 使能 ``` > Device Drivers > HID support > HID bus support (HID [ y]) > <*> Generic HID driver //使能通用HID驱动 > Device Drivers > HID support > USB HID support > <*> USB HID transport layer //USB键盘鼠标等 HID设备驱动 ``` HID设备里面包括鼠标键盘等 使能U盘 ``` > Device Drivers > SCSI device support > <*> SCSI disk support //选中此选项 ``` ### otg从机 USB 设备驱动，按照设备端关联的 USB 控制器 是工作在 主模式 还是 从模式，分为 USB 设备主机侧驱动 (主模式驱动)，或者 USB 设备从机侧驱动 (从模式驱动)。同时，工作在 主模式 的 USB 控制器，称为 USB 主机控制器 (UHC: USB Host Controller)，工作在 从模式 的 USB 控制器，称为 USB 设备控制器 (UDC: USB Device Controller)。有的 USB 控制器，只能工作在 主模式 或 从模式 中的某一种；而有的则既可以工作在 主模式，也可以工作在 从模式，模式通过 OTG 切换。当然，在同一时刻，USB 控制器 要么工作在 主模式，要么工作在 从模式。 Linux 下将 USB 设备从机侧驱动 ，称为 `USB Gadget` 驱动。USB Gadget 驱动 是通过 USB 来模拟其它类型的设备，如 USB Gadget UAC 驱动 用来模拟声卡外设；USB Gadget Serial 驱动 用来模拟串口外设，等等等等。这里所谓模拟，是指通过 USB 来模拟这些设备的行为，而这些对于连接对端的 USB 主机 是透明的。对于 USB Gadget 驱动 ，类似于 U 盘设备的固件，但它们并不完全等同，因为毕竟只是通过 USB 模拟设备行为。 #### 模拟U盘 ``` > Device Drivers > SCSI device support > <*> SCSI disk support //选中此选项, U盘使用SCSI协议 > Device Drivers > USB support (USB_SUPPORT [ y]) > USB Gadget Support (USB_GADGET [ y] > [M]USB Gadget Drivers (<choice> [ m]) //选中 USB Gadget驱动 >[M]Mass Storage Gadget //大容量存储 ``` 将驱动编译为模块, 重新编译Linux内核，会得到三个.ko驱动模块 ``` drivers/usb/gadget/libcomposite.ko drivers/usb/gadget/function/usb_f_mass_storage.ko drivers/usb/gadget/legacy/g_mass_storage.ko ``` ```bash depmod modprobe libcomposite.ko modprobe usb_f_mass_storage.ko modprobe g_mass_storage.ko file /dev/sda1 removable 1 # 退出操作 rmmod g_mass_storage.ko ``` 在linux下面的文件系统一般是ext4的格式, windows是不可以识别的, 所以可以使用一个U盘模拟 #### 模拟声卡 ``` > Device Drivers > USB support (USB_SUPPORT [ y]) > USB Gadget Support (USB_GADGET [ y] > [M]USB Gadget Drivers //选中USB Gadget驱动 >[M] Audio Gadget //选中音频 >UAC 1.0 (Legacy) //选中UAC ``` 使用的模块有三个 ``` drivers/usb/gadget/libcomposite.ko drivers/usb/gadget/function/usb_f_uac1.ko drivers/usb/gadget/legacy/g_audio.ko ``` 全部加载即可模拟声卡"},"/note/Linux/野火Linux/2025-9-25-30-Completion.html":{"title":"","content":"## completion机制基本概念 完成量：用于进程/线程同步，与信号量/互斥量类似 #### 语义 信号量/互斥量：资源对所有进程/线程是公平的，按先来后到顺序使用 完成量：一个线程的运行依赖另一个线程 #### completion结构体 include/linux/completion.h ```c struct completion { \tunsigned int done; \twait_queue_head_t wait; }; ``` done：表示当前completion的状态 wait：等待队列头 #### 初始化completion ##### init_completion()宏 include/linux/completion.h ```c #define init_completion(x) __init_completion(x) ``` ###### __init_completion()函数 include/linux/completion.h ```c static inline void __init_completion(struct completion *x) { \tx >done 0; \tinit_waitqueue_head(&x >wait); } ``` ##### 静态定义并初始化 ###### DECLARE_COMPLETION宏 可以使用这一个宏实现申请以及初始化 ```c #define DECLARE_COMPLETION(work) \\ \tstruct completion work COMPLETION_INITIALIZER(work) ``` ###### COMPLETION_INITIALIZER宏 ```c #define COMPLETION_INITIALIZER(work) \\ \t{ 0, __WAIT_QUEUE_HEAD_INITIALIZER((work).wait) } ``` #### completion休眠 ##### wait_for_completion()函数 kernel/sched/completion.c ```c void __sched wait_for_completion(struct completion *x) ``` 参数： x：完成量结构体指针 ##### wait_for_completion_timeout()函数 kernel/sched/completion.c ```c unsigned long __sched wait_for_completion_timeout(struct completion *x, unsigned long timeout) ``` 参数： x：完成量结构体指针 timeout：超时事件 ##### wait_for_completion_interruptible()函数 kernel/sched/completion.c ```c int __sched wait_for_completion_interruptible(struct completion *x) ``` 参数： x：完成量结构体指针 #### complete唤醒 ##### complete()函数 一次唤醒一个进程 kernel/sched/completion.c ```c void complete(struct completion *x) ``` 参数： x：完成量结构体指针 ##### complete_all()函数 kernel/sched/completion.c 唤醒所有的 ```c void complete_all(struct completion *x) ``` 参数： x：完成量结构体指针 ## 使用 ```c struct completion rgb_wait; unsigned int write_data; //用于保存接收到的数据 /*字符设备操作函数集，open函数*/ static int led_chr_dev_open(struct inode *inode, struct file *filp) { \tprintk(\"\\n open form driver \\n\"); \treturn 0; } /*字符设备操作函数集，write函数*/ static ssize_t led_chr_dev_write(struct file *filp, const char __user *buf, size_t cnt, loff_t *offt) { \tint ret,error; \tunsigned char receive_data[10]; //用于保存接收到的数据 \t \tif(cnt>10) \t\t\tcnt 10; \terror copy_from_user(receive_data, buf, cnt); \tif (error < 0) \t{ \t\treturn 1; \t} \tret kstrtoint(receive_data, 16, &write_data); \tif (ret) { \t\treturn 1; } \tif(write_data) \t{ \t\tcomplete_all(&rgb_wait); \t\treturn cnt; \t} \telse \t{ \t\twait_for_completion(&rgb_wait); \t} \t \t/*设置 GPIO1_04 输出电平*/ \tif (write_data ) \t{ \t\tgpio_set_value(rgb_led_red,0); \t} \treturn cnt; } ```"},"/note/Linux/野火Linux/2025-7-19-14-uevent消息.html":{"title":"uevent","content":"# uevent kobject对象可以通过uevent机制往用户空间发送信息, 主要是驱动设备使用的 ![image 20250719153349309](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507191533370.png) kobject_uevent：内核消息发送接口 广播方式发送 NETLINK：特殊的网络通信，本地主机使用 传统做法是内核执行*hotplug*程序进行消息通知（效率低、不优雅） udev/mdev：用户空间守护进程，监听广播信息 默认开机启动, debian系统使用的是udev，通过systemd进行启动 udevadm monitor指令：打印uevent事件 #### 内核消息发送 ##### 消息类型 ```c enum kobject_action { \tKOBJ_ADD, \tKOBJ_REMOVE, \tKOBJ_CHANGE, \tKOBJ_MOVE, \tKOBJ_ONLINE, \tKOBJ_OFFLINE, \tKOBJ_BIND, \tKOBJ_UNBIND, \tKOBJ_MAX }; ``` ##### kobject_uevent()函数 通常使用的发送消息的函数 ```c int kobject_uevent(struct kobject *kobj, enum kobject_action action) { \treturn kobject_uevent_env(kobj, action, NULL); } ``` ##### kobject_uevent_env()函数 使用kobject找到一个最上层的kset对象, 使用他的uevent_ops里面的部分函数, 实际不初始化可以可以发送的, 主要是使用里面的过滤函数和标志位 ```c int kobject_uevent_env(struct kobject *kobj, enum kobject_action action, \t\t char *envp_ext[]) { \tstruct kobj_uevent_env *env; \t... \ttop_kobj kobj; \t/*while循坏查找kobj所隶属的最顶层kobject或者kset指针不为空的kobj*/ \twhile (!top_kobj >kset && top_kobj >parent) \t\ttop_kobj top_kobj >parent; \t/*判断kobj的kset指针是否为空, 只有有kset的时候才可以进行*/ \tif (!top_kobj >kset) { \t\tpr_debug(\"kobject: '%s' (%p): %s: attempted to send uevent \" \t\t\t \"without kset!\\n\", kobject_name(kobj), kobj, \t\t\t __func__); \t\treturn EINVAL; \t} \t/*得到kobj指向的kset对象*/ \tkset top_kobj >kset; \t/*获取kset的uevent_ops*/ \tuevent_ops kset >uevent_ops; \t/*若kobject >uevent_suppress为1，表示kobj不适用uevent*/ \tif (kobj >uevent_suppress) { \t\tpr_debug(\"kobject: '%s' (%p): %s: uevent_suppress \" \t\t\t\t \"caused the event to drop!\\n\", \t\t\t\t kobject_name(kobj), kobj, __func__); \t\treturn 0; \t} \t/*过滤event事件, filter执行为0的时候过滤*/ \tif (uevent_ops && uevent_ops >filter) \t\tif (!uevent_ops >filter(kset, kobj)) { \t\t\tpr_debug(\"kobject: '%s' (%p): %s: filter function \" \t\t\t\t \"caused the event to drop!\\n\", \t\t\t\t kobject_name(kobj), kobj, __func__); \t\t\treturn 0; \t\t} \t... \t/* environment buffer */ \tenv kzalloc(sizeof(struct kobj_uevent_env), GFP_KERNEL); \tif (!env) \t\treturn ENOMEM; \t/* 获取kobj在sysfs中的路径 */ \tdevpath kobject_get_path(kobj, GFP_KERNEL); \tif (!devpath) { \t\tretval ENOENT; \t\tgoto exit; \t} \t/* 消息内容 记录路径, 事件的string, 上层节点*/ \tretval add_uevent_var(env, \"ACTION %s\", action_string); \tif (retval) \t\tgoto exit; \tretval add_uevent_var(env, \"DEVPATH %s\", devpath); \tif (retval) \t\tgoto exit; \tretval add_uevent_var(env, \"SUBSYSTEM %s\", subsystem); \tif (retval) \t\tgoto exit; \t... \t \tif (uevent_ops && uevent_ops >uevent) { \t\tretval uevent_ops >uevent(kset, kobj, env); \t\tif (retval) { \t\t\tpr_debug(\"kobject: '%s' (%p): %s: uevent() returned \" \t\t\t\t \"%d\\n\", kobject_name(kobj), kobj, \t\t\t\t __func__, retval); \t\t\tgoto exit; \t\t} \t} \t... \t/*本地socket通信，发送广播信息*/ \tretval kobject_uevent_net_broadcast(kobj, env, action_string, \t\t\t\t\t devpath); \t... } ``` ## 代码实现 ```c static int __init led_init(void) { \tint retval; \t/* GPIO相关寄存器映射 */ \tIMX6U_CCM_CCGR1 ioremap(0x20c406c, 4); \tSW_MUX_GPIO1_IO04 ioremap(0x20e006c, 4); \tSW_PAD_GPIO1_IO04 ioremap(0x20e02f8, 4); \tGPIO1_GDIR ioremap(0x0209c004, 4); \tGPIO1_DR ioremap(0x0209c000, 4); \t/* 使能GPIO1时钟 */ \tiowrite32(0xffffffff, IMX6U_CCM_CCGR1); \t/* 设置GPIO1_IO04复用为普通GPIO*/ \tiowrite32(5, SW_MUX_GPIO1_IO04); \t /*设置GPIO属性*/ \tiowrite32(0x10B0, SW_PAD_GPIO1_IO04); \t/* 设置GPIO1_IO04为输出功能 */ \tiowrite32(1 << 4, GPIO1_GDIR); \t/* LED输出高电平 */ \tiowrite32(1<< 4, GPIO1_DR); \t/*创建一个kset对象*/ \texample_kset kset_create_and_add(\"kset_example\", NULL, NULL); \tif (!example_kset) \t\treturn ENOMEM; \t/* 创建一个kobject对象*/ \tled_kobj kobject_create_and_add(\"led_kobject\", &example_kset >kobj); \t// 设置一下父对象的kset, 之后会使用这个 \tled_kobj >kset example_kset; \tif (!led_kobj) \t\treturn ENOMEM; \t/* 为kobject设置属性文件*/ \tretval sysfs_create_group(led_kobj, &attr_group); \tif (retval) \t\tkobject_put(led_kobj); \tkobject_uevent(led_kobj, KOBJ_ADD); \treturn retval; \treturn 0; } static void __exit led_exit(void) { \t/* 取消映射 */ \tiounmap(IMX6U_CCM_CCGR1); \tiounmap(SW_MUX_GPIO1_IO04); \tiounmap(SW_PAD_GPIO1_IO04); \tiounmap(GPIO1_DR); \tiounmap(GPIO1_GDIR); \t/* 注销字符设备驱动 */ \tkobject_put(led_kobj); \t/*取消字符设备的注册*/ \tkset_unregister(example_kset); } ``` ![image 20250719160839870](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507191608931.png) 第一条是内核自己的打印, 第二个是自己发送的"},"/note/Linux/野火Linux/2025-7-14-08-时钟控制模块.html":{"title":"时钟控制模块","content":"# 时钟控制模块 四个层次 + 晶振时钟 + PLL于PFD时钟 + PLL选择时钟 + 根时钟/外设时钟 ## 晶振时钟 芯片连接两个时钟24MHz主晶振以及一个32.768KHz用于RTC模块 ## PLL与PFD时钟 实际一个用于倍频的电路, 7路锁相环电路 ARM_PLL：驱动 ARM 内核 528_PLL：倍频参数固定为22，系统总线时钟, 固定是528MHz USB1_PLL：驱动第一个 USB 物理层 AUDIO_PLL：驱动音频接口 VIDEO_PLL：驱动视频接口 ENET_PLL：驱动外部以太网接口 USB2_PLL：驱动第二个 USB 物理层 > 主要需要关注的时候528PLL以及USB1PLL > > PLL输出的时钟在需要通过PFD进行分频, 一路PLL可以获取到四路不同频率的时钟 ![image 20250714093631291](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507140936485.png) #### PLL选择时钟 对 PLL1 和 PLL3 的输出进行选择、对 PLL4 和 PLL5 进行分频 cpu内核时钟来于PLL1时钟。 刚上电时，PLL1时钟未初始化，arm内核先使用24M晶振频率，等PLL1时钟稳定输出后，再切换回PLL1时钟。 ![image 20250714094153368](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507140941449.png) CCM_ANALOG_PLL_XXX 设置PPL时钟主频(pll1_main_clk) 使能PLL时钟输出 CCM_ANALOG_PFD_XXX 设置PPL下PFD的分频系数 ![image 20250714180317070](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507141803206.png)"},"/note/Linux/野火Linux/2025-9-4-20-iomux节点(上).html":{"title":"pinctrl子系统","content":"# pinctrl子系统 ![image 20250917000442622](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509170004744.png) ## iomux节点 输入输出多路复用器 汇总所需引脚的配置信息 pinctrl子系统预存iomux节点信息, 用于设置gpio的复用 #### iomuxc节点 **imx6ull.dtsi**最基础的配置 ```json iomuxc: iomuxc@20e0000 { \t\t\t\tcompatible \"fsl,imx6ul iomuxc\"; \t\t\t\treg <0x20e0000 0x4000>; \t\t\t}; ``` compatible：与pinctrl子系统的平台驱动做匹配 reg：引脚配置寄存器的基地址 > 这个文件里面是最基础的属性 **imx6ull seeed npi.dts**追加的配置 ```json &iomuxc { \tpinctrl names \"default\"，\"init\",\"sleep\"; \tpinctrl 0 <&pinctrl_hog_1>; \tpinctrl 1 <&xxx>; \tpinctrl 2 <&yyy>; \t \tpinctrl_hog_1: hoggrp 1 { \t\tfsl,pins < \t\t\tMX6UL_PAD_UART1_RTS_B__GPIO1_IO19\t0x17059 /* SD1 CD */ \t\t\tMX6UL_PAD_GPIO1_IO05__USDHC1_VSELECT\t0x17059 /* SD1 VSELECT */ \t\t\tMX6UL_PAD_GPIO1_IO09__GPIO1_IO09 0x17059 /* SD1 RESET */ \t\t>; \t}; ... \tpinctrl_uart1: uart1grp { \t\tfsl,pins < \t\t\tMX6UL_PAD_UART1_TX_DATA__UART1_DCE_TX 0x1b0b1 \t\t\tMX6UL_PAD_UART1_RX_DATA__UART1_DCE_RX 0x1b0b1 \t\t>; \t}; ... } &uart1 { \tpinctrl names \"default\"; \tpinctrl 0 <&pinctrl_uart1>; \tstatus \"okay\"; }; ``` > 进行属性的追加 **`pinctrl names`**: 定义了三个状态的名称列表。 `\"default\"`: **默认状态**。当设备被正常启用时（例如 `probe` 函数中），内核会自动将此状态应用到硬件上。 `\"init\"`: **初始化状态**。可能用于设备初始化过程中某个特殊阶段，需要由驱动代码显式调用。 `\"sleep\"`: **睡眠状态**。当设备挂起或系统进入低功耗模式时，内核会自动切换到此状态。通常用于将引脚配置为漏电最小的状态（如上拉、下拉或高阻态）以省电。 **`pinctrl 0`**, **`pinctrl 1`**, **`pinctrl 2`**: 这些属性将状态名称**映射**到具体的引脚配置组（`phandle`）。 `pinctrl 0` 对应 `pinctrl names` 中的第一个名字 `\"default\"`，它引用了 `&pinctrl_hog_1` 这个配置组。 `pinctrl 1` 对应 `\"init\"`，引用一个名为 `xxx` 的配置组（示例中未完整给出）。 `pinctrl 2` 对应 `\"sleep\"`，引用一个名为 `yyy` 的配置组（示例中未完整给出）。 **注意**：`pinctrl_hog_1` 通常用于那些在系统生命周期内**永远不需要改变功能**的引脚（例如，始终作为 GPIO 驱动一个 LED，或者被硬件固定了功能），这些引脚在系统启动早期就被配置好，之后就不再变动，俗称“钉死的”（Hogged）引脚。 > 它本身也是一个外设, 所以可以设置一部分的引脚, 其他的外设可以引用里面的配置 > > 一个外设里面的引脚可以有多种状态 这部分定义了一个名为 `pinctrl_uart1` 的引脚配置组，它的标签（label）是 `uart1grp`。这个组描述了一组引脚应该如何配置，以实现某个特定功能（这里是 UART1）。 **`pinctrl_uart1`**: 这是该节点的**句柄（handle）**，可以被其他节点（如 `&pinctrl 0`）或串口设备节点引用。`uart1grp` 是节点名，方便阅读。 **`fsl,pins`**: 这是 NXP/Freescale i.MX 平台特有的属性，用于列出该配置组中所有引脚的设置。它是一个由多个 `<宏定义 电气属性值>` 组成的列表。 **宏定义 (例如 `MX6UL_PAD_UART1_TX_DATA__UART1_DCE_TX`)**: 这是一个在头文件（如 `imx6ul pinfunc.h``）中定义好的宏，它唯一地确定了： 1. **哪个物理引脚**（例如：`MX6UL_PAD_UART1_TX_DATA`） 2. **复用为何种功能**（例如：`__UART1_DCE_TX`，即作为 UART1 的设备（DCE）发送引脚） **DCE** 指的是数据通信设备（如调制解调器），在 i.MX 上下文中，通常用于区分 TX/RX 方向。`DCE_TX` 意味着这个引脚是 UART 的**输出**脚。 **电气属性值 (例如 `0x1b0b1`)**: 这是一个十六进制数，配置了该引脚除功能复用之外的**所有电气特性**。它代表了芯片参考手册中 **IOMUXC 寄存器**的配置值。每一位的含义通常包括： **速度** (Slew Rate) **驱动强度** (Drive Strength) **上拉/下拉电阻** (Pull up / Pull down) ** hysteresis** (施密特触发器使能) **开漏** (Open Drain) 值 `0x1b0b1` 是一组经过验证的、适用于中低速外设（如 UART）的稳定配置，通常保证了适当的驱动能力和上拉。 #### 节点配置信息记录 **fsl,pins** 结合imx6ull的pinctrl子系统驱动使用 以该属性来标识引脚的配置信息 **fsl,pins属性值** 一个宏+一个十六进制数 ``` MX6UL_PAD_UART1_TX_DATA__UART1_DCE_TX 0x1b0b1 ``` **宏定义原型** imx6ull.dtsi >#include \"imx6ull pinfunc.h\" >\\#include \"imx6ul pinfunc.h\" ``` #define MX6UL_PAD_UART1_TX_DATA__UART1_DCE_TX 0x0084 0x0310 0x0000 0 0 ``` **宏值含义** ``` <mux_reg conf_reg input_reg mux_mode input_val> 0x0084 0x0310 0x0000 0x0 0x0 ``` mux_reg：引脚复用设置寄存器 ![image 20200821153238037](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509041642615.png) conf_reg：引脚属性设置寄存器 ![image 20200821153304942](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509041709436.png) input_reg：引脚输入设置寄存器 引脚需要输入功能时设置 mux_mode：复用寄存器设置值, 设置引脚复用 input_value：输入寄存器设置值 设置引脚输入特性 **十六进制数** 属性寄存器设置值conf_reg 特性复杂，独立设置 #### 设备树iomuxc节点层次 iomuxc function group ``` fsl,pins < \t\t\txxx \t\t\txxx \t\t>; ``` ... group ... function ... #### 层次关系说明 iomuxc：pinctrl子系统的设备树节点 function：芯片具有外设功能，一个功能对应一个或多个IO组配置信息, 比如i2c控制器, spi控制器, 可能不同情况下面是不同的引脚组 group：IO组中每个IO的配置信息 fsl,pins：imx6ull中，功能和IO组的标识属性 > imx6ull里面使用的没有function节点, 全部都是group节点, 所有节点在同一个function里面进行管理 ## imx_pinctrl和pinctrl_dev ![image 20250915210310359](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509152103462.png) pinctrl子系统预先确定引脚的数量和名字 为每个引脚的配置信息分配内存, 解析所有的数据 以后会记录这部分信息在内存里面 管理每个引脚的使用状态 #### imx6ul_pinctrl_probe()函数 drivers/pinctrl/freescale/pinctrl imx6ul.c ```c static const struct imx_pinctrl_soc_info imx6ul_pinctrl_info { \t.pins imx6ul_pinctrl_pads, // 赋的值是一个结构体数组, 实际是所有芯片引脚的名字以及编号 \t\t\t\t\t\t // 可以用于复用寄存器计算偏移 \t.npins ARRAY_SIZE(imx6ul_pinctrl_pads), \t.gpr_compatible \"fsl,imx6ul iomuxc gpr\", }; static int imx6ul_pinctrl_probe(struct platform_device *pdev) { \tconst struct imx_pinctrl_soc_info *pinctrl_info; \tconst struct of_device_id *match; \t// 从设备树中获取匹配的设备数据(未使用) \tpinctrl_info of_device_get_match_data(&pdev >dev); \tif (!pinctrl_info) \t\treturn ENODEV; \t// 判断一下这两个是不是匹配 \tmatch of_match_device(imx6ul_pinctrl_of_match, &pdev >dev); \tif (!match) \t\treturn ENODEV; \t// 获取到imx6ul_pinctrl_of_match里面的对应的项imx6ul_pinctrl_info \tpinctrl_info (struct imx_pinctrl_soc_info *) match >data; \treturn imx_pinctrl_probe(pdev, pinctrl_info); } ``` ```c // pin对应的结构 struct pinctrl_pin_desc { \tunsigned number; \tconst char *name; \tvoid *drv_data; }; struct imx_pinctrl_soc_info { \tconst struct pinctrl_pin_desc *pins; \tunsigned int npins; \tunsigned int flags; \tconst char *gpr_compatible; \t... } ``` #### of_device_get_match_data()函数 drivers/of/device.c 判断是不是设备树和驱动是不是匹配上的 ```c const void *of_device_get_match_data(const struct device *dev) { \tconst struct of_device_id *match; \tmatch of_match_device(dev >driver >of_match_table, dev); \tif (!match) \t\treturn NULL; \treturn match >data; } ``` #### of_match_device()函数 ```c const struct of_device_id *of_match_device(const struct of_device_id *matches, \t\t\t\t\t const struct device *dev) { \tif ((!matches) (!dev >of_node)) \t\treturn NULL; \treturn of_match_node(matches, dev >of_node); } ``` #### imx6ul_pinctrl_pads 引脚的编号和名字表 ```c /* Pad names for the pinmux subsystem */ static const struct pinctrl_pin_desc imx6ul_pinctrl_pads[] { \tIMX_PINCTRL_PIN(MX6UL_PAD_RESERVE0), \tIMX_PINCTRL_PIN(MX6UL_PAD_RESERVE1), \tIMX_PINCTRL_PIN(MX6UL_PAD_RESERVE2), \tIMX_PINCTRL_PIN(MX6UL_PAD_RESERVE3), \tIMX_PINCTRL_PIN(MX6UL_PAD_RESERVE4), \tIMX_PINCTRL_PIN(MX6UL_PAD_RESERVE5), ,,, } ``` ##### IMX_PINCTRL_PIN宏 drivers/pinctrl/freescale/pinctrl imx.h ```c #define IMX_PINCTRL_PIN(pin) PINCTRL_PIN(pin, #pin) ``` ##### PINCTRL_PIN宏 include/linux/pinctrl/pinctrl.h ```c #define PINCTRL_PIN(a, b) { .number a, .name b } ``` ##### 引脚编号与复用寄存器的关系 pin.num mux/4 #### imx_pinctrl：存储引脚的名字和编号原始表 ##### imx_pinctrl_probe()函数 匹配以后得初始化函数 ![image 20250915211242897](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509152112048.png) ```c int imx_pinctrl_probe(struct platform_device *pdev, \t\t const struct imx_pinctrl_soc_info *info) { \tstruct imx_pinctrl *ipctl; \tstruct pinctrl_desc *imx_pinctrl_desc; \t... // imx_pinctrl结构体 \tipctl devm_kzalloc(&pdev >dev, sizeof(*ipctl), GFP_KERNEL); \t... // 初始化regs变量, 每一个引脚都有一个这个结构体, 记录复用以及属性寄存器的偏移地址 ipctl >pin_regs devm_kmalloc(&pdev >dev, sizeof(*ipctl >pin_regs) * info >npins, GFP_KERNEL); if (!ipctl >pin_regs) return ENOMEM; for (i 0; i < info >npins; i++) { ipctl >pin_regs[i].mux_reg 1; ipctl >pin_regs[i].conf_reg 1; } ... // 获取设备数里面的reg寄存器 \tres platform_get_resource(pdev, IORESOURCE_MEM, 0); // 虚拟地址的映射, 实际的寄存器控制的位置 \tipctl >base devm_ioremap_resource(&pdev >dev, res); \t... \timx_pinctrl_desc devm_kzalloc(&pdev >dev, sizeof(*imx_pinctrl_desc),GFP_KERNEL); \t... \timx_pinctrl_desc >name dev_name(&pdev >dev); \timx_pinctrl_desc >pins info >pins; \timx_pinctrl_desc >npins info >npins; \timx_pinctrl_desc >pctlops &imx_pctrl_ops; \timx_pinctrl_desc >pmxops &imx_pmx_ops; \timx_pinctrl_desc >confops &imx_pinconf_ops; \timx_pinctrl_desc >owner THIS_MODULE; \t... \tipctl >info info; \tipctl >dev &pdev >dev; // 数据记录在平台设备里面 \tplatform_set_drvdata(pdev, ipctl); \t... // pctl会在这个函数里面进行赋值 \tret devm_pinctrl_register_and_init(&pdev >dev, \t\t\t\t\t imx_pinctrl_desc, ipctl, \t\t\t\t\t &ipctl >pctl); \t... // 读取注册所有的引脚信息 \tret imx_pinctrl_probe_dt(pdev, ipctl); \t... // 初始化所有的引脚 \treturn pinctrl_enable(ipctl >pctl); \t... \treturn ret; } \t ``` #### pinctrl_desc：以基数树的方式存储引脚的名字，记录引脚的使用状态 ##### devm_pinctrl_register_and_init()函数 drivers/pinctrl/core.c 初始化pinctrl_dev这个结构体 ```c int pinctrl_register_and_init(struct pinctrl_desc *pctldesc, \t\t\t struct device *dev, void *driver_data, \t\t\t struct pinctrl_dev **pctldev) { \tstruct pinctrl_dev *p; \t \tp pinctrl_init_controller(pctldesc, dev, driver_data); \tif (IS_ERR(p)) \t\treturn PTR_ERR(p); \t*pctldev p; \treturn 0; } ``` ##### pinctrl_init_controller()函数 drivers/pinctrl/core.c 参数依次是imx_pinctrl_desc, device设备, ipctl结构 初始化一下pinctrldev_list结构体 ![image 20250915212456940](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509152124056.png) ```c static struct pinctrl_dev * pinctrl_init_controller(struct pinctrl_desc *pctldesc, struct device *dev, \t\t\tvoid *driver_data) { \tstruct pinctrl_dev *pctldev; \t... \tpctldev kzalloc(sizeof(*pctldev), GFP_KERNEL); \t... \tpctldev >owner pctldesc >owner; \tpctldev >desc pctldesc; \tpctldev >driver_data driver_data; \t/*初始化基数树, 可以理解为一个数据库 */ \tINIT_RADIX_TREE(&pctldev >pin_desc_tree, GFP_KERNEL); \t... \tpctldev >dev dev; \t... \tret pinctrl_register_pins(pctldev, pctldesc >pins, pctldesc >npins); \t... \treturn pctldev; \t... } ``` ##### pinctrl_register_pins()函数 drivers/pinctrl/core.c 把所有的引脚数据进行记录 ```c static int pinctrl_register_pins(struct pinctrl_dev *pctldev, \t\t\t\t const struct pinctrl_pin_desc *pins, \t\t\t\t unsigned num_descs) { \tunsigned i; \tint ret 0; \tfor (i 0; i < num_descs; i++) { \t\tret pinctrl_register_one_pin(pctldev, &pins[i]); \t\tif (ret) \t\t\treturn ret; \t} \treturn 0; } ``` ##### pinctrl_register_one_pin()函数 drivers/pinctrl/core.c 初始化一下基数树里面的pin_desc结构体 ![image 20250915213045745](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509152130828.png) ```c static int pinctrl_register_one_pin(struct pinctrl_dev *pctldev, \t\t\t\t const struct pinctrl_pin_desc *pin) { \tstruct pin_desc *pindesc; \t// 在基数树查找一个引脚, 因为没有初始化, 所以这里找到的数据为空 \tpindesc pin_desc_get(pctldev, pin >number); \tif (pindesc) { \t\tdev_err(pctldev >dev, \"pin %d already registered\\n\", \t\t\tpin >number); \t\treturn EINVAL; \t} \tpindesc kzalloc(sizeof(*pindesc), GFP_KERNEL); \t... \tpindesc >pctldev pctldev; \t... \tif (pin >name) { \t\tpindesc >name pin >name; \t} else { \t\tpindesc >name kasprintf(GFP_KERNEL, \"PIN%u\", pin >number); \t\tif (!pindesc >name) { \t\t\tkfree(pindesc); \t\t\treturn ENOMEM; \t\t} \t\tpindesc >dynamic_name true; \t} \t... // 使用编号进行插入 \tradix_tree_insert(&pctldev >pin_desc_tree, pin >number, pindesc); \t... \treturn 0; } ```"},"/note/Linux/野火Linux/2025-9-28-40-LCD-FB设备.html":{"title":"","content":"## LCD驱动框架分析 实际就是配置eLCDIF的配置参数 #### 裸机开发 lcd显示原理 相关寄存器 分辨率 显示时序(6个时间参数) 显存地址 #### framebuffer机制 帧缓冲 显示图像信息 /dev/fbx(x 0~n) fb是一种机制，将系统中所有跟显示有关的硬件以及软件集合起来，虚拟出一个 fb 设备, 是个字符设备, 操作集定义在 drivers/video/fbdev/core/fbmem.c 文件, 可以使用mmap函数进行控制 #### 分层模型 ##### 核心层 drivers/video/fbdev/core/fbmem.c linux内核实现 创建graphics设备类，占据主设备号29 为不同的显示设备提供文件通用处理接口 ##### 硬件设备层 驱动人员实现 提供显示时序、显存、像素格式等硬件信息 提供显示设备的私有文件操作接口 创建lcd设备文件/dev/fbx(x 0~n) #### 核心层分析 drivers/video/fbdev/core/fbmem.c ##### 创建graphics设备类，占据主设备号29 开机以后自动执行 ```c static int __init fbmem_init(void) { \tint ret; \tif (!proc_create_seq(\"fb\", 0, NULL, &proc_fb_seq_ops)) \t\treturn ENOMEM; \tret register_chrdev(FB_MAJOR, \"fb\", &fb_fops); // 占据设备号 \tif (ret) { \t\tprintk(\"unable to get major %d for fb devs\\n\", FB_MAJOR); \t\tgoto err_chrdev; \t} \tfb_class class_create(THIS_MODULE, \"graphics\"); \tif (IS_ERR(fb_class)) { \t\tret PTR_ERR(fb_class); \t\tpr_warn(\"Unable to create fb class; errno %d\\n\", ret); \t\tfb_class NULL; \t\tgoto err_class; \t} \tfb_console_init(); \treturn 0; err_class: \tunregister_chrdev(FB_MAJOR, \"fb\"); err_chrdev: \tremove_proc_entry(\"fb\", NULL); \treturn ret; } ``` ##### FB_MAJOR宏 /usr/include/linux/major.h ```c #define FB_MAJOR\t\t29 ``` ##### fb_fops文件操作接口 drivers/video/fbdev/core/fbmem.c ```c static const struct file_operations fb_fops { \t.owner \tTHIS_MODULE, \t.read \t\tfb_read, \t.write \tfb_write, \t.unlocked_ioctl fb_ioctl, #ifdef CONFIG_COMPAT \t.compat_ioctl fb_compat_ioctl, #endif \t.mmap \t\tfb_mmap, \t.open \t\tfb_open, \t.release \tfb_release, #if defined(HAVE_ARCH_FB_UNMAPPED_AREA) \\ \t(defined(CONFIG_FB_PROVIDE_GET_FB_UNMAPPED_AREA) && \\ \t !defined(CONFIG_MMU)) \t.get_unmapped_area get_fb_unmapped_area, #endif #ifdef CONFIG_FB_DEFERRED_IO \t.fsync \tfb_deferred_io_fsync, #endif \t.llseek \tdefault_llseek, }; ``` > 所有LCD的通用接口 #### 硬件设备层分析 ##### fb_info 结构体 include/linux/fb.h LCD硬件的相关信息, 这个结构体需要在驱动文件里面初始化, 是Linux所有的framebuffer都会被抽象的一个结构, 屏幕的驱动最重要的就是初始化这个结构 ```c struct fb_info { \tatomic_t count; \tint node; \tint flags; \t \tint fbcon_rotate_hint; \tstruct mutex lock;\t\t/* Lock for open/release/ioctl funcs */ \tstruct mutex mm_lock;\t\t/* Lock for fb_mmap and smem_* fields */ \tstruct fb_var_screeninfo var;\t/* Current var 当前可变参数 */ \tstruct fb_fix_screeninfo fix;\t/* Current fix 当前固定参数 */ \tstruct fb_monspecs monspecs;\t/* Current Monitor specs 显示器特性 */ \tstruct work_struct queue;\t/* Framebuffer event queue 事件缓冲区 */ \tstruct fb_pixmap pixmap;\t/* Image hardware mapper 硬件映射 */ \tstruct fb_pixmap sprite;\t/* Cursor hardware mapper 光标映射 */ \tstruct fb_cmap cmap;\t\t/* Current cmap 调色板 */ \tstruct list_head modelist; /* mode list 模式列表 */ \tstruct fb_videomode *mode;\t/* current mode 视频模式 */ #ifdef CONFIG_FB_BACKLIGHT \t/* assigned backlight device */ \t/* set before framebuffer registration, \t remove after unregister */ \tstruct backlight_device *bl_dev; \t/* Backlight level curve */ \tstruct mutex bl_curve_mutex;\t \tu8 bl_curve[FB_BACKLIGHT_LEVELS]; #endif #ifdef CONFIG_FB_DEFERRED_IO \tstruct delayed_work deferred_work; \tstruct fb_deferred_io *fbdefio; #endif \tstruct fb_ops *fbops; // 对应的操作函数 \tstruct device *device;\t\t/* This is the parent */ \tstruct device *dev;\t\t/* This is this fb device */ \tint class_flag; /* private sysfs flags */ #ifdef CONFIG_FB_TILEBLITTING \tstruct fb_tile_ops *tileops; /* Tile Blitting */ #endif \tunion { \t\tchar __iomem *screen_base;\t/* Virtual address */ \t\tchar *screen_buffer; \t}; \tunsigned long screen_size;\t/* Amount of ioremapped VRAM or 0 */ \tvoid *pseudo_palette;\t\t/* Fake palette of 16 colors */ ... }; ``` var、fix、screen_base、screen_size：提供显示时序、显存、像素格式等硬件信息 fbops：显示设备的私有文件操作接口, 会被通用的接口调用 #### register_framebuffer()函数 drivers/video/fbdev/core/fbmem.c 注册一个fb_info到内核里面 ```c register_framebuffer(struct fb_info *fb_info) { \tint ret; \tmutex_lock(&registration_lock); \tret do_register_framebuffer(fb_info); \tmutex_unlock(&registration_lock); \treturn ret; } ``` ##### do_register_framebuffer()函数 drivers/video/fbdev/core/fbmem.c ```c static int do_register_framebuffer(struct fb_info *fb_info) { \t... \tfor (i 0 ; i < FB_MAX; i++) \t\tif (!registered_fb[i]) \t\t\tbreak; // 获取一个空闲选项(次设备号) \tfb_info >node i; \t... // 创建一个设备 \tfb_info >dev device_create(fb_class, fb_info >device, \t\t\t\t MKDEV(FB_MAJOR, i), NULL, \"fb%d\", i); ... } ``` ##### registered_fb数组 drivers/video/fbdev/core/fbmem.c ```c struct fb_info *registered_fb[FB_MAX] ``` ##### FB_MAX宏 include/uapi/linux/fb.h ```c #define FB_MAX\t\t\t32\t/* sufficient for now */ ``` ##### fb_open()函数 drivers/video/fbdev/core/fbmem.c ```c static int fb_open(struct inode *inode, struct file *file) { \tint fbidx iminor(inode); // 获取次设备号 \tstruct fb_info *info; \tint res 0; \tinfo get_fb_info(fbidx); \t... \tfile >private_data info; \tif (info >fbops >fb_open) { \t\tres info >fbops >fb_open(info,1); // 使用自定义的open函数 \t\tif (res) \t\t\tmodule_put(info >fbops >owner); \t} #ifdef CONFIG_FB_DEFERRED_IO \tif (info >fbdefio) \t\tfb_deferred_io_open(info, inode, file); #endif out: \tmutex_unlock(&info >lock); \tif (res) \t\tput_fb_info(info); \treturn res; } ``` ## LCD驱动实验 ### 硬件原理图 ![1595577582841](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509282222986.png) ### 设备树节点 arch/arm/boot/dts/imx6ull seeed npi.dts #### iomuxc子节点 ```json pinctrl_lcdif_dat: lcdifdatgrp { \t\t\t fsl,pins < \t\t\t MX6UL_PAD_LCD_DATA00__LCDIF_DATA00 0x79 \t\t\t MX6UL_PAD_LCD_DATA01__LCDIF_DATA01 0x79 \t\t\t MX6UL_PAD_LCD_DATA02__LCDIF_DATA02 0x79 \t\t\t MX6UL_PAD_LCD_DATA03__LCDIF_DATA03 0x79 \t\t\t MX6UL_PAD_LCD_DATA04__LCDIF_DATA04 0x79 \t\t\t MX6UL_PAD_LCD_DATA05__LCDIF_DATA05 0x79 \t\t\t MX6UL_PAD_LCD_DATA06__LCDIF_DATA06 0x79 \t\t\t MX6UL_PAD_LCD_DATA07__LCDIF_DATA07 0x79 \t\t\t MX6UL_PAD_LCD_DATA08__LCDIF_DATA08 0x79 \t\t\t MX6UL_PAD_LCD_DATA09__LCDIF_DATA09 0x79 \t\t\t MX6UL_PAD_LCD_DATA10__LCDIF_DATA10 0x79 \t\t\t MX6UL_PAD_LCD_DATA11__LCDIF_DATA11 0x79 \t\t\t MX6UL_PAD_LCD_DATA12__LCDIF_DATA12 0x79 \t\t\t MX6UL_PAD_LCD_DATA13__LCDIF_DATA13 0x79 \t\t\t MX6UL_PAD_LCD_DATA14__LCDIF_DATA14 0x79 \t\t\t MX6UL_PAD_LCD_DATA15__LCDIF_DATA15 0x79 \t\t\t MX6UL_PAD_LCD_DATA16__LCDIF_DATA16 0x79 \t\t\t MX6UL_PAD_LCD_DATA17__LCDIF_DATA17 0x79 \t\t\t MX6UL_PAD_LCD_DATA18__LCDIF_DATA18 0x79 \t\t\t MX6UL_PAD_LCD_DATA19__LCDIF_DATA19 0x79 \t\t\t MX6UL_PAD_LCD_DATA20__LCDIF_DATA20 0x79 \t\t\t MX6UL_PAD_LCD_DATA21__LCDIF_DATA21 0x79 \t\t\t MX6UL_PAD_LCD_DATA22__LCDIF_DATA22 0x79 \t\t\t MX6UL_PAD_LCD_DATA23__LCDIF_DATA23 0x79 \t\t\t >; \t\t\t}; \t\t\t pinctrl_lcdif_ctrl: lcdifctrlgrp { \t\t\tfsl,pins < \t\t\t MX6UL_PAD_LCD_CLK__LCDIF_CLK\t 0x79 \t\t\t MX6UL_PAD_LCD_ENABLE__LCDIF_ENABLE 0x79 \t\t\t MX6UL_PAD_LCD_HSYNC__LCDIF_HSYNC 0x79 \t\t\t MX6UL_PAD_LCD_VSYNC__LCDIF_VSYNC 0x79 \t\t\t>; \t\t\t}; \t\t\t pinctrl_pwm1: pwm1grp { \t\t\t\tfsl,pins < \t\t\t\t\tMX6UL_PAD_GPIO1_IO08__PWM1_OUT 0x110b0 \t\t\t\t>; \t\t\t}; ``` #### backlight子节点 ```json backlight { compatible \"pwm backlight\"; \tpinctrl names \"default\"; \tpinctrl 0 <&pinctrl_pwm1>; pwms <&pwm1 0 5000000>; brightness levels <0 4 8 16 32 64 128 255>; default brightness level <6>; status \"okay\"; }; ``` #### lcdif节点 arch/arm/boot/dts/imx6ull.dtsi 对应的相关驱动文件, 这个驱动文件对应的位置在`drivers/video/fbdev/mxsfb.c` ```json \tlcdif: lcdif@21c8000 { \t\t\t\tcompatible \"fsl,imx6ul lcdif\", \"fsl,imx28 lcdif\"; \t\t\t\treg <0x21c8000 0x4000>; \t\t\t\tinterrupts <GIC_SPI 5 IRQ_TYPE_LEVEL_HIGH>; \t\t\t\tclocks <&clks IMX6UL_CLK_LCDIF_PIX>, \t\t\t\t\t <&clks IMX6UL_CLK_LCDIF_APB>, \t\t\t\t\t <&clks IMX6UL_CLK_DUMMY>; \t\t\t\tclock names \"pix\", \"axi\", \"disp_axi\"; \t\t\t\tstatus \"disabled\"; \t\t\t}; ``` #### lcd设备节点 Documentation\\devicetree\\binding ```json &lcdif { \tpinctrl names \"default\"; pinctrl 0 <&pinctrl_lcdif_dat &pinctrl_lcdif_ctrl>; display <&display0>; status \"okay\"; display0: display { bits per pixel <32>; bus width <24>; display timings { native mode <&timing1>; timing1: timing1 { mode_name \"TFT50AB\"; clock frequency <27000000>; hactive <800>; vactive <480>; hfront porch <23>; hback porch <46>; hsync len <1>; vback porch <22>; vfront porch <22>; vsync len <1>; hsync active <0>; vsync active <0>; de active <1>; pixelclk active <0>; }; \t\t\t}; \t\t}; }; ``` display：lcd属性信息 bits per pixel：一个像素占用24bit bus width：总线宽度 native mode：时序信息 clock frequency：lcd像素时钟，单位Hz hactive：x轴像素个数 vactive：y轴像素个数 hfront porch、hback porch、hsync len、vback porch、vfront porch、vsync len：时序参数 * active：时钟极性 ### 驱动文件 主要实现的功能是fb_info的注册 #### mxsfb_probe 驱动匹配以后执行`static int mxsfb_probe(struct platform_device *pdev)`函数 这个函数实现电源引脚初始化, 申请mxsfb_info结构体的内存, 进行ioremap, 申请中断, 之后会进一步调用`ret mxsfb_init_fbinfo(host);`初始化fb_info 初始化之后, registere这个fb_info 其他还有对于寄存器的一系列初始化操作 #### mxsfb_init_fbinfo 初始化各种变量, 同时申请一块帧显存, 清空显存, 记录的操控结构体是`mfsfb_ops`, 这个函数还要使用设备树里面的相关参数`mxsfb_init_fbinfo_bt` #### mxsfb_init_fbinfo_bt 从设备树里读取信息进行初始化, 获取lcdif节点, 获取实际屏幕的时序信息 ### 控制函数 #### mmap()函数 \\#include <sys/mman.h> 将文件内容映射到内存, 这里是把位图文件映射一下 ```c void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset); ``` 参数： addr：表示指定映射的內存起始地址，通常设为 NULL表示让系统自动选定地址 length：表示将文件中多大的内容映射到内存中 prot：表示映射区域的保护方式 PROT_EXEC ：映射区域可被执行 PROT_READ ：映射区域可被读取 PROT_WRITE ：映射区域可被写入 PROT_NONE ：映射区域不能被访问 Flags：映射区域的不同特性 MAP_SHARED：共享映射，多个进程实时看到文件映射内容的变化，映射内容写入到磁盘文件 MAP_PRIVATE：匿名映射，其他进程无法看到映射内容变化，映射内容不会写入到磁盘文件 ... #### 位图转换器 SEGGER 图片转化c文件 《emWin应用开发实战指南》 第11章 显示位图 ARGB格式 ## 实际应用 ```c #include <stdio.h> #include <unistd.h> #include <fcntl.h> #include <string.h> #include <stdlib.h> #include <sys/ioctl.h> /*显示屏相关头文件*/ #include <linux/fb.h> #include <sys/mman.h> extern unsigned int test_picture[]; typedef struct lcd_color { unsigned char bule; unsigned char green; unsigned char red; unsigned char alpha; } lcd_color; int main() { int fp 0; long screensize 0; struct fb_var_screeninfo vinfo; struct fb_fix_screeninfo finfo; char *fbp 0; int x 0, y 0; long location 0; fp open(\"/dev/fb0\", O_RDWR); if (fp < 0) { printf(\"Error : Can not open framebuffer device/n\"); exit(1); } if (ioctl(fp, FBIOGET_FSCREENINFO, &finfo)) { printf(\"Error reading fixed information/n\"); exit(2); } if (ioctl(fp, FBIOGET_VSCREENINFO, &vinfo)) { printf(\"Error reading variable information/n\"); exit(3); } // printf(\"The mem is :%d\\n\", finfo.smem_len); screensize vinfo.xres * vinfo.yres * vinfo.bits_per_pixel / 8; /*这就是把fp所指的文件中从开始到screensize大小的内容给映射出来，得到一个指向这块空间的指针*/ fbp (char *) mmap (0, screensize, PROT_READ PROT_WRITE, MAP_SHARED, fp,0); if ((int) fbp 1) { printf (\"Error: failed to map framebuffer device to memory./n\"); exit (4); } /*刷红色*/ int i 0; lcd_color clear_color {0,0,255,0}; for(i 0; i < screensize; i+ 4) { *((lcd_color*)(fbp + i)) clear_color; } usleep(1000*2000); /*刷绿色*/ clear_color.red 0; clear_color.green 255; clear_color.bule 0; for(i 0; i < screensize; i+ 4) { *((lcd_color*)(fbp + i)) clear_color; } usleep(1000*2000); /*刷蓝色*/ clear_color.red 0; clear_color.green 0; clear_color.bule 255; for(i 0; i < screensize; i+ 4) { *((lcd_color*)(fbp + i)) clear_color; } /*显示图片*/ memcpy(fbp,test_picture,800*480*4); munmap (fbp, screensize); /*解除映射*/ printf(\"The mem is :%d\\n\", finfo.smem_len); printf(\"The line_length is :%d\\n\", finfo.line_length); printf(\"The xres is :%d\\n\", vinfo.xres); printf(\"The yres is :%d\\n\", vinfo.yres); printf(\"bits_per_pixel is :%d\\n\", vinfo.bits_per_pixel); close(fp); return 0; } ``` 可以使用`echo test > /dev/tty1`的方式实现在屏幕上显示字符 ### 设置屏幕为终端 1. 在/etc/inittab文件里面添加`tty1::askfirst:~/bin/sh` 2. 在uboot的bootargs里面添加`console tty1`"},"/note/Linux/野火Linux/2025-10-31-61-Linux启动流程.html":{"title":"Linux启动流程","content":"# Linux启动流程 ## 汇编启动阶段 Linux内核的连接脚本文件arch/arm/kernel/vmlinux.lds ``` OUTPUT_ARCH(arm) ENTRY(stext) jiffies jiffies_64; ``` ENTRY指明了了Linux内核入口，入口为stext，stext定义在文件arch/arm/ke rnel/head.S 在启动的时候, linux需要解压缩, 这个函数实际是解压缩以后才会调用的 ```c /* * Kernel startup entry point. * * * This is normally called from the decompressor code. The requirements * are: MMU off, D cache off, I cache dont care, r0 0, * r1 machine nr, r2 atags or dtb pointer. 需要设置为以上的状态, r2记录设备树 * * This code is mostly position independent, so if you link the kernel at * 0xc0008000, you call this at __pa(0xc0008000). * * See linux/arch/arm/tools/mach types for the complete list of machine * numbers for r1. * * We're trying to keep crap to a minimum; DO NOT add any machine specific * crap here that's what the boot loader (or in extreme, well justified * circumstances, zImage) is for. */ ``` ```assembly \t.arm \t__HEAD ENTRY(stext) ARM_BE8(setend\tbe )\t\t\t@ ensure we are in BE8 mode THUMB(\tadr\tr9, BSYM(1f)\t)\t@ Kernel is always entered in ARM. THUMB(\tbx\tr9\t\t)\t@ If this is a Thumb 2 kernel, THUMB(\t.thumb\t\t\t)\t@ switch to Thumb now. THUMB(1:\t\t\t) #ifdef CONFIG_ARM_VIRT_EXT \tbl\t__hyp_stub_install #endif \t@ ensure svc mode and all interrupts masked, 设置模式以及中断关闭 \tsafe_svcmode_maskall r9 \tmrc\tp15, 0, r9, c0, c0\t\t@ get processor id 获取处理器ID记录在c9 \t# 查找处理器类型, 判断是不是支持, 记录在一个代码段里面, 是proc_info_list类型的结构体 \tbl\t__lookup_processor_type\t\t@ r5 procinfo r9 cpuid \tmovs\tr10, r5\t\t\t\t@ invalid processor (r5 0)? THUMB( it\teq )\t\t@ force fixup able long branch encoding \tbeq\t__error_p\t\t\t@ yes, error 'p' #ifdef CONFIG_ARM_LPAE \tmrc\tp15, 0, r3, c0, c1, 4\t\t@ read ID_MMFR0 \tand\tr3, r3, #0xf\t\t\t@ extract VMSA support \tcmp\tr3, #5\t\t\t\t@ long descriptor translation table format? THUMB( it\tlo )\t\t\t\t@ force fixup able long branch encoding \tblo\t__error_lpae\t\t\t@ only classic page table format #endif #ifndef CONFIG_XIP_KERNEL \tadr\tr3, 2f \tldmia\tr3, {r4, r8} \tsub\tr4, r3, r4\t\t\t@ (PHYS_OFFSET PAGE_OFFSET) \tadd\tr8, r8, r4\t\t\t@ PHYS_OFFSET #else \tldr\tr8, PLAT_PHYS_OFFSET\t\t@ always constant in this case #endif \t/* \t * r1 machine no, r2 atags or dtb, \t * r8 phys_offset, r9 cpuid, r10 procinfo \t * 当前的寄存器记录的信息 \t */ \tbl\t__vet_atags # 验证一下dtb是不是有效的 #ifdef CONFIG_SMP_ON_UP \tbl\t__fixup_smp # 多核处理 #endif #ifdef CONFIG_ARM_PATCH_PHYS_VIRT \tbl\t__fixup_pv_table #endif \tbl\t__create_page_tables # 创建页表 \t/* \t * The following calls CPU specific code in a position independent \t * manner. See arch/arm/mm/proc *.S for details. r10 base of \t * xxx_proc_info structure selected by __lookup_processor_type \t * above. On return, the CPU will be ready for the MMU to be \t * turned on, and r0 will hold the CPU control register value. \t */ \t # 记录返回地址, 这个函数进行清BSS等, 最后使用start_kernel函数进入内核 \tldr\tr13, __mmap_switched\t\t@ address to jump to after \t\t\t\t\t\t@ mmu has been enabled \tadr\tlr, BSYM(1f)\t\t\t@ return (PIC) address \tmov\tr8, r4\t\t\t\t@ set TTBR1 to swapper_pg_dir \tldr\tr12, [r10, #PROCINFO_INITFUNC] \tadd\tr12, r12, r10 \tret\tr12 1:\tb\t__enable_mmu # 使能mmu, 最终会使用r3里面记录的那个函数 ENDPROC(stext) \t.ltorg #ifndef CONFIG_XIP_KERNEL 2:\t.long\t. \t.long\tPAGE_OFFSET #endif ``` `start_kernel`在init/main.c文件里面已经是C语言了 ## C代码 ### start_kernel 在这函数里面进行了大量的初始化代码 ```c asmlinkage __visible void __init start_kernel(void) { char *command_line; char *after_dashes; lockdep_init(); /* lockdep是死锁检测模块，此函数会初始化 * 两个hash表。此函数要求尽可能早的执行！ */ set_task_stack_end_magic(&init_task);/* 设置任务栈结束魔术数， *用于栈溢出检测 */ smp_setup_processor_id(); /* 跟SMP有关(多核处理器)，设置处理器ID。 * 有很多资料说ARM架构下此函数为空函数，那是因 * 为他们用的老版本Linux，而那时候ARM还没有多 * 核处理器。 */ debug_objects_early_init(); /* 做一些和debug有关的初始化 */ boot_init_stack_canary(); /* 栈溢出检测初始化 */ cgroup_init_early(); /* cgroup初始化，cgroup用于控制Linux系统资源*/ local_irq_disable(); /* 关闭当前CPU中断 */ early_boot_irqs_disabled true; /* * 中断关闭期间做一些重要的操作，然后打开中断 */ boot_cpu_init(); /* 跟CPU有关的初始化 */ page_address_init(); /* 页地址相关的初始化 */ pr_notice(\"%s\", linux_banner);/* 打印Linux版本号、编译时间等信息 */ setup_arch(&command_line); /* 架构相关的初始化，此函数会解析传递进来的 * ATAGS或者设备树(DTB)文件。会根据设备树里面 * 的model和compatible这两个属性值来查找 * Linux是否支持这个单板。此函数也会获取设备树 * 中chosen节点下的bootargs属性值来得到命令 * 行参数，也就是uboot中的bootargs环境变量的 * 值，获取到的命令行参数会保存到 *command_line中。 */ mm_init_cpumask(&init_mm); /* 看名字，应该是和内存有关的初始化 */ setup_command_line(command_line); /* 好像是存储命令行参数 */ setup_nr_cpu_ids(); /* 如果只是SMP(多核CPU)的话，此函数用于获取 * CPU核心数量，CPU数量保存在变量 * nr_cpu_ids中。 */ setup_per_cpu_areas(); /* 在SMP系统中有用，设置每个CPU的per cpu数据 */ smp_prepare_boot_cpu(); build_all_zonelists(NULL, NULL); /* 建立系统内存页区(zone)链表 */ page_alloc_init(); /* 处理用于热插拔CPU的页 */ /* 打印命令行信息 */ pr_notice(\"Kernel command line: %s\\n\", boot_command_line); parse_early_param(); /* 解析命令行中的console参数 */ after_dashes parse_args(\"Booting kernel\", static_command_line, __start___param, __stop___param __start___param, 1, 1, &unknown_bootoption); if (!IS_ERR_OR_NULL(after_dashes)) parse_args(\"Setting init args\", after_dashes, NULL, 0, 1, 1, set_init_arg); jump_label_init(); setup_log_buf(0); /* 设置log使用的缓冲区*/ pidhash_init(); /* 构建PID哈希表，Linux中每个进程都有一个ID, * 这个ID叫做PID。通过构建哈希表可以快速搜索进程 * 信息结构体。 */ vfs_caches_init_early(); /* 预先初始化vfs(虚拟文件系统)的目录项和 * 索引节点缓存 */ sort_main_extable(); /* 定义内核异常列表 */ trap_init(); /* 完成对系统保留中断向量的初始化 */ mm_init(); /* 内存管理初始化 */ sched_init(); /* 初始化调度器，主要是初始化一些结构体 */ preempt_disable(); /* 关闭优先级抢占 */ if (WARN(!irqs_disabled(), /* 检查中断是否关闭，如果没有的话就关闭中断 */ \"Interrupts were enabled *very* early, fixing it\\n\")) local_irq_disable(); idr_init_cache(); /* IDR初始化，IDR是Linux内核的整数管理机 * 制，也就是将一个整数ID与一个指针关联起来。 */ rcu_init(); /* 初始化RCU，RCU全称为Read Copy Update(读 拷贝修改) */ trace_init(); /* 跟踪调试相关初始化 */ context_tracking_init(); radix_tree_init(); /* 基数树相关数据结构初始化 */ early_irq_init(); /* 初始中断相关初始化,主要是注册irq_desc结构体变 * 量，因为Linux内核使用irq_desc来描述一个中断。 */ init_IRQ(); /* 中断初始化 */ tick_init(); /* tick初始化 */ rcu_init_nohz(); init_timers(); /* 初始化定时器 */ hrtimers_init(); /* 初始化高精度定时器 */ softirq_init(); /* 软中断初始化 */ timekeeping_init(); time_init(); /* 初始化系统时间 */ sched_clock_postinit(); perf_event_init(); profile_init(); call_function_init(); WARN(!irqs_disabled(), \"Interrupts were enabled early\\n\"); early_boot_irqs_disabled false; local_irq_enable(); /* 使能中断 */ kmem_cache_init_late(); /* slab初始化，slab是Linux内存分配器 */ console_init(); /* 初始化控制台，之前printk打印的信息都存放 * 缓冲区中，并没有打印出来。只有调用此函数 * 初始化控制台以后才能在控制台上打印信息。 */ if (panic_later) panic(\"Too many boot %s vars at `%s'\", panic_later, panic_param); lockdep_info();/* 如果定义了宏CONFIG_LOCKDEP，那么此函数打印一些信息。*/ locking_selftest() /* 锁自测 */ ...... page_ext_init(); debug_objects_mem_init(); kmemleak_init(); /* kmemleak初始化，kmemleak用于检查内存泄漏 */ setup_per_cpu_pageset(); numa_policy_init(); if (late_time_init) late_time_init(); sched_clock_init(); calibrate_delay(); /* 测定BogoMIPS值，可以通过BogoMIPS来判断CPU的性能 * BogoMIPS设置越大，说明CPU性能越好。 */ pidmap_init(); /* PID位图初始化 */ anon_vma_init(); /* 生成anon_vma slab缓存 */ acpi_early_init(); ...... thread_info_cache_init(); cred_init(); /* 为对象的每个用于赋予资格(凭证) */ fork_init(); /* 初始化一些结构体以使用fork函数 */ proc_caches_init(); /* 给各种资源管理结构分配缓存 */ buffer_init(); /* 初始化缓冲缓存 */ key_init(); /* 初始化密钥 */ security_init(); /* 安全相关初始化 */ dbg_late_init(); vfs_caches_init(totalram_pages); /* 为VFS创建缓存 */ signals_init(); /* 初始化信号 */ page_writeback_init(); /* 页回写初始化 */ proc_root_init(); /* 注册并挂载proc文件系统 */ nsfs_init(); cpuset_init(); /* 初始化cpuset，cpuset是将CPU和内存资源以逻辑性 * 和层次性集成的一种机制，是cgroup使用的子系统之一 */ cgroup_init(); /* 初始化cgroup */ taskstats_init_early(); /* 进程状态初始化 */ delayacct_init(); check_bugs(); /* 检查写缓冲一致性 */ acpi_subsystem_init(); sfi_init_late(); if (efi_enabled(EFI_RUNTIME_SERVICES)) { efi_late_init(); efi_free_boot_services(); } ftrace_init(); rest_init(); /* rest_init函数 */ } ``` ### reset_init ```c static noinline void __init_refok rest_init(void) { \tint pid; \trcu_scheduler_starting(); \tsmpboot_thread_init(); \t/* \t * We need to spawn init first so that it obtains pid 1, however \t * the init task will end up wanting to create kthreads, which, if \t * we schedule it before we create kthreadd, will OOPS. \t */ \tkernel_thread(kernel_init, NULL, CLONE_FS); // 创建init进程, PID是1 \tnuma_default_policy(); \tpid kernel_thread(kthreadd, NULL, CLONE_FS CLONE_FILES); \trcu_read_lock(); \tkthreadd_task find_task_by_pid_ns(pid, &init_pid_ns); \trcu_read_unlock(); \tcomplete(&kthreadd_done); \t/* \t * The boot idle thread must execute schedule() \t * at least once to get things moving: \t */ \tinit_idle_bootup_task(current); \tschedule_preempt_disabled(); \t/* Call into cpu_idle with preempt disabled */ \tcpu_startup_entry(CPUHP_ONLINE); } ``` > init进程的PID为1。init进程一开始是内核进程(也就是运行在内核态)，后面init进程会在根 文件系统中查找名为“init”这个程序，这个“init”程序处于用户态，通过运行这个“init”程 序，init进程就会实现从内核态到用户态的转变。实际运行的是`kernel_init` > > `kthreadd` 内核进程，此内核进程的PID为2。kthre add进程负责所有内核进程的调度和管理 > > `cpu_startup_entry`会调用`cpu _idle_loop`，cpu_idle_loop是个while循环，也就是idle进程代码。idle进程的PID为0，idle进 程叫做空闲进程, 它是有主进程演变 而来的 #### kernel_init init进程具体做的工作，定义在文件init/main.c ```c static int __ref kernel_init(void *unused) { \tint ret; \tkernel_init_freeable(); \t/* need to finish all async __init code before freeing the memory */ \tasync_synchronize_full(); \tfree_initmem(); \tmark_rodata_ro(); \tsystem_state SYSTEM_RUNNING; \tnuma_default_policy(); \tflush_delayed_fput(); \tif (ramdisk_execute_command) { // 这个变量是\"/init\", 也可以在uboot里面使用rdinit xxx设置 \t\tret run_init_process(ramdisk_execute_command); \t\tif (!ret) \t\t\treturn 0; \t\tpr_err(\"Failed to execute %s (error %d)\\n\", \t\t ramdisk_execute_command, ret); \t} \t/* \t * We try each of these until one succeeds. \t * \t * The Bourne shell can be used instead of init if we are \t * trying to recover a really broken machine. \t */ \tif (execute_command) {// execute_command的值是通过uboot传递，使用init xxxx \t\tret run_init_process(execute_command); \t\tif (!ret) \t\t\treturn 0; \t\tpanic(\"Requested init %s failed (error %d).\", \t\t execute_command, ret); \t} // 一次尝试运行下面 \tif (!try_to_run_init_process(\"/sbin/init\") \t !try_to_run_init_process(\"/etc/init\") \t !try_to_run_init_process(\"/bin/init\") \t !try_to_run_init_process(\"/bin/sh\")) \t\treturn 0; \tpanic(\"No working init found. Try passing init option to kernel. \" \t \"See Linux Documentation/init.txt for guidance.\"); } ``` > init进程的主要任务是启动其他系统服务和用户交互界面。它会执行用户态的init程序（如*/sbin/init*），并启动各种服务，如登录进程（getty）、命令行进程和shell进程。所有用户进程都直接或间接派生自init进程。 ```c static noinline void __init kernel_init_freeable(void) { \t/* \t * Wait until kthreadd is all set up. \t */ \twait_for_completion(&kthreadd_done); \t/* Now the scheduler is fully set up and can do blocking allocations */ \tgfp_allowed_mask __GFP_BITS_MASK; \t/* \t * init can allocate pages on any node \t */ \tset_mems_allowed(node_states[N_MEMORY]); \t/* \t * init can run on any cpu. \t */ \tset_cpus_allowed_ptr(current, cpu_all_mask); \tcad_pid task_pid(current); \tsmp_prepare_cpus(setup_max_cpus); \tdo_pre_smp_initcalls(); \tlockup_detector_init(); \tsmp_init(); \tsched_init_smp(); \tdo_basic_setup(); // 完成Linux下设备驱动初始化工作 \t/* Open the /dev/console on the rootfs, this should never fail */ // 打开这个串口作为默认stdin(0) \tif (sys_open((const char __user *) \"/dev/console\", O_RDWR, 0) < 0) \t\tpr_err(\"Warning: unable to open an initial console.\\n\"); \t(void) sys_dup(0); // 文件描述符1, 标准输出 \t(void) sys_dup(0); // 文件描述符2标准错误 \t/* \t * check if there is an early userspace init. If yes, let it do all \t * the work \t */ \tif (!ramdisk_execute_command) \t\tramdisk_execute_command \"/init\"; \tif (sys_access((const char __user *) ramdisk_execute_command, 0) ! 0) { \t\tramdisk_execute_command NULL; \t\tprepare_namespace(); // 挂载根文件系统 \t} \t/* \t * Ok, we have completed the initial bootup, and \t * we're essentially up and running. Get rid of the \t * initmem segments and start the user mode stuff.. \t * \t * rootfs is available now, try loading the public keys \t * and default modules \t */ \tintegrity_load_keys(); \tload_default_modules(); } ```"},"/note/Linux/野火Linux/2025-7-14-05-ARMv7汇编.html":{"title":"","content":"## ARM V7架构 Cortex A7 MPcore 处理器支持1~4核，通常是和Cortex A15组成big.LITTLE架构的，Co rtex A15 作为大核负责高性能运算，比如玩游戏啥的，Cortex A7负责普通应用，因为Cortex A 7 省电。Cortex A7 本身性能也不弱，不要看它叫做Cortex A7但是它可是比Cortex A8性能要 强大，而且更省电 ![image 20251012094949005](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510120949051.png) #### 运行模式 User(USR)：用户模式, linux系统用户进程，资源访问受限 System(SYS)：系统模式, linux内核，共用寄存器(用户模式可以使用寄存器给SYS模式发送信息)，资源自由访问 IRQ：一般中断模式, 硬件产生中断信号 FIQ：快速中断模式, 时间紧急的中断，高速信号的传输、采集 Supervisor(SVC)：管理模式, 默认模式，系统初始化，软中断, 可以使用软终端进入 Abort(ABT)：数据访问终止模式, 非法访问地址或寄存器、段错误 Undef(UND)：未定义指令模式, 程序跑飞、篡改 Monitor：用于用户安全扩展模式 Hyp ：用于虚拟化扩展 #### 寄存器组 ##### 通用寄存器 ![image 20251012095317545](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510120953586.png) r0~r3：用来传递函数参数、暂存数据 r4~r11：用来保存被调函数的局部变量、暂存数据 r12：记录函数调用过程中上一次sp指针的值 r13(sp)：函数堆栈寄存器 r14(lr)：记录函数返回地址 r15(pc)：程序计数器, 指向当前正在执行的 指令地址再加上2条指令的地址 ##### 程序状态寄存器 ![image 20251012095741144](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510120957174.png) cpsr：该寄存器包含运算标志位、中断禁止位、当前运行模式标志等一些状态位以及一些控制位 > bit31：负数标记位 > bit30：零标志位 > ... > M[4:0]：运行模式控制位 > 10000：User 模式 > 10001：FIQ 模式 > 10010：IRQ 模式 > 10011：SVC模式 > 10111：Abort模式 > 11011：Undef模式 > 11111：System模式 > 10110：Monitor模式 > 11010：Hyp模式 spsr：发生异常切换模式时，将cpsr复制到发生异常的模式下的spsr 上一小节我们讲了Cortex A7有9种运行模式，每一种运行模式都有一组与之对应的寄存 器组。每一种模式可见的寄存器包括15个通用寄存器(R0~R14)、一两个程序状态寄存器和一个 程序计数器PC ![image 20251012095414780](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510120954828.png) ##### 系统寄存器 cp15协处理器：内存、缓存、中断等 ### ARM常用汇编指令 汇编格式： ``` label：instruction @ comment ``` label：标号 标记一个代码的位置 instruction：具体汇编指令 comment：注释内容 常用段名： .text：代码段 .data：初始化的数据段 .bss：未初始化的数据段 .rodata：只读数据段 .section：自定义段 ``` .section .vector ``` 常见伪操作： .global：定义全局标号, 可以在其他的文件使用 ``` .global _start ``` .align：字节对齐 ``` .align 2 ``` 寄存器间数据传输: mov：寄存器数据(或者是立即数)拷贝到另一个寄存器, 左←右 ``` mov r0，r1 mov r0, #0x12 ``` mrs：读程序状态寄存器 ``` mrs r0,cpsr ``` msr：写程序状态寄存器 ``` msr cpsr,r0 ``` mrc：读cp15协处理器, 以及spsr状态寄存器 mcr：写cp15寄存器, 以及cpsr状态寄存器 cps: 直接写cpsr的[0:4] 内存与寄存器数据传输: ldr：把内存数据(或者是立即数)加载到寄存器 ``` ldr r0, 0x80000000 ldr r1, [r0] ``` str：把寄存器数据写入到内存 ``` str r0, 0x80000000 str r1,[r0] ``` 压栈和出栈 push：把寄存器列表存入栈中 ``` push {r0~r3, r12} ``` pop：从栈中恢复寄存器列表 ``` pop {r0~r3, r12} ``` 跳转 b：跳转到目标地址 ``` b main ``` bl：跳转到目标地址，并把当前pc指针值保存在lr寄存器中 ``` bl main ``` 算术运算指令 add：加法运算 ``` add r1,r2,r3 @ r1 r2 + r3 add r1,r2 @ r1 r ``` sub：减法运算 ``` sub r1,r2,r3 ``` mul：乘法运算 ``` mul r1,r2,r3 ``` udiv：除法运算 ``` udiv r1,r2,r3 ``` 逻辑运算 and：与 ``` and r1,r2,r3 and r1,r2 ``` orr：或 ``` orr r1,r2,r3 ``` bic：位清除 ``` bic r1,r2,r3 ```"},"/note/Linux/野火Linux/2025-9-25-29-POLL机制.html":{"title":"POLL机制","content":"# POLL机制 ## 使用 + 使用poll在驱动里面的对应函数 + 调用`wait_poll`等待一个等待队列, 队列在其他地方使用wake_up唤醒 + 唤醒之后根据当前的状态设置标志位 ## POLL机制基本概念 应用空间里面poll()函数 实际调用的是file_operations >poll #### 应用层poll()函数 异步阻塞型IO 同步阻塞：阻塞在一个文件的读写操作上(read\\write)，自己设备驱动唤醒自己 异步阻塞：阻塞在**多个**文件的轮询操作上(poll)，可被多个设备驱动唤醒 ## 文件I/O事件 可读、可写、异常... ### select函数 ```c int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout) ``` **nfds**：所要监视的这三类文件描述集合中，最大文件描述符加1。 **readfds**、**writefds** 和 **exceptfds**：这三个指针指向描述符集合，这三个参数指明了关心哪些描述符、需要满足哪些条件等等，这三个参数都是 fd_set 类型的，fd_set 类型变量的每一个位都代表了一个文件描述符。readfds用于监视指定描述符集的读变化，也就是监视这些文件是否可以读取，只要这些集合里面有一个文件可以读取那么 seclect就会返回一个大于 0的值表示文件可以读取。如果没有文件可以读取，那么就会根据 timeout参数来判断是否超时。可以将 readfs设置为NULL，表示不关心任何文件的读变化。writefds和readfs类似，只是 writefs用于监视这些文件是否可以进行写操作。exceptfds用于监视这些文件的异常 **timeout**: ```c struct timeval { long tv_sec; /* 秒 */ long tv_usec; /* 微妙 */ }; ``` >比如我们现在要从一个设备文件中读取数据，那么就可以定义一个 fd_set 变量，这个变量要传递给参数 readfds > >使用以下的宏定义初始化fd_set > >```c >void FD_ZERO(fd_set *set) >void FD_SET(int fd, fd_set *set) >void FD_CLR(int fd, fd_set *set) >int FD_ISSET(int fd, fd_set *set) >``` ### poll函数 \\#include <poll.h> 监视多个文件描述符的指定事件，事件发生时(驱动唤醒)，把发生的具体事件通知给用户程序 ```c int poll(struct pollfd *fds,nfds_t nfds,int timeout) ``` 参数： fds ：一个struct pollfd类型的**数组** ```c struct pollfd { int fd; /* 文件描述符 */ short events; /* 请求的事件类型 */ short revents; /* 返回的事件类型 */ }; ``` fd：要监视的文件描述符 events 是要监视的事件 `POLLIN`：系统内核通知应用层指定数据已经备好，读数据不会被阻塞 `POLLPRI` ：有紧急的数据需要读取 `POLLOUT` ：系统内核通知应用层IO缓冲区已准备好，写数据不会被阻塞 `POLLERR` ：指定的文件描述符发生错误 `POLLNVAL`：无效的请求 ... `revents`是返回事件，内核设置具体的返回事件 nfds：pollfd数组的元素个数，要监控的文件描述符数量 timeout：超时时间(ms) 返回值： 成功：发生事件的文件数量，超时返回0 失败： 1 ### epoll 传统的 selcet和 poll函数都会随着所监听的 fd数量的增加，出现效率低下的问题，而且 poll函数每次必须遍历所有的描述符来检查就绪的描述 ```c int epoll_create(int size) ``` 之后使用以下的函数来检查 ```c int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event) ``` + **epfd**：要操作的 epoll句柄，也就是使用epoll_create函数创建的epoll句柄。 + **op**：表示要对epfd(epoll句柄)进行的操作 ```c EPOLL_CTL_ADD 向 epfd添加文件参数 fd表示的描述符。 EPOLL_CTL_MOD 修改参数fd的event事件。 EPOLL_CTL_DEL 从 epfd中删除fd描述符。 ``` + **fd**：要监视的文件描述符。 + **event**：要监视的事件类型，为 epoll_event结构体类型指针，epoll_event结构体类型如下所示： ```c struct epoll_event { uint32_t events; /* epoll事件 */ epoll_data_t data; /* 用户数据 */ }; EPOLLIN 有数据可以读取。 EPOLLOUT 可以写数据。 EPOLLPRI 有紧急的数据需要读取。 EPOLLERR 指定的文件描述符发生错误。 EPOLLHUP 指定的文件描述符挂起。 EPOLLET 设置epoll为边沿触发，默认触发模式为水平触发。 EPOLLONESHOT 一次性的监视，当监视完成以后还需要再次监视某个fd，那么就需要将fd重新添加到epoll里面。 ``` 可以通过 epoll_wait 函数来等待事件的发生，类似 select 函数 ```c int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout) ``` + **epfd**：要等待的 epoll。 + **events**：指向epoll_event结构体的数组，当有事件发生的时候Linux内核会填写events，调用者可以根据events判断发生了哪些事件。 + **maxevents**：events数组大小，必须大于0。 + **timeout**：超时时间，单位为 ms。 返回值：0，超时； 1，错误；其他值，准备就绪的文件描述符数量。 ## 使用 ```c #include <stdio.h> #include <unistd.h> #include <fcntl.h> #include <string.h> #include <poll.h> int main(int argc, char *argv[]) { struct pollfd fds {0}; fds.fd 0; // 标准输入 fds.events POLLIN; int ret poll(&fds,1,5000); if(ret 1) printf(\"poll error!\\r\\n\"); else if(ret) printf(\"data is ready!\\r\\n\"); else if(ret 0) printf(\"time out!/r/n\"); } ``` ## POLL底层机制剖析 #### 系统调用接口sys_poll fs/select.c 这个宏定义会把这个函数的名字设置为sys_poll ```c SYSCALL_DEFINE3(poll, struct pollfd __user *, ufds, unsigned int, nfds,int, timeout_msecs) { \tstruct timespec64 end_time, *to NULL;\t// 实现一个时间相关的时间的结构体 \tint ret; \tif (timeout_msecs > 0) { \t\tto &end_time; \t\tpoll_select_set_timeout(to, timeout_msecs / MSEC_PER_SEC, \t\t\tNSEC_PER_MSEC * (timeout_msecs % MSEC_PER_SEC)); \t} \t// 实际使用的函数 \tret do_sys_poll(ufds, nfds, to); \t... \treturn ret; } ``` #### SYSCALL_DEFINE3()宏 ``` #define SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__) ``` #### SYSCALL_DEFINEx()宏 ```c #define SYSCALL_DEFINEx(x, sname, ...)\t\t\t\t\\ \tSYSCALL_METADATA(sname, x, __VA_ARGS__)\t\t\t\\ \t__SYSCALL_DEFINEx(x, sname, __VA_ARGS__) ``` #### __SYSCALL_DEFINEx()宏 ```c #ifndef __SYSCALL_DEFINEx #define __SYSCALL_DEFINEx(x, name, ...)\t\t\t\t\t\\ \t \tasmlinkage long sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))\t\\ \t\t__attribute__((alias(__stringify(__se_sys##name))));\t\\ \t... #endif /* __SYSCALL_DEFINEx */ ``` #### timespec64结构体 include/linux/time64.h Linux里面用于记录时间的结构体 ```c struct timespec64 { \ttime64_t\ttv_sec;\t\t\t/* seconds */ \tlong\t\ttv_nsec;\t\t/* nanoseconds */ }; ``` #### do_sys_poll()函数 fs/select.c 复制用户空间pollfd数组到内核空间 分配静态数组内存(一个poll_list结构体） 动态分配内存（一组poll_list结构体） 调用do_poll函数 返回修改后的pollfd数组到用户空间 主要是返回修改后revents值 ![image 20250925161310271](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509251613340.png) ![image 20250925163522058](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509251635150.png) ```c static int do_sys_poll(struct pollfd __user *ufds, unsigned int nfds,struct timespec64 *end_time) { \tstruct poll_wqueues table; \tint err EFAULT, fdcount, len, size; \tlong stack_pps[POLL_STACK_ALLOC/sizeof(long)]; // 一共是256字节 \tstruct poll_list *const head (struct poll_list *)stack_pps; \tstruct poll_list *walk head; \tunsigned long todo nfds; // 记录元素的个数 \t... \t//获取静态分配的数组大小 \tlen min_t(unsigned int, nfds, N_STACK_PPS); // 取输入和分配的最小值 \tfor (;;) { \t\twalk >next NULL; \t\twalk >len len; \t\tif (!len) \t\t\tbreak; \t\t// 复制数据到内核态, 分配的大小不足时候分多次 \t\tif (copy_from_user(walk >entries, ufds + nfds todo, \t\t\t\t\tsizeof(struct pollfd) * walk >len)) \t\t\tgoto out_fds; \t\ttodo walk >len; \t\tif (!todo) \t\t\tbreak; \t\t//计算剩下的文件描述符所需空间大小，最大为一个页 \t\tlen min(todo, POLLFD_PER_PAGE); \t\tsize sizeof(struct poll_list) + sizeof(struct pollfd) * len; \t\twalk walk >next kmalloc(size, GFP_KERNEL); \t\tif (!walk) { \t\t\terr ENOMEM; \t\t\tgoto out_fds; \t\t} \t} \t \tpoll_initwait(&table); \tfdcount do_poll(head, &table, end_time); \tpoll_freewait(&table); \tfor (walk head; walk; walk walk >next) { // 遍历数组查看一下发生的事件 \t\tstruct pollfd *fds walk >entries; \t\tint j; \t\tfor (j 0; j < walk >len; j++, ufds++) \t\t\tif (__put_user(fds[j].revents, &ufds >revents)) \t\t\t\tgoto out_fds; \t} \t... } ``` ##### 相关宏定义 ```c #define FRONTEND_STACK_ALLOC\t256 #define POLL_STACK_ALLOC\tFRONTEND_STACK_ALLOC #define N_STACK_PPS ((sizeof(stack_pps) sizeof(struct poll_list)) / \\ \t\t\tsizeof(struct pollfd)) ``` #### poll_initwait()函数 fs/select.c ```c void poll_initwait(struct poll_wqueues *pwq) { \tinit_poll_funcptr(&pwq >pt, __pollwait); \t... } ``` #### init_poll_funcptr()函数 include/linux/poll.h ```c static inline void init_poll_funcptr(poll_table *pt, poll_queue_proc qproc) { \tpt >_qproc qproc; // __pollwait, 一个函数的指针 \tpt >_key ~(__poll_t)0; /* all events enabled */ } ``` #### __pollwait()函数 fs/select.c **注册等待队列**：将当前进程注册到指定的等待队列中 **非阻塞检查**：本身不会阻塞，只是设置唤醒机制 **事件通知**：当设备就绪时，通过等待队列唤醒等待的进程 ```c static void __pollwait(struct file *filp, wait_queue_head_t *wait_address, \t\t\t\tpoll_table *p) { // 获取到poll_wqueues \tstruct poll_wqueues *pwq container_of(p, struct poll_wqueues,pt); \tstruct poll_table_entry *entry poll_get_entry(pwq); \tif (!entry) \t\treturn; \tentry >filp get_file(filp); \tentry >wait_address wait_address; \tentry >key p >_key; \tinit_waitqueue_func_entry(&entry >wait, pollwake); \tentry >wait.private pwq; // 加入等待队列 \tadd_wait_queue(wait_address, &entry >wait); } ``` #### poll_get_entry()函数 fs/select.c ```c static struct poll_table_entry *poll_get_entry(struct poll_wqueues *p) { \tstruct poll_table_page *table p >table; \t// 返回一个可以使用的等待队列元素wait_queue_entry \tif (p >inline_index < N_INLINE_POLL_ENTRIES) \t\treturn p >inline_entries + p >inline_index++; \t// 不够用的话重新分配 \tif (!table POLL_TABLE_FULL(table)) { \t\tstruct poll_table_page *new_table; \t\tnew_table (struct poll_table_page *) __get_free_page(GFP_KERNEL); \t\tif (!new_table) { \t\t\tp >error ENOMEM; \t\t\treturn NULL; \t\t} \t\tnew_table >entry new_table >entries; \t\tnew_table >next table; \t\tp >table new_table; \t\ttable new_table; \t} \treturn table >entry++; } ``` #### do_poll()函数 fs/select.c 第一重for：确保线程/进程被唤醒后，继续执行一次循环体内容 第二重for：遍历一组poll_list 第二重for：遍历每个poll_list中的一组pollfd ```c static int do_poll(struct poll_list *list, struct poll_wqueues *wait, \t\t struct timespec64 *end_time) { \tpoll_table* pt &wait >pt; \tktime_t expire, *to NULL; \tint timed_out 0, count 0; \tu64 slack 0; \t__poll_t busy_flag net_busy_loop_on() ? POLL_BUSY_LOOP : 0; \tunsigned long busy_start 0; \t... \tfor (;;) { \t\tstruct poll_list *walk; \t\tbool can_busy_loop false; \t\tfor (walk list; walk ! NULL; walk walk >next) { // 遍历所有的poll_list结构体 \t\t\tstruct pollfd * pfd, * pfd_end; \t\t\tpfd walk >entries; \t\t\tpfd_end pfd + walk >len; \t\t\tfor (; pfd ! pfd_end; pfd++) { // 遍历list数组里面的所有的选项 \t\t\t\tif (do_pollfd(pfd, pt, &can_busy_loop, \t\t\t\t\t busy_flag)) { \t\t\t\t\tcount++; // 发生事件的文件数量 \t\t\t\t\tpt >_qproc NULL; \t\t\t\t\t/* found something, stop busy polling */ \t\t\t\t\tbusy_flag 0; \t\t\t\t\tcan_busy_loop false; \t\t\t\t} \t\t\t} \t\t} \t\tpt >_qproc NULL; \t\tif (!count) { \t\t\tcount wait >error; \t\t\t//检查是否有信号处理 \t\t\tif (signal_pending(current)) \t\t\t\tcount EINTR; \t\t} \t\tif (count timed_out) \t\t\tbreak; \t\t... // 休眠函数 \t\tif (!poll_schedule_timeout(wait, TASK_INTERRUPTIBLE, to, slack)) \t\t\ttimed_out 1; \t} \treturn count; } ``` #### do_pollfd()函数 fs/select.c 实际处理一个文件的函数, 返回的值是非零的时候, 表示发生事件 ```c static inline __poll_t do_pollfd(struct pollfd *pollfd, poll_table *pwait, \t\t\t\t bool *can_busy_poll, \t\t\t\t __poll_t busy_flag) { \tint fd pollfd >fd; \t__poll_t mask 0, filter; \tstruct fd f; \tif (fd < 0) \t\tgoto out; \t... // 在这里处理 \tmask vfs_poll(f.file, pwait); \t... } ``` #### vfs_poll()函数 include/linux/poll.h ```c tatic inline __poll_t vfs_poll(struct file *file, struct poll_table_struct *pt) { \tif (unlikely(!file >f_op >poll)) \t\treturn DEFAULT_POLLMASK; \treturn file >f_op >poll(file, pt); // 底层驱动里面的 } ``` #### 驱动层poll底层接口 include/linux/fs.h ```c __poll_t (*poll) (struct file *, struct poll_table_struct *); ``` 参数： filp ：要打开的设备文件 wait ：结构体 poll_table_struct 类型指针 返回值： 文件可用事件类型 ##### poll驱动模板 实现得时候必须调用一下poll_wait函数 ```c static __poll_t xxx_poll(struct file *filp, struct poll_table_struct *wait) { \tunsigned int mask 0; \tpoll_wait(filp, &yyy, wait); \tif(...) \t{ \t\tmask POLLOUT ...; \t} \treturn mask; } ``` #### poll_wait()函数 include/linux/poll.h wait_address是等待队列的头, 实际是等待这个等待队列, 需要在其他地方释放这个消息队列 ```c static inline void poll_wait(struct file * filp, wait_queue_head_t * wait_address, poll_table *p) { \tif (p && p >_qproc && wait_address) \t\tp >_qproc(filp, wait_address, p); // __pollwait函数 } ``` ## 实际使用 ### 简单示例 ```c #include <linux/poll.h> #include <linux/wait.h> struct my_device { wait_queue_head_t readq; wait_queue_head_t writeq; int data_ready; int space_available; }; static unsigned int my_poll(struct file *filp, poll_table *wait) { struct my_device *dev filp >private_data; unsigned int mask 0; // 注册到等待队列 poll_wait(filp, &dev >readq, wait); poll_wait(filp, &dev >writeq, wait); // 检查当前状态 spin_lock(&dev >lock); if (dev >data_ready) mask POLLIN POLLRDNORM; // 可以读取 if (dev >space_available) mask POLLOUT POLLWRNORM; // 可以写 spin_unlock(&dev >lock); return mask; } // 数据到达时的处理 static void data_arrived(struct my_device *dev) { spin_lock(&dev >lock); dev >data_ready 1; spin_unlock(&dev >lock); // 唤醒等待读取的进程 wake_up_interruptible(&dev >readq); } ``` ### 教程 ```c wait_queue_head_t wait_queue; unsigned int write_data; //用于保存接收到的数据 /*字符设备操作函数集，write函数*/ static ssize_t led_chr_dev_write(struct file *filp, const char __user *buf, size_t cnt, loff_t *offt) { \tint ret,error; \tunsigned char receive_data[10]; //用于保存接收到的数据 \tif(cnt>10) \t\t\tcnt 10; \terror copy_from_user(receive_data, buf, cnt); \tif (error < 0) \t{ \t\treturn 1; \t} \tret kstrtoint(receive_data, 16, &write_data); \tif (ret) { \t\treturn 1; } \tif(write_data) \t{ \t\twake_up(&wait_queue); \t\treturn cnt; \t} \telse \t{ \t\tgpio_set_value(rgb_led_red,0); \t} \treturn cnt; } __poll_t led_chrdev_poll (struct file *filp, struct poll_table_struct *wait) { \tunsigned int mask 0; \tpoll_wait(filp, &wait_queue, wait); \tif(write_data) \t{ \t\tmask POLLOUT; \t} \treturn mask; } ``` ```c #include <linux/poll.h> struct my_device { wait_queue_head_t readq; struct mutex lock; char buffer[1024]; int data_len; bool data_ready; }; static ssize_t my_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos) { struct my_device *dev filp >private_data; int ret; // 如果没有数据，等待 if (wait_event_interruptible(dev >readq, dev >data_ready)) return ERESTARTSYS; mutex_lock(&dev >lock); // 复制数据到用户空间 ret copy_to_user(buf, dev >buffer, min(count, dev >data_len)); dev >data_ready false; mutex_unlock(&dev >lock); return ret; } static unsigned int my_poll(struct file *filp, poll_table *wait) { struct my_device *dev filp >private_data; unsigned int mask 0; // 注册调用poll的进程到等待队列 poll_wait(filp, &dev >readq, wait); mutex_lock(&dev >lock); if (dev >data_ready) mask POLLIN POLLRDNORM; // 数据可读 mutex_unlock(&dev >lock); return mask; } // 数据到达时（可能在中断中调用） static void data_received(struct my_device *dev, const char *data, int len) { mutex_lock(&dev >lock); memcpy(dev >buffer, data, len); dev >data_len len; dev >data_ready true; mutex_unlock(&dev >lock); // 唤醒所有等待读取的进程 wake_up_interruptible(&dev >readq); } ```"},"/note/Linux/野火Linux/2025-10-2-47-镜像构建.html":{"title":"镜像合成","content":"# 镜像合成 ## 整个镜像 ![image 20251002103617559](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510021036830.png) `sudo apt install xz utils debootstrap multistrap` `git clone git@gitee.com:LubanCat/build_sd_img.git` 默认./all 下为野火2022 12 24 的镜像组件，如果需要修改可以根据以下进行修改 ### 使用脚本合成 1.修改rootfs ./all/rootfs下默认是没有内容的，需要把自己的rootfs解压到./all/rootfs目录,或者将野火官方的带qt的文件系统解压到./all/rootfs下,野火官方的文件系统可以从网盘 i.MX6ULL系列\\3 Debian镜像\\ebf_debian_2022_12_24\\usb烧录文件\\mfgtools release\\Profiles\\Linux\\OS Firmware\\release中获取console armhf rootfs lubancat buster.tar为纯净版文件系统，qt armhf rootfs lubancat buster.tar为带qt的文件系统,解压到./all/rootfs下即可 2.修改kernel 把生成的zImage拷贝到./all/boot/kernel文件夹下更名替换vmlinuz 4.19.35 imx6,注意boot文件夹不能超过40M 3.修改uboot 把生成的u boot dtb.imx更名替换./all/uboot/目录下的u boot mmc.imx,注意编译时需要选择mmc版的uboot配置文件编译 4.修改设备树 把生成的设备树imx6ull mmc npi.dtb替换.all/rootfs/usr/lib/linux image 4.19.35 imx6/imx6ull mmc npi.dtb 5.修改设备树插件 把生成的设备树插件xxx.dtbo添加或替换.all/rootfs/usr/lib/linux image 4.19.35 imx6/overlays/下，并在./all/boot/uEnv.txt进行相应的修改 构建： 执行sudo ./build_sd_img.sh 8 构建SD卡镜像 参数8为内存卡大小为8G，同时也为镜像内可用大小，但总大小最小要求为rootfs文件夹的大小+40M 参数也可以为小数，比如0.5，即打包500M大小的镜像 构建前请确认./all/rootfs目录已经放了文件系统，参考以上 1.修改rootfs 确认。 `sudo ./build_sd_img.sh 1`使用这个命令进行构建 > 参数 1 为内存卡大小为1G，同时也为镜像内可用大 小，该参数支持小数，比如输入0.5即构建500M大小的镜像包 > > 建议在打包的时候参数尽量小，避免烧录镜像至sd卡的时间过长，我们在烧录完成后再对分区 进行扩容即可 ### 扩容 将sd卡插入板卡并以sd卡启动方式启动，执行下面命令对分区进行扩容 ```bash #sd卡的主分区是/dev/mmcblk0 sudo parted /dev/mmcblk0 #以GB作为单位查看分区信息 unit GB print #对mmcblk0的第2分区进行扩容,该分区存放跟文件系统 resizepart 2 #按提示输入yes进行确认 yes #输入参数 1表示完全使用剩余空间 1 #退出交互 quit #调整文件系统大小 sudoresize2fs /dev/mmcblk0p2 ```"},"/note/Linux/野火Linux/2025-11-18-70-中断线程化.html":{"title":"中断线程化","content":"# 中断线程化 ## 概念 在中断函数中断上文的同步触发的情况下，中断下文基于内核机制在线程或者进程中同步处理。甚至中断上文触发函数都不要了 设为null,直接触发中断下文的 中断线程化机制 处理 延时、阻塞业务。 ```c int request_threaded_irq(unsigned int irq, irq_handler_t handler, irq_handler_t thread_fn, unsigned long irqflags, const char *devname, void *dev_id); ``` + irq： 中断号， 表示要请求的中断线路。 + handler： 是在发生中断时首先要执行的处理程序， 非常类似于顶半部， 该函数最后会返回 IRQ_WAKE_THREAD 来唤醒中断， 一般 handler 设为 NULL， 用系统提供的默认处理。 + thread_fn： 线程化的中断处理函数， 非常类似于底半部。 如果此处设置为 NULL 则表示没有使用中断线程化。 + irqflags： 中断标志， 用于指定中断的属性和行为。 + devname： 中断的名称， 用于标识中断请求的设备。 + dev_id： 设备标识符， 用于传递给中断处理函数的参数。 > 对于触摸屏而言只要手指放到屏幕上，它可能就会一直产生中断(视具体芯片而定，FT5426是这样的)，中断处理程序里面需要通过 I2C读取触摸信息并上报给内核，I2C的速度最大只有 400KHz，算是低速外设。不断的产生中断、读取触摸信息、上报信息会导致处理器在触摸中断上花费大量的时间，但是触摸相对来说不是那么重要的事件，因此可以将触摸中断线程化"},"/note/Linux/野火Linux/2025-7-19-16-17-总结.html":{"title":"总结","content":"# 总结 1. 驱动设备模型（总线 设备 驱动） **角色**：设备管理的底层框架，通过**总线**（Bus）管理**设备**（Device）和**驱动**（Driver）。 **工作流程**： 设备注册时，总线将其加入设备链表。 驱动注册时，总线将其加入驱动链表。 总线通过 `match()` 函数匹配设备与驱动，匹配成功则调用驱动的 `probe()` 初始化设备710。 **典型代表**： 物理总线（如 I2C、USB）。 虚拟总线（如 `platform_bus`，用于管理片内外设）110。 2. **xbus（自定义总线）** **角色**：驱动设备模型的扩展，用于实现自定义总线（如专有硬件接口）。 **作用**： 通过 `bus_register()` 注册新总线类型（如 `xbus`），在 `/sys/bus` 下生成目录。 管理自定义设备的匹配规则（如通过名称匹配）49。 **代码示例**： ```c struct bus_type xbus { .name \"xbus\", .match xbus_match, // 自定义匹配函数 }; bus_register(&xbus); // 注册总线 ``` 3. **class（设备类）** **角色**：高层功能抽象，按设备功能（而非硬件连接）分类管理设备（如所有输入设备归为 `input` 类）。 **作用**： 在 `/sys/class` 下创建统一视图（如 `/sys/class/leds` 管理所有LED）。 支持 `udev` 自动创建设备节点（如 `/dev/led1`）68。 维度 驱动设备模型 xbus class : : : : 核心目标 硬件 驱动匹配与资源管理 扩展自定义总线规则 设备功能抽象与用户接口 SysFS位置 `/sys/bus`、`/sys/devices` `/sys/bus/xbus` `/sys/class` 用户空间影响 间接（需驱动支持） 间接 直接（生成 `/dev` 节点） 典型API `device_register()`, `driver_register()` `bus_register()` `class_create()`, `device_create()` ### 实际使用 通过kset建立的bus里面的一种为 >platform建立一个device和一个driver进行匹配 匹配实现以后建立cdev, 通过class实现自动注册"},"/note/Linux/野火Linux/2025-9-18-26-IIC驱动框架.html":{"title":"","content":"## IIC驱动框架简介 ## iic物理总线 SCL：时钟线，数据收发同步 SDA：数据线，具体数据 支持一主多从，各设备地址独立，标准模式传输速率为100kbit/s，快速模式为400kbit/s ##### 常见iic设备 eeprom 触摸芯片 温湿度传感器 mpu6050 ... #### 框架图 ![image 20200901213737995](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509181548628.png) I2C核心 提供I2C总线驱动和设备驱动的注册方法、注销方法、I2C通信硬件无关代码 I2C适配器 不同的I2C设备可能使用不同的配置, Algorithm里面记录实际的操作函数 I2C 总线驱动 主要包含I2C硬件体系结构中适配器(iic控制器)的控制，用于I2C 读写时序 主要数据结构：I2C_adapter、i2c_algorithm I2C设备驱动 通过I2C适配器与CPU交换数据 主要数据结构：i2c_driver和i2c_client #### 核心数据结构 ##### i2c_adapter include/linux/i2c.h I2C适配器, 抽象表示一个控制器 ```c struct i2c_adapter { \tstruct module *owner; \tunsigned int class;\t\t /* classes to allow probing for */ \tconst struct i2c_algorithm *algo; /* the algorithm to access the bus */ \tvoid *algo_data; \t... }; ``` 对应一个IIC控制器 相关API `int i2c_add_adapter(struct i2c_adapter *adapter)` 注册一个i2c_adapter ，系统分配编号 `int i2c_add_numbered_adapter(struct i2c_adapter *adapter)` 注册一个i2c_adapter ，自己指定编号 `void i2c_del_adapter(struct i2c_adapter * adap)` 注销一个i2c_adapter > imx默认已经实现了这部分功能, 所以可以不用处理这部分的工作 ##### i2c_algorithm 记录一系列的函数指针 include/linux/i2c.h ```c struct i2c_algorithm { \tint (*master_xfer)(struct i2c_adapter *adap, struct i2c_msg *msgs, \t\t\t int num); \tint (*smbus_xfer) (struct i2c_adapter *adap, u16 addr, \t\t\t unsigned short flags, char read_write, \t\t\t u8 command, int size, union i2c_smbus_data *data); \t/* To determine what the adapter supports */ \tu32 (*functionality) (struct i2c_adapter *); #if IS_ENABLED(CONFIG_I2C_SLAVE) \tint (*reg_slave)(struct i2c_client *client); \tint (*unreg_slave)(struct i2c_client *client); #endif }; ``` 对应一套具体的通信方法 master_xfer：产生I2C通信时序 ### 驱动 ##### struct i2c_client 表示一个I2C设备, 从设备树里面加载数据 include/linux/i2c.h ```c struct i2c_client { \tunsigned short flags;\t\t/* div., see below\t\t*/ \tunsigned short addr;\t\t/* chip address NOTE: 7bit\t设备地址 */ \tchar name[I2C_NAME_SIZE]; \tstruct i2c_adapter *adapter;\t/* the adapter we sit on\t*/ \tstruct device dev;\t\t/* the device structure\t\t*/ \tint init_irq;\t\t\t/* irq set at initialization\t*/ \tint irq;\t\t\t/* irq issued by device\t\t*/ \tstruct list_head detected; #if IS_ENABLED(CONFIG_I2C_SLAVE) \ti2c_slave_cb_t slave_cb;\t/* callback for slave mode\t*/ #endif }; ``` addr：i2c设备地址 > 设备树节点自动生成注册 ##### struct i2c_driver include/linux/i2c.h ```c struct i2c_driver { \tunsigned int class; \t/* Standard driver model interfaces */ \tint (*probe)(struct i2c_client *, const struct i2c_device_id *); \tint (*remove)(struct i2c_client *); \t... \tstruct device_driver driver; \tconst struct i2c_device_id *id_table; \t... } ``` id_table：i2c总线传统匹配方式 probe：i2c设备和i2c驱动匹配后，回调该函数指针 相关API `int i2c_add_driver (struct i2c_driver *driver)` 注册一个i2c_driver `void i2c_del_driver(struct i2c_driver *driver)` 注销一个i2c_driver #### I2C 总线驱动分析 ##### i2c总线注册 这部分代码是Linux内核自动处理的 drivers/i2c/i2c core base.c ```c static int __init i2c_init(void) { \tint retval; \t... // 注册一个总线 \tretval bus_register(&i2c_bus_type); \tif (retval) \t\treturn retval; \tis_registered true; \t... // 添加i2c设备 \tretval i2c_add_driver(&dummy_driver); \tif (retval) \t\tgoto class_err; \tif (IS_ENABLED(CONFIG_OF_DYNAMIC)) \t\tWARN_ON(of_reconfig_notifier_register(&i2c_of_notifier)); \tif (IS_ENABLED(CONFIG_ACPI)) \t\tWARN_ON(acpi_reconfig_notifier_register(&i2c_acpi_notifier)); \treturn 0; \t... } ``` ##### i2c总线定义 ```c struct bus_type i2c_bus_type { \t.name\t\t \"i2c\", \t.match\t\t i2c_device_match, \t.probe\t\t i2c_device_probe, \t.remove\t\t i2c_device_remove, \t.shutdown\t i2c_device_shutdown, }; ``` ##### i2c设备和i2c驱动匹配规则 处理不同的匹配规则 ```c static int i2c_device_match(struct device *dev, struct device_driver *drv) { \tstruct i2c_client\t*client i2c_verify_client(dev); \tstruct i2c_driver\t*driver; \t/* Attempt an OF style match */ \tif (i2c_of_match_device(drv >of_match_table, client)) \t\treturn 1; \t/* Then ACPI style match */ \tif (acpi_driver_match_device(dev, drv)) \t\treturn 1; \tdriver to_i2c_driver(drv); \t/* Finally an I2C match */ \tif (i2c_match_id(driver >id_table, client)) \t\treturn 1; \treturn 0; } ``` `of_driver_match_device`：设备树匹配方式 比较 I2C 设备节点的 compatible 属性和 of_device_id 中的 compatible 属性 `acpi_driver_match_device `： ACPI 匹配方式 `i2c_match_id`：i2c总线传统匹配方式 比较 I2C设备名字和 i2c驱动的id_table >name 字段是否相等 ##### 设备树节点 arch/arm/boot/dts/imx6ull.dtsi ```json i2c1: i2c@21a0000 { \t\t\t\t#address cells <1>; \t\t\t\t#size cells <0>; \t\t\t\tcompatible \"fsl,imx6ul i2c\", \"fsl,imx21 i2c\"; \t\t\t\treg <0x21a0000 0x4000>; \t\t\t\tinterrupts <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>; \t\t\t\tclocks <&clks IMX6UL_CLK_I2C1>; \t\t\t\tstatus \"disabled\"; \t\t\t}; ``` 实际匹配的位置在这里 ```c static int __init i2c_adap_imx_init(void) { \treturn platform_driver_register(&i2c_imx_driver); } ``` 注册一个平台驱动, 首先使用一个platform的封装 ##### i2c_imx_probe()函数 drivers/i2c/busses/i2c imx.c 这个是platform匹配以后得执行函数, 注册实际的i2cbus ```c static int i2c_imx_probe(struct platform_device *pdev) { \tconst struct of_device_id *of_id of_match_device(i2c_imx_dt_ids, \t\t\t\t\t\t\t &pdev >dev); \tstruct imx_i2c_struct *i2c_imx; \tstruct resource *res; \tstruct imxi2c_platform_data *pdata dev_get_platdata(&pdev >dev); \tvoid __iomem *base; \tint irq, ret; \tdma_addr_t phy_addr; \t... \tres platform_get_resource(pdev, IORESOURCE_MEM, 0); \tbase devm_ioremap_resource(&pdev >dev, res); // 地址的映射 \t \tphy_addr (dma_addr_t)res >start; // 记录物理地址 \ti2c_imx devm_kzalloc(&pdev >dev, sizeof(*i2c_imx), GFP_KERNEL); \t... \ti2c_imx >adapter.algo\t\t &i2c_imx_algo; // i2c_adapter里面的i2c_algorithm变量 \t... \ti2c_imx >base\t\t\t base; // 记录虚拟地址 \t... \tret i2c_add_numbered_adapter(&i2c_imx >adapter); // 注册一个设备号 \t... } ``` #### i2c_imx_algo结构体变量 drivers/i2c/busses/i2c imx.c ```c static const struct i2c_algorithm i2c_imx_algo { \t.master_xfer\t i2c_imx_xfer, // 产生i2c时序进行数据收发的 \t.functionality\t i2c_imx_func, }; ``` i2c_imx_xfer：iic通信函数 i2c_imx_func：查询iic通信协议类型 #### i2c_imx_func()函数 drivers/i2c/busses/i2c imx.c 返回支持的IIC格式 ```c static u32 i2c_imx_func(struct i2c_adapter *adapter) { \treturn I2C_FUNC_I2C I2C_FUNC_SMBUS_EMUL \t\t I2C_FUNC_SMBUS_READ_BLOCK_DATA; // 几种不同的通信协议 } ``` #### i2c_imx_xfer()函数 drivers/i2c/busses/i2c imx.c 实际的发送函数 ```c static int i2c_imx_xfer(struct i2c_adapter *adapter, \t\t\t\t\t\tstruct i2c_msg *msgs, int num) { \tunsigned int i, temp; \tint result; \tbool is_lastmsg false; \tbool enable_runtime_pm false; \tstruct imx_i2c_struct *i2c_imx i2c_get_adapdata(adapter); \t... // 启动信号 \tresult i2c_imx_start(i2c_imx); \t... \t\tfor (i 0; i < num; i++) { \t\tif (i num 1) \t\t\tis_lastmsg true; \t\tif (i) { \t\t\tdev_dbg(&i2c_imx >adapter.dev, \t\t\t\t\"<%s> repeated start\\n\", __func__); \t\t\ttemp imx_i2c_read_reg(i2c_imx, IMX_I2C_I2CR); \t\t\ttemp I2CR_RSTA; \t\t\timx_i2c_write_reg(temp, i2c_imx, IMX_I2C_I2CR); // 判断是不是忙碌 \t\t\tresult i2c_imx_bus_busy(i2c_imx, 1); \t\t\tif (result) \t\t\t\tgoto fail0; \t\t} \t... \t\tif (msgs[i].flags & I2C_M_RD) // 处理读 \t\t\tresult i2c_imx_read(i2c_imx, &msgs[i], is_lastmsg); \t\telse { \t\t\tif (i2c_imx >dma && msgs[i].len > DMA_THRESHOLD) \t\t\t\tresult i2c_imx_dma_write(i2c_imx, &msgs[i]); \t\t\telse \t\t\t\tresult i2c_imx_write(i2c_imx, &msgs[i]); \t\t} \t\tif (result) \t\t\tgoto fail0; \t} fail0: \t/* Stop I2C transfer */ \ti2c_imx_stop(i2c_imx); \t... } \t ``` ## IIC核心函数与“万能”驱动 #### i2c_add_adapter()函数 drivers/i2c/i2c core base.c 注册一个i2c适配器, 这部分是自动处理的 ```c int i2c_add_adapter(struct i2c_adapter *adapter) // 自动设置适配器编号 int i2c_add_numbered_adapter(struct i2c_adapter *adapter) ``` adapter >nr：适配器的编号 参数： adapter：i2c物理控制器对应的适配器 返回值： 成功：0 失败：负数 #### i2c_add_driver()宏 include/linux/i2c.h 注册一个i2c驱动, 实际是使用另一个函数 ```c #define i2c_add_driver(driver) i2c_register_driver(THIS_MODULE, driver) ``` #### i2c_register_driver()函数 drivers/i2c/i2c core base.c 注册一个i2c驱动 ````c int i2c_register_driver(struct module *owner, struct i2c_driver *driver) ```` 参数： owner： ：一般为 THIS_MODULE driver：要注册的 i2c_driver. 返回值： 成功：0 失败：负数 #### i2c_transfer()函数 drivers/i2c/i2c core base.c 收发iic消息 ```c int i2c_transfer(struct i2c_adapter *adap, struct i2c_msg *msgs, int num) ``` 参数： adap ：所使用的 I2C 适配器，i2c_client 会保存其对应的 i2c_adapter msgs：I2C 要发送的一个或多个消息 num ：消息数量，也就是 msgs 的数量 返回值： 成功：发送的msgs 的数量 失败：负数 #### i2c_msg结构体 include/uapi/linux/i2c.h 描述一个iic消息 ```c struct i2c_msg { \t__u16 addr;\t/* slave address\t\t\t*/ \t__u16 flags; #define I2C_M_RD\t\t0x0001\t/* read data, from slave to master */ \t\t\t\t\t/* I2C_M_RD is guaranteed to be 0x0001! */ #define I2C_M_TEN\t\t0x0010\t/* this is a ten bit chip address */ #define I2C_M_DMA_SAFE\t\t0x0200\t/* the buffer of this message is DMA safe */ \t\t\t\t\t/* makes only sense in kernelspace */ \t\t\t\t\t/* userspace buffers are copied anyway */ #define I2C_M_RECV_LEN\t\t0x0400\t/* length will be first received byte */ #define I2C_M_NO_RD_ACK\t\t0x0800\t/* if I2C_FUNC_PROTOCOL_MANGLING */ #define I2C_M_IGNORE_NAK\t0x1000\t/* if I2C_FUNC_PROTOCOL_MANGLING */ #define I2C_M_REV_DIR_ADDR\t0x2000\t/* if I2C_FUNC_PROTOCOL_MANGLING */ #define I2C_M_NOSTART\t\t0x4000\t/* if I2C_FUNC_NOSTART */ #define I2C_M_STOP\t\t0x8000\t/* if I2C_FUNC_PROTOCOL_MANGLING */ \t__u16 len;\t\t/* msg length\t\t\t\t*/ \t__u8 *buf;\t\t/* pointer to msg data\t\t\t*/ }; ``` addr：iic设备地址 flags：消息传输方向和特性。 I2C_M_RD：表示读取消息 0：表示发送消息 len：消息数据的长度 buf：消息缓冲区 #### i2c_master_send()函数 include/linux/i2c.h 发送一个i2c消息, 对之前的函数再次封装, i2c_add_driver的prob函数可以获取到i2c_client ```c static inline int i2c_master_send(const struct i2c_client *client, \t\t\t\t const char *buf, int count) { \treturn i2c_transfer_buffer_flags(client, (char *)buf, count, 0); }; ``` #### i2c_master_recv()函数 include/linux/i2c.h ```c static inline int i2c_master_recv(const struct i2c_client *client, \t\t\t\t char *buf, int count) { \treturn i2c_transfer_buffer_flags(client, buf, count, I2C_M_RD); }; ``` #### i2c_transfer_buffer_flags()函数 drivers/i2c/i2c core base.c 发送一个i2c消息 ```c int i2c_transfer_buffer_flags(const struct i2c_client *client, char *buf, \t\t\t int count, u16 flags) { \tint ret; \tstruct i2c_msg msg { \t\t.addr client >addr, \t\t.flags flags (client >flags & I2C_M_TEN), \t\t.len count, \t\t.buf buf, \t}; \tret i2c_transfer(client >adapter, &msg, 1); \t/* \t * If everything went ok (i.e. 1 msg transferred), return #bytes \t * transferred, else error code. \t */ \treturn (ret 1) ? count : ret; } ``` #### \"万能\"的i2c驱动 i2c dev.c分析 drivers/i2c/i2c dev.c 内核集成i2c_dev驱动模块，开机自动加载 为每个i2c_adapter生成一个设备文件，通过该设备文件间接使用IIC核心函数收发数据 注册i2c总线的通知函数，解决加载顺序问题 #### i2c_dev_init()函数 drivers/i2c/i2c dev.c ```c static int __init i2c_dev_init(void) { \tint res; \tprintk(KERN_INFO \"i2c /dev entries driver\\n\"); \t// 请求一个设备号, 89号, 最大的次设备号 \tres register_chrdev_region(MKDEV(I2C_MAJOR, 0), I2C_MINORS, \"i2c\"); \tif (res) \t\tgoto out; \t// 注册一个类 \ti2c_dev_class class_create(THIS_MODULE, \"i2c dev\"); \tif (IS_ERR(i2c_dev_class)) { \t\tres PTR_ERR(i2c_dev_class); \t\tgoto out_unreg_chrdev; \t} \t... // 注册一个通知 \tres bus_register_notifier(&i2c_bus_type, &i2cdev_notifier); \tif (res) \t\tgoto out_unreg_class; \t/* Bind to already existing adapters right away */ // 第二个参数就是处理添加事件的函数 \ti2c_for_each_dev(NULL, i2cdev_attach_adapter); \treturn 0; out_unreg_class: \tclass_destroy(i2c_dev_class); out_unreg_chrdev: \tunregister_chrdev_region(MKDEV(I2C_MAJOR, 0), I2C_MINORS); out: \tprintk(KERN_ERR \"%s: Driver Initialisation failed\\n\", __FILE__); \treturn res; } ``` #### i2cdev_notifier定义 ```c static struct notifier_block i2cdev_notifier { \t.notifier_call i2cdev_notifier_call, // 通知的回调函数 }; ``` #### i2cdev_notifier_call()函数 处理一下各种不同的通知 ```c static int i2cdev_notifier_call(struct notifier_block *nb, unsigned long action, \t\t\t void *data) { \tstruct device *dev data; \tswitch (action) { \tcase BUS_NOTIFY_ADD_DEVICE: // 处理添加设备 \t\treturn i2cdev_attach_adapter(dev, NULL); \tcase BUS_NOTIFY_DEL_DEVICE: // 处理删除设备 \t\treturn i2cdev_detach_adapter(dev, NULL); \t} \treturn 0; } ``` #### I2C_MAJOR include/linux/i2c dev.h ```c #define I2C_MAJOR\t89\t\t/* Device major number\t\t*/ ``` #### I2C_MINORS drivers/i2c/i2c dev.c ```c #define MINORBITS\t20 #define MINORMASK\t((1U << MINORBITS) 1) #define I2C_MINORS\tMINORMASK ``` #### i2c_for_each_dev()函数 drivers/i2c/i2c core base.c ```c int i2c_for_each_dev(void *data, int (*fn)(struct device *, void *)) { \tint res; \tmutex_lock(&core_lock); \tres bus_for_each_dev(&i2c_bus_type, NULL, data, fn); \tmutex_unlock(&core_lock); \treturn res; } ``` #### bus_for_each_dev()函数 drivers/base/bus.c ```c int bus_for_each_dev(struct bus_type *bus, struct device *start, \t\t void *data, int (*fn)(struct device *, void *)) { \tstruct klist_iter i; \tstruct device *dev; \tint error 0; \tif (!bus !bus >p) \t\treturn EINVAL; \tklist_iter_init_node(&bus >p >klist_devices, &i, \t\t\t (start ? &start >p >knode_bus : NULL)); \twhile (!error && (dev next_device(&i))) \t\terror fn(dev, data); \tklist_iter_exit(&i); \treturn error; } ``` #### i2cdev_attach_adapter()函数 drivers/i2c/i2c dev.c ```c static int i2cdev_attach_adapter(struct device *dev, void *dummy) { \tstruct i2c_adapter *adap; \tstruct i2c_dev *i2c_dev; \tint res; // 看一下是不是i2c适配器 \tif (dev >type ! &i2c_adapter_type) \t\treturn 0; // 获取i2c适配器 \tadap to_i2c_adapter(dev); \t// 分配内存以及记录adap \ti2c_dev get_free_i2c_dev(adap); \tif (IS_ERR(i2c_dev)) \t\treturn PTR_ERR(i2c_dev); \t// 添加一个cdev \tcdev_init(&i2c_dev >cdev, &i2cdev_fops); \ti2c_dev >cdev.owner THIS_MODULE; // 设定设备号 \tres cdev_add(&i2c_dev >cdev, MKDEV(I2C_MAJOR, adap >nr), 1); \tif (res) \t\tgoto error_cdev; \t/* register this i2c device with the driver core */ // 添加/dev下面的文件 \ti2c_dev >dev device_create(i2c_dev_class, &adap >dev, \t\t\t\t MKDEV(I2C_MAJOR, adap >nr), NULL, \t\t\t\t \"i2c %d\", adap >nr); \tif (IS_ERR(i2c_dev >dev)) { \t\tres PTR_ERR(i2c_dev >dev); \t\tgoto error; \t} \tpr_debug(\"i2c dev: adapter [%s] registered as minor %d\\n\", \t\t adap >name, adap >nr); \treturn 0; error: \tcdev_del(&i2c_dev >cdev); error_cdev: \tput_i2c_dev(i2c_dev); \treturn res; } ``` #### i2cdev_fops定义 drivers/i2c/i2c dev.c 实际使用的操作函数 ```c static const struct file_operations i2cdev_fops { \t.owner\t\t THIS_MODULE, \t.llseek\t\t no_llseek, \t.read\t\t i2cdev_read, \t.write\t\t i2cdev_write, \t.unlocked_ioctl\t i2cdev_ioctl, \t.compat_ioctl\t compat_i2cdev_ioctl, \t.open\t\t i2cdev_open, \t.release\t i2cdev_release, }; ``` #### i2cdev_open()函数 drivers/i2c/i2c dev.c ```c static int i2cdev_open(struct inode *inode, struct file *file) { // 获取一下文件的次设备号 \tunsigned int minor iminor(inode); \tstruct i2c_client *client; \tstruct i2c_adapter *adap; \t// 依据子设备号获取实际的i2c_adapter \tadap i2c_get_adapter(minor); \tif (!adap) \t\treturn ENODEV; \tclient kzalloc(sizeof(*client), GFP_KERNEL); \tif (!client) { \t\ti2c_put_adapter(adap); \t\treturn ENOMEM; \t} \tsnprintf(client >name, I2C_NAME_SIZE, \"i2c dev %d\", adap >nr); \tclient >adapter adap; \tfile >private_data client; // 记录在文件指针里面 \treturn 0; } ``` #### i2cdev_read()函数 drivers/i2c/i2c dev.c ```c static ssize_t i2cdev_read(struct file *file, char __user *buf, size_t count, \t\tloff_t *offset) { \tchar *tmp; \tint ret; \tstruct i2c_client *client file >private_data; \tif (count > 8192) \t\tcount 8192; \ttmp kmalloc(count, GFP_KERNEL); \tif (tmp NULL) \t\treturn ENOMEM; \tpr_debug(\"i2c dev: i2c %d reading %zu bytes.\\n\", \t\timinor(file_inode(file)), count); \tret i2c_master_recv(client, tmp, count); \tif (ret > 0) \t\tret copy_to_user(buf, tmp, count) ? EFAULT : ret; \tkfree(tmp); \treturn ret; } ``` #### i2cdev_write()函数 drivers/i2c/i2c dev.c ```c static ssize_t i2cdev_write(struct file *file, const char __user *buf, \t\tsize_t count, loff_t *offset) { \tint ret; \tchar *tmp; \tstruct i2c_client *client file >private_data; \tif (count > 8192) \t\tcount 8192; \ttmp memdup_user(buf, count); \tif (IS_ERR(tmp)) \t\treturn PTR_ERR(tmp); \tpr_debug(\"i2c dev: i2c %d writing %zu bytes.\\n\", \t\timinor(file_inode(file)), count); \tret i2c_master_send(client, tmp, count); \tkfree(tmp); \treturn ret; } ```"},"/note/Linux/野火Linux/2025-10-11-56-裸机汇编开发.html":{"title":"裸机汇编开发","content":"# 裸机汇编开发 ## 汇编指令 ### 基础指令 GNU汇编语法适用于所有的架构，并不是ARM独享的，GNU汇编由一系列的语句组成， 每行一条语句，每条语句有三个可选部分 ```c label：instruction @ comment ``` + **label** 即标号，表示地址位置，有些指令前面可能会有标号，这样就可以通过这个标号得到 指令的地址，标号也可以用来表示数据地址。注意label后面的“：”，任何以“：”结尾的标识 符都会被识别为一个标号 + **instruction** 即指令，也就是汇编指令或伪指令。 + @符号，表示后面的是注释 ### 段 用户可以使用.section伪操作来定义一个段，汇编系统预定义了一些段名： + .text 表示代码段 + .data 初始化的数据段。 + .bss 未初始化的数据段。 + .rodata 只读数据段。 `.section .testsection @定义一个testsetcion段` 汇编程序的默认入口标号是_start，不过我们也可以在链接脚本中使用ENTRY来指明其它 的入口点 ```assembly .global _start _start: ldr r0, 0x12 @r0 0x12 ``` ### 伪指令 + .byte 定义单字节数据，比如.byte 0x12。 + .short 定义双字节数据，比如.short 0x1234。 + .long 定义一个4字节数据，比如.long 0x12345678。 + .equ 赋值语句，格式为：.equ 变量名，表达式，比如.equ num, 0x12，表示num 0x1 2。 + .align 数据字节对齐，比如：.align 4表示4字节对齐。 + .end 表示源文件结束。 + .global 定义一个全局符号，格式为：.global symbol，比如：.global _start。 ### 函数 ```bash 函数名: 函数体 返回语句 ``` ```assembly /* SVC中断 */ SVC_Handler: ldr r0, SVC_Handler bx r0 ``` ### 常用指令 #### 处理器内部数据传输 ![image 20251012092932952](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510120929002.png) #### 存储器访问 ![image 20251012093914518](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510120939565.png) ```assembly LDR R0, 0X0209C004 @将寄存器地址0X0209C004加载到R0中，即R0 0X0209C004 LDR R1, [R0] @读取地址0X0209C004中的数据到R1寄存器中 ``` #### 栈 ![image 20251012094024647](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510120940686.png) #### 跳转 ![image 20251012094154703](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510120941754.png) #### 运算 ![image 20251012094220778](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510120942821.png) #### 逻辑运算 ![image 20251012094249892](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510120942937.png) ## 裸机运行 6ULL有内部128K(0x0090 0000~0x0091 FFFF)以及外部的DDR I.MX6U ALPHA开发板的DDR容量有两种：512MB和256MB，起 始地址都为0X80000000，只不过512MB的终止地址为0X9FFFFFFF，而 256MB容量的终止地 址为0X8FFFFFFF 所以使用的链接地址是0x8780 0000 也是UBoot的起始地址 > IM6ULL运行的时候不可以直接运行bin文件, 需要添加一个头部, 这个头部里面添加了DDR的初始化参数, 所以可以直接使用DDR进行代码的运行, 同时会自动进行bin文件的拷贝 ## 编译 ```bash arm linux gnueabihf gcc g c led.s o led.o arm linux gnueabihf ld Ttext 0X87800000 led.o o led.elf # “ O”选项指定以什么格式输出，后面的“binary”表示以二进制格式输出， # 选项“ S”表示不要复制源文件中的重定位信息和符号信息，“ g”表示不复制源文件中的调试信息。 arm linux gnueabihf objcopy O binary S g led.elf led.bin # 反汇编 arm linux gnueabihf objdump D led.elf > led.dis ``` 下载的时候需要添加头部以及烧录到对应的SD卡里面, 这里使用的方式是利用正点原子的软件 ## 使用C语言 1. 配置为SVC模式, 设置CPSR状态寄存器的0 4位10011, Supervisor是系统的权限等级 2. 设置SP指针, 可以使内部的RAM, 也可以使用DDR(0x8000 0000 0x9fff ffff) 3. 跳转C语言里面的函数"},"/note/Linux/野火Linux/2025-11-22-79-IIO驱动框架.html":{"title":"IIO","content":"# IIO IIO全称是Industrial I/O，翻译过来就是工业 I/O，大家不要看到“工业”两个字就觉得IIO是只用于工业领域的。大家一般在搜索IIO子系统的时候，会发现大多数讲的都是ADC，这是因为IIO就是为ADC类传感器准备的，当然了DAC也是可以的 之前使得的传感器在获取到数据以后, 数据的传输是没有一个规定的格式的, 不同的厂商获取的数据格式是不同的, 所以为了解决这个问题提出IIO子系统 ## 使用 ### 使能 ``` > Device Drivers > Industrial I/O support (IIO [ y]) > [*]Enable buffer support within IIO //选中 > <*>Industrial I/O buffering based on kfifo //选中 ``` ### 使用 加载驱动以后会出现在`/sys/bus/iio/devices`文件夹里面, 对应一个文件夹, 里面的文件是这个驱动端的各种属性, 文件的名字是按照特定格式的, 在读取的时候实际获取的是一个字符串 ### 编写 + 使用的是也是的IIC之类的驱动框架, 在里面为不同的设备的属性创建自己使用的的通道, 记录在`struct iio_chan_spec `数组里面 + 初始化`struct iio_info`里面的函数, 用于实际的读写, 在这个回调函数里面判断通道来决定返回值, 读取函数return的值是返回的数据的解释方式 + 使用上面的两个结构体初始化使用`devm_iio_device_alloc`申请的`iio_dev`, 进一步使用`iio_device_register`进行注册 ## IIO驱动 ### iio_dev #### 数据结构 ``` c /** * struct iio_dev industrial I/O device * @id:\t\t\t[INTERN] used to identify device internally * @modes:\t\t[DRIVER] operating modes supported by device * @currentmode:\t[DRIVER] current operating mode * @dev:\t\t[DRIVER] device structure, should be assigned a parent *\t\t\tand owner * @event_interface:\t[INTERN] event chrdevs associated with interrupt lines * @buffer:\t\t[DRIVER] any buffer present * @buffer_list:\t[INTERN] list of all buffers currently attached * @scan_bytes:\t\t[INTERN] num bytes captured to be fed to buffer demux * @mlock:\t\t[INTERN] lock used to prevent simultaneous device state *\t\t\tchanges * @available_scan_masks: [DRIVER] optional array of allowed bitmasks * @masklength:\t\t[INTERN] the length of the mask established from *\t\t\tchannels * @active_scan_mask:\t[INTERN] union of all scan masks requested by buffers * @scan_timestamp:\t[INTERN] set if any buffers have requested timestamp * @scan_index_timestamp:[INTERN] cache of the index to the timestamp * @trig:\t\t[INTERN] current device trigger (buffer modes) * @pollfunc:\t\t[DRIVER] function run on trigger being received * @channels:\t\t[DRIVER] channel specification structure table * @num_channels:\t[DRIVER] number of channels specified in @channels. * @channel_attr_list:\t[INTERN] keep track of automatically created channel *\t\t\tattributes * @chan_attr_group:\t[INTERN] group for all attrs in base directory * @name:\t\t[DRIVER] name of the device. * @info:\t\t[DRIVER] callbacks and constant info from driver * @info_exist_lock:\t[INTERN] lock to prevent use during removal * @setup_ops:\t\t[DRIVER] callbacks to call before and after buffer *\t\t\tenable/disable * @chrdev:\t\t[INTERN] associated character device * @groups:\t\t[INTERN] attribute groups * @groupcounter:\t[INTERN] index of next attribute group * @flags:\t\t[INTERN] file ops related flags including busy flag. * @debugfs_dentry:\t[INTERN] device specific debugfs dentry. * @cached_reg_addr:\t[INTERN] cached register address for debugfs reads. */ struct iio_dev { \tint\t\t\t\tid; \tint\t\t\t\tmodes; // 设备支持的模式 \tint\t\t\t\tcurrentmode; // 当前的模式 \tstruct device\t\t\tdev; \tstruct iio_event_interface\t*event_interface; \tstruct iio_buffer\t\t*buffer; // 缓冲区 \tstruct list_head\t\tbuffer_list; \tint\t\t\t\tscan_bytes; // 获取到给缓冲区的数据个数 \tstruct mutex\t\t\tmlock; \t// 可选的扫描位掩码，使用触发缓冲区的时候可以通过设 \t// 置掩码来确定使能哪些通道，使能以后的通道会将捕获到的数据发送到 IIO缓冲区 \tconst unsigned long\t\t*available_scan_masks; \tunsigned\t\t\tmasklength; // 为缓冲区已经开启的通道掩码。只有这些使能了的通道数据 \t// 才能被发送到缓冲区 \tconst unsigned long\t\t*active_scan_mask; // 为扫描时间戳，如果使能以后会将捕获时间戳放到缓冲区里面 \tbool\t\t\t\tscan_timestamp; \tunsigned\t\t\tscan_index_timestamp; // 当前触发器，当使用缓冲模式的时候 \tstruct iio_trigger\t\t*trig; \tstruct iio_poll_func\t\t*pollfunc; \t// IIO 设备通道, 表示设备的测量通道 \tstruct iio_chan_spec const\t*channels; \tint\t\t\t\tnum_channels; // 通道的数量 \tstruct list_head\t\tchannel_attr_list; \tstruct attribute_group\t\tchan_attr_group; \tconst char\t\t\t*name; // 名字 // 里面有很多函数，需要驱动开发人员编 \t// 写，非常重要！我们从用户空间读取 IIO设备内部数据， // 最终调用的就是 iio_info里面的函数 \tconst struct iio_info\t\t*info; \tstruct mutex\t\t\tinfo_exist_lock; // 一些回调函数，在使能或禁用缓冲区的时候会调用 // 如果未指定的话就默认使用iio_triggered_buffer_setup_ops` \tconst struct iio_buffer_setup_ops\t*setup_ops; \tstruct cdev\t\t\tchrdev; #define IIO_MAX_GROUPS 6 \tconst struct attribute_group\t*groups[IIO_MAX_GROUPS + 1]; \tint\t\t\t\tgroupcounter; \tunsigned long\t\t\tflags; #if defined(CONFIG_DEBUG_FS) \tstruct dentry\t\t\t*debugfs_dentry; \tunsigned\t\t\tcached_reg_addr; #endif }; ``` ![image 20251123221916970](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251123221916970.png) ```c struct iio_buffer_setup_ops { int (*preenable)(struct iio_dev *); /* 缓冲区使能之前调用 */ int (*postenable)(struct iio_dev *); /* 缓冲区使能之后调用 */ int (*predisable)(struct iio_dev *); /* 缓冲区禁用之前调用 */ int (*postdisable)(struct iio_dev *); /* 缓冲区禁用之后调用 */ bool (*validate_scan_mask)(struct iio_dev *indio_dev, const unsigned long *scan_mask); /* 检查扫描掩码是否有效 */ }; ``` #### API ###### 申请 ```c struct iio_dev *iio_device_alloc(int sizeof_priv); void iio_device_free(struct iio_dev *indio_dev); ``` + **sizeof_priv**私有数据内存空间大小，一般我们会将自己定义的设备结构体变量作为 iio_dev 的私有数据，这样可以直接通过 iio_device_alloc 函数同时完成 iio_dev 和设备结构体变量的内存申请。申请成功以后使用`iio_priv`函数来得到自定义的设备结构体变量首地址 ```c struct icm20608_dev *dev; struct iio_dev *indio_dev; /* 1、申请 iio_dev内存 */ indio_dev iio_device_alloc(sizeof(*dev)); if (!indio_dev) \t\treturn ENOMEM; /* 2、获取设备结构体变量地址 */ dev iio_priv(indio_dev); ``` ###### 注册 ```c int iio_device_register(struct iio_dev *indio_dev); int iio_device_register(struct iio_dev *indio_dev) ``` ### iio_info操作函数 ```c /** * struct iio_info constant information about device * @driver_module:\tmodule structure used to ensure correct *\t\t\townership of chrdevs etc * @event_attrs:\tevent control attributes * @attrs:\t\tgeneral purpose device attributes * @read_raw:\t\tfunction to request a value from the device. *\t\t\tmask specifies which value. Note 0 means a reading of *\t\t\tthe channel in question. Return value will specify the *\t\t\ttype of value returned by the device. val and val2 will *\t\t\tcontain the elements making up the returned value. * @read_raw_multi:\tfunction to return values from the device. *\t\t\tmask specifies which value. Note 0 means a reading of *\t\t\tthe channel in question. Return value will specify the *\t\t\ttype of value returned by the device. vals pointer *\t\t\tcontain the elements making up the returned value. *\t\t\tmax_len specifies maximum number of elements *\t\t\tvals pointer can contain. val_len is used to return *\t\t\tlength of valid elements in vals. * @write_raw:\t\tfunction to write a value to the device. *\t\t\tParameters are the same as for read_raw. * @write_raw_get_fmt:\tcallback function to query the expected *\t\t\tformat/precision. If not set by the driver, write_raw *\t\t\treturns IIO_VAL_INT_PLUS_MICRO. * @read_event_config:\tfind out if the event is enabled. * @write_event_config:\tset if the event is enabled. * @read_event_value:\tread a configuration value associated with the event. * @write_event_value:\twrite a configuration value for the event. * @validate_trigger:\tfunction to validate the trigger when the *\t\t\tcurrent trigger gets changed. * @update_scan_mode:\tfunction to configure device and scan buffer when *\t\t\tchannels have changed * @debugfs_reg_access:\tfunction to read or write register value of device * @of_xlate:\t\tfunction pointer to obtain channel specifier index. *\t\t\tWhen #iio cells is greater than '0', the driver could *\t\t\tprovide a custom of_xlate function that reads the *\t\t\t*args* and returns the appropriate index in registered *\t\t\tIIO channels array. * @hwfifo_set_watermark: function pointer to set the current hardware *\t\t\tfifo watermark level; see hwfifo_* entries in *\t\t\tDocumentation/ABI/testing/sysfs bus iio for details on *\t\t\thow the hardware fifo operates * @hwfifo_flush_to_buffer: function pointer to flush the samples stored *\t\t\tin the hardware fifo to the device buffer. The driver *\t\t\tshould not flush more than count samples. The function *\t\t\tmust return the number of samples flushed, 0 if no *\t\t\tsamples were flushed or a negative integer if no samples *\t\t\twere flushed and there was an error. **/ struct iio_info { \tstruct module\t\t\t*driver_module; \tstruct attribute_group\t\t*event_attrs; \tconst struct attribute_group\t*attrs; \t// 读取原始数据, 最终的操作函数 // indio_dev: 需要控制的设备 // chan: 控制的通道 // val，val2: read_raw这两个就是应用程序从内核空间读取到数 \t// \t\t\t\t\t 据，一般就是传感器指定通道值，或者传感器的量程、分辨率等 // \t\t\t\t\t val和val2共同组成具体值，val是整数部分，val2是小数部分。但是 \t// \t\t\t\t\t val2也是对具体的小数部分扩大N倍后的整数值，因为不能直接从内核 //\t\t\t\t\t 向应用程序返回一个小数值, 扩大的倍数我们不能随便设置，而是要使用 Linux定义的倍数 // mask: 掩码，用于指定我们读取的是什么数据，比如 ICM20608这样的传感器，他既有原 \t// \t\t\t 始的测量数据，比如 X,Y,Z 轴的陀螺仪、加速度计等，也有测量范围值，或者分辨率 \tint (*read_raw)(struct iio_dev *indio_dev, \t\t\tstruct iio_chan_spec const *chan, \t\t\tint *val, \t\t\tint *val2, \t\t\tlong mask); \tint (*read_raw_multi)(struct iio_dev *indio_dev, \t\t\tstruct iio_chan_spec const *chan, \t\t\tint max_len, \t\t\tint *vals, \t\t\tint *val_len, \t\t\tlong mask); \t// 写原始数据, 一般是用于配置的时候 // val，val2: 程序向设备写入的数据 \tint (*write_raw)(struct iio_dev *indio_dev, \t\t\t struct iio_chan_spec const *chan, \t\t\t int val, \t\t\t int val2, \t\t\t long mask); \t// 用于设置用户空间向内核空间写入的数据格式, 决定了 wtite_raw // 函数中 val 和 val2 的意义, 设置实际使用的 IIO_VAL_XXX \tint (*write_raw_get_fmt)(struct iio_dev *indio_dev, \t\t\t struct iio_chan_spec const *chan, \t\t\t long mask); ... }; ``` ![image 20251123225208106](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251123225208106.png) > val1以及val2可以使用的模式 ### iio_chan_spec通道 IIO的核心就是通道，一个传感器可能有多路数据，比如一个ADC芯片支持 8路采集，那么这个ADC就有8个通道 ```c /** * struct iio_chan_spec specification of a single channel * @type:\t\tWhat type of measurement is the channel making. * @channel:\t\tWhat number do we wish to assign the channel. * @channel2:\t\tIf there is a second number for a differential *\t\t\tchannel then this is it. If modified is set then the *\t\t\tvalue here specifies the modifier. * @address:\t\tDriver specific identifier. * @scan_index:\t\tMonotonic index to give ordering in scans when read *\t\t\tfrom a buffer. * @scan_type:\t\tSign:\t\t's' or 'u' to specify signed or unsigned *\t\t\trealbits:\tNumber of valid bits of data *\t\t\tstorage_bits:\tRealbits + padding *\t\t\tshift:\t\tShift right by this before masking out *\t\t\t\t\trealbits. *\t\t\tendianness:\tlittle or big endian *\t\t\trepeat:\t\tNumber of times real/storage bits *\t\t\t\t\trepeats. When the repeat element is *\t\t\t\t\tmore than 1, then the type element in *\t\t\t\t\tsysfs will show a repeat value. *\t\t\t\t\tOtherwise, the number of repetitions is *\t\t\t\t\tomitted. * @info_mask_separate: What information is to be exported that is specific to *\t\t\tthis channel. * @info_mask_shared_by_type: What information is to be exported that is shared *\t\t\tby all channels of the same type. * @info_mask_shared_by_dir: What information is to be exported that is shared *\t\t\tby all channels of the same direction. * @info_mask_shared_by_all: What information is to be exported that is shared *\t\t\tby all channels. * @event_spec:\t\tArray of events which should be registered for this *\t\t\tchannel. * @num_event_specs:\tSize of the event_spec array. * @ext_info:\t\tArray of extended info attributes for this channel. *\t\t\tThe array is NULL terminated, the last element should *\t\t\thave its name field set to NULL. * @extend_name:\tAllows labeling of channel attributes with an *\t\t\tinformative name. Note this has no effect codes etc, *\t\t\tunlike modifiers. * @datasheet_name:\tA name used in in kernel mapping of channels. It should *\t\t\tcorrespond to the first name that the channel is referred *\t\t\tto by in the datasheet (e.g. IND), or the nearest *\t\t\tpossible compound name (e.g. IND INC). * @modified:\t\tDoes a modifier apply to this channel. What these are *\t\t\tdepends on the channel type. Modifier is set in *\t\t\tchannel2. Examples are IIO_MOD_X for axial sensors about *\t\t\tthe 'x' axis. * @indexed:\t\tSpecify the channel has a numerical index. If not, *\t\t\tthe channel index number will be suppressed for sysfs *\t\t\tattributes but not for event codes. * @output:\t\tChannel is output. * @differential:\tChannel is differential. */ struct iio_chan_spec { \tenum iio_chan_type\ttype; // 通道类型 \tint\t\t\tchannel; // indexed为1的时候, 记录通道的索引 \tint\t\t\tchannel2;// modified为1的时候，channel2为通道修饰符 \tunsigned long\t\taddress; // 可以自定义 \tint\t\t\tscan_index; // 使用触发缓冲区的时候, 记录索引 \tstruct { \t\tchar\tsign;// ‘u’表示数据为无符号类型，为‘s’的话为有符号类型 \t\tu8\trealbits; // 数据真实的有效位数 \t\tu8\tstoragebits; // 存储位数，有效位数+填充位 \t\tu8\tshift; // 右移位数，也就是存储位数和有效位数不一致的时候 \t\tu8\trepeat; // 实际或存储位的重复数量 // 数据的大小端模式，可设置为IIO_CPU、IIO_BE(大端)或IIO_LE(小端) \t\tenum iio_endian endianness; \t} scan_type; // 扫描数据在缓冲区中的存储格式 // 标记某些属性专属于此通道 \tlong\t\t\tinfo_mask_separate; // 标记导出的信息由相同类型的通道共享 // 例: 使能 IIO_CHAN_INFO_SCALE这个属性，表示这 \t// 三个通道的分辨率是共用的，这样在 sysfs下就会只生成一个描述分辨率的文件，这三个通道都 \t// 可以使用这一个分辨率文件 \tlong\t\t\tinfo_mask_shared_by_type; // 标记某些导出的信息由相同方向的通道共享 \tlong\t\t\tinfo_mask_shared_by_dir; // 表设计某些信息所有的通道共享 \tlong\t\t\tinfo_mask_shared_by_all; \tconst struct iio_event_spec *event_spec; \tunsigned int\t\tnum_event_specs; \tconst struct iio_chan_spec_ext_info *ext_info; \tconst char\t\t*extend_name; \tconst char\t\t*datasheet_name; // 为1的时候，channel2为通道修饰符 \tunsigned\t\tmodified:1; // 为1的时候，channel为通道索引 \tunsigned\t\tindexed:1; \tunsigned\t\toutput:1; // 表示为输出通道 \tunsigned\t\tdifferential:1; // 表示为差分通道 }; ``` #### 类型 ```c enum iio_chan_type { \tIIO_VOLTAGE, /* 14 IIO_VOLTAGE, /* 电压类型 */ \tIIO_CURRENT, /* 15 IIO_CURRENT, /* 电流类型 */ \tIIO_POWER, /* 16 IIO_POWER, /* 功率类型 */ \tIIO_ACCEL, /* 17 IIO_ACCEL, /* 加速度类型 */ \tIIO_ANGL_VEL, /* 18 IIO_ANGL_VEL, /* 角度类型(陀螺仪) */ \tIIO_MAGN, /* 电磁类型(磁力计) */ \tIIO_LIGHT, /* 灯光类型 */ \tIIO_INTENSITY, /* 强度类型(光强传感器) */ \tIIO_PROXIMITY, /* 接近类型(接近传感器) */ \tIIO_TEMP, /* 温度类型 */ \tIIO_INCLI, /* 倾角类型(倾角测量传感器) */ \tIIO_ROT, /* 旋转角度类型 */ \tIIO_ANGL, /* 转动角度类型(电机旋转角度测量传感器) */ \tIIO_TIMESTAMP, /* 时间戳类型 */ \tIIO_CAPACITANCE, /* 电容类型 */ \tIIO_ALTVOLTAGE, /* 频率类型 */ \tIIO_CCT, /* 笔者暂时未知的类型 */ \tIIO_PRESSURE, /* 压力类型 */ \tIIO_HUMIDITYRELATIVE, /* 湿度类型 */ \tIIO_ACTIVITY, /* 活动类型(计步传感器) */ \tIIO_STEPS, /* 步数类型 */ \tIIO_ENERGY, /* 能量类型(卡路里) */ \tIIO_DISTANCE, /* 距离类型 */ \tIIO_VELOCITY, /* 速度类型 */ \tIIO_LIGHT, /* 灯光类型 */ \tIIO_INTENSITY, /* 强度类型(光强传感器) */ \tIIO_PROXIMITY, /* 接近类型(接近传感器) */ \tIIO_TEMP, /* 温度类型 */ \tIIO_INCLI, /* 倾角类型(倾角测量传感器) */ \tIIO_ROT, /* 旋转角度类型 */ \tIIO_ANGL, /* 转动角度类型(电机旋转角度测量传感器) */ \tIIO_TIMESTAMP, /* 时间戳类型 */ \tIIO_CAPACITANCE, /* 电容类型 */ \tIIO_ALTVOLTAGE, /* 频率类型 */ \tIIO_CCT, /* 笔者暂时未知的类型 */ \tIIO_PRESSURE, /* 压力类型 */ \tIIO_HUMIDITYRELATIVE, /* 湿度类型 */ \tIIO_ACTIVITY, /* 活动类型(计步传感器) */ \tIIO_STEPS, /* 步数类型 */ \tIIO_ENERGY, /* 能量类型(卡路里) */ \tIIO_DISTANCE, /* 距离类型 */ \tIIO_VELOCITY, /* 速度类型 */ }; ``` #### 修饰符 主要是影响 sysfs下的通道文件名字 ```c enum iio_modifier { \tIIO_NO_MOD, \tIIO_MOD_X, \tIIO_MOD_Y, \tIIO_MOD_Z, \tIIO_MOD_X_AND_Y, \tIIO_MOD_X_AND_Z, \tIIO_MOD_Y_AND_Z, \tIIO_MOD_X_AND_Y_AND_Z, \tIIO_MOD_X_OR_Y, \tIIO_MOD_X_OR_Z, \tIIO_MOD_Y_OR_Z, \tIIO_MOD_X_OR_Y_OR_Z, \tIIO_MOD_LIGHT_BOTH, \tIIO_MOD_LIGHT_IR, \tIIO_MOD_ROOT_SUM_SQUARED_X_Y, \tIIO_MOD_SUM_SQUARED_X_Y_Z, \tIIO_MOD_LIGHT_CLEAR, \tIIO_MOD_LIGHT_RED, \tIIO_MOD_LIGHT_GREEN, \tIIO_MOD_LIGHT_BLUE, \tIIO_MOD_QUATERNION, \tIIO_MOD_TEMP_AMBIENT, \tIIO_MOD_TEMP_OBJECT, \tIIO_MOD_NORTH_MAGN, \tIIO_MOD_NORTH_TRUE, \tIIO_MOD_NORTH_MAGN_TILT_COMP, \tIIO_MOD_NORTH_TRUE_TILT_COMP, \tIIO_MOD_RUNNING, \tIIO_MOD_JOGGING, \tIIO_MOD_WALKING, \tIIO_MOD_STILL, \tIIO_MOD_ROOT_SUM_SQUARED_X_Y_Z, }; ``` #### 专属属性 ```c \tIIO_CHAN_INFO_RAW 0, // 原始数据 \tIIO_CHAN_INFO_PROCESSED, \tIIO_CHAN_INFO_SCALE, // 分辨率 \tIIO_CHAN_INFO_OFFSET, \tIIO_CHAN_INFO_CALIBSCALE, \tIIO_CHAN_INFO_CALIBBIAS, // 校准 \tIIO_CHAN_INFO_PEAK, \tIIO_CHAN_INFO_PEAK_SCALE, \tIIO_CHAN_INFO_QUADRATURE_CORRECTION_RAW, \tIIO_CHAN_INFO_AVERAGE_RAW, \tIIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY, \tIIO_CHAN_INFO_SAMP_FREQ, \tIIO_CHAN_INFO_FREQUENCY, \tIIO_CHAN_INFO_PHASE, \tIIO_CHAN_INFO_HARDWAREGAIN, \tIIO_CHAN_INFO_HYSTERESIS, \tIIO_CHAN_INFO_INT_TIME, \tIIO_CHAN_INFO_ENABLE, \tIIO_CHAN_INFO_CALIBHEIGHT, \tIIO_CHAN_INFO_CALIBWEIGHT, \tIIO_CHAN_INFO_DEBOUNCE_COUNT, \tIIO_CHAN_INFO_DEBOUNCE_TIME, }; ``` ## 编写驱动 ### IIC驱动 ```c /*************************************************************** Copyright © ALIENTEK Co., Ltd. 1998 2029. All rights reserved. 文件名\t\t: ap3216c.c 作者\t \t: 正点原子Linux团队 版本\t \t: V1.0 描述\t \t: AP3216C驱动程序 其他\t \t: 无 论坛 \t \t: www.openedv.com 日志\t \t: 初版V1.0 2021/03/19 正点原子Linux团队创建 \t\t\t V1.1 2021/03/19 \t\t\t 使用regmap来访问寄存器\t ***************************************************************/ #include <linux/types.h> #include <linux/kernel.h> #include <linux/delay.h> #include <linux/ide.h> #include <linux/init.h> #include <linux/module.h> #include <linux/errno.h> #include <linux/gpio.h> #include <linux/cdev.h> #include <linux/device.h> #include <linux/of_gpio.h> #include <linux/semaphore.h> #include <linux/timer.h> #include <linux/i2c.h> #include <asm/mach/map.h> #include <asm/uaccess.h> #include <asm/io.h> #include <linux/regmap.h> #include <linux/iio/iio.h> #include <linux/iio/sysfs.h> #include <linux/iio/trigger_consumer.h> #include <linux/iio/buffer.h> #include <linux/iio/triggered_buffer.h> #include <linux/unaligned/be_byteshift.h> #include <linux/iio/trigger.h> #include \"ap3216creg.h\" #define AP3216C_NAME\t\t\t\"ap3216c\" /* * AP3216C的扫描元素，1路ALS(环境关)，1路PS(距离传感器)，1路IR */ enum inv_icm20608_scan { \tAP3216C_ALS, \tAP3216C_PS, \tAP3216C_IR, }; /* * ap3216c环境光传感器分辨率,扩大1000000倍, * 量程依次为0～20661，0～5162，0～1291，0～323。单位：lux */ static const int als_scale_ap3216c[] {315000, 78800, 19700, 4900}; struct ap3216c_dev { \tstruct i2c_client *client;\t/* i2c 设备 */ \tstruct regmap *regmap;\t\t\t\t/* regmap */ \tstruct regmap_config regmap_config;\t \tstruct mutex lock; \tstruct iio_trigger *trig; }; /* * ap3216c通道，1路ALS(环境关)，1路PS(距离传感器)，1路IR */ static const struct iio_chan_spec ap3216c_channels[] { \t/* ALS通道 */ \t{ \t\t.type IIO_INTENSITY, \t\t.modified 1, \t\t.channel2 IIO_MOD_LIGHT_BOTH, \t\t.address AP3216C_ALSDATALOW, \t\t.info_mask_separate BIT(IIO_CHAN_INFO_RAW) \t\t\tBIT(IIO_CHAN_INFO_SCALE), \t\t.scan_index AP3216C_ALS, \t\t.scan_type { \t\t\t.sign 'u', \t\t\t.realbits 16, \t\t\t.storagebits 16, \t\t\t.endianness IIO_LE, \t\t}, \t}, \t/* PS通道 */ \t{ \t\t.type IIO_PROXIMITY, \t\t.address AP3216C_PSDATALOW, \t\t.info_mask_separate BIT(IIO_CHAN_INFO_RAW), \t\t.scan_index AP3216C_PS, \t\t.scan_type { \t\t\t.sign 'u', \t\t\t.realbits 10, \t\t\t.storagebits 16, \t\t\t.endianness IIO_LE, \t\t}, \t}, \t/* IR通道 */ \t{ \t\t.type IIO_INTENSITY, \t\t.modified 1, \t\t.channel2 IIO_MOD_LIGHT_IR, \t\t.address AP3216C_IRDATALOW, \t\t.info_mask_separate BIT(IIO_CHAN_INFO_RAW), \t\t.scan_index AP3216C_IR, \t\t.scan_type { \t\t\t.sign 'u', \t\t\t.realbits 10, \t\t\t.storagebits 16, \t\t\t.endianness IIO_LE, \t\t}, \t}, }; /* * 扫描掩码，两种情况，全启动0X111，或者都不启动0X0 */ static const unsigned long ap3216c_scan_masks[] { \tBIT(AP3216C_ALS) \t BIT(AP3216C_PS) \t BIT(AP3216C_IR), \t0, }; /* * @description\t: 读取ap3216c指定寄存器值，读取一个寄存器 * @param dev: ap3216c设备 * @param reg: 要读取的寄存器 * @return \t : 读取到的寄存器值 */ static unsigned char ap3216c_read_reg(struct ap3216c_dev *dev, u8 reg) { \tu8 ret; \tunsigned int data; \tret regmap_read(dev >regmap, reg, &data); \treturn (u8)data; } /* * @description\t: 向ap3216c指定寄存器写入指定的值，写一个寄存器 * @param dev: ap3216c设备 * @param reg: 要写的寄存器 * @param data: 要写入的值 * @return : 无 */ static void ap3216c_write_reg(struct ap3216c_dev *dev, u8 reg, u8 data) { \tregmap_write(dev >regmap, reg, data); } /* * @description\t\t: 初始化AP3216C * @param dev \t: 要初始化的ap3216c设备 * @return \t\t\t: 0 成功;其他 失败 */ static int ap3216c_reginit(struct ap3216c_dev *dev) { \t/* 初始化AP3216C */ \tap3216c_write_reg(dev, AP3216C_SYSTEMCONG, 0x04);\t\t/* 复位AP3216C \t\t\t*/ \tmdelay(50);\t\t\t\t\t\t\t\t\t\t\t\t/* AP3216C复位最少10ms \t*/ \tap3216c_write_reg(dev, AP3216C_SYSTEMCONG, 0X03);\t\t/* 开启ALS、PS+IR \t\t*/ \tap3216c_write_reg(dev, AP3216C_ALSCONFIG, 0X00);\t\t/* ALS单次转换触发，量程为0～20661 lux */ \tap3216c_write_reg(dev, AP3216C_PSLEDCONFIG, 0X13);\t\t/* IR LED 1脉冲，驱动电流100%*/ \treturn 0; } /* * @description \t: 读取AP3216C传感器数 * @param dev\t: ap3216c设备 * @param reg \t: 要读取的通道寄存器首地址。 * @param chann2 : 需要读取的通道，比如ALS，IR。 * @param val \t: 保存读取到的值。 * @return\t\t\t: 0，成功；其他值，错误 */ static int ap3216c_read_alsir_data(struct ap3216c_dev *dev, int reg, \t\t\t\t int chann2, int *val) { \tint ret 0; \tunsigned char data[2]; \tswitch (chann2) { \tcase IIO_MOD_LIGHT_BOTH:\t/* 读取ALS数据 */ \t\tret regmap_bulk_read(dev >regmap, reg, data, 2); \t\t*val ((int)data[1] << 8) data[0]; \t\tbreak; \tcase IIO_MOD_LIGHT_IR:\t\t/* 读取IR数据 */ \t\tret regmap_bulk_read(dev >regmap, reg, data, 2); \t\t*val ((int)data[1] << 2) (data[0] & 0X03); \t\tbreak; \tdefault: \t\tret EINVAL; \t\tbreak; \t} \tif (ret) { \t\treturn EINVAL; \t} \t\t \treturn IIO_VAL_INT; } /* * @description \t: 设置AP3216C的ALS量程(分辨率) * @param dev\t: ap3216c设备 * @param val \t: 量程(分辨率值)。 * @param chann2 : 需要设置的通道。 * @return\t\t\t: 0，成功；其他值，错误 */ static int ap3216c_write_als_scale(struct ap3216c_dev *dev, int chann2, int val) { \tint ret 0, i;\t \tu8 d; \tswitch (chann2) { \tcase IIO_MOD_LIGHT_BOTH:\t/* 设置ALS分辨率 */ \t\tfor (i 0; i < ARRAY_SIZE(als_scale_ap3216c); ++i) { \t\t\tif (als_scale_ap3216c[i] val) { \t\t\t\td (i << 4); \t\t\t\tret regmap_write(dev >regmap, AP3216C_ALSCONFIG, d); \t\t\t} \t\t} \t\tbreak; \tdefault: \t\tret EINVAL; \t\tbreak; \t} \t\t \treturn ret; } /* * @description \t: 读函数，当读取sysfs中的文件的时候最终此函数会执行，此函数 * \t\t\t\t\t：里面会从传感器里面读取各种数据，然后上传给应用。 * @param indio_dev\t: iio_dev * @param chan \t: 通道 * @param val \t\t: 读取的值，如果是小数值的话，val是整数部分。 * @param val2 \t: 读取的值，如果是小数值的话，val2是小数部分。 * @return\t\t\t\t: 0，成功；其他值，错误 */ static int ap3216c_read_raw(struct iio_dev *indio_dev, \t\t\t struct iio_chan_spec const *chan, \t\t\t int *val, int *val2, long mask) { \tint ret 0; \tunsigned char data[2]; \tunsigned char regdata 0; \tstruct ap3216c_dev *dev iio_priv(indio_dev); \tswitch (mask) { \tcase IIO_CHAN_INFO_RAW:\t\t\t\t\t\t\t\t/* 读取ICM20608加速度计、陀螺仪、温度传感器原始值 */ \t\tmutex_lock(&dev >lock);\t\t\t\t\t\t\t\t/* 上锁 \t\t\t*/ \t\tswitch (chan >type) { \t\tcase IIO_INTENSITY: \t\t\tret ap3216c_read_alsir_data(dev, chan >address, chan >channel2, val); /* 读取ALS */ \t\t\tbreak;\t\t\t\t/* 值为val */ \t\tcase IIO_PROXIMITY: \t\t\tret regmap_bulk_read(dev >regmap, chan >address, data, 2); \t\t\t*val ((int)(data[1] & 0X3F) << 4) (data[0] & 0X0F); \t\t\tret IIO_VAL_INT; \t/* 值为val */ \t\t\tbreak; \t\tdefault: \t\t\tret EINVAL; \t\t\tbreak; \t\t} \t\tmutex_unlock(&dev >lock);\t\t\t\t\t\t\t/* 释放锁 \t\t\t*/ \t\treturn ret; \tcase IIO_CHAN_INFO_SCALE: \t\tswitch (chan >type) { \t\tcase IIO_INTENSITY:\t\t\t/* ALS量程 */ \t\t\tmutex_lock(&dev >lock); \t\t\tregdata (ap3216c_read_reg(dev, AP3216C_ALSCONFIG) & 0X30) >> 4; \t\t\t*val 0; \t\t\t*val2 als_scale_ap3216c[regdata]; \t\t\tmutex_unlock(&dev >lock); \t\t\treturn IIO_VAL_INT_PLUS_MICRO;\t/* 值为val+val2/1000000 */ \t\tdefault: \t\t\treturn EINVAL; \t\t} \t\treturn ret; \t\t \tdefault: \t\treturn EINVAL; \t} \treturn ret; } /* @description \t: 写函数，当向sysfs中的文件写数据的时候最终此函数会执行，一般在此函数 * \t\t\t\t\t：里面设置传感器，比如量程等。 * @param indio_dev\t: iio_dev * @param chan \t: 通道 * @param val \t\t: 应用程序写入的值，如果是小数值的话，val是整数部分。 * @param val2 \t: 应用程序写入的值，如果是小数值的话，val2是小数部分。 * @return\t\t\t\t: 0，成功；其他值，错误 */ static int ap3216c_write_raw(struct iio_dev *indio_dev, \t\t\t struct iio_chan_spec const *chan, \t\t\t int val, int val2, long mask) { \tint ret 0; \tstruct ap3216c_dev *dev iio_priv(indio_dev); \tswitch (mask) { \tcase IIO_CHAN_INFO_SCALE:\t/* 设置ALS量程 */ \t\tswitch (chan >type) { \t\tcase IIO_INTENSITY:\t\t/* 设置ALS量程 */ \t\t\tmutex_lock(&dev >lock); \t\t\tret ap3216c_write_als_scale(dev, chan >channel2, val2); \t\t\tmutex_unlock(&dev >lock); \t\t\tbreak; \t\tdefault: \t\t\tret EINVAL; \t\t\tbreak; \t\t} \t\tbreak; \t \tdefault: \t\tret EINVAL; \t\tbreak; \t} \treturn ret; } /* * @description \t: 用户空间写数据格式，比如我们在用户空间操作sysfs来设置传感器的分辨率， * \t\t\t\t\t：如果分辨率带小数，那么这个小数传递到内核空间应该扩大多少倍，此函数就是 *\t\t\t\t\t\t: 用来设置这个的。 * @param indio_dev\t: iio_dev * @param chan \t: 通道 * @param mask \t: 掩码 * @return\t\t\t\t: 0，成功；其他值，错误 */ static int ap3216c_write_raw_get_fmt(struct iio_dev *indio_dev, \t\t\t\t struct iio_chan_spec const *chan, long mask) { \tswitch (mask) { \tcase IIO_CHAN_INFO_SCALE: \t\tswitch (chan >type) { \t\tcase IIO_INTENSITY:\t\t/* 用户空间写的陀螺仪分辨率数据要乘以1000000 */ \t\t\treturn IIO_VAL_INT_PLUS_MICRO; \t\tdefault:\t\t\t\t \t\t\treturn IIO_VAL_INT_PLUS_MICRO; \t\t} \tdefault: \t\treturn IIO_VAL_INT_PLUS_MICRO; \t} \treturn EINVAL; } /* * iio_info结构体变量 */ static const struct iio_info ap3216c_info { \t.read_raw\t\t ap3216c_read_raw, \t.write_raw\t\t ap3216c_write_raw, \t.write_raw_get_fmt &ap3216c_write_raw_get_fmt,\t/* 用户空间写数据格式 */ }; /* * @description : i2c驱动的probe函数，当驱动与 * 设备匹配以后此函数就会执行 * @param client : i2c设备 * @param id : i2c设备ID * @return : 0，成功;其他负值,失败 */ static int ap3216c_probe(struct i2c_client *client, const struct i2c_device_id *id) { \tint ret; \tstruct ap3216c_dev *dev; \tstruct iio_dev *indio_dev; \t/* 1、申请iio_dev内存 */ \tindio_dev devm_iio_device_alloc(&client >dev, sizeof(*dev)); \tif (!indio_dev) \t\treturn ENOMEM; \t/* 2、获取ap3216c_dev结构体地址 */ \tdev iio_priv(indio_dev); \tdev >client client; \t \ti2c_set_clientdata(client, indio_dev); /* 保存ap3216cdev结构体 */ \t\t \t/* 初始化regmap_config设置 */ \tdev >regmap_config.reg_bits 8;\t\t/* 寄存器长度8bit */ \tdev >regmap_config.val_bits 8;\t\t/* 值长度8bit */ \t/* 初始化IIC接口的regmap */ \tdev >regmap regmap_init_i2c(client, &dev >regmap_config); \tif (IS_ERR(dev >regmap)) { \t\tret PTR_ERR(dev >regmap); \t\tgoto err_regmap_init; \t}\t \tmutex_init(&dev >lock);\t \t/* 4、iio_dev的其他成员变量 */ \tindio_dev >dev.parent &client >dev; \tindio_dev >info &ap3216c_info; \tindio_dev >name AP3216C_NAME;\t \tindio_dev >modes INDIO_DIRECT_MODE;\t/* 直接模式，提供sysfs接口 */ \tindio_dev >channels ap3216c_channels; \tindio_dev >num_channels ARRAY_SIZE(ap3216c_channels); \tindio_dev >available_scan_masks ap3216c_scan_masks; \t/* 5、注册iio_dev */ \tret iio_device_register(indio_dev); \tif (ret < 0) { \t\tdev_err(&client >dev, \"iio_device_register failed\\n\"); \t\tgoto err_iio_register; \t} \tap3216c_reginit(dev); /* 初始化ap3216c */ \treturn 0; err_iio_register: err_regmap_init: \tiio_device_unregister(indio_dev); \treturn ret; } /* * @description : i2c驱动的remove函数，移除i2c驱动的时候此函数会执行 * @param client \t: i2c设备 * @return : 0，成功;其他负值,失败 */ static int ap3216c_remove(struct i2c_client *client) { \tstruct iio_dev *indio_dev i2c_get_clientdata(client); \tstruct ap3216c_dev *dev; \t \tdev iio_priv(indio_dev); \t/* 1、释放regmap */ \tregmap_exit(dev >regmap); \t/* 2、注销IIO */ \tiio_device_unregister(indio_dev); \treturn 0; } /* 传统匹配方式ID列表 */ static const struct i2c_device_id ap3216c_id[] { \t{\"alientek,ap3216c\", 0}, \t{} }; /* 设备树匹配列表 */ static const struct of_device_id ap3216c_of_match[] { \t{ .compatible \"alientek,ap3216c\" }, \t{ /* Sentinel */ } }; /* i2c驱动结构体 */\t static struct i2c_driver ap3216c_driver { \t.probe ap3216c_probe, \t.remove ap3216c_remove, \t.driver { \t\t\t.owner THIS_MODULE, \t\t \t.name \"ap3216c\", \t\t \t.of_match_table ap3216c_of_match, \t\t }, \t.id_table ap3216c_id, }; \t\t /* * @description\t: 驱动入口函数 * @param \t\t: 无 * @return \t\t: 无 */ static int __init ap3216c_init(void) { \tint ret 0; \tret i2c_add_driver(&ap3216c_driver); \treturn ret; } /* * @description\t: 驱动出口函数 * @param \t\t: 无 * @return \t\t: 无 */ static void __exit ap3216c_exit(void) { \ti2c_del_driver(&ap3216c_driver); } /* module_i2c_driver(ap3216c_driver) */ module_init(ap3216c_init); module_exit(ap3216c_exit); MODULE_LICENSE(\"GPL\"); MODULE_AUTHOR(\"ALIENTEK\"); MODULE_INFO(intree, \"Y\"); ``` ### SPI驱动 ```c /*************************************************************** Copyright © ALIENTEK Co., Ltd. 1998 2029. All rights reserved. 文件名\t\t: icm20608.c 作者\t \t: 正点原子Linux团队 版本\t \t: V1.0 描述\t \t: ICM20608 SPI驱动程序 其他\t \t: 无 论坛 \t \t: www.openedv.com 日志\t \t: 初版V1.0 2021/03/22 正点原子Linux团队创建 \t\t\t V1.1 2021/08/10 \t\t\t 使用regmap读写SPI外设内部寄存器。 \t\t\t V1.2 2021/08/13 \t\t\t 使用IIO框架，参考bma220_spi.c ***************************************************************/ #include <linux/spi/spi.h> #include <linux/kernel.h> #include <linux/module.h> #include <linux/init.h> #include <linux/delay.h> #include <linux/ide.h> #include <linux/errno.h> #include <linux/platform_device.h> #include \"icm20608reg.h\" #include <linux/gpio.h> #include <linux/device.h> #include <asm/uaccess.h> #include <linux/cdev.h> #include <linux/regmap.h> #include <linux/iio/iio.h> #include <linux/iio/sysfs.h> #include <linux/iio/buffer.h> #include <linux/iio/trigger.h> #include <linux/iio/triggered_buffer.h> #include <linux/iio/trigger_consumer.h> #include <linux/unaligned/be_byteshift.h> #define ICM20608_NAME\t\"icm20608\" #define ICM20608_TEMP_OFFSET\t 0 #define ICM20608_TEMP_SCALE\t\t 326800000 #define ICM20608_CHAN(_type, _channel2, _index) \\ \t{ \\ \t\t.type _type, \\ \t\t.modified 1, \\ \t\t.channel2 _channel2, \\ \t\t.info_mask_shared_by_type BIT(IIO_CHAN_INFO_SCALE), \\ // 共用分辨率 \t\t.info_mask_separate BIT(IIO_CHAN_INFO_RAW) \t \\ // 单独原始数据 \t\t\t\t BIT(IIO_CHAN_INFO_CALIBBIAS), \\ // 单独校准 \t\t.scan_index _index, \\ \t\t.scan_type { \\ \t\t\t\t.sign 's', \\ \t\t\t\t.realbits 16, \\ \t\t\t\t.storagebits 16, \\ \t\t\t\t.shift 0, \\ \t\t\t\t.endianness IIO_BE, \\ \t\t\t }, \\ \t} /* * ICM20608的扫描元素，3轴加速度计、 * 3轴陀螺仪、1路温度传感器，1路时间戳 */ enum inv_icm20608_scan { \tINV_ICM20608_SCAN_ACCL_X, \tINV_ICM20608_SCAN_ACCL_Y, \tINV_ICM20608_SCAN_ACCL_Z, \tINV_ICM20608_SCAN_TEMP, \tINV_ICM20608_SCAN_GYRO_X, \tINV_ICM20608_SCAN_GYRO_Y, \tINV_ICM20608_SCAN_GYRO_Z, \tINV_ICM20608_SCAN_TIMESTAMP, }; struct icm20608_dev { \tstruct spi_device *spi;\t\t/* spi设备 */ \tstruct regmap *regmap;\t\t\t\t/* regmap */ \tstruct regmap_config regmap_config;\t \tstruct mutex lock; }; /* * icm20608陀螺仪分辨率，对应250、500、1000、2000，计算方法： * 以正负250度量程为例，500/2^16 0.007629，扩大1000000倍，就是7629 */ static const int gyro_scale_icm20608[] {7629, 15258, 30517, 61035}; /* * icm20608加速度计分辨率，对应2、4、8、16 计算方法： * 以正负2g量程为例，4/2^16 0.000061035，扩大1000000000倍，就是61035 */ static const int accel_scale_icm20608[] {61035, 122070, 244140, 488281}; /* * icm20608通道，1路温度通道，3路陀螺仪，3路加速度计 */ static const struct iio_chan_spec icm20608_channels[] { \t/* 温度通道 */ \t{ \t\t.type IIO_TEMP, \t\t.info_mask_separate BIT(IIO_CHAN_INFO_RAW) // 原始数据 \t\t\t\t BIT(IIO_CHAN_INFO_OFFSET) // 偏移 \t\t\t\t BIT(IIO_CHAN_INFO_SCALE), // 分辨率 \t\t.scan_index INV_ICM20608_SCAN_TEMP, \t\t.scan_type { \t\t\t\t.sign 's', \t\t\t\t.realbits 16, \t\t\t\t.storagebits 16, \t\t\t\t.shift 0, \t\t\t\t.endianness IIO_BE, \t\t\t }, \t}, \t// 实际只使用到前两个去判断实际获取的是哪一个数据 \tICM20608_CHAN(IIO_ANGL_VEL, IIO_MOD_X, INV_ICM20608_SCAN_GYRO_X),\t/* 陀螺仪X轴 */ \tICM20608_CHAN(IIO_ANGL_VEL, IIO_MOD_Y, INV_ICM20608_SCAN_GYRO_Y),\t/* 陀螺仪Y轴 */ \tICM20608_CHAN(IIO_ANGL_VEL, IIO_MOD_Z, INV_ICM20608_SCAN_GYRO_Z),\t/* 陀螺仪Z轴 */ \tICM20608_CHAN(IIO_ACCEL, IIO_MOD_Y, INV_ICM20608_SCAN_ACCL_Y),\t/* 加速度X轴 */ \tICM20608_CHAN(IIO_ACCEL, IIO_MOD_X, INV_ICM20608_SCAN_ACCL_X),\t/* 加速度Y轴 */ \tICM20608_CHAN(IIO_ACCEL, IIO_MOD_Z, INV_ICM20608_SCAN_ACCL_Z),\t/* 加速度Z轴 */ }; /* * @description\t: 读取icm20608指定寄存器值，读取一个寄存器 * @param dev: icm20608设备 * @param reg: 要读取的寄存器 * @return \t : 读取到的寄存器值 */ static unsigned char icm20608_read_onereg(struct icm20608_dev *dev, u8 reg) { \tu8 ret; \tunsigned int data; \tret regmap_read(dev >regmap, reg, &data); \treturn (u8)data; } /* * @description\t: 向icm20608指定寄存器写入指定的值，写一个寄存器 * @param dev: icm20608设备 * @param reg: 要写的寄存器 * @param data: 要写入的值 * @return : 无 */\t static void icm20608_write_onereg(struct icm20608_dev *dev, u8 reg, u8 value) { \tregmap_write(dev >regmap, reg, value); } /* * @description \t: ICM20608内部寄存器初始化函数 * @param spi \t: 要操作的设备 * @return \t\t\t: 无 */ void icm20608_reginit(struct icm20608_dev *dev) { \tu8 value 0; \t \ticm20608_write_onereg(dev, ICM20_PWR_MGMT_1, 0x80); \tmdelay(50); \ticm20608_write_onereg(dev, ICM20_PWR_MGMT_1, 0x01); \tmdelay(50); \tvalue icm20608_read_onereg(dev, ICM20_WHO_AM_I); \tprintk(\"ICM20608 ID %#X\\r\\n\", value);\t \ticm20608_write_onereg(dev, ICM20_SMPLRT_DIV, 0x00); \t/* 输出速率是内部采样率\t\t*/ \ticm20608_write_onereg(dev, ICM20_GYRO_CONFIG, 0x18); \t/* 陀螺仪±2000dps量程 \t\t*/ \ticm20608_write_onereg(dev, ICM20_ACCEL_CONFIG, 0x18); \t/* 加速度计±16G量程 \t\t*/ \ticm20608_write_onereg(dev, ICM20_CONFIG, 0x04); \t\t/* 陀螺仪低通滤波BW 20Hz \t*/ \ticm20608_write_onereg(dev, ICM20_ACCEL_CONFIG2, 0x04); /* 加速度计低通滤波BW 21.2Hz \t*/ \ticm20608_write_onereg(dev, ICM20_PWR_MGMT_2, 0x00); \t/* 打开加速度计和陀螺仪所有轴 \t*/ \ticm20608_write_onereg(dev, ICM20_LP_MODE_CFG, 0x00); \t/* 关闭低功耗 \t\t\t\t*/ \ticm20608_write_onereg(dev, ICM20_INT_ENABLE, 0x01);\t\t/* 使能FIFO溢出以及数据就绪中断\t*/ } /* * @description \t: 设置ICM20608传感器，可以用于陀螺仪、加速度计设置 * @param dev\t: icm20608设备 * @param reg \t: 要设置的通道寄存器首地址。 * @param anix \t: 要设置的通道，比如X，Y，Z。 * @param val \t: 要设置的值。 * @return\t\t\t: 0，成功；其他值，错误 */ static int icm20608_sensor_set(struct icm20608_dev *dev, int reg, \t\t\t\tint axis, int val) { \tint ind, result; \t__be16 d cpu_to_be16(val); \tind (axis IIO_MOD_X) * 2; // 计算出实际的寄存器的偏移的位置 \tresult regmap_bulk_write(dev >regmap, reg + ind, (u8 *)&d, 2); \tif (result) \t\treturn EINVAL; \treturn 0; } /* * @description \t: 读取ICM20608传感器数据，可以用于陀螺仪、加速度计、温度的读取 * @param dev\t: icm20608设备 * @param reg \t: 要读取的通道寄存器首地址。 * @param anix \t: 需要读取的通道，比如X，Y，Z。 * @param val \t: 保存读取到的值。 * @return\t\t\t: 0，成功；其他值，错误 */ static int icm20608_sensor_show(struct icm20608_dev *dev, int reg, \t\t\t\t int axis, int *val) { \tint ind, result; \t__be16 d; \tind (axis IIO_MOD_X) * 2; \tresult regmap_bulk_read(dev >regmap, reg + ind, (u8 *)&d, 2); \tif (result) \t\treturn EINVAL; \t*val (short)be16_to_cpup(&d); \treturn IIO_VAL_INT; } /* * @description \t\t: 读取ICM20608陀螺仪、加速度计、温度通道值 * @param indio_dev\t: iio设备 * @param chan \t\t: 通道。 * @param val \t\t: 保存读取到的通道值。 * @return\t\t\t\t: 0，成功；其他值，错误 */ static int icm20608_read_channel_data(struct iio_dev *indio_dev, \t\t\t\t\t struct iio_chan_spec const *chan, \t\t\t\t\t int *val) { \tstruct icm20608_dev *dev iio_priv(indio_dev); \tint ret 0; \tswitch (chan >type) { \tcase IIO_ANGL_VEL:\t/* 读取陀螺仪数据 */ \t\tret icm20608_sensor_show(dev, ICM20_GYRO_XOUT_H, chan >channel2, val); /* channel2为X、Y、Z轴 */ \t\tbreak; \tcase IIO_ACCEL:\t\t/* 读取加速度计数据 */ \t\tret icm20608_sensor_show(dev, ICM20_ACCEL_XOUT_H, chan >channel2, val); /* channel2为X、Y、Z轴 */ \t\tbreak; \tcase IIO_TEMP:\t\t/* 读取温度 */ \t\tret icm20608_sensor_show(dev, ICM20_TEMP_OUT_H, IIO_MOD_X, val); \t\tbreak; \tdefault: \t\tret EINVAL; \t\tbreak; \t} \treturn ret; } /* * @description \t: 设置ICM20608的陀螺仪计量程(分辨率) * @param dev\t: icm20608设备 * @param val \t: 量程(分辨率值)。 * @return\t\t\t: 0，成功；其他值，错误 */ static int icm20608_write_gyro_scale(struct icm20608_dev *dev, int val) { \tint result, i; \tu8 d; \tfor (i 0; i < ARRAY_SIZE(gyro_scale_icm20608); ++i) { \t\tif (gyro_scale_icm20608[i] val) { \t\t\td (i << 3); \t\t\tresult regmap_write(dev >regmap, ICM20_GYRO_CONFIG, d); \t\t\tif (result) \t\t\t\treturn result; \t\t\treturn 0; \t\t} \t} \treturn EINVAL; } /* * @description \t: 设置ICM20608的加速度计量程(分辨率) * @param dev\t: icm20608设备 * @param val \t: 量程(分辨率值)。 * @return\t\t\t: 0，成功；其他值，错误 */ static int icm20608_write_accel_scale(struct icm20608_dev *dev, int val) { \tint result, i; \tu8 d; \tfor (i 0; i < ARRAY_SIZE(accel_scale_icm20608); ++i) { \t\tif (accel_scale_icm20608[i] val) { \t\t\td (i << 3); \t\t\tresult regmap_write(dev >regmap, ICM20_ACCEL_CONFIG, d); \t\t\tif (result) \t\t\t\treturn result; \t\t\treturn 0; \t\t} \t} \treturn EINVAL; } /* * @description \t: 读函数，当读取sysfs中的文件的时候最终此函数会执行，此函数 * \t\t\t\t\t：里面会从传感器里面读取各种数据，然后上传给应用。 * @param indio_dev\t: iio_dev * @param chan \t: 通道 * @param val \t\t: 读取的值，如果是小数值的话，val是整数部分。 * @param val2 \t: 读取的值，如果是小数值的话，val2是小数部分。 * @param mask \t: 掩码。 * @return\t\t\t\t: 0，成功；其他值，错误 */ static int icm20608_read_raw(struct iio_dev *indio_dev, \t\t\t struct iio_chan_spec const *chan, \t\t\t int *val, int *val2, long mask) { \tstruct icm20608_dev *dev iio_priv(indio_dev); \tint ret 0; \tunsigned char regdata 0; \tswitch (mask) { \tcase IIO_CHAN_INFO_RAW:\t\t\t\t/* 读取ICM20608加速度计、陀螺仪、温度传感器原始值 */ \t\tmutex_lock(&dev >lock);\t\t\t\t\t\t\t\t/* 上锁 \t\t\t*/ \t\tret icm20608_read_channel_data(indio_dev, chan, val); \t/* 读取通道值 */ \t\tmutex_unlock(&dev >lock);\t\t\t\t\t\t\t/* 释放锁 \t\t\t*/ \t\treturn ret; \tcase IIO_CHAN_INFO_SCALE: \t\tswitch (chan >type) { \t\tcase IIO_ANGL_VEL: \t\t\tmutex_lock(&dev >lock); // 从寄存器里面获取当前的分辨率的配置 \t\t\tregdata (icm20608_read_onereg(dev, ICM20_GYRO_CONFIG) & 0X18) >> 3; \t\t\t*val 0; \t\t\t*val2 gyro_scale_icm20608[regdata]; \t\t\tmutex_unlock(&dev >lock); \t\t\treturn IIO_VAL_INT_PLUS_MICRO;\t/* 值为val+val2/1000000 */ \t\tcase IIO_ACCEL: \t\t\tmutex_lock(&dev >lock); \t\t\tregdata (icm20608_read_onereg(dev, ICM20_ACCEL_CONFIG) & 0X18) >> 3; \t\t\t*val 0; \t\t\t*val2 accel_scale_icm20608[regdata];; \t\t\tmutex_unlock(&dev >lock); \t\t\treturn IIO_VAL_INT_PLUS_NANO;/* 值为val+val2/1000000000 */ \t\tcase IIO_TEMP:\t\t\t\t\t \t\t\t*val ICM20608_TEMP_SCALE/ 1000000; \t\t\t*val2 ICM20608_TEMP_SCALE % 1000000; \t\t\treturn IIO_VAL_INT_PLUS_MICRO;\t/* 值为val+val2/1000000 */ \t\tdefault: \t\t\treturn EINVAL; \t\t} \t\treturn ret; \tcase IIO_CHAN_INFO_OFFSET:\t\t/* ICM20608温度传感器offset值 */ \t\tswitch (chan >type) { \t\tcase IIO_TEMP: \t\t\t*val ICM20608_TEMP_OFFSET; \t\t\treturn IIO_VAL_INT; \t\tdefault: \t\t\treturn EINVAL; \t\t} \t\treturn ret; \tcase IIO_CHAN_INFO_CALIBBIAS:\t/* ICM20608加速度计和陀螺仪校准值 */ \t\tswitch (chan >type) { \t\tcase IIO_ANGL_VEL:\t\t/* 陀螺仪的校准值 */ \t\t\tmutex_lock(&dev >lock); \t\t\tret icm20608_sensor_show(dev, ICM20_XG_OFFS_USRH, chan >channel2, val); \t\t\tmutex_unlock(&dev >lock); \t\t\treturn ret; \t\tcase IIO_ACCEL:\t\t\t/* 加速度计的校准值 */ \t\t\tmutex_lock(&dev >lock);\t \t\t\tret icm20608_sensor_show(dev, ICM20_XA_OFFSET_H, chan >channel2, val); \t\t\tmutex_unlock(&dev >lock); \t\t\treturn ret; \t\tdefault: \t\t\treturn EINVAL; \t\t} \t\t \tdefault: \t\treturn ret EINVAL; \t} }\t /* * @description \t: 写函数，当向sysfs中的文件写数据的时候最终此函数会执行，一般在此函数 * \t\t\t\t\t：里面设置传感器，比如量程等。 * @param indio_dev\t: iio_dev * @param chan \t: 通道 * @param val \t\t: 应用程序写入的值，如果是小数值的话，val是整数部分。 * @param val2 \t: 应用程序写入的值，如果是小数值的话，val2是小数部分。 * @return\t\t\t\t: 0，成功；其他值，错误 */ static int icm20608_write_raw(struct iio_dev *indio_dev, \t\t\t struct iio_chan_spec const *chan, \t\t\t int val, int val2, long mask) { \tstruct icm20608_dev *dev iio_priv(indio_dev); \tint ret 0; \tswitch (mask) { \tcase IIO_CHAN_INFO_SCALE:\t/* 设置陀螺仪和加速度计的分辨率 */ \t\tswitch (chan >type) { \t\tcase IIO_ANGL_VEL:\t\t/* 设置陀螺仪 */ \t\t\tmutex_lock(&dev >lock); \t\t\tret icm20608_write_gyro_scale(dev, val2); \t\t\tmutex_unlock(&dev >lock); \t\t\tbreak; \t\tcase IIO_ACCEL:\t\t\t/* 设置加速度计 */ \t\t\tmutex_lock(&dev >lock); \t\t\tret icm20608_write_accel_scale(dev, val2); \t\t\tmutex_unlock(&dev >lock); \t\t\tbreak; \t\tdefault: \t\t\tret EINVAL; \t\t\tbreak; \t\t} \t\tbreak; \tcase IIO_CHAN_INFO_CALIBBIAS:\t/* 设置陀螺仪和加速度计的校准值*/ \t\tswitch (chan >type) { \t\tcase IIO_ANGL_VEL:\t\t/* 设置陀螺仪校准值 */ \t\t\tmutex_lock(&dev >lock); \t\t\tret icm20608_sensor_set(dev, ICM20_XG_OFFS_USRH, \t\t\t\t\t\t\t\t\t chan >channel2, val); \t\t\tmutex_unlock(&dev >lock); \t\t\tbreak; \t\tcase IIO_ACCEL:\t\t\t/* 加速度计校准值 */ \t\t\tmutex_lock(&dev >lock); \t\t\tret icm20608_sensor_set(dev, ICM20_XA_OFFSET_H, \t\t\t\t\t\t\t chan >channel2, val); \t\t\tmutex_unlock(&dev >lock); \t\t\tbreak; \t\tdefault: \t\t\tret EINVAL; \t\t\tbreak; \t\t} \t\tbreak; \tdefault: \t\tret EINVAL; \t\tbreak; \t} \treturn ret; } /* * @description \t: 用户空间写数据格式，比如我们在用户空间操作sysfs来设置传感器的分辨率， * \t\t\t\t\t：如果分辨率带小数，那么这个小数传递到内核空间应该扩大多少倍，此函数就是 *\t\t\t\t\t\t: 用来设置这个的。 * @param indio_dev\t: iio_dev * @param chan \t: 通道 * @param mask \t: 掩码 * @return\t\t\t\t: 0，成功；其他值，错误 */ static int icm20608_write_raw_get_fmt(struct iio_dev *indio_dev, \t\t\t\t struct iio_chan_spec const *chan, long mask) { \tswitch (mask) { \tcase IIO_CHAN_INFO_SCALE: \t\tswitch (chan >type) { \t\tcase IIO_ANGL_VEL:\t\t/* 用户空间写的陀螺仪分辨率数据要乘以1000000 */ \t\t\treturn IIO_VAL_INT_PLUS_MICRO; \t\tdefault:\t\t\t\t/* 用户空间写的加速度计分辨率数据要乘以1000000000 */ \t\t\treturn IIO_VAL_INT_PLUS_NANO; \t\t} \tdefault: \t\treturn IIO_VAL_INT_PLUS_MICRO; \t} \treturn EINVAL; } /* * iio_info结构体变量 */ static const struct iio_info icm20608_info { \t.read_raw\t\t icm20608_read_raw, \t.write_raw\t\t icm20608_write_raw, \t.write_raw_get_fmt &icm20608_write_raw_get_fmt,\t/* 用户空间写数据格式 */ }; /* * @description : spi驱动的probe函数，当驱动与 * 设备匹配以后此函数就会执行 * @param spi \t: spi设备 * @return \t\t: 0,成功；其他值，失败 */\t static int icm20608_probe(struct spi_device *spi) { \tint ret; \tstruct icm20608_dev *dev; \tstruct iio_dev *indio_dev; \t/* 1、申请iio_dev内存 */ \tindio_dev devm_iio_device_alloc(&spi >dev, sizeof(*dev)); \tif (!indio_dev) \t\treturn ENOMEM; \t/* 2、获取icm20608_dev结构体地址 */ \tdev iio_priv(indio_dev); \tdev >spi spi; \tspi_set_drvdata(spi, indio_dev); \t\t/* 将indio_de设置为spi >dev的driver_data */ \tmutex_init(&dev >lock); \t/* 3、iio_dev的其他成员变量 */ \tindio_dev >dev.parent &spi >dev; \tindio_dev >info &icm20608_info; \tindio_dev >name ICM20608_NAME;\t \tindio_dev >modes INDIO_DIRECT_MODE;\t/* 直接模式，提供sysfs接口 */ \tindio_dev >channels icm20608_channels; \tindio_dev >num_channels ARRAY_SIZE(icm20608_channels); \t/* 4、注册iio_dev */ \tret iio_device_register(indio_dev); \tif (ret < 0) { \t\tdev_err(&spi >dev, \"iio_device_register failed\\n\"); \t\tgoto err_iio_register; \t} \t/* 5、初始化regmap_config设置 */ \tdev >regmap_config.reg_bits 8;\t\t\t/* 寄存器长度8bit */ \tdev >regmap_config.val_bits 8;\t\t\t/* 值长度8bit */ \tdev >regmap_config.read_flag_mask 0x80; /* 读掩码设置为0X80，ICM20608使用SPI接口读的时候寄存器最高位应该为1 */ \t/* 6、初始化SPI接口的regmap */ \tdev >regmap regmap_init_spi(spi, &dev >regmap_config); \tif (IS_ERR(dev >regmap)) { \t\tret PTR_ERR(dev >regmap); \t\tgoto err_regmap_init; \t} \t/* 7、初始化spi_device */ \tspi >mode SPI_MODE_0;\t/*MODE0，CPOL 0，CPHA 0*/ \tspi_setup(spi); \t \t/* 初始化ICM20608内部寄存器 */ \ticm20608_reginit(dev);\t \treturn 0; err_regmap_init: iio_device_unregister(indio_dev); err_iio_register: \treturn ret; } /* * @description : spi驱动的remove函数，移除spi驱动的时候此函数会执行 * @param spi \t: spi设备 * @return : 0，成功;其他负值,失败 */ static int icm20608_remove(struct spi_device *spi) { \tstruct iio_dev *indio_dev spi_get_drvdata(spi); \tstruct icm20608_dev *dev; \t \tdev iio_priv(indio_dev); \t/* 1、删除regmap */ \tregmap_exit(dev >regmap); \t/* 2、注销IIO */ \tiio_device_unregister(indio_dev); \treturn 0; } /* 传统匹配方式ID列表 */ static const struct spi_device_id icm20608_id[] { \t{\"alientek,icm20608\", 0}, \t{} }; /* 设备树匹配列表 */ static const struct of_device_id icm20608_of_match[] { \t{ .compatible \"alientek,icm20608\" }, \t{ /* Sentinel */ } }; /* SPI驱动结构体 */ static struct spi_driver icm20608_driver { \t.probe icm20608_probe, \t.remove icm20608_remove, \t.driver { \t\t\t.owner THIS_MODULE, \t\t \t.name \"icm20608\", \t\t \t.of_match_table icm20608_of_match, \t\t }, \t.id_table icm20608_id, }; /* * @description\t: 驱动入口函数 * @param \t\t: 无 * @return \t\t: 无 */ static int __init icm20608_init(void) { \treturn spi_register_driver(&icm20608_driver); } /* * @description\t: 驱动出口函数 * @param \t\t: 无 * @return \t\t: 无 */ static void __exit icm20608_exit(void) { \tspi_unregister_driver(&icm20608_driver); } module_init(icm20608_init); module_exit(icm20608_exit); MODULE_LICENSE(\"GPL\"); MODULE_AUTHOR(\"ALIENTEK\"); MODULE_INFO(intree, \"Y\"); ```"},"/note/Linux/野火Linux/2025-11-14-67-MISC设备.html":{"title":"MISC设备","content":"# MISC设备 misc的意思是混合、杂项的，因此 MISC驱动也叫做杂项驱动，也就是当我们板子上的某些外设无法进行分类的时候就可以使用 MISC 驱动。MISC 驱动其实就是最简单的字符设备驱动，通常嵌套在 platform 总线驱动中，实现复杂的驱动 所有的 MISC 设备驱动的主设备号都为 10，不同的设备使用不同的从设备号。随着 Linux字符设备驱动的不断增加，设备号变得越来越紧张，尤其是主设备号，MISC 设备驱动就用于解决此问题。**MISC 设备会自动创建 cdev**，不需要像我们以前那样手动创建，因此采用 MISC设备驱动可以简化字符设备驱动的编写 我们需要向 Linux注册一个miscdevice设备 ## 使用 使用misc_register替换整个字符设备的注册部分, 在device_platform的注册prob函数里面 ### 数据结构 ```c struct miscdevice { \tint minor; // 次设备号 \tconst char *name; \tconst struct file_operations *fops; // 字符设备驱动 \tstruct list_head list; \tstruct device *parent; \tstruct device *this_device; \tconst struct attribute_group **groups; \tconst char *nodename; \tumode_t mode; }; ``` 我们需要设置 minor、name 和 fops 这三个成员变量, Linux 系统已经预定义了一些 MISC 设备的子设备号，这些预定义的子设备号定义在 `include/linux/miscdevice.h`文件中, 子设备号设置为`MISC_DYNAMIC_MINOR`是自动赋值 name就是此MISC设备名字，当此设备注册成功以后就会在/dev目录下生成一个名为 name 的设备文件。fops 就是字符设备的操作集合 ### 注册函数 ```c extern int misc_register(struct miscdevice *misc); extern int misc_deregister(struct miscdevice *misc); ``` 注册函数可以理解为下面几个函数的集合 ```c alloc_chrdev_region(); /* 申请设备号 */ cdev_init(); /* 初始化 cdev */ cdev_add(); /* 添加 cdev */ class_create(); /* 创建类 */ device_create(); /* 创建设备 */ ```"},"/note/Linux/野火Linux/2025-9-27-37-Input子系统.html":{"title":"","content":"## 输入(input)子系统基础概念 ## 使用 + 使用`input_allocate_device`申请`input_device` + 初始化`input_device`的位图`evbit`表示注册的事件类型, 以及其他实际的事件对应的种类 + 使用`input_register_device`进行注册 + 在按键等触发的时候使用`input_event`进行事件的上报 + 使用`input_sync`进行事件同步 + 在`/dev/input/eventx`可以读取上报的事件, 是`struct input_event`类型的 ## 概念 统一管理外部输入设备 按键 键盘 鼠标 触摸屏 ## 用户空间接口 创建的输入接口会放在/dev/input目录里面 /dev/input/event0/1/2/... /dev/input/mouse0/1/2/... /dev/input/sj0/1/2/... ... ### 分层模型 ##### 核心层 创建input设备类 根据输入设备种类、分发事件到不同事件处理器 ##### 事件处理层 提供具体设备的操作接口，为输入设备(input_dev)创建具体设备文件 通用事件处理器(drivers/input/evdev.c) 鼠标事件处理器(drivers/input/mousedev.c) 摇杆事件处理器(drivers/input/joydev.c) ![image 20251114110855097](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251114110855097.png) > 自动创建字符设备, 不再需要手动进行创建 ### input设备类 #### input_init()函数 drivers/input/input.c Linux自动运行这侧的一个类 ```c static int __init input_init(void) { \tint err; \t// 创建一个类 \terr class_register(&input_class); \tif (err) { \t\tpr_err(\"unable to register input_dev class\\n\"); \t\treturn err; \t} \t... \terr register_chrdev_region(MKDEV(INPUT_MAJOR, 0), \t\t\t\t INPUT_MAX_CHAR_DEVICES, \"input\"); // 13号dev \tif (err) { \t\tpr_err(\"unable to register char major %d\", INPUT_MAJOR); \t\tgoto fail2; \t} \treturn 0; fail2:\tinput_proc_exit(); fail1:\tclass_unregister(&input_class); \treturn err; } ``` #### input_class定义 drivers/input/input.c ```c struct class input_class { \t.name\t\t \"input\", \t.devnode\t input_devnode, }; ``` #### INPUT_MAJOR定义 include/uapi/linux/major.h 这个是所有的input类使用的设备号 ``` #define INPUT_MAJOR 13 ``` #### INPUT_MAX_CHAR_DEVICES定义 drivers/input/input.c ``` #define INPUT_MAX_CHAR_DEVICES\t\t1024 ``` ### input_dev结构体 include/linux/input.h ```c struct input_dev { \tconst char *name; // 设备的名字 \tconst char *phys; \tconst char *uniq; \tstruct input_id id; // 记录设备的信息 \t// 几个位图 \tunsigned long propbit[BITS_TO_LONGS(INPUT_PROP_CNT)]; \t \tunsigned long evbit[BITS_TO_LONGS(EV_CNT)]; // 支持的输入事件, 按键, 鼠标等 \tunsigned long keybit[BITS_TO_LONGS(KEY_CNT)]; // 具体的按键类型 \tunsigned long relbit[BITS_TO_LONGS(REL_CNT)]; // 坐标类型 \tunsigned long absbit[BITS_TO_LONGS(ABS_CNT)]; \tunsigned long mscbit[BITS_TO_LONGS(MSC_CNT)]; \tunsigned long ledbit[BITS_TO_LONGS(LED_CNT)]; \tunsigned long sndbit[BITS_TO_LONGS(SND_CNT)]; \tunsigned long ffbit[BITS_TO_LONGS(FF_CNT)]; \tunsigned long swbit[BITS_TO_LONGS(SW_CNT)]; \t... \tint (*open)(struct input_dev *dev); \tvoid (*close)(struct input_dev *dev); \tint (*flush)(struct input_dev *dev, struct file *file); \tint (*event)(struct input_dev *dev, unsigned int type, unsigned int code, int value); \t... \tstruct device dev; \tstruct list_head\th_list; \tstruct list_head\tnode; \tunsigned int num_vals; \tunsigned int max_vals; \tstruct input_value *vals; \tbool devres_managed; }; ``` name：输入设备名 id：输入设备与事件处理器的匹配信息 evbit：指定支持的事件类型 同步事件、按键事件、坐标事件... keybit：指定支持的按键值类型 key1、key2... relbit：指定支持相对坐标类型 x轴、y轴、z轴、滑轮... absbit：指定支持绝对坐标类型 x轴、y轴、z轴、滑轮... #### 事件类型 include/linux/input.h ```c #define EV_SYN\t\t\t0x00\t// 同步事件 #define EV_KEY\t\t\t0x01\t// 按键事件 #define EV_REL\t\t\t0x02\t// 相对坐标 #define EV_ABS\t\t\t0x03 // 绝对坐标 ... #define EV_CNT\t\t\t(EV_MAX+1) ``` #### 按键值类型 include/linux/input.h ```c #define KEY_RESERVED\t\t0 #define KEY_ESC\t\t\t1 #define KEY_1\t\t\t2 #define KEY_2\t\t\t3 #define KEY_3\t\t\t4 #define KEY_4\t\t\t5 #define KEY_5\t\t\t6 ... ``` Linux下面的按键有两种, KEY以及button Key（按键） **来源**：主要来自键盘 **用途**：字符输入、功能键、组合键 **事件类型**：`EV_KEY` Button（按钮） **来源**：鼠标、触摸板、游戏手柄等指针设备, 通常与指针移动配合使用 **用途**：点击、选择、导航 **事件类型**：`EV_KEY` #### 注册/销毁输入设备 ##### input_allocate_device()函数 drivers/input/input.c 分配并初步初始化 input_dev 结构体变量 ```c struct input_dev *input_allocate_device(void) ``` ##### input_register_device()函数 drivers/input/input.c 向系统注册输入设备 ```c int input_register_device(struct input_dev *dev) ``` ##### input_unregister_device()函数 drivers/input/input.c 向系统注释输入设备 ```c void input_unregister_device(struct input_dev *dev) ``` ##### input_free_device()函数 drivers/input/input.c 释放 input_dev 结构体变量 ```c void input_free_device(struct input_dev *dev) ``` #### 上报输入事件 ##### input_event()函数 drivers/input/input.c 通用事件上报接口 ```c void input_event(struct input_dev *dev,unsigned int type, unsigned int code, int value) ``` 参数： dev：需要上报信息的输入设备 type：上报的具体输入事件类型 按键输入类型：EV_KEY 坐标输入类型：EV_REL、EV_ABS 特殊类型：EV_SYN 同步事件：通知用户空间的程序接收消息 code：记录输入事件类型中的具体事件 键盘发生按键输入类型事件时，记录键盘那个值被按下 value：具体事件的对应值 按键按下，value值为1；按键松开，value值为0 返回值：无 ##### input_report_key()函数 include/linux/input.h 按键事件上报接口 ```c static inline void input_report_key(struct input_dev *dev, unsigned int code, int value) { \tinput_event(dev, EV_KEY, code, !!value); } ``` ##### input_report_rel()函数 include/linux/input.h 相对坐标事件上报接口 ```c static inline void input_report_rel(struct input_dev *dev, unsigned int code, int value) { \tinput_event(dev, EV_REL, code, value); } ``` ##### input_report_abs()函数 include/linux/input.h 绝对坐标事件上报接口 ```c static inline void input_report_abs(struct input_dev *dev, unsigned int code, int value) { \tinput_event(dev, EV_ABS, code, value); } ``` ##### input_sync()函数 include/linux/input.h 同步事件上报接口 ```c static inline void input_sync(struct input_dev *dev) { \tinput_event(dev, EV_SYN, SYN_REPORT, 0); } ``` 调用其他的事件以后使用这个函数进行同步 ### 事件 ```c struct input_event { \tstruct timeval time; \t__u16 type; \t__u16 code; \t__s32 value; }; ``` > + **time**：时间，也就是此事件发生的时间 > + **type**：事件类型，比如EV_KEY，表示此次事件为按键事件，此成员变量为 16位。 > + **code**：事件码，比如在 EV_KEY 事件中 code 就表示具体的按键码，如：KEY_0、KEY_1等等这些按键。此成员变量为 16位。 > + **value**：值，比如EV_KEY事件中value就是按键值，表示按键有没有被按下，如果为 1的话说明按键按下，如果为0的话说明按键没有被按下或者按键松开了 所有的输入设备最终都是按照 input_event 结构体呈现给用户的，用户应用程序可以通过input_event来获取到具体的输入事件或相关的值 ## 输入(input)子系统实验 ### 系统下显示 #### 通用输入设备(evdev.c)识别 /dev/input/event0 /dev/input/event1 记录在device/input目录下面 #### 查看输入设备名和event对应关系 ```bash cat /proc/bus/input/devices ``` ### 位设置 include/asm generic/bitops/non atomic.h 一般可以使用三个方式进行设置位图 ```c static inline void __set_bit(int nr, volatile unsigned long *addr) __set_bit(EV_KEY, inputdev >evbit); #define BIT_MASK(nr)\t\t(1UL << ((nr) % BITS_PER_LONG)) keyinputdev.inputdev >evbit[0] BIT_MASK(EV_KEY); void input_set_capability(struct input_dev *dev, unsigned int type, unsigned int code); input_set_capability(keyinputdev.inputdev, EV_KEY, KEY_0); ``` #### input_set_capability()函数 drivers/input/input.c 设置事件类型以及事件的代号, 需要设置以后才可以上报 ```c void input_set_capability(struct input_dev *dev, unsigned int type, unsigned int code) { \tswitch (type) { \tcase EV_KEY: \t\t__set_bit(code, dev >keybit); \t\tbreak; \tcase EV_REL: \t\t__set_bit(code, dev >relbit); \t\tbreak; \tcase EV_ABS: \t\tinput_alloc_absinfo(dev); \t\tif (!dev >absinfo) \t\t\treturn; \t\t__set_bit(code, dev >absbit); \t\tbreak; \t... } ``` ### 实际代码 ```c #include <linux/init.h> #include <linux/kernel.h> #include <linux/module.h> #include <linux/fs.h> #include <linux/cdev.h> #include <linux/uaccess.h> #include <linux/delay.h> #include <linux/ide.h> #include <linux/errno.h> #include <linux/gpio.h> #include <asm/mach/map.h> #include <linux/of.h> #include <linux/of_address.h> #include <linux/of_gpio.h> #include <asm/io.h> #include <linux/device.h> #include <linux/irq.h> #include <linux/of_irq.h> #include <linux/input.h> #include <asm/uaccess.h> struct device_node *button_device_node NULL; //定义按键设备节点结构体 unsigned button_GPIO_number 0;\t\t\t //保存button使用的GPIO引脚编号 u32 interrupt_number 0;\t\t\t\t\t // button 引脚中断编号 /*input 子系统相关内容*/ #define BUTTON_NAME \"input_button\" struct input_dev *button_input_dev NULL; //定义按键对应的输入子系统结构体 /*按键中断处理函数*/ static irqreturn_t button_irq_hander(int irq, void *dev_id) { \tint button_satus 0; \t/*读取按键引脚的电平，根据读取得到的结果输入按键状态*/ \tbutton_satus gpio_get_value(button_GPIO_number); \tif(0 button_satus) \t{ \t\tinput_report_key(button_input_dev, KEY_1, 0); \t\tinput_sync(button_input_dev); \t} \telse \t{ \t\tinput_report_key(button_input_dev, KEY_1, 1); \t\tinput_sync(button_input_dev); \t} \t \treturn IRQ_HANDLED; } /* *驱动初始化函数 */ static int __init button_driver_init(void) { \tint error; \tprintk(KERN_ERR\"button_driver_init \\n\"); \t/*获取按键 设备树节点*/ \tbutton_device_node of_find_node_by_path(\"/button_interrupt\"); \tif (NULL button_device_node) \t{ \t\tprintk(KERN_ERR \"of_find_node_by_path error!\"); \t\treturn 1; \t} \t/*获取按键使用的GPIO*/ \tbutton_GPIO_number of_get_named_gpio(button_device_node, \"button_gpio\", 0); \tif (0 button_GPIO_number) \t{ \t\tprintk(KERN_ERR\"of_get_named_gpio error\"); \t\treturn 1; \t} \t/*申请GPIO , 记得释放*/ \terror gpio_request(button_GPIO_number, \"button_gpio\"); \tif (error < 0) \t{ \t\tprintk(KERN_ERR \"gpio_request error\"); \t\tgpio_free(button_GPIO_number); \t\treturn 1; \t} \terror gpio_direction_input(button_GPIO_number); //设置引脚为输入模式 \t/*获取中断号*/ \tinterrupt_number irq_of_parse_and_map(button_device_node, 0); \tprintk(KERN_ERR\"\\n interrupt_number %d \\n\", interrupt_number); \t/*申请中断, 记得释放*/ \terror request_irq(interrupt_number, button_irq_hander, IRQF_TRIGGER_RISING \t\t\tIRQF_TRIGGER_FALLING, \"button_interrupt\", NULL); \tif (error ! 0) \t{ \t\tprintk(KERN_ERR \"request_irq error:%d\\r\\n\",error); \t\tgpio_free(button_GPIO_number); \t\tfree_irq(interrupt_number, NULL); \t\treturn 1; \t} \t/*申请输入子系统结构体*/ \tbutton_input_dev input_allocate_device(); \tif (NULL button_input_dev) \t{ \t\tprintk(KERN_ERR \"input_allocate_device error\"); \t\treturn 1; \t} \tbutton_input_dev >name BUTTON_NAME; \t/*设置要使用的输入事件类型*/ \tbutton_input_dev >evbit[0] BIT_MASK(EV_KEY); \t/*标记设备能够触发的具体事件代号*/ \tinput_set_capability(button_input_dev, EV_KEY, KEY_1); \t/*注册输入设备*/ \terror input_register_device(button_input_dev); \tif (0 ! error) \t{ \t\tprintk(KERN_ERR \"input_register_device error:%d\",error); \t\tgpio_free(button_GPIO_number); \t\tfree_irq(interrupt_number, NULL); \t\tinput_unregister_device(button_input_dev); \t\treturn 1; \t} \treturn 0; } /* *驱动注销函数 */ static void __exit button_driver_exit(void) { \tprintk(KERN_ERR \"button_driver_exit\\n\"); \t/*释放申请的引脚,和中断*/ \tgpio_free(button_GPIO_number); \tfree_irq(interrupt_number, NULL); \t \t/*释放输入子系统相关内容*/ \tinput_unregister_device(button_input_dev); \tinput_free_device(button_input_dev); } module_init(button_driver_init); module_exit(button_driver_exit); MODULE_LICENSE(\"GPL\"); ``` ### 读取事件的应用 ```c #include <stdio.h> #include <unistd.h> #include <fcntl.h> #include <string.h> #include <stdlib.h> #include <linux/input.h> struct input_event button_input_event; int button_status 0; //保存按键状态; int main(int argc, char *argv[]) { int error 20; int button_status 0; /*打开文件*/ int fd open(\"/dev/input/event1\", O_RDONLY); if (fd < 0) { printf(\"open file : /dev/input/event1 error!\\n\"); return 1; } printf(\"wait button down... \\n\"); printf(\"wait button down... \\n\"); do { /*读取按键状态*/ error read(fd, &button_input_event, sizeof(button_input_event)); if (error < 0) { printf(\"read file error! \\n\"); } if((button_input_event.type 1) && (button_input_event.code 2)) { if(button_input_event.value 0) { printf(\"button up\\n\"); } else if(button_input_event.value 1) { printf(\"button down\\n\"); } } } while (1); printf(\"button Down !\\n\"); /*关闭文件*/ error close(fd); if (error < 0) { printf(\"close file error! \\n\"); } return 0; } ``` ## 内核驱动 可以使用gpio keys这个驱动实现类似的效果"},"/note/Linux/野火Linux/2025-10-30-59-Uboot图形配置界面语法.html":{"title":"图形化配置界面","content":"# 图形化配置界面 ## Makefile文件 ```makefile %config: scripts_basic outputmakefile FORCE \t$(Q)$(MAKE) $(build) scripts/kconfig $@ ``` > 实际匹配的命令和加载config命令的是同一个 ```makefile @ make f ./scripts/Makefile.build obj scripts/kconfig menuconfig ``` 实际是使用这个命令进行处理的 ```c menuconfig: $(obj)/mconf \t$< $(silent) $(Kconfig) ``` 实际运行的命令如下 ```makefile menuconfig: scripts/kconfig/mconf \tscripts/kconfig/mconf Kconfig ``` 目标menuconfig 依赖 scripts/kconfig/mconf，因此 scripts/kconfig/mconf.c 这个文件会被编 译，生成mconf这个可执行文件 默认使用的是根文件下面的Kconfig文件 ## Kconfig语法 + `mainmenu`主菜单, 默认打开的界面, `mainmenu \"U Boot $UBOOTVERSION Configuration\" ` + 调用其他目录下的Kconfig, `source \"xxx/Kconfig\" //xxx为具体的目录名，相对路径` + `menu/endmenu`: 生成以及结束一个菜单 + `config`条目: 具体配置项 ```c config CC_OPTIMIZE_FOR_SIZE \tbool \"Optimize for size\" \tdefault y \thelp \t Enabling this option will pass \" Os\" instead of \" O2\" to gcc \t resulting in a smaller U Boot image. \t This option is enabled by default for U Boot. ``` **类型**: bool、tristate、string、hex 和 int，一共 5 种。最常用的是bool、tristate 和 string 这三种，b ool 类型有两种值：y和n，当为y的时候表示使能这个配置项，当为n的时候就禁止这个配置 项。tristate 类型有三种值：y、m和n，其中y和n的涵义与bool类型一样，m表示将这个配置 项编译为模块。string 为字符串类型，所以 LOCALVERSION 是个字符串变量，用来存储本地字符串 **依赖**: 可以使用`depend on`选一下依赖的文件, 也可以使用`select`选择在这个配置以后自动选择的项 + `choice/endchoice ` ``` choice \tprompt \"Architecture select\" \tdefault SANDBOX config ARC \tbool \"ARC architecture\" \tselect HAVE_PRIVATE_LIBGCC \tselect HAVE_GENERIC_BOARD \tselect SYS_GENERIC_BOARD \tselect SUPPORT_OF_CONTROL config ARM \tbool \"ARM architecture\" \tselect CREATE_ARCH_SYMLINK \tselect HAVE_PRIVATE_LIBGCC if !ARM64 \tselect HAVE_GENERIC_BOARD \tselect SYS_GENERIC_BOARD \tselect SUPPORT_OF_CONTROL ... endchoice ``` 将多个类似的配置项组合在一起，供用户单 选或者多选 + `menuconfig`带选项的菜单 ``` menuconfig EXPERT \tbool \"Configure standard U Boot features (expert users)\" \tdefault y \thelp \t This option allows certain base U Boot options and settings \t to be disabled or tweaked. This is for specialized \t environments which can tolerate a \"non standard\" U Boot. \t Only use this if you really know what you are doing. if EXPERT \tconfig SYS_MALLOC_CLEAR_ON_INIT \tbool \"Init with zeros the memory reserved for malloc (slow)\" \tdefault y \thelp \t This setting is enabled by default. The reserved malloc \t memory is initialized with zeros, so first malloc calls \t will return the pointer to the zeroed memory. But this \t slows the boot time. \t It is recommended to disable it, when CONFIG_SYS_MALLOC_LEN \t value, has more than few MiB, e.g. when uses bzip2 or bmp logo. \t Then the boot time can be significantly reduced. \t Warning: \t When disabling this, please check if malloc calls, maybe \t should be replaced by calloc if expects zeroed memory. endif endmenu\t\t# General setup ``` 选择了EXPERT以后会出现下面的配置 + `comment`注释"},"/note/Linux/野火Linux/2025-10-2-50-修改img文件.html":{"title":"修改img文件","content":"# 修改img文件 完整的img镜像(将开发板直接提供的xxx.img.xz镜像文 件解压也能得到img文件)，除了重新编译镜像之外，还有一种方法也能够修改img镜像内部的 内容，将部署应用程序需要的一些程序、脚本等文件直接添加到img镜像中 ## 实际操控 ### 查看信息 可以使用命令`parted imx6ull lubancat carp console armhf 2021 04 08.img`进入img文件里面 在命令行输入`unit b`以及`print`可以查看分区以及大小的信息 ![image 20251002165353095](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510021803825.png) ### 挂载 ```bash sudo mount o loop,offset 46137344 imx6ull lubancat carp console armhf 2021 04 08.img ./dir_img/ ``` 使用上面获取到的位置进行挂载, 接着就可以往挂载了img镜像的目录下添加自己想要的脚本、程序等文件 修改完成之后回到刚刚的目录下取消挂载img镜像的文件系统，取消挂载之后在dir_img目 录下的目录和文件将会消失 ` sudo umount ./dir_img` 此时得到img镜像已经是修改过的img镜像了"},"/note/Linux/野火Linux/2025-11-22-76-Wifi.html":{"title":"Wifi","content":"# Wifi I.MX6U ALPHA开发板目前支持两种接口的 WIFI：USB和 SDIO，其中USBWIFI使用的芯片为 RTL8188EUS或RTL8188CUS，SDIO接口的 WIFI使用芯片为RTL8189FS，也叫做 RTL8189FTV。这两个都是 realtek 公司出品的 WIFI 芯片。WIFI 驱动不需要我们编写，因为realtek公司提供了 WIFI驱动源码，因此我们只需要将 WIFI驱动源码添加到 Linux内核中，然后通过图形化界面配置，选择将其编译成模块即可 linux 内核已经自带了 RTL8192CU/8188CUS 驱动，但是经过测试，linux内核自带的驱动不稳定！因此不建议大家使用。 打开 drivers/net/wireless/rtlwifi/Kconfig删除config RTL8192CU, drivers/net/wireless/rtlwifi/Makefile删除里面的添加 把提供的驱动源码添加到`drivers/net/wireless`目录, 在这个文件夹的Kconfig文件里面添加`source \"drivers/net/wireless/realtek/Kconfig\"`引用, Makefile文件里面添加`obj y + realtek/` ``` > Device Drivers > <*> USB support > <*> Support for Host side USB > <*> EHCI HCD (USB 2.0) support > <*> OHCI HCD (USB 1.1) support > <*> ChipIdea Highspeed Dual Role Controller > [*] ChipIdea device controller > [*] ChipIdea host controller ``` ``` > Device Drivers > [*] Network device support > [*] Wireless LAN > <*> IEEE 802.11 for Host AP (Prism2/2.5/3 and WEP/TKIP/CCMP) > [*] Support downloading firmware images with Host AP driver > [*] Support for non volatile firmware download > Networking support > * Wireless > [*] cfg80211 wireless extensions compatibility > <*> Generic IEEE 802.11 Networking Stack (mac80211) > Device Drivers > Network device support (NETDEVICES [ y]) > Wireless LAN (WLAN [ y]) > Realtek wifi (REALTEK_WIFI [ m]) > rtl8189ftv sdio wifi > rtl8188eus usb wifi > Realtek 8192C USB WiFi ```"},"/note/Linux/野火Linux/2025-7-15-12-驱动设备模型.html":{"title":"elem_attr驱动设备模型","content":"# elem_attr驱动设备模型 ## linux设备驱动模型 ### 应用 创建一个kobject对象, 这个对象里面可以有很多个属性, 分别对应一个文件, 对文件读写操控对应的函数 ```c // 创建一个文件夹 struct kobject *kobject_create_and_add(const char *name, struct kobject *parent); // 添加属性文件 int sysfs_create_group(struct kobject *kobj, const struct attribute_gr释放资源 // 释放资源 void kobject_put(struct kobject *kobj); ``` 使用的参数 ```c static struct kobj_attribute led_attribute // 第一个是名字的字符串, 使用宏定义进行类型的转换 \t__ATTR(led, 0664, led_show, led_store); // 参数的列表 static struct attribute *attrs[] { \t&foo_attribute.attr, \t&led_attribute.attr, \tNULL,\t/* need to NULL terminate the list of attributes */ }; // 实际注册的类型 static struct attribute_group attr_group { \t.attrs attrs, }; ``` ### 概念 #### 为什么需要设备驱动模型 早期内核（2.4之前）没有统一的设备驱动模型，但照样可以用, 需要使用mknod命令在/dev创建驱动文件 2.4~2.6期间使用devfs，挂载在/dev目录。 需要在内核驱动中创建设备文件(可以使用devfs_register函数进行文件的创建)，在代码里面写死命名死板 2.6以后使用sysfs，挂载在/sys目录 将设备分类、分层次统一进行管理 配合udev/mdev守护进程动态创建设备文件，命令规则自由制定, 守护进程监听用户发来的信息 实际控制的是模型的多个属性, 可以进行读写 #### sysfs概述 linux系统通过sysfs体现出设备驱动模型 sysfs是一个虚拟文件系统（类似proc文件系统） **目录**对应的inode节点会记录基本驱动对象(kobject)，从而将系统中的设备组成层次结构 用户可以读写目录下的不同文件来配置驱动对象(kobject)的不同属性 > proc文件系统一般适用于展示任务的信息的 > > rootfs的根文件系统在初始化脚本里面有`echo /sbin/mdev > /proc/sys/kernel/hotplug`把 hotplug 机制的路径设置为 /sbin/mdev > > /proc/sys/kernel/hotplug 是一个内核参数，用于指定当检测到新硬件设备时，内核应调用哪个程序来处理设备的创建与删除（即 hotplug 事件的处理器）。 > /sbin/mdev 是 busybox 或类似工具提供的一个轻量级设备管理器，它负责在设备节点和 /dev 目录之间建立或删除设备节点。它常用于嵌入式系统、内核初始阶段尚未运行 udev 的场景。 #### 设备驱动模型基本元素 kobject：sysfs中的一个目录，常用来表示基本驱动对象，不允许发送消息到用户空间 kset：sysfs中的一个目录，常用来管理kobject，允许发送消息到用户空间 kobj_type：目录下属性文件的操作接口 ### 驱动模型1 ![image 20250718142106602](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507181421091.png) 在 Linux 内核的设备模型中，**`kset`（Kernel Object Set）** 是一个 **管理同类型 `kobject` 的容器**。它本质上是 `kobject` 的集合管理器，用于组织、管理和操作一组逻辑相关的内核对象。 #### kset 的核心作用 1. **逻辑分组** 将具有**相同类型或功能属性**的 `kobject` 归入同一集合（如所有 USB 设备、所有 PCI 设备）。 示例： ``` struct kset *usb_devices_kset; // 所有 USB 设备的集合 ``` 2. **统一管理** 提供对组内对象的批量操作： 遍历所有成员（通过链表 `kobject >entry` 连接）。 递归释放组内所有对象（当 `kset` 自身被释放时）。 3. **sysfs 目录结构** 每个 `kset` 在 sysfs 中对应**一个目录**（如 `/sys/bus/usb/devices/`）。 成员 `kobject` 默认显示在该目录下（除非显式指定 `parent`）。 4. **继承默认行为** 为组内对象提供共享的属性和方法： 通过关联 `ktype`（如所有 USB 设备共享相同的属性文件操作）。 若组内 `kobject` 未单独设置 `ktype`，则继承 `kset >ktype`。 5. **热插拔事件处理** 管理 **uevent** 事件（如设备插入/移除）： 定义 `kset >uevent_ops` 处理事件回调。 统一向用户空间（如 udev）发送事件通知。 1. `*kset` 指针：管理对象集合（横向分组） > **作用**： > 指向一个 **`kset` 对象**，表示当前 `kobject` **所属的集合**。`kset` 是相同类型对象的逻辑分组（如所有 USB 设备、所有 PCI 设备）。 > > **核心功能**： > > **统一管理**：通过 `kset` 可批量操作组内对象（如遍历所有对象、统一释放资源）。 > **定义默认属性**：`kset` 可提供组内对象共享的默认属性和方法（如 `ktype`）。 > **sysfs 组织结构**： > 若 `kobject` 未显式指定 `parent`，则它在 sysfs 中默认出现在 `kset` 对应的目录下。 > 例如：所有 USB 设备（`kobject`）位于 `/sys/bus/usb/devices/`（`kset` 的目录）。 > > **特点**： > 体现对象的 **“分类归属”**（如设备类型、总线类型），强调逻辑分组。 2. `*parent` 指针：构建层次结构（纵向继承） > **作用**： > 指向另一个 **`kobject` 对象**，表示当前对象的 **父对象**，用于构建树形层次结构。 > **核心功能**： > **sysfs 目录结构**： > 当前对象的 sysfs 目录直接位于父对象的目录下（形成路径如 `/sys/devices/parent/child/`）。 > **生命周期管理**： > 父对象被释放时，所有子对象会递归释放（引用计数机制）。 > **设备模型关系**： > 描述物理/逻辑层级（如：USB 鼠标的 `parent` 是 USB 集线器，集线器的 `parent` 是 USB 控制器）。 > **特点**： > 体现对象的 **“从属关系”**（如设备拓扑结构），强调物理/逻辑层级。 #### kset 的数据结构 ```c struct kset { struct list_head list; // 连接所有成员的链表头 spinlock_t list_lock; // 链表操作锁 struct kobject kobj; // 内嵌的 kobject（kset本身也是kobject！） const struct kset_uevent_ops *uevent_ops; // 热插拔事件操作集 }; ``` ### 驱动模型2 ![image 20250718142424444](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507181424565.png) 上层kobject节点无法遍历查找下层kobject ### kobject sysfs中每一个目录都对应一个kobject, 目录里面的文件是实际需要控制的属性 ![image 20250718143722417](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507181437767.png) include/linux/kobject.h ```c struct kobject { \t//用来表示该kobject的名称 \tconst char\t\t*name; \t//链表节点 \tstruct list_head\tentry; \t//该kobject的上层节点，构建kobject之间的层次关系 \tstruct kobject\t\t*parent; \t//该kobject所属的kset对象，用于批量管理kobject对象 \tstruct kset\t\t*kset; \t//该Kobject的sysfs文件系统相关的操作和属性 \tstruct kobj_type\t*ktype; \t//该kobject在sysfs文件系统中对应目录项 \tstruct kernfs_node\t*sd; /* sysfs directory entry */ \t//该kobject的引用次数 \tstruct kref\t\tkref; #ifdef CONFIG_DEBUG_KOBJECT_RELEASE \tstruct delayed_work\trelease; #endif \t//记录内核对象的初始化状态 \tunsigned int state_initialized:1; \t//表示该kobject所代表的内核对象有没有在sysfs建立目录 \tunsigned int state_in_sysfs:1; // 用于发送消息到用户空间 \tunsigned int state_add_uevent_sent:1; \tunsigned int state_remove_uevent_sent:1; \tunsigned int uevent_suppress:1; }; ``` #### kobject_create_and_add() lib/kobject.c + kobject对象的构建 + 构建一个sysfs里面的目录项, kernelfs_node + 关联起来 ```c struct kobject *kobject_create_and_add(const char *name, struct kobject *parent) { \tstruct kobject *kobj; \tint retval; \t/*创建并初始化一个kobject对象*/ \tkobj kobject_create(); \tif (!kobj) \t\treturn NULL; \t/*sysfs创建一个目录项并与kobject对象关联*/ \tretval kobject_add(kobj, parent, \"%s\", name); \tif (retval) { \t\tpr_warn(\"%s: kobject_add error: %d\\n\", __func__, retval); \t\tkobject_put(kobj); \t\tkobj NULL; \t} \treturn kobj; } ``` #### kobject_create()函数 lib/kobject.c 创建一个对象以及初始化他的操作函数 ```c struct kobject *kobject_create(void) { \tstruct kobject *kobj; \t/*动态申请内存，存放kobject对象*/ \tkobj kzalloc(sizeof(*kobj), GFP_KERNEL); \tif (!kobj) \t\treturn NULL; \t// 初始化, 设置实际的操作接口ktype为dynamic_kobj_ktype \tkobject_init(kobj, &dynamic_kobj_ktype); \treturn kobj; } ``` ```c static struct kobj_type dynamic_kobj_ktype { \t.release\t dynamic_kobj_release, \t.sysfs_ops\t &kobj_sysfs_ops, }; ``` ```c // 文件的属性接口, 是一个统一的接口 const struct sysfs_ops kobj_sysfs_ops { \t.show\t kobj_attr_show, \t.store\t kobj_attr_store, }; ``` ##### kobject_init()函数 lib/kobject.c 初始化操作的接口 ```c void kobject_init(struct kobject *kobj, struct kobj_type *ktype) { ... // 初始化一下其他的操作对象 \tkobject_init_internal(kobj); \t/*设置目录属性文件的操作接口*/ \tkobj >ktype ktype; \treturn; ... } ``` ##### kobject_init_internal()函数 lib/kobject.c 初始化一下基础的成员变量, 计数链表初始化 ```c static void kobject_init_internal(struct kobject *kobj) { \tif (!kobj) \t\treturn;\\ \t/*将kobject的引用计数设置为1*/ \tkref_init(&kobj >kref); \t/*初始化链表节点*/ \tINIT_LIST_HEAD(&kobj >entry); \t/*该kobject对象还没和sysfs目录项关联*/ \tkobj >state_in_sysfs 0; \tkobj >state_add_uevent_sent 0; \tkobj >state_remove_uevent_sent 0; \t/*kobject对象的初始化标志*/ \tkobj >state_initialized 1; } ``` #### kobject_add()函数 lib/kobject.c 设置名字参数以及把这个对象和父对象进行链接等 调用: `retval kobject_add(kobj, parent, \"%s\", name);` ```c int kobject_add(struct kobject *kobj, struct kobject *parent,const char *fmt, ...) { \tva_list args; \tint retval; ... \t/*获取第一个可变参数(名字)，可变参数函数的实现与函数传参的栈结构有关*/ \tva_start(args, fmt); \tretval kobject_add_varg(kobj, parent, fmt, args); \tva_end(args); ... \treturn retval; } ``` ##### kobject_add_varg()函数 lib/kobject.c 设置父对象以及设置名字等 ```c static __printf(3, 0) int kobject_add_varg(struct kobject *kobj, \t\t\t\t\t struct kobject *parent, \t\t\t\t\t const char *fmt, va_list vargs) { \tint retval; \tretval kobject_set_name_vargs(kobj, fmt, vargs); \tif (retval) { \t\tpr_err(\"kobject: can not set name properly!\\n\"); \t\treturn retval; \t} \t/*第一次设置kobj的parent指针*/ \tkobj >parent parent; \treturn kobject_add_internal(kobj); } ``` ##### kobject_set_name_vargs()函数 lib/kobject.c 初始化名字参数 ```c int kobject_set_name_vargs(struct kobject *kobj, const char *fmt, \t\t\t\t va_list vargs) { \tconst char *s; \t... \t/*参数格式化打印到s字符串中*/ \ts kvasprintf_const(GFP_KERNEL, fmt, vargs); \t... \t/*设置kobject对象的名称*/ \tkobj >name s; \t... } \t ``` ##### kobject_add_internal()函数 lib/kobject.c 把这个对象和父对象进行连接 ```c static int kobject_add_internal(struct kobject *kobj) { \tstruct kobject *parent; \t... \tparent kobject_get(kobj >parent); \t \tif (kobj >kset) { \t\t/*如果parent为空，parent设置为kobj >kset >kobj*/ \t\tif (!parent) \t\t\tparent kobject_get(&kobj >kset >kobj); \t\t/*把该kobject加入到kset链表的末尾*/ \t\tkobj_kset_join(kobj); \t\t/*第二次设置kobj的parent指针*/ \t\tkobj >parent parent; \t} \t... // 负责创建目录项 \terror create_dir(kobj); \t... \tkobj >state_in_sysfs 1; \t... } ``` ##### create_dir()函数 lib/kobject.c ```c static int create_dir(struct kobject *kobj) { \tconst struct kobj_ns_type_operations *ops; \tint error; \t// 实际的创建函数 \terror sysfs_create_dir_ns(kobj, kobject_namespace(kobj)); \t... } ``` ##### sysfs_create_dir_ns()函数 fs/sysfs/dir.c ```c int sysfs_create_dir_ns(struct kobject *kobj, const void *ns) { \tstruct kernfs_node *parent, *kn; \tkuid_t uid; \tkgid_t gid; \tBUG_ON(!kobj); \t \tif (kobj >parent) \t\t/*获取上一层节点的目录项*/ \t\tparent kobj >parent >sd; \telse \t\t/*设置上一层节点的目录项为sysfs根目录*/ \t\tparent sysfs_root_kn; \tif (!parent) \t\treturn ENOENT; \t// 记录在sysfs文件系统里面 \tkn kernfs_create_dir_ns(parent, kobject_name(kobj), \t\t\t\t S_IRWXU S_IRUGO S_IXUGO, uid, gid, \t\t\t\t kobj, ns); \t... \t/*kobj对象关联sysfs目录项*/ \tkobj >sd kn; \treturn 0; } ``` ##### kernfs_create_dir_ns()函数 ```c struct kernfs_node *kernfs_create_dir_ns(struct kernfs_node *parent, \t\t\t\t\t const char *name, umode_t mode, \t\t\t\t\t kuid_t uid, kgid_t gid, \t\t\t\t\t void *priv, const void *ns) { \tstruct kernfs_node *kn; \tint rc; \t/* allocate */ \tkn kernfs_new_node(parent, name, mode S_IFDIR, \t\t\t uid, gid, KERNFS_DIR); \t... \t/*sysfs目录项关联kobject对象*/ \tkn >priv priv; // 记录的是kobject对象 \t... } ``` ##### kernfs_new_node()函数 ```c struct kernfs_node *kernfs_new_node(struct kernfs_node *parent, \t\t\t\t const char *name, umode_t mode, \t\t\t\t kuid_t uid, kgid_t gid, \t\t\t\t unsigned flags) { \tstruct kernfs_node *kn; \tkn __kernfs_new_node(kernfs_root(parent), \t\t\t name, mode, uid, gid, flags); \tif (kn) { \t\tkernfs_get(parent); \t\tkn >parent parent; \t} \treturn kn; } ``` ### kset 对应一个目录, 可以用于管理多个子目录 ```c struct kset { \t//用来将起中的object对象构建成链表 \tstruct list_head list; \t//自旋锁 \tspinlock_t list_lock; \t//当前kset内核对象的kobject变量 \tstruct kobject kobj; \t//定义了一组函数指针，当kset中的某些kobject对象发生状态变化需要通知用户空间时，调用其中的函数来完成 \tconst struct kset_uevent_ops *uevent_ops; } ``` ### kobj_type 目录文件的操作接口, 初始化的时候注册在kobject里面 ```c struct kobj_type { \t//销毁kobject对象时调用 \tvoid (*release)(struct kobject *kobj); \t//kobject对象属性文件统一操作接口, 之后调用不同属性的具体接口 \tconst struct sysfs_ops *sysfs_ops; \t//kobject默认属性文件的名字、\"文件具体操作接口\" \tstruct attribute **default_attrs; \tconst struct kobj_ns_type_operations *(*child_ns_type)(struct kobject *kobj); \tconst void *(*namespace)(struct kobject *kobj); \tvoid (*get_ownership)(struct kobject *kobj, kuid_t *uid, kgid_t *gid); }; ``` #### kobj_type：用户空间的法宝 为kobject对象构建多个**属性文件** 为每个属性文件设置具体操作接口 vfs的inode对象与sysfs的kernfs_node对象的绑定过程, 使得文件系统可以直接控制 ![image 20250718235010661](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507182350766.png) #### 重点 关注属性文件具体操作接口的赋值过程 关注open()、read()、write函数的底层机制 ### 属性 #### 第一阶段：属性文件操作接口赋值 ##### sysfs_create_group()函数 fs/sysfs/group.c 创建属性文件以及和文件接口的绑定 ```c int sysfs_create_group(struct kobject *kobj, \t\t const struct attribute_group *grp) { \treturn internal_create_group(kobj, 0, grp); } ``` attribute_group结构体： include/linux/sysfs.h ![image 20250718235047632](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507182350775.png) ```c struct attribute_group { \tconst char\t\t*name; \tumode_t\t\t\t(*is_visible)(struct kobject *, \t\t\t\t\t struct attribute *, int); \tumode_t\t\t\t(*is_bin_visible)(struct kobject *, \t\t\t\t\t\t struct bin_attribute *, int); \tstruct attribute\t**attrs; // 一个attribute的指针数组, 记录属性 \tstruct bin_attribute\t**bin_attrs; }; ``` struct attribute结构体： include/linux/sysfs.h ```c // 一个属性 struct attribute { \tconst char\t\t*name; \tumode_t\t\t\tmode; // 属性文件的权限 }; ``` kobj_attribute结构体 ```c // 实际使用的属性 struct kobj_attribute { \tstruct attribute attr; // 实际的操作接口 \tssize_t (*show)(struct kobject *kobj, struct kobj_attribute *attr, \t\t\tchar *buf); \tssize_t (*store)(struct kobject *kobj, struct kobj_attribute *attr, \t\t\t const char *buf, size_t count); }; ``` ##### internal_create_group()函数 ![image 20250718235130790](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507182351866.png) fs/sysfs/group.c 把一个kobject和属性建立关系 ```c tatic int internal_create_group(struct kobject *kobj, int update, \t\t\t\t const struct attribute_group *grp) { \tstruct kernfs_node *kn; \tkuid_t uid; \tkgid_t gid; \tint error; \t \t... \tif (grp >name) \t... \telse \t\tkn kobj >sd; // 获取目录项 ... // 文件的目录节点, 所属的用户以及组等信息 error create_files(kn, kobj, uid, gid, grp, update); ... }\t ``` ##### create_files()函数 fs/sysfs/group.c 依次个每个属性建立文件 ```c static int create_files(struct kernfs_node *parent, struct kobject *kobj, \t\t\tkuid_t uid, kgid_t gid, \t\t\tconst struct attribute_group *grp, int update) { \tstruct attribute *const *attr; \tstruct bin_attribute *const *bin_attr; \tint error 0, i; \tif (grp >attrs) { \t\tfor (i 0, attr grp >attrs; *attr && !error; i++, attr++) { // 遍历所有属性, 属性以及权限是自己设置的 \t\t\tumode_t mode (*attr) >mode; \t\t\t... \t\t\terror sysfs_add_file_mode_ns(parent, *attr, false, \t\t\t\t\t\t mode, uid, gid, NULL); \t\t\t... \t\t\t} \t... } ``` ##### sysfs_add_file_mode_ns()函数 fs/sysfs/file.c 获取一下实际的操作函数 ```c int sysfs_add_file_mode_ns(struct kernfs_node *parent, \t\t\t const struct attribute *attr, bool is_bin, \t\t\t umode_t mode, kuid_t uid, kgid_t gid, const void *ns) { \tstruct lock_class_key *key NULL; \tconst struct kernfs_ops *ops; \tstruct kernfs_node *kn; \tloff_t size; \t// 参数是false, 一定进入 \tif (!is_bin) { \t\tstruct kobject *kobj parent >priv; \t\t/*kobj_sysfs_ops 初始化默认的属性操作函数*/ \t\tconst struct sysfs_ops *sysfs_ops kobj >ktype >sysfs_ops; \t\t... // 默认初始化的两个函数 \t\tif (sysfs_ops >show && sysfs_ops >store) { \t\t\tif (mode & SYSFS_PREALLOC) \t\t\t\tops &sysfs_prealloc_kfops_rw; \t\t\telse // 实际初始化的操作接口 \t\t\t\tops &sysfs_file_kfops_rw; \t\telse if \t\t\t... \t\t} \t... // 实际创建文件的位置 \tkn __kernfs_create_file(parent, attr >name, mode & 0777, uid, gid, \t\t\t\t size, ops, (void *)attr, ns, key); ... } ``` kernfs_ops节点的操作函数 `ops &sysfs_file_kfops_rw;`初始化的操作函数, 最后赋值给kernelfs_node的节点 ```c static const struct kernfs_ops sysfs_file_kfops_rw { \t.seq_show\t sysfs_kf_seq_show, \t.write\t\t sysfs_kf_write, }; ``` ##### __kernfs_create_file()函数 为每一个属性创建一个kernfs_node文件 ```c struct kernfs_node *__kernfs_create_file(struct kernfs_node *parent, \t\t\t\t\t const char *name, \t\t\t\t\t umode_t mode, kuid_t uid, kgid_t gid, \t\t\t\t\t loff_t size, \t\t\t\t\t const struct kernfs_ops *ops, \t\t\t\t\t void *priv, const void *ns, \t\t\t\t\t struct lock_class_key *key) { \tstruct kernfs_node *kn; \tunsigned flags; \tint rc; \tflags KERNFS_FILE; \t// 建立一个新的节点 \tkn kernfs_new_node(parent, name, (mode & S_IALLUGO) S_IFREG, \t\t\t uid, gid, flags); \tif (!kn) \t\treturn ERR_PTR( ENOMEM); \t/*给这一个节点的操作接口赋值*/ \tkn >attr.ops ops; \tkn >attr.size size; \tkn >ns ns; \t/*文件属性赋值*/ \tkn >priv priv; // 实际的前一级是一个attribute \t \tif (ops >seq_show) \t\tkn >flags KERNFS_HAS_SEQ_SHOW; \t... } ``` #### 第二阶段：open()\\read()\\write()的底层机制 **设置参数的相关的部分**, 使用对于参数的控制实现操作 ![image 20250718235348248](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507182353345.png) 在 Linux 内核的 `kernfs` 子系统（用于 sysfs、cgroupfs 等）中，当用户空间进程与一个 `kernfs_node`（代表文件、目录、符号链接等）进行交互（特别是打开和读写文件）时，涉及到的结构体 `inode`, `kernfs_open_file`, `file`, `seq_file`, `seq_operations` 扮演着关键角色。它们协同工作，将 VFS 层的操作路由到具体的 `kernfs` 实现。以下是它们建立关系和发挥作用的过程： 1. **`kernfs_node` (核心实体):** 这是 `kernfs` 文件系统的基石，代表文件系统中的一个对象（文件、目录、符号链接、属性）。 它包含： 名称、父节点、操作权限等元数据。 一个指向 `kernfs_ops` 结构体的指针 (`kernfs_ops *ops`)。这个结构体定义了该节点类型（特别是文件节点）的核心操作： `open`：可选，当文件被打开时调用。 `release`：可选，当文件被关闭时调用。 `read` / `write`：**传统模式**的直接读写函数。 `seq_show` / `seq_start` / `seq_next` / `seq_stop`：**seq_file 模式**的函数，用于实现顺序、迭代式读取（常用于输出内核数据结构）。 `mmap`：内存映射操作。 节点特定的私有数据 (`void *priv`)。 2. **`inode` (VFS 索引节点):** 当 `kernfs_node`（特别是文件节点）被查找或创建时，`kernfs` 会为其在内存中创建一个对应的 VFS `inode` 结构体（通过 `kernfs_get_inode`）。 这个 `inode` 的 `i_private` 字段会被设置为指向它所代表的 `kernfs_node` (`kn`)。 `inode` 的 `i_fop` (文件操作) 字段会被设置为 `kernfs` 定义的通用文件操作结构体 `kernfs_file_operations`。 **作用:** 在 VFS 层代表 `kernfs_node`。当 VFS 操作（如 `open`, `read`, `write`）作用在这个 `inode` 上时，VFS 会调用 `i_fop` 中注册的函数，这些函数由 `kernfs` 提供，并将操作路由到具体的 `kernfs_node` 及其 `kernfs_ops`。 3. **`file` (VFS 文件对象):** 当用户空间**进程**调用 `open()` 打开一个由 `kernfs_node` 代表的文件时，VFS 会创建一个 `file` 结构体来表示这次“打开”的实例。 这个 `file` 结构体的 `private_data` 字段至关重要。 VFS 会调用该文件对应 `inode >i_fop >open()` 函数。对于 `kernfs`，这个函数是 `kernfs_fop_open`。 **`kernfs_fop_open` 的关键作用 (建立桥梁):** 1. 通过 `file >f_inode >i_private` 获取对应的 `kernfs_node` (`kn`)。 2. 分配一个 `kernfs_open_file` 结构体 (`of`)。 3. 将 `of >kn` 设置为 `kn` (关联 `kernfs_node`)。 4. 将 `file >private_data` 设置为 `of` (关联 `file` 和 `kernfs_open_file`)。 5. 检查 `kn >attr.ops` (`kernfs_ops`)： 如果定义了 `kn >attr.ops >open`，则调用它。 如果定义了 `kn >attr.ops >seq_show` (表明使用 seq_file 模式)，则调用 `seq_open(file, &kernfs_seq_ops)`。这个函数： 分配一个 `seq_file` 结构体 (`seq`)。 将 `seq >private` 设置为 `of` (关联 `seq_file` 和 `kernfs_open_file`)。 将 `file >private_data` **覆盖**为指向这个 `seq_file` 结构体 (`seq`)。*(注意：此时 `file >private_data` 指向 `seq`，而 `seq >private` 指向 `of`，`of >kn` 指向 `kn`)* 设置 `seq >op` 为 `&kernfs_seq_ops` (一个 `seq_operations` 结构体，其函数内部会再路由到 `kernfs_open_file` 和 `kernfs_ops`)。 否则（传统模式），`file >private_data` 保持指向 `of`。 4. **`kernfs_open_file` (Per open file 状态):** 表示一个 `kernfs_node` 文件被**打开一次**的上下文信息。 关键字段： `kn`: 指向关联的 `kernfs_node`。 `file`: 指向关联的 VFS `file` 结构体。 `priv`: 可选的私有数据，可由 `kernfs_ops >open` 设置，供后续操作（`read`/`write`/`seq_show` 等）使用。 `atomic_write_len`: 原子写长度（如果适用）。 `mutex`: 保护该打开文件状态的互斥锁（用于防止并发读写冲突）。 **作用:** 维护特定于这次文件打开操作的状态（如 `priv` 数据）。它是连接 VFS `file` 和底层 `kernfs_node` 及其操作的核心中间结构。无论是传统模式还是 seq_file 模式，最终的操作都需要通过它来访问 `kn` 和可能的 `priv` 数据。 5. **`seq_file` (序列文件抽象):** 当 `kernfs_ops` 定义了 `seq_show` 时，`kernfs_fop_open` 会调用 `seq_open` 创建一个 `seq_file` 结构体。 该结构体管理顺序、迭代读取的状态。它处理缓冲区、游标位置、迭代状态机等。 关键字段： `buf`: 内核缓冲区，用于累积要输出到用户空间的数据。 `size` / `from` / `count` / `index`: 缓冲区管理和迭代状态。 `op`: 指向 `seq_operations` 结构体 (这里是 `&kernfs_seq_ops`)。 `private`: 指向与之关联的 `kernfs_open_file` (`of`)。 **作用:** 为需要迭代输出大量或结构化数据（如链表、数组）的 `kernfs` 文件提供标准化的、更简单的编程接口 (`seq_operations`)。它处理了缓冲区管理、多次调用 (`start`/`next`/`show`/`stop`) 的协调等复杂性。 6. **`seq_operations` (序列文件操作):** 这是一个包含函数指针的结构体 (`start`, `next`, `show`, `stop`)，定义了如何遍历和显示序列中的元素。 在 `kernfs` 的 seq_file 模式下，它被设置为 `kernfs_seq_ops`。 `kernfs_seq_ops` 的函数实现 (`kernfs_seq_start`, `kernfs_seq_next`, `kernfs_seq_stop`, `kernfs_seq_show`) 充当适配器： 1. 它们通过 `seq_file >private` 获取 `kernfs_open_file *of`。 2. 它们通过 `of >kn` 获取 `kernfs_node *kn`。 3. 它们最终调用 `kn >attr.ops` (`kernfs_ops`) 中定义的对应 seq_file 函数： `kernfs_seq_start` > 调用 `ops >seq_start(of, &pos)` (如果定义了)，否则处理简单的单次输出。 `kernfs_seq_next` > 调用 `ops >seq_next(of, v, &pos)` (如果定义了)。 `kernfs_seq_show` > 调用 `ops >seq_show(of, v)` **(核心输出函数！)**. `kernfs_seq_stop` > 调用 `ops >seq_stop(of, v)` (如果定义了)。 **作用:** 提供 VFS seq_file 子系统期望的通用接口 (`seq_operations`)，并将这些通用调用**适配**到具体的 `kernfs_node` 的 `kernfs_ops` 中定义的 seq_file 操作函数上。`kernfs_seq_show` 是核心，它调用 `ops >seq_show` 来生成文件的实际内容。 ##### kernfs_init_inode()函数 进行inode以及kernfs_node的关联, 实际是在open函数的时候进行的 ```c static void kernfs_init_inode(struct kernfs_node *kn, struct inode *inode) { \tkernfs_get(kn); \t/*sysfs的kernels_node赋值给vfs的inode*/ \tinode >i_private kn; // 使用这个函数记录关联 \tinode >i_mapping >a_ops &kernfs_aops; \tinode >i_op &kernfs_iops; \tinode >i_generation kn >id.generation; \tset_default_inode_attr(inode, kn >mode); \tkernfs_refresh_inode(kn, inode); \t/* 判断sysfs的kernels_node类型 */ \tswitch (kernfs_type(kn)) { \tcase KERNFS_DIR: \t\tinode >i_op &kernfs_dir_iops; \t\tinode >i_fop &kernfs_dir_fops; \t\tif (kn >flags & KERNFS_EMPTY_DIR) \t\t\tmake_empty_dir_inode(inode); \t\tbreak; \tcase KERNFS_FILE: // 属性分支 \t\tinode >i_size kn >attr.size; \t\t/*文件的操作接口*/ \t\tinode >i_fop &kernfs_file_fops; // 初始化一下各种实际的操作指针 \t\tbreak; \tcase KERNFS_LINK: \t\tinode >i_op &kernfs_symlink_iops; \t\tbreak; \tdefault: \t\tBUG(); \t} \tunlock_new_inode(inode); } ``` ```c // 最先调用的函数 const struct file_operations kernfs_file_fops { \t.read\t\t kernfs_fop_read, \t.write\t\t kernfs_fop_write, \t.llseek\t\t generic_file_llseek, \t.mmap\t\t kernfs_fop_mmap, \t.open\t\t kernfs_fop_open, \t.release\t kernfs_fop_release, \t.poll\t\t kernfs_fop_poll, \t.fsync\t\t noop_fsync, }; ``` ##### kernfs_fop_open()函数 初始化kernfs_open_file结构 ```c static int kernfs_fop_open(struct inode *inode, struct file *file) { \tstruct kernfs_node *kn inode >i_private; // sysfs的node, 是kernfs_node类 \tstruct kernfs_open_file *of; \t... \tof kzalloc(sizeof(struct kernfs_open_file), GFP_KERNEL); \t... \t/*sysfs中文件的kernfs_node赋值给of >kn*/ \tof >kn kn; \t/*进程的struct file赋值给of >file*/ \tof >file file; \t... // 这里获取到的是kernfs_node里面的attr属性的ops参数 \tif (ops >seq_show) \t\terror seq_open(file, &kernfs_seq_ops); \t... \t/*struct file的私有指针赋值给of >seq_file */ \tof >seq_file file >private_data; \t/*of赋值给of >seq_file >private*/ \tof >seq_file >private of; \t... } ``` // 记录的是fs系统的操作 ```c static const struct seq_operations kernfs_seq_ops { \t.start kernfs_seq_start, \t.next kernfs_seq_next, \t.stop kernfs_seq_stop, \t.show kernfs_seq_show, }; ``` seq_open ```c int seq_open(struct file *file, const struct seq_operations *op) { \tstruct seq_file *p; \tWARN_ON(file >private_data); \tp kmem_cache_zalloc(seq_file_cache, GFP_KERNEL); \tif (!p) \t\treturn ENOMEM; \t \tfile >private_data p; \t... \tp >op op; \t... } ``` ##### kernfs_fop_read()函数 用于调用之前设置的 seq_operations里面的show函数 ```c static ssize_t kernfs_fop_read(struct file *file, char __user *user_buf, \t\t\t size_t count, loff_t *ppos) { \tstruct kernfs_open_file *of kernfs_of(file); \t// 创建的时候设置的这个标志位 \tif (of >kn >flags & KERNFS_HAS_SEQ_SHOW) // 实际的读取函数 \t\treturn seq_read(file, user_buf, count, ppos); \telse \t\treturn kernfs_file_direct_read(of, user_buf, count, ppos); } ``` ##### kernfs_of()函数 获取一个file结构体和sysfs连接的kernfs_open_file结构 ```c static struct kernfs_open_file *kernfs_of(struct file *file) { \treturn ((struct seq_file *)file >private_data) >private; } ``` ##### seq_read()函数 ```c ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos) { \tstruct seq_file *m file >private_data; \t... \terr m >op >show(m, p); // 实际是kernfs_seq_show函数 \t... \terr copy_to_user(buf, m >buf, n); \t... } ``` ##### kernfs_seq_show()函数 ![image 20250719000819498](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507190008624.png) ```c static int kernfs_seq_show(struct seq_file *sf, void *v) { \tstruct kernfs_open_file *of sf >private; \t... \treturn of >kn >attr.ops >seq_show(sf, v); // 调用的是sysfs_kf_seq_show } ``` ##### sysfs_kf_seq_show()函数 这里的seq_file实际就是和用户空间通信使用的, 记录读取的数据缓冲区等 ![image 20250719001258975](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507190012035.png) ```c static int sysfs_kf_seq_show(struct seq_file *sf, void *v) { \tstruct kernfs_open_file *of sf >private; \tstruct kobject *kobj of >kn >parent >priv; \tconst struct sysfs_ops *ops sysfs_file_ops(of >kn); \tssize_t count; \tchar *buf; \t// 获取一个缓冲区buf \tcount seq_get_buf(sf, &buf); \tif (count < PAGE_SIZE) { \t\tseq_commit(sf, 1); \t\treturn 0; \t} \tmemset(buf, 0, PAGE_SIZE); \t/* \t * Invoke show(). Control may reach here via seq file lseek even \t * if @ops >show() isn't implemented. \t */ \tif (ops >show) { // 实际是sysfs_kf_seq_show, 使用属性的上一级节点, 获取kobject \t\tcount ops >show(kobj, of >kn >priv, buf); // 使用这个文件对用的属性进行读取kobj_attr_show \t\tif (count < 0) \t\t\treturn count; \t} \t/* \t * The code works fine with PAGE_SIZE return but it's likely to \t * indicate truncated result or overflow in normal use cases. \t */ \tif (count > (ssize_t)PAGE_SIZE) { \t\tprintk(\"fill_read_buffer: %pS returned bad count\\n\", \t\t\t\tops >show); \t\t/* Try to struggle along */ \t\tcount PAGE_SIZE 1; \t} \tseq_commit(sf, count); \treturn 0; } ``` ##### sysfs_file_ops()函数 获取到最初的kobject的sysfs_ops, 实际是kobj_sysfs_ops函数 ```c static const struct sysfs_ops *sysfs_file_ops(struct kernfs_node *kn) { \tstruct kobject *kobj kn >parent >priv; \tif (kn >flags & KERNFS_LOCKDEP) \t\tlockdep_assert_held(kn); \treturn kobj >ktype ? kobj >ktype >sysfs_ops : NULL; } ``` ##### seq_get_buf()函数 在seq_file里面有一个buf, 用于和用户通信 ```c static inline size_t seq_get_buf(struct seq_file *m, char **bufp) { \tBUG_ON(m >count > m >size); \tif (m >count < m >size) \t\t*bufp m >buf + m >count; // 缓冲区加偏移 \telse \t\t*bufp NULL; \treturn m >size m >count; } ``` #### kobj_attr_show()函数 最终的获取属性的位置 ```c static ssize_t kobj_attr_show(struct kobject *kobj, struct attribute *attr,char *buf) { \tstruct kobj_attribute *kattr; \tssize_t ret EIO; \t/*根据结构体成员的内存地址获取结构体的地址*/ \tkattr container_of(attr, struct kobj_attribute, attr); \tif (kattr >show) \t\tret kattr >show(kobj, kattr, buf);// 用户自己初始化的show属性 \treturn ret; } ``` ## 实际应用 ### 实验思路 内核模块+led驱动+kobject+kobj_attribute 首先使用函数`kobject_create_and_add`创建一个kobject对象, 之后使用`sysfs_create_group`添加对应的参数 #### 内核模块 动态加载功能 #### led驱动 控制硬件led #### kobject 在/sys创建目录项 #### kobj_attribute 为kobject对象的属性文件提供独有的读写接口 ### 代码示例 ```c #include <linux/module.h> #include <linux/init.h> #include <linux/kernel.h> #include <linux/kobject.h> #include <linux/string.h> #include <linux/sysfs.h> #include <linux/fs.h> #include <linux/uaccess.h> #include <asm/io.h> #define DEV_MAJOR\t\t0\t\t/* 动态申请主设备号 */ #define DEV_NAME\t\t\"red_led\" \t/*led设备名字 */ /* GPIO虚拟地址指针 */ static void __iomem *IMX6U_CCM_CCGR1; static void __iomem *SW_MUX_GPIO1_IO04; static void __iomem *SW_PAD_GPIO1_IO04; static void __iomem *GPIO1_DR; static void __iomem *GPIO1_GDIR; static int foo; static ssize_t foo_show(struct kobject *kobj, struct kobj_attribute *attr, \t\t\tchar *buf) { \treturn sprintf(buf, \"%d\\n\", foo); } static ssize_t foo_store(struct kobject *kobj, struct kobj_attribute *attr, \t\t\t const char *buf, size_t count) { \tint ret; \t// 使用10进制的格式进行读取 \tret kstrtoint(buf, 10, &foo); \tif (ret < 0) \t\treturn ret; \treturn count; } // 第一个参数是名字会被转换为字符串, 第二个是文件的权限, 后面的是读写的函数 static struct kobj_attribute foo_attribute \t__ATTR(foo, 0664, foo_show, foo_store); static ssize_t led_show(struct kobject *kobj, struct kobj_attribute *attr, \t\t char *buf) { \tint var; \tif (strcmp(attr >attr.name, \"led\") 0) \t\t\tvar 123; \treturn sprintf(buf, \"%d\\n\", var); } static ssize_t led_store(struct kobject *kobj, struct kobj_attribute *attr, \t\t const char *buf, size_t count) { \tif (strcmp(attr >attr.name, \"led\") 0){ \t\tif(!memcmp(buf,\"on\",2)) {\t \t\t\tiowrite32(0 << 4, GPIO1_DR);\t \t\t} else if(!memcmp(buf,\"off\",3)) { \t\t\tiowrite32(1 << 4, GPIO1_DR); \t\t} \t} \treturn count; } static struct kobj_attribute led_attribute // 第一个是名字的字符串, 使用宏定义进行类型的转换 \t__ATTR(led, 0664, led_show, led_store); static struct attribute *attrs[] { \t&foo_attribute.attr, \t&led_attribute.attr, \tNULL,\t/* need to NULL terminate the list of attributes */ }; static struct attribute_group attr_group { \t.attrs attrs, }; static struct kobject *led_kobj; static int __init led_init(void) { \tint retval; \t/* GPIO相关寄存器映射 */ IMX6U_CCM_CCGR1 ioremap(0x20c406c, 4); \tSW_MUX_GPIO1_IO04 ioremap(0x20e006c, 4); SW_PAD_GPIO1_IO04 ioremap(0x20e02f8, 4); \tGPIO1_GDIR ioremap(0x0209c004, 4); \tGPIO1_DR ioremap(0x0209c000, 4); \t/* 使能GPIO1时钟 */ \tiowrite32(0xffffffff, IMX6U_CCM_CCGR1); \t/* 设置GPIO1_IO04复用为普通GPIO*/ \tiowrite32(5, SW_MUX_GPIO1_IO04); \t /*设置GPIO属性*/ \tiowrite32(0x10B0, SW_PAD_GPIO1_IO04); \t/* 设置GPIO1_IO04为输出功能 */ \tiowrite32(1 << 4, GPIO1_GDIR); \t/* LED输出高电平 */ \tiowrite32(1<< 4, GPIO1_DR); \t/* 创建一个kobject对象, 目录在sys的根目录*/ \tled_kobj kobject_create_and_add(\"led_kobject\", NULL); \tif (!led_kobj) \t\treturn ENOMEM; \t/* 为kobject设置属性文件*/ \tretval sysfs_create_group(led_kobj, &attr_group); \tif (retval) \t\tkobject_put(led_kobj); \treturn retval; \treturn 0; } static void __exit led_exit(void) { \t/* 取消映射 */ \tiounmap(IMX6U_CCM_CCGR1); \tiounmap(SW_MUX_GPIO1_IO04); \tiounmap(SW_PAD_GPIO1_IO04); \tiounmap(GPIO1_DR); \tiounmap(GPIO1_GDIR); \t/* 注销字符设备驱动 */ \tkobject_put(led_kobj); } module_init(led_init); module_exit(led_exit); MODULE_LICENSE(\"GPL\"); MODULE_AUTHOR(\"embedfire \"); MODULE_DESCRIPTION(\"led_module\"); MODULE_ALIAS(\"led_module\"); ``` ```c #define __ATTR(_name, _mode, _show, _store) {\t\t\t\t\\ \t.attr {.name __stringify(_name),\t\t\t\t\\ \t\t .mode VERIFY_OCTAL_PERMISSIONS(_mode) },\t\t\\ \t.show\t _show,\t\t\t\t\t\t\\ \t.store\t _store,\t\t\t\t\t\t\\ } /* Indirect stringification. Doing two levels allows the parameter to be a * macro itself. For example, compile with DFOO bar, __stringify(FOO) * converts to \"bar\". */ #define __stringify_1(x...)\t#x #define __stringify(x...)\t__stringify_1(x) /* Permissions on a sysfs file: you didn't miss the 0 prefix did you? */ #define VERIFY_OCTAL_PERMISSIONS(perms)\t\t\t\t\t\t\\ \t(BUILD_BUG_ON_ZERO((perms) < 0) +\t\t\t\t\t\\ \t BUILD_BUG_ON_ZERO((perms) > 0777) +\t\t\t\t\t\\ \t /* USER_READABLE > GROUP_READABLE > OTHER_READABLE */\t\t\\ \t BUILD_BUG_ON_ZERO((((perms) >> 6) & 4) < (((perms) >> 3) & 4)) +\t\\ \t BUILD_BUG_ON_ZERO((((perms) >> 3) & 4) < ((perms) & 4)) +\t\t\\ \t /* USER_WRITABLE > GROUP_WRITABLE */\t\t\t\t\t\\ \t BUILD_BUG_ON_ZERO((((perms) >> 6) & 2) < (((perms) >> 3) & 2)) +\t\\ \t /* OTHER_WRITABLE? Generally considered a bad idea. */\t\t\\ \t BUILD_BUG_ON_ZERO((perms) & 2) +\t\t\t\t\t\\ \t (perms)) #endif ``` ![image 20250719130531021](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507191305098.png)"},"/note/Linux/野火Linux/2025-9-25-28-阻塞和非阻塞IO.html":{"title":"阻塞和非阻塞IO","content":"# 阻塞和非阻塞IO ## 使用 + 定义并初始化一个等待队列使用`init_waitqueue_head`或者使用`DECLARE_WAIT_QUEUE_HEAD(name, tsk)`一次性初始化以及定义 + 初始化等待队列项`DECLARE_WAITQUEUE(name, tsk)`使用`add_wait_queue`进行等待 + 或者添加`wait_event`进行等待事件 + 获取到相应的资源以后唤醒`wake_up` + 被唤醒的资源需要处理是否为信号的判断 #### IO操作 数据读取/发送 #### 两个阶段 用户空间< >内核空间 内核空间< >file_operation #### 阻塞操作 请求的资源没有准备好，进程/线程睡眠等待，直到数据准备完毕 ![image 20200904164240430](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509251452576.png) #### 非阻塞操作 请求的资源没有准备好，直接返回错误信息 ![image 20200904164346909](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509251452336.png) #### O_NONBLOCK open函数的非阻塞标志 ## 非阻塞实际使用 ```c /*字符设备操作函数集，open函数*/ static int led_chr_dev_open(struct inode *inode, struct file *filp) { \tif(filp >f_flags &O_NONBLOCK) \t{ \t\tif(down_trylock(&sem)) \t\t{ \t\t\treturn EBUSY; \t\t} \t} \telse \t\tdown(&sem); \tprintk(\"\\n open form driver \\n\"); \treturn 0; } ``` ## 设备驱动的阻塞IO：等待队列 请求数据没有准备好时，让该进程睡眠直到数据准备好为止 #### 等待队列头 include/linux/wait.h ```c struct wait_queue_head { \tspinlock_t\t\tlock; \tstruct list_head\thead; }; typedef struct wait_queue_head wait_queue_head_t; ``` #### 初始化等待队列头 ##### init_waitqueue_head() include/linux/wait.h ```c #define init_waitqueue_head(wq_head)\t\t\t\t\t\t \\ \tdo {\t\t\t\t\t\t\t\t\t\t\t\t\t\\ \t\tstatic struct lock_class_key __key;\t\t\t\t \t \\ \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\ \t\t__init_waitqueue_head((wq_head), #wq_head, &__key);\t\t \\ \t} while (0) ``` ##### 静态定义并初始化 一个函数实现以上的内容 ``` #define DECLARE_WAIT_QUEUE_HEAD(name) \\ \tstruct wait_queue_head name __WAIT_QUEUE_HEAD_INITIALIZER(name) ``` #### 等待队列元素 include/linux/wait.h ```c struct wait_queue_entry { \tunsigned int\t\tflags; \tvoid\t\t\t*private; \twait_queue_func_t\tfunc; \tstruct list_head\tentry; // 使用这个节点进行连接 }; typedef struct wait_queue_entry wait_queue_entry_t ``` #### 初始化静态队列 ##### 静态定义并初始化 include/linux/wait.h ```c #define DECLARE_WAITQUEUE(name, tsk)\t\t\t\t\t\t\\ \tstruct wait_queue_entry name __WAITQUEUE_INITIALIZER(name, tsk) ``` > tsk表示这个等待队列项属于哪个任务(进程)，一般设置为`current`，在 Linux内核中 `current` 相当于一个全局变量，表示当前进程 #### 添加等待队列 add_wait_queue()函数, 可以和wait_event函数二选一 kernel/sched/wait.c ```c void add_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry); ``` 参数： q ：等待队列项要加入的等待队列头。 wq_entry：要加入的等待队列项。 返回值：无 > 在这个函数调用之后可以使用`__set_current_state(TASK_INTERRUPTIBLE)`设置这个任务可以被信号打断, 之后使用`schedule()`切换任务下面在运行的都是唤醒以后的, 需要处理运行到这了的原因 > > 示例: > > ```c > __set_current_state(TASK_RUNNING); > remove_wait_queue(&port >delta_msr_wait, &wait); > /* see if a signal did it 判断是不是被信号打断 */ > if (signal_pending(current)) { > ret ERESTARTSYS; > return ret; > } > ``` #### 移除等待队列 remove_wait_queue()函数 kernel/sched/wait.c ```c void remove_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq_entry); ``` 参数： q ：等待队列项要加入的等待队列头。 wq_entry：要删除的等待队列项。 返回值：无 #### 等待事件 include/linux/wait.h ```c wait_event(wq_head, condition) // 进入睡眠 屏蔽信号 wait_event_interruptible(wq_head, condition) // 可以被信号唤醒 wait_event_timeout(wq_head, condition, timeout)\t ``` 参数： wq_head ：等待队列项要加入的等待队列头。 condition：唤醒条件, 是一个bool条件, 在被wakeup的时候会判断这个变量 timeout：超时时间 #### 等待唤醒 kernel/sched/wait.c 唤醒, 同时需要保证之前的condition为1 ```c void wake_up(wait_queue_head_t *q) void wake_up_interruptible(wait_queue_head_t *q) ``` 参数： q 就是要唤醒的等待队列头 返回值：无 ## 实际使用 ```c wait_queue_head_t wait_queue; unsigned int write_data; //用于保存接收到的数据 /*字符设备操作函数集，open函数*/ static int led_chr_dev_open(struct inode *inode, struct file *filp) { \tprintk(\"\\n open form driver \\n\"); \treturn 0; } /*字符设备操作函数集，write函数*/ static ssize_t led_chr_dev_write(struct file *filp, const char __user *buf, size_t cnt, loff_t *offt) { \tint ret,error; \tunsigned char receive_data[10]; //用于保存接收到的数据 \t \tif(cnt>10) \t\t\tcnt 10; \terror copy_from_user(receive_data, buf, cnt); \tif (error < 0) \t{ \t\treturn 1; \t} \t// 获取的数据转换为int类型 \tret kstrtoint(receive_data, 16, &write_data); \tif (ret) { \t\treturn 1; } \tif(write_data) \t{ // 不是1的时候唤醒 \t\twake_up(&wait_queue); \t\treturn cnt; \t} \telse \t{ // 是0的时候所有的进入睡眠 \t\twait_event(wait_queue,write_data);\t \t} \t \t/*设置 GPIO1_04 输出电平*/ \tif (write_data ) \t{ \t\tgpio_set_value(rgb_led_red,0); \t} \treturn cnt; } ```"},"/note/Linux/野火Linux/2025-10-2-48-systemd.html":{"title":"Systemd","content":"# Systemd 历史上，[Linux 的启动](http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html)一直采用[`init`](https://en.wikipedia.org/wiki/Init)进程。 下面的命令用来启动服务。 > ```bash > $ sudo /etc/init.d/apache2 start > # 或者 > $ service apache2 start > ``` 这种方法有两个缺点。 一是启动时间长。`init`进程是串行启动，只有前一个进程启动完，才会启动下一个进程。 二是启动脚本复杂。`init`进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。 systemd 不是一个命令，而是一组命令的集合，提供了一个系统和服务管理器，运行为PID1并负 责启动其它程序 > 提高系统启动速度、简化服务管理，并提供更多功能 > > 根据 Linux 惯例，字母`d`是守护进程（daemon）的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。使用了 Systemd，就不需要再用`init`了。Systemd 取代了`initd`，成为系统的第一个进程（PID 等于 1） ![image 20251002112100504](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510021121582.png) systemd 功能包括： + 支持并行化任务； + 同时采用socket式与D Bus总线式激活服务； + 按需启动守 护进程（daemon）； + 利用Linux 的 cgroups 监视进程； + 支持快照和系统恢复； + 维护挂载点和自动 挂载点； + 各服务间基于依赖关系进行精密控制。 + systemd支持SysV和LSB初始脚本，可以替代 sysvinit。 + 日志进程、控制基础系统配置，维护登陆用户列表以及系统账户、 运行时目录和设置，可以运行容器和虚拟机，可以简单的管理网络配置、网络时间同步、日志转 发和名称解析等。 ## 常用命令 ### 常用命令使用示例 **服务管理**： ```bash # 启动服务 systemctl start nginx.service # 停止服务 systemctl stop nginx.service # 重启服务 systemctl restart nginx.service # 查看服务状态 systemctl status nginx.service ``` **启动项管理**： ```bash # 开机自动启动 systemctl enable nginx.service # 禁止开机启动 systemctl disable nginx.service # 查看服务是否开机自启 systemctl is enabled nginx.service ``` **查看系统状态**： ```bash # 查看所有运行的服务 systemctl list units type service # 查看当前的启动目标 systemctl get default # 设置启动目标为多用户模式 systemctl set default multi user.target ``` **日志管理**： ```bash # 查看系统日志 journalctl # 查看特定服务日志 journalctl u nginx.service # 按时间范围查看日志 journalctl since \"2025 01 01\" until \"2025 01 14\" ``` ### systemctl `systemctl`是 Systemd 的主命令，用于管理系统。 > ```bash > #输出激活的单元 > $ systemctl > > # 显示系统状态 > $ systemctl status l > > # 输出运行失败的单元 > $ systemctl failed > > # 重启系统 > $ sudo systemctl reboot > > # 关闭系统，切断电源 > $ sudo systemctl poweroff > > # CPU停止工作 > $ sudo systemctl halt > > # 暂停系统 > $ sudo systemctl suspend > > # 让系统进入冬眠状态 > $ sudo systemctl hibernate > > # 让系统进入交互式休眠状态 > $ sudo systemctl hybrid sleep > > # 启动进入救援状态（单用户状态） > $ sudo systemctl rescue > ``` ### systemd analyze `systemd analyze`命令用于查看启动耗时。 > ```bash > # 查看启动耗时 > $ systemd analyze > > # 查看每个服务的启动耗时 > $ systemd analyze blame > > # 显示瀑布状的启动过程流 > $ systemd analyze critical chain > > # 显示指定服务的启动流 > $ systemd analyze critical chain atd.service > ``` ### hostnamectl `hostnamectl`命令用于查看当前主机的信息。 > ```bash > # 显示当前主机的信息 > $ hostnamectl > > # 设置主机名。 > $ sudo hostnamectl set hostname rhel7 > ``` ### localectl `localectl`命令用于查看本地化设置。 通过与systemd localed.service(8)通信来修改例如/etc/locale.conf与/etc/vconsole.conf之类的配置文件。本地化设 置控制着用户界面的语言、字符类型与字符编码、日期时间与货币符号的表达方式等许多细节 > ```bash > # 查看本地化设置 > $ localectl > > # 设置本地化参数。 > $ sudo localectl set locale LANG en_GB.utf8 > $ sudo localectl set keymap en_GB > ``` ### timedatectl `timedatectl`命令用于查看当前时区设置。 > ```bash > # 查看当前时区设置 > $ timedatectl > > # 显示所有可用的时区 > $ timedatectl list timezones > > # 设置当前时区 > $ sudo timedatectl set timezone America/New_York > $ sudo timedatectl set time YYYY MM DD > $ sudo timedatectl set time HH:MM:SS > > > # 关闭网络时间同步 > timedatectl set ntp no > # 开启网络时间同步 > timedatectl set ntp yes > # 设置时间和日期 > timedatectl set time 9:40:20 > timedatectl set time 2021 4 16 > ``` ### loginctl `loginctl`命令用于查看当前登录的用户。 > ```bash > # 列出当前session > $ loginctl list sessions > > # 列出当前登录用户 > $ loginctl list users > > # 列出显示指定用户的信息 > $ loginctl show user ruanyf > > > # 显示所有会话及属性 > loginctl a > # 显示会话配置消息 > loginctl show session > # 列出显示指定用户的信息 > loginctl show user root > ``` ## 核心概念 ### unit #### 简介 单元，单元文件是ini风格的纯文本文件，Systemd可以管理所有系统资源，不同的资源统称为 Unit（单位）。其封装了12种对象的信息：服务(service)、套接字(socket)、设备(device)、挂载点 (mount)、自动挂载点(automount)、启动目标(target)、交换分区或交换文件(swap)、被监视的路径 (path)、任务计划(timer)、资源控制组(slice)、一组外部创建的进程(scope)、快照(snapshot) + **service**：一个后台服务进程，其封装了守护进程的启动、停止、重启与重载等操作。 + **socket**：此类配置单元封装系统和互联网中的一个套接字。当下，systemd支持流式，数据 报和连续包的AF_INET，AF_INET6，AF_UNIX socket。每个套接字配置单元都有一个相应 的服务配置单元，相应的服务在第一个“连接”进入套接字时就会启动（例如：nscd.socket 在有新连接后便启动nscd.service），监控系统或者网络的数据信息。 + **device**：此类配置单元封装一个存在于Linux设备树中的设备。每个使用udev规则标记的 设备都将会在systemd中作为一个设备配置单元出现，定义设备之间的依赖关系 + **mount**：此类配置单元封装文件系统结构层次中的一个挂载点。systemd将对这个挂载点进 行监控和管理。比如，可以在启动时自动将其挂载，可以在某些条件下自动卸载。systemd 会将/etc/fstab 中的条目都转换为挂载点，并在开机时处理。 + **automount**：此类配置单元封装系统结构层次中的一个自挂载点。每个自挂载配置单元对应 一个挂载配置单元，当该自动挂载点被访问时，systemd执行挂载点中定义的挂载行为 + **Swap**：和挂载配置单元类似，交换配置单元用来管理交换分区。用户可以用交换配置单元 来定义系统中的交换分区，可以让这些交换分区在启动时被激活 + **target**：此类配置单元为其他配置单元进行逻辑分组。它们本身实际上并不做什么，只是引 用其他配置单元而已，这样便可以对配置单元做一个统一的控制，就可以实现大家都非常 熟悉的运行级别的概念。比如，想让系统进入图形化模式，需要运行许多服务和配置命令， 这些操作都由一个个的配置单元表示，将所有的这些配置单元组合为一个目标（target）， 就表示需要将这些配置单元全部执行一遍，以便进入目标所代表的系统运行状态 + **timer**：定时器配置单元用来定时触发用户定义的操作。这类配置单元取代了atd，crond等 传统的定时服务。 + **snapshot**：与 target 配置单元相似，快照是一组配置单元，它保存了系统当前的运行状态 + **slice**：表示一个CGroup的树。 + **path**：监控指定目录或文件的变化，并触发其它Unit的运行。 + **scope**：它用于描述一些系统服务的分组信息。 每个配置单元都有一个对应的配置文件，比如一个 avahi daemon 服务对应一个 avahi daemon.service 文件。这种配置文件的语法非常简单，用户不需要再编写和维护复杂的 sysv 脚 本 #### 查询命令 ```bash # 列出正在运行的 Unit systemctl list units # 列出所有 Unit，包括没有找到配置文件的或者启动失败的 systemctl list units all # 列出所有没有运行的 Unit systemctl list units all state inactive # 列出所有加载失败的 Unit systemctl list units failed # 列出所有正在运行的、类型为 service 的 Unit systemctl list units type service # 显示某个 Unit 是否正在运行 systemctl is active systemd timesyncd.service #显示某个Unit服务是否建立了启动链接 systemctlis enabledsystemd timesyncd.service ``` #### 管理命令 ```bash #立即启动一个服务 $ sudo systemctl startbootlogo.service #立即停止一个服务 $ sudo systemctl stopbootlogo.service #重启一个服务 $ sudo systemctl restartbootlogo.service #杀死一个服务的所有子进程 $ sudo systemctl killbootlogo.service #重新加载一个服务的配置文件 $ sudo systemctl reloadbootlogo.service #重载所有修改过的配置文件 $ sudo systemctl daemon reload #显示某个Unit的所有底层参数 $ systemctlshow httpd.service # 显示某个 Unit 的指定属性的值 $ systemctl show p CPUShares avahi daemon.service # 设置某个 Unit 的指定属性 $ sudo systemctl set property avahi daemon.service CPUShares 500 ``` #### 依赖 存在一些任务，它 们之间存在天生的依赖关系，不能用“套接字激活”（socketactivation）,D Busactivation和autofs 三大方法来解除依赖 systemd的配置单元之间可以彼此定义依赖关系。比 如，unit Q 依赖unit W，可以在unitW的定义中用“requireQ”来表示，这样systemd就会保证 先启动Q再启动W。systemd能保证事务完整性。 若存在循环依赖，那么systemd将无法启 动任意一个服务。此时，systemd将会尝试解决这个问题，因为配置单元之间的依赖关系有两种： `requireds` 为强依赖，`wants` 为弱依赖，systemd 将去掉wants 关键字指定的依赖看看是否能打破循环。如果无法修复，systemd会报错。systemd能够自动检测和修复这类配置错误，极大地减轻了 管理员的拔锚负担 ```bash # 命令列出一个 Unit 的所有依赖 $ systemctl list dependencies avahi daemon.service # 命令列出一个 Unit 的所有依赖，并展开显示 Target 依赖类型 $ systemctl list dependencies all avahi daemon.service ``` #### 配置文件 systemd 的配置文件默认会存放于文件系统中的/etc/systemd/system 或/usr/lib/systemd/system 目录下 初始化 过程中systemd只执行/etc/systemd/system 目录里面的配置文件。当你安装完systemd程序之后，他 会自动的在/lib/systemd/system 目录下生成一个与该程序对应的配置文件。 你可以使用“systemctl enable xxx.service”的方式来建立一个服务软链接，若设置了开机启动，则“systemctlenable”相当 于使能开机启动，而“systemctldisable”命令与之相反，他会断开软链接，所以开机就不会启动 + ssh的server文件, /etc/systemd/system/sshd.service ``` [Unit] Description OpenBSD Secure Shell server After network.target auditd.service ConditionPathExists !/etc/ssh/sshd_not_to_be_run [Service] EnvironmentFile /etc/default/ssh ExecStartPre /usr/sbin/sshd t ExecStart /usr/sbin/sshd D $SSHD_OPTS ExecReload /usr/sbin/sshd t ExecReload /bin/kill HUP $MAINPID KillMode process Restart on failure RestartPreventExitStatus 255 Type notify RuntimeDirectory sshd RuntimeDirectoryMode 0755 [Install] WantedBy multi user.target Alias sshd.service ``` + Unit + + **Description **描述了当前服务 + **After** 字段，它指定了服务的启动顺序，但是不涉及依赖关系, 表示的是当前服务需要在network.target及auditd.service 两个服 务之后启动。而Wants和Requires字段只涉及依赖关系，他与启动顺序是无关的，默认为同时启 动。如果想要设置服务之间的依赖关系，及使用Wants和Requires字段即可，Wants为“弱依赖”， Requires 为“强依赖”。 + **ConditionPathExists**: 条件检查，如果存在 `/etc/ssh/sshd_not_to_be_run` 文件，则不运行此服务（用于临时禁用 SSH） + [Service] + + **EnvironmentFile**: 从 `/etc/default/ssh` 文件加载环境变量（` ` 表示文件不存在时不报错） + **ExecStartPre**: 服务启动前执行的命令，`sshd t` 用于测试配置文件语法 + **ExecStart**: 主服务启动命令，` D` 表示前台运行，`$SSHD_OPTS` 来自环境变量文件, 其中的变量 $SSHD_OPTS 就是来自于EnvironmentFile 字段所指定的环境参数文件 + **ExecReload**: 有两个重载命令： 先执行 `sshd t` 测试配置语法 然后向主进程发送 HUP 信号重新加载配置 + **KillMode process**: 只杀死主进程，不杀死整个进程组 + **Restart on failure**: 服务失败时自动重启 > + no（默认值）：退出后不会重启 > + on success：只有正常退出时（退出状态码为0），才会重启 > + on failure：非正常退出时（退出状态码非0），包括被信号终止和超时，才会重启 > + on abnormal：只有被信号终止和超时，才会重启 > + on abort：只有在收到没有捕捉到的信号终止时，才会重启 > + on watchdog：超时退出，才会重启 > + always：不管是什么退出原因，总是重启 + **RestartPreventExitStatus 255**: 退出状态为 255 时不重启 + **Type notify**: 服务启动完成后会通知 systemd + **RuntimeDirectory**: 在 `/run` 下创建 sshd 运行时目录 + **RuntimeDirectoryMode**: 设置运行时目录权限为 755 + [Install] + + **WantedBy**: 表示当前服务所在的 Target,Target 表示的是服务组, 它是一组服务的集合，用于定义系统的特定状态, 指定该服务在 multi user.target 启动时自动启用 > Target 对应运行级别 描述 > : : : > **graphical.target** 运行级别 5 图形界面模式 > **rescue.target** 运行级别 1 单用户救援模式 > **emergency.target** 运行级别 0 紧急模式 > **poweroff.target** 关机 > **reboot.target** 重启 > **multi user.target** 运行级别 3 多用户命令行模式（非图形界面） > > 依赖关系: local fs.target → swap.target → sysinit.target → basic.target → multi user.target → graphical.target > > ```bash > # 设置默认 Target（重启后生效） > sudo systemctl set default multi user.target > > # 立即切换到另一个 Target（不重启） > sudo systemctl isolate multi user.target > ``` > > + **Alias**: 服务别名，可以通过 `sshd.service` 名称引用 执行阶段 命令示例 作用 设计考量 : : : : **启动前检查** (ExecStartPre) `/usr/sbin/sshd t` **语法检查**：解析并验证`sshd_config`等配置文件的语法是否正确，但不真正启动服务。 提前发现配置错误，避免因配置有误导致服务启动失败。 **主进程启动** (ExecStart) `/usr/sbin/sshd D $SSHD_OPTS` **启动服务**： • ` D`：让`sshd`在前台运行，便于systemd监控。 • `$SSHD_OPTS`：来自`/etc/default/ssh`环境文件，用于传递额外启动参数。 前台运行是使用systemd管理服务的推荐方式。服务类型为`notify`，意味着服务启动完成后需要通知systemd。 **配置重载** (ExecReload) 1. `/usr/sbin/sshd t` 2. `/bin/kill HUP $MAINPID` **安全重载**： 1. **再次语法检查**，防止错误配置被加载。 2. 向主进程发送`HUP`信号，使其重新加载配置文件。 先检查后重载，确保服务配置的每一次变更都是安全且有效的。 > 如果我们修改了配置文件，就需要重新加载配置文件，然后重启该服务 > > ```bash > # 重新加载配置文件 > $ sudo systemctl daemon reload > # 重启相关服务 > $ sudo systemctl restart ssh > ``` ##### 自定义示例 + 一个简单的python示例 ```c [Unit] Description My Python Service After network.target [Service] Type simple User www data Group www data WorkingDirectory /path/to/your/python/code ExecStart /usr/bin/python3 /path/to/your/python/code/app.py Restart always RestartSec 5 Environment PYTHONPATH /path/to/your/python/code Environment PYTHONUNBUFFERED 1 [Install] WantedBy multi user.target ``` ```bash sudo chmod 644 /etc/systemd/system/my_python_service.service sudo systemctl daemon reload sudo systemctl start my_python_service sudo systemctl enable my_python_service # 开机自启 # 日志 sudo systemctl status my_python_service sudo journalctl u my_python_service f # 实时日志 ``` + 脚本 创建一个脚本文件 ```bash #!/bin/bash while true do echo Hello Embedfire >> /tmp/hello.log sleep 3 done ``` `sudo chmod 0755 hello.sh` 创建配置文件 ``` [Unit] Description hello daemon [Service] ExecStart /opt/scripts/boot/hello.sh Restart always Type simple [Install] WantedBy multi user.target ``` ```bash sudo systemctl enable hello sudo systemctl start hello ``` #### 系统配置 ```bash # 重启系统（异步操作） $ systemctl reboot # 关闭系统，切断电源（异步操作） $ systemctl poweroff # 仅 CPU 停止工作，其他硬件仍处于开机状态（异步操作） $ systemctl halt # 暂停系统（异步操作），执行 suspend.target $ systemctl suspend # 使系统进入冬眠状态（异步操作），执行 hibernate.target $ systemctl hibernate ``` #### 日志文件 可以只用`journalctl`一个命令，查看所 有日志（内核日志和应用日志） 日志配置文件位于/etc/systemd/journald.conf，其保存目录为/var/log/journal/ 默认情况下日志最大限 制为所在文件系统容量的10%，可通过/etc/systemd/journald.conf 中的 SystemMaxUse 字段来指定 日志最大限制 ```bash # 指定日志文件占据的最大空间 $ sudo journalctl vacuum size 8M ```"},"/note/Linux/野火Linux/2025-7-2-03-控制设备.html":{"title":"控制设备","content":"# 控制设备 控制设备的时候可以使用`/dev`目录或者`/sys`目录下边的文件对一个外设进行控制, /sys目录的一般是根据设备的功能进行划分以后, /dev可以使用同一个文件实现多个功能的控制 > 可以使用/sys/class/leds/blue/brightness这个文件进行控制 > > /sys目录下边的实际是系统导出的操作接口 在进行文件读写的时候可能有缓冲区 在控制GPIO的时候, 没有进行导出操作接口, 比如GPIO1_19是蜂鸣器的, 可以在/sys/class/gpio/export下边写入引脚的编号进行引脚的导出, 默认的时候是没有这个引脚的控制接口的 `echo 19 > /sys/class/gpio/export`, 之后会出现一个gpio19的目录, 可以控制direction改变输入输出模式(in/out), 也可以使用value控制引脚的输出电平 ## 控制按键输入 /dev/input/by path/plaform gpio keys event是按键的设备文件 ### input子系统 + 按键 + 键盘 + 触摸屏 + ... ```c struct input_event{ struct timeval time; //触发时间 __u16 type; //触发的事件类型. 比如按键, 坐标等, 还有特殊EV_SYN是一种同步事件, 提醒处理事件, 不是实际的触发 __u16 code; // 实际的事件的代号, 记录按键的位置 __s32 value; // 记录事件的具体的值, 比如按键按下为1, 松开的时候是0 }; ``` > 需要使用头文件`linux/input.h`, 以及`linux/input event codes.h`两个文件 可以使用`/dev/input/by path/platform gpio kesy input`这个文件, 使用一个`input_event`结构体进行读取这个文件"},"/note/Linux/野火Linux/2025-7-20-18-DTS设备树.html":{"title":"DTS设备树","content":"# DTS设备树 由于platform的driver文件过多 DTS(device tree source)：设备树源文件，ASCII 格式 DTC(device tree compiler)：设备树编译工具 DTB(device tree blob)：二进制设备树, Lniux实际可以使用的文件 > 在没有使用设备树之前, 在 Linux 内核源码中大量的 arch/arm/mach xxx和 arch/arm/plat xxx文件夹，这些文件夹里面的文件就是对应平台下的板级信息, 各种配置信息记录在C文件里面 ![image 20250720103047027](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507201030111.png) ## 设备树使用 uboot负责加载到内存固定位置，内核解析使用 ### 设备树源文件 `ebf buster linux/arch/arm/boot/dts/imx6ull seeed npi.dts` ### 二进制设备树 pc：`ebf buster linux/arch/arm/boot/dts/imx6ull seeed npi.dtb`编译的结果一般在同一个目录下面 开发板：`/boot/dtbs/4.19.71 imx r1/imx6ull seeed npi.dtb`, 启动的时候自动加载, 需要在这个文件夹下面进行替换 特性维度 `/boot/dtbs/4.19.71 imx r1/` `/usr/lib/linux image 4.19.71 imx r1/` : : : **主要用途** Bootloader**实际使用**的设备树文件 软件包管理系统（如dpkg）**存放**的设备树文件 **启动阶段** 系统启动初期由Bootloader读取 通常不直接参与启动，作为系统文件的一部分 **更新影响** 直接影响下次启动的硬件配置 主要用于软件包管理，**替换系统镜像时可能被使用** **文件性质** 通常是**活动**的设备树文件 可能是软件包安装的副本 **修改建议** ✅ **推荐手动更新此目录下的文件** 通常由系统包管理器维护，**不建议手动修改** **在系统中的作用** 关键的启动配置文件 系统文件的组成部分 ### 设备树编译 内核编译, 在内核的根目录下面执行这个命令 ```makefile //进行内核配置需要在内核的根目录下面进行, 生成一个.config文件 make ARCH arm CROSS_COMPILE arm linux gnueabihf npi_v7_defconfig //编译dts make ARCH arm j4 CROSS_COMPILE arm linux gnueabihf dtbs ``` 手工编译 ```bash ./scripts/dtc/dtc I dts O dtb o xxx.dtb arch/arm/boot/dts/xxx.dts // 编译 dts 为 dtb ./scripts/dtc/dtc I dtb O dts o xxx.dts arch/arm/boot/dts/xxx.dtb // 反编译 dtb 为 dts ``` I：指定输入格式 O：指定输出格式 o：指定输出文件 ## 设备树框架 从上到下 头文件 主体 子节点追加内容 从外到内 属性 其他子节点 属性 其他子节点 ... ### linux系统中查看设备树 ``` ls /sys/firmware/devicetree/base ``` 或者 ``` ls /proc/device tree ``` 以目录的形式体现设备树结构 ### 添加子节点 ```json test_led{ \t#address cells <1>; \t#size cells <1>; \trgb_led_red@0x0209C000{ \t\t\tcompatible \"fire,rgb_led_red\"; \t\t\treg <0x0209C000 0x00000020>; \t\t\tstatus \"okay\"; \t}; }; ``` 可以直接使用文件替换重启的方式进行更新, 更新文件以后`sync`命令写入磁盘同步一下 ## 属性读取API ![image 20250720154031156](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507201540217.png) 查属性所在的节点 查节点的属性值 > 有compatible属性的节点才会被转换, 可以使用的API函数记录在文件`include/linux/of.h`里面 ### 节点 /include/linux/of.h ```c struct device_node { const char *name; //节点名 const char *type; //设备类型, 使用的比较少 phandle phandle; const char *full_name; //完整名字 struct fwnode_handle fwnode; struct property *properties; //属性 struct property *deadprops; struct device_node *parent; //父节点 struct device_node *child; //子节点 struct device_node *sibling; #if defined(CONFIG_OF_KOBJ) struct kobject kobj; #endif unsigned long _flags; void *data; #if defined(CONFIG_SPARC) const char *path_component_name; unsigned int unique_id; struct of_irq_controller *irq_trans; #endif }; ``` #### 查节点 路径/类型/名字/compatible incldue/linux/of.h ##### 路径 根据路径找到节点 ```c struct device_node *of_find_node_by_path(struct device_node *from,const char *path); ``` 参数： from：开始查找的节点，NULL表示从根节点开始查找 path：查找的节点名 返回值： 成功：device_node表示的节点 失败：NULL ##### 名字 根据\"name\"属性来查找节点 ```c struct device_node *of_find_node_by_name(struct device_node *from,const char *name); ``` from是起始的位置, NULL的时候设置的是根节点 ##### 类型 ```c struct device_node *of_find_node_by_type(struct device_node *from, const char *type) ``` 查找的节点对应的 type字符串，也就是 device_type属性值 ##### 类型和compatible属性 ```c struct device_node *of_find_compatible_node(struct device_node *from,const char *type, const char *compat); ``` 参数： from：开始查找的节点，NULL表示从根节点开始查找 type：指定 device_type 属性值可以为NULL，表示忽略掉device_type属性 compat：指定 compatible 属性值 返回值： 成功：device_node表示的节点 失败：NULL ##### compatible属性列表 ```c struct device_node *of_find_matching_node_and_match(struct device_node *from, \t\t\t\t\tconst struct of_device_id *matches, \t\t\t\t\tconst struct of_device_id **match) ``` + **from**：开始查找的节点，如果为 NULL表示从根节点开始查找整个设备树。 + **matches**：of_device_id匹配表，也就是在此匹配表里面查找节点。 + **match**：找到的匹配的 of_device_id。 使用的mactches示例如下 ```c static const struct of_device_id versatile_reboot_of_match[] { \t{ \t\t.compatible \"arm,core module integrator\", \t\t.data (void *)INTEGRATOR_REBOOT_CM \t}, \t{ \t\t.compatible \"arm,realview eb syscon\", \t\t.data (void *)REALVIEW_REBOOT_EB, \t}, \t{ \t\t.compatible \"arm,realview pb1176 syscon\", \t\t.data (void *)REALVIEW_REBOOT_PB1176, \t}, \t{ \t\t.compatible \"arm,realview pb11mp syscon\", \t\t.data (void *)REALVIEW_REBOOT_PB11MP, \t}, \t{ \t\t.compatible \"arm,realview pba8 syscon\", \t\t.data (void *)REALVIEW_REBOOT_PBA8, \t}, \t{ \t\t.compatible \"arm,realview pbx syscon\", \t\t.data (void *)REALVIEW_REBOOT_PBX, \t}, \t{}, }; ``` 可以使用里面的data判断实际获取的是哪个设备 #### 父子节点 ##### 父节点 ```c struct device_node *of_get_parent(const struct device_node *node) ``` ##### 子节点 ```c struct device_node *of_get_next_child(const struct device_node *node,struct device_node *prev) ``` 函数用迭代的方式查找子节点, prev是前一个子节点，也就是从哪一个子节点开始迭代的查找下一个子节点。可以设置为NULL，表示从第一个子节点开始 ### 属性 incldue/linux/of.h ```c struct property { char *name; \t//属性名 int length; //属性长度 void *value; \t//属性值 struct property *next; //下一个属性 #if defined(CONFIG_OF_DYNAMIC) defined(CONFIG_SPARC) unsigned long _flags; #endif #if defined(CONFIG_OF_PROMTREE) unsigned int unique_id; #endif #if defined(CONFIG_OF_KOBJ) struct bin_attribute attr; #endif }; ``` #### 名字查找 节点+属性名 查找节点中的属性, 通过名字以及名字的长度 ```c struct property *of_find_property(const struct device_node *np,const char *name,int *lenp); ``` 参数： np：device_node表示的节点 name：查找的属性名字 lenp：属性值的字节数, 返回参数 返回值： 成功：property表示的属性 失败：NULL + 案例： ```c test_property { \ttest_name “hello”; }; ``` name：“hello” lenp 6 #### 整形 读取一个32位无符号整数 ```c static inline int of_property_read_u32(const struct device_node *np,const char *propname, u32 *out_value); ``` 参数： np：device_node表示的节点 propname：查找的属性名字 out_value：属性值的整数值 返回值： 成功：0 失败：负值 ```c int of_property_read_u8(const struct device_node *np, const char *propname,u8 *out_value) int of_property_read_u16(const struct device_node *np, const char *propname,u16 *out_value) int of_property_read_u64(const struct device_node *np, const char *propname,u64 *out_value) ``` #### 数组 读取32位无符号整数数组 ```c int of_property_read_u32_array(const struct device_node *np,const char *propname,u32 *out_values,size_t sz) ``` np：device_node表示的节点 name：查找的属性名字 out_value：读取到的数组值 sz：要读取的数组元素数量 类似的函数有 ```c int of_property_read_u8_array(const struct device_node *np, const char *propname,u8 *out_values, size_t sz) int of_property_read_u16_array(const struct device_node *np, const char *propname, u16 *out_values, size_t sz) int of_property_read_u64_array(const struct device_node *np, const char *propname, u64 *out_values, size_t sz) ``` #### 字符串 读字符串 ```c int of_property_read_string(struct device_node *np,const char *propname,const char **out_string) ``` 参数： np：device_node表示的节点 proname：查找的属性名字 out_string：读取到的字符串值 返回值： 成功：0 失败：负值 #### 数组长度 ```c int of_property_count_elems_of_size(const struct device_node *np, const char *propname, int elem_size) ``` 获取属性中元素的数量，比如 reg 属性值是一个数组，那么使用此函数可以获取到这个数组的大小 #### 数组中一个 ```c int of_property_read_u32_index(const struct device_node *np,const char *propname, u32 index,u32 *out_value) ``` #### #address cell和#size cells ```c int of_n_addr_cells(struct device_node *np) int of_n_size_cells(struct device_node *np) ``` ### 其他常用 #### 比较compatible ```c int of_device_is_compatible(const struct device_node *device, const char *compat) ``` 查看节点的 compatible 属性是否有包含 compat 指定的字符串，也就是检查设备节点的兼容性 #### 地址相关属性 ```c const __be32 *of_get_address(struct device_node *dev, int index, u64 *size, unsigned int *flags) ``` 获取地址相关属性 + **dev**：设备节点。 + **index**：要读取的地址标号。 + **size**：地址长度。 + **flags**：参数，比如 IORESOURCE_IO、IORESOURCE_MEM等 #### 地址资源获取 Linux里面使用的resource描述地址, 记录在reg里面 ```c /* * Resources are tree like, allowing * nesting etc.. */ struct resource { \tresource_size_t start; \tresource_size_t end; \tconst char *name; \tunsigned long flags; // 资源的描述 \tstruct resource *parent, *sibling, *child; }; ``` 常见的资源标志就是 IORESOURCE_MEM、IORESOURCE_REG和IORESOURCE_IRQ等 ```c int of_address_to_resource(struct device_node *dev, int index, struct resource *r) ``` 可以直接使用函数进行地址的映射 ```c #include <linux/io.h> void __iomem *devm_ioremap_resource(struct device *dev, const struct resource *res); ``` #### reg属性内存映射 将reg属性值的物理地址转化为虚拟地址 ```c void __iomem *of_iomap(struct device_node *np, int index) ``` 参数： np：device_node表示的节点 index：通常情况下reg属性包含多段，index 用于指定映射那一段，标号从0开始。 ## 节点使用示例 ```c test_led{ \t#address cells <1>; \t#size cells <1>; \trgb_led_red@0x0209C000{ \t\t\tcompatible \"fire,rgb_led_red\"; \t\t\treg <0x0209C000 0x00000020>; \t\t\tstatus \"okay\"; \t}; }; ``` ```c #include <linux/init.h> #include <linux/module.h> #include <linux/fs.h> #include <linux/cdev.h> #include <linux/uaccess.h> #include <linux/types.h> #include <linux/kernel.h> #include <linux/delay.h> #include <linux/ide.h> #include <linux/errno.h> #include <linux/gpio.h> #include <asm/mach/map.h> #include <asm/io.h> #include <linux/of.h> #include <linux/of_address.h> #define DEV_NAME \"get_dts_info\" #define DEV_CNT (1) //定义字符设备的设备号 static dev_t led_devno; //定义字符设备结构体chr_dev static struct cdev led_chr_dev; //创建类 struct class *led_chrdev_class; struct device_node\t*led_device_node; //led的设备树节点 struct device_node *rgb_led_red_device_node; //rgb_led_red 红灯节点 struct property *rgb_led_red_property; //定义属性结构体指针 int size 0 ; unsigned int out_values[18]; //保存读取得到的REG 属性值 /*.open 函数*/ static int led_chr_dev_open(struct inode *inode, struct file *filp) { int error_status 1; printk(\"\\n open form device \\n\"); /*获取DTS属性信息*/ led_device_node of_find_node_by_path(\"/test_led\"); if(led_device_node NULL) { printk(KERN_ALERT \"\\n get led_device_node failed ! \\n\"); return 1; } /*根据 led_device_node 设备节点结构体输出节点的基本信息*/ printk(KERN_ALERT \"name: %s\",led_device_node >name); //输出节点名 printk(KERN_ALERT \"child name: %s\",led_device_node >child >name); //输出子节点的节点名 /*获取 rgb_led_red_device_node 的子节点*/ rgb_led_red_device_node of_get_next_child(led_device_node,NULL); if(rgb_led_red_device_node NULL) { printk(KERN_ALERT \"\\n get rgb_led_red_device_node failed ! \\n\"); return 1; } printk(KERN_ALERT \"name: %s\",rgb_led_red_device_node >name); //输出节点名 printk(KERN_ALERT \"parent name: %s\",rgb_led_red_device_node >parent >name); //输出父节点的节点名 /*获取 rgb_led_red_device_node 节点 的\"compatible\" 属性 */ rgb_led_red_property of_find_property(rgb_led_red_device_node,\"compatible\",&size); if(rgb_led_red_property NULL) { printk(KERN_ALERT \"\\n get rgb_led_red_property failed ! \\n\"); return 1; } printk(KERN_ALERT \"size : %d\",size); //实际读取得到的长度 printk(KERN_ALERT \"name: %s\",rgb_led_red_property >name); //输出属性名 printk(KERN_ALERT \"length: %d\",rgb_led_red_property >length); //输出属性长度 printk(KERN_ALERT \"value : %s\",(char*)rgb_led_red_property >value); //属性值 /*获取 reg 地址属性*/ error_status of_property_read_u32_array(rgb_led_red_device_node,\"reg\",out_values, 2); if(error_status ! 0) { printk(KERN_ALERT \"\\n get out_values failed ! \\n\"); return 1; } printk(KERN_ALERT\"0x%08X \", out_values[0]); printk(KERN_ALERT\"0x%08X \", out_values[1]); return 0; } /*.release 函数*/ static int led_chr_dev_release(struct inode *inode, struct file *filp) { printk(\"\\nrelease\\n\"); return 0; } /*字符设备操作函数集*/ static struct file_operations led_chr_dev_fops { .owner THIS_MODULE, .open led_chr_dev_open, .release led_chr_dev_release, }; /* *驱动初始化函数 */ static int __init led_chrdev_init(void) { int ret 0; printk(\"led chrdev init\\n\"); //第一步 //采用动态分配的方式，获取设备编号，次设备号为0， //设备名称为EmbedCharDev，可通过命令cat /proc/devices查看 //DEV_CNT为1，当前只申请一个设备编号 ret alloc_chrdev_region(&led_devno, 0, DEV_CNT, DEV_NAME); if(ret < 0){ printk(\"fail to alloc led_devno\\n\"); goto alloc_err; } led_chrdev_class class_create(THIS_MODULE, \"led_chrdev\"); //第二步 //关联字符设备结构体cdev与文件操作结构体file_operations cdev_init(&led_chr_dev, &led_chr_dev_fops); //第三步 //添加设备至cdev_map散列表中 ret cdev_add(&led_chr_dev, led_devno, DEV_CNT); if(ret < 0) { printk(\"fail to add cdev\\n\"); goto add_err; } //创建设备 device_create(led_chrdev_class, NULL, led_devno, NULL, \t\t\t DEV_NAME); return 0; add_err: //添加设备失败时，需要注销设备号 unregister_chrdev_region(led_devno, DEV_CNT); alloc_err: return ret; } /* *驱动注销函数 */ static void __exit led_chrdev_exit(void) { printk(\"chrdev exit\\n\"); device_destroy(led_chrdev_class, led_devno); //清除设备 cdev_del(&led_chr_dev); //清除设备号 unregister_chrdev_region(led_devno, DEV_CNT); //取消注册字符设备 class_destroy(led_chrdev_class); //清除类 } module_init(led_chrdev_init); module_exit(led_chrdev_exit); MODULE_LICENSE(\"GPL\"); ``` ## 设备树驱动GPIO示例 ![image 20250720171557489](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507201715587.png) > 信息记录在platform_device继承的device结构体里面 #### 设备树添加节点信息 RGB灯的相关寄存器 ```json /* *CCM_CCGR1 0x020C406C *IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO04 0x020E006C *IOMUXC_SW_PAD_CTL_PAD_GPIO1_IO04 0x020E02F8 *GPIO1_GD 0x0209C000 *GPIO1_GDIR 0x0209C004 */ /* *CCM_CCGR3 0x020C4074 *IOMUXC_SW_MUX_CTL_PAD_CSI_HSYNC 0x020E01E0 *IOMUXC_SW_PAD_CTL_PAD_CSI_HSYNC 0x020E046C *GPIO4_GD 0x020A8000 *GPIO4_GDIR 0x020A8004 */ /* *CCM_CCGR3 0x020C4074 *IOMUXC_SW_MUX_CTL_PAD_CSI_VSYNC 0x020E01DC *IOMUXC_SW_PAD_CTL_PAD_CSI_VSYNC 0x020E0468 *GPIO4_GD 0x020A8000 *GPIO4_GDIR 0x020A8004 */ \t/*添加led节点*/ \trgb_led{ \t\t#address cells <1>; \t\t#size cells <1>; \t\tcompatible \"fire,rgb_led\"; \t\t/*红灯节点*/ \t\tranges; \t\trgb_led_red@0x020C406C{ \t\t\treg <0x020C406C 0x00000004 \t\t\t 0x020E006C 0x00000004 \t\t\t 0x020E02F8 0x00000004 \t\t\t\t 0x0209C000 0x00000004 \t\t\t 0x0209C004 0x00000004>; \t\t\tstatus \"okay\"; \t\t}; \t\t/*绿灯节点*/ \t\trgb_led_green@0x020C4074{ \t\t\treg <0x020C4074 0x00000004 \t\t\t 0x020E01E0 0x00000004 \t\t\t 0x020E046C 0x00000004 \t\t\t\t 0x020A8000 0x00000004 \t\t\t 0x020A8004 0x00000004>; \t\t\tstatus \"okay\"; \t\t}; \t\t/*蓝灯节点*/ \t\trgb_led_blue@0x020C4074{ \t\t\treg <0x020C4074 0x00000004 \t\t\t 0x020E01DC 0x00000004 \t\t\t 0x020E0468 0x00000004 \t\t\t\t 0x020A8000 0x00000004 \t\t\t 0x020A8004 0x00000004>; \t\t\tstatus \"okay\"; \t\t}; \t}; ``` ### 代码使用 ```c #include <linux/init.h> #include <linux/module.h> #include <linux/fs.h> #include <linux/cdev.h> #include <linux/uaccess.h> #include <linux/string.h> #include <linux/types.h> #include <linux/kernel.h> #include <linux/delay.h> #include <linux/ide.h> #include <linux/errno.h> #include <linux/gpio.h> #include <asm/mach/map.h> #include <linux/of.h> #include <linux/of_address.h> #include <linux/of_gpio.h> #include <asm/io.h> #include <linux/device.h> #include <linux/platform_device.h> /* 字符设备内容 */ #define DEV_NAME \"rgb_led\" #define DEV_CNT (1) /*定义 led 资源结构体，保存获取得到的节点信息以及转换后的虚拟寄存器地址*/ struct led_resource { \tstruct device_node *device_node; //rgb_led_red的设备树节点 \tvoid __iomem *virtual_CCM_CCGR; \tvoid __iomem *virtual_IOMUXC_SW_MUX_CTL_PAD; \tvoid __iomem *virtual_IOMUXC_SW_PAD_CTL_PAD; \tvoid __iomem *virtual_DR; \tvoid __iomem *virtual_GDIR; }; static dev_t led_devno;\t\t\t\t\t //定义字符设备的设备号 static struct cdev led_chr_dev;\t\t\t //定义字符设备结构体chr_dev struct class *class_led;\t\t\t\t //保存创建的类 struct device *device;\t\t\t\t\t // 保存创建的设备 struct device_node *rgb_led_device_node; //rgb_led的设备树节点结构体 /*定义 R G B 三个灯的led_resource 结构体，保存获取得到的节点信息*/ struct led_resource led_red; struct led_resource led_green; struct led_resource led_blue; /*字符设备操作函数集，open函数*/ static int led_chr_dev_open(struct inode *inode, struct file *filp) { \tprintk(\"\\n open form driver \\n\"); \treturn 0; } /*字符设备操作函数集，write函数*/ static ssize_t led_chr_dev_write(struct file *filp, const char __user *buf, size_t cnt, loff_t *offt) { \tint ret,error; \tunsigned int register_data 0; //暂存读取得到的寄存器数据 \tunsigned char receive_data[10]; //用于保存接收到的数据 \tunsigned int write_data; //用于保存接收到的数据 \tif(cnt>10) \t\t\tcnt 10; \terror copy_from_user(receive_data, buf, cnt); \tif (error < 0) \t{ \t\treturn 1; \t} \tret kstrtoint(receive_data, 16, &write_data); \tif (ret) { \t\treturn 1; } \t/*设置 GPIO1_04 输出电平*/ \tif (write_data & 0x04) \t{ \t\tregister_data ioread32(led_red.virtual_DR); \t\tregister_data & ~(0x01 << 4); \t\tiowrite32(register_data, led_red.virtual_DR); // GPIO1_04引脚输出低电平，红灯亮 \t} \telse \t{ \t\tregister_data ioread32(led_red.virtual_DR); \t\tregister_data (0x01 << 4); \t\tiowrite32(register_data, led_red.virtual_DR); // GPIO1_04引脚输出高电平，红灯灭 \t} \t/*设置 GPIO4_20 输出电平*/ \tif (write_data & 0x02) \t{ \t\tregister_data ioread32(led_green.virtual_DR); \t\tregister_data & ~(0x01 << 20); \t\tiowrite32(register_data, led_green.virtual_DR); // GPIO4_20引脚输出低电平，绿灯亮 \t} \telse \t{ \t\tregister_data ioread32(led_green.virtual_DR); \t\tregister_data (0x01 << 20); \t\tiowrite32(register_data, led_green.virtual_DR); // GPIO4_20引脚输出高电平，绿灯灭 \t} \t/*设置 GPIO4_19 输出电平*/ \tif (write_data & 0x01) \t{ \t\tregister_data ioread32(led_blue.virtual_DR); \t\tregister_data & ~(0x01 << 19); \t\tiowrite32(register_data, led_blue.virtual_DR); //GPIO4_19引脚输出低电平，蓝灯亮 \t} \telse \t{ \t\tregister_data ioread32(led_blue.virtual_DR); \t\tregister_data (0x01 << 19); \t\tiowrite32(register_data, led_blue.virtual_DR); //GPIO4_19引脚输出高电平，蓝灯灭 \t} \treturn cnt; } /*字符设备操作函数集*/ static struct file_operations led_chr_dev_fops \t{ \t\t.owner THIS_MODULE, \t\t.open led_chr_dev_open, \t\t.write led_chr_dev_write, }; /* 平台驱动函数集 */ static int led_probe(struct platform_device *pdv) { \tint ret 1; //保存错误状态码 \tunsigned int register_data 0; \tprintk(KERN_ALERT \"\\t match successed \\n\"); \t/*获取rgb_led的设备树节点*/ \trgb_led_device_node of_find_node_by_path(\"/rgb_led\"); \tif (rgb_led_device_node NULL) \t{ \t\tprintk(KERN_ERR \"\\t get rgb_led failed! \\n\"); \t\treturn 1; \t} \t/*获取rgb_led节点的红灯子节点*/ \tled_red.device_node of_find_node_by_name(rgb_led_device_node,\"rgb_led_red\"); \tif (led_red.device_node NULL) \t{ \t\tprintk(KERN_ERR \"\\n get rgb_led_red_device_node failed ! \\n\"); \t\treturn 1; \t} \t/*获取 reg 属性并转化为虚拟地址*/ \tled_red.virtual_CCM_CCGR of_iomap(led_red.device_node, 0); \tled_red.virtual_IOMUXC_SW_MUX_CTL_PAD of_iomap(led_red.device_node, 1); \tled_red.virtual_IOMUXC_SW_PAD_CTL_PAD of_iomap(led_red.device_node, 2); \tled_red.virtual_DR of_iomap(led_red.device_node, 3); \tled_red.virtual_GDIR of_iomap(led_red.device_node, 4); \t/*初始化红灯*/ \tregister_data ioread32(led_red.virtual_CCM_CCGR); \tregister_data (0x03 << 26); \tiowrite32(register_data, led_red.virtual_CCM_CCGR); //开启时钟 \tregister_data ioread32(led_red.virtual_IOMUXC_SW_MUX_CTL_PAD); \tregister_data & ~(0xf << 0); \tregister_data (0x05 << 0); \tiowrite32(register_data, led_red.virtual_IOMUXC_SW_MUX_CTL_PAD); //设置复用功能 \tregister_data ioread32(led_red.virtual_IOMUXC_SW_PAD_CTL_PAD); \tregister_data (0x10B0); \tiowrite32(register_data, led_red.virtual_IOMUXC_SW_PAD_CTL_PAD); //设置PAD 属性 \tregister_data ioread32(led_red.virtual_GDIR); \tregister_data (0x01 << 4); \tiowrite32(register_data, led_red.virtual_GDIR); //设置GPIO1_04 为输出模式 \tregister_data ioread32(led_red.virtual_DR); \tregister_data (0x01 << 4); \tiowrite32(register_data, led_red.virtual_DR); //设置 GPIO1_04 默认输出高电平 \t/*获取rgb_led节点的绿灯子节点*/ \tled_green.device_node of_find_node_by_name(rgb_led_device_node,\"rgb_led_green\"); \tif (led_green.device_node NULL) \t{ \t\tprintk(KERN_ERR \"\\n get rgb_led_green_device_node failed ! \\n\"); \t\treturn 1; \t} \t/*获取 reg 属性并转化为虚拟地址*/ \tled_green.virtual_CCM_CCGR of_iomap(led_green.device_node, 0); \tled_green.virtual_IOMUXC_SW_MUX_CTL_PAD of_iomap(led_green.device_node, 1); \tled_green.virtual_IOMUXC_SW_PAD_CTL_PAD of_iomap(led_green.device_node, 2); \tled_green.virtual_DR of_iomap(led_green.device_node, 3); \tled_green.virtual_GDIR of_iomap(led_green.device_node, 4); \t/*初始化绿灯*/ \tregister_data ioread32(led_green.virtual_CCM_CCGR); \tregister_data (0x03 << 12); \tiowrite32(register_data, led_green.virtual_CCM_CCGR); //开启时钟 \tregister_data ioread32(led_green.virtual_IOMUXC_SW_MUX_CTL_PAD); \tregister_data & ~(0xf << 0); \tregister_data (0x05 << 0); \tiowrite32(register_data, led_green.virtual_IOMUXC_SW_MUX_CTL_PAD); //设置复用功能 \tregister_data ioread32(led_green.virtual_IOMUXC_SW_PAD_CTL_PAD); \tregister_data (0x10B0); \tiowrite32(register_data, led_green.virtual_IOMUXC_SW_PAD_CTL_PAD); //设置PAD 属性 \tregister_data ioread32(led_green.virtual_GDIR); \tregister_data (0x01 << 20); \tiowrite32(register_data, led_green.virtual_GDIR); //设置GPIO4_IO20 为输出模式 \tregister_data ioread32(led_green.virtual_DR); \tregister_data (0x01 << 20); \tiowrite32(register_data, led_green.virtual_DR); //设置 GPIO4_IO20 默认输出高电平 \t/*获取rgb_led节点的蓝灯子节点*/ \tled_blue.device_node of_find_node_by_name(rgb_led_device_node,\"rgb_led_blue\"); \tif (led_blue.device_node NULL) \t{ \t\tprintk(KERN_ERR \"\\n get rgb_led_blue_device_node failed ! \\n\"); \t\treturn 1; \t} \t/*获取 reg 属性并转化为虚拟地址*/ \tled_blue.virtual_CCM_CCGR of_iomap(led_blue.device_node, 0); \tled_blue.virtual_IOMUXC_SW_MUX_CTL_PAD of_iomap(led_blue.device_node, 1); \tled_blue.virtual_IOMUXC_SW_PAD_CTL_PAD of_iomap(led_blue.device_node, 2); \tled_blue.virtual_DR of_iomap(led_blue.device_node, 3); \tled_blue.virtual_GDIR of_iomap(led_blue.device_node, 4); \t... // 寄存器设置 \t/* 注册 字符设备部分 */ \t//第一步 \t//采用动态分配的方式，获取设备编号，次设备号为0， \t//设备名称为rgb leds，可通过命令cat /proc/devices查看 \t//DEV_CNT为1，当前只申请一个设备编号 \tret alloc_chrdev_region(&led_devno, 0, DEV_CNT, DEV_NAME); \tif (ret < 0) \t{ \t\tprintk(\"fail to alloc led_devno\\n\"); \t\tgoto alloc_err; \t} \t//第二步 \t//关联字符设备结构体cdev与文件操作结构体file_operations \tled_chr_dev.owner THIS_MODULE; \tcdev_init(&led_chr_dev, &led_chr_dev_fops); \t//第三步 \t//添加设备至cdev_map散列表中 \tret cdev_add(&led_chr_dev, led_devno, DEV_CNT); \tif (ret < 0) \t{ \t\tprintk(\"fail to add cdev\\n\"); \t\tgoto add_err; \t} \t//第四步 \t/*创建类 */ \tclass_led class_create(THIS_MODULE, DEV_NAME); \t/*创建设备*/ \tdevice device_create(class_led, NULL, led_devno, NULL, DEV_NAME); \treturn 0; add_err: \t//添加设备失败时，需要注销设备号 \tunregister_chrdev_region(led_devno, DEV_CNT); \tprintk(\"\\n error! \\n\"); alloc_err: \treturn 1; } static const struct of_device_id rgb_led[] { \t{.compatible \"fire,rgb_led\"}, // 实际匹配 \t{/* sentinel */}}; /*定义平台设备结构体*/ struct platform_driver led_platform_driver { \t.probe led_probe, \t.driver { \t\t.name \"rgb leds platform\", \t\t.owner THIS_MODULE, \t\t.of_match_table rgb_led, \t}}; /* *驱动初始化函数 */ static int __init led_platform_driver_init(void) { \tint DriverState; \tDriverState platform_driver_register(&led_platform_driver); \tprintk(KERN_ALERT \"\\tDriverState is %d\\n\", DriverState); \treturn 0; } /* *驱动注销函数 */ static void __exit led_platform_driver_exit(void) { \t/*取消物理地址映射到虚拟地址*/ \tiounmap(led_green.virtual_CCM_CCGR); \tiounmap(led_green.virtual_IOMUXC_SW_MUX_CTL_PAD); \tiounmap(led_green.virtual_IOMUXC_SW_PAD_CTL_PAD); \tiounmap(led_green.virtual_DR); \tiounmap(led_green.virtual_GDIR); \tiounmap(led_red.virtual_CCM_CCGR); \tiounmap(led_red.virtual_IOMUXC_SW_MUX_CTL_PAD); \tiounmap(led_red.virtual_IOMUXC_SW_PAD_CTL_PAD); \tiounmap(led_red.virtual_DR); \tiounmap(led_red.virtual_GDIR); \tiounmap(led_blue.virtual_CCM_CCGR); \tiounmap(led_blue.virtual_IOMUXC_SW_MUX_CTL_PAD); \tiounmap(led_blue.virtual_IOMUXC_SW_PAD_CTL_PAD); \tiounmap(led_blue.virtual_DR); \tiounmap(led_blue.virtual_GDIR); \t/*删除设备*/ \tdevice_destroy(class_led, led_devno);\t\t //清除设备 \tclass_destroy(class_led);\t\t\t\t\t //清除类 \tcdev_del(&led_chr_dev);\t\t\t\t\t\t //清除设备号 \tunregister_chrdev_region(led_devno, DEV_CNT); //取消注册字符设备 \t/*注销字符设备*/ \tplatform_driver_unregister(&led_platform_driver); \tprintk(KERN_ALERT \"led_platform_driver exit!\\n\"); } module_init(led_platform_driver_init); module_exit(led_platform_driver_exit); MODULE_LICENSE(\"GPL\"); /**/ ``` ## 原理拓展 ### 设备树的匹配 在没有使用设备树以前，uboot会向Linux内核传递一个叫做machine id的值，machine id也就是设备 ID，告诉 Linux 内核自己是个什么设备，看看 Linux 内核是否支持, 每一个开发板对应的是一个.c文件 如在文件arch/arm/mach imx/mach mx35_3ds.c里面会设置`static const struct machine_desc __mach_desc_MX35_3DS`里面的`.nr MACH_TYPE_MX35_3DS`, MACH_TYPE_MX35_3DS定义在文件include/generated/mach types.h中 > 这个是使用宏定义MACHINE_START和 MACHINE_END 来声明一个开发板 在使用设备树以后, 对应的nr设置为~0说明引入设备树以后不会再根据 machine id来检查Linux内核是否支持某个设备了 > 使用DT_MACHINE_START。DT_MACHINE_START 来定义一个板子 文件arch/arm/mach imx/mach imx6ul.c ```c static const char *imx6ul_dt_compat[] __initconst { \t\"fsl,imx6ul\", \t\"fsl,imx6ull\", \tNULL, }; ``` 这个就是匹配设备树的, imx6ull alientek emmc.dts中根节点的compatible属性值 ```json compatible \"fsl,imx6ull 14x14 evk\", \"fsl,imx6ull\"; ``` ![image 20251108113527346](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251108113527346.png) ### 根节点下内容 + cpus: 节点用于描述SOC内部的所有CPU + soc: 像 uart，iic控制器等等这些都属于 SOC内部外设，因此一般会创建一个叫做 soc的父节点来管理这些SOC内部外设的子节点 + **ocram**: 记录内部RAM的地址信息 + **aips1**、**aips2** 和 **aips3**: 分管不同的外设控制器 ![image 20251108114018258](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251108114018258.png) ### Linux解析设备树 ![image 20251108114152913](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251108114152913.png) ### 添加设备相关文档 在 Linux 内核源码中有详细的.txt 文档描述了如何添加节点，这些.txt 文档叫做绑定文档，路径为：Linux源码目录`/Documentation/devicetree/bindings`"},"/note/Linux/野火Linux/2025-10-2-52-Uboot启动.html":{"title":"Uboot启动","content":"# Uboot启动 [U Boot – Universal Bootloader](https://u boot.org/) **上电—>设备初始化—>启动设备—>镜像头—>Uboot入口** SPL部分(引导Full Uboot)未使用到(IMX6ULL会使用镜像头初始化DDR, 同时自动加载bin文件到DDR里面去0x8780 0000, 所以**没有这部分**) ```'1. ROM Bootloader 加载 SPL 到 SRAM ↓ 2. _start (入口点) ↓ 3. reset() ├── save_boot_params() ├── cpu_init_cp15() ├── cpu_init_crit() └── _main() ↓ 4. _main() ├── board_init_f_alloc_reserve() ├── board_init_f_init_reserve() └── board_init_f() ↓ 5. board_init_f() ├── arch_cpu_init() ├── spl_clear_bss() └── board_init_r() ↓ 6. board_init_r() ├── 硬件初始化 ├── 存储设备初始化 ├── 加载 U Boot 镜像 └── 跳转到 U Boot' ``` + 加载镜像头(加载完全的Uboot到RAM里面) + Uboot启动 ```c 1. SPL 加载 U Boot 到内存 ↓ 2. _start (入口点) ↓ 3. reset() ├── save_boot_params() ├── cpu_init_cp15() ├── cpu_init_crit() └── _main() ↓ 4. _main() ├── board_init_f_alloc_reserve() ├── board_init_f_init_reserve() └── board_init_f() ↓ 5. board_init_f() 重定位前初始化 ├── init_sequence_f[] 执行 │ ├── setup_mon_len │ ├── initf_malloc │ ├── arch_cpu_init │ ├── timer_init │ ├── env_init │ ├── serial_init │ └── console_init_f └── 计算重定位地址 ↓ 6. 重定位过程 ├── relocate_code() └── relocate_vectors() ↓ 7. board_init_r() 重定位后初始化 ├── init_sequence_r[] 执行 │ ├── initr_reloc │ ├── initr_caches │ ├── initr_malloc │ ├── initr_dm │ └── board_init └── run_main_loop() ↓ 8. main_loop() ├── cli_init() ├── bootdelay_process() ├── autoboot_command() └── cli_loop() (命令循环) ↓ 9. 启动内核或进入命令模式 ``` + + **设置异常向量表**：CPU 发生中断、快速中断等异常时，会跳转到这个表指定的地址。U Boot 需要先设置一个简单的向量表。 + **进入特权模式**：CPU 可能从复位后的特殊模式启动，U Boot 会切换到 Supervisor 模式，以便执行特权指令。 + **关闭看门狗**：看门狗定时器如果不及时“喂狗”，会导致系统复位。U Boot 首先要关闭它或定期复位它，防止系统在启动过程中意外重启。 + **关闭中断**：在初始化早期，中断系统尚未准备就绪，为了避免意外中断，会先关闭所有中断。 + **设置时钟系统**：包括 CPU 主频、总线频率、外设时钟等。芯片通常以一个低速的晶振启动，U Boot 需要配置锁相环等电路，将时钟提升到稳定运行所需的高频率。 + **初始化内存控制器**：这是**至关重要的一步**。在初始化之前，CPU 无法访问外部的 DDR SDRAM。U Boot 需要根据板子的硬件设计，正确配置内存控制器的时序、位宽、大小等参数，使内存可用。 + **设置栈指针**：为 C 语言代码的执行准备运行栈。一旦栈设置好，就可以跳转到 C 代码执行，大大提高开发效率。 + **代码重定位**：U Boot 自身可能运行在只读的 ROM、NOR Flash 或容量有限的 SRAM 中。这一步它将**把自己完整的代码拷贝到刚刚初始化好的 DDR 内存中**，然后跳转到内存中继续执行。这样做是为了获得更快的执行速度。 最后加载boot分区里面的dtb文件以及zImage内核 ## bootROM作用 主要是原厂的固化在芯片内的程序的功能：简单初始化一下总线资源，再通过外部引 脚判断从什么类型的flash中读取数据进行外设的初始化 ### 初始化内部ROM RAM imx6ull里是带有ROM和RAM的，我们称它为iROM和iRAM ![image 20251002202453485](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510022024546.png) iROM作用：存储异常向量表，HABAPI向量表，ROMAPI向量表，日志缓冲区，固化的出厂程序 iRAM作用：运行出厂程序和镜像4K头部数据 ### 初始化部分时钟 ![image 20251012221918839](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510122219911.png) ### 初始化引导模块 ![image 20251002202621581](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510022026645.png) 初始化了大部分的总线，为下面读取外部存储做准备 + 启动MMU/L2映射 启动ROM包括一个功能，使内存管理单元(MMU)和缓存，以提高启动速度。在镜像下载开始 时，将启用Ll指令缓存。图像认证时需要启用L1数据缓存、L2缓存和MMU。当HAB认证完 成时，ROM会关闭L1数据缓存、L2缓存和MMU。其中L1指令缓存、L1数据缓存、L2缓存 和MMU由eFuse控制。默认情况下，这些是启用的 + 映射异常向量表, 映射后存于iRAM的0x0091FFB8 0x0091FFFF地址中 ### 识别存储设备 在使用bootROM进行识别启动的方式的时候, 会检测一下这部分的配置, 通过GPIO的配置, 和LCD的DATA引脚进行复用, 一般默认接地就可以了, BOOTCONFIG4全部接地, BOOTCONFIG2的引脚3选择一下eSDHC接口, 也就是哪一个SD卡, BOOTCONFIG1的3, 4, 5, 6, 7 ![image 20251002202928268](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510022029320.png) ![image 20251002203023937](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510022030011.png) ### 镜像头读取 uboot在启动的时候会被复制到0x87800000位置, 前面需要加上3K的数据头, 所以imx文件的起始地址是0x877FF400 ![image 20251002203120052](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510022031092.png) + NOR 该flash 支持XIP可以在片上运行程序，需要注意的是NOR只能像RAM一样读取数据但不能像 RAM一样写入，写入还得像NAND那样擦除再写入，所以其镜像头的加载可以是整个空间 然后根据镜像头配置好时钟和各种外设（内置外设） + OneNAND(不常用) 从256byte 开始读取往后的1K（0页0块的扇区0和扇区1）作为镜像头将其加 载到内部的iRAM中，这1K必须包含完整的镜像头数据，但我们常用的NAND和eMMC镜像 头（2K大小）是不符合的，所以只需要启动主要的内置外设即可将镜像头压缩到1K内，剩下的功能可以在需要使用时再到外置DDR中配置 + Raw NAND 我们常使用的NANDflash也是固态硬盘中的固态颗粒，imx6ull支持MLC/SLC的 颗粒 **NAND的存储地址较为特殊，不是板子指定，而是由FCB决定**。讲到FCB不得不提一下DBBT。 **FCB**：全称为Firmwareconfiguration block，主要描述了NAND的各项硬件参数，ECC纠正参数和 镜像入口 **DBBT**：全称为DiscoveredBad Block Table，主要作用是记录NAND的坏块地址。 FCB 中有一行参数Firmware1_startingPage ![image 20251002203449510](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510022034563.png) 相应值为0x200，但是这个并不是指在NAND中的地址，而是指页数 还需要一个参数是页大小，页大小可以从NAND数据手册上找到 也可以从uboot的命令界面输入`nand info`查看, 还可以根据FCB描述的NAND参数进行计算 ![image 20251009130211779](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510091302849.png) 则可以算出页大小 0x1000 4096byte + SD卡 SD 和emmc一类都是根据跳过1K读取4K原则, 这1K里包含了MBR表，主要记录分区信息 ![image 20251009132756581](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510091337825.png) > **MMC/SD卡分区** > > MBR表中有一块存储DPT的表，DPT中包含了分区信息 > > ![image 20251009132848230](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510091338804.png) > > ![image 20251009132912395](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510091338732.png) > > 可以在Linux下用`fdisk l`查看 #### 镜像头分析 1. Image vector table，简称 IVT，IVT 里面包含了一系列的地址信息，这些地址信息在 ROM中按照固定的地址存放着 2. Boot data，启动数据，包含了镜像要拷贝到哪个地址，拷贝的大小是多少等等。 3. Device configuration data，简称 DCD，设备配置信息，重点是 DDR3 的初始化配置 4. 可执行文件，比如led.bin ![image 20251012222704716](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510122227765.png) 镜像头的作用主要是，对外置DDR进行初始化，时钟的设置，镜像的大小，uboot（裸机）的入 口地址，CPU的电源控制等 > DDR（双倍速率同步动态随机存储器）是计算机内存的一种类型，属于同步动态随机存储器（[SDRAM](https://baike.baidu.com/item/SDRAM/362234?fromModule lemma_inlink)）的改进型号，通过时钟信号的上升沿和下降沿各传输一次数据，实现双倍于传统SDRAM的传输速率 ```c const int imx6_512mb_ivtdcd_table[256] { 0X402000D1,0X87800000,0X00000000,0X877FF42C,0X877FF420,0X877FF400,0X00000000,0X00000000, 0X877FF000,0X00200000,0X00000000,0X40E801D2,0X04E401CC,0X68400C02,0XFFFFFFFF,0X6C400C02, 0XFFFFFFFF,0X70400C02,0XFFFFFFFF,0X74400C02,0XFFFFFFFF,0X78400C02,0XFFFFFFFF,0X7C400C02, 0XFFFFFFFF,0X80400C02,0XFFFFFFFF,0XB4040E02,0X00000C00,0XAC040E02,0X00000000,0X7C020E02, 0X30000000,0X50020E02,0X30000000,0X4C020E02,0X30000000,0X90040E02,0X30000000,0X88020E02, 0X30000C00,0X70020E02,0X00000000,0X60020E02,0X30000000,0X64020E02,0X30000000,0XA0040E02, 0X30000000,0X94040E02,0X00000200,0X80020E02,0X30000000,0X84020E02,0X30000000,0XB0040E02, 0X00000200,0X98040E02,0X30000000,0XA4040E02,0X30000000,0X44020E02,0X30000000,0X48020E02, 0X30000000,0X1C001B02,0X00800000,0X00081B02,0X030039A1,0X0C081B02,0X0B000300,0X3C081B02, 0X44014801,0X48081B02,0X302C4040,0X50081B02,0X343E4040,0X1C081B02,0X33333333,0X20081B02, 0X33333333,0X2C081B02,0X333333F3,0X30081B02,0X333333F3,0XC0081B02,0X09409400,0XB8081B02, 0X00080000,0X04001B02,0X2D000200,0X08001B02,0X3030331B,0X0C001B02,0XF3526B67,0X10001B02, 0X630B6DB6,0X14001B02,0XDB00FF01,0X18001B02,0X40172000,0X1C001B02,0X00800000,0X2C001B02, 0XD2260000,0X30001B02,0X23106B00,0X40001B02,0X4F000000,0X00001B02,0X00001884,0X90081B02, 0X00004000,0X1C001B02,0X32800002,0X1C001B02,0X33800000,0X1C001B02,0X31800400,0X1C001B02, 0X30802015,0X1C001B02,0X40800004,0X20001B02,0X00080000,0X18081B02,0X27020000,0X04001B02, 0X2D550200,0X04041B02,0X06100100,0X1C001B02,0X00000000,0X00000000,0X00000000,0X00000000, 0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000, 0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000, 0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000, 0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000, 0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000, 0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000, 0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000, 0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000, 0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000, 0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000, 0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000, 0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000, 0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000, 0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000, 0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000,0X00000000 }; ``` ![image 20251009134140855](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510091341912.png) > ![image 20251012222841054](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510122228090.png) > > ![image 20251012223021094](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510122230136.png) ![image 20251009135350479](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510091353527.png) > DCD其实就是I.MX6U寄存器地址和 对应的配置信息集合，Boot ROM会使用这些寄存器地址和配置集合来初始化相应的寄存器， 比如开启某些外设的时钟、初始化DDR等等。DCD区域不能超过1768Byte > > ![image 20251013145329886](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510131453975.png) > > ![image 20251013145444332](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510131454367.png) > > 其中Tag是单字节，固定为0XD2，Length为两个字节，表示DCD区域的大小，包含hea der，同样是大端模式，Version是单字节，固定为0X40或者0X41 > > CMD 就是要初始化的寄存器地址和相应的寄存器值 > > ![image 20251013145544039](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510131455099.png) > > bytes表示是目标位置宽度，单位为byte，可以选择1、2、和4字节。flags 是命令控制标志位, Address和Vlalue/Mask就是要初始化的寄存器地址和相应的寄存器值，注 意采用的是大端模式 > > ![image 20251013150011693](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510131500765.png) ![image 20251009135546607](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510091355705.png) 启动所有的时钟以及初始化DDR3所有使用的IO, 配置MMDC控制器初始化DDR3等 后面还有检查数据, NOP命令, 解锁命令等也属于DCD都是0 ## Uboot分析 在镜像头中有一个名为entry地址0x87800000, 真正的uboot入口是没有添加镜像头的 ### 目录分析 ![image 20251021161315114](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510211614785.png) ![image 20251021161408978](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510211614139.png) 在configs文件夹下面的文件是针对不同的开发板进行配置的, 使用`make xxx_defconfig`命令进行配置, 最后生成的文件是.config文件 在移植的时候, 主要需要关注board文件夹下面的文件以及configs文件 ### 第一阶段 reset 函数的位置和执行环境： 1. SPL 阶段： 存储在 SD 卡前几个扇区 由 ROM Bootloader 直接加载 在 SRAM 中执行 负责加载完整的 U Boot 2. U Boot 阶段： 存储在 SD 卡特定扇区（几百KB偏移） 由 SPL 加载到内存 在 DDR 内存中执行 负责系统初始化和内核启动 3. 代码位置：/arch/arm/cpu/armv7/start.S 文件中的 reset 函数被 SPL 和 U Boot 共享使用，通过编译时宏定义来区分不同的执行环境。 #### 链接文件 ![image 20251009145154606](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510091451659.png) 对 于 imx6ull 而 言， 其 第一阶段对应的文件时 arch/arm/cpu/armv7/start.S 和 arch/arm/cpu/armv7/lowlevel_init.S 编译通过后我们可 以看到源码根目录下会出现一个u boot.lds文件, 这个是链接的指导文件 ```cmake # 指定输出可执行文件是elf格式，32位ARM指令，小端 OUTPUT_FORMAT(\"elf32 littlearm\", \"elf32 littlearm\", \"elf32 littlearm\") # 设置输出可执行文件的体系架构为arm OUTPUT_ARCH(arm) # 将_start设为入口地址 ENTRY(_start) SECTIONS { # 指定可执行文件的全局入口点，通常这个地址都放在ROM(flash)0x0位置。 # 必须使编译器知道这个地址，通常都是修改此处来完成 . 0x00000000; # 代码以4字节对齐 . ALIGN(4); # 指定代码段 .text : { # u boot把自己拷贝到RAM中，这里指定拷贝的起始处 *(.__image_copy_start) # arch/arm/lib/vectors.S，存放异常向量表 *(.vectors) # 代码的第一个部分，arch/arm/cpu/armv7/start.S arch/arm/cpu/armv7/start.o (.text*) } .__efi_runtime_start : { *(.__efi_runtime_start) } .efi_runtime : { *(.text.efi_runtime*) *(.rodata.efi_runtime*) *(.data.efi_runtime*) } .__efi_runtime_stop : { *(.__efi_runtime_stop) } .text_rest : { # 其它代码段存放于此处 *(.text*) } # 上面的代码结束后，可能会导致没有4字节对齐，这里再一次做好4字节对齐，方便后面的只读数据段 . ALIGN(4); # 指定存放只读数据段 .rodata : { *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) } . ALIGN(4); .data : { *(.data*) } . ALIGN(4); . .; . ALIGN(4); .u_boot_list : { # 在读/写数据段后，存放一些u boot自有的函数，如uboot command等 KEEP(*(SORT(.u_boot_list*))); } . ALIGN(4); .efi_runtime_rel_start : { *(.__efi_runtime_rel_start) } .efi_runtime_rel : { *(.rel*.efi_runtime) *(.rel*.efi_runtime.*) } .efi_runtime_rel_stop : { *(.__efi_runtime_rel_stop) } . ALIGN(4); .image_copy_end : { *(.__image_copy_end) # 这里指定拷贝的末尾处，拷贝的包括代码段、只读数据、读写数据段和 u_boot_list 等 } .rel_dyn_start : { *(.__rel_dyn_start) # 动态链接符段开始处 } .rel.dyn : { *(.rel*) } .rel_dyn_end : { *(.__rel_dyn_end) # 动态链接符段末尾处 } .end : { *(.__end) } _image_binary_end .; # 二进制文件结束 . ALIGN(4096); .mmutable : { *(.mmutable) # 内存管理单元表 } .bss_start __rel_dyn_start (OVERLAY) : { KEEP(*(.__bss_start)); __bss_base .; } .bss __bss_base (OVERLAY) : { *(.bss*) . ALIGN(4); __bss_limit .; # 把__bss_limit赋值为当前位置 } .bss_end __bss_limit (OVERLAY) : { KEEP(*(.__bss_end)); } .dynsym _image_binary_end : { *(.dynsym) } .dynbss : { *(.dynbss) } .dynstr : { *(.dynstr*) } .dynamic : { *(.dynamic*) } .plt : { *(.plt*) } .interp : { *(.interp*) } .gnu.hash : { *(.gnu.hash) } .gnu : { *(.gnu*) } .ARM.exidx : { *(.ARM.exidx*) } .gnu.linkonce.armexidx : { *(.gnu.linkonce.armexidx.*) } } ``` + __image_copy_start : uboot起始地址 + __image_copy_end: uboot结束地址 + __rel_dyn_start: .rel.dyn 段起始地址 + __rel_dyn_end: .rel.dyn 段结束地址 + _image_binary_end: 镜像结束地址 + __bss_start: .bss段起始地址 + __bss_end: .bss段结束地址 > 在 U Boot 从 Flash 加载到 RAM 运行时，由于加载地址与链接地址不同，所有绝对地址引用都需要修正。`.rel.dyn` 段记录了这些需要修正的位置信息 #### 入口函数 查找`_start`即可找到它定义在arch/arm/lib/vectors.S文件中，这里便是代码入口处，见名知意，这里便指明了异常向量 ```assembly #include <config.h> /* * A macro to allow insertion of an ARM exception vector either * for the non boot0 case or by a boot0 header. 终端向量表的宏定义, 实际是一系列的跳转 */ .macro ARM_VECTORS #ifdef CONFIG_ARCH_K3 \tldr pc, _reset #else \tb\treset #endif \tldr\tpc, _undefined_instruction \tldr\tpc, _software_interrupt \tldr\tpc, _prefetch_abort \tldr\tpc, _data_abort \tldr\tpc, _not_used \tldr\tpc, _irq \tldr\tpc, _fiq \t.endm /* ************************************************************************* * * Symbol _start is referenced elsewhere, so make it global * ************************************************************************* */ .globl _start /* ************************************************************************* * * Vectors have their own section so linker script can map them easily * ************************************************************************* */ \t.section \".vectors\", \"ax\" #if defined(CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK) /* * Various SoCs need something special and SoC specific up front in * order to boot, allow them to set that in their boot0.h file and then * use it here. * * To allow a boot0 hook to insert a 'special' sequence after the vector * table (e.g. for the socfpga), the presence of a boot0 hook supresses * the below vector table and assumes that the vector table is filled in * by the boot0 hook. The requirements for a boot0 hook thus are: * (1) defines '_start:' as appropriate * (2) inserts the vector table using ARM_VECTORS as appropriate */ #include <asm/arch/boot0.h> #else /* ************************************************************************* * * Exception vectors as described in ARM reference manuals * * Uses indirect branch to allow reaching handlers anywhere in memory. * ************************************************************************* */ _start: #ifdef CONFIG_SYS_DV_NOR_BOOT_CFG \t# 则包含 SoC 特定的引导代码 \t.word\tCONFIG_SYS_DV_NOR_BOOT_CFG #endif \t# 中断向量表 \tARM_VECTORS #endif /* !defined(CONFIG_ENABLE_ARM_SOC_BOOT0_HOOK) */ /* ************************************************************************* * * Indirect vectors table * * Symbols referenced here must be defined somewhere else * ************************************************************************* */ \t.globl _reset \t.globl\t_undefined_instruction \t.globl\t_software_interrupt \t.globl\t_prefetch_abort \t.globl\t_data_abort \t.globl\t_not_used \t.globl\t_irq \t.globl\t_fiq # 这部分定义了每个异常处理程序的实际地址，通过 .word 指令存储各个异常处理函数的入口地址。 #ifdef CONFIG_ARCH_K3 _reset:\t\t\t.word reset #endif _undefined_instruction:\t.word undefined_instruction _software_interrupt:\t.word software_interrupt _prefetch_abort:\t.word prefetch_abort _data_abort:\t\t.word data_abort _not_used:\t\t.word not_used _irq:\t\t\t.word irq _fiq:\t\t\t.word fiq ``` ![image 20251009153648845](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510091536907.png) resets其实就定义在 arch/arm/cpu/armv7/start.S文件中 ```assembly reset: \t/* Allow the board to save important registers */ \tb\tsave_boot_params ``` ```assembly /************************************************************************* * * void save_boot_params(u32 r0, u32 r1, u32 r2, u32 r3) *\t__attribute__((weak)); * * Stack pointer is not yet initialized at this moment * Don't save anything to stack even if compiled with O0 * *************************************************************************/ ENTRY(save_boot_params) \tb\tsave_boot_params_ret\t\t@ back to my caller ENDPROC(save_boot_params) \t.weak\tsave_boot_params ``` ![image 20251025185035571](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510251850615.png) ```assembly save_boot_params_ret: #ifdef CONFIG_ARMV7_LPAE /* * check for Hypervisor support */ \tmrc\tp15, 0, r0, c0, c1, 1\t\t@ read ID_PFR1 \tand\tr0, r0, #CPUID_ARM_VIRT_MASK\t@ mask virtualization bits \tcmp\tr0, #(1 << CPUID_ARM_VIRT_SHIFT) \tbeq\tswitch_to_hypervisor switch_to_hypervisor_ret: #endif \t/* \t * disable interrupts (FIQ and IRQ), also set the cpu to SVC32 mode, \t * except if in HYP mode already \t */ \tmrs\tr0, cpsr \tand\tr1, r0, #0x1f\t\t@ mask mode bits 屏蔽寄存器的非模式位域，留下模式位域的值 \tteq\tr1, #0x1a\t\t@ test for HYP mode 测试看看当前 cpu 是否处于 hyp 模式 \tbicne\tr0, r0, #0x1f\t\t@ clear all mode bits 清除所有的模式位M[4:0], 不相等的时候处理 \torrne\tr0, r0, #0x13\t\t@ set SVC mode 设置为 Supervisor（SVC）模式, 不是hyp模式的时候 \torr\tr0, r0, #0xc0\t\t@ disable FIQ and IRQ 屏蔽 FIQ 和 IRQ 中断 \tmsr\tcpsr,r0 ``` > 将cpu的工作模式设置为SVC32模式（即管理模式），同时将中断禁止位与快速中断禁止位都设置为1，以此屏蔽IRQ和FIQ的中断 > > ![image 20251009154456511](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510091544556.png) > > M[4:0]决定 了当前cpu的工作模式，而位域F[6]为FIQ中断屏蔽位，位域I[7]为IRQ中断屏蔽位，位域T[5] 为Thumb执行状态位（此位没有设置，可忽略），模式位域M[4:0]详情如下表格所示 > > ![image 20251009154534801](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510091545864.png) ```assembly /* * Setup vector: * (OMAP4 spl TEXT_BASE is not 32 byte aligned. * Continue to use ROM code vector only in OMAP4 spl) */ #if !(defined(CONFIG_OMAP44XX) && defined(CONFIG_SPL_BUILD)) \t/* Set V 0 in CP15 SCTLR register for VBAR to point to vector */ \t# 是要设置SCTLR（系统控制寄存器） \tmrc\tp15, 0, r0, c1, c0, 0\t@ Read CP15 SCTLR Register \tbic\tr0, #CR_V\t\t@ V 0 \tmcr\tp15, 0, r0, c1, c0, 0\t@ Write CP15 SCTLR Register #ifdef CONFIG_HAS_VBAR \t/* Set vector address in CP15 VBAR register */ \tldr\tr0, _start # 将_start的值加载到r0寄存器当中 \t/* \t设置 c12 的值为 0x87800000（_start），即设置非安全模式异常基址寄存器为 0x87800000，结合前面清除SCTLR中的V[13]，即实现的向量表的重定位。ARM默认的异 常向量表入口在0x0地址，uboot的运行介质（norflashnandflashsram等）映射地址可能不 在0x0起始的地址，所以需要修改异常向量表入口 */ \tmcr\tp15, 0, r0, c12, c0, 0\t@Set VBAR 实现分区表的映射 #endif #endif ``` > SCTLR寄存器用于控制标准内存和系统设备，并且为在硬件内核中实现的功能提供状态信息， 其中位域V[13]的作用是选择异常向量表的基地址，根据ARMv7架构参考手册描述可知，当往 V[13]填如0时，异常向量表的基地址 0x00000000, 并且该地址可以被re mapped（重映射） > > ![image 20251025181156475](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510251811528.png) 当往V[13]填如1时，异常向量表的基地址 0xffff0000，此时该地址不能被重映射 在System.map 文件中，可以看到 _start 的值为 0x87800000，该地址为我们前面分析u boot.lds 中向量表vectors 的起始地址 ```assembly \t/* the mask ROM code should have PLL and others stable */ #ifndef CONFIG_SKIP_LOWLEVEL_INIT \t# 未被定义，后面的代码块有效 #ifdef CONFIG_CPU_V7A \t# 跳转至cpu_init_cp15标号处，执行完cpu_init_cp15函数后返回 \tbl\tcpu_init_cp15 #endif #ifndef CONFIG_SKIP_LOWLEVEL_INIT_ONLY \t# 跳转至cpu_init_crit 标号处，执行完cpu_init_crit 函数后返回 \tbl\tcpu_init_crit #endif #endif \tbl\t_main ``` ##### cpu_init_cp15 ![image 20251009224551639](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510092245712.png) ```assembly /************************************************************************* * * cpu_init_cp15 * * Setup CP15 registers (cache, MMU, TLBs). The I cache is turned on unless * CONFIG_SYS_ICACHE_OFF is defined. * *************************************************************************/ ENTRY(cpu_init_cp15) \t/* \t * Invalidate L1 I/D \t */ \tmov\tr0, #0\t\t\t@ set up for MCR 将r0寄存器的内容清零 \t/* 即将0写入到寄存器8（Register 8）中去，它是一个只写的寄存器，配合指令“mcrp15,0,r0,c8,c7,0”最后两个参数，其 作用是使整个数据和指令TLB无效，禁止虚拟地址到物理地址的转换，为何要关闭呢？因 为刚开始我们并没有建立页表，且都是直接操作物理寄存器的，所以不能打开，否则会发 生意想不到的错误。 \t*/ \tmcr\tp15, 0, r0, c8, c7, 0\t@ invalidate TLBs \tmcr\tp15, 0, r0, c7, c5, 0\t@ invalidate icache 使无效整个指令缓冲 \tmcr\tp15, 0, r0, c7, c5, 6\t@ invalidate BP array 清空整个跳转目标缓冲，关闭分支预测功能 \tmcr p15, 0, r0, c7, c10, 4\t@ DSB 清空写缓冲区，以便数据同步 \tmcr p15, 0, r0, c7, c5, 4\t@ ISB 清空预取缓冲区，以便指令同步，清空流水线中已经取到的指令，进行重新取指令。 \t /* \t * disable MMU stuff and caches \t * 将cp15的寄存器c1的值读到r0中，c1是一个控制寄存器，它包括使能或禁止 \t * mmu以及与其他存储系统相关的功能，配置存储系统以及ARM处理器中的相关部分的工作 \t */ \tmrc\tp15, 0, r0, c1, c0, 0 \t# 清除位域V[13]，即选择低端异常中断向量表，向量表基地址为0x00000000，且支持向量表重映射 \tbic\tr0, r0, #0x00002000\t@ clear bits 13 ( V ) \t# 清除位域M[0]、A[1]、C[2],即分别禁止内存管理单元mmu、地址对齐检查、数据缓冲。 \tbic\tr0, r0, #0x00000007\t@ clear bits 2:0 ( CAM) \t# 使能地址对齐检查 \torr\tr0, r0, #0x00000002\t@ set bit 1 ( A ) Align \t# 打开ARM系统的跳转预测（分支预测）功能，不打断流水线，提高指令执行效率 \torr\tr0, r0, #0x00000800\t@ set bit 11 (Z ) BTB #if CONFIG_IS_ENABLED(SYS_ICACHE_OFF) \tbic\tr0, r0, #0x00001000\t@ clear bit 12 (I) I cache #else \t# 故打开I cache \torr\tr0, r0, #0x00001000\t@ set bit 12 (I) I cache #endif \t# 将修改后的r0重新写入SCTLR寄存器中 \tmcr\tp15, 0, r0, c1, c0, 0 #ifdef CONFIG_ARM_ERRATA_716044 \t# 未使用 \tmrc\tp15, 0, r0, c1, c0, 0\t@ read system control register \torr\tr0, r0, #1 << 11\t@ set bit #11 \tmcr\tp15, 0, r0, c1, c0, 0\t@ write system control register #endif ... # 处理cp15协处理器 ``` > mmu负责从虚 拟地址到物理地址之间的转换，但是我们现在的汇编都是直接操作物理寄存器，此时如果打开了 mmu，而我们并没有有效的TLB，这样cpu可以说是胡乱运行的，所以我们需要关闭mmu，不 需要它转换地址，直接操作寄存器方便快捷。 > > 因为 catch和MMU是通过cp15管理的，刚上电的时候，CPU并不能管理他们。所以上电的时候mmu 必须关闭，指令cache可关闭，可不关闭，但数据cache一定要关闭，否则可能导致刚开始的代 码里面，去取数据的时候，从catch里面取，而这时候RAM中数据还没有cache过来，导致数据 预取异常 ##### cpu_init_crit ````assembly /************************************************************************* * * CPU_init_critical registers * * setup important registers * setup memory timing * *************************************************************************/ ENTRY(cpu_init_crit) \t/* \t * Jump to board specific initialization... \t * The Mask ROM will have already initialized \t * basic memory. Go here to bump up clock rate and handle \t * wake up conditions. \t */ \tb\tlowlevel_init\t\t@ go setup pll,mux,memory 跳转至lowlevel_init 函数 ENDPROC(cpu_init_crit) ```` > lowlevel_init 完成了内存的初始化工作，而内存的初始化依赖于开发板，所以lowlevel_init于 当前imx6u 相关，lowlevel_init 函数是与特定开发板相关的初始化函数，在这个函数里会做一些 pll 初始化，如果不是从内存启动，则会做内存初始化，方便后续拷贝到内存中运行。全局搜索 lowlevel_init 发现其在 arch/arm/cpu/armv7/lowlevel_init.S 文件中有定义 ![image 20251025183245513](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510251832554.png) ![image 20251025184523499](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510251845557.png) ```assembly WEAK(lowlevel_init) \t/* \t * Setup a temporary stack. Global data is not available yet. \t */ #if defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_STACK) \tldr\tsp, CONFIG_SPL_STACK #else \tldr\tsp, CONFIG_SYS_INIT_SP_ADDR # 设置栈指针指向CONFIG_SYS_INIT_SP_ADDR 0x0091ff00 #endif \tbic\tsp, sp, #7 /* 8 byte alignment for ABI compliance 遵从ABI的8字节对齐 */ #ifdef CONFIG_SPL_DM \tmov\tr9, #0 #else \t/* \t * Set up global data for boards that still need it. This will be \t * removed soon. \t */ #ifdef CONFIG_SPL_BUILD \tldr\tr9, gdata #else \tsub\tsp, sp, # GD_SIZE \t\t\t\t# 将堆栈指针减去GD_SIZE，GD_SIZE在include/generated/generic asm offsets.h 中 \t\t\t\t# 被定义为256，即sp sp 0x00000100\t\t \tbic\tsp, sp, #7 \t\t\t\t# 遵从ABI的8字节对齐 \tmov\tr9, sp\t # 将sp的值存储在r9寄存器当中 #endif #endif \t/* \t * Save the old lr(passed in ip) and the current lr to stack \t */ \tpush\t{ip, lr} \t/* \t * Call the very early init function. This should do only the \t * absolute bare minimum to get started. It should not: \t * \t * set up DRAM \t * use global_data \t * clear BSS \t * try to start a console \t * \t * For boards with SPL this should be empty since SPL can do all of \t * this init in the SPL board_init_f() function which is called \t * immediately after this. \t */ \tbl\ts_init # s_init函数为一个空的函数，里面什么也没做 \tpop\t{ip, pc} # lr记录函数的返回地址, 这里给pc实际是这个函数的返回 ENDPROC(lowlevel_init) ``` > CONFIG_SYS_INIT_SP_ADDR 具体是什么？它在include/configs/mx6ullevk.h 文件中有如下定义 > > ```c > #define CONFIG_SYS_INIT_SP_ADDR \\ > \t(CONFIG_SYS_INIT_RAM_ADDR + CONFIG_SYS_INIT_SP_OFFSET) > > #define CONFIG_SYS_INIT_SP_OFFSET \\ > (CONFIG_SYS_INIT_RAM_SIZE GENERATED_GBL_DATA_SIZE) > > #define CONFIG_SYS_INIT_RAM_ADDR IRAM_BASE_ADDR > #define CONFIG_SYS_INIT_RAM_SIZE IRAM_SIZE > ``` > > IRAM_BASE_ADDR 在 arch/arm/include/asm/arch mx6/imx regs.h 定义为 0x00900000, 是6ULL的内部OCRAM有128K，IRAM_SIZE 在 arch/arm/include/asm/arch mx6/imx regs.h 中定义为 0x00020000 > > ```c > #if !(defined(CONFIG_MX6SX) \\ > defined(CONFIG_MX6UL) defined(CONFIG_MX6ULL) \\ > defined(CONFIG_MX6SLL) defined(CONFIG_MX6SL)) > #define IRAM_SIZE\t\t 0x00040000 > #else > #define IRAM_SIZE\t\t 0x00020000 > #endif > ``` > > .config 文件中我们配置了 CONFIG_MX6ULL y，所以条件不成立，即定义 IRAM_SIZE 0x00020000 > > GENERATED_GBL_DATA_SIZE 在 include/generated/generic asm offsets.h 中定义为 256，转换成 十六进制为0x00000100。故 CONFIG_SYS_INIT_SP_ADDR （0x00900000 + （0x00020000 0x00000100）） 0x0091ff00 ```c /* * DO NOT MODIFY. * * This file was generated by Kbuild */ #define GENERATED_GBL_DATA_SIZE 256 /* (sizeof(struct global_data) + 15) & ~15\t@ */ #define GENERATED_BD_INFO_SIZE 80 /* (sizeof(struct bd_info) + 15) & ~15\t@ */ #define GD_SIZE 248 /* sizeof(struct global_data)\t@ */ #define GD_BD 0 /* offsetof(struct global_data, bd)\t@ */ #define GD_MALLOC_BASE 188 /* offsetof(struct global_data, malloc_base)\t@ */ #define GD_RELOCADDR 44 /* offsetof(struct global_data, relocaddr)\t@ */ #define GD_RELOC_OFF 64 /* offsetof(struct global_data, reloc_off)\t@ */ #define GD_START_ADDR_SP 60 /* offsetof(struct global_data, start_addr_sp)\t@ */ ```"},"/note/Linux/野火Linux/2025-7-19-13-Kset.html":{"title":"Kset","content":"# Kset ![image 20250719131703278](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507191317328.png) 特性 父对象是 `kobject` (`kobj >parent &other_kobj`) 父对象是 `kset` (`kobj >kset &some_kset`, 常隐含设置 `parent`) : : : **`sysfs` 目录位置** 在父 `kobject` 的目录下 在 `kset` 的目录 (`kset >kobj` 对应的目录) 下 **主要语义** 直接的层级/包含关系 (Part of) 集合/类别成员关系 (Member of) **主要目的** 构建 `sysfs` 树形结构 分组管理、提供默认行为 (`ktype`/属性) **是否自动设置 `parent`** 否 (必须显式设置) **是** (当 `parent` 未显式设置时，自动设为 `kset >kobj`) **引用持有者** 父 `kobject` 持有子 `kobject` 的引用 `kset` 持有成员 `kobject` 的引用 **`kset` 关联** 仍需单独设置 `kobj >kset` (用于类型/分组) 直接通过 `kobj >kset` 设置 ## 使用 创建一个kset, 需要添加一个处理管理的子kobject的事件的结构体, 不用的时候可以设置为NULL ```c struct kset *kset_create_and_add(const char *name, const struct kset_uevent_ops *uevent_ops,struct kobject *parent_kobj); // 注销 kset void kset_unregister(struct kset *kset); ``` 之后按照处理kobject的方式添加kobject, 参数设置为`kset >kobj`即可 ## 代码逻辑 ##### kset_create_and_add()函数 lib/kobject.c 创建一个kset并且关联一个目录项, kobj不可以直接发送消息到用户空间, 需要使用kset对象转发, 守护进程接收以后创建文件 ```c // kset_uevent_ops: 操作接口, 用于和用户空间通信 // name 目录项的名称, kset_uevent_ops 一系列接口, 用于发送信息到用户空间, parent_kobj 上一级的 struct kset *kset_create_and_add(const char *name, const struct kset_uevent_ops *uevent_ops,struct kobject *parent_kobj) { \tstruct kset *kset; \tint error; \t// 分配一个kset注册立即信息, 名字以及操作函数 \tkset kset_create(name, uevent_ops, parent_kobj); \tif (!kset) \t\treturn NULL; \t// 和目录项进行绑定, 同时通知用户空间 \terror kset_register(kset); \tif (error) { \t\tkfree(kset); \t\treturn NULL; \t} \treturn kset; } ``` ##### kset_create()函数 lib/kobject.c 分配一个kset注册立即信息, 名字以及操作函数 <img src \"https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507181437767.png\" alt \"image 20250718143722417\" style \"zoom:35%;\" /> ```c static struct kset *kset_create(const char *name,const struct kset_uevent_ops *uevent_ops,struct kobject *parent_kobj) { \tstruct kset *kset; \tint retval; \tkset kzalloc(sizeof(*kset), GFP_KERNEL); \tif (!kset) \t\treturn NULL; \tretval kobject_set_name(&kset >kobj, \"%s\", name); \tif (retval) { \t\tkfree(kset); \t\treturn NULL; \t} \t/*注册消息发送接口*/ \tkset >uevent_ops uevent_ops; \tkset >kobj.parent parent_kobj; \tkset >kobj.ktype &kset_ktype; // kobject对应属性操作接口 \tkset >kobj.kset NULL; \treturn kset; } ``` ##### kset_init()函数 lib/kobject.c ```c void kset_init(struct kset *k) { // 初始化kobj的各种标志链表 \tkobject_init_internal(&k >kobj); // 初始化链表头 \tINIT_LIST_HEAD(&k >list); \tspin_lock_init(&k >list_lock); } ``` ##### kset_register()函数 lib/kobject.c, 和目录项绑定, 同时通知用户空间 ```c int kset_register(struct kset *k) { \tint err; \tif (!k) \t\treturn EINVAL; \tkset_init(k); \t// 依据之间设置的parent, 初始化文件系统关联目录项, 和父对象进行关联, 初始化kernfs_node \terr kobject_add_internal(&k >kobj); \tif (err) \t\treturn err; \t/*发送驱动模型消息到应用层*/ \tkobject_uevent(&k >kobj, KOBJ_ADD); \treturn 0; } ``` ## 代码实现 ```c static int __init led_init(void) { \tint retval; \t/* GPIO相关寄存器映射 */ \tIMX6U_CCM_CCGR1 ioremap(0x20c406c, 4); \tSW_MUX_GPIO1_IO04 ioremap(0x20e006c, 4); \tSW_PAD_GPIO1_IO04 ioremap(0x20e02f8, 4); \tGPIO1_GDIR ioremap(0x0209c004, 4); \tGPIO1_DR ioremap(0x0209c000, 4); \t/* 使能GPIO1时钟 */ \tiowrite32(0xffffffff, IMX6U_CCM_CCGR1); \t/* 设置GPIO1_IO04复用为普通GPIO*/ \tiowrite32(5, SW_MUX_GPIO1_IO04); \t /*设置GPIO属性*/ \tiowrite32(0x10B0, SW_PAD_GPIO1_IO04); \t/* 设置GPIO1_IO04为输出功能 */ \tiowrite32(1 << 4, GPIO1_GDIR); \t/* LED输出高电平 */ \tiowrite32(1<< 4, GPIO1_DR); \t/*创建一个kset对象, 无发送信息函数以及父对象*/ \texample_kset kset_create_and_add(\"kset_example\", NULL, NULL); \tif (!example_kset) \t\treturn ENOMEM; \t/* 创建一个kobject对象*/ \tled_kobj kobject_create_and_add(\"led_kobject\", &example_kset >kobj); \tif (!led_kobj) \t\treturn ENOMEM; \t/* 为kobject设置属性文件*/ \tretval sysfs_create_group(led_kobj, &attr_group); \tif (retval) \t\tkobject_put(led_kobj); \treturn retval; \treturn 0; } ``` ![image 20250719133340540](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507191333594.png) ## 使用kset以及kobject的区别 ### 1. Uevent 事件无法发送（最严重的问题） 这是最核心的区别。`kset` 结构体中包含一个至关重要的成员 `uevent_ops`： c ``` struct kset { struct kobj_type * ktype; struct list_head list; spinlock_t list_lock; struct kobject kobj; const struct kset_uevent_ops *uevent_ops; // < 关键！ }; ``` 这个 `uevent_ops` 提供了三个函数指针： `filter`: 决定是否允许为某个 kobject 发送 uevent。 `name`: 当发送 uevent 时，如何获取该 kobject 在 uevent 中的名称。 `uevent`: 在发送 uevent 之前，允许添加额外的环境变量。 **当你调用 `kobject_uevent()` 为某个 kobject 发送事件时（例如，设备被添加 `KOBJ_ADD`），该函数会沿着父级链向上查找，直到找到一个拥有 `uevent_ops` 的父对象（即一个 `kset`），然后调用它的 `uevent_ops` 来最终完成事件的发送。** **如果父对象只是一个普通的 `kobject`：** 它没有 `uevent_ops` 成员。 `kobject_uevent()` 在向上查找时会遇到这个“死胡同”，找不到能够处理事件的 `kset`。 **结果就是：uevent 事件发送失败，用户空间的 udev 或其他守护进程永远不会收到“设备添加”、“设备移除”等通知。** **这直接导致 `/dev` 目录下不会自动创建设备节点，应用程序无法通过设备节点访问你的驱动。** ### 2. 组织结构混乱，不符合内核设计模式 `kset` 被设计为**同类 kobject 的容器**。它的 `list` 成员会维护一个链表，自动将所有属于它的子 kobject 链接起来。 c ``` // kobject_add() 内部会发生类似这样的操作 list_add_tail(&kobj >entry, &kobj >parent >kset >list); ``` **如果父对象只是一个普通的 `kobject`：** 它没有 `kset` 所需的链表头 (`list`) 和自旋锁 (`list_lock`)。 子对象无法被加入到任何容器链表中。 你无法通过遍历一个父 `kset` 的链表来找到所有属于它的子对象。 这打破了内核的对象管理模型，使得代码难以维护和调试。你无法使用内核提供的标准方法来管理和查询一组相关的对象。 ### 3. 可能缺乏必要的生命周期管理支持 虽然一个 `kobject` 可以有自己的 `ktype` 并提供 `release` 方法，但 `kset` 作为一个容器，其生命周期通常与其包含的对象紧密相关。 当引用计数为 0 时，`kset` 的 `release` 方法 (`kset_release`) 会负责释放 `kset` 本身。 如果一个 `kobject` 的父指针指向另一个 `kobject`，而不是一个管理它的 `kset`，那么父 `kobject` 的释放可能会在其子对象之前发生，这可能导致无效的父指针和不可预知的行为。而 `kset` 的设计更能保证容器生命周期的正确性。"},"/note/Linux/野火Linux/2025-7-13-07-中断.html":{"title":"通用中断处理器GIC","content":"# 通用中断处理器GIC GIC用于处理单核或者多核的芯片中的处理资源, 可以类比于stm32的NVIC ARM公司开发了4 个版本GIC规范 ，V1~V4, 板子使用的是V2 ARMv7 A内核搭配GIC 400使用 ARM会根据GIC版本的不同研发出不 同的IP核，那些半导体厂商直接购买对应的IP核即可，比如ARM针对GIC V2就开发出了G IC400 这个中断控制器IP核。当GIC接收到外部中断信号以后就会报给ARM内核，但是AR M内核只提供了四个信号给GIC来汇报中断情况：VFIQ、VIRQ、FIQ和IRQ ![image 20251014145854420](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510141458481.png) + VFIQ:虚拟快速FIQ。 + VIRQ:虚拟外部IRQ。 + FIQ:快速中断IRQ。 + IRQ:外部中断IRQ。 VFIQ 和VIRQ是针对虚拟化的，我们不讨论虚拟化，剩下的就是FIQ和IRQ了，我们前 面都讲了很多次了。本教程我们只使用IRQ，所以相当于GIC最终向ARM内核就上报一个IRQ信号 ![image 20251014150417790](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510141504849.png) 左侧部分就是中断源，中间部分就是GIC控制器，最右侧就是中断控制器向 处理器内核发送中断信息。我们重点要看的肯定是中间的GIC部分，GIC将众多的中断源分为 分为三类 1. SPI(Shared Peripheral Interrupt),共享中断，顾名思义，所有Core 共享的中断，这个是 最常见的，那些外部中断都属于SPI中断(注意！不是SPI总线那个中断) 。比如按键中断、串 口中断等等，这些中断所有的Core都可以处理，不限定特定Core 2. PPI(Private Peripheral Interrupt)，私有中断，我们说了 GIC 是支持多核的，每个核肯 定有自己独有的中断。这些独有的中断肯定是要指定的核心处理，因此这些中断就叫做私有中 断。 3. SGI(Software generated Interrupt)，软件中断，由软件触发引起的中断，通过向寄存 器GICD_SGIR 写入数据来触发，系统会使用SGI中断来完成多核之间的通信 > 中断源有很多，为了区分这些不同的中断源肯定要给他们分配一个唯一ID，这些ID就是 中断ID。每一个CPU最多支持1020个中断ID，中断ID号为ID0~ID1019。这1020个ID包 含了PPI、SPI和SGI + ID0~ID15：这 16个ID分配给SGI。 + ID16~ID31：这16个ID分配给PPI + ID32~ID1019：这988个ID分配给SPI，像GPIO中断、串口中断等这些外部中断 ，至于 具体到某个ID对应哪个中断那就由半导体厂商根据实际情况去定义了 I.MX6U的总共 使用了128个中断ID，加上前面属于PPI和SGI的32个ID，I.MX6U的中断源共有128+32 160个 ![image 20251014151046100](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510141510151.png) ## GIC结构 GIC官方手册：ARM® Generic Interrupt Controller V2最多支持 8 个内核 三类信号源： 软件中断：用于多核通信，ID0~ID15 私有中断：内核独有的中断，ID16~ID31 共享中断：所有内核共享的中断，ID32~ID1019, 使用的比较多的 ### 分发器Distributor + 将优先级最高的中断事件发送到CPU接口端 1. 全局中断使能控制。 2. 控制每一个中断的使能或者关闭。 3. 设置每个中断的优先级。 4. 设置每个中断的目标处理器列表。 5. 设置每个外部中断的触发模式：电平触发或边沿触发。 6. 设置每个中断属于组0还是组1。 #### 相关寄存器 中断数量：GICD_TYPER 中断清除： GICD_ ICENABLERn 中断使能：GICD_ISACTIVERn 中断优先级设置：GICD_IPRIORITYR ### cpu接口单元CPU Interface 1. 使能或者关闭发送到CPU Core的中断请求信号。 2. 应答中断。 3. 通知中断处理完成。 4. 设置优先级掩码，通过掩码来设置哪些中断不需要上报给CPU Core。 5. 定义抢占策略。 6. 当多个中断到来的时候，选择优先级最高的中断通知给CPU Core #### 相关寄存器 中断优先级数量：GICC_PMR 抢占优先级和子优先级设置： GICC_BPR 保存中断ID：GICC_IAR 通知cpu中断完成：GICC_EOIR ### 读取GIC基地址 #### 方法一 ![image 20250713161938224](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507131619320.png) #### 方法二：查询cp15协处理器 > CP15可以被配置为很多不同的寄存器, 用于不同的功能, 比如读取数据, 设置cache, mmu, 预测分支等 > > 在中断里面的时候需要关闭MMU, cache以及分支预测等功能 > > 1. SCTTLR: 关闭cache, mmu, 控制对齐, 分支预测 > 2. VBAR: 设置一下终端向量表的偏移位置 共有16个：c0~c15。**每个协处理器本身有多种含义，需逐步配置**, 实际就是另一种配置寄存器的方式 ```assembly //设置并读协处理器 MRC {cond} p15, <opc1>, <Rn>, <CRn>, <CRm>, <opc2> //设置并写协处理器 MCR {cond} p15, <opc1>, <Rn>, <CRn>, <CRm>, <opc2> ``` cond：执行条件，一般省略 opc1：第一层设置 Rn：通用寄存器 CRn：要设置的协处理器 CRm：第二层设置 opc2：第三层设置 ![image 20250713163559275](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507131635370.png) > 可以使用命令`mrc p15,0,r0,c1,c0,0`读取的SCTLR(系统控制寄存器) ##### CBAR寄存器 GIC的地址 ``` MRC p15, 4, r1, c15, c0, 0 ;获取 GIC 基地址 ``` CRn c15，opc1 4，CRm c0，opc2 0, 使用这个命令可以把c15设置为CBAR寄存器, 同时使用r1读取GIC的基地址 ![image 20250713164736843](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507131647939.png) ##### SCTLR寄存器 ![image 20250713170056574](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507131700626.png) 使用bit13记录中断向量表的基地址 ![image 20250713170128727](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507131701790.png) #### VABR寄存器 CRn c12，opc1 0，CRm c0，opc2 0 bit5~31：中断向量表偏移地址 ``` MRC p15, 0, <Rt>, c12, c0, 0 ;读取 VBAR 寄存器，数据保存到 Rt 中。 MCR p15, 0, <Rt>, c12, c0, 0 ;将 Rt 中的数据写到 VBAR寄存器中。 ``` ## 开关中断 cpsid i 禁止IRQ中断。 cpsie i 使能IRQ中断。 cpsid f 禁止FIQ中断。 cpsie f 使能FIQ中断。 ## 优先级 GICC_PMR寄存器 只有低8位有效，这8位最多可以设置256个优先级 GICC_BPR 只有低 3 位有效，其值不同，抢占优先级和子优先级占用的位数也不 同 ![image 20251015094734781](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510150947034.png) 某个中断ID的中断优先级设置由寄存器D_IPRIO RITYR 来完成 ## 中断向量表 V7 A会使用两级查表 ### 一级查表 自动跳转基址+偏移的方式, 这个表的起始位置一般在代码的起始位置, 基址为0, 获取的是终端的类型, 一般使用的是IRQ Cortex A内核CPU的所有外部中 断都属于这个IRQ中断，当任意一个外部中断发生的时候都会触发IRQ中断。在IRQ中断服 务函数里面就可以读取指定的寄存器来判断发生的具体是什么中断，进而根据具体的中断做出 相应的处理 addr TYPE FUNCTION MODE 0x00 Reset 复位中断, 上电以后的处理 SVC 0x04 Undefined instructions 未定义指令中断 Undef 0x08 Supervisor Call 软中断, 由 SWI 指令引起的中断，Linux的系统调用会用SW I 指令来引起软中断，通过软中断来陷入到内核空间 SYC 0x0C Prefetch abort 指令预取中止中断 ABT 0x10 Data abort 数据访问中止中断 ABT 0x14 RESERVED 未使用 未使用 0x18 IRQ interrupt IRQ 中断, 芯片内部的外设中断都会引起此 中断的发生 IRQ 0x1C FIQ interrupt FIQ 中断, 如果需要快速处理中断的话就可以使用此中断 FIQ ![image 20250713173722466](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507131737521.png) ### 二级查表 可以在官方芯片手册里面获取到, 这里的终端是共享中断, 需要有32位的偏移 ![image 20250713174059043](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507131740116.png) ![image 20250713174219138](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507131742200.png) ```c void SystemIrqHandler(uint32_t giccIar) { uint32_t intNum giccIar & 0x3FFUL; /* j检查中断号是否合法 */ if ((intNum 1023) (intNum > NUMBER_OF_INT_VECTORS)) { return; } /*如果对应的中断函数不为空，则调用该中断函数*/ if(NULL ! irqTable[intNum].irqHandler) irqTable[intNum].irqHandler(giccIar, irqTable[intNum].userParam); return; } ``` ### 代码实现 ```assembly .global _start _start: ldr pc, Reset_Handler /* Reset */ ldr pc, Undefined_Handler /* Undefined instructions */ ldr pc, SVC_Handler /* Supervisor Call */ ldr pc, PrefAbort_Handler /* Prefetch abort */ ldr pc, DataAbort_Handler /* Data abort */ .word 0 /* RESERVED */ ldr pc, IRQ_Handler /* IRQ interrupt */ ldr pc, FIQ_Handler /* FIQ interrupt */ Reset_Handler: @ 禁止 IRQ 中断 cpsid i @ 定义IRQ模式的栈地址, cps可以控制cpsr寄存器, 控制状态为IRQ模式 cps #0x12 ldr sp, 0x9FF00000 #if 0 mrs r0, cpsr bic r0, r0, #0x1f @将 r0 的低 5 位清零，也就是 cpsr 的 M0~M4 orr r0, r0, #0x12 @r0 或上 0x12,表示使用 IRQ 模式 msr cpsr, r0 @将 r0 的数据写入到 cpsr 中 ldr sp, 0x80600000 @IRQ 模式栈首地址为 0X80600000,大小为 2MB #endif \t@ 设置栈地址为64M,0X80000000~0XA0000000(512MB), 进入SVC模式 \tcps #0x13 ldr sp, 0x84000000 \t@ 打开全局中断 \tcpsie i\t\t\t\t \t@重定位data段 \tbl copy_data \t@清除bss段 \tbl clean_bss \t@ 跳转main函数 b main IRQ_Handler: \tpush {r0 r12, lr}\t\t @保存r0 r2，lr寄存器 \tmrs r0, spsr\t\t\t\t @读取spsr寄存器 \tpush {r0}\t\t\t\t\t\t@保存spsr寄存器 \tmrc p15, 4, r1, c15, c0, 0 @从CP15的C0寄存器内的值到R1寄存器中, 获取CBAR寄存器, 是GIC寄存器首地址 \tadd r1, r1, #0X2000\t\t\t@ GIC基地址加0X2000，也就是GIC的CPU接口端基地址 \tldr r0, [r1, #0XC]\t\t\t@ GIC的CPU接口端基地址加0X0C就是GICC_IAR寄存器，GICC_IAR寄存器保存这当前发生中断的中断号 \tpush {r0, r1}\t\t\t\t \t\t\t@保存r0,r1 \t \tbl SystemIrqHandler\t\t\t@ 运行C语言中断处理函数，带有一个参数，保存在R0寄存器中 \tpop {r0, r1}\t\t\t\t \tstr r0, [r1, #0X10]\t\t\t\t\t@ 中断执行完成，通知cpu \tpop {r0}\t\t\t\t\t\t \tmsr spsr_cxsf, r0\t\t\t\t @ 恢复spsr, 清除中断 \tpop {r0 r12, lr} \t\t\t@恢复r0 r2，lr寄存器 \tsubs pc, lr, #4\t\t\t\t @将lr 4赋给pc FIQ_Handler: \tldr r0, FIQ_Handler\t \tbx r0\t Undefined_Handler: \tldr r0, Undefined_Handler \tbx r0 SVC_Handler: \tldr r0, SVC_Handler \tbx r0 PrefAbort_Handler: \tldr r0, PrefAbort_Handler\t \tbx r0 DataAbort_Handler: \tldr r0, DataAbort_Handler \tbx r0 NotUsed_Handler: \tldr r0, NotUsed_Handler \tbx r0 copy_data: \tldr r1, data_load_addr @ data段的加载地址 \tldr r2, data_start @data段重定位地址 \tldr r3, data_end @data段结束地址 \tloop: \tldrb r4, [r1] @从r1读到r4 \tstrb r4, [r2] @r4存放到r2 \tadd r1, r1, #1@复制下1个字节 \tadd r2, r2, #1 \tcmp r2, r3 @ r2 、r3比较 \tbne loop @ 如果没拷贝完则重复拷贝 \tmov pc, lr clean_bss: \tldr r1, __bss_start @将链接脚本变量__bss_start变量保存于r1 ldr r2, __bss_end @将链接脚本变量__bss_end变量保存于r2 \tmov r3, #0 clean: \tstrb r3, [r1] @将当前地址下的数据清零 \tadd r1, r1, #1 @将r1内存储的地址+4 \tcmp r1, r2 @相等：清零操作结束；否则继续执行clean函数清零bss段 \tbne clean \tmov pc, lr ``` > ### 1. `mrc p15, 4, r1, c15, c0, 0` 的作用 > > armasm > > ``` > mrc p15, 4, r1, c15, c0, 0 @ 关键指令 > ``` > > **功能**：从CP15协处理器的寄存器中读取GIC的**分发器(Distributor)基地址**。 > **寄存器说明**： > `p15`：协处理器编号 > `opc1 4`：操作码1 > `CRn c15, CRm c0`：指定协处理器寄存器 > `opc2 0`：操作码2 > **返回值**：ARM内核通过此操作将**GIC分发器的物理基地址**存入`r1`寄存器。这是由硬件确定的固定地址。 > > ### 2. `add r1, r1, #0X2000` 的作用 > > armasm > > ``` > add r1, r1, #0X2000 @ 地址转换 > ``` > > **功能**：将分发器基地址偏移`0x2000`，得到**CPU接口(CPU Interface)的基地址**。 > **GIC架构划分**： > `GIC Distributor` (基地址 + `0x0000`)：全局中断管理（优先级/路由等） > `GIC CPU Interface` (基地址 + `0x2000`)：CPU核心相关的中断控制（应答/完成等） > **为何偏移0x2000**：这是ARM GICv2架构的标准偏移量，代表从分发器到CPU接口的固定地址距离。 > > > > ### 地址使用详解 > > armasm > > ``` > ldr r0, [r1, #0XC] @ r1 + 0x0C → GICC_IAR > str r0, [r1, #0X10] @ r1 + 0x10 → GICC_EOIR > ``` > > **GICC_IAR (0x0C)**：中断应答寄存器 > 读取后返回当前中断号（如0x42代表SPI#34） > 自动标记该中断为\"处理中\" > **GICC_EOIR (0x10)**：中断结束寄存器 > 写入相同中断号通知GIC中断处理完成 > 清除\"处理中\"状态，允许新中断 > > > > ### 完整流程总结 > > 1. **保存现场**：压栈寄存器及`spsr` > 2. **获取GIC地址**： > 读CP15 → **GIC Distributor基地址** (e.g., `0xA0020000`) > 加`0x2000` → **CPU Interface基地址** (e.g., `0xA0022000`) > 3. **处理中断**： > 读`GICC_IAR`获取中断号 → `r0` > 调用C函数`SystemIrqHandler(r0)` > 写`GICC_EOIR`通知完成 > 4. **恢复现场**：弹栈并返回`lr 4`（ARM流水线修正） > > > 取指令（pc） > > 译指令 > > 执行指令 > > > > ``` > > lr pc 当前执行指令+8 > > 当前执行指令的下一条：lr 4 > > ``` > > > > > **关键点**：CP15返回的是GIC Distributor的硬件固定地址，通过`+0x2000`偏移转换到CPU Interface地址空间，这是GICv2标准设计。所有后续操作（中断号获取/完成通知）都基于CPU Interface地址进行。 ## 初始化中断 ```c /*中断初始化*/ void irq_init() { GIC_Init(); for(int i 0; i < NUMBER_OF_INT_VECTORS; i++) \t{ \t\tsystem_register_irqhandler((IRQn_Type)i, NULL, NULL); \t} \t// 设置终端向量表的位置 __set_VBAR((uint32_t)0x80002000); } ``` 初始化的函数在库函数里面 ```c /* For simplicity, we only use group0 of GIC */ FORCEDINLINE __STATIC_INLINE void GIC_Init(void) { uint32_t i; uint32_t irqRegs; /*获取GIC地址*/ GIC_Type *gic (GIC_Type *)(__get_CBAR() & 0xFFFF0000UL); /*支持共享中断数量*/ irqRegs (gic >D_TYPER & 0x1FUL) + 1; /* On POR, all SPI is in group 0, level sensitive and using 1 N model */ /* Disable all PPI, SGI and SPI */ for (i 0; i < irqRegs; i++) gic >D_ICENABLER[i] 0xFFFFFFFFUL; /* Make all interrupts have higher priority */ /*设置中断优先级数为32*/ gic >C_PMR (0xFFUL << (8 __GIC_PRIO_BITS)) & 0xFFUL; /* No subpriority, all priority level allows preemption */ /*设置5级抢占优先级，3级子优先级*/ gic >C_BPR 7 __GIC_PRIO_BITS; /* Enable group0 distribution */ /*使能第0组中断*/ gic >D_CTLR 1UL; /* Enable group0 signaling */ gic >C_CTLR 1UL; } ``` > #### GIC相关寄存器 > > 分发器 > > 中断数量：GICD_TYPER > 中断清除： GICD_ ICENABLERn > 中断使能：GICD_ISACTIVERn > 中断优先级设置：GICD_IPRIORITYR > > 详见GIC官方手册 > > **4.3 Distributor register descriptions** > > cpu接口单元 > > 中断优先级数量：GICC_PMR > 抢占优先级和子优先级设置： GICC_BPR > 保存中断ID：GICC_IAR > 通知cpu中断完成：GICC_EOIR > > 详见GIC官方手册 > > **4.4 CPU interface register descriptions** > > #### GPIO中断相关寄存器 > > gpio中断触发类型:高/低电平、上升/下降沿 > > GPIO5_ICR1(0~15) > > GPIO5_ICR2(16~31) > > gpio中断屏蔽 > > GPIO5_IMR > > gpio中断状态寄存器 > > GPIO5_ISR > > gpio双边缘触发 > > GPIO5_EDGE_SEL > > 详见芯片数据手册 > > **28.5 GPIO Memory Map/Register Definition** ```c FORCEDINLINE __STATIC_INLINE uint32_t __get_CBAR(void) { return __MRC(15, 4, 15, 0, 0); } #define __STRINGIFY(x) #x /* C语言实现写cp15协处理器 */ #define __MCR(coproc, opcode_1, src, CRn, CRm, opcode_2) \\ __ASM volatile (\"MCR \" __STRINGIFY(p##coproc) \", \" __STRINGIFY(opcode_1) \", \" \\ \"%0, \" __STRINGIFY(c##CRn) \", \" __STRINGIFY(c##CRm) \", \" \\ __STRINGIFY(opcode_2) \\ : : \"r\" (src) ) /* C语言实现读cp15协处理器 */ #define __MRC(coproc, opcode_1, CRn, CRm, opcode_2) \\ ({ \\ uint32_t __dst; \\ __ASM volatile (\"MRC \" __STRINGIFY(p##coproc) \", \" __STRINGIFY(opcode_1) \", \" \\ \"%0, \" __STRINGIFY(c##CRn) \", \" __STRINGIFY(c##CRm) \", \" \\ __STRINGIFY(opcode_2) \\ : \" r\" (__dst) ); \\ __dst; \\ }) ``` > C语言读写cp15协处理器 > > `__ASM ( code : 输出操作数列表 : 输入操作数列表 );` > > code > > 具体操作指令(字符串表示) > > #是把宏参数变为一个字符串 > > ##是把两个参数连接在一起 > > __STRINGIFY(p##coproc) \", >\"p15\" > > 操作数 > > 通过%加数字引用，比如%0 引用第一个操作数，%1 引用第二个操作数 > > r：将变量放入通用寄存器, 实际是把返回值放入__dst这个参数里面 > > 处理以后得是`` ## 位置无关码和重定位 位置无关的代码可以在任意的合法内存里面运行, 位置相关的代码是需要放到对应的位置里面 一般访问的.bss, .data, .rodata段里面的数据是位置无关的, 还有一部分特殊的.text代码, 比如进行绝对地址的跳转"},"/note/Linux/野火Linux/2025-10-9-53-Uboot启动(二).html":{"title":"Uboot启动(下)","content":"# Uboot启动(下) ## _main ![image 20251025185745925](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510251857975.png) 它在arch/arm/lib/crt0.S中有定义, 主要是初始化c语言的运行环境, 实现把uboot重定位以及初始化全局变量 ```assembly /* * entry point of crt0 sequence */ ENTRY(_main) /* * Set up initial C runtime environment and call board_init_f(0). */ #if defined(CONFIG_TPL_BUILD) && defined(CONFIG_TPL_NEEDS_SEPARATE_STACK) \tldr\tr0, (CONFIG_TPL_STACK) #elif defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_STACK) \tldr\tr0, (CONFIG_SPL_STACK) #else \tldr\tr0, (CONFIG_SYS_INIT_SP_ADDR) # 加载CONFIG_SYS_INIT_SP_ADDR到r0寄存器0x0091ff00 #endif \tbic\tr0, r0, #7\t/* 8 byte alignment for ABI compliance */ \tmov\tsp, r0 # 将堆栈指针指向r0寄存器的值，由于r0本就是对齐的，所以sp 0x0091ff00 \t/* \t\t该函数有一个参数 top，根据 ARM 函数调 用规则，top r0 0x0091ff00，该函数主要作用是保留早期 malloc 区域有0x400，且为 GD（全局数 据区）留出空间，函数返回值也是r0，r0保存着预留早期malloc区域和GD后的地址 \t*/ \tbl\tboard_init_f_alloc_reserve \tmov\tsp, r0 \t/* set up gd here, outside any C code ，gd 是 GD 地址为 0x0091fa00 一个保存在 ARM 的 r9 寄存器中的 gd_t 结构体的指针 当使用 gd_t 前要用 DECLARE_GLOBAL_DATA_PTR 来声明，以指定占用 r9 寄存器避免编译器把 \tr9 分配给其它的变量 */ \tmov\tr9, r0 \t# 将GD区域清零，返回最初malloc区域的地址，即0x0091fb00 0x0091fa00+0x100 \tbl\tboard_init_f_init_reserve #if defined(CONFIG_SPL_BUILD) && defined(CONFIG_SPL_EARLY_BSS) \tCLEAR_BSS #endif \tmov\tr0, #0 \t/* \t\t1. 设置dg的标志为0 \t\t2. 标记dg的have_console为0，表示我们还没有初始化串口 \t\t3. 调用initcall_run_list（）初始化 uboot 的前半段 \t\t\t遍历执行函数指针数组init_sequence[]里面放的所有函数 \t*/ \tbl\tboard_init_f #if ! defined(CONFIG_SPL_BUILD) /* * Set up intermediate environment (new sp and gd) and call * relocate_code(addr_moni). Trick here is that we'll return * 'here' but relocated. */ \t# 重新设置环境(sp和gd)、获取gd >start_addr_sp的值赋给sp， \t# 在函数board_init_f 中会初始化gd的所有成员变量，其中gd >start_addr_sp 0X9EF44E90 \tldr\tr0, [r9, #GD_START_ADDR_SP]\t/* sp gd >start_addr_sp */ \tbic\tr0, r0, #7\t/* 8 byte alignment for ABI compliance */ \tmov\tsp, r0 \t# 获取gd >bd的地址赋给r9，此时r9存放的是老的gd，这里通过获取gd >bd的 \t# 地址来计算出新的gd的位置。GD_BD 0 \tldr\tr9, [r9, #GD_NEW_GD]\t\t/* r9 < gd >new_gd */ \t \t# 设置lr寄存器为here, 函数返回的时候到这个位置 \tadr\tlr, here \t# 读取gd >reloc_off 的值复制给r0寄存器, 计算重定位以后的程序的位置 \tldr\tr0, [r9, #GD_RELOC_OFF]\t\t/* r0 gd >reloc_off */ \tadd\tlr, lr, r0 #if defined(CONFIG_CPU_V7M) \torr\tlr, #1\t\t\t\t/* As required by Thumb only */ #endif \tldr\tr0, [r9, #GD_RELOCADDR]\t\t/* r0 gd >relocaddr */ \t# 重定位函数 \tb\trelocate_code here: /* * now relocate vectors */ \t# 重定位中断向量表 \tbl\trelocate_vectors /* Set up final (full) environment */ \t \tbl\tc_runtime_cpu_setup\t/* we still call old routine here */ #endif #if !defined(CONFIG_SPL_BUILD) CONFIG_IS_ENABLED(FRAMEWORK) #if !defined(CONFIG_SPL_BUILD) !defined(CONFIG_SPL_EARLY_BSS) \t# 清除BSS段 \tCLEAR_BSS #endif # ifdef CONFIG_SPL_BUILD \t/* Use a DRAM stack for the rest of SPL, if requested */ \tbl\tspl_relocate_stack_gd \tcmp\tr0, #0 \tmovne\tsp, r0 \tmovne\tr9, r0 # endif #if ! defined(CONFIG_SPL_BUILD) \tbl coloured_LED_init \tbl red_led_on #endif \t/* call board_init_r(gd_t *id, ulong dest_addr) */ \t# 记录函数的参数 \tmov r0, r9 /* gd_t */ \tldr\tr1, [r9, #GD_RELOCADDR]\t/* dest_addr */ \t/* call board_init_r */ #if CONFIG_IS_ENABLED(SYS_THUMB_BUILD) \tldr\tlr, board_init_r\t/* this is auto relocated! */ \tbx\tlr #else \tldr\tpc, board_init_r\t/* this is auto relocated! */ #endif \t/* we should not return here. */ #endif ENDPROC(_main) ``` > 因为并没有定 义整个全局结构体变量，编译器没有给该结构体存放区域，所以需要自己手动分配gd_t结构体的存储地址区域, 记录在r9里面，可以说gd_t结构体几乎包含了u boot中用到的所有全局变量，gd_t和bd_t都 u boot 中两个重要的数据结构在初始化操作很多都要靠这两个数据结构来保存或传递 > > ```c > #define DECLARE_GLOBAL_DATA_PTR\t\tregister volatile gd_t *gd asm (\"r9\") > ``` > > ```c >typedef struct global_data { > bd_t *bd;/* board_info 结构体指针，用来保存板子信息，如波特率、ip 地址、启动参数等 */ > unsigned long flags; /* 用于指示的标志，如板子是否已初始化、串口是否打开 */ > unsigned int baudrate; /* 串口波特率 */ > unsigned long cpu_clk; /* cpu 时钟频率 */ > unsigned long bus_clk; /* 总线时钟频率 */ > /* We cannot bracket this with CONFIG_PCI due to mpc5xxx */ > unsigned long pci_clk;\t/* pci 时钟频率 */ > unsigned long mem_clk;\t/* 内存时钟频率 */ > #if defined(CONFIG_LCD) defined(CONFIG_VIDEO) > unsigned long fb_base; /* 如果定义了 CONFIG_LCD 或 CONFIG_VIDEO， > 则此变量保存 frameBuffer 内存的基地址 */ > > #endif > #if defined(CONFIG_POST) > unsigned long post_log_word;\t/* Record POST activities */ > unsigned long post_log_res;\t /* success of POST test */ > unsigned long post_init_f_time; /* When post_init_f started */ > #endif > #ifdef CONFIG_BOARD_TYPES > unsigned long board_type; /* 板子类型 */ > #endif > unsigned long have_console; /* 用于记录串口是否已初始化 */ > #if CONFIG_IS_ENABLED(PRE_CONSOLE_BUFFER) > unsigned long precon_buf_idx; /* 串口未初始化前用于保存要打印数据的缓冲区索引 */ > #endif > unsigned long env_addr; /* 环境参数地址 */ > unsigned long env_valid; /* 环境参数 CRC 校验是否有效标志 */ > unsigned long env_has_init; > /* Bitmask of boolean of struct env_location offsets */ > int env_load_prio; /* 加载环境的优先级 */ > unsigned long ram_base; /* U Boot 所占用 RAM 的基地址 */ > unsigned long ram_top; /* Top address of RAM used by U Boot */ > > unsigned long relocaddr; /* u boot 占用 RAM 的起始地址 */ > phys_size_t ram_size; /* RAM 的大小 */ > > unsigned long mon_len; /* monitor len */ > unsigned long irq_sp; /* irq 栈指针 */ > unsigned long start_addr_sp; /* 栈指针起始地址 */ > unsigned long reloc_off; /* 重定位偏移，就是实际定向的位置与编译连接时指定的位置之差，一般为 0 */ > struct global_data *new_gd; /* 新分配的全局数据区指针 */ > #ifdef CONFIG_DM > struct udevice *dm_root; /* Root instance for Driver Model */ > struct udevice *dm_root_f; /* Pre relocation root instance */ > struct list_head uclass_root; /* Head of core tree */ > #endif > #ifdef CONFIG_TIMER > struct udevice *timer; /* Timer instance for Driver Model */ > #endif > > const void *fdt_blob; /* 设备树 */ > void *new_fdt; /* Relocated FDT */ > unsigned long fdt_size; /* Space reserved for relocated FDT */ > #ifdef CONFIG_OF_LIVE > struct device_node *of_root; > #endif > #if CONFIG_IS_ENABLED(MULTI_DTB_FIT) > const void *multi_dtb_fit; /* uncompressed multi dtb FIT image */ > #endif > struct jt_funcs *jt; /* jump table */ > char env_buf[32]; /* buffer for env_get() before reloc. */ > #ifdef CONFIG_TRACE > void *trace_buff; /* The trace buffer */ > #endif > #if defined(CONFIG_SYS_I2C) > int cur_i2c_bus; /* 当前使用的 i2c 总线 */ > #endif > #ifdef CONFIG_SYS_I2C_MXC > void *srdata[10]; > #endif > unsigned int timebase_h; > unsigned int timebase_l; > #if CONFIG_VAL(SYS_MALLOC_F_LEN) > unsigned long malloc_base; /* 早期 malloc() 的基地址 */ > unsigned long malloc_limit; /* limit address */ > unsigned long malloc_ptr; /* current address */ > #endif > #ifdef CONFIG_PCI > \t... > ``` ```c void board_init_f_init_reserve(ulong base) { \tstruct global_data *gd_ptr; #ifndef _USE_MEMCPY \tint *ptr; #endif \t/* \t * clear GD entirely and set it up. \t * Use gd_ptr, as gd may not be properly set yet. \t */ \tgd_ptr (struct global_data *)base; \t/* zero the area 清空gd_t结构体*/ #ifdef _USE_MEMCPY \tmemset(gd_ptr, '\\0', sizeof(*gd)); #else \tfor (ptr (int *)gd_ptr; ptr < (int *)(gd_ptr + 1); ) \t\t*ptr++ 0; #endif \t/* set GD unless architecture did it already */ #if !defined(CONFIG_ARM) \tarch_setup_gd(gd_ptr); #endif \t/* next alloc will be higher by one GD plus 16 byte alignment */ // 计算一下malloc区域的地址, 同时16字节对齐 \tbase + roundup(sizeof(struct global_data), 16); \t/* \t * record early malloc arena start. \t * Use gd as it is now properly set for all architectures. \t */ #if defined(CONFIG_SYS_MALLOC_F) \t/* go down one 'early malloc arena' */ \tgd >malloc_base base; //记录malloc的地址 \t/* next alloc will be higher by one 'early malloc arena' size */ \tbase + CONFIG_SYS_MALLOC_F_LEN; #endif } ``` ### board_init_f ![image 20251025215126781](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510252151835.png) 初始化一系列外设，比如串口、定时器，或者打印一些消息 初始化gd的各个成员变量，uboot会将自己重定位到DRAM最后面的地址区域，也就 是将自己拷贝到DRAM最后面的内存区域中。这么做的目的是给Linux腾出空间，防止Linux kernel覆盖掉uboot，将DRAM前面的区域完整的空出来。在拷贝之前肯定要给uboot各部分 分配好内存位置和大小 这个函数会调用init_sequence里面的一系列函数 > **init_sequence** > > ```c > staticconst init_fnc_tinit_sequence_f[] { > \tsetup_mon_len, /*设置gd >mon_len为编译出来的u boot.bin+bss段的大小*/ > \tfdtdec_setup, /*和设备树有关*/ > \tinitf_malloc, /*初始化并设置内存池, 记录malloc_limit为0x400, malloc_ptr 0*/ > \tlog_init, /* log初始化*/ > \tinitf_bootstage, /*用于记录board_init_f()的引导阶段*/ > \tsetup_spl_handoff, > \tinitf_console_record, /*平台信息记录初始化*/ > \tarch_cpu_init, /*空函数*/ > \tmach_cpu_init, /*空函数*/ > \tinitf_dm, /*驱动模型初始化*/ > \tarch_cpu_init_dm, /*空函数*/ > \tboard_early_init_f, /*设置时钟和GPIO*/ > \ttimer_init, /*定时器初始化*/ > \tenv_init, /*找到最适合存放环境变量的地址，并初始化*/ > \tinit_baud_rate, /*波特率初始化*/ > \tserial_init, /*串口初始化*/ > \tconsole_init_f, /*使能在重定位之前用的串口功能gd >have_console 1 */ > \tdisplay_options, /*显示banner，如u boot版本、编译时间等信息*/ > \tdisplay_text_info, /*显示调试信息*/ > \tprint_cpuinfo, /*显示cpu信息，如cpu速度*/ > \tshow_board_info, /*显示板子信息 对应的设备树文件为arch/arm/dts/imx6ull14x14 evk.dts， > \t\t\t\t\t文件中有关于板子model信息的描述*/ > \tannounce_dram_init, /*准备显示DRAM大小，在u boot启动时可以看到DRAM大小的信息*/ > \tdram_init, /*DRAM初始化，对于本imx6ull设置dg >ram_size 512 MiB */ > \tsetup_dest_addr, /*设置重定位地址，gd >relocaddr gd >ram_top 映射到0x80000000位置 > \t\t\t\t\tRAM顶端地址gd >ram_top gd >relocaddr 0xa0000000*/ > \treserve_round_4k, /* 4字节对齐，将内存指针调到下一个4kB*/ > \treserve_mmu, /*为mmu区域腾出空间是预留出4kB空间来存放mmu的TLB页表*/ > \treserve_video, /*预留video显示内存*/ > \treserve_trace, > \treserve_uboot, /*预留U Boot代码、data和bss区 预留出949kB给u Boot，同时做4kB对齐*/ > \treserve_malloc, /*预留malloc区16M, 以及CONFIG_ENV_SIZE 8KB, 使用start_addr_sp指向分配*/ > \treserve_board, /*预留存放板子信息区, bd_t结构体的大小 80*/ > \tsetup_machine, /*板子ID，这里没有用到, 未使用设备树的时候使用的*/ > \treserve_global_data, /*预留GD区域，栈gd >start_addr_sp指向gd段基地址248*/ > reserve_fdt, /* 预留设备树区域 */ > reserve_bootstage, > reserve_bloblist, > reserve_arch, /* 架构相关预留区 */ > reserve_stacks, /* 预留栈区，gd >start_addr_sp 指向栈底基地址 */ > dram_init_banksize, /* DRAM 的大小初始化 */ > show_dram_config, /* 显示 DRAM 的配置 */ > display_new_sp, /* 显示新的栈地址 */ > reloc_fdt,/* 和设备树有关, 复制到新地址 */ > reloc_bootstage,/* 和 u boot 阶段有关 */ > reloc_bloblist,/* 和 blob 列表有关 */ > setup_reloc, /* 重定位, 把gd表复制到新的地址里面, 计算一下偏移 */ > NULL, > }; > ``` > > > > + setup_mon_len 根据.lds 文件中 `__bss_end` 与 `__bss_end` 计算出 u boot 本身的大，赋给gd >mon_len > + fdtdec_setup 检查gd >fdt_blob 处是否存在dtb设备树 > + env_init 标记已经初始化环境变量, 将默认环境 变量default_environment的地址赋值给全局变量gd >env_addr，该数组在include/env_default.h 如bootargs、bootcmd、bootdelay等 标记环境变量有效，gd >env_valid ENV_VALID 1。 > + init_baud_rate 调用env_get_ulong 函数获取环境变量中波特率的参数, 设置gd >flags，表示串口已经准备好了, get_current() >start()返回一个指向当前被选择的串口的指针 > + console_init_f > + display_options > + spl_relocate_stack_gd ![image 20251009223537937](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510092235002.png) ### relocate_code 重定位代码, 在使用这个函数之前, 使用r0记录gd >relocaddr地址, 由于代码的位置是变化的, 所以函数的话, 绝对变量的使用会出现问题 >使用位置无关码(链接的时候使用 pie选项), 使用rel.dyn段, .rel.dyn段是存放.text段中需要重定位地址的集合 在位置无关码的代码里面, 使用一些label记录变量的绝对地址, 重定位以后, 需要把这些label更新, 加上偏移 这个字段里面的数据是两个一组, 高字节是0x17, 低字节是一个label的数据所在的地址, 需要对这个地址的label进行更新 ![image 20251025234755578](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510252348365.png) ```assembly /* * void relocate_code(addr_moni) * * This function relocates the monitor code. * * NOTE: * To prevent the code below from containing references with an R_ARM_ABS32 * relocation record type, we never refer to linker defined symbols directly. * Instead, we declare literals which contain their relative location with * respect to relocate_code, and at run time, add relocate_code back to them. */ ENTRY(relocate_code) \tldr\tr1, __image_copy_start\t/* r1 < SRC &__image_copy_start 获取镜像的起始地址 */ \tsubs\tr4, r0, r1\t\t/* r4 < relocation offset 计算一下偏移在r4 */ \tbeq\trelocate_done\t\t/* skip relocation偏移地址和起始地址相同的时候直接结束 */ \tldr\tr2, __image_copy_end\t/* r2 < SRC &__image_copy_end记录结束地址 */ copy_loop: \tldmia\tr1!, {r10 r11}\t/* copy from source address [r1] 从r1位置记录两个数据到r10 r11同时r1++ */ \tstmia\tr0!, {r10 r11}\t/* copy to target address [r0] 复制到r0位置里面 */ \tcmp\tr1, r2\t\t\t/* until source end address [r2] */ \tblo\tcopy_loop \t/* \t * fix .rel.dyn relocations \t */ \tldr\tr2, __rel_dyn_start\t/* r2 < SRC &__rel_dyn_start */ \tldr\tr3, __rel_dyn_end\t/* r3 < SRC &__rel_dyn_end */ fixloop: \t# 每次读取两个4字节的数据存放到r0和r1寄存器 \tldmia\tr2!, {r0 r1}\t\t/* (r0,r1) < (SRC location,fixup) */ \tand\tr1, r1, #0xff \tcmp\tr1, #23\t\t\t/* relative fixup? 判断是不是标志位 */ \tbne\tfixnext \t/* relative fix: increase location by offset */ \tadd\tr0, r0, r4 # 增加偏移, 获取重定位以后的记录label的地址 \tldr\tr1, [r0]\t# 加载这个数字 \tadd\tr1, r1, r4\t# 计算这个label对应数字的更新值 \tstr\tr1, [r0] # 重定位后的变量地址写入到重定位后的Label中 fixnext: \tcmp\tr2, r3 \tblo\tfixloop relocate_done: #ifdef __XSCALE__ \t/* \t * On xscale, icache must be invalidated and write buffers drained, \t * even with cache disabled 4.2.7 of xscale core developer's manual \t */ \tmcr\tp15, 0, r0, c7, c7, 0\t/* invalidate icache */ \tmcr\tp15, 0, r0, c7, c10, 4\t/* drain write buffer */ #endif \t/* ARMv4 don't know bx lr but the assembler fails to see that */ #ifdef __ARM_ARCH_4__ \tmov\tpc, lr #else \tbx\tlr #endif ENDPROC(relocate_code) ``` ### relocate_vectors 重定位中断向量表 ```assembly /* * Default/weak exception vectors relocation routine * * This routine covers the standard ARM cases: normal (0x00000000), * high (0xffff0000) and VBAR. SoCs which do not comply with any of * the standard cases must provide their own, strong, version. */ \t.section\t.text.relocate_vectors,\"ax\",%progbits \t.weak\t\trelocate_vectors ENTRY(relocate_vectors) #ifdef CONFIG_CPU_V7M \t/* \t * On ARMv7 M we only have to write the new vector address \t * to VTOR register. 不执行 \t */ \tldr\tr0, [r9, #GD_RELOCADDR]\t/* r0 gd >relocaddr */ \tldr\tr1, V7M_SCB_BASE \tstr\tr0, [r1, V7M_SCB_VTOR] #else #ifdef CONFIG_HAS_VBAR \t/* \t * If the ARM processor has the security extensions, \t * use VBAR to relocate the exception vectors. 这里, 使用协处理器重新设置 \t */ \tldr\tr0, [r9, #GD_RELOCADDR]\t/* r0 gd >relocaddr */ \tmcr p15, 0, r0, c12, c0, 0 /* Set VBAR */ #else \t/* \t * Copy the relocated exception vectors to the \t * correct address \t * CP15 c1 V bit gives us the location of the vectors: \t * 0x00000000 or 0xFFFF0000. \t */ \tldr\tr0, [r9, #GD_RELOCADDR]\t/* r0 gd >relocaddr */ \tmrc\tp15, 0, r2, c1, c0, 0\t/* V bit (bit[13]) in CP15 c1 */ \tands\tr2, r2, #(1 << 13) \tldreq\tr1, 0x00000000\t\t/* If V 0 */ \tldrne\tr1, 0xFFFF0000\t\t/* If V 1 */ \tldmia\tr0!, {r2 r8,r10} \tstmia\tr1!, {r2 r8,r10} \tldmia\tr0!, {r2 r8,r10} \tstmia\tr1!, {r2 r8,r10} #endif #endif \tbx\tlr ENDPROC(relocate_vectors) ``` #### board_init_r 和之前的board_init_r比较类似 ```c void board_init_r(gd_t *new_gd, ulong dest_addr) { #ifdef CONFIG_NEEDS_MANUAL_RELOC \tint i; #endif #ifdef CONFIG_AVR32 \tmmu_init_r(dest_addr); #endif #if !defined(CONFIG_X86) && !defined(CONFIG_ARM) && !defined(CONFIG_ARM64) \tgd new_gd; #endif #ifdef CONFIG_NEEDS_MANUAL_RELOC \tfor (i 0; i < ARRAY_SIZE(init_sequence_r); i++) \t\tinit_sequence_r[i] + gd >reloc_off; #endif \tif (initcall_run_list(init_sequence_r)) \t\thang(); \t/* NOTREACHED run_main_loop() does not return */ \thang(); } ``` 执行初始化序列init_sequence_r ```c init_fnc_t init_sequence_r[] { initr_trace, // 调试跟踪 initr_reloc, // 标记一下重定位成功 initr_caches, // 使能cache initr_reloc_global_data, // 初始化重定位以后gd里面的一些变量 initr_barrier, // 未使用 initr_malloc, // 初始化malloc initr_console_record, // 初始化控制台, 未使用 bootstage_relocate, // 启动状态重定位 initr_bootstage, board_init, /* Setup chipselects板级初始化 */ stdio_init_tables, // stdio相关 initr_serial, // 串口 initr_announce, // 调试 INIT_FUNC_WATCHDOG_RESET INIT_FUNC_WATCHDOG_RESET INIT_FUNC_WATCHDOG_RESET power_init_board, // 初始化电源芯片 initr_flash, // 未使用 INIT_FUNC_WATCHDOG_RESET initr_nand, // 初始化NAND initr_mmc, // 初始化emmc initr_env, // 初始化环境变量 INIT_FUNC_WATCHDOG_RESET initr_secondary_cpu, // 初始化其他的CPU核心, 未使用 INIT_FUNC_WATCHDOG_RESET stdio_add_devices, // 各种输入输出设备 initr_jumptable, // 初始化跳转表 console_init_r, /* fully init console as a device 控制台初始化 */ INIT_FUNC_WATCHDOG_RESET interrupt_init, initr_enable_interrupts, initr_ethaddr, // 初始化网络地址, 获取MAC board_late_init, // 后续初始化 INIT_FUNC_WATCHDOG_RESET INIT_FUNC_WATCHDOG_RESET INIT_FUNC_WATCHDOG_RESET initr_net, // 初始化网络 INIT_FUNC_WATCHDOG_RESET run_main_loop, // 主循环 }; ```"},"/note/Linux/野火Linux/2025-6-22-02-开发板下载启动.html":{"title":"开发板","content":"# 开发板 ![pro高清图](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506221954771.jpeg) 使用的硬件外设比较多, 所以需要使用12V进行供电, 一共有四路串口, 1 个EBF接口(使用1*6P2.54间距排母引出，单独引出部分IO，适用于连接部分串 口型野火模块) BOOT设置开发板的启动方式, SPDIF使用光纤进行音频的传输 咪头，是将声音信号转换为电信号的能量转换器件，是和喇叭正好相反的一个器件（电→声）。是声音设备的两个终端，咪头是输入，喇叭是输出。又名咪芯，麦克风，话筒，传声器。 WIFI和SD使用同一个SDIO接口, 所以会冲突 ## 烧录 ### SD卡烧录 可以使用以下两个软件 Etcher工具: https://www.balena.io/etcher/ ![image 20250622201050582](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506222010678.png) 野火Debian镜像: https://pan.baidu.com/s/1pji1U1vvgP8sl_TTZp59qg/ https://sourceforge.net/projects/ebf debian firmware/files [6. 烧写系统 — [野火\\]快速使用手册——基于i.MX6ULL开发板 文档](https://doc.embedfire.com/linux/imx6/quick_start/zh/latest/quick_start/install_debian/install_debian.html) ![image 20250622204404066](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506222044142.png) 引脚MODE0和MODE1选择使用串行下载启动还是使用内部的bootROM启动, 内部的bootROM运行代码的时候会进一步进行检测启动的方式 串行下载的意思就是可 以通过USB或者UART将代码下载到板子上的外置存储设备中，我们可以使用OTG1这个USB口向开发板上的SD/EMMC、NAND等存储设备下载代码 ### USB烧录 https://doc.embedfire.com/lubancat/os_release_note/zh/latest/board/nxp/imx6ull/index.html#imx6ull 解压后的“cfg.ini”文件默认为EMMC的烧写配置文件，若想要烧写NAND版本镜像，将cfg.ini 重命名为cfg emmc.ini，并将cfg nand.ini 文件重命名为cfg.ini 即可 默认烧写镜像版本为debian纯净版,若想要烧写带qt版本的固件或Ubuntu版本固件，可通过修 改cfg.ini 配置文件的内容 ![image 20251002181125147](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202510021811193.png) ```bash [profiles] chip Linux [platform] board sabresd [LIST] #name NAND Flash name eMMC [variable] board sabresd mmc 1 sxuboot sabresd sxdtb sdb 7duboot sabresd 7ddtb sdb 6uluboot 14x14evk 6uldtb 14x14 evk ldo plus lite l initramfs fsl image mfgtool initramfs imx_mfgtools.cpio.gz.u boot nand nand nanddtb gpmi weim part_uboot 0 part_rootfs 1 files_dir release my_zImage zImage my_uboot u boot mmc.imx my_bootpart boot.tar my_rootfs console armhf rootfs ubuntu bionic.tar #my_rootfs console armhf rootfs ubuntu focal.tar #my_rootfs qt armhf rootfs ubuntu bionic.tar my_dtb imx6ull 14x14 evk emmc.dtb ``` ### Linux烧录 #### 烧录到SD卡 mfgtools release ubuntu\\Profiles\\Linux\\OS Firmware\\files 可以使用正点原子修改的恩智浦工具下面的`imx6mksdboot.sh`脚本文件 可以使用` help`查看可以使用的命令 使用下面的命令进行烧录 ```bash sudo imx6mksdboot.sh device /dev/sdb flash emmc ddrsize 512 ``` 烧录好的有boot以及roofs两个分区, 烧录以后把这个files 文件也复制到rootfs分区里面 #### 烧录到semmc 在使用sd卡启动以后, 使用复制过来的脚本`imx6mksemmcboot.sh`脚本 ```bash sudo imx6mksdboot.sh device /dev/mmcblk1 ddrsize 512 ``` ## 通信 这里使用的串口是115200的波特率, 默认的密码会在连接之前通过日志打印出来, root用户的密码是root ## 使用fire config配置设备 [4. 鲁班猫系统特色功能 — [野火\\]快速使用手册——基于i.MX6ULL开发板 文档](https://doc.embedfire.com/linux/imx6/quick_start/zh/latest/quick_start/debian_sys/debian_sys.html#fire config) ![image 20250622210514979](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506222105071.png) > 使用命令`sudo fire config`进行启动 fire config工具集成了Device Tree Overlays机制，用来管理一些硬件资源的分配和模块的加载， 从而缓解多个驱动程序争用系统资源的问题。 在传统开发模式中，这个机制通常是由设备树来完成的：在开发之前根据项目需求， 提前确定系统中所有用到的硬件设备。在设备树中把所有的外围设备信息以设备树特定的语法进行描述， 在设备树被编译为dtb文件后，被linux内核加载使用。 可以看到，在传统开发过程，一旦硬件资源发生变化，就要重新修改、编译、下载设备树。比较极端的情况是: 当项目中要支持多种的硬件模块，而不同模块间往往会共用某些系统资源(如IO引脚)。 一旦系统要兼容模块任意组合使用，那么随着模块数量增加，需要编译的设备树数量将爆炸增长。 因此，使用传统设备树是不利于项目的维护和扩展的。内核为了解决这个提出了一套新的解决方案， 那就是Device Tree Overlays，中文上可理解为“设备树插件”。 它的核心原理是，通过扩展传统的设备树语法，使得各个硬件模块的信息可以独立地用新的设备树语法来描述。 这样一来，传统的主设备树中只需要保留最基础的硬件信息(主要是cpu和内存)，其他模块单独编译成“设备树插件”。 在系统实际使用时，根据实际应用情景，需要用到哪些硬件模块就把对应的设备树插件加入到主设备树即可。 如下为实际内存中设备树的示意图: ![设备树示意图](https://doc.embedfire.com/linux/imx6/quick_start/zh/latest/_images/device_tree_overlays.png) “设备树插件”无疑提高了系统的可维护性和减少了大量的重复工作，目前， 我们已经把常见的硬件模块都编译成了“设备树插件”,比如LCD、HDMI、WiFi等等。 用户可以通过fire config工具轻松地实现对硬件模块的便捷管理。 ### fire config刷机 可以使用这个软件使用SD卡进行刷机 1、执行sudo fire config，选择“Advanced”项。 如下图所示: ![image 20250622223922319](C:\\Users\\14586\\AppData\\Roaming\\Typora\\typora user images\\image 20250622223922319.png) 2、在“Advanced”,能够选择从sd烧写镜像到emmc或nand中，也可以选择从emmc或nand烧写系统到sd卡中， 从sd烧写镜像到emmc或nand可选择单次烧录，也可选择持续烧录模式方便量产使用，普通用户选择单次烧录即可。 此处我们选择从sd单次烧录到emmc或nand选项。 如下图所示： ![image 20250622223936662](C:\\Users\\14586\\AppData\\Roaming\\Typora\\typora user images\\image 20250622223936662.png) 3、系统提示: “Would you like the flasher to be enabled”，选择<Enable>。 如下图所示: ![image 20250622223945239](C:\\Users\\14586\\AppData\\Roaming\\Typora\\typora user images\\image 20250622223945239.png) 4、系统提示：“The flasher is enabled”,选择<Ok>. 如下图所示: ![image 20250622223954928](C:\\Users\\14586\\AppData\\Roaming\\Typora\\typora user images\\image 20250622223954928.png) 5、返回fire config初始界面,选择<Finish>。 如下图所示: ![image 20250622224006535](C:\\Users\\14586\\AppData\\Roaming\\Typora\\typora user images\\image 20250622224006535.png) 6、在初始界面,选择<Finish>项。 系统提示：“Some config will take effect after reboot，would you like to reboot now?” 选择<Yes>选项 如下图所示: ![image 20250622224016889](C:\\Users\\14586\\AppData\\Roaming\\Typora\\typora user images\\image 20250622224016889.png) 7、系统自动重启，重启后的系统将自动进行eMMC或者nandflash刷机。 如下图所示(以eMMC刷机为例): ![image 20250622224029225](C:\\Users\\14586\\AppData\\Roaming\\Typora\\typora user images\\image 20250622224029225.png) > 成功以后需要把这个模式关闭, 不然每一次启动都会进行刷机 #### 直接修改文件 可以通过修改/boot/uEnv.txt文件里面的 ```bash #flash_firmware continued #flash_firmware once ``` 实现一次烧写一个持续烧写的功能 ### 使用wifi模块 由于WIFI和SD卡使用的是同一个SDIO, 所以需要通过一个跳线帽进行选择功能 ![image 20250622224937499](C:\\Users\\14586\\AppData\\Roaming\\Typora\\typora user images\\image 20250622224937499.png) 在使用这给模块的时候, 会有比较多的日志输出, 可以使用命令`echo \"1 4 1 7\" > /proc/sys/kernel/printk` 使用之前的工具使能一下WIFI即可, 重启以后可以使用扫描进行连接 [24. 板载wifi — [野火\\]快速使用手册——基于i.MX6ULL开发板 文档](https://doc.embedfire.com/linux/imx6/quick_start/zh/latest/quick_start/wifi/wifi.html) 可以使用ipconfig命令查看是不是连接成功, 可以使用命令`udhcpc b 1 网卡`动态请求一个ip ### 点灯 [10. led子系统 — [野火\\]快速使用手册——基于i.MX6ULL开发板 文档](https://doc.embedfire.com/linux/imx6/quick_start/zh/latest/quick_start/led_subsystem/led_subsystem.html) 在/sys/class里面是一系列的硬件接口, 可以进入led子目录, 控制RGB灯的显示, 记录不同的灯的属性, 其中的brightness是一个0 255的数值, 可以使用命令`echo 255 > brightness`进行更改 ## 使用脚本进行控制 使用`sudo apt update`以后可以使用`sudo apt install peripheral`下载野火软件源的脚本 可以在家目录下边有一个脚本文件的文件夹, 需要使用fireconfig使能模块 测试按键的时候需要安装`evtest`的软件包 ## 安装nfs ### 服务器 ``` sudo apt install nfs kernel server y ``` 安装服务 ``` sudo vim /etc/exports ``` > ``` > # /etc/exports: the access control list for filesystems which may be exported > # to NFS clients. See exports(5). > # > # Example for NFSv2 and NFSv3: > # /srv/homes hostname1(rw,sync,no_subtree_check) hostname2(ro,sync,no_subtree_check) > # > # Example for NFSv4: > # /srv/nfs4 gss/krb5i(rw,sync,fsid 0,crossmnt,no_subtree_check) > # /srv/nfs4/homes gss/krb5i(rw,sync,no_subtree_check) > # > /home/jiao/yh linux *(rw,sync,no_root_squash) > ``` ``` sudo exportfs arv showmount e ``` ### 客户端 ``` sudo apt install nfs common y showmount e \"192.168.64.173\" sudo mount t nfs 192.168.64.173:/home/jiao/yh linux /mnt ```"}}