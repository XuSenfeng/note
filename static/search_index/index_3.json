{"/note/嵌入式/第三方移植/freeRTOS/2023-6-18-1架构概念.html":{"title":"架构概念","content":" layout: post title: \"架构概念\" date: 2023 6 18 15:39:08 +0800 tags: FreeRTOS # 架构概念 双架构 + ARM + RISC V 双系统 + `FreeRTOS`: 简单 + `RT Thread`: 成熟的国内系统"},"/note/嵌入式/第三方移植/freeRTOS/2023-7-10-fire4临界段.html":{"title":"临界段","content":" layout: post title: \"临界段\" date: 2023 7 10 15:39:08 +0800 tags: FreeRTOS # 临界段 在执行的时候不被中断的函数 一般是在系统调度以及外部中断的时候会被打断 + PRIMASK: 设置为1以后关闭所有可屏蔽中断, 只剩下NMI和硬FSULT可以响应 + FAULTMASK, 设置为1, 只有NMI可以响应 + BASEPRI: 最多有九位, 设置为一个数, 优先级比他大的都屏蔽 ## 实现 ```c //关闭中断 #define portDISABLE_INTERRUPTS()\t\t\t\tvPortRaiseBASEPRI() //在中断中使用,中断保护版本 #define portSET_INTERRUPT_MASK_FROM_ISR()\t\tulPortRaiseBASEPRI() #define portINLINE __inline #ifndef portFORCE_INLINE \t#define portFORCE_INLINE __forceinline #endif //定义函数为内联函数 static portFORCE_INLINE void vPortRaiseBASEPRI( void ) { uint32_t ulNewBASEPRI configMAX_SYSCALL_INTERRUPT_PRIORITY;//这个值高四位有效为11, 中断优先级高于11可以响应 \t__asm \t{ \t\t/* Set BASEPRI to the max syscall priority to effect a critical \t\tsection. */ \t\tmsr basepri, ulNewBASEPRI \t\tdsb \t\tisb \t} } //把原来的数字保存在返回值中, 之后设置为11, 为可以嵌套的 static portFORCE_INLINE uint32_t ulPortRaiseBASEPRI( void ) { uint32_t ulReturn, ulNewBASEPRI configMAX_SYSCALL_INTERRUPT_PRIORITY; \t__asm \t{ \t\t/* Set BASEPRI to the max syscall priority to effect a critical \t\tsection. */ \t\tmrs ulReturn, basepri \t\tmsr basepri, ulNewBASEPRI \t\tdsb \t\tisb \t} \treturn ulReturn; } ``` > 实现关闭中断, 前一个值由于不关心中断现在的状态所以不能在中断中使用 ```c //打开最有中断 #define portENABLE_INTERRUPTS()\t\t\t\t\tvPortSetBASEPRI( 0 ) //设置打开的范围 #define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)\tvPortSetBASEPRI(x) static portFORCE_INLINE void vPortSetBASEPRI( uint32_t ulBASEPRI ) { \t__asm \t{ \t\t/* Barrier instructions are not used as this function is only used to \t\tlower the BASEPRI value. */ \t\tmsr basepri, ulBASEPRI \t} } ``` > 打开中断"},"/note/嵌入式/第三方移植/freeRTOS/2023-7-19-fire12任务状态.html":{"title":"任务状态","content":" layout: post title: \"任务状态\" date: 2023 7 19 15:39:08 +0800 tags: FreeRTOS # 任务状态 ## fireRTOS代码分析 ### 任务挂起 ```c //把一个任务挂起 void vTaskSuspend( TaskHandle_t xTaskToSuspend ) { TCB_t *pxTCB; taskENTER_CRITICAL();//进入临界区 { /* 参数是NULL的时候设置为当前任务, 否则返回这一个参数的TCB */ pxTCB prvGetTCBFromHandle( xTaskToSuspend ); traceTASK_SUSPEND( pxTCB ); /* 从就绪列表里面移除 */ if( uxListRemove( &( pxTCB >xStateListItem ) ) ( UBaseType_t ) 0 ) { //重新设置优先级 taskRESET_READY_PRIORITY( pxTCB >uxPriority ); } else { mtCOVERAGE_TEST_MARKER(); } /* 检测这一个任务是不是在等待一个事件 */ if( listLIST_ITEM_CONTAINER( &( pxTCB >xEventListItem ) ) ! NULL ) { //是的话把他从事件链表里面移除 ( void ) uxListRemove( &( pxTCB >xEventListItem ) ); } \t\t//插入挂起的队列 vListInsertEnd( &xSuspendedTaskList, &( pxTCB >xStateListItem ) ); \t #if( configUSE_TASK_NOTIFICATIONS 1 ) { if( pxTCB >ucNotifyState taskWAITING_NOTIFICATION ) { /* The task was blocked to wait for a 通知, but is \t\t\t\t\tnow suspended, so no notification was received. */ pxTCB >ucNotifyState taskNOT_WAITING_NOTIFICATION; } } #endif } taskEXIT_CRITICAL(); if( xSchedulerRunning ! pdFALSE ) { /* 重新设置一下下一个软件时钟的时间(一般用于Delay以及等待事件) */ taskENTER_CRITICAL(); { prvResetNextTaskUnblockTime(); } taskEXIT_CRITICAL(); } if( pxTCB pxCurrentTCB ) { if( xSchedulerRunning ! pdFALSE ) { /* 调度器在运行 */ configASSERT( uxSchedulerSuspended 0 ); //切换任务 portYIELD_WITHIN_API(); } else { /* 调度器没有运行(不能进行任务切换) */ if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) uxCurrentNumberOfTasks ) { /* 没有其他的任务了 */ pxCurrentTCB NULL; } else { //把记录当前任务的全局变量改为优先级最高的一个任务 vTaskSwitchContext(); } } } else { mtCOVERAGE_TEST_MARKER(); } } ``` ### 恢复挂起的任务 ```c //恢复挂起的任务 void vTaskResume( TaskHandle_t xTaskToResume ) { TCB_t * const pxTCB ( TCB_t * ) xTaskToResume; /* 同上 */ if( ( pxTCB ! NULL ) && ( pxTCB ! pxCurrentTCB ) ) { taskENTER_CRITICAL(); { //检测是不是真的被挂起了 if( prvTaskIsTaskSuspended( pxTCB ) ! pdFALSE ) { traceTASK_RESUME( pxTCB ); /* 从挂起的链表里面移除 */ ( void ) uxListRemove( &( pxTCB >xStateListItem ) ); //加入就绪列表 prvAddTaskToReadyList( pxTCB ); /* A higher priority task may have just been resumed. */ if( pxTCB >uxPriority > pxCurrentTCB >uxPriority ) { /* 优先级比较当前任务高, 进行一次任务切换 */ taskYIELD_IF_USING_PREEMPTION(); } } } taskEXIT_CRITICAL(); } } ``` ```c //恢复所有挂起的任务 BaseType_t xTaskResumeAll( void ) { TCB_t *pxTCB NULL; BaseType_t xAlreadyYielded pdFALSE; \t/* If uxSchedulerSuspended is zero then this function does not match a \tprevious call to vTaskSuspendAll(). */ \tconfigASSERT( uxSchedulerSuspended ); \t/* It is possible that an ISR caused a task to be removed from an event \tlist while the scheduler was suspended. If this was the case then the \tremoved task will have been added to the xPendingReadyList. Once the \tscheduler has been resumed it is safe to move all the pending ready \ttasks from this list into their appropriate ready list. \t如果之前的任务有在ISR中并且任务调度实现的时候被从事件List里面移除, 需要处理 */ \ttaskENTER_CRITICAL(); \t{ //任务切换挂起的记录减一 \t\t uxSchedulerSuspended; \t\tif( uxSchedulerSuspended ( UBaseType_t ) pdFALSE ) \t\t{ \t\t\tif( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U ) \t\t\t{ \t\t\t\t/* Move any readied tasks from the pending list into the \t\t\t\tappropriate ready list. 这是一个等待恢复的队列, 一般是在时钟挂起的时候转为ready的任务 */ \t\t\t\twhile( listLIST_IS_EMPTY( &xPendingReadyList ) pdFALSE ) \t\t\t\t{ //处理待处理的任务 \t\t\t\t\tpxTCB ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) ); \t\t\t\t\t( void ) uxListRemove( &( pxTCB >xEventListItem ) ); \t\t\t\t\t( void ) uxListRemove( &( pxTCB >xStateListItem ) ); \t\t\t\t\tprvAddTaskToReadyList( pxTCB ); \t\t\t\t\t/* If the moved task has a priority higher than the current \t\t\t\t\ttask then a yield must be performed. */ \t\t\t\t\tif( pxTCB >uxPriority > pxCurrentTCB >uxPriority ) \t\t\t\t\t{ //需要优先级切换 \t\t\t\t\t\txYieldPending pdTRUE; \t\t\t\t\t} \t\t\t\t\telse \t\t\t\t\t{ \t\t\t\t\t\tmtCOVERAGE_TEST_MARKER(); \t\t\t\t\t} \t\t\t\t} \t\t\t\tif( pxTCB ! NULL ) \t\t\t\t{ \t\t\t\t\t/* A task was unblocked while the scheduler was suspended, \t\t\t\t\twhich may have prevented the next unblock time from being \t\t\t\t\tre calculated, in which case re calculate it now. Mainly \t\t\t\t\timportant for low power tickless implementations, where \t\t\t\t\tthis can prevent an unnecessary exit from low power \t\t\t\t\tstate. 更新一下下一个需要处理的Delay时钟的值 */ \t\t\t\t\tprvResetNextTaskUnblockTime(); \t\t\t\t} \t\t\t\t/* If any ticks occurred while the scheduler was suspended then \t\t\t\tthey should be processed now. This ensures the tick count does \t\t\t\tnot\tslip, and that any delayed tasks are resumed at the correct \t\t\t\ttime. \t\t\t\t处理挂期间任务的待处理事项*/ \t\t\t\t{ \t\t\t\t\tUBaseType_t uxPendedCounts uxPendedTicks; /* Non volatile copy. */ \t\t\t\t\tif( uxPendedCounts > ( UBaseType_t ) 0U ) \t\t\t\t\t{ \t\t\t\t\t\tdo \t\t\t\t\t\t{ //调用时钟处理函数, 更新一下时钟值 \t\t\t\t\t\t\tif( xTaskIncrementTick() ! pdFALSE ) \t\t\t\t\t\t\t{ \t\t\t\t\t\t\t\txYieldPending pdTRUE; \t\t\t\t\t\t\t} \t\t\t\t\t\t\telse \t\t\t\t\t\t\t{ \t\t\t\t\t\t\t\tmtCOVERAGE_TEST_MARKER(); \t\t\t\t\t\t\t} \t\t\t\t\t\t\t uxPendedCounts;//记录挂起的时钟数 \t\t\t\t\t\t} while( uxPendedCounts > ( UBaseType_t ) 0U ); \t\t\t\t\t\tuxPendedTicks 0; \t\t\t\t\t} \t\t\t\t\telse \t\t\t\t\t{ \t\t\t\t\t\tmtCOVERAGE_TEST_MARKER(); \t\t\t\t\t} \t\t\t\t} \t\t\t\tif( xYieldPending ! pdFALSE ) \t\t\t\t{ \t\t\t\t\t#if( configUSE_PREEMPTION ! 0 ) \t\t\t\t\t{ \t\t\t\t\t\txAlreadyYielded pdTRUE; \t\t\t\t\t} \t\t\t\t\t#endif //任务切换 \t\t\t\t\ttaskYIELD_IF_USING_PREEMPTION(); \t\t\t\t} \t\t\t} \t} \ttaskEXIT_CRITICAL(); \treturn xAlreadyYielded; } ``` ### 延时函数 ```c void vTaskDelay( const TickType_t xTicksToDelay ) { BaseType_t xAlreadyYielded pdFALSE; /* A delay time of zero just forces a reschedule. */ if( xTicksToDelay > ( TickType_t ) 0U ) { vTaskSuspendAll(); { /* A task that is removed from the event list while the \t\t\t\tscheduler is suspended will not get placed in the ready \t\t\t\tlist or removed from the blocked list until the scheduler \t\t\t\tis resumed. \t\t\t\tThis task cannot be in an event list as it is the currently \t\t\t\texecuting task. 把这一个任务插入Delay队列里面 */ prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE ); } xAlreadyYielded xTaskResumeAll(); } /* Force a reschedule if xTaskResumeAll has not already done so, we may \t\thave put ourselves to sleep. */ if( xAlreadyYielded pdFALSE ) { portYIELD_WITHIN_API(); } else { mtCOVERAGE_TEST_MARKER(); } } ``` ```c static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely ) { TickType_t xTimeToWake; const TickType_t xConstTickCount xTickCount; \t/* 把当前的任务从运行的任务里面删除 */ \tif( uxListRemove( &( pxCurrentTCB >xStateListItem ) ) ( UBaseType_t ) 0 ) \t{ \t\t/* 这个优先级没有任务了, 清除标志位 */ \t\tportRESET_READY_PRIORITY( pxCurrentTCB >uxPriority, uxTopReadyPriority ); \t} \telse \t{ \t\tmtCOVERAGE_TEST_MARKER(); \t} if( ( xTicksToWait portMAX_DELAY ) && ( xCanBlockIndefinitely ! pdFALSE ) ) { /* 设置的时间是无限, 直接挂起. */ vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB >xStateListItem ) ); } else { /* 计算唤醒的时间 */ xTimeToWake xConstTickCount + xTicksToWait; /* 设置时钟 */ listSET_LIST_ITEM_VALUE( &( pxCurrentTCB >xStateListItem ), xTimeToWake ); if( xTimeToWake < xConstTickCount ) { /* 溢出列表. */ vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB >xStateListItem ) ); } else { /* 不是溢出 */ vListInsert( pxDelayedTaskList, &( pxCurrentTCB >xStateListItem ) ); /* 设置下一次的唤醒时间 */ if( xTimeToWake < xNextTaskUnblockTime ) { xNextTaskUnblockTime xTimeToWake; } else { mtCOVERAGE_TEST_MARKER(); } } } \t } ``` ```c void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) { TickType_t xTimeToWake; BaseType_t xAlreadyYielded, xShouldDelay pdFALSE; configASSERT( pxPreviousWakeTime ); configASSERT( ( xTimeIncrement > 0U ) ); configASSERT( uxSchedulerSuspended 0 ); vTaskSuspendAll(); { /* Minor optimisation. The tick count cannot change in this \t\t\tblock. */ const TickType_t xConstTickCount xTickCount; /* Generate the tick time at which the task wants to wake. */ xTimeToWake *pxPreviousWakeTime + xTimeIncrement; \t\t//节拍器溢出 if( xConstTickCount < *pxPreviousWakeTime ) { /* 唤醒时间和现在的时间都已经溢出过了 */ if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) ) { xShouldDelay pdTRUE; } else { mtCOVERAGE_TEST_MARKER(); } } else { /* 只有溢出时间溢出了, 或者都没有溢出 */ if( ( xTimeToWake < *pxPreviousWakeTime ) ( xTimeToWake > xConstTickCount ) ) { xShouldDelay pdTRUE; } else { mtCOVERAGE_TEST_MARKER(); } } /* Update the wake time ready for the next call. */ *pxPreviousWakeTime xTimeToWake; if( xShouldDelay ! pdFALSE ) { traceTASK_DELAY_UNTIL( xTimeToWake ); \t\t\t\t/* 插入到延时链表里面 */ \t\t\t\tprvAddCurrentTaskToDelayedList( xTimeToWake xConstTickCount, pdFALSE ); \t\t\t} \t\t\telse \t\t\t{ \t\t\t\tmtCOVERAGE_TEST_MARKER(); \t\t\t} \t\t} \t\txAlreadyYielded xTaskResumeAll(); /* Force a reschedule if xTaskResumeAll has not already done so, we may \t\thave put ourselves to sleep. */ if( xAlreadyYielded pdFALSE ) { portYIELD_WITHIN_API(); } else { mtCOVERAGE_TEST_MARKER(); } } ```"},"/note/嵌入式/第三方移植/freeRTOS/2023-7-12-fire7任务延时列表实现.html":{"title":"任务延时列表","content":" layout: post title: \"任务延时列表\" date: 2023 7 12 15:39:08 +0800 tags: FreeRTOS # 任务延时列表 从就绪列表删除, 添加到延时列表 实现两条列表, 一条是溢出列表, 一条是没有溢出的列表 ```c static List_t xDelayedTaskList1; static List_t xDelayedTaskList2; static List_t * volatile pxDelayedTaskList; static List_t * volatile pxOverflowDelayedTaskList; ``` ```c //初始化列表 void prvInitialiseTaskLists( void ) { UBaseType_t uxPriority; /* 初始化就绪列表 */ for( uxPriority ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ ) \t{ \t\tvListInitialise( &( pxReadyTasksLists[ uxPriority ] ) ); \t} vListInitialise( &xDelayedTaskList1 ); \tvListInitialise( &xDelayedTaskList2 ); pxDelayedTaskList &xDelayedTaskList1; \tpxOverflowDelayedTaskList &xDelayedTaskList2;//两个指针指向对应列表 } ``` ```c static volatile TickType_t xNextTaskUnblockTime\t\t ( TickType_t ) 0U; static volatile BaseType_t xNumOfOverflows \t\t\t ( BaseType_t ) 0; ``` > 下一个要解锁的变量 ```c //在初始化的时候把下一个解锁的任务时间设置为最大值, 计数器时间设置为0 //初始化下一个任务的启动时间为最大值 xNextTaskUnblockTime portMAX_DELAY; xTickCount 0; ``` + 修改代码 延时函数 ```c void vTaskDelay( const TickType_t xTicksToDelay ) { TCB_t *pxTCB NULL; /* 获取当前任务的TCB */ pxTCB pxCurrentTCB; /* 设置延时时间 */ //pxTCB >xTicksToDelay xTicksToDelay; /* 将任务插入到延时列表 */ prvAddCurrentTaskToDelayedList( xTicksToDelay ); /* 任务切换 */ taskYIELD(); } ``` ```c static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait ) { TickType_t xTimeToWake; /* 获取系统时基计数器xTickCount的值 */ const TickType_t xConstTickCount xTickCount; /* 将任务从就绪列表中移除 */ \tif( uxListRemove( &( pxCurrentTCB >xStateListItem ) ) ( UBaseType_t ) 0 ) \t{ \t\t/* 将任务在优先级位图中对应的位清除 */ portRESET_READY_PRIORITY( pxCurrentTCB >uxPriority, uxTopReadyPriority ); \t} /* 计算延时到期时，系统时基计数器xTickCount的值是多少 */ xTimeToWake xConstTickCount + xTicksToWait; /* 将延时到期的值设置为节点的排序值 */ listSET_LIST_ITEM_VALUE( &( pxCurrentTCB >xStateListItem ), xTimeToWake ); /* 溢出 */ if( xTimeToWake < xConstTickCount ) { vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB >xStateListItem ) ); } else /* 没有溢出 */ { vListInsert( pxDelayedTaskList, &( pxCurrentTCB >xStateListItem ) ); /* 更新下一个任务解锁时刻变量xNextTaskUnblockTime的值 */ if( xTimeToWake < xNextTaskUnblockTime ) { xNextTaskUnblockTime xTimeToWake; } }\t } ``` > 把他的就绪位删除, 从就序列表中删除, 之后根据解除的时间进行切换唤醒时间 + 更新一下时钟处理函数 ```c void xTaskIncrementTick( void ) { \tTCB_t * pxTCB; \tTickType_t xItemValue; \tconst TickType_t xConstTickCount xTickCount + 1; \txTickCount xConstTickCount; \t/* 如果xConstTickCount溢出，则切换延时列表 */ \tif( xConstTickCount ( TickType_t ) 0U ) \t{ \t\ttaskSWITCH_DELAYED_LISTS(); \t} \t/* 最近的延时任务延时到期 */ \tif( xConstTickCount > xNextTaskUnblockTime ) \t{ \t\tfor( ;; ) \t\t{ \t\t\tif( listLIST_IS_EMPTY( pxDelayedTaskList ) ! pdFALSE ) \t\t\t{ \t\t\t\t/* 延时列表为空，设置xNextTaskUnblockTime为可能的最大值 */ \t\t\t\txNextTaskUnblockTime portMAX_DELAY; \t\t\t\tbreak; \t\t\t} \t\t\telse /* 延时列表不为空 */ \t\t\t{ \t\t\t\tpxTCB ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); \t\t\t\txItemValue listGET_LIST_ITEM_VALUE( &( pxTCB >xStateListItem ) ); \t\t\t\t/* 直到将延时列表中所有延时到期的任务移除才跳出for循环 */ if( xConstTickCount < xItemValue ) \t\t\t\t{ \t\t\t\t\txNextTaskUnblockTime xItemValue; \t\t\t\t\tbreak; \t\t\t\t} \t\t\t\t/* 将任务从延时列表移除，消除等待状态 */ \t\t\t\t( void ) uxListRemove( &( pxTCB >xStateListItem ) ); \t\t\t\t/* 将解除等待的任务添加到就绪列表 */ \t\t\t\tprvAddTaskToReadyList( pxTCB ); \t\t\t} \t\t} \t}/* xConstTickCount > xNextTaskUnblockTime */ /* 任务切换 */ portYIELD(); } ``` + 之后修改taskRESET_READY_PRIORITY() ## 出错 在调用之后会出现硬件错误, 调整栈指针之后没有解决, 并且经过仿真发现不能正常到达空闲任务"},"/note/嵌入式/第三方移植/freeRTOS/2023-6-21-4修改.html":{"title":"修改","content":" layout: post title: \"修改\" date: 2023 6 21 15:39:08 +0800 tags: FreeRTOS # 修改 ## 增加串口打印功能 ### 去掉无关代码 删除所有的测试文件代码 ### 增加串口打印 初始化串口, 实现这个函数"},"/note/嵌入式/第三方移植/freeRTOS/2023-7-12-fire8实现时间片.html":{"title":"实现时间片","content":" layout: post title: \"实现时间片\" date: 2023 7 12 15:39:08 +0800 tags: FreeRTOS # 实现时间片 + 修改时间中断函数 ```c void xPortSysTickHandler( void ) { \t/* 关中断 */ vPortRaiseBASEPRI(); { //xTaskIncrementTick(); /* 更新系统时基 */ \t\tif( xTaskIncrementTick() ! pdFALSE ) \t\t{ \t\t\t/* 任务切换，即触发PendSV */ //portNVIC_INT_CTRL_REG portNVIC_PENDSVSET_BIT; taskYIELD(); \t\t} \t} \t/* 开中断 */ vPortClearBASEPRIFromISR(); } ``` > 这里只有当有任务的优先级比较高的时候才会发生切换 ```c //void xTaskIncrementTick( void ) BaseType_t xTaskIncrementTick( void ) { \tTCB_t * pxTCB; \tTickType_t xItemValue; BaseType_t xSwitchRequired pdFALSE; \tconst TickType_t xConstTickCount xTickCount + 1; \txTickCount xConstTickCount; \t/* 如果xConstTickCount溢出，则切换延时列表 */ \tif( xConstTickCount ( TickType_t ) 0U ) \t{ \t\ttaskSWITCH_DELAYED_LISTS(); \t} \t/* 最近的延时任务延时到期 */ \tif( xConstTickCount > xNextTaskUnblockTime ) \t{ \t\tfor( ;; ) \t\t{ \t\t\tif( listLIST_IS_EMPTY( pxDelayedTaskList ) ! pdFALSE ) \t\t\t{ \t\t\t\t/* 延时列表为空，设置xNextTaskUnblockTime为可能的最大值 */ \t\t\t\txNextTaskUnblockTime portMAX_DELAY; \t\t\t\tbreak; \t\t\t} \t\t\telse /* 延时列表不为空 */ \t\t\t{ \t\t\t\tpxTCB ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); \t\t\t\txItemValue listGET_LIST_ITEM_VALUE( &( pxTCB >xStateListItem ) ); \t\t\t\t/* 直到将延时列表中所有延时到期的任务移除才跳出for循环 */ if( xConstTickCount < xItemValue ) \t\t\t\t{ \t\t\t\t\txNextTaskUnblockTime xItemValue; \t\t\t\t\tbreak; \t\t\t\t} \t\t\t\t/* 将任务从延时列表移除，消除等待状态 */ \t\t\t\t( void ) uxListRemove( &( pxTCB >xStateListItem ) ); \t\t\t\t/* 将解除等待的任务添加到就绪列表 */ \t\t\t\tprvAddTaskToReadyList( pxTCB ); #if ( configUSE_PREEMPTION 1 ) { if( pxTCB >uxPriority > pxCurrentTCB >uxPriority ) { xSwitchRequired pdTRUE; } } #endif /* configUSE_PREEMPTION */ \t\t\t} \t\t} \t}/* xConstTickCount > xNextTaskUnblockTime */ #if ( ( configUSE_PREEMPTION 1 ) && ( configUSE_TIME_SLICING 1 ) ) { if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB >uxPriority ] ) ) > ( UBaseType_t ) 1 ) { xSwitchRequired pdTRUE; } } #endif /* ( ( configUSE_PREEMPTION 1 ) && ( configUSE_TIME_SLICING 1 ) ) */ /* 任务切换 */ //portYIELD(); } ``` > 实际上就是在时间片到达之后检测是否有更高优先级的任务存在, 存在的话就进行切换, 否则不进行切换"},"/note/嵌入式/第三方移植/freeRTOS/2023-7-11-fire5空闲任务阻塞延时.html":{"title":"空闲任务阻塞延时","content":" layout: post title: \"空闲任务阻塞延时\" date: 2023 7 11 15:39:08 +0800 tags: FreeRTOS # 空闲任务和阻塞延时 之前使用的是软件延时, CPU空等来延时, RTOS使用阻塞延时, 任务需要延时的时候放弃CPU使用权, 没有其他任务的时候会运行空闲任务 空闲任务的优先级最低, 启动调度器的时候创建 ```c /**************空闲任务*****************/ StackType_t IdleTaskStack[configMINIMAL_STACK_SIZE]; TCB_t IdleTaskTCB;\t//控制块 void vApplicationGetIdleTaskMemory( TCB_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize ) { \t\t*ppxIdleTaskTCBBuffer &IdleTaskTCB; \t\t*ppxIdleTaskStackBuffer IdleTaskStack; \t\t*pulIdleTaskStackSize configMINIMAL_STACK_SIZE; } ``` > main.c文件中的创建 ```c static portTASK_FUNCTION( prvIdleTask, pvParameters ) { \t/* 防止编译器的警告 */ \t( void ) pvParameters; for(;;) { /* 空闲任务暂时什么都不做 */ } } ``` > 任务主体 ```c /* 创建空闲任务start */ TCB_t *pxIdleTaskTCBBuffer NULL; /* 用于指向空闲任务控制块 */ StackType_t *pxIdleTaskStackBuffer NULL; /* 用于空闲任务栈起始地址 */ uint32_t ulIdleTaskStackSize; /* 获取空闲任务的内存：任务栈和任务TCB */ vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize ); xIdleTaskHandle xTaskCreateStatic( (TaskFunction_t)prvIdleTask, /* 任务入口 */ \t\t\t\t\t (char *)\"IDLE\", /* 任务名称，字符串形式 */ \t\t\t\t\t (uint32_t)ulIdleTaskStackSize , /* 任务栈大小，单位为字 */ \t\t\t\t\t (void *) NULL, /* 任务形参 */ \t\t\t\t\t (StackType_t *)pxIdleTaskStackBuffer, /* 任务栈起始地址 */ \t\t\t\t\t (TCB_t *)pxIdleTaskTCBBuffer ); /* 任务控制块 */ /* 将任务添加到就绪列表 */ vListInsertEnd( &( pxReadyTasksLists[0] ), &( ((TCB_t *)pxIdleTaskTCBBuffer) >xStateListItem ) ); /* 创建空闲任务end */ ``` > 在初始函数里面创建 ## 实现阻塞延时 ```c \tTickType_t xTicksToDelay; /* 用于延时 */ ``` > 在TCB中添加参数 ```c void vTaskSwitchContext( void ) { \t/* 如果当前线程是空闲线程，那么就去尝试执行线程1或者线程2， 看看他们的延时时间是否结束，如果线程的延时时间均没有到期， 那就返回继续执行空闲线程 */ \tif( pxCurrentTCB &IdleTaskTCB ) \t{ \t\tif(Task1TCB.xTicksToDelay 0) \t\t{ pxCurrentTCB &Task1TCB; \t\t} \t\telse if(Task2TCB.xTicksToDelay 0) \t\t{ pxCurrentTCB &Task2TCB; \t\t} \t\telse \t\t{ \t\t\treturn;\t\t/* 线程延时均没有到期则返回，继续执行空闲线程 */ \t\t} \t} \telse \t{ \t\t/*如果当前线程是线程1或者线程2的话，检查下另外一个线程,如果另外的线程不在延时中，就切换到该线程 否则，判断下当前线程是否应该进入延时状态，如果是的话，就切换到空闲线程。否则就不进行任何切换 */ \t\tif(pxCurrentTCB &Task1TCB) \t\t{ \t\t\tif(Task2TCB.xTicksToDelay 0) \t\t\t{ pxCurrentTCB &Task2TCB; \t\t\t} \t\t\telse if(pxCurrentTCB >xTicksToDelay ! 0) \t\t\t{ pxCurrentTCB &IdleTaskTCB; \t\t\t} \t\t\telse \t\t\t{ \t\t\t\treturn;\t\t/* 返回，不进行切换，因为两个线程都处于延时中 */ \t\t\t} \t\t} \t\telse if(pxCurrentTCB &Task2TCB) \t\t{ \t\t\tif(Task1TCB.xTicksToDelay 0) \t\t\t{ pxCurrentTCB &Task1TCB; \t\t\t} \t\t\telse if(pxCurrentTCB >xTicksToDelay ! 0) \t\t\t{ pxCurrentTCB &IdleTaskTCB; \t\t\t} \t\t\telse \t\t\t{ \t\t\t\treturn;\t\t/* 返回，不进行切换，因为两个线程都处于延时中 */ \t\t\t} \t\t} \t} } ``` > 修改切换任务的函数, 只有三个函数之间的切换, 判断各个函数是不是在延时中 ### 配置时钟 ```c /* ************************************************************************* * 初始化SysTick ************************************************************************* */ void vPortSetupTimerInterrupt( void ) { /* 设置重装载寄存器的值 */ portNVIC_SYSTICK_LOAD_REG ( configSYSTICK_CLOCK_HZ / configTICK_RATE_HZ ) 1UL; /* 设置系统定时器的时钟等于内核时钟 使能SysTick 定时器中断 使能SysTick 定时器 */ portNVIC_SYSTICK_CTRL_REG ( portNVIC_SYSTICK_CLK_BIT portNVIC_SYSTICK_INT_BIT portNVIC_SYSTICK_ENABLE_BIT ); } /* ************************************************************************* * SysTick中断服务函数 ************************************************************************* */ void xPortSysTickHandler( void ) { \t/* 关中断 */ vPortRaiseBASEPRI(); /* 更新系统时基 */ xTaskIncrementTick(); \t/* 开中断 */ vPortClearBASEPRIFromISR(); } ``` > ```c > #define xPortSysTickHandler SysTick_Handler > ``` > > > 中断函数重命名 ```c //更新时钟 void xTaskIncrementTick( void ) { TCB_t *pxTCB NULL; BaseType_t i 0; /* 更新系统时基计数器xTickCount，xTickCount是一个在port.c中定义的全局变量 */ const TickType_t xConstTickCount xTickCount + 1; xTickCount xConstTickCount; /* 扫描就绪列表中所有线程的xTicksToDelay，如果不为0，则减1 */ \tfor(i 0; i<configMAX_PRIORITIES; i++) \t{\t \t\t//获取下一个链表的第一个任务 pxTCB ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &pxReadyTasksLists[i] ) );//这里只获取第一个项, 所以配置为同一个优先级不能正常使用 \t\tif(pxTCB >xTicksToDelay > 0) \t\t{ \t\t\tpxTCB >xTicksToDelay ; \t\t} \t} /* 任务切换 */ portYIELD(); } ``` > 更新时钟 ```c //实现阻塞延时 void vTaskDelay( const TickType_t xTicksToDelay ) { TCB_t *pxTCB NULL; /* 获取当前任务的TCB */ pxTCB pxCurrentTCB; /* 设置延时时间 */ pxTCB >xTicksToDelay xTicksToDelay; /* 任务切换 */ taskYIELD(); } ```"},"/note/嵌入式/第三方移植/freeRTOS/2023-11-22-wds06资源管理.html":{"title":"资源管理","content":" layout: post title: \"资源管理\" date: 2023 11 22 15:39:08 +0800 tags: FreeRTOS # 资源管理 独占的访问临界资源有三种方式 + 公平竞争: 使用互斥量, 谁先获得谁就使用 + 屏蔽中断 + 屏蔽任务切换 ## 屏蔽中断 屏蔽中断有两套宏：任务中使用、ISR中使用： ```c 任务中使用： taskENTER_CRITICA()/taskEXIT_CRITICAL() ISR中使用：taskENTER_CRITICAL_FROM_ISR()/taskEXIT_CRITICAL_FROM_ISR() ``` > 低优先级的中断被屏蔽了：优先级低于、等于 configMAX_SYSCALL_INTERRUPT_PRIORITY > > 高优先级的中断可以产生：优先级高于 configMAX_SYSCALL_INTERRUPT_PRIORITY > > > 这个宏会操作中断屏蔽寄存器, stm32只使用了八位寄存器的高四位 > > + 但是，这些中断ISR里，不允许使用FreeRTOS的API函数(这些中断需要在上面的宏的范围里面) > > 任务调度依赖于中断、依赖于API函数，所以：这两段代码之间，不会有任务调度产生 ```c static portFORCE_INLINE void vPortRaiseBASEPRI( void ) { uint32_t ulNewBASEPRI configMAX_SYSCALL_INTERRUPT_PRIORITY; __asm { /* Set BASEPRI to the max syscall priority to effect a critical * section. */ /* *INDENT OFF* */ msr basepri, ulNewBASEPRI\t//设置这个寄存器设置屏蔽的等级 dsb isb /* *INDENT ON* */ } } ``` + 在中断中使用 ```c void vAnInterruptServiceRoutine( void ) { /* 用来记录当前中断是否使能 */ UBaseType_t uxSavedInterruptStatus; /* 在ISR中，当前时刻中断可能是使能的，也可能是禁止的 * 所以要记录当前状态, 后面要恢复为原先的状态 * 执行这句代码后，屏蔽中断 */ uxSavedInterruptStatus taskENTER_CRITICAL_FROM_ISR(); /* 访问临界资源 */ /* 恢复中断状态 */ taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus ); /* 现在，当前ISR可以被更高优先级的中断打断了 */ } ``` > 在屏蔽以后需要保持当前函数的状态, 返回的是当前的屏蔽的等级, 默认设置的是11优先级 ## 禁止任务调度 直接暂停调度器就可以了 ```c /* 暂停调度器 */ void vTaskSuspendAll( void ); /* 恢复调度器 * 返回值: pdTRUE表示在暂定期间有更高优先级的任务就绪了 * 可以不理会这个返回值 */ BaseType_t xTaskResumeAll( void ); ``` ```c void vTaskSuspendAll( void ) { /* A critical section is not required as the variable is of type * BaseType_t. Please read Richard Barry's reply in the following link to a * post in the FreeRTOS support forum before reporting this as a bug! * https://goo.gl/wu4acr */ /* portSOFRWARE_BARRIER() is only implemented for emulated/simulated ports that * do not otherwise exhibit real time behaviour. */ portSOFTWARE_BARRIER(); /* The scheduler is suspended if uxSchedulerSuspended is non zero. An increment * is used to allow calls to vTaskSuspendAll() to nest. */ ++uxSchedulerSuspended;//主要就是这一个全局变量 /* Enforces ordering for ports and optimised compilers that may otherwise place * the above increment elsewhere. */ portMEMORY_BARRIER(); } ``` > 这些个函数可以进行递归使用, 内部会记录嵌套的深度, 只有深度为0的时候, taskEXIT_CRITICAL()才会重新使能中断"},"/note/嵌入式/第三方移植/freeRTOS/2023-7-5-fire1项目构建.html":{"title":"项目构建","content":" layout: post title: \"项目构建\" date: 2023 7 5 15:39:08 +0800 tags: FreeRTOS # 项目构建 新建文件夹 创建工程, 使用ARM M3进行创建 之后添加 ![image 20230705200025995](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401251336039.png) startup_ARMCM3.s是汇编文件, 启动文件 > 这个文件主要就是一个中断向量表, 之后会有一些中断函数的默认初始值 startup_ARMCM3.c时钟配置文件 > 主要设置的是一个全局变量时钟频率, 还有设置中断向量表的偏移 ![image 20230705200111569](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401251336040.png) ![image 20230705204943209](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401251336041.png) 在这里添加分组, 文件, 定义一个空实现的main函数 ![image 20230705205326927](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401251336042.png) 添加配置时钟 ![image 20230705205840524](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401251336043.png) ![image 20230705205903521](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401251336044.png) 添加头文件 ## 裸机系统 通常有成分轮询系统, 和前后台系统 轮询系统, 在编程的时候初始化硬件, 之后在一个循环里面不断地循环, 顺序的做事情 前后台系统, 在这基础上加上了中断, 前台就是中断, 后台就是一个无限循环 ## 多任务系统 任务有优先级 优先级比较高的任务会被优先执行, 通过调度器执行, 有高优先级任务的时候高优先级优先执行 ![image 20230705211030514](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401251336045.png)"},"/note/嵌入式/第三方移植/freeRTOS/2023-6-18-2堆栈.html":{"title":"堆栈","content":" layout: post title: \"堆栈\" date: 2023 6 18 15:39:08 +0800 tags: FreeRTOS # 堆 一块空闲的内存 ```c char heap_buf[1024]; int pos 0; void *my_malloc(int size) { int old_pos; pos + size; return &heap_bunf[old_pos]; } ``` 这一段内存被称为内存 ```c void my_free(void buf) { } ``` # 栈 ```c void c_func(void); void b_func(void); int a_func(int val) { int a 0; a + val; b_func(); c_func(); return a; } ``` > 返回地址现保存在LR寄存器, 保存在栈中, 在函数a_func调用函数b_func的时候会把LR寄存器中的值保存下来, 还会保存局部变量 > > C函数开头 > > 1. 划分出栈用来保存变量, SP寄存器 > 2. LR寄存器入栈 > 3. 执行代码"},"/note/嵌入式/第三方移植/freeRTOS/2023-7-5-fire2数据结构.html":{"title":"数据结构","content":" layout: post title: \"数据结构\" date: 2023 7 5 15:39:08 +0800 tags: FreeRTOS # 数据结构 ## 数据类型 portCHAR: char portSHORT: short portLONG: long portTickType: unsigned short int, unsigned int用于系统计时器, 具体要看文件FreeRTOSConfig.h文件中宏configUSE_16_BIT_TICKS为1时为16位, 0为32位 portBASE_TYPE: long, 根据处理器架构界定 ### 前缀 c: char s: short l: long x: portBASE_TYPE u: 无符号类型 p: 指针 ### 函数名 包括前缀, 文件名, 函数名 ### 宏 宏的前缀是文件名 信号量的函数是一个宏定义, 但是是遵循函数名的命名方法 ![image 20230706103041491](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401251337241.png) ## 列表和列表项 列表和列表项, 实际上就是链表和链表项 单链表: 本身包含一个节点指针, 指向后一个节点, 还可以包含一些私有信息, 通常内嵌一个节点, 会使用链表把零散的数据串联, 通常会设置一个根节点 双向链表: 有两个节点指针 ```c struct xLIST_ITEM { listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE /*< Set to a known value if config \t\t\t\t\t\tUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1.辅助值 */ configLIST_VOLATILE TickType_t xItemValue; /*< The value being listed. In most cases this is used to \t\t\t\t\t\t\t\t\t\t\t\t\t\tsort the list in ascending order. */ struct xLIST_ITEM * configLIST_VOLATILE pxNext; /*< Pointer to the next ListItem_t in the list. 指向后一个节点*/ struct xLIST_ITEM * configLIST_VOLATILE pxPrevious; /*< Pointer to the previous ListItem_t in the list. 指向前一个节点*/ void * pvOwner; /*< Pointer to the object (normally a TCB) that contains the list item. There is therefore a two way link between the object containing the list item and the list item itself. 指向拥有该节点的对象, 通常是PCB*/ struct xLIST * configLIST_VOLATILE pxContainer; /*< Pointer to the list in which this list item is placed (if any). */ listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE /*< Set to a known value if \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tconfigUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */ }; typedef struct xLIST_ITEM ListItem_t; /* For some reason lint wants this as two separate \tdefinitions. */ ``` ```c struct xLIST_ITEM { \tTickType_t\txItemValue;\t\t\t\t//辅助值 \tstruct xLIST_ITEN * pxNext;\t\t\t//指向下一个节点 \tstruct xLIST_ITEN * pxPrevious;\t\t//指向上一个节点 \tvoid * pvOwner;\t\t\t\t//指向拥有该节点的内核对象 \tvoid * pvCountainer;\t\t//指向节点所在的链表 }; typedef struct xLIST_ITEM ListItem_t; //结尾节点 struct xMINI_LIST_ITEM { \tTickType_t\txItemValue;\t\t\t\t//辅助值, 帮助节点升序排列 \tstruct xLIST_ITEM * pxNext;\t\t\t//指向上一个节点 \tstruct xLIST_ITEM * pxPrevious;\t\t//指向下一个节点 }; typedef struct xMINI_LIST_ITEM MiniListItem_t; //初始化最开始的链表 typedef struct xLIST { \tUBaseType_t uxNumberOfItem;\t\t//节点计数器 \tListItem_t\t* pxIndex;\t\t\t//链表节点索引 \tMiniListItem_t xListEnd;\t\t//最后一个节点 }List_t; ``` > 定义三中节点 ![image 20230706112438094](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401251337242.png) > 初始化根节点 ```c //根节点初始化函数 void vListInitialist(List_t * const pxList) { \tpxList >pxIndex (ListItem_t *) & (pxList >xListEnd);\t\t//索引指向最后一个节点 \tpxList >xListEnd.xItemValue portMAX_DELAY;//最后一个节点的数字指向最大 \tpxList >xListEnd.pxNext (ListItem_t *) &(pxList >xListEnd);//最后节点pxNext和pxPrevious指向自身 \tpxList >xListEnd.pxPrevious (ListItem_t *) &(pxList >xListEnd); \tpxList >uxNumberOfItem (UBaseType_t)0U;\t\t//设置节点的数量为0 } ``` ![image 20230706113548330](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401251337243.png) ```c //把一个空的链表插入到尾部 void vListInsertEnd(List_t * const pxList, ListItem_t * const pxNewListItem) { \tListItem_t * const pxIndex pxList >pxIndex;\t//获得最后一个节点的指针, 转换为ListItem类型 \t \tpxNewListItem >pxNext pxIndex;\t\t//新节点最后指向末尾的节点 \tpxNewListItem >pxPrevious pxIndex >pxPrevious;\t//前一个节点指向末尾结点的前一个节点 \tpxIndex >pxPrevious >pxNext pxNewListItem;\t//之前的倒数第二个节点指向自己 \tpxIndex >pxPrevious pxNewListItem;\t//末尾结点前一个节点指向自己 \t \t(pxList >uxNumberOfItem)++; } ``` ![image 20230706122402274](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401251337244.png) 按照值的大小进行插入 ```c //按照数字的大小进行插入 void vListInsert(List_t * const pxList, ListItem_t * const pxNewListItem) { \tListItem_t * pxIterator; \t \tconst TickType_t xValueOfInsertion pxNewListItem >xItemValue;\t//获取节点的数字 \t \tif(xValueOfInsertion portMAX_DELAY) \t{ \t\tpxIterator pxList >xListEnd.pxPrevious;//如果优先级最低直接插到最后 \t\t \t\t \t}else \t{ \t\tfor(pxIterator (ListItem_t *) &pxList >xListEnd; \t\t\tpxIterator >pxNext >xItemValue < xValueOfInsertion; \t\tpxIterator pxIterator >pxNext) \t\t{ \t\t\t//初始为第一个链表, 如果链表的值比较小, 就变为下一个链表 \t\t\t//这里只是为了找到位置 \t\t \t\t} \t} \t//插入后面的值改变 \tpxNewListItem >pxNext pxIterator >pxNext; \tpxNewListItem >pxNext >pxPrevious pxNewListItem; \t//改变前面 \tpxNewListItem >pxPrevious pxIterator; \tpxIterator >pxNext pxNewListItem; \t//保存该节点所在的链表 \tpxNewListItem >pvCountainer (void *)pxList; \t(pxList >uxNumberOfItem)++; } ``` ![image 20230706124423375](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401251337245.png) ```c //移除一个链表 UBaseType_t uxListRemove(ListItem_t * const pxItemToRemov) { \t//获取链表的节点 \tList_t * const pxList (List_t *)pxItemToRemov >pvCountainer; \t \t \tpxItemToRemov >pxNext >pxPrevious pxItemToRemov >pxPrevious; \tpxItemToRemov >pxPrevious >pxNext pxItemToRemov >pxNext; \t \tif(pxList >pxIndex pxItemToRemov) \t{ \t\t//如果删除的最后的节点把他设置为现在数字最大的节点(前一个) \t\tpxList >pxIndex pxItemToRemov >pxPrevious; \t} \tpxItemToRemov >pvCountainer NULL; \t(pxList >uxNumberOfItem) ; \t \treturn pxList >uxNumberOfItem; } ``` + 一些宏定义 ```c //初始化节点拥有者 #define liseSET_LIST_ITEM_OWNER(pxListItem, pxOwner) \t((pxListItem >pvOwner) (void *)(pxOwner)) //获得节点的拥有者 #define listGET_ITEM_ITEM_OWNER(pxListItem) \t\t\t(pxListItem >pvOwner) //初始化节点的排序辅助值 #define liseSET_LIST_ITEM_VALUE(pxListItem, xValue) \t((pxListItem) >xItemValue) xValue //获取链表根节点的计数器值 #define liseGET_LIST_ITEM_VALUE(pxListItem)\t\t\t\t(pxListItem >xItemValue) //获取链表的入口节点计数器的值 #define listGET_ITEM_VALUE_OF_HEAD_ENTRY(pxList) \t\t(((pxList) >xListEnd).pxNext >xItemValue) //获取入口节点 #define listGET_HEAD_ENTRY(pxList)\t\t\t\t\t\t( ( ( pxList ) >xListEnd ).pxNext ) //获取下一个节点 #define listGET_NEXT(pxListItem) \t\t\t\t\t\t( ( pxListItem ) >pxNext ) //获取最后一个节点 #define listGET_END_MARKER(pxList) \t\t\t\t\t\t((ListItem_t const *)(&((pxList) >xListEnd))) //链表是否为空 #define listLIST_IS_EMPTY( pxList ) \t\t\t\t\t((BaseType_t)((pxList) >uxNumberOfItems (UBaseType_t)0)) //获取连接数 #define listCURRENT_LIST_LENGTH( pxList ) \t\t\t\t( ( pxList ) >uxNumberOfItems ) /* 获取链表节点的OWNER，即TCB */ #define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )\t\t\t\t\t\t\t\t\t\t\\ {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\ \tList_t * const pxConstList ( pxList );\t\t\t\t\t\t\t\t\t\t\t \\ \t/* 节点索引指向链表第一个节点调整节点索引指针，指向下一个节点， 如果当前链表有N个节点，当第N次调用该函数时，pxInedex则指向第N个节点 */\\ \t( pxConstList ) >pxIndex ( pxConstList ) >pxIndex >pxNext;\t\t\t\t\t\t\t\\ \t/* 当前链表为空 */ \\ \tif( ( void * ) ( pxConstList ) >pxIndex ( void * ) &( ( pxConstList ) >xListEnd ) )\t\\ \t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\ \t\t( pxConstList ) >pxIndex ( pxConstList ) >pxIndex >pxNext;\t\t\t\t\t\t\\ \t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\ \t/* 获取节点的OWNER，即TCB */ \\ \t( pxTCB ) ( pxConstList ) >pxIndex >pvOwner;\t\t\t\t\t\t\t\t\t\t\t \\ } #define listGET_OWNER_OF_HEAD_ENTRY( pxList ) ( (&( ( pxList ) >xListEnd )) >pxNext >pvOwner ) ``` ![image 20230709102454093](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401251337246.png)"},"/note/嵌入式/第三方移植/freeRTOS/2023-6-20-3FreeRTOS.html":{"title":"FreeRTOS","content":" layout: post title: \"FreeRTOS\" date: 2023 6 20 15:39:08 +0800 tags: FreeRTOS # FreeRTOS [官网](https://www.freertos.org/zh cn cmn s/a00104.html#getting started) 文件中只保留E:\\a学习\\9.myOC\\FreeRTOS\\FreeRTOSv202212.01\\FreeRTOS\\Demo文件夹下面的CORTEX_STM32F103_Keil, 其他的文件暂时用不到 source文件是核心文件 ![image 20230620001237465](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401251335467.png) > 只保留以上的文件, 之后打开项目 ![image 20230620001249646](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401251335468.png) ![image 20230620001510156](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401251335469.png) 之后编译文件, 选择用keil5进行格式转换 ``` *** Using Compiler 'V5.06 update 5 (build 528)', folder: 'D:\\kiel5\\ARM\\ARMCC\\Bin' Build target 'Target 1' assembling cortexm3_macro_rvds.s... cortexm3_macro_rvds.s: error: A1023E: File \"..\\Common\\drivers\\ST\\STM32F10xFWLib\\src\\cortexm3_macro_rvds.s\" could not be opened: No such file or directory compiling semtest.c... \"no source\": Error: #5: cannot open source input file \"..\\Common\\Minimal\\semtest.c\": No such file or directory ..\\Common\\Minimal\\semtest.c: 0 warnings, 1 error compiling death.c... \"no source\": Error: #5: cannot open source input file \"..\\Common\\Minimal\\death.c\": No such file or directory ..\\Common\\Minimal\\death.c: 0 warnings, 1 error compiling blocktim.c... \"no source\": Error: #5: cannot open source input file \"..\\Common\\Minimal\\blocktim.c\": No such file or directory ..\\Common\\Minimal\\blocktim.c: 0 warnings, 1 error compiling lcd.c... \"no source\": Error: #5: cannot open source input file \"..\\Common\\drivers\\ST\\STM32F10xFWLib\\src\\lcd.c\": No such file or directory ..\\Common\\drivers\\ST\\STM32F10xFWLib\\src\\lcd.c: 0 warnings, 1 error compiling comtest.c... \"no source\": Error: #5: cannot open source input file \"..\\Common\\Minimal\\comtest.c\": No such file or directory ..\\Common\\Minimal\\comtest.c: 0 warnings, 1 error compiling flash.c... \"no source\": Error: #5: cannot open source input file \"..\\Common\\Minimal\\flash.c\": No such file or directory ..\\Common\\Minimal\\flash.c: 0 warnings, 1 error compiling BlockQ.c... \"no source\": Error: #5: cannot open source input file \"..\\Common\\Minimal\\BlockQ.c\": No such file or directory ..\\Common\\Minimal\\BlockQ.c: 0 warnings, 1 error compiling integer.c... \"no source\": Error: #5: cannot open source input file \"..\\Common\\Minimal\\integer.c\": No such file or directory ..\\Common\\Minimal\\integer.c: 0 warnings, 1 error compiling ParTest.c... ParTest\\ParTest.c(35): error: #5: cannot open source input file \"partest.h\": No such file or directory #include \"partest.h\" ParTest\\ParTest.c: 0 warnings, 1 error compiling serial.c... serial\\serial.c(41): error: #5: cannot open source input file \"serial.h\": No such file or directory #include \"serial.h\" serial\\serial.c: 0 warnings, 1 error compiling PollQ.c... \"no source\": Error: #5: cannot open source input file \"..\\Common\\Minimal\\PollQ.c\": No such file or directory ..\\Common\\Minimal\\PollQ.c: 0 warnings, 1 error compiling main.c... main.c(74): error: #5: cannot open source input file \"BlockQ.h\": No such file or directory #include \"BlockQ.h\" main.c: 0 warnings, 1 error \".\\RTOSDemo.axf\" 4 Error(s), 0 Warning(s). Target not created. Build Time Elapsed: 00:00:04 ``` > 发现Common目录不能少, 重新添加 > 原有的文件是在lcd上面打印文字, 但是没有配套的板子 ## 目录分析 + Demo是一系列的工程文件 下面是各种芯片的项目文件 + source是核心文件, 事件组, 链表, 队列, stream buff, 任务, 定时器 ![image 20230621195959158](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401251335471.png) portable是可移植文件, 顶层目录是各种编译器, keil下面显示看RVDS, RVDS下面是各种架构 ## 编程规范 ![image 20230621201125341](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401251335472.png) > 后面的变量经常作为返回值 这个文件在source/portable/ARM_CM3 + 变量名: ![image 20230621201532751](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401251335473.png) + 函数名 返回值类型 + 实现的文件名 + 函数的功能 prv表示私有函数 ![image 20230621201917146](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401251335474.png) + 宏的名字 ![image 20230621202018243](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401251335475.png) 小写代表的是文件名字 ![image 20230621202040119](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401251335476.png)"},"/note/嵌入式/第三方移植/freeRTOS/2023-11-21-wds04计时器.html":{"title":"定时器","content":" layout: post title: \"定时器\" date: 2023 11 21 15:39:08 +0800 tags: FreeRTOS # 定时器 + 超时时间 + 函数 + 单次触发还是多次触发 ## 实际实现 会使用两个链表, 这两个链表一个记录溢出的时钟, 一个记录没有溢出的时钟 使用指针进行切换 ```c PRIVILEGED_DATA static List_t xActiveTimerList1 {0}; PRIVILEGED_DATA static List_t xActiveTimerList2 {0}; PRIVILEGED_DATA static List_t *pxCurrentTimerList NULL; PRIVILEGED_DATA static List_t *pxOverflowTimerList NULL; ``` ## 守护任务 一般来说定时器的时间到了处理函数会放在Tick中断里面, 但是在中断里面执行长度未知的代码是不确定的, 所以FreeRTOS使用了一个线程来执行定时器函数 这个任务是\"RTOS Damemon Task\"守护函数, 使用宏定义configUSE_TIMERS的时候会自动创建这一个任务 守护任务的优先级为：configTIMER_TASK_PRIORITY；定时器命令队列的长度为 configTIMER_QUEUE_LENGTH, 还有一个栈的深度configTIMER_TASK_STACK_DEPTH > 这个队列是在调用定时器任务的时候其他的函数相当于在给任务发送命令, 命令保存在一个队列里面 ```c vApplicationGetTimerTaskMemory( &pxTimerTaskTCBBuffer, &pxTimerTaskStackBuffer, &ulTimerTaskStackSize ); ``` > 使用这一个获取任务的参数 ```c static portTASK_FUNCTION( prvTimerTask, pvParameters ) { TickType_t xNextExpireTime; BaseType_t xListWasEmpty; /* Just to avoid compiler warnings. */ ( void ) pvParameters; #if ( configUSE_DAEMON_TASK_STARTUP_HOOK 1 ) { extern void vApplicationDaemonTaskStartupHook( void ); /* Allow the application writer to execute some code in the context of * this task at the point the task starts executing. This is useful if the * application includes initialisation code that would benefit from * executing after the scheduler has been started. */ vApplicationDaemonTaskStartupHook(); } #endif /* configUSE_DAEMON_TASK_STARTUP_HOOK */ for( ; ; ) { /* Query the timers list to see if it contains any timers, and if so, * obtain the time at which the next timer will expire. */ xNextExpireTime prvGetNextExpireTime( &xListWasEmpty ); /* If a timer has expired, process it. Otherwise, block this task * until either a timer does expire, or a command is received. */ prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty ); /* Empty the command queue. */ prvProcessReceivedCommands(); } } ``` ```c #define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void * pvParameters ) ``` > 相当于定义了一个`void prvTimerTask( void * pvParameters )` > > 在`xTimerCreateTimerTask`里面会创建这个函数的优先级 ## 定时器的状态 有两个状态: 运行和冬眠 ![image 20231121225742533](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311212257595.png) ## 实际使用 + 创建 ```c /* 使用动态分配内存的方法创建定时器 * pcTimerName:定时器名字, 用处不大, 尽在调试时用到 * xTimerPeriodInTicks: 周期, 以Tick为单位 * uxAutoReload: 类型, pdTRUE表示自动加载, pdFALSE表示一次性 * pvTimerID: 回调函数可以使用此参数, 比如分辨是哪个定时器 * pxCallbackFunction: 回调函数 * 返回值: 成功则返回TimerHandle_t, 否则返回NULL */ TimerHandle_t xTimerCreate( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction ); /* 使用静态分配内存的方法创建定时器 * pcTimerName:定时器名字, 用处不大, 尽在调试时用到 * xTimerPeriodInTicks: 周期, 以Tick为单位 * uxAutoReload: 类型, pdTRUE表示自动加载, pdFALSE表示一次性 * pvTimerID: 回调函数可以使用此参数, 比如分辨是哪个定时器 * pxCallbackFunction: 回调函数 * pxTimerBuffer: 传入一个StaticTimer_t结构体, 将在上面构造定时器 * 返回值: 成功则返回TimerHandle_t, */ TimerHandle_t xTimerCreateStatic(const char * const pcTimerName, TickType_t xTimerPeriodInTicks, UBaseType_t uxAutoReload, void * pvTimerID, TimerCallbackFunction_t pxCallbackFunction, StaticTimer_t *pxTimerBuffer ); ``` > 在使用的时候可以使用pvTimerID传递一个参数 > > 回调函数 > > ```c > void ATimerCallback( TimerHandle_t xTimer ); > typedef void (* TimerCallbackFunction_t)( TimerHandle_t xTimer ); > ``` ```c typedef struct tmrTimerControl /* The old naming convention is used to prevent breaking kernel aware debuggers. */ { const char * pcTimerName; /* 计时器的名字 */ ListItem_t xTimerListItem; /* 计时器使用的列表项 */ TickType_t xTimerPeriodInTicks; /*计时器的时间 */ void * pvTimerID; /* 一个计时器的ID, 用于在一个回调函数里面区分不同的时钟 */ TimerCallbackFunction_t pxCallbackFunction; /* 回调函数 */ #if ( configUSE_TRACE_FACILITY 1 ) UBaseType_t uxTimerNumber; /*<< An ID assigned by trace tools such as FreeRTOS+Trace */ #endif uint8_t ucStatus; /* 记录是不是Static的 */ } xTIMER; ``` + 删除 ```c /* 删除定时器 * xTimer: 要删除哪个定时器 * xTicksToWait: 超时时间 * 返回值: pdFAIL表示\"删除命令\"在xTicksToWait个Tick内无法写入队列 * pdPASS表示成功 */ BaseType_t xTimerDelete( TimerHandle_t xTimer, TickType_t xTicksToWait ); ``` > 定时器的很多API函数，都是通过发送\"命令\"到命令队列，由守护任务来实现。 如果队列满了，\"命令\"就无法即刻写入队列。我们可以指定一个超时时间 xTicksToWait ，等待一会。 + 启动停止 ```c /* 启动定时器 * xTimer: 哪个定时器 * xTicksToWait: 超时时间 * 返回值: pdFAIL表示\"启动命令\"在xTicksToWait个Tick内无法写入队列 * pdPASS表示成功 */ BaseType_t xTimerStart( TimerHandle_t xTimer, TickType_t xTicksToWait ); /* 启动定时器(ISR版本) * xTimer: 哪个定时器 * pxHigherPriorityTaskWoken: 向队列发出命令使得守护任务被唤醒, * 如果守护任务的优先级比当前任务的高, * 则\"*pxHigherPriorityTaskWoken pdTRUE\", * 表示需要进行任务调度 * 返回值: pdFAIL表示\"启动命令\"无法写入队列 * pdPASS表示成功 */ BaseType_t xTimerStartFromISR( TimerHandle_t xTimer, \t\t\t\tBaseType_t *pxHigherPriorityTaskWoken ); /* 停止定时器 * xTimer: 哪个定时器 * xTicksToWait: 超时时间 * 返回值: pdFAIL表示\"停止命令\"在xTicksToWait个Tick内无法写入队列 * pdPASS表示成功 */ BaseType_t xTimerStop( TimerHandle_t xTimer, TickType_t \txTicksToWait ); /* 停止定时器(ISR版本) * xTimer: 哪个定时器 * pxHigherPriorityTaskWoken: 向队列发出命令使得守护任务被唤醒, * 如果守护任务的优先级比当前任务的高, * 则\"*pxHigherPriorityTaskWoken pdTRUE\", * 表示需要进行任务调度 * 返回值: pdFAIL表示\"停止命令\"无法写入队列 * pdPASS表示成功 */ BaseType_t xTimerStopFromISR( TimerHandle_t xTimer, \t\t\t\tBaseType_t *pxHigherPriorityTaskWoken ); ``` > 这些函数的 xTicksToWait 表示的是，把命令写入命令队列的超时时间。命令队列可能已经满 了，无法马上把命令写入队列里，可以等待一会。 > > xTicksToWait 不是定时器本身的超时时间，不是定时器本身的\"周期\"。 > > 创建定时器时，设置了它的周期(period)。 xTimerStart() 函数是用来启动定时器。假设调用 xTimerStart() 的时刻是tX，定时器的周期是n，那么在 tX+n 时刻定时器的回调函数被调用。 > > 如果定时器已经被启动，但是它的函数尚未被执行，再次执行 xTimerStart() 函数相当于执行 xTimerReset() ，重新设定它的启动时间。 + 复位 使用 xTimerReset() 函数可以让定时器的状态从冬眠态转换为运行 态，相当于使用 xTimerStart() 函数。 如果定时器已经处于运行态，使用 xTimerReset() 函数就相当于重新确定超时时间。假设调用 xTimerReset() 的时刻是tX，定时器的周期是n，那么 tX+n 就是重新确定的超时时间。 ```c /* 复位定时器 * xTimer: 哪个定时器 * xTicksToWait: 超时时间 * 返回值: pdFAIL表示\"复位命令\"在xTicksToWait个Tick内无法写入队列 * pdPASS表示成功 */ BaseType_t xTimerReset( TimerHandle_t xTimer, TickType_t xTicksToWait ); /* 复位定时器(ISR版本) * xTimer: 哪个定时器 * pxHigherPriorityTaskWoken: 向队列发出命令使得守护任务被唤醒, * 如果守护任务的优先级比当前任务的高, * 则\"*pxHigherPriorityTaskWoken pdTRUE\", * 表示需要进行任务调度 * 返回值: pdFAIL表示\"停止命令\"无法写入队列 * pdPASS表示成功 */ BaseType_t xTimerResetFromISR( TimerHandle_t xTimer, \t\t\t\t\tBaseType_t *pxHigherPriorityTaskWoken ); ``` + 修改周期 ```c /* 修改定时器的周期 * xTimer: 哪个定时器 * xNewPeriod: 新周期 * xTicksToWait: 超时时间, 命令写入队列的超时时间 * 返回值: pdFAIL表示\"修改周期命令\"在xTicksToWait个Tick内无法写入队列 * pdPASS表示成功 */ BaseType_t xTimerChangePeriod( TimerHandle_t xTimer, TickType_t xNewPeriod, TickType_t xTicksToWait ); /* 修改定时器的周期 * xTimer: 哪个定时器 * xNewPeriod: 新周期 * pxHigherPriorityTaskWoken: 向队列发出命令使得守护任务被唤醒, * 如果守护任务的优先级比当前任务的高, * 则\"*pxHigherPriorityTaskWoken pdTRUE\", * 表示需要进行任务调度 * 返回值: pdFAIL表示\"修改周期命令\"在xTicksToWait个Tick内无法写入队列 * pdPASS表示成功 */ BaseType_t xTimerChangePeriodFromISR( TimerHandle_t xTimer, TickType_t xNewPeriod, BaseType_t *pxHigherPriorityTaskWoken ); ``` + 使用ID ID可以作为标志也可以作为参数 ```c /* 获得定时器的ID * xTimer: 哪个定时器 * 返回值: 定时器的ID */ void *pvTimerGetTimerID( TimerHandle_t xTimer ); /* 设置定时器的ID * xTimer: 哪个定时器 * pvNewID: 新ID * 返回值: 无 */ void vTimerSetTimerID( TimerHandle_t xTimer, void *pvNewID ); ``` ## 示例 使用定时器进行硬件消抖 ![image 20231122083653147](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311220836226.png) 在引脚中断的时候打开一个时钟 ![image 20231122084311943](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311220843989.png) ![image 20231122084335093](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311220843130.png) 使用这一个模拟按键 # FreeRTOS实现 ```c static void prvTimerTask( void *pvParameters ) { TickType_t xNextExpireTime; BaseType_t xListWasEmpty; \tfor( ;; ) \t{ \t\t//获取先下一个时钟的时间, 没有时钟返回0, 以及获取列表是不是空的 xNextExpireTime prvGetNextExpireTime( &xListWasEmpty ); \t\t \t\tprvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty ); \t\t/* 处理收到的命令 */ \t\tprvProcessReceivedCommands(); \t} } ``` ```c static TickType_t prvGetNextExpireTime( BaseType_t * const pxListWasEmpty ) { TickType_t xNextExpireTime; \t*pxListWasEmpty listLIST_IS_EMPTY( pxCurrentTimerList ); \tif( *pxListWasEmpty pdFALSE ) \t{ \t\txNextExpireTime listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList ); \t} \telse \t{ \t\t/* Ensure the task unblocks when the tick count rolls over. */ \t\txNextExpireTime ( TickType_t ) 0U; \t} \treturn xNextExpireTime; } ``` ```c static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty ) { TickType_t xTimeNow; BaseType_t xTimerListsWereSwitched; \tvTaskSuspendAll(); \t{ \t\t/* 检测一下时钟有没有溢出, 有的话进行切换 */ \t\txTimeNow prvSampleTimeNow( &xTimerListsWereSwitched ); \t\tif( xTimerListsWereSwitched pdFALSE ) \t\t{ \t\t\t/* 没有溢出 */ \t\t\tif( ( xListWasEmpty pdFALSE ) && ( xNextExpireTime < xTimeNow ) ) \t\t\t{ //时钟已经到点了 \t\t\t\t( void ) xTaskResumeAll(); \t\t\t\tprvProcessExpiredTimer( xNextExpireTime, xTimeNow ); \t\t\t} \t\t\telse \t\t\t{ \t\t\t\t/* 下一个时钟的时间没有到 */ \t\t\t\tif( xListWasEmpty ! pdFALSE ) \t\t\t\t{ \t\t\t\t\t/* 记录一下移溢出时钟是不是也是空的 */ \t\t\t\t\txListWasEmpty listLIST_IS_EMPTY( pxOverflowTimerList ); \t\t\t\t} \t\t\t\t//进入阻塞, 等待下一个任务或者一个命令 \t\t\t\tvQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime xTimeNow ), xListWasEmpty ); \t\t\t\tif( xTaskResumeAll() pdFALSE ) \t\t\t\t{ \t\t\t\t\t/* Yield to wait for either a command to arrive, or the \t\t\t\t\tblock time to expire. If a command arrived between the \t\t\t\t\tcritical section being exited and this yield then the yield \t\t\t\t\twill not cause the task to block. */ \t\t\t\t\tportYIELD_WITHIN_API(); \t\t\t\t} \t\t\t\telse \t\t\t\t{ \t\t\t\t\tmtCOVERAGE_TEST_MARKER(); \t\t\t\t} \t\t\t} \t\t} \t\telse \t\t{ \t\t\t( void ) xTaskResumeAll(); \t\t} \t} } ``` ```c void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) { Queue_t * const pxQueue ( Queue_t * ) xQueue; \t prvLockQueue( pxQueue ); if( pxQueue >uxMessagesWaiting ( UBaseType_t ) 0U ) { /* 记录一下需要等待的时间, 以及把这一个事件的链表放在事件以及Delay链表里面 */ vTaskPlaceOnEventListRestricted( &( pxQueue >xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely ); } prvUnlockQueue( pxQueue ); } ``` ````c static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow ) { BaseType_t xResult; Timer_t * const pxTimer ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); \t( void ) uxListRemove( &( pxTimer >xTimerListItem ) ); \ttraceTIMER_EXPIRED( pxTimer ); \tif( pxTimer >uxAutoReload ( UBaseType_t ) pdTRUE ) \t{ \t\t/* 则一个任务需要周期性执行. */ \t\tif( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer >xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) ! pdFALSE ) \t\t{ \t\t\t/* 发送一个命令使能下一个时钟 */ \t\t\txResult xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY ); \t\t\tconfigASSERT( xResult ); \t\t\t( void ) xResult; \t\t} \t\telse \t\t{ \t\t\tmtCOVERAGE_TEST_MARKER(); \t\t} \t} \tpxTimer >pxCallbackFunction( ( TimerHandle_t ) pxTimer ); } ````"},"/note/嵌入式/第三方移植/u8g2/2024-10-4-01U8G2.html":{"title":"U8G2","content":" layout: post title: \"U8G2\" date: 2024 1 11 15:39:08 +0800 tags: stm32 # U8G2 U8g2 是一个用于[嵌入式](https://so.csdn.net/so/search?q 嵌入式&spm 1001.2101.3001.7020)设备的单色图形库。U8g2支持单色OLED和LCD U8g2： 包括所有图形程序（线/框/圆绘制）。 支持多种字体。（几乎）对字体高度没有限制。 需要微控制器中的一些内存来呈现显示。 U8x8： 仅文本输出（字符）设备。 仅允许适合 8x8 像素网格的字体。 直接写入显示器。微控制器中不需要缓冲器。 ![image 20241004105307348](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202410041053445.png) ![image 20241004105549386](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202410041055418.png) ![image 20241004105724985](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202410041057019.png) ![image 20241004105740848](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202410041057886.png) ## 移植 下载源码, 在csrc里面是使用C语言实现的源码, 这一个里面有各种不同种类的驱动, 这里保存u8x8_d_ssd1306_128x64_noname.c 精简一下u8g2_d_setup.c文件, 把里面的函数只留下来u8g2_Setup_ssd1306_i2c_128x64_noname_f ```c void u8g2_Setup_ssd1306_i2c_128x64_noname_f(u8g2_t *u8g2, const u8g2_cb_t *rotation, u8x8_msg_cb byte_cb, u8x8_msg_cb gpio_and_delay_cb) // 结构体, 屏幕方向, 驱动, 回调函数 ``` 在u8g2_d_memory.c文件里面只保留一个u8g2_m_16_8_f()这一个函数, 这一个函数在u8g2_Setup_ssd1306_i2c_128x64_noname_f函数里面进行使用 > [函数的选择](https://github.com/olikraus/u8g2/wiki/u8g2setupcpp#buffer size) > > 实际使用的时候初始化一下GPIO ## 使用 使用示例里面的main函数的初始化 [u8g2_template_stm32f103c8t6/Src/main.c at master · nikola v/u8g2_template_stm32f103c8t6 (github.com)](https://github.com/nikola v/u8g2_template_stm32f103c8t6/blob/master/Src/main.c) ```c /* USER CODE BEGIN PFP */ uint8_t u8g2_gpio_and_delay_stm32(U8X8_UNUSED u8x8_t *u8x8, U8X8_UNUSED uint8_t msg, U8X8_UNUSED uint8_t arg_int, U8X8_UNUSED void *arg_ptr) { \tswitch(msg){ \t\t//Initialize SPI peripheral \t\tcase U8X8_MSG_GPIO_AND_DELAY_INIT: \t\t\t/* HAL initialization contains all what we need so we can skip this part. */ \t\t\t//GPIO初始化 \t\tbreak; \t\t//Function which implements a delay, arg_int contains the amount of ms \t\tcase U8X8_MSG_DELAY_MILLI: \t\tHAL_Delay(arg_int); //毫秒级别的延时 \t\tbreak; \t\t//Function which delays 10us \t\tcase U8X8_MSG_DELAY_10MICRO: //10微秒的延时 \t\tfor (uint16_t n 0; n < 320; n++) \t\t{ \t\t\t__NOP(); \t\t} \t\tbreak; \t\t//Function which delays 100ns \t\tcase U8X8_MSG_DELAY_100NANO: // 100纳秒延时 \t\t__NOP(); \t\tbreak; \t\t//Function to define the logic level of the clockline \t\tcase U8X8_MSG_GPIO_I2C_CLOCK: \t\t\tif (arg_int) HAL_GPIO_WritePin(SCL_GPIO_Port, SCl_Pin, RESET); \t\t\telse HAL_GPIO_WritePin(SCL_GPIO_Port, SCL_Pin, SET); \t\tbreak; \t\t//Function to define the logic level of the data line to the display \t\tcase U8X8_MSG_GPIO_I2C_DATA: \t\t\tif (arg_int) HAL_GPIO_WritePin(SDA_GPIO_Port, SDA_Pin, SET); \t\t\telse HAL_GPIO_WritePin(SDA_GPIO_Port, SDA_Pin, RESET); \t\tbreak; \t\tdefault: \t\t\treturn 0; //A message was received which is not implemented, return 0 to indicate an error \t} \treturn 1; // command processed successfully. } int main(void){ u8g2_t u8g2; //实际使用的时候需要一个结构体 //之后使用一下setup函数 u8g2_Setup_ssd1306_i2c_128x64_noname_f(&u8g2, U8G2_R0, u8x8_byte_sw_i2c, u8g2_gpio_and_delay_stm32); u8g2_InitDisplay(&u8g2); // send init sequence to the display, display is in sleep mode after this, u8g2_SetPowerSave(&u8g2, 0); // wake up display //复位屏幕 //一个延时1s //测试图像 u8g2_DrawLine(&u8g2, 0,0, 127, 63); u8g2_SendBuffer(&u8g2); } ``` ## API函数 [u8g2reference · olikraus/u8g2 Wiki (github.com)](https://github.com/olikraus/u8g2/wiki/u8g2reference) [玩转u8g2 OLED库，一篇就够——基于SMT32、HAL CSDN博客](https://blog.csdn.net/qq_51096702/article/details/130257230#:~:text 文章浏览阅读2.4w) ### 初始化函数 ```c void u8g2_Setup_ssd1306_i2c_128x64_noname_f(u8g2_t *u8g2, const u8g2_cb_t *rotation, u8x8_msg_cb byte_cb, u8x8_msg_cb gpio_and_delay_cb) ``` > + rotation: U8G2_Rx, x 0, 1, 2, 3控制屏幕的方向, U8G2_MIRROR左右镜像, U8G2_MIRROR_VERTICAL上下镜像 > > 使用f结尾的函数的时候会开启一个1024大小的缓冲区 ```c #define u8g2_InitDisplay(u8g2) u8x8_InitDisplay(u8g2_GetU8x8(u8g2)) void u8x8_InitDisplay(u8x8_t *u8x8); ``` > Reset and configure the display. This procedure must be called before any other procedures draw something on the display. This procedure leaves the display in a power save mode. In order to see something on the screen, disable power save mode first ([setPowerSave](https://github.com/olikraus/u8g2/wiki/u8g2reference#setpowersave)). This procedure is called by the [begin](https://github.com/olikraus/u8g2/wiki/u8x8reference#begin) procedure. Either [begin](https://github.com/olikraus/u8g2/wiki/u8x8reference#begin) or `initDisplay` must be called initially. ### 屏幕开启 ```c void u8g2_setPowerSave(u8g2_t *u8g2, uint8_t is_enable) ``` > is_enable: 1关闭屏幕, 0开启屏幕 ### 缓冲区 ```c void u8g2_ClearBuffer(u8g2_t *u8g2); void u8g2_SendBuffer(u8g2_t *u8g2); ``` > 在使用_f结尾的初始化函数的时候可以使用这两个函数进行清屏以及绘制 ```c void u8g2_UpdateDisplay(u8g2_t *u8g2) void u8g2_UpdateDisplayArea(u8g2_t *u8g2, uint8_t tx, uint8_t ty, uint8_t tw, uint8_t th) ``` 更新一部分的屏幕 ### 清屏 ```c void u8g2_ClearDisplay(u8g2_t *u8g2); ``` ### 绘制XBM格式图片 文本编码二进制 只能表示单色像素（黑白） 能直接编译到应用程序内 1. 从左到右，从上到下，遍历像素 2. 激活像素记 1，非激活像素记 0，按 [大端模式](https://link.zhihu.com/?target https%3A//baike.baidu.com/item/%E5%A4%A7%E5%B0%8F%E7%AB%AF%E6%A8%A1%E5%BC%8F/6750542) 排列成二进制比特序列，不足 8 位则以 0 补齐 3. 以 `unsigned char` 数组表示上述二进制比特序列，即得 xbm 格式 ```c void u8g2_DrawXBM(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t w, u8g2_uint_t h, const uint8_t *bitmap) void u8g2_DrawXBMP(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t w, u8g2_uint_t h, const uint8_t *bitmap) ``` > 使用第二种的时候, 这一个图片的存储的位置是只读的 > > ```c > static const unsigned char u8g_logo_bits[] U8X8_PROGMEM { ... > ``` ### 图形绘制 ```c void u8g2_DrawBox(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t w, u8g2_uint_t h) ``` > 绘制一个实心的方框 ```c void u8g2_DrawButtonUTF8(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t flags, u8g2_uint_t width, u8g2_uint_t padding_h, u8g2_uint_t padding_v, const char *text) ``` > 绘制一个带边框的文字区域 > > ![image 20241004223827305](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202410042238476.png) > > `u8g2` : Pointer to the `u8g2` structure (C interface only). > `x`, `y`: Position of the first character on the display. If `U8G2_BTN_HCENTER` is used, then this is the center position of the text., 没有使用的时候这一个指的是左下角的位置 > `flags`: See table above. Multiple flags can be used with the \"or\" operator. > `width`: Minimum width of the text. If 0 (or lower than the text width), then the text width is used for the frame. > `padding_h`: Extra space before and after the text. > `padding_v`: Extra space above and below the text. > `text`: UTF8 encoded string which will be drawn on the display. > > **注: **在使用这一个函数之前需要设置一下使用的字体`void u8g2_SetFont(u8g2_t *u8g2, const uint8_t *font);` > > 可以使用[fntlistall · olikraus/u8g2 Wiki (github.com)](https://github.com/olikraus/u8g2/wiki/fntlistall)里面的字体 ```c void u8g2_DrawCircle(u8g2_t *u8g2, u8g2_uint_t x0, u8g2_uint_t y0, u8g2_uint_t rad, uint8_t opt) ``` > 绘制一个空心圆 > > ``` > opt: Selects some or all sections of the circle. > ``` > > `U8G2_DRAW_UPPER_RIGHT` > `U8G2_DRAW_UPPER_LEFT` > `U8G2_DRAW_LOWER_LEFT` > `U8G2_DRAW_LOWER_RIGHT` > `U8G2_DRAW_ALL` ```c void u8g2_DrawDisc(u8g2_t *u8g2, u8g2_uint_t x0, u8g2_uint_t y0, u8g2_uint_t rad, uint8_t opt) ``` > 绘制一个实心的圆 ```c void u8g2_DrawEllipse(u8g2_t *u8g2, u8g2_uint_t x0, u8g2_uint_t y0, u8g2_uint_t rx, u8g2_uint_t ry, uint8_t opt) ``` > 绘制一个椭圆 ```c void u8g2_DrawFilledEllipse(u8g2_t *u8g2, u8g2_uint_t x0, u8g2_uint_t y0, u8g2_uint_t rx, u8g2_uint_t ry, uint8_t opt) ``` > 实心的椭圆 ```c void u8g2_DrawFrame(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t w, u8g2_uint_t h) ``` > 画一个方框 ```c void u8g2_DrawRBox(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t w, u8g2_uint_t h, u8g2_uint_t r) void u8g2_DrawRFrame(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, u8g2_uint_t w, u8g2_uint_t h, u8g2_uint_t r) ``` > 绘制一个圆角矩形 ```c void u8g2_DrawTriangle(u8g2_t *u8g2, int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t x2, int16_t y2) ``` > 绘制一个三角形 ```c u8g2_uint_t u8g2_DrawGlyph(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, uint16_t encoding); u8g2_uint_t u8g2_DrawGlyphX2(u8g2_t *u8g2, u8g2_uint_t x, u8g2_uint_t y, uint16_t encoding); ``` > 使用这个函数可以进行一个Unicode编码的图案的绘制, 实际使用: > > ```c > u8g2.setFont(u8g2_font_unifont_t_symbols); > u8g2.drawGlyph(5, 20, 0x2603);\t/* dec 9731/hex 2603 Snowman */ > ``` > > U8g2 supports the lower 16 bit of the unicode character range (plane 0/Basic Multilingual Plane): The `encoding` can be any value from 0 to 65535. > > 使用X2的时候会把这一个字符放大2倍 > > ![fntpic/u8g2_font_unifont_t_symbols.png](https://github.com/olikraus/u8g2/wiki/fntpic/u8g2_font_unifont_t_symbols.png) ### 字体格式 ```c void u8g2_SetFontMode(u8g2_t *u8g2, uint8_t is_transparent); ``` > whether the glyph and string drawing functions will write the background color (mode 0/solid, `is_transparent 0`) or not (mode 1/transparent, `is_transparent 1`). Default mode is 0 (background color of the characters is overwritten). ```c void u8g2_SetDrawColor(u8g2_t *u8g2, uint8_t color); ``` > **:** Defines the bit value (color index) for all drawing functions. All drawing function will change the display memory to this bit value. Default value is 1. ![image 20241004230016413](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202410042300482.png) ```c void u8g2_SetFont(u8g2_t *u8g2, const uint8_t *font); ``` 可以使用的字体会使用最后两个字母进分类, Available fonts are listed [here](https://github.com/olikraus/u8g2/wiki/fntlistall). ![image 20241004231754994](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202410042317086.png) ```c void u8g2_SetFontDirection(u8g2_t *u8g2, uint8_t dir) ``` > 设置字体的方向 > > Argument String Rotation Description > : : : : : : > 0 0 degree Left to right > 1 90 degree Top to down > 2 180 degree Right to left > 3 270 degree Down to top ```c void u8g2_SetFontPosBaseline(u8g2_t *u8g2); void u8g2_SetFontPosBottom(u8g2_t *u8g2); void u8g2_SetFontPosTop(u8g2_t *u8g2); void u8g2_SetFontPosCenter(u8g2_t *u8g2); ``` > 设置字体的基准点, 这一个默认的时候是Baseline > > ![image 20241005102516419](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202410051025614.png) > > 这一个虚线指的是基准线, 而31和 9则分别表示[u8g.disp:getFontAscent()](https://github.com/olikraus/u8glib/wiki/userreference#getfontascent)和[u8g.disp:getFontDescent()](https://github.com/olikraus/u8glib/wiki/userreference#getfontdescent)两个函数的返回值。 > > 但是,这两个函数的返回值还和另外的函数有关系： > > ```c > void u8g2_SetFontRefHeightAll(u8g2_t *u8g2) > void u8g2_SetFontRefHeightExtendedText(u8g2_t *u8g2) > void u8g2_SetFontRefHeightText(u8g2_t *u8g2) > ``` > > `setFontRefHeightAll`: Ascent will be the highest ascent of all glyphs of the current font. Descent will be the highest descent of all glyphs of the current font. > `setFontRefHeightExtendedText`: Ascent will be the largest ascent of \"A\", \"1\" or \"(\" of the current font. Descent will be the descent of \"g\" or \"(\" of the current font. > `setFontRefHeightText`: Ascent will be the ascent of \"A\" or \"1\" of the current font. Descent will be the descent \"g\" of the current font (this is the default after startup). ### 按键处理(Arduino) ```c uint8_t u8g2_UserInterfaceInputValue(u8g2_t *u8g2, const char *title, const char *pre, uint8_t *value, uint8_t lo, uint8_t hi, uint8_t digits, const char *post); ``` > 格式化字符串, 用于处理按键 > > `u8g2`: A pointer to the u8g2 structure. > `title`: Multiline description for the value (Lines have to be separated with `\\n`).显示的标题 > `pre`: Text before the `value`.值的提示符 > `value`: A pointer to a variable which will be filled with the input from the user.实际显示的值 > `lo`: Lowest value, which can be selected by the user.最小值 > `hi`: Highest value, which can be selected by the user.最大值 > `digits`: Number of digits (1 to 3).显示使用的位 > `post`: Text after the `value`.后缀 > > ```c > u8g2_userInterfaceInputValue(\"Select Voltage\", \"DAC \", &v, 0, 5, 1, \" V\"); > ``` > > ![image 20241005105313044](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202410051053137.png) > > **Returns:** 1, if the user has pressed the select button. 0 if the user has pressed the home/cancel button. The selected value will be stored in `value` only if the user has pressed the select key. ### 设置翻转 ```c void u8g2_SetFlipMode(u8g2_t *u8g2, uint8_t is_enable); ``` `is_enable`: Enable (1) or disable (0) 180 degree rotation of the display content ### 通信 ```c void u8g2_SetI2CAddress(u8g2_t *u8g2, uint8_t adr) ``` > 设置I2C的地址 ### 设置窗口 ```c void u8g2_SetClipWindow(u8g2_t *u8g2, u8g2_uint_t x0, u8g2_uint_t y0, u8g2_uint_t x1, u8g2_uint_t y1 ); ``` > 开启一个可以绘制的窗口, 这一个函数的作用可以使用 > > ```c > void u8g2_SetMaxClipWindow(u8g2_t *u8g2); > ``` > > 取消"},"/note/嵌入式/第三方移植/RT-Thread/2025-1-18-RTThreadEnv.html":{"title":"RTThreadEnv","content":"# RTThreadEnv ## 实际使用 ```bash # 输入 menuconfig # 进入配置页面 >选择使用的软件包 pkgs update # 更新一下软件包 scons target mdk5 pkgs upgrade # 对本地进行升级 ```"},"/note/嵌入式/第三方移植/RT-Thread/2024-1-30-14RT-Thread对象管理.html":{"title":"对象管理","content":" layout: post title: \"对象管理\" date: 2024 1 30 15:39:08 +0800 tags: RT Thread # 对象管理 RT Thread的对象可以使用动态创建以及静态创建, 使用动态的话需要定义一个宏定义RT_USING_HEAP, 有这一个宏定义后会使用堆区进行初始化 一般使用动态的函数为rt_xxx_create(), 静态的为rt_xxx_init() ## 内核对象的管理 RT Thread采用内核对象管理系统来访问/管理所有内核对象，内核对象包含了内核中绝大部分设施 这些对象可以是静态的也可以是动态创建的 1. 使用链表的方式进行管理 ![image 20240130202922420](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401302029519.png) 2. 使用继承的方式进行管理 ![image 20240130203024639](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401302030685.png) > 可以使用统一的接口对对象进行管理 ## 主要使用的类型 > ```c > //一个基础类型, 一般位于内核对象的最前方, 用于记录一个对象的信息 > struct rt_object > { > /*内核对象名称*/ > char name[RT_NAME_MAX]; > /*内核对象类型*/ > rt_uint8_t type; > /*内核对象的参数*/ > rt_uint8_t flag; > /*内核对象管理链表*/ > rt_list_t list; > }; > ``` > > ```c > /**可以使用的对象类型 > * The object type can be one of the follows with specific > * macros enabled: > * Thread > * Semaphore > * Mutex > * Event > * MailBox > * MessageQueue > * MemHeap > * MemPool > * Device > * Timer > * Unknown > * Static > */ > enum rt_object_class_type > { > RT_Object_Class_Null 0x00, /**< The object is not used. */ > RT_Object_Class_Thread 0x01, /**< 对象为线程类型 */ > RT_Object_Class_Semaphore 0x02, /**< 对象为信号量类型 */ > RT_Object_Class_Mutex 0x03, /**< 对象为互斥量类型 */ > RT_Object_Class_Event 0x04, /**< 对象为事件类型 */ > RT_Object_Class_MailBox 0x05, /**< 对象为邮箱类型 */ > RT_Object_Class_MessageQueue 0x06, /**< 对象为消息队列类型 */ > RT_Object_Class_MemHeap 0x07, /**< memory heap. */ > RT_Object_Class_MemPool 0x08, /**< memory pool. */ > RT_Object_Class_Device 0x09, /**< 对象为设备类型 */ > RT_Object_Class_Timer 0x0a, /**< 对象为定时器类型 */ > RT_Object_Class_Unknown 0x0c, /**< 对象类型未知 */ > RT_Object_Class_Static 0x80 /**< 对象为静态对象, 这是一个标志位 */ > }; > ``` > > ```c > /** > * The information of the kernel object, 这一个是用于记录初始化信息的临时变量 > */ > struct rt_object_information > { > enum rt_object_class_type type; /**< object class type */ > rt_list_t object_list; /**< object list */ > rt_size_t object_size; /**< object size */ > }; > ``` > > RT Thread使用一个结构体数组`static struct rt_object_information rt_object_container[RT_Object_Info_Unknown]`保存默认的信息 ## 管理的API ### 初始化一个静态的对象 ```c /**实际上是对一个以及存在的类型进行赋值以及链表的插入 * This function will initialize an object and add it to object system * management. * * @param object the specified object to be initialized. * @param type the object type. * @param name the object name. In system, the object's name must be unique. */ void rt_object_init(struct rt_object *object, enum rt_object_class_type type, const char *name) ``` > 系统会把这个对象放置到对象容器中进行管理，即初始化对象的一些参数，然后把这个对象节点插入到对象容器的对象链表中 ### 脱离一个对象 ```c /** * This function will detach a static object from object system, * and the memory of static object is not freed. * * @param object the specified object to be detached. */ void rt_object_detach(rt_object_t object) ``` 使得一个静态内核对象从内核对象容器中脱离出来，即从内核对象容器链表上删除相应的对象节点。 ### 动态创建以及删除 ```c /**清除类型以及链表的脱离 * This function will allocate an object from object system * * @param type the type of object * @param name the object name. In system, the object's name must be unique. * * @return object */ rt_object_t rt_object_allocate(enum rt_object_class_type type, const char *name) /**多了一个释放内存 * This function will delete an object and release object memory. * * @param object the specified object to be deleted. */ void rt_object_delete(rt_object_t object) ``` ### 判断一个对象是不是静态对象 ```c /**判断static标志位 * This function will judge the object is system object or not. * Normally, the system object is a static object and the type * of object set to RT_Object_Class_Static. * * @param object the specified object to be judged. * * @return RT_TRUE if a system object, RT_FALSE for others. */ rt_bool_t rt_object_is_systemobject(rt_object_t object) ``` ## 实际的管理示例(动态) + 以下用线程的初始化为例 ```c /** * This function will create a thread object and allocate thread object memory * and stack. * * @param name the name of thread, which shall be unique * @param entry the entry function of thread * @param parameter the parameter of thread enter function * @param stack_size the size of thread stack * @param priority the priority of thread * @param tick the time slice if there are same priority thread * * @return the created thread object */ rt_thread_t rt_thread_create(const char *name, void (*entry)(void *parameter), void *parameter, rt_uint32_t stack_size, rt_uint8_t priority, rt_uint32_t tick) { struct rt_thread *thread; void *stack_start; \t//获取一个线程对象 thread (struct rt_thread *)rt_object_allocate(RT_Object_Class_Thread, name); if (thread RT_NULL) return RT_NULL; \t//获取一块栈区 stack_start (void *)RT_KERNEL_MALLOC(stack_size); if (stack_start RT_NULL) { /* allocate stack failure */ rt_object_delete((rt_object_t)thread); return RT_NULL; } \t//这个函数主要是用来填充信息的, 以及栈的初始化, 不在这里讨论(详细看线程管理的笔记, 以后会更新) _rt_thread_init(thread, name, entry, parameter, stack_start, stack_size, priority, tick); return thread; } ``` ```c /** * This function will allocate an object from object system * * @param type the type of object * @param name the object name. In system, the object's name must be unique. * * @return object */ rt_object_t rt_object_allocate(enum rt_object_class_type type, const char *name) { struct rt_object *object; register rt_base_t temp; struct rt_object_information *information; RT_DEBUG_NOT_IN_INTERRUPT; /* get object information 获取想要的对象的信息 */ information rt_object_get_information(type); RT_ASSERT(information ! RT_NULL); \t//根据获取的信息进行分配一块内存, object对象实际上是这一个结构体的前几项 object (struct rt_object *)RT_KERNEL_MALLOC(information >object_size); if (object RT_NULL) { /* no memory can be allocated */ return RT_NULL; } /* clean memory data of object 把所有的位清零*/ rt_memset(object, 0x0, information >object_size); /* initialize object's parameters 以下是初始化object的变量 */ /* set object type */ object >type type; /* set object flag */ object >flag 0; /* copy name */ rt_strncpy(object >name, name, RT_NAME_MAX); RT_OBJECT_HOOK_CALL(rt_object_attach_hook, (object)); /* lock interrupt */ temp rt_hw_interrupt_disable(); /* insert object into information object list 插入队列里面 */ rt_list_insert_after(&(information >object_list), &(object >list)); /* unlock interrupt */ rt_hw_interrupt_enable(temp); /* return object */ return object; } ``` ```c /** * This function will return the specified type of object information. * * @param type the type of object, which can be * RT_Object_Class_Thread/Semaphore/Mutex... etc * * @return the object type information or RT_NULL */ struct rt_object_information * rt_object_get_information(enum rt_object_class_type type) { int index; \t//依次和保存的信息结构体里面的数值比较, 获取对应的类型的信息 for (index 0; index < RT_Object_Info_Unknown; index ++) if (rt_object_container[index].type type) return &rt_object_container[index]; return RT_NULL; } ```"},"/note/嵌入式/第三方移植/RT-Thread/2024-1-28-10IO模型.html":{"title":"IO模型","content":" layout: post title: \"IO模型\" date: 2024 1 28 15:39:08 +0800 tags: RT Thread # IO模型 驱动一般在drivers目录下面 ![image 20240128191745924](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401281917000.png) 提供了一套简单的 I/O 设备模型框架，如下图所示，它位于硬件和应用程序之间，共分成三层，从上到下分别是 I/O 设备管理层、设备驱动框架层、设备驱动层。 ![image 20240128162158303](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401281621333.png) + 应用程序通过 I/O 设备管理接口获得正确的设备驱动，然后通过这个设备驱动与底层 I/O 硬件设备进行交互。 + I/O 设备管理层实现了对设备驱动程序的封装 + 设备驱动框架层是对同类硬件设备驱动的抽象，将不同厂家的同类硬件设备驱动中相同的部分抽取出来，将不同部分留出接口，由驱动程序实现。 + 设备驱动层是一组驱使硬件设备工作的程序，实现访问硬件设备的功能。 简单设备的注册不经过设备驱动框架层，直接将设备注册到I/O设备管理器中 + 设备驱动根据设备模型定义，创建出具备硬件访问能力的设备实例，将该设备通过rt_device_register()接口注册到 I/O 设备管理器中 + 应用程序通过 rt_device_find()接口查找到设备，然后使用 I/O 设备管理接口来访 <img src \"https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401281626855.png\" alt \"image 20240128162659825\" style \"zoom:150%;\" /> 对于一些复杂设备，需要使用到对应的设备驱动框架层，进行注册，如：看门狗定时器 + 看门狗设备驱动程序根据看门狗设备模型定义，创建出具备硬件访问能力的看门狗设备实例，并将该看门狗设备通过 rt_hw_watchdog_register()接口注册到看门狗设备驱动框架中 + 看门狗设备驱动框架通过 rt_device_register()接口将看门狗设备注册到 I/O 设备管理器中 + 应用程序通过 I/O 设备管理接口来访问看门狗设备硬件 <img src \"https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401281628152.png\" alt \"image 20240128162838121\" style \"zoom:150%;\" /> ## IO设备类型 ```c RT_Device_Class_Char 0, /**< character device 字符设备 */ RT_Device_Class_Block, /**< block device 块设备*/ RT_Device_Class_NetIf, /**< net interface 网络设备*/ RT_Device_Class_MTD, /**< memory device 内存设备*/ RT_Device_Class_CAN, /**< CAN device */ RT_Device_Class_RTC, /**< RTC device */ RT_Device_Class_Sound, /**< Sound device 声音 */ RT_Device_Class_Graphic, /**< Graphic device 图形 */ RT_Device_Class_I2CBUS, /**< I2C bus device */ RT_Device_Class_USBDevice, /**< USB slave device */ RT_Device_Class_USBHost, /**< USB host bus */ RT_Device_Class_SPIBUS, /**< SPI bus device */ RT_Device_Class_SPIDevice, /**< SPI device */ RT_Device_Class_SDIO, /**< SDIO bus device */ RT_Device_Class_Timer, /**< Timer device */ RT_Device_Class_Miscellaneous, /**< misc device 杂项设备*/ RT_Device_Class_Sensor, /**< Sensor device */ RT_Device_Class_Touch, /**< Touch device */ RT_Device_Class_Unknown /**< unknown device */ ``` > 字符设备、块设备是常用的设备类型，它们的分类依据是设备数据与系统之间的传输处理方式。字符模式设备允许非结构的数据传输，即通常数据传输采用串行的形式，每次一个字节。字符设备通常是一些简单设备，如串口、按键。 > > 块设备每次传输一个数据块，例如每次传输 512 个字节数据。这个数据块是硬件强制性的，数据块可能使用某类数据接口或某些强制性的传输协议，否则就可能发生错误。因此，有时块设备驱动程序对读或写操作必须执行附加的工作 ## I/O设备的注册 ### 创建以及注册 ```c /** * This function creates a device object with user data size. * * @param type, the kind type of this device object. * @param attach_size, the size of user data. * * @return the allocated device object, or RT_NULL when failed. */ rt_device_t rt_device_create(int type, int attach_size) ``` ```c /** * This function will initialize the specified device * * @param dev the pointer of device driver structure * * @return the result */ rt_err_t rt_device_init(rt_device_t dev) ``` ### 注册函数 ```c /** * This function registers a device driver with specified name. * * @param dev the pointer of device driver structure * @param name the device driver's name 这一个名字是find函数使用的 * @param flags the capabilities flag of device 设备模式标志 * * @return the error code, RT_EOK on initialization successfully. */ rt_err_t rt_device_register(rt_device_t dev, const char *name, rt_uint16_t flags) ``` > ```c > #define RT_DEVICE_FLAG_RDONLY 0x001 /*只读*/ > #define RT_DEVICE_FLAG_WRONLY 0x002 /*只写*/ > #define RT_DEVICE_FLAG_RDWR 0x003 /*读写*/ > #define RT_DEVICE_FLAG_REMOVABLE 0x004 /*可移除*/ > #define RT_DEVICE_FLAG_STANDALONE 0x008 /*独立*/ > #define RT_DEVICE_FLAG_SUSPENDED 0x020 /*挂起*/ > #define RT_DEVICE_FLAG_STREAM 0x040 /*流模式*/ > #define RT_DEVICE_FLAG_INT_RX 0x100 /*中断接收*/ > #define RT_DEVICE_FLAG_DMA_RX 0x200 /*DMA接收*/ > #define RT_DEVICE_FLAG_INT_TX 0x400 /*中断发送*/ > #define RT_DEVICE_FLAG_DMA_TX 0x800 /* DMA发送*/ > ``` ### 注销以及销毁 ```c /** * This function removes a previously registered device driver * * @param dev the pointer of device driver structure * * @return the error code, RT_EOK on successfully. */ rt_err_t rt_device_unregister(rt_device_t dev) ``` > 这一个函数不会销毁他的管理模块, 但是不可以再通过搜索找到 ```c /** * This function destroy the specific device object. * * @param dev, the specific device object. */ void rt_device_destroy(rt_device_t dev) ``` ### 需要实现的访问的操作方法集 ```c /** * operations set for device object */ struct rt_device_ops { /* common device interface */ rt_err_t (*init) (rt_device_t dev); rt_err_t (*open) (rt_device_t dev, rt_uint16_t oflag); rt_err_t (*close) (rt_device_t dev); rt_size_t (*read) (rt_device_t dev, rt_off_t pos, void *buffer, rt_size_t size); rt_size_t (*write) (rt_device_t dev, rt_off_t pos, const void *buffer, rt_size_t size); rt_err_t (*control)(rt_device_t dev, int cmd, void *args); }; ``` > 这一些函数会被放在rt_device_t里面 ## 访问I/O设备(用户层) ![image 20240128182148339](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401281821371.png) ### 查找一个设备 ```c /** * This function finds a device driver by specified name. * * @param name the device driver's name * * @return the registered device driver on successful, or RT_NULL on failure. */ rt_device_t rt_device_find(const char *name) ``` ### 打开一个设备 ```c /** * This function will open a device * * @param dev the pointer of device driver structure * @param oflag the flags for device open * * @return the result */ rt_err_t rt_device_open(rt_device_t dev, rt_uint16_t oflag) ``` > ```c > #define RT_DEVICE_FLAG_INT_RX 0x100 /**< INT mode on Rx > \t\t\t\t\t\t\t\t\t\t\t\t\t中断接收*/ > #define RT_DEVICE_FLAG_DMA_RX 0x200 /**< DMA mode on Rx > \t\t\t\t\t\t\t\t\t\t\t\t\tDMA接收*/ > #define RT_DEVICE_FLAG_INT_TX 0x400 /**< INT mode on Tx > \t\t\t\t\t\t\t\t\t\t\t\t\t中断发送*/ > #define RT_DEVICE_FLAG_DMA_TX 0x800 /**< DMA mode on Tx > \t\t\t\t\t\t\t\t\t\t\t\t\tDMA发送*/ > > #define RT_DEVICE_OFLAG_CLOSE 0x000 /**< device is closed > \t\t\t\t\t\t\t\t\t\t\t\t\t设备已关闭(内部使用)*/ > #define RT_DEVICE_OFLAG_RDONLY 0x001 /**< read only access > \t\t\t\t\t\t\t\t\t\t\t\t\t只读的方式打开*/ > #define RT_DEVICE_OFLAG_WRONLY 0x002 /**< write only access > \t\t\t\t\t\t\t\t\t\t\t\t\t只写的方式打开*/ > #define RT_DEVICE_OFLAG_RDWR 0x003 /**< read and write > \t\t\t\t\t\t\t\t\t\t\t\t\t读写的方式打开*/ > #define RT_DEVICE_OFLAG_OPEN 0x008 /**< device is opened > \t\t\t\t\t\t\t\t\t\t\t\t\t已经打开了(内部使用)*/ > #define RT_DEVICE_OFLAG_MASK 0xf0f /**< mask of open flag*/ > > #define RT_DEVICE_FLAG_RDONLY 0x001 /**< read only */ > #define RT_DEVICE_FLAG_WRONLY 0x002 /**< write only */ > #define RT_DEVICE_FLAG_RDWR 0x003 /**< read and write */ > > #define RT_DEVICE_FLAG_REMOVABLE 0x004 /**< removable device */ > #define RT_DEVICE_FLAG_STANDALONE 0x008 /**< standalone device */ > #define RT_DEVICE_FLAG_ACTIVATED 0x010 /**< device is activated */ > #define RT_DEVICE_FLAG_SUSPENDED 0x020 /**< device is suspended */ > #define RT_DEVICE_FLAG_STREAM 0x040 /**< stream mode 流设备*/ > ``` > > > RT_DEVICE_FLAG_STREAM：流模式用于向串口终端输出字符串：当输出的字符是 \"\\n\"（对应 16 进制值为 0x0A）时，自动在前面输出一个 \"\\r\"（对应 16 进制值为 0x0D）做分行。 ### 关闭设备 ```c /** * This function will close a device * * @param dev the pointer of device driver structure * * @return the result */ rt_err_t rt_device_close(rt_device_t dev) ``` ### 控制设备 ```c /** * This function will perform a variety of control functions on devices. * * @param dev the pointer of device driver structure * @param cmd the command sent to device * @param arg the argument of command * * @return the result */ rt_err_t rt_device_control(rt_device_t dev, int cmd, void *arg) ``` > 可以使用的参数 > > ```c > #define RT_DEVICE_CTRL_RESUME 0x01 /* 恢复设备 */ > #define RT_DEVICE_CTRL_SUSPEND 0x02 /* 挂起设备 */ > #define RT_DEVICE_CTRL_CONFIG 0x03 /* 配置设备 */ > #define RT_DEVICE_CTRL_SET_INT 0x10 /* 设置中断 */ > #define RT_DEVICE_CTRL_CLR_INT 0x11 /* 清中断 */ > #define RT_DEVICE_CTRL_GET_INT 0x12 /* 获取中断状态 */ > ``` ### 读写设备 ```c /** * This function will read some data from a device. * * @param dev the pointer of device driver structure * @param pos the position of reading * @param buffer the data buffer to save read data * @param size the size of buffer * * @return the actually read size on successful, otherwise negative returned. * * @note since 0.4.0, the unit of size/pos is a block for block device. */ rt_size_t rt_device_read(rt_device_t dev, rt_off_t pos, void *buffer, rt_size_t size) /** * This function will write some data to a device. * * @param dev the pointer of device driver structure * @param pos the position of written * @param buffer the data buffer to be written to device * @param size the size of buffer * * @return the actually written size on successful, otherwise negative returned. * * @note since 0.4.0, the unit of size/pos is a block for block device. */ rt_size_t rt_device_write(rt_device_t dev, rt_off_t pos, const void *buffer, rt_size_t size) ``` ### 数据的收发回调函数 当硬件设备收到数据时，可以通过如下函数回调另一个函数来设置数据接收指示，通知上层应用线程有数据到达 ```c /** * This function will set the reception indication callback function. * This callback function * is invoked when this device receives data. * * @param dev the pointer of device driver structure * @param rx_ind the indication callback function * * @return RT_EOK */ rt_err_t rt_device_set_rx_indicate(rt_device_t dev, rt_err_t (*rx_ind)(rt_device_t dev, rt_size_t size)) /** * This function will set the indication callback function when device has * written data to physical hardware. * * @param dev the pointer of device driver structure * @param tx_done the indication callback function * * @return RT_EOK */ rt_err_t rt_device_set_tx_complete(rt_device_t dev, rt_err_t (*tx_done)(rt_device_t dev, void *buffer)) ``` ## 实际使用 ### 注册 在drivers目录下面添加一个文件, 在工程里面进行刷新 需要使用一个宏定义用来把这一个函数进行注册 ```c INIT_BOARD_EXPORT(rt_wdt_init); //进行展开 /***************1**************/ #define INIT_BOARD_EXPORT(fn) INIT_EXPORT(fn, \"1\") INIT_EXPORT(rt_wdt_init, \"1\") /***************2*************/ #define INIT_EXPORT(fn, level) \\ \tRT_USED const init_fn_t __rt_init_##fn SECTION(\".rti_fn.\" level) fn RT_USED const init_fn_t __rt_init_rt_wdt_init SECTION(\".rti_fn.\" \"1\") rt_wdt_init /***************3*************/ #define RT_USED __attribute__((used)) #define SECTION(x) __attribute__((section(x))) __attribute__((used)) const init_fn_t __rt_init_rt_wdt_init __attribute__((section(\".rti_fn.1\"))) rt_wdt_init /* attribute((used)) 其作用是告诉编译器避免被链接器因为未用过而被优化掉。 attribute((section(“name”))) 其作用是将作用的函数或数据放入指定名为\"section_name\"对应的段中 */ ``` > 宏替换完之后，就是定义了一个指向函数的指针变量 `__rt_init_rt_hw_spi_init`，该变量值为 `rt_hw_spi_init`，同时该变量位于 `.rti_fn.1` 段， 该符号段位于内存分配的 RO 段中。 ```c /** * @brief Onboard components initialization. In this function, the board level * initialization function will be called to complete the initialization * of the on board peripherals. */ void rt_components_board_init(void) { volatile const init_fn_t *fn_ptr; \t//会在这里被调用 for (fn_ptr &__rt_init_rti_board_start; fn_ptr < &__rt_init_rti_board_end; fn_ptr++) { (*fn_ptr)(); } #endif /* RT_DEBUGING_INIT */ } ``` > `__rt_init_rti_board_start` 和 `__rt_init_rti_board_end` 这 2 个变量没有在代码中定义 > > ```c > static int rti_start(void) > { > return 0; > } > INIT_EXPORT(rti_start, \"0\"); > > static int rti_board_start(void) > { > return 0; > } > INIT_EXPORT(rti_board_start, \"0.end\"); > > static int rti_board_end(void) > { > return 0; > } > INIT_EXPORT(rti_board_end, \"1.end\"); > > static int rti_end(void) > { > return 0; > } > INIT_EXPORT(rti_end, \"6.end\"); > ``` > > 通过 > > ```c > __rt_init_start .; > KEEP(*(SORT(.rti_fn*))) > __rt_init_end .;KEEP(*(SORT(.rti_fn*))) > ``` > > 语句将所有的 `.rti_fn*` 的段，排序后放在 rt_init_start 和 rt_init_end 之间，KEEP 关键字强制链接器保留某些特定部分。 ### 实际实现框架 ```c #include <rtdevice.h> #include <rtdbg.h> rt_err_t demo_init (rt_device_t dev){ rt_kprintf(\"demo_init\\n\"); return 0; } rt_err_t demo_open (rt_device_t dev, rt_uint16_t oflag){ rt_kprintf(\"demo_open\\n\"); return 0; } rt_err_t demo_close (rt_device_t dev){ rt_kprintf(\"demo_close\\n\"); return 0; } int rt_demo_init(void) { rt_device_t demo_dev; demo_dev rt_device_create(RT_Device_Class_Char, 32); if(demo_dev RT_NULL){ LOG_E(\"rt_device demo create fail...\\n\"); return ENOMEM; } demo_dev >init demo_init; demo_dev >open demo_open; demo_dev >close demo_close; rt_device_register(demo_dev, \"demo\", RT_DEVICE_FLAG_RDWR); return 0; } INIT_BOARD_EXPORT(rt_demo_init); ``` ```c rt_device_t dev; int main(void) { dev rt_device_find(\"demo\"); if(dev RT_NULL) { LOG_E(\"dev find err\\n\"); return EINVAL; } rt_device_init(dev); rt_device_open(dev, RT_DEVICE_OFLAG_RDWR); rt_device_close(dev); return 0; } ``` <img src \"https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401282019246.png\" alt \"image 20240128201940159\" style \"zoom:150%;\" /> ![image 20240128205057888](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401282050951.png)"},"/note/嵌入式/第三方移植/RT-Thread/2024-1-27-06线程管理.html":{"title":"RT-Thread线程管理","content":" layout: post title: \"RT Thread线程管理\" date: 2024 1 26 15:39:08 +0800 tags: RT Thread # 线程管理(使用篇) > 之后会做源码分析 线程是任务的载体，是RTT中最基本的调度单位。 线程执行时的运行环境称为上下文，具体来说就是各个变量和数据，包括所有的寄存器变量、堆栈、内存信息等。 ## 管理的特点 RT Thread 线程管理的主要功能是对线程进行管理和调度，系统中总共存在两类线程，分别是系统线程和用户线程 这两类线程都会从内核对象容器中分配线程对象，当线程被删除时，也会被从对象容器中删除。 RT Thread 的线程调度器是抢占式的，主要的工作就是从就绪线程列表中查找最高优先级线程，保证最高优先级的线程能够被运行，最高优先级的任务一旦就绪，总能得到 CPU 的使用权。 ```c struct rt_thread { /* rt object */ char name[RT_NAME_MAX]; /**< the name of thread 名字*/ rt_uint8_t type; /**< type of object 类型*/ rt_uint8_t flags; /**< thread's flags 标志位*/ #ifdef RT_USING_MODULE void *module_id; /**< id of application module */ #endif rt_list_t list; /**< the object list 对象列表*/ rt_list_t tlist; /**< the thread list 线程列表*/ /* stack point and entry 栈对应的指针*/ void *sp; /**< stack point 栈指针*/ void *entry; /**< entry 入口函数*/ void *parameter; /**< parameter 参数*/ void *stack_addr; /**< stack address 栈的地址*/ rt_uint32_t stack_size; /**< stack size 栈的大小*/ /* error code */ rt_err_t error; /**< error code 线程错误代码*/ rt_uint8_t stat; /**< thread status 线程状态*/ //对称多处理器, M3只有一个内核, 不会用到 #ifdef RT_USING_SMP rt_uint8_t bind_cpu; /**< thread is bind to cpu */ rt_uint8_t oncpu; /**< process on cpu` */ rt_uint16_t scheduler_lock_nest; /**< scheduler lock count */ rt_uint16_t cpus_lock_nest; /**< cpus lock count */ rt_uint16_t critical_lock_nest; /**< critical lock count */ #endif /*RT_USING_SMP*/ /* priority */ rt_uint8_t current_priority; /**< current priority 当前的优先级*/ rt_uint8_t init_priority; /**< initialized priority 初始化时候的优先级(在优先级继承的时候使用)*/ #if RT_THREAD_PRIORITY_MAX > 32 rt_uint8_t number; rt_uint8_t high_mask; #endif rt_uint32_t number_mask; #if defined(RT_USING_EVENT) /* thread event */ rt_uint32_t event_set; rt_uint8_t event_info; #endif #if defined(RT_USING_SIGNALS) rt_sigset_t sig_pending; /**< the pending signals */ rt_sigset_t sig_mask; /**< the mask bits of signal */ #ifndef RT_USING_SMP void *sig_ret; /**< the return stack pointer from signal */ #endif rt_sighandler_t *sig_vectors; /**< vectors of signal handler */ void *si_list; /**< the signal infor list */ #endif rt_ubase_t init_tick; /**< thread's initialized tick 线程初始化计数值*/ rt_ubase_t remaining_tick; /**< remaining tick 当前剩余的计数值*/ struct rt_timer thread_timer; /**< built in thread timer 一个内置的定时器*/ void (*cleanup)(struct rt_thread *tid); /**< cleanup function when thread exit 退出回调函数*/ /* light weight process if present */ #ifdef RT_USING_LWP void *lwp; #endif rt_uint32_t user_data; /**< private user data beyond this thread */ }; typedef struct rt_thread *rt_thread_t; ``` > cleanup函数指针指向的函数，会在线程退出的时候，被idle线程回调一次，执行用户设置的清理现场等工作。 > > 成员user_data可由用户挂接一些数据信息到线程控制块中，以提供类似线程私有数据的实现 ## 线程属性 ### 线程状态 ![image 20240127164313400](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401271643499.png) ### 优先级 最大支持 256 个线程优先级 (0~255)，数值越小的优先级越高，0 为最高优先级。在一些资源比较紧张的系统中，可以根据实际情况选择只支持 8 个或 32 个优先级的系统配置 对于 ARM Cortex M系列，普遍采用 32 个优先级。最低优先级默认分配给空闲线程使用，用户一般不使用。 ### 时间片 每个线程都有时间片这个参数，但时间片仅对优先级相同的就绪态线程有效。 > **注意: **线程里面不要有死循环, 否则低优先级任务不会吧执行到 ### 错误码 ```c /* RT Thread error code definitions */ #define RT_EOK 0 /**< There is no error */ #define RT_ERROR 1 /**< 普通错误 */ #define RT_ETIMEOUT 2 /**< Timed out */ #define RT_EFULL 3 /**< 资源已满 */ #define RT_EEMPTY 4 /**< 无资源 */ #define RT_ENOMEM 5 /**< No memory */ #define RT_ENOSYS 6 /**< No system */ #define RT_EBUSY 7 /**< Busy */ #define RT_EIO 8 /**< IO error */ #define RT_EINTR 9 /**< Interrupted system call */ #define RT_EINVAL 10 /**< 非法参数 */ ``` ## 状态切换 ![image 20240127165225864](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401271652903.png) ![image 20240127165707366](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401271657400.png) ![image 20240127165835227](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401271658271.png) ## 系统线程 在RT Thread内核中的系统线程有空闲线程和主线程。 ### 空闲线程 系统创建的最低优先级的线程，线程状态永远为就绪态。当系统中无其他就绪线程存在时，调度器将调度到空闲线程，它通常是一个死循环，且永远不能被挂起。 空闲线程在RT Thread也有着它的特殊用途： 线程运行完毕，系统将自动删除线程：自动执行rt_thread_exit()函数，先将该线程从系统就绪队列中删除，再将该线程的状态更改为关闭状态，不再参与系统调度，然后挂入rt_thread_defunct僵尸队列（资源未回收、处于关闭状态的线程队列）中，最后空闲线程会回收被删除线程的资源。 也提供了接口来运行用户设置的钩子函数，在空闲线程运行时会调用该钩子函数，适合钩入功耗管理、看门狗喂狗等工作。 ### 主线程 入口函数为main_thread_entry() 回在这个线程里面初始化软件, 然后调用用户的main函数 ## 实际操作API 线程相关的操作包括：创建/初始化、启动、运行、删除/脱离。 动态线程是系统自动从动态内存堆上分配栈空间与线程句柄（初始化 heap 之后才能使用 create 创建动态线程），静态线程是由用户分配栈空间与线程句柄。 ![image 20240127173904171](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401271739203.png) > create和delete是动态的 > > init和detach是静态的 ### 创建 ```c /**动态 * This function will create a thread object and allocate thread object memory * and stack. * * @param name the name of thread, which shall be unique名字 * @param entry the entry function of thread一个函数指针 * @param parameter the parameter of thread enter function一个参数 * @param stack_size the size of thread stack栈的大小 * @param priority the priority of thread优先级 * @param tick the time slice if there are same priority thread时间片 * * @return the created thread object */ rt_thread_t rt_thread_create(const char *name, void (*entry)(void *parameter), void *parameter, rt_uint32_t stack_size, rt_uint8_t priority, rt_uint32_t tick) ``` ```c /**静态 * This function will initialize a thread, normally it's used to initialize a * static thread object. * * @param thread the static thread object * @param name the name of thread, which shall be unique * @param entry the entry function of thread * @param parameter the parameter of thread enter function * @param stack_start the start address of thread stack * @param stack_size the size of thread stack * @param priority the priority of thread * @param tick the time slice if there are same priority thread * * @return the operation status, RT_EOK on OK, RT_ERROR on error */ rt_err_t rt_thread_init(struct rt_thread *thread, const char *name, void (*entry)(void *parameter), void *parameter, void *stack_start, rt_uint32_t stack_size, rt_uint8_t priority, rt_uint32_t tick) ``` ### 删除 ```c /**动态的时候使用的函数 * This function will delete a thread. The thread object will be removed from * thread queue and deleted from system object management in the idle thread. * * @param thread the thread to be deleted * * @return the operation status, RT_EOK on OK, RT_ERROR on error */ rt_err_t rt_thread_delete(rt_thread_t thread) ``` ```c /**静态的时候使用的函数 * This function will detach a thread. The thread object will be removed from * thread queue and detached/deleted from system object management. * * @param thread the thread to be deleted * * @return the operation status, RT_EOK on OK, RT_ERROR on error */ rt_err_t rt_thread_detach(rt_thread_t thread) ``` > 会在运行结束以后自动调用, 不建议使用 ### 启动 ```c /**开始可以被执行 * This function will start a thread and put it to system ready queue * * @param thread the thread to be started * * @return the operation status, RT_EOK on OK, RT_ERROR on error */ rt_err_t rt_thread_startup(rt_thread_t thread) ``` ### 获取当前在运行的任务句柄 ```c /** * This function will return self thread object * * @return the self thread object */ rt_thread_t rt_thread_self(void) { return rt_current_thread; } ``` > 可以用于在多个任务执行同一段代码的时候区分 ### 让出处理器 ```c /** * This function will let current thread yield processor, and scheduler will * choose a highest thread to run. After yield processor, the current thread * is still in READY state. * * @return RT_EOK */ rt_err_t rt_thread_yield(void) ``` > 在让出CPU以后, 当前的线程依旧是ready状态, 会执行相同优先级的任务 ### 休眠 ```c /** * This function will let current thread sleep for some ticks. * * @param tick the sleep ticks 系统的时钟数 * * @return RT_EOK */ rt_err_t rt_thread_sleep(rt_tick_t tick) /** * This function will let current thread delay for some ticks. * * @param tick the delay ticks * * @return RT_EOK */ rt_err_t rt_thread_delay(rt_tick_t tick) { return rt_thread_sleep(tick); } ``` ```c /** * This function will let current thread delay for some milliseconds. * * @param ms the delay ms time使用毫秒级别延时 * * @return RT_EOK */ rt_err_t rt_thread_mdelay(rt_int32_t ms) ``` ### 控制 ```c /** * This function will control thread behaviors according to control command. * * @param thread the specified thread to be controlled * @param cmd the control command, which includes * RT_THREAD_CTRL_CHANGE_PRIORITY for changing priority level of thread;控制优先级 * RT_THREAD_CTRL_STARTUP for starting a thread;启动一个线程 * RT_THREAD_CTRL_CLOSE for delete a thread;删除一个线程 * RT_THREAD_CTRL_BIND_CPU for bind the thread to a CPU.把一个线程绑定在某一个CPU * @param arg the argument of control command * * @return RT_EOK */ rt_err_t rt_thread_control(rt_thread_t thread, int cmd, void *arg) ``` ### 设置以及删除idle线程的hook函数 ```c /** * @ingroup Hook * This function sets a hook function to idle thread loop. When the system performs * idle loop, this hook function should be invoked. * * @param hook the specified hook function * * @return RT_EOK: set OK * RT_EFULL: hook list is full * * @note the hook function must be simple and never be blocked or suspend. */ rt_err_t rt_thread_idle_sethook(void (*hook)(void)) ``` ```c /** * delete the idle hook on hook list * * @param hook the specified hook function * * @return RT_EOK: delete OK * RT_ENOSYS: hook was not found */ rt_err_t rt_thread_idle_delhook(void (*hook)(void)) ``` > 空闲线程是一个线程状态永远为就绪态的线程，因此设置的钩子函数必须保证空闲线程在任何时刻都不会处于挂起状态，例如 rt_thread_delay()，rt_sem_take() 等可能会导致线程挂起的函数都不能使用。 ### 设置调度器hook函数 用户可能会想知道在一个时刻发生了什么样的线程切换，可以通过调用下面的函数接口设置一个相应的钩子函数。 ```c /** * This function will set a hook function, which will be invoked when thread * switch happens. * * @param hook the hook function, 可以获取线程来的位置以及下一个线程 */ void rt_scheduler_sethook(void (*hook)(struct rt_thread *from, struct rt_thread *to)) ``` ## 实际使用 ```c void test_thread(void * parameter){ int16_t i 0; while(1) { rt_kprintf(\"test threader\\n\"); rt_thread_mdelay(1000); if(i++>10) break; } } int main(void) { test_prt rt_thread_create(\"test\", test_thread, RT_NULL, 300, 20, 20); if(test_prt ! RT_NULL) { LOG_D(\"malloc test thread successed\\n\"); }else{ LOG_E(\"malloc test thread fail\\n\"); } rt_thread_startup(test_prt); } ```"},"/note/嵌入式/第三方移植/RT-Thread/2024-1-26-00速查手册.html":{"title":"速查手册","content":" layout: post title: \"速查手册\" date: 2024 1 26 15:39:08 +0800 tags: RT Thread [RT Thread API参考手册: RT Thread 简介](https://www.rt thread.org/document/api/index.html) # 宏定义 ## 配置 ### 内核部分 ```c /*表示内核对象的名称的最大长度，若代码中对象名称的最大长度大于宏定义的长度，*多余的部分将被截掉。*/ #define RT_NAME_MAX 8 /*字节对齐时设定对齐的字节个数。常使用ALIGN(RT_ALIGN_SIZE)进行字节对齐。*/ #define RT_ALIGN_SIZE 4 /*定义系统线程优先级数；通常用RT_THREAD_PRIORITY_MAX 1定义空闲线程的优先级*/ #define RT_THREAD_PRIORITY_MAX 32 /*定义时钟节拍，为100时表示100个tick每秒，一个tick为10ms*/ #define RT_TICK_PER_SECOND 100 /*检查栈是否溢出，未定义则关闭*/ #define RT_USING_OVERFLOW_CHECK /*定义该宏开启debug模式，未定义则关闭*/ #define RT_DEBUG /*开启debug模式时：该宏定义为0时表示关闭打印组件初始化信息，定义为1时表示启用*/ #define RT_DEBUG_INIT 0 /*开启debug模式时：该宏定义为0时表示关闭打印线程切换信息，定义为1时表示启用*/ #define RT_DEBUG_THREAD 0 /*定义该宏表示开启钩子函数的使用，未定义则关闭*/ #define RT_USING_HOOK /*定义了空闲线程的栈大小*/ #define IDLE_THREAD_STACK_SIZE 256 ``` ### 线程间同步 ```c /*定义该宏可开启信号量的使用，未定义则关闭*/ #define RT_USING_SEMAPHORE /*定义该宏可开启互斥量的使用，未定义则关闭*/ #define RT_USING_MUTEX /*定义该宏可开启事件集的使用，未定义则关闭*/ #define RT_USING_EVENT /*定义该宏可开启邮箱的使用，未定义则关闭*/ #define RT_USING_MAILBOX /*定义该宏可开启消息队列的使用，未定义则关闭*/ #define RT_USING_MESSAGEQUEUE /*定义该宏可开启信号的使用，未定义则关闭*/ #define RT_USING_SIGNALS ``` ### 内存管理 ```c /*开启静态内存池的使用*/ #defineRT_USING_MEMPOOL /*定义该宏可开启两个或以上内存堆拼接的使用，未定义则关闭*/ #defineRT_USING_MEMHEAP /*开启小内存管理算法*/ #defineRT_USING_SMALL_MEM /*关闭SLAB内存管理算法*/ /*#defineRT_USING_SLAB*/ /*开启堆的使用*/ #defineRT_USING_HEAP ``` ## 内核设备对象 ```c /*表示开启了系统设备的使用*/ #define RT_USING_DEVICE /*定义该宏可开启系统控制台设备的使用，未定义则关闭*/ #define RT_USING_CONSOLE /*定义控制台设备的缓冲区大小*/ #define RT_CONSOLEBUF_SIZE 128 /*控制台设备的名称*/ #define RT_CONSOLE_DEVICE_NAME \"uart1\" ``` ### 自动初始化 ```c /*定义该宏开启自动初始化机制，未定义则关闭*/ #define RT_USING_COMPONENTS_INIT /*定义该宏开启设置应用入口为main函数*/ #define RT_USING_USER_MAIN /*定义main线程的栈大小*/ #define RT_MAIN_THREAD_STACK_SIZE 2048 ``` ### FinSH ```c /*定义该宏可开启系统FinSH调试工具的使用，未定义则关闭*/ #define RT_USING_FINSH /*开启系统FinSH时：将该线程名称定义为tshell*/ #define FINSH_THREAD_NAME \"tshell\" /*开启系统FinSH时：使用历史命令*/ #define FINSH_USING_HISTORY /*开启系统FinSH时：对历史命令行数的定义*/ #defineFINSH_HISTORY_LINES 5 /*开启系统FinSH时：定义该宏开启使用Tab键，未定义则关闭*/ #define FINSH_USING_SYMTAB /*开启系统FinSH时：定义该线程的优先级*/ #define FINSH_THREAD_PRIORITY 20 /*开启系统FinSH时：定义该线程的栈大小*/ #define FINSH_THREAD_STACK_SIZE 4096 /*开启系统FinSH时：定义命令字符长度*/ #define FINSH_CMD_SIZE 80 /*开启系统FinSH时：定义该宏开启MSH功能*/ #define FINSH_USING_MSH /*开启系统FinSH时：开启MSH功能时，定义该宏默认使用MSH功能*/ #defineFINSH_USING_MSH_DEFAULT /*开启系统FinSH时：定义该宏，仅使用MSH功能*/ #defineFINSH_USING_MSH_ONLY ``` ### MCU ```c /*定义该工程使用的MCU为STM32F103ZE；系统通过对芯片类型的定义，来定义芯片的管脚*/ #define STM32F103ZE /*定义时钟源频率*/ #define RT_HSE_VALUE 8000000 /*定义该宏开启UART1的使用*/ #define RT_USING_UART1 ``` ### 常见的宏定义 1. rt_inline，定义如下，static关键字的作用是令函数只能在当前的文件中使用；inline表示内联，用static修饰后在调用函数时会建议编译器进行内联展开。 ```c #define rt_inline \t\t\t\tstatic __inline ``` 2. RT_USED，定义如下，该宏的作用是向编译器说明这段代码有用，即使函数中没有调用也要保留编译。例如RT Thread自动初始化功能使用了自定义的段，使用RT_USED会将自定义的代码段保留。 ```c #define RT_USED \t\t\t\t__attribute__((used)) ``` 3. RT_UNUSED，定义如下，表示函数或变量可能不使用，这个属性可以避免编译器产生警告信息。 ```c #define\tRT_UNUSED\t\t\t\t__attribute__((unused)) ``` 4. RT_WEAK，定义如下，常用于定义函数，编译器在链接函数时会优先链接没有该关键字前缀的函数，如果找不到则再链接由weak修饰的函数。 ```c #define\tRT_WEAK\t\t\t\t\t__weak ``` 5. ALIGN(n)，定义如下，作用是在给某对象分配地址空间时，将其存放的地址按照n字节对齐，这里n可取2的幂次方。字节对齐的作用不仅是便于CPU快速访问，同时合理的利用字节对齐可以有效地节省存储空间。 ```c #define\tALIGN(n)\t\t\t\t__attribute__((aligned(n))) ``` 6. RT_ALIGN(size,align)，定义如下，作用是将size提升为align定义的整数的倍数，例如，RT_ALIGN(13,4)将返回16。 ```c #define\tRT_ALIGN(size, align)\t(((size) + (align) 1) & ~((align) 1)) ```"},"/note/嵌入式/第三方移植/RT-Thread/2024-1-31-16线程管理(源码分析02.html":{"title":"RT-Thread线程管理(代码分析01--用户API)","content":" layout: post title: \"RT Thread线程管理(代码分析01 用户API)\" date: 2024 1 31 15:39:08 +0800 tags: RT Thread # RT Thread线程管理(源代码分析02 内核) ## 开启 在启动代码的最后会调用一个系统时钟的启动函数 ```c /** * @ingroup SystemInit * This function will startup scheduler. It will select one thread * with the highest priority level, then switch to it. */ void rt_system_scheduler_start(void) { register struct rt_thread *to_thread; rt_ubase_t highest_ready_priority; \t//获取最高优先级的任务句柄 to_thread _get_highest_priority_thread(&highest_ready_priority); \t//使用全局变量记录当前任务 rt_current_thread to_thread; \t//把这个任务从ready链表里面移除, 更新全局优先级标志位 rt_schedule_remove_thread(to_thread); to_thread >stat RT_THREAD_RUNNING; /* switch to new thread 切换线程, 这是一个汇编函数 */ rt_hw_context_switch_to((rt_ubase_t)&to_thread >sp); /* never come back */ } ``` ```c static struct rt_thread* _get_highest_priority_thread(rt_ubase_t *highest_prio) { register struct rt_thread *highest_priority_thread; register rt_ubase_t highest_ready_priority; //获取最高优先级的大小, 这一个全局变量的第几位为1表示这一个优先级有对应的任务, 优先级数值小的优先级高 highest_ready_priority __rt_ffs(rt_thread_ready_priority_group) 1; /* get highest ready priority thread 获取最高优先级的第一个任务 */ highest_priority_thread rt_list_entry(rt_thread_priority_table[highest_ready_priority].next, struct rt_thread, tlist); \t//保存一下最高的优先级大小 *highest_prio highest_ready_priority; return highest_priority_thread; } ``` ```c int __rt_ffs(int value) { return __builtin_ffs(value); } ``` > __builtin_ffs 是 gcc 内置的函数，获取一个数值：从低位起，第一个1 出现的位置，如0x11，返回的是1,0x00返回的是0,0x02，返回的是2 ```assembly /*这一个函数主要是设置两个全局变量以及开启PendSV * void rt_hw_context_switch_to(rt_uint32 to); * R0 > to */ .global rt_hw_context_switch_to .type rt_hw_context_switch_to, %function rt_hw_context_switch_to: \t/* 记录一下要切换到的位置, 记录在rt_interrupt_to_thread里面 */ LDR R1, rt_interrupt_to_thread STR R0, [R1] /* set from thread to 0 设置rt_interrupt_from_thread的值为0，表示启动第一次线程切换 */ LDR R1, rt_interrupt_from_thread MOV R0, #0 STR R0, [R1] /* set interrupt flag to 1 另一个为1, 不会跳过任务切换 */ LDR R1, rt_thread_switch_interrupt_flag MOV R0, #1 STR R0, [R1] /* set the PendSV exception priority 这里是设置PendSV优先级为最低, 原因可以看我的Cotex M3部分的笔记*/ LDR R0, SHPR3 LDR R1, PENDSV_PRI_LOWEST LDR.W R2, [R0,#0] /* read 读取原来的值 */ ORR R1, R1, R2 /* modify 计算新的值 */ STR R1, [R0] /* write back 写回 */ LDR R0, ICSR /* trigger the PendSV exception (causes context switch) 软件挂起PenSV中断 */ LDR R1, PENDSVSET_BIT STR R1, [R0] /* restore MSP */ LDR r0, SCB_VTOR\t\t LDR r0, [r0]\t\t\t/* 获取中断向量表的起始地址 */ LDR r0, [r0]\t\t\t/* 获取中断向量表第一个的值, 这是MSP的起始地址 */ NOP MSR msp, r0\t\t\t\t/* 恢复MSP(清空主栈) */ /* enable interrupts at processor level */ CPSIE F CPSIE I \t/* 这时候进PendSV中断了 */ /* never reach here! */ ``` > ```c > .equ \tSCB_VTOR, 0xE000ED08 /* Vector Table Offset Register */\t > .equ \tNVIC_SHPR3, 0xE000ED20 /* system priority register (3) */ > ``` ![image 20240131193309840](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401311933919.png) > 这个是保存的寄存器的位置关系 ```assembly /* R0 > switch from thread stack * R1 > switch to thread stack * psr, pc, LR, R12, R3, R2, R1, R0 are pushed into [from] stack */ .global PendSV_Handler .type PendSV_Handler, %function PendSV_Handler: /* disable interrupt to protect context switch */ MRS R2, PRIMASK\t\t/* 用R2记录一下中断屏蔽等级 */ CPSID I /* get rt_thread_switch_interrupt_flag 这一个变量会在开启时钟的时候设置为 1 */ LDR R0, rt_thread_switch_interrupt_flag LDR R1, [R0] CBZ R1, pendsv_exit\t\t/* pendsv aLReady handled */ /* clear rt_thread_switch_interrupt_flag to 0 清除这一个变量 */ MOVS R1, #0 STR R1, [R0] LDR R0, rt_interrupt_from_thread\t\t/* 第一次启动的时候没有from, 这个是0 */ LDR R1, [R0] CBZ R1, switch_to_thread /* skip register save at the first time 第一次启动的时候不用保存寄存器 */ \t/* 这里是不是第一次启动的时候需要保存一下上下文 */ MRS R1, PSP /* get from thread stack pointer 更新一下PSP*/ STMFD R1!, {R4 R11} /* push R4 R11 register 把这几个寄存器保存起来 */ LDR R0, [R0] STR R1, [R0] /* update from thread stack pointer 更新一下TCB里 \t\t\t\t\t\t\t 记录PSP的一个值,用于下一次回来时候获取栈指针 */ switch_to_thread: LDR R1, rt_interrupt_to_thread LDR R1, [R1] LDR R1, [R1] /* load thread stack pointer 获取新的任务的栈指针 */ LDMFD R1!, {R4 R11} /* pop R4 R11 register 获取手动保存的几个寄存器 */ MSR PSP, R1 /* update stack pointer 更新一下PSP*/ pendsv_exit: /* restore interrupt */ MSR PRIMASK, R2\t\t/* 按记录的屏蔽等级恢复中断 */ ORR LR, LR, #0x04\t/* EXC_RETURN为0xFFFF_FFFD返回线程模式，并使用线程堆栈(SP PSP) */ BX LR ``` ## 自动切换 在启动的时候打开了Systick的中断, 之后会周期性的进入这一个中断服务函数 ````c /** * This is the timer interrupt service routine. * */ void SysTick_Handler(void) { /* enter interrupt 每一个中断都会调用这一个用于RT Thread管理嵌套 */ rt_interrupt_enter(); \t//更新一下HAL库使用的时钟 HAL_IncTick(); //时钟的更新以及需要切换线程的话设置PendSV rt_tick_increase(); /* leave interrupt */ rt_interrupt_leave(); } ```` ```c /** * This function will be invoked by BSP, when enter interrupt service routine * * @note please don't invoke this routine in application * * @see rt_interrupt_leave */ void rt_interrupt_enter(void) { rt_base_t level; RT_DEBUG_LOG(RT_DEBUG_IRQ, (\"irq coming..., irq nest:%d\\n\", rt_interrupt_nest)); level rt_hw_interrupt_disable(); rt_interrupt_nest ++;\t\t//这一个是用来记录中断嵌套的层数的 //调用一个回调函数 RT_OBJECT_HOOK_CALL(rt_interrupt_enter_hook,()); rt_hw_interrupt_enable(level); } ``` ```c /** * This function will notify kernel there is one tick passed. Normally, * this function is invoked by clock ISR. */ void rt_tick_increase(void) { struct rt_thread *thread; /* increase the global tick 更新一下系统的时钟 */ ++ rt_tick; /* check time slice */ thread rt_thread_self(); thread >remaining_tick;\t\t//更新一下线程的时钟 if (thread >remaining_tick 0) { /* change to initialized tick 这一个线程没有时间了 */ thread >remaining_tick thread >init_tick; thread >stat RT_THREAD_STAT_YIELD; /* yield 切换一个线程 */ rt_thread_yield(); } /* check timer 进行时钟的处理, 暂时不讨论 */ rt_timer_check(); } ``` ```c /** * This function will let current thread yield processor, and scheduler will * choose a highest thread to run. After yield processor, the current thread * is still in READY state. * * @return RT_EOK */ rt_err_t rt_thread_yield(void) { rt_schedule(); return RT_EOK; } RTM_EXPORT(rt_thread_yield); ``` ```c /** * This function will perform one schedule. It will select one thread * with the highest priority level, then switch to it. */ void rt_schedule(void) { rt_base_t level; struct rt_thread *to_thread; struct rt_thread *from_thread; /* disable interrupt 临界区 */ level rt_hw_interrupt_disable(); /* check the scheduler is enabled or not 看一看可不可以切换 */ if (rt_scheduler_lock_nest 0) { rt_ubase_t highest_ready_priority; if (rt_thread_ready_priority_group ! 0) { /* need_insert_from_thread: need to insert from_thread to ready queue 记录一下当前线程需不需切换 */ int need_insert_from_thread 0; \t\t //获取一下最高优先级 to_thread _get_highest_priority_thread(&highest_ready_priority); \t\t\t if ((rt_current_thread >stat & RT_THREAD_STAT_MASK) RT_THREAD_RUNNING) { if (rt_current_thread >current_priority < highest_ready_priority) { \t\t //当前的线程优先级最高, 不需要切换 to_thread rt_current_thread; } else if (rt_current_thread >current_priority highest_ready_priority && (rt_current_thread >stat & RT_THREAD_STAT_YIELD_MASK) 0) { //这一个线程有同级线程但是不希望切换 to_thread rt_current_thread; } else { //需要切换线程 rt_current_thread >stat & ~RT_THREAD_STAT_YIELD_MASK; need_insert_from_thread 1; } } if (to_thread ! rt_current_thread) { //需要进行切换 /* if the destination thread is not the same as current thread 更新一下使用的全局变量 */ rt_current_priority (rt_uint8_t)highest_ready_priority; from_thread rt_current_thread; rt_current_thread to_thread; \t\t\t //回调函数 RT_OBJECT_HOOK_CALL(rt_scheduler_hook, (from_thread, to_thread)); if (need_insert_from_thread) { //把当前的线程插入就绪队列 rt_schedule_insert_thread(from_thread); } \t\t\t\t//把下一个线程从就绪队列里面移除 rt_schedule_remove_thread(to_thread); //更新一下状态 to_thread >stat RT_THREAD_RUNNING (to_thread >stat & ~RT_THREAD_STAT_MASK); #ifdef RT_USING_OVERFLOW_CHECK //检测一下栈有么有溢出 _rt_scheduler_stack_check(to_thread); #endif if (rt_interrupt_nest 0) { //不是在中断中进行切换的 extern void rt_thread_handle_sig(rt_bool_t clean_state); \t\t\t\t //切换上下文 rt_hw_context_switch((rt_ubase_t)&from_thread >sp, (rt_ubase_t)&to_thread >sp); /* enable interrupt */ rt_hw_interrupt_enable(level); goto __exit; } else { RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, (\"switch in interrupt\\n\")); \t\t\t\t //切换上下文Cotex M3里面这俩上下文切换是一个函数 rt_hw_context_switch_interrupt((rt_ubase_t)&from_thread >sp, (rt_ubase_t)&to_thread >sp); } } else { //不需要切换 rt_schedule_remove_thread(rt_current_thread); rt_current_thread >stat RT_THREAD_RUNNING (rt_current_thread >stat & ~RT_THREAD_STAT_MASK); } } } /* enable interrupt */ rt_hw_interrupt_enable(level); __exit: return; } ``` ```c /*这俩是一个函数 * void rt_hw_context_switch(rt_uint32 from, rt_uint32 to); * R0 > from * R1 > to */ .global rt_hw_context_switch_interrupt .type rt_hw_context_switch_interrupt, %function .global rt_hw_context_switch .type rt_hw_context_switch, %function rt_hw_context_switch_interrupt: rt_hw_context_switch: /* set rt_thread_switch_interrupt_flag to 1 设置这一个变量为1, 不会跳过切换 */ LDR R2, rt_thread_switch_interrupt_flag LDR R3, [R2] CMP R3, #1 BEQ _reswitch MOV R3, #1 STR R3, [R2] \t//记录一下来和去的线程的栈指针 LDR R2, rt_interrupt_from_thread /* set rt_interrupt_from_thread */ STR R0, [R2] _reswitch: LDR R2, rt_interrupt_to_thread /* set rt_interrupt_to_thread */ STR R1, [R2] LDR R0, ICSR /* trigger the PendSV exception (causes context switch) 开启PendSV的标志位, \t\t\t\t\t\t 之后会在那里面切换 */ LDR R1, PENDSVSET_BIT STR R1, [R0] BX LR ```"},"/note/嵌入式/第三方移植/RT-Thread/2024-2-5-17线程间通信.html":{"title":"RT-Thread线程间通信","content":" layout: post title: \"RT Thread线程间通信\" date: 2024 2 5 15:39:08 +0800 tags: RT Thread # 线程间通信 一般可以使用全局变量以及线程间同步进行实现 RT Thread也提供了一部分的通信机制 ## 邮箱 一个线程发送, 另外的线程接受信息, 进行处理 使用邮箱的时候每一次只能发送一个四字节的数据(32位处理器),特点是开销比较低，效率较高 > 可以发送一个地址从而达到发送多个数据的目的 非阻塞方式的邮件发送过程能够安全的应用于中断服务中, 发送以及接受信息的时候可以使用阻塞的模式 邮箱有一个缓存区, 使用rt_mailbox_t进行控制 ### 实际使用 ![image 20240205161002594](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402051610635.png) #### 创建(初始化) ```c /** 动态的方式创建 * This function will create a mailbox object from system resource * * @param name the name of mailbox 记录一个名字 * @param size the size of mailbox 记录一下缓存区的大小 * @param flag the flag of mailbox 一个标志位 * * @return the created mailbox, RT_NULL on error happen */ rt_mailbox_t rt_mb_create(const char *name, rt_size_t size, rt_uint8_t flag) /** 静态的方式创建 * This function will initialize a mailbox and put it under control of resource * management. * * @param mb the mailbox object 邮箱的句柄 * @param name the name of mailbox 名字 * @param msgpool the begin address of buffer to save received mail 缓存区的地址 * @param size the size of mailbox\t缓冲区大小 * @param flag the flag of mailbox 标志 * * @return the operation status, RT_EOK on successful */ rt_err_t rt_mb_init(rt_mailbox_t mb, const char *name, void *msgpool, rt_size_t size, rt_uint8_t flag) ``` > 这一个标志位可以为RT_IPC_FLAG_FIFO或RT_IPC_FLAG_PRIO, 设置的是挂起任务被释放的时候是按照进入的顺序先进入的先出去还是优先级比较高的先出去 #### 删除 ```c /**动态 * This function will delete a mailbox object and release the memory * * @param mb the mailbox object * * @return the error code */ rt_err_t rt_mb_delete(rt_mailbox_t mb) /**静态 * This function will detach a mailbox from resource management * * @param mb the mailbox object * * @return the operation status, RT_EOK on successful */ rt_err_t rt_mb_detach(rt_mailbox_t mb) ``` #### 发送邮件 ```c /** * This function will send a mail to mailbox object, if there are threads * suspended on mailbox object, it will be waked up. This function will return * immediately, if you want blocking send, use rt_mb_send_wait instead. * * @param mb the mailbox object * @param value the mail 要发送的数据 * * @return the error code */ rt_err_t rt_mb_send(rt_mailbox_t mb, rt_ubase_t value) ``` > 这是一个不等待的时钟发送函数 ```c /** * This function will send a mail to mailbox object. If the mailbox is full, * current thread will be suspended until timeout. * * @param mb the mailbox object * @param value the mail * @param timeout the waiting time 多了一个等待时间 * * @return the error code */ rt_err_t rt_mb_send_wait(rt_mailbox_t mb, rt_ubase_t value, rt_int32_t timeout) ``` #### 接收 ```c /** * This function will receive a mail from mailbox object, if there is no mail * in mailbox object, the thread shall wait for a specified time. * * @param mb the mailbox object * @param value the received mail will be saved in 给出一个存放收到的数据的位置 * @param timeout the waiting time * * @return the error code */ rt_err_t rt_mb_recv(rt_mailbox_t mb, rt_ubase_t *value, rt_int32_t timeout) ``` ### 使用技巧 可以使用一个这样的结构体, 每次发送这一个结构体的地址, 进行大于32字节的数据发送 ```c struct msg { uint32_t *data; uint32_t size; } ``` ## 消息队列 是邮箱的扩展, 没有4字节的限制 消息队列能够接收来自线程或中断服务例程中不固定长度的消息，并把消息缓存在自己的内存空间中。这些消息使用的是链表进行连接, 消息先进先出 这一个使用的拷贝的模式进行传输, 不建议直接发送大量数据(可以发送一个地址) 可以用于发送不定长的数据, 实际使用的时候可以使用消息队列发送消息, 使用邮箱表示接收到数据了 ![image 20240205164352685](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402051643722.png) ### 实际使用 ![image 20240205164847142](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402051648180.png) #### 创建 ```c /**动态 * This function will create a message queue object from system resource * * @param name the name of message queue 名字 * @param msg_size the size of message\t每一个消息的大小(字节) * @param max_msgs the maximum number of message in queue 记录一下消息的最大的个数 * @param flag the flag of message queue 一个标志 * * @return the created message queue, RT_NULL on error happen */ rt_mq_t rt_mq_create(const char *name, rt_size_t msg_size, rt_size_t max_msgs, rt_uint8_t flag) /**静态 * This function will initialize a message queue and put it under control of * resource management. * * @param mq the message object\t对象的句柄 * @param name the name of message queue * @param msgpool the beginning address of buffer to save messages 缓冲区的地址, 动态申请 *\t\t 的时候这个的大小是 (一个数据的大小+sizeof(struct rt_mq_message)) * mq >max_msgs * @param msg_size the maximum size of message一个消息的大小 * @param pool_size the size of buffer to save messages 缓冲区的大小 * @param flag the flag of message queue * * @return the operation status, RT_EOK on successful */ rt_err_t rt_mq_init(rt_mq_t mq, const char *name, void *msgpool, rt_size_t msg_size, rt_size_t pool_size, rt_uint8_t flag) ``` > 这一个标志位可以为RT_IPC_FLAG_FIFO或RT_IPC_FLAG_PRIO, 设置的是挂起任务被释放的时候是按照进入的顺序先进入的先出去还是优先级比较高的先出去 #### 删除 ```c /**动态 * This function will delete a message queue object and release the memory * * @param mq the message queue object * * @return the error code */ rt_err_t rt_mq_delete(rt_mq_t mq) /**静态 * This function will detach a message queue object from resource management * * @param mq the message queue object * * @return the operation status, RT_EOK on successful */ rt_err_t rt_mq_detach(rt_mq_t mq) ``` #### 发送消息 ```c /** * This function will send a message to message queue object, if there are * threads suspended on message queue object, it will be waked up. * * @param mq the message queue object * @param buffer the message 发送的消息的地址 * @param size the size of buffer 发送的数据的大小 * * @return the error code */ rt_err_t rt_mq_send(rt_mq_t mq, const void *buffer, rt_size_t size) ``` > 不等待 ```c /** * This function will send a message to message queue object. If the message queue is full, * current thread will be suspended until timeout. * * @param mq the message queue object * @param buffer the message * @param size the size of buffer * @param timeout the waiting time * * @return the error code */ rt_err_t rt_mq_send_wait(rt_mq_t mq, const void *buffer, rt_size_t size, rt_int32_t timeout) ``` > 等待 ```c /** * This function will send an urgent message to message queue object, which * means the message will be inserted to the head of message queue. If there * are threads suspended on message queue object, it will be waked up. * * @param mq the message queue object * @param buffer the message * @param size the size of buffer * * @return the error code */ rt_err_t rt_mq_urgent(rt_mq_t mq, const void *buffer, rt_size_t size) ``` > 发送一个紧急的消息, 这一个消息会直接放到队首 #### 接收 ```c /** * This function will receive a message from message queue object, if there is * no message in message queue object, the thread shall wait for a specified * time. * * @param mq the message queue object * @param buffer the received message will be saved in 接收到的数据 * @param size the size of buffer * @param timeout the waiting time * * @return the error code */ rt_err_t rt_mq_recv(rt_mq_t mq, void *buffer, rt_size_t size, rt_int32_t timeout) ``` ## 信号(软件中断信号) > **注: **信号这块应该是要在微内核里使用，如果你是用宏内核版本，不推荐使用信号功能。 POSIX标准定义了sigset_t类型来定义一个信号集, 实际是一个unsigned long类型的数据, 应用程序能够使用的信号为SIGUSR1（10）和SIGUSR2（12） 他的本质是一个软件中断 收到信号的线程实际的处理方法有三种 + 类似中断的处理程序，对于需要处理的信号，线程可以指定处理函数，由该函数来处理。 + 忽略某个信号，对该信号不做任何处理，就像未发生过一样。 + 对该信号的处理保留系统的默认值。 ![image 20240205171441255](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402051714288.png) > 需要定义RT_USING_SIGNALS这一个宏 ### 实际使用 ![image 20240205171459644](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402051714696.png) #### 安装信号 如果线程要处理某一信号，那么就要在线程中安装该信号。 主要用来确定信号值及线程针对该信号值的动作之间的映射关系，即线程将要处理哪个信号，该信号被传递给线程时，将执行何种操作。 ```c rt_sighandler_t rt_signal_install(int signo, rt_sighandler_t handler) ``` > (这一个函数是给现在的线程安装) > > signo信号值（只有SIGUSR1和SIGUSR2是开放给用户使用的） > > handler设置对信号值的处理方式, 这一个的实际的函数是void (*rt_sighandler_t)(int signo); > > 也可以使用SIG_IGN，忽略某个信号, SIG_DFL，系统会调用默认的处理函数_signal_default_handler() > > 返回安装信号前的handler值表示成功 #### 阻塞(屏蔽)信号 该信号将不会递达给安装此信号的线程，也不会引发软中断处理。 ```c void rt_signal_mask(int signo) ``` #### 解除信号阻塞 ```c void rt_signal_unmask(int signo) ``` #### 发送信号 ```c int rt_thread_kill(rt_thread_t tid, int sig) ``` > tid: 接收信号的线程 > > sig: 信号值 #### 等待信号 ```c int rt_signal_wait(const rt_sigset_t *set, rt_siginfo_t *si, rt_int32_t timeout) ``` > set: 指定等待的信号 > > si: 指向存储等到信号信息的指针 # RT Thread代码分析 ## 邮箱 实际是实现是一个对环形缓存区的使用 ![image 20240205185245224](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402051852365.png) ```c struct rt_mailbox { struct rt_ipc_object parent; /**< inherit from ipc_object */ rt_ubase_t *msg_pool; /**< start address of \t\t\t\t\t\t\t\t\t\t\t\tmessage buffer 缓存区地址*/ rt_uint16_t size; /**< size of message pool 大小*/ rt_uint16_t entry; /**< index of messages in msg_pool \t\t\t\t\t\t\t\t\t\t\t\t记录一下数量*/ rt_uint16_t in_offset; /**< input offset of the message \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbuffer记录一下写的位置 */ rt_uint16_t out_offset; /**< output offset of the message \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t记录一下读的位置buffer */ rt_list_t suspend_sender_thread; /**< sender thread suspended on \t\t\t\t\t\t\t\t\t\t\t\t挂起的任务链表this mailbox */ }; typedef struct rt_mailbox *rt_mailbox_t; ``` ```c struct rt_ipc_object { struct rt_object parent; /**< inherit from rt_object */ rt_list_t suspend_thread; /**< threads pended on this resource 记录接收的任务的队列 */ }; ``` ### 创建 ```c rt_mailbox_t rt_mb_create(const char *name, rt_size_t size, rt_uint8_t flag) { rt_mailbox_t mb; RT_DEBUG_NOT_IN_INTERRUPT; /* allocate object 这一个在对象创建的那一篇里面分析过了*/ mb (rt_mailbox_t)rt_object_allocate(RT_Object_Class_MailBox, name); if (mb RT_NULL) return mb; /* set parent */ mb >parent.parent.flag flag; /* initialize ipc object 实际上就是初始化一个用于记录接收任务挂起的链表 */ rt_ipc_object_init(&(mb >parent)); /* initialize mailbox 记录一些信息 */ mb >size size; //获取一个缓存区 mb >msg_pool (rt_ubase_t *)RT_KERNEL_MALLOC(mb >size * sizeof(rt_ubase_t)); if (mb >msg_pool RT_NULL) { //获取失败 /* delete mailbox object */ rt_object_delete(&(mb >parent.parent)); return RT_NULL; } mb >entry 0; mb >in_offset 0; mb >out_offset 0; /* initialize an additional list of sender suspend thread 发送者的队列 */ rt_list_init(&(mb >suspend_sender_thread)); return mb; } ``` ```c //实际就是记录一下信息 rt_err_t rt_mb_init(rt_mailbox_t mb, const char *name, void *msgpool, rt_size_t size, rt_uint8_t flag) { RT_ASSERT(mb ! RT_NULL); /* initialize object 具体看对象的分析那一章*/ rt_object_init(&(mb >parent.parent), RT_Object_Class_MailBox, name); /* set parent flag */ mb >parent.parent.flag flag; /* initialize ipc object */ rt_ipc_object_init(&(mb >parent)); /* initialize mailbox */ mb >msg_pool (rt_ubase_t *)msgpool; mb >size size; mb >entry 0; mb >in_offset 0; mb >out_offset 0; /* initialize an additional list of sender suspend thread */ rt_list_init(&(mb >suspend_sender_thread)); return RT_EOK; } ``` ### 删除 ```c rt_err_t rt_mb_delete(rt_mailbox_t mb) { RT_DEBUG_NOT_IN_INTERRUPT; /* resume all suspended thread 把所有的挂起的接收线程释放, 这个同步那一章里面有 */ rt_ipc_list_resume_all(&(mb >parent.suspend_thread)); /* also resume all mailbox private suspended thread 发送线程释放 */ rt_ipc_list_resume_all(&(mb >suspend_sender_thread)); /* free mailbox pool 释放缓存内存 */ RT_KERNEL_FREE(mb >msg_pool); /* delete mailbox object 控制块会在空闲任务释放 */ rt_object_delete(&(mb >parent.parent)); return RT_EOK; } ``` ### 发送 ```c rt_err_t rt_mb_send(rt_mailbox_t mb, rt_ubase_t value) { return rt_mb_send_wait(mb, value, 0); } ``` ```c rt_err_t rt_mb_send_wait(rt_mailbox_t mb, rt_ubase_t value, rt_int32_t timeout) { struct rt_thread *thread; register rt_ubase_t temp; rt_uint32_t tick_delta; /* initialize delta tick */ tick_delta 0; /* get current thread 获取当前线程 */ thread rt_thread_self(); \t//回调函数 RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mb >parent.parent))); /* disable interrupt 临界区 */ temp rt_hw_interrupt_disable(); /* for non blocking call 看一看有没有位置 */ if (mb >entry mb >size && timeout 0) { //没有并且不等待 rt_hw_interrupt_enable(temp); return RT_EFULL; } /* mailbox is full */ while (mb >entry mb >size) { //邮箱满了 /* reset error number in thread */ thread >error RT_EOK; /* no waiting, return timeout */ if (timeout 0) { /* enable interrupt 这一个线程等待时间到了 */ rt_hw_interrupt_enable(temp); return RT_EFULL; } \t\t//这个使用的时候需要已经开始调度了 RT_DEBUG_IN_THREAD_CONTEXT; /* suspend current thread */ //把这一个任务记录在挂起队列里面(具体分析看任务同步的那一篇) rt_ipc_list_suspend(&(mb >suspend_sender_thread), thread, mb >parent.parent.flag); /* has waiting time, start thread timer */ if (timeout > 0) { //需要等待 /* get the start tick of timer 获取现在的时间 */ tick_delta rt_tick_get(); RT_DEBUG_LOG(RT_DEBUG_IPC, (\"mb_send_wait: start timer of thread:%s\\n\", thread >name)); /* reset the timeout of thread timer and start it 开启一个时钟用于超时时候的唤醒*/ rt_timer_control(&(thread >thread_timer), RT_TIMER_CTRL_SET_TIME, &timeout); rt_timer_start(&(thread >thread_timer)); } /* enable interrupt */ rt_hw_interrupt_enable(temp); /* re schedule 启动一次调度 */ rt_schedule(); \t\t//这里线程被唤醒, 看一看这这时候是不是超时了 /* resume from suspend state */ if (thread >error ! RT_EOK) { /* return error */ return thread >error; } /* disable interrupt 在这之前可能有一个高优先级把这一个位置又使用了, 需要再看看可不可以发送*/ temp rt_hw_interrupt_disable(); /* if it's not waiting forever and then re calculate timeout tick 跟新一下发送的时间, 再试着发送一次 */ if (timeout > 0) { tick_delta rt_tick_get() tick_delta; timeout tick_delta; //时间已经到了 if (timeout < 0) timeout 0; } } \t//可以发送信息 /* set ptr 记录一下信息*/ mb >msg_pool[mb >in_offset] value; /* increase input offset 更新一下记录的指针 */ ++ mb >in_offset; if (mb >in_offset > mb >size) mb >in_offset 0;//大小大于这一个环形缓冲区, 回头部 /* increase message entry */ mb >entry ++;//大小加一 /* resume suspended thread 看一看接收的有没有在等的 */ if (!rt_list_isempty(&mb >parent.suspend_thread)) { //唤醒一下第一个等待的线程以及把时钟关了(看线程同步) rt_ipc_list_resume(&(mb >parent.suspend_thread)); /* enable interrupt */ rt_hw_interrupt_enable(temp); \t\t//切换一下任务 rt_schedule(); return RT_EOK; } /* enable interrupt */ rt_hw_interrupt_enable(temp); return RT_EOK; } ``` ### 接收 ```c //基本和发送一样, 只是循环判断是为空, 以及标识符加减反过来了 rt_err_t rt_mb_recv(rt_mailbox_t mb, rt_ubase_t *value, rt_int32_t timeout) { struct rt_thread *thread; register rt_ubase_t temp; rt_uint32_t tick_delta; /* parameter check */ RT_ASSERT(mb ! RT_NULL); RT_ASSERT(rt_object_get_type(&mb >parent.parent) RT_Object_Class_MailBox); /* initialize delta tick */ tick_delta 0; /* get current thread */ thread rt_thread_self(); RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mb >parent.parent))); /* disable interrupt */ temp rt_hw_interrupt_disable(); /* for non blocking call */ if (mb >entry 0 && timeout 0) { rt_hw_interrupt_enable(temp); return RT_ETIMEOUT; } /* mailbox is empty 看看是不是空的 */ while (mb >entry 0) { //需要等待 /* reset error number in thread */ thread >error RT_EOK; /* no waiting, return timeout */ if (timeout 0) { //等待的时间到了, 失败 /* enable interrupt */ rt_hw_interrupt_enable(temp); thread >error RT_ETIMEOUT; return RT_ETIMEOUT; } \t\t//必须打开调度器了 RT_DEBUG_IN_THREAD_CONTEXT; //一个典型的icp挂起处理 /* suspend current thread */ rt_ipc_list_suspend(&(mb >parent.suspend_thread), thread, mb >parent.parent.flag); /* has waiting time, start thread timer 还有时间, 挂起*/ if (timeout > 0) { /* get the start tick of timer */ tick_delta rt_tick_get(); RT_DEBUG_LOG(RT_DEBUG_IPC, (\"mb_recv: start timer of thread:%s\\n\", thread >name)); /* reset the timeout of thread timer and start it */ rt_timer_control(&(thread >thread_timer), RT_TIMER_CTRL_SET_TIME, &timeout); rt_timer_start(&(thread >thread_timer)); } /* enable interrupt */ rt_hw_interrupt_enable(temp); /* re schedule */ rt_schedule(); \t\t//切换, 看一看是不是出错了(超时等) /* resume from suspend state */ if (thread >error ! RT_EOK) { /* return error */ return thread >error; } /* disable interrupt 最后检测一下有没有位置 */ temp rt_hw_interrupt_disable(); /* if it's not waiting forever and then re calculate timeout tick 更新时间 */ if (timeout > 0) { tick_delta rt_tick_get() tick_delta; timeout tick_delta; if (timeout < 0) timeout 0; } } /* fill ptr */ *value mb >msg_pool[mb >out_offset]; /* increase output offset */ ++ mb >out_offset; if (mb >out_offset > mb >size) mb >out_offset 0; /* decrease message entry */ mb >entry ; /* resume suspended thread */ if (!rt_list_isempty(&(mb >suspend_sender_thread))) { //释放第一个线程 rt_ipc_list_resume(&(mb >suspend_sender_thread)); /* enable interrupt */ rt_hw_interrupt_enable(temp); RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mb >parent.parent))); rt_schedule(); return RT_EOK; } /* enable interrupt */ rt_hw_interrupt_enable(temp); RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mb >parent.parent))); return RT_EOK; } ``` ## 消息队列 实际上这是一个对链表的使用 消息链表: 使用两个指针记录消息链表的头以及尾 空闲链表: 类似栈, 使用一个指针记录空闲任务尾部 ```c struct rt_messagequeue { struct rt_ipc_object parent; /**< inherit from ipc_object */ void *msg_pool; /**< start address of message \t\t\t\t\t\t\t\t\t\t\t\tqueue 存放消息的缓冲区 */ rt_uint16_t msg_size; /**< message size of each message \t\t\t\t\t\t\t\t\t\t\t\t记录可以容纳的每一个消息的大小*/ rt_uint16_t max_msgs; /**< max number of messages \t\t\t\t\t\t\t\t\t\t\t\t记录消息的个数*/ rt_uint16_t entry; /**< index of messages in the \t\t\t\t\t\t\t\t\t\t\t\t\t \t\t\t\t\t\t\t\tqueue 记录现在消息的个数 */ void *msg_queue_head; /**< list head 链表头 */ void *msg_queue_tail; /**< list tail 链表尾*/ void *msg_queue_free; /**< pointer indicated the free \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnode of queue 记录缓冲区里下一个空闲消息的链表 */ rt_list_t suspend_sender_thread; /**< sender thread suspended on \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis message queue 发送线程的挂起的等待队列*/ }; ``` ```c struct rt_mq_message { struct rt_mq_message *next; }; ``` > 一个管理信息的链表 ### 创建 ![image 20240205182510596](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402051825703.png) > 初始化以后的缓冲区 ```c rt_mq_t rt_mq_create(const char *name, rt_size_t msg_size, rt_size_t max_msgs, rt_uint8_t flag) { struct rt_messagequeue *mq; struct rt_mq_message *head; register rt_base_t temp; \t//这一个函数不应该在中断里面使用 RT_DEBUG_NOT_IN_INTERRUPT; /* allocate object 获取一个邮箱的对象 */ mq (rt_mq_t)rt_object_allocate(RT_Object_Class_MessageQueue, name); if (mq RT_NULL) return mq; /* set parent 记录一下标志 */ mq >parent.parent.flag flag; /* initialize ipc object 主要是初始化一个ipc的链表(这一部分在信号同步的的那一篇里面有) */ rt_ipc_object_init(&(mq >parent)); /* initialize message queue */ /* get correct message size 把这一个按照四字节对齐 */ mq >msg_size RT_ALIGN(msg_size, RT_ALIGN_SIZE); mq >max_msgs max_msgs; /* allocate message pool 获取一个存信息的内存, 实际的大小是(信息大小 + 管理结构体(一个链表)) * 数量 */ mq >msg_pool RT_KERNEL_MALLOC((mq >msg_size + sizeof(struct rt_mq_message)) * mq >max_msgs); if (mq >msg_pool RT_NULL) { //获取失败的时候 rt_object_delete(&(mq >parent.parent)); return RT_NULL; } /* initialize message list */ mq >msg_queue_head RT_NULL; mq >msg_queue_tail RT_NULL; /* initialize message empty list 初始化这一个缓存里面的信息 */ mq >msg_queue_free RT_NULL; for (temp 0; temp < mq >max_msgs; temp ++) { head (struct rt_mq_message *)((rt_uint8_t *)mq >msg_pool + temp * (mq >msg_size + sizeof(struct rt_mq_message)));//计算一下第n个信息的位置 head >next (struct rt_mq_message *)mq >msg_queue_free;//初始化链表指向数组前一个信息 mq >msg_queue_free head;//更新一下可以使用的下一个的位置 } /* the initial entry is zero */ mq >entry 0; /* initialize an additional list of sender suspend thread */ rt_list_init(&(mq >suspend_sender_thread)); return mq; } ``` ```c //静态, 实际就是记录一下用到的值 rt_err_t rt_mq_init(rt_mq_t mq, const char *name, void *msgpool, rt_size_t msg_size, rt_size_t pool_size, rt_uint8_t flag) { struct rt_mq_message *head; register rt_base_t temp; /* parameter check */ RT_ASSERT(mq ! RT_NULL); /* initialize object */ rt_object_init(&(mq >parent.parent), RT_Object_Class_MessageQueue, name); /* set parent flag */ mq >parent.parent.flag flag; /* initialize ipc object */ rt_ipc_object_init(&(mq >parent)); /* set message pool */ mq >msg_pool msgpool; /* get correct message size 计算一下实际可以存储的信息的个数 */ mq >msg_size RT_ALIGN(msg_size, RT_ALIGN_SIZE); mq >max_msgs pool_size / (mq >msg_size + sizeof(struct rt_mq_message)); /* initialize message list */ mq >msg_queue_head RT_NULL; mq >msg_queue_tail RT_NULL; /* initialize message empty list */ mq >msg_queue_free RT_NULL; for (temp 0; temp < mq >max_msgs; temp ++) { head (struct rt_mq_message *)((rt_uint8_t *)mq >msg_pool + temp * (mq >msg_size + sizeof(struct rt_mq_message))); head >next (struct rt_mq_message *)mq >msg_queue_free; mq >msg_queue_free head; } /* the initial entry is zero */ mq >entry 0; /* initialize an additional list of sender suspend thread */ rt_list_init(&(mq >suspend_sender_thread)); return RT_EOK; } ``` ### 发送消息 ```c rt_err_t rt_mq_send_wait(rt_mq_t mq, const void *buffer, rt_size_t size, rt_int32_t timeout) { register rt_ubase_t temp; struct rt_mq_message *msg; rt_uint32_t tick_delta; struct rt_thread *thread; /* greater than one message size */ if (size > mq >msg_size) //发送的消息太大了, 不能发送 return RT_ERROR; /* initialize delta tick */ tick_delta 0; /* get current thread 获取当前线程 */ thread rt_thread_self(); RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mq >parent.parent))); /* disable interrupt 临界区 */ temp rt_hw_interrupt_disable(); /* get a free list, there must be an empty item */ msg (struct rt_mq_message *)mq >msg_queue_free; /* for non blocking call */ if (msg RT_NULL && timeout 0) { /* enable interrupt 没有位置, 并且不等待 */ rt_hw_interrupt_enable(temp); return RT_EFULL; } /* message queue is full 没有可以用于发送的空闲缓冲区 */ while ((msg mq >msg_queue_free) RT_NULL) { /* reset error number in thread */ thread >error RT_EOK; /* no waiting, return timeout */ if (timeout 0) { /* enable interrupt 时间到了 */ rt_hw_interrupt_enable(temp); return RT_EFULL; } \t\t//一个典型的ipc挂起 RT_DEBUG_IN_THREAD_CONTEXT; /* suspend current thread */ rt_ipc_list_suspend(&(mq >suspend_sender_thread), thread, mq >parent.parent.flag); /* has waiting time, start thread timer */ if (timeout > 0) { //还需要等待 /* get the start tick of timer 记录现在的时间, 用于计算是不是超时 */ tick_delta rt_tick_get(); RT_DEBUG_LOG(RT_DEBUG_IPC, (\"mq_send_wait: start timer of thread:%s\\n\", thread >name)); /* reset the timeout of thread timer and start it */ rt_timer_control(&(thread >thread_timer), RT_TIMER_CTRL_SET_TIME, &timeout); rt_timer_start(&(thread >thread_timer)); } /* enable interrupt */ rt_hw_interrupt_enable(temp); /* re schedule 任务切换*/ rt_schedule(); \t\t//回来了, 可能有位置或者出错(超时) /* resume from suspend state */ if (thread >error ! RT_EOK) { //是出错回来的 /* return error */ return thread >error; } /* disable interrupt */ temp rt_hw_interrupt_disable(); \t\t//最后更新时间以及检测一下是不是真的有位置 /* if it's not waiting forever and then re calculate timeout tick */ if (timeout > 0) { tick_delta rt_tick_get() tick_delta; timeout tick_delta; if (timeout < 0) timeout 0; } } \t//有位置 /* move free list pointer 获取一个位置, 这个msg是记录空闲位置的那一个指针 */ mq >msg_queue_free msg >next; /* enable interrupt */ rt_hw_interrupt_enable(temp); /* the msg is the new tailer of list, the next shall be NULL 这是一个新加入的信息, 没有下一个*/ msg >next RT_NULL; /* copy buffer 把信息拷贝到缓冲区 */ rt_memcpy(msg + 1, buffer, size); /* disable interrupt */ temp rt_hw_interrupt_disable(); /* link msg to message queue 看一看链表里面有没有信息*/ if (mq >msg_queue_tail ! RT_NULL) { //这是不第一个信息, 更新上一条信息的下一条为这个新的消息 /* if the tail exists, */ ((struct rt_mq_message *)mq >msg_queue_tail) >next msg; } /* set new tail 尾部记录为这一个信息 */ mq >msg_queue_tail msg; /* if the head is empty, set head 这时候没有信息的话记录一下这一条信息为第一条 */ if (mq >msg_queue_head RT_NULL) mq >msg_queue_head msg; /* increase message entry 数量加一 */ mq >entry ++; /* resume suspended thread 看一看有没有可以释放的任务*/ if (!rt_list_isempty(&mq >parent.suspend_thread)) { //释放第一个任务 rt_ipc_list_resume(&(mq >parent.suspend_thread)); /* enable interrupt */ rt_hw_interrupt_enable(temp); rt_schedule(); return RT_EOK; } /* enable interrupt */ rt_hw_interrupt_enable(temp); return RT_EOK; } ``` ### 接收信息 ```c //基本一样, 主要看链表操作 rt_err_t rt_mq_recv(rt_mq_t mq, void *buffer, rt_size_t size, rt_int32_t timeout) { struct rt_thread *thread; register rt_ubase_t temp; struct rt_mq_message *msg; rt_uint32_t tick_delta; /* parameter check */ RT_ASSERT(mq ! RT_NULL); RT_ASSERT(rt_object_get_type(&mq >parent.parent) RT_Object_Class_MessageQueue); RT_ASSERT(buffer ! RT_NULL); RT_ASSERT(size ! 0); /* initialize delta tick */ tick_delta 0; /* get current thread */ thread rt_thread_self(); RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mq >parent.parent))); /* disable interrupt */ temp rt_hw_interrupt_disable(); /* for non blocking call */ if (mq >entry 0 && timeout 0) { //没有可以获取的信息, 并且不等待 rt_hw_interrupt_enable(temp); return RT_ETIMEOUT; } /* message queue is empty 没有信息 */ while (mq >entry 0) { RT_DEBUG_IN_THREAD_CONTEXT; /* reset error number in thread */ thread >error RT_EOK; /* no waiting, return timeout 超时 */ if (timeout 0) { /* enable interrupt */ rt_hw_interrupt_enable(temp); thread >error RT_ETIMEOUT; return RT_ETIMEOUT; } \t\t//ipc挂起 /* suspend current thread */ rt_ipc_list_suspend(&(mq >parent.suspend_thread), thread, mq >parent.parent.flag); /* has waiting time, start thread timer */ if (timeout > 0) { /* get the start tick of timer */ tick_delta rt_tick_get(); RT_DEBUG_LOG(RT_DEBUG_IPC, (\"set thread:%s to timer list\\n\", thread >name)); /* reset the timeout of thread timer and start it */ rt_timer_control(&(thread >thread_timer), RT_TIMER_CTRL_SET_TIME, &timeout); rt_timer_start(&(thread >thread_timer)); } /* enable interrupt */ rt_hw_interrupt_enable(temp); /* re schedule */ rt_schedule(); /* recv message */ if (thread >error ! RT_EOK) { /* return error */ return thread >error; } /* disable interrupt */ temp rt_hw_interrupt_disable(); /* if it's not waiting forever and then re calculate timeout tick */ if (timeout > 0) { tick_delta rt_tick_get() tick_delta; timeout tick_delta; if (timeout < 0) timeout 0; } } /* get message from queue 获取当前的第一个信息 */ msg (struct rt_mq_message *)mq >msg_queue_head; /* move message queue head 更新一下下一条消息的位置 */ mq >msg_queue_head msg >next; /* reach queue tail, set to NULL 这个里面没有消息了(头尾一样, 只有一条信息) */ if (mq >msg_queue_tail msg) mq >msg_queue_tail RT_NULL; /* decrease message entry 数量更新 */ mq >entry ; /* enable interrupt */ rt_hw_interrupt_enable(temp); /* copy message 拷贝一下信息 */ rt_memcpy(buffer, msg + 1, size > mq >msg_size ? mq >msg_size : size); /* disable interrupt */ temp rt_hw_interrupt_disable(); /* put message to free list 把这个回归空闲队列 */ msg >next (struct rt_mq_message *)mq >msg_queue_free; mq >msg_queue_free msg; /* resume suspended thread 释放等待线程*/ if (!rt_list_isempty(&(mq >suspend_sender_thread))) { rt_ipc_list_resume(&(mq >suspend_sender_thread)); /* enable interrupt */ rt_hw_interrupt_enable(temp); RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mq >parent.parent))); rt_schedule(); return RT_EOK; } /* enable interrupt */ rt_hw_interrupt_enable(temp); RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mq >parent.parent))); return RT_EOK; } ``` ## 信号 ```c #if defined(RT_USING_SIGNALS) rt_sigset_t sig_pending; /**< the pending signals 记录来了的信号 */ rt_sigset_t sig_mask; /**< the mask bits of signal 记录屏蔽的信号 */ rt_sighandler_t *sig_vectors; /**< vectors of signal handler 记录处理函数 */ void *si_list; /**< the signal infor list 挂起的信号的信息链表 */ #endif ``` > 线程管理结构体 ```c typedef void (*rt_sighandler_t)(int signo); ``` > 处理函数 ```c struct siginfo_node { siginfo_t si; struct rt_slist_node list; }; ``` > 这一个是用来记录挂起的信号的的信息 信号的处理除了会在这里面显示的位置进行, 还会在切换任务的时候处理 ### 安装 ```c rt_sighandler_t rt_signal_install(int signo, rt_sighandler_t handler) { rt_base_t level; rt_sighandler_t old RT_NULL; rt_thread_t tid rt_thread_self(); \t//看一看是不是有效的值 if (!sig_valid(signo)) return SIG_ERR; level rt_hw_interrupt_disable(); if (tid >sig_vectors RT_NULL) { //这一个线程之前没有安转过 rt_thread_alloc_sig(tid); } if (tid >sig_vectors) { old tid >sig_vectors[signo]; if (handler SIG_IGN) tid >sig_vectors[signo] RT_NULL; else if (handler SIG_DFL) tid >sig_vectors[signo] _signal_default_handler; else tid >sig_vectors[signo] handler; } rt_hw_interrupt_enable(level); return old; } ``` ```c void rt_thread_alloc_sig(rt_thread_t tid) { int index; rt_base_t level; rt_sighandler_t *vectors; \t//获取一个足以记录处理所有信号的函数的数组 vectors (rt_sighandler_t *)RT_KERNEL_MALLOC(sizeof(rt_sighandler_t) * RT_SIG_MAX); RT_ASSERT(vectors ! RT_NULL); for (index 0; index < RT_SIG_MAX; index ++) { //初始化为默认的函数 vectors[index] _signal_default_handler; } \t//把这一个数组记录在线程里面 level rt_hw_interrupt_disable(); tid >sig_vectors vectors; rt_hw_interrupt_enable(level); } ``` ```c //默认的函数 static void _signal_default_handler(int signo) { LOG_I(\"handled signo[%d] with default action.\", signo); return ; } ``` ### 删除(屏蔽) ```c //实际上是更新一下线程里面的屏蔽值 void rt_signal_mask(int signo) { rt_base_t level; rt_thread_t tid rt_thread_self(); level rt_hw_interrupt_disable(); tid >sig_mask & ~sig_mask(signo); rt_hw_interrupt_enable(level); } ``` ### 解除 ```c void rt_signal_unmask(int signo) { rt_base_t level; rt_thread_t tid rt_thread_self(); level rt_hw_interrupt_disable(); \t//改一下标志 tid >sig_mask sig_mask(signo); /* let thread handle pended signals */ if (tid >sig_mask & tid >sig_pending) { //有需要处理的标志 rt_hw_interrupt_enable(level); _signal_deliver(tid); } else { rt_hw_interrupt_enable(level); } } ``` ```c //根据要处理的有信号的线程的状态进行分支处理 static void _signal_deliver(rt_thread_t tid) { rt_ubase_t level; level rt_hw_interrupt_disable(); /* thread is not interested in pended signals */ if (!(tid >sig_pending & tid >sig_mask)) { //没有待处理的信号 rt_hw_interrupt_enable(level); return; } if ((tid >stat & RT_THREAD_STAT_MASK) RT_THREAD_SUSPEND) { //这一个任务挂起了(他在等待这一个信号) /* resume thread to handle signal */ rt_thread_resume(tid); /* add signal state */ tid >stat (RT_THREAD_STAT_SIGNAL RT_THREAD_STAT_SIGNAL_PENDING); rt_hw_interrupt_enable(level); \t\t//恢复这一个任务 /* re schedule */ rt_schedule(); //这时候已经看完是不是这一个信号待处理了 } else { //这一个任务运行或ready中 if (tid rt_thread_self()) { //是当前的在运行的任务 /* add signal state */ tid >stat RT_THREAD_STAT_SIGNAL; rt_hw_interrupt_enable(level); /* do signal action in self thread context */ if (rt_interrupt_get_nest() 0) { //直接开启这一个软件线程 rt_thread_handle_sig(RT_TRUE); } } else if (!((tid >stat & RT_THREAD_STAT_SIGNAL_MASK) & RT_THREAD_STAT_SIGNAL)) { //不是在运行的任务, 这个时候会为这一个任务开启一个新的栈 /* add signal state 更新一下标志 */ tid >stat (RT_THREAD_STAT_SIGNAL RT_THREAD_STAT_SIGNAL_PENDING); \t\t\t /* point to the signal handle entry */ tid >stat & ~RT_THREAD_STAT_SIGNAL_PENDING; tid >sig_ret tid >sp;//记录一下之前的栈 //这一个看线程处理篇 //实际处理使用的之前栈下面的一部分 tid >sp rt_hw_stack_init((void *)_signal_entry, RT_NULL, (void *)((char *)tid >sig_ret 32), RT_NULL);//设置一下这一个线程返回以后的处理 rt_hw_interrupt_enable(level); LOG_D(\"signal stack pointer @ 0x%08x\", tid >sp); /* re schedule */ rt_schedule(); } else { rt_hw_interrupt_enable(level); } } } ``` ```c //这是一个软件中断的线程, 如果需要执行这一个的线程不在runing状态, 会使用一个新的栈空间执行这一个线程 void rt_thread_handle_sig(rt_bool_t clean_state) { rt_base_t level; rt_thread_t tid rt_thread_self(); struct siginfo_node *si_node; level rt_hw_interrupt_disable(); if (tid >sig_pending & tid >sig_mask) { /* if thread is not waiting for signal 等一个信号的话直接返回 */ if (!(tid >stat & RT_THREAD_STAT_SIGNAL_WAIT)) { //这个时候不是在等一个信号 while (tid >sig_pending & tid >sig_mask) { //依次处理信号 int signo, error; rt_sighandler_t handler; \t\t\t\t//获取一个待处理的信号 si_node (struct siginfo_node *)tid >si_list; if (!si_node) break; /* remove this sig info node from list */ if (si_node >list.next RT_NULL) tid >si_list RT_NULL;//这是最后一个信号 else tid >si_list (void *)rt_slist_entry(si_node >list.next, struct siginfo_node, list);//记录下一个信号 signo si_node >si.si_signo;//获取标号 handler tid >sig_vectors[signo];//获取处理函数 tid >sig_pending & ~sig_mask(signo);//更新挂起的标志 rt_hw_interrupt_enable(level); LOG_D(\"handle signal: %d, handler 0x%08x\", signo, handler); if (handler) handler(signo);//执行处理函数 level rt_hw_interrupt_disable(); error RT_EINTR; rt_mp_free(si_node); /* release this siginfo node 从内存池里面释放 */ /* set errno in thread tcb */ tid >error error; } /* whether clean signal status */ //这一个标志需要清除 if (clean_state RT_TRUE) { tid >stat & ~RT_THREAD_STAT_SIGNAL; } else { return; } } } rt_hw_interrupt_enable(level); } ``` ```c //非当前线程的时候线程返回时候的处理函数(软件中断) static void _signal_entry(void *parameter) { rt_thread_t tid rt_thread_self(); /* handle signal 处理一下信号 */ rt_thread_handle_sig(RT_FALSE); /* return to thread 返回之前的在处理的任务状态 */ tid >sp tid >sig_ret;//改变栈 tid >sig_ret RT_NULL; LOG_D(\"switch back to: 0x%08x\\n\", tid >sp); tid >stat & ~RT_THREAD_STAT_SIGNAL; \t//线程处理的里面分析了, 主要是切换一下运行位置以及栈 rt_hw_context_switch_to((rt_ubase_t)&(tid >sp)); } ``` ### 发送信号 ```c #define sig_mask(sig_no) (1u << sig_no) int rt_thread_kill(rt_thread_t tid, int sig) { siginfo_t si; rt_base_t level; struct siginfo_node *si_node; \t if (!sig_valid(sig)) return RT_EINVAL; \t LOG_I(\"send signal: %d\", sig); si.si_signo sig; si.si_code SI_USER; si.si_value.sival_ptr RT_NULL; level rt_hw_interrupt_disable(); if (tid >sig_pending & sig_mask(sig)) { //这一个信号标志已经挂起了, 用这一个新的信息队列覆盖之前的信息 /* whether already emits this signal? */ struct rt_slist_node *node; struct siginfo_node *entry; \t\t//获取挂起的信号的信息链表 si_node (struct siginfo_node *)tid >si_list; if (si_node) node (struct rt_slist_node *)&si_node >list; else node RT_NULL; /* update sig info */ for (; (node) ! RT_NULL; node node >next) { //遍历当前任务待处理的所有信号信息 entry rt_slist_entry(node, struct siginfo_node, list); if (entry >si.si_signo sig) { //用新的信息覆盖 memcpy(&(entry >si), &si, sizeof(siginfo_t)); rt_hw_interrupt_enable(level); return 0; } } } rt_hw_interrupt_enable(level); \t//这时候是标志没有挂起, 或者挂起了但是没有信息处理的链表项 //获取一个内存块 si_node (struct siginfo_node *) rt_mp_alloc(_rt_siginfo_pool, 0); if (si_node) { rt_slist_init(&(si_node >list)); //更新一下信息 memcpy(&(si_node >si), &si, sizeof(siginfo_t)); level rt_hw_interrupt_disable(); \t\t//把这个挂入链表里面 if (tid >si_list) { struct siginfo_node *si_list; \t\t\t//这个里面前面有节点 si_list (struct siginfo_node *)tid >si_list; rt_slist_append(&(si_list >list), &(si_node >list)); } else { //前面没有, 这就是第一个 tid >si_list si_node; } /* a new signal 记录一下标志 */ tid >sig_pending sig_mask(sig); rt_hw_interrupt_enable(level); } else { LOG_E(\"The allocation of signal info node failed.\"); } /* deliver signal to this thread */ _signal_deliver(tid); return RT_EOK; } ``` ```c int rt_system_signal_init(void) { //这一个会设置rt_mp_alloc返回的大小 _rt_siginfo_pool rt_mp_create(\"signal\", RT_SIG_INFO_MAX, sizeof(struct siginfo_node)); if (_rt_siginfo_pool RT_NULL) { LOG_E(\"create memory pool for signal info failed.\"); RT_ASSERT(0); } return 0; } ``` ### 等待信号 这一个实际是一直在等待那一个信号, 那一个信号来之前一直挂起, 不会处理其他信号 ```c int rt_signal_wait(const rt_sigset_t *set, rt_siginfo_t *si, rt_int32_t timeout) { int ret RT_EOK; rt_base_t level; rt_thread_t tid rt_thread_self(); struct siginfo_node *si_node RT_NULL, *si_prev RT_NULL; /* current context checking */ RT_DEBUG_IN_THREAD_CONTEXT; /* parameters check */ if (set NULL *set 0 si NULL ) { ret RT_EINVAL; goto __done_return; } /* clear siginfo to avoid unknown value 清空一下, 用于记录 */ memset(si, 0x0, sizeof(rt_siginfo_t)); level rt_hw_interrupt_disable(); /* already pending */ if (tid >sig_pending & *set) goto __done; if (timeout 0) { ret RT_ETIMEOUT; goto __done_int; } /* suspend self thread 把自己挂起 */ rt_thread_suspend(tid); /* set thread stat as waiting for signal */ tid >stat RT_THREAD_STAT_SIGNAL_WAIT; /* start timeout timer */ if (timeout ! RT_WAITING_FOREVER) { /* reset the timeout of thread timer and start it */ rt_timer_control(&(tid >thread_timer), RT_TIMER_CTRL_SET_TIME, &timeout); rt_timer_start(&(tid >thread_timer)); } rt_hw_interrupt_enable(level); /* do thread scheduling */ rt_schedule(); \t//返回, 可能超时或者有信号来了 level rt_hw_interrupt_disable(); /* remove signal waiting flag */ tid >stat & ~RT_THREAD_STAT_SIGNAL_WAIT; /* check errno of thread */ if (tid >error RT_ETIMEOUT) { //是超时 tid >error RT_EOK; rt_hw_interrupt_enable(level); /* timer timeout */ ret RT_ETIMEOUT; goto __done_return; } __done: //是信号来了 /* to get the first matched pending signals */ si_node (struct siginfo_node *)tid >si_list; while (si_node) { //遍历一下所有的节点 int signo; signo si_node >si.si_signo; if (sig_mask(signo) & *set) { //是在等的这一个 *si si_node >si; LOG_D(\"sigwait: %d sig raised!\", signo); if (si_prev) si_prev >list.next si_node >list.next;//这一个信号的链表不在第一个 else { //是第一个 struct siginfo_node *node_next; if (si_node >list.next) { //不是最后一个 node_next (void *)rt_slist_entry(si_node >list.next, struct siginfo_node, list); tid >si_list node_next; } else { //唯一的信号 tid >si_list RT_NULL; } } /* clear pending */ tid >sig_pending & ~sig_mask(signo);//记录为这一个链表处理完了 rt_mp_free(si_node);//释放一下 break; } si_prev si_node; if (si_node >list.next) { //后面还有, 获取下一个 si_node (void *)rt_slist_entry(si_node >list.next, struct siginfo_node, list); } else { si_node RT_NULL; } }//while __done_int: rt_hw_interrupt_enable(level); __done_return: return ret; } ``` ### 其他 ```c #ifdef RT_USING_SIGNALS /* check stat of thread for signal */ level rt_hw_interrupt_disable(); if (rt_current_thread >stat & RT_THREAD_STAT_SIGNAL_PENDING) { extern void rt_thread_handle_sig(rt_bool_t clean_state); rt_current_thread >stat & ~RT_THREAD_STAT_SIGNAL_PENDING; rt_hw_interrupt_enable(level); /* check signal status 处理信号 */ rt_thread_handle_sig(RT_TRUE); } else { rt_hw_interrupt_enable(level); } #endif ``` > 在任务切换的时候rt_schedule里面"},"/note/嵌入式/第三方移植/RT-Thread/2024-1-26-03移植.html":{"title":"RT-Thread移植","content":" layout: post title: \"RT Thread移植\" date: 2024 1 26 15:39:08 +0800 tags: RT Thread # RT Thread移植 ## 标准版本 ![image 20240126182119100](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401261821147.png) ## Nano版本 极简版的硬实时内核, 可裁剪的、抢占式实时多任务的 RTOS。 其内存资源占用极小，功能包括任务处理、软件定时器、信号量、邮箱和实时调度等相对完整的实时操作系统特性。 ![image 20240126182301109](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401261823145.png) [Nano 简介与下载 (rt thread.org)](https://docs.rt thread.org/#/rt thread version/rt thread nano/an0038 nano introduction?id nano 的特点) ## Smart版本 RT Thread Smart（简称 rt smart）是基于 RT Thread 操作系统衍生的新分支，面向带 MMU，中高端应用的芯片 它把应用从内核中独立出来，形成独立的用户态应用程序，并具备独立的地址空间 ![image 20240126183703834](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401261837889.png) ## 实际创建 ![image 20240126190252027](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401261902073.png) ![image 20240126190422972](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401261904008.png) ![image 20240126193038262](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401261930289.png) ![image 20240126195715079](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401261957124.png) ## 添加FinSH ![image 20240126200421732](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401262004758.png) ![image 20240126200458162](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401262004207.png) ![image 20240126200554775](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401262005806.png) ![image 20240126203631759](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401262036796.png)"},"/note/嵌入式/第三方移植/RT-Thread/2024-1-27-05启动流程.html":{"title":"RT-Thread启动流程","content":" layout: post title: \"RT Thread启动流程\" date: 2024 1 26 15:39:08 +0800 tags: RT Thread # RT Thread启动流程 <img src \"https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401271231214.png\" alt \"image 20240127123137747\" style \"zoom:150%;\" /> 开始的时候rttread_startup()函数是RTThread的统一的入口, 一般的顺序是系统先从启动文件开始运行，然后进入 RT Thread 的启动 rtthread_startup() ，最后进入用户入口 main() ![image 20240127123607178](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401271236208.png) ![image 20240127133652325](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401271336375.png) ![image 20240127133749303](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401271337336.png) ## 实际的文件 ![image 20240127134016114](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401271340142.png) ```c /** * @brief This is the code that gets called when the processor first * starts execution following a reset event. Only the absolutely * necessary set is performed, after which the application * supplied main() routine is called. * @param None * @retval : None */ .section .text.Reset_Handler .weak Reset_Handler .type Reset_Handler, %function Reset_Handler: /* Copy the data segment initializers from flash to SRAM 把数据段拷贝到SRAM*/ movs r1, #0 b LoopCopyDataInit CopyDataInit: ldr r3, _sidata ldr r3, [r3, r1] str r3, [r0, r1] adds r1, r1, #4 LoopCopyDataInit: ldr r0, _sdata ldr r3, _edata adds r2, r0, r1 cmp r2, r3 bcc CopyDataInit ldr r2, _sbss b LoopFillZerobss /* Zero fill the bss segment. 把BSS段清零*/ FillZerobss: movs r3, #0 str r3, [r2], #4 LoopFillZerobss: ldr r3, _ebss cmp r2, r3 bcc FillZerobss /* Call the clock system intitialization function.*/ bl SystemInit /* Call static constructors */ /* bl __libc_init_array */ /* Call the application's entry point. 进入C语言的函数*/ bl entry bx lr .size Reset_Handler, . Reset_Handler ``` > 上电以后会进入的是reset中断 ```c /** * @brief Setup the microcontroller system * Initialize the Embedded Flash Interface, the PLL and update the * SystemCoreClock variable. 主要是实现时钟的初始化, 这一个函数设置值一般会在板子初始化的时候被覆盖 * @note This function should be used only after reset. * @param None * @retval None */ void SystemInit (void) { \t//这一个实际需要根据实际的芯片进行分析 ... } ``` ```c //这一个是gcc编译器进入的函数, Keil进入$Sub$$main(后面Keil部分有讲解) int entry(void) { rtthread_startup(); return 0; } ``` ```c //这是一个初始化函数 int rtthread_startup(void) { //关中断 rt_hw_interrupt_disable(); /* board level initialization硬件的初始化 * NOTE: please initialize heap inside board initialization. */ rt_hw_board_init(); /* show RT Thread version 一个打印信息的函数*/ rt_show_version(); /* timer system initialization */ rt_system_timer_init(); /* scheduler system initialization */ rt_system_scheduler_init(); #ifdef RT_USING_SIGNALS /* signal system initialization 信号量的初始化*/ rt_system_signal_init(); #endif /* create init_thread app的线程*/ rt_application_init(); /* timer thread initialization 定时器线程的初始化*/ rt_system_timer_thread_init(); /* idle thread initialization 空闲任务*/ rt_thread_idle_init(); #ifdef RT_USING_SMP rt_hw_spin_lock(&_cpus_lock); #endif /*RT_USING_SMP*/ /* start scheduler 开启调度器*/ rt_system_scheduler_start(); /* never reach here */ return 0; } ``` ```c //主要的作用是开启执行main函数的一个线程 void rt_application_init(void) { rt_thread_t tid; //看看是否使用堆 #ifdef RT_USING_HEAP //使用动态的方式进行初始化 //一个叫做main的任务, 使用的函数是main_thread_entry, 没有参数, 栈大小2048, 优先级10, 时钟20 //会在这一个线程里面进行软件的相关的初始化 tid rt_thread_create(\"main\", main_thread_entry, RT_NULL, RT_MAIN_THREAD_STACK_SIZE, RT_MAIN_THREAD_PRIORITY, 20); RT_ASSERT(tid ! RT_NULL); #else rt_err_t result; tid &main_thread; result rt_thread_init(tid, \"main\", main_thread_entry, RT_NULL, main_stack, sizeof(main_stack), RT_MAIN_THREAD_PRIORITY, 20); RT_ASSERT(result RT_EOK); /* if not define RT_USING_HEAP, using to eliminate the warning */ (void)result; #endif \t//启动线程 rt_thread_startup(tid); } ``` ```c /* the system main thread */ void main_thread_entry(void *parameter) { extern int main(void); extern int $Super$$main(void); #ifdef RT_USING_COMPONENTS_INIT /* RT Thread components initialization 各个组件的初始化*/ rt_components_init(); #endif #ifdef RT_USING_SMP //多处理器的时候用的 rt_hw_secondary_cpu_up(); #endif /* invoke system main function */ #if defined(__CC_ARM) defined(__CLANG_ARM) $Super$$main(); /* for ARMCC. 这个是在Keil里面调用实际的用户定义的main函数*/ #elif defined(__ICCARM__) defined(__GNUC__) //用户层的main函数的接口 main(); #endif } ``` > 这里使用的$Super$$main()的用法会在后面的Keil启动进行讲解 ## Keil启动 在使用Keil的代码的时候为了在进入main函数之前进行初始化, 使用了MDK的扩展功能 ```c //$Super$$以及$Sub$$ /* re define main function */ int $Sub$$main(void) { rtthread_startup(); return 0; } ``` > 使用这一个符号的时候, 会在main函数之前进行调用\\$Sub\\$\\$main这一个函数, 如果想使用原来的main函数, 需要使用\\$Super\\$\\$main(), 在函数之前加上这一个前缀 > > 这一个功能的作用主要是用来在一些不能更改的函数前面进行更改, 比如说库函数 ## 组件以及模块的初始化 RT_Thread使用一些宏定义把需要的初始化的时候调用的函数做成一张表 + 这里使用的是设备的进行分析 需要使用一个宏定义用来把这一个函数进行注册 ```c INIT_BOARD_EXPORT(rt_wdt_init); //进行展开 /***************1**************/ #define INIT_BOARD_EXPORT(fn) INIT_EXPORT(fn, \"1\") INIT_EXPORT(rt_wdt_init, \"1\") /***************2*************/ #define INIT_EXPORT(fn, level) \\ \tRT_USED const init_fn_t __rt_init_##fn SECTION(\".rti_fn.\" level) fn RT_USED const init_fn_t __rt_init_rt_wdt_init SECTION(\".rti_fn.\" \"1\") rt_wdt_init /***************3*************/ #define RT_USED __attribute__((used)) #define SECTION(x) __attribute__((section(x))) __attribute__((used)) const init_fn_t __rt_init_rt_wdt_init __attribute__((section(\".rti_fn.1\"))) rt_wdt_init /* attribute((used)) 其作用是告诉编译器避免被链接器因为未用过而被优化掉。 attribute((section(“name”))) 其作用是将作用的函数或数据放入指定名为\"section_name\"对应的段中 */ ``` > 宏替换完之后，就是定义了一个指向函数的指针变量 `__rt_init_rt_hw_spi_init`，该变量值为 `rt_hw_spi_init`，同时该变量位于 `.rti_fn.1` 段， 该符号段位于内存分配的 RO 段中。 ```c /** * @brief Onboard components initialization. In this function, the board level * initialization function will be called to complete the initialization * of the on board peripherals. */ void rt_components_board_init(void) { volatile const init_fn_t *fn_ptr; \t//会在这里被调用 for (fn_ptr &__rt_init_rti_board_start; fn_ptr < &__rt_init_rti_board_end; fn_ptr++) { (*fn_ptr)(); } #endif /* RT_DEBUGING_INIT */ } ``` > `__rt_init_rti_board_start` 和 `__rt_init_rti_board_end` 这 2 个变量没有在代码中定义, 这里还有一些用于排序的函数的初始化 > > ```c > static int rti_start(void) > { > return 0; > } > INIT_EXPORT(rti_start, \"0\"); > > static int rti_board_start(void) > { > return 0; > } > INIT_EXPORT(rti_board_start, \"0.end\"); > > static int rti_board_end(void) > { > return 0; > } > INIT_EXPORT(rti_board_end, \"1.end\"); > > static int rti_end(void) > { > return 0; > } > INIT_EXPORT(rti_end, \"6.end\"); > ``` > > 通过链接文件进行排序 > > ![](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202501181808371.png) > > ```c > __rt_init_start .; > KEEP(*(SORT(.rti_fn*))) > __rt_init_end .;KEEP(*(SORT(.rti_fn*))) > ``` > > 语句将所有的 `.rti_fn*` 的段，排序后放在 rt_init_start 和 rt_init_end 之间，KEEP 关键字强制链接器保留某些特定部分。 ### 实际的排序 ```c /* board init routines will be called in board_init() function */ #define INIT_BOARD_EXPORT(fn) INIT_EXPORT(fn, \"1\") /* pre/device/component/env/app init routines will be called in init_thread */ /* components pre initialization (pure software initilization) */ #define INIT_PREV_EXPORT(fn) INIT_EXPORT(fn, \"2\") /* device initialization */ #define INIT_DEVICE_EXPORT(fn) INIT_EXPORT(fn, \"3\") /* components initialization (dfs, lwip, ...) */ #define INIT_COMPONENT_EXPORT(fn) INIT_EXPORT(fn, \"4\") /* environment initialization (mount disk, ...) */ #define INIT_ENV_EXPORT(fn) INIT_EXPORT(fn, \"5\") /* appliation initialization (rtgui application etc ...) */ #define INIT_APP_EXPORT(fn) INIT_EXPORT(fn, \"6\") ``` > 这一些是Thread里面的一些宏定义, 通过上面的示例可以知道在RT Thread的初始化的时候这一些函数的顺序如下(这里的宏定义主要是按照这几个数值创建一系列的常量放在对应的段里面, 同时防止编译器优化) > > 1. rti_start() > 2. rti_board_start() > 3. 使用INIT_BOARD_EXPORT初始化的设备的硬件初始化函数 > 4. rti_board_end()这是一个分割线, 不会实际调用 > 5. 使用INIT_PREV_EXPORT的纯软件的初始化、没有太多依赖的函数 > 6. 使用INIT_DEVICE_EXPORT的外设驱动初始化相关，比如网卡设备 > 7. 使用INIT_COMPONENT_EXPORT的组件初始化，比如文件系统或者LWIP > 8. 使用INIT_ENV_EXPORT系统环境初始化，比如挂载文件系统 > 9. 使用INIT_APP_EXPORT的应用初始化，比如GUI应用 > 10. rti_end() ### 实际的调用 在rt_components_board_init里面会调用第一部分的硬件初始化 ```c for (fn_ptr &__rt_init_rti_board_start; fn_ptr < &__rt_init_rti_board_end; fn_ptr++) { (*fn_ptr)(); } ``` rt_components_init()函数会在操作系统运行起来之后创建的main线程里被调用执行 ```c for (fn_ptr &__rt_init_rti_board_end; fn_ptr < &__rt_init_rti_end; fn_ptr ++) { (*fn_ptr)(); } ``` > 调用剩下的一些函数"},"/note/嵌入式/第三方移植/RT-Thread/2024-1-27-07时钟管理.html":{"title":"RT-Thread时钟管理","content":" layout: post title: \"RT Thread时钟管理\" date: 2024 1 26 15:39:08 +0800 tags: RT Thread # 时钟管理 操作系统需要一个时钟用来规范任务 ## 时钟节拍 时钟节拍的长度可以根据 RT_TICK_PER_SECOND 的定义来调整 rtconfig.h配置文件中定义 ```c #define RT_TICK_PER_SECOND 1000 ``` > 时钟是每秒1000次 ```c void SysTick_Handler(void) { /* enter interrupt */ rt_interrupt_enter(); \t//更新时钟 HAL_IncTick(); rt_tick_increase(); /* leave interrupt */ rt_interrupt_leave(); } ``` ```c /** * This function will return current tick from operating system startup * * @return current tick */ rt_tick_t rt_tick_get(void) ``` > 获取时钟 ## 定时器 从指定的时刻开始，经过一定的指定时间后触发一个事件 硬件定时器: 芯片本身提供的定时功能。一般是由外部晶振提供给芯片输入时钟，芯片向软件模块提供一组配置寄存器，接受控制输入，到达设定时间值后芯片中断控制器产生时钟中断。 软件定时器: 由操作系统提供的一类系统接口，它构建在硬件定时器基础之上，使系统能够提供不受数目限制的定时器服务。 RT Thread操作系统提供软件实现的定时器，以时钟节拍（OS Tick）的时间长度为单位，即定时数值必须是OS Tick的整数倍 可以设置单次触发以及周期触发 根据定时器超时函数执行时所处的上下文环境，RT Thread的定时器可以分为HARD_TIMER模式和SOFT_TIMER模式 ![定时器上下文环境](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401281236822.png) HARD_TIMER模式：中断上下文 定时器超时函数的要求：执行时间应该尽量短，执行时不应导致当前上下文挂起、等待。例如在中断上下文中执行的超时函数它不应该试图去申请动态内存、释放动态内存等 SOFT_TIMER模式：线程上下文 该模式被启用后，系统会在初始化时创建一个 timer 线程，然后 SOFT_TIMER 模式的定时器超时函数在都会在timer线程的上下文环境中执行 > 这个是RT Thread使用的 ### 初始化 int rtthread_startup(void)里面有两个函数 ```c /** * @ingroup SystemInit * * This function will initialize system timer */ void rt_system_timer_init(void) { int i; for (i 0; i < sizeof(rt_timer_list) / sizeof(rt_timer_list[0]); i++) { rt_list_init(rt_timer_list + i); } } ``` > 系统定时器的初始化, 注意就是一个列表, 这个数组的个数是一个, 这个是一个硬件定时器的列表 ```c void rt_system_timer_thread_init(void) { #ifdef RT_USING_TIMER_SOFT int i; for (i 0;i < sizeof(rt_soft_timer_list) / sizeof(rt_soft_timer_list[0]);i++) { //这个只是一个链表头, 之后会使用定时器的时间顺序进行插入 rt_list_init(rt_soft_timer_list + i); } /* start software timer thread */ rt_thread_init(&timer_thread, \"timer\", rt_thread_timer_entry, RT_NULL, &timer_thread_stack[0], sizeof(timer_thread_stack), RT_TIMER_THREAD_PRIO, 10); /* startup */ rt_thread_startup(&timer_thread); #endif } ``` ### 机制 主要有两个列表 + 当前系统经过的 tick 时间 rt_tick（当硬件定时器中断来临时，它将加 1） ； + 定时器链表 rt_timer_list。系统新创建并激活的定时器都会按照以超时时间排序的方式插入到rt_timer_list 链表中。 > 这个插入使用的是[定时器跳表 (Skip List) 算法](https://www.rt thread.org/document/site/#/rt thread version/rt thread standard/programming manual/timer/timer?id 定时器跳表 skip list 算法) > > 类似于二分查找法, 会记录一个列表里面的部分项的位置, 用于之后的查找, 可以记录多级索引, 在 RT Thread 中通过宏定义 RT_TIMER_SKIP_LIST_LEVEL 来配置跳表的层数，默认为 1 ## 实际使用 ### 创建 ```c //动态创建 /** * This function will create a timer * * @param name the name of timer * @param timeout the timeout function * @param parameter the parameter of timeout function * @param time the tick of timer * @param flag the flag of timer * * @return the created timer object */ rt_timer_t rt_timer_create(const char *name, void (*timeout)(void *parameter), void *parameter, rt_tick_t time, rt_uint8_t flag) ``` > ```c > #define RT_TIMER_FLAG_DEACTIVATED 0x0 /**< timer is deactive */ > #define RT_TIMER_FLAG_ACTIVATED 0x1 /**< timer is active */ > #define RT_TIMER_FLAG_ONE_SHOT 0x0 /**< one shot timer 一次性的*/ > #define RT_TIMER_FLAG_PERIODIC 0x2 /**< periodic timer 周期的*/ > > #define RT_TIMER_FLAG_HARD_TIMER 0x0 /**< hard timer,the timer's callback function will be called in tick isr. 硬件的, 这一个不会用到*/ > #define RT_TIMER_FLAG_SOFT_TIMER 0x4 /**< soft timer,the timer's callback function will be called in timer thread. 软件的, 这一个主要是插入不同的列表里面*/ > ``` > > 调用该函数接口后，内核首先从动态内存堆中分配一个定时器控制块，然后对该控制块进行基本的初始化。 > > 如果是硬件的会在SystemTick中断里面进行处理, 不然的话会在timer线程处理 ```c //静态创建 /** * This function will initialize a timer, normally this function is used to * initialize a static timer object. * * @param timer the static timer object * @param name the name of timer * @param timeout the timeout function * @param parameter the parameter of timeout function * @param time the tick of timer * @param flag the flag of timer */ void rt_timer_init(rt_timer_t timer, const char *name, void (*timeout)(void *parameter), void *parameter, rt_tick_t time, rt_uint8_t flag) { /* timer check */ RT_ASSERT(timer ! RT_NULL); /* timer object initialization */ rt_object_init((rt_object_t)timer, RT_Object_Class_Timer, name); _rt_timer_init(timer, timeout, parameter, time, flag); } ``` ### 删除 ```c /** * This function will delete a timer and release timer memory * * @param timer the timer to be deleted * * @return the operation status, RT_EOK on OK; RT_ERROR on error */ rt_err_t rt_timer_delete(rt_timer_t timer) ``` ```c /** * This function will detach a timer from timer management. * * @param timer the static timer object * * @return the operation status, RT_EOK on OK; RT_ERROR on error */ rt_err_t rt_timer_detach(rt_timer_t timer) ``` ### 开启 ```c /** * This function will start the timer * * @param timer the timer to be started * * @return the operation status, RT_EOK on OK, RT_ERROR on error */ rt_err_t rt_timer_start(rt_timer_t timer) ``` ### 停止 ```c /** * This function will stop the timer * * @param timer the timer to be stopped * * @return the operation status, RT_EOK on OK, RT_ERROR on error */ rt_err_t rt_timer_stop(rt_timer_t timer) ``` ### 控制 ```c /** * This function will get or set some options of the timer * * @param timer the timer to be get or set * @param cmd the control command * @param arg the argument * * @return RT_EOK */ rt_err_t rt_timer_control(rt_timer_t timer, int cmd, void *arg) ``` > 主要的参数 > > ```c > #define RT_TIMER_CTRL_SET_TIME 0x0 /**< set timer control command 设置时间*/ > #define RT_TIMER_CTRL_GET_TIME 0x1 /**< get timer control command 获取时间*/ > #define RT_TIMER_CTRL_SET_ONESHOT 0x2 /**< change timer to one shot 调整为单次模式*/ > #define RT_TIMER_CTRL_SET_PERIODIC 0x3 /**< change timer to periodic 调整为循环模式*/ > #define RT_TIMER_CTRL_GET_STATE 0x4 /**< get timer run state active or deactive 获取状态(这一个在手册里面没有)*/ > ``` ### 高精度延时 > 这一个延时的时间需要低于一个系统时钟, 否则SysTick会溢出 ```c /** * This function will delay for some us. * * @param us the delay time of us */ void rt_hw_us_delay(rt_uint32_t us) ``` > 这一个函数没有实现, 官方的示例给出的是一个死循环 ## 实际代码分析 ### 用户API函数 ### 创建 ```c //动态获取一个时钟对象 rt_timer_t rt_timer_create(const char *name, void (*timeout)(void *parameter), void *parameter, rt_tick_t time, rt_uint8_t flag) { struct rt_timer *timer; /* 这一部分可以看RT Thread对象篇的讲解 */ timer (struct rt_timer *)rt_object_allocate(RT_Object_Class_Timer, name); if (timer RT_NULL) { return RT_NULL; } _rt_timer_init(timer, timeout, parameter, time, flag); return timer; } ``` ```c //主要是进行一下记录信息 static void _rt_timer_init(rt_timer_t timer, void (*timeout)(void *parameter), void *parameter, rt_tick_t time, rt_uint8_t flag) { int i; /* set flag */ timer >parent.flag flag; /* set deactivated */ timer >parent.flag & ~RT_TIMER_FLAG_ACTIVATED; timer >timeout_func timeout; timer >parameter parameter; \t//这个溢出时间是在start的时候设置才计算的 timer >timeout_tick 0; timer >init_tick time; /* initialize timer list */ for (i 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++) { rt_list_init(&(timer >row[i])); } } ``` #### 删除 ```c rt_err_t rt_timer_delete(rt_timer_t timer) { register rt_base_t level; /* disable interrupt 临界区(可嵌套) */ level rt_hw_interrupt_disable(); \t _rt_timer_remove(timer); /* enable interrupt */ rt_hw_interrupt_enable(level); \t//会在空闲任务释放内存 rt_object_delete((rt_object_t)timer); \t return RT_EOK; } ``` ```c rt_inline void _rt_timer_remove(rt_timer_t timer) { int i; \t//主要是从链表里面移除 for (i 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++) { rt_list_remove(&timer >row[i]); } } ``` #### 开启 ```c rt_err_t rt_timer_start(rt_timer_t timer) { unsigned int row_lvl; rt_list_t *timer_list; register rt_base_t level; rt_list_t *row_head[RT_TIMER_SKIP_LIST_LEVEL]; unsigned int tst_nr; static unsigned int random_nr; /* stop timer firstly 临界区 */ level rt_hw_interrupt_disable(); /* remove timer from list 如果已经开启的话先移出来, 防止一个时钟多次出现在链表里面 */ _rt_timer_remove(timer); /* change status of timer 改变一下标志位 */ timer >parent.flag & ~RT_TIMER_FLAG_ACTIVATED; rt_hw_interrupt_enable(level); \t//回调函数 RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(timer >parent))); /* * get timeout tick, * the max timeout tick shall not great than RT_TICK_MAX/2 */ RT_ASSERT(timer >init_tick < RT_TICK_MAX / 2); //获取当前的时间计算一下溢出的时间 timer >timeout_tick rt_tick_get() + timer >init_tick; /* disable interrupt 可嵌套临界区 */ level rt_hw_interrupt_disable(); #ifdef RT_USING_TIMER_SOFT //根据用户的标志判断是在什么位置处理时钟 if (timer >parent.flag & RT_TIMER_FLAG_SOFT_TIMER) { //这个时钟会在时钟处理任务里面处理 /* insert timer to soft timer list */ timer_list rt_soft_timer_list; } else #endif { //这个会在Systick中断里面处理 /* insert timer to system timer list */ timer_list rt_timer_list; } \t//使用这一个变量进行遍历 row_head[0] &timer_list[0]; //这个时钟的链表只有一层 for (row_lvl 0; row_lvl < RT_TIMER_SKIP_LIST_LEVEL; row_lvl++) { //依次遍历这一个链表 //直到第一个溢出时间比这一个时钟长的时钟的时候退出 //实际使用row_head[0]记录这一个值的前一个 //用于升序插入 for (; row_head[row_lvl] ! timer_list[row_lvl].prev; row_head[row_lvl] row_head[row_lvl] >next) { struct rt_timer *t; rt_list_t *p row_head[row_lvl] >next; /* 获取这个链表所在的时钟结构体(后面有分析) */ t rt_list_entry(p, struct rt_timer, row[row_lvl]); /* If we have two timers that timeout at the same time, it's * preferred that the timer inserted early get called early. * So insert the new timer to the end the the some timeout timer * list. */ if ((t >timeout_tick timer >timeout_tick) 0) { continue; } else if ((t >timeout_tick timer >timeout_tick) < RT_TICK_MAX / 2) { break; } } //这是多层的处理, 不需要关心 if (row_lvl ! RT_TIMER_SKIP_LIST_LEVEL 1) row_head[row_lvl + 1] row_head[row_lvl] + 1; } /* Interestingly, this super simple timer insert counter works very very * well on distributing the list height uniformly. By means of \"very very * well\", I mean it beats the randomness of timer >timeout_tick very easily * (actually, the timeout_tick is not random and easy to be attacked). 这是使用跳表(Skip List)算法的时候使用的, 不需要关心 */ random_nr++; tst_nr random_nr; \t//把这一个链表插入对应的位置 rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL 1], &(timer >row[RT_TIMER_SKIP_LIST_LEVEL 1])); for (row_lvl 2; row_lvl < RT_TIMER_SKIP_LIST_LEVEL; row_lvl++) { //这是使用跳表(Skip List)算法的时候使用的, 不需要关心 \t\t... } timer >parent.flag RT_TIMER_FLAG_ACTIVATED; /* enable interrupt */ rt_hw_interrupt_enable(level); #ifdef RT_USING_TIMER_SOFT if (timer >parent.flag & RT_TIMER_FLAG_SOFT_TIMER) { //检测一下子使用软件时钟处理的时候处理线程打开了没, 没有的话打开 //这个主要是用于更新一下下一次的溢出时间 /* check whether timer thread is ready */ if ((timer_thread.stat & RT_THREAD_STAT_MASK) RT_THREAD_SUSPEND) { /* resume timer thread to check soft timer */ rt_thread_resume(&timer_thread); rt_schedule(); } } #endif return RT_EOK; } ``` ```c /**获取一个链表所在的结构体的起始位置 * @brief get the struct for this entry * @param node the entry point * @param type the type of structure * @param member the name of list in structure */ #define rt_list_entry(node, type, member) \\ rt_container_of(node, type, member) /**这一个实际上是用一个结构体里面的某一个变量的地址减去他的相对于这一个结构体的起始的偏移 * rt_container_of return the member address of ptr, if the type of ptr is the * struct type. */ #define rt_container_of(ptr, type, member) \\ ((type *)((char *)(ptr) (unsigned long)(&((type *)0) >member))) ``` #### 时钟的关闭 ```c rt_err_t rt_timer_stop(rt_timer_t timer) { register rt_base_t level; \t//这不是一个启动了的时钟 if (!(timer >parent.flag & RT_TIMER_FLAG_ACTIVATED)) return RT_ERROR; \t//回调函数 RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(timer >parent))); /* disable interrupt 临界区 */ level rt_hw_interrupt_disable(); \t//主要的处理 _rt_timer_remove(timer); /* enable interrupt */ rt_hw_interrupt_enable(level); /* change stat */ timer >parent.flag & ~RT_TIMER_FLAG_ACTIVATED; return RT_EOK; } ``` ```c //把这一个时钟从链表里面移除 rt_inline void _rt_timer_remove(rt_timer_t timer) { int i; for (i 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++) { rt_list_remove(&timer >row[i]); } } ``` ### 系统后台 #### 中断时钟处理 ```c /**这个是在Systick系统时钟里面的时钟处理 * This function will notify kernel there is one tick passed. Normally, * this function is invoked by clock ISR. */ void rt_tick_increase(void) { struct rt_thread *thread; /* 全局变量rt_tick自加, 使用这一个变量作为系统时钟 */ ++ rt_tick; /* 线程部分的处理, 线程篇分析过了 */ \t... /* check timer */ rt_timer_check(); } ``` ```c void rt_timer_check(void) { struct rt_timer *t; rt_tick_t current_tick; register rt_base_t level; \t//获取时间 current_tick rt_tick_get(); /* disable interrupt 临界区 */ level rt_hw_interrupt_disable(); \t//看一看有没有需要处理的时钟(在中断处理的链表里面) while (!rt_list_isempty(&rt_timer_list[RT_TIMER_SKIP_LIST_LEVEL 1])) { //获取第一个待处理的时钟 t rt_list_entry(rt_timer_list[RT_TIMER_SKIP_LIST_LEVEL 1].next, struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL 1]); /* * It supposes that the new tick shall less than the half duration of * tick max.减去一个溢出时间比最大的时钟小, 说明现在的时间比较大 */ if ((current_tick t >timeout_tick) < RT_TICK_MAX / 2) { //这一个时钟已经到点了 RT_OBJECT_HOOK_CALL(rt_timer_enter_hook, (t)); /* remove timer from timer list firstly 从链表里面移除 */ _rt_timer_remove(t); /* call timeout function 调用一下处理函数 */ t >timeout_func(t >parameter); /* re get tick 更新时钟, 因为不知道用户的代码的长度 */ current_tick rt_tick_get(); \t\t\t//回调函数 RT_OBJECT_HOOK_CALL(rt_timer_exit_hook, (t)); RT_DEBUG_LOG(RT_DEBUG_TIMER, (\"current tick: %d\\n\", current_tick)); if ((t >parent.flag & RT_TIMER_FLAG_PERIODIC) && (t >parent.flag & RT_TIMER_FLAG_ACTIVATED)) { /* start it 这是一个希望周期执行的函数 */ t >parent.flag & ~RT_TIMER_FLAG_ACTIVATED; rt_timer_start(t); } else { /* stop timer 只用执行一次 */ t >parent.flag & ~RT_TIMER_FLAG_ACTIVATED; } } else break; } /* enable interrupt */ rt_hw_interrupt_enable(level); RT_DEBUG_LOG(RT_DEBUG_TIMER, (\"timer check leave\\n\")); } ``` #### 软件时钟的处理 ```c //这是一个时钟处理线程 static void rt_thread_timer_entry(void *parameter) { rt_tick_t next_timeout; while (1) { /* get the next timeout tick 记录一下下一个溢出的时间 */ next_timeout rt_timer_list_next_timeout(rt_soft_timer_list); if (next_timeout RT_TICK_MAX) { /* no software timer exist, suspend self. 没有需要处理的时钟了 */ rt_thread_suspend(rt_thread_self()); rt_schedule(); } else { rt_tick_t current_tick; /* get current tick */ current_tick rt_tick_get(); if ((next_timeout current_tick) < RT_TICK_MAX / 2) { /* get the delta timeout tick */ next_timeout next_timeout current_tick; //任务休眠, 实际使用一个中断时钟(任务篇有讲) rt_thread_delay(next_timeout); } } \t\t//到这里的时候1.有新的时钟插入 2.有时钟到点了 /* check software timer */ rt_soft_timer_check(); } } ``` ```c void rt_soft_timer_check(void) { rt_tick_t current_tick; rt_list_t *n; struct rt_timer *t; RT_DEBUG_LOG(RT_DEBUG_TIMER, (\"software timer check enter\\n\")); current_tick rt_tick_get(); /* lock scheduler */ rt_enter_critical(); \t//遍历一下所有的软件处理的时钟 for (n rt_soft_timer_list[RT_TIMER_SKIP_LIST_LEVEL 1].next; n ! &(rt_soft_timer_list[RT_TIMER_SKIP_LIST_LEVEL 1]);) { //获取一个时钟 t rt_list_entry(n, struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL 1]); /* * It supposes that the new tick shall less than the half duration of * tick max.依次遍历所以到点的时钟 */ if ((current_tick t >timeout_tick) < RT_TICK_MAX / 2) { //这一个时钟时间到了 RT_OBJECT_HOOK_CALL(rt_timer_enter_hook, (t)); /* move node to the next 链表移动到下一个时钟 */ n n >next; /* remove timer from timer list firstly 先从链表里面移出来 */ _rt_timer_remove(t); /* not lock scheduler when performing timeout function 在处理这一个时钟的处理函数的时候不能关闭中断 */ rt_exit_critical(); /* call timeout function 调用时钟的函数 */ t >timeout_func(t >parameter); /* re get tick 获取当前时间 */ current_tick rt_tick_get(); RT_OBJECT_HOOK_CALL(rt_timer_exit_hook, (t)); RT_DEBUG_LOG(RT_DEBUG_TIMER, (\"current tick: %d\\n\", current_tick)); /* lock scheduler */ rt_enter_critical(); if ((t >parent.flag & RT_TIMER_FLAG_PERIODIC) && (t >parent.flag & RT_TIMER_FLAG_ACTIVATED)) { /* start it 这是一个周期性的 */ t >parent.flag & ~RT_TIMER_FLAG_ACTIVATED; rt_timer_start(t); } else { /* stop timer */ t >parent.flag & ~RT_TIMER_FLAG_ACTIVATED; } } else break; /* not check anymore */ } /* unlock scheduler */ rt_exit_critical(); RT_DEBUG_LOG(RT_DEBUG_TIMER, (\"software timer check leave\\n\")); } ```"},"/note/嵌入式/第三方移植/RT-Thread/2024-1-26-02RT-Thread架构.html":{"title":"RT-Thread架构","content":" layout: post title: \"RT Thread架构\" date: 2024 1 26 15:39:08 +0800 tags: RT Thread # RT Thread架构 物联网（Internet Of Things，IoT）概念普及, 物联网操作系统（IoT OS）的概念应运而生。 物联网操作系统是指以操作系统内核（可以是 RTOS、Linux 等）为基础，包括如文件系统、图形库等较为完整的中间件组件，具备低功耗、安全、通信协议支持和云端连接能力的软件平台，RT Thread 就是一个 IoT OS。 不仅仅是一个实时内核，还具备丰富的中间层组件 ![image 20240126180636950](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401261806999.png)"},"/note/嵌入式/第三方移植/RT-Thread/2024-1-26-01简介.html":{"title":"简介","content":" layout: post title: \"简介\" date: 2024 1 26 15:39:08 +0800 tags: RT Thread # RT Thread简介 Real Time Thread 这是一个为了物联网开发设计的RTOS, 目标是Alot的主流操作系统 > AIoT AI+IoT，智能物联 人工智能+物联网。简单来说，AI像是大脑，负责数据处理，IoT是神经末梢网络，负责连接、数据收集、数据反馈。 RT Thread是一个操作系统内核, 是一个组件以及社区一体的技术平台, 组件多, 高度可收缩, 低功耗, 高安全性的物联网操作系统, 可通过方便易用的工具，裁剪出仅需要 3KB Flash、1.2KB RAM 内存资源的 NANO 版本 他有GUI, 网络协议, 安全传输, 低功耗等组件, 国内最大的嵌入式开源社区, 国人开发的最大的开源RTOS 支持GGC, Keil等, 支持各种标准接口如POSIX, CMSIS, C++应用环境, Javascript执行环境, 方便移植, 以及主流的架构和几乎所有的MUC和WiFi芯片 可以实现类似于安卓的图形界面 > POSIX：可移植操作系统接口, 这是Linux和Unix使用的标准 > > CMSIS: ARM公司的一个硬件接口层 ## 发展历史 ![image 20240126174726577](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401261747664.png) ## 文档 https://www.rt thread.org/document/site/tutorial/quick start/introduction/introduction/"},"/note/嵌入式/第三方移植/RT-Thread/2024-1-28-09系统间同步.html":{"title":"系统间同步","content":" layout: post title: \"系统间同步\" date: 2024 1 28 15:39:08 +0800 tags: RT Thread # 系统间同步 RTThread提供的方式有信号量, 互斥量以及事件集 ## 信号量 每个信号量对象都有一个信号量值和一个线程等待队列，信号量的值对应了信号量对象的实例数目、资源数目，假如信号量值为 5，则表示共有 5 个信号量实例（资源）可以被使用，当信号量实例数目为零时，再申请该信号量的线程就会被挂起在该信号量的等待队列上，等待可用的信号量实例 ```c struct rt_semaphore { struct rt_ipc_object parent; /**< inherit from ipc_object 继承自ipc_object类*/ rt_uint16_t value; /**< value of semaphore. */ rt_uint16_t reserved; /**< reserved field 预留*/ }; typedef struct rt_semaphore *rt_sem_t; ``` ![image 20240128135511326](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401281355367.png) ## 实际使用 ### 创建 ```c /** * This function will create a semaphore from system resource * * @param name the name of semaphore * @param value the initial value of semaphore * @param flag the flag of semaphore * * @return the created semaphore, RT_NULL on error happen * * @see rt_sem_init */ rt_sem_t rt_sem_create(const char *name, rt_uint32_t value, rt_uint8_t flag) ``` > ```c > #define RT_IPC_FLAG_FIFO 0x00 /**< FIFOed IPC. @ref IPC. 按照先进先出的方式获取 */ > #define RT_IPC_FLAG_PRIO 0x01 /**< PRIOed IPC. @ref IPC. 按照线程优先级 */ > ``` ```c /** * This function will initialize a semaphore and put it under control of * resource management. * * @param sem the semaphore object * @param name the name of semaphore * @param value the initial value of semaphore * @param flag the flag of semaphore * * @return the operation status, RT_EOK on successful */ rt_err_t rt_sem_init(rt_sem_t sem, const char *name, rt_uint32_t value, rt_uint8_t flag) ``` ### 删除 ```c /** * This function will delete a semaphore object and release the memory * * @param sem the semaphore object * * @return the error code * * @see rt_sem_detach */ rt_err_t rt_sem_delete(rt_sem_t sem) ``` > 系统将删除这个信号量。如果删除该信号量时，有线程正在等待该信号量，那么删除操作会先唤醒等待在该信号量上的线程（等待线程的返回值是 RT_ERROR），然后再释放信号量的内存资源。 ```c /** * This function will detach a semaphore from resource management * * @param sem the semaphore object * * @return the operation status, RT_EOK on successful * * @see rt_sem_delete */ rt_err_t rt_sem_detach(rt_sem_t sem) ``` ### 获取 ```c /** * This function will take a semaphore, if the semaphore is unavailable, the * thread shall wait for a specified time. * * @param sem the semaphore object * @param time the waiting time * * @return the error code */ rt_err_t rt_sem_take(rt_sem_t sem, rt_int32_t time) /** * This function will try to take a semaphore and immediately return * * @param sem the semaphore object * * @return the error code */ rt_err_t rt_sem_trytake(rt_sem_t sem) { return rt_sem_take(sem, 0); } ``` ### 释放 ```c /** * This function will release a semaphore, if there are threads suspended on * semaphore, it will be waked up. * * @param sem the semaphore object * * @return the error code */ rt_err_t rt_sem_release(rt_sem_t sem) ``` ## 互斥量 拥有互斥量的线程拥有互斥量的所有权，互斥量支持递归访问且能防止线程优先级翻转；并且互斥量只能由持有线程释放，而信号量则可以由任何线程释放。 持有该互斥量的线程也能够再次获得这个锁而不被挂起(防止死锁) 这个实现了优先级继承(防止优先级翻转) > **注: **不可在中断里面使用 ![image 20240128143528805](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401281435847.png) ### 创建 ```c /** * This function will create a mutex from system resource * * @param name the name of mutex * @param flag the flag of mutex * * @return the created mutex, RT_NULL on error happen * * @see rt_mutex_init */ rt_mutex_t rt_mutex_create(const char *name, rt_uint8_t flag) ``` ```c /** * This function will initialize a mutex and put it under control of resource * management. * * @param mutex the mutex object * @param name the name of mutex * @param flag the flag of mutex * * @return the operation status, RT_EOK on successful */ rt_err_t rt_mutex_init(rt_mutex_t mutex, const char *name, rt_uint8_t flag) ``` > flag可以是 > > ```c > #define RT_IPC_FLAG_FIFO 0x00 /**< FIFOed IPC. @ref IPC. 按照先进先出的方式获取 */ > #define RT_IPC_FLAG_PRIO 0x01 /**< PRIOed IPC. @ref IPC. 按照线程优先级 */ > ``` ### 删除 ```c /** * This function will delete a mutex object and release the memory * * @param mutex the mutex object * * @return the error code * * @see rt_mutex_detach */ rt_err_t rt_mutex_delete(rt_mutex_t mutex) /** * This function will detach a mutex from resource management * * @param mutex the mutex object * * @return the operation status, RT_EOK on successful * * @see rt_mutex_delete */ rt_err_t rt_mutex_detach(rt_mutex_t mutex) ``` > 会唤醒所有的睡眠的函数 ### 获取 ```c /* * This function will take a mutex, if the mutex is unavailable, the * thread shall wait for a specified time. * * @param mutex the mutex object * @param time the waiting time * * @return the error code */ rt_err_t rt_mutex_take(rt_mutex_t mutex, rt_int32_t time) ``` ### 释放 ```c /** * This function will release a mutex, if there are threads suspended on mutex, * it will be waked up. * * @param mutex the mutex object * * @return the error code */ rt_err_t rt_mutex_release(rt_mutex_t mutex) ``` ## 事件集 一个事件集可以包含多个事件，利用事件集可以完成一对多，多对多的线程间同步。 其中任意一个事件唤醒 线程，或几个事件都到达后唤醒线程，多个事件集合可以用一个32bit无符号整型变量来表示 + 事件只与线程相关，事件间相互独立 + 事件仅用于同步，不提供数据传输功能 + 事件无排队性，即多次向线程发送同一事件(如果线程还未来得及读走)，其效果等同于只发送一次 ![image 20240128155840632](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401281558667.png) ```c /* * event structure */ struct rt_event { struct rt_ipc_object parent; /**< inherit from ipc_object */ rt_uint32_t set; /**< event set */ }; ``` ## 实际使用 ### 创建和删除 ```c /** * This function will create an event object from system resource * * @param name the name of event * @param flag the flag of event RT_IPC_FLAG_FIFO RT_IPC_FLAG_PRIO * * @return the created event, RT_NULL on error happen */ rt_event_t rt_event_create(const char *name, rt_uint8_t flag) /** * This function will delete an event object and release the memory * * @param event the event object * * @return the error code */ rt_err_t rt_event_delete(rt_event_t event) /** * This function will initialize an event and put it under control of resource * management. * * @param event the event object * @param name the name of event * @param flag the flag of event * * @return the operation status, RT_EOK on successful */ rt_err_t rt_event_init(rt_event_t event, const char *name, rt_uint8_t flag) /** * This function will detach an event object from resource management * * @param event the event object * * @return the operation status, RT_EOK on successful */ rt_err_t rt_event_detach(rt_event_t event) ``` ### 发送事件 ```c /** * This function will send an event to the event object, if there are threads * suspended on event object, it will be waked up. * * @param event the event object * @param set the event set * * @return the error code */ rt_err_t rt_event_send(rt_event_t event, rt_uint32_t set) ``` ### 接收事件集 ```c /** * This function will receive an event from event object, if the event is * unavailable, the thread shall wait for a specified time. * * @param event the fast event object * @param set the interested event set * @param option the receive option, either RT_EVENT_FLAG_AND or * RT_EVENT_FLAG_OR should be set. RT_EVENT_FLAG_CLEAR * @param timeout the waiting time RT_WAITING_FOREVER RT_WAITING_NO * @param recved the received event, if you don't care, RT_NULL can be set. * * @return the error code */ rt_err_t rt_event_recv(rt_event_t event, rt_uint32_t set, rt_uint8_t option, rt_int32_t timeout, rt_uint32_t *recved) ``` ## 源码分析 ### 信号量 ```c /** * Semaphore structure */ struct rt_semaphore { struct rt_ipc_object parent; /**< inherit from ipc_object */ rt_uint16_t value; /**< value of semaphore. \t\t\t\t\t\t\t\t\t\t\t\t信号量的值*/ rt_uint16_t reserved; /**< reserved field 保留*/ }; typedef struct rt_semaphore *rt_sem_t; ``` ```c /** * Base structure of IPC object */ struct rt_ipc_object { struct rt_object parent; /**< inherit from rt_object */ rt_list_t suspend_thread; /**< threads pended on this \t\t\t\t\t\t\t\t\t\t\t\t\t\tresource 希望获取这一个的线程 */ }; ``` #### 创建 ```c rt_sem_t rt_sem_create(const char *name, rt_uint32_t value, rt_uint8_t flag) { rt_sem_t sem; /* allocate object 获取一个对象, 这一个是对象处理的时候分析过了 */ sem (rt_sem_t)rt_object_allocate(RT_Object_Class_Semaphore, name); if (sem RT_NULL) return sem; /* initialize ipc object 初始化以及记录链表的信息*/ rt_ipc_object_init(&(sem >parent)); /* set initial value */ sem >value value; /* set parent */ sem >parent.parent.flag flag; return sem; } ``` ```c //初始化一个链表 rt_inline rt_err_t rt_ipc_object_init(struct rt_ipc_object *ipc) { /* initialize ipc object */ rt_list_init(&(ipc >suspend_thread)); return RT_EOK; } ``` #### 删除 ```c rt_err_t rt_sem_delete(rt_sem_t sem) { RT_DEBUG_NOT_IN_INTERRUPT; /* wakeup all suspended threads 唤醒所有的在等待这一个线程的任务, 把他们的错误标志位设置为错误 */ rt_ipc_list_resume_all(&(sem >parent.suspend_thread)); /* delete semaphore object 把这一个对象放在删除队列里面, 空闲任务的时候会处理 */ rt_object_delete(&(sem >parent.parent)); return RT_EOK; } ``` ```c rt_inline rt_err_t rt_ipc_list_resume_all(rt_list_t *list) { struct rt_thread *thread; register rt_ubase_t temp; /* wakeup all suspended threads */ while (!rt_list_isempty(list)) { //这一个信号量有正在等待他的线程 /* disable interrupt 临界区 */ temp rt_hw_interrupt_disable(); /* get next suspended thread 获取一个线程的控制块 */ thread rt_list_entry(list >next, struct rt_thread, tlist); /* set error code to RT_ERROR 线程的标志位改为错误 */ thread >error RT_ERROR; /* * resume thread 恢复这一个线程的运行, 关闭线程时钟 * In rt_thread_resume function, it will remove current thread from * suspended list */ rt_thread_resume(thread); /* enable interrupt */ rt_hw_interrupt_enable(temp); } return RT_EOK; } ``` #### 获取 ```c rt_err_t rt_sem_take(rt_sem_t sem, rt_int32_t time) { register rt_base_t temp; struct rt_thread *thread; \t//回调函数 RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(sem >parent.parent))); /* disable interrupt 临界区 */ temp rt_hw_interrupt_disable(); \t//Debug信息打印 RT_DEBUG_LOG(RT_DEBUG_IPC, (\"thread %s take sem:%s, which value is: %d\\n\", rt_thread_self() >name, ((struct rt_object *)sem) >name, sem >value)); if (sem >value > 0) { //这时候还有可以申请的 /* semaphore is available */ sem >value ; /* enable interrupt */ rt_hw_interrupt_enable(temp); } else { //没有可以使用的资源了 /* no waiting, return with timeout */ if (time 0) { //不想等待 rt_hw_interrupt_enable(temp); return RT_ETIMEOUT; } else { //有一个等待时间, 需要挂起 /* current context checking */ RT_DEBUG_IN_THREAD_CONTEXT; /* semaphore is unavailable, push to suspend list */ /* get current thread */ //获取当前的线程 thread rt_thread_self(); /* reset thread error number */ //改变一下线程的错误值 thread >error RT_EOK; RT_DEBUG_LOG(RT_DEBUG_IPC, (\"sem take: suspend thread %s\\n\", thread >name)); /* suspend thread */ //把这个线程插入链表里面 rt_ipc_list_suspend(&(sem >parent.suspend_thread), thread, sem >parent.parent.flag); /* has waiting time, start thread timer */ if (time > 0) { RT_DEBUG_LOG(RT_DEBUG_IPC, (\"set thread:%s to timer list\\n\", thread >name)); /* reset the timeout of thread timer and start it 使用这一个线程的时钟进行唤醒 */ rt_timer_control(&(thread >thread_timer), RT_TIMER_CTRL_SET_TIME, &time); rt_timer_start(&(thread >thread_timer)); } /* enable interrupt */ rt_hw_interrupt_enable(temp); /* do schedule 获取当前优先级最高的函数并切换过去 */ rt_schedule(); \t\t\t//这个时候1.获取到了2.超时3.信号量没了 if (thread >error ! RT_EOK) { //出现错误了 return thread >error; } } } RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(sem >parent.parent))); return RT_EOK; } ``` ```c rt_inline rt_err_t rt_ipc_list_suspend(rt_list_t *list, struct rt_thread *thread, rt_uint8_t flag) { /* suspend thread */ rt_thread_suspend(thread); switch (flag) { case RT_IPC_FLAG_FIFO: //按照先进先出的方式进行添加 rt_list_insert_before(list, &(thread >tlist)); break; case RT_IPC_FLAG_PRIO: { //按照优先级的模式进行添加 struct rt_list_node *n; struct rt_thread *sthread; /* find a suitable position 遍历一下链表获取一个合适的位置 */ for (n list >next; n ! list; n n >next) { sthread rt_list_entry(n, struct rt_thread, tlist); /* find out */ if (thread >current_priority < sthread >current_priority) { /* insert this thread before the sthread 把这个线程插入进去 */ rt_list_insert_before(&(sthread >tlist), &(thread >tlist)); break; } } /* 这一个线程的优先级是链表里面最低的放在最后 * not found a suitable position, * append to the end of suspend_thread list */ if (n list) rt_list_insert_before(list, &(thread >tlist)); } break; } return RT_EOK; } ``` ```c rt_err_t rt_sem_trytake(rt_sem_t sem) {\t //一个不延时的获取信号量 return rt_sem_take(sem, 0); } ``` #### 释放 ````c rt_err_t rt_sem_release(rt_sem_t sem) { register rt_base_t temp; register rt_bool_t need_schedule; need_schedule RT_FALSE;//记录一下需不需要任务的切换 /* disable interrupt 临界区 */ temp rt_hw_interrupt_disable(); RT_DEBUG_LOG(RT_DEBUG_IPC, (\"thread %s releases sem:%s, which value is: %d\\n\", rt_thread_self() >name, ((struct rt_object *)sem) >name, sem >value)); \t//看一看有么有挂起的任务 if (!rt_list_isempty(&sem >parent.suspend_thread)) { /* resume the suspended thread */ //把一个任务释放出来, 这一个任务获取到这一个信号量, 下面有分析 rt_ipc_list_resume(&(sem >parent.suspend_thread)); need_schedule RT_TRUE; } else sem >value ++; /* increase value */ /* enable interrupt */ rt_hw_interrupt_enable(temp); /* resume a thread, re schedule 之前记录的需要切换任务 */ if (need_schedule RT_TRUE) rt_schedule(); return RT_EOK; } ```` ```c rt_inline rt_err_t rt_ipc_list_resume(rt_list_t *list) { struct rt_thread *thread; /* get thread entry */ thread rt_list_entry(list >next, struct rt_thread, tlist); RT_DEBUG_LOG(RT_DEBUG_IPC, (\"resume thread:%s\\n\", thread >name)); /* resume it 恢复一个线程, 把线程时钟关了 */ rt_thread_resume(thread); return RT_EOK; } ``` ### 互斥量 ```c struct rt_mutex { struct rt_ipc_object parent; /**< inherit from ipc_object */ rt_uint16_t value; /**< value of mutex 值*/ rt_uint8_t original_priority; /**< priority of last thread hold \t\t\t\t\t\t\t\t\t\t\t\tthe mutex 持有的线程的原优先级*/ rt_uint8_t hold; /**< numbers of thread hold the \t\t\t\t\t\t\t\t\t\t\t\tmutex 持有线程的持有次数*/ struct rt_thread *owner; /**< current owner of mutex \t\t\t\t\t\t\t\t\t\t\t\t当前拥有互斥量的线程*/ }; ``` #### 创建 ```c //一个标准的对象创建, 和信号量基本一致 rt_mutex_t rt_mutex_create(const char *name, rt_uint8_t flag) { struct rt_mutex *mutex; RT_DEBUG_NOT_IN_INTERRUPT; /* allocate object */ mutex (rt_mutex_t)rt_object_allocate(RT_Object_Class_Mutex, name); if (mutex RT_NULL) return mutex; /* initialize ipc object */ rt_ipc_object_init(&(mutex >parent)); mutex >value 1; mutex >owner RT_NULL; mutex >original_priority 0xFF; mutex >hold 0; /* set flag */ mutex >parent.parent.flag flag; return mutex; } ``` #### 释放 ```c rt_err_t rt_mutex_delete(rt_mutex_t mutex) { RT_DEBUG_NOT_IN_INTERRUPT; /* wakeup all suspended threads 唤醒所有的线程, 上面分析过了 */ rt_ipc_list_resume_all(&(mutex >parent.suspend_thread)); /* delete mutex object 等待释放 */ rt_object_delete(&(mutex >parent.parent)); return RT_EOK; } ``` #### 获取 ```c rt_err_t rt_mutex_take(rt_mutex_t mutex, rt_int32_t time) { register rt_base_t temp; struct rt_thread *thread; \t//这一个函数不可以在中断里面使用, 这时候的优先级是无效的 /* this function must not be used in interrupt even if time 0 */ RT_DEBUG_IN_THREAD_CONTEXT; /* get current thread 获取当前的线程*/ thread rt_thread_self(); /* disable interrupt 临界区 */ temp rt_hw_interrupt_disable(); /* reset thread error */ thread >error RT_EOK; \t//看一下是不是一个线程的重复上锁 if (mutex >owner thread) { /* it's the same thread 是的*/ mutex >hold ++; } else { __again: /* The value of mutex is 1 in initial status. Therefore, if the * value is great than 0, it indicates the mutex is avaible. */ if (mutex >value > 0) { //这是第一次上锁是可以获取的状态 /* mutex is available */ mutex >value ; /* set mutex owner and original priority 记录一下这个线程的优先级 */ mutex >owner thread; mutex >original_priority thread >current_priority; mutex >hold ++; } else { /* no waiting, return with timeout 这个互斥量已经被拥有了 */ if (time 0) { //不需要等待 /* set error as timeout */ thread >error RT_ETIMEOUT; /* enable interrupt */ rt_hw_interrupt_enable(temp); return RT_ETIMEOUT; } else { //等待这线互斥量被释放 /* mutex is unavailable, push to suspend list */ RT_DEBUG_LOG(RT_DEBUG_IPC, (\"mutex_take: suspend thread: %s\\n\", thread >name)); \t\t\t\t//调整一下优先级, 以防被优先级反转 /* change the owner thread priority of mutex */ if (thread >current_priority < mutex >owner >current_priority) { //持有者的优先级比较低, 需要进行升级 /* change the owner thread priority */ rt_thread_control(mutex >owner, RT_THREAD_CTRL_CHANGE_PRIORITY, &thread >current_priority); } /* suspend current thread 把这一个线程归入挂起的队列里面(按互斥量的获取规则) */ rt_ipc_list_suspend(&(mutex >parent.suspend_thread), thread, mutex >parent.parent.flag); /* has waiting time, start thread timer 使能这一个线程的时钟用于唤醒 */ if (time > 0) { RT_DEBUG_LOG(RT_DEBUG_IPC, (\"mutex_take: start the timer of thread:%s\\n\", thread >name)); /* reset the timeout of thread timer and start it */ rt_timer_control(&(thread >thread_timer), RT_TIMER_CTRL_SET_TIME, &time); rt_timer_start(&(thread >thread_timer)); } /* enable interrupt */ rt_hw_interrupt_enable(temp); /* do schedule 开启任务切换 */ rt_schedule(); \t\t\t\t//这个时候以及获取到或者失败 if (thread >error ! RT_EOK) { //失败了 /* interrupt by signal, try it again */ if (thread >error RT_EINTR) goto __again;//这一个分支是使用信号 \t\t\t\t\t\t\t\t\t\t //机制打断的时候的处理 /* return error */ return thread >error; } else { /* the mutex is taken successfully. */ /* disable interrupt */ temp rt_hw_interrupt_disable(); } } } } /* enable interrupt */ rt_hw_interrupt_enable(temp); RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mutex >parent.parent))); return RT_EOK; } ``` #### 释放 ```c rt_err_t rt_mutex_release(rt_mutex_t mutex) { register rt_base_t temp; struct rt_thread *thread; rt_bool_t need_schedule; need_schedule RT_FALSE; /* only thread could release mutex because we need test the ownership 不可以在中断里面使用 */ RT_DEBUG_IN_THREAD_CONTEXT; /* get current thread */ thread rt_thread_self(); /* disable interrupt */ temp rt_hw_interrupt_disable(); RT_DEBUG_LOG(RT_DEBUG_IPC, (\"mutex_release:current thread %s, mutex value: %d, hold: %d\\n\", thread >name, mutex >value, mutex >hold)); RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mutex >parent.parent))); /* mutex only can be released by owner 只有拥有这一个互斥量的线程可以释放它 */ if (thread ! mutex >owner) { //没有释放的权利 thread >error RT_ERROR; /* enable interrupt */ rt_hw_interrupt_enable(temp); return RT_ERROR; } /* decrease hold */ mutex >hold ; /* if no hold */ if (mutex >hold 0) { //这是最后一层的释放 /* change the owner thread to original priority */ if (mutex >original_priority ! mutex >owner >current_priority) { rt_thread_control(mutex >owner, RT_THREAD_CTRL_CHANGE_PRIORITY, &(mutex >original_priority)); } /* wakeup suspended thread 看一看有没有在等待的线程 */ if (!rt_list_isempty(&mutex >parent.suspend_thread)) { /* get suspended thread 获取一下下一个等待的线程 */ thread rt_list_entry(mutex >parent.suspend_thread.next, struct rt_thread, tlist); RT_DEBUG_LOG(RT_DEBUG_IPC, (\"mutex_release: resume thread: %s\\n\", thread >name)); /* set new owner and priority 记录信息 */ mutex >owner thread; mutex >original_priority thread >current_priority; mutex >hold ++; /* resume thread 把这一个线程从等待队列里面取出来以及关闭时钟, 前面有分析 */ rt_ipc_list_resume(&(mutex >parent.suspend_thread)); need_schedule RT_TRUE; } else { //最外层并且没有在等待的线程 //设置为空闲的状态 /* increase value */ mutex >value ++; /* clear owner */ mutex >owner RT_NULL; mutex >original_priority 0xff; } } /* enable interrupt */ rt_hw_interrupt_enable(temp); /* perform a schedule */ if (need_schedule RT_TRUE) rt_schedule(); return RT_EOK; } ``` ### 事件集 ```c struct rt_event { struct rt_ipc_object parent; /**< inherit from ipc_object */ rt_uint32_t set; /**< event set \t\t\t\t\t\t\t\t\t\t\t\t记录事件, 每一bit表示1个事件 */ }; ``` #### 创建以及释放和上面基本一样 略 #### 发送事件 ```c rt_err_t rt_event_send(rt_event_t event, rt_uint32_t set) { struct rt_list_node *n; struct rt_thread *thread; register rt_ubase_t level; register rt_base_t status; rt_bool_t need_schedule; if (set 0)//没有要发送的事件 return RT_ERROR; need_schedule RT_FALSE; /* disable interrupt 临界区 */ level rt_hw_interrupt_disable(); /* set event 设置一下对应的位 */ event >set set; if (!rt_list_isempty(&event >parent.suspend_thread)) { //这个队列里面有在等待的事件, 遍历一遍看一看有没有可以释放的 /* search thread list to resume thread */ n event >parent.suspend_thread.next; while (n ! &(event >parent.suspend_thread)) { /* get thread */ thread rt_list_entry(n, struct rt_thread, tlist); status RT_ERROR;//记录一下可不可以释放 if (thread >event_info & RT_EVENT_FLAG_AND) { //使用AND的方式比较 if ((thread >event_set & event >set) thread >event_set) { /* received an AND event */ status RT_EOK; } } else if (thread >event_info & RT_EVENT_FLAG_OR) { //使用OR的方式进行比较 if (thread >event_set & event >set) { /* save the received event set 传递一下当前的事件 */ thread >event_set thread >event_set & event >set; /* received an OR event */ status RT_EOK; } } /* move node to the next 下一个链表记录一下*/ n n >next; /* condition is satisfied, resume thread */ if (status RT_EOK) { //需要释放这一个任务 /* clear event */ if (thread >event_info & RT_EVENT_FLAG_CLEAR) event >set & ~thread >event_set;//需要清除这一个事件 /* resume thread, and thread list breaks out 释放这一个任务 */ rt_thread_resume(thread); /* need do a scheduling 记录一下需要进行任务切换 */ need_schedule RT_TRUE; } } } /* enable interrupt */ rt_hw_interrupt_enable(level); /* do a schedule */ if (need_schedule RT_TRUE) rt_schedule(); return RT_EOK; } ``` #### 接收事件 ```c rt_err_t rt_event_recv(rt_event_t event, rt_uint32_t set, rt_uint8_t option, rt_int32_t timeout, rt_uint32_t *recved) { struct rt_thread *thread; register rt_ubase_t level; register rt_base_t status; if (set 0)//没有等待的事件 return RT_ERROR; /* initialize status */ status RT_ERROR; /* get current thread 获取当前的任务 */ thread rt_thread_self(); /* reset thread error */ thread >error RT_EOK; /* disable interrupt 临界区 */ level rt_hw_interrupt_disable(); /* check event set 看一看这一个事件是不是已经达成了 */ if (option & RT_EVENT_FLAG_AND) { if ((event >set & set) set) status RT_EOK; } else if (option & RT_EVENT_FLAG_OR) { if (event >set & set) status RT_EOK; } else { /* either RT_EVENT_FLAG_AND or RT_EVENT_FLAG_OR should be set */ RT_ASSERT(0); } if (status RT_EOK) { //这个事件已经实现了, 记录一下当前的情况 /* set received event */ if (recved) *recved (event >set & set); /* received event */ if (option & RT_EVENT_FLAG_CLEAR)//需要清除标志位 event >set & ~set; } else if (timeout 0) { //事件没有达成, 但是不等待 /* no waiting */ thread >error RT_ETIMEOUT; } else { /* fill thread event info */ thread >event_set set; thread >event_info option; /* put thread to suspended thread list 把这一个任务挂起 */ rt_ipc_list_suspend(&(event >parent.suspend_thread), thread, event >parent.parent.flag); /* if there is a waiting timeout, active thread timer 使用时钟进行唤醒 */ if (timeout > 0) { /* reset the timeout of thread timer and start it */ rt_timer_control(&(thread >thread_timer), RT_TIMER_CTRL_SET_TIME, &timeout); rt_timer_start(&(thread >thread_timer)); } /* enable interrupt */ rt_hw_interrupt_enable(level); /* do a schedule 任务切换 */ rt_schedule(); \t\t//这时候获取到事件或者时间到了 if (thread >error ! RT_EOK) { //出错了(比如超时) /* return error */ return thread >error; } /* received an event, disable interrupt to protect */ level rt_hw_interrupt_disable(); /* set received event */ if (recved)//记录一下当前的事件 *recved thread >event_set; } /* enable interrupt */ rt_hw_interrupt_enable(level); return thread >error; } ```"},"/note/嵌入式/第三方移植/RT-Thread/2024-1-28-11串口设备.html":{"title":"串口设备","content":" layout: post title: \"串口设备\" date: 2024 1 28 15:39:08 +0800 tags: RT Thread # 串口设备 ## 访问的时候使用到的函数 **函数** **描述** rt_device_find() 查找设备 rt_device_open() 打开设备 rt_device_read() 读取数据 rt_device_write() 写入数据 rt_device_control() 控制设备 rt_device_set_rx_indicate() 设置接收回调函数 rt_device_set_tx_complete() 设置发送完成回调函数 rt_device_close() 关闭设备 ### 查找 ```c rt_device_t rt_device_find(const char* name); ``` 一般情况下，注册到系统的串口设备名称为 uart0，uart1等，使用示例如下所示： ```c #define SAMPLE_UART_NAME \"uart2\" /* 串口设备名称 */ static rt_device_t serial; /* 串口设备句柄 */ /* 查找串口设备 */ serial rt_device_find(SAMPLE_UART_NAME); ``` ### 打开一个串口设备 ```c rt_err_t rt_device_open(rt_device_t dev, rt_uint16_t oflags); ``` > ```c > #define RT_DEVICE_FLAG_STREAM 0x040 /* 流模式 */ > /* 接收模式参数 */ > #define RT_DEVICE_FLAG_INT_RX 0x100 /* 中断接收模式 */ > #define RT_DEVICE_FLAG_DMA_RX 0x200 /* DMA 接收模式 */ > /* 发送模式参数 */ > #define RT_DEVICE_FLAG_INT_TX 0x400 /* 中断发送模式 */ > #define RT_DEVICE_FLAG_DMA_TX 0x800 /* DMA 发送模式 */ > ``` > > > 串口数据接收和发送数据的模式分为 3 种：中断模式、轮询模式、DMA 模式。 > > > > 默认使用轮询模式。 > > > > RT_DEVICE_FLAG_STREAM：流模式用于向串口终端输出字符串：当输出的字符是 `\"\\n\"` （对应 16 进制值为 0x0A）时，自动在前面输出一个 `\"\\r\"`（对应 16 进制值为 0x0D） 做分行。 ```c #define SAMPLE_UART_NAME \"uart2\" /* 串口设备名称 */ static rt_device_t serial; /* 串口设备句柄 */ /* 查找串口设备 */ serial rt_device_find(SAMPLE_UART_NAME); /* 以中断接收及轮询发送模式打开串口设备 */ rt_device_open(serial, RT_DEVICE_FLAG_INT_RX); ``` ### 控制 ```c rt_err_t rt_device_control(rt_device_t dev, rt_uint8_t cmd, void* arg); ``` > dev 设备句柄 > > cmd 命令控制字，可取值：RT_DEVICE_CTRL_CONFIG > arg 控制的参数，可取类型： struct serial_configure > **返回** RT_EOK函数执行成功, RT_ENOSYS执行失败，dev 为空 ```c struct serial_configure { rt_uint32_t baud_rate; /* 波特率 */ rt_uint32_t data_bits :4; /* 数据位 */ rt_uint32_t stop_bits :2; /* 停止位 */ rt_uint32_t parity :2; /* 奇偶校验位 */ rt_uint32_t bit_order :1; /* 高位在前或者低位在前 */ rt_uint32_t invert :1; /* 模式 */ rt_uint32_t bufsz :16; /* 接收数据缓冲区大小 */ rt_uint32_t reserved :4; /* 保留位 */ }; ``` > ```c > /* 波特率可取值 */ > #define BAUD_RATE_2400 2400 > #define BAUD_RATE_4800 4800 > #define BAUD_RATE_9600 9600 > #define BAUD_RATE_19200 19200 > #define BAUD_RATE_38400 38400 > #define BAUD_RATE_57600 57600 > #define BAUD_RATE_115200 115200 > #define BAUD_RATE_230400 230400 > #define BAUD_RATE_460800 460800 > #define BAUD_RATE_921600 921600 > #define BAUD_RATE_2000000 2000000 > #define BAUD_RATE_3000000 3000000 > /* 数据位可取值 */ > #define DATA_BITS_5 5 > #define DATA_BITS_6 6 > #define DATA_BITS_7 7 > #define DATA_BITS_8 8 > #define DATA_BITS_9 9 > /* 停止位可取值 */ > #define STOP_BITS_1 0 > #define STOP_BITS_2 1 > #define STOP_BITS_3 2 > #define STOP_BITS_4 3 > /* 极性位可取值 */ > #define PARITY_NONE 0 > #define PARITY_ODD 1 > #define PARITY_EVEN 2 > /* 高低位顺序可取值 */ > #define BIT_ORDER_LSB 0 > #define BIT_ORDER_MSB 1 > /* 模式可取值 */ > #define NRZ_NORMAL 0 /* normal mode */ > #define NRZ_INVERTED 1 /* inverted mode */ > /* 接收数据缓冲区默认大小 */ > #define RT_SERIAL_RB_BUFSZ 64 > ``` > > 接收缓冲区：当串口使用中断接收模式打开时，串口驱动框架会根据 RT_SERIAL_RB_BUFSZ 大小开辟一块缓冲区用于保存接收到的数据，底层驱动接收到一个数据,都会在中断服务程序里面将数据放入缓冲区。 RT Thread 提供的默认串口配置如下，即 RT Thread 系统中默认每个串口设备都使用如下配置： ```c #define RT_SERIAL_CONFIG_DEFAULT \\ { \\ BAUD_RATE_115200, /* 115200 bits/s */ \\ DATA_BITS_8, /* 8 databits */ \\ STOP_BITS_1, /* 1 stopbit */ \\ PARITY_NONE, /* No parity */ \\ BIT_ORDER_LSB, /* LSB first sent */ \\ NRZ_NORMAL, /* Normal mode */ \\ RT_SERIAL_RB_BUFSZ, /* Buffer size */ \\ 0 \\ } ``` > 在修改缓冲区大小时请注意，缓冲区大小无法动态改变，只有在 open 设备之前可以配置。open 设备之后，缓冲区大小不可再进行更改。但除缓冲区之外的其他参数，在 open 设备前 / 后，均可进行更改。 ### 发送数据 ```c rt_size_t rt_device_write(rt_device_t dev, rt_off_t pos, const void* buffer, rt_size_t size); ``` > **参数** **描述** > > dev 设备句柄 > pos 写入数据偏移量，此参数串口设备未使用 > buffer 内存缓冲区指针，放置要写入的数据 > size 写入数据的大小 > **返回** 写入数据的实际大小, 0需要读取当前线程的 errno 来判断错误状态 ### 发送的回调函数 ```c rt_err_t rt_device_set_tx_complete(rt_device_t dev, rt_err_t (*tx_done)(rt_device_t dev,void *buffer)); ``` > 回调函数由调用者提供，当硬件设备发送完数据时，由设备驱动程序回调这个函数并把发送完成的数据块地址 buffer 作为参数传递给上层应用。 ### 接收回调函数 ```c rt_err_t rt_device_set_rx_indicate(rt_device_t dev, rt_err_t (*rx_ind)(rt_device_t dev,rt_size_t size)); ``` > 若串口以中断接收模式打开，当串口接收到一个数据产生中断时，就会调用回调函数，并且会把此时缓冲区的数据大小放在 size 参数里，把串口设备句柄放在 dev 参数里供调用者获取。 > > 串口以 DMA 接收模式打开，当 DMA 完成一批数据的接收后会调用此回调函数。 ### 接收数据 ```c rt_size_t rt_device_read(rt_device_t dev, rt_off_t pos, void* buffer, rt_size_t size); ``` **参数** **描述** dev 设备句柄 pos 读取数据偏移量，此参数串口设备未使用 buffer 缓冲区指针，读取的数据将会被保存在缓冲区中 size 读取数据的大小 **返回** 读到数据的实际大小, 0: 需要读取当前线程的 errno 来判断错误状态 > ```c > static rt_device_t serial; /* 串口设备句柄 */ > static struct rt_semaphore rx_sem; /* 用于接收消息的信号量 */ > > /* 接收数据的线程 */ > static void serial_thread_entry(void *parameter) > { > char ch; > > while (1) > { > /* 从串口读取一个字节的数据，没有读取到则等待接收信号量 */ > while (rt_device_read(serial, 1, &ch, 1) ! 1) > { > /* 阻塞等待接收信号量，等到信号量后再次读取数据 */ > rt_sem_take(&rx_sem, RT_WAITING_FOREVER); > } > /* 读取到的数据通过串口错位输出 */ > ch ch + 1; > rt_device_write(serial, 0, &ch, 1); > } > } > ``` ### 关闭 ```c rt_err_t rt_device_close(rt_device_t dev); ``` ## 实际使用 ### 使用中断的模式 ![串口中断接收及轮询发送序列图](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401282052189.png) 1. 在board.h文件里面 ```c /* UART CONFIG BEGIN */ /** After configuring corresponding UART or UART DMA, you can use it. * * STEP 1, define macro define related to the serial port opening based on the serial port number * such as #define BSP_USING_UART1 * * STEP 2, according to the corresponding pin of serial port, define the related serial port information macro * such as #define BSP_UART1_TX_PIN \"PA9\" * #define BSP_UART1_RX_PIN \"PA10\" * * STEP 3, if you want using SERIAL DMA, you must open it in the RT Thread Settings. * RT Thread Setting > Components > Device Drivers > Serial Device Drivers > Enable Serial DMA Mode * * STEP 4, according to serial port number to define serial port tx/rx DMA function in the board.h file * such as #define BSP_UART1_RX_USING_DMA * */ #define BSP_USING_UART1 #define BSP_UART1_TX_PIN \"PA9\" #define BSP_UART1_RX_PIN \"PA10\" #define BSP_USING_UART2 #define BSP_UART1_TX_PIN \"PA2\" #define BSP_UART1_RX_PIN \"PA3\" ``` ![image 20240128211934937](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401282119042.png) > 这个是老师的失误, 不需要, 需要的头文件rt_device.h ```c #include <rtthread.h> #define DBG_TAG \"main\" #define DBG_LVL DBG_LOG #include <rtdbg.h> #include <rtdevice.h> rt_device_t u2_dev; rt_sem_t u2_sem; rt_thread_t u2_thread; rt_err_t rx_callback(rt_device_t dev, rt_size_t size) { //一个回调函数, 主要是进行一个解锁 rt_sem_release(u2_sem); return RT_EOK; } void u2_deal(void *parameter){ int8_t ch; while(1){ //进行读取, 有数据的话进行回显, 不然进入阻塞 while(rt_device_read(u2_dev, 1, &ch, 1) ! 1){ rt_sem_take(u2_sem, RT_WAITING_FOREVER); } rt_device_write(u2_dev, 1, &ch, 1); } } int main(void) { rt_err_t ret; //使用默认的配置 struct serial_configure u1_config RT_SERIAL_CONFIG_DEFAULT;; //初始化一个信号量, 以及一个处理线程 u2_sem rt_sem_create(\"u2_sem\", 0, RT_IPC_FLAG_FIFO); u2_thread rt_thread_create(\"u2_deal\", u2_deal, RT_NULL, 512, 20, 20); //开始运行这一个线程 rt_thread_startup(u2_thread); //寻找使用的USART设备 u2_dev rt_device_find(\"uart2\"); if(u2_dev RT_NULL) { LOG_E(\"rt_device_find fail...\\n\"); return EINVAL; } //配置一下模式 rt_device_control(u2_dev, RT_DEVICE_CTRL_CONFIG, (void *)&u1_config); //设置一个回调函数 rt_device_set_rx_indicate(u2_dev, rx_callback); //打开一个USART用的是中断的接收的模式 ret rt_device_open(u2_dev, RT_DEVICE_OFLAG_RDWR RT_DEVICE_FLAG_INT_RX); if(ret<0) { LOG_E(\"rt_device_open fail...\\n\"); return ret; } rt_device_write(u2_dev, 0, \"Uart1 config ...\\n\", rt_strlen(\"Uart1 config ...\\n\")); return 0; } ``` ### 使用DMA的模式 ```c /* * STEP 3, if you want using SERIAL DMA, you must open it in the RT Thread Settings. * RT Thread Setting > Components > Device Drivers > Serial Device Drivers > Enable Serial DMA Mode * * STEP 4, according to serial port number to define serial port tx/rx DMA function in the board.h file * such as #define BSP_UART1_RX_USING_DMA * */ ``` ![image 20240129205149106](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401292051223.png) > 之后直接关闭, 然后保存就可以了 2. 定义一个宏定义 ![image 20240129210417498](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401292104527.png)"},"/note/嵌入式/第三方移植/RT-Thread/2024-2-7-18内存管理.html":{"title":"RT-Thread内存管理","content":" layout: post title: \"RT Thread内存管理\" date: 2024 2 5 15:39:08 +0800 tags: RT Thread # RT Thread内存管理 RT Thread使用两种方法进行内存管理, 动态内存堆管理以及静态内存池管理 ## 特点 RTOS对于时间的要求非常高 1. 分配内存的时间必须是确定的。实时系统必须要保证内存块的分配过程在可预测的确定时间内完成，否则实时任务对外部事件的响应也将变得不可确定。 2. 对于需要长时间使用不能重启的嵌入式系统来说不能出现内存的碎片化 3. 使用的时候需要高效, 因为嵌入式的内存一般都不大 RT Thread内存堆管理又根据具体内存设备提供了不同的内存分配管理算法 + 小内存块的分配管理（小内存管理算法） + 大内存块的分配管理（slab管理算法） + 多内存堆的分配情况（memheap管理算法） ## 内存堆管理 用于管理一段连续的内存空间 RT Thread将“ZI段(未初始化的全局变量)结尾处”到内存尾部的空间用作内存堆 ![image 20240207204055281](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402072040478.png) 内存堆可以在当前资源满足的情况下，根据用户的需求分配任意大小的内存块。而当用户不需要再使用这些内存块时，又可以释放回堆中供其他应用分配使用 ### 小内存管理算法 是一个简单的内存分配算法。初始时，它是一块大的内存。当需要分配内存块时，将从这个大的内存块上分割出相匹配的内存块，然后把分割出来的空闲内存块还回给堆管理系统中。每个内存块都包含一个管理用的数据头，通过这个头把使用块与空闲块用双向链表的方式链接起来 ![image 20240207204439515](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402072044709.png) > magic：变数（或称为幻数），它会被初始化成0x1ea0（即英文单词heap），用于标记这个内存块是一个内存管理用的内存数据块；变数不仅仅用于标识这个数据块是一个内存管理用的内存数据块，实质也是一个内存保护字：如果这个区域被改写，那么也就意味着这块内存块被非法改写 > > used：指示出当前内存块是否已经分配。 在使用的时候会遍历这一个链表, 直到找到第一个必须要的内存大的块, 然后进行分割 在每一次分割的时候都会使用12字节作为信息记录的节点, 释放的时候看一看前后是不是可以相连, 是的话进行连接 ### slab管理算法 slab分配器会根据对象的大小分成多个区（zone），也可以看成每类对象有一个内存池 ![image 20240207205000301](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402072050346.png) 一个zone的大小在32K到128K字节之间，分配器会在堆初始化时根据堆的大小自动调整。系统中的zone最多包括72种对象，一次最大能够分配16K的内存空间，如果超出了16K那么直接从页分配器中分配。 每个zone上分配的内存块大小是固定的，能够分配相同大小内存块的zone会链接在一个链表中，而72种对象的zone链表则放在一个数组（zone_array[]）中统一管理 主要的操作: 1. 内存分配 在分配的时候首先会从链表里面找, 没有找到的话则向页分配器分配一个新的zone，然后从zone中返回第一个空闲内存块。 如果链表非空，则这个zone链表中的第一个zone节点必然有空闲块存在 如果分配完成后，zone中所有空闲内存块都使用完毕，那么分配器需要把这个zone节点从链表中删除 2. 内存释放 分配器需要找到内存块所在的zone节点，然后把内存块链接到zone的空闲内存块链表中 如果此时zone的空闲链表指示出zone的所有内存块都已经释放，即zone是完全空闲的，那么当zone链表中全空闲zone达到一定数目后，系统就会把这个全空闲的zone释放到页面分配器中去 ### memheap管理算法 适用于系统含有多个地址可不连续的内存堆 用户只需要在系统初始化时将多个所需的memheap初始化，并开启memheap功能就可以很方便地把多个memheap（地址可不连续）粘合起来用于系统的heap分配。 开启memheap之后原来的heap功能将被关闭，两者只可以通过打开或关闭RT_USING_MEMHEAP_AS_HEAP来选择其一 ![image 20240207205604871](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402072056922.png) ## 实际使用 ### 初始化 ```c ```"},"/note/嵌入式/第三方移植/RT-Thread/2024-1-30-13I2C.html":{"title":"I2C","content":" layout: post title: \"I2C\" date: 2024 1 28 15:39:08 +0800 tags: RT Thread # I2C [I2C总线设备 (rt thread.org)](https://www.rt thread.org/document/site/#/rt thread version/rt thread standard/programming manual/device/i2c/i2c) 一般情况下 MCU 的 I2C 器件都是作为主机和从机通讯，在 RT Thread 中将 I2C 主机虚拟为 I2C总线设备，I2C 从机通过 I2C 设备接口和 I2C 总线通讯，相关接口如下所示： **函数** **描述** rt_device_find() 根据 I2C 总线设备名称查找设备获取设备句柄 rt_i2c_transfer() 传输数据 ## 使用 ### 获取 ```c rt_device_t rt_device_find(const char* name); ``` > **参数** **描述** > > name I2C 总线设备名称 > **返回** —— > 设备句柄 查找到对应设备将返回相应的设备句柄 > RT_NULL 没有找到相应的设备对象 一般情况下，注册到系统的 I2C 设备名称为 i2c0 ，i2c1 ### 数据传输 ```c rt_size_t rt_i2c_transfer(struct rt_i2c_bus_device *bus, struct rt_i2c_msg msgs[], rt_uint32_t num); ``` > **参数** **描述** > > bus I2C 总线设备句柄 > msgs[] 待传输的消息数组指针 > num 消息数组的元素个数 > **返回** —— > 消息数组的元素个数 成功 > 错误码 失败 > > ```c > struct rt_i2c_msg > { > rt_uint16_t addr; /* 从机地址 */ > rt_uint16_t flags; /* 读1、写0标志等 */ > rt_uint16_t len; /* 读写数据字节数 */ > rt_uint8_t *buf; /* 读写数据缓冲区指针　*/ > } > ``` > > > 从机地址 addr：支持 7 位和 10 位二进制地址 > > > > ```c > > #define RT_I2C_WR 0x0000 /* 写标志，不可以和读标志进行“”操作 */ > > #define RT_I2C_RD (1u << 0) /* 读标志，不可以和写标志进行“”操作 */ > > #define RT_I2C_ADDR_10BIT (1u << 2) /* 10 位地址模式 */ > > #define RT_I2C_NO_START (1u << 4) /* 无开始条件 */ > > #define RT_I2C_IGNORE_NACK (1u << 5) /* 忽视 NACK */ > > #define RT_I2C_NO_READ_ACK (1u << 6) /* 读的时候不发送 ACK */ > > #define RT_I2C_NO_STOP (1u << 7) /* 不发送结束位 */ > > ``` > > > > 这是flag可以使用的标志 ### 封装使用 ```c rt_size_t rt_i2c_master_send(struct rt_i2c_bus_device *bus, rt_uint16_t addr, rt_uint16_t flags, const rt_uint8_t *buf, rt_uint32_t count); ``` > bus I2C 总线设备句柄 > > addr I2C 从设备地址 > flags 标志位，可为上文提到的除 `RT_I2C_WR` `RT_I2C_RD`之外的其他标志位，可以进行 “\\” 操作 > buf 待数据数据缓冲区 > count 待发送数据大小（单位：字节） > **返回** —— > 消息数组的元素个数 成功 > 错误码 失败 ```c rt_size_t rt_i2c_master_recv(struct rt_i2c_bus_device *bus, rt_uint16_t addr, rt_uint16_t flags, rt_uint8_t *buf, rt_uint32_t count); ``` > **参数** **描述** > > bus I2C 总线设备句柄 > addr I2C 从设备地址 > flags 标志位，可为上文提到的除 `RT_I2C_WR` `RT_I2C_RD`之外的其他标志位，可以进行 “\\” 操作 > buf 数据缓冲区 > count 缓冲区大小（单位：字节，要大于等于最大接收到的数据长度） > **返回** —— > 消息数组的元素个数 成功 > 错误码 失败 ## 实际实现 ```c /** if you want to use i2c bus(soft simulate) you can use the following instructions. * * STEP 1, open i2c driver framework(soft simulate) support in the RT Thread Settings file * * STEP 2, define macro related to the i2c bus * such as #define BSP_USING_I2C1 * * STEP 3, according to the corresponding pin of i2c port, modify the related i2c port and pin information * such as #define BSP_I2C1_SCL_PIN GET_PIN(port, pin) > GET_PIN(C, 11) * #define BSP_I2C1_SDA_PIN GET_PIN(port, pin) > GET_PIN(C, 12) */ ```"},"/note/嵌入式/第三方移植/RT-Thread/2024-1-26-04内核框架.html":{"title":"RT-Thread内核框架","content":" layout: post title: \"RT Thread内核框架\" date: 2024 1 26 15:39:08 +0800 tags: RT Thread # RT Thread内核框架 ![image 20240126205109979](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401262051027.png) > 内核库是为了保证内核能够独立运行的一套小型的类似 C 库的函数实现子集。 ## 线程调度 RT Thread 操作系统中最小的调度单位，线程调度算法是基于优先级的全抢占式多线程调度算法，即在系统中除了中断处理函数、调度器上锁部分的代码和禁止中断的代码是不可抢占的之外，系统的其他部分都是可以抢占的 支持 256 个线程优先级（也可通过配置文件更改为最大支持 32 个或 8 个线程优先级，针对 STM32 默认配置是 32 个线程优先级） 0 优先级代表最高优先级，最低优先级留给空闲线程使用； ## 时钟管理 RT Thread 的时钟管理以时钟节拍为基础，时钟节拍是 RT Thread 操作系统中最小的时钟单位。 可以设置单次触发, 或重复的 根据超时函数执行时所处的上下文环境，RT Thread 的定时器可以设置为 HARD_TIMER 模式或者 SOFT_TIMER 模式 ## 线程间同步 RT Thread 采用信号量、互斥量与事件集实现线程间同步。线程通过对信号量、互斥量的获取与释放进行同步；互斥量采用优先级继承的方式解决了实时系统常见的优先级翻转问题。 线程同步机制支持线程按优先级等待或按先进先出方式获取信号量或互斥量。线程通过对事件的发送与接收进行同步；事件集支持多事件的 “或触发” 和“与触发”，适合于线程等待多个事件的情况。 ## 线程间通信 支持邮箱和消息队列等通信机制。邮箱中一封邮件的长度固定为 4 字节大小；消息队列能够接收不固定长度的消息，并把消息缓存在自己的内存空间中。 邮箱效率较消息队列更为高效。邮箱和消息队列的发送动作可安全用于中断服务例程中。通信机制支持线程按优先级等待或按先进先出方式获取。 ## 内存管理 RT Thread 支持静态内存池管理及动态内存堆管理。 当静态内存池具有可用内存时，系统对内存块分配的时间将是恒定的；当静态内存池为空时，系统将申请内存块的线程挂起或阻塞掉 动态内存堆管理模块在系统资源不同的情况下，分别提供了面向小内存系统的内存管理算法及面向大内存系统的 SLAB 内存管理算法。 还有一种动态内存堆管理叫做 memheap，适用于系统含有多个地址可不连续的内存堆。使用 memheap 可以将多个内存堆 “粘贴” 在一起，让用户操作起来像是在操作一个内存堆。 ## I/O设备管理 RT Thread 将 PIN、I2C、SPI、USB、UART 等作为外设设备，统一通过设备注册完成。 实现了按名称访问的设备管理子系统，可按照统一的 API 界面访问硬件设备。在设备驱动接口上，根据嵌入式系统的特点，对不同的设备可以挂接相应的事件。 当设备事件触发时，由驱动程序通知给上层的应用程序。"},"/note/嵌入式/第三方移植/RT-Thread/2024-1-31-15线程管理(代码分析).html":{"title":"RT-Thread线程管理(代码分析01--用户API)","content":" layout: post title: \"RT Thread线程管理(代码分析01 用户API)\" date: 2024 1 31 15:39:08 +0800 tags: RT Thread # RT Thread线程管理(源代码分析01 用户API) ## 基础知识 在进行任务切换的时候, 会使用中断函数PendSV以及使用系统时钟Systick, 具体的可以看我的这些笔记, 或者Cotex M3权威指南 [Cotex M3系统异常管理机制 CSDN博客](https://blog.csdn.net/qq_61585528/article/details/135951882?csdn_share_tail {\"type\"%3A\"blog\"%2C\"rType\"%3A\"article\"%2C\"rId\"%3A\"135951882\"%2C\"source\"%3A\"qq_61585528\"}) [Cotex M3内核寄存器详解(寄存器 栈 中断向量表) CSDN博客](https://blog.csdn.net/qq_61585528/article/details/135952212?csdn_share_tail {\"type\"%3A\"blog\"%2C\"rType\"%3A\"article\"%2C\"rId\"%3A\"135952212\"%2C\"source\"%3A\"qq_61585528\"}) [Cotex M3汇编指令集(速查以及使用) CSDN博客](https://blog.csdn.net/qq_61585528/article/details/135952810?csdn_share_tail {\"type\"%3A\"blog\"%2C\"rType\"%3A\"article\"%2C\"rId\"%3A\"135952810\"%2C\"source\"%3A\"qq_61585528\"}) [Cotex M3中断处理的具体行为(状态保存以及恢复机制等) CSDN博客](https://blog.csdn.net/qq_61585528/article/details/135952094?csdn_share_tail {\"type\"%3A\"blog\"%2C\"rType\"%3A\"article\"%2C\"rId\"%3A\"135952094\"%2C\"source\"%3A\"qq_61585528\"}) [Cotex M3内核定时器Systick,电源管理,复位以及多处理器机制 CSDN博客](https://blog.csdn.net/qq_61585528/article/details/135952303?csdn_share_tail {\"type\"%3A\"blog\"%2C\"rType\"%3A\"article\"%2C\"rId\"%3A\"135952303\"%2C\"source\"%3A\"qq_61585528\"}) 为了保证返回以后可以继续执行, 需要保存当前线程的上下文存在栈中，当线程要恢复运行时，再从栈中读取上下文信息，进行恢复。 ![image 20240131140256134](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401311402302.png) ## 全局变量 ```c rt_list_t rt_thread_priority_table[RT_THREAD_PRIORITY_MAX];\t\t//记录各个优先级的任务的链表 rt_uint32_t rt_thread_ready_priority_group;\t\t\t\t\t //用一个32位的变量记录优先级 rt_list_t rt_thread_defunct;\t\t\t\t\t\t\t\t//记录需要空闲进程释放的进程链表 ``` ## 用户接口分析 ### 创建 ```c /** * This function will create a thread object and allocate thread object memory * and stack. * * @param name the name of thread, which shall be unique * @param entry the entry function of thread * @param parameter the parameter of thread enter function * @param stack_size the size of thread stack * @param priority the priority of thread * @param tick the time slice if there are same priority thread * * @return the created thread object */ rt_thread_t rt_thread_create(const char *name, void (*entry)(void *parameter), void *parameter, rt_uint32_t stack_size, rt_uint8_t priority, rt_uint32_t tick) { struct rt_thread *thread; void *stack_start; \t//这一个在对象管理里面分析过了, 主要是获取一个thread大小的内存以及保存对象的信息 thread (struct rt_thread *)rt_object_allocate(RT_Object_Class_Thread, name); if (thread RT_NULL) return RT_NULL; \t//获取一个栈大小的内存 stack_start (void *)RT_KERNEL_MALLOC(stack_size); if (stack_start RT_NULL) { /* allocate stack failure */ rt_object_delete((rt_object_t)thread); return RT_NULL; } \t//实现初始时候的管理结构体的信息, 以及栈的内容 _rt_thread_init(thread, name, entry, parameter, stack_start, stack_size, priority, tick); return thread; } RTM_EXPORT(rt_thread_create); ``` ```c //初始化一个线程 static rt_err_t _rt_thread_init(struct rt_thread *thread, const char *name, void (*entry)(void *parameter), void *parameter, void *stack_start, rt_uint32_t stack_size, rt_uint8_t priority, rt_uint32_t tick) { /* init thread list 记录信息 */ rt_list_init(&(thread >tlist)); thread >entry (void *)entry; thread >parameter parameter; /* stack init */ thread >stack_addr stack_start; thread >stack_size stack_size; /* init thread stack 把栈里面内存设置为'#' */ rt_memset(thread >stack_addr, '#', thread >stack_size); thread >sp (void *)rt_hw_stack_init(thread >entry, thread >parameter, (rt_uint8_t *)((char *)thread >stack_addr + thread >stack_size sizeof(rt_ubase_t)), (void *)rt_thread_exit); /* priority init */ RT_ASSERT(priority < RT_THREAD_PRIORITY_MAX); thread >init_priority priority; thread >current_priority priority; thread >number_mask 0; /* tick init 记录时间片大小 */ thread >init_tick tick; thread >remaining_tick tick; /* error and flags */ thread >error RT_EOK; thread >stat RT_THREAD_INIT; /* initialize cleanup function and user data */ thread >cleanup 0; thread >user_data 0; /* initialize thread timer 初始化一个时钟,未开启 */ rt_timer_init(&(thread >thread_timer), thread >name, rt_thread_timeout, thread, 0, RT_TIMER_FLAG_ONE_SHOT); RT_OBJECT_HOOK_CALL(rt_thread_inited_hook, (thread)); return RT_EOK; } ``` ```c //记录信息以及初始化栈 /** * This function will initialize thread stack * * @param tentry the entry of thread * @param parameter the parameter of entry * @param stack_addr the beginning stack address * @param texit the function will be called when thread exit * * @return stack address */ rt_uint8_t *rt_hw_stack_init(void *tentry, void *parameter, rt_uint8_t *stack_addr, void *texit) { struct stack_frame *stack_frame; rt_uint8_t *stk; unsigned long i; \t//则是计算一下对齐的堆栈的地址, 并且减去一个初始化结构体的大小, 用于存储起始的时候任务的寄存器信息 stk stack_addr + sizeof(rt_uint32_t); stk (rt_uint8_t *)RT_ALIGN_DOWN((rt_uint32_t)stk, 8); stk sizeof(struct stack_frame); \t//之后可是使用这个指针更直观的管理初始化栈里面的寄存器信息 stack_frame (struct stack_frame *)stk; /* init all register 使用这一个数字标记没有使用的内存 */ for (i 0; i < sizeof(struct stack_frame) / sizeof(rt_uint32_t); i ++) { ((rt_uint32_t *)stack_frame)[i] 0xdeadbeef; } stack_frame >exception_stack_frame.r0 (unsigned long)parameter; /* r0 : argument C语言会使用这一个寄存器传递信息 */ stack_frame >exception_stack_frame.r1 0; /* r1 */ stack_frame >exception_stack_frame.r2 0; /* r2 */ stack_frame >exception_stack_frame.r3 0; /* r3 */ stack_frame >exception_stack_frame.r12 0; /* r12 */ stack_frame >exception_stack_frame.lr (unsigned long)texit; /* lr 记录出口函数*/ stack_frame >exception_stack_frame.pc (unsigned long)tentry; /* entry point, pc 记录入口函数*/ stack_frame >exception_stack_frame.psr 0x01000000L; /* PSR */ /* return task's current stack address */ return stk; } ``` > ```c > //这一个是需要用户自己保存的信息 > struct stack_frame > { > /* r4 ~ r11 register */ > rt_uint32_t r4; > rt_uint32_t r5; > rt_uint32_t r6; > rt_uint32_t r7; > rt_uint32_t r8; > rt_uint32_t r9; > rt_uint32_t r10; > rt_uint32_t r11; > > struct exception_stack_frame exception_stack_frame; > }; > ``` > > ```c > //这一个是系统自动保存的寄存器信息 > struct exception_stack_frame > { > rt_uint32_t r0; > rt_uint32_t r1; > rt_uint32_t r2; > rt_uint32_t r3; > rt_uint32_t r12; > rt_uint32_t lr; > rt_uint32_t pc; > rt_uint32_t psr; > }; > ``` > > ![image 20240131152643254](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401311526308.png) > > > 可以实现这样的一个结果 ### 开启 ```c /** * This function will start a thread and put it to system ready queue * * @param thread the thread to be started * * @return the operation status, RT_EOK on OK, RT_ERROR on error */ rt_err_t rt_thread_startup(rt_thread_t thread) { /* set current priority to initialize priority */ thread >current_priority thread >init_priority; /* calculate priority attribute 使用一个32位的变量记录优先级*/ thread >number_mask 1L << thread >current_priority; \t//打印一条信息 RT_DEBUG_LOG(RT_DEBUG_THREAD, (\"startup a thread:%s with priority:%d\\n\", thread >name, thread >init_priority)); /* change thread stat 先设置为挂起 */ thread >stat RT_THREAD_SUSPEND; /* then resume it 使用这一个开启 */ rt_thread_resume(thread); if (rt_thread_self() ! RT_NULL) { /* do a scheduling 当前已经开启调度了 */ rt_schedule(); } return RT_EOK; } RTM_EXPORT(rt_thread_startup); ``` ### 挂起相关 ```c /**挂起一个线程 * This function will suspend the specified thread. * * @param thread the thread to be suspended * * @return the operation status, RT_EOK on OK, RT_ERROR on error * * @note if suspend self thread, after this function call, the * rt_schedule() must be invoked. */ rt_err_t rt_thread_suspend(rt_thread_t thread) { register rt_base_t stat; register rt_base_t temp; \t//获取这一个线程的状态 stat thread >stat & RT_THREAD_STAT_MASK; if ((stat ! RT_THREAD_READY) && (stat ! RT_THREAD_RUNNING)) { //这一个线程以及不是运行的线程了 RT_DEBUG_LOG(RT_DEBUG_THREAD, (\"thread suspend: thread disorder, 0x%2x\\n\", thread >stat)); return RT_ERROR; } /* disable interrupt 进入临界区 */ temp rt_hw_interrupt_disable(); if (stat RT_THREAD_RUNNING)//这一个线程正在运行 { /* not suspend running status thread on other core 这是一个多核的处理 */ RT_ASSERT(thread rt_thread_self()); } /* change thread stat */ rt_schedule_remove_thread(thread); //从链表里面移除以及更新全局变量 thread >stat RT_THREAD_SUSPEND (thread >stat & ~RT_THREAD_STAT_MASK); //更新状态 /* stop thread timer anyway 停止这一个线程的时钟 */ rt_timer_stop(&(thread >thread_timer)); /* enable interrupt */ rt_hw_interrupt_enable(temp); RT_OBJECT_HOOK_CALL(rt_thread_suspend_hook, (thread)); return RT_EOK; } RTM_EXPORT(rt_thread_suspend); ``` ```c /* * This function will remove a thread from system ready queue. * * @param thread the thread to be removed * * @note Please do not invoke this function in user application. */ void rt_schedule_remove_thread(struct rt_thread *thread) { register rt_base_t level; RT_ASSERT(thread ! RT_NULL); /* disable interrupt */ level rt_hw_interrupt_disable(); /* remove thread from ready list 把这个任务从对应优先级链表里面移除 */ rt_list_remove(&(thread >tlist)); if (rt_list_isempty(&(rt_thread_priority_table[thread >current_priority]))) { //这个优先级没有任务了, 更新一下记录 rt_thread_ready_priority_group & ~thread >number_mask; } /* enable interrupt */ rt_hw_interrupt_enable(level); } ``` ### 恢复一个线程 ```c /** * This function will resume a thread and put it to system ready queue. * * @param thread the thread to be resumed * * @return the operation status, RT_EOK on OK, RT_ERROR on error */ rt_err_t rt_thread_resume(rt_thread_t thread) { register rt_base_t temp; if ((thread >stat & RT_THREAD_STAT_MASK) ! RT_THREAD_SUSPEND) { \t//这一个线程不是挂起的线程 RT_DEBUG_LOG(RT_DEBUG_THREAD, (\"thread resume: thread disorder, %d\\n\", thread >stat)); return RT_ERROR; } /* disable interrupt 临界区 */ temp rt_hw_interrupt_disable(); /* remove from suspend list 这里我没有看到有加入suspend链表的代码 */ rt_list_remove(&(thread >tlist)); rt_timer_stop(&thread >thread_timer); /* enable interrupt */ rt_hw_interrupt_enable(temp); /* insert to schedule ready list */ rt_schedule_insert_thread(thread); RT_OBJECT_HOOK_CALL(rt_thread_resume_hook, (thread)); return RT_EOK; } RTM_EXPORT(rt_thread_resume); ``` ```c void rt_schedule_insert_thread(struct rt_thread *thread) { register rt_base_t temp; RT_ASSERT(thread ! RT_NULL); /* disable interrupt */ temp rt_hw_interrupt_disable(); /* it's current thread, it should be RUNNING thread */ if (thread rt_current_thread) { //这个在操作的线程正在运行, 不需要改变链表, 以防通过自己插入自己, 更新链表起到一直执行的效果 thread >stat RT_THREAD_RUNNING (thread >stat & ~RT_THREAD_STAT_MASK); goto __exit; } /* READY thread, insert to ready queue 更新状态*/ thread >stat RT_THREAD_READY (thread >stat & ~RT_THREAD_STAT_MASK); /* insert thread to ready list 插入在运行的链表, 按照线程的优先级, 放在最前面 */ rt_list_insert_before(&(rt_thread_priority_table[thread >current_priority]), &(thread >tlist)); /* set priority mask 更新全局的最高优先级 */ rt_thread_ready_priority_group thread >number_mask; __exit: /* enable interrupt */ rt_hw_interrupt_enable(temp); } ``` ### 延时 ```c /** * This function will let current thread sleep for some ticks. * * @param tick the sleep ticks * * @return RT_EOK */ rt_err_t rt_thread_sleep(rt_tick_t tick) { register rt_base_t temp; struct rt_thread *thread; /* set to current thread 获取当前的进程 */ thread rt_thread_self(); /* disable interrupt */ temp rt_hw_interrupt_disable(); /* suspend thread 挂起 */ rt_thread_suspend(thread); /* reset the timeout of thread timer and start it 启动线程时钟用于延时 */ rt_timer_control(&(thread >thread_timer), RT_TIMER_CTRL_SET_TIME, &tick); rt_timer_start(&(thread >thread_timer)); /* enable interrupt */ rt_hw_interrupt_enable(temp); rt_schedule();//切换任务 /* clear error number of this thread to RT_EOK */ if (thread >error RT_ETIMEOUT) thread >error RT_EOK; return RT_EOK; } ``` ```c /**任务的超时函数 * This function is the timeout function for thread, normally which is invoked * when thread is timeout to wait some resource. * * @param parameter the parameter of thread timeout function */ void rt_thread_timeout(void *parameter) { struct rt_thread *thread; thread (struct rt_thread *)parameter; /* set error number */ thread >error RT_ETIMEOUT; /* remove from suspend list */ rt_list_remove(&(thread >tlist)); /* insert to schedule ready list 恢复运行 */ rt_schedule_insert_thread(thread); /* do schedule */ rt_schedule(); } ``` ```c /** * This function will let current thread delay for some milliseconds. * * @param tick the delay time * * @return RT_EOK */ rt_err_t rt_thread_mdelay(rt_int32_t ms) { rt_tick_t tick; \t//时钟转换 tick rt_tick_from_millisecond(ms); return rt_thread_sleep(tick); } ```"},"/note/嵌入式/第三方移植/RT-Thread/2024-1-26-00问题处理.html":{"title":"问题处理","content":" layout: post title: \"问题处理\" date: 2024 1 26 15:39:08 +0800 tags: RT Thread ## 问题处理 ## 问题 1. 野火的开发板在使用RTThread Studio的时候下载不正常 2. 下载以后串口乱码 3. 使用SourceCRT, XShell不可以运行 3. 头文件 3. rt_printf不可以打印浮点数 ## 解决 ### 下载 在使用Keil的时候会有一个设置 ![image 20240127141830061](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401271418091.png) > 这个的意思大概是如果SWD功能被关掉的话也可以下载 ![image 20240127142109499](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401271421542.png) RTThread里面不可以选择, 所以在烧录之前按住Reset按钮, 点击下载, 松开就可以下载了 ### 新项目串口乱码 ![image 20240127142323091](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401271423129.png) 这个默认配置下载的话会出现串口频率不对 ![image 20240127142449828](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401271424865.png) 这时候可以使用CubeMX进行配置 ![image 20240127142535701](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401271425747.png) ![image 20240127142611980](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401271426009.png) ![image 20240127142623462](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401271426490.png) ![image 20240127142642258](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401271426299.png) ![image 20240127142716071](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401271427103.png) ![image 20240127142732394](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401271427432.png) ![image 20240127142754008](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401271427039.png) ![image 20240127142804390](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401271428413.png) ![image 20240127142845601](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401271428632.png) > 更新一下 ![image 20240127142926611](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401271429635.png) > 可以编译 ![image 20240127143025237](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401271430260.png) > 方便调试 ![image 20240127143114873](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401271431909.png) ### 不可以运行 [野火霸道STM32F103 (rt thread.org)](https://www.rt thread.org/document/site/#/rt thread version/rt thread standard/tutorial/quick start/stm32f103 fire arbitrary/quick start) 这一篇文章里面提到了这是下载电路的问题, 可以先复位, 再打开连接 ![image 20240127143430237](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401271434269.png) ### 头文件 ![image 20240128211934937](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401282119042.png) ### 打印浮点数 1. 直接使用软件包 ![image 20240130133229894](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401301332040.png) ![image 20240130133309328](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401301333389.png) > **不要开代理!!!!!** > > ![image 20240130142119589](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401301421627.png) 2. 自己转换一下 ```c rt_kprintf(\"data %d, real value %d.%d \\n\", adc_data, adc_data*33/40960, (adc_data*33*1000/4096)%10000); ```"},"/note/嵌入式/第三方移植/RT-Thread/2024-1-29-12ADC.html":{"title":"ADC","content":" layout: post title: \"ADC\" date: 2024 1 28 15:39:08 +0800 tags: RT Thread # ADC rt_thread已经实现了ADC的驱动, 可以直接使用接口进行使用 **函数** **描述** rt_device_find() 根据 ADC 设备名称查找设备获取设备句柄 rt_adc_enable() 使能 ADC 设备 rt_adc_read() 读取 ADC 设备数据 rt_adc_disable() 关闭 ADC 设备 > 一般情况下，注册到系统的 ADC 设备名称为 adc0，adc1 ## 接口 ## 获取 ```c rt_err_t rt_adc_enable(rt_adc_device_t dev, rt_uint32_t channel); ``` > **参数** **描述** > > dev ADC 设备句柄 > channel ADC 通道 > **返回** —— > RT_EOK 成功 > RT_ENOSYS 失败，设备操作方法为空 > 其他错误码 失败 ### 使能 ```c rt_err_t rt_adc_enable(rt_adc_device_t dev, rt_uint32_t channel); ``` > **参数** **描述** > > dev ADC 设备句柄 > channel ADC 通道 > **返回** —— > RT_EOK 成功 > RT_ENOSYS 失败，设备操作方法为空 > 其他错误码 失败 ### 读取 ```c rt_uint32_t rt_adc_read(rt_adc_device_t dev, rt_uint32_t channel); ``` > > > **参数** **描述** > dev ADC 设备句柄 > channel ADC 通道 > **返回** —— > 读取的数值 ### 关闭通道 ```c rt_err_t rt_adc_disable(rt_adc_device_t dev, rt_uint32_t channel); ``` > **参数** **描述** > > dev ADC 设备句柄 > channel ADC 通道 > **返回** —— > RT_EOK 成功 > RT_ENOSYS 失败，设备操作方法为空 > 其他错误码 失败 ## Finsh命令 在使用设备前，需要先查找设备是否存在，可以使用命令 `adc probe` 后面跟注册的 ADC 设备的名称。 ```bash msh >adc probe adc1 probe adc1 success ``` 可以使用命令进行使能 ```bash msh >adc enable 5 adc1 channel 5 enables success ``` 使用命令进行读取 ```c msh >adc read 5 adc1 channel 5 read value is 0x00000FFF msh > ``` 关闭 ```bash msh >adc disable 5 adc1 channel 5 disable success msh > ``` ## 实际的使用 ```c /** if you want to use adc you can use the following instructions. * * STEP 1, open adc driver framework support in the RT Thread Settings file * * STEP 2, define macro related to the adc * such as #define BSP_USING_ADC1 * * STEP 3, copy your adc init function from stm32xxxx_hal_msp.c generated by stm32cubemx to the end of board.c file * such as void HAL_ADC_MspInit(ADC_HandleTypeDef* hadc) * * STEP 4, modify your stm32xxxx_hal_config.h file to support adc peripherals. define macro related to the peripherals * such as #define HAL_ADC_MODULE_ENABLED * */ /*#define BSP_USING_ADC1*/ /*#define BSP_USING_ADC2*/ /*#define BSP_USING_ADC3*/ ``` ![image 20240129221820103](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401292218160.png) ![image 20240129223630892](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401292236962.png) <img src \"https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401301427170.png\"/> ![image 20240129223616174](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401292236225.png) ### 使用的代码 ```c #include <rtthread.h> #define DBG_TAG \"main\" #define DBG_LVL DBG_LOG #include <rtdbg.h> #include <rtdevice.h> rt_adc_device_t dev; rt_thread_t adc_thread; void adc_deal(void *parameter) { rt_uint32_t adc_data; while(1){ adc_data rt_adc_read(dev, 11); rt_kprintf(\"data %d, real value %f \\n\", adc_data, adc_data*3.3/4096); rt_thread_mdelay(2000); } } int main(void) { rt_err_t ret; dev (rt_adc_device_t)rt_device_find(\"adc1\"); if(dev RT_NULL){ LOG_E(\"adc_find err...\\n\"); return EINVAL; } ret rt_adc_enable(dev, 11); if(ret < 0) { LOG_E(\"adc_open err..\\n\"); return ret; } adc_thread rt_thread_create(\"adc_thread\", adc_deal, RT_NULL, 1024, 18, 20); rt_thread_startup(adc_thread); return 0; } ``` ### 串口 ![image 20240130143247962](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401301432001.png)"},"/note/嵌入式/第三方移植/物联网/2023-11-25-03移植到stm32.html":{"title":"移植到stm32","content":" layout: post title: \"移植到stm32\" date: 2023 11 25 15:39:08 +0800 tags: 物联网 stm32 # 移植到stm32 根据作者给出的示例里面的代码之间的关系, 复制以下的文件夹 + common 通用的头文件 + mqttclient + network + platform 不同的平台 + + FreeRTOS + mqtt 格式相关的函数 ![image 20231125223404662](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311252234713.png) ## 出现的问题 + 找不到头文件 1. 添加对应路径 2. platform下面的文件有的头文件不存在, 直接删除 ```c #if 0 #include \"lwip/opt.h\" #include \"lwip/sys.h\" #include \"lwip/api.h\" #include <lwip/sockets.h> #include \"lwip/netdb.h\" #endif ``` 之后在使用的时候不使用lwip的方式 > LWIP (Lightweight IP)是一个轻量级的开源TCP/IP协议栈，专为小型系统和嵌入式系统设计，可以运行于各种操作系统和硬件平台上。LWIP提供了TCP、UDP、IP、ICMP、DNS、DHCP、SNTP、PPP等协议的实现，可以方便地用于网络通信应用，如互联网应用、物联网应用等。LWIP还支持多种操作系统和编译器，比如FreeRTOS、Linux、Windows、Keil、IAR等。 + 没有对应的类型定义 在平台的头文件里面添加一个 ```c #define size_t unsigned int\t//这一个添加以后会报一个重复包含的错误 #define socklen_t unsigned int /* 100ask add */ ``` > 这个是FreeRTOS里面的, 需要添加头文件 ![image 20231126201125223](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311262011259.png) > 在文件nettpye_tcp.c里面使用了这两个头文件, 在后面的文件里面引用了stdio.h文件, 里面有size_t, 但是前面的nettpye_tcp.h文件里面包含的文件 > > ![image 20231126201323289](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311262013313.png) > > 在文件platform_net_socket.h文件里面使用到了 > > **解决方法: **对调头文件顺序 + platform_net_socket文件里面的函数实现不正确 改为空函数 + 少括号 ```c #define configTICK_RATE_HZ 1000 //((TickType_t)1000) ``` ![image 20231126194846824](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311261948911.png) > 可以在这里面添加![image 20231126195225514](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311261952543.png) > > 之后会有更多的错误, 暂时不添加 + 不使用安全相关 在`mqtt_defconfig.h`文件里面添加一个宏定义 ```c #define MQTT_NETWORK_TYPE_NO_TLS ``` + 报错匿名结构体 ![image 20231126202215811](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311262022843.png) keil使用的编译器arm_cc不支持gcc的语法 ```c def_class(mqtt_connack_data_t, private_member( uint8_t rc; uint8_t session_present; ) ) #elif defined(__PLOOC_CLASS_IMPLEMENT__) defined(__PLOOC_CLASS_IMPLEMENT) //实际上使用的是这一个,跳转会跳转错误 # define private_member(...) PLOOC_VISIBLE(__VA_ARGS__) # define protected_member(...) PLOOC_VISIBLE(__VA_ARGS__) # define public_member(...) PLOOC_VISIBLE(__VA_ARGS__) # if defined(PLOOC_CFG_REMOVE_MEMORY_LAYOUT_BOUNDARY___USE_WITH_CAUTION___) # define PLOOC_VISIBLE(...) __VA_ARGS__ # else # define PLOOC_VISIBLE(...) \\ struct { \\ __VA_ARGS__ \\ }PLOOC_ALIGN(PLOOC_ALIGNOF_STRUCT(__VA_ARGS__)); //这里是实际上使用到的位置 # endif #define def_class(__name, ...) __def_class(__name, __VA_ARGS__) #define __def_class(__name, ...) \\ typedef struct __name __name; \\ struct __name { \\ __VA_ARGS__ \\ }; ``` 展开以后 ```c typedef struct mqtt_connack_data_t mqtt_connack_data_t; struct __name { ,private_member( uint8_t rc; uint8_t session_present; ) }; ``` > ![image 20231126202931235](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311262029288.png) **另外的修改方式: ** ```c #define PLOOC_CFG_REMOVE_MEMORY_LAYOUT_BOUNDARY___USE_WITH_CAUTION___ ``` 使用另一种方式进行展开 > PLOOC_CFG_REMOVE_MEMORY_LAYOUT_BOUNDARY_\\_\\_USE\\_WITH_CAUTION\\___是plooc库的一个配置开关，用于控制是否启用内存布局边界优化。默认情况下，该开关是关闭的。 > > 当该开关开启时，plooc库会将多个成员变量放在一起，从而减少成员变量之间的空隙，使结构体的内存布局更加紧凑，从而可以优化内存占用和访问速度。但是，这种优化可能会带来一些潜在的问题，比如可能会影响代码的可移植性和可靠性，因此需要谨慎使用。 > > 具体而言，开启这个开关后，plooc库可能会违反C语言标准对于结构体内存布局的规定，也可能会导致一些未定义行为。因此，建议只有在确保不会出现问题的情况下才使用该开关。 + 使用无符号数返回一个有符号的整形 ![image 20231126205950058](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311262059631.png) > 把函数的uint32_t改为int ![image 20231127172536430](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311271725466.png)"},"/note/嵌入式/第三方移植/物联网/2023-11-13-02MQQT程序分层.html":{"title":"MQTT程序分层","content":" layout: post title: \"MQTT程序分层\" date: 2023 11 12 15:39:08 +0800 tags: 物联网 stm32 # MQTT程序分层 我们主要关注的是客户端(记者和用户), 我们只需要把信息发送给电视台或者接受信息就行了 1. 初始化以及连接 2. 发出订阅信息 3. 有一个线程读传感器, 有某种情况发生以后发布消息 4. 另一个线程等待消息, 在等到消息以后处理消息 ```c int main(void) { int res; pthread_t thread1; mqtt_client_t *client NULL; printf(\"\\nwelcome to mqttclient test...\\n\"); mqtt_log_init(); client mqtt_lease();\t//获取一个句柄 #ifdef TEST_USEING_TLS //未使用 mqtt_set_port(client, \"8883\"); mqtt_set_ca(client, (char*)test_ca_get()); #else mqtt_set_port(client, \"1883\");\t//设置一个端口 #endif mqtt_set_host(client, \"www.jiejie01.top\");\t\t//设置服务器 mqtt_set_client_id(client, random_string(10)); mqtt_set_user_name(client, random_string(10)); mqtt_set_password(client, random_string(10)); mqtt_set_clean_session(client, 1); mqtt_connect(client);`//连接服务器 mqtt_subscribe(client, \"topic1\", QOS0, topic1_handler); mqtt_subscribe(client, \"topic2\", QOS1, NULL); mqtt_subscribe(client, \"topic3\", QOS2, NULL); res pthread_create(&thread1, NULL, mqtt_publish_thread, client); //创建一个线程用于接收数据 if(res ! 0) { MQTT_LOG_E(\"create mqtt publish thread fail\"); exit(res); } while (1) { sleep(100); } } ``` + 获取一个句柄 ```c mqtt_client_t *mqtt_lease(void) { int rc; mqtt_client_t* c; c (mqtt_client_t *)platform_memory_alloc(sizeof(mqtt_client_t)); if (NULL c) return NULL; memset(c, 0, sizeof(mqtt_client_t)); rc mqtt_init(c); if (MQTT_SUCCESS_ERROR ! rc) return NULL; return c; } ``` > 申请一个MQTT的句柄, 并进行初始化 ```c static int mqtt_init(mqtt_client_t* c) { /* network init */ c >mqtt_network (network_t*) platform_memory_alloc(sizeof(network_t)); if (NULL c >mqtt_network) { MQTT_LOG_E(\"%s:%d %s()... malloc memory failed...\", __FILE__, __LINE__, __FUNCTION__); RETURN_ERROR(MQTT_MEM_NOT_ENOUGH_ERROR); } memset(c >mqtt_network, 0, sizeof(network_t)); c >mqtt_packet_id 1; c >mqtt_clean_session 0; //no clear session by default c >mqtt_will_flag 0; c >mqtt_cmd_timeout MQTT_DEFAULT_CMD_TIMEOUT; c >mqtt_client_state CLIENT_STATE_INITIALIZED; c >mqtt_ping_outstanding 0; c >mqtt_ack_handler_number 0; c >mqtt_client_id_len 0; c >mqtt_user_name_len 0; c >mqtt_password_len 0; c >mqtt_keep_alive_interval MQTT_KEEP_ALIVE_INTERVAL;\t//多少秒联系一次 c >mqtt_version MQTT_VERSION; c >mqtt_reconnect_try_duration MQTT_RECONNECT_DEFAULT_DURATION; c >mqtt_will_options NULL; c >mqtt_reconnect_data NULL; c >mqtt_reconnect_handler NULL; c >mqtt_interceptor_handler NULL; mqtt_read_buf_malloc(c, MQTT_DEFAULT_BUF_SIZE);\t\t//读写buff mqtt_write_buf_malloc(c, MQTT_DEFAULT_BUF_SIZE); mqtt_list_init(&c >mqtt_msg_handler_list); mqtt_list_init(&c >mqtt_ack_handler_list); platform_mutex_init(&c >mqtt_write_lock); platform_mutex_init(&c >mqtt_global_lock); platform_timer_init(&c >mqtt_last_sent); platform_timer_init(&c >mqtt_last_received); RETURN_ERROR(MQTT_SUCCESS_ERROR); } ``` > 主要是设置一些参数 + 网络连接 ```c int mqtt_connect(mqtt_client_t* c) { /* connect server in blocking mode and wait for connection result */ return mqtt_connect_with_results(c); } ``` ```c int network_connect(network_t *n) { #ifndef MQTT_NETWORK_TYPE_NO_TLS if (n >channel) return nettype_tls_connect(n); #endif return nettype_tcp_connect(n); } ``` ```c int nettype_tcp_connect(network_t* n) { n >socket platform_net_socket_connect(n >host, n >port, PLATFORM_NET_PROTO_TCP);//平台相关的socket连接 if (n >socket < 0) RETURN_ERROR(n >socket); RETURN_ERROR(MQTT_SUCCESS_ERROR); } ``` > platform_net_socket_connect这个是主要需要实现的, 需要使用AT命令进行实现, 通过串口进行实现 ### 创建线程 调用过程： ```c main \tmqtt_connect(client); \t\tmqtt_connect_with_results(c); \t\t rc network_init(c >mqtt_network, c >mqtt_host, c >mqtt_port, NULL); \t\t rc network_connect(c >mqtt_network);\t//在这里面会调用平台提供的函数 /* send connect packet */ if ((rc mqtt_send_packet(c, len, &connect_timer)) ! MQTT_SUCCESS_ERROR) goto exit; \t\t if (mqtt_wait_packet(c, CONNACK, &connect_timer) CONNACK) { } /* connect success, and need init mqtt thread */ c >mqtt_thread platform_thread_init(\"mqtt_yield_thread\", mqtt_yield_thread,c, ...); ``` ### 发布消息 调用过程： ```c main res pthread_create(&thread1, NULL, mqtt_publish_thread, client); \t\t\t\tmqtt_publish_thread mqtt_publish(client, \"topic1\", &msg); // 1. 构造消息 mqtt_message_t msg; memset(&msg, 0, sizeof(msg)); msg.payload (void *) buf;\t//初始化一个信息 msg.payloadlen xxx;\t//设置信息的长度 mqtt_publish(client, \"topic1\", &msg); \t// 1.1 根据MQTT协议构造数据包 // 1.2 根据平台相关的函数发送数据包 mqtt_send_packet network_write \tnettype_tcp_write \t\tplatform_net_socket_write_timeout ``` ### 4.4 最复杂：订阅消息 消息何时到来？不知道！ 所以，必定是某个内核线程不断查询网卡： * 读网卡数据 * 得到数据的话就判断、处理 ```c mqtt_subscribe(client, \"topic1\", QOS0, topic1_handler); mqtt_subscribe(client, \"topic2\", QOS1, NULL); mqtt_subscribe(client, \"topic3\", QOS2, NULL); ``` > 之后调用这个函数订阅主题, 当收到某一个主题的函数的时候会调用注册的函数 ```c def_class(message_handlers_t, private_member( mqtt_list_t list;//插入到某一个链表 mqtt_qos_t qos;//服务质量 const char* topic_filter;//主题名字 message_handler_t handler;//函数指针 ) ) ``` > 之后会创建这样一个结构体 ### 关键线程 1. 处理收到的数据 2. 保持心跳 ```c while (1) { rc mqtt_yield(c, c >mqtt_cmd_timeout);//接受信息 if (MQTT_CLEAN_SESSION_ERROR rc) {//错误处理 MQTT_LOG_W(\"%s:%d %s()..., mqtt clean session....\", __FILE__, __LINE__, __FUNCTION__); network_disconnect(c >mqtt_network); mqtt_clean_session(c); goto exit; } else if (MQTT_RECONNECT_TIMEOUT_ERROR rc) { MQTT_LOG_W(\"%s:%d %s()..., mqtt reconnect timeout....\", __FILE__, __LINE__, __FUNCTION__); } } ``` + 接收信息的函数 ```c static int mqtt_yield(mqtt_client_t* c, int timeout_ms) { int rc MQTT_SUCCESS_ERROR; client_state_t state; platform_timer_t timer; if (NULL c) RETURN_ERROR(MQTT_FAILED_ERROR); if (0 timeout_ms) timeout_ms c >mqtt_cmd_timeout; platform_timer_cutdown(&timer, timeout_ms); while (!platform_timer_is_expired(&timer)) { state mqtt_get_client_state(c); if (CLIENT_STATE_CLEAN_SESSION state) { RETURN_ERROR(MQTT_CLEAN_SESSION_ERROR); } else if (CLIENT_STATE_CONNECTED ! state) { /* mqtt not connect, need reconnect */ rc mqtt_try_reconnect(c); if (MQTT_RECONNECT_TIMEOUT_ERROR rc) RETURN_ERROR(rc); continue; } /* mqtt connected, handle mqtt packet */ rc mqtt_packet_handle(c, &timer);//信息的处理 if (rc > 0) { /* scan ack list, destroy ack handler that have timed out or resend them */ mqtt_ack_list_scan(c, 1); } else if (MQTT_NOT_CONNECT_ERROR rc) { MQTT_LOG_E(\"%s:%d %s()... mqtt not connect\", __FILE__, __LINE__, __FUNCTION__); } else { break; } } RETURN_ERROR(rc); } ``` + 处理信息 ```c static int mqtt_packet_handle(mqtt_client_t* c, platform_timer_t* timer) { int rc MQTT_SUCCESS_ERROR; int packet_type 0; rc mqtt_read_packet(c, &packet_type, timer);//会在这里进行读数据包, 会把包的数据保存在第二个参数里面 switch (packet_type) { case 0: /* timed out reading packet or an error occurred while reading data*/ if (MQTT_BUFFER_TOO_SHORT_ERROR rc) {//没有收到 MQTT_LOG_E(\"the client read buffer is too short, please call mqtt_set_read_buf_size() to reset the buffer size\"); /* don't return directly, you need to stay active, because there is data readable now, but the buffer is too small */ } break; \t\t//处理不同的包 case CONNACK: /* has been processed */ goto exit; case PUBACK: case PUBCOMP: rc mqtt_puback_and_pubcomp_packet_handle(c, timer); break; case SUBACK: rc mqtt_suback_packet_handle(c, timer); break; case UNSUBACK: rc mqtt_unsuback_packet_handle(c, timer); break; case PUBLISH: rc mqtt_publish_packet_handle(c, timer); break; case PUBREC: case PUBREL: rc mqtt_pubrec_and_pubrel_packet_handle(c, timer); break; case PINGRESP: c >mqtt_ping_outstanding 0; /* keep alive ping success */ break; default: break; } rc mqtt_keep_alive(c);//保持心跳 exit: if (rc MQTT_SUCCESS_ERROR) rc packet_type; RETURN_ERROR(rc); } ``` + 心跳处理 ```c int mqtt_keep_alive(mqtt_client_t* c) { int rc MQTT_SUCCESS_ERROR; rc mqtt_is_connected(c); if (MQTT_SUCCESS_ERROR ! rc) RETURN_ERROR(rc); if (platform_timer_is_expired(&c >mqtt_last_sent) platform_timer_is_expired(&c >mqtt_last_received)) {//时间到了 if (c >mqtt_ping_outstanding) { MQTT_LOG_W(\"%s:%d %s()... ping outstanding\", __FILE__, __LINE__, __FUNCTION__); /*must realse the socket file descriptor zhaoshimin 20200629*/ network_release(c >mqtt_network); mqtt_set_client_state(c, CLIENT_STATE_DISCONNECTED); rc MQTT_NOT_CONNECT_ERROR; /* PINGRESP not received in keepalive interval */ } else { platform_timer_t timer; int len MQTTSerialize_pingreq(c >mqtt_write_buf, c >mqtt_write_buf_size); if (len > 0 && (rc mqtt_send_packet(c, len, &timer)) MQTT_SUCCESS_ERROR) // send the ping packet c >mqtt_ping_outstanding++; } } RETURN_ERROR(rc); } ``` + 处理头部 ```c struct { unsigned int retain : 1;\t\t/**< retained flag bit */ unsigned int qos : 2;\t\t\t\t/**< QoS value, 0, 1 or 2 */ unsigned int dup : 1;\t\t\t\t/**< DUP flag bit */ unsigned int type : 4;\t\t\t/**< message type nibble */ } bits; ``` > 使用位域对头部进行解析 + 其中一个处理函数 ```c static int mqtt_publish_packet_handle(mqtt_client_t *c, platform_timer_t *timer) { int len 0, rc MQTT_SUCCESS_ERROR; MQTTString topic_name; mqtt_message_t msg; int qos; msg.payloadlen 0; //确保连接 rc mqtt_is_connected(c); if (MQTT_SUCCESS_ERROR ! rc) RETURN_ERROR(rc); if (MQTTDeserialize_publish(&msg.dup, &qos, &msg.retained, &msg.id, &topic_name, (uint8_t**)&msg.payload, (int*)&msg.payloadlen, c >mqtt_read_buf, c >mqtt_read_buf_size) ! 1) RETURN_ERROR(MQTT_PUBLISH_PACKET_ERROR); msg.qos (mqtt_qos_t)qos; /* for qos1 and qos2, you need to send a ack packet */ if (msg.qos ! QOS0) { platform_mutex_lock(&c >mqtt_write_lock); if (msg.qos QOS1) len MQTTSerialize_ack(c >mqtt_write_buf, c >mqtt_write_buf_size, PUBACK, 0, msg.id); else if (msg.qos QOS2) len MQTTSerialize_ack(c >mqtt_write_buf, c >mqtt_write_buf_size, PUBREC, 0, msg.id); if (len < 0) rc MQTT_SERIALIZE_PUBLISH_ACK_PACKET_ERROR; else rc mqtt_send_packet(c, len, timer); platform_mutex_unlock(&c >mqtt_write_lock); } if (rc < 0) RETURN_ERROR(rc); if (msg.qos ! QOS2) mqtt_deliver_message(c, &topic_name, &msg); else { /* record the received of a qos2 message and only processes it when the qos2 message is received for the first time */ if ((rc mqtt_ack_list_record(c, PUBREL, msg.id, len, NULL)) ! MQTT_ACK_NODE_IS_EXIST_ERROR) mqtt_deliver_message(c, &topic_name, &msg);\t\t//在这里对信息进一步解析,调用对应处理函数 } RETURN_ERROR(rc); } ``` ```c static int mqtt_deliver_message(mqtt_client_t* c, MQTTString* topic_name, mqtt_message_t* message) { int rc MQTT_FAILED_ERROR; message_handlers_t *msg_handler; /* get mqtt message handler */ msg_handler mqtt_get_msg_handler(c, topic_name);\t//获取处理函数 if (NULL ! msg_handler) { message_data_t md; mqtt_new_message_data(&md, topic_name, message); /* make a message data */ msg_handler >handler(c, &md); /* deliver the message */ rc MQTT_SUCCESS_ERROR; } else if (NULL ! c >mqtt_interceptor_handler) { message_data_t md; mqtt_new_message_data(&md, topic_name, message); /* make a message data */ c >mqtt_interceptor_handler(c, &md); rc MQTT_SUCCESS_ERROR; } memset(message >payload, 0, strlen((const char *)message >payload)); memset(topic_name >lenstring.data, 0, topic_name >lenstring.len); RETURN_ERROR(rc); } ``` ```c #define LIST_FOR_EACH_SAFE(curr, next, list) \\ for (curr (list) >next, next curr >next; curr ! (list); \\ curr next, next curr >next) ``` 1. 订阅消息调用函数, 告诉他要订阅的消息以及接收到消息以后的处理函数 2. 这个订阅会把这个消息加到一个链表里面, 链表包含名称以及处理函数 3. 创建一个线程进行处理接收到的消息 4. 线程里面会进行读数据包, 之后根据数据包的类型进行处理 ## 实际的移植 使用的是FreeRTOS, 里面的时钟等已经被实现, 需要自己实现网络连接的接口 移植的是platform_net_socket.c文件里面的connect函数, write函数, read函数"},"/note/嵌入式/第三方移植/物联网/2023-11-12-01网络基础知识.html":{"title":"网络基础知识","content":" layout: post title: \"网络基础知识\" date: 2023 11 12 15:39:08 +0800 tags: 物联网 stm32 # 网络基础知识 在局域网里面可以很简单的控制设备, 但是不是在局域网的时候就需要引入服务器 在一个设备上面使用ip表示一个设备, 一个设备上不同的程序使用的不同的端口, 一般来说80端口是http端口, 22端口是ssh服务端口 IP和端口都很珍贵, 不是所有的设备都有公网的ip, 局域网的ip是192.168.x.x, 一般一个路由器有一个公网ip, 一般一个设备在访问网络的时候, 把需求发送给路由器, 路由器记录以后, 路由器进行转发, 构造出一个新的数据包, 源被修改, 但是目的不变, 通过互联网进行发送, 在服务器接受以后返回数据的时候会给路由器, 路由器会再转发给设备 路由器在接受到来路不明的信息会进行屏蔽, 起到保护作用 所以在使用开发板进行上网的时候如果没有一个服务器进行中介, 接收到的路由器会对数据进行丢弃 ![image 20231112214547242](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311122145332.png) 解决方案 ![image 20231112214625747](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311122146814.png) > 两个服务器都连接到服务器, 在发送数据以后由服务器进行传输数据, 服务器上面需要运行一些软件, 进行数据的传输, 一般使用的是MQTT(一种优化过的协议, 适合传输比较短的数据) > > 一般使用的软件是 ## MQTT [mqttclient/README_CN.md at master · jiejieTop/mqttclient (github.com)](https://github.com/jiejieTop/mqttclient/blob/master/README_CN.md) * kawaii mqtt源码： * 作者发布源码：https://github.com/jiejieTop/mqttclient * 大牛维护的：https://github.com/longtengmcu/kawaii mqtt * 博客 * 作者博客： * [你不得不看的图文并茂的MQTT协议通信过程！！！](https://jiejie.blog.csdn.net/article/details/106737995?spm 1001.2014.3001.5502) * [MQTT协议简介及协议原理](https://jiejie.blog.csdn.net/article/details/106732811?spm 1001.2014.3001.5502) * [mqttclient设计与实现方式](https://blog.csdn.net/jiejiemcu/article/details/106773181?spm 1001.2014.3001.5501) * 大牛笔记： * [记一次解决MQTT软件包内存泄露的心路历程](https://python.iitter.com/other/90280.html) * APP * https://mosquitto.org/download/ * https://mqttx.app/zh 可以理解为一个中央电视台, 接受发布者的网络连接, 以及用户的网络连接, 记者会发布消息, 之后转发给订阅他的用户 记者和观众都是客户端 ![image 20231112215659232](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311122156268.png) 一般是服务器应用先运行, 之后建立连接, 选择订阅的栏目, 用户以及记者需要时不时ping一下中央电视台确保连接, 中央电视台发送ping说明自己还存在 开发板: 连接服务器, 订阅消息, 读MQTT包(有可能一直读不到, 需要有一个超时时间, 没有数据就返回, 在某种情况下发出ping包确认对方的存在), 处理收到的数据 ## MQTT 数据包结构 `固定头（Fixed header）`，存在于所有`MQTT`数据包中，表示数据包类型及数据包的分组类标识； `可变头（Variable header）`，存在于部分`MQTT`数据包中，数据包类型决定了可变头是否存在及其具体内容； `消息体（Payload）`，存在于部分`MQTT`数据包中，表示客户端收到的具体内容； 整体MQTT的消息格式如下图所示； ![img](https://pic3.zhimg.com/80/v2 861c089bea9570876bb13a031e6c3902_720w.webp) ### 2.1 `MQTT`固定头 `固定头`存在于所有`MQTT`数据包中，其结构如下： ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311122214812.webp) 下面简单分析一下固定头的消息格式； ### `MQTT`消息类型 / message type **位置：**byte 1, bits 7 4。 4位的无符号值，类型如下： 名称 值 流方向 描述 ![image 20240714225715707](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407142257790.png) ### 标识位 / DUP ![image 20240714230254033](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407142302132.png) > 这里的reserved表示的是后面的数据暂时没有含义, 需要按照给出的数据进行设置 **位置：**byte 1, bits 3 0。 在不使用标识位的消息类型中，标识位被作为保留位。如果收到无效的标志时，接收端必须关闭网络连接： 数据包 标识位 Bit 3 Bit 2 Bit 1 Bit 0 `DUP`：发布消息的副本。用来在保证消息的可靠传输，如果设置为 1，则在下面的变长中增加MessageId，并且需要回复确认，以保证消息传输完成，但不能用于检测消息重复发送。 `QoS`发布消息的服务质量（前面已经做过介绍），即：保证消息传递的次数 `00`：最多一次，即：< 1 `01`：至少一次，即：> 1 `10`：一次，即： 1 `11`：预留 `RETAIN`：发布保留标识，表示服务器要保留这次推送的信息，如果有新的订阅者出现，就把这消息推送给它，如果设有那么推送至当前订阅者后释放。 ### 剩余长度（Remaining Length） 位置：byte 1。 固定头的第二字节用来保存变长头部和消息体的总大小的，但不是直接保存的。这一字节是可以扩展，其保存机制，前7位用于保存长度，后一部用做标识。当最后一位为 1时，表示长度不足，需要使用二个字节继续保存。这一个的长度最大4字节 > 高位在后, 标志位不计算大小 ### 2.2 `MQTT`可变头 / Variable header `MQTT`数据包中包含一个可变头，它驻位于固定的头和负载之间。可变头的内容因数据包类型而不同，较常的应用是做为包的标识： Bit 7 — 0 很多类型数据包中都包括一个2字节的数据包标识字段，这些类型的包有： PUBLISH (QoS > 0)、PUBACK、PUBREC、PUBREL、PUBCOMP、SUBSCRIBE、SUBACK、UNSUBSCRIBE、UNSUBACK SUBSCRIBE，UNSUBSCRIBE和PUBLISH（QoS大于0）控制报文**必须**包含一个非零的16位报文标识符（Packet Identifier）[MQTT 2.3.1 1]。客户端每次发送一个新的这些类型的报文时都**必须**分配一个当前未使用的报文标识符 [MQTT 2.3.1 2]。如果一个客户端要重发这个特殊的控制报文，在随后重发那个报文时，它**必须**使用相同的标识符。当客户端处理完这个报文对应的确认后，这个报文标识符就释放可重用。QoS 1的PUBLISH对应的是PUBACK，QoS 2的PUBLISH对应的是PUBCOMP，与SUBSCRIBE或UNSUBSCRIBE对应的分别是SUBACK或UNSUBACK [MQTT 2.3.1 3]。发送一个QoS 0的PUBLISH报文时，相同的条件也适用于服务端 [MQTT 2.3.1 4]。 > QoS等于0的PUBLISH报文**不能**包含报文标识符 [MQTT 2.3.1 5]。 PUBACK, PUBREC, PUBREL报文**必须**包含与最初发送的PUBLISH报文相同的报文标识符 [MQTT 2.3.1 6]。类似地，SUBACK和UNSUBACK**必须**包含在对应的SUBSCRIBE和UNSUBSCRIBE报文中使用的报文标识符 [MQTT 2.3.1 7]。 ![image 20240716150932037](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407161509363.png) ### 2.3 `Payload`消息体 `Payload`消息体是`MQTT`数据包的第三部分，CONNECT、SUBSCRIBE、SUBACK、UNSUBSCRIBE四种类型的消息 有消息体： `CONNECT`，消息体内容主要是：客户端的ClientID、订阅的Topic、Message以及用户名和密码 `SUBSCRIBE`，消息体内容是一系列的要订阅的主题以及`QoS`。 `SUBACK`，消息体内容是服务器对于`SUBSCRIBE`所申请的主题及`QoS`进行确认和回复。 `UNSUBSCRIBE`，消息体内容是要订阅的主题。 > 实际发送的数据要求是UTF 8格式的, 如果赎金不是这一个格式的, 可能会被丢弃 ## 传输的数据(有效荷载) 在MQTT中，“有效荷载”（Payload）指的是实际的数据部分，即发送的消息内容，不包括MQTT协议头部信息。 ![image 20240716151602556](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407161516647.png) [通过案例理解 MQTT 主题与通配符 EMQ (emqx.com)](https://www.emqx.com/zh/blog/advanced features of mqtt topics) ## 主题 MQTT 协议根据主题来转发消息。主题通过 `/` 来区分层级，类似于 URL 路径，例如： ``` chat/room/1 sensor/10/temperature sensor/+/temperature ``` > [通过案例理解 MQTT 主题与通配符 EMQ (emqx.com)](https://www.emqx.com/zh/blog/advanced features of mqtt topics) > > 不同于消息队列中的主题（比如 Kafka 和 Pulsar），MQTT 主题不需要提前创建。[MQTT 客户端](https://www.emqx.com/zh/blog/mqtt client tools)在订阅或发布时即自动的创建了主题，开发者无需再关心主题的创建，并且也不需要手动删除主题。 > > MQTT 主题通配符包含单层通配符 `+` 及多层通配符 `#`，主要用于客户端一次订阅多个主题。 > > > 只能用于订阅 > > 加号 (“+” U+002B) 是用于单个主题层级匹配的通配符。在使用单层通配符时，单层通配符必须占据整个层级，例如： > > ```lsl > + 有效 > sensor/+ 有效 > sensor/+/temperature 有效 > sensor+ 无效（没有占据整个层级） > ``` > > 井字符号（“#” U+0023）是用于匹配主题中任意层级的通配符。多层通配符表示它的父级和任意数量的子层级，在使用多层通配符时，它必须占据整个层级并且必须是主题的最后一个字符，例如： > > ```awk > # 有效，匹配所有主题 > sensor/# 有效 > sensor/bedroom# 无效（没有占据整个层级） > sensor/#/temperature 无效（不是主题最后一个字符） > ``` > > ### 系统主题 > > 以 `$SYS/` 开头的主题为系统主题，系统主题主要用于获取 [MQTT 服务器](https://www.emqx.com/zh/mqtt/public mqtt5 broker)自身运行状态、消息统计、客户端上下线事件等数据。目前，MQTT 协议暂未明确规定 `$SYS/` 主题标准，但大多数 MQTT 服务器都遵循该[标准建议](https://github.com/mqtt/mqtt.org/wiki/SYS Topics)。 > > 主题 说明 > > $SYS/brokers EMQX 集群节点列表 > $SYS/brokers/emqx@127.0.0.1/version EMQX 版本 > $SYS/brokers/emqx@127.0.0.1/uptime EMQX 运行时间 > $SYS/brokers/emqx@127.0.0.1/datetime EMQX 系统时间 > $SYS/brokers/emqx@127.0.0.1/sysdescr EMQX 系统信息 > > EMQX 还支持客户端上下线事件、收发流量、消息收发、系统监控等丰富的系统主题，用户可通过订阅 `$SYS/#` 主题获取所有系统主题消息。详细请见：[EMQX 系统主题文档](https://www.emqx.io/docs/zh/v5.0/observability/mqtt system topics.html#客户端上下线事件)。 > > ### 共享订阅 > > 共享订阅是 [MQTT 5.0](https://www.emqx.com/zh/blog/introduction to mqtt 5) 引入的新特性，用于在多个订阅者之间实现订阅的负载均衡，MQTT 5.0 规定的共享订阅主题以 `$share` 开头。 > > > 虽然 MQTT 协议在 5.0 版本才引入共享订阅，但是 EMQX 从 MQTT 3.1.1 版本开始就支持共享订阅。 > > 下图中，3 个订阅者用共享订阅的方式订阅了同一个主题 `$share/g/topic`，其中`topic` 是它们订阅的真实主题名，而 `$share/g/` 是共享订阅前缀（`g/` 是群组名，可为任意 UTF 8 编码字符串）。 **QoS** MQTT 提供了三种服务质量（QoS），在不同网络环境下保证消息的可靠性。 QoS 0：消息最多传送一次。如果当前客户端不可用，它将丢失这条消息。 QoS 1：消息至少传送一次。 QoS 2：消息只传送一次。 关于 MQTT QoS 的更多详情，请参阅文章 [MQTT QoS 0, 1, 2 介绍](https://www.emqx.com/zh/blog/introduction to mqtt qos)。 其中，使用 QoS 0 可能丢失消息，使用 QoS 1 可以保证收到消息，但消息可能重复，使用 QoS 2 可以保证消息既不丢失也不重复。QoS 等级从低到高，不仅意味着消息可靠性的提升，也意味着传输复杂程度的提升。 QoS 等级是由发布者在 PUBLISH 报文中指定的，大部分情况下 Broker 向订阅者转发消息时都会维持原始的 QoS 不变。不过也有一些例外的情况，根据订阅者的订阅要求，消息的 QoS 等级可能会在转发的时候发生降级。 ## QoS 0 最多交付一次 QoS 0 是最低的 QoS 等级。QoS 0 消息即发即弃，不需要等待确认，不需要存储和重传，因此对于接收方来说，永远都不需要担心收到重复的消息。 ![MQTT QoS 0](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311122226132.png) ### 为什么 QoS 0 消息会丢失？ 当我们使用 QoS 0 传递消息时，消息的可靠性完全依赖于底层的 TCP 协议。 而 TCP 只能保证在连接稳定不关闭的情况下消息的可靠到达，一旦出现连接关闭、重置，仍有可能丢失当前处于网络链路或操作系统底层缓冲区中的消息。这也是 QoS 0 消息最主要的丢失场景。 ## QoS 1 至少交付一次 为了保证消息到达，QoS 1 加入了应答与重传机制，发送方只有在收到接收方的 PUBACK 报文以后，才能认为消息投递成功，在此之前，发送方需要存储该 PUBLISH 报文以便下次重传。 QoS 1 需要在 PUBLISH 报文中设置 Packet ID，而作为响应的 PUBACK 报文，则会使用与 PUBLISH 报文相同的 Packet ID，以便发送方收到后删除正确的 PUBLISH 报文缓存。 ![MQTT QoS 1](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311122226636.png) ### 为什么 QoS 1 消息会重复？ 对于发送方来说，没收到 PUBACK 报文分为以下两种情况： 1. PUBLISH 未到达接收方 2. PUBLISH 已经到达接收方，接收方的 PUBACK 报文还未到达发送方 在第一种情况下，发送方虽然重传了 PUBLISH 报文，但是对于接收方来说，实际上仍然仅收到了一次消息。 但是在第二种情况下，在发送方重传时，接收方已经收到过了这个 PUBLISH 报文，这就导致接收方将收到重复的消息。 ![MQTT QoS 1 重复消息](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311122226867.png) 虽然重传时 PUBLISH 报文中的 DUP 标志会被设置为 1，用以表示这是一个重传的报文。但是接收方并不能因此假定自己曾经接收过这个消息，仍然需要将其视作一个全新的消息。 这是因为对于接收方来说，可能存在以下两种情况： ![MQTT QoS 1 重复消息](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311122226888.png) 第一种情况，发送方由于没有收到 PUBACK 报文而重传了 PUBLISH 报文。此时，接收方收到的前后两个 PUBLISH 报文使用了相同的 Packet ID，并且第二个 PUBLISH 报文的 DUP 标志为 1，此时它确实是一个重复的消息。 第二种情况，第一个 PUBLISH 报文已经完成了投递，1024 这个 Packet ID 重新变为可用状态。发送方使用这个 Packet ID 发送了一个全新的 PUBLISH 报文，但这一次报文未能到达对端，所以发送方后续重传了这个 PUBLISH 报文。这就使得虽然接收方收到的第二个 PUBLISH 报文同样是相同的 Packet ID，并且 DUP 为 1，但确实是一个全新的消息。 由于我们无法区分这两种情况，所以只能让接收方将这些 PUBLISH 报文都当作全新的消息来处理。因此当我们使用 QoS 1 时，消息的重复在协议层面上是无法避免的。 甚至在比较极端的情况下，例如 Broker 从发布方收到了重复的 PUBLISH 报文，而在将这些报文转发给订阅方的过程中，再次发生重传，这将导致订阅方最终收到更多的重复消息。 在下图表示的例子中，虽然发布者的本意只是发布一条消息，但对接收方来说，最终却收到了三条相同的消息： ![MQTT QoS 1 重复消息](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311122226881.png) 以上，就是 QoS 1 保证消息到达带来的副作用。 ## QoS 2 只交付一次 QoS 2 解决了 QoS 0、1 消息可能丢失或者重复的问题，但相应地，它也带来了最复杂的交互流程和最高的开销。每一次的 QoS 2 消息投递，都要求发送方与接收方进行至少两次请求/响应流程。 ![MQTT QoS 2](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311122226785.png) 1. 首先，发送方存储并发送 QoS 为 2 的 PUBLISH 报文以启动一次 QoS 2 消息的传输，然后等待接收方回复 PUBREC 报文。这一部分与 QoS 1 基本一致，只是响应报文从 PUBACK 变成了 PUBREC。 2. 当发送方收到 PUBREC 报文，即可确认对端已经收到了 PUBLISH 报文，发送方将**不再需要重传**这个报文，并且也**不能再重传**这个报文。所以此时发送方可以删除本地存储的 PUBLISH 报文，然后发送一个 PUBREL 报文，通知对端自己准备将本次使用的 Packet ID 标记为可用了。与 PUBLISH 报文一样，我们需要确保 PUBREL 报文到达对端，所以也需要一个响应报文，并且这个 PUBREL 报文需要被存储下来以便后续重传。 3. 当接收方收到 PUBREL 报文，也可以确认在这一次的传输流程中不会再有重传的 PUBLISH 报文到达，因此回复 PUBCOMP 报文表示自己也准备好将当前的 Packet ID 用于新的消息了。 4. 当发送方收到 PUBCOMP 报文，这一次的 QoS 2 消息传输就算正式完成了。在这之后，发送方可以再次使用当前的 Packet ID 发送新的消息，而接收方再次收到使用这个 Packet ID 的 PUBLISH 报文时，也会将它视为一个全新的消息。 ### 为什么 QoS 2 消息不会重复？ QoS 2 消息保证不会丢失的逻辑与 QoS 1 相同，所以这里我们就不再重复了。 与 QoS 1 相比，QoS 2 新增了 PUBREL 报文和 PUBCOMP 报文的流程，也正是这个新增的流程带来了消息不会重复的保证。 在我们更进一步之前，我们先快速回顾一下 QoS 1 消息无法避免重复的原因。 当我们使用 QoS 1 消息时，对接收方来说，回复完 PUBACK 这个响应报文以后 Packet ID 就重新可用了，也不管响应是否确实已经到达了发送方。所以就无法得知之后到达的，携带了相同 Packet ID 的 PUBLISH 报文，到底是发送方因为没有收到响应而重传的，还是发送方因为收到了响应所以重新使用了这个 Packet ID 发送了一个全新的消息。 ![MQTT QoS 1 PUBACK](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311122226725.png) 所以，消息去重的关键就在于，通信双方如何正确地同步释放 Packet ID，换句话说，不管发送方是重传消息还是发布新消息，一定是和对端达成共识了的。 而 QoS 2 中增加的 PUBREL 流程，正是提供了帮助通信双方协商 Packet ID 何时可以重用的能力。 ![MQTT QoS 2 PUBREL](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311122226384.png) QoS 2 规定，发送方只有在收到 PUBREC 报文之前可以重传 PUBLISH 报文。一旦收到 PUBREC 报文并发出 PUBREL 报文，发送方就进入了 Packet ID 释放流程，不可以再使用当前 Packet ID 重传 PUBLISH 报文。同时，在收到对端回复的 PUBCOMP 报文确认双方都完成 Packet ID 释放之前，也不可以使用当前 Packet ID 发送新的消息。 ![MQTT QoS 2 PUBREC](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311122226417.png) 因此，对于接收方来说，能够以 PUBREL 报文为界限，凡是在 PUBREL 报文之前到达的 PUBLISH 报文，都必然是重复的消息；而凡是在 PUBREL 报文之后到达的 PUBLISH 报文，都必然是全新的消息。 一旦有了这个前提，我们就能够在协议层面完成 QoS 2 消息的去重。 ## 协议使用 https://mcxiaoke.gitbooks.io/mqtt cn/content/mqtt/0301 CONNECT.html ### 连接服务器 实际连接的时候只可以发送一次CONNECT请求 有效载荷包含一个或多个编码的字段。包括客户端的唯一标识符，Will主题，Will消息，用户名和密码。除了客户端标识之外，其它的字段都是可选的，基于标志位来决定可变报头中是否需要包含这些字段。 ![image 20240716153358619](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407161533698.png) > 剩余长度等于可变报头的长度（10字节）加上有效载荷的长度。 #### 可变报头 ![image 20240716160054815](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407161600884.png) 包含四个字段：协议名（Protocol Name），协议级别（Protocol Level），连接标志（Connect Flags）和保持连接（Keep Alive）。 + 协议名 ![image 20240716153619056](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407161536131.png) > 这一个名字不对的时候, 可以断开连接 + 协议级别 ![image 20240716153738915](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407161537994.png) 对于3.1.1版协议，协议级别字段的值是4(0x04)。如果发现不支持的协议级别，服务端**必须**给发送一个返回码为0x01（不支持的协议级别）的CONNACK报文响应CONNECT报文，然后断开客户端的连接 + 连接标志 包含一些用于指定MQTT连接行为的参数。它还指出有效载荷中的字段是否存在。 ![image 20240716153916436](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407161539516.png) **Clean Session**: 清理会话, 标志被设置为1，客户端和服务端**必须**丢弃之前的任何会话并开始一个新的会话。会话仅持续和网络连接同样长的时间。与这个会话关联的状态数据**不能**被任何之后的会话重用 标志被设置为0，服务端**必须**基于当前会话（使用客户端标识符识别）的状态恢复与客户端的通信。如果没有与这个客户端标识符关联的会话，服务端**必须**创建一个新的会话。在连接断开之后，当连接断开后，客户端和服务端**必须**保存会话信息 [MQTT 3.1.2 4]。当清理会话标志为0的会话连接断开之后，服务端**必须**将之后的QoS 1和QoS 2级别的消息保存为会话状态的一部分，如果这些消息匹配断开连接时客户端的任何订阅 [[MQTT 3](https://tools.oasis open.org/issues/browse/MQTT 3).1.2 5]。服务端也**可以**保存满足相同条件的QoS 0级别的消息。 > 客户端的会话状态包括： > > 已经发送给服务端，但是还没有完成确认的QoS 1和QoS 2级别的消息 > 已从服务端接收，但是还没有完成确认的QoS 2级别的消息。 > > 服务端的会话状态包括： > > 会话是否存在，即使会话状态的其它部分都是空。 > 客户端的订阅信息。 > 已经发送给客户端，但是还没有完成确认的QoS 1和QoS 2级别的消息。 > 即将传输给客户端的QoS 1和QoS 2级别的消息。 > 已从客户端接收，但是还没有完成确认的QoS 2级别的消息。 > 可选，准备发送给客户端的QoS 0级别的消息。 > > 这个选择取决于具体的应用。清理会话标志设置为1的客户端不会收到旧的应用消息，而且在每次连接成功后都需要重新订阅任何相关的主题。清理会话标志设置为0的客户端会收到所有在它连接断开期间发布的QoS 1和QoS 2级别的消息。因此，要确保不丢失连接断开期间的消息，需要使用QoS 1或 QoS 2级别，同时将清理会话标志设置为0。 **Will Flag**: 被设置为1，表示如果连接请求被接受了，遗嘱（Will Message）消息**必须**被存储在服务端并且与这个网络连接关联。之后网络连接关闭时，服务端**必须**发布这个遗嘱消息，除非服务端收到DISCONNECT报文时删除了这个遗嘱消息 > 服务端检测到了一个I/O错误或者网络故障。 > 客户端在保持连接（Keep Alive）的时间内未能通讯。 > 客户端没有先发送DISCONNECT报文直接关闭了网络连接。 > 由于协议错误服务端关闭了网络连接。 > > 如果遗嘱标志被设置为1，连接标志中的Will QoS和Will Retain字段会被服务端用到，同时有效载荷中**必须**包含Will Topic和Will Message字段 > > 如果遗嘱标志被设置为0，连接标志中的Will QoS和Will Retain字段**必须**设置为0，并且有效载荷中**不能**包含Will Topic和Will Message字段 > > 如果遗嘱标志被设置为0，网络连接断开时，**不能**发送遗嘱消息, 服务端应该迅速发布遗嘱消息。在关机或故障的情况下，服务端可以推迟遗嘱消息的发布直到之后的重启。如果发生了这种情况，在服务器故障和遗嘱消息被发布之间可能会有一个延迟 **QoS Will QoS**: 这两位用于指定发布遗嘱消息时使用的服务质量等级 > 如果遗嘱标志被设置为1，遗嘱QoS的值可以等于0(0x00)，1(0x01)，2(0x02)。它的值**不能**等于3 **Will Retain**: 遗嘱保留, 如果遗嘱消息被发布时需要保留，需要指定这一位的值。 **User Name Flag**: 如果用户名（User Name）标志被设置为0，有效载荷中**不能**包含用户名字段。如果用户名（User Name）标志被设置为1，有效载荷中**必须**包含用户名字段。 **Password Flag**: 标志被设置为0，有效载荷中**不能**包含密码字段, 标志被设置为1，有效载荷中**必须**包含密码字段 **Keep Alive**: 是一个以秒为单位的时间间隔，表示为一个16位的字，它是指在客户端传输完成一个控制报文的时刻到发送下一个报文的时刻，两者之间允许空闲的最大时间间隔。客户端负责保证控制报文发送的时间间隔不超过保持连接的值。如果没有任何其它的控制报文可以发送，客户端**必须**发送一个PINGREQ报文 ![image 20240716155930952](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407161559041.png) > 不管保持连接的值是多少，客户端任何时候都可以发送PINGREQ报文，并且使用PINGRESP报文判断网络和服务端的活动状态。 > > 如果保持连接的值非零，并且服务端在一点五倍的保持连接时间内没有收到客户端的控制报文，它**必须**断开客户端的网络连接，认为网络连接已断开 > > 客户端发送了PINGREQ报文之后，如果在合理的时间内仍没有收到PINGRESP报文，它**应该**关闭到服务端的网络连接。 > > 保持连接的值为零表示关闭保持连接功能。这意味着，服务端不需要因为客户端不活跃而断开连接。注意：不管保持连接的值是多少，任何时候，只要服务端认为客户端是不活跃或无响应的，可以断开客户端的连接。 #### 有效荷载 CONNECT报文的有效载荷（payload）包含一个或多个以长度为前缀的字段，可变报头中的标志决定是否包含这些字段。如果包含的话，**必须**按这个顺序出现：客户端标识符，遗嘱主题，遗嘱消息，用户名，密码 + 客户端标识符 服务端使用客户端标识符 (ClientId) 识别客户端。连接服务端的每个客户端都有唯一的客户端标识符（ClientId）。客户端和服务端都必须使用ClientId识别两者之间的MQTT会话相关的状态 服务端**必须**允许1到23个字节长的UTF 8编码的客户端标识符，客户端标识符只能包含这些字符：“0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ”（大写字母，小写字母和数字） 服务端**可以**允许编码后超过23个字节的客户端标识符 (ClientId)。服务端**可以**允许包含不是上面列表字符的客户端标识符 (ClientId)。 服务端**可以**允许客户端提供一个零字节的客户端标识符 (ClientId) ，如果这样做了，服务端**必须**将这看作特殊情况并分配唯一的客户端标识符给那个客户端。然后它**必须**假设客户端提供了那个唯一的客户端标识符，正常处理这个CONNECT报文 > 如果客户端提供了一个零字节的客户端标识符，它**必须**同时将清理会话标志设置为1 > > 如果客户端提供的ClientId为零字节且清理会话标志为0，服务端**必须**发送返回码为0x02（表示标识符不合格）的CONNACK报文响应客户端的CONNECT报文，然后关闭网络连接 + Will Topic 遗嘱主题, 如果遗嘱标志被设置为1，有效载荷的下一个字段是遗嘱主题 + Will MEssage 如果遗嘱标志被设置为1，有效载荷的下一个字段是遗嘱消息。遗嘱消息定义了将被发布到遗嘱主题的应用消息 这个字段由一个两字节的长度和遗嘱消息的有效载荷组成，表示为零字节或多个字节序列。长度给出了跟在后面的数据的字节数，不包含长度字段本身占用的两个字节。 + User Name用户名 如果用户名（User Name）标志被设置为1，有效载荷的下一个字段就是它。 + Password 如果密码（Password）标志被设置为1，有效载荷的下一个字段就是它。密码字段包含一个两字节的长度字段，长度表示二进制数据的字节数（不包含长度字段本身占用的两个字节），后面跟着0到65535字节的二进制数据 #### 响应 1. 网络连接建立后，如果服务端在合理的时间内没有收到CONNECT报文，服务端**应该**关闭这个连接。 2. 服务端**必须**按照3.1节的要求验证CONNECT报文，如果报文不符合规范，服务端不发送CONNACK报文直接关闭网络连接 [MQTT 3.1.4 1]。 3. 服务端**可以**检查CONNECT报文的内容是不是满足任何进一步的限制，**可以**执行身份验证和授权检查。如果任何一项检查没通过，按照3.2节的描述，它**应该**发送一个适当的、返回码非零的CONNACK响应，并且**必须**关闭这个网络连接。 > 1. 如果ClientId表明客户端已经连接到这个服务端，那么服务端**必须**断开原有的客户端连接 [MQTT 3.1.4 2]。 > 2. 服务端**必须**按照 3.1.2.4节的描述执行清理会话的过程 [MQTT 3.1.4 3]。 > 3. 服务端**必须**发送返回码为零的CONNACK报文作为CONNECT报文的确认响应 [MQTT 3.1.4 4]。 > 4. 开始消息分发和保持连接状态监视。 允许客户端在发送CONNECT报文之后立即发送其它的控制报文；客户端不需要等待服务端的CONNACK报文。如果服务端拒绝了CONNECT，它**不能**处理客户端在CONNECT报文之后发送的任何数据 > 客户端通常会等待一个CONNACK报文。然而客户端有权在收到CONNACK之前发送控制报文，由于不需要维持连接状态，这可以简化客户端的实现。 ### 确认连接 服务端发送CONNACK报文响应从客户端收到的CONNECT报文。服务端发送给客户端的第一个报文**必须**是CONNACK ![image 20240716161732572](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407161617678.png) ![image 20240716162053518](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407161620621.png) #### 当前会话 > 第1个字节是 *连接确认标志*，位7 1是保留位且**必须**设置为0。 第0 (SP)位 是当前会话（Session Present）标志。 如果服务端收到清理会话（CleanSession）标志为1的连接，除了将CONNACK报文中的返回码设置为0之外，还**必须**将CONNACK报文中的当前会话设置（Session Present）标志为0 如果服务端收到一个CleanSession为0的连接，当前会话标志的值取决于服务端是否已经保存了ClientId对应客户端的会话状态。如果服务端已经保存了会话状态，它**必须**将CONNACK报文中的当前会话标志设置为1。如果服务端没有已保存的会话状态，它**必须**将CONNACK报文中的当前会话设置为0。还需要将CONNACK报文中的返回码设置为0 > 一旦完成了会话的初始化设置，已经保存会话状态的客户端将期望服务端维持它存储的会话状态。如果客户端从服务端收到的当前的值与预期的不同，客户端可以选择继续这个会话或者断开连接。客户端可以丢弃客户端和服务端之间的会话状态，方法是，断开连接，将清理会话标志设置为1，再次连接，然后再次断开连接。 如果服务端发送了一个包含非零返回码的CONNACK报文，它**必须**将当前会话标志设置为0 #### 返回码 **值** **返回码响应** **描述** 0 0x00连接已接受 连接已被服务端接受 1 0x01连接已拒绝，不支持的协议版本 服务端不支持客户端请求的MQTT协议级别 2 0x02连接已拒绝，不合格的客户端标识符 客户端标识符是正确的UTF 8编码，但服务端不允许使用 3 0x03连接已拒绝，服务端不可用 网络连接已建立，但MQTT服务不可用 4 0x04连接已拒绝，无效的用户名或密码 用户名或密码的数据格式无效 5 0x05连接已拒绝，未授权 客户端未被授权连接到此服务器 6 255 保留 ### 发布消息 ![image 20240716162442985](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407161624100.png) + DUP 如果DUP标志被设置为0，表示这是客户端或服务端第一次请求发送这个PUBLISH报文。如果DUP标志被设置为1，表示这可能是一个早前报文请求的重发。 客户端或服务端请求重发一个PUBLISH报文时，**必须**将DUP标志设置为1 。对于QoS 0的消息，DUP标志**必须**设置为0 服务端发送PUBLISH报文给订阅者时，收到（入站）的PUBLISH报文的DUP标志的值不会被传播。发送（出站）的PUBLISH报文与收到（入站）的PUBLISH报文中的DUP标志是独立设置的，它的值**必须**单独的根据发送（出站）的PUBLISH报文是否是一个重发来确定 + QoS PUBLISH报文**不能**将QoS所有的位设置为1。如果服务端或客户端收到QoS所有位都为1的PUBLISH报文，它**必须**关闭网络连接 + RETAIN 如果客户端发给服务端的PUBLISH报文的保留（RETAIN）标志被设置为1，服务端**必须**存储这个应用消息和它的服务质量等级（QoS），以便它可以被分发给未来的主题名匹配的订阅者 [MQTT 3.3.1 5]。一个新的订阅建立时，对每个匹配的主题名，如果存在最近保留的消息，它**必须**被发送给这个订阅者 如果服务端收到一条保留（RETAIN）标志为1的QoS 0消息，它**必须**丢弃之前为那个主题保留的任何消息。它**应该**将这个新的QoS 0消息当作那个主题的新保留消息，但是任何时候都**可以**选择丢弃它 — 如果这种情况发生了，那个主题将没有保留消息 服务端发送PUBLISH报文给客户端时，如果消息是作为客户端一个新订阅的结果发送，它**必须**将报文的保留标志设为1。当一个PUBLISH报文发送给客户端是因为匹配一个已建立的订阅时，服务端**必须**将保留标志设为0，不管它收到的这个消息中保留标志的值是多少 保留标志为1且有效载荷为零字节的PUBLISH报文会被服务端当作正常消息处理，它会被发送给订阅主题匹配的客户端。此外，同一个主题下任何现存的保留消息必须被移除，因此这个主题之后的任何订阅者都不会收到一个保留消息 [MQTT 3.3.1 10]。*当作正常* 意思是现存的客户端收到的消息中保留标志未被设置。服务端**不能**存储零字节的保留消息 [MQTT 3.3.1 11]。 如果客户端发给服务端的PUBLISH报文的保留标志位0，服务端**不能**存储这个消息也**不能**移除或替换任何现存的保留消息 #### 可变报头 可变报头按顺序包含主题名和报文标识符。 + 主题名 主题名（Topic Name）用于识别有效载荷数据应该被发布到哪一个信息通道。 主题名**必须**是PUBLISH报文可变报头的第一个字段。它**必须**是 1.5.3节定义的UTF 8编码的字符串 [MQTT 3.3.2 1]。 PUBLISH报文中的主题名**不能**包含通配符。 服务端发送给订阅客户端的PUBLISH报文的主题名**必须**匹配该订阅的主题过滤器 + 报文标识符 只有当QoS等级是1或2时，报文标识符（Packet Identifier）字段才能出现在PUBLISH报文中。 ![image 20240716164247153](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407161642282.png) #### 有效数据 有效载荷包含将被发布的应用消息。数据的内容和格式是应用特定的。有效载荷的长度这样计算：用固定报头中的剩余长度字段的值减去可变报头的长度。包含零长度有效载荷的PUBLISH报文是合法的 #### 响应 ![image 20240716165532711](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407161655831.png) ### 发布确认Qos1 PUBACK报文是对QoS 1等级的PUBLISH报文的响应。 ![image 20240716165749448](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407161657525.png) 之后是确认的报文的标识符 ![image 20240716165828233](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407161658352.png) ### 发布收到Qos2 1 PUBREC报文是对QoS等级2的PUBLISH报文的响应。它是QoS 2等级协议交换的第二个报文。 ![image 20240716165910511](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407161659588.png) ![image 20240716165924829](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407161659951.png) ### 发布释放Qos2 2 PUBREL报文是对PUBREC报文的响应。它是QoS 2等级协议交换的第三个报文。 ![image 20240716170031142](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407161700266.png) 可变报头包含与等待确认的PUBREC报文相同的报文标识符。 ### 发布完成Qos2 3 PUBCOMP报文是对PUBREL报文的响应。它是QoS 2等级协议交换的第四个也是最后一个报文。 ![image 20240716170143961](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407161701040.png) ### 订阅主题 客户端向服务端发送SUBSCRIBE报文用于创建一个或多个订阅。每个订阅注册客户端关心的一个或多个主题。为了将应用消息转发给与那些订阅匹配的主题，服务端发送PUBLISH报文给客户端。SUBSCRIBE报文也（为每个订阅）指定了最大的QoS等级，服务端根据这个发送应用消息给客户端。 ![image 20240716170754448](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407161707526.png) 之后是一个报文标识符, 然后是有效载荷, 里面是主题过滤器表 表里面是主题过滤器以及一个字节的服务质量要求 ![image 20240716171046867](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407161710999.png) > 长度不包括这一个服务质量要求 #### 示例 ![image 20240716171306102](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407161713211.png) #### 响应 服务端收到客户端发送的一个SUBSCRIBE报文时，**必须**使用SUBACK报文响应 如果服务端收到一个SUBSCRIBE报文，报文的主题过滤器与一个现存订阅的主题过滤器相同，那么**必须**使用新的订阅彻底替换现存的订阅。新订阅的主题过滤器和之前订阅的相同，但是它的最大QoS值可以不同。与这个主题过滤器匹配的任何现存的保留消息**必须**被重发，但是发布流程**不能**中断 服务端发送给客户端的SUBACK报文对每一对主题过滤器 和QoS等级都**必须**包含一个返回码。这个返回码**必须**表示那个订阅被授予的最大QoS等级，或者表示这个订阅失败。服务端可以授予比订阅者要求的低一些的QoS等级。为响应订阅而发出的消息的有效载荷的QoS**必须**是原始发布消息的QoS和服务端授予的QoS两者中的最小值。如果原始消息的QoS是1而被授予的最大QoS是0，允许服务端重复发送一个消息的副本给订阅者 > 对某个特定的主题过滤器，如果正在订阅的客户端被授予的最大QoS等级是1，那么匹配这个过滤器的QoS等级0的应用消息会按QoS等级0分发给这个客户端。这意味着客户端最多收到这个消息的一个副本。从另一方面说，发布给同一主题的QoS等级2的消息会被服务端降级到QoS等级1再分发给客户端，因此客户端可能会收到重复的消息副本。 > > 如果正在订阅的客户端被授予的最大QoS等级是0，那么原来按QoS等级2发布给客户端的应用消息在繁忙时可能会丢失，但是服务端不应该发送重复的消息副本。发布给同一主题的 QoS等级1的消息在传输给客户端时可能会丢失或重复。 > > 使用QoS等级2订阅一个主题过滤器等于是说：*我想要按照它们发布时的QoS等级接受匹配这个过滤器的消息* 。这意味着，**确定消息分发时可能的最大QoS等级是发布者的责任，而订阅者可以要求服务端降低QoS到更适合它的等级。** ### 订阅确认 服务端发送SUBACK报文给客户端，用于确认它已收到并且正在处理SUBSCRIBE报文。 SUBACK报文包含一个返回码清单，它们指定了SUBSCRIBE请求的每个订阅被授予的最大QoS等级。 ![image 20240716180842299](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407161808380.png) 之后是回复SUBSCRIBE的报文标识符 有效载荷包含一个返回码清单。每个返回码对应等待确认的SUBSCRIBE报文中的一个主题过滤器。返回码的顺序**必须**和SUBSCRIBE报文中主题过滤器的顺序相同 ![image 20240716180950231](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407161809309.png) 0x00 最大QoS 0 0x01 成功 – 最大QoS 1 0x02 成功 – 最大 QoS 2 0x80 Failure 失败 ### 取消订阅 客户端发送UNSUBSCRIBE报文给服务端，用于取消订阅主题。 ![image 20240716181610041](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407161816168.png) 之后是一个报文标识符 UNSUBSCRIBE报文的有效载荷包含客户端想要取消订阅的主题过滤器列表。UNSUBSCRIBE报文中的主题过滤器**必须**是连续打包的 ![image 20240716182319105](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407161823194.png) > 这一个车只有完全匹配的时候才会进行删除 > > 它**必须**停止分发任何新消息给这个客户端 [MQTT 3.10.4 2]。 > 它**必须**完成分发任何已经开始往客户端发送的QoS 1和QoS 2的消息 [MQTT 3.10.4 3]。 > 它**可以**继续发送任何现存的准备分发给客户端的缓存消息。 服务端**必须**发送UNSUBACK报文响应客户端的UNSUBSCRIBE请求。UNSUBACK报文**必须**包含和UNSUBSCRIBE报文相同的报文标识符 [MQTT 3.10.4 4]。即使没有删除任何主题订阅，服务端也**必须**发送一个UNSUBACK响应 [MQTT 3.10.4 5]。 ### 取消订阅确认 ![image 20240716182914760](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407161829845.png) 之后是重复标识符, 没有其他数据 ### 心跳请求 客户端发送PINGREQ报文给服务端的。用于： 1. 在没有任何其它控制报文从客户端发给服务的时，告知服务端客户端还活着。 2. 请求服务端发送 响应确认它还活着。 3. 使用网络以确认网络连接没有断开。 ### 心跳响应 服务端发送PINGRESP报文响应客户端的PINGREQ报文。表示服务端还活着。 ![image 20240716184424665](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407161844745.png) ### 断开连接 DISCONNECT报文是客户端发给服务端的最后一个控制报文。表示客户端正常断开连接。 ![image 20240716184557657](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407161845793.png)"},"/note/嵌入式/第三方移植/物联网/2023-11-26-04连接wifi.html":{"title":"连接到wifi","content":" layout: post title: \"连接到wifi\" date: 2023 11 25 15:39:08 +0800 tags: 物联网 stm32 # 连接到wif 在文件platform里面还没有进行实现 ![image 20231126210236900](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311262102950.png) 现在使用的链接方式的esp8266模块, 和32通信的方式是串口, 所以需要一个串口进行通信 ![image 20231126210609479](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311262106511.png) [ESP8266 Non OS AT 指令使用示例_V1.3.pdf](file:///E:/a学习/15 嵌入式/doc_and_source_for_projects/00_开发板配套资料/ESP8266 01S模块资料/01_技术手册/01_乐鑫(espressif)/ESP8266 Non OS AT 指令使用示例_V1.3.pdf) 这个文件里面有对应的命令 ``` AT >测试连接 AT+CWMODE 3 >设置模式可以连接和被连接 AT+CWJAP \"jiao\",\"1234567890\" > 连接路由器 AT+CIFSR > 查ip AT+CIPSTART \"TCP\",\"192.168.78.165\",777 > 连接服务器 AT+CIPSEND 4 > 发送四个字节的数据, 之后再输入四个字节就可以了 AT+CIPCLOSE > 断开连接 ``` <img src \"https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311271629698.png\" alt \"image 20231127162950575\" style \"zoom:150%;\" /> ![image 20240113133713909](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401131337126.png) > 也可以使用服务器向8266发送数据, 之后8266会显示接收到的数据`+IPD,15:www.100ask.com` + 出现`busy p...` 在发送的时候不要发送多余的换行符 ## 数据格式 数据发送成功的时候会返回一个OK, 失败的话会返回一个ERROR 如果接收到数据会发送一个`+IPD,15:www.100ask.com`格式的数据 接收到数据产生中断需要保存数据 之后需要处理数据 + 实现 用一个发送命令的函数, 之后接受串口的数据, 检查返回的是REEOR还是OK 有一个环形缓冲区进行保存数据 1. 使用死等的方式进行发送数据 在写入的时候等代标志位, 使用死循环的方式 2. 使用中断 一般使用memcpy把buf复制到另一个buf里面, 之后启动一个中断, 在中断里面发送数据 ![image 20231202094135910](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312020941002.png) ![image 20231202110926963](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312021109031.png) > ![image 20231202111015489](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312021110537.png) + 处理开始的时候产生中断 在是使能中断的时候清除中断位 ## 实现命令参考RT Thread ### 思路 实现两个线程 + 线程一 发送命令at_obj_exec_cmd 等待回应进入阻塞rt_sem_take + 线程二 解析数据的线程client_parser 这个会读串口, 检测返回的是不是OK或者ERROR之类的, 是的话返回对应的返回值 这时候读会使用函数at_recv_readline函数, 在里面进行一个行的获取, 并进行处理 ![image 20231203105728745](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312031057888.png) > 会使用一个urc_table保存要处理的数据的类型, 前缀和后缀收到以后用对应的函数进行处理, 在收到一个换行, 特殊的标志位或者上面的格式的时候会表示收到了一行新的数据 可以使用函数strstr(), 会返回某一个字符串里面是否有另一个字符串, 有的话返回第一次出现的位置 ## 问题 在中断里面使用锁相关函数需要使用FromIRQ的函数 中断优先级不能太高 在中断中不能使用互斥量 ## 网络相关 ```c int platform_net_socket_connect(const char *host, const char *port, int proto) { return 0; } int platform_net_socket_recv_timeout(int fd, unsigned char *buf, int len, int timeout) { return 0; } int platform_net_socket_write_timeout(int fd, unsigned char *buf, int len, int timeout) { return 0; } int platform_net_socket_close(int fd) { return 0; } ``` > 需要实现这几个函数 ## 电脑做服务器 在mosquitto.exe的配置文件里面加上 ```c allow_anonymous true listener 1883 ``` 最后执行 ```bash mosquitto.exe c mosquitto.conf v ```"},"/note/嵌入式/esp32/2023-9-16-02ESP-IDE.html":{"title":"ESP-IDE","content":" layout: post title: \"ESP IDE\" date: 2023 9 16 15:39:08 +0800 tags: esp32 # ESP IDE ESP IDF(全称：Espressif IoT Development Framework) 是乐鑫官方推出的物联网开发框架，支持 Windows、Linux 和 macOS 操作系统，适用于 ESP32、ESP32 S、ESP32 C 和 ESP32 H 系列 SoC。它基于 C/C++ 语言提供了一个自给自足的 SDK，方便用户在这些平台上开发通用应用程序。ESP IDF 目前已服务支持数以亿计的物联网设备，并已开发构建了多种物联网产品，例如照明、消费电子大小家电、支付终端、工控等各类物联网设备。 ![image 20230916092642022](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300888.png) 进行安装 之后使用vscode进行开发 下载插件ESP IDF, 之后下载对应的版本 ![image 20230917100027215](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300889.png) ## 创建项目 ![image 20230917100129187](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300890.png) ![image 20230917100155350](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300891.png) ![image 20230917100800772](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300892.png)"},"/note/嵌入式/esp32/Arduino/2024-12-30-03-w25q64b.html":{"title":"Arduino","content":" layout: post title: \"Arduino\" date: 2024 12 30 15:39:08 +0800 tags: esp32 Arduino # W25Q64 ## 下载库 ![image 20241230230027287](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202412302300329.png) 使用管理库 ![image 20241230230156628](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202412302301696.png) ![image 20241230230221266](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202412302302318.png)"},"/note/嵌入式/esp32/Arduino/2025-1-1-04-WifiAP.html":{"title":"WifiAP","content":"# WifiAP 可以在示例里面找到, 使得esp32作为一个WiFI的热点 ![image 20250101145912251](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202501011459575.png)"},"/note/嵌入式/esp32/Arduino/2024-2-2-01Arduino框架.html":{"title":"Arduino","content":" layout: post title: \"Arduino\" date: 2024 2 2 15:39:08 +0800 tags: esp32 Arduino # Arduino框架学习 ## 项目文件 ![image 20240202213317807](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402022133872.png) ## 使用的框架 ```c #include <Arduino.h> // put function declarations here: int myFunction(int, int); //初始化的地方 void setup() { // put your setup code here, to run once: int result myFunction(2, 3); } //之后的一个循环 void loop() { // put your main code here, to run repeatedly: } // put function definitions here: int myFunction(int x, int y) { return x + y; } ``` ## 常用的函数 ### GPIO #### pinMode设置引脚模式 ```c pinMode(pin, INPUT); //configures pin as an input pinMode(pin, OUTPUT); //configures pin as an output pinMode(pin, INPUT_PULLUP); //enables the internal pull up resistor ``` #### digitalWrite写数字信号 ```c digitalWrite(pin, HIGH); // writes a high (1) state to a pin (aka turn it on) digitalWrite(pin, LOW); // writes a low (0) state to a pin (aka turn it off) ``` > 这一个是数字信号 #### analogWrite写模拟信号 ```c analogWrite(pin, value); //write a range between 0 255 to a specific pin ``` > 这一个函数使用向一个引脚写入一个PWM信号达到模拟不同的电平的效果, 这一个值可以是0 255 > > PWM is only available on specific pins (marked with a \"~\" symbol). #### analogRead读模拟信号 ```c sensorValue analogRead(A1); //stores reading of A1 in \"sensorValue\" variable ``` > 这一个返回值0 1024 #### digitalRead数字信号读 ```c int state digitalRead(pin); //store the state in the \"state\" variable ``` #### delay毫秒延时 ```c void loop() { digitalWrite(LED, HIGH); //turn on an LED delay(1000); //as program is paused, with the LED on digitalWrite(LED, LOW); //program is unpaused, and the LED is turned off delay(1000); //program is paused, with the LED off } ``` #### millis获取时间 ```c unsigned long previousMillis_1 0; //store time for first event unsigned long previousMillis_2 0; //store time for second event const long interval_1 1000; //interval for first event const long interval_2 2000; //interval for second event void setup(){ } void loop() { //check time since program started, and store in \"currentMillis\" unsigned long currentMillis millis(); //conditional that checks whether 1 second has passed since last event if (currentMillis previousMillis_1 > interval_1) { previousMillis_1 millis(); //execute a piece of code, every *1 second* } //conditional that checks whether 2 seconds have passed since last event if (currentMillis previousMillis_2 > interval_2) { previousMillis_2 millis(); //execute a piece of code, every *2 seconds* } } ``` #### delayMicroseconds微秒 进行微秒级别的延时, 其他和delay一样 ### 串口 #### Serial.begin ```c void setup() { Serial.begin(9600); } ``` > 参数是波特率 #### Serial.print > 输出信息 ### Serial.read > 读取信息 ### Serial.available > 看有没有可以读取的信息"},"/note/嵌入式/esp32/2023-9-19-05多个文件编译.html":{"title":"多个文件编译","content":" layout: post title: \"多个文件编译\" date: 2023 9 16 15:39:08 +0800 tags: esp32 # 多个文件编译 文件CCMakeList.txt ``` idf_component_register(SRCS \"hello_world_main.c\" \"my_function/print.c\" INCLUDE_DIRS \"\") ``` > 假如要编译文件的路径"},"/note/嵌入式/esp32/2025-1-16-服务器.html":{"title":"服务器","content":"# 服务器 https://x509p6c8to.feishu.cn/docx/doxcniDDyYcFo6BCkjUCnkO2aUb ## ssh [Ubuntu: 配置ssh，保姆级教程_ubuntu配置ssh CSDN博客](https://blog.csdn.net/weixin_44197719/article/details/119888235) 这时候的服务器是不可以使用root意外的用户的, 同时需要使用密码登录 [Linux创建用户并授予SSH权限_linux创建ssh用户 CSDN博客](https://blog.csdn.net/adinlead/article/details/123200169) [vscode通过ssh连接服务器实现免密登录+删除（吐血总结）_vscode ssh CSDN博客](https://blog.csdn.net/Oxford1151/article/details/137228119) ## Samba"},"/note/嵌入式/esp32/2023-9-15-01初识esp32.html":{"title":"初识esp32","content":" layout: post title: \"初识esp32\" date: 2023 9 15 15:39:08 +0800 tags: esp32 # 初识esp32 ESP32是功能丰富的Wi Fi & 蓝牙的通用MCU，适用于多样的物联网应用。 性能稳定。工作温度范围达到 –40°C 到 +125°C。集成的自校准电路实现了动态电压调整，可以消除外部电路的缺陷并适应外部条件的变化。 高度集成。ESP32 将天线开关、RF balun、功率放大器、接收低噪声放大器、滤波器、电源管理模块等功能集于一体。ESP32 只需极少的外围器件，即可实现强大的处理性能、可靠的安全性能，和 Wi Fi & 蓝牙功能。 超低功耗。ESP32 专为移动设备、可穿戴电子产品和物联网应用而设计，具有业内高水平的低功耗性能，包括精细分辨时钟门控、省电模式和动态电压调整等。 Wi Fi & 蓝牙解决方案。ESP32 可作为独立系统运行应用程序或是主机 MCU 的从设备，通过 SPI / SDIO 或 I2C / UART 接口提供 Wi Fi 和蓝牙功能。 ## 常见的型号 ESP32 D0WDQ6：最常见的型号，双核心。 ESP32 C3：单核心 RISC V 处理器，支持 Wi Fi 4 和蓝牙5.0。 ESP32 S3：双核心 LX7 处理器，支持 Wi Fi 4 和蓝牙 5.0。 款 ESP32 WROOM 32 模组(后文简称 WROOM 模组)，是目前最常见的模组，常常被各种厂家在其基础上造出自己的开发板 ![DshanMCU Mio_esp idf_chapter1 1_images_001](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242303461.jpg) WROOM模组再加上直流电源管理芯片和UART转USB芯片，就能组成一个最基本的ESP32开发板。 ![DshanMCU Mio_esp idf_chapter1 1_images_002](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242303462.jpg) ![DShanMCU Mio引脚布局](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242303463.png) 功能 描述 主控 ESP32 S3 内存 512KBytes + 2M 8MBytes PSARM(选配) 标配 512KB+8MB FLASH 8M 128MBytes (选配) 标配 16MB KEY 连接到引脚0 I2C 支持任意IO UART 支持任意IO PWM 支持任意IO 双USB 1. USAR: 板载 USB转TTL 2.USB：USB OTG 5V USB供电输入、对外供电输出 3.3V 3.3V输出，最大电流 600mA 墨水屏 支持局刷、快刷，提供LVGL开发教程、示例 SPI彩屏 SPI接口，提供LVGL开发教程、示例 ![image 20230917102404924](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242303464.png)"},"/note/嵌入式/esp32/2023-9-17-03延时函数点亮LED.html":{"title":"延时函数点亮LED","content":" layout: post title: \"延时函数点亮LED\" date: 2023 9 16 15:39:08 +0800 tags: esp32 # 延时函数点亮LED ```c #include <stdio.h> #include <inttypes.h> #include \"freertos/FreeRTOS.h\" #include \"freertos/task.h\" #include \"esp_log.h\" void app_main(void) { while(1){ //使用ESP的打印函数, 会输出这时候执行的时间 ESP_LOGI(\"main\", \"Hello world\"); //使用freeFTOS的延时函数 vTaskDelay(1000); } } ``` > FreeRTOS的延时函数的参数是切换任务的次数, 可以通过设置每一秒的任务切换的次数进行设置频率 > > 或者使用`vTaskDelay(1000/portTICK_PERIOD_MS);`, 将时间换算为毫秒 ![image 20230917100543836](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242257974.png) ![image 20230917100718634](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242257975.png) > 设置每秒钟的时钟的个数 在ESP IDF中一般我们使用 ESP_LOGx 输出日志信息，日志打印等级有： ESP_LOGE 错误（最低） ESP_LOGW 警告 ESP_LOGI 信息 ESP_LOGD 调试 ESP_LOGV 详细（最高） > 为什么不用 printf 打印日志信息？ESP IDF基于 freeRTOS，而FreeRTOS是一个抢占式的实时多任务系统，抢占就意味着任务之间有优先级，高优先级的任务可以打断低优先级的任务。因为 printf 是一个不可重入函数，而在中断中要避免调用不可重入函数(在freeRTOS多任务中也是一样)。 > 区分一个函数是否可重入就是看这个函数能否在未返回的时候再次被调用。而造成一个函数不可重入的原因往往是使用了全局变量，如果一个函数未返回再执行一次会导致对全局变量的操作是不安全的。就例如我们常用的printf、malloc、free都是不可重入的函数，printf会引用全局变量stdout，malloc，free会引用全局的内存分配表，在多线程的环境下，如果没有很好的处理数据保护和互斥访问，就会发生错误。 > 所以使用printf是不够安全的，为此ESP IDF提供了自己的安全接口 **ESP_LOGx**。"},"/note/嵌入式/esp32/2023-9-0-00CMake.html":{"title":"CMake","content":" layout: post title: \"CMake\" date: 2023 9 16 15:39:08 +0800 tags: esp32 # CMake 由于Makfile在编译文件跨平台的时候需要的代价比较大, CMake相对比较简单 使用的文件CMakeList.txt, 之后执行文件cmake, 会根据系统生成对应的文件 根节点`CMakeLists.txt`中的变量全局有效 父节点`CMakeLists.txt`中的变量可以在子节点中使用 子节点`CMakeLists.txt`中的变量只能在当前节点中使用 ## 命令 + 注释 `#`, 使用这个注释一行 `#[[ ]]`: 注释一块内容 + 命令最低版本 ```cmake cmake_minimum_required(VERSION 3.0) ``` > 这个是可以选择的 + project：定义工程名称，并可指定工程的版本、工程描述、web主页地址、支持的语言（默认情况支持所有语言），如果不需要这些都是可以忽略的，只需要指定出工程名字即可。 ```cmake project(<PROJECT NAME> [<language name>...]) project(<PROJECT NAME> [VERSION <major>[.<minor>[.<patch>[.<tweak>]]]] [DESCRIPTION <project description string>] [HOMEPAGE_URL <url string>] [LANGUAGES <language name>...]) ``` + add_executable：定义工程会生成一个可执行程序 ```cmake add_executable(可执行程序名 源文件名称) ```"},"/note/嵌入式/esp32/esp-idf/2024-6-13-16蓝牙GATT.html":{"title":"蓝牙GATT","content":" layout: post title: \"蓝牙GATT\" date: 2024 6 13 15:39:08 +0800 tags: esp32 ESP IDF # GATT GATT (Generic Attribute Profile) 和 ATT (Attribute Protocol) 是蓝牙协议栈中的两个重要协议，主要用于在蓝牙设备之间传输数据和交换信息。 ATT 是蓝牙协议栈中的底层协议，它定义了蓝牙设备之间交换数据的规则和格式。ATT 协议使用一种基于属性的数据交换模型，其中每个属性都有一个唯一的标识符和对应的值。 GATT 是建立在 ATT 协议之上的协议，它定义了蓝牙设备之间如何组织和交换数据。GATT 协议使用一种基于属性的数据协议，其中每个属性都有一个唯一的UUID（Universally Unique Identifier）来标识，并且可以包含不同类型的数据，例如传感器数据、配置信息、命令等。 GATT 和 ATT 协议结合在一起，可以让蓝牙设备之间进行灵活地数据交换和通信。例如，一个蓝牙智能手表可以使用 GATT 协议向手机发送心率数据，手机可以使用 GATT 协议向手表发送配置信息，从而实现设备之间的交互和控制。 GATT/ATT 协议在蓝牙传感器、智能家居、健康监测等领域得到了广泛的应用。 + ATT基本属性 属性句柄(属性表下标), 属性类型(UUID), 属性值, 访问权限, 相当于一个设备的数据库 + GATT属性 定义了两个角色 服务器GATTS, 客户端GATTC 独立于GAP, 服务器提供数据, 客户端访问数据, 应用的时候外围设备为服务器 一个设备可以同时为服务器和客户端 可以进行交换配置, 发现对方设备服务和特性, 读写特征值, 特征值的通知和指示 ![image 20240611091558544](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406110915669.png) ### 串口穿透 #### 初始化 ![image 20240611091629583](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406110916707.png) ![image 20240611091833545](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406110918657.png) > + 扫描结果查询 > > SDP指的是Service Discovery Protocol，它是蓝牙技术中用于设备发现和服务查找的协议。SDP允许蓝牙设备发现其附近的其他蓝牙设备，并且查询这些设备上提供的各种服务和功能。通过SDP，一个蓝牙设备可以向其他设备发送查询请求，以获取它们所提供的服务的详细信息。 ![image 20240611092838141](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406110928271.png) ![image 20240611093444755](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406110934881.png) ![image 20240611093523396](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406110935609.png) #### 属性表 ![image 20240611093749791](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406110937904.png) > 一个characteristic包含三种条目：characteristic声明，characteristic的值以及characteristic的描述符（可以有多个描述符）： > > **Characteristic declaration** > > 就是每个characteristic的分界符。解析时一旦遇到characteristicdeclaration，就可以认为接下来又是一个新的characteristic了，同时characteristic declaration还将包含value的读写属性等。 > > **Characteristic value** > > 就是数据的值了，这个比较好理解就不再说了。 > > **Characteristic descriptor** > > 就是数据的额外信息。比如温度的单位是什么，数据是用小数表示还是百分比表示等之类的数据描述信息。CCCD是一种特殊的characteristicdescriptor，当characteristic具有notify或者indicate操作功能时，那么必须为其添加相应CCCD，以方便client来使能或者禁止notify或者indicate功能。 ![image 20240611094753765](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406110947878.png) > Attribute句柄。Client要访问Server的Attribute，都是通过这个句柄来访问的，也就是说ATT PDU一般都包含handle的值。用户在软件代码添加characteristic的时候，系统会自动按顺序地为相关attribute生成句柄。 > > Attribute类型。在BLE中我们使用UUID来定义数据的类型，UUID是128 bit的，所以我们有足够的UUID来表达万事万物。 > > 就是数据真正的值，0到512字节长。 > > 　Attribute的权限属性，权限属性不会直接在空中包中体现，而是隐含在ATT命令的操作结果中。目前主要有如下四种权限属性： > > + Open，直接可以读或者写 > + No Access，禁止读或者写 > + Authentication，需要配对才能读或者写，由于配对有多种类型，因此authentication又衍生多种子类型，比如带不带MITM，有没有LESC > + Authorization，跟open一样，不过server返回attribute的值之前需要应用先授权，也就是说应用可以在回调函数里面去修改读或者写的原始值。 > + Signed，签名后才能读或者写，这个用得比较少。 ## 示例代码服务器 ### 初始化 ```c void app_main(void) { esp_err_t ret; esp_bt_controller_config_t bt_cfg BT_CONTROLLER_INIT_CONFIG_DEFAULT(); //低功耗蓝牙参数 // Initialize NVS 初始化falsh ret nvs_flash_init(); if (ret ESP_ERR_NVS_NO_FREE_PAGES ret ESP_ERR_NVS_NEW_VERSION_FOUND) { ESP_ERROR_CHECK(nvs_flash_erase()); ret nvs_flash_init(); } ESP_ERROR_CHECK( ret ); //释放经典蓝牙的内存 ESP_ERROR_CHECK(esp_bt_controller_mem_release(ESP_BT_MODE_CLASSIC_BT)); //初始化低功耗蓝牙 ret esp_bt_controller_init(&bt_cfg); //开启蓝牙控制器 ret esp_bt_controller_enable(ESP_BT_MODE_BLE); //初始化bluedroid的协议栈 ret esp_bluedroid_init(); ret esp_bluedroid_enable(); //注册事件回调 esp_ble_gatts_register_callback(gatts_event_handler); esp_ble_gap_register_callback(gap_event_handler); //注册APP esp_ble_gatts_app_register(ESP_SPP_APP_ID); spp_task_init(); return; } ``` ## 示例代码客户端 ### 初始化 ```c esp_err_t ret; ESP_ERROR_CHECK(esp_bt_controller_mem_release(ESP_BT_MODE_CLASSIC_BT)); //标准蓝牙释放 esp_bt_controller_config_t bt_cfg BT_CONTROLLER_INIT_CONFIG_DEFAULT(); esp_bt_controller_init(&bt_cfg); //初始化控制器 esp_bt_controller_enable(ESP_BT_MODE_BLE); //使能 esp_bluedroid_init(); //初始化框架 esp_bluedroid_enable(); //使能框架 ble_client_appRegister(); //申请APP ``` ```c void ble_client_appRegister(void) { esp_err_t status; char err_msg[20]; ESP_LOGI(GATTC_TAG, \"register callback\"); //register the scan callback function to the gap module //注册GAP的回调 if ((status esp_ble_gap_register_callback(esp_gap_cb)) ! ESP_OK) { ESP_LOGE(GATTC_TAG, \"gap register error: %s\", esp_err_to_name_r(status, err_msg, sizeof(err_msg))); return; } //register the callback function to the gattc module //客户端的回调 if ((status esp_ble_gattc_register_callback(esp_gattc_cb)) ! ESP_OK) { ESP_LOGE(GATTC_TAG, \"gattc register error: %s\", esp_err_to_name_r(status, err_msg, sizeof(err_msg))); return; } //注册GATTC的APP esp_ble_gattc_app_register(PROFILE_APP_ID); //设置最大回调单元 esp_err_t local_mtu_ret esp_ble_gatt_set_local_mtu(200); if (local_mtu_ret){ ESP_LOGE(GATTC_TAG, \"set local MTU failed: %s\", esp_err_to_name_r(local_mtu_ret, err_msg, sizeof(err_msg))); } \t//一个队列用于spp, 这一个会阻塞等待发送事件 cmd_reg_queue xQueueCreate(10, sizeof(uint32_t)); xTaskCreate(spp_client_reg_task, \"spp_client_reg_task\", 2048, NULL, 10, NULL); } ``` ### gattc回调函数 ```c static void esp_gattc_cb(esp_gattc_cb_event_t event, esp_gatt_if_t gattc_if, esp_ble_gattc_cb_param_t *param) { ESP_LOGI(GATTC_TAG, \"EVT %d, gattc if %d\", event, gattc_if); /* If event is register event, store the gattc_if for each profile */ if (event ESP_GATTC_REG_EVT) { //这一个是一个注册的事件 if (param >reg.status ESP_GATT_OK) { gl_profile_tab[param >reg.app_id].gattc_if gattc_if; } else { ESP_LOGI(GATTC_TAG, \"Reg app failed, app_id %04x, status %d\", param >reg.app_id, param >reg.status); return; } } /* If the gattc_if equal to profile A, call profile A cb handler, * so here call each profile's callback */ do { //遍历一下所有的回调函数, 实际是调用事件处理函数 int idx; for (idx 0; idx < PROFILE_NUM; idx++) { if (gattc_if ESP_GATT_IF_NONE /* ESP_GATT_IF_NONE, not specify a certain gatt_if, need to call every profile cb function */ gattc_if gl_profile_tab[idx].gattc_if) { if (gl_profile_tab[idx].gattc_cb) { gl_profile_tab[idx].gattc_cb(event, gattc_if, param); } } } } while (0); } ``` ### GAP回调(获取连接) ```c //在这一个里面实现扫描对方, 检测名字之后连接 static void esp_gap_cb(esp_gap_ble_cb_event_t event, esp_ble_gap_cb_param_t *param) { uint8_t *adv_name NULL; uint8_t adv_name_len 0; esp_err_t err; switch(event){ case ESP_GAP_BLE_SCAN_PARAM_SET_COMPLETE_EVT: { //判断是不是设置参数成功 if((err param >scan_param_cmpl.status) ! ESP_BT_STATUS_SUCCESS){ ESP_LOGE(GATTC_TAG, \"Scan param set failed: %s\", esp_err_to_name(err)); break; } //the unit of the duration is second uint32_t duration 0xFFFF; ESP_LOGI(GATTC_TAG, \"Enable Ble Scan:during time %04\" PRIx32 \" minutes.\",duration); //开启扫描, 之后进入ESP_GAP_BLE_SCAN_PARAM_SET_COMPLETE_EVT esp_ble_gap_start_scanning(duration); break; } case ESP_GAP_BLE_SCAN_START_COMPLETE_EVT: //scan start complete event to indicate scan start successfully or failed //成功打开了 if ((err param >scan_start_cmpl.status) ! ESP_BT_STATUS_SUCCESS) { ESP_LOGE(GATTC_TAG, \"Scan start failed: %s\", esp_err_to_name(err)); break; } ESP_LOGI(GATTC_TAG, \"Scan start successed\"); //之后进入 ESP_GAP_BLE_SCAN_RESULT_EVT break; case ESP_GAP_BLE_SCAN_STOP_COMPLETE_EVT: //停止事件 if ((err param >scan_stop_cmpl.status) ! ESP_BT_STATUS_SUCCESS) { ESP_LOGE(GATTC_TAG, \"Scan stop failed: %s\", esp_err_to_name(err)); break; } ESP_LOGI(GATTC_TAG, \"Scan stop successed\"); if (is_connect false) { ESP_LOGI(GATTC_TAG, \"Connect to the remote device.\"); //开启gattc, 使用获取的数据 //gattc_if获取是在esp_gattc_cb里面的ESP_GATTC_REG_EVT事件的时候设置 //其余的数据是scan的时候获取的地址和类型 //这一个函数之后进入gattc回调函数的ESP_GATTC_CONNECT_EVT esp_ble_gattc_open(gl_profile_tab[PROFILE_APP_ID].gattc_if, scan_rst.scan_rst.bda, scan_rst.scan_rst.ble_addr_type, true); } break; case ESP_GAP_BLE_SCAN_RESULT_EVT: { //扫描有结果了 esp_ble_gap_cb_param_t *scan_result (esp_ble_gap_cb_param_t *)param; switch (scan_result >scan_rst.search_evt) { case ESP_GAP_SEARCH_INQ_RES_EVT: //查询成功事件 esp_log_buffer_hex(GATTC_TAG, scan_result >scan_rst.bda, 6); //解析一下数据 ESP_LOGI(GATTC_TAG, \"Searched Adv Data Len %d, Scan Response Len %d\", scan_result >scan_rst.adv_data_len, scan_result >scan_rst.scan_rsp_len); adv_name esp_ble_resolve_adv_data(scan_result >scan_rst.ble_adv, ESP_BLE_AD_TYPE_NAME_CMPL, &adv_name_len); ESP_LOGI(GATTC_TAG, \"Searched Device Name Len %d\", adv_name_len); esp_log_buffer_char(GATTC_TAG, adv_name, adv_name_len); ESP_LOGI(GATTC_TAG, \"\\n\"); if (adv_name ! NULL) { //对比一下是不是这一个名字 if ( strncmp((char *)adv_name, device_name, adv_name_len) 0) { //记录一下参数在scan_rst这一个全局变量里面 memcpy(&(scan_rst), scan_result, sizeof(esp_ble_gap_cb_param_t)); //把这一个GAP停止了, 之后进入ESP_GAP_BLE_SCAN_STOP_COMPLETE_EVT esp_ble_gap_stop_scanning(); } } break; case ESP_GAP_SEARCH_INQ_CMPL_EVT: break; default: break; } break; } case ESP_GAP_BLE_ADV_STOP_COMPLETE_EVT: if ((err param >adv_stop_cmpl.status) ! ESP_BT_STATUS_SUCCESS){ ESP_LOGE(GATTC_TAG, \"Adv stop failed: %s\", esp_err_to_name(err)); }else { ESP_LOGI(GATTC_TAG, \"Stop adv successfully\"); } break; default: break; } } ``` ### GATTC回调函数 ```c static void gattc_profile_event_handler(esp_gattc_cb_event_t event, esp_gatt_if_t gattc_if, esp_ble_gattc_cb_param_t *param) { esp_ble_gattc_cb_param_t *p_data (esp_ble_gattc_cb_param_t *)param; switch (event) { case ESP_GATTC_REG_EVT: ESP_LOGI(GATTC_TAG, \"REG EVT, set scan params\"); esp_ble_gap_set_scan_params(&ble_scan_params); break; case ESP_GATTC_CONNECT_EVT: //连接事件 ESP_LOGI(GATTC_TAG, \"ESP_GATTC_CONNECT_EVT: conn_id %d, gatt_if %d\", spp_conn_id, gattc_if); ESP_LOGI(GATTC_TAG, \"REMOTE BDA:\"); esp_log_buffer_hex(GATTC_TAG, gl_profile_tab[PROFILE_APP_ID].remote_bda, sizeof(esp_bd_addr_t)); //记录一下全局变量 spp_gattc_if gattc_if; is_connect true; spp_conn_id p_data >connect.conn_id; //记录设备地址 memcpy(gl_profile_tab[PROFILE_APP_ID].remote_bda, p_data >connect.remote_bda, sizeof(esp_bd_addr_t)); //对服务进行搜索, 进入ESP_GATTC_SEARCH_RES_EVT esp_ble_gattc_search_service(spp_gattc_if, spp_conn_id, &spp_service_uuid); break; case ESP_GATTC_DISCONNECT_EVT: ESP_LOGI(GATTC_TAG, \"disconnect\"); free_gattc_srv_db(); esp_ble_gap_start_scanning(SCAN_ALL_THE_TIME); break; case ESP_GATTC_SEARCH_RES_EVT: //搜索事件 ESP_LOGI(GATTC_TAG, \"ESP_GATTC_SEARCH_RES_EVT: start_handle %d, end_handle %d, UUID:0x%04x\", p_data >search_res.start_handle, p_data >search_res.end_handle, p_data >search_res.srvc_id.uuid.uuid.uuid16); //记录一下对方的Handler数据 spp_srv_start_handle p_data >search_res.start_handle; spp_srv_end_handle p_data >search_res.end_handle; break; case ESP_GATTC_SEARCH_CMPL_EVT: //搜索完成 ESP_LOGI(GATTC_TAG, \"SEARCH_CMPL: conn_id %x, status %d\", spp_conn_id, p_data >search_cmpl.status); //发送以及确定最大传输单元 //之后进入ESP_GATTC_CFG_MTU_EVT事件 esp_ble_gattc_send_mtu_req(gattc_if, spp_conn_id); break; case ESP_GATTC_REG_FOR_NOTIFY_EVT: { //注册通知esp_ble_gattc_register_for_notify这一个函数之后 //这一个函数是在cmd设置以后, 在spp的任务里面启用的 ESP_LOGI(GATTC_TAG,\"Index %d,status %d,handle %d\\n\", cmd, p_data >reg_for_notify.status, p_data >reg_for_notify.handle); if(p_data >reg_for_notify.status ! ESP_GATT_OK){ ESP_LOGE(GATTC_TAG, \"ESP_GATTC_REG_FOR_NOTIFY_EVT, status %d\", p_data >reg_for_notify.status); break; } uint16_t notify_en 1; //写入特征描述符 esp_ble_gattc_write_char_descr( spp_gattc_if, spp_conn_id, (db+cmd+1) >attribute_handle, sizeof(notify_en), (uint8_t *)&notify_en, ESP_GATT_WRITE_TYPE_RSP, ESP_GATT_AUTH_REQ_NONE); break; } case ESP_GATTC_NOTIFY_EVT: //接收通知事件 ESP_LOGI(GATTC_TAG,\"ESP_GATTC_NOTIFY_EVT\\n\"); notify_event_handler(p_data); break; case ESP_GATTC_READ_CHAR_EVT: ESP_LOGI(GATTC_TAG,\"ESP_GATTC_READ_CHAR_EVT\\n\"); break; case ESP_GATTC_WRITE_CHAR_EVT: ESP_LOGI(GATTC_TAG,\"ESP_GATTC_WRITE_CHAR_EVT:status %d,handle %d\", param >write.status, param >write.handle); if(param >write.status ! ESP_GATT_OK){ ESP_LOGE(GATTC_TAG, \"ESP_GATTC_WRITE_CHAR_EVT, error status %d\", p_data >write.status); break; } break; case ESP_GATTC_PREP_WRITE_EVT: break; case ESP_GATTC_EXEC_EVT: break; case ESP_GATTC_WRITE_DESCR_EVT: ESP_LOGI(GATTC_TAG,\"ESP_GATTC_WRITE_DESCR_EVT: status %d,handle %d \\n\", p_data >write.status, p_data >write.handle); if(p_data >write.status ! ESP_GATT_OK){ ESP_LOGE(GATTC_TAG, \"ESP_GATTC_WRITE_DESCR_EVT, error status %d\", p_data >write.status); break; } switch(cmd){ case SPP_IDX_SPP_DATA_NTY_VAL: cmd SPP_IDX_SPP_STATUS_VAL; xQueueSend(cmd_reg_queue, &cmd,10/portTICK_PERIOD_MS); break; case SPP_IDX_SPP_STATUS_VAL: #ifdef SUPPORT_HEARTBEAT cmd SPP_IDX_SPP_HEARTBEAT_VAL; xQueueSend(cmd_reg_queue, &cmd, 10/portTICK_PERIOD_MS); #endif break; #ifdef SUPPORT_HEARTBEAT case SPP_IDX_SPP_HEARTBEAT_VAL: xQueueSend(cmd_heartbeat_queue, &cmd, 10/portTICK_PERIOD_MS); break; #endif default: break; }; break; case ESP_GATTC_CFG_MTU_EVT: //配置最大传输单元 if(p_data >cfg_mtu.status ! ESP_OK){ break; } ESP_LOGI(GATTC_TAG,\"+MTU:%d\\n\", p_data >cfg_mtu.mtu); spp_mtu_size p_data >cfg_mtu.mtu;//记录一下对方的值 //申请服务特征数据库 //这一个数据库和对方相比, 差了一个声明 db (esp_gattc_db_elem_t *)malloc(count*sizeof(esp_gattc_db_elem_t)); if(db NULL){ ESP_LOGE(GATTC_TAG,\"%s:malloc db falied\\n\",__func__); break; } //获取数据库的数据 if(esp_ble_gattc_get_db(spp_gattc_if, spp_conn_id, spp_srv_start_handle, spp_srv_end_handle, db, &count) ! ESP_GATT_OK){ ESP_LOGE(GATTC_TAG,\"%s:get db falied\\n\",__func__); break; } if(count ! SPP_IDX_NB){ //判断是不是获取成功了 ESP_LOGE(GATTC_TAG,\"%s:get db count ! SPP_IDX_NB, count %d, SPP_IDX_NB %d\\n\",__func__,count,SPP_IDX_NB); break; } //根据数据的类型进行打印 for(int i 0;i < SPP_IDX_NB;i++){ switch((db+i) >type){ case ESP_GATT_DB_PRIMARY_SERVICE: ESP_LOGI(GATTC_TAG,\"attr_type PRIMARY_SERVICE,attribute_handle %d,start_handle %d,end_handle %d,properties 0x%x,uuid 0x%04x\\n\",\\ (db+i) >attribute_handle, (db+i) >start_handle, (db+i) >end_handle, (db+i) >properties, (db+i) >uuid.uuid.uuid16); break; case ESP_GATT_DB_SECONDARY_SERVICE: ESP_LOGI(GATTC_TAG,\"attr_type SECONDARY_SERVICE,attribute_handle %d,start_handle %d,end_handle %d,properties 0x%x,uuid 0x%04x\\n\",\\ (db+i) >attribute_handle, (db+i) >start_handle, (db+i) >end_handle, (db+i) >properties, (db+i) >uuid.uuid.uuid16); break; case ESP_GATT_DB_CHARACTERISTIC: ESP_LOGI(GATTC_TAG,\"attr_type CHARACTERISTIC,attribute_handle %d,start_handle %d,end_handle %d,properties 0x%x,uuid 0x%04x\\n\",\\ (db+i) >attribute_handle, (db+i) >start_handle, (db+i) >end_handle, (db+i) >properties, (db+i) >uuid.uuid.uuid16); break; case ESP_GATT_DB_DESCRIPTOR: ESP_LOGI(GATTC_TAG,\"attr_type DESCRIPTOR,attribute_handle %d,start_handle %d,end_handle %d,properties 0x%x,uuid 0x%04x\\n\",\\ (db+i) >attribute_handle, (db+i) >start_handle, (db+i) >end_handle, (db+i) >properties, (db+i) >uuid.uuid.uuid16); break; case ESP_GATT_DB_INCLUDED_SERVICE: ESP_LOGI(GATTC_TAG,\"attr_type INCLUDED_SERVICE,attribute_handle %d,start_handle %d,end_handle %d,properties 0x%x,uuid 0x%04x\\n\",\\ (db+i) >attribute_handle, (db+i) >start_handle, (db+i) >end_handle, (db+i) >properties, (db+i) >uuid.uuid.uuid16); break; case ESP_GATT_DB_ALL: ESP_LOGI(GATTC_TAG,\"attr_type ESP_GATT_DB_ALL,attribute_handle %d,start_handle %d,end_handle %d,properties 0x%x,uuid 0x%04x\\n\",\\ (db+i) >attribute_handle, (db+i) >start_handle, (db+i) >end_handle, (db+i) >properties, (db+i) >uuid.uuid.uuid16); break; default: break; } } cmd SPP_IDX_SPP_DATA_NTY_VAL; xQueueSend(cmd_reg_queue, &cmd, 10/portTICK_PERIOD_MS); break; case ESP_GATTC_SRVC_CHG_EVT: break; default: break; } } ``` ### 属性表 ```c /** * @brief attribute auto response flag */ typedef struct { #define ESP_GATT_RSP_BY_APP 0 //手动回复 #define ESP_GATT_AUTO_RSP 1 //自动回复 /** * @brief if auto_rsp set to ESP_GATT_RSP_BY_APP, means the response of Write/Read operation will by replied by application. if auto_rsp set to ESP_GATT_AUTO_RSP, means the response of Write/Read operation will be replied by GATT stack automatically. */ uint8_t auto_rsp; } esp_attr_control_t; /** * @brief Attribute description (used to create database) */ typedef struct { uint16_t uuid_length; /*!< UUID length */ uint8_t *uuid_p; /*!< UUID value */ uint16_t perm; /*!< Attribute permission 权限*/ uint16_t max_length; /*!< Maximum length of the element value最大长度*/ uint16_t length; /*!< Current length of the element 当前的长度*/ uint8_t *value; /*!< Element value array 数据*/ } esp_attr_desc_t; /** * @brief attribute type added to the gatt server database */ typedef struct { esp_attr_control_t attr_control; /*!< The attribute control type */ esp_attr_desc_t att_desc; /*!< The attribute type */ } esp_gatts_attr_db_t; ///Full HRS Database Description Used to add attributes into the database //实际是一个数据库的特征声明 static const esp_gatts_attr_db_t spp_gatt_db[SPP_IDX_NB] { //SPP Service Declaration [SPP_IDX_SVC] \t { {ESP_GATT_AUTO_RSP}, //使用自动回复 {ESP_UUID_LEN_16, //UUID长度 (uint8_t *)&primary_service_uuid, //使用的UUID(实际是标记一个类型) ESP_GATT_PERM_READ, \t//有读权限 sizeof(spp_service_uuid), //两个长度 sizeof(spp_service_uuid), (uint8_t *)&spp_service_uuid //数据 } }, //SPP data receive characteristic Declaration 声明 [SPP_IDX_SPP_DATA_RECV_CHAR] {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_declaration_uuid, ESP_GATT_PERM_READ, CHAR_DECLARATION_SIZE,CHAR_DECLARATION_SIZE, (uint8_t *)&char_prop_read_write}}, //SPP data receive characteristic Value 值 [SPP_IDX_SPP_DATA_RECV_VAL] \t {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&spp_data_receive_uuid, ESP_GATT_PERM_READESP_GATT_PERM_WRITE, SPP_DATA_MAX_LEN,sizeof(spp_data_receive_val), (uint8_t *)spp_data_receive_val}}, //SPP data notify characteristic Declaration [SPP_IDX_SPP_DATA_NOTIFY_CHAR] {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_declaration_uuid, ESP_GATT_PERM_READ, CHAR_DECLARATION_SIZE,CHAR_DECLARATION_SIZE, (uint8_t *)&char_prop_read_notify}}, //SPP data notify characteristic Value [SPP_IDX_SPP_DATA_NTY_VAL] {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&spp_data_notify_uuid, ESP_GATT_PERM_READ, SPP_DATA_MAX_LEN, sizeof(spp_data_notify_val), (uint8_t *)spp_data_notify_val}}, //SPP data notify characteristic Client Characteristic Configuration Descriptor [SPP_IDX_SPP_DATA_NTF_CFG] {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_client_config_uuid, ESP_GATT_PERM_READESP_GATT_PERM_WRITE, sizeof(uint16_t),sizeof(spp_data_notify_ccc), (uint8_t *)spp_data_notify_ccc}}, //SPP command characteristic Declaration [SPP_IDX_SPP_COMMAND_CHAR] {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_declaration_uuid, ESP_GATT_PERM_READ, CHAR_DECLARATION_SIZE,CHAR_DECLARATION_SIZE, (uint8_t *)&char_prop_read_write}}, //SPP command characteristic Value [SPP_IDX_SPP_COMMAND_VAL] {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&spp_command_uuid, ESP_GATT_PERM_READESP_GATT_PERM_WRITE, SPP_CMD_MAX_LEN,sizeof(spp_command_val), (uint8_t *)spp_command_val}}, //SPP status characteristic Declaration [SPP_IDX_SPP_STATUS_CHAR] {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_declaration_uuid, ESP_GATT_PERM_READ, CHAR_DECLARATION_SIZE,CHAR_DECLARATION_SIZE, (uint8_t *)&char_prop_read_notify}}, //SPP status characteristic Value [SPP_IDX_SPP_STATUS_VAL] {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&spp_status_uuid, ESP_GATT_PERM_READ, SPP_STATUS_MAX_LEN,sizeof(spp_status_val), (uint8_t *)spp_status_val}}, //SPP status characteristic Client Characteristic Configuration Descriptor [SPP_IDX_SPP_STATUS_CFG] {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_client_config_uuid, ESP_GATT_PERM_READESP_GATT_PERM_WRITE, sizeof(uint16_t),sizeof(spp_status_ccc), (uint8_t *)spp_status_ccc}}, #ifdef SUPPORT_HEARTBEAT //心跳, 实际使用的时候需要实现一个类似的 0x2803是一个没有使用的UUID //SPP Heart beat characteristic Declaration [SPP_IDX_SPP_HEARTBEAT_CHAR] {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_declaration_uuid, ESP_GATT_PERM_READ, CHAR_DECLARATION_SIZE,CHAR_DECLARATION_SIZE, (uint8_t *)&char_prop_read_write_notify}}, //SPP Heart beat characteristic Value //使用0xABF5 [SPP_IDX_SPP_HEARTBEAT_VAL] {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&spp_heart_beat_uuid, ESP_GATT_PERM_READESP_GATT_PERM_WRITE, sizeof(spp_heart_beat_val), sizeof(spp_heart_beat_val), (uint8_t *)spp_heart_beat_val}}, //SPP Heart beat characteristic Client Characteristic Configuration Descriptor //客户端配置 0x2902 [SPP_IDX_SPP_HEARTBEAT_CFG] {{ESP_GATT_AUTO_RSP}, {ESP_UUID_LEN_16, (uint8_t *)&character_client_config_uuid, ESP_GATT_PERM_READESP_GATT_PERM_WRITE, sizeof(uint16_t),sizeof(spp_data_notify_ccc), (uint8_t *)spp_heart_beat_ccc}}, #endif }; //创建属性列表(重点!!!) ESP_LOGI(GATTS_TABLE_TAG, \"%s %d\\n\", __func__, __LINE__); esp_ble_gatts_create_attr_tab(spp_gatt_db, gatts_if, SPP_IDX_NB, SPP_SVC_INST_ID); ``` + 建立成功的处理函数 ```c case ESP_GATTS_CREAT_ATTR_TAB_EVT:{ //创建属性表的事件 ESP_LOGI(GATTS_TABLE_TAG, \"The number handle %x\\n\",param >add_attr_tab.num_handle); if (param >add_attr_tab.status ! ESP_GATT_OK){ ESP_LOGE(GATTS_TABLE_TAG, \"Create attribute table failed, error code 0x%x\", param >add_attr_tab.status); } else if (param >add_attr_tab.num_handle ! SPP_IDX_NB){ //判断创建的数据表的数量 ESP_LOGE(GATTS_TABLE_TAG, \"Create attribute table abnormally, num_handle (%d) doesn't equal to HRS_IDX_NB(%d)\", param >add_attr_tab.num_handle, SPP_IDX_NB); } else { //记录属性表 memcpy(spp_handle_table, param >add_attr_tab.handles, sizeof(spp_handle_table)); //开启服务 esp_ble_gatts_start_service(spp_handle_table[SPP_IDX_SVC]); } break; } ``` ## 实际使用 ### 服务器 + 服务器 1. 在注册表里面添加使用的属性, 包括属性的声明, 值和描述符 2. 可以使用esp_ble_gatts_get_attr_value获取本地的值 3. 在ESP_GATTS_WRITE_EVT事件里面获取要写入的值, 使用esp_ble_gatts_set_attr_value进行更新 ```c esp_ble_gatts_set_attr_value(p_data >write.handle,p_data >write.len,p_data >write.value) ``` 4. 完成写入以后会进入这一个ESP_GATTS_SET_ATTR_VAL_EVT事件里面 5. 可以使用esp_ble_gatts_send_indicate发送通知给客户端 ### 客户端 + 客户端读取 1. 在注册表里面添加自己的属性(下标, 描述符) 2. 连接以后可以使用esp_ble_gattc_read_char函数获取数据库里面的值 3. 在ESP_GATTC_READ_CHAR_EVT事件里面处理实际的读取 ```c //判断是否读取成功 if(p_data >read.status ESP_GATT_OK) { //判断属性句柄句柄 if(p_data >read.handle (db+TEST_LED_VAL) >attribute_handle)//判断一下读取的属性 { printf(\"read value %d,len %d\\r\\n\",*p_data >read.value,p_data >read.value_len); //记录通知状态 memcpy(&read_status,p_data >read.value,p_data >read.value_len); } } ``` + 客户端写入 1. 添加属性表属性 2. 使用esp_ble_gattc_write_char函数进行写入 + 注册通知 1. 使用esp_ble_gattc_register_for_notify注册通知, 绑定一个属性表的值 2. ESP_GATTC_REG_FOR_NOTIFY_EVT事件里面使用esp_ble_gattc_write_char_descr告诉服务器 3. ESP_GATTC_NOTIFY_EVT可以捕获到这一个属性表值的通知 ## API ### 注册通知 ```c esp_err_t esp_ble_gattc_register_for_notify(esp_gatt_if_t gattc_if, esp_bd_addr_t server_bda, uint16_t handle); ``` > 注册一个通知, 之后会调用回调函数里面的ESP_GATTC_REG_FOR_NOTIFY_EVT这一个回调函数 ### 发送一个值 ```c esp_err_t esp_ble_gattc_write_char_descr(esp_gatt_if_t gattc_if, uint16_t conn_id, uint16_t handle, uint16_t value_len, uint8_t *value, esp_gatt_write_type_t write_type, esp_gatt_auth_req_t auth_req); ``` > gattc_if: 使用的客户端的类型, 是回调函数的参数 > > conn_id: 连接的对方的id, 这一个数据是在连接的时候获取`spp_conn_id p_data >connect.conn_id;` > > handle: 操作的对象的句柄 > > value_len, value写入的数据 > > write_type: 需不需要远程响应`ESP_GATT_WRITE_TYPE_RSP\\_NO_RSP`, 示例使用后者 > > auth_req: 加密认证`ESP_GATT_AUTH_REQ_NONE` ### 最大传输单元设置 ```c esp_ble_gatt_set_local_mtu(200); //设置本地的最大传输单元 esp_err_t esp_ble_gattc_send_mtu_req(esp_gatt_if_t gattc_if, uint16_t conn_id);//交换数据, 需要在本地设置以后 ``` ### 开启GATT ```c esp_err_t esp_ble_gattc_open(esp_gatt_if_t gattc_if, esp_bd_addr_t remote_bda, esp_ble_addr_type_t remote_addr_type, bool is_direct) ``` > **gattc_if**: Gatt client access interface.注册的时候获取 > > remote_bda, remote_addr_type: 扫描的时候获取 > > is_direct: 直接连接还是后台连接, 使用true > > ESP_GATTC_CONNECT_EVT ### 注册回调函数 ```c esp_err_t esp_ble_gattc_register_callback(esp_gattc_cb_t callback); //在这里记录回调函数 esp_err_t esp_ble_gattc_app_register(uint16_t app_id); //实际用于这一个app_id ``` ### 获取服务 ```c esp_err_t esp_ble_gattc_search_service(esp_gatt_if_t gattc_if, uint16_t conn_id, esp_bt_uuid_t *filter_uuid); ``` > **gattc_if** **[in]** Gatt client access interface. gattc申请的id > **conn_id** **[in]** connection ID. 连接id > **filter_uuid** **[in]** a UUID of the service application is interested in. If Null, discover for all services. ### 获取数据库信息 ```c esp_gatt_status_t esp_ble_gattc_get_db(esp_gatt_if_t gattc_if, uint16_t conn_id, uint16_t start_handle, uint16_t end_handle, esp_gattc_db_elem_t *db, uint16_t *count) ``` > This function is called to get the GATT database. Note: It just get attribute data base from local cache, won't get from remote devices. > > db: 传出参数, 获取到的数据库 ### 注册一个通知 ```c esp_err_t esp_ble_gattc_register_for_notify(esp_gatt_if_t gattc_if, esp_bd_addr_t server_bda, uint16_t handle); ``` ### 服务器设置属性表的一个值 ```c esp_err_t esp_ble_gatts_set_attr_value(uint16_t attr_handle, uint16_t length, const uint8_t *value); ``` > 服务器使用, 之后会调用ESP_GATTS_SET_ATTR_VAL_EVT这一个事件的处理 设置的这一个属性值可以使用 ```c esp_gatt_status_t esp_ble_gatts_get_attr_value(uint16_t attr_handle, uint16_t *length, const uint8_t **value); ``` > 进行获取 > > attr_handle属性句柄 ### 客户端读取 ```c esp_err_t esp_ble_gattc_read_char(esp_gatt_if_t gattc_if, uint16_t conn_id, uint16_t handle, esp_gatt_auth_req_t auth_req); ``` > ```c > //读取特征值完成事件 > case ESP_GATTC_READ_CHAR_EVT: > ESP_LOGI(GATTC_TAG,\"ESP_GATTC_READ_CHAR_EVT\\n\"); > > #ifdef SUPPORT_LED > //判断是否读取成功 > if(p_data >read.status ESP_GATT_OK) > { > //判断属性句柄句柄 > if(p_data >read.handle (db+TEST_LED_VAL) >attribute_handle) > { > printf(\"read value %d,len %d\\r\\n\",*p_data >read.value,p_data >read.value_len); > //记录通知状态 > memcpy(&read_status,p_data >read.value,p_data >read.value_len); > } > > } > else > printf(\"read faild, status %d\\r\\n\",p_data >read.status); > > #endif > break; > ``` > > ### 服务器发通知 ```c esp_err_t esp_ble_gatts_send_indicate(esp_gatt_if_t gatts_if, uint16_t conn_id, uint16_t attr_handle, uint16_t value_len, uint8_t *value, bool need_confirm); ``` > 发送一指示或者通知给客户端 > > **need_confirm**: 1指示 0通知 > > 之后客户端会进入ESP_GATTC_NOTIFY_EVT这一个事件里面(需要注册这一个句柄的通知) 实现通知的时候, 需要自己手动调用 ### 客户端注册通知 ```c esp_err_t esp_ble_gattc_register_for_notify(esp_gatt_if_t gattc_if, esp_bd_addr_t server_bda, uint16_t handle); ``` 给某一个句柄注册一个通知, 之后就可以获这一个句柄的通知, 这一个注册的时候不会对服务端进行通知, 需要在ESP_GATTC_REG_FOR_NOTIFY_EVT里面自己通知"},"/note/嵌入式/esp32/esp-idf/2024-5-25-08触摸屏.html":{"title":"触摸屏","content":" layout: post title: \"触摸屏\" date: 2024 5 24 15:39:08 +0800 tags: esp32 ESP IDF # 触摸屏 [LCD ESP32 — ESP IDF 编程指南 v5.1 文档 (espressif.com)](https://docs.espressif.com/projects/esp idf/zh_CN/v5.1/esp32/api reference/peripherals/lcd.html#i2c lcd panel) 需要添加一下I2C的驱动, 在主函数进行初始化 ![image 20240525214058696](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405252140869.png) 添加一下这一个驱动使用的宏定义, 使用组建管理文件里面的方法进行添加他的驱动 ![image 20240525214252476](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405252142510.png) ```c #if CONFIG_EXAMPLE_LCD_TOUCH_ENABLED esp_lcd_panel_io_handle_t tp_io_handle NULL; esp_lcd_panel_io_i2c_config_t tp_io_config ESP_LCD_TOUCH_IO_I2C_FT5x06_CONFIG(); ESP_ERROR_CHECK(esp_lcd_new_panel_io_i2c((esp_lcd_spi_bus_handle_t)I2C_MASTER_NUM, &tp_io_config, &tp_io_handle)); esp_lcd_touch_config_t tp_cfg { .x_max EXAMPLE_LCD_H_RES, .y_max EXAMPLE_LCD_V_RES, .rst_gpio_num 1, .int_gpio_num 1, .flags { .swap_xy 0, .mirror_x 0, .mirror_y 0, }, }; #if CONFIG_EXAMPLE_LCD_TOUCH_CONTROLLER_STMPE610 ESP_LOGI(TAG, \"Initialize touch controller STMPE610\"); ESP_ERROR_CHECK(esp_lcd_touch_new_spi_stmpe610(tp_io_handle, &tp_cfg, &tp)); #if CONFIG_EXAMPLE_LCD_TOUCH_CONTROLLER_FT5x06 ESP_LOGI(TAG, \"Initialize touch controller FT6336\"); ESP_ERROR_CHECK(esp_lcd_touch_new_i2c_ft5x06(tp_io_handle, &tp_cfg, &tp)); #endif // CONFIG_EXAMPLE_LCD_TOUCH_CONTROLLER_STMPE610 #endif // CONFIG_EXAMPLE_LCD_TOUCH_ENABLED ```"},"/note/嵌入式/esp32/esp-idf/2024-5-23-02基础使用.html":{"title":"基础使用","content":" layout: post title: \"基础使用\" date: 2024 5 23 15:39:08 +0800 tags: esp32 ESP IDF # 基础使用 ## 配置芯片 ![image 20240523222949596](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405232229640.png) > 这一个是USB转串口 ## 具体的配置 ![image 20240523224143065](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405232241092.png) ![image 20240523223926210](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405232239268.png) ![image 20240523224129882](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405232241910.png) ## 命令行的使用 ![image 20240523224659338](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405232246388.png) ![image 20240523224846186](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405232248230.png) ```bash PS E:\\alearn\\EDP IDF 5.2\\Espressif\\frameworks\\esp idf v5.2.1> cd E:\\JHY\\esp32\\hello_world\\ PS E:\\JHY\\esp32\\hello_world> idf.py set target esp32 # 设置芯片 PS E:\\JHY\\esp32\\hello_world> idf.py menuconfig # 设置flash ``` > ![image 20240523225133788](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405232251840.png) > > ![image 20240523225212889](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405232252942.png) > > q: 退出 ```bash idf.py build # 编译 idf.py p COM7 flash #下载 idf.py p COM7 monitor # 打开终端 ``` > 可以使用Ctrl + ] 退出终端"},"/note/嵌入式/esp32/esp-idf/2024-6-13-17SMP安全配对绑定.html":{"title":"安全配对绑定","content":" layout: post title: \"安全配对绑定\" date: 2024 6 13 15:39:08 +0800 tags: esp32 ESP IDF # 安全配对绑定 实现这一个的时候实际还是依赖GATT和ATT的网络模型 ![image 20240613211938864](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406132119948.png) ![image 20240613212348867](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406132123935.png) ## 名词解释 **Paring（配对）**，配对包括配对能力交换，设备认证，密钥生成，连接加密以及机密信息分发等过程，配对的目的有三个：加密连接，认证设备，以及生成密钥。 **Bonding（绑定）**，配对过程中会生成一个长期密钥（LTK，long term Key），如果配对双方把这个LTK存储起来放在Flash中，那么这两个设备再次重连的时候，就可以跳过配对流程，而直接使用LTK对蓝牙连接进行加密，设备的这种状态称为bonding。如果paring过程中不存储LTK（不分发LTK）也是可以的，paring完成后连接也是加密的，但是如果两个设备再次重连，那么就需要重走一次paring流程，否则两者还是明文通信。在不引起误解的情况下，我们经常把paring当成paring和 bonding两者的组合，因为只paring不bonding的应用情况非常少见。在不引起混淆的情况下，下文就不区分paring和bonding的区别，换句话说，我们会把paring和bonding两个概念等同起来进行混用。 **SM（security manager）**，蓝牙协议栈的安全管理层，规定了跟蓝牙安全通信有关的所有要素，包括paring，bonding，以及下文提到的SMP。 **SMP（security manager protocol）**，安全管理协议，SMP着重两个设备之间的蓝牙交互命令序列，对paring的空中包进行了严格时序规定。 **OOB（out of band，带外）**，OOB就是不通过蓝牙射频本身来交互，而是通过比如人眼，NFC，UART等带外方式来交互配对信息，在这里人眼，NFC，UART通信方式就被称为OOB通信方式。 **Passkey（又称pin码）**，是指用户在键盘中输入的一串数字，以达到认证设备的目的。低功耗蓝牙的passkey必须为6位。 > 客户端(发起端)进行输入 **Numeric comparison（数字比较）**，numeric comparison其实跟passkey一样，也是用来认证设备的，只不过passkey是通过键盘输入的，而numeric comparison是显示在显示器上的，numericcomparison也必须是6位的数字。 > 直接显示一下, 手机弹出数字, 蓝牙设备输入这一个设备 **justwork**: 不进行认证, 直接进行连接 > 直接进行设备的连接 **MITM（man in the middle）**，MITM是指A和B通信过程中，C会插入进来以模拟A或者B，并且具备截获和篡改A和B之间所有通信报文的能力，从而达到让A或者B信任它，以至于错把C当成B或者A来通信。如果对安全要求比较高，需要具备MITM保护能力，在SM中这个是通过认证（authentication）来实现的，SM中实现认证的方式有三种：OOB认证信息，passkey以及numeric comparison，大家根据自己的实际情况，选择其中一种即可。 **LESC（LE security connections）** 新式配对，又称SC，蓝牙4.2引入的一种新的密钥生成方式和验证方式，SC通过基于椭圆曲线的Diffie Hellman密钥交换算法来生成设备A和B的共享密钥，此密钥生成过程中需要用到公私钥对，以及其他的密码算法库。LESC同时还规定了相应的通信协议以生成该密钥，并验证该密钥。需要注意的是LESC对paring的其他方面也会产生一定的影响，所以我们经常会把LESC看成是一种新的配对方式。 **Legacy paring 老式配对**，在LESC引入之前的密钥生成方式，称为legacy paring，换句话说，legacy paring是相对LESC来说的，不支持LESC的配对即为legacy paring（legacy配对）。 **TK（Temporary Key，临时密钥）**，legacy paring里面的概念，如果采用just work配对方式，TK就是为全0；如果采用passkey配对方式，TK就是passkey；如果采用OOB配对方式，TK就是OOB里面的信息。 **STK（short term key，短期密钥）**，legacy配对里面的概念，STK是通过TK推导出来的，通过TK对设备A和B的随机数进行加密，即得到STK。 **LTK（long term key，长期密钥）**，legacy配对和LESC配对都会用到LTK，如前所述，LTK是用来对未来的连接进行加密和解密用的。Legacy paring中的LTK由从设备根据相应的算法自己生成的（LTK生成过程中会用到EDIV（分散因子）和Rand（随机数）），然后通过蓝牙空中包传给主机。LESC配对过程中，先通过Diffie Hellman生成一个共享密钥，然后这个共享密钥再对设备A和B的蓝牙地址和随机数进行加密，从而得到LTK，LTK由设备A和B各自同时生成，因此LTK不会出现在LESC蓝牙空中包中，大大提高了蓝牙通信的安全性。 **IRK（Identity Resolving Key，蓝牙设备地址解析密钥）**，有些蓝牙设备的地址为可解析的随机地址，比如iPhone手机，由于他们的地址随着时间会变化，那如何确定这些变化的地址都来自同一个设备呢？答案就是IRK，IRK通过解析变化的地址的规律，从而确定这些地址是否来自同一个设备，换句话说，IRK可以用来识别蓝牙设备身份，因此其也称为Identity information。IRK一般由设备出厂的时候按照一定要求自动生成。 **Identity Address（设备唯一地址）**，蓝牙设备地址包括public，random static， privateresolvable，random unresolved共四类。如果设备不支持privacy，那么identity address就等于public或者random static设备地址。如果设备支持privacy，即使用private resolvable蓝牙设备地址，在这种情况下，虽然其地址每隔一段时间会变化一次，但是identity address仍然保持不变，其取值还是等于内在的public或者random static设备地址。Identity Address和IRK都可以用来唯一标识一个蓝牙设备。 **IO capabilities（输入输出能力）**，是指蓝牙设备的输入输出能力，比如是否有键盘，是否有显示器，是否可以输入Yes/No两个确认值。Key size（密钥长度），一般来说，密钥默认长度为16字节，为了适应一些低端的蓝牙设备处理 能力，你也可以把密钥长度调低，比如变为10个字节。 ## 认证要求 ![image 20240613215022096](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406132150142.png) ![image 20240613215122965](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406132151032.png) ![image 20240613220321001](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406132203057.png) > 使用OOB和MITM的区别是使用OOB的时候, 需要两端同时输入16位数字 > > 使用ESP32的MITM的时候是使用密钥的方式, 这里的检查实际是查看是不是设置了IO ![image 20240613220344639](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406132203695.png) ![image 20240613220512977](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406132205060.png) > 通过双方的IO配置设置实际的IO方式, 主要使用的是老式配对 > > (这一个数字比较好像不会触发) ## 实际实现 ![image 20240613221422664](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406132214738.png) > 主要是设置参数这一步是不同的 ![image 20240613221506128](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406132215199.png) ### 客户端 ![image 20240613221754270](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406132217319.png) > 主要认证是GAP层 ![image 20240613222105775](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406132221845.png) ### 服务端 ![image 20240613223030016](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406132230094.png) > 实际实现的时候需要实现 ### 实际实现 ### 实际参数设置 ```c /***************************************************************************/ /* set the security iocap & auth_req & key size & init key response key parameters to the stack*/ // 设置BOND的时候, 会记录连接, 下一次连接的时候跳过认证 //\tesp_ble_auth_req_t auth_req ESP_LE_AUTH_NO_BOND;\t\t\t//未启用绑定 //\tesp_ble_auth_req_t auth_req ESP_LE_AUTH_BOND;\t\t\t\t//启用绑定 //\tesp_ble_auth_req_t auth_req ESP_LE_AUTH_REQ_MITM;\t\t\t//开启MITM保护 //\tesp_ble_auth_req_t auth_req ESP_LE_AUTH_REQ_SC_ONLY;\t\t//未启用绑定的安全连接 //\tesp_ble_auth_req_t auth_req ESP_LE_AUTH_REQ_SC_BOND;\t\t//启用绑定后的安全连接 esp_ble_auth_req_t auth_req ESP_LE_AUTH_REQ_SC_MITM;\t\t//使用MITM保护和未启用连接的安全连接 // esp_ble_auth_req_t auth_req ESP_LE_AUTH_REQ_SC_MITM_BOND;\t //安全连接，启用MITM(中间人)保护和连接 //设置IO类型, 这一个类型会使得MITM认证的发生区别 // esp_ble_io_cap_t iocap ESP_IO_CAP_NONE; //NoInputNoOutput esp_ble_io_cap_t iocap ESP_IO_CAP_KBDISP;\t\t\t//Keyboard display //\tesp_ble_io_cap_t iocap ESP_IO_CAP_IO;\t\t\t\t//DisplayYesNo //\tesp_ble_io_cap_t iocap ESP_IO_CAP_OUT;\t\t\t//DisplayOnly //\tesp_ble_io_cap_t iocap ESP_IO_CAP_IN;\t\t\t\t//KeyboardOnly uint8_t key_size 16; //the key size should be 7~16 bytes //发起密钥, 长期密钥以及身份解析密钥 uint8_t init_key ESP_BLE_ENC_KEY_MASK ESP_BLE_ID_KEY_MASK; uint8_t rsp_key ESP_BLE_ENC_KEY_MASK ESP_BLE_ID_KEY_MASK; //set static passkey uint32_t passkey 123456; //密码 uint8_t auth_option ESP_BLE_ONLY_ACCEPT_SPECIFIED_AUTH_DISABLE; //\tuint8_t auth_option ESP_BLE_ONLY_ACCEPT_SPECIFIED_AUTH_ENABLE;\t\t\t//必须绑定才能开启 uint8_t oob_support ESP_BLE_OOB_DISABLE;\t\t\t//关闭OOB, 这时候使用其他的方式认证 //\tuint8_t oob_support ESP_BLE_OOB_ENABLE;\t\t\t//开启OOB //设置静态密钥, 密码是一个uint32_t的值 esp_ble_gap_set_security_param(ESP_BLE_SM_SET_STATIC_PASSKEY, &passkey, sizeof(uint32_t)); //设置认证要求 身份验证以后与对方设备绑定 esp_ble_gap_set_security_param(ESP_BLE_SM_AUTHEN_REQ_MODE, &auth_req, sizeof(uint8_t)); // 设置本地io的能力 esp_ble_gap_set_security_param(ESP_BLE_SM_IOCAP_MODE, &iocap, sizeof(uint8_t)); //设置加密密钥的长度(OOP) esp_ble_gap_set_security_param(ESP_BLE_SM_MAX_KEY_SIZE, &key_size, sizeof(uint8_t)); //关闭仅接受指定的SMP的身份验证的要求 esp_ble_gap_set_security_param(ESP_BLE_SM_ONLY_ACCEPT_SPECIFIED_SEC_AUTH, &auth_option, sizeof(uint8_t)); //关闭支持OOB esp_ble_gap_set_security_param(ESP_BLE_SM_OOB_SUPPORT, &oob_support, sizeof(uint8_t)); /* If your BLE device acts as a Slave, the init_key means you hope which types of key of the master should distribute to you, and the response key means which key you can distribute to the master; If your BLE device acts as a master, the response key means you hope which types of key of the slave should distribute to you, and the init key means which key you can distribute to the slave. */ //设置密钥类型 esp_ble_gap_set_security_param(ESP_BLE_SM_SET_INIT_KEY, &init_key, sizeof(uint8_t)); esp_ble_gap_set_security_param(ESP_BLE_SM_SET_RSP_KEY, &rsp_key, sizeof(uint8_t)); ``` ```c //数字比较事件 安全配对的模式下面才有, 具体的设备需要看两方的输入输出 case ESP_GAP_BLE_NC_REQ_EVT: /* The app will receive this evt when the IO has DisplayYesNO capability and the peer device IO also has DisplayYesNo capability. show the passkey number to the user to confirm it with the number displayed by peer device. */ esp_ble_confirm_reply(param >ble_security.ble_req.bd_addr, true); ESP_LOGI(GATTS_TABLE_TAG, \"ESP_GAP_BLE_NC_REQ_EVT, the passkey Notify number:%d\", (int)param >ble_security.key_notif.passkey); count_printf(\"ESP_GAP_BLE_NC_REQ_EVT\"); break; //安全请求 case ESP_GAP_BLE_SEC_REQ_EVT: /* send the positive(true) security response to the peer device to accept the security request. If not accept the security request, should send the security response with negative(false) accept value*/ esp_ble_gap_security_rsp(param >ble_security.ble_req.bd_addr, true); count_printf(\"ESP_GAP_BLE_SEC_REQ_EVT\"); break; //密钥显示通知 case ESP_GAP_BLE_PASSKEY_NOTIF_EVT: ///the app will receive this evt when the IO has Output capability and the peer device IO has Input capability. ///show the passkey number to the user to input it in the peer device. ESP_LOGI(GATTS_TABLE_TAG, \"The passkey Notify number:%06d\", (int)param >ble_security.key_notif.passkey); count_printf(\"ESP_GAP_BLE_PASSKEY_NOTIF_EVT\"); break; //对方设备密钥 case ESP_GAP_BLE_KEY_EVT: //shows the ble key info share with peer device to the user. ESP_LOGI(GATTS_TABLE_TAG, \"key type %s\", esp_key_type_to_str(param >ble_security.ble_key.key_type)); count_printf(\"ESP_GAP_BLE_KEY_EVT\"); break; //认证完成 case ESP_GAP_BLE_AUTH_CMPL_EVT: { esp_bd_addr_t bd_addr; //记录一下地址 memcpy(bd_addr, param >ble_security.auth_cmpl.bd_addr, sizeof(esp_bd_addr_t)); ESP_LOGI(GATTS_TABLE_TAG, \"remote BD_ADDR: %08x%04x\",\\ (bd_addr[0] << 24) + (bd_addr[1] << 16) + (bd_addr[2] << 8) + bd_addr[3], (bd_addr[4] << 8) + bd_addr[5]); ESP_LOGI(GATTS_TABLE_TAG, \"address type %d\", param >ble_security.auth_cmpl.addr_type); ESP_LOGI(GATTS_TABLE_TAG, \"pair status %s\",param >ble_security.auth_cmpl.success ? \"success\" : \"fail\"); if(!param >ble_security.auth_cmpl.success) { ESP_LOGI(GATTS_TABLE_TAG, \"fail reason 0x%x\",param >ble_security.auth_cmpl.fail_reason); } else { ESP_LOGI(GATTS_TABLE_TAG, \"auth mode %s\",esp_auth_req_to_str(param >ble_security.auth_cmpl.auth_mode)); } //显示绑定的设备的id show_bonded_devices(); //\t\tremove_all_bonded_devices(); count_printf(\"ESP_GAP_BLE_AUTH_CMPL_EVT\"); break; } case ESP_GAP_BLE_REMOVE_BOND_DEV_COMPLETE_EVT: { ESP_LOGD(GATTS_TABLE_TAG, \"ESP_GAP_BLE_REMOVE_BOND_DEV_COMPLETE_EVT status %d\", param >remove_bond_dev_cmpl.status); ESP_LOGI(GATTS_TABLE_TAG, \"ESP_GAP_BLE_REMOVE_BOND_DEV\"); ESP_LOGI(GATTS_TABLE_TAG, \" ESP_GAP_BLE_REMOVE_BOND_DEV \"); esp_log_buffer_hex(GATTS_TABLE_TAG, (void *)param >remove_bond_dev_cmpl.bd_addr, sizeof(esp_bd_addr_t)); ESP_LOGI(GATTS_TABLE_TAG, \" \"); count_printf(\"ESP_GAP_BLE_REMOVE_BOND_DEV_COMPLETE_EVT\"); break; } case ESP_GAP_BLE_SET_LOCAL_PRIVACY_COMPLETE_EVT: if (param >local_privacy_cmpl.status ! ESP_BT_STATUS_SUCCESS){ ESP_LOGE(GATTS_TABLE_TAG, \"config local privacy failed, error status %x\", param >local_privacy_cmpl.status); break; } esp_err_t ret esp_ble_gap_config_adv_data(&heart_rate_adv_config); if (ret){ ESP_LOGE(GATTS_TABLE_TAG, \"config adv data failed, error code %x\", ret); }else{ adv_config_done ADV_CONFIG_FLAG; } ret esp_ble_gap_config_adv_data(&heart_rate_scan_rsp_config); if (ret){ ESP_LOGE(GATTS_TABLE_TAG, \"config adv data failed, error code %x\", ret); }else{ adv_config_done SCAN_RSP_CONFIG_FLAG; } count_printf(\"ESP_GAP_BLE_SET_LOCAL_PRIVACY_COMPLETE_EVT\"); break; ``` ```c case ESP_GATTS_CONNECT_EVT: ESP_LOGI(GATTS_TABLE_TAG, \"ESP_GATTS_CONNECT_EVT\"); /* start security connect with peer device when receive the connect event sent by the master */ //接收到客户端连接 启动对等的安全连接 //传参影响是否使用esp_ble_gap_set_security_param 函数的确认类型 //esp_ble_set_encryption(param >connect.remote_bda, ESP_BLE_SEC_ENCRYPT_MITM);\t\t//使用MITM，且不管安全参数函数配置 //esp_ble_set_encryption(param >connect.remote_bda, ESP_BLE_SEC_ENCRYPT_NO_MITM); //不使用MITM，且不管安全参数函数配置 esp_ble_set_encryption(param >connect.remote_bda, ESP_BLE_SEC_ENCRYPT);\t//再次交换密钥 //拷贝对方设备地址 memcpy(dev_addr,param >connect.remote_bda,sizeof(esp_bd_addr_t)); count_printf(\"ESP_GATTS_CONNECT_EVT\"); break; ``` ### 参数 #### 安全模式 ```c ESP_LE_AUTH_NO_BOND：不进行绑定 ESP_LE_AUTH_BOND：设备与对等体进行绑定 ESP_LE_AUTH_REQ_MITM：需要进行中间人攻击验证 ESP_LE_AUTH_REQ_BOND_MITM：需要进行绑定和中间人攻击验证 ESP_LE_AUTH_REQ_SC_ONLY：仅使用安全连接 ESP_LE_AUTH_REQ_SC_BOND：需要进行绑定并使用安全连接 ESP_LE_AUTH_REQ_SC_MITM：需要进行中间人攻击验证并使用安全连接 ESP_LE_AUTH_REQ_SC_MITM_BOND：需要进行绑定、中间人攻击验证和使用安全连接 ``` > 这里连接的时候使用ESP_LE_AUTH_BOND即可, 会记录连接的信息, 使用SC和MITM会增加一个认证的过程 #### 设备 ```c ESP_IO_CAP_OUT：表示设备只能在显示设备上显示信息，但没有输入能力。在BTM_IO_CAP_xxx中对应的是DisplayOnly。 ESP_IO_CAP_IO：表示设备既能在显示设备上显示信息，又能进行确认操作（Yes/No）。在BTM_IO_CAP_xxx中对应的是DisplayYesNo。 ESP_IO_CAP_IN：表示设备只能进行键盘输入操作，但没有显示能力。在BTM_IO_CAP_xxx中对应的是KeyboardOnly。 ESP_IO_CAP_NONE：表示设备既没有显示能力，也没有输入能力。在BTM_IO_CAP_xxx中对应的是NoInputNoOutput。 ESP_IO_CAP_KBDISP：表示设备同时具有键盘输入和显示功能。在BTM_IO_CAP_xxx中对应的是KeyboardDisplay。 ``` > ESP_IO_CAP_NONE可以实现最简单的连接方式"},"/note/嵌入式/esp32/esp-idf/2024-6-6-11HTTP库.html":{"title":"HTTP库","content":" layout: post title: \"HTTP库\" date: 2024 5 24 15:39:08 +0800 tags: esp32 ESP IDF # HTTP库 ### HTTP server库 ### 基础使用 用于从 ESP IDF 应用程序中发起 HTTP/S 请求 首先调用 [`esp_http_client_init()`](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/protocols/esp_http_client.html#_CPPv420esp_http_client_initPK24esp_http_client_config_t)，创建一个 [`esp_http_client_handle_t`](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/protocols/esp_http_client.html#_CPPv424esp_http_client_handle_t) 实例，即基于给定的 [`esp_http_client_config_t`](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/protocols/esp_http_client.html#_CPPv424esp_http_client_config_t) 配置创建 HTTP 客户端句柄。此函数必须第一个被调用。若用户未明确定义参数的配置值，则使用默认值。 ```c esp_http_client_handle_t esp_http_client_init(const esp_http_client_config_t *config); ``` 其次调用 [`esp_http_client_perform()`](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/protocols/esp_http_client.html#_CPPv423esp_http_client_perform24esp_http_client_handle_t)，执行 `esp_http_client` 的所有操作，包括打开连接、交换数据、关闭连接（如需要），同时在当前任务完成前阻塞该任务。所有相关的事件（在 [`esp_http_client_config_t`](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/protocols/esp_http_client.html#_CPPv424esp_http_client_config_t) 中指定）将通过事件处理程序被调用。 > esp_http_client_open > esp_http_client_write > esp_http_client_fetch_headers > esp_http_client_read (and option) esp_http_client_close > > ```c > esp_err_t esp_http_client_perform(esp_http_client_handle_t client); > ``` 最后调用 [`esp_http_client_cleanup()`](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/protocols/esp_http_client.html#_CPPv423esp_http_client_cleanup24esp_http_client_handle_t) 来关闭连接（如有），并释放所有分配给 HTTP 客户端实例的内存。此函数必须在操作完成后最后一个被调用。 ```c char local_response_buffer[MAX_HTTP_OUTPUT_BUFFER] {0}; int https_status 0; int64_t gzip_len 0; memset(dstBuf, 0, 1024); esp_http_client_config_t config { .url \"https://devapi.qweather.com/v7/weather/now?location 101010100&key 7be28a7cc429438abf4f1d5feeb9c910\", .event_handler _http_event_handler, //事件处理回调函数 .crt_bundle_attach esp_crt_bundle_attach, .user_data local_response_buffer, // Pass address of local buffer to get response }; //基础配置 esp_http_client_handle_t client esp_http_client_init(&config); esp_err_t err esp_http_client_perform(client); //获取信息 https_status esp_http_client_get_status_code(client); gzip_len esp_http_client_get_content_length(client); if (err ESP_OK) { ESP_LOGI(TAG, \"HTTPS Status %d, content_length %\"PRIu64, https_status, gzip_len); } else { ESP_LOGE(TAG, \"Error perform http request %s\", esp_err_to_name(err)); } esp_http_client_cleanup(client); ``` ### 设置post数据 ```c esp_err_t esp_http_client_set_post_field(esp_http_client_handle_t client, const char *data, int len); int esp_http_client_get_post_field(esp_http_client_handle_t client, char **data); ``` > 通过post方式请求的数据，传入发送数据的缓存地址与长度，必须在`esp_http_client_perform`之前调用 ### 设置header ```c esp_err_t esp_http_client_set_header(esp_http_client_handle_t client, const char *key, const char *value); esp_err_t esp_http_client_get_header(esp_http_client_handle_t client, const char *key, char **value); esp_err_t esp_http_client_delete_header(esp_http_client_handle_t client, const char *key); ``` > 设置、获取、删除请求头，可新增、删除或根据应用发送的数据类型来自定义请求文件类型来修改请求头 > > esp_http_client_set_header(client, \"HeaderKey\", \"HeaderValue\"); ### 请求方式 ```c //请求方式枚举 typedef enum { HTTP_METHOD_GET 0, /*!< HTTP GET Method */ HTTP_METHOD_POST, /*!< HTTP POST Method */ HTTP_METHOD_PUT, /*!< HTTP PUT Method */ HTTP_METHOD_PATCH, /*!< HTTP PATCH Method */ HTTP_METHOD_DELETE, /*!< HTTP DELETE Method */ HTTP_METHOD_HEAD, /*!< HTTP HEAD Method */ HTTP_METHOD_NOTIFY, /*!< HTTP NOTIFY Method */ HTTP_METHOD_SUBSCRIBE, /*!< HTTP SUBSCRIBE Method */ HTTP_METHOD_UNSUBSCRIBE,/*!< HTTP UNSUBSCRIBE Method */ HTTP_METHOD_OPTIONS, /*!< HTTP OPTIONS Method */ HTTP_METHOD_COPY, /*!< HTTP COPY Method */ HTTP_METHOD_MOVE, /*!< HTTP MOVE Method */ HTTP_METHOD_LOCK, /*!< HTTP LOCK Method */ HTTP_METHOD_UNLOCK, /*!< HTTP UNLOCK Method */ HTTP_METHOD_PROPFIND, /*!< HTTP PROPFIND Method */ HTTP_METHOD_PROPPATCH, /*!< HTTP PROPPATCH Method */ HTTP_METHOD_MKCOL, /*!< HTTP MKCOL Method */ HTTP_METHOD_MAX, } esp_http_client_method_t; esp_http_client_set_method(client, HTTP_METHOD_GET);//GET请求 ``` ## HTTP事件 ```c /** * @brief HTTP configuration */ typedef struct { const char *url; //url请求接口必须配置 /*!< HTTP URL, the information on the URL is most important, it overrides the other fields below, if any */ const char *host; //服务器域名或ip地址 /*!< Domain or IP as string */ int port; //端口 http默认80 https 默认443 /*!< Port to connect, default depend on esp_http_client_transport_t (80 or 443) */ const char *username; //用户名，认证使用 /*!< Using for Http authentication */ const char *password; //用户密码，认证使用 /*!< Using for Http authentication */ esp_http_client_auth_type_t auth_type; //认证方式 /*!< Http authentication type, see `esp_http_client_auth_type_t` */ const char *path; //路径 /*!< HTTP Path, if not set, default is `/` */ const char *query; //请求参数 /*!< HTTP query */ const char *cert_pem; //证书 /*!< SSL server certification, PEM format as string, if the client requires to verify server */ const char *client_cert_pem; /*!< SSL client certification, PEM format as string, if the server requires to verify client */ const char *client_key_pem; /*!< SSL client key, PEM format as string, if the server requires to verify client */ esp_http_client_method_t method; //请求方式 post get /*!< HTTP Method */ int timeout_ms; //请求超时 /*!< Network timeout in milliseconds */ bool disable_auto_redirect; /*!< Disable HTTP automatic redirects */ int max_redirection_count; /*!< Max number of redirections on receiving HTTP redirect status code, using default value if zero*/ int max_authorization_retries; /*!< Max connection retries on receiving HTTP unauthorized status code, using default value if zero. Disables authorization retry if 1*/ http_event_handle_cb event_handler; //可注册回调 /*!< HTTP Event Handle */ esp_http_client_transport_t transport_type; // 传输方式 tcp ssl /*!< HTTP transport type, see `esp_http_client_transport_t` */ int buffer_size; //接收缓存大小 /*!< HTTP receive buffer size */ int buffer_size_tx; //发送缓存大小 /*!< HTTP transmit buffer size */ void *user_data; //http用户数据 /*!< HTTP user_data context */ bool is_async; //同步模式 /*!< Set asynchronous mode, only supported with HTTPS for now */ bool use_global_ca_store; /*!< Use a global ca_store for all the connections in which this bool is set. */ bool skip_cert_common_name_check; //跳过证书 /*!< Skip any validation of server certificate CN field */ } esp_http_client_config_t; ``` > 这些事件可以使用事件处理回调函数进行处理, 这些回调函数的默认数据类型如下 > > HTTP_EVENT_ERROR : esp_http_client_handle_t > > HTTP_EVENT_ON_CONNECTED : esp_http_client_handle_t > > HTTP_EVENT_HEADERS_SENT : esp_http_client_handle_t > > HTTP_EVENT_ON_HEADER : esp_http_client_handle_t > > HTTP_EVENT_ON_DATA : esp_http_client_on_data_t > > HTTP_EVENT_ON_FINISH : esp_http_client_handle_t > > HTTP_EVENT_DISCONNECTED : esp_http_client_handle_t > > HTTP_EVENT_REDIRECT : esp_http_client_redirect_event_data_t ```c //事件回调 static esp_err_t _http_event_handle(esp_http_client_event_t *evt) { switch(evt >event_id) { case HTTP_EVENT_ERROR://错误事件 ESP_LOGI(TAG, \"HTTP_EVENT_ERROR\"); break; case HTTP_EVENT_ON_CONNECTED://连接成功事件 ESP_LOGI(TAG, \"HTTP_EVENT_ON_CONNECTED\"); break; case HTTP_EVENT_HEADER_SENT://发送头事件 ESP_LOGI(TAG, \"HTTP_EVENT_HEADER_SENT\"); break; case HTTP_EVENT_ON_HEADER://接收头事件 ESP_LOGI(TAG, \"HTTP_EVENT_ON_HEADER\"); printf(\"%.*s\", evt >data_len, (char*)evt >data); break; case HTTP_EVENT_ON_DATA://接收数据事件 ESP_LOGI(TAG, \"HTTP_EVENT_ON_DATA, len %d\", evt >data_len); if (!esp_http_client_is_chunked_response(evt >client)) { printf(\"%.*s\", evt >data_len, (char*)evt >data); } break; case HTTP_EVENT_ON_FINISH://会话完成事件 ESP_LOGI(TAG, \"HTTP_EVENT_ON_FINISH\"); break; case HTTP_EVENT_DISCONNECTED://断开事件 ESP_LOGI(TAG, \"HTTP_EVENT_DISCONNECTED\"); break; } return ESP_OK; } ``` > ```c > esp_http_client_config_t config { > \t.method HTTP_METHOD_GET, //get请求 > \t.url \"https://www.baidu.com/\", //请求url > \t.event_handler _http_event_handle,//注册时间回调 > }; > ``` > > 在init 的时候设置回调函数 ## 配置结构体 ```c /** * @brief HTTP configuration */ typedef struct { const char *url; /*!< HTTP URL, the information on the URL is most important, it overrides the other fields below, if any 网址*/ const char *host; /*!< Domain or IP as string ip地址*/ int port; /*!< Port to connect, default depend on esp_http_client_transport_t (80 or 443) 端口*/ const char *username; /*!< Using for Http authentication */ const char *password; /*!< Using for Http authentication */ esp_http_client_auth_type_t auth_type; /*!< Http authentication type, see \t\t\t\t\t\t\t\t\t\t`esp_http_client_auth_type_t` */ const char *path; /*!< HTTP Path, if not set, default is `/` */ const char *query; /*!< HTTP query 参数*/ const char *cert_pem; /*!< SSL server certification, PEM format as string, if the client requires to verify server */ size_t cert_len; /*!< Length of the buffer pointed to by cert_pem. May be 0 for null terminated pem */ const char *client_cert_pem; /*!< SSL client certification, PEM format as string, if the server requires to verify client */ size_t client_cert_len; /*!< Length of the buffer pointed to by client_cert_pem. May be 0 for null terminated pem */ const char *client_key_pem; /*!< SSL client key, PEM format as string, if the server requires to verify client */ size_t client_key_len; /*!< Length of the buffer pointed to by client_key_pem. May be 0 for null terminated pem */ const char *client_key_password; /*!< Client key decryption password string */ size_t client_key_password_len; /*!< String length of the password pointed to by client_key_password */ #ifdef CONFIG_MBEDTLS_HARDWARE_ECDSA_SIGN bool use_ecdsa_peripheral; /*!< Use ECDSA peripheral to use private key. */ uint8_t ecdsa_key_efuse_blk; /*!< The efuse block where ECDSA key is stored. */ #endif const char *user_agent; /*!< The User Agent string to send with HTTP requests */ esp_http_client_method_t method; /*!< HTTP Method */ int timeout_ms; /*!< Network timeout in milliseconds */ bool disable_auto_redirect; /*!< Disable HTTP automatic redirects */ int max_redirection_count; /*!< Max number of redirections on receiving HTTP redirect status code, using default value if zero*/ int max_authorization_retries; /*!< Max connection retries on receiving HTTP unauthorized status code, using default value if zero. Disables authorization retry if 1*/ http_event_handle_cb event_handler; /*!< HTTP Event Handle事件处理函数*/ esp_http_client_transport_t transport_type; /*!< HTTP transport type, see `esp_http_client_transport_t` */ int buffer_size; /*!< HTTP receive buffer size */ int buffer_size_tx; /*!< HTTP transmit buffer size */ void *user_data; /*!< HTTP user_data context 获取的信息*/ bool is_async; /*!< Set asynchronous mode, only supported with HTTPS for now */ bool use_global_ca_store; /*!< Use a global ca_store for all the connections in which this bool is set. */ bool skip_cert_common_name_check; /*!< Skip any validation of server certificate CN field */ const char *common_name; /*!< Pointer to the string containing server certificate common name. If non NULL, server certificate CN must match this name, If NULL, server certificate CN must match hostname. */ esp_err_t (*crt_bundle_attach)(void *conf); /*!< Function pointer to esp_crt_bundle_attach. Enables the use of certification bundle for server verification, must be enabled in menuconfig */ bool keep_alive_enable; /*!< Enable keep alive timeout */ int keep_alive_idle; /*!< Keep alive idle time. Default is 5 (second) */ int keep_alive_interval; /*!< Keep alive interval time. Default is 5 (second) */ int keep_alive_count; /*!< Keep alive packet retry send count. Default is 3 counts */ struct ifreq *if_name; /*!< The name of interface for data to go through. Use the default interface without setting */ #if CONFIG_ESP_TLS_USE_SECURE_ELEMENT bool use_secure_element; /*!< Enable this option to use secure element */ #endif #if CONFIG_ESP_TLS_USE_DS_PERIPHERAL void *ds_data; /*!< Pointer for digital signature peripheral context, see ESP TLS Documentation for more details */ #endif } esp_http_client_config_t; ``` ## HTTP server实现 这是个在的项目基础上面添 ```c #include <esp_http_server.h> http_config_t config HTTPD_DEFAULT_CONFIG(); httpd_start httpd_register_uri_handler httpd_stop ``` ```c //两个网页 const char mainpage[] \"<!DOCTYPE html>\\r\\n<html lang \\\"en\\\">\\r\\n<head>\\r\\n<meta charset \\\"UTF 8\\\">\\r\\n<meta name \\\"viewport\\\" content \\\"width device width, initial scale 1.0\\\">\\r\\n<title>你好</title>\\r\\n</head>\\r\\n<body>\\r\\n<div style \\\"text align: center;\\\">\\r\\n<h1>你好page1</h1>\\r\\n<hr size 3>\\r\\n<a href \\\"index.html\\\">Back To Homepage</a>\\r\\n</div>\\r\\n</body>\\r\\n</html>\\r\\n\"; const char mainpage2[] \"<!DOCTYPE html>\\r\\n<html lang \\\"en\\\">\\r\\n<head>\\r\\n<meta charset \\\"UTF 8\\\">\\r\\n<meta name \\\"viewport\\\" content \\\"width device width, initial scale 1.0\\\">\\r\\n<title>你好</title>\\r\\n</head>\\r\\n<body>\\r\\n<div style \\\"text align: center;\\\">\\r\\n<h1>你好page2</h1>\\r\\n<hr size 3>\\r\\n<a href \\\"index.html\\\">Back To Homepage</a>\\r\\n</div>\\r\\n</body>\\r\\n</html>\\r\\n\"; esp_err_t get_handler(httpd_req_t *req){ httpd_resp_send(req, mainpage, HTTPD_RESP_USE_STRLEN); return ESP_OK; } esp_err_t post_handler(httpd_req_t *req){ //获取数据 char content[100]; int totallen req >content_len; size_t recv_size MIN(req >content_len, sizeof(content)); int len 0; do{ len httpd_req_recv(req, content, recv_size); totallen len; printf(\"%s\\n\", content); }while(totallen > 0); //回复数据 httpd_resp_send(req, mainpage2, strlen(mainpage2)); return ESP_OK; } //网页设置 httpd_uri_t uri_get { .uri \"geturl\", .method HTTP_GET, //处理的信号 .handler get_handler, //处理的函数 .user_ctx NULL }; httpd_uri_t uri_post { .uri \"posturl\", .method HTTP_POST, .handler post_handler, .user_ctx NULL }; httpd_handle_t server_handler(void){ //初始化 httpd_config_t config HTTPD_DEFAULT_CONFIG(); httpd_handle_t server NULL; if(httpd_start(&server, &config) ESP_OK){ //注册两个网页 httpd_register_uri_handler(server, &uri_get); httpd_register_uri_handler(server, &uri_post); } return server; } ``` ![image 20240608232531346](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406082325423.png) ## HTTP client实现 ### 域名转IP函数 ```c #incldue \"lwip/netdb.h\" getaddrinfo ```"},"/note/嵌入式/esp32/esp-idf/2024-6-13-15蓝牙GAP.html":{"title":"蓝牙GAP","content":" layout: post title: \"蓝牙GAP\" date: 2024 6 13 15:39:08 +0800 tags: esp32 ESP IDF # 蓝牙GAP + 广播者: 通过发送数据让接受者发现自己, 只可以发送信息不可以被连接 + 观察者: 接收发送的请求, 不可以被连接 + 外围设备: 广播者接收观察者的信息以后会进入这一种, 作为从设备通信 + 中央设备: 当观察者主动进⾏初始化，并建⽴⼀个物理链路时就会进⼊这 种⻆⾊。这种⻆⾊在链路中同样被称为主设备 ![image 20240624101046145](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406241010267.png) ## beacon(灯塔)信标广播(GAP) [GAP API ESP32 — ESP IDF 编程指南 v5.1.4 文档 (espressif.com)](https://docs.espressif.com/projects/esp idf/zh_CN/v5.1.4/esp32/api reference/bluetooth/esp_gap_ble.html) > 蓝牙中的GAP指的是“Generic Access Profile”，是蓝牙协议栈中的一个重要部分。它定义了蓝牙设备的广播格式、连接建立和断开、设备发现、连接参数等方面的规范。通过GAP，不同类型的蓝牙设备能够互相通信和交互。 Beacon 设备作为蓝牙低功耗协议中的外围设备，持续向周围广播包含设备标识的特定数据包，但不能和中心设备建立连接。小程序运行的设备作为中心设备，可以收到 Beacon 设备的广播包，实现数据交互。常用于室内定位、消息推送等场景 这是一个蓝牙广播的标准, 不是蓝牙技术联盟提出来的标准, 可以从云端获取咨询吗然后进行广播, 周围的用户可以接收 > 网络侧定位: 在室内有多个探针, 发送出去的数据有一个距离参数, 通过计算衰减可以获取设备的位置 而**Eddystone**是**谷歌**公司制定的标准。Eddystone相对于iBeacon功能更为广泛，可以广播自定义唯一的信标ID（UID）、广播网址（URL）、广播自身数据（TLM/ETLM）、加密的临时标识符（EID）。 > 这一个是beacon信标的其中一种, 还有苹果的iBeacon等 [ESP32S3蓝牙学习系列 Beacon信标之Eddystone CSDN博客](https://blog.csdn.net/yplwrt/article/details/129107710) 可以广播四种帧格式 + UID: 最高有128位, 实际使用的时候16 32位就可以了, 广播自定义的唯一信标ID + URL: 网络地址 + TLM/ETLM 自身数据(E代表加密) + EID: 加密的临时标识符, 用于保密等 > UUID: 通用唯一标识符 > > 最高可以有128bit, 一般使用16或者32位就可以了\t > > 这一个ID里面有公司, 对象特征值类型, 属性类型声明, 属性特征描述符, 属性服务, 计量单位, 协助标识符, 标准开发组织, 服务规范ID ### 广播数据包 ![image 20240610102609584](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406101026657.png) > + 4个字节固定值 > > 0x8e89bed6 > > > 接入地址有两种类型：广播接入地址和数据接入地址。 > > > > 广播接入地址：固定为0x8E89BED6，在广播、扫描、发起连接时使用 > > > > 数据接入地址：随机值，不同的连接有不同的值，在连接建立后两个设备间使用。 > > + Header头 > > 有两种, 第一种是一些类型, 使用bit6, bit7记录发送的信息是公开的(0)还是随机的(1) > > 第二种是一个长度, 这一个长度记录的是数据不包括CRC校验的长度 > > + 数据 > > 最少是6字节, 记录自己的地址, 之后是实际的数据, 这里的数据是很多AD结构构成的 ![image 20240610102638669](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406101026742.png) > 这个Flag是数据的第一种类型的数据实际格式 ### Eddystone数据包 实际就是上面的一组数据包 ![image 20240610102810263](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406101028453.png) > 第一个数据包格式 > > ![image 20240610215030490](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406102150561.png) > > 第一个数据对应的是这一个, 只有第三位置1 > 第二个数据包![image 20240610215202175](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406102152221.png) > > 这一个ID是谷歌公司的ID > ![image 20240610215311534](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406102153579.png) > > 数据有四种 > > 这时候发送的功率会在对方接收以后计算距离使用 > > UID > 这是由三个字段组成的主要Eddystone框架，即命名空间标识符（10byte），实例标识符（6byte）和功率校准（1byte）。他将有助于将字段直接配置到BLE信标中，实例标识符旨在唯一地表示一个信标，因为他们具有不同的实例ID，功率校准字段用于根据RSSI帮助计算移动设备和Eddystone信标之间的距离。 > URL > 该框架的主要目的是提供一种传输URL的方法，以便蓝牙低功耗扫描仪设备检测和发现它，然后BLE设备将连接收到并为用户显示正确的网页。BLE信标发送Eddystone URL资源，智能手机等移动设备在检测到信标数据后立即在浏览器中自动打开网址。同时该框架提供类似于Eddystone UID的功率校准功能。 > TLM > Eddystone TML 框架的主要是提供关于Eddystone的健康状况的完整报告。当前温度, 当前电池电量, 正常运行时间 (信标已通电的秒数), 和 PduCount (信标在最后一次供电后部署的广告数据包的数量). > EID > 这是负责小工具安全和隐私的框架。 ### 示例代码 #### 接收数据 使用的时候eddystone的数据格式需要自己准备, eddystone的数据解码是这一个示例里面的用户空间里面实现的![image 20240610223305298](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406102233382.png) ```c esp_ble_gap_set_scan_params(&ble_scan_params); //使用这一个函数设置扫描 esp_ble_gap_start_scanning(duration);//开启扫描,在回调函数的配置成功的时候开启 ``` ```c #ifndef\t_EDDYSTONE_PACKET_H #define\t_EDDYSTONE_PACKET_H #include <stddef.h> #define EDDYSTONE_UID\t0x00 #define EDDYSTONE_URL\t0x10 #define EDDYSTONE_TLM\t0x20 #define CONV32(v,a)\t\t(v ((a)&0xff) << 24 ((a)&0xff00) << 8 ((a)&0xff0000) >> 8 ((a)&0xff000000)>>24) #define CONV16(v,a)\t\t(v ((a)&0xff) << 8 ((a)&0xff00) >> 8) /**********URL*************/ #define\tURL_LEN\t\t20 #define URL_DATA_LEN(dns)\t(2+2+1+dns+1) typedef struct { \tuint16_t uuid; \tuint8_t frame_type;\t\t//类型 \tuint8_t tx_power;\t\t//发射功率 \tuint8_t name_space[10];\t//命名空间 \tuint8_t instance[6];\t//实例 \tuint8_t rfu[2];\t\t\t//保留位 }__attribute__((packed)) eddystone_uid_t;\t\t\t\t//UID typedef struct { \tuint16_t uuid; \tuint8_t frame_type;\t//类型 \tuint8_t tx_power;\t//发射功率 \tuint8_t scheme;\t\t//前缀 \tuint8_t encoded[20];//网址 }__attribute__((packed)) eddystone_url_t;\t\t\t//URL typedef struct { \tuint16_t \tuuid; \tuint8_t \tframe_type;\t\t\t//类型 \tuint8_t \tversion;\t\t\t//版本 \tuint16_t \tbattery_voltage; \t//1 mV/bit \tuint16_t \ttemperature; \t//温度 \tuint32_t\tcount;\t\t\t\t//计数 \tuint32_t \ttime; \t\t\t\t//时间 \t }__attribute__((packed)) eddystone_tlm_t; int Eddystone_Set_UID(eddystone_uid_t *uid,char power,uint8_t * name_space,uint8_t *instance); int Eddystone_Set_URL(eddystone_url_t *url,char power,uint8_t scheme, \t\t\t\t\t\t\tconst char *dns_addr ,uint8_t len, uint8_t postfix); int Eddystone_Set_TLM(eddystone_tlm_t *tlm,uint16_t voltage,float temp,uint32_t time); #endif ``` ```c #include <stdio.h> #include <string.h> #include \"eddystone_packet.h\" #include \"esp_eddystone_protocol.h\" /******************************************************************** 函数名：\t\tEddystone_Set_UID 描述：\t\t\t设置eddystone UID 帧格式参数 参数：\t\t\tuid \t uid指针 \t\t\t\tpower \t 功率 \t\t\t\tname_space \t 命名空间 \t\t\t\tinstance\t 实例 返回值：\t\t错误\t 1 \t\t\t\t正确\t服务数据长度\t ********************************************************************/ int Eddystone_Set_UID(eddystone_uid_t *uid,char power,uint8_t * name_space,uint8_t *instance) { \tif(uid NULL name_space NULL instance NULL) \t{ \t\treturn 1; \t} \tmemset(uid,0,sizeof(eddystone_uid_t)); \tuid >uuid EDDYSTONE_SERVICE_UUID; \tuid >frame_type EDDYSTONE_UID; \tuid >tx_power (uint8_t)power; \tfor(int i 0;i <10;i++) \t\tuid >name_space[i] *name_space++; \tfor(int i 0;i <6;i++) \t\tuid >instance[i] *instance++; \treturn sizeof(eddystone_uid_t); } /******************************************************************** 函数名：\t\tEddystone_Set_URL 描述：\t\t\t设置eddystone URL 帧格式参数 参数：\t\t\turl \t uid指针 \t\t\t\tpower \t 功率 \t\t\t\tscheme \t 前缀 \t\t\t\tdns_addr 域名 \t\t\t\tlen\t\t 域名长度 \t\t\t\tpostfix\t 后缀 返回值：\t\t错误\t 1 \t\t\t\t正确\t服务数据长度（根据网址长度而定）\t ********************************************************************/ int Eddystone_Set_URL(eddystone_url_t *url,char power,uint8_t scheme, \t\t\t\t\t\t\tconst char *dns_addr ,uint8_t len, uint8_t postfix) { \tif(url NULL dns_addr NULL len > 17) \t\treturn 1; \t \tif(url >encoded NULL) \t\treturn 1; \t\t \tmemset(url >encoded,0,len); \turl >uuid EDDYSTONE_SERVICE_UUID; \turl >frame_type EDDYSTONE_URL; \turl >tx_power (uint8_t)power; \turl >scheme scheme; \tmemcpy(url >encoded,dns_addr,len); \turl >encoded[len] postfix; \treturn URL_DATA_LEN(len); } /******************************************************************** 函数名：\t\tEddystone_Set_TLM 描述：\t\t\t设置eddystone TLM 帧格式参数 参数：\t\t\ttlm \t uid指针 \t\t\t\tvoltage 电压 单位 mV \t\t\t\ttemp \t 温度\t(大于0) \t\t\t\ttime \t 开机到现在时间 以0.1秒为单位计数 返回值：\t\t错误\t 1 \t\t\t\t正确\t服务数据长度（根据网址长度而定）\t ********************************************************************/ int Eddystone_Set_TLM(eddystone_tlm_t *tlm,uint16_t voltage,float temp,uint32_t time) { \tstatic uint32_t cnt 0; \tif(tlm NULL) \t\treturn 1; \tcnt++; \tint8_t temp_integral (int8_t)temp; \tfloat temp_decimal temp temp_integral; \tuint8_t decimal (uint8_t)(temp_decimal * 256.0); \t \tprintf(\"temp_integral %d,temp_decimal %f,decimal %d,\\r\\n\",temp_integral,temp_decimal,decimal); \t \ttlm >uuid EDDYSTONE_SERVICE_UUID; \ttlm >frame_type EDDYSTONE_TLM; \ttlm >version 0; \tCONV16(tlm >battery_voltage,voltage);\t//电压值 \t \ttlm >temperature (uint16_t)(decimal << 8 temp_integral);\t//温度 \tprintf(\"tlm >temperature %x\\r\\n\",tlm >temperature); \t \tCONV32(tlm >count,cnt);\t\t//发送计数 \tCONV32(tlm >time,time);\t\t \treturn sizeof(eddystone_tlm_t); } ``` ![image 20240610102944431](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406101029486.png) > ble_eddystone为信标扫描 ```c /* * SPDX FileCopyrightText: 2021 2022 Espressif Systems (Shanghai) CO LTD * * SPDX License Identifier: Unlicense OR CC0 1.0 */ /**************************************************************************** * * This file is used for eddystone receiver. * ****************************************************************************/ #include <stdio.h> #include <stdint.h> #include <string.h> #include <inttypes.h> #include \"esp_bt.h\" #include \"nvs_flash.h\" #include \"esp_log.h\" #include \"esp_bt_defs.h\" #include \"esp_bt_main.h\" #include \"esp_gatt_defs.h\" #include \"esp_gattc_api.h\" #include \"esp_gap_ble_api.h\" #include \"freertos/FreeRTOS.h\" #include \"esp_eddystone_protocol.h\" #include \"esp_eddystone_api.h\" static const char* DEMO_TAG \"EDDYSTONE_DEMO\"; /* declare static functions */ static void esp_gap_cb(esp_gap_ble_cb_event_t event, esp_ble_gap_cb_param_t* param); static void esp_eddystone_show_inform(const esp_eddystone_result_t* res); //扫描的参数设置 static esp_ble_scan_params_t ble_scan_params { .scan_type BLE_SCAN_TYPE_ACTIVE, //扫描类型 .own_addr_type BLE_ADDR_TYPE_PUBLIC, //所有者的地址类型 .scan_filter_policy BLE_SCAN_FILTER_ALLOW_ALL, .scan_interval 0x50, //扫描间隔 .scan_window 0x30, //扫描的持续时间 .scan_duplicate BLE_SCAN_DUPLICATE_DISABLE // }; static void esp_eddystone_show_inform(const esp_eddystone_result_t* res) { //打印信息 switch(res >common.frame_type) { //三种类型 case EDDYSTONE_FRAME_TYPE_UID: { ESP_LOGI(DEMO_TAG, \"Eddystone UID inform:\"); ESP_LOGI(DEMO_TAG, \"Measured power(RSSI at 0m distance):%d dbm\", res >inform.uid.ranging_data); ESP_LOGI(DEMO_TAG, \"EDDYSTONE_DEMO: Namespace ID:0x\"); esp_log_buffer_hex(DEMO_TAG, res >inform.uid.namespace_id, 10); ESP_LOGI(DEMO_TAG, \"EDDYSTONE_DEMO: Instance ID:0x\"); esp_log_buffer_hex(DEMO_TAG, res >inform.uid.instance_id, 6); break; } case EDDYSTONE_FRAME_TYPE_URL: { ESP_LOGI(DEMO_TAG, \"Eddystone URL inform:\"); ESP_LOGI(DEMO_TAG, \"Measured power(RSSI at 0m distance):%d dbm\", res >inform.url.tx_power); ESP_LOGI(DEMO_TAG, \"URL: %s\", res >inform.url.url); break; } case EDDYSTONE_FRAME_TYPE_TLM: { ESP_LOGI(DEMO_TAG, \"Eddystone TLM inform:\"); ESP_LOGI(DEMO_TAG, \"version: %d\", res >inform.tlm.version); ESP_LOGI(DEMO_TAG, \"battery voltage: %d mV\", res >inform.tlm.battery_voltage); ESP_LOGI(DEMO_TAG, \"beacon temperature in degrees Celsius: %6.1f\", res >inform.tlm.temperature); ESP_LOGI(DEMO_TAG, \"adv pdu count since power up: %\" PRIu32, res >inform.tlm.adv_count); ESP_LOGI(DEMO_TAG, \"time since power up: %\" PRIu32 \" s\", (res >inform.tlm.time)/10); break; } default: break; } } //回调函数 static void esp_gap_cb(esp_gap_ble_cb_event_t event, esp_ble_gap_cb_param_t* param) { esp_err_t err; switch(event) { //参数设置完成 case ESP_GAP_BLE_SCAN_PARAM_SET_COMPLETE_EVT: { uint32_t duration 0; esp_ble_gap_start_scanning(duration); break; } //扫描启动 case ESP_GAP_BLE_SCAN_START_COMPLETE_EVT: { if((err param >scan_start_cmpl.status) ! ESP_BT_STATUS_SUCCESS) { ESP_LOGE(DEMO_TAG,\"Scan start failed: %s\", esp_err_to_name(err)); } else { ESP_LOGI(DEMO_TAG,\"Start scanning...\"); } break; } //扫描结束 case ESP_GAP_BLE_SCAN_RESULT_EVT: { //获取数据 esp_ble_gap_cb_param_t* scan_result (esp_ble_gap_cb_param_t*)param; switch(scan_result >scan_rst.search_evt) { case ESP_GAP_SEARCH_INQ_RES_EVT: { //获取查询数据 esp_eddystone_result_t eddystone_res; memset(&eddystone_res, 0, sizeof(eddystone_res)); //进行解码, 查看是不是eddystone的广播包 esp_err_t ret esp_eddystone_decode(scan_result >scan_rst.ble_adv, scan_result >scan_rst.adv_data_len, &eddystone_res); if (ret) { // error:The received data is not an eddystone // frame packet or a correct eddystone frame packet. // just return return; } else { // The received adv data is a correct eddystone frame packet. // Here, we get the eddystone infomation in eddystone_res, // we can use the data in res to do other things. // For example, just print them: \t//获取信息成功 ESP_LOGI(DEMO_TAG, \" Eddystone Found \"); esp_log_buffer_hex(\"EDDYSTONE_DEMO: Device address:\", scan_result >scan_rst.bda, ESP_BD_ADDR_LEN); ESP_LOGI(DEMO_TAG, \"RSSI of packet:%d dbm\", scan_result >scan_rst.rssi); esp_eddystone_show_inform(&eddystone_res); } break; } default: break; } break; } //停止的回调函数 case ESP_GAP_BLE_SCAN_STOP_COMPLETE_EVT:{ if((err param >scan_stop_cmpl.status) ! ESP_BT_STATUS_SUCCESS) { ESP_LOGE(DEMO_TAG,\"Scan stop failed: %s\", esp_err_to_name(err)); } else { ESP_LOGI(DEMO_TAG,\"Stop scan successfully\"); } break; } default: break; } } void esp_eddystone_appRegister(void) { esp_err_t status; ESP_LOGI(DEMO_TAG,\"Register callback\"); //注册一个应用层回调函数 /*<! register the scan callback function to the gap module */ if((status esp_ble_gap_register_callback(esp_gap_cb)) ! ESP_OK) { ESP_LOGE(DEMO_TAG,\"gap register error: %s\", esp_err_to_name(status)); return; } } void esp_eddystone_init(void) { esp_bluedroid_init(); //初始化信标 esp_bluedroid_enable(); //使能信标 esp_eddystone_appRegister(); } void app_main(void) { ESP_ERROR_CHECK(nvs_flash_init()); //释放经典蓝牙 ESP_ERROR_CHECK(esp_bt_controller_mem_release(ESP_BT_MODE_CLASSIC_BT)); //初始化开启低功耗蓝牙定时器 esp_bt_controller_config_t bt_cfg BT_CONTROLLER_INIT_CONFIG_DEFAULT(); esp_bt_controller_init(&bt_cfg); esp_bt_controller_enable(ESP_BT_MODE_BLE); //初始化 esp_eddystone_init(); /*<! set scan parameters 设置扫描参数*/ esp_ble_gap_set_scan_params(&ble_scan_params); } ``` #### 发送数据 ```c // The length of adv data must be less than 31 bytes //static uint8_t test_manufacturer[TEST_MANUFACTURER_DATA_LEN] {0x12, 0x23, 0x45, 0x56}; //adv data 广播的数据包结构体 static esp_ble_adv_data_t adv_data { .set_scan_rsp false, //是否响应 .include_name true, //是不是有设备名 .include_txpower true,//是不是包含频率 //最小以及最大间隔 .min_interval 0x0006, //slave connection min interval, Time min_interval * 1.25 msec .max_interval 0x000C, //slave connection max interval, Time max_interval * 1.25 msec .appearance 0x00, //设备外观 .manufacturer_len 0, //TEST_MANUFACTURER_DATA_LEN, 制造商的名字长度 .p_manufacturer_data NULL, //&test_manufacturer[0], 制造商数据的长度 .service_data_len 0, //服务数据的长度 .p_service_data NULL, .service_uuid_len 32, //uuid的长度 .p_service_uuid adv_service_uuid128, //uuid指针 .flag (ESP_BLE_ADV_FLAG_GEN_DISC ESP_BLE_ADV_FLAG_BREDR_NOT_SPT), //flag的那一个参数 }; //广播数据设置 static esp_ble_adv_params_t adv_params { .adv_int_min 0x20,\t\t //广告间隔 .adv_int_max 0x40, .adv_type ADV_TYPE_IND, //可连接通用广播 .own_addr_type BLE_ADDR_TYPE_PUBLIC, //设备地址类型 //.peer_addr \t\t\t\t//对端蓝牙设备地址 //.peer_addr_type .channel_map ADV_CHNL_ALL,\t\t//通道 .adv_filter_policy ADV_FILTER_ALLOW_SCAN_ANY_CON_ANY, //过滤 }; ``` ```c esp_err_t esp_ble_gap_config_adv_data(esp_ble_adv_data_t *adv_data); //设置发送的数据 esp_err_t esp_ble_gap_start_advertising(esp_ble_adv_params_t *adv_params); //开启广播 ``` ```c eddystone_uid_t uid; int len Eddystone_Set_UID(&uid, 10, \"hello\", \"12345\"); if(len 1){ ESP_LOGE(\"main\", \"get eddystone error\"); return; } adv_data.service_data_len len; adv_data.p_service_data &uid; esp_ble_gap_config_adv_data(&adv_data); esp_ble_gap_start_advertising(&adv_params); //这一个函数最好放在回调函数里面 ``` > 实际的实现 ### API #### 开启扫描 ```c esp_err_t esp_ble_gap_start_scanning(uint32_t duration); ``` > 开启扫描, duration持续的时间 #### 获取特定类型数据 ```c uint8_t *esp_ble_resolve_adv_data(uint8_t *adv_data, uint8_t type, uint8_t *length) ``` > type: 是esp_ble_adv_data_type里面的, 解析GATT名字的时候使用的是ESP_BLE_AD_TYPE_NAME_CMPL"},"/note/嵌入式/esp32/esp-idf/2024-6-26-22错误处理.html":{"title":"错误处理","content":" layout: post title: \"错误处理\" date: 2024 6 24 15:39:08 +0800 tags: esp32 ESP IDF # 错误处理 [错误代码参考 ESP32 — ESP IDF 编程指南 latest 文档 (espressif.com)](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/error codes.html) 除了ESP_OK以外都是错误信息, 这些信息一般以ESP_ERR开头 可以使用`esp_err_to_name()` 函数传递错误代码 `0x101`，可以得到返回字符串 “ESP_ERR_NO_MEM”。 在 ESP IDF 中，`errno` 是一个基于线程的局部变量，即每个 FreeRTOS 任务都有自己的 `errno` 副本，通过函数修改 `errno` 也只会作用于当前任务中的 `errno` 变量值。 ## 错误检查 宏 `ESP_ERROR_CHECK` 的功能和 `assert` 类似，不同之处在于：这个宏会检查 `esp_err_t` 的值，而非判断 `bool` 条件。如果传给 `ESP_ERROR_CHECK`的参数不等于 `ESP_OK` ，则会在控制台上打印错误消息，然后调用 `abort()` 函数。 宏 `ESP_RETURN_ON_ERROR`用于错误码检查, 如果错误码不等于 `ESP_OK`, 该宏会打印错误信息，并使原函数立刻返回。 宏 `ESP_ERROR_CHECK_WITHOUT_ABORT` 的功能和 `ESP_ERROR_CHECK` 类似, 不同之处在于它不会调用 `abort()`. `ESP_GOTO_ON_ERROR`用于错误码检查, 如果错误码不等于 `ESP_OK`, 该宏会打印错误信息，将局部变量 ret 赋值为该错误码, 并使原函数跳转至给定的 goto_tag. 宏 `ESP_RETURN_ON_FALSE`用于条件检查, 如果给定条件不等于 true, 该宏会打印错误信息，并使原函数立刻返回，返回值为给定的 err_code. 宏 `ESP_GOTO_ON_FALSE` 用于条件检查, 如果给定条件不等于 true, 该宏会打印错误信息，将局部变量 ret 赋值为给定的 err_code, 并使原函数跳转至给定的 goto_tag."},"/note/嵌入式/esp32/esp-idf/2024-10-4-28大语言模型.html":{"title":"大语言模型","content":" layout: post title: \"大语言模型\" date: 2024 10 4 15:39:08 +0800 tags: esp32 ESP IDF # 大语言模型 [DaveBben/esp32 llm: Running a LLM on the ESP32 (github.com)](https://github.com/DaveBben/esp32 llm) [ESP32 C3开发笔记2：乐鑫ESP32 C/S系列选型对比 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/571048601#:~:text 其中ESP32 C3) [【立创·实战派ESP32 C3】开发板 飞书云文档 (feishu.cn)](https://lceda001.feishu.cn/wiki/L5Qhw037viVW5MkyFXPcRLhznbe) ## 初次使用 使用下载的文件进行编译, 出现组件没有下载的问题, 下载以下组件 + [espressif](https://components.espressif.com/components?q namespace:espressif)/esp dsp The ESP DSP library includes implementations of the following functions: Matrix multiplication: [reference](https://docs.espressif.com/projects/esp dsp/en/latest/esp dsp apis.html#matrix operations apis) Dot product: [reference](https://docs.espressif.com/projects/esp dsp/en/latest/esp dsp apis.html#dot product), [example](https://github.com/espressif/esp dsp/tree/master/examples/dotprod) FFT: [reference](https://docs.espressif.com/projects/esp dsp/en/latest/esp dsp apis.html#fft), [example](https://github.com/espressif/esp dsp/tree/master/examples/fft) IIR: [reference](https://docs.espressif.com/projects/esp dsp/en/latest/esp dsp apis.html#iir), [example](https://github.com/espressif/esp dsp/tree/master/examples/iir) FIR: [reference](https://docs.espressif.com/projects/esp dsp/en/latest/esp dsp apis.html#fir) Vector math operations: [reference](https://docs.espressif.com/projects/esp dsp/en/latest/esp dsp apis.html#math) Kalman filter: [reference](https://docs.espressif.com/projects/esp dsp/en/latest/esp dsp apis.html#kalman) ```bash idf.py add dependency \"espressif/esp dsp^1.5.2\" ```"},"/note/嵌入式/esp32/esp-idf/2024-8-1-27启动模式.html":{"title":"启动模式","content":" layout: post title: \"启动模式\" date: 2024 6 28 15:39:08 +0800 tags: esp32 ESP IDF # 启动模式 [Boot Mode Selection ESP32 — esptool.py latest documentation (espressif.com)](https://docs.espressif.com/projects/esptool/en/latest/esp32/advanced topics/boot mode selection.html) 默认的时候GPIO0会被一个45K的电阻进行上拉, 如果把这一个引脚拉低使用下载启动模式, 使用下载启动模式的时候GPIO2也需要是低电平或者是浮空的 GPIO是高电平的时候, 启动模式是从Flash启动 在使用esptools进行下载的时候会使用控制DTR和RTS引脚的方式进行控制下载的模式, 在使用的时候要控制这两个分别控制GPIO0以及EN引脚 ![image 20240801150021247](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408011500298.png) 在EN引脚以及GND之间需要加一个1uF 10uF range的电容 ![image 20240801150809138](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408011508168.png) 可以使用这一个电路 ## 启动信息 ```c ets Jun 8 2016 00:22:57 rst:0x1 (POWERON_RESET),boot:0x3 (DOWNLOAD_BOOT(UART0/UART1/SDIO_REI_REO_V2)) ``` `rst:0xNN (REASON)` is an enumerated value (and description) of the reason for the reset. A mapping between the hex value and each reason can be found in the [ESP IDF source under RESET_REASON enum](https://github.com/espressif/esp idf/blob/release/v5.2/components/esp_rom/include/esp32/rom/rtc.h). The value can be read in ESP32 code via the [get_reset_reason() ROM function](https://github.com/espressif/esp idf/blob/release/v5.2/components/esp_rom/include/esp32/rom/rtc.h). `boot:0xNN (DESCRIPTION)` is the hex value of the strapping pins, as represented in the [GPIO_STRAP register](https://github.com/espressif/esp idf/blob/release/v5.2/components/soc/esp32/include/soc/gpio_reg.h). `0x01` GPIO5 `0x02` MTDO (GPIO15) `0x04` GPIO4 `0x08` GPIO2 `0x10` GPIO0 `0x20` MTDI (GPIO12) If the pin was high on reset, the bit value will be set. If it was low on reset, the bit will be cleared. ## 启动流程 ### 一级引导程序 该部分程序是直接存储在ESP32 P4内部ROM中，所以普通开发者无法直接查看，它主要 是做一些前期的准备工作（复位向量代码），然后从flash 0x2000偏移地址中读取二级引导程序 文件头中的配置信息，并使用这些信息来加载剩余的二级引导程序。 ### 二级引导程序 该程序是可以查看且可被修改，在搭建ESP IDF环境完成后，可在esp idf\\components\\bootl oader/subproject/main/路径下找到bootloader_start.c文件，此文件就是二级引导程序启动处。 硬件初始化:初始化内存、启用超级看门狗自动喂养、配置时钟、清除bss段、开启cache和 复位mmu等操作 选择启动分区的数量：加载分区表，选择boot分区 加载应用程序映像并启动 ### 三级引导程序 应用程序的入口是在esp idf/components/esp_system/port/路径下的cpu_star.c文件，在此文件 下找到call_start_cpu0函数（端口层初始化函数）。这个函数由二级引导加载程序执行，并且从 不返回。 你看不到是哪个函数调用了它，它是从汇编的最底层直接调用的（components\\esp _system\\ld\\esp32p4\\sections.ld.in汇编文件） 这个函数会初始化基本的C运行环境（“CRT”），并对SOC的内部硬件进行了初始配置。 执行call_start_cpu0函数完成之后，在components\\esp_system\\startup.c文件下调用`start_cpu0`（在 36行中，弱关联`start_cpu0_default`函数）系统层初始化函数 ![image 20250607112747883](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506071127011.png) 到了这里，就完成了二级程序引导，并调用esp_startup_start_app函数进入三级引导程序 首先在 xTaskCreatePinnedToCore 函数创建 main_task 任务，然后开启 freeRTOS 任务调度器，最后在 main_task任务下调用 app_main函数（此函数在创建工程时，在 main.c 下定义的）。"},"/note/嵌入式/esp32/esp-idf/2025-6-7-36存储器.html":{"title":"存储器","content":"# 存储器 ## 概述 ESP IDF 将存储器分为指令总线和数据总线。指令总线包括 IRAM（指令 RAM）、IROM （从Flash中运行的代码）和RTC FAST内存，这些存储器是可执行的，并且只能通过4字节对 齐的方式进行读取或写入。数据总线则由DRAM（数据RAM）和DROM（存储在Flash中的数 据）组成，这些存储器不可执行，允许单独的字节操作。 ### DRAM数据RAM DRAM用于存放非常量静态数据（.data段）和零初始化数据（.bss段）。链接器会将这些数 据放置于内部 SRAM中，且该区域的剩余空间可在程序运行时用作堆。 使用 EXT_RAM_BSS_ ATTR宏可将零初始化数据（.bss段）放入外部RAM。要启用此功能，需确保配置了CONFIG_ SPIRAM_ALLOW_BSS_SEG_EXTERNAL_MEMORY选项，如下图所示。 ![image 20250607121412551](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506071214618.png) 启用后，使用EXT_RAM_BSS_ATTR属性 的变量将被放置在SPIRAM中。 ![image 20250607121514515](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506071215676.png) ```c #include \"esp_attr.h\" EXT_RAM_BSS_ATTR uint32_t external_bss_data 0; /** * @brief 程序入口 * @param 无 * @retval 无 */ void app_main() { \t/* 在此处可以使用external_bss_data */ } ``` 这段代码声明了一个外部RAM变量external_bss_data，使用EXT_RAM_BSS_ATTR宏确保 它在外部RAM中存储并初始化为零。 ### IRAM指令RAM IRAM是存放执行指令的内存区域。内部SRAM中未用于IRAM的部分将作为DRAM供静 态数据和动态分配（堆）使用。 在特定情况下，将部分应用程序代码放入 IRAM 是有益的。首先，当注册中断处理程序时， 如果使用了 ESP_INTR_FLAG_IRAM，则该处理程序必须放置于 IRAM 中，以确保其快速响应。 其次，对于时序关键的代码，放入IRAM可以显著减少从Flash加载代码所带来的延迟，从而提升函数性能，确保系统在执行关键任务时的高效性。 过链接器脚本，可以自动将特定代码放入IRAM。如果需要手动指定，可以使用IRAM_AT TR宏 ```c #include \"esp_attr.h\" void IRAM_ATTR gpio_isr_handler(void* arg) { \t/* 及时相应代码 */ } ``` > 需要注意的是，将代码放入 IRAM 可能会引发安全中断处理程序的问题，因为字符串或常 量可能不会自动放入 RAM。在这种情况下，应使用 DRAM_ATTR 属性进行标记，以确保它们 正确存储在RAM中 > > ```c > void IRAM_ATTR gpio_isr_handler(void* arg) > { > \tconst static DRAM_ATTR uint8_t INDEX_DATA[] { 45, 33, 12, 0 }; > \tconst static char *MSG DRAM_STR(\"I am a string stored in RAM\"); > } > ``` 上述代码中，确定哪些数据需要标记为DRAM_ATTR可能比较困难。如果未标记，某些变 量或表达式可能会被编译器识别为常量并放入Flash中。这是因为GCC优化会自动生成跳转表 或switch/case 查找表。为了解决此问题，可以在ESP IDF编译时使用 fno jump tables fno tree s witch conversion 标志，以避免将这些表放入Flash。 ### IROM 如果一个函数没有被显式地声明放在IRAM或RTC存储器中，则它将被放置在Flash中。 由于IRAM空间有限，大部分应用程序的二进制代码需要放入IROM中。 在启动过程中，从IR AM中运行的引导加载程序配置MMU以缓存Flash，将应用程序的指令代码区域映射到指令空 间。通过MMU访问的Flash使用一些内部SRAM进行缓存，这使得访问缓存的Flash数据的速 度与访问其他类型的内部存储器一样快。 ### DRAM 默认情况下，链接器将常量数据放入一个映射到MMU Flash缓存的区域，这个区域与IRO M相同，但用于只读数据而非可执行代码。唯一不默认放入DROM的常量数据是那些被编译器 嵌入到应用程序代码中的字面常量，这些常量会被放置在周围函数的可执行指令中。 ### RTC FAST memory(RTC 快速存储器) 除非禁用 CONFIG_ESP_SYSTEM_ALLOW_RTC_FAST_MEM_AS_HEAP 选项（见下图所 示），否则剩余的RTC FAST内存会被添加到堆中。这部分内存可以与DRAM（数据RAM）互 换使用，但访问速度略慢一些。 ![image 20250607123348780](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506071233867.png) ### 紧密耦合内存（TCM） TCM（紧耦合内存）是靠近 CPU的内存，支持在 CPU频率下直接访问，无需经过缓存。尽管在一般情况下，TCM 的效率或速度相比缓存要低一些，但访问 TCM的时间是可预测且始 终一致的。这种稳定的访问速度对时间关键型例程尤为重要，因此，TCM 在需要精准时序控制 的任务中非常有用，可以确保执行的延迟和速度一致。 ## DMA相关内存 在ESP32开发中，许多DMA控制器（如SPI、SDMMC等）要求发送/接收缓冲区必须放置 在DRAM中，并且按字对齐。为了确保DMA传输的稳定性和性能，我们建议将DMA缓冲区 放在静态变量中，而不是堆栈中。 ### 静态 DMA 缓冲区 可以使用DMA_ATTR宏声明全局或 本地静态变量具备DMA能力。 ```c DMA_ATTR uint8_t buffer[] \"I want to send something\"; void app_main() { /* 初始化代码 */ spi_transaction_t temp { .tx_buffer buffer, .length 8 * sizeof(buffer), }; spi_device_transmit(spi, &temp); /* 其它程序 */ } ``` ### 堆栈 DMA 缓冲区 一般建议避免这样做。如果确实需要在堆栈中使 用DMA缓冲区 1. 如果堆栈位于PSRAM中，不建议将DRAM缓冲区放置在堆栈中。这种情况下，任务 堆栈在PSRAM中时，必须按照片外RAM（请看ESP IDF编程指南的“片外 RAM”章节）的 相关步骤进行特殊处理，以确保DMA传输的正确性和稳定性。 2. 在函数中，使用WORD_ALIGNED_ATTR宏修饰变量，确保变量的内存对齐，从而使 其可以被DMA正确访问 ```c void app_main() { uint8_t stuff; /* 否则 buffer 会被存储在 stuff 变量后面 */ WORD_ALIGNED_ATTR uint8_t buffer[] \"I want to send something\"; /* 初始化代码 * spi_transaction_t temp { .tx_buffer buffer, .length 8 * sizeof(buffer), }; spi_device_transmit(spi, &temp); /* 其它程序 */ } ```"},"/note/嵌入式/esp32/esp-idf/2024-10-5-30U8g2.html":{"title":"U8g2","content":" layout: post title: \"U8g2\" date: 2024 5 24 15:39:08 +0800 tags: esp32 ESP IDF # U8g2 在ESP32使用u8g2的时候可以使用添加component的方式进行, 由于[官方的component库](https://components.espressif.com/components?q u8g2)没有, 这里我找到了一个可以使用的[github库](https://github.com/mkfrey/u8g2 hal esp idf?tab readme ov file), 使用git的方式进行添加这一个库 > 具体的原理可以看[官方手册](https://docs.espressif.com/projects/esp idf/zh_CN/stable/esp32/api guides/tools/idf component manager.html#:~:text IDF 组件管理器工) ## 添加 ### 方式一 ![image 20241005193812089](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202410051938150.png) ```yaml u8g2: \tgit: https://github.com/olikraus/u8g2.git u8g2 hal esp idf: \tgit: https://github.com/mkfrey/u8g2 hal esp idf.git ``` 在这一个文件里面添加这两行即可在编译的时候自动下载 ### 方式2 这一个是README手册里面使用的方法 To use the actual U8g2 library in your ESP32 project, perform the following steps: 1. Create a directory called `components` in your main project directory. 添加一个组件文件夹 2. Change into the `components` directory. 3. Run `git clone https://github.com/mkfrey/u8g2 hal esp idf.git` to bring in the latest copy of this library. 4. Run `git clone https://github.com/olikraus/u8g2.git` to bring in a the latest copy of u8g2 library. 在这一个文件夹里面使用这两个命令 If your project itself is a git repository, you should consider using `git submodule add` instead of cloning. ## 实际使用 **注: **实际是对README文件的翻译 在实际使用的时候需要在使用U8g2的函数之前调用一下`u8g2_esp32_hal_init()` 函数, 这一个函数的作用实际是告诉ESP32我们使用到的引脚, Here is an example of SPI use: ``` u8g2_esp32_hal_t u8g2_esp32_hal U8G2_ESP32_HAL_DEFAULT; u8g2_esp32_hal.bus.spi.clk PIN_CLK; u8g2_esp32_hal.bus.spi.mosi PIN_MOSI; u8g2_esp32_hal.bus.spi.cs PIN_CS; u8g2_esp32_hal.dc PIN_DC; u8g2_esp32_hal.reset PIN_RESET; u8g2_esp32_hal_init(u8g2_esp32_hal); ``` I2C的示例 ``` u8g2_esp32_hal_t u8g2_esp32_hal U8G2_ESP32_HAL_DEFAULT; u8g2_esp32_hal.bus.i2c.sda PIN_SDA; u8g2_esp32_hal.bus.i2c.scl PIN_SCL; u8g2_esp32_hal_init(u8g2_esp32_hal); ``` 需要在调用这一个函数以后设置一下I2C的地址 ``` u8x8_SetI2CAddress(&u8g2.u8x8,<address>); ``` Note that `<address>` is the I2C address already shifted left to include the read/write flag. For example, if you are using an SSD1305, instead of supplying the address `0x3C` which would be `0011 1100` supply `0x78` which would be `0111 1000`. > 这一个地址是一个进行左移一位(空出来读写位)的地址 之后即可进行正常的初始化过程 ````c /** * @brief Configure SSD1306 display * Uses I2C connection */ void init_display(void) { u8g2_esp32_hal_t u8g2_esp32_hal U8G2_ESP32_HAL_DEFAULT; u8g2_esp32_hal.bus.i2c.sda PIN_SDA; u8g2_esp32_hal.bus.i2c.scl PIN_SCL; u8g2_esp32_hal_init(u8g2_esp32_hal); // 针对不同的屏幕使用不同的初始化函数 u8g2_Setup_ssd1306_i2c_128x64_noname_f( &u8g2, U8G2_R0, // u8x8_byte_sw_i2c, u8g2_esp32_i2c_byte_cb, u8g2_esp32_gpio_and_delay_cb); // init u8g2 structure // 0x3c u8x8_SetI2CAddress(&u8g2.u8x8, OLED_I2C_ADDRESS); u8g2_InitDisplay(&u8g2); // send init sequence to the display, display is in // sleep mode after this, u8g2_SetPowerSave(&u8g2, 0); // wake up display u8g2_ClearBuffer(&u8g2); } ````"},"/note/嵌入式/esp32/esp-idf/2024-6-26-23MQTT.html":{"title":"MQTT","content":" layout: post title: \"MQTT\" date: 2024 6 26 15:39:08 +0800 tags: esp32 ESP IDF # MQTT ## 服务器 ```c # 安装mosquitto sudo apt get install mosquitto # 安装客户端 sudo apt get install mosquitto clients # 安装设备端 sudo apt get install mosquitto dev ``` > 关防火墙和安全组设置 ```bash mosquitto_sub v t hello # 订阅安全组 h 指定域名 t 指定订阅的主题，主题为：hello v 详细模式 打印调试信息 ``` ```bash mosquitto_pub t hello m world # 发布订阅 t 指定订阅的主题，主题为：hello m 指定发布的消息的内容 ``` ### esp32 ### 流程 1. wifi初始化以及设置参数 2. wifi连接 3. mqtt初始化 4. 订阅监听事件 > 1. 初始化esp_mqtt_client_config_t结构体, 使用esp_mqtt_client_init进行初始化 > 2. esp_mqtt_client_register_event注册一下事件处理的函数 > 3. esp_mqtt_client_start开启服务 > 4. 在事件回调函数里面处理事件 ### 事件 `MQTT_EVENT_BEFORE_CONNECT`：客户端已初始化并即将开始连接至服务器。 `MQTT_EVENT_CONNECTED`：客户端已成功连接至服务器。客户端已准备好收发数据。 `MQTT_EVENT_DISCONNECTED`：由于无法读取或写入数据，例如因为服务器无法使用，客户端已终止连接。 `MQTT_EVENT_SUBSCRIBED`：服务器已确认客户端的订阅请求。事件数据将包含订阅消息的消息 ID。 `MQTT_EVENT_UNSUBSCRIBED`：服务器已确认客户端的退订请求。事件数据将包含退订消息的消息 ID。 `MQTT_EVENT_PUBLISHED`：服务器已确认客户端的发布消息。消息将仅针对 QoS 级别 1 和 2 发布，因为级别 0 不会进行确认。事件数据将包含发布消息的消息 ID。 `MQTT_EVENT_DATA`：客户端已收到发布消息。事件数据包含：消息 ID、发布消息所属主题名称、收到的数据及其长度。对于超出内部缓冲区的数据，将发布多个 `MQTT_EVENT_DATA`，并更新事件数据的 `current_data_offset` 和 `total_data_len` 以跟踪碎片化消息。 `MQTT_EVENT_ERROR`：客户端遇到错误。使用事件数据 `error_handle` 字段中的 `error_type`，可以发现错误。错误类型决定 `error_handle` 结构体的哪些部分会被填充。 ### 遗嘱消息 (LWT) 初始化结构体里面有一个last_will, 可以设置这一个的参数从而在意外断开里面的时候通过遗嘱通知其他的设备 [`topic`](https://docs.espressif.com/projects/esp idf/zh_CN/stable/esp32/api reference/protocols/mqtt.html#_CPPv4N24esp_mqtt_client_config_t9session_t11last_will_t5topicE)：指向 LWT 消息主题的指针 [`msg`](https://docs.espressif.com/projects/esp idf/zh_CN/stable/esp32/api reference/protocols/mqtt.html#_CPPv4N24esp_mqtt_client_config_t9session_t11last_will_t3msgE)：指向 LWT 消息的指针 [`msg_len`](https://docs.espressif.com/projects/esp idf/zh_CN/stable/esp32/api reference/protocols/mqtt.html#_CPPv4N24esp_mqtt_client_config_t9session_t11last_will_t7msg_lenE)：LWT 消息的长度，[`msg`](https://docs.espressif.com/projects/esp idf/zh_CN/stable/esp32/api reference/protocols/mqtt.html#_CPPv4N24esp_mqtt_client_config_t9session_t11last_will_t3msgE) 不以空字符结尾时需要该字段 [`qos`](https://docs.espressif.com/projects/esp idf/zh_CN/stable/esp32/api reference/protocols/mqtt.html#_CPPv4N24esp_mqtt_client_config_t9session_t11last_will_t3qosE)：LWT 消息的服务质量 [`retain`](https://docs.espressif.com/projects/esp idf/zh_CN/stable/esp32/api reference/protocols/mqtt.html#_CPPv4N24esp_mqtt_client_config_t9session_t11last_will_t6retainE)：指定 LWT 消息的保留标志 ### API #### 常用 ```c esp_mqtt_client_handle_t esp_mqtt_client_init(const esp_mqtt_client_config_t *config); ``` > 初始化, config里面最少需要设置`.broker.address.uri \"mqtt://110.41.39.131/\"`这一个参数 ```c esp_err_t esp_mqtt_client_start(esp_mqtt_client_handle_t client) ``` > 开启mqtt服务 ```c int esp_mqtt_client_subscribe_single(esp_mqtt_client_handle_t client, const char *topic, int qos); ``` > 订阅一个主题 ```c int esp_mqtt_client_unsubscribe(esp_mqtt_client_handle_t client, const char *topic) ``` > 取消订阅 ```c int esp_mqtt_client_publish(esp_mqtt_client_handle_t client, const char *topic, const char *data, int len, int qos, int retain) ``` > 发送消息 ```c esp_err_t esp_mqtt_client_register_event(esp_mqtt_client_handle_t client, esp_mqtt_event_id_t event, esp_event_handler_t event_handler, void *event_handler_arg) ``` > 注册事件, 可以使用ESP_EVENT_ANY_ID注册所有的事件 ### 其他 ```c esp_err_t esp_mqtt_client_set_uri(esp_mqtt_client_handle_t client, const char *uri) ``` > 重新设置URL ### 示例 ```c #include <stdio.h> #include <string.h> #include \"freertos/FreeRTOS.h\" #include \"freertos/task.h\" #include \"mqtt_client.h\" #include \"esp_event.h\" #include \"esp_wifi.h\" #include \"nvs_flash.h\" void Z_WiFi_Init(void); void Z_Mqtt_Init(void); bool Z_mqtt_connect_flag false; //记录是否连接上MQTT服务器的一个标志,如果连接上了才可以发布信息 esp_mqtt_client_handle_t emcht; //MQTT客户端句柄 //WiFI事件处理函数 void wifi_event_fun(void* handler_arg,esp_event_base_t event_base,int32_t event_id,void* event_data){ printf(\"%s,%ld\\r\\n\",event_base,event_id); if(event_id WIFI_EVENT_STA_START){ //如果是STA开启了,那么尝试连接 printf(\"\\r\\nstart wifi success\\r\\n\"); esp_wifi_connect(); }else if(event_id WIFI_EVENT_STA_CONNECTED){ //连接上WiFI之后 printf(\"connect wifi success\\r\\n\"); Z_Mqtt_Init(); //开始连接MQTT服务器 }else if(event_id WIFI_EVENT_STA_DISCONNECTED){ //断开WiFi之后 esp_wifi_connect(); //尝试重连WiFi } } //MQTT事件处理函数 void mqtt_event_fun(void *event_handler_arg, esp_event_base_t event_base, int32_t event_id, void *event_data){ printf(\"%s,%ld\\r\\n\",event_base,event_id); if(event_id MQTT_EVENT_CONNECTED){ //连接上MQTT服务器 Z_mqtt_connect_flag true; esp_mqtt_client_subscribe_single(emcht,\"Z_topic\",1); //订阅一个测试主题 printf(\"success connect mqtt\\r\\n\"); }else if(event_id MQTT_EVENT_DISCONNECTED){ //断开MQTT服务器连接 Z_mqtt_connect_flag false; printf(\"lose connect mqtt\\r\\n\"); }else if(event_id MQTT_EVENT_DATA){ //收到订阅信息 esp_mqtt_event_handle_t event (esp_mqtt_event_handle_t )event_data; //强转获取存放订阅信息的参数 printf(\"receive data : %.*s from %.*s\\r\\n\",event >data_len,event >data,event >topic_len,event >topic); } } void Z_WiFi_Init(void){ nvs_flash_init(); //初始化nvs esp_netif_init(); //初始化TCP/IP堆栈 esp_event_loop_create_default(); //创建默认事件循环 esp_event_handler_register(WIFI_EVENT,ESP_EVENT_ANY_ID,wifi_event_fun,NULL); //绑定事件处理函数 esp_netif_create_default_wifi_sta(); //创建STA wifi_init_config_t wict WIFI_INIT_CONFIG_DEFAULT(); esp_wifi_init(&wict); //初始化WiFI esp_wifi_set_mode(WIFI_MODE_STA); //设为STA模式 wifi_config_t wct { .sta { .ssid \"Xiaomi_5314\", .password \"13838106970\" } }; esp_wifi_set_config(WIFI_IF_STA,&wct); //设置WiFi printf(\"\\r\\nstart wifi\\r\\n\"); esp_wifi_start(); //启动WiFi } void Z_Mqtt_Init(void){ esp_mqtt_client_config_t emcct { .broker.address.uri \"mqtt://110.41.39.131/\", //MQTT服务器的uri .broker.address.port 1883 //MQTT服务器的端口 }; emcht esp_mqtt_client_init(&emcct); //初始化MQTT客户端获取句柄 if(!emcht) printf(\"mqtt init error!\\r\\n\"); //注册MQTT事件处理函数 if(esp_mqtt_client_register_event(emcht,ESP_EVENT_ANY_ID,mqtt_event_fun,NULL)! ESP_OK) printf(\"mqtt register error!\\r\\n\"); //开启MQTT客户端 if(esp_mqtt_client_start(emcht) ! ESP_OK) printf(\"mqtt start errpr!\\r\\n\"); } void app_main(void){ Z_WiFi_Init(); char* data \"Hello World\"; while(1){ //每隔5S发布一次测试消息 if(Z_mqtt_connect_flag) esp_mqtt_client_publish(emcht,\"hello\",data,strlen(data),1,0); vTaskDelay(3000/portTICK_PERIOD_MS); } } ```"},"/note/嵌入式/esp32/esp-idf/2024-6-9-14蓝牙.html":{"title":"蓝牙","content":" layout: post title: \"蓝牙\" date: 2024 5 24 15:39:08 +0800 tags: esp32 ESP IDF # 蓝牙 BLE: 低功耗控制器 BR/EDR: 两个标准的蓝牙协议, 一个是低速, 一个是高速(经典控制器) > 支持两个 > 双模 > > 支持一个 > 单模 蓝牙支持4.2版本以后支持ipv6, ESP32支持的版本, 但是不可以直接连接广域网 蓝牙mesh: 蓝牙局域网 ![image 20240610102221260](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406101022357.png) ### 客户端 Client 1. 请求数据服务 2. 客户端可以主动搜索并连接附近的服务端 3. 客户端类似蹭网的 ### 服务端Server 1. 提供数据服务 2. 服务端不需要进行主动设置，只要开启广播就可以让附近的客户端搜索到，并提供连接 3. 服务端类似被蹭网的wifi > 如果想要让ESP处于别人随时可以搜索连接的情况要配置为服务端；如果想让ESP通过扫描连接周围可连接的蓝牙设备，需要把它设置成客户端，正好和WiFi模式的设定相反 ## 蓝牙协议栈 ### 结构 ![image 20240609231306004](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406092313089.png) ### 蓝牙控制器 有BR/EDR控制器, BLE控制器和AMP控制器(已经被弃用了) ![image 20240610102351298](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406101023356.png) ### 蓝牙主机 ![image 20240610102410928](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406101024983.png) ### 专用术语 GAP: 通用访问 GATT/ATT: 通用属性 SMP: 安全管理 SDP: 服务发现 L2CAP: 链路管理与适配 HCI: 主机控制接口 DM: 设备管理 LM: 链路管理 LC: 链路控制 PHY: 物理层 ## ESP32 esp32使用的是bluedroid这一个协议栈 > bluedroid: 安卓系统 > > bluez: linux系统官方 > > Zephyr 物联网系统里面有自己的协议栈 > > AliOS Things 阿里物联网操作系统使用自己的操作站 > > nimble: RT Thread bluedroid是谷歌开发的"},"/note/嵌入式/esp32/esp-idf/2025-6-6-34USB.html":{"title":"USB","content":"# USB ## 简介 USB（Universal Serial Bus，通用串行总线）是一种广泛应用的总线标准，用于连接主机与 外设设备，实现数据传输、电源供给等功能。作为现代电子设备间通信的核心技术，USB 以其 高效性和易用性成为了嵌入式开发中不可或缺的组成部分。 ### 硬件接口 USB 协议有漫长的发展历程，为的不同的场合和硬件功能而发展出不同的接口：Type A、 Type B、Type C，Type C规范碰巧是跟着USB3.1的规范一起发布的。 ![image 20250606234929047](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506062349125.png) USB 发展到现在已经有 USB1.0/1.1/2.0/3.x/4等多个版本。目前用的最多的就是版本 USB1.1 和 USB2.0，USB3.x/USB4 目前也在加速推广。从图中可以发现不同的版本的 USB接口内的引 脚数量是有差异的。USB3.0以后为了提高速度，采用了更多数量的通讯线，比如同样的是Type A接口，USB2.0版本内部只有四根线，采用半双工式广播式通讯，USB3.0版本则将通讯线提高 到了 9根，并可以支持全双工非广播式的总线，允许两个单向数据管道分别处理一个单向通信。 USB2.0 常使用四根线：VCC（5V）、 GND、D+（3.3V）和 D （3.3V） （注：五线模式多 了一个DI脚用于支持OTG模式，OTG为USB主机+USB设备双重角色），其中数据线采用差 分电压的方式进行数据传输。 在USB主机上，D 和D+都是接了15K的电阻到地的，所以在没有设备接入的时候，D+、D 均是低电平。而在USB设备中，如果是高速设备，则会在D+上接 一个1.5K的电阻到3.3V，而如果是低速设备，则会在D 上接一个1.5K的电阻到3.3V。这样当 设备接入主机的时候，主机就可以判断是否有设备接入，并能判断设备是高速设备还是低速设 备。 ### 速度 USB 规范已经为 USB 系统定义了以下四种速度模式：低速（Low Speed）、全速（Full Speed）、高速（Hi Speed）和超高速（SuperSpeedUSB）。 ![image 20250606235135187](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506062351377.png) ### USB系统 USB系统主要包括三个部分：控制器（Host Controller）、集线器 (Hub) 和USB设备。 + 控制器（Host Controller），主机一般可以有一个或多个控制器，主要负责执行由控制器驱 动程序发出的命令。控制器驱动程序(Host Controller Driver)在控制器与 USB设备之间建立通信 信道。 + 集线器(Hub)连接到USB主机的根集线器，可用于拓展主机可访问的USB设备的数量。 + USB设备(USB Device)则是我们常用的如U盘，USB鼠标这类受主机控制的设备。 ### 通信通道 USB 针对主机、集线器和设备制定了严格的协议。概括来讲，通过检测、令牌、传输控制、 数据传输等多种方式，定义了主机和从机在系统中的不同职能。USB 系统通过“管道”进行通 讯，有“控制管道”和“数据管道”两种，“控制管道”是双向的，而每个“数据管道”则是单向的 USB 通讯中的检测和断开总是由主机发起。USB主机与设备首次进行连接时会交换信息， 这一过程叫“USB枚举”。枚举是设备和主机间进行的信息交换过程，包含用于识别设备的信息。 此外，枚举过程主机需要分配设备地址、读取描述符（作为提供有关设备信息的数据结构），并 分配和加载设备驱动程序，而从机需要提供相应的描述符使主机知悉如何操作此设备。 整个过 程需要数秒时间。完成该过程后设备才可以向主机传输数据。数据传输也有规定的三种类型， 分别是：IN/读取/上行数据传输、OUT/写入/下行数据传输、控制数据传输。 USB 通过设备端点寻址，在主机和设备间实现信息交流。枚举发生前有一套专用的端点用 于与设备进行通信。这些专用的端点统称为控制端点或端点0，有端点0 IN和端点0 OUT两个 不同的端点，但对开发者来说，它们的构建和运行方式是一样的。每一个USB设备都需要支持 端点0。因此，端点0不需要使用独立的描述符。除了端点0外，特定设备所支持的端点数量将 由各自的设计要求决定。简单的设计（如鼠标）可能仅要一个IN端点。复杂的设计可能需要多 个数据端点。 USB规定的4种数据传输方式也是通过管道进行，分别是控制传输（Control Transfer）、中 断传输（Interrupt Transfer）、批量传输或叫块传输（Bulk Transfer）、实时传输或叫同步传输 （Isochronous Transfer），每种模式规定了各自通讯时使用的管道类型。 ## ESP32设备USB 乐鑫ESP32 P4 内置了 USB 2.0 OTG High Speed、USB 2.0 OTG Full Speed 和 USB Serial JTAG 外设，为开发者提供了支持 USB 多媒体、通信、存储、人机交互等多种应用的能力。 ![image 20250606235549741](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506071136062.png) ### USB OTG Full speed 控制器简介 ESP32 P4 芯片内置USB OTG Full speed外设，它包含了USB控制器和USB PHY，支持通 过USB连接到PC机上，实现USB Host和USB Device功能。 ![image 20250607102021613](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506071136182.png) > 上述传输速率计算方法：传输速率（Bytes/s） 传输的最大尺寸 * 每毫秒传输包数量 * 1000。 ![image 20250607102224923](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506071136163.png) 1. USB Controller Core（USB控制器核心） OTG_FS 外设的核心部分，负责 USB功能的主要处理。它与多种接口协同工作以完成数据 传输及控制操作。 2. CPU Interface（CPU接口） 提供对控制器核心寄存器和 FIFO 的读/写访问。使用内部实现的 AHB 从接口，以“Slave Mode”方式访问FIFO。 3. APB Interface（APB接口） 它用于通过外部USB控制器管理控制器核心。允许CPU控制外部模块或进行查询操作。 4. DMA Interface（DMA接口） 控制器核心通过该接口以DMA模式访问系统内存。使用AHB主接口实现数据负载的读取与写入。 5. USB 2.0 Full Speed Interface（USB 全速接口） 用于连接 USB 2.0 全速串行收发器。ESP32 P4 包含两个全速收发器（FS_PHY1 和 FS_PHY2），可通过时分复用分别为USB Serial/JTAG控制器和USB OTG服务，eFuse可配置这 些收发器的连接关系，支持灵活调整硬件功能。 6. USB External Controller（USB外部控制器） 控制 USB串行接口与核心寄存器的路由。支持电源管理功能，例如通过关闭 AHB时钟或 SPRAM时钟来实现节能。 7. Data FIFO RAM Interface（FIFO数据 RAM接口） 控制器核心的多个FIFO动态分配在SPRAM中，而非控制器核心内。数据访问通过该接口 路由到SPRAM。 ### USB Serial JTAG 外设简介 ESP32 P4/S3 等芯片内置 USB Serial JTAG 外设，它包含了 USB to serial 转换器和 USB to JTAG 转换器，支持通过 USB 线连接到 PC，实现固件下载、调试和打印系统 LOG 等功能。 通过USB主机设备（以下简 称“主机”）与ESP32 P4直接通信，无需任何额外的外部组件即可实现这些功能。 ESP32 P4提供了USB串行/JTAG控制器，集成了USB转串口和USB转 JTAG 的功能。该模块通过USB 2.0协议仅使用两条数据线（D+和D ）与主机通信，仅需占用 两根引脚即可完成ESP32 P4的调试工作。 ![image 20250607104910104](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506071136541.png) CDC ACM模块中软件可访问的部分由APB_CLK 时钟驱动。JTAG命令处理器连接到主处理器的JTAG调试单元；CDC ACM寄存器连接到APB 总线，因此可以由主CPU运行的软件进行读写操作。 需要注意的是，虽然USB串行/JTAG设备支持USB 2.0标准，但它仅支持全速模式（12 M bps），而不支持USB 2.0标准引入的其他模式，例如高速模式（480 Mbps）。 基于这一优势，ESP32 P4 芯片内置 USB 串行/JTAG 控制器，能够高效地实现串口通信和 JTAG 调试功能，进一步减少对外部 USB UART 桥接芯片的依赖。通过该控制器，用户可以方 便地将ESP32 P4连接至主机或PC，进行各种操作和调试。如下图所示。 ![image 20250607105127251](C:\\Users\\14586\\AppData\\Roaming\\Typora\\typora user images\\image 20250607105127251.png) > PC机与 ESP32 P4 芯片之间的串口通信有三种连接方式。第一 幅图展示了通过ESP32 P4芯片的内部USB串行/JTAG控制器直接实现通信。第二和第三幅图则 展示了使用USB转UART模块连接ESP32 P4外设UART接口的两种方式，它们的唯一区别在 于：第二幅图是开发板上集成的USB转UART电路，而第三幅图则是一个独立的模块。 ![image 20250607110643816](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506071106995.png) 某些外设必须使用特定的管脚实现，例如具有调试功能的JTAG、USB串口 /JTAG、全速 USB 2.0和 EMAC等。如果在开发时未使用这些外设，我们可以利用IO MUX功 能对特定通信接口进行映射。然而，这些映射可能会影响传输速率，因此笔者建议开发者首先 采用ESP32 P4默认的复用功能IO设计原理图，然后再考虑其他IO映射功能，以确保系统性能 的稳定性和可靠性。 在ESP IDF的配置菜单中，选择USJ_ENABLE_USB_SERIAL_JTAG选项，即启用USB串 行/JTAG控制器 ![image 20250607120247653](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506071202740.png)"},"/note/嵌入式/esp32/esp-idf/2024-5-25-05I2S.html":{"title":"I2S","content":" layout: post title: \"I2S\" date: 2024 5 24 15:39:08 +0800 tags: esp32 ESP IDF # I2S ### 使用es8311芯片 这一个芯片ESP IDF自带的示例里面就有 可以直接使用 在example_config.h文件里面改一下使用的GPIO, 在main函数里面加入使能引脚的定义, 设置为高电平即可 > 使用的GPIO11需要使用uFuse进行设置 ![image 20240525112254805](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405251122910.png) > 回声模式可以设置麦克风的增益 ```c void app_main(void) { printf(\"i2s es8311 codec example start\\n \\n\"); printf(\"ESP_EFUSE_VDD_SPI_AS_GPIO start\\n \\n\"); //这一个引脚熔断只需要一次 //esp_efuse_write_field_bit(ESP_EFUSE_VDD_SPI_AS_GPIO); /* 初始化PA芯片NS4150B控制引脚 低电平关闭音频输出 高电平允许音频输出 */ gpio_config_t io_conf { .intr_type GPIO_INTR_DISABLE, //disable interrupt .mode GPIO_MODE_OUTPUT, //set as output mode .pin_bit_mask 1<<13, //bit mask of the pins .pull_down_en 0, //disable pull down mode .pull_up_en 1, //enable pull up mode }; //configure GPIO with the given settings gpio_config(&io_conf); gpio_set_level(GPIO_NUM_13, 1); // 输出高电平 /* Initialize i2s peripheral */ if (i2s_driver_init() ! ESP_OK) { ESP_LOGE(TAG, \"i2s driver init failed\"); abort(); } else { ESP_LOGI(TAG, \"i2s driver init success\"); } /* Initialize i2c peripheral and config es8311 codec by i2c */ if (es8311_codec_init() ! ESP_OK) { ESP_LOGE(TAG, \"es8311 codec init failed\"); abort(); } else { ESP_LOGI(TAG, \"es8311 codec init success\"); } #if CONFIG_EXAMPLE_MODE_MUSIC /* Play a piece of music in music mode */ xTaskCreate(i2s_music, \"i2s_music\", 4096, NULL, 5, NULL); #else /* Echo the sound from MIC in echo mode */ xTaskCreate(i2s_echo, \"i2s_echo\", 8192, NULL, 5, NULL); #endif } ``` ### 初始化I2S ```c static esp_err_t i2s_driver_init(void) { #if !defined(CONFIG_EXAMPLE_BSP) i2s_chan_config_t chan_cfg I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM, I2S_ROLE_MASTER); chan_cfg.auto_clear true; // Auto clear the legacy data in the DMA buffer ESP_ERROR_CHECK(i2s_new_channel(&chan_cfg, &tx_handle, &rx_handle)); i2s_std_config_t std_cfg { .clk_cfg I2S_STD_CLK_DEFAULT_CONFIG(EXAMPLE_SAMPLE_RATE), .slot_cfg I2S_STD_PHILIPS_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_16BIT, I2S_SLOT_MODE_STEREO), .gpio_cfg { //配置引脚 .mclk I2S_MCK_IO, .bclk I2S_BCK_IO, .ws I2S_WS_IO, .dout I2S_DO_IO, .din I2S_DI_IO, .invert_flags { .mclk_inv false, .bclk_inv false, .ws_inv false, }, }, }; std_cfg.clk_cfg.mclk_multiple EXAMPLE_MCLK_MULTIPLE; \t//设置模式 ESP_ERROR_CHECK(i2s_channel_init_std_mode(tx_handle, &std_cfg)); ESP_ERROR_CHECK(i2s_channel_init_std_mode(rx_handle, &std_cfg)); //使能通道 ESP_ERROR_CHECK(i2s_channel_enable(tx_handle)); ESP_ERROR_CHECK(i2s_channel_enable(rx_handle)); #else //这一个是乐鑫自己的开发板执行的函数 ESP_LOGI(TAG, \"Using BSP for HW configuration\"); i2s_std_config_t std_cfg { .clk_cfg I2S_STD_CLK_DEFAULT_CONFIG(EXAMPLE_SAMPLE_RATE), .slot_cfg I2S_STD_PHILIPS_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_16BIT, I2S_SLOT_MODE_STEREO), .gpio_cfg BSP_I2S_GPIO_CFG, }; std_cfg.clk_cfg.mclk_multiple EXAMPLE_MCLK_MULTIPLE; ESP_ERROR_CHECK(bsp_audio_init(&std_cfg, &tx_handle, &rx_handle)); ESP_ERROR_CHECK(bsp_audio_poweramp_enable(true)); #endif return ESP_OK; } ``` ### esc8311初始化 ```c static esp_err_t es8311_codec_init(void) { /* Initialize I2C peripheral */ #if !defined(CONFIG_EXAMPLE_BSP) //初始化I2C驱动 const i2c_config_t es_i2c_cfg { .sda_io_num I2C_SDA_IO, .scl_io_num I2C_SCL_IO, .mode I2C_MODE_MASTER, .sda_pullup_en GPIO_PULLUP_ENABLE, .scl_pullup_en GPIO_PULLUP_ENABLE, .master.clk_speed 100000, }; ESP_RETURN_ON_ERROR(i2c_param_config(I2C_NUM, &es_i2c_cfg), TAG, \"config i2c failed\"); ESP_RETURN_ON_ERROR(i2c_driver_install(I2C_NUM, I2C_MODE_MASTER, 0, 0, 0), TAG, \"install i2c driver failed\"); #else ESP_ERROR_CHECK(bsp_i2c_init()); #endif \t//初始化esc8311 /* Initialize es8311 codec */ es8311_handle_t es_handle es8311_create(I2C_NUM, ES8311_ADDRRES_0); ESP_RETURN_ON_FALSE(es_handle, ESP_FAIL, TAG, \"es8311 create failed\"); const es8311_clock_config_t es_clk { .mclk_inverted false, .sclk_inverted false, .mclk_from_mclk_pin true, .mclk_frequency EXAMPLE_MCLK_FREQ_HZ, .sample_frequency EXAMPLE_SAMPLE_RATE }; ESP_ERROR_CHECK(es8311_init(es_handle, &es_clk, ES8311_RESOLUTION_16, ES8311_RESOLUTION_16)); ESP_RETURN_ON_ERROR(es8311_sample_frequency_config(es_handle, EXAMPLE_SAMPLE_RATE * EXAMPLE_MCLK_MULTIPLE, EXAMPLE_SAMPLE_RATE), TAG, \"set es8311 sample frequency failed\");//采样频率 ESP_RETURN_ON_ERROR(es8311_voice_volume_set(es_handle, EXAMPLE_VOICE_VOLUME, NULL), TAG, \"set es8311 volume failed\");//声音大小 ESP_RETURN_ON_ERROR(es8311_microphone_config(es_handle, false), TAG, \"set es8311 microphone failed\");//设置麦克风false: 模拟麦克风 true数字麦克风 #if CONFIG_EXAMPLE_MODE_ECHO ESP_RETURN_ON_ERROR(es8311_microphone_gain_set(es_handle, EXAMPLE_MIC_GAIN), TAG, \"set es8311 microphone gain failed\");//配置麦克风的增益 #endif return ESP_OK; } ``` ```c typedef struct { i2c_port_t port; uint16_t dev_addr; } es8311_dev_t; es8311_handle_t es8311_create(const i2c_port_t port, const uint16_t dev_addr) { es8311_dev_t *sensor (es8311_dev_t *) calloc(1, sizeof(es8311_dev_t)); sensor >port port; sensor >dev_addr dev_addr; return (es8311_handle_t) sensor; } ``` ### 执行任务 ```c static void i2s_music(void *args) { esp_err_t ret ESP_OK; size_t bytes_write 0; uint8_t *data_ptr (uint8_t *)music_pcm_start; /* (Optional) Disable TX channel and preload the data before enabling the TX channel, * so that the valid data can be transmitted immediately */ ESP_ERROR_CHECK(i2s_channel_disable(tx_handle));//输出通道禁止 ESP_ERROR_CHECK(i2s_channel_preload_data(tx_handle, data_ptr, music_pcm_end data_ptr, &bytes_write));//预加载输出的数据 data_ptr + bytes_write; // Move forward the data pointer /* Enable the TX channel */ ESP_ERROR_CHECK(i2s_channel_enable(tx_handle));//开启 while (1) { /* Write music to earphone */ ret i2s_channel_write(tx_handle, data_ptr, music_pcm_end data_ptr, &bytes_write, portMAX_DELAY);//输出音乐, 使用的是canon.pcm这一个文件 if (ret ! ESP_OK) { /* Since we set timeout to 'portMAX_DELAY' in 'i2s_channel_write' so you won't reach here unless you set other timeout value, if timeout detected, it means write operation failed. */ ESP_LOGE(TAG, \"[music] i2s write failed, %s\", err_reason[ret ESP_ERR_TIMEOUT]); abort(); } if (bytes_write > 0) { ESP_LOGI(TAG, \"[music] i2s music played, %d bytes are written.\", bytes_write); } else { ESP_LOGE(TAG, \"[music] i2s music play failed.\"); abort(); } data_ptr (uint8_t *)music_pcm_start; vTaskDelay(1000 / portTICK_PERIOD_MS); } vTaskDelete(NULL); } #else static void i2s_echo(void *args) { int *mic_data malloc(EXAMPLE_RECV_BUF_SIZE); if (!mic_data) { ESP_LOGE(TAG, \"[echo] No memory for read data buffer\"); abort(); } esp_err_t ret ESP_OK; size_t bytes_read 0; size_t bytes_write 0; ESP_LOGI(TAG, \"[echo] Echo start\"); while (1) { memset(mic_data, 0, EXAMPLE_RECV_BUF_SIZE); /* Read sample data from mic */ ret i2s_channel_read(rx_handle, mic_data, EXAMPLE_RECV_BUF_SIZE, &bytes_read, 1000); if (ret ! ESP_OK) { ESP_LOGE(TAG, \"[echo] i2s read failed, %s\", err_reason[ret ESP_ERR_TIMEOUT]); abort(); } /* Write sample data to earphone */ ret i2s_channel_write(tx_handle, mic_data, EXAMPLE_RECV_BUF_SIZE, &bytes_write, 1000); if (ret ! ESP_OK) { ESP_LOGE(TAG, \"[echo] i2s write failed, %s\", err_reason[ret ESP_ERR_TIMEOUT]); abort(); } if (bytes_read ! bytes_write) { ESP_LOGW(TAG, \"[echo] %d bytes read but only %d bytes are written\", bytes_read, bytes_write); } } vTaskDelete(NULL); } #endif ``` ### 配置自己的音乐 1. Choose the music in any format you want to play (e.g. a.mp3) 2. Install 'ffmpeg' tool 安装这一个工具 3. Check your music format using `ffprobe a.mp3`, you can get the stream format (e.g. Stream #0.0: Audio: mp3, 44100Hz, stereo, s16p, 64kb/s) 剪切 4. Cut your music since there is no enough space for the whole piece of music. `ffmpeg i a.mp3 ss 00:00:00 t 00:00:20 a_cut.mp3` 5. Transfer the music format into .pcm. `ffmpeg i a_cut.mp3 f s16ls ar 16000 ac 1 acodec pcm_s16le a.pcm`转换格式 6. Move 'a.pcm' under 'main' directory 7. Replace 'canon.pcm' with 'a.pcm' in 'CMakeLists.txt' under 'main' directory 改配置文件 8. Replace '_binary_canon_pcm_start' and '_binary_canon_pcm_end' with '_binary_a_pcm_start' and '_binary_a_pcm_end' in `i2s_es8311_example.c` 9. Download the example and enjoy your own music ## I2S协议 ![image 20250703143711535](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507031437643.png) + 时钟线（Continues Serial Clock，SCK）：SCK线提供了同步音频数据传输的时钟信号。确定了数据传输的速度和时序。该时钟也称为Bit Clock（BCLK）。SCK的频率 2x采样频率x位宽 + 左/右声道线（Left Right Clock，LRCK）：LRCK线指示了当前传输的是左声道的音频数据还是右声道的音频数据。它被称为帧同步信号。LRCK的频率 采样频率 + 数据线（Serial Data，SD ）：SD线用于传输实际的音频数据。数据的位宽可以根据具体应用而变化，通常为16位或32位。TX方向为：Serial Data Out（SDOUT）；RX方向为：Serial Data In（SDIN）。 I2S协议中常见的参数 + 位宽（Word Length）：位宽指定每个采样数据的位数，通常为16位或32位。较大的位宽可以提供更高的分辨率和动态范围。 + 时钟极性（Clock Polarity）：时钟极性确定了数据位传输的时钟沿。根据具体的I2S设备和系统设置，可以定义在时钟上升沿或下降沿开始数据传输 + 帧同步极性（Frame Sync Polarity）：帧同步极性确定了帧同步信号的有效电平。帧同步信号指示音频数据的帧起始和结束位置。 + 传输格式（Data Format）：传输格式定义了音频数据的编码方式，传输格式还可以指定数据的顺序，如左声道先传输还是右声道先传输 + i2s协议的位宽指的是每个数据帧中的位数，包括左右声道、同步信号等，通常是16位或24位。位深指的是每个样本的位数，也就是每个数据帧中每个声道的采样深度，常见的有16位、24位或32位。 时钟的提供可以有三种模式, 主模式（Master Mode）或从模式（Slave Mode）。两者唯一的区别是：Master Mode提供时钟信号（SCK）和帧同步信号（LRCK）。如下图所示，一共存在三种工作模式，分别是： 1.发射器（transmitter）为Master，接收器（receiver）为Slave，此时由发射器提供SCK和LRCK 2.接收器（receiver）为Master，发射器（transmitter）为Slave，此时由接收器提供SCK和LRCK 3.发射器（transmitter）和接收器（receiver）均为Slave，由系统中其他模块提供SCK和LRCK ![image 20250703143915111](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507031439229.png) ### 实际的数据传输 I2S接口标准中，存在三种数据传输模式，分别是：飞利浦标准模式（I2S mode），左对齐（Left Justified）和右对齐（Right Justified）三种传输模式。 + 飞利浦格式 ![image 20250703144048550](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507031440648.png) （1）LRCK（左右声道选择信号）：LRCK信号用于指示当前数据帧是左声道数据还是右声道数据。飞利浦格式中，当LRCK为低时，表示当前传输的数据是左声道数据；当LRCK为高时，表示当前传输的数据为右声道数据 （2）SCK（位时钟）：数据传输的时钟信号。在SCK下降沿发送数据，在SCK上升沿采样数据 （3）Data Delay：发送的有效数据相对于LRCK的跳变沿（从0到1或从1到0）延迟一个时钟周期 （4）数据发送从MSB开始；数据MSB与LRCK delay 1个SCK的边沿对齐 + 左对齐 ![image 20250703144122666](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507031441743.png) （1）在左对齐格式中，LRCK为高时，表示当前传输的数据为左声道数据；当LRCK为低时，表示当前传输的数据为右声道数据 （2）在SCK下降沿发送数据，在SCK上升沿接收数据 （3）无data delay：发送的有效数据相当于LRCK跳变沿（从0到1或从1到0）不延迟 （4）数据发送从MSB开始；数据MSB与LRCK跳变沿对齐 + 右对齐 （1）右对齐格式中，LRCK为高电平时，表示当前传输的数据为右声道数据；当LRCK为低电平时，表示当前传输的数据为左声道数据 （2）在SCK下降沿发送数据，在SCK上升沿接收数据 （3）无Data delay：发送的有效数据相当于LRCK跳变沿（从0到1或从1到0）不延迟 （4）数据发送从MSB开始；数据LSB与LRCK跳变沿对齐"},"/note/嵌入式/esp32/esp-idf/2024-6-24-20OTA数据分区.html":{"title":"OTA数据分析","content":" layout: post title: \"OTA数据分析\" date: 2024 6 24 15:39:08 +0800 tags: esp32 ESP IDF # 数据分析 分区表里面必须要有一个OTA数据分区, 类型为Data 第一次 OTA 升级后，OTA 数据分区更新，指定下一次启动哪个 OTA 应用程序分区。 ![image 20240625174631671](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406251746731.png) 1. 如果在项目 `PROJECT_VER` 文件中设置`PROJECT_VER`变量，则使用它的值。 2. 否则，如果 `$PROJECT_PATH/version.txt` 存在，它的内容将用作 `PROJECT_VER`。 3. 否则，如果项目位于Git存储库中，则使用 `git describe`的输出. ## 应用回滚 应用程序回滚的主要目的是确保设备在更新后正常工作。如果新版应用程序出现严重错误，该功能可使设备回滚到之前正常运行的应用版本。在使能回滚并且 OTA 升级应用程序至新版本后，可能出现的结果如下： 应用程序运行正常，[`esp_ota_mark_app_valid_cancel_rollback()`](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/system/ota.html#_CPPv438esp_ota_mark_app_valid_cancel_rollbackv) 将正在运行的应用程序状态标记为 `ESP_OTA_IMG_VALID`，启动此应用程序无限制。 应用程序出现严重错误，无法继续工作，必须回滚到此前的版本，[`esp_ota_mark_app_invalid_rollback_and_reboot()`](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/system/ota.html#_CPPv444esp_ota_mark_app_invalid_rollback_and_rebootv) 将正在运行的版本标记为 `ESP_OTA_IMG_INVALID` 然后复位。引导加载程序不会选取此版本，而是启动此前正常运行的版本。 如果 [CONFIG_BOOTLOADER_APP_ROLLBACK_ENABLE](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/kconfig.html#config bootloader app rollback enable) 使能，则无需调用函数便可复位，回滚至之前的应用版本。 ```c const esp_partition_t *running esp_ota_get_running_partition(); esp_ota_img_states_t ota_state; //获取当前的状态 if (esp_ota_get_state_partition(running, &ota_state) ESP_OK) { if (ota_state ESP_OTA_IMG_PENDING_VERIFY) { //这一个状态表示当前的程序是第一次启动 // run diagnostic function ... bool diagnostic_is_ok diagnostic(); if (diagnostic_is_ok) { ESP_LOGI(TAG, \"Diagnostics completed successfully! Continuing execution ...\"); esp_ota_mark_app_valid_cancel_rollback(); //标记一下当前的程序是有效的 } else { ESP_LOGE(TAG, \"Diagnostics failed! Start rollback to the previous version ...\"); esp_ota_mark_app_invalid_rollback_and_reboot();//标记一下当前的程序是无效的, 并且重启, 重启后会回到上一个版本 } } } ``` > 程序的状态是放在`otadata` 分区, 该分区有一个 `ota_seq` 计数器，该计数器是 OTA 应用分区的指针，指向下次启动时选取应用所在的分区 (`ota_0`, `ota_1`, ...)。 Kconfig 中的 [CONFIG_BOOTLOADER_APP_ROLLBACK_ENABLE](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/kconfig.html#config bootloader app rollback enable) 可以帮助用户追踪新版应用程序的第一次启动。应用程序需调用 [`esp_ota_mark_app_valid_cancel_rollback()`](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/system/ota.html#_CPPv438esp_ota_mark_app_valid_cancel_rollbackv) 函数确认可以运行，否则将会在重启时回滚至旧版本。该功能可让用户在启动阶段控制应用程序的可操作性。新版应用程序仅有一次机会尝试是否能成功启动。 状态 引导加载程序选取启动应用程序的限制 ESP_OTA_IMG_VALID 没有限制，可以选取。 ESP_OTA_IMG_UNDEFINED 没有限制，可以选取。 ESP_OTA_IMG_INVALID 不会选取。 ESP_OTA_IMG_ABORTED 不会选取。 ESP_OTA_IMG_NEW 如使能 [CONFIG_BOOTLOADER_APP_ROLLBACK_ENABLE](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/kconfig.html#config bootloader app rollback enable)， 则仅会选取一次。在引导加载程序中，状态立即变为 `ESP_OTA_IMG_PENDING_VERIFY`。 ESP_OTA_IMG_PENDING_VERIFY 如使能 [CONFIG_BOOTLOADER_APP_ROLLBACK_ENABLE](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/kconfig.html#config bootloader app rollback enable)， 则不会选取，状态变为 `ESP_OTA_IMG_ABORTED`。 > 默认的时候这一个是没有启用的, ESP_OTA_IMG_PENDING_VERIFY是不会到达的 > > 如果失能, 第一次启动的时候状态从ESP_OTA_IMG_NEW, 变为ESP_OTA_IMG_PENDING_VERIFY, 如果不使用esp_ota_mark_app_valid_cancel_rollback();进行设置之后会变为ESP_OTA_IMG_PENDING_VERIFY不能在进行启动 ### 自动回滚过程 [CONFIG_BOOTLOADER_APP_ROLLBACK_ENABLE](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/kconfig.html#config bootloader app rollback enable) 使能时，回滚过程如下： 新版应用程序下载成功，[`esp_ota_set_boot_partition()`](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/system/ota.html#_CPPv426esp_ota_set_boot_partitionPK15esp_partition_t) 函数将分区设为可启动，状态设为 `ESP_OTA_IMG_NEW`。该状态表示应用程序为新版本，第一次启动需要监测。 重新启动 [`esp_restart()`](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/system/misc_system_api.html#_CPPv411esp_restartv)。 引导加载程序检查 `ESP_OTA_IMG_PENDING_VERIFY` 状态，如有设置，则将其写入 `ESP_OTA_IMG_ABORTED`。 引导加载程序选取一个新版应用程序来引导，这样应用程序状态就不会设置为 `ESP_OTA_IMG_INVALID` 或 `ESP_OTA_IMG_ABORTED`。 引导加载程序检查所选取的新版应用程序，若状态设置为 `ESP_OTA_IMG_NEW`，则写入 `ESP_OTA_IMG_PENDING_VERIFY`。该状态表示，需确认应用程序的可操作性，如不确认，发生重启，则状态会重写为 `ESP_OTA_IMG_ABORTED` （见上文），该应用程序不可再启动，将回滚至上一版本。 新版应用程序启动，应进行自测。 若通过自测，则必须调用函数 [`esp_ota_mark_app_valid_cancel_rollback()`](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/system/ota.html#_CPPv438esp_ota_mark_app_valid_cancel_rollbackv)，因为新版应用程序在等待确认其可操作性（`ESP_OTA_IMG_PENDING_VERIFY` 状态）。 若未通过自测，则调用函数 [`esp_ota_mark_app_invalid_rollback_and_reboot()`](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/system/ota.html#_CPPv444esp_ota_mark_app_invalid_rollback_and_rebootv)，回滚至之前能正常工作的应用程序版本，同时将无效的新版本应用程序设置为 `ESP_OTA_IMG_INVALID`。 如果新版应用程序可操作性没有确认，则状态一直为 `ESP_OTA_IMG_PENDING_VERIFY`。下一次启动时，状态变更为 `ESP_OTA_IMG_ABORTED`，阻止其再次启动，之后回滚到之前的版本。 > 尽快完成, 防止意外复位, 自测以后设置状态是用户代码实现的 ## 实际的更新 1. 查看当前的版本, 看一看启动的是不是配置的版本 ```c static void ota_example_task(void *pvParameter) { esp_err_t err; /* update handle : set by esp_ota_begin(), must be freed via esp_ota_end() */ esp_ota_handle_t update_handle 0 ; const esp_partition_t *update_partition NULL; ESP_LOGI(TAG, \"Starting OTA example task\"); const esp_partition_t *configured esp_ota_get_boot_partition(); //获取配置的分区 const esp_partition_t *running esp_ota_get_running_partition(); //获取当前运行的分区 if (configured ! running) { //版本不一致, 可能出错, 提示一下 ESP_LOGW(TAG, \"Configured OTA boot partition at offset 0x%08\"PRIx32\", but running from offset 0x%08\"PRIx32, configured >address, running >address); ESP_LOGW(TAG, \"(This can happen if either the OTA boot data or preferred boot image become corrupted somehow.)\"); } ESP_LOGI(TAG, \"Running partition type %d subtype %d (offset 0x%08\"PRIx32\")\", running >type, running >subtype, running >address); \t//设置一下http的服务器 esp_http_client_config_t config { .url CONFIG_EXAMPLE_FIRMWARE_UPG_URL, .cert_pem (char *)server_cert_pem_start, .timeout_ms CONFIG_EXAMPLE_OTA_RECV_TIMEOUT, .keep_alive_enable true, }; #ifdef CONFIG_EXAMPLE_FIRMWARE_UPGRADE_URL_FROM_STDIN char url_buf[OTA_URL_SIZE]; if (strcmp(config.url, \"FROM_STDIN\") 0) { example_configure_stdin_stdout(); fgets(url_buf, OTA_URL_SIZE, stdin); int len strlen(url_buf); url_buf[len 1] '\\0'; config.url url_buf; } else { ESP_LOGE(TAG, \"Configuration mismatch: wrong firmware upgrade image url\"); abort(); } #endif #ifdef CONFIG_EXAMPLE_SKIP_COMMON_NAME_CHECK config.skip_cert_common_name_check true; #endif //获取http client esp_http_client_handle_t client esp_http_client_init(&config); if (client NULL) { ESP_LOGE(TAG, \"Failed to initialise HTTP connection\"); task_fatal_error(); } //开启http服务器 err esp_http_client_open(client, 0); if (err ! ESP_OK) { ESP_LOGE(TAG, \"Failed to open HTTP connection: %s\", esp_err_to_name(err)); esp_http_client_cleanup(client); task_fatal_error(); } esp_http_client_fetch_headers(client); //从Flash里面获取一个可以使用的分区 update_partition esp_ota_get_next_update_partition(NULL); //获取下一个可以进行写入的位置 assert(update_partition ! NULL); ESP_LOGI(TAG, \"Writing to partition subtype %d at offset 0x%\"PRIx32, update_partition >subtype, update_partition >address); int binary_file_length 0; //记录当前的bin文件大小 /*deal with all receive packet*/ bool image_header_was_checked false; while (1) { int data_read esp_http_client_read(client, ota_write_data, BUFFSIZE); //获取数据, 数据在ota_write_data里面 if (data_read < 0) { ESP_LOGE(TAG, \"Error: SSL data read error\"); http_cleanup(client); task_fatal_error(); } else if (data_read > 0) { //成功获取数据 if (image_header_was_checked false) { //第一次获取数据, 需要把数据头部进行解析 esp_app_desc_t new_app_info; //分析一下获取的信息 if (data_read > sizeof(esp_image_header_t) + sizeof(esp_image_segment_header_t) + sizeof(esp_app_desc_t)) { // check current version with downloading //获取新的image文件的头部信息 memcpy(&new_app_info, &ota_write_data[sizeof(esp_image_header_t) + sizeof(esp_image_segment_header_t)], sizeof(esp_app_desc_t)); ESP_LOGI(TAG, \"New firmware version: %s\", new_app_info.version); //获取当前运行的程序的版本相关的信息 esp_app_desc_t running_app_info; if (esp_ota_get_partition_description(running, &running_app_info) ESP_OK) { ESP_LOGI(TAG, \"Running firmware version: %s\", running_app_info.version); } //获取上一次无效的程序的版本 const esp_partition_t* last_invalid_app esp_ota_get_last_invalid_partition(); esp_app_desc_t invalid_app_info; if (esp_ota_get_partition_description(last_invalid_app, &invalid_app_info) ESP_OK) { ESP_LOGI(TAG, \"Last invalid firmware version: %s\", invalid_app_info.version); } // check current version with last invalid partition if (last_invalid_app ! NULL) { //如果当前的版本和上一次无效的版本是一样的，那么就不进行更新 if (memcmp(invalid_app_info.version, new_app_info.version, sizeof(new_app_info.version)) 0) { ESP_LOGW(TAG, \"New version is the same as invalid version.\"); ESP_LOGW(TAG, \"Previously, there was an attempt to launch the firmware with %s version, but it failed.\", invalid_app_info.version); ESP_LOGW(TAG, \"The firmware has been rolled back to the previous version.\"); http_cleanup(client); //无限循环 infinite_loop(); } } #ifndef CONFIG_EXAMPLE_SKIP_VERSION_CHECK //比较当前的版本和新的版本是否一样 if (memcmp(new_app_info.version, running_app_info.version, sizeof(new_app_info.version)) 0) { ESP_LOGW(TAG, \"Current running version is the same as a new. We will not continue the update.\"); http_cleanup(client); infinite_loop(); } #endif //检查image的头部信息 image_header_was_checked true; //擦除分区update_handle是一个传出参数, 表示状态 err esp_ota_begin(update_partition, OTA_WITH_SEQUENTIAL_WRITES, &update_handle); if (err ! ESP_OK) { ESP_LOGE(TAG, \"esp_ota_begin failed (%s)\", esp_err_to_name(err)); http_cleanup(client); esp_ota_abort(update_handle); task_fatal_error(); } ESP_LOGI(TAG, \"esp_ota_begin succeeded\"); } else { ESP_LOGE(TAG, \"received package is not fit len\"); http_cleanup(client); esp_ota_abort(update_handle); task_fatal_error(); } } //写入数据, 除了第一次直接回到这里来, 数据直接写入 err esp_ota_write( update_handle, (const void *)ota_write_data, data_read); if (err ! ESP_OK) { http_cleanup(client); esp_ota_abort(update_handle); task_fatal_error(); } binary_file_length + data_read; ESP_LOGD(TAG, \"Written image length %d\", binary_file_length); } else if (data_read 0) { //读取结束 /* * As esp_http_client_read never returns negative error code, we rely on * `errno` to check for underlying transport connectivity closure if any */ if (errno ECONNRESET errno ENOTCONN) { ESP_LOGE(TAG, \"Connection closed, errno %d\", errno); break; } if (esp_http_client_is_complete_data_received(client) true) { ESP_LOGI(TAG, \"Connection closed\"); break; } } } //关闭http连接 ESP_LOGI(TAG, \"Total Write binary data length: %d\", binary_file_length); if (esp_http_client_is_complete_data_received(client) ! true) { ESP_LOGE(TAG, \"Error in receiving complete file\"); http_cleanup(client); esp_ota_abort(update_handle); task_fatal_error(); } err esp_ota_end(update_handle); if (err ! ESP_OK) { if (err ESP_ERR_OTA_VALIDATE_FAILED) { ESP_LOGE(TAG, \"Image validation failed, image is corrupted\"); } else { ESP_LOGE(TAG, \"esp_ota_end failed (%s)!\", esp_err_to_name(err)); } http_cleanup(client); task_fatal_error(); } \t//设置新的启动 err esp_ota_set_boot_partition(update_partition); if (err ! ESP_OK) { ESP_LOGE(TAG, \"esp_ota_set_boot_partition failed (%s)!\", esp_err_to_name(err)); http_cleanup(client); task_fatal_error(); } ESP_LOGI(TAG, \"Prepare to restart system!\"); //重启进入新的程序 esp_restart(); return ; } ``` ### API ```c const esp_partition_t *esp_ota_get_boot_partition(void) ``` > Get partition info of currently configured boot app.获取当前配置的启动APP > > If esp_ota_set_boot_partition() has been called, the partition which was set by that function will be returned.使用esp_ota_set_boot_partition这一个进行设置, 没有设置的时候一般是当前运行的APP ```c const esp_partition_t *esp_ota_get_running_partition(void) ``` > 获取运行的APP ```c const esp_partition_t *esp_ota_get_next_update_partition(const esp_partition_t *start_from) ``` > 获取下一个OTA分区, 从当前的running分区开始 ```c esp_err_t esp_ota_begin(const esp_partition_t *partition, size_t image_size, esp_ota_handle_t *out_handle) ``` > 开始启动OTA擦除, 需要设置image的大小从而开始擦除**out_handle**是一个传出参数 ```c esp_err_t esp_ota_write(esp_ota_handle_t handle, const void *data, size_t size) ``` > 开始进行写入 ```c esp_err_t esp_ota_end(esp_ota_handle_t handle) ``` > 写入结束 ```c esp_err_t esp_ota_abort(esp_ota_handle_t handle) ``` > 写入出错的时候中断使用这一个 ```c esp_err_t esp_ota_set_boot_partition(const esp_partition_t *partition ``` > 设置启动的分区 ```c esp_err_t esp_ota_get_partition_description(const esp_partition_t *partition, esp_app_desc_t *app_desc) ``` > 从app的部分获取app的版本信息 ```c const esp_partition_t *esp_ota_get_last_invalid_partition(void) ``` > 获取上一次出错的版本"},"/note/嵌入式/esp32/esp-idf/2025-3-27-33照相机.html":{"title":"照相机","content":"# 照相机 使用[esp32的照相机库进行驱动](https://components.espressif.com/components/espressif/esp32 camera/versions/2.0.15), 嘉立创的开安防办使用的是gc0308摄像头, [ESP32 Cam 通过Http协议来显示一张图片_esp32可以显示网络图片么 CSDN博客](https://blog.csdn.net/qq_28877125/article/details/103446024) ![image 20250327132653516](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202503271326795.png) 可以支持的输出模式如下 ## 初始化 ```cpp // 摄像头硬件初始化 void bsp_camera_init(void) { dvp_pwdn(0); // 打开摄像头, 这个引脚是照相机的电源引脚 camera_config_t config; config.ledc_channel LEDC_CHANNEL_1; // LEDC通道选择 用于生成XCLK时钟 但是S3不用 config.ledc_timer LEDC_TIMER_1; // LEDC timer选择 用于生成XCLK时钟 但是S3不用 config.pin_d0 CAMERA_PIN_D0; config.pin_d1 CAMERA_PIN_D1; config.pin_d2 CAMERA_PIN_D2; config.pin_d3 CAMERA_PIN_D3; config.pin_d4 CAMERA_PIN_D4; config.pin_d5 CAMERA_PIN_D5; config.pin_d6 CAMERA_PIN_D6; config.pin_d7 CAMERA_PIN_D7; config.pin_xclk CAMERA_PIN_XCLK; config.pin_pclk CAMERA_PIN_PCLK; config.pin_vsync CAMERA_PIN_VSYNC; config.pin_href CAMERA_PIN_HREF; config.pin_sccb_sda 1; // 这里写 1 表示使用已经初始化的I2C接口 config.pin_sccb_scl CAMERA_PIN_SIOC; config.sccb_i2c_port 0; // 实际使用的i2c的标号 config.pin_pwdn CAMERA_PIN_PWDN; config.pin_reset CAMERA_PIN_RESET; config.xclk_freq_hz XCLK_FREQ_HZ; config.pixel_format PIXFORMAT_RGB565; // 设置一下输出的模式 config.frame_size FRAMESIZE_QVGA; config.jpeg_quality 12; config.fb_count 2; config.fb_location CAMERA_FB_IN_PSRAM; config.grab_mode CAMERA_GRAB_WHEN_EMPTY; // camera init esp_err_t err esp_camera_init(&config); // 配置上面定义的参数 if (err ! ESP_OK) { ESP_LOGE(TAG, \"Camera init failed with error 0x%x\", err); return; } sensor_t *s esp_camera_sensor_get(); // 获取摄像头型号 if (s >id.PID GC0308_PID) { s >set_hmirror(s, 1); // 这里控制摄像头镜像 写1镜像 写0不镜像 } } ``` ## 网页 [ESP32 Cam 通过Http协议来显示一张图片_esp32可以显示网络图片么 CSDN博客](https://blog.csdn.net/qq_28877125/article/details/103446024) ```c ```"},"/note/嵌入式/esp32/esp-idf/2024-6-22-18蓝牙HID控制.html":{"title":"HID蓝牙配对","content":" layout: post title: \"HID蓝牙配对\" date: 2024 6 22 15:39:08 +0800 tags: esp32 ESP IDF # HID蓝牙控制 使用的是HOGP这一个协议 使用一个报告地图进行描述数据的格式(实际的数据使用gatt里面的一个表项), 之后使用发送数据修改这一个表项的方式进行发送数据 ## HOGP规范 ![image 20240622230516285](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406222305974.png) HID设备通过HOGP这一个协议进行连接 HID（Human Interface Device，人机接口设备）是 USB 设备中常用的设备类型，是直接与人交互的 USB 设备，例如键盘、鼠标与游戏杆等。HID 设备并不一定要有人机交互功能，只要符合 HID 类别规范的设备都是HID 设备。 Wndows操作系统最先支持的HID设备。在windows 98以及后来的版本中内置有HID设备的驱动程序，应用程序可以直接使用这些驱动程序来与设备通信。 在设计一个 USB 接口的计算机外部设备时，如果 HID 类型的设备可以满足需要，可以将其设计为 HID 类型设备，这样可以省去比较复杂的 USB 驱动程序的编写，直接利用Windows 操作系统对标准的 HID 类型 USB 设备的支持。 ![image 20240622231038265](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406222310320.png) ## 蓝牙HID服务 ![image 20240622231339714](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406222313801.png) ![image 20240622231410183](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406222314235.png) > 硬件本地化, 这一个和不同的国家有关 > > 使用的模式一般是使用报告模式 > > 控制点: 设备低功耗模式, 可一个是可选的 <img src \"https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406222319353.png\" alt \"image 20240622231943306\" style \"zoom:150%;\" /> ## 数据格式 对应代码里面的hidReportMap ![image 20240623122116963](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406231221040.png) ![image 20240623122630648](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406231226734.png) > USB_HID协议中文版.pdf这一个文档里面有实际的数据的每一位含义的描述 > > 在使用输入标签的时候, 数据最多只定义了9位 ![image 20240623152748240](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406231527295.png) ```c // HID Report Map characteristic value // Keyboard report descriptor (using format for Boot interface descriptor) static const uint8_t hidReportMap[] { 0x05, 0x01, // Usage Page (Generic Desktop) 用途: 桌面通用 0000 0101 0000 0001 Global标签, 长度为1, 使用页面 0x09, 0x02, // Usage (Mouse) 用途 鼠标 0000 1001 0000 0010 标签, 大小为1, 用法页面 0xA1, 0x01, // Collection (Application) 1010 0001 0000 0001开集合 这是一个应用程序 0x85, 0x01, // Report Id (1) 1000 0101 报告ID, ID是01 0x09, 0x01, // Usage (Pointer) 用途指针 0xA1, 0x00, // Collection (Physical) 开集合 物理 //第一个8位数据 0x05, 0x09, // Usage Page (Buttons) 用途页, 按键 0x19, 0x01, // Usage Minimum (01) Button 1 最小值左键 0x29, 0x03, // Usage Maximum (03) Button 3 最大值 中键 0x15, 0x00, // Logical Minimum (0) 逻辑最小值 按键抬起 0x25, 0x01, // Logical Maximum (1) 逻辑最大值 按键按下 0x75, 0x01, // Report Size (1) 报告的大小, 每一个占一位 0x95, 0x03, // Report Count (3) 一共有三个报告: 3个按键 0x81, 0x02, // Input (Data, Variable, Absolute) Button states 数据输入, 可变, 独立, 绝对值 0x75, 0x05, // Report Size (5) 报告大小 5个bit, 和前面的3bit为一个byte(这几位是无效的) 0x95, 0x01, // Report Count (1) 报告数量 1 0x81, 0x01, // Input (Constant) Padding or Reserved bits 数据输入: 常量, 独立, 绝对值 //3个字节, 鼠标的位移 0x05, 0x01, // Usage Page (Generic Desktop) 0x09, 0x30, // Usage (X) 0x09, 0x31, // Usage (Y) 0x09, 0x38, // Usage (Wheel) 0x15, 0x81, // Logical Minimum ( 127) 0x25, 0x7F, // Logical Maximum (127) 0x75, 0x08, // Report Size (8) 0x95, 0x03, // Report Count (3) 0x81, 0x06, // Input (Data, Variable, Relative) X & Y coordinate 输入的数据相对值 0xC0, // End Collection 0xC0, // End Collection ``` > 第一行是一个Usage的声明, 在hut1_22.pdf这一个文件里面有这一个类型的数据的具体类型 > > ![image 20240623150212401](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406231502448.png) > > 使用页面的列表 > > ![image 20240623145901217](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406231459279.png) > > 使用页面下面的用法, 这一个是第一条获取的, 0x02是鼠标 ![image 20240623154108299](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406231541360.png) ```c 0x05, 0x01, // Usage Pg (Generic Desktop) 0x09, 0x06, // Usage (Keyboard) 0xA1, 0x01, // Collection: (Application) 0x85, 0x02, // Report Id (2) // 0x05, 0x07, // Usage Pg (Key Codes) 0x19, 0xE0, // Usage Min (224) 0x29, 0xE7, // Usage Max (231) 0x15, 0x00, // Log Min (0) 0x25, 0x01, // Log Max (1) // // Modifier byte 第一个byte 0x75, 0x01, // Report Size (1) 0x95, 0x08, // Report Count (8) 0x81, 0x02, // Input: (Data, Variable, Absolute) // // Reserved byte 保留的那一byte 0x95, 0x01, // Report Count (1) 0x75, 0x08, // Report Size (8) 0x81, 0x01, // Input: (Constant) // // LED report 0x95, 0x05, // Report Count (5) 0x75, 0x01, // Report Size (1) 0x05, 0x08, // Usage Pg (LEDs) 0x19, 0x01, // Usage Min (1) 0x29, 0x05, // Usage Max (5) 0x91, 0x02, // Output: (Data, Variable, Absolute) // // LED report padding 0x95, 0x01, // Report Count (1) 0x75, 0x03, // Report Size (3) 0x91, 0x01, // Output: (Constant) // // Key arrays (6 bytes) 按键 0x95, 0x06, // Report Count (6) 0x75, 0x08, // Report Size (8) 0x15, 0x00, // Log Min (0) 0x25, 0x65, // Log Max (101) 0x05, 0x07, // Usage Pg (Key Codes) 0x19, 0x00, // Usage Min (0) 0x29, 0x65, // Usage Max (101) 0x81, 0x00, // Input: (Data, Array) // 0xC0, // End Collection ``` ## 实际实现 ![image 20240622223526138](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406222235194.png) 1. 初始化低功耗蓝牙 2. 注册回调函数, 设置安全相关的参数 3. 在hid的回调函数里面设置GAP的设备名字以及设备的设置 4. 在hidd注册函数里面设置gatt的回调函数, 以及APP的注册 5. gatt的回调函数里面设置数据库(先设置电池) ```c esp_hidd_register_callbacks(hidd_event_callback); ``` > 使用者一个函数注册HID的回调函数"},"/note/嵌入式/esp32/esp-idf/2024-6-8-13AI大语言模型.html":{"title":"AI大语言模型","content":" layout: post title: \"AI大语言模型\" date: 2024 6 8 15:39:08 +0800 tags: esp32 ESP IDF # AI大语言模型"},"/note/嵌入式/esp32/esp-idf/2024-5-23-01ESP-IDF接口.html":{"title":"接口","content":" layout: post title: \"接口\" date: 2024 5 23 15:39:08 +0800 tags: esp32 ESP IDF # 接口 ## 宏定义 ### ESP_ERROR_CHECK检错 ```c #define ESP_ERROR_CHECK(x) do { \\ esp_err_t err_rc_ (x); \\ if (unlikely(err_rc_ ! ESP_OK)) { \\ _esp_error_check_failed(err_rc_, __FILE__, __LINE__, \\ __ASSERT_FUNC, #x); \\ } \\ } while(0) ``` ### 日志 [ESP32学习笔记（6）——Log日志库使用_esp32 log CSDN博客](https://blog.csdn.net/qq_36347513/article/details/115913430) 这一个模块是线程安全的, 在使用FreeRTOS的时候尽量使用这一个库进行输出 ```c #define ESP_LOGE( tag, format, ... ) ESP_LOG_LEVEL_LOCAL(ESP_LOG_ERROR, tag, format, ##__VA_ARGS__) #define ESP_LOGW( tag, format, ... ) ESP_LOG_LEVEL_LOCAL(ESP_LOG_WARN, tag, format, ##__VA_ARGS__) #define ESP_LOGI( tag, format, ... ) ESP_LOG_LEVEL_LOCAL(ESP_LOG_INFO, tag, format, ##__VA_ARGS__) #define ESP_LOGD( tag, format, ... ) ESP_LOG_LEVEL_LOCAL(ESP_LOG_DEBUG, tag, format, ##__VA_ARGS__) #define ESP_LOGV( tag, format, ... ) ESP_LOG_LEVEL_LOCAL(ESP_LOG_VERBOSE, tag, format, ##__VA_ARGS__) ``` ```c #define ESP_LOG_LEVEL_LOCAL(level, tag, format, ...) do { \\ if ( LOG_LOCAL_LEVEL > level ) ESP_LOG_LEVEL(level, tag, format, ##__VA_ARGS__); \\ } while(0) #endif //CONFIG_LOG_MASTER_LEVEL ``` ```c #define ESP_LOG_LEVEL(level, tag, format, ...) do { \\ if (level ESP_LOG_ERROR ) { esp_log_write(ESP_LOG_ERROR, tag, LOG_FORMAT(E, format), esp_log_timestamp(), tag, ##__VA_ARGS__); } \\ else if (level ESP_LOG_WARN ) { esp_log_write(ESP_LOG_WARN, tag, LOG_FORMAT(W, format), esp_log_timestamp(), tag, ##__VA_ARGS__); } \\ else if (level ESP_LOG_DEBUG ) { esp_log_write(ESP_LOG_DEBUG, tag, LOG_FORMAT(D, format), esp_log_timestamp(), tag, ##__VA_ARGS__); } \\ else if (level ESP_LOG_VERBOSE ) { esp_log_write(ESP_LOG_VERBOSE, tag, LOG_FORMAT(V, format), esp_log_timestamp(), tag, ##__VA_ARGS__); } \\ else { esp_log_write(ESP_LOG_INFO, tag, LOG_FORMAT(I, format), esp_log_timestamp(), tag, ##__VA_ARGS__); } \\ } while(0) ``` > 会调用esp_log_write函数 ```c void esp_log_write(esp_log_level_t level, const char *tag, const char *format, ...) { va_list list; va_start(list, format); esp_log_writev(level, tag, format, list); va_end(list); } ``` 在编译时：在menuconfig中，使用选项设置详细程度CONFIG_LOG_DEFAULT_LEVEL。详细程度高于的所有日志记录语句CONFIG_LOG_DEFAULT_LEVEL 将被预处理器删除。 ![image 20240524211747095](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405242117181.png) 在运行时：详细级别低于的所有日志CONFIG_LOG_DEFAULT_LEVEL默认情况下启用。该功能esp_log_level_set()可用于按模块设置日志记录级别。模块由其标签标识，这些标签是可读的ASCII零终止字符串。 > 该功能[`esp_log_level_set()`](https://docs.espressif.com/projects/esp idf/en/latest/esp32/api reference/system/log.html#_CPPv417esp_log_level_setPKc15esp_log_level_t)无法将日志记录级别设置为高于`CONFIG_LOG_DEFAULT_LEVEL`。要在编译时增加特定文件的日志级别，请使用宏`LOG_LOCAL_LEVEL`"},"/note/嵌入式/esp32/esp-idf/2024-6-4-10事件循环库.html":{"title":"时间循环库","content":" layout: post title: \"时间循环库\" date: 2024 5 24 15:39:08 +0800 tags: esp32 ESP IDF # 时间循环库 ESP32的系统API [事件循环库 ESP32 — ESP IDF 编程指南 latest 文档 (espressif.com)](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/system/esp_event.html) 事件循环库使组件能够声明事件，允许其他组件注册处理程序（即在事件发生时执行的代码片段）。在其他组件状态变化时附加所需的行为。(可以理解为软件层面的中断) 当某个高级库要使用 Wi Fi 库时，它可以直接订阅 [ESP32 Wi Fi 编程模型](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api guides/wifi.html#wifi programming model)，对有关事件做出相应。 ## 使用流程 1. 定义一个函数，并在事件发布到事件循环中时运行该函数。此函数被称为事件处理程序，应具有与 [`esp_event_handler_t`](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/system/esp_event.html#_CPPv419esp_event_handler_t) 同类型的签名。 > ```c > typedef void (*esp_event_handler_t)(void *event_handler_arg, esp_event_base_t event_base, int32_t event_id, void *event_data) > ``` 2. 调用 [`esp_event_loop_create()`](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/system/esp_event.html#_CPPv421esp_event_loop_createPK21esp_event_loop_args_tP23esp_event_loop_handle_t) 创建事件循环，该函数输出类型为 [`esp_event_loop_handle_t`](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/system/esp_event.html#_CPPv423esp_event_loop_handle_t) 的循环句柄，使用此 API 创建的事件循环称为用户事件循环。另有一种特殊事件循环，请参阅 [默认事件循环](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/system/esp_event.html#esp event default loops)。 ```c esp_err_t esp_event_loop_create(const esp_event_loop_args_t* event_loop_args, esp_event_loop_handle_t* event_loop) ``` 3. 调用 [`esp_event_handler_register_with()`](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/system/esp_event.html#_CPPv431esp_event_handler_register_with23esp_event_loop_handle_t16esp_event_base_t7int32_t19esp_event_handler_tPv) 将事件处理程序注册到循环中。处理程序可以注册到多个循环中，请参阅 [注册处理程序注意事项](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/system/esp_event.html#esp event handler registration)。 ```c esp_err_t esp_event_handler_register_with(esp_event_loop_handle_t event_loop, esp_event_base_t event_base, int32_t event_id, esp_event_handler_t event_handler, void* event_handler_arg) esp_err_t esp_event_handler_instance_register_with(esp_event_loop_handle_t event_loop, esp_event_base_t event_base, int32_t event_id, esp_event_handler_t event_handler, void *event_handler_arg, esp_event_handler_instance_t *instance); ``` > event_loop: 要注册的事件组 > > event_base: base是一个字符串用于标识 > > event_id: 一个数字 > > event_handler: 处理函数 > > event_handler_arg: 传递给处理函数的参数 > > instance: 一般为NULL, 一个传出参数 这一个函数实际是创建了一个 ```c /// Event posted to the event queue typedef struct esp_event_post_instance { #if CONFIG_ESP_EVENT_POST_FROM_ISR bool data_allocated; /**< indicates whether data is allocated from heap */ bool data_set; /**< indicates if data is null */ #endif esp_event_base_t base; /**< the event base 事件的基类 */ int32_t id; /**< the event id 事件的id*/ esp_event_post_data_t data; /**< data associated with the event 事件的数据*/ } esp_event_post_instance_t; ``` 4. 事件源调用 [`esp_event_post_to()`](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/system/esp_event.html#_CPPv417esp_event_post_to23esp_event_loop_handle_t16esp_event_base_t7int32_tPKv6size_t10TickType_t) 将事件发布到事件循环中。 ```c esp_err_t esp_event_post_to(esp_event_loop_handle_t event_loop, esp_event_base_t event_base, int32_t event_id, const void* event_data, size_t event_data_size, TickType_t ticks_to_wait) ``` 5. 调用 [`esp_event_handler_unregister_with()`](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/system/esp_event.html#_CPPv433esp_event_handler_unregister_with23esp_event_loop_handle_t16esp_event_base_t7int32_t19esp_event_handler_t) ，组件可以在事件循环中取消注册事件处理程序。 6. 调用 [`esp_event_loop_delete()`](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/system/esp_event.html#_CPPv421esp_event_loop_delete23esp_event_loop_handle_t) 删除不再需要的事件循环。 ## 事件定义与事件声明 如前所述，事件标识符由两部分组成：事件根基和事件 ID。事件根基标识独立的事件组；事件 ID 标识组中的特定事件。可以将事件根基和事件 ID 类比为人的姓和名，姓表示一个家族，名表示家族中的某个人。 ## 默认事件循环 是一种特殊循环，用于处理系统事件（如 Wi Fi 事件）。用户无法使用该循环的句柄，创建、删除、注册/注销处理程序以及事件发布均通过用户事件循环 API 的变体完成，下表列出了这些变体及其对应用户事件循环。 ![image 20240604092531370](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406040925453.png) ```c esp_event_loop_create_default(); ``` > 这一个函数实际是创建了一个线程, 这一个线程实际是在读取默认事件队列 在Wifi作为AP的时候, 如果有一个新的设备接入进来, 官方的底层会写入一个事件, 使用data这一个参数传递信息, 之后事件循环会调用相应的回调函数 ```c esp_err_t esp_event_handler_instance_register(esp_event_base_t event_base, int32_t event_id, esp_event_handler_t event_handler, void *event_handler_arg, esp_event_handler_instance_t *instance) ``` Register an instance of event handler to the default loop. This function does the same as esp_event_handler_instance_register_with, except that it registers the handler to the default event loop. > 这一个是一个省略第一个参数的注册函数"},"/note/嵌入式/esp32/esp-idf/2024-5-23-03GPIO.html":{"title":"GPIO","content":" layout: post title: \"GPIO\" date: 2024 5 23 15:39:08 +0800 tags: esp32 ESP IDF # GPIO ## API [GPIO & RTC GPIO ESP32 — ESP IDF 编程指南 v5.2.1 文档 (espressif.com)](https://docs.espressif.com/projects/esp idf/zh_CN/stable/esp32/api reference/peripherals/gpio.html#_CPPv424gpio_install_isr_servicei) [ESP32S2开发学习之路 GPIO与中断（三）_gpio isr CSDN博客](https://blog.csdn.net/qq_24317435/article/details/113497368) ### gpio_config_t 结构体 + pin_bit_mask端口号：GPIO_SEL_X。 + intr_type中断触发类型：GPIO_INTR_DISABLE关闭中断触发；GPIO_INTR_POSEDGE上升沿；GPIO_INTR_NEGEDGE下降沿；GPIO_INTR_ANYEDGE双边沿；GPIO_INTR_LOW_LEVEL低电平；GPIO_INTR_HIGH_LEVEL高电平。 + mode模式：GPIO_MODE_DISABLE关闭；GPIO_MODE_INPUT输入；GPIO_MODE_OUTPUT输出；GPIO_MODE_OUTPUT_OD开漏输出；PIO_MODE_INPUT_OUTPUT_OD开漏输入输出；GPIO_MODE_INPUT_OUTPUT输入输出。 + pull_up_en上拉电阻：GPIO_PULLUP_DISABLE断开；GPIO_PULLUP_ENABLE使能。 + pull_down_en下拉电阻：GPIO_PULLDOWN_DISABLE断开；GPIO_PULLDOWN_ENABLE使能。 ### gpio_config配置函数 ```c esp_err_t gpio_config(const gpio_config_t *pGPIOConfig) ``` > 用于配置GPIO ### gpio_install_isr_service单个gpio中断 ```c esp_err_t gpio_install_isr_service(int intr_alloc_flags) ``` > Flags used to allocate the interrupt. One or multiple (ORred) ESP_INTR_FLAG_* values. See esp_intr_alloc.h for more info. > > 开启一个处理单个引脚中断的服务 This function is incompatible with gpio_isr_register() if that function is used, a single global ISR is registered for all GPIO interrupts. If this function is used, the ISR service provides a global GPIO ISR and individual pin handlers are registered via the gpio_isr_handler_add() function. ### gpio_isr_handler_add添加处理函数 ```c esp_err_t gpio_isr_handler_add(gpio_num_t gpio_num, gpio_isr_t isr_handler, void *args) ``` > 给某一个引脚添加一个中断处理函数 > > **gpio_num** GPIO number > **isr_handler** ISR handler function for the corresponding GPIO number. > **args** parameter for ISR handler. ### gpio_isr_register所有GPIO中断 ```c esp_err_t gpio_isr_register(void (*fn)(void*), void *arg, int intr_alloc_flags, gpio_isr_handle_t *handle) ``` > **gpio_num** GPIO number > **isr_handler** ISR handler function for the corresponding GPIO number. > **args** parameter for ISR handler. This ISR function is called whenever any GPIO interrupt occurs. See the alternative gpio_install_isr_service() and gpio_isr_handler_add() API in order to have the driver support per GPIO ISRs. ### gpio_set_level设置电平 ```c esp_err_t gpio_set_level(gpio_num_t gpio_num, uint32_t level) ``` ### gpio_get_level获取电平状态 ```python int gpio_get_level(gpio_num_t gpio_num) ``` > If the pad is not configured for input (or input and output) the returned value is always 0. > > 配置的 时候需要是输入输出模式 ## 示例 ```c #include <stdio.h> #include <inttypes.h> #include \"freertos/FreeRTOS.h\" #include \"freertos/task.h\" #include \"freertos/queue.h\" #include \"driver/gpio.h\" #define GPIO_OUTPUT_PIN_SEL (1ULL<<GPIO_NUM_0) static QueueHandle_t gpio_evt_queue NULL; //任务函数 static void gpio_task_example(void* arg) { uint32_t io_num; for (;;) { if (xQueueReceive(gpio_evt_queue, &io_num, portMAX_DELAY)) { printf(\"GPIO[%\"PRIu32\"] intr, val: %d\\n\", io_num, gpio_get_level(io_num)); } } } // 中断处理函数 static void IRAM_ATTR gpio_isr_handler(void* arg) { uint32_t gpio_num (uint32_t) arg; xQueueSendFromISR(gpio_evt_queue, &gpio_num, NULL); } void app_main(void) { //zero initialize the config structure. gpio_config_t io_conf { //disable interrupt .intr_type GPIO_INTR_NEGEDGE, // 设置中断,下降沿 //set as input mode .mode GPIO_MODE_INPUT, //bit mask of the pins that you want to set .pin_bit_mask GPIO_OUTPUT_PIN_SEL, //disable pull down mode .pull_down_en 0, //enable pull up mode 打开上拉电阻 .pull_up_en 1, }; //configure GPIO with the given settings gpio_config(&io_conf); //create a queue to handle gpio event from isr 消息队列 gpio_evt_queue xQueueCreate(10, sizeof(uint32_t)); //start gpio task xTaskCreate(gpio_task_example, \"gpio_task_example\", 2048, NULL, 10, NULL); //install gpio isr service /* 安装GPIO ISR服务的驱动，开启每个引脚GPIO中断处理程序 。 这个函数与gpio_isr_register()不兼容。 如果使用这个函数，ISR服务将提供一个全局GPIO ISR，并且通过gpio_isr_handler_add()函数注册单个的pin处理程序。 */ gpio_install_isr_service(0); //hook isr handler for specific gpio pin gpio_isr_handler_add(GPIO_NUM_0, gpio_isr_handler, (void*) GPIO_INPUT_IO_0); } ```"},"/note/嵌入式/esp32/esp-idf/2024-6-3-09wifi.html":{"title":"wifi","content":" layout: post title: \"wifi\" date: 2024 5 24 15:39:08 +0800 tags: esp32 ESP IDF # wifi [官方文档](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32c3/api guides/wifi.html#id74) ## 基础知识 在多个主机之间进行交流的时候, 主机之间直接连接会导致网络十分复杂, 在实际的使用时候会使用一个转发器进行连接(Access Point AP可接入点), 其他的主机为station(STA)站 ### 基础配置AP ```c #include <stdio.h> #include \"nvs_flash.h\" #include \"esp_event.h\" #include \"esp_netif.h\" #include \"esp_wifi.h\" #include \"string.h\" #define EXAMPLE_ESP_WIFI_SSID \"ESP32 C3\" void app_main(void) { nvs_flash_init(); //esp32的nvs分区 #include \"nvs_flash.h\" esp_event_loop_create_default(); //建立一个事件循环 #include \"esp_event.h\" //配置AP esp_netif(可以理解为软件模拟网卡 为了方便使用TCPIP协议族) Wifi外设 //初始化网卡的底层配置 ESP_ERROR_CHECK(esp_netif_init()); //默认的方式建立一个AP类型的网卡 esp_netif_t * pnetif esp_netif_create_default_wifi_ap(); /* wifi */ //初始化Wifi底层配置 wifi_init_config_t cfg WIFI_INIT_CONFIG_DEFAULT(); esp_wifi_init(&cfg); //设置Wifi的模式 esp_wifi_set_mode(WIFI_MODE_AP); //配置AP模式特有的属性 wifi_config_t cfg2 { .ap { .ssid EXAMPLE_ESP_WIFI_SSID, .ssid_len strlen(EXAMPLE_ESP_WIFI_SSID), .channel 1, .password \"1234567890\", .max_connection 4, .authmode WIFI_AUTH_WPA2_PSK } }; esp_wifi_set_config(WIFI_IF_AP, &cfg2); //启动Wifi esp_wifi_start(); } ``` ![image 20240604102023111](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406041020206.png) ```c // 建立一个AP类型的网卡 esp_netif_t* esp_netif_create_default_wifi_ap(void) { esp_netif_config_t cfg ESP_NETIF_DEFAULT_WIFI_AP(); //一个默认的配置 esp_netif_t *netif esp_netif_new(&cfg); //建立一个网络接口 assert(netif); ESP_ERROR_CHECK(esp_netif_attach_wifi_ap(netif)); //举行关联 ESP_ERROR_CHECK(esp_wifi_set_default_wifi_ap_handlers()); //注册事件 return netif; } ``` ```c /** @brief Soft AP configuration settings for the device */ typedef struct { uint8_t ssid[32]; /**< SSID of soft AP. If ssid_len field is 0, this must be a Null terminated string. Otherwise, length is set according to ssid_len. wifi的名称*/ uint8_t password[64]; /**< Password of soft AP. 密码*/ uint8_t ssid_len; /**< Optional length of SSID field. 长度*/ uint8_t channel; /**< Channel of soft AP 信道在实际使用的Wifi的频段有13个, 其中1, 6, 13完全没有重叠,一般使用1*/ wifi_auth_mode_t authmode; /**< Auth mode of soft AP. Do not support AUTH_WEP, AUTH_WAPI_PSK and AUTH_OWE in soft AP mode. When the auth mode is set to WPA2_PSK, WPA2_WPA3_PSK or WPA3_PSK, the pairwise cipher will be overwritten with WIFI_CIPHER_TYPE_CCMP. 认证模式 设置为WIFI_AUTH_OPEN开放式WIFI, WIFI_AUTH_WPA_WPA2_PSK一般使用这一个 */ uint8_t ssid_hidden; /**< Broadcast SSID or not, default 0, broadcast the SSID 是否广播SSID 默认为0(进行广播)*/ uint8_t max_connection; /**< Max number of stations allowed to connect in 可以连接的个数*/ uint16_t beacon_interval; /**< Beacon interval which should be multiples of 100. Unit: TU(time unit, 1 TU 1024 us). Range: 100 ~ 60000. Default value: 100 广播频率, 0默认值*/ wifi_cipher_type_t pairwise_cipher; /**< Pairwise cipher of SoftAP, group cipher will be derived using this. Cipher values are valid starting from WIFI_CIPHER_TYPE_TKIP, enum values before that will be considered as invalid and default cipher suites(TKIP+CCMP) will be used. Valid cipher suites in softAP mode are WIFI_CIPHER_TYPE_TKIP, WIFI_CIPHER_TYPE_CCMP and WIFI_CIPHER_TYPE_TKIP_CCMP. 加密方式0即可*/ bool ftm_responder; /**< Enable FTM Responder mode wifi测距, 不需要false*/ wifi_pmf_config_t pmf_cfg; /**< Configuration for Protected Management Frame */ wifi_sae_pwe_method_t sae_pwe_h2e; /**< Configuration for SAE PWE derivation method */ } wifi_ap_config_t; ``` ### 事件组 ```c void Wifi_callback(void* event_handler_arg,esp_event_base_t event_base, int32_t event_id,void* event_data){ if(event_base IP_EVENT){ if(event_id IP_EVENT_AP_STAIPASSIGNED){ ip_event_ap_staipassigned_t *info (ip_event_ap_staipassigned_t *)event_data; //打印一下实际的ip printf(\"\\nSTA IP: \"IPSTR\"\\n\", IP2STR(&info >ip)); printf(\"STA Mac is \"MACSTR\"\\n\", MAC2STR(info >mac)); //#include \"esp_mac.h\" } } } //在发生事件IP_EVENT基底的IP_EVENT_AP_STAIPASSIGNED的时候, 调用Wifi_callback, 传入参数NULL esp_event_handler_instance_register(IP_EVENT, IP_EVENT_AP_STAIPASSIGNED, Wifi_callback, NULL, NULL); ``` ```c /** Event structure for IP_EVENT_AP_STAIPASSIGNED event */ typedef struct { esp_netif_t *esp_netif; /*!< Pointer to the associated netif handle */ esp_ip4_addr_t ip; /*!< IP address which was assigned to the station */ uint8_t mac[6]; /*!< MAC address of the connected client */ } ip_event_ap_staipassigned_t; ``` > 处理连接事件 ```c if(event_base WIFI_EVENT && event_id WIFI_EVENT_AP_STADISCONNECTED){ wifi_event_ap_stadisconnected_t *info (wifi_event_ap_stadisconnected_t *)event_data; printf(\"\\n disconnected STA Mac is \"MACSTR\"\\n\", MAC2STR(info >mac)); } esp_event_handler_instance_register(WIFI_EVENT, WIFI_EVENT_AP_STADISCONNECTED, Wifi_callback, NULL, NULL); ``` > 处理断开连接 ### 基础配置STA ```c void app_main(void) { nvs_flash_init(); esp_event_loop_create_default(); //初始化网络接口 esp_netif_init(); //建立sta接口 esp_netif_create_default_wifi_sta(); //初始化Wifi底层配置 wifi_init_config_t wifi_cfg WIFI_INIT_CONFIG_DEFAULT(); esp_wifi_init(&wifi_cfg); //设置wifi esp_wifi_set_mode(WIFI_MODE_STA); //配置STA的相关参数, 这两个是必须设置的 wifi_config_t sta_cfg { .sta { .ssid \"jiao\", .password \"1234567890\" } }; esp_wifi_set_config(WIFI_IF_STA, &sta_cfg); esp_wifi_start(); esp_wifi_connect(); } ``` ![image 20240604224927559](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406042249653.png) ### 可使用的事件 ```c uint8_t connect 0; void wifi_cb(void* event_handler_arg, esp_event_base_t event_base, int32_t event_id, void* event_data){ if(event_base WIFI_EVENT && event_id WIFI_EVENT_STA_START){ //wifi启动成功 esp_wifi_connect(); } if(event_base WIFI_EVENT && event_id WIFI_EVENT_STA_DISCONNECTED){ //wifi连接失败 connect ++; if(connect < 5){ esp_wifi_connect(); }else{ ESP_LOGE(\"main\", \"connected failed\"); } } if(event_base IP_EVENT && event_id IP_EVENT_STA_GOT_IP){ ESP_LOGI(\"main\", \"connected successed\"); ip_event_got_ip_t *info (ip_event_got_ip_t *)event_data; printf(\"get sta ip \"IPSTR\"\\n\", IP2STR(&info >ip_info.ip)); } } esp_event_loop_create_default(); esp_event_handler_register(WIFI_EVENT, WIFI_EVENT_STA_START, wifi_cb, NULL); //连接失败的回调 esp_event_handler_register(WIFI_EVENT, WIFI_EVENT_STA_DISCONNECTED, wifi_cb, NULL); //连接成功的事件 esp_event_handler_register(IP_EVENT, IP_EVENT_STA_GOT_IP, wifi_cb, NULL); //初始化网络接口 esp_netif_init(); ``` ![image 20240604230554741](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406042305953.png) > 这时候出现时间比较长的现象, 是省电模式的原因 ### 省电模式 这一个模式是在STA发送信息给AP, AP转发信息给STA的时候 AP设备每一段时间会进行一次广播, 发送一个信号帧, 这一个信号帧可以用于告诉其他的设备自己的存在, 还有一个TIM告诉已经接入的STA设备, 他这里有没有要发送给你的数据(这是一个单播, 是一对一的) 还有一个DTIM, 这一个是特殊的TIM, 不是每一个信号帧里面都有, 他有TIM的功能还有一个组播 含有TIM的信标帧是可以不及时接收的(可以之后重复发送), 但是DTIM是必须接受的, 是不会重复发送的 省电模式的实现实际是让esp32平时的时候是一个省电模式, 只有在有AP发送DTIM的时候唤醒 ```c /** * @brief Set current WiFi power save type * * @attention Default power save type is WIFI_PS_MIN_MODEM. * * @param type power save type * * @return ESP_OK: succeed */ esp_err_t esp_wifi_set_ps(wifi_ps_type_t type); typedef enum { WIFI_PS_NONE, /**< No power save */ WIFI_PS_MIN_MODEM, /**< Minimum modem power saving. In this mode, station wakes up to receive beacon every DTIM period 这一个模式是默认的*/ WIFI_PS_MAX_MODEM, /**< Maximum modem power saving. In this mode, interval to receive beacons is determined by the listen_interval parameter in wifi_sta_config_t */ } wifi_ps_type_t; ``` > 使用最大省电模式的时候, 需要设置wifi_config_t 里面的参数 .listen_interval 这一个参数, 会在收到这么多信标帧以后才进行一次接收 ![image 20240604234224741](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406042342830.png) > ![image 20240604234941720](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406042349807.png) > > ```c > esp_wifi_set_ps(WIFI_PS_MAX_MODEM); > esp_pm_config_t pm_config { > .max_freq_mhz 160, > .min_freq_mhz 40, > .light_sleep_enable true > }; > ESP_ERROR_CHECK(esp_pm_configure(&pm_config)); > ``` ### 静态ip 1. 停止这一个网卡的DHCP ` esp_netif_dhcpc_stop()`在创建sta网卡以后就可以立即使用 > DHCP（Dynamic Host Configuration Protocol）是一种网络协议，用于在局域网中动态分配IP地址 2. 设置ip ```c esp_err_t esp_netif_set_ip_info(esp_netif_t *esp_netif, const esp_netif_ip_info_t *ip_info); ``` ```c /** * @brief IPv4 address * */ struct esp_ip4_addr { uint32_t addr; /*!< IPv4 address */ }; typedef struct esp_ip4_addr esp_ip4_addr_t; typedef struct { esp_ip4_addr_t ip; /**< Interface IPV4 address */ esp_ip4_addr_t netmask; /**< Interface IPV4 netmask */ esp_ip4_addr_t gw; /**< Interface IPV4 gateway address */ } esp_netif_ip_info_t; ``` ```c esp_netif_ip_info_t ip_info { .gw.addr inet_addr(\"192.168.97.183\"), .ip.addr inet_addr(\"192.168.97.190\"), .netmask.addr inet_addr(\"255.255.255.0\") }; esp_netif_set_ip_info(netif, &ip_info); ``` ## 扫描 在wifi目录下面有一个scan例程 ```bash I (2988) scan: Max AP number ap_info can hold 10 I (2988) scan: Total APs scanned 10, actual AP number ap_info holds 10 I (2988) scan: SSID jiao I (2988) scan: RSSI 45 I (2988) scan: Authmode WIFI_AUTH_WPA2_PSK I (2998) scan: Pairwise Cipher WIFI_CIPHER_TYPE_CCMP I (2998) scan: Group Cipher WIFI_CIPHER_TYPE_CCMP I (3008) scan: Channel 11 ``` ```c void app_main(void) { // Initialize NVS esp_err_t ret nvs_flash_init(); //初始化分区表 if (ret ESP_ERR_NVS_NO_FREE_PAGES ret ESP_ERR_NVS_NEW_VERSION_FOUND) { ESP_ERROR_CHECK(nvs_flash_erase()); ret nvs_flash_init(); } ESP_ERROR_CHECK( ret ); wifi_scan(); } ``` ### 分区表 [分区表 ESP32 C3 — ESP IDF 编程指南 v5.1.3 文档 (espressif.com)](https://docs.espressif.com/projects/esp idf/zh_CN/v5.1.3/esp32c3/api guides/partition tables.html)\\ esp32 c3的 flash 可以包含多个应用程序，以及多种不同类型的数据（例如校准数据、文件系统数据、参数存储数据等）。因此，我们在 flash 的 [默认偏移地址](https://docs.espressif.com/projects/esp idf/zh_CN/v5.1.3/esp32c3/api reference/kconfig.html#config partition table offset) 0x8000 处烧写一张分区表。 分区表的长度为 0xC00 字节，最多可以保存 95 条分区表条目。MD5 校验和附加在分区表之后，用于在运行时验证分区表的完整性。分区表占据了整个 flash 扇区，大小为 0x1000 (4 KB)。因此，它后面的任何分区至少需要位于 ([默认偏移地址](https://docs.espressif.com/projects/esp idf/zh_CN/v5.1.3/esp32c3/api reference/kconfig.html#config partition table offset)) + 0x1000 处。 ![image 20240603223407540](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406032234603.png) flash 的 0x10000 (64 KB) 偏移地址处存放一个标记为 \"factory\" 的二进制应用程序，且启动加载器将默认加载这个应用程序。 分区表中还定义了两个数据区域，分别用于存储 NVS 库专用分区和 PHY 初始化数据。 > nvs分区就是用来配置wifi数据的，凡是涉及到需要使用wifi外设的应用程序，必须先初始化nvs分区。 > > 这一个分区里面实际存储的是一些键值对, 之后连接Wifi的时候会自动的吧Wifi的信息写入这一个分区里面 ### wifi扫描 [Wi Fi 驱动程序 ESP32 C3 — ESP IDF 编程指南 v5.1.3 文档 (espressif.com)](https://docs.espressif.com/projects/esp idf/zh_CN/v5.1.3/esp32c3/api guides/wifi.html#esp32 c3 wi fi station) ![img](https://docs.espressif.com/projects/esp idf/zh_CN/v5.1.3/esp32c3/_images/seqdiag c9a68de05aa0a22e5fc3caf61dde7d4d179520fd.png) ```c /* Initialize Wi Fi as sta and set scan method */ static void wifi_scan(void) { //WIFI初始化 ESP_ERROR_CHECK(esp_netif_init()); //创建一个LwIP核心任务 ESP_ERROR_CHECK(esp_event_loop_create_default()); //创建一个系统事任务 //创建一个有TCP/IP堆栈的默认网络接口 esp_netif_t *sta_netif esp_netif_create_default_wifi_sta(); assert(sta_netif); \t wifi_init_config_t cfg WIFI_INIT_CONFIG_DEFAULT(); //创建Wi Fi驱动程序任务，并初始化Wi Fi驱动程序。 ESP_ERROR_CHECK(esp_wifi_init(&cfg)); \t uint16_t number DEFAULT_SCAN_LIST_SIZE; wifi_ap_record_t ap_info[DEFAULT_SCAN_LIST_SIZE]; uint16_t ap_count 0; memset(ap_info, 0, sizeof(ap_info)); \t//将Wi Fi模式配置为station模式。 ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA)); ESP_ERROR_CHECK(esp_wifi_start());//启动WI FI驱动程序。 esp_wifi_scan_start(NULL, true); ESP_LOGI(TAG, \"Max AP number ap_info can hold %u\", number); ESP_ERROR_CHECK(esp_wifi_scan_get_ap_num(&ap_count)); ESP_ERROR_CHECK(esp_wifi_scan_get_ap_records(&number, ap_info)); ESP_LOGI(TAG, \"Total APs scanned %u, actual AP number ap_info holds %u\", ap_count, number); for (int i 0; i < number; i++) { ESP_LOGI(TAG, \"SSID \\t\\t%s\", ap_info[i].ssid); ESP_LOGI(TAG, \"RSSI \\t\\t%d\", ap_info[i].rssi); print_auth_mode(ap_info[i].authmode); if (ap_info[i].authmode ! WIFI_AUTH_WEP) { print_cipher_type(ap_info[i].pairwise_cipher, ap_info[i].group_cipher); } ESP_LOGI(TAG, \"Channel \\t\\t%d\\n\", ap_info[i].primary); } } ``` > 以上代码，按照顺序，分为wifi的初始化阶段、配置阶段、启动阶段。因为只扫描名称，没有连接，所以没有执行后面的几个wifi阶段。关于wifi的所有阶段介绍，可以通过下面链接查看。 ## WIFI连接 一般来说, WIFI有两种模式, STA和AP, STA是站点, AP是热点 这个使用官方的station工程 ![image 20240603230051614](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406032300667.png) ```c I (6401) esp_netif_handlers: sta ip: 192.168.97.190, mask: 255.255.255.0, gw: 192.168.97.183 I (6401) wifi station: got ip:192.168.97.190 I (6401) wifi station: connected to ap SSID:jiao password:1234567890 I (6411) main_task: Returned from app_main() ``` ```c static void event_handler(void* arg, esp_event_base_t event_base, int32_t event_id, void* event_data) { if (event_base WIFI_EVENT && event_id WIFI_EVENT_STA_START) { esp_wifi_connect(); } else if (event_base WIFI_EVENT && event_id WIFI_EVENT_STA_DISCONNECTED) { if (s_retry_num < EXAMPLE_ESP_MAXIMUM_RETRY) { esp_wifi_connect(); s_retry_num++; ESP_LOGI(TAG, \"retry to connect to the AP\"); } else { xEventGroupSetBits(s_wifi_event_group, WIFI_FAIL_BIT); //设置事件组的位 } ESP_LOGI(TAG,\"connect to the AP fail\"); } else if (event_base IP_EVENT && event_id IP_EVENT_STA_GOT_IP) { ip_event_got_ip_t* event (ip_event_got_ip_t*) event_data; ESP_LOGI(TAG, \"got ip:\" IPSTR, IP2STR(&event >ip_info.ip)); s_retry_num 0; xEventGroupSetBits(s_wifi_event_group, WIFI_CONNECTED_BIT); } } void wifi_init_sta(void) { //创建一个事件组 s_wifi_event_group xEventGroupCreate(); \t//初始化Wifi ESP_ERROR_CHECK(esp_netif_init()); ESP_ERROR_CHECK(esp_event_loop_create_default()); esp_netif_create_default_wifi_sta(); wifi_init_config_t cfg WIFI_INIT_CONFIG_DEFAULT(); ESP_ERROR_CHECK(esp_wifi_init(&cfg)); esp_event_handler_instance_t instance_any_id; esp_event_handler_instance_t instance_got_ip; //注册两个事件 ESP_ERROR_CHECK(esp_event_handler_instance_register(WIFI_EVENT, ESP_EVENT_ANY_ID, &event_handler, NULL, &instance_any_id)); ESP_ERROR_CHECK(esp_event_handler_instance_register(IP_EVENT, IP_EVENT_STA_GOT_IP, &event_handler, NULL, &instance_got_ip)); wifi_config_t wifi_config { .sta { .ssid EXAMPLE_ESP_WIFI_SSID, .password EXAMPLE_ESP_WIFI_PASS, /* Setting a password implies station will connect to all security modes including WEP/WPA. * However these modes are deprecated and not advisable to be used. Incase your Access point * doesn't support WPA2, these mode can be enabled by commenting below line */ \t .threshold.authmode ESP_WIFI_SCAN_AUTH_MODE_THRESHOLD, \t .sae_pwe_h2e WPA3_SAE_PWE_BOTH, }, }; ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA) ); ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &wifi_config) ); ESP_ERROR_CHECK(esp_wifi_start() ); ESP_LOGI(TAG, \"wifi_init_sta finished.\"); /* Waiting until either the connection is established (WIFI_CONNECTED_BIT) or connection failed for the maximum * number of re tries (WIFI_FAIL_BIT). The bits are set by event_handler() (see above) */ EventBits_t bits xEventGroupWaitBits(s_wifi_event_group, WIFI_CONNECTED_BIT WIFI_FAIL_BIT, pdFALSE, pdFALSE, portMAX_DELAY); /* xEventGroupWaitBits() returns the bits before the call returned, hence we can test which event actually * happened. */ if (bits & WIFI_CONNECTED_BIT) { ESP_LOGI(TAG, \"connected to ap SSID:%s password:%s\", EXAMPLE_ESP_WIFI_SSID, EXAMPLE_ESP_WIFI_PASS); } else if (bits & WIFI_FAIL_BIT) { ESP_LOGI(TAG, \"Failed to connect to SSID:%s, password:%s\", EXAMPLE_ESP_WIFI_SSID, EXAMPLE_ESP_WIFI_PASS); } else { ESP_LOGE(TAG, \"UNEXPECTED EVENT\"); } /* The event will not be processed after unregister */ ESP_ERROR_CHECK(esp_event_handler_instance_unregister(IP_EVENT, IP_EVENT_STA_GOT_IP, instance_got_ip)); ESP_ERROR_CHECK(esp_event_handler_instance_unregister(WIFI_EVENT, ESP_EVENT_ANY_ID, instance_any_id)); vEventGroupDelete(s_wifi_event_group); } ``` ## sntp SNTP的全称是Simple Network Time Protocol，意思是简单网络时间协议，用来从网络中获取当前的时间，也可以称为网络授时。 ```c void app_main(void) { ++boot_count; ESP_LOGI(TAG, \"Boot count: %d\", boot_count); time_t now; struct tm timeinfo; time(&now); //获取系统时间 localtime_r(&now, &timeinfo); //把这一个时间转换为可以理解的时间 // Is time set? If not, tm_year will be (1970 1900). if (timeinfo.tm_year < (2016 1900)) { ESP_LOGI(TAG, \"Time is not set yet. Connecting to WiFi and getting time over NTP.\"); obtain_time(); //获取时间 // update 'now' variable with current time time(&now); } char strftime_buf[64]; // Set timezone to Eastern Standard Time and print local time setenv(\"TZ\", \"EST5EDT,M3.2.0/2,M11.1.0\", 1); tzset(); //设置时区 localtime_r(&now, &timeinfo); //进行转换 strftime(strftime_buf, sizeof(strftime_buf), \"%c\", &timeinfo);//把时间转换为字符串 ESP_LOGI(TAG, \"The current date/time in New York is: %s\", strftime_buf); // Set timezone to China Standard Time setenv(\"TZ\", \"CST 8\", 1); tzset(); localtime_r(&now, &timeinfo); strftime(strftime_buf, sizeof(strftime_buf), \"%c\", &timeinfo); ESP_LOGI(TAG, \"The current date/time in Shanghai is: %s\", strftime_buf); if (sntp_get_sync_mode() SNTP_SYNC_MODE_SMOOTH) { \t\t... } \t//深度睡眠 const int deep_sleep_sec 10; ESP_LOGI(TAG, \"Entering deep sleep for %d seconds\", deep_sleep_sec); esp_deep_sleep(1000000LL * deep_sleep_sec); } ``` ```c static void obtain_time(void) { ESP_ERROR_CHECK(nvs_flash_init() ); ESP_ERROR_CHECK(esp_netif_init()); ESP_ERROR_CHECK(esp_event_loop_create_default()); #if LWIP_DHCP_GET_NTP_SRV /** * NTP server address could be acquired via DHCP, * see following menuconfig options: * 'LWIP_DHCP_GET_NTP_SRV' enable STNP over DHCP * 'LWIP_SNTP_DEBUG' enable debugging messages * * NOTE: This call should be made BEFORE esp acquires IP address from DHCP, * otherwise NTP option would be rejected by default. */ ESP_LOGI(TAG, \"Initializing SNTP\"); esp_sntp_config_t config ESP_NETIF_SNTP_DEFAULT_CONFIG(CONFIG_SNTP_TIME_SERVER); config.start false; // start SNTP service explicitly (after connecting) config.server_from_dhcp true; // accept NTP offers from DHCP server, if any (need to enable *before* connecting) config.renew_servers_after_new_IP true; // let esp netif update configured SNTP server(s) after receiving DHCP lease config.index_of_first_server 1; // updates from server num 1, leaving server 0 (from DHCP) intact // configure the event on which we renew servers #ifdef CONFIG_EXAMPLE_CONNECT_WIFI config.ip_event_to_renew IP_EVENT_STA_GOT_IP; #else config.ip_event_to_renew IP_EVENT_ETH_GOT_IP; #endif config.sync_cb time_sync_notification_cb; // only if we need the notification function esp_netif_sntp_init(&config); #endif /* LWIP_DHCP_GET_NTP_SRV */ /* This helper function configures Wi Fi or Ethernet, as selected in menuconfig. * Read \"Establishing Wi Fi or Ethernet Connection\" section in * examples/protocols/README.md for more information about this function. */ ESP_ERROR_CHECK(example_connect()); //Wifi连接 #if LWIP_DHCP_GET_NTP_SRV ESP_LOGI(TAG, \"Starting SNTP\"); esp_netif_sntp_start(); #if LWIP_IPV6 && SNTP_MAX_SERVERS > 2 /* This demonstrates using IPv6 address as an additional SNTP server * (statically assigned IPv6 address is also possible) */ ip_addr_t ip6; if (ipaddr_aton(\"2a01:3f7::1\", &ip6)) { // ipv6 ntp source \"ntp.netnod.se\" esp_sntp_setserver(2, &ip6); } #endif /* LWIP_IPV6 */ #else ESP_LOGI(TAG, \"Initializing and starting SNTP\"); #if CONFIG_LWIP_SNTP_MAX_SERVERS > 1 /* This demonstrates configuring more than one server */ esp_sntp_config_t config ESP_NETIF_SNTP_DEFAULT_CONFIG_MULTIPLE(2, ESP_SNTP_SERVER_LIST(CONFIG_SNTP_TIME_SERVER, \"pool.ntp.org\" ) ); #else /* * This is the basic default config with one server and starting the service */ esp_sntp_config_t config ESP_NETIF_SNTP_DEFAULT_CONFIG(CONFIG_SNTP_TIME_SERVER); #endif config.sync_cb time_sync_notification_cb; // Note: This is only needed if we want #ifdef CONFIG_SNTP_TIME_SYNC_METHOD_SMOOTH config.smooth_sync true; #endif esp_netif_sntp_init(&config); #endif print_servers(); // wait for time to be set time_t now 0; struct tm timeinfo { 0 }; int retry 0; //实际的连接, 尝试15次 const int retry_count 15; while (esp_netif_sntp_sync_wait(2000 / portTICK_PERIOD_MS) ESP_ERR_TIMEOUT && ++retry < retry_count) { ESP_LOGI(TAG, \"Waiting for system time to be set... (%d/%d)\", retry, retry_count); } time(&now); localtime_r(&now, &timeinfo); ESP_ERROR_CHECK( example_disconnect() ); esp_netif_sntp_deinit(); } ```"},"/note/嵌入式/esp32/esp-idf/2024-6-24-19分区表.html":{"title":"分区表","content":" layout: post title: \"分区表\" date: 2024 6 24 15:39:08 +0800 tags: esp32 ESP IDF # 分区表 esp32的Flash里面可以有多个不同的程序, 所以默认的时候, 通常在0x8000的位置放一个分区表, 大小为4KB, 之后的所有分区默认的地址需要加0x1000 所有的表项有Name（标签）、Type（app、data 等）、SubType 以及在 flash 中的偏移量（分区的加载地址）。 > OTA应用程序指的是通过空中升级（OTA，Over the Air）技术进行更新和升级的应用程序。这种技术允许用户通过互联网直接下载并安装新的版本，而无需通过传统的有线连接方式。 OTA 应用程序能够提供更方便、更快速的更新体验，使用户能够及时获得最新的功能和修复bug。 ## 示例 ### 单程序 ```c # ESP IDF Partition Table # Name, Type, SubType, Offset, Size, Flags nvs, data, nvs, 0x9000, 0x6000, phy_init, data, phy, 0xf000, 0x1000, factory, app, factory, 0x10000, 1M, ``` > 在0x10000这一个位置放一个名字叫factory的二进制程序, 这一个程序是实际的要加载的程序 > > 分区表中还定义了两个数据区域，分别用于存储 NVS 库专用分区和 PHY 初始化数据。 ```c # Name, Type, SubType, Offset, Size nvs, data, nvs, 0x9000, 0x4000 phy_init, data, phy, 0xd000, 0x1000 factory, app, factory, 0x10000, 7M, ``` > 这一个是嘉立创开发板可以使用的分区表 ### 多程序 ```c # ESP IDF Partition Table # Name, Type, SubType, Offset, Size, Flags nvs, data, nvs, 0x9000, 0x4000, otadata, data, ota, 0xd000, 0x2000, phy_init, data, phy, 0xf000, 0x1000, factory, app, factory, 0x10000, 1M, ota_0, app, ota_0, 0x110000, 1M, ota_1, app, ota_1, 0x210000, 1M, ``` > 这一个里面有三个程序, 默认加载factory ## 自定义 + CSV 文件中的每个非注释行均为一个分区定义。 + 每个分区的 `Offset` 字段可以为空，`gen_esp32part.py` 工具会从分区表位置的后面开始自动计算并填充该分区的偏移地址，同时确保每个分区的偏移地址正确对齐。 Name 字段可以是任何有意义的名称，但不能超过 16 个字节，其中包括一个空字节（之后的内容将被截断）。该字段对 ESP32 并不是特别重要。 Type 字段可以指定为 app (0x00) 或者 data (0x01)，也可以直接使用数字 0 254（或者十六进制 0x00 0xFE）。注意，0x00 0x3F 不得使用（预留给 esp idf 的核心功能）。 > 启动加载器将忽略 `app` (0x00) 和 `data` (0x01) 以外的其他分区类型。 SubType 字段长度为 8 bit，内容与具体分区 Type 有关。目前，esp idf 仅仅规定了 “app” 和 “data” 两种分区类型的子类型含义。 ### APP类 当 Type 定义为 `app` 时，SubType 字段可以指定为 `factory` (0x00)、 `ota_0` (0x10) … `ota_15` (0x1F) 或者 `test` (0x20)。 > `factory` (0x00) 是默认的 app 分区。启动加载器将默认加载该应用程序。但如果存在类型为 data/ota 分区，则启动加载器将加载 data/ota 分区中的数据，进而判断启动哪个 OTA 镜像文件。 > > OTA 升级永远都不会更新 factory 分区中的内容。 > > 如果你希望在 OTA 项目中预留更多 flash，可以删除 factory 分区，转而使用 ota_0 分区。 > > ota_0 (0x10) … ota_15 (0x1F) 为 OTA 应用程序分区，启动加载器将根据 OTA 数据分区中的数据来决定加载哪个 OTA 应用程序分区中的程序。在使用 OTA 功能时，应用程序应至少拥有 2 个 OTA 应用程序分区（`ota_0` 和 `ota_1`）。更多详细信息，请参考 [OTA 文档](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/system/ota.html) 。 > > `test` (0x20) 为预留的子类型，用于工厂测试流程。如果没有其他有效 app 分区，test 将作为备选启动分区使用。也可以配置启动加载器在每次启动时读取 GPIO，如果 GPIO 被拉低则启动该分区。详细信息请查阅 [从测试固件启动](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api guides/bootloader.html#bootloader boot from test firmware)。 ### Data类 SubType 字段可以指定为 `ota` (0x00)、`phy` (0x01)、`nvs` (0x02)、`nvs_keys` (0x04) 或者其他组件特定的子类型（请参考 [`子类型枚举`](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/storage/partition.html#_CPPv423esp_partition_subtype_t)). `ota` (0) 即 [OTA 数据分区](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/system/ota.html#ota data partition) ，用于存储当前所选的 OTA 应用程序的信息。这个分区的大小需要设定为 0x2000。更多详细信息，请参考 [OTA 文档](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/system/ota.html) 。 `phy` (1) 分区用于存放 PHY 初始化数据，从而保证可以为每个设备单独配置 PHY，而非必须采用固件中的统一 PHY 初始化数据。 > 默认配置下，phy 分区并不启用，而是直接将 phy 初始化数据编译至应用程序中，从而节省分区表空间（直接将此分区删掉）。 > > 如果需要从此分区加载 phy 初始化数据，请打开项目配置菜单（`idf.py menuconfig`），并且使能 [CONFIG_ESP_PHY_INIT_DATA_IN_PARTITION](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/kconfig.html#config esp phy init data in partition) 选项。此时，还需要手动将 phy 初始化数据烧至设备 flash（esp idf 编译系统并不会自动完成该操作）。 + `nvs` (2) 是专门给 [非易失性存储 (NVS) API](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/storage/nvs_flash.html) 使用的分区。 > 用于存储每台设备的 PHY 校准数据（注意，并不是 PHY 初始化数据）。 > > 用于存储 Wi Fi 数据（如果使用了 [esp_wifi_set_storage(WIFI_STORAGE_FLASH)](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/network/esp_wifi.html) 初始化函数）。 > > NVS API 还可以用于其他应用程序数据。 > > 强烈建议为 NVS 分区分配至少 0x3000 字节空间。 > > 如果使用 NVS API 存储大量数据，请增加 NVS 分区的大小（默认是 0x6000 字节）。 + `nvs_keys` (4) 是 NVS 秘钥分区。详细信息，请参考 [非易失性存储 (NVS) API](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/storage/nvs_flash.html) 文档。 + `coredump` (0x03) 用于在使用自定义分区表 CSV 文件时存储核心转储，详情请参阅 [核心转储](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api guides/core_dump.html)。 + `efuse` (0x05) 使用 [虚拟 eFuse](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/system/efuse.html#virtual efuses) 模拟 eFuse 位。 + `undefined` (0x06) 隐式用于未指定子类型（即子类型为空）的数据分区，但也可显式将其标记为未定义。 + `fat` (0x81) 用于 [FAT 文件系统](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/storage/fatfs.html)。 + `spiffs` (0x82) 用于 [SPIFFS 文件系统](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/storage/spiffs.html)。 + `littlefs` (0x83) 用于 [LittleFS 文件系统](https://github.com/littlefs project/littlefs)，详情可参阅 [storage/littlefs](https://github.com/espressif/esp idf/tree/0479494e/examples/storage/littlefs) 示例。 ### 偏移 偏移地址表示 SPI flash 中的分区地址，扇区大小为 0x1000 (4 KB)。因此，偏移地址必须是 4 KB 的倍数。 若 CSV 文件中的分区偏移地址为空，则该分区会接在前一个分区之后；若为首个分区，则将接在分区表之后。 `app` 分区的偏移地址必须与 0x10000 (64 KB) 对齐。如果偏移字段留空，则 `gen_esp32part.py` 工具会自动计算得到一个满足对齐要求的偏移地址。如果 `app` 分区的偏移地址没有与 0x10000 (64 KB) 对齐，则该工具会报错。 `app` 分区的大小和偏移地址可以采用十进制数或是以 0x 为前缀的十六进制数，且支持 K 或 M 的倍数单位（K 和 M 分别代表 1024 和 1024*1024 字节）。 ### flag 目前支持 `encrypted` 和 `readonly` 标记： ### 其他 这一个文件可以使用`gen_esp32part.py`来进行csv文件和bin文件之间的转换"},"/note/嵌入式/esp32/esp-idf/2025-1-22-32cpp.html":{"title":"CPP","content":"# CPP [C++ 支持 ESP32 — ESP IDF 编程指南 v5.2.3 文档](https://docs.espressif.com/projects/esp idf/zh_CN/v5.2.3/esp32/api guides/cplusplus.html) ESP IDF 支持以下 C++ 功能： [异常处理](https://docs.espressif.com/projects/esp idf/zh_CN/v5.2.3/esp32/api guides/cplusplus.html#cplusplus exceptions) [多线程](https://docs.espressif.com/projects/esp idf/zh_CN/v5.2.3/esp32/api guides/cplusplus.html#cplusplus multithreading) [运行时类型信息 (RTTI)](https://docs.espressif.com/projects/esp idf/zh_CN/v5.2.3/esp32/api guides/cplusplus.html#cplusplus rtti) [线程局部存储](https://docs.espressif.com/projects/esp idf/zh_CN/v5.2.3/esp32/api guides/thread local storage.html) （`thread_local` 关键字） 除部分 [限制](https://docs.espressif.com/projects/esp idf/zh_CN/v5.2.3/esp32/api guides/cplusplus.html#cplusplus limitations)，所有由 GCC 实现的 C++ 功能均受支持。有关由 GCC 所实现功能的详细信息，请参阅 [GCC 文档](https://gcc.gnu.org/projects/cxx status.html)。 ## 异常处理 ### 异常捕获 [C++ 异常处理 菜鸟教程](https://www.runoob.com/cplusplus/cpp exceptions handling.html) 异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。 异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：**try、catch、throw**。 **throw:** 当问题出现时，程序会抛出一个异常。这是通过使用 **throw** 关键字来完成的。 **catch:** 在您想要处理问题的地方，通过异常处理程序捕获异常。**catch** 关键字用于捕获异常。 **try:** **try** 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。 ```cpp #include <iostream> using namespace std; double division(int a, int b) { \tif (b 0) { \t\tthrow \"Division by zero condition!\"; \t} \treturn (a / b); } int main() { \tint x 50; \tint y 0; \tdouble z 0; \ttry { \t\tz division(x, y); \t\tcout << z << endl; \t} catch (const char* msg) { \t\tcerr << msg << endl; \t}\t \treturn 0; } ``` 如果`try`块可能抛出不同类型的异常，可以使用多个`catch`块来捕获不同类型的异常。 ```cpp try { \t// 可能抛出不同类型的异常 } catch (DataType1& e1) { \t// 处理DataType1类型的异常 } catch (DataType2& e2) { \t// 处理DataType2类型的异常 } catch (DataType3& e3) { \t// 处理DataType3类型的异常 } catch (...) { \t// 处理所有其他类型的异常 } ``` cpp专门使用一组`<exception>`类用于返回错误 ![image 20250122233108235](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/picture/202501222331375.png) 异常 描述 : : **std::exception** 该异常是所有标准 C++ 异常的父类。 std::bad_alloc 该异常可以通过 **new** 抛出。 std::bad_cast 该异常可以通过 **dynamic_cast** 抛出。 std::bad_typeid 该异常可以通过 **typeid** 抛出。 std::bad_exception 这在处理 C++ 程序中无法预期的异常时非常有用。 **std::logic_error** 理论上可以通过读取代码来检测到的异常。 std::domain_error 当使用了一个无效的数学域时，会抛出该异常。 std::invalid_argument 当使用了无效的参数时，会抛出该异常。 std::length_error 当创建了太长的 std::string 时，会抛出该异常。 std::out_of_range 该异常可以通过方法抛出，例如 std::vector 和 std::bitset<>::operator[]()。 **std::runtime_error** 理论上不可以通过读取代码来检测到的异常。 std::overflow_error 当发生数学上溢时，会抛出该异常。 std::range_error 当尝试存储超出范围的值时，会抛出该异常。 std::underflow_error 当发生数学下溢时，会抛出该异常。 实际使用的时候可以使用`.what()`获取实际的错误, 自定义的时候也需要重写这一个函数 ```cpp class bad_hmean : public std::exception { public: \tconst char* what() \t{ \t\treturn \"bad arguments to hmean()\"; \t} \t// ... }; try{ \t//... } catch(std::exception& e) { \tcout << e.what() << endl; \t// ... } ``` 也可以改写描述 ```cpp //可以使用()来传递参数, 参数类型必须是const char*或者std::string, 这一个参数会被传递给std::runtime_error的构造函数, 作为异常的描述信息, 使用what()函数可以获取这个描述信息 throw std::runtime_error(\"Runtime error occurred\"); ``` ### 异常类型 `#include <optional>` 使用这一个头文件的时候可以使用类型`std::optional<int>`这一个类型的范围是[INT_MIN, INT_MAX] {nullopt}, 所以可以返回`std::nullopt`表示失败 判断的时候可以使用`.has_value()`进行判断, 使用`.value()`获取数值, 也可以直接判断返回值`if(ret)`是不是为空 > 使用`*ret`的时候不会进行检查, 相当于使用解引用一个NULL 这一种方式只有一种输出, 如果使用返回值为负数的情况会使得输出的范围减小, 所以也可以使用一个指针参数作为返回 + 使用一个全局变量进行记录 使用头文件`#include \"errno.h\"`, 使用全局变量errno, 这是每一个线程独属的变量 在这个头文件里面定义了一系列的错误 使用`#include <cstring>`里面的`const char *str strerror(ENOENT);`可以获取描述, 使用`setlocale(LC_ALL, \"zh_CN.UTF 8\");`返回的是中文 也可以使用`perror(\"你的提示\")`进行输出 > 使用这一个的时候自定义的程度比较差, 所以可以自己建立一个枚举类型 ## 多任务 Mutex 又称互斥量，C++ 11中与 Mutex 相关的类（包括锁类型）和函数都声明在 `<mutex>` 头文件中，所以如果你需要使用 std::mutex，就必须包含` <mutex> `头文件。 Mutex 系列类(四种) std::mutex，最基本的 Mutex 类, 不支持递归。 std::recursive_mutex，递归 Mutex 类。 std::time_mutex，定时 Mutex 类。 std::recursive_timed_mutex，定时递归 Mutex 类。 Lock 类（两种） std::lock_guard，与 Mutex RAII 相关，方便线程对互斥量上锁。 std::unique_lock，与 Mutex RAII 相关，方便线程对互斥量上锁，但提供了更好的上锁和解锁控制。 其他类型 std::once_flag std::adopt_lock_t std::defer_lock_t std::try_to_lock_t 函数 std::try_lock，尝试同时对多个互斥量上锁。 std::lock，可以同时对多个互斥量上锁。 std::call_once，如果多个线程需要同时调用某个函数，call_once 可以保证多个线程对该函数只调用一次。 ### std::mutex 构造函数，std::mutex不允许拷贝构造，也不允许 move 拷贝，最初产生的 mutex 对象是处于 unlocked 状态的。 lock()，调用线程将锁住该互斥量。线程调用该函数会发生下面 3 种情况：(1). 如果该互斥量当前没有被锁住，则调用线程将该互斥量锁住，直到调用 unlock之前，该线程一直拥有该锁。(2). 如果当前互斥量被其他线程锁住，则当前的调用线程被阻塞住。(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。 unlock()， 解锁，释放对互斥量的所有权。 try_lock()，尝试锁住互斥量，如果互斥量被其他线程占有，则当前线程也不会被阻塞。线程调用该函数也会出现下面 3 种情况，(1). 如果当前互斥量没有被其他线程占有，则该线程锁住互斥量，直到该线程调用 unlock 释放互斥量。(2). 如果当前互斥量被其他线程锁住，则当前调用线程返回 false，而并不会被阻塞掉。(3). 如果当前互斥量被当前调用线程锁住，则会产生死锁(deadlock)。 ### std::recursive_mutex std::recursive_mutex 允许同一个线程对互斥量多次上锁（即递归上锁） ### std::time_mutex std::time_mutex 比 std::mutex 多了两个成员函数，try_lock_for()，try_lock_until()。 try_lock_for 函数接受一个时间范围，表示在这一段时间范围之内线程如果没有获得锁则被阻塞住（与 std::mutex 的 try_lock() 不同，try_lock 如果被调用时没有获得锁则直接返回 false），如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 false。 ### std::lock_guard 一种自动管理 std::mutex 锁的封装器，使用 RAII 风格，确保在作用域结束时自动释放锁。 ```cpp #include <mutex> std::mutex mtx; void function() { std::lock_guard<std::mutex> lock(mtx); // 访问共享资源 } ``` ### std::unique_lock 提供比 std::lock_guard 更灵活的锁管理，可以手动释放和重新获得锁，还支持定时锁定。 ```cpp #include <mutex> #include <chrono> std::mutex mtx; void function() { std::unique_lock<std::mutex> lock(mtx); // 访问共享资源 // 可以手动释放锁 lock.unlock(); // 可以重新获得锁 lock.lock(); // 可以进行定时锁定 if (lock.try_lock_for(std::chrono::seconds(1))) { // 成功获得锁 } } ``` ### 原子变量 [C++ 中的原子变量（std::atomic）使用指南_std::atomic CSDN博客](https://blog.csdn.net/qq_46017342/article/details/132838649) 原子变量（`std::atomic`）是C++中用于多线程编程的强大工具之一。它们提供了一种线程安全的方式来访问和修改共享数据，而无需使用显式的互斥锁。 `std::atomic`支持各种数据类型，如整数、布尔值、指针等。您可以创建`std::atomic`对象，并使用原子操作来读取和修改它们的值。 ```cpp std::atomic<int> atomicInt(0); std::atomic<bool> atomicBool(true); ``` + 读取值 要读取std::atomic变量的值，可以使用load函数： ```cpp int value atomicInt.load(); bool flag atomicBool.load(); ``` + 修改值 要修改std::atomic变量的值，可以使用store函数： ```cpp atomicInt.store(42); atomicBool.store(false); ``` ### std::condition_variable 用于在多线程程序中进行线程间的同步。它允许一个或多个线程在某个条件为真之前挂起（等待），直到另一个线程修改了条件并通知 std::condition_variable `std::condition_variable` 需要与 `std::unique_lock<std::mutex>` 一起使用，以便在等待条件时释放互斥锁，并在条件满足后重新获取互斥锁。它提供了 `wait`、`notify_one` 和 `notify_all` 方法来实现线程间的等待和通知机制。 `wait` 方法使当前线程阻塞，直到条件变量被另一个线程通过 *notify_one* 或 `notify_all` 方法唤醒。 `notify_one` 方法唤醒一个等待条件变量的线程。 `notify_all` 方法唤醒所有等待条件变量的线程。"},"/note/嵌入式/esp32/esp-idf/2024-10-5-29文件系统.html":{"title":"SPIFFS文件系统","content":" layout: post title: \"SPIFFS文件系统\" date: 2024 6 24 15:39:08 +0800 tags: esp32 ESP IDF # SPIFFS文件系统 SPIFFS 是一个用于 SPI NOR flash 设备的嵌入式文件系统，支持磨损均衡、文件系统一致性检查等功能。 > 目前，SPIFFS 尚不支持目录，但可以生成扁平结构。如果 SPIFFS 挂载在 `/spiffs` 下，在 `/spiffs/tmp/myfile.txt` 路径下创建一个文件则会在 SPIFFS 中生成一个名为 `/tmp/myfile.txt` 的文件，而不是在 `/spiffs/tmp` 下生成名为 `myfile.txt` 的文件； > SPIFFS 并非实时栈，每次写操作耗时不等； > 目前，SPIFFS 尚不支持检测或处理已损坏的块。 > SPIFFS 只能稳定地使用约 75% 的指定分区容量。 > 当文件系统空间不足时，垃圾收集器会尝试多次扫描文件系统来寻找可用空间。根据所需空间的不同，写操作会被调用多次，每次函数调用将花费几秒。同一操作可能会花费不同时长的问题缘于 SPIFFS 的设计，且已在官方的 [SPIFFS github 仓库](https://github.com/pellepl/spiffs/issues/) 或是 https://github.com/espressif/esp idf/issues/1737 中被多次报告。这个问题可以通过 [SPIFFS 配置](https://github.com/pellepl/spiffs/wiki/Configure spiffs) 部分缓解。 > 当垃圾收集器尝试多次（默认为 10 次）扫描整个文件系统以回收空间时，在每次扫描期间，如果有可用的数据块，则垃圾收集器会释放一个数据块。因此，如果为垃圾收集器设置的最大运行次数为 n（可通过 SPIFFS_GC_MAX_RUNS 选项配置，该选项位于 [SPIFFS 配置](https://github.com/pellepl/spiffs/wiki/Configure spiffs) 中），那么 n 倍数据块大小的空间将可用于写入数据。如果尝试写入超过 n 倍数据块大小的数据，写入操作可能会失败并返回错误。 > 如果 ESP32 在文件系统操作期间断电，可能会导致 SPIFFS 损坏。但是仍可通过 `esp_spiffs_check` 函数恢复文件系统。详情请参阅官方 SPIFFS [FAQ](https://github.com/pellepl/spiffs/wiki/FAQ)。 在实际使用这一个进行生成一个 [spiffsgen.py](https://github.com/espressif/esp idf/blob/46acfdce/components/spiffs/spiffsgen.py) （只写）是 SPIFFS 的一种 Python 实现，可用于从主机文件夹内容生成文件系统镜像。打开终端并运行以下命令即可使用 `spiffsgen.py`: ```bash python spiffsgen.py <image_size> <base_dir> <output_file> ``` 参数（必选）说明如下： **image_size**：分区大小，用于烧录生成的 SPIFFS 镜像； **base_dir**：创建 SPIFFS 镜像的目录； **output_file**：SPIFFS 镜像输出文件。 镜像生成后，用户可以使用 `esptool.py` 或 `parttool.py` 烧录镜像。 用户可以在命令行或脚本中手动单独调用 `spiffsgen.py`，也可以直接从构建系统调用 `spiffs_create_partition_image` 来使用 `spiffsgen.py`: ```cmake spiffs_create_partition_image(<partition> <base_dir> [FLASH_IN_PROJECT] [DEPENDS dep dep dep...]) ``` > 使用 `spiffs_create_partition_image`，必须从组件 `CMakeLists.txt` 文件调用。 > > **实际使用的示例: ** > > ```cmake > # Create a SPIFFS image from the contents of the 'spiffs_image' directory > # that fits the partition named 'data'. FLASH_IN_PROJECT indicates that > # the generated image should be flashed when the entire project is flashed to > # the target with 'idf.py p PORT flash'. > spiffs_create_partition_image(data ../data FLASH_IN_PROJECT) > ``` > > ![image 20241005185906408](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202410051859592.png) 不指定 FLASH_IN_PROJECT/SPIFFS_IMAGE_FLASH_IN_PROJECT 也可以生成镜像，但须使用 `esptool.py`、`parttool.py` 或自定义构建系统目标手动烧录。 有时基本目录中的内容是在构建时生成的，用户可以使用 DEPENDS/SPIFFS_IMAGE_DEPENDS 指定目标，因此可以在生成镜像之前执行此目标: ```cmake add_custom_target(dep COMMAND ...) spiffs_create_partition_image(my_spiffs_partition my_folder DEPENDS dep) ``` ## 程序使用 ```c esp_err_t esp_vfs_spiffs_register(const esp_vfs_spiffs_conf_t *conf) ``` > 挂载这一个分区 > > ```c > /** > * @brief Configuration structure for esp_vfs_spiffs_register > */ > typedef struct { > /*!< File path prefix associated with the filesystem. */ > const char* base_path; > /*!< Optional, label of SPIFFS partition to use. If set to NULL, first > partition with subtype spiffs will be used. */ > const char* partition_label; > /*!< Maximum files that could be open at the same time. */ > size_t max_files; > /*!< If true, it will format the file system if it fails to mount. */ > bool format_if_mount_failed; > } esp_vfs_spiffs_conf_t; > ``` > > ![image 20241005192005005](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202410051920053.png) ```c bool esp_spiffs_mounted(const char *partition_label) ``` > 检测是否mount一个文件系统 ```c esp_err_t esp_spiffs_format(const char *partition_label) ``` > 格式化一个操作系统 ````c esp_err_t esp_spiffs_check(const char *partition_label) ```` > 检测一个文件系统是否可以正常使用 ```c esp_err_t esp_spiffs_info(const char *partition_label, size_t *total_bytes, size_t *used_bytes) ``` > 获取一下这一个文件系统的基本信息, 总共的大小以及已经使用的大小 ## 示例 ```c esp_vfs_spiffs_conf_t conf { .base_path \"/data\", .partition_label NULL, .max_files 5, .format_if_mount_failed false}; esp_err_t ret esp_vfs_spiffs_register(&conf); //检测一下各种错误 if (ret ! ESP_OK) { if (ret ESP_FAIL) { ESP_LOGE(TAG, \"Failed to mount or format filesystem\"); } else if (ret ESP_ERR_NOT_FOUND) { ESP_LOGE(TAG, \"Failed to find SPIFFS partition\"); } else { ESP_LOGE(TAG, \"Failed to initialize SPIFFS (%s)\", esp_err_to_name(ret)); } return; } ```"},"/note/嵌入式/esp32/esp-idf/2024-11-9-31SD卡.html":{"title":"SD卡","content":" layout: post title: \"SD卡\" date: 2024 5 24 15:39:08 +0800 tags: esp32 ESP IDF # SD卡 使用一线SDIO的操控模式 ![image 20241105215558719](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202411052155857.png)"},"/note/嵌入式/esp32/esp-idf/2024-5-25-06efuse.html":{"title":"eFuse","content":" layout: post title: \"eFuse\" date: 2024 5 24 15:39:08 +0800 tags: esp32 ESP IDF # eFuse eFuse 是芯片中一块特殊的存储空间，它内部由熔丝相互连接。当流经的电流达到一定程度时，熔丝会被烧断，该位的值会改变。这一个是不可逆的, 使用的时候需要根据实际开发板的设计进行使用 ```c esp_efuse_write_field_bit(ESP_EFUSE_VDD_SPI_AS_GPIO); ``` > esp32 s3的GPIO11这一个引脚在使用的时候由于默认的时候设置为SPI_VDD, 所以不可以作为一个GPIO进行使用, 所以实际使用的时候需要使用eFuse功能, 把这一个引脚设置为GPIO"},"/note/嵌入式/esp32/esp-idf/2024-6-25-21FreeRTOS.html":{"title":"FreeRTOS","content":" layout: post title: \"FreeRTOS\" date: 2024 6 24 15:39:08 +0800 tags: esp32 ESP IDF # FreeRTOS 这里的FreeRTOS使用SMP(对称多处理), 可使一个 FreeRTOS FreeRTOS 内核实例在多个相同的处理器内核上调度任务。 这些内核架构必须相同，并共享相同的内存。 在ESP IDF里面大部分的配置文件是不可以修改的 [CONFIG_FREERTOS_ENABLE_BACKWARD_COMPATIBILITY](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/kconfig.html#config freertos enable backward compatibility) 向后兼容 ## 程序 ESP IDF已经启动了cTaskStartScheduler这一个函数, 用户需要自定义一个app_main的函数, 作为用户程序的入口 这一个函数可以返回, 可以用于启动其他的任务 空闲任务 (`IDLEx`) 为每个 CPU 核创建并分配一个空闲任务 (`IDLEx`)，其中 `x` 是 CPU 核的编号。 当启用单核配置时，`x` 将被删除。 [CONFIG_FREERTOS_IDLE_TASK_STACKSIZE](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/kconfig.html#config freertos idle task stacksize) 核 x `0` FreeRTOS 定时器任务 (`Tmr Svc`) 如果应用程序调用了任何 FreeRTOS 定时器 API，FreeRTOS 会创建定时器服务或守护任务 [CONFIG_FREERTOS_TIMER_TASK_STACK_DEPTH](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/kconfig.html#config freertos timer task stack depth) 核 0 [CONFIG_FREERTOS_TIMER_TASK_PRIORITY](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/kconfig.html#config freertos timer task priority) 主任务 (`main`) 简单调用 `app_main` 的任务在 `app_main` 返回时会自我删除 [CONFIG_ESP_MAIN_TASK_STACK_SIZE](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/kconfig.html#config esp main task stack size) [CONFIG_ESP_MAIN_TASK_AFFINITY](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/kconfig.html#config esp main task affinity) `1` IPC 任务 (`ipcx`) 当 [CONFIG_FREERTOS_UNICORE](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/kconfig.html#config freertos unicore) 为假时，为每个 CPU 核创建并分配一个 IPC 任务 (`ipcx`)。IPC 任务用于实现处理器间调用 (IPC) 功能 [CONFIG_ESP_IPC_TASK_STACK_SIZE](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/kconfig.html#config esp ipc task stack size) 核 x `24` ESP 定时器任务 (`esp_timer`) ESP IDF 创建 ESP 定时器任务用于处理 ESP 定时器回调 [CONFIG_ESP_TIMER_TASK_STACK_SIZE](https://docs.espressif.com/projects/esp idf/zh_CN/latest/esp32/api reference/kconfig.html#config esp timer task stack size) 核 0 `22` ## 双核SMP ### 对称多处理 对称多处理是一种计算架构，其中，两个及以上相同的 CPU 核连接到单个共享的主内存，并由单个操作系统控制。SMP 系统通常具有以下特点： 多个核独立运行。每个核都有自己的寄存器文件、中断和中断处理。 对每个核呈现相同的内存视图。因此，无论在哪个核上运行，访问特定内存地址的代码都会产生相同的效果。 与单核或非对称多处理系统相比，SMP 系统的主要优势在于： 存在多个核，支持多个硬件线程，从而提高整体处理吞吐量。 对称内存支持线程在执行期间切换核，从而提高 CPU 利用率。 尽管 SMP 系统支持线程切换核，但在某些情况下，线程必须或应该仅在特定核上运行。因此，在 SMP 系统中，线程也具备核亲和性，指定线程在哪个特定核上运行。 分配给特定核的线程只能在该核上运行。 未分配给特定核的线程支持在执行期间切换核。 ### esp32的SMP 具有两个完全相同的核，分别称为核 0 和核 1。代码段无论在哪个核上运行，都有相同的执行效果。 具有对称内存（除了少数例外情况）。 如果多个核同时访问相同的内存地址，它们的访问会被内存总线串行化。 通过 ISA 提供的原子比较和交换指令，可以实现对同一内存地址的真正原子访问。 跨核中断支持由一个核触发另一个核上的中断，这使得核间可以互相发送信号，如请求在另一个核上进行上下文切换。 ## 任务 ```c BaseType_t xTaskCreatePinnedToCore( TaskFunction_t pxTaskCode, const char * const pcName, const configSTACK_DEPTH_TYPE usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pvCreatedTask, const BaseType_t xCoreID ); ``` > 在一个特定的内核创建一个任务 > > pxTaskCode 任务 pcName 名字 usStackDepth 栈的大小 pvParameters 参数 uxPriority 优先级 > > pvCreatedTask 返回任务句柄 xCoreID 使用的核 一般情况使用普通的创建函数即可, 内部已经经过调整了 在释放任务的时候可以释放另一个内核上面的任务, 但是这一个任务需要把互斥锁之类的资源手动释放 ### 临界区 在 SMP 系统中，仅禁用中断并不能构成临界区，因为存在其他核意味着共享资源仍可以同时访问。因此，IDF FreeRTOS 中的临界区是使用自旋锁实现的。 自旋锁为 `portMUX_TYPE` (**请勿与 FreeRTOS 互斥混淆**) `taskENTER_CRITICAL(&spinlock)` 从任务上下文进入临界区 `taskEXIT_CRITICAL(&spinlock)` 从任务上下文退出临界区 `taskENTER_CRITICAL_ISR(&spinlock)` 从中断上下文进入临界区 `taskEXIT_CRITICAL_ISR(&spinlock)` 从中断上下文退出临界区 > 这一个可以重复调用, 但是注意不要死锁 实际使用静态 ```c // 静态分配并初始化自旋锁 static portMUX_TYPE my_spinlock portMUX_INITIALIZER_UNLOCKED; void some_function(void) { taskENTER_CRITICAL(&my_spinlock); // 此时已处于临界区 taskEXIT_CRITICAL(&my_spinlock); } ``` + 动态 ```c // 动态分配自旋锁 portMUX_TYPE *my_spinlock malloc(sizeof(portMUX_TYPE)); // 动态初始化自旋锁 portMUX_INITIALIZE(my_spinlock); ... taskENTER_CRITICAL(my_spinlock); // 访问资源 taskEXIT_CRITICAL(my_spinlock); ```"},"/note/嵌入式/esp32/esp-idf/2024-6-27-24睡眠模式.html":{"title":"睡眠模式","content":" layout: post title: \"睡眠模式\" date: 2024 6 26 15:39:08 +0800 tags: esp32 ESP IDF # 睡眠模式 ESP32 具有 Light sleep 和 Deep sleep 两种睡眠节能模式。根据应用所使用的功能，还有一些细分的子睡眠模式。 [睡眠模式 ESP32 — ESP IDF 编程指南 v5.2.2 文档 (espressif.com)](https://docs.espressif.com/projects/esp idf/zh_CN/stable/esp32/api reference/system/sleep_modes.html#disable sleep wakeup source) ## 睡眠模式 在 Light sleep 模式下，数字外设、CPU、以及大部分 RAM 都使用时钟门控，同时其供电电压降低。退出该模式后，数字外设、CPU 和 RAM 恢复运行，并且内部状态将被保留。 在 Deep sleep 模式下，CPU、大部分 RAM、以及所有由时钟 APB_CLK 驱动的数字外设都会被断电。芯片上继续处于供电状态的部分仅包括： > RTC 控制器 > ULP 协处理器 > RTC 高速内存 > RTC 低速内存 ### 进入前设置 在 Light sleep 和 Deep sleep 模式下，无线外设会被断电。因此，在进入这两种睡眠模式前，应用程序必须调用恰当的函数 `nimble_port_stop()`、`nimble_port_deinit()`、`esp_bluedroid_disable()`、`esp_bluedroid_deinit()`、`esp_bt_controller_disable()`、`esp_bt_controller_deinit()`或 `esp_wifi_stop()`来禁用 Wi Fi 和 Bluetooth。 ## 唤醒源 通过 API `esp_sleep_enable_X_wakeup` 可启用唤醒源。唤醒源在芯片被唤醒后并不会被禁用，若你不再需要某些唤醒源，可通过 API `esp_sleep_disable_wakeup_source()` 将其禁用 ### 定时器唤醒 RTC 控制器中内嵌定时器，可用于在预定义的时间到达后唤醒芯片。时间精度为微秒，但其实际分辨率依赖于为 RTC_SLOW_CLK 所选择的时钟源。 调用 [`esp_sleep_enable_timer_wakeup()`](https://docs.espressif.com/projects/esp idf/zh_CN/stable/esp32/api reference/system/sleep_modes.html#_CPPv429esp_sleep_enable_timer_wakeup8uint64_t) 函数可启用使用定时器唤醒睡眠模式。 ### ext0唤醒  可调用 esp_sleep_enable_ext0_wakeup() 函数来启用此唤醒源。 当RTC的某一个引脚设置为一个值的时候会进行唤醒 ### GPIO唤醒 这一个只可以在 Light sleep 模式 可以使用 [`gpio_wakeup_enable()`](https://docs.espressif.com/projects/esp idf/zh_CN/stable/esp32/api reference/peripherals/gpio.html#_CPPv418gpio_wakeup_enable10gpio_num_t15gpio_int_type_t)。启用该唤醒源后，可将每个管脚单独配置为在高电平或低电平时唤醒。 在进入 Light sleep 模式前，请查看将要驱动的 GPIO 管脚的电源域。如果有管脚属于 VDD_SDIO 电源域，必须将此电源域配置为在睡眠期间保持供电。 例如，在 ESP32 WROOM 32 开发板上，GPIO16 和 GPIO17 连接到 VDD_SDIO 电源域。如果这两个管脚被配置为在睡眠期间保持高电平，则需将对应电源域配置为保持供电。为此，可以使用函数 [`esp_sleep_pd_config()`](https://docs.espressif.com/projects/esp idf/zh_CN/stable/esp32/api reference/system/sleep_modes.html#_CPPv419esp_sleep_pd_config21esp_sleep_pd_domain_t21esp_sleep_pd_option_t): ```c esp_sleep_pd_config(ESP_PD_DOMAIN_VDDSDIO, ESP_PD_OPTION_ON); ``` ### 串口唤醒 这一个只可以在 Light sleep 模式 [`uart_set_wakeup_threshold()`](https://docs.espressif.com/projects/esp idf/zh_CN/stable/esp32/api reference/peripherals/uart.html#_CPPv425uart_set_wakeup_threshold11uart_port_ti) 函数可设置被观测上升沿的数量。请注意，触发唤醒的字符（及该字符前的所有字符）在唤醒后不会被 UART 接收，因此在发送数据之前，外部设备通常需要首先向 ESP32 额外发送一个字符以触发唤醒。 > Stop bit and parity bits (if enabled) also contribute to the number of edges. For example, letter 'a' with ASCII code 97 is encoded as 0100001101 on the wire (with 8n1 configuration), start and stop bits included. This sequence has 3 positive edges (transitions from 0 to 1). Therefore, to wake up the system when 'a' is sent, set wakeup_threshold 3. > > 实际计算的时候, 需要看这一个字符里面的上升沿的个数 可调用 [`esp_sleep_enable_uart_wakeup()`](https://docs.espressif.com/projects/esp idf/zh_CN/stable/esp32/api reference/system/sleep_modes.html#_CPPv428esp_sleep_enable_uart_wakeupi) 函数来启用此唤醒源。 ## 断电 应用程序可以使用 API [`esp_sleep_pd_config()`](https://docs.espressif.com/projects/esp idf/zh_CN/stable/esp32/api reference/system/sleep_modes.html#_CPPv419esp_sleep_pd_config21esp_sleep_pd_domain_t21esp_sleep_pd_option_t) 强制 RTC 外设和 RTC 内存进入特定断电模式。在 Deep sleep 模式下，你还可以通过隔离一些 IO 来进一步降低功耗。 ### Deep Sleep启动 默认情况下，调用函数 [`esp_deep_sleep_start()`](https://docs.espressif.com/projects/esp idf/zh_CN/stable/esp32/api reference/system/sleep_modes.html#_CPPv420esp_deep_sleep_startv) 和 [`esp_light_sleep_start()`](https://docs.espressif.com/projects/esp idf/zh_CN/stable/esp32/api reference/system/sleep_modes.html#_CPPv421esp_light_sleep_startv) 后，所有唤醒源不需要的 RTC 电源域都会被断电。可调用函数 [`esp_sleep_pd_config()`](https://docs.espressif.com/projects/esp idf/zh_CN/stable/esp32/api reference/system/sleep_modes.html#_CPPv419esp_sleep_pd_config21esp_sleep_pd_domain_t21esp_sleep_pd_option_t) 来修改这一设置 ### Light Sleep启动 函数 esp_light_sleep_start() 可用于在配置唤醒源后进入 Light sleep 模式，也可用于在未配置唤醒源的情况下进入 Light sleep 模式。在后一种情况中，芯片将一直处于睡眠模式，直到从外部被复位。"},"/note/嵌入式/esp32/esp-idf/2024-6-28-26RTC.html":{"title":"RTC时钟","content":" layout: post title: \"RTC时钟\" date: 2024 6 28 15:39:08 +0800 tags: esp32 ESP IDF # RTC时钟 esp32里面的RTC部件和SNTP服务可以用于获取时间 是顺着一个部分的时候 1. esp32进行wifi的连接 2. 使用SNTP网络时间库进行时间的校准 3. 通过RTC库设置时区, 对获取的数据进行转换 4. 使用time.h文件对时间进行转换 ## STNP 网络时间协议NTP的一个子集, 使用NTP协议可以获取准确的时间, 会自动获取可靠的服务器, 并且这一个架构有灵活的可扩展性以及很高的精度 使用SNTP的时候精度会有所下降 国内可用的NTP 服务器地址 1.cn.pool.ntp.org 2.cn.pool.ntp.org 3.cn.pool.ntp.org 0.cn.pool.ntp.org cn.pool.ntp.org tw.pool.ntp.org 0.tw.pool.ntp.org 1.tw.pool.ntp.org 2.tw.pool.ntp.org 3.tw.pool.ntp.org   esp32提供了sntp时钟同步的库，sntp获得的网络时间可以更新到esp32的系统时钟里面去 ### 时间戳 使用NTP获取的时间戳是一个64位的数据, 前面32位是1970到现在的秒数, 后面的是小数 esp32的SNTP库会在内部调用settimeofday() and adjtime()来自动更新esp32的系统时间。这些两个函数的功能是，当收到来自NTP服务器的信息后，修改esp32的系统时间。 ### API函数 ### C语言 ### 常用的结构 ```c struct tm { int\ttm_sec; //秒 int\ttm_min; //分钟 int\ttm_hour; //当天的小时 int\ttm_mday; //每个月的日期 int\ttm_mon; //月份 int\ttm_year; //从1900年开始的年份 int\ttm_wday; //周几, 周日开始 int\ttm_yday; //每年的第几天 int\ttm_isdst; //Daylight Saving Time flag }; clock_t 时钟数, 实际是一个long类型 time_t 从1900年1月1日0点UTC时间开始的时间， 实际是一个long类型。单位秒。 struct timeval { time_t tv_sec; /* seconds */ suseconds_t tv_usec; /* microseconds */ }; ``` ### 函数 函数 说明 asctime tm 转 string ctime time_t 转 string gmtime UTC时间的time_t 转 tm localtime 本地时间的time_t 转 tm strftime 格式化为string mktime tm 转time_t ```c char *asctime(const struct tm *timeptr); ``` > 返回一个方便读取的字符串格式的时间 > > ```c > struct tm { > int tm_sec; /* 秒，范围从 0 到 59 */ > int tm_min; /* 分，范围从 0 到 59 */ > int tm_hour; /* 小时，范围从 0 到 23 */ > int tm_mday; /* 一月中的第几天，范围从 1 到 31 */ > int tm_mon; /* 月份，范围从 0 到 11 */ > int tm_year; /* 自 1900 起的年数 */ > int tm_wday; /* 一周中的第几天，范围从 0 到 6 */ > int tm_yday; /* 一年中的第几天，范围从 0 到 365 */ > int tm_isdst; /* 夏令时 */ > }; > ``` ```c time_t time(time_t *t); ``` > 获取时间, 返回值和传入参数都是返回值可以用于返回一个时间 ```c int gettimeofday(struct timeval *tv, struct timezone *tz); ``` > 会把当前的时间使用第一个参数传递出来 > > 第二个参数是用来计算时区的 > > ```c > struct timezone{ > int tz_minuteswest;/*和greenwich时间差*/ > int tz_dsttime; > } > ``` ```c sock_t clock(); ``` > clock()函数的返回值就是你程序当前运行的时间（毫秒为单位） > > sock_t实际是一个long类型的毫秒值 ```c double difftime(time_t time2, time_t time1); ``` > double difftime(time_t time1, time_t time2) 返回 time1 和 time2 之间相差的秒数 (time1 time2)。这两个时间是在日历时间中指定的，表示了自纪元 Epoch（协调世界时 UTC：1970 01 01 00:00:00）起经过的时间。 > ```c struct tm *gmtime(const time_t *timeptr); ``` > 时间格式转换 ```c struct tm * tmS localtime(time_t * p); ``` > localtime 将 time_t （从格林威治时间1970年01月01日00时00分00秒起至现在的总秒数,是一个8字节长度的有符号整数）格式数据转化为tm的格式 ```c time_t mktime(struct tm *timeptr); ``` > 格式转换 ```c size_t strftime(char *str, size_t maxsize, const char *format, const struct tm *timeptr) ``` > 根据 **format** 中定义的格式化规则，格式化结构 **timeptr** 表示的时间，并把它存储在 **str** 中。 > > 说明符 替换为 实例 > : : : > %a 缩写的星期几名称 Sun > %A 完整的星期几名称 Sunday > %b 缩写的月份名称 Mar > %B 完整的月份名称 March > %c 日期和时间表示法 Sun Aug 19 02:56:02 2012 > %d 一月中的第几天（01 31） 19 > %H 24 小时格式的小时（00 23） 14 > %I 12 小时格式的小时（01 12） 05 > %j 一年中的第几天（001 366） 231 > %m 十进制数表示的月份（01 12） 08 > %M 分（00 59） 55 > %p AM 或 PM 名称 PM > %S 秒（00 61） 02 > %U 一年中的第几周，以第一个星期日作为第一周的第一天（00 53） 33 > %w 十进制数表示的星期几，星期日表示为 0（0 6） 4 > %W 一年中的第几周，以第一个星期一作为第一周的第一天（00 53） 34 > %x 日期表示法 08/19/12 > %X 时间表示法 02:50:06 > %y 年份，最后两个数字（00 99） 01 > %Y 年份 2012 > %Z 时区的名称或缩写 CDT > %% 一个 % 符号 % ```c int gettimeofday(struct timeval*tv,struct timezone *tz ); //获取时间 int settimeofday(const struct timeval *tv, const struct timezone *tz); //设置时间 ``` ## SNTP时间同步 在获取SNTP时间以后会使用settimeofday进行设置时间 包括 SNTP 函数在内的一些 lwIP API 并非线程安全，因此建议在与 SNTP 模块交互时使用 [esp_netif component](https://docs.espressif.com/projects/esp idf/zh_CN/stable/esp32/api reference/network/esp_netif.html)。 1. 要初始化特定的 SNTP 服务器并启动 SNTP 服务，只需创建有特定服务器名称的默认 SNTP 服务器配置，然后调用 [`esp_netif_sntp_init()`](https://docs.espressif.com/projects/esp idf/zh_CN/stable/esp32/api reference/network/esp_netif.html#_CPPv419esp_netif_sntp_initPK17esp_sntp_config_t) 注册该服务器并启动 SNTP 服务。这一个函数会自动获取时间 ```c esp_sntp_config_t config ESP_NETIF_SNTP_DEFAULT_CONFIG(\"pool.ntp.org\"); esp_netif_sntp_init(&config); ``` 2. 等待获取时间 ```c if (esp_netif_sntp_sync_wait(pdMS_TO_TICKS(10000)) ! ESP_OK) { printf(\"Failed to update system time within 10s timeout\"); } ``` ### 时区 要设置本地时区，请使用以下 POSIX 函数： 1. 调用 `setenv()`，将 `TZ` 环境变量根据设备位置设置为正确的值。时间字符串的格式与 [GNU libc 文档](https://www.gnu.org/software/libc/manual/html_node/TZ Variable.html) 中描述的相同（但实现方式不同）。 2. 调用 `tzset()`，为新的时区更新 C 库的运行数据。 完成上述步骤后，请调用标准 C 库函数 `localtime()`。该函数将返回排除时区偏差和夏令时干扰后的准确本地时间。 ```c setenv(\"TZ\",\"UTC 08:00\",1); ```"},"/note/嵌入式/esp32/esp-idf/2024-5-25-07lvgl.html":{"title":"lvgl","content":" layout: post title: \"lvgl\" date: 2024 5 24 15:39:08 +0800 tags: esp32 ESP IDF # lvgl 接线表 LCD ST7735 ESP32 GND GND VCC 3V3 SCL IO14(CLK) SDA IO13(MOSI) RES IO17 DC IO16(DC) CS1 IO18 BLK 空 ## 使用例程 spi_lcd_touch ![image 20240525130154611](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405251301661.png) ![image 20240525130336277](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405251303324.png) > 加入这一个驱动 ![image 20240525130424813](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405251304844.png) ![image 20240525130958510](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405251309548.png) ![image 20240525131158631](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405251311667.png) ![image 20240525131324689](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405251313725.png) ![image 20240525131347905](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405251313935.png) > 这一个文件注释后三句 ## API ### 设置镜像 ```c esp_err_t esp_lcd_panel_mirror(esp_lcd_panel_handle_t panel, bool mirror_x, bool mirror_y) esp_lcd_panel_mirror(panel_handle, false, false); ``` > 第一个参数是x轴, 第二个参数是y轴 ### 反色 ```c esp_err_t esp_lcd_panel_invert_color(esp_lcd_panel_handle_t panel, bool invert_color_data) ESP_ERROR_CHECK(esp_lcd_panel_invert_color(panel_handle, true)); ``` ### 颜色格式 ```c .rgb_ele_order LCD_RGB_ELEMENT_ORDER_RGB, ``` > 使用RGB格式"},"/note/嵌入式/esp32/esp-idf/2024-5-25-07组件管理.html":{"title":"组件管理","content":" layout: post title: \"组件管理\" date: 2024 5 24 15:39:08 +0800 tags: esp32 ESP IDF # 组件管理 [ESP Component Registry (espressif.com)](https://components.espressif.com/) 可以在这一个网站里面找各种驱动 ![image 20240525192902725](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405251929777.png) > 开发板使用的是这一个芯片, 但是这一个驱动不好用, 所以使用ft5x06的驱动 ![image 20240525193110218](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405251931299.png) > 使用这一个命令可以添加驱动库, 添加的驱动会记录在idf_component.yml这一个文件里面 > > ```bash > idf.py add dependency \"espressif/esp_lcd_touch_ft5x06^1.0.6\" > ``` > > 使用这一个命令进行添加依赖 > > ![image 20240525213130060](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405252131185.png) ![image 20240525213555570](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405252135645.png) 使用这一个方法获取的组件是不可以直接修改的, 需要把这一个文件剪切到自己的文件夹里面 > IDF有个规定，如果要修改managed_components中的代码，需要先把managed_components中的组件放到自己的components中才可以修改，否则你改了之后，一编译，就会恢复原来的样子，就白改了。"},"/note/嵌入式/esp32/esp-idf/2024-6-6-12cJSON.html":{"title":"cJSON","content":" layout: post title: \"cJSON\" date: 2024 5 24 15:39:08 +0800 tags: esp32 ESP IDF # cJSON [cJSON使用详细教程 一个轻量级C语言JSON解析器 CSDN博客](https://blog.csdn.net/Mculover666/article/details/103796256) ## json语法 JSON对象是一个无序的\"名称/值\"键值对的集合： 以\"`{`“开始，以”`}`\"结束，允许嵌套使用； 每个名称和值成对出现，名称和值之间使用\"`:`\"分隔； 键值对之间用\"`,`\"分隔 在这些字符前后允许存在无意义的空白符； 这里面可以有 一个新的json对象 数组：使用\"`[`“和”`]`\"表示 数字：直接表示，可以是整数，也可以是浮点数 字符串：使用引号`\"`表示 字面值：false、null、true中的一个(必须是小写) > https://github.com/DaveGamble/cJSON > > 从这里面获取的实际的源码文件只有两个cJSON.c/h ## 数据类型 cjson里面使用一个结构体表示一个json数据 ```c /* The cJSON structure: */ typedef struct cJSON { /* next/prev allow you to walk array/object chains. Alternatively, use GetArraySize/GetArrayItem/GetObjectItem 链表记录前后的JSON数据*/ struct cJSON *next; struct cJSON *prev; /* An array or object item will have a child pointer pointing to a chain of the items in the array/object. 子对象是一个新的JSON数据*/ struct cJSON *child; /* The type of the item, as above. 记录类型*/ int type; /* The item's string, if type cJSON_String and type cJSON_Raw 字符串数据*/ char *valuestring; /* writing to valueint is DEPRECATED, use cJSON_SetNumberValue instead 指向整形数据*/ int valueint; /* The item's number, if type cJSON_Number 浮点数使用这一个指向*/ double valuedouble; /* The item's name string, if this item is the child of, or is in the list of subitems of an object. 键值对的名称*/ char *string; } cJSON; ``` ## 创建 cJSON使用的一个链表的形式进行建立的 头指针：指向链表头结点的指针； 头结点：不存放有效数据，方便链表操作； 首节点：第一个存放有效数据的节点； 尾节点：最后一个存放有效数据的节点； 1. 创建头指针 ```c cJSON* cjson_test NULL; ``` 2. 建立头结点 ```c cjson_test cJSON_CreateObject(); ``` 3. 添加信息 ```c /* Helper functions for creating and adding items to an object at the same time. * They return the added item or NULL on failure. */ CJSON_PUBLIC(cJSON*) cJSON_AddNullToObject(cJSON * const object, const char * const name); CJSON_PUBLIC(cJSON*) cJSON_AddTrueToObject(cJSON * const object, const char * const name); CJSON_PUBLIC(cJSON*) cJSON_AddFalseToObject(cJSON * const object, const char * const name); CJSON_PUBLIC(cJSON*) cJSON_AddBoolToObject(cJSON * const object, const char * const name, const cJSON_bool boolean); CJSON_PUBLIC(cJSON*) cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number); CJSON_PUBLIC(cJSON*) cJSON_AddStringToObject(cJSON * const object, const char * const name, const char * const string); CJSON_PUBLIC(cJSON*) cJSON_AddRawToObject(cJSON * const object, const char * const name, const char * const raw); CJSON_PUBLIC(cJSON*) cJSON_AddObjectToObject(cJSON * const object, const char * const name); CJSON_PUBLIC(cJSON*) cJSON_AddArrayToObject(cJSON * const object, const char * const name); ``` ```c int main(void){ cJSON *root cJSON_CreateObject(); cJSON *message cJSON_CreateObject(); cJSON_AddStringToObject(root, \"name\", \"John\"); cJSON_AddNumberToObject(root, \"age\", 25); cJSON_AddStringToObject(message, \"city\", \"New York\"); cJSON_AddItemToObject(root, \"address\", message); char * data cJSON_Print(root); //获取字符形式 printf(data); } ``` ```c cJSON_AddItemToObject(root, \"language\", cJSON_CreateString( \"C\" )); ``` > 这一个实际和`cJSON_AddStringToObject(root, \"language\", \"C\");`是一样的 ## 数据解析 1. 创建一个链表头部 ```c cJSON *cjson NULL; ``` 2. 解析数据 ```c (cJSON *)cJSON_Parse(const char *value); ``` 3. 获取对应的值 ```c (cJSON *) cJSON_GetObjectItem(const cJSON * const object, const char * const string) ``` 4. 解析数组 ```c (int) cJSON_GetArraySize(const cJSON *array); (cJSON *) cJSON_GetArrayItem(const cJSON *array, int index); ``` 5. 释放内存 ```c (void) cJSON_Delete(cJSON *item); ``` > 这一个系列操作会使用大量内存, 需要及时释放内存"},"/note/嵌入式/esp32/esp-idf/2024-6-27-25电源管理.html":{"title":"电源管理","content":" layout: post title: \"电源管理\" date: 2024 6 26 15:39:08 +0800 tags: esp32 ESP IDF # 电源管理 ESP IDF的集成电源管理可以根据程序组件的需求, 调节总线的频率, CPU的频率 [CONFIG_PM_ENABLE](https://docs.espressif.com/projects/esp idf/zh_CN/stable/esp32/api reference/kconfig.html#config pm enable) 选项启用电源管理功能。 使用这一个进行调节CPU的频率会使得中断的响应时间增加 ## 启用动态调频和自动 Light sleep ```c esp_err_t esp_pm_configure(const void *config) ``` > 这一个里面需要设置三个函数 > > `max_freq_mhz`：最大 CPU 频率 (MHz)，即获取 `ESP_PM_CPU_FREQ_MAX` 锁后所使用的频率。该字段通常设置为 [CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ](https://docs.espressif.com/projects/esp idf/zh_CN/stable/esp32/api reference/kconfig.html#config esp default cpu freq mhz)。 > `min_freq_mhz`：最小 CPU 频率 (MHz)，即仅获取 `ESP_PM_APB_FREQ_MAX` 锁后所使用的频率。该字段可设置为晶振 (XTAL) 频率值，或者 XTAL 频率值除以整数。注意，10 MHz 是生成 1 MHz 的 REF_TICK 默认时钟所需的最小频率。 > `light_sleep_enable`：没有获取任何管理锁时，决定系统是否需要自动进入 Light sleep 状态 (`true`/`false`)。 > > 如果在 menuconfig 中启用了 [CONFIG_PM_DFS_INIT_AUTO](https://docs.espressif.com/projects/esp idf/zh_CN/stable/esp32/api reference/kconfig.html#config pm dfs init auto) 选项，最大 CPU 频率将由 [CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ](https://docs.espressif.com/projects/esp idf/zh_CN/stable/esp32/api reference/kconfig.html#config esp default cpu freq mhz) 设置决定，最小 CPU 频率将锁定为 XTAL 频率(晶振的频率)。 ESP32的电源管理中，管理锁用于保护系统在深度睡眠模式下不被意外唤醒。当ESP32进入深度睡眠模式后，所有的外设和时钟都被关闭，只有管理模块处于工作状态。如果在此期间，外部信号或中断触发了某个外设，可能会导致系统被唤醒，从而影响功耗。因此，ESP32引入了管理锁的概念，当管理锁被锁定时，即使有外部触发，系统也不会被唤醒。只有当管理锁被解锁时，才会允许外部信号触发系统唤醒。这样可以有效地防止系统被意外唤醒，延长电池寿命。 > 自动 Light sleep 模式基于 FreeRTOS Tickless Idle 功能，因此如果在 menuconfig 中没有启用 [CONFIG_FREERTOS_USE_TICKLESS_IDLE](https://docs.espressif.com/projects/esp idf/zh_CN/stable/esp32/api reference/kconfig.html#config freertos use tickless idle) 选项，在请求自动 Light sleep 时，[`esp_pm_configure()`](https://docs.espressif.com/projects/esp idf/zh_CN/stable/esp32/api reference/system/power_management.html#_CPPv416esp_pm_configurePKv) 将会返回 ESP_ERR_NOT_SUPPORTED 错误。 > > If power management support is enabled, FreeRTOS will be able to put the system into light sleep mode when no tasks need to run for a number of ticks. This number can be set using FREERTOS_IDLE_TIME_BEFORE_SLEEP option. This feature is also known as \"automatic light sleep\". > > 可以使用这一个选项设置自动睡眠 CPU 最高频率 电源管理锁获取情况 APB 频率和 CPU 频率 240 获取 `ESP_PM_CPU_FREQ_MAX`或 `ESP_PM_APB_FREQ_MAX` CPU: 240 MHzAPB: 80 MHz 无 使用 [`esp_pm_configure()`](https://docs.espressif.com/projects/esp idf/zh_CN/v5.2.2/esp32/api reference/system/power_management.html#_CPPv416esp_pm_configurePKv) 为二者设置最小值 160 获取 `ESP_PM_CPU_FREQ_MAX` CPU: 160 MHzAPB: 80 MHz 获取 `ESP_PM_APB_FREQ_MAX`,未获得 `ESP_PM_CPU_FREQ_MAX` CPU: 80 MHzAPB: 80 MHz 无 使用 [`esp_pm_configure()`](https://docs.espressif.com/projects/esp idf/zh_CN/v5.2.2/esp32/api reference/system/power_management.html#_CPPv416esp_pm_configurePKv) 为二者设置最小值 80 获取 `ESP_PM_CPU_FREQ_MAX`或 `ESP_PM_APB_FREQ_MAX` CPU: 80 MHzAPB: 80 MHz 无 使用 [`esp_pm_configure()`](https://docs.espressif.com/projects/esp idf/zh_CN/v5.2.2/esp32/api reference/system/power_management.html#_CPPv416esp_pm_configurePKv) 为二者设置最小值 ## 动态调频和外设驱动 使用动态调频的时候, APB的频率可以在一个RTOS的周期里面多次改变, 有的外设不受APB的频率影响, 有的可能会出现问题 > Timer Group 外设定时器会继续计数，但定时器计数的速度将随 APB 频率的变更而变更。 时钟频率不受 APB 频率影响的外设时钟源通常有 `REF_TICK`, `XTAL`, `RC_FAST` (i.e., `RTC_8M`)。 目前以下外设驱动程序可感知动态调频，并在调频期间使用 `ESP_PM_APB_FREQ_MAX` 锁： SPI master I2C I2S（如果 APLL 锁在使用中，I2S 则会启用 `ESP_PM_NO_LIGHT_SLEEP` 锁） SDMMC 启用以下驱动程序时，将占用 `ESP_PM_APB_FREQ_MAX` 锁： **SPI slave**：从调用 [`spi_slave_initialize()`](https://docs.espressif.com/projects/esp idf/zh_CN/v5.2.2/esp32/api reference/peripherals/spi_slave.html#_CPPv420spi_slave_initialize17spi_host_device_tPK16spi_bus_config_tPK28spi_slave_interface_config_t14spi_dma_chan_t) 至 [`spi_slave_free()`](https://docs.espressif.com/projects/esp idf/zh_CN/v5.2.2/esp32/api reference/peripherals/spi_slave.html#_CPPv414spi_slave_free17spi_host_device_t) 期间。 **GPTimer**：从调用 [`gptimer_enable()`](https://docs.espressif.com/projects/esp idf/zh_CN/v5.2.2/esp32/api reference/peripherals/gptimer.html#_CPPv414gptimer_enable16gptimer_handle_t) 至 [`gptimer_disable()`](https://docs.espressif.com/projects/esp idf/zh_CN/v5.2.2/esp32/api reference/peripherals/gptimer.html#_CPPv415gptimer_disable16gptimer_handle_t) 期间。 **Ethernet**：从调用 [`esp_eth_driver_install()`](https://docs.espressif.com/projects/esp idf/zh_CN/v5.2.2/esp32/api reference/network/esp_eth.html#_CPPv422esp_eth_driver_installPK16esp_eth_config_tP16esp_eth_handle_t) 至 [`esp_eth_driver_uninstall()`](https://docs.espressif.com/projects/esp idf/zh_CN/v5.2.2/esp32/api reference/network/esp_eth.html#_CPPv424esp_eth_driver_uninstall16esp_eth_handle_t) 期间。 **WiFi**：从调用 [`esp_wifi_start()`](https://docs.espressif.com/projects/esp idf/zh_CN/v5.2.2/esp32/api reference/network/esp_wifi.html#_CPPv414esp_wifi_startv) 至 [`esp_wifi_stop()`](https://docs.espressif.com/projects/esp idf/zh_CN/v5.2.2/esp32/api reference/network/esp_wifi.html#_CPPv413esp_wifi_stopv) 期间。如果启用了调制解调器睡眠模式，广播关闭时将释放此管理锁。 **TWAI**：从调用 [`twai_driver_install()`](https://docs.espressif.com/projects/esp idf/zh_CN/v5.2.2/esp32/api reference/peripherals/twai.html#_CPPv419twai_driver_installPK21twai_general_config_tPK20twai_timing_config_tPK20twai_filter_config_t) 至 [`twai_driver_uninstall()`](https://docs.espressif.com/projects/esp idf/zh_CN/v5.2.2/esp32/api reference/peripherals/twai.html#_CPPv421twai_driver_uninstallv) 期间 (只有在 TWAI 时钟源选择为 [`TWAI_CLK_SRC_APB`](https://docs.espressif.com/projects/esp idf/zh_CN/v5.2.2/esp32/api reference/peripherals/clk_tree.html#_CPPv4N25soc_periph_twai_clk_src_t16TWAI_CLK_SRC_APBE) 的时候生效)。 **Bluetooth**：从调用 [`esp_bt_controller_enable()`](https://docs.espressif.com/projects/esp idf/zh_CN/v5.2.2/esp32/api reference/bluetooth/controller_vhci.html#_CPPv424esp_bt_controller_enable13esp_bt_mode_t) 至 [`esp_bt_controller_disable()`](https://docs.espressif.com/projects/esp idf/zh_CN/v5.2.2/esp32/api reference/bluetooth/controller_vhci.html#_CPPv425esp_bt_controller_disablev) 期间。如果启用了蓝牙调制解调器，广播关闭时将释放此管理锁。但依然占用 `ESP_PM_NO_LIGHT_SLEEP` 锁，除非将 [CONFIG_BTDM_CTRL_LOW_POWER_CLOCK](https://docs.espressif.com/projects/esp idf/zh_CN/v5.2.2/esp32/api reference/kconfig.html#config btdm ctrl low power clock) 选项设置为 “外部 32 kHz 晶振”。 ## API ```c #include \"esp_pm.h\" ``` This header file is a part of the API provided by the `esp_pm` component. To declare that your component depends on `esp_pm`, add the following to your CMakeLists.txt: > REQUIRES esp_pm > > PRIV_REQUIRES esp_pm ```c esp_err_t esp_pm_configure(const void *config) ``` > 配置函数, 使用这一个函数进行配置 ```c esp_err_t esp_pm_lock_create(esp_pm_lock_type_t lock_type, int arg, const char *name, esp_pm_lock_handle_t *out_handle) ``` > 初始化句柄, 初始化的时候这一个句柄是没有获取的 > > **lock_type** Power management constraint which the lock should control > **arg** argument, value depends on lock_type, see esp_pm_lock_type_t > **name** arbitrary string identifying the lock (e.g. \"wifi\" or \"spi\"). Used by the esp_pm_dump_locks function to list existing locks. May be set to NULL. If not set to NULL, must point to a string which is valid for the lifetime of the lock. > **out_handle** **[out]** handle returned from this function. Use this handle when calling esp_pm_lock_delete, esp_pm_lock_acquire, esp_pm_lock_release. Must not be NULL. ```c esp_err_t esp_pm_lock_acquire(esp_pm_lock_handle_t handle) ``` > 这一个锁被获取的时候会使用对应的电池管理算法, 这一个锁是一个递归的锁, 可以在中断里面使用 > > **handle** handle obtained from esp_pm_lock_create function ```c esp_err_t esp_pm_lock_release(esp_pm_lock_handle_t handle) ``` > 释放这一个锁 ## 重启 ```c void esp_restart(void) ``` > 重启 ```c esp_err_t esp_register_shutdown_handler(shutdown_handler_t handle) ``` > 注册一个回调函数, 会在esp_restart函数执行的时候进行调用"},"/note/嵌入式/esp32/esp-idf/2024-5-24-04I2C.html":{"title":"I2C","content":" layout: post title: \"I2C\" date: 2024 5 24 15:39:08 +0800 tags: esp32 ESP IDF # I2C ## 使用流程 1. 使用i2c_config_t这一个结构体设置i2c的模式 ```c /** * @brief I2C initialization parameters */ typedef struct{ i2c_mode_t mode; /*!< I2C mode */ int sda_io_num; /*!< GPIO number for I2C sda signal使用的IO */ int scl_io_num; /*!< GPIO number for I2C scl signal */ bool sda_pullup_en; /*!< Internal GPIO pull mode for I2C sda signal 是否使用上下拉*/ bool scl_pullup_en; /*!< Internal GPIO pull mode for I2C scl signal*/ union { struct { uint32_t clk_speed; /*!< I2C clock frequency for master mode, (no higher than 1MHz for now) 设置时钟的频率*/ } master; /*!< I2C master config */ #if SOC_I2C_SUPPORT_SLAVE struct { uint8_t addr_10bit_en; /*!< I2C 10bit address mode enable for slave mode 是不是使用10位地址*/ uint16_t slave_addr; /*!< I2C address for slave mode 从机地址*/ uint32_t maximum_speed; /*!< I2C expected clock speed from SCL. 最大的时速*/ } slave; /*!< I2C slave config */ #endif // SOC_I2C_SUPPORT_SLAVE }; uint32_t clk_flags; /*!< Bitwise of ``I2C_SCLK_SRC_FLAG_**FOR_DFS**`` for clk source choice 这一个不用设置 使用默认即可*/ } i2c_config_t; ``` 2. 初始化给定 I2C 端口的配置, 使用函数`i2c_param_config`设置参数 3. 进行安装驱动程序 ## API ### i2c_param_config初始化设置 ```c esp_err_t i2c_param_config(i2c_port_ti2c_num, consti2c_config_t *i2c_conf) ``` > 使用I2C编号以及初始化结构体进行初始化这一个I2C设备 ### i2c_driver_install安装驱动 ```c esp_err_t i2c_driver_install(i2c_port_ti2c_num, i2c_mode_tmode, size_t slv_rx_buf_len, size_t slv_tx_buf_len, int intr_alloc_flags) ``` ### 主机发送 1. 使用 [`i2c_cmd_link_create()`](https://docs.espressif.com/projects/esp idf/zh_CN/v4.4/esp32/api reference/peripherals/i2c.html#_CPPv419i2c_cmd_link_createv) 创建一个命令链接。 > 然后，将一系列待发送给从机的数据填充命令链接： 1. **启动位** [`i2c_master_start()`](https://docs.espressif.com/projects/esp idf/zh_CN/v4.4/esp32/api reference/peripherals/i2c.html#_CPPv416i2c_master_start16i2c_cmd_handle_t) 2. **从机地址** [`i2c_master_write_byte()`](https://docs.espressif.com/projects/esp idf/zh_CN/v4.4/esp32/api reference/peripherals/i2c.html#_CPPv421i2c_master_write_byte16i2c_cmd_handle_t7uint8_tb)。提供单字节地址作为调用此函数的实参。 3. **数据** 一个或多个字节的数据作为 [`i2c_master_write()`](https://docs.espressif.com/projects/esp idf/zh_CN/v4.4/esp32/api reference/peripherals/i2c.html#_CPPv416i2c_master_write16i2c_cmd_handle_tPK7uint8_t6size_tb) 的实参。 4. **停止位** [`i2c_master_stop()`](https://docs.espressif.com/projects/esp idf/zh_CN/v4.4/esp32/api reference/peripherals/i2c.html#_CPPv415i2c_master_stop16i2c_cmd_handle_t) > 函数 [`i2c_master_write_byte()`](https://docs.espressif.com/projects/esp idf/zh_CN/v4.4/esp32/api reference/peripherals/i2c.html#_CPPv421i2c_master_write_byte16i2c_cmd_handle_t7uint8_tb) 和 [`i2c_master_write()`](https://docs.espressif.com/projects/esp idf/zh_CN/v4.4/esp32/api reference/peripherals/i2c.html#_CPPv416i2c_master_write16i2c_cmd_handle_tPK7uint8_t6size_tb) 都有额外的实参，规定主机是否应确认其有无接受到 ACK 位。 2. 通过调用 [`i2c_master_cmd_begin()`](https://docs.espressif.com/projects/esp idf/zh_CN/v4.4/esp32/api reference/peripherals/i2c.html#_CPPv420i2c_master_cmd_begin10i2c_port_t16i2c_cmd_handle_t10TickType_t) 来触发 I2C 控制器执行命令链接。一旦开始执行，就不能再修改命令链接。 3. 命令发送后，通过调用 [`i2c_cmd_link_delete()`](https://docs.espressif.com/projects/esp idf/zh_CN/v4.4/esp32/api reference/peripherals/i2c.html#_CPPv419i2c_cmd_link_delete16i2c_cmd_handle_t) 释放命令链接使用的资源。 > 前几个函数获取一个发送的命令, 使用i2c_master_cmd_begin实际进行发送 ![image 20240524213136923](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405242131986.png) > 发送的时候需要设置地址`(ESP_SLAVE_ADDR << 1) I2C_MASTER_WRITE` > > `i2c_master_write_byte(cmd, (ESP_SLAVE_ADDR << 1) I2C_MASTER_WRITE, ACK_EN);` ```c i2c_cmd_handle_t cmd i2c_cmd_link_create(); i2c_master_start(cmd); i2c_master_write_byte(cmd, 0x70 << 1 I2C_MASTER_WRITE, true);//发送一个读地址 i2c_master_write_byte(cmd, 0xEF, true); i2c_master_write_byte(cmd, 0xC8, true); // 发送一个0xefc8的命令 i2c_master_stop(cmd); ret i2c_master_cmd_begin(I2C_MASTER_NUM, cmd, 1000 / portTICK_PERIOD_MS); if (ret ! ESP_OK) { goto end; } i2c_cmd_link_delete(cmd); ``` ![image 20240524213027175](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405242130236.png) > `i2c_master_write_byte(cmd, (ESP_SLAVE_ADDR << 1) I2C_MASTER_READ, ACK_EN);` ```c cmd i2c_cmd_link_create(); i2c_master_start(cmd); i2c_master_write_byte(cmd, 0x70 << 1 I2C_MASTER_READ, true); i2c_master_read(cmd, data, 3, I2C_MASTER_LAST_NACK); //读取三个字节 i2c_master_stop(cmd); ret i2c_master_cmd_begin(I2C_MASTER_NUM, cmd, 1000 / portTICK_PERIOD_MS); i2c_cmd_link_delete(cmd); ``` ### 从机接收 ```c int i2c_slave_read_buffer(i2c_port_t i2c_num, uint8_t *data, size_t max_size, TickType_t ticks_to_wait) ``` > 阻塞获取数据 ### 从机发送 ```c int i2c_slave_write_buffer(i2c_port_ti2c_num, const uint8_t *data, int size, TickType_t ticks_to_wait) ``` > 这几个数据会进行存储, 主机获取的时候依次发送数据 ### i2c_master_write_read_device ```c esp_err_t i2c_master_write_read_device(i2c_port_t i2c_num, uint8_t device_address, const uint8_t *write_buffer, size_t write_size, uint8_t *read_buffer, size_t read_size, TickType_t ticks_to_wait) ``` > write followed by a read to a device on the I2C bus. > > 在主机模式下面可以使用这一个函数进行发送一个数据然后读取 > > **i2c_num** I2C port number to perform the transfer on 使用的设备 > **device_address** I2C device's 7 bit address 从机地址 > **write_buffer** Bytes to send on the bus 写入的数据(一般是寄存器, 命令之类的) > **write_size** Size, in bytes, of the write buffer 大小 > **read_buffer** Buffer to store the bytes received on the bus 读取的数据 > **read_size** Size, in bytes, of the read buffer 读取的大小 > **ticks_to_wait** Maximum ticks to wait before issuing a timeout. 等待的时间 > > ```c > i2c_master_write_read_device(I2C_MASTER_NUM, QMI8658C_SENSOR_ADDR, &reg_addr, 1, data, len, I2C_MASTER_TIMEOUT_MS / portTICK_PERIOD_MS); > } > ``` ### i2c_master_read_from_device ```c esp_err_t i2c_master_read_from_device(i2c_port_t i2c_num, uint8_t device_address, uint8_t *read_buffer, size_t read_size, TickType_t ticks_to_wait) ``` > 一个封装的读取函数 ### i2c_master_write_to_device ```c esp_err_t i2c_master_write_to_device(i2c_port_t i2c_num, uint8_t device_address, const uint8_t *write_buffer, size_t write_size, TickType_t ticks_to_wait) ``` > 一个封装的写入函数 ## 示例 使用头文件`#include \"driver/i2c.h\"` ```c #ifndef JIAO_I2C_H #define JIAO_I2C_H #define I2C_MASTER_SCL_IO GPIO_NUM_1 /*!< GPIO number used for I2C master clock 两个引脚*/ #define I2C_MASTER_SDA_IO GPIO_NUM_0 /*!< GPIO number used for I2C master data */ #define I2C_MASTER_NUM 0 /*!< 使用的I2C序号 I2C master i2c port number, the number of i2c peripheral interfaces available will depend on the chip */ #define I2C_MASTER_FREQ_HZ 400000 /*!< 设置它的速率 I2C master clock frequency */ #define I2C_MASTER_TX_BUF_DISABLE 0 /*!< 主机不使用buf I2C master doesn't need buffer */ #define I2C_MASTER_RX_BUF_DISABLE 0 /*!< I2C master doesn't need buffer */ #define I2C_MASTER_TIMEOUT_MS 1000 //设置超时时间 #endif //JIAO_I2C_H ``` ```c static esp_err_t i2c_master_init(void) { int i2c_master_port I2C_MASTER_NUM; i2c_config_t conf { .mode I2C_MODE_MASTER, .sda_io_num I2C_MASTER_SDA_IO, .scl_io_num I2C_MASTER_SCL_IO, .sda_pullup_en GPIO_PULLUP_ENABLE, .scl_pullup_en GPIO_PULLUP_ENABLE, .master.clk_speed I2C_MASTER_FREQ_HZ, }; i2c_param_config(i2c_master_port, &conf); return i2c_driver_install(i2c_master_port, conf.mode, I2C_MASTER_RX_BUF_DISABLE, I2C_MASTER_TX_BUF_DISABLE, 0); } ``` ```c // 读取ID esp_err_t gxhtc3_read_id(void) { esp_err_t ret; uint8_t data[3]; i2c_cmd_handle_t cmd i2c_cmd_link_create(); i2c_master_start(cmd); i2c_master_write_byte(cmd, 0x70 << 1 I2C_MASTER_WRITE, true); i2c_master_write_byte(cmd, 0xEF, true); i2c_master_write_byte(cmd, 0xC8, true); i2c_master_stop(cmd); ret i2c_master_cmd_begin(I2C_MASTER_NUM, cmd, 1000 / portTICK_PERIOD_MS); if (ret ! ESP_OK) { goto end; } cmd i2c_cmd_link_create(); i2c_master_start(cmd); i2c_master_write_byte(cmd, 0x70 << 1 I2C_MASTER_READ, true); i2c_master_read(cmd, data, 3, I2C_MASTER_LAST_NACK); i2c_master_stop(cmd); ret i2c_master_cmd_begin(I2C_MASTER_NUM, cmd, 1000 / portTICK_PERIOD_MS); if(data[2]! gxhtc3_calc_crc(data,2)){ ret ESP_FAIL; } end: i2c_cmd_link_delete(cmd); return ret; } ```"},"/note/嵌入式/esp32/esp-idf/2024-5-23-安装.html":{"title":"安装","content":" layout: post title: \"安装\" date: 2024 5 23 15:39:08 +0800 tags: esp32 ESP IDF # 安装 ## 离线安装 ### vscode设置 ![image 20240523205039087](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405232050199.png) ![image 20240523205125931](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405232051962.png) > 建立一个新的配置文件, 这里面的插件是全新的 ### 安装esp idf [官网下载espidf](https://dl.espressif.com/dl/esp idf/?idf 4.4) ![image 20240523205614417](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405232056448.png) 安装这一个 ![image 20240523214724220](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405232147252.png) ![image 20240523214745610](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405232147657.png) > 选项默认即可 ![image 20240523205625139](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405232056169.png) > 记住各一个路径, 之后要用到 vscode安装插件 ![image 20240523205640736](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405232056774.png) ![image 20240523205719849](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405232057953.png) > 安装以后会进入这一个界面, 也可以Ctrl+Shift+P输入ESP IDFextension进入 ![image 20240523205834263](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405232058295.png) ![image 20240523214903317](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405232149369.png) ![image 20240523205857288](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405232058331.png) ![image 20240523210014210](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405232100306.png) > 使用espressif ### 问题 ![image 20240523210115454](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405232101488.png) ![image 20240523210351955](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405232103011.png) > 这一个是路径问题 ![image 20240523210443236](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405232104294.png) > 之后安装成功 ### 测试 ![image 20240523212302116](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405232123151.png) ![image 20240523212326590](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405232123651.png) ![image 20240523212413663](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405232124711.png) ![image 20240523212847411](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405232128442.png) ![image 20240523212811842](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405232128875.png) ### 出现问题import包失败 这一个是脚本里面的问题, 需要在环境变量里面把这一个使用的那一个python路径移动到前面 ### build.ninja: error: loading 'build.ninja' 重新选一下板子然后编译 ## vscode直接安装 使用之前的方法建立一个新的环境 ![image 20240523214344411](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405232143462.png) ![image 20240523214426494](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405232144547.png) 安装即可 ## 切换版本 ![image 20240523214508795](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405232145899.png) ![image 20240523214531249](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405232145293.png) ![image 20240523214615252](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405232146313.png)"},"/note/嵌入式/esp32/micropython/2026-1-3-05-编译.html":{"title":"编译","content":"# 编译 ```bash git clone https://github.com/micropython/micropython.git cd micropython make C mpy cross cd ports/esp32 git submodule update init recursive make clean idf.py set target esp32s3 IDF_TARGET esp32s3 idf.py set target esp32s3 IDF_TARGET esp32s3 make BOARD ESP32_GENERIC_S3 USER_C_MODULES ../../examples/usercmodule/micropython.cmake # OTA变体: make BOARD ESP32_GENERIC BOARD_VARIANT OTA picocom b 115200 /dev/ ``` ### 烧录 ```bash # 擦除falsh make erase # 烧录 make deploy ```"},"/note/嵌入式/esp32/micropython/2024-4-22-02-GPIO.html":{"title":"GPIO","content":" layout: post title: \"GPIO\" date: 2024 2 2 15:39:08 +0800 tags: esp32 Micropython # GPIO ## 官网示例 ```python from machine import Pin p0 Pin(0, Pin.OUT) # create output pin on GPIO0 p0.on() # set pin to \"on\" (high) level p0.off() # set pin to \"off\" (low) level p0.value(1) # set pin to on/high p2 Pin(2, Pin.IN) # create input pin on GPIO2 print(p2.value()) # get value, 0 or 1 p4 Pin(4, Pin.IN, Pin.PULL_UP) # enable internal pull up resistor p5 Pin(5, Pin.OUT, value 1) # set pin high on creation p6 Pin(6, Pin.OUT, drive Pin.DRIVE_3) # set maximum drive strength ``` ## PWM ```python from machine import Pin, PWM pwm0 PWM(Pin(0), freq 5000, duty_u16 32768) # create PWM object from a pin, 同时设置占空比 freq pwm0.freq() # get current frequency pwm0.freq(1000) # set PWM frequency from 1Hz to 40MHz duty pwm0.duty() # get current duty cycle, range 0 1023 (default 512, 50%) pwm0.duty(256) # set duty cycle from 0 to 1023 as a ratio duty/1023, (now 25%) duty_u16 pwm0.duty_u16() # get current duty cycle, range 0 65535使用16位数据控制占空比 pwm0.duty_u16(2**16*3//4) # set duty cycle from 0 to 65535 as a ratio duty_u16/65535, (now 75%) duty_ns pwm0.duty_ns() # get current pulse width in ns pwm0.duty_ns(250_000) # set pulse width in nanoseconds from 0 to 1_000_000_000/freq, (now 25%) pwm0.deinit() # turn off PWM on the pin pwm2 PWM(Pin(2), freq 20000, duty 512) # create and configure in one go print(pwm2) # view PWM settings ``` > PWM can be enabled on all output enabled pins. The base frequency can range from 1Hz to 40MHz but there is a tradeoff; as the base frequency *increases* the duty resolution *decreases*. > > ```c > from machine import Pin, PWM > import time > pwm0 PWM(Pin(2), freq 5000, duty_u16 768) # create PWM object from a pin > > duty_now 1 > > while True: > pwm0.duty(duty_now) > duty_now + 30 > if duty_now > 255: > duty_now 0 > time.sleep(1) > print(duty_now) > ``` > > ```python > from machine import Pin, PWM > import time > pwm0 PWM(Pin(2), freq 5000, duty_u16 768) # create PWM object from a pin > > while True: > for i in range(0, 1024, 1): > pwm0.duty(i) > time.sleep_ms(2) > for i in range(1023, 0, 1): > pwm0.duty(i) > time.sleep_ms(2) > ``` > >"},"/note/嵌入式/esp32/micropython/2024-4-22-03-WIFI.html":{"title":"WIFI","content":" layout: post title: \"WIFI\" date: 2024 2 2 15:39:08 +0800 tags: esp32 Micropython # WIFI `Wi Fi`是基于`IEEE 802.11`标准的无线网络技术 让联网设备以无线电波的形式，加入采用`TCP/IP`通信协议的网络 `Wi Fi`网络环境通常有两种设备 Access Point(`AP`) 无线接入点，提供无线接入的设备，家里的光猫就是结合WiFi和internet路由功能的AP。AP和AP可以相互连接。 Station(`STA`) 无线终端，连接到AP的装置，手机，电脑等需要联网的设备都是出于STA模式，这个模式不允许其他设备接入 ### 官方示例 ```python import network wlan network.WLAN(network.STA_IF) # create station interface设置无线终端模式 wlan.active(True) # activate the interface wlan.scan() # scan for access points wlan.isconnected() # check if the station is connected to an AP wlan.connect('ssid', 'key') # connect to an AP wlan.config('mac') # get the interface's MAC address获取信息 wlan.ifconfig() # get the interface's IP/netmask/gw/DNS addresses获取信息 ``` ```c ap network.WLAN(network.AP_IF) # create access point interface ap.config(ssid 'ESP AP') # set the SSID of the access point ap.config(max_clients 10) # set how many clients can connect to the network ap.active(True) # activate the interface ``` ```python def do_connect(): import network wlan network.WLAN(network.STA_IF) wlan.active(True) if not wlan.isconnected(): print('connecting to network...') wlan.connect('ssid', 'key') while not wlan.isconnected(): pass print('network config:', wlan.ifconfig()) # 返回IP/netmask/gw/DNS ``` > Once the network is established the [`socket`](https://docs.micropython.org/en/latest/library/socket.html#module socket) module can be used to create and use TCP/UDP sockets as usual, and the `requests` module for convenient HTTP requests. > > 之后就可以使用这两个模块了 > > After a call to `wlan.connect()`, the device will by default retry to connect **forever**, even when the authentication failed or no AP is in range. `wlan.status()` will return `network.STAT_CONNECTING` in this state until a connection succeeds or the interface gets disabled. This can be changed by calling `wlan.config(reconnects n)`, where n are the number of desired reconnect attempts (0 means it won’t retry, 1 will restore the default behaviour of trying to reconnect forever). > > 一旦建立连接, 这一个连接会被保存下来, 可以通过wlan.config(reconnects n)设置连接的次数 **BSSID**就是无线路由器的MAC地址（本质是**一个MAC地址**） **SSID**就是手机上搜索到的wifi名字（本质是**一串字符**） **ESSID**是一个比较抽象的概念，它实际上就和ssid相同（本质也是**一串字符**）。如果有好几个无线路由器都叫这个名字，那么我们就相当于把这个ssid**扩大**了，所以这几个无线路由器共同的这个名字就叫ESSID 打个比方： SSID就好比是每个连锁店的门口**招牌**上写的字（例如：阿迪达斯） ESSID就是连锁店的牌子（例如：阿迪达斯） BSSID就是每个连锁店的地址（比如万达广场店，襄阳路店）"},"/note/嵌入式/esp32/micropython/2026-1-6-06-自定义模块.html":{"title":"自定义模块","content":"# 自定义模块 ## 编译 ```bash # 使用make cd micropython/ports/rp2 make USER_C_MODULES ../../examples/usercmodule # 使用cmake cd micropython/ports/esp32 make USER_C_MODULES ../../examples/usercmodule/micropython.cmake ``` 对应的文件分别是micropythonmk以及micropython.cmake 可以使用一个顶层 `micropython.cmake`（比如位于 `modules`）需通过 `include` 引入所有待启用的模块 ```cmake include(${CMAKE_CURRENT_LIST_DIR}/cexample/micropython.cmake) # Add the CPP example. include(${CMAKE_CURRENT_LIST_DIR}/cppexample/micropython.cmake) ``` 编译的时候 ```bash make USER_C_MODULES ../../../../modules/micropython.cmake ``` 所有通过 `USER_C_MODULES` 指定的模块（Make 从目录自动查找、CMake 从 `include` 引入）都会被编译，但只有启用的模块可被导入： 自定义模块通常默认启用（由模块开发者决定），此时只需按上述方式设置 `USER_C_MODULES` 即可； 若模块未默认启用，需手动开启对应的 C 预处理器宏： 1. 在模块源码中找到 `MP_REGISTER_MODULE` 行（通常在主源码文件末尾），其外围会有 `#if X` / `#endif` 包裹，`X` 即为需启用的配置项； 2. 通过 `CFLAGS_EXTRA` 设置 `X 1`，或在 `mpconfigport.h` / `mpconfigboard.h` 中添加 `#define X (1)`。 示例：若 `cexample` 模块默认禁用，源码中会有： ```c #if MODULE_CEXAMPLE_ENABLED MP_REGISTER_MODULE(MP_QSTR_cexample, example_user_cmodule); #endif ``` 启用方式： ```bash # 编译时添加 CFLAGS_EXTRA make CFLAGS_EXTRA DMODULE_CEXAMPLE_ENABLED 1 ``` 或在配置文件中添加： ```c #define MODULE_CEXAMPLE_ENABLED (1) ``` ## 函数 ### 变量定义 ```cpp typedef mp_obj_t (*mp_fun_0_t)(void); typedef mp_obj_t (*mp_fun_1_t)(mp_obj_t); typedef mp_obj_t (*mp_fun_2_t)(mp_obj_t, mp_obj_t); typedef mp_obj_t (*mp_fun_3_t)(mp_obj_t, mp_obj_t, mp_obj_t); // 传入的位置参数个数, 数组里每个元素都是 mp_obj_t 类型的位置参数 typedef mp_obj_t (*mp_fun_var_t)(size_t n, const mp_obj_t *); // mp_fun_kw_t takes mp_map_t* (and not const mp_map_t*) to ease passing // this arg to mp_map_lookup(). // Note that the mp_obj_t* array will contain all arguments, positional and keyword, with the keyword // ones starting at offset n, like: arg0 arg1 ... arg<n> key0 value0 key1 value1 ..., and the mp_map_t* // gets those same keyword arguments but as a map for convenience; see fun_builtin_var_call. // mp_obj_t：MicroPython 中所有对象的 “通用容器类型”（整数、字符串、列表、函数等都用这个类型表示）。 // mp_map_t：MicroPython 中用于存储键值对的映射结构（对应 Python 的字典，专门用来处理关键字参数）。 // mp_obj_t: 纯位置参数的个数, 前 n 个元素 位置参数（对应 Python 的 *args） // 从 n 开始 关键字参数（键 值成对出现，如 key0, value0, key1, value1...） // mp_map_t 关键字参数的映射表（简化查找，对应 Python 的 **kwargs） typedef mp_obj_t (*mp_fun_kw_t)(size_t n, const mp_obj_t *, mp_map_t *); // functions 使用下面的类型进行封装 typedef struct _mp_obj_fun_builtin_fixed_t { mp_obj_base_t base; union { mp_fun_0_t _0; mp_fun_1_t _1; mp_fun_2_t _2; mp_fun_3_t _3; } fun; } mp_obj_fun_builtin_fixed_t; typedef struct _mp_obj_fun_builtin_var_t { mp_obj_base_t base; uint32_t sig; // see MP_OBJ_FUN_MAKE_SIG union { mp_fun_var_t var; mp_fun_kw_t kw; } fun; } mp_obj_fun_builtin_var_t; // 使用的变量 #define MP_OBJ_FUN_ARGS_MAX (0xffff) // to set maximum value in n_args_max below #define MP_OBJ_FUN_MAKE_SIG(n_args_min, n_args_max, takes_kw) ((uint32_t)((((uint32_t)(n_args_min)) << 17) (((uint32_t)(n_args_max)) << 1) ((takes_kw) ? 1 : 0))) // 实际使用的注册宏定义 #define MP_DEFINE_CONST_FUN_OBJ_0(obj_name, fun_name) \\ const mp_obj_fun_builtin_fixed_t obj_name \\ {.base {.type &mp_type_fun_builtin_0}, .fun {._0 fun_name}} #define MP_DEFINE_CONST_FUN_OBJ_1(obj_name, fun_name) \\ const mp_obj_fun_builtin_fixed_t obj_name \\ {.base {.type &mp_type_fun_builtin_1}, .fun {._1 fun_name}} #define MP_DEFINE_CONST_FUN_OBJ_2(obj_name, fun_name) \\ const mp_obj_fun_builtin_fixed_t obj_name \\ {.base {.type &mp_type_fun_builtin_2}, .fun {._2 fun_name}} #define MP_DEFINE_CONST_FUN_OBJ_3(obj_name, fun_name) \\ const mp_obj_fun_builtin_fixed_t obj_name \\ {.base {.type &mp_type_fun_builtin_3}, .fun {._3 fun_name}} #define MP_DEFINE_CONST_FUN_OBJ_VAR(obj_name, n_args_min, fun_name) \\ const mp_obj_fun_builtin_var_t obj_name \\ {.base {.type &mp_type_fun_builtin_var}, .sig MP_OBJ_FUN_MAKE_SIG(n_args_min, MP_OBJ_FUN_ARGS_MAX, false), .fun {.var fun_name}} #define MP_DEFINE_CONST_FUN_OBJ_VAR_BETWEEN(obj_name, n_args_min, n_args_max, fun_name) \\ const mp_obj_fun_builtin_var_t obj_name \\ {.base {.type &mp_type_fun_builtin_var}, .sig MP_OBJ_FUN_MAKE_SIG(n_args_min, n_args_max, false), .fun {.var fun_name}} #define MP_DEFINE_CONST_FUN_OBJ_KW(obj_name, n_args_min, fun_name) \\ const mp_obj_fun_builtin_var_t obj_name \\ {.base {.type &mp_type_fun_builtin_var}, .sig MP_OBJ_FUN_MAKE_SIG(n_args_min, MP_OBJ_FUN_ARGS_MAX, true), .fun {.kw fun_name}} ``` 可以使用的几种函数的类型 ### 实际函数注册 ```cpp // This is the function which will be called from Python as cexample.add_ints(a, b). static mp_obj_t example_add_ints(mp_obj_t a_obj, mp_obj_t b_obj) { // Extract the ints from the micropython input objects. int a mp_obj_get_int(a_obj); int b mp_obj_get_int(b_obj); // Calculate the addition and convert to MicroPython object. return mp_obj_new_int(a + b); } // Define a Python reference to the function above. 使用宏定义注册 static MP_DEFINE_CONST_FUN_OBJ_2(example_add_ints_obj, example_add_ints); ``` ### 变参数函数注册 + 第一个没有key ```cpp #include \"py/obj.h\" #include \"py/runtime.h\" // 1. 实现核心函数（符合 mp_fun_var_t 签名） // 功能：计算所有传入位置参数的和（仅支持整数） static mp_obj_t sum_ints_var(size_t n_args, const mp_obj_t *args) { // 初始化求和结果为0 long total 0; // 遍历所有位置参数 for (size_t i 0; i < n_args; i++) { // 将 mp_obj_t 类型的参数转换为整数（MicroPython 内置API） total + mp_obj_get_int(args[i]); } // 将 C 语言的 long 转换为 mp_obj_t 并返回 return mp_obj_new_int(total); } // 2. 定义函数对象（注册到 MicroPython 中） static MP_DEFINE_CONST_FUN_OBJ_VAR(sum_ints_obj, 0, sum_ints_var); // 解释： // MP_DEFINE_CONST_FUN_OBJ_VAR：宏，定义“可变位置参数函数对象” // sum_ints_obj：函数对象名 // 0：函数最少需要的参数个数（0表示可选参数） // sum_ints_var：指向核心函数的指针 // 3. 注册模块（让 Python 能导入）MicroPython 的只读映射元素类型，专门用来定义 “字符串名称 ↔ C 对象” 的对应关系 // 核心是QSTR（Quick String）——MicroPython 为嵌入式场景优化的 “快速字符串”（避免重复存储相同字符串，节省内存）。 // 这行代码的作用是：把 “sum_ints” 这个字符串转换成 MicroPython 内部的 QSTR 类型，作为模块里的 “函数名”（对应 Python 中mymodule.sum_ints的sum_ints） // ROM表示 “只读内存”，PTR是指针；这行是把之前定义的sum_ints_obj函数对象的地址，绑定到 “sum_ints” 这个名称上 —— 相当于告诉 MicroPython：“当用户调用mymodule.sum_ints时，执行的是 C 里的sum_ints_obj”。 static const mp_rom_map_elem_t mymodule_globals_table[] { { MP_ROM_QSTR(MP_QSTR_sum_ints), MP_ROM_PTR(&sum_ints_obj) }, }; // 用来把上面的mp_rom_map_elem_t数组，转换成 MicroPython 的只读字典对象（mp_obj_dict_t类型）—— 这是 MicroPython 识别 “模块命名空间” 的核心结构 // Python 中import mymodule后，mymodule.__dict__对应的就是这个字典 static MP_DEFINE_CONST_DICT(mymodule_globals, mymodule_globals_table); // MicroPython 的模块对象类型—— 所有能被import的模块，本质都是这个类型的实例 // 设置模块对象的 “基类型” 为mp_type_module（MicroPython 内置的 “模块类型”） // 模块的核心字段，指向上面创建的字典对象（mymodule_globals） const mp_obj_module_t mymodule_module { .base { &mp_type_module }, .globals (mp_obj_dict_t *)&mymodule_globals, }; // 模块对象（mymodule_module）“上报” 给 MicroPython 系统 MP_REGISTER_MODULE(MP_QSTR_mymodule, mymodule_module); ``` ```python import mymodule print(mymodule.sum_ints(1, 2, 3)) # 输出 6 print(mymodule.sum_ints(10, 20)) # 输出 30 print(mymodule.sum_ints()) # 输出 0（参数个数为0） ``` + 有key的 ```cpp #include \"py/obj.h\" #include \"py/runtime.h\" #include \"py/map.h\" // 1. 实现核心函数（符合 mp_fun_kw_t 签名） // 功能：打印位置参数 + 关键字参数（支持指定分隔符 sep） static mp_obj_t print_with_kw(size_t n_pos_args, const mp_obj_t *args, mp_map_t *kw_args) { // 定义默认分隔符：空格 mp_obj_t sep_obj mp_obj_new_str(\" \", 1); // 步骤1：查找关键字参数 \"sep\"（MicroPython 内置API） mp_obj_t sep_key mp_obj_new_str(\"sep\", 3); mp_map_elem_t *elem mp_map_lookup(kw_args, sep_key, MP_MAP_LOOKUP); if (elem ! NULL) { // 如果传入了 sep 参数，替换默认值 sep_obj elem >value; } // 步骤2：打印所有位置参数（用 sep 分隔） for (size_t i 0; i < n_pos_args; i++) { // 打印当前参数（MicroPython 内置打印API） mp_obj_print(args[i], PRINT_STR); // 不是最后一个参数时，打印分隔符 if (i < n_pos_args 1) { mp_obj_print(sep_obj, PRINT_STR); } } // 打印换行 mp_printf(&mp_plat_print, \"\\n\"); // 返回 None（MicroPython 中 None 对应的常量） return mp_const_none; } // 2. 定义函数对象（注册关键字参数函数） static MP_DEFINE_CONST_FUN_OBJ_KW(print_with_kw_obj, 0, print_with_kw); // 解释： // MP_DEFINE_CONST_FUN_OBJ_KW：宏，定义“支持关键字参数的函数对象” // print_with_kw_obj：函数对象名 // 0：最少位置参数个数 // print_with_kw：核心函数指针 // 3. 注册到模块（复用上面的 mymodule 模块） static const mp_rom_map_elem_t mymodule_globals_table[] { { MP_ROM_QSTR(MP_QSTR_sum_ints), MP_ROM_PTR(&sum_ints_obj) }, { MP_ROM_QSTR(MP_QSTR_print_with_kw), MP_ROM_PTR(&print_with_kw_obj) }, }; ``` ```python import mymodule mymodule.print_with_kw(1, 2, 3) # 输出：1 2 3 mymodule.print_with_kw(1, 2, 3, sep \" \") # 输出：1 2 3 mymodule.print_with_kw(\"hello\", \"world\", sep \"!\") # 输出：hello!world ``` ## 定义类 ### 数据类型 ```cpp // This macros is used to define a object type in ROM. // Invoke as MP_DEFINE_CONST_OBJ_TYPE(_typename, _name, _flags, [, slot, func]*) // It uses the number of arguments to select which MP_DEFINE_CONST_OBJ_TYPE_* // macro to use based on the number of arguments. It works by shifting the // numeric values 12, 11, ... 0 by the number of arguments, such that the // 29th argument ends up being the number to use. The _INV values are // placeholders because the slot arguments come in pairs. #define MP_DEFINE_CONST_OBJ_TYPE(...) \\ MP_DEFINE_CONST_OBJ_TYPE_EXPAND( \\ \tMP_DEFINE_CONST_OBJ_TYPE_NARGS(__VA_ARGS__, _INV, 12, _INV, 11, _INV, 10, \\ _INV, 9, _INV, 8, _INV, 7, _INV, 6, _INV, 5, _INV, 4, _INV, 3, _INV, 2, \\ _INV, 1, _INV, 0) \\ (mp_obj_type_t, __VA_ARGS__)) ``` 该宏用于在 ROM 中定义对象类型 MicroPython 中所有 “类型”（比如整数、字符串、自定义类、模块）的底层都是 `mp_obj_type_t` 结构体（类似 Python 的 `type` 对象）。这个结构体包含类型名称、标志位、以及一系列可选的 “槽位(slot)(比如`new`槽位对应构造函数, `print`槽位对应打印函数、`call` 槽位对应调用函数） 实际的调用形式如下 ```cpp MP_DEFINE_CONST_OBJ_TYPE(_typename, _name, _flags, [, slot, func]*) ``` `_typename`：自定义的类型名（比如 `my_timer_type`）； `_name`：类型的 QSTR 名称（比如 `MP_QSTR_Timer`，对应 Python 中类型的 `__name__`）； `_flags`：类型标志位（比如 `MP_TYPE_FLAG_NONE`，控制类型的行为）； `MP_DEFINE_CONST_OBJ_TYPE_NARGS`用于自动计算输入的键值对的个数 ### `MP_DEFINE_CONST_OBJ_TYPE_EXPAND` —— 宏的二次展开 C 宏的展开有 “优先级问题”：直接嵌套的宏可能无法正确展开可变参数。`MP_DEFINE_CONST_OBJ_TYPE_EXPAND` 是一个 “空宏”（通常定义为 `#define MP_DEFINE_CONST_OBJ_TYPE_EXPAND(x) x`），作用是**触发编译器对宏的二次展开**，确保参数计数和结构体生成的逻辑能正确执行。 `(mp_obj_type_t, __VA_ARGS__)` —— 生成最终结构体 参数计数完成后，会调用对应的底层宏（比如 `MP_DEFINE_CONST_OBJ_TYPE_2`），并传入两个关键参数： `mp_obj_type_t`：要定义的结构体类型（MicroPython 所有对象类型的基类）； `__VA_ARGS__`：调用时传入的所有参数（类型名、名称、标志、槽位 函数对）。 ### 定义类 ```cpp // This structure represents Timer instance objects. // 表示 Timer 实例对象的结构体 typedef struct _example_Timer_obj_t { // All objects start with the base. mp_obj_base_t base; // Everything below can be thought of as instance attributes, but they // cannot be accessed by MicroPython code directly. In this example we // store the time at which the object was created. mp_uint_t start_time; } example_Timer_obj_t; // This is the Timer.time() method. After creating a Timer object, this // can be called to get the time elapsed since creating the Timer. // 方法的实现：返回实例创建后的耗时 static mp_obj_t example_Timer_time(mp_obj_t self_in) { // The first argument is self. It is cast to the *example_Timer_obj_t // type so we can read its attributes. example_Timer_obj_t *self MP_OBJ_TO_PTR(self_in); // Get the elapsed time and return it as a MicroPython integer. mp_uint_t elapsed mp_hal_ticks_ms() self >start_time; return mp_obj_new_int_from_uint(elapsed); } static MP_DEFINE_CONST_FUN_OBJ_1(example_Timer_time_obj, example_Timer_time); // This represents Timer.__new__ and Timer.__init__, which is called when // the user instantiates a Timer object. // Timer 类的 __new__/__init__ 方法：实例化时调用 static mp_obj_t example_Timer_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) { // Allocates the new object and sets the type. example_Timer_obj_t *self mp_obj_malloc(example_Timer_obj_t, type); // Initializes the time for this Timer instance. self >start_time mp_hal_ticks_ms(); // The make_new function always returns self. return MP_OBJ_FROM_PTR(self); } // This collects all methods and other static class attributes of the Timer. // The table structure is similar to the module table, as detailed below. // 存储 Timer 类的所有方法/静态属性（类似 Python 中类的 __dict__） static const mp_rom_map_elem_t example_Timer_locals_dict_table[] { { MP_ROM_QSTR(MP_QSTR_time), MP_ROM_PTR(&example_Timer_time_obj) }, }; // 将清单转换为 MicroPython 只读字典对象 static MP_DEFINE_CONST_DICT(example_Timer_locals_dict, example_Timer_locals_dict_table); // This defines the type(Timer) object. MP_DEFINE_CONST_OBJ_TYPE( example_type_Timer, MP_QSTR_Timer, MP_TYPE_FLAG_NONE, make_new, example_Timer_make_new, // // 构造函数槽位：关联 make_new 方法 locals_dict, &example_Timer_locals_dict /// 本地字典槽位：关联类的方法清单 ); // Define all attributes of the module. // Table entries are key/value pairs of the attribute name (a string) // and the MicroPython object reference. // All identifiers and strings are written as MP_QSTR_xxx and will be // optimized to word sized integers by the build system (interned strings). // 定义模块的全局属性清单（cexample 模块的 __dict__） static const mp_rom_map_elem_t example_module_globals_table[] { { MP_ROM_QSTR(MP_QSTR_Timer), MP_ROM_PTR(&example_type_Timer) }, }; static MP_DEFINE_CONST_DICT(example_module_globals, example_module_globals_table); // Define module object. const mp_obj_module_t example_user_cmodule { .base { &mp_type_module }, .globals (mp_obj_dict_t *)&example_module_globals, }; // Register the module to make it available in Python. MP_REGISTER_MODULE(MP_QSTR_cexample, example_user_cmodule); ``` ### 使用 ```python from cexample import Timer from time import sleep_ms watch Timer() sleep_ms(1000) print(watch.time()) ```"},"/note/嵌入式/esp32/micropython/2024-5-20-04SPI.html":{"title":"SPI","content":" layout: post title: \"SPI\" date: 2024 5 20 15:39:08 +0800 tags: esp32 Micropython # SPI ```python from machine import Pin, SPI hspi SPI(1, 10000000) hspi SPI(1, 10000000, sck Pin(14), mosi Pin(13), miso Pin(12)) vspi SPI(2, baudrate 80000000, polarity 0, phase 0, bits 8, firstbit 0, sck Pin(18), mosi Pin(23), miso Pin(19)) ``` > 可以使用这三种方式进行初始化 ### 显示器初始化 ![image 20240521100146782](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405211001032.png) > LCD ST7735ESP32 > > GND GND > > VCC 3V3 > > SCL IO14(CLK) > > SDA IO13(MOSI) > > RES IO17 > > DC IO16(DC) > > CS1 IO18 > > BLK 空 ```python from st7735.ST7735 import TFT,TFTColor from machine import SPI,Pin # 设置SPI spi SPI(2, baudrate 20000000, polarity 0, phase 0, sck Pin(14), mosi Pin(13), miso Pin(12)) tft TFT(spi,16,17,18) tft.initr() tft.rgb(True) tft.fill(TFT.BLUE) ``` ## 基础使用 ### 显示一个点 ```python tft.pixel((100, 100), TFTColor(128, 0, 255)) ``` > 在100, 100的位置显示一个这个颜色的点 ### 显示图片 + 格式转换 ```python from st7735.ST7735 import TFT,TFTColor from machine import SPI,Pin f open('lymy.bmp', 'rb') f2 open('lymy.bat', 'wb+') if f.read(2) b'BM': #header dummy f.read(8) #file size(4), creator bytes(4) offset int.from_bytes(f.read(4), 'little') hdrsize int.from_bytes(f.read(4), 'little') width int.from_bytes(f.read(4), 'little') height int.from_bytes(f.read(4), 'little') if int.from_bytes(f.read(2), 'little') 1: #planes must be 1 depth int.from_bytes(f.read(2), 'little') if depth 24 and int.from_bytes(f.read(4), 'little') 0:#compress method uncompressed print(\"Image size:\", width, \"x\", height) rowsize (width * 3 + 3) & ~3 if height < 0: height height flip False else: flip True w, h width, height if w > 128: w 128 if h > 160: h 160 for row in range(h): if flip: pos offset + (height 1 row) * rowsize else: pos offset + row * rowsize if f.tell() ! pos: dummy f.seek(pos) for col in range(w): bgr f.read(3) buf bytearray(2) buf[0] TFTColor(bgr[2],bgr[1],bgr[0]) >> 8 buf[1] TFTColor(bgr[2],bgr[1],bgr[0]) & 0xff f2.write(buf) else: print(\"error\") else: print(\"error\") f.close() f2.close() ``` + 显示 ```python from st7735.ST7735 import TFT,TFTColor from machine import SPI,Pin spi SPI(2, baudrate 20000000, polarity 0, phase 0, sck Pin(14), mosi Pin(13), miso Pin(12)) tft TFT(spi,16,17,18) tft.initr() tft.rgb(True) tft.fill(TFT.BLUE) f open('lymy.bat', 'rb') tft._setwindowloc((0,0),(127,159)) for row in range(20): bgr f.read(16 * 128) tft.image(0, 8*row, 127, 159, bgr) spi.deinit() ``` ### 二维码 可以使用一个叫uQR的库在micropython里面使用 > [uQR/uQR.py at master · JASchilz/uQR (github.com)](https://github.com/JASchilz/uQR/blob/master/uQR.py) ```python from uQR import QRCode from st7735.ST7735 import TFT,TFTColor from machine import SPI,Pin spi SPI(2, baudrate 20000000, polarity 0, phase 0, sck Pin(14), mosi Pin(13), miso Pin(12)) tft TFT(spi,16,17,18) tft.initr() tft.rgb(True) tft.fill(TFT.WHITE) qr QRCode() qr.add_data(\"jiao\") matrix qr.get_matrix() row_len len(matrix) col_len len(matrix[0]) scale_rate 4 for row in range(row_len): for col in range(col_len): if(matrix[row][col]): tft.fillrect((row*scale_rate, col*scale_rate), (scale_rate, scale_rate), TFT.BLACK) else: tft.fillrect((row*scale_rate, col*scale_rate), (scale_rate, scale_rate), TFT.WHITE) ```"},"/note/嵌入式/esp32/micropython/2024-4-22-01环境搭建.html":{"title":"环境搭建","content":" layout: post title: \"环境搭建\" date: 2024 4 22 15:39:08 +0800 tags: esp32 Micropython # 环境搭建 [Thonny, Python IDE for beginners](https://thonny.org/) > 编译器 [MicroPython Python for microcontrollers](https://micropython.org/download/ESP32_GENERIC/) > 获取固件 ![image 20240422203921277](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404222039340.png) ![image 20240422203934497](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404222039526.png) > 选择解释器 ![image 20240422204028089](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404222040125.png) ![image 20240422204146031](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404222041066.png) ![image 20240422204349476](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404222043513.png) ![image 20240422204408619](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404222044651.png) ![image 20240422204737948](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404222047034.png) > 可以使用help获取帮助信息 ```python Welcome to MicroPython on the ESP32! For online docs please visit http://docs.micropython.org/ For access to the hardware use the 'machine' module: import machine pin12 machine.Pin(12, machine.Pin.OUT) pin12.value(1) pin13 machine.Pin(13, machine.Pin.IN, machine.Pin.PULL_UP) print(pin13.value()) i2c machine.I2C(scl machine.Pin(21), sda machine.Pin(22)) i2c.scan() i2c.writeto(addr, b'1234') i2c.readfrom(addr, 4) Basic WiFi configuration: import network sta_if network.WLAN(network.STA_IF); sta_if.active(True) sta_if.scan() # Scan for available access points sta_if.connect(\"<AP_name>\", \"<password>\") # Connect to an AP sta_if.isconnected() # Check for successful connection Control commands: CTRL A on a blank line, enter raw REPL mode CTRL B on a blank line, enter normal REPL mode CTRL C interrupt a running program CTRL D on a blank line, do a soft reset of the board CTRL E on a blank line, enter paste mode For further help on a specific object, type help(obj) For a list of available modules, type help('modules') ``` > Pin2连接的IO是一个蓝色的灯 ```python import machine import time pin2 machine.Pin(2, machine.Pin.OUT) while True: pin2.value(1) time.sleep(1) pin2.value(0) time.sleep(1) ```"},"/note/嵌入式/esp32/2023-9-17-04Flash和psram的配置.html":{"title":"Flash和psram的配置","content":" layout: post title: \"Flash和psram的配置\" date: 2023 9 16 15:39:08 +0800 tags: esp32 # Flash和psram的配置 ![image 20230917101913064](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242257402.png) ![image 20230917102856323](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242257404.png) ![image 20230917103515582](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242257405.png) > 使用扩展的SRAM的话这几个引脚就会被占用 ```c I (24) boot: ESP IDF v5.0.4 2nd stage bootloader I (25) boot: compile time 10:37:52 I (25) boot: Multicore bootloader I (27) boot: chip revision: v0.1 I (31) qio_mode: Enabling default flash chip QIO //这里显示的是SPIFLASH I (36) boot.esp32s3: Boot SPI Speed : 80MHz I (41) boot.esp32s3: SPI Mode : QIO I (45) boot.esp32s3: SPI Flash Size : 16MB I (50) boot: Enabling RNG early entropy source... I (56) boot: Partition Table: I (59) boot: ## Label Usage Type ST Offset Length I (66) boot: 0 nvs WiFi data 01 02 00009000 00006000 I (74) boot: 1 phy_init RF data 01 01 0000f000 00001000 I (81) boot: 2 factory factory app 00 00 00010000 00100000 I (89) boot: End of partition table I (93) esp_image: segment 0: paddr 00010020 vaddr 3c020020 size 09aach ( 39596) map I (108) esp_image: segment 1: paddr 00019ad4 vaddr 3fc92b00 size 02b34h ( 11060) load I (112) esp_image: segment 2: paddr 0001c610 vaddr 40374000 size 03a08h ( 14856) load I (121) esp_image: segment 3: paddr 00020020 vaddr 42000020 size 1a098h (106648) map I (143) esp_image: segment 4: paddr 0003a0c0 vaddr 40377a08 size 0b018h ( 45080) load I (158) boot: Loaded app from partition at offset 0x10000 I (158) boot: Disabling RNG early entropy source... I (169) cpu_start: Multicore app I (170) octal_psram: vendor id : 0x0d (AP) I (170) octal_psram: dev id : 0x02 (generation 3) I (173) octal_psram: density : 0x03 (64 Mbit) I (179) octal_psram: good die : 0x01 (Pass) I (184) octal_psram: Latency : 0x01 (Fixed) I (189) octal_psram: VCC : 0x01 (3V) I (194) octal_psram: SRF : 0x01 (Fast Refresh) I (200) octal_psram: BurstType : 0x01 (Hybrid Wrap) I (206) octal_psram: BurstLen : 0x01 (32 Byte) I (211) octal_psram: Readlatency : 0x02 (10 cycles@Fixed) I (218) octal_psram: DriveStrength: 0x00 (1/1) I (223) MSPI Timing: PSRAM timing tuning index: 5 I (228) esp_psram: Found 8MB PSRAM device I (233) esp_psram: Speed: 80MHz I (237) cpu_start: Pro cpu up. I (240) cpu_start: Starting app cpu, entry point is 0x40375374 0x40375374: call_start_cpu1 at E:/alearn/ESP IDE/esp idf_v5.1.2/esp idf/components/esp_system/port/cpu_start.c:143 I (0) cpu_start: App cpu up. //测试SPRAM, 测试成功 I (699) esp_psram: SPI SRAM memory test OK I (708) cpu_start: Pro cpu start user code I (708) cpu_start: cpu freq: 160000000 Hz I (708) cpu_start: Application information: I (711) cpu_start: Project name: hello_world I (716) cpu_start: App version: 1 I (721) cpu_start: Compile time: Sep 17 2023 10:37:22 I (727) cpu_start: ELF file SHA256: c57c0dd431ce40e9... I (733) cpu_start: ESP IDF: v5.0.4 I (738) cpu_start: Min chip rev: v0.0 I (742) cpu_start: Max chip rev: v0.99 I (747) cpu_start: Chip rev: v0.1 I (752) heap_init: Initializing. RAM available for dynamic allocation: I (759) heap_init: At 3FC960C8 len 00053648 (333 KiB): DRAM I (765) heap_init: At 3FCE9710 len 00005724 (21 KiB): STACK/DRAM I (772) heap_init: At 3FCF0000 len 00008000 (32 KiB): DRAM I (778) heap_init: At 600FE010 len 00001FD8 (7 KiB): RTCRAM I (785) esp_psram: Adding pool of 8192K of PSRAM memory to heap allocator I (793) spi_flash: detected chip: winbond I (797) spi_flash: flash io: qio I (801) app_start: Starting scheduler on CPU0 I (806) app_start: Starting scheduler on CPU1 I (806) main_task: Started on CPU0 I (816) esp_psram: Reserving pool of 32K of internal memory for DMA/internal allocations I (826) main_task: Calling app_main() I (826) main: Hello world ``` ```c [13/907] Generating ../../partition_table/partition table.bin Partition table binary generated. Contents: ******************************************************************************* # ESP IDF Partition Table # Name, Type, SubType, Offset, Size, Flags nvs,data,nvs,0x9000,24K, phy_init,data,phy,0xf000,4K, factory,app,factory,0x10000,1M, ******************************************************************************* ``` > 发现在这个时候并不是所有的Flash都被使用了 ## 添加分区表 ![image 20230917105409604](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242257406.png) ![image 20230917105358856](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242257407.png) > 把这个文件添加到文件夹里面 ![image 20230917105947422](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242257408.png) ```bash ******************************************************************************* # ESP IDF Partition Table # Name, Type, SubType, Offset, Size, Flags nvs,data,nvs,0x9000,16K, otadata,data,ota,0xd000,8K, phy_init,data,phy,0xf000,4K, factory,app,factory,0x10000,1M, ota_0,app,ota_0,0x110000,1M, ota_1,app,ota_1,0x210000,1M, ******************************************************************************* ``` > 分区表增加了 ![image 20230917110203861](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242257409.png) > 之后可以在上面的表里面进行修改分区表, 也可以添加自己的分区 > >"},"/note/嵌入式/stm32/HAL原子/2023-11-12-08启动过程浅析.html":{"title":"启动过程浅析","content":" layout: post title: \"启动过程浅析\" date: 2023 11 11 15:39:08 +0800 tags: HAL库 stm32 # 启动过程浅析 ![image 20231112095453247](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311120954290.png) ## MAP文件 MDK编译以后产生的集程序, 数据以及IO空间的一种映射关系的列表文件 简单地说就是各个c文件, 函数, 符号的地址大小以及引用关系 ![image 20231112095722306](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311120957347.png) ![image 20231112100137623](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311121001651.png) ## 启动模式 M3/M4/M7等内核复位后，做的第一件事： 1，从地址 0x0000 0000 处取出堆栈指针 MSP 的初始值，该值就是栈顶地址 2，从地址 0x0000 0004 处取出程序计数器指针 PC 的初始值，该值是复位向量 系统复位以后第四个时钟上升沿BOOT引脚的值会被锁存 ![image 20231112105742708](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311121057742.png) > st公司对不同的启动方式进行了不同的映射 > > 主闪存对应的就是我们常用的flash > > 系统存储器里面有bootloader, 这个是st公司写的, 可以通过USART进行下载程序 > > 内置的SRAM ![image 20231112110436862](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311121104937.png) > 从芯片手册上发现, 使用ITCM和AXIM都可以访问到相同的FLASH > > ITCM (Instruction Tightly Coupled Memory) 是 STM32F7 中的一个片内高速、低延迟、高可靠性的指令存储器区域，它的主要作用是存储常用的程序指令，提高数据读取的效率，降低延迟，提高系统性能。 > > AXIM (Axi SRAM Interface) 是片内高速静态随机存储器 (SRAM) 的接口，它与处理器核相连接，可读取或写入处理器的数据。ITCM 和 AXIM 的作用是不同的，ITCM 主要用于存储指令，而 AXIM 主要用于存储数据。这两个区域可以并行访问，提高系统的性能和效率。 > > 为什么要设置为两个而不是一个呢？这是因为处理器需要同时访问指令和数据，并且在访问内存时需要满足一系列的时序和电气规范。将指令和数据存储在不同的存储区域中，可以提高系统并行访问的效率，降低存储器访问之间的竞争，避免数据与指令之间的干扰。此外，通过对不同存储区域进行不同的配置，可以更好地满足不同的应用需求。 > 从ITCM启动和从AXIM启动的主要区别在于访问速度和访问方式。从ITCM启动的程序可以获得更快的访问速度，因为ITCM位于处理器的指令总线上，读取指令时直接从ITCM中读取，无需通过处理器总线和外部存储器进行访问。从AXIM启动的程序则需要通过处理器总线和外部存储器进行访问，访问速度会较慢。此外，从ITCM启动的程序不能超出ITCM的地址范围，因为ITCM的容量较小，通常只有几十KB到几百KB左右，适用于存储常用的指令。而从AXIM启动的程序则可以访问较大的外部存储器容量。总之，从ITCM启动的程序可以获得更快的访问速度，但存储容量较小，只适用于存储常用的指令；而从AXIM启动的程序则可以访问较大的外部存储器容量，但访问速度较慢。在实际应用中，可以根据具体的需求选择不同的启动方式。 > 由于设置的位最小的是第14位, 对应的是16KB, 所以设置的最小单位是16KB(实际地址是32位控制的, 但是我们只能设置里面的16位) ![image 20231112111705331](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311121117418.png) ![image 20231112112313922](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311121123979.png) > 允许配置为0x00000000到0x3fff0000, 低16位位只能为0 ### 启动过程 + 内部flash的启动模式 1. 获取MSP指针的值0x80000000 2. 获取PC指针的值0x80000004 3. PC指向的是Reset_Handler, 在启动文件里面 + 启动文件 1. 设置MSP 2. 初始化PC 3. 设置堆栈的大小 4. 初始化中断向量表 5. 调用初始化函数 6. 调用__main ```assembly ; Reset handler Reset_Handler PROC\t\t\t\t\t\t\t\t\t;定义一个子程序 EXPORT Reset_Handler [WEAK]\t;设置为若定义, 可以自己实现一个这个函数 IMPORT __main IMPORT SystemInit LDR R0, SystemInit BLX R0 LDR R0, __main BX R0 ENDP\t\t\t\t\t\t\t\t\t;子程序结束相当于C语言函数的结束 ``` ```c void SystemInit (void) { #if defined(STM32F100xE) defined(STM32F101xE) defined(STM32F101xG) defined(STM32F103xE) defined(STM32F103xG) #ifdef DATA_IN_ExtSRAM SystemInit_ExtMemCtl(); #endif /* DATA_IN_ExtSRAM */ #endif /* Configure the Vector Table location */ #if defined(USER_VECT_TAB_ADDRESS) SCB >VTOR VECT_TAB_BASE_ADDRESS VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */ #endif /* USER_VECT_TAB_ADDRESS */ } ``` ### __main函数的作用 ![image 20231112192933069](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311121929117.png) + __main函数 作用：Initialization of the execution environment and execution of the application You can customize execution intialization by defining your own \\_\\_main that branches to \\_\\_rt_entry. The entry point of a program is at __main in the C library where library code: > Copies non root (RO（不会拷贝，官方提供和实际实践有出入） and RW) execution regions from their load addresses to their execution addresses. Also, if any data sections are compressed, they are decompressed from the load address to the execution address. > Zeroes ZI regions. > Branches to \\_\\_rt_entry. > If you do not want the library to perform these actions, you can define your own \\_\\_main that branches to \\_\\_rt_entry. 注意：__main函数不会将RO段数据拷贝到执行地址处，虽然官方说明了 + _rt_entry函数 procedure The library function __rt_entry() runs the program as follows: Sets up the stack and the heap by one of a number of means that include calling \\_\\_user_setup_stackheap(), calling __rt_stackheap_init(), or loading the absolute addresses of scatter loaded regions. Calls \\_\\_rt_lib_init() to initialize referenced library functions, initialize the locale and, if necessary, set up argc and argv for main().This function is called immediately after\\_\\_rt_stackheap_init() and is passed an initial chunk of memory to use as a heap. This function is the standard ARM C library initialization function and it must not be reimplemented. > Calls main(), the user level root of the application. > > From main(), your program might call, among other things, library functions. > > Calls exit() with the value returned by main(). > > entry的是ARM汇编语法中程序的入口地址，GNU Assember语法中start是程序的入口地址 __rt_lib库函数是没有源文件，都已经编译完成了。 The symbol __rt_entry is the starting point for a program using the ARM C library. Control passes to __rt_entry after all scatter loaded regions have been relocated to their execution addresses. + Usage The default implementation of __rt_entry: Sets up the heap and stack. Initializes the C library by calling \\_\\_rt_lib_init.(ARMc库里面全面都是.b .l形式的库，没有源码) Calls main(). Shuts down the C library, by calling \\_\\_rt\\_lib\\_shutdown. Exits. \\_\\_rt_entry must end with a call to one of the following functions: + exit() Calls atexit() registered functions and shuts down the library. + \\_\\_rt_exit() Shuts down the library but does not call atexit() functions. + \\_sys\\_exit() Exits directly to the execution environment. It does not shut down the library and does not call atexit() functions."},"/note/嵌入式/stm32/HAL原子/2023-11-9-04stm32基础知识.html":{"title":"stm32基础知识","content":" layout: post title: \"stm32基础知识\" date: 2023 11 9 15:39:08 +0800 tags: HAL库 stm32 # stm32基础知识 ## Cortex内核以及芯片 ![image 20231109222142666](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311092221753.png) ## F1系统框架 ![image 20231109222451180](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311092224315.png) ![image 20231109222514871](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311092225931.png) > 主动单元: 可以发起通讯 ![image 20231109222638545](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311092226606.png) > 1. 主动单元 > 2. 被动单元 > > ICode总线直接连接到Flash接口, 但是没有经过总线矩阵, 为的是加快读取的速率 > > AHB >72MHz > > APB1 >36MHz > > APB2 >72MHz ## 其他架构 ![image 20231109223559174](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311092235244.png) ![image 20231109223630721](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311092236796.png) > 上面的S0 S7对应的是主动总线, M0 M7对应的是被动主线 ![image 20231109225850042](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311092258107.png) ![image 20231109225911986](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311092259148.png) ![image 20231109225945938](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311092259026.png) ![image 20231109231501866](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311092315936.png) ![image 20231109231522897](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311092315978.png) ![image 20231109231602432](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311092316515.png) ## 寻址范围 32位单片机有32根地址线, 每一根地址线有两种状态 单片机的内存地址访问到的存储单元是以字节为单位的 存储器可以指存储数据的设备, 本身没有地址信息, 对存储器分配地址的过程就是存储器的映射 ![image 20231109232624697](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311092326773.png) ![image 20231110223816801](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311102238974.png) ## 寄存器映射 寄存器是一个特殊的内存, 可以实现对于单片机的控制 ![image 20231110224147188](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311102241252.png) 给寄存器命名的过程就叫做寄存器映射 计算寄存器的位置的时候使用的是总线地址+外设及四肢+设备便宜 ![image 20231110230754265](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311102307314.png) ![image 20231110230810837](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311102308894.png) ![image 20231110230840176](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311102308230.png)"},"/note/嵌入式/stm32/HAL原子/2023-12-6-17MPU.html":{"title":"MPU","content":" layout: post title: \"MPU\" date: 2023 12 1 15:39:08 +0800 tags: HAL库 stm32 # MPU ![image 20231206111622386](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312061116437.png) ![image 20231206111754503](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312061117562.png) ![image 20231206111946595](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312061119653.png) ![image 20231206120219391](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312061202441.png) ![image 20231206121214167](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312061212225.png) > FSMC的操作需要按照时序来进行, 使用cache的时候有可能会导致出问题 在Debug里面可以查看内存保护的状态"},"/note/嵌入式/stm32/HAL原子/2023-11-21-12中断.html":{"title":"中断","content":" layout: post title: \"中断\" date: 2023 21 18 15:39:08 +0800 tags: HAL库 stm32 # 中断 实际的介绍看固件库笔记 ## 使用 配置分组的模式AIRCR寄存器[10:8], 使用HAL_NVIC_SetPriorityGrouping() > 这个函数在HAL_Init函数里面会有设置 设置中断的优先级IPRxbit[7:4], HAL_NVIC_SetPriority() 使能中断ISERx, HAL_NVIC_EnableIRQ() ## GPIO中断 ![image 20231125195759940](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311251957994.png) 1. 使能GPIO时钟 2. 设置GPIO的输入模式 3. 使能AFIO/SYSCFG时钟 4. 设置EXTI和IO的对应关系 5. 设置EXTI屏蔽, 上下沿 6. 设置NVIC 7. 设置中断服务函数, 编写对应的函数, 清除标志位 > 使用HAL_GPIO_Init函数一步到位 1. 使能GPIO时钟 2. 使用HAL_GPIO_Init函数一步到位 3. 设置中断分组HAL_NVIC_SetPriorityGrouping 4. 使能中断HAL_NVIC_EnableIRQ 5. 设计中断函数EXTIx_IRQHandler中断服务函数 stm32只有EXTI0 4, EXTI9\\_5, EXTI15\\_10七个中断函数 ## HAL库回调函数 ![image 20231125203940587](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311252039623.png) > EXTI0 15的中断处理函数放在gpio.c文件里面 ```c //中断函数 void EXTI4_IRQHandler(void) { HAL_GPIO_EXTI_IRQHandler(GPIO_Pin_4); } /** * @brief This function handles EXTI interrupt request. * @param GPIO_Pin: Specifies the pins connected EXTI line * @retval None */ void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin) { /* EXTI line interrupt detected */ if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) ! 0x00u) { __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin); HAL_GPIO_EXTI_Callback(GPIO_Pin); } } /** * @brief EXTI line detection callbacks. * @param GPIO_Pin: Specifies the pins connected EXTI line * @retval None */ __weak void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) { /* Prevent unused argument(s) compilation warning */ UNUSED(GPIO_Pin); /* NOTE: This function Should not be modified, when the callback is needed, the HAL_GPIO_EXTI_Callback could be implemented in the user file */ } ```"},"/note/嵌入式/stm32/HAL原子/2023-12-29-27DAC.html":{"title":"DAC","content":" layout: post title: \"DAC\" date: 2023 12 29 15:39:08 +0800 tags: HAL库 stm32 # DAC ![image 20231230105634508](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312301056589.png) ![image 20231230105830705](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312301058746.png) ![image 20231230110306711](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312301103782.png) ```c void dac_init(void) { DAC_ChannelConfTypeDef dac_ch_conf; g_dac_handle.Instance DAC; HAL_DAC_Init(&g_dac_handle); /* 初始化DAC */ dac_ch_conf.DAC_Trigger DAC_TRIGGER_NONE; /* 不使用触发功能,设置为自动触发 */ dac_ch_conf.DAC_OutputBuffer DAC_OUTPUTBUFFER_DISABLE; /* DAC输出缓冲关闭 */ HAL_DAC_ConfigChannel(&g_dac_handle, &dac_ch_conf, DAC_CHANNEL_1); /* 配置DAC通道1 */ HAL_DAC_Start(&g_dac_handle, DAC_CHANNEL_1); /* 开启DAC通道1 */ } ``` ## 使用外部触发 ![image 20231230145102246](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312301451294.png) ![image 20231230145145338](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312301451387.png) ```c dac_ch_conf.DAC_Trigger DAC_TRIGGER_T7_TRGO;\t\t//设置为定时器7触发 dac_ch_conf.DAC_OutputBuffer DAC_OUTPUTBUFFER_DISABLE;\t//不使能缓冲 HAL_DAC_ConfigChannel(&g_dac_dma_handle, &dac_ch_conf, DAC_CHANNEL_1); ``` ```c /** * @brief DAC DMA使能波形输出 * @note TIM7的输入时钟频率(f)来自APB1, f 36M * 2 72Mhz. * DAC触发频率 ftrgo f / ((psc + 1) * (arr + 1)) * 波形频率 ftrgo / ndtr; * * @param ndtr : DMA通道单次传输数据量 * @param arr : TIM7的自动重装载值 * @param psc : TIM7的分频系数 * @retval 无 */ void dac_dma_wave_enable(uint16_t cndtr, uint16_t arr, uint16_t psc) { TIM_HandleTypeDef tim7_handle {0}; TIM_MasterConfigTypeDef tim_mater_config {0}; __HAL_RCC_TIM7_CLK_ENABLE(); tim7_handle.Instance TIM7; tim7_handle.Init.Prescaler psc; tim7_handle.Init.Period arr; HAL_TIM_Base_Init(&tim7_handle);//初始化定时器 tim_mater_config.MasterOutputTrigger TIM_TRGO_UPDATE;\t\t//更新事件, 会产生一个TRGO信号 tim_mater_config.MasterSlaveMode TIM_MASTERSLAVEMODE_DISABLE; HAL_TIMEx_MasterConfigSynchronization(&tim7_handle, &tim_mater_config); HAL_TIM_Base_Start(&tim7_handle); HAL_DAC_Stop_DMA(&g_dac_dma_handle, DAC_CHANNEL_1); HAL_DAC_Start_DMA(&g_dac_dma_handle, DAC_CHANNEL_1, (uint32_t *)g_dac_sin_buf, cndtr, DAC_ALIGN_12B_R); } ```"},"/note/嵌入式/stm32/HAL原子/2023-11-30-15WWDG.html":{"title":"WWDG","content":" layout: post title: \"WWDG\" date: 2023 11 30 15:39:08 +0800 tags: HAL库 stm32 # WWDG ## 设置方法 初始化 HAL_WWDG_Init() Msp初始化 HAL_WWDG_Msp_init() 设置优先级使能中断HAL_NVIC_SetPriority(), HAL_NVIC_EnableIRQ() 编写中断服务函数WWGD_IRQHandler >HAL_WWDG_IRQHandler 在窗口期里面喂狗HAL_WWDG_Refresh() ![image 20231130212402198](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311302124270.png) ```c HAL_StatusTypeDef HAL_WWDG_Refresh(WWDG_HandleTypeDef *hwwdg) { /* Write to WWDG CR the WWDG Counter value to refresh with */ WRITE_REG(hwwdg >Instance >CR, (hwwdg >Init.Counter));//根据手册, 一旦使能, 使能位就不会受软件影响, 所以直接写入不会影响使能位的配置 /* Return function status */ return HAL_OK; } ``` 通过宏\\_\\_HAL\\_RCC\\_GET\\_FLAG()获取是哪一个引起的中断"},"/note/嵌入式/stm32/HAL库/2023-10-29-19-定时器.html":{"title":"定时器","content":" layout: post title: \"定时器\" date: 2023 10 19 15:39:08 +0800 tags: stm32 HAL库 # 定时器 ![image 20231029095925333](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310290959893.png) 定时器的工作频率: 外设总线频率/(PSC+1) 定时频率: 定时器工作频率/(CNT+1) ![image 20231029102228210](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310291022266.png) 影子寄存器在这里实际上才是在比较的时候起作用的，也就是为预装载寄存器做缓冲，目的是为了当预装载寄存器ARR中的值更新后，影子寄存器仍然保持原来的值（这是在ARPE 1的情况下），参与比较操作的是影子寄存器，所以这样不会影响到计数器的工作误差。它在更新事件发生之后影子寄存器的值才从ARR寄存器那里获得更新，它也有同步的作用，使所有的相关寄存器数值都同时更新。 当ARPE为0时，影子寄存器是立即更新的，不等待更新事件 的发生。 那为什么非得弄个影子寄存器呢？大家想想啊。因为定时器里面有这样一句话：“计数器、自动装载寄存器和预分频器寄存器可以由软件读写，在计数器运行时仍可以读写”。在运行时就可以写自动装载寄存器，那么当你对自动装载寄存器进行写入新值时，如果你的没有影子寄存器，那么肯定的你的计数器在这次溢出就会不准确。而如果有了影子寄存器且ARPE＝１，那就不会出现这种情况了。起到了一个缓冲作用。 在使用影子寄存器的时候写入的时候会写入的值不会立刻更新, 而是在发生事件之后更新 ![image 20231029105854446](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310291058484.png) ![image 20231029105946719](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310291059755.png) > ![image 20231029110339836](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310291103877.png) ```c /* USER CODE BEGIN TIM7_Init 2 */ \tHAL_TIM_Base_Start_IT(&htim7); /* USER CODE END TIM7_Init 2 */ ``` > 使用这个函数进行开启 ## 高级定时器 ![image 20231029224632618](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310292246650.png) + 16位的递增递减重装载寄存器 + 16位的预分频寄存器 + 四个独立通道: 输入捕获, 输出比较, PWM生成(边缘或中间对齐模式) + 死区可编程 + 使用外部信号控制定时器和定时器互联的同步电路 + 允许在指定书目计数器周期后更新定时器寄存器重读计数器 + 刹车输入信号可以将定时器输出信号置于复位状态或者一个已知状态 + 如下事件发生时产生中断/DMA: 更新：计数器向上溢出/向下溢出，计数器初始化(通过软件或者内部/外部触发) , 触发事件(计数器启动、停止、初始化或者由内部/外部触发计数), 输入捕获, 输出比较, 刹车信号输入 + 支持针对定位的增量(正交)编码器和霍尔传感器电路 + 触发输入作为外部时钟或者按周期的电流管理 ![image 20231029220138202](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310292201274.png) > 捕获: 在捕获到的信号进行跳变的时候, 将计数器的值保存到捕获寄存器里面, 两次捕获的值相减就可以算出来脉宽 ### 输入捕获 ![image 20231029222949431](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310292229480.png) + 输入通道: 需要被测量的信号从定时器的外部引脚 TIMx_CH1/2/3/4 进入，通常叫 TI1/2/3/4 + 输入滤波器: 当输入的信号存在高频干扰的时候，我们需要对输入信号进行滤波，即进行重新采样，根据采样 定律，采样的频率必须大于等于两倍的输入信号。比如输入的信号为 1M，又存在高频的信号干 扰，那么此时就很有必要进行滤波，我们可以设置采样频率为 2M + 边沿检测器用来设置信号在捕获的时候是什么边沿有效，可以是上升沿，下降沿，或者是双边沿， 具体的由 CCER 寄存器的位 CCxP 和 CCxNP 决定。 + 捕获通道就是图中的 IC1/2/3/4，每个捕获通道都有相对应的捕获寄存器 CCR1/2/3/4，当发生捕获 的时候，计数器 CNT 的值就会被锁存到捕获寄存器中 > 输入通道和捕获通道的区别，输入通道是用来输入信号的，捕获通道是用来捕 获输入信号的通道，一个输入通道的信号可以同时输入给两个捕获通道。比如输入通道 TI1 的信 号经过滤波边沿检测器之后的 TI1FP1 和 TI1FP2 可以进入到捕获通道 IC1 和 IC2 + PWM捕获 ![image 20231029223124911](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310292231948.png) PWM 信号由输入通道 TI1 进入，因为是 PWM 输入模式的缘故，信号会被分为两路，一路是 TI1FP1，另外一路是 TI2FP2。其中一路是周期，另一路是占空比，具体哪一路信号对应周期还 是占空比 ![image 20231029223746544](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310292237577.png) ![image 20231030160253148](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310301602257.png) ```c /* 启动定时器 */ HAL_TIM_Base_Start_IT(&htim5); /* 启动定时器通道输入捕获并开启中断 */ HAL_TIM_IC_Start_IT(&htim5,TIM_CHANNEL_1); HAL_TIM_IC_Start_IT(&htim5,TIM_CHANNEL_2); ``` ### 输出比较 ![image 20231029223004973](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310292230029.png) 通过定时器的外部引脚对外输出控制信号，有冻结、将通道 X（x 1,2,3,4）设置为 匹配时输出有效电平、将通道 X 设置为匹配时输出无效电平、翻转、强制变为无效电平、强制变 为有效电平、PWM1 和 PWM2 这八种模式 ![image 20231029223825567](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310292238595.png) + 边沿模式 计数器从 0 计数到自动重载值（TIMx_ARR 寄存器的内容），然后重新 从 0 开始计数并生成计数器上溢事件 ![image 20231029224330948](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310292243978.png) + 中心对齐模式 ![image 20231029224407593](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310292244632.png) > 在中心对齐模式下，计数器 CNT 是工作做递增/递减模式下。开始的时候，计数器 CNT 从 0 开始 计数到自动重载值减 1(ARR 1)，生成计数器上溢事件；然后从自动重载值开始向下计数到 1 并 生成计数器下溢事件。之后从 0 开始重新计数。 具体的区 别就是比较中断中断标志位 CCxIF 在何时置 1：中心模式 1 在 CNT 递减计数的时候置 1，中心对 齐模式 2 在 CNT 递增计数时置 1，中心模式 3 在 CNT 递增和递减计数时都置 1。"},"/note/嵌入式/stm32/HAL库/2023-10-19-15FSMC扩展SRAM.html":{"title":"FSMC扩展SRAM","content":" layout: post title: \"FSMC扩展SRAM\" date: 2023 10 19 15:39:08 +0800 tags: stm32 HAL库 # FSMC扩展SRAM 灵活存储控制器 ## SRAM和SDROM 这一些是易失性存储器, F1系列上面有FSMC但是由于引脚数量不全, vet6不能使用 F4之后的系列封装了FMC外设, 可以使用SDRAM作为RAM, 主要的区别是是静态和动态, 以及读取的时序的区别, 动态时序以及静态时序 设备的区别是使用锁存器和内存的区别 这里使用的是IS62WV51216(1MB) ![image 20231019114215227](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242256028.png) 使用一个存储矩阵进行保存数据, 需要给出行地址以及列地址 ![image 20231019123129387](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242256029.png) A0 A18: 这一些是地址线 I/O 数据的输入输出, 一共有16位 CS2/CS1: 两个片选2为高电平有效, 1是低电平, 主要用来组装多个SRAM为一个大的SRAM OE#: 输出使能 WE#: 写使能 UB#: 数据掩码 LB#: 低数据位位的掩码, 低位允许访问 这里使用的SRAM由于比较小, 所以没有列地址线, 数据的宽度是16位的, 十九根线是512K, 每一个位是16bit一共有1M ![image 20231019181840140](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242256030.png) ![image 20231019182441522](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242256031.png) 比较特殊的引脚就是FSMC_NE引脚用来控制不同的地址区域 ![image 20231019182726965](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242256032.png) 在访问不同的地址的时候会把不同的地址对应的引脚进行拉低, 使用储存器的时候可以直接使用指针进行访问对应的设备 ![image 20231019183145614](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242256033.png) > 有四种设备, 每一个设备又分为四个区域, 对应四个片选引脚, FSMC_NE[1:4] > > 这里使用的四块区域分别为0x60000000 0x63ffffff, 0x64000000 0x67ffffff, 0x68000000 0x6bffffff, 0x6c000000 0x6fffffff ![image 20231019183839162](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242256034.png) > 一般采用这一个时序进行控制SRAM ![image 20231019183851638](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242256035.png) ## CubeMX ![image 20231019184844301](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242256036.png) > 100引脚封装的时候只有FSMC_NE1引脚被引出来了 > > ![image 20231019184928342](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242256038.png) ![image 20231019190347057](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242256039.png) ![image 20231019190408157](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242256040.png) > 根据对应的时间进行设置 由于没有对应的引脚, 不能进行后面的测试 ## FMC的使用"},"/note/嵌入式/stm32/HAL库/2023-10-2-01入门.html":{"title":"HAL库入门","content":" layout: post title: \"HAL库入门\" date: 2023 10 2 15:39:08 +0800 tags: stm32 HAL库 # HAL库入门 stm公司的芯片有Cotex M3, M4, M7的芯片(F1/F4/F7/H7), 有很多不同的芯片, 基于不同的架构, 使用HAL库对于平台的移植有很好的兼容性, HAL是硬件抽象层的概念, 不需要关心底层的硬件, 开发人员不需要关心硬件实现 HAL库: 封装出来通用的接口, 大大提高代码通用性, 对于一个应用, 可以把它分为 可以把一个应用分为: 硬件层, 驱动层, 中间件以及应用 ![image 20231002225350493](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300762.png) 还可以使用工具CubeMX很方便的添加一些功能, 这一个组件通过HAL库与硬件进行交流, 第三方的库就是独立出来的, 同时还有一个LL库, 直接操控底层的寄存器, 追求效率的时候可以两个库一同进行开发 + 中间件: 操作系统以及应用程序之间的连接, 为了方便应用的开发,够为一种或多种应用程序合作互通、资源共享，同时还能够为该应用程序提供相关的服务的软件。中间件是一类软件统称，而非一种软件;中间件不仅仅实现互连，还要实现应用之间的互操作。 + LL库（Low Level库）是针对单片机底层硬件的库，提供了对寄存器和外设的直接访问；固件库（Standard库）是基于LL库的高级库，提供了更高层次的抽象和易用性；HAL库（Hardware Abstraction Layer库）是更高级别的库，提供了跨平台的硬件抽象层，使得代码可移植性更强。 + CubeMX: CubeMX是一款图形化配置工具，用于生成嵌入式系统的初始化代码，可以帮助开发人员快速生成代码，加快开发进程。 ## 内核的差异 [Cortex M for Beginners 2017_CN_v3.pdf](file:///E:/a学习/1.stm/A盘（资料盘）/3 STM32官方资料/STM32F1官方手册资料/Cortex M for Beginners 2017_CN_v3.pdf) ### 分类 ARM有三种处理器有三个分类 应用处理器: 用于操作系统, 支持MMU(内存管理单元) 实时处理器: 多数不支持MMU, 通常有MPU, Cache 和其他针对工业应用设计的存 储器功能。 微控制器处理器: 在单片机和深度嵌入式系统市场非常 成功和受欢迎 + Cortex内核的特点 使用的指令集比较高级, 有优秀的中断处理机制, 可以处理中断嵌套以及中断处理机制支持C语言, 反应速度快 在处理中断的时候跳转指令变为异常处理函数的起始地址 + Cotex M对于系统的支持 影子堆栈指针(为每一个进程使用不同的堆栈指针), 系统服务调用SVC和可挂起系统调用, Systick 24位递减计数器, MPU + 错误处理 使用未定义的指令, 访问非法的地址空间, 非法操作(在优先级高于SVC的中断中尝试触发SVC中断) ### 野火产品 Cortex M3, 最精简的内核, 有完整的debug功能 Cortex M4, 额外的指令, 用于数字处理, 还有浮点运算单元 Cortex M7, 双精度的浮点运算, cache等进行添加 所有的Cotex内核都支持基准的编程模式, NVIC, 睡眠模式, 操作系统支持, Debug的支持 这几个内核使用的都是ARMv7的指令集 ![image 20231003130623665](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300763.png) 差异主要体现在指令集上面, 系统的架构是否有缓存, 主要还是性能以及能耗上面 ## 认识STM32 ST: 意法半导体 M: 微电子 32: 总线的宽度 ![image 20231003223139300](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300764.png) ![image 20231003223102987](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300765.png) ![image 20231003223506611](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300766.png) 参考手册: 软件编程, 数据手册: 硬件数据 ![image 20231003223659313](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300767.png) ## 寄存器操控STM32的GPIO ![image 20231004090947979](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300768.png) ![image 20231004090956981](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300769.png) > 主要的区别: 上下拉位置的区别 ![image 20231004091117095](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300770.png) > 1. 进行保护, 防止电压过高过低, 但是是有效的, 数据手册中有推荐的电压以及电流 > 2. 输出模式的选择 > 3. 4. 实际的寄存器控制 > > 5. 6. 7. 输入电平信号的控制 ![image 20231004091408229](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300771.png) > 推挽输出模式的时候直接连接到电源的正负极, 开漏输出可以接地, 没有办法输出高电压电流, 主要是为了实现一个线与的通信方式 有两种方式进行环境的配置(启动文件) 1. 运行环境管理工具, ARM公司提供了一个标准的接口, CMSIS ![image 20231004093050416](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300772.png) > 添加一个内核控制文件, 以及一个设备启动文件 ![image 20231004093236547](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300773.png) 2. 从库包里面寻找 在使用HAL库的时候使用的包要是大版本的, 以0进行结尾 ### 总线架构 Cortex M3使用总线矩阵与外界进行连接, 通过总线可以把不同的外设分离开来, 由此可以独立的控制各个外设的使能与否(控制外设的时钟) 在存储器映像里面可以找到各个寄存器的位置, 之后再RCC时钟控制器的章节里面找到实际要控制的寄存器的偏移 最后在GPIO的章节里面找到要控制的模式 ## 引入库编程的方式 寄存器编程开发难度大, 代码可读性差, 翻阅手册比较麻烦"},"/note/嵌入式/stm32/HAL库/2023-10-13-13SPIFlash.html":{"title":"SPI/FLASH","content":" layout: post title: \"SPI/FLASH\" date: 2023 10 13 15:39:08 +0800 tags: stm32 HAL库 # SPI/FLASH ![image 20231013230337791](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302183.png) 高速全双工的通信协议, 时钟线两根通信引脚, 一根片选引脚, SS引脚是低电平的时候选择这一个设备 在时钟的一个边沿时候进行数据的变换, 时钟的另一个边沿进行数据的采样, 可以设置为不同的模式 CPOL控制的是空闲的时候时钟的状态, 0的时候是低电平, CPHA控制的是数据采样的时间, 设置为0的时候为奇数边沿进行采样 ## QSPI 应用比SPI协议更加广泛, 对其功能进行增强, 增加队列传输机制, 推出队列串行外围接口协议 ![image 20231013233015162](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302184.png) > 使用四条数据线进行数据传输, 使用的方式和SIP相似 + 四个阶段 指令, 地址, 复用字节, 空周期, 数据 ![image 20231013233238400](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302185.png) > 在指令传输的时候使用的SPI的协议, 之后数据的传输, 发送的是四个数据线进行传输 ## STM32的实现 使用三跟线,可以选择单项的同步单工的功能 8位或者16为的传输格式, 主机或者从机的模式, 可以选的8个分频系数, 可以选的时钟的极性或者相位, MSB在前或者LSB在前, NSS可以选则是硬件控制还是软件控制 有中断标志位对于状态进行处理, SPI总线的忙状态位, 硬件校验, 可以作为最后一个字节进行传输, 支持DMA + 升级 支持SPITI协议, 只要是片选信号线的差异 数据支持4位到16为的长度, 支持FIFO 4位到32位, 使用双时钟域, 对于片选极性以及时序, MISO和MOSI的切换 Quad SPI的扩展, 主要用于控制SPI Flash > 有三种模式, 间接模式, 使用寄存器进行所有操作 > > 状态轮训模式, 周期性读取尾部Flash的状态寄存器, 标志位为1的时候会产生中断, 内部映射模式, 外部的Flash映射到内部的内存空间 > > 支持双闪存, 提高容量 ![image 20231014093513425](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302186.png) ![image 20231014095519114](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302187.png) ![image 20231014111033864](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302188.png) ![image 20231014112809824](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302189.png) ![image 20231014113308789](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302190.png) ## 实际发送数据 + 拉低引脚 + 写入数据到缓冲区 + 发送完成标志BSY标志 + 当有数据接收到的时候会有一个RXNE标志 + 读取SPI的Flash的时候可以读取Flash的标志位 + 在使用容量比较大的flash的时候有专门的指令进入四字节表示一个地址, 状态寄存器里面有保存 ### QSPI 有三种模式 + 间接模式 直接操控寄存器 + 自动轮训模式 查询SPIFlsh的器件状态寄存器的状态, 有一个掩码功能, 用于匹配状态位 + 内存映射 将其视为一块内存, 直接使用指针进行操作 有一个限制, 只能够读取数据, 不能进行写入数据 在使用的时候需要设置指令的格式, QSPI_CommandTypeDef, 有具体的指令, 用几条线进行传输, 有的Flash可以设置之后的命令使用地址线发送, 这个不使能, 是否使用DDR(上下边沿进行采样) 最后使用HAL_SPI_Command()进行发送, 使用HAL_QSPI_Transmit()传输数据 可以使用命令HAL_QSPI_AutoPolling()进行自动轮询的读取状态寄存器, 有一个专门的结构体控制自动轮训的查询的标志位, 还可以设置匹配的标志位是与还是或(是否需要全部匹配)"},"/note/嵌入式/stm32/HAL库/2023-10-30-20电容按键.html":{"title":"电容按键","content":" layout: post title: \"电容按键\" date: 2023 10 19 15:39:08 +0800 tags: stm32 HAL库 # 电容按键 原理, 金属块之间加一个绝缘体就可以构成电容 ![image 20231030163639725](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310301636781.png) > 在上电以后会进行充电, 充电以后会变为3.3V ![image 20231030163852923](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310301638983.png) > 手指触摸的时候会形成另一个电容, 容纳的电荷量会增加, 充电时间变长, 最主要的就是测量按键充电的时间"},"/note/嵌入式/stm32/HAL库/2023-10-6-10通讯原理-USART.html":{"title":"通讯原理, USART","content":" layout: post title: \"通讯原理, USART\" date: 2023 10 6 15:39:08 +0800 tags: stm32 HAL库 # 通讯原理 + 串行通讯并行通讯 串行通讯使用的数据线比较少, 一般是8根以下, 地线以及控制线, 按照数据位形式一位一位的进行传输 并行通讯使用8, 16, 32, 64以及更多的数据线进行通讯 串行的通讯距离比较远, 抗干扰能力强, 并行的速率快, 但是成本高 + 全双工半双工单工 是否可以同时发送信息, 以及发送信息的时候是否只是一个方向进行区分 + 同步, 异步 根据数据的同步方式, 根据是否有时钟信号 ## 通讯速率 一般使用比特率作为通讯速率的参数, 单位是bit/s 波特率: 每秒钟有多少个码元, 码元是通讯信号调制的概念, 一个码元可以有多个二进制位, 等价的时候默认使用1bit为一个码元 ## 串口 UART: 通用异步收发器 USART: 添加了同步功能 主要通过产生RS232/RS485等串行接口标准协议发送数据 主要是通过tx, rx两根线进行通讯, stm32与PC通过RS 232进行通讯, 标准规定了连接电缆和机械, 电气特性信号功能以及发送过程 使用的电平不同 通讯标准 电平标准 : : : : 5V TTL 逻辑1: 2.4 ~ 5V 逻辑0: 0 ~ 0.5V RS 232 逻辑1: 15V ~ 3V 逻辑0: +3 ~ +15 > 需要一个芯片对电平进行转化,这个电平主要是为了进行抗干扰 ![image 20231007093222663](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242301712.png) 但是在使用的时候一般会进行裁剪, 使用RXD, TXD, GND三根线 + 协议层 有一个起始位, 8位数据从位0 7, 一个校验位, 一个停止位 使用异步通讯, 需要提前约定好通讯使用的波特率, 即每一个码元的长度, 常见的波特率是4800, 9600, 115200 起始位是一个0, 停止信号为0.5, 1, 1.0或者2个逻辑数字1表示, 有效数据传输的个数也可以进行约定 校验有奇校验, 偶校验, 0校验, 1校验, 这个也是可选的 ![image 20231007111459309](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242301713.png) > 可以使用CPU或者DMA的形式进行读取或写入, ![image 20231007111624332](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242301714.png) > H7使用两个时钟, 对功能进行分区, 添加了FIFO的功能, 可以设置一个阈值, 之后进行一次性读出 ## 实际使用 现在一般使用USB转串口来达到串口通讯的功能 ![image 20231007123203739](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242301715.png) + 配置时钟 + 调试为串行调试 + 设置usart ![image 20231007124204336](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242301716.png) ![image 20231007124403815](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242301717.png) ![image 20231007124822808](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242301718.png) ![image 20231007124604721](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242301719.png) ![image 20231007124657232](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242301720.png) ![image 20231007124835713](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242301721.png) ![image 20231007124910375](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242301722.png) ```c void Usart_SendString(uint8_t *str) { \tunsigned int k 0; do { HAL_UART_Transmit(&huart1,(uint8_t *)(str + k) ,1,1000); k++; } while(*(str + k)! '\\0'); } ``` > 使用者一个函数进行发送数据, 要使用printf的话需要重定义fputc函数 > > ```c > //重定向c库函数printf到串口DEBUG_USART，重定向后可使用printf函数 > int fputc(int ch, FILE *f) > { > \t/* 发送一个字节数据到串口DEBUG_USART */ > \tHAL_UART_Transmit(&UartHandle, (uint8_t *)&ch, 1, 1000);\t > \t > \treturn (ch); > } > > //重定向c库函数scanf到串口DEBUG_USART，重写向后可使用scanf、getchar等函数 > int fgetc(FILE *f) > {\t\t > \tint ch; > \tHAL_UART_Receive(&UartHandle, (uint8_t *)&ch, 1, 1000);\t > \treturn (ch); > } > ``` > >"},"/note/嵌入式/stm32/HAL库/2023-10-4-02初识HAL固件库.html":{"title":"初识HAL库","content":" layout: post title: \"初识HAL库\" date: 2023 10 4 15:39:08 +0800 tags: stm32 HAL库 # 初识HAL库 ## CMSIS标准以及库法的层次关系 ![image 20231004160626443](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302579.png) CMSIS层: 内核通用的一些接口 ![image 20231004160903832](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302581.png) ![image 20231004164009251](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302582.png) ![image 20231004164610417](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302583.png) ### 使用的两种模式 1. 自己移植, 不推荐 2. 使用CubeMX进行配置 ## 自己进行移植 主要是移植CMSIS文件夹以及HAL_Driver两个文件夹 之后添加文件, 添加一个启动文件, 之后添加一个CMSIS文件夹下的对应的系统设置的文件 在添加库文件的时候不添加template文件以及ll库的文件 移植之后添加两个宏`USE_HAL_DRIVER,STM32F103xE` 添加之后依旧在报错找不到一个文件 ```c /** ****************************************************************************** * @file stm32f1xx_hal_conf.h * @author MCD Application Team * @version V1.1.1 * @date 12 May 2017 * @brief HAL configuration template file. * This file should be copied to the application folder and renamed * to stm32f1xx_hal_conf.h. ******************************************************************************/ ``` > 这个文件里面说明需要这样进行设置, 这一个文件会进行设置哪一个文件会被编译进我们的项目 > 之后有的文件之间又相互的依赖关系, 需要在添加的时候把所有的文件都添加到里面 ## CubeMX ### 安装 首先下载Java的运行环境, 之后下载CubeMX进行安装, 使用默认配置 ### 使用 ![image 20231004193845251](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302584.png) 有三种创建项目的模式, 第一种是根据芯片进行创建, 第二种是官方的开发板, 第三种是示例 ![image 20231004194307823](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302585.png) > 找到对应的芯片双击进入 ![image 20231004194525685](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302586.png) ![image 20231004194617060](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302587.png) ![image 20231004194718648](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302588.png) ![image 20231004194933122](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302589.png) ![image 20231004195042492](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302590.png) > 可以在这里添加其他的功能 [STM32CubeMX STM32Cube初始化代码生成器 意法半导体STMicroelectronics](https://www.st.com/zh/development tools/stm32cubemx.html#documentation) > 这里面有相关的配置文档 ![image 20231004195425275](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302591.png) > 1. 各种外设的配置 > 2. 时钟 > 3. 项目的工程怎么生成 ![image 20231004200040453](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302592.png) ![image 20231004200135447](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302593.png) 下载不同版本的固件包版本 ![image 20231004200633367](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302594.png) ![image 20231004200901772](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302595.png) ![image 20231004201045833](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302596.png)生成代码"},"/note/嵌入式/stm32/HAL库/2023-10-6-08HAL库驱动框架.html":{"title":"HAL库驱动框架","content":" layout: post title: \"HAL库驱动框架\" date: 2023 10 6 15:39:08 +0800 tags: stm32 HAL库 # HAL库驱动框架 + 外设初始化 + 外设使用 ## 对外设进行封装 ### xx_HandleTypeDef(xx外设的句柄结构体) + Instance成员, xx_TypeDef, 保存实际操控的对象 ```c typedef struct { __IO uint32_t CRL; __IO uint32_t CRH; __IO uint32_t IDR; __IO uint32_t ODR; __IO uint32_t BSRR; __IO uint32_t BRR; __IO uint32_t LCKR; } GPIO_TypeDef; ``` > 记录实际操控的寄存器, 在stm32f103xe.h文件里面 + xx_InitTypeDef 用于初始化一个具体的对象 + Hdma*成员, DMA_HandleTypeDef类型, 可以有多个 + LOCK锁, HAL_LockTypeDef类型 + STATUS状态, HAL_xx_StateTypeDef ### 初始化方法 + HAL_xx_Init, 参数一般是句柄结构体 + HAL_xx_MspInit, 会完成底层相关资源的初始化, 比如时钟, 使用到的引脚, 中断使能, DMA开启等, 会在Init函数里面进行调用, 这个需要用户来进行实现 > 一般在.c文件的How to use this driver里面有 ### 外设的使用 + 阻塞轮训 xx_start xx_read/xx_write > 函数特征, 需要传入一个Timeout参数 > > ```c > HAL_StatusTypeDef HAL_I2C_Master_Transmit(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size, uint32_t Timeout); > ``` + 中断 xx_start_it > HAL_XX_IRQHandler > HAL_XX_xxCallback xx_read_it/xx_write_it > 以IT进行结尾的函数 > > ```c > HAL_StatusTypeDef HAL_I2C_Master_Transmit_IT(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size); > ``` + DMA xx_start_dma xx_read/write_dma > ```c > HAL_StatusTypeDef HAL_I2C_Master_Transmit_DMA(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t *pData, uint16_t Size); > ``` + 其他方式 标志位的查询, 中断的使能\\失能, 时钟的使能\\失能 ### 回调函数 HAL库使用了很多的回调函数, 用户自己实现, 但是会导致这个库的性能比较低下, 在中断里面会调用不同的回调函数 ## 总结 1. 定义并且填充句柄结构体 2. 遵守HAL库的规范, 通过HAL_xx_MspInit函数初始化GPIO等资源 3. 调用HAL库的HAL_xxx_Init函数 4. 初始化完成, 开始使用外设 5. 查看.c文件的使用说明"},"/note/嵌入式/stm32/HAL库/2023-10-7-11DMA直接存储访问控制器.html":{"title":"DMA直接存储访问控制器","content":" layout: post title: \"DMA直接存储访问控制器\" date: 2023 10 7 15:39:08 +0800 tags: stm32 HAL库 # DMA直接存储访问控制器 用于外设和存储器之间, 或者存储器和存储器之间提供高速的数据传输, 节省CPU的资源 ![image 20231007195126574](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242304177.png) > DMA是一个独立的外设, 直接连接在总线矩阵之上, 所以可以访问所有的外设 + DMA请求 + 通道的选择 + 数据搬运的地址 > F4, F7添加了一个FIFO的功能, 主要是为了对数据长度不同处理, 以及进行暂存数据 传输方向, 传输的对象, DMA传输的时候也有一个优先级, 确定传输数据双方的数据格式, 传输的时候是否需要循环传输, 是否需要传输的中断/标志 ![image 20231007224819386](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242304178.png) ![image 20231007224833420](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242304179.png) > 传输的使能需要由别的外设发起 + 升级 双缓冲模式, DMA在两个内存区域之间进行切换, 与此同时CPU对填充结束的区域进行操作 FIFO: FIFO随着源目标和目标数据宽度不同的的时候进行使用, 比如8bit 32bit 单次传输: 批量传输数据, AHB总线的外设设置为单次传输的时候, 每一个DMA请求产生一个一字节, 半字节或者字的传输 突发传输: 每一个字节产生4个, 8个或16个节拍的字节, 半字节或者字的传输 > 主要是针对FIFO进行的设置, FIFO的容量为16byte, 实际上就是一个阈值, 当FIFO填充到一定情况的时候, 一次传输出去特定数量的字节数 DMA请求复用器(DMAMUX), 由于请求的数量以及格式多样化, 使用复用器就不再是一一对应的 ```c typedef struct __DMA_HandleTypeDef { DMA_Channel_TypeDef *Instance; /*!< Register base address */ DMA_InitTypeDef Init; /*!< DMA communication parameters */ HAL_LockTypeDef Lock; /*!< DMA locking object */ __IO HAL_DMA_StateTypeDef State; /*!< DMA transfer state */ void *Parent; /*!< Parent object state */ void (* XferCpltCallback)( struct __DMA_HandleTypeDef * hdma); /*!< DMA transfer complete callback */ void (* XferHalfCpltCallback)( struct __DMA_HandleTypeDef * hdma); /*!< DMA Half transfer complete callback */ void (* XferErrorCallback)( struct __DMA_HandleTypeDef * hdma); /*!< DMA transfer error callback */ void (* XferAbortCallback)( struct __DMA_HandleTypeDef * hdma); /*!< DMA transfer abort callback */ __IO uint32_t ErrorCode; /*!< DMA Error code */ DMA_TypeDef *DmaBaseAddress; /*!< DMA Channel Base Address */ uint32_t ChannelIndex; /*!< DMA Channel Index */ } DMA_HandleTypeDef; ``` > 这里面有一个指向寄存器的结构体, 一个初始化结构体, 还有一些回调函数的结构体, 会在中断中被调用 ![image 20231008185444038](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242304180.png) ![image 20231008185521314](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242304181.png)"},"/note/嵌入式/stm32/HAL库/2023-10-6-09Debug调试.html":{"title":"Debug调试","content":" layout: post title: \"Debug调试\" date: 2023 10 6 15:39:08 +0800 tags: stm32 HAL库 # Debug调试 常见的方法 + 硬件调试 + 打印调试 + 调试器调试 + 常见的Debug工具 一般集成的IDE都有自带的Debug工具, Keil, CubeIDE ![image 20231006185914035](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259883.png) ![image 20231006190322607](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259884.png) > 命令窗口, 可以在这里使用命令进行操控 ![image 20231006190353538](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259885.png) > 汇编窗口, 显示汇编命令 ![image 20231006190510987](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259886.png) > 显示使用的变量以及它的类型 ![image 20231006190554488](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259887.png) > 寄存器窗口, 指示CPU的工作状态 ![image 20231006190713265](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259888.png) > 调用栈的函数, 可以获取函数的调用过程, 还会有函数中使用到的参数的具体数值 ![image 20231006190917293](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259889.png) > 监视窗口, 可以直接进行拖拽或者右键add to ![image 20231006192434885](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259890.png) > 监控内存, 监控的时候需要在变量前面添加取址符号, 这个内存里面的数据可以直接进行更改 ![image 20231006192713085](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259891.png) > 以后的都是对应特定的仿真器使用的 ![image 20231006192824100](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259892.png) > 用来查看各种外设的状态 ![image 20231006193235238](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259893.png) ![image 20231006193250842](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259894.png) 设置进行周期性的更新"},"/note/嵌入式/stm32/HAL库/2023-10-27-18ADC.html":{"title":"ADC","content":" layout: post title: \"ADC\" date: 2023 10 19 15:39:08 +0800 tags: stm32 HAL库 # ADC 将模拟量转化为数字量的器件叫做模数转换器, ADC 将数字量转换为模拟量的是DAC, 只要和CPU打交道的都是数字量 传感器的数据通过运放进行放大, 之后通过多路模拟开关, 进行采样保持, 传给A/D转换器转换为数字量通过I/O接口交给微处理器 + stm32最少支持到12位的ADC, 但是如果传感器的精度不够就会导致在放大以后的精度变得更差 + 第二个参数相对精度ADC实际输出的数字量和实际的值之间的最大的差值 + 转换速度指的是一次转换需要的时间 + 采样间隔时间, 两次转换之间的时间 + 采样的电压范围 ## stm32的ADC 12位分辨率, 单次和连续转换切换模式, 转换结束以及注入结束以后会发生中断和模拟看门狗事件 规则模式会依次进行采集, 但是有些时候需要插入一个通道的采集的时候需要注入通道的使用 模拟看门狗设定一个阈值, 在电平超过一个值以后会发生中断 ![image 20231028091328367](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310280913555.png) > 每一个ADC在某一次只能连接到某一个通道, 有多个通道要采集的时候, 需要设定一个顺序, 三个ADC可以同时对一个引脚进行采集用来加快采集的顺序 > > 规则通道最多有16个, 注入通道最多有四个, 注入通道使用的前提是有规则通道 > > 使用的时候可以选择左对齐右对齐, 将数据存放在一个16位的寄存器里面, 使用6位保存结果的时候会把数据放在低八位里面 ADC输入范围：VREF ≤ VIN ≤ VREF+ ![image 20231028092534936](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310280925978.png) ![image 20231028093348195](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310280933254.png) ![image 20231028093403895](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310280934929.png) > 这个在进行转换的时候如果JL设置的数字小于四, 会将最上面的通道不予以考虑, 例如设置为00也就是1的时候实际转换的是JSQ4保存的通道 温度传感器和通道ADC1_IN16相连接，内部参照电压VREFINT和ADC1_IN17相连接 ![image 20231028094535622](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310280945649.png) 可以利用这一个值进行计算实际采样得到的数据 在使用双ADC的时候, 使用的是ADC1和ADC2 ![image 20231028100318249](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281003286.png) > 高级的芯片有三DMA模式 ![image 20231028103647643](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281036699.png) > 由于现在设置的是中断处理, 中断函数需要一定的时间, 所以需要把采样时间设置比较大 ![image 20231028103833374](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281038402.png) ## 实际使用 ```c /* USER CODE BEGIN PD */ uint16_t ADC_Data 0; /* USER CODE END PD */ /* Private macro */ /* USER CODE BEGIN PM */ void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc) { \t/*获取结果*/ \tADC_Data HAL_ADC_GetValue(hadc); } /* USER CODE END PM */ ``` > 设置一个回调函数的值 ```c /* USER CODE BEGIN ADC1_Init 2 */ \tHAL_ADC_Start_IT(&hadc1); /* USER CODE END ADC1_Init 2 */ ``` ## 交替采集 采样同一个通道的时候不要使用同步注入以及同步规则模式进行采样 一般使用DMA进行数据的传输, 设置一块较大的区域进行存储, 防止DMA频繁进入中断 采集的时候由于不支持多个ADC同时采集一个引脚, 所以使用多个ADC采集同一个通道的意义不大"},"/note/嵌入式/stm32/HAL库/2023-10-6-07Systick定时器.html":{"title":"Systick定时器","content":" layout: post title: \"Systick定时器\" date: 2023 10 6 15:39:08 +0800 tags: stm32 HAL库 # Systick定时器 是一个内核的外设, 内嵌在NVIC里面, 有一个24位的向下递减的自动重装载寄存器, 计数的周期为CLKSource, 可以配置这个时钟最高频率为72MHz 一般来说Cortex M的内核都有这样一个定时器 一般用于操作系统, 用于任务的调度, 或者进行微妙毫秒级别的延时 ![image 20231006105704629](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242304192.png) RCC通过AHB时钟(HCLK)8分频后作为Cortex系统定时器(SysTick)的外部时钟。通过对SysTick 控制与状态寄存器的设置，可选择上述时钟或Cortex(HCLK)时钟作为SysTick时钟。 ![image 20231006110403364](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242304193.png) ![image 20231006110418371](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242304194.png) 使用的HAL_Delay()函数就是依靠这一个时钟生成的, CubeMX提供的配置只有这两个 默认的时候这个时钟会在HAL库初始化的时候进行使能, 设置优先级为最小的优先级, 之后设置时钟的频率以后会再次设置Systick的频率 ```c /* Update the SystemCoreClock global variable计算时钟的频率 */ SystemCoreClock HAL_RCC_GetSysClockFreq() >> AHBPrescTable[(RCC >CFGR & RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos]; /* Configure the source of time base considering new system clocks settings设置Systick时钟*/ HAL_InitTick(uwTickPrio); ``` ```c /** * @brief This function provides minimum delay (in milliseconds) based * on variable incremented. * @note In the default implementation , SysTick timer is the source of time base. * It is used to generate interrupts at regular time intervals where uwTick * is incremented. * @note This function is declared as __weak to be overwritten in case of other * implementations in user file. * @param Delay specifies the delay time length, in milliseconds. * @retval None */ __weak void HAL_Delay(uint32_t Delay) { uint32_t tickstart HAL_GetTick(); uint32_t wait Delay; /* Add a freq to guarantee minimum wait */ if (wait < HAL_MAX_DELAY) { wait + (uint32_t)(uwTickFreq); } while ((HAL_GetTick() tickstart) < wait) { } } ``` > 使用一个全局变量进行记录时间"},"/note/嵌入式/stm32/HAL库/2023-10-9-12常见的存储器-I2C-EEPROM.html":{"title":"常见的存储器, I2C-EEPROM","content":" layout: post title: \"常见的存储器, I2C EEPROM\" date: 2023 10 7 15:39:08 +0800 tags: stm32 HAL库 # 常见的存储器 ## 易失性存储器RAM: + SRAM: 静态随机存储器 + DRAM: 动态随机存储器 > 随机是指访问数据与数据的位置无关 > SRAM使用的是锁存器, DRMA使用的是电容存储的电荷, DRAM需要定期进行充电 一般SRAM采用的是异步的方式进行访问, DRAM使用的同步的方式进行访问 DRAM >SDRAM, DDR SDRAM, DDRII SDRAM, DDRIII SDRAM > DDR: 双边沿数据监测 + 对比 DRAM存储较慢, 集成度比较高, 生产的成本比较低, 需要刷新 ## 非易失性存储器 + ROM只读存储器 >MASK ROM, OTP, EPROM, EEPROM + FLASH:闪存 + 磁盘光盘 MASK ROM出厂的时候固定程序, 不可以修改 OTP只可以写入一次 EPROM: 重复擦写, 需要紫外线设备进行擦除 EEPROM:电擦写 FLASH: 容量比较大, 分为Nor FLASH和Nand FLASH两种, 主要的区别在于内部的连接方式, 在写入之前需要进行擦除, 按照块进行擦除, Nor FLASH支持按照字节进行读取, Nand FLASH只能使用块进行读写 一般来说NorFLASH的读取速度比较快, 且坏块比较少 ## I2C 使用一根数据线, 一根时钟线, 支持多设备, 每一个设备有自己的设备号 设备通过上拉电阻接到总线上, 空闲的时候输出高组态 使用线与的方式来进行 有三种模式速度 + STM的实现 可以作为主机以及从机, 支持100bit/谁,400bit/s的速率, 支持7位, 10位的设备地址, 支持DMA数据传输, 有数据校验 作为从设备的时候可以设置为两个地址 有拉长时钟的功能, 为了应对其他设备的响应速率比较低 + 高级的芯片 添加了滤波器, 不同模块使用不同的总线的时钟 + 框图 ![image 20231012113635364](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259986.png) ![image 20231012182221706](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259987.png) ## EEPROM 一个外接的设备, 兼容400KHz, 有八个引脚 可以设地址, 一个写保护引脚 ![image 20231012195024984](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259988.png) ![image 20231012195119125](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259989.png) ![image 20231012195408842](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259990.png) ![image 20231012195442176](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259991.png) ![image 20231012223322119](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259992.png) ## 问题 串口打印的时候不能使用printf > 勾选![image 20231012232447183](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259993.png)"},"/note/嵌入式/stm32/HAL库/2023-10-5-03GPIO板级支持包的构建.html":{"title":"GPIO板级支持包的构建","content":" layout: post title: \"GPIO板级支持包的构建\" date: 2023 10 5 15:39:08 +0800 tags: stm32 HAL库 # GPIO板级支持包的构建 板级支持包是基于主板的硬件和操作系统之间的一层, 一般认为是操作系统中的一部分, 主要是实现对操作系统的支持, 为上层的驱动程序提供访问硬件的函数包, 让他能更好的运行在主板 HAL库驱动 > LED,按键 > 访问硬件的接口 > 应用程序 对板子上的资源功能进行实现, 给出用户程序的接口"},"/note/嵌入式/stm32/HAL库/2023-10-5-06异常和中断EXTI.html":{"title":"异常和中断, EXTI和事件控制器","content":" layout: post title: \"异常和中断, EXTI和事件控制器\" date: 2023 10 5 15:39:08 +0800 tags: stm32 HAL库 # 异常和中断 ## 中断 计算机运行的时候, 出现某些意外需要主机进行干预, 机器自动停止正在运行的程序, 转入处理程序, 处理完毕以后返回原先被暂停的程序继续进行 STM32有异常以及中断, 这个是Cortex内核支持的, ST公司进行扩展 异常是内核产生的, 中断一般是指连接到内核的外部器件产生, 他们触发的处理方式相同 ![image 20231005200910723](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259531.png) ![image 20231005200936043](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259532.png) ![image 20231005200946754](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259533.png) > 优先级越小, 优先级越高, 除了固定的优先级, 其他的中断根据优先级分组进行配置, Cotex内核有8bit的优先级, 但是STM32只支持高四位也就是4bit的优先级配置 > > STM32使用优先级分组 > > 分组分别为抢占优先级以及子优先级, 抢占优先级才会进行中断的嵌套, 挂起的中断里面抢占优先级相同的时候才会根据子优先级的大小进行判断哪一个中断先进行, 通过NVIC进行设置, 如果抢占优先级子优先级相同, 则IRQ小的先运行 使用NVIC可以使能失能中断, 设置中断悬起, 清除中断悬起, 获取悬起的中断, 设置中断优先级, 获取中断优先级, 以及系统复位 ## EXTI拓展中断和事件控制器 ### 事件 STM32上面有很多的外设, 通过内部的信号来进行协同的工作, 这个信号可以理解为时间, 有些事件是可见的, 另一些不可见, 在寄存器里面可以查到这一些事件的标志, 通常我们把中断和事件绑定在一起, 来使用相应的事件 ### EXTI 拓展中断和事件控制器 可以捕获电平的变化等, 产生对应的中断 ![image 20231005224409532](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259534.png) > 一般来说是GPIO的输入, 但是高级的芯片里面还有其他的输入, 电平变化以后根据触发选择寄存器来选择是否会向后面进行, 这时候连接的是一个或门, 还可以进行软件触发, 之后会往下进行传递, 再行下传递会进行分叉, 向上触发中断, 向左会触发脉冲, 脉冲主要用于芯片的唤醒 > > 事件可以用于一些外设上面, 比如可以在不使用中断但是启动ADC > > 在H7系列的芯片里面, 对于能够在系统处于停止模式或 CPU 处于 CStop 模式时生成唤醒事件的外设，将连接至 EXTI 可配置事件输入或直接事件输入 > > ![image 20231005230615656](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259535.png) > > 可配置事件(Configurable events)来自GPIO，PVD以及比较器COMP1和COMP2的外部中断关联。 > > 直接事件(Direct events)来自RTC，Tamper，I2C1，USARTS 1和2，CEC，LPUART1，LPTIM 1、2，LSE，UCPD 1、2。 ## 使用CubeMX进行生成代码 ![image 20231006093132019](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259536.png) ![image 20231006093232841](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259537.png) 有事件模式以及中断模式 ![image 20231006093338005](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259538.png) ![image 20231006093443948](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259539.png) > HAL库直接使用GPIO的一个模式进行表示EXTI模式, 使用GPIO_Init函数就可以实现这一个功能 之后就可以设置生成对应的程序 程序中会生成对应的初始化代码, 同时还会生成一个中断处理函数, 进行中断的标志位的清除"},"/note/嵌入式/stm32/HAL库/2023-10-19-16LCD.html":{"title":"LCD","content":" layout: post title: \"LCD\" date: 2023 10 19 15:39:08 +0800 tags: stm32 HAL库 # LCD 图像的颜色是使用RGB进行控制 HSV和HLS颜色空间适用于图形处理, 包括色调, 饱和度等设置 LCD主要是通过施加电压来控制通过不同颜色的滤光片的颜色的多少, 电压可以改变液晶的偏转角度, 背光发射的光是白光, 经过滤光之后显示不同的颜色, LCD所有的像素使用同一个背光 OLED有机自发光二极管, 通过特殊设计的发光二极管, 控制不同颜色的二极管的颜色明暗来进行控制显示的颜色, 每一个的光源单独控制, 在部分显示的时候OLED会更加省电, 对比度更高, 显示出来的黑色等颜色更加纯正 液晶在寒冷的时候会响应比较慢, OLED没有这个方面的问题, 并且屏幕更加的低, 但是存在问题, OLED是有机物, 老化的比较快, 会出现烧屏 调光的方式, OLED使用的是DC调光, 使用的是直接调节电压的方式, 而LCD使用的是PWM, 有可能会导致屏闪 ## 显示屏控制原理 主要的参数, 像素, 分辨率, 色彩深度(显示的颜色的数量), 显示器尺寸, 屏幕的对角线的尺寸, 使用英寸进行表示, 点距 显示器的接口, DP, HDMI, DVI, VGA MCU模式: RGB模式, SPI, 串口 一般的屏幕的组成, 液晶显示面板, 触摸面板, PCB板, PCB上面有可能有一个控制芯片, 主要是为了低级的MCU也可以控制, MCU屏幕因为有LCD驱动器不需要点.行,时钟等, 而另一种没有的则需要, 高级的芯片可以直接进行刷新板子的显示, 一般RGB屏幕一般比较大, 而MCU屏幕一般比较小, 在控制器里面有显存 + 不使用控制器的屏幕 ![image 20231019230025389](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302499.png) 液晶屏与外部使用同步通讯方式，以 CLK 信号作为同步时钟，在同步时钟的驱动下， 每个时钟传输一个像素点数据。水平同步信号 HSYNC(Horizontal Sync) 用于表示液晶屏一行像素数据的传输结束，每 传输完成液晶屏的一行像素数据时，HSYNC 会发生电平跳变，如分辨率为 800x480 的显示屏 (800 列，480 行)，传输一帧的图像 HSYNC 的电平会跳变 480 次。垂直同步信号 VSYNC(Vertical Sync) 用于表示液晶屏一帧像素数据的传输结束，每传 输完成一帧像素数据时，VSYNC 会发生电平跳变。其中“帧”是图像的单位，一幅 图像称为一帧 实际上还有一些边缘的校验, 需要加上一些边沿的像素, 但是不参与显示, 主要是当你传入的数据不对的时候会显示出来 ![image 20231019230634768](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302500.png) ![image 20231019230709862](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302501.png) ![image 20231019230720064](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302502.png) RGB LCD一般有两种驱动模式：DE模式和HV模式，这两个模式的区别是DE模式需要用到DE信号线，而HV模式不需要用到DE信号线，在DE模式下是可以不需要HSYNC信号线的，即使不接HSYNC信号线LCD也可以正常工作。 ![image 20231019232615262](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302503.png) ## 8080时序(RGB控制) + NT35510控制芯片 一般使用8080时序, 还可以使用的是SPI和I2C时序, 但是时钟速率比较低 使用一个引脚低电平为数据有效WRX, 使用另一个引脚控制是数据还是命令DCX, 一个片选引脚CSX, 读写控制引脚 RDX, 还使用了16位的数据引脚, 可以使用FSMC进行模拟 ![image 20231020092842819](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302504.png) > 使用数据引脚传输数据, 使用一根数据线选择发送数据还是命令, NEx用来做CSX, NOE对应读RDX, NWE作为写WRX ![image 20231021122811362](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302505.png) > 实际写入的时候需要控制对应的引脚为0或1, 计算地址之后自动生成 ![image 20231021124050145](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302506.png) ![image 20231021124551051](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302507.png) ## 使用CubeMX生成代码 生成之后需要手动设置一下使用的模式 ![image 20231021201854963](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302508.png) ### 读取时序的设置 [STM32CubeMX学习笔记（38）——FSMC接口使用（TFT LCD屏显示） 掘金 (juejin.cn)](https://juejin.cn/post/7135631218787221541) ![image 20231021220059327](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302509.png) ![image 20231021220312279](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302510.png) > 地址给出以后多长时间可以进行读取使能**这个时间就是`ADDSET地址建立时间`**, 以及NOE变化之后多长时间会进行采样, **低电平保持的时间由`DATAST数据建立时间`** > > ![image 20231021231110807](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302511.png) ### 写时序的设置 ![image 20231021220059327](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302509.png) ![image 20231021231437325](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302512.png) ![image 20231021231531904](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302513.png) > 设置时间最小是10ns，在这个周期内WRX线处于低电平。 tdht：数据保持时间,与 twrh写控制高电平的最小时间相同,是10ns,在这个周期内WRX线处于高电平。 观察时序图，我们设置 tdst数据设置时间 为1HCLK（13.8>10）就能满足数据设置最小时间的要求,我们不需要考虑tdht数据保持时间(看上面模式B时序图,NWE变成高电平后,会持续1HCLK 13.8ns,默认满足tdht了)。 ### 设置其他的引脚 复位引脚PE1, 背光引脚PD12需要单独设置, ![image 20231021231958972](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302514.png) ### 移植 添加文件 ![image 20231022101605231](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302515.png) 在初始化函数里面把引脚以及FSMC的初始化注释掉 ### 初始化使用的数据 数据来自于厂家提供的内容 ```c #define FSMC_Addr_ILI9341_CMD ( ( uint32_t ) 0x60000000 ) //FSMC_Bank1_NORSRAM用于LCD数据操作的地址 #define FSMC_Addr_ILI9341_DATA ( ( uint32_t ) 0x60020000 ) ``` > 实际写入数据 > > ![image 20231024093354379](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302516.png) > > 使用16位的模式的时候由于地址偏移, 会导致实际操作的A16应该操作第17位的数字, 实际上通过地址线发送的地址是软件操控的地址>>1 ### 实际的操控像素 首先打开一个窗口, 之后对里面进行填充色素数据 ```c /** * @brief 在ILI9341显示器上开辟一个窗口 * @param usX ：在特定扫描方向下窗口的起点X坐标 * @param usY ：在特定扫描方向下窗口的起点Y坐标 * @param usWidth ：窗口的宽度 * @param usHeight ：窗口的高度 * @retval 无 */ void ILI9341_OpenWindow ( uint16_t usX, uint16_t usY, uint16_t usWidth, uint16_t usHeight ) {\t \tILI9341_Write_Cmd ( CMD_SetCoordinateX ); \t\t\t\t /* 设置X坐标 */ \tILI9341_Write_Data ( usX >> 8 );\t /* 先高8位，然后低8位 */ \tILI9341_Write_Data ( usX & 0xff );\t /* 设置起始点和结束点*/ \tILI9341_Write_Data ( ( usX + usWidth 1 ) >> 8 ); \tILI9341_Write_Data ( ( usX + usWidth 1 ) & 0xff ); \tILI9341_Write_Cmd ( CMD_SetCoordinateY ); \t\t\t /* 设置Y坐标*/ \tILI9341_Write_Data ( usY >> 8 ); \tILI9341_Write_Data ( usY & 0xff ); \tILI9341_Write_Data ( ( usY + usHeight 1 ) >> 8 ); \tILI9341_Write_Data ( ( usY + usHeight 1) & 0xff ); \t } ``` ![image 20231025094222271](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302517.png) ## 显示中英文 首先是字节编码, 最早的字符编码是ASCII编码, 但是由于只使用一个字节, 存储的数量有限 1980年我国发布的汉字编码字符集GB2312, 是一个简体汉字的字符集, 使用一到两个字符表示一个字符, 包含6763个常用汉字, 以及682个全角的非汉字组成 但是相对于整个汉字总数前还是不够看, 1995年发布的GBK字符集扩展了两万多个新汉字(包含繁体字)与符号, 兼容GB2312 2003年发布GB18030, 添加少数民族的字, 向下兼容GBK ASCII使用一个字节, 但是汉字使用的是两个字节, 具体的区分ASCII使用127个字符也就是0x7f, 如果使用大于这一个数字的显示的就是汉字 ### 标准统一 1994年ISO发布Unicode标准, 统一的二进制标准, 满足各个国家跨语言处理的要求 有三种形式进行存储 + UTF 8: 使用变长的方式 + UTF 16: 两或四字节 + UTF 32: 使用四个字节进行保存一个字符, 可以保存这一个标准中的任意一个字符 外码 >内码 > 交换码 >字形码 外码: 输入码, 平常键盘拼音输入的字母, 是一个索引码 内码: 计算机存储的二进制, 输入的汉字要转化为二进制形式, 集合叫做字符集 交换码: 国标码, 和别的计算机交换信息的时候使用的编码 字形码: 汉字字模, 二进制转化为可视化的图形, 集合叫做字库 ### GB2312 实际使用的编码位是0xA1A1 FEFE, 汉字的区域是B0A1 F7FE, 原因是为了兼容ASCII, 最高位为1, 并且预留0x20个控制位 GB2312编码对收录的字符进行分区, 分为94个区, 每一个区有94个位, 一共有8836个码位 第16个区开始是汉字, 0 9是682个汉字以外的字符 10 15是空白区域没有使用 16 55是一级汉字, 按照拼音进行排序 56 87区收录3008个二级汉字, 按照部首进行排序 88 94是空白区没有使用 实际使用的时候就是: 区码加位码+A0A0, 比如''啊''是16区第一个, 就是0x1001+0xA0A0 实际在使用字模库的时候由于没有进行兼容偏移, 所以使用的是字符的在总个数的排序 Addr (((ColdH 0xA0 1)* 94) + (CodeL 0xA0 1))\\*32\\*32/8 > Addr 地址偏移 > > CodeH区码 > > CodeL位码 ## 实际移植 主要问题是在移植野火的库函数以后, 由于片选引脚使用的是软件进行控制的需要单独进行设置, 修改MSP函数 ![image 20231026183438462](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302518.png) ![image 20231026183452162](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302519.png) ![image 20231026183512048](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302520.png) ![image 20231026183532660](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242302521.png)"},"/note/嵌入式/stm32/HAL库/2023-10-16-14Fatfs.html":{"title":"Fatfs","content":" layout: post title: \"Fatfs\" date: 2023 10 16 15:39:08 +0800 tags: stm32 HAL库 # Fatfs 为了有效的进行文件的管理 特点: 会建立一些引导结构, 需要先对存储介质进行格式化 存储的时候可能会将一个应用存储在不连续的地址空间里面, 会使得内存的空间利用率增加 ![image 20231016225733318](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300909.png) Fatfs是一个脱离底层的文件操作系统, 可以容易的移植到其他的存储器里面 ## 文件组成 + doucuments 帮助文档 + source 源代码 + + ff.c 文件系统的模块, 核心文件 + ffconf.c配置文件 + ff.h 使用时候包含的文件 + diskio.h + diskio.c 包含底层的存储介质的操作函数, 函数需要用户自己进行添加 + ffunicode.c 简体中文包需要的文件 + ffsystem.c支持RTOS, 提供Fatfs功能的线程安全保护功能 > 底层设备的输入输出需要进行读写函数, 存储信息获取函数等 ![image 20231016231527316](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300910.png) > 可以使用CubeMX进行添加以及源码进行移植, CubeMX是通过ST工程师修改的, 支持多设更好 ## 自己移植 将几个文件添加到项目, 之后把初始化的几个实例删掉, 添加一个函数, get_fattime()返回一个32位的时间 实现对应的接口 + 获取SPI_FLASH的状态, 使用ID状态进行判断 + 初始化函数 + 读取一个扇区, 读取的时候传入的数据是扇区, 一个扇区是4096个字节, 需要进行转化 + 写的操作和读的操作类似 + 在写之前需要进行擦除 + 获取存储相关信息的函数, 比如存在的扇区的数量 配置对应的文件ff_conf.h + 进行裁剪 ```c #define FF_FS_MINIMIZE\t0 /* This option defines minimization level to remove some basic API functions. / / 0: Basic functions are fully enabled. / 1: f_stat(), f_getfree(), f_unlink(), f_mkdir(), f_truncate() and f_rename() / are removed. / 2: f_opendir(), f_readdir() and f_closedir() are removed in addition to 1. / 3: f_lseek() function is removed in addition to 2. */ ``` + 格式化 ```c #define FF_USE_MKFS\t\t0 /* This option switches f_mkfs() function. (0:Disable or 1:Enable) */ ``` + 文件权限 ```c #define FF_USE_CHMOD\t0 /* This option switches attribute manipulation functions, f_chmod() and f_utime(). / (0:Disable or 1:Enable) Also FF_FS_READONLY needs to be 0 to enable this option. */ ``` + 文件名是否支持中文等 ```c #define FF_CODE_PAGE\t932 /* This option specifies the OEM code page to be used on the target system. / Incorrect code page setting can cause a file open failure. ``` + 长文件名 ```c #define FF_USE_LFN\t\t0 #define FF_MAX_LFN\t\t255 ``` + 字符编码 ```C #define FF_LFN_UNICODE\t0 ``` + 挂载的设备 ```c #define FF_VOLUMES\t\t1 /* Number of volumes (logical drives) to be used. (1 10) */ ``` + 扇区大小 ```c #define FF_MIN_SS\t\t512 #define FF_MAX_SS\t\t512 /* This set of options configures the range of sector size to be supported. (512, / 1024, 2048 or 4096) Always set both 512 for most systems, generic memory card and / harddisk, but a larger value may be required for on board flash memory and some / type of optical media. When FF_MAX_SS is larger than FF_MIN_SS, FatFs is configured / for variable sector size mode and disk_ioctl() function needs to implement / GET_SECTOR_SIZE command. */ ``` > 当使用不同的扇区大小的时候会使用信息获取函数从而获取扇区的大小 + 其他 还有进行分盘的, 进行和操作系统相互协调的, 修改使用的分盘的名字的宏定义等 > 主要修改使用格式化, 修改编码页支持中文, 使用长文件名, 一个扇区的大小 ## 实际的使用 + 挂载文件系统ff_mount(文件系统句柄, 文件系统挂载的路径, 操作模式(1马上挂载, 0不立即挂载)) + 创建文件系统f_mkfs() + 打开文件 + 对文件进行修改 + 关闭文件 > 在使用的时候需要注意文件指针的位置 ## 使用CubeMX进行添加 ![image 20231017121801203](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300911.png) ![image 20231017122122852](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300912.png) > 对应之前宏定义对应的各个选项 stc公司对设备进行封装了一层结构体, 用来简化代码, 以及优化操作 添加了一个文件ff_gen_drv.c用于链接驱动文件 user_diskio.c这是一个具体的驱动的实现 fatfs.c具体的使用, 这是一个上层文件 ![image 20231017124301230](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300913.png) ### 使用流程上的不同 主要在于对驱动的连接上不同, STC对这个文件做了一层封装, 使用ff_gen_drv.c管理注册的驱动 + MX_FATFS_Init函数调用 + 会进行FATFS_LinkDriver函数, 参数是一个结构体包含驱动是否初始化以及一个驱动的实现, 记录当前的驱动数量等, 还有一个路径变量, 初始化全局变量disk用来记录已经初始化的设备 ![image 20231018125357304](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300914.png) > 这个是记录所有设备的结构体, ```c uint8_t FATFS_LinkDriverEx(Diskio_drvTypeDef *drv, char *path, uint8_t lun) { uint8_t ret 1; uint8_t DiskNum 0; if(disk.nbr < _VOLUMES) { disk.is_initialized[disk.nbr] 0; disk.drv[disk.nbr] drv; disk.lun[disk.nbr] lun; DiskNum disk.nbr++; path[0] DiskNum + '0'; path[1] ':'; path[2] '/'; path[3] 0; ret 0; } return ret; } ``` ## 问题修正 [STM32CubeMX学习笔记（25）——FatFs文件系统使用（操作SPI Flash） 掘金 (juejin.cn)](https://juejin.cn/post/7103349303883595784) ```c /* USER CODE BEGIN Header */ /** ****************************************************************************** * @file user_diskio.c * @brief This file includes a diskio driver skeleton to be completed by the user. ****************************************************************************** * @attention * * Copyright (c) 2023 STMicroelectronics. * All rights reserved. * * This software is licensed under terms that can be found in the LICENSE file * in the root directory of this software component. * If no LICENSE file comes with this software, it is provided AS IS. * ****************************************************************************** */ /* USER CODE END Header */ #ifdef USE_OBSOLETE_USER_CODE_SECTION_0 /* * Warning: the user section 0 is no more in use (starting from CubeMx version 4.16.0) * To be suppressed in the future. * Kept to ensure backward compatibility with previous CubeMx versions when * migrating projects. * User code previously added there should be copied in the new user sections before * the section contents can be deleted. */ /* USER CODE BEGIN 0 */ /* USER CODE END 0 */ #endif /* USER CODE BEGIN DECL */ /* Includes */ #include <string.h> #include \"ff_gen_drv.h\" #include <stdio.h> /* Private typedef */ /* Private define */ #define SPI_FLASH_PageSize 256 #define SPI_FLASH_PerWritePageSize 256 #define ManufactDeviceID_CMD 0x90 #define READ_STATU_REGISTER_1 0x05 #define READ_STATU_REGISTER_2 0x35 #define READ_DATA_CMD 0x03 #define WRITE_ENABLE_CMD 0x06 #define WRITE_DISABLE_CMD 0x04 #define SECTOR_ERASE_CMD 0x20 #define CHIP_ERASE_CMD 0xc7 #define PAGE_PROGRAM_CMD 0x02 #define SPI_FLASH_CS_LOW() HAL_GPIO_WritePin(GPIOC, GPIO_PIN_0, GPIO_PIN_RESET); #define SPI_FLASH_CS_HIGH() HAL_GPIO_WritePin(GPIOC, GPIO_PIN_0, GPIO_PIN_SET); extern SPI_HandleTypeDef hspi1; /** * @brief SPI发送指定长度的数据 * @param buf —— 发送数据缓冲区首地址 * @param size —— 要发送数据的字节数 * @retval 成功返回HAL_OK */ static HAL_StatusTypeDef SPI_Transmit(uint8_t* send_buf, uint16_t size) { return HAL_SPI_Transmit(&hspi1, send_buf, size, 200); } /** * @brief SPI接收指定长度的数据 * @param buf —— 接收数据缓冲区首地址 * @param size —— 要接收数据的字节数 * @retval 成功返回HAL_OK */ static HAL_StatusTypeDef SPI_Receive(uint8_t* recv_buf, uint16_t size) { return HAL_SPI_Receive(&hspi1, recv_buf, size, 200); } /** * @brief SPI在发送数据的同时接收指定长度的数据 * @param send_buf —— 接收数据缓冲区首地址 * @param recv_buf —— 接收数据缓冲区首地址 * @param size —— 要发送/接收数据的字节数 * @retval 成功返回HAL_OK */ HAL_StatusTypeDef SPI_TransmitReceive(uint8_t* send_buf, uint8_t* recv_buf, uint16_t size) { return HAL_SPI_TransmitReceive(&hspi1, send_buf, recv_buf, size, 200); } /*等待超时时间*/ #define SPIT_FLAG_TIMEOUT ((uint32_t)0x1000) #define SPIT_LONG_TIMEOUT ((uint32_t)(10 * SPIT_FLAG_TIMEOUT)) static __IO uint32_t SPITimeout SPIT_LONG_TIMEOUT; /** * @brief 等待超时回调函数 * @param None. * @retval None. */ static uint16_t SPI_TIMEOUT_UserCallback(uint8_t errorCode) { /* 等待超时后的处理,输出错误信息 */ printf(\"SPI 等待超时!errorCode %d\",errorCode); return 0; } /** * @brief 使用SPI发送一个字节的数据 * @param byte：要发送的数据 * @retval 返回接收到的数据 */ uint8_t SPI_FLASH_SendByte(uint8_t byte) { SPITimeout SPIT_FLAG_TIMEOUT; /* 等待发送缓冲区为空，TXE事件 */ while (__HAL_SPI_GET_FLAG( &hspi1, SPI_FLAG_TXE ) RESET) { if((SPITimeout ) 0) return SPI_TIMEOUT_UserCallback(0); } /* 写入数据寄存器，把要写入的数据写入发送缓冲区 */ WRITE_REG(hspi1.Instance >DR, byte); SPITimeout SPIT_FLAG_TIMEOUT; /* 等待接收缓冲区非空，RXNE事件 */ while (__HAL_SPI_GET_FLAG( &hspi1, SPI_FLAG_RXNE ) RESET) { if((SPITimeout ) 0) return SPI_TIMEOUT_UserCallback(1); } /* 读取数据寄存器，获取接收缓冲区数据 */ return READ_REG(hspi1.Instance >DR); } /** * @brief 读取Flash内部的ID * @param none * @retval 成功返回device_id */ uint16_t W25QXX_ReadID(void) { uint8_t recv_buf[2] {0}; //recv_buf[0]存放Manufacture ID, recv_buf[1]存放Device ID uint16_t device_id 0; uint8_t send_data[4] {ManufactDeviceID_CMD,0x00,0x00,0x00}; //待发送数据，命令+地址 /* 使能片选 */ SPI_FLASH_CS_LOW(); /* 发送并读取数据 */ if (HAL_OK SPI_Transmit(send_data, 4)) { if (HAL_OK SPI_Receive(recv_buf, 2)) { device_id (recv_buf[0] << 8) recv_buf[1]; } } /* 取消片选 */ SPI_FLASH_CS_HIGH(); return device_id; } /** * @brief 读取W25QXX的状态寄存器，W25Q64一共有2个状态寄存器 * @param reg —— 状态寄存器编号(1~2) * @retval 状态寄存器的值 */ static uint8_t W25QXX_ReadSR(uint8_t reg) { uint8_t result 0; uint8_t send_buf[4] {0x00,0x00,0x00,0x00}; switch(reg) { case 1: send_buf[0] READ_STATU_REGISTER_1; case 2: send_buf[0] READ_STATU_REGISTER_2; case 0: default: send_buf[0] READ_STATU_REGISTER_1; } /* 使能片选 */ SPI_FLASH_CS_LOW(); if (HAL_OK SPI_Transmit(send_buf, 4)) { if (HAL_OK SPI_Receive(&result, 1)) { /* 取消片选 */ SPI_FLASH_CS_HIGH(); return result; } } /* 取消片选 */ SPI_FLASH_CS_HIGH(); return 0; } /** * @brief 阻塞等待Flash处于空闲状态 * @param none * @retval none */ static void W25QXX_Wait_Busy(void) { while((W25QXX_ReadSR(1) & 0x01) 0x01); // 等待BUSY位清空 } /** * @brief W25QXX写使能,将S1寄存器的WEL置位 * @param none * @retval */ void W25QXX_Write_Enable(void) { uint8_t cmd WRITE_ENABLE_CMD; SPI_FLASH_CS_LOW(); SPI_Transmit(&cmd, 1); SPI_FLASH_CS_HIGH(); W25QXX_Wait_Busy(); } /** * @brief W25QXX写禁止,将WEL清零 * @param none * @retval none */ void W25QXX_Write_Disable(void) { uint8_t cmd WRITE_DISABLE_CMD; SPI_FLASH_CS_LOW(); SPI_Transmit(&cmd, 1); SPI_FLASH_CS_HIGH(); W25QXX_Wait_Busy(); } /** * @brief W25QXX擦除一个扇区 * @param sector_addr —— 扇区地址 根据实际容量设置 * @retval none * @note 阻塞操作 */ void W25QXX_Erase_Sector(uint32_t sector_addr) { W25QXX_Write_Enable(); //擦除操作即写入0xFF，需要开启写使能 W25QXX_Wait_Busy(); //等待写使能完成 /* 使能片选 */ SPI_FLASH_CS_LOW(); /* 发送扇区擦除指令*/ SPI_FLASH_SendByte(SECTOR_ERASE_CMD); /*发送擦除扇区地址的高位*/ SPI_FLASH_SendByte((sector_addr & 0xFF0000) >> 16); /* 发送擦除扇区地址的中位 */ SPI_FLASH_SendByte((sector_addr & 0xFF00) >> 8); /* 发送擦除扇区地址的低位 */ SPI_FLASH_SendByte(sector_addr & 0xFF); /* 取消片选 */ SPI_FLASH_CS_HIGH(); W25QXX_Wait_Busy(); //等待扇区擦除完成 } /** * @brief 页写入操作 * @param dat —— 要写入的数据缓冲区首地址 * @param WriteAddr —— 要写入的地址 * @param byte_to_write —— 要写入的字节数（0 256） * @retval none */ void W25QXX_PageProgram(uint8_t* dat, uint32_t WriteAddr, uint16_t nbytes) { uint8_t cmd PAGE_PROGRAM_CMD; // WriteAddr << 8; W25QXX_Write_Enable(); /* 使能片选 */ SPI_FLASH_CS_LOW(); //发送指令 SPI_Transmit(&cmd, 1); // SPI_Transmit((uint8_t*)&WriteAddr, 3); uint8_t addr; /* 发送 读 地址高位 */ addr (WriteAddr & 0xFF0000) >> 16; SPI_Transmit(&addr, 1); /* 发送 读 地址中位 */ addr (WriteAddr & 0xFF00) >> 8; SPI_Transmit(&addr, 1); /* 发送 读 地址低位 */ addr WriteAddr & 0xFF; SPI_Transmit(&addr, 1); SPI_Transmit(dat, nbytes); /* 取消片选 */ SPI_FLASH_CS_HIGH(); W25QXX_Wait_Busy(); } /** * @brief 对FLASH写入数据，调用本函数写入数据前需要先擦除扇区 * @param pBuffer，要写入数据的指针 * @param WriteAddr，写入地址 * @param NumByteToWrite，写入数据长度 * @retval 无 */ void W25QXX_BufferWrite(uint8_t* pBuffer, uint32_t WriteAddr, uint16_t NumByteToWrite) { uint8_t NumOfPage 0; uint8_t NumOfSingle 0; uint8_t Addr 0; uint8_t count 0; uint8_t temp 0; /*mod运算求余，若writeAddr是SPI_FLASH_PageSize整数倍，运算结果Addr值为0*/ Addr WriteAddr % SPI_FLASH_PageSize; /*差count个数据值，刚好可以对齐到页地址*/ count SPI_FLASH_PageSize Addr; /*计算出要写多少整数页*/ NumOfPage NumByteToWrite / SPI_FLASH_PageSize; /*mod运算求余，计算出剩余不满一页的字节数*/ NumOfSingle NumByteToWrite % SPI_FLASH_PageSize; /* Addr 0,则WriteAddr 刚好按页对齐 aligned */ if(Addr 0) { /* NumByteToWrite < SPI_FLASH_PageSize */ if(NumOfPage 0) { W25QXX_PageProgram(pBuffer, WriteAddr, NumByteToWrite); } /* NumByteToWrite > SPI_FLASH_PageSize */ else { /*先把整数页都写了*/ while(NumOfPage ) { W25QXX_PageProgram(pBuffer, WriteAddr, SPI_FLASH_PageSize); WriteAddr + SPI_FLASH_PageSize; pBuffer + SPI_FLASH_PageSize; } /*若有多余的不满一页的数据，把它写完*/ W25QXX_PageProgram(pBuffer, WriteAddr, NumOfSingle); } } /* 若地址与 SPI_FLASH_PageSize 不对齐 */ else { /* NumByteToWrite < SPI_FLASH_PageSize */ if(NumOfPage 0) { /*当前页剩余的count个位置比NumOfSingle小，写不完*/ if(NumOfSingle > count) { temp NumOfSingle count; /*先写满当前页*/ W25QXX_PageProgram(pBuffer, WriteAddr, count); WriteAddr + count; pBuffer + count; /*再写剩余的数据*/ W25QXX_PageProgram(pBuffer, WriteAddr, temp); } /*当前页剩余的count个位置能写完NumOfSingle个数据*/ else { W25QXX_PageProgram(pBuffer, WriteAddr, NumByteToWrite); } } /* NumByteToWrite > SPI_FLASH_PageSize */ else { /*地址不对齐多出的count分开处理，不加入这个运算*/ NumByteToWrite count; NumOfPage NumByteToWrite / SPI_FLASH_PageSize; NumOfSingle NumByteToWrite % SPI_FLASH_PageSize; W25QXX_PageProgram(pBuffer, WriteAddr, count); WriteAddr + count; pBuffer + count; /*把整数页都写了*/ while(NumOfPage ) { W25QXX_PageProgram(pBuffer, WriteAddr, SPI_FLASH_PageSize); WriteAddr + SPI_FLASH_PageSize; pBuffer + SPI_FLASH_PageSize; } /*若有多余的不满一页的数据，把它写完*/ if(NumOfSingle ! 0) { W25QXX_PageProgram(pBuffer, WriteAddr, NumOfSingle); } } } } /** * @brief 读取FLASH数据 * @param pBuffer，存储读出数据的指针 * @param ReadAddr，读取地址 * @param NumByteToRead，读取数据长度 * @retval 无 */ void W25QXX_BufferRead(uint8_t* pBuffer, uint32_t ReadAddr, uint16_t NumByteToRead) { W25QXX_Wait_Busy(); /* 选择FLASH: CS低电平 */ SPI_FLASH_CS_LOW(); /* 发送 读 指令 */ uint8_t cmd READ_DATA_CMD; SPI_Transmit(&cmd, 1); // 不知道为什么连起来发不行 // ReadAddr ReadAddr << 8; // SPI_Transmit((uint8_t*)&ReadAddr, 3); uint8_t addr; HAL_StatusTypeDef status; /* 发送 读 地址高位 */ addr (ReadAddr & 0xFF0000) >> 16; status SPI_Transmit(&addr, 1); /* 发送 读 地址中位 */ addr (ReadAddr& 0xFF00) >> 8; status SPI_Transmit(&addr, 1); /* 发送 读 地址低位 */ addr ReadAddr & 0xFF; status SPI_Transmit(&addr, 1); if(HAL_OK status) { SPI_Receive(pBuffer, NumByteToRead); } /* 停止信号 FLASH: CS 高电平 */ SPI_FLASH_CS_HIGH(); } /* Private variables */ /* Disk status */ static volatile DSTATUS Stat STA_NOINIT; /* USER CODE END DECL */ /* Private function prototypes */ DSTATUS USER_initialize (BYTE pdrv); DSTATUS USER_status (BYTE pdrv); DRESULT USER_read (BYTE pdrv, BYTE *buff, DWORD sector, UINT count); #if _USE_WRITE 1 DRESULT USER_write (BYTE pdrv, const BYTE *buff, DWORD sector, UINT count); #endif /* _USE_WRITE 1 */ #if _USE_IOCTL 1 DRESULT USER_ioctl (BYTE pdrv, BYTE cmd, void *buff); #endif /* _USE_IOCTL 1 */ Diskio_drvTypeDef USER_Driver { USER_initialize, USER_status, USER_read, #if _USE_WRITE USER_write, #endif /* _USE_WRITE 1 */ #if _USE_IOCTL 1 USER_ioctl, #endif /* _USE_IOCTL 1 */ }; /* Private functions */ /** * @brief Initializes a Drive * @param pdrv: Physical drive number (0..) * @retval DSTATUS: Operation status */ DSTATUS USER_initialize ( \tBYTE pdrv /* Physical drive nmuber to identify the drive */ ) { /* USER CODE BEGIN INIT */ /* USER CODE BEGIN INIT */ /* 延时一小段时间 */ uint16_t i; i 500; while( i); Stat STA_NOINIT; \tif(W25QXX_ReadID() ! 0) { Stat & ~STA_NOINIT; }\t\t return Stat; /* USER CODE END INIT */ } /** * @brief Gets Disk Status * @param pdrv: Physical drive number (0..) * @retval DSTATUS: Operation status */ DSTATUS USER_status ( \tBYTE pdrv /* Physical drive number to identify the drive */ ) { /* USER CODE BEGIN STATUS */ Stat & ~STA_NOINIT; return Stat; /* USER CODE END STATUS */ } /** * @brief Reads Sector(s) * @param pdrv: Physical drive number (0..) * @param *buff: Data buffer to store read data * @param sector: Sector address (LBA) * @param count: Number of sectors to read (1..128) * @retval DRESULT: Operation result */ DRESULT USER_read ( \tBYTE pdrv, /* Physical drive nmuber to identify the drive */ \tBYTE *buff, /* Data buffer to store read data */ \tDWORD sector, /* Sector address in LBA */ \tUINT count /* Number of sectors to read */ ) { /* USER CODE BEGIN READ */ \tDRESULT status RES_PARERR; if(!count) { return RES_PARERR; //count不能等于0，否则返回参数错误 } // /* 扇区偏移2MB，外部Flash文件系统空间放在SPI Flash后面6MB空间 */ sector + 512; W25QXX_BufferRead(buff, sector << 12, count << 12); status RES_OK; \treturn status; /* USER CODE END READ */ } /** * @brief Writes Sector(s) * @param pdrv: Physical drive number (0..) * @param *buff: Data to be written * @param sector: Sector address (LBA) * @param count: Number of sectors to write (1..128) * @retval DRESULT: Operation result */ #if _USE_WRITE 1 DRESULT USER_write ( \tBYTE pdrv, /* Physical drive nmuber to identify the drive */ \tconst BYTE *buff, /* Data to be written */ \tDWORD sector, /* Sector address in LBA */ \tUINT count /* Number of sectors to write */ ) { /* USER CODE BEGIN WRITE */ /* USER CODE HERE */ uint32_t write_addr; \tDRESULT status RES_PARERR; \tif(!count) { \t\treturn RES_PARERR;\t\t/* Check parameter */ \t} ///* 扇区偏移2MB，外部Flash文件系统空间放在SPI Flash后面6MB空间 */ sector + 512; write_addr sector << 12; W25QXX_Erase_Sector(write_addr); W25QXX_BufferWrite((uint8_t *)buff, write_addr, count << 12); status RES_OK; \treturn status; /* USER CODE END WRITE */ } #endif /* _USE_WRITE 1 */ /** * @brief I/O control operation * @param pdrv: Physical drive number (0..) * @param cmd: Control code * @param *buff: Buffer to send/receive control data * @retval DRESULT: Operation result */ #if _USE_IOCTL 1 DRESULT USER_ioctl ( \tBYTE pdrv, /* Physical drive nmuber (0..) */ \tBYTE cmd, /* Control code */ \tvoid *buff /* Buffer to send/receive control data */ ) { /* USER CODE BEGIN IOCTL */ \tDRESULT status RES_OK; switch(cmd) { case CTRL_SYNC : break; /* 扇区数量：1536*4096/1024/1024 6(MB) */ case GET_SECTOR_COUNT: *(DWORD * )buff 1536;\t\t break; /* 扇区大小 */ case GET_SECTOR_SIZE : *(WORD * )buff 4096; break; /* 同时擦除扇区个数 */ case GET_BLOCK_SIZE : *(DWORD * )buff 1; break; case CTRL_TRIM: break; \t\tdefault: \t\t\tstatus RES_PARERR; break; \t} \treturn status; /* USER CODE END IOCTL */ } #endif /* _USE_IOCTL 1 */ ``` ```c /* USER CODE BEGIN Header */ /** ****************************************************************************** * @file : main.c * @brief : Main program body ****************************************************************************** * @attention * * Copyright (c) 2023 STMicroelectronics. * All rights reserved. * * This software is licensed under terms that can be found in the LICENSE file * in the root directory of this software component. * If no LICENSE file comes with this software, it is provided AS IS. * ****************************************************************************** */ /* USER CODE END Header */ /* Includes */ #include \"main.h\" #include \"fatfs.h\" #include \"spi.h\" #include \"usart.h\" #include \"gpio.h\" #include <stdio.h> /* Private includes */ /* USER CODE BEGIN Includes */ /* USER CODE END Includes */ /* Private typedef */ /* USER CODE BEGIN PTD */ /* USER CODE END PTD */ /* Private define */ /* USER CODE BEGIN PD */ /* USER CODE END PD */ /* Private macro */ /* USER CODE BEGIN PM */ /* USER CODE END PM */ /* Private variables */ /* USER CODE BEGIN PV */ /* USER CODE END PV */ /* Private function prototypes */ void SystemClock_Config(void); /* USER CODE BEGIN PFP */ /* USER CODE END PFP */ /* Private user code */ /* USER CODE BEGIN 0 */ FATFS fs;\t\t\t\t\t\t\t\t\t\t\t\t\t/* FatFs文件系统对象 */ FIL fnew;\t\t\t\t\t\t\t\t\t\t\t\t\t/* 文件对象 */ FRESULT res_flash; /* 文件操作结果 */ UINT fnum; \t\t\t\t\t /* 文件成功读写数量 */ BYTE ReadBuffer[1024] {0}; /* 读缓冲区 */ BYTE WriteBuffer[] \"欢迎使用野火STM32开发板 今天是个好日子，新建文件系统测试文件\\r\\n\"; /* USER CODE END 0 */ /** * @brief The application entry point. * @retval int */ int main(void) { /* USER CODE BEGIN 1 */ /* USER CODE END 1 */ /* MCU Configuration */ /* Reset of all peripherals, Initializes the Flash interface and the Systick. */ HAL_Init(); /* USER CODE BEGIN Init */ /* USER CODE END Init */ /* Configure the system clock */ SystemClock_Config(); /* USER CODE BEGIN SysInit */ /* USER CODE END SysInit */ /* Initialize all configured peripherals */ MX_GPIO_Init(); MX_SPI1_Init(); MX_FATFS_Init(); MX_USART1_UART_Init(); /* USER CODE BEGIN 2 */ /* USER CODE END 2 */ \tprintf(\"hello world\"); \tres_flash f_mount(&fs,\"0:\",1); \t/* 格式化测试 */ \t/* 如果没有文件系统就格式化创建创建文件系统 */ \tif(res_flash FR_NO_FILESYSTEM) \t{ \t\tprintf(\"》FLASH还没有文件系统，即将进行格式化...\\r\\n\"); /* 格式化 */ \t\tres_flash f_mkfs(\"0:\",0,0);\t\t\t\t\t\t\t \t\t \t\tif(res_flash FR_OK) \t\t{ \t\t\tprintf(\"》FLASH已成功格式化文件系统。\\r\\n\"); /* 格式化后，先取消挂载 */ \t\t\tres_flash f_mount(NULL,\"1:\",1);\t\t\t /* 重新挂载\t*/\t\t\t \t\t\tres_flash f_mount(&fs,\"1:\",1); \t\t} \t\telse \t\t{ \t\t\tprintf(\"《《格式化失败。》》\\r\\n\"); \t\t\twhile(1); \t\t} \t} else if(res_flash! FR_OK) { printf(\"！！外部Flash挂载文件系统失败。(%d)\\r\\n\",res_flash); printf(\"！！可能原因：SPI Flash初始化不成功。\\r\\n\"); \t\twhile(1); } else { printf(\"》文件系统挂载成功，可以进行读写测试\\r\\n\"); } \tprintf(\"\\r\\n****** 即将进行文件写入测试... ******\\r\\n\");\t \tres_flash f_open(&fnew, \"0:FatFs读写测试文件.txt\",FA_CREATE_ALWAYS FA_WRITE ); \tif ( res_flash FR_OK ) \t{ \t\tprintf(\"》打开/创建FatFs读写测试文件.txt文件成功，向文件写入数据。\\r\\n\"); /* 将指定存储区内容写入到文件内 */ \t\tres_flash f_write(&fnew,WriteBuffer,sizeof(WriteBuffer),&fnum); if(res_flash FR_OK) { printf(\"》文件写入成功，写入字节数据：%d\\n\",fnum); printf(\"》向文件写入的数据为：\\r\\n%s\\r\\n\",WriteBuffer); } else { printf(\"！！文件写入失败：(%d)\\n\",res_flash); } \t\t/* 不再读写，关闭文件 */ f_close(&fnew); \t} \telse \t{\t \t\tprintf(\"！！打开/创建文件失败。\\r\\n\"); \t} \t /* 文件系统测试：读测试 */ \tprintf(\"****** 即将进行文件读取测试... ******\\r\\n\"); \tres_flash f_open(&fnew, \"0:FatFs读写测试文件.txt\",FA_OPEN_EXISTING FA_READ); \t \tif(res_flash FR_OK) \t{ \t\tprintf(\"》打开文件成功。\\r\\n\"); \t\tres_flash f_read(&fnew, ReadBuffer, sizeof(ReadBuffer), &fnum); if(res_flash FR_OK) { printf(\"》文件读取成功,读到字节数据：%d\\r\\n\",fnum); printf(\"》读取得的文件数据为：\\r\\n%s \\r\\n\", ReadBuffer);\t } else { printf(\"！！文件读取失败：(%d)\\n\",res_flash); }\t\t \t} \telse \t{ \t\tprintf(\"！！打开文件失败。\\r\\n\"); \t} \t/* 不再读写，关闭文件 */ \tf_close(&fnew);\t \t/* 不再使用文件系统，取消挂载文件系统 */ \tf_mount(NULL,\"1:\",1); /* Infinite loop */ /* USER CODE BEGIN WHILE */ while (1) { /* USER CODE END WHILE */ /* USER CODE BEGIN 3 */ } /* USER CODE END 3 */ } /** * @brief System Clock Configuration * @retval None */ void SystemClock_Config(void) { RCC_OscInitTypeDef RCC_OscInitStruct {0}; RCC_ClkInitTypeDef RCC_ClkInitStruct {0}; /** Initializes the RCC Oscillators according to the specified parameters * in the RCC_OscInitTypeDef structure. */ RCC_OscInitStruct.OscillatorType RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState RCC_HSE_ON; RCC_OscInitStruct.HSEPredivValue RCC_HSE_PREDIV_DIV1; RCC_OscInitStruct.HSIState RCC_HSI_ON; RCC_OscInitStruct.PLL.PLLState RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLMUL RCC_PLL_MUL9; if (HAL_RCC_OscConfig(&RCC_OscInitStruct) ! HAL_OK) { Error_Handler(); } /** Initializes the CPU, AHB and APB buses clocks */ RCC_ClkInitStruct.ClockType RCC_CLOCKTYPE_HCLKRCC_CLOCKTYPE_SYSCLK RCC_CLOCKTYPE_PCLK1RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider RCC_HCLK_DIV2; RCC_ClkInitStruct.APB2CLKDivider RCC_HCLK_DIV1; if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) ! HAL_OK) { Error_Handler(); } } /* USER CODE BEGIN 4 */ /* USER CODE END 4 */ /** * @brief This function is executed in case of error occurrence. * @retval None */ void Error_Handler(void) { /* USER CODE BEGIN Error_Handler_Debug */ /* User can add his own implementation to report the HAL error return state */ __disable_irq(); while (1) { } /* USER CODE END Error_Handler_Debug */ } #ifdef USE_FULL_ASSERT /** * @brief Reports the name of the source file and the source line number * where the assert_param error has occurred. * @param file: pointer to the source file name * @param line: assert_param error line source number * @retval None */ void assert_failed(uint8_t *file, uint32_t line) { /* USER CODE BEGIN 6 */ /* User can add his own implementation to report the file name and line number, ex: printf(\"Wrong parameters value: file %s on line %d\\r\\n\", file, line) */ /* USER CODE END 6 */ } #endif /* USE_FULL_ASSERT */ ``` > 这时候使用的系统盘是设备0, 使用野火提供的SPI库直接移植会产生问题 > 在进行写入的时候会有一个缓冲区, 提高写入的性能"},"/note/嵌入式/stm32/HAL库/2023-10-5-04启动过程.html":{"title":"启动过程","content":" layout: post title: \"启动过程\" date: 2023 10 5 15:39:08 +0800 tags: stm32 HAL库 # 启动过程 ARM CM3处理器使用的是哈佛结构 > 哈佛结构是一种将**程序指令存储**和**数据存储**分开的存储器结构，如下图所示。中央处理器首先到程序指令存储器中读取程序指令内容，解码后得到数据地址，再到相应的数据存储器中读取数据，并进行下一步的操作（通常是执行）。程序指令存储和数据存储分开，可以使**指令和数据有不同的数据宽度** > > 哈佛结构的微处理器通常具有较高的执行效率。其程序指令和数据指令分开组织和存储的，执行时可以预先读取下一条指令。 > > 哈佛结构是指程序和数据空间独立的体系结构， 目的是为了减轻程序运行时的访存瓶颈。 > > 哈佛结构能基本上解决取指和取数的冲突问题。 芯片上电以后会触发复位异常, 之后会寻找中断向量表, 之后会进行偏移 ![image 20231005102001486](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242256896.png) > 上电以后会汇获取复位异常位位置, 修改复位异常里面的内容, 就可以让处理器进行执行 可以通过设置引脚的状态来进行设置芯片启动的时候读取的位置 ![image 20231005102411916](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242256897.png) ![image 20231005102507307](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242256898.png) > 复位以后时钟的第四个上升沿的时候引脚的状态会被锁定 > 在启动延迟之后，CPU从地址0x0000 0000获取堆栈顶的地址，并从启动 存储器的0x0000 0004指示的地址开始执行代码。 因为固定的存储器映像，代码区始终从地址0x0000 0000开始(通过ICode和DCode总线访问)， 而数据区(SRAM)始终从地址0x2000 0000开始(通过系统总线访问)。 + 从主闪存存储器启动：主闪存存储器被映射到启动空间(0x0000 0000)，但仍然能够在它原 有的地址(0x0800 0000)访问它，即闪存存储器的内容可以在两个地址区域访问，0x0000 0000或0x0800 0000. + 从系统存储器启动：系统存储器被映射到启动空间(0x0000 0000)，但仍然能够在它原有的 地址(互联型产品原有地址为0x1FFF B000，其它产品原有地址为0x1FFF F000)访问它。 + 从内置SRAM启动：只能在0x2000 0000开始的地址区访问SRAM ## 启动文件 > ;* Set the initial SP > ;* Set the initial PC Reset_Handler > ;* Set the vector table entries with the exceptions ISR address > ;* Configure the clock system > ;* Branches to __main in the C library (which eventually > ;* calls main()). > 在链接的时候会把启动文件的中断向量表放置在最前面"},"/note/嵌入式/stm32/HAL库/2023-10-26-17电阻触摸屏.html":{"title":"电阻触摸屏","content":" layout: post title: \"电阻触摸屏\" date: 2023 10 26 15:39:08 +0800 tags: stm32 HAL库 # 电阻触摸屏 电阻屏通过压力控制, 可以适应比较恶劣的环境, 但是只支持单点触摸, 电容屏支持多点"},"/note/嵌入式/stm32/HAL库/2023-10-5-05复位以及时钟控制.html":{"title":"复位以及时钟控制","content":" layout: post title: \"复位以及时钟控制\" date: 2023 10 5 15:39:08 +0800 tags: stm32 HAL库 # 复位以及时钟控制(RCC) ## 复位 有三种复位 + 系统复位: 将复位除了时钟控制寄存器CSR中的复位标志和备份区域以内的寄存器以外的所有寄存器 + 电源复位: 复位除了备份区域以外的所有寄存器 + 后备域复位: 备份区有两个专门的复位, 只影响备份区域 > 当以下事件中的一件发生时，产生一个系统复位： 1. NRST引脚上的低电平(外部复位) 2. 窗口看门狗计数终止(WWDG复位) 3. 独立看门狗计数终止(IWDG复位) 4. 软件复位(SW复位) 5. 低功耗管理复位 > > 通过查看RCC_CSR控制状态寄存器中的复位状态标志位识别复位事件来源 ![image 20231005124719368](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300704.png) > 当以下事件中之一发生时，产生电源复位： 1. 上电/掉电复位(POR/PDR复位) 2. 从待机模式中返回 > 当以下事件中之一发生时，产生备份区域复位。 79/754 1. 软件复位，备份区域复位可由设置备份域控制寄存器(RCC_BDCR)(见7.3.9节)中的 BDRST位产生。 2. 在VDD和VBAT两者掉电的前提下，VDD或VBAT上电将引发备份区域复位。 + 备份域BKP 备份寄存器是42个16位的寄存器，可用来存储84个字节的用户应用程序数据。他们处在备份域 里，当VDD电源被切断，他们仍然由VBAT维持供电。用户可以在这一部分区域保存自己的数据 > 开发板上的电池对着一部分进行供电 ## RCC时钟 时钟是芯片的心跳, STM32有很多种时钟的来源, HSI高速内部时钟, HSE高速外部时钟, PLL, 锁相环倍频时钟, 还有一些二级时钟, 内部低速时钟LSI, LSE外部低速时钟32.768KHz(主要用于RTC) + 内部时钟以及外部时钟 ![image 20231116114402843](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311161144872.png) 内部时钟成本低, 但是没有外部时钟的稳定性高 使用不同的频率的时钟, 消耗的能量更高 ![image 20231116114204137](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311161142199.png) ![image 20231005130041906](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300705.png) > 使用CubeMX可以进行时钟的设置 ## 使用CubeMX进行配置 ![image 20231005130748391](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300706.png)在这里配置时钟源![image 20231005130849556](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300707.png) 外部的高速时钟通常是外部的晶振或者用户的输入 ![image 20231005190711212](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300708.png) 选择之后就可以使用时钟配置进行操作了 ![image 20231005190821626](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300709.png) 不设置的话默认使用的是HSI, 8MHz, 这里可以手动设置, 或者在系统时钟输入对应的数字自动生成 ![image 20231005191126994](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300710.png) > 在数据手册中有各个时钟所对应的最高频率的时钟 互联型的芯片的某一些时钟并不是从系统时钟获取时钟的, 需要单独考虑 使用F4以及H7系列的芯片的时候可以通过配置提高最高的时钟频率, 但是会增加芯片的耗能 ![image 20231116230729825](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311162307869.png) ## 其他芯片的时钟 ![image 20231116114538415](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311161145472.png) > APB1和APB2是挂载在AHB1上面的, 可能有2 3个AHB总线 ![image 20231116114646955](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311161146987.png) <img src \"C:/Users/jinhua/AppData/Roaming/Typora/typora user images/image 20231116114706064.png\" alt \"image 20231116114706064\" style \"zoom:200%;\" /> > 这个是f429, 不满足f407, 主要是下面的PLL锁相环的数量的区别 > > PLL里面的VCC是用来稳定频率用的, 分出来的48MHz一般是给USB时钟使用的 > > 以太网和高速USB需要外部的始终提供频率 + f407 ![image 20231118100612737](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311181006831.png) > 四个时钟源, 和f1的区别的是实际支持的频率不同 <img src \"https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311181007866.png\" alt \"image 20231118100746809\" style \"zoom:150%;\" /> ![image 20231118100758471](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311181007525.png) ![image 20231118100823666](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311181008726.png) > USB必须是48MHz, 满足USB会导致系统超频, 但是这个是芯片允许的, 可以正常使用的 + F7 <img src \"https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311181040318.png\" alt \"image 20231118104005264\" style \"zoom:150%;\" /> ![image 20231118104035867](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311181040897.png) ![image 20231118104050143](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311181040200.png) ![image 20231118104110813](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311181041870.png) + H7 <img src \"C:/Users/jinhua/AppData/Roaming/Typora/typora user images/image 20231118111146378.png\" alt \"image 20231118111146378\" style \"zoom:150%;\" /> ![image 20231118111206572](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311181112611.png) ![image 20231118111231765](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311181112823.png) ![image 20231118111254923](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311181112988.png) > 对了一个低功耗的时钟, franc为一个小数的倍频 ![image 20231118111307800](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311181113842.png) <img src \"https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311181113003.png\" alt \"image 20231118111324945\" style \"zoom:150%;\" /> ![image 20231118111344488](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311181113547.png) ![image 20231118111403155](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311181114214.png) ## 配置系统时钟 ### 系统时钟配置步骤 1. 配置HSE_VALUE的值, 在文件stm32xxxx_hal_config.h文件里面 2. 调用SystemInit()函数, 在启动文件里面调用, system_stm32xxxx.c文件里面 3. 选择时钟源, 配置PLL, HAL_RCC_OscConfig() 4. 选择系统时钟源, 配置总线分频器HAL_RCC_ClockConfig() 5. 配置扩展外设时钟可选, HAL_RCCEx_PeriphCLKConfig() 3+4+5 sys_stm32_clock_init()正点原子配置的函数 ### 外设时钟的使能失能 使用某一个外设的时候需要使能一个外设的时钟 __HAL_RCC_GPIOA_CLK_ENABLE(); __HAL_RCC_GPIOA_CLK_DISABLE(); ### 正点原子的初始化函数 主要使用的是 HAL_RCC_OscConfig(), HAL_RCC_ClockConfig() ```c void Stm32_Clock_Init(u32 PLL) { HAL_StatusTypeDef ret HAL_OK; RCC_OscInitTypeDef RCC_OscInitStructure; RCC_ClkInitTypeDef RCC_ClkInitStructure; RCC_OscInitStructure.OscillatorType RCC_OSCILLATORTYPE_HSE; \t//时钟源为HSE RCC_OscInitStructure.HSEState RCC_HSE_ON; \t//打开HSE \tRCC_OscInitStructure.HSEPredivValue RCC_HSE_PREDIV_DIV1;\t\t//HSE预分频 RCC_OscInitStructure.PLL.PLLState RCC_PLL_ON;\t\t\t\t\t//打开PLL RCC_OscInitStructure.PLL.PLLSource RCC_PLLSOURCE_HSE;\t\t\t//PLL时钟源选择HSE RCC_OscInitStructure.PLL.PLLMUL PLL; \t\t\t\t\t\t\t//主PLL倍频因子 ret HAL_RCC_OscConfig(&RCC_OscInitStructure);//初始化 \t if(ret! HAL_OK) while(1); //选中PLL作为系统时钟源并且配置HCLK,PCLK1和PCLK2 RCC_ClkInitStructure.ClockType (RCC_CLOCKTYPE_SYSCLKRCC_CLOCKTYPE_HCLKRCC_CLOCKTYPE_PCLK1RCC_CLOCKTYPE_PCLK2); RCC_ClkInitStructure.SYSCLKSource RCC_SYSCLKSOURCE_PLLCLK;\t\t//设置系统时钟时钟源为PLL RCC_ClkInitStructure.AHBCLKDivider RCC_SYSCLK_DIV1;\t\t\t\t//AHB分频系数为1 RCC_ClkInitStructure.APB1CLKDivider RCC_HCLK_DIV2; \t\t\t\t//APB1分频系数为2 RCC_ClkInitStructure.APB2CLKDivider RCC_HCLK_DIV1; \t\t\t\t//APB2分频系数为1 ret HAL_RCC_ClockConfig(&RCC_ClkInitStructure,FLASH_LATENCY_2);\t//同时设置FLASH延时周期为2WS，也就是3个CPU周期。 \t\t if(ret! HAL_OK) while(1); } ``` ![image 20231118114904703](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311181149761.png) > HSI由于温度变化会有偏差, 所以需要一个校准值 > > ![image 20231118115325311](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311181153351.png) > > ![image 20231118115412210](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311181154238.png) ![image 20231118115508211](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311181155258.png) > 设置的是FLASH_ACR寄存器的LATENCY位, 在闪存编程手册里面 > > 主要是为了CPU和FLASH的频率进行配对(72MHz 24MHz) > > ![image 20231118120030654](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311181200371.png) ### 其他芯片初始化 ![image 20231118205328947](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311182053024.png) ![image 20231118212354151](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311182123212.png) ![image 20231118212406338](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311182124385.png) ![image 20231118212426921](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311182124989.png) ![image 20231118212445550](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311182124601.png) ![image 20231118212456632](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311182124670.png)"},"/note/嵌入式/第三方移植/homeassistant/2025-3-30-homeassistant.html":{"title":"HomeAssistant","content":"# HomeAssistant 智能家居的控制, 不同品牌的智能家居 [AlexxIT/HassWP: Portable version of Home Assistant for Windows (no need to install)](https://github.com/AlexxIT/HassWP) 使用这个项目在Windows下面可以使用脚本进行部署"},"/note/嵌入式/第三方移植/lvgl/2024-6-3-09实体按键.html":{"title":"实体按键","content":" layout: post title: \"实体按键\" date: 2024 1 11 15:39:08 +0800 tags: stm32 lvgl # 实体按键 使用一个实体按键的时候, 需要把所控制的组件添加到组里面, 把他和按键的组关联起来 ![image 20240603184238603](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406031842770.png) > 有的部件默认已经在这一个组里面了, 不需要再次添加 ## 配置输入设备 在这里配置时候实际使用的是键盘的相关代码 ```c /* 键盘 */ static void keypad_init(void); static void keypad_read(lv_indev_drv_t * indev_drv, lv_indev_data_t * data); static uint32_t keypad_get_key(void); ``` ![image 20240603184852216](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406031848266.png) ```c /* * 键盘 * */ /** * @brief 初始化键盘 * @param 无 * @retval 无 */ static void keypad_init(void) { /*Your code comes here*/ key_init(); } /** * @brief 图形库的键盘读取回调函数 * @param indev_drv : 键盘设备 * @arg data : 输入设备数据结构体 * @retval 无 */ static void keypad_read(lv_indev_drv_t * indev_drv, lv_indev_data_t * data) { static uint32_t last_key 0; // /* 这段代码是 LVGL 给出的例子，这里获取坐标好像是多余的 */ // /*Get the current x and y coordinates*/ // mouse_get_xy(&data >point.x, &data >point.y); /* 获取按键是否被按下，并保存键值 */ uint32_t act_key keypad_get_key(); if(act_key ! 0) { data >state LV_INDEV_STATE_PR; /* 将键值转换成 LVGL 的控制字符 */ switch(act_key) { case KEY0_PRES: act_key LV_KEY_NEXT; break; case KEY1_PRES: act_key LV_KEY_PREV; break; case WKUP_PRES: act_key LV_KEY_ENTER; break; } last_key act_key; } else { data >state LV_INDEV_STATE_REL; } data >key last_key; } /** * @brief 获取当前正在按下的按键 * @param 无 * @retval 0 : 按键没有被按下 */ static uint32_t keypad_get_key(void) { /*Your code comes here*/ return key_scan(0); } ``` + 支持的按键 ```c enum { LV_KEY_UP 17, /*0x11*/ LV_KEY_DOWN 18, /*0x12*/ LV_KEY_RIGHT 19, /*0x13*/ LV_KEY_LEFT 20, /*0x14*/ LV_KEY_ESC 27, /*0x1B*/ LV_KEY_DEL 127, /*0x7F*/ LV_KEY_BACKSPACE 8, /*0x08*/ LV_KEY_ENTER 10, /*0x0A, '\\n'*/ LV_KEY_NEXT 9, /*0x09, '\\t'*/ LV_KEY_PREV 11, /*0x0B, '*/ LV_KEY_HOME 2, /*0x02, STX*/ LV_KEY_END 3, /*0x03, ETX*/ }; ``` > 在文档的Key这一个部分有某一个部件可以接受的按键 ```c /* * Keypad * */ /*Initialize your keypad*/ static void keypad_init(void) { /*Your code comes here*/ } /*Will be called by the library to read the mouse*/ static void keypad_read(lv_indev_drv_t * indev_drv, lv_indev_data_t * data) { static uint32_t last_key 0; /*Get the current x and y coordinates*/ mouse_get_xy(&data >point.x, &data >point.y); /*Get whether the a key is pressed and save the pressed key*/ uint32_t act_key keypad_get_key(); if(act_key ! 0) { data >state LV_INDEV_STATE_PR; /*Translate the keys to LVGL control characters according to your key definitions*/ switch(act_key) { case 1: act_key LV_KEY_NEXT; break; case 2: act_key LV_KEY_PREV; break; case 3: act_key LV_KEY_LEFT; break; case 4: act_key LV_KEY_RIGHT; break; case 5: act_key LV_KEY_ENTER; break; } last_key act_key; } else { data >state LV_INDEV_STATE_REL; } data >key last_key; } /*Get the currently being pressed key. 0 if no key is pressed*/ static uint32_t keypad_get_key(void) { /*Your code comes here*/ return 0; } ``` ## 设置组 ![image 20240603190016150](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406031900218.png) Objects you want to control with a keypad or encoder need to be added to a *Group*. In every group there is exactly one focused object which receives the pressed keys or the encoder actions. You need to associate an input device with a group. An input device can send key events to only one group but a group can receive data from more than one input device. To create a group use `lv_group_t * g lv_group_create()` and to add an object to the group use `lv_group_add_obj(g, obj)`. 创建 To associate a group with an input device use `lv_indev_set_group(indev, g)`, where `indev` is the return value of `lv_indev_drv_register()` 设置关联设备 Interactive widgets such as buttons, checkboxes, sliders, etc. can be automatically added to a default group. Just create a group with `lv_group_t * g lv_group_create();` and set the default group with `lv_group_set_default(g);` 可以使用默认的设置"},"/note/嵌入式/第三方移植/lvgl/2025-12-07-图层绘制.html":{"title":"图层绘制","content":"# 图层绘制 ## 图层 默认情况下，LVGL会将新的Widgets绘制在旧的Widgets之上。 例如，假设我们在名为button1的父Widget上添加一个按钮，然后再添加另一个名为button2的按钮。那么，button1（及其子Widget）将处于背景中，并可能被button2及其子Widget覆盖。 使用`lv_obj_move_foreground(widget)`将Widget移至前景。 类似地，使用`lv_obj_move_background(widget)`将其移至背景。 使用`lv_obj_move_to_index(widget, idx)`将Widget移动到子节点顺序中的指定索引位置 + `0`: 背景 + `child_num 1`: 前景 + `< 0`: 从顶部开始计数，向前（上）移动，例如:`lv_obj_move_to_index(widget, lv_obj_get_index(widget) 1)` 可以使用`lv_obj_swap(widget1, widget2)`交换图层 也可以使用`lv_obj_set_parent(widget, new_parent)`重新指定父对象 LVGL使用了两个特殊的层，分别是`layer_top`和`layer_sys`。这两个层在显示器的所有屏幕上都是可见且通用的。**但它们并不会在多个物理显示器之间共享。** `layer_top`始终位于默认屏幕`lv_screen_active()`之上，而``layer_sys``则位于``layer_top``之上 `layer_top`可供用户创建一些在所有地方都可见的内容。例如，一个菜单栏、弹出窗口等。如果启用了``click``属性，那么``layer_top``将吸收所有用户点击，并作为一个模态窗口。 ```c lv_obj_add_flag(lv_layer_top(), LV_OBJ_FLAG_CLICKABLE); ``` 这些层的工作方式与其他Widget类似，这意味着它们可以设置样式、滚动，并且可以在其上创建任何类型的Widget ## Canvas画布 用户能够绘制任何内容。在这里，可以使用 LVGL 强大的绘图引擎绘制矩形、文本、图像、线条、弧线等等。 Canvas 需要一个缓冲区来存储绘制的图像。 要为 Canvas 分配缓冲区，请使用函数 `lv_canvas_set_buffer(canvas, buffer, width, height, LV_COLOR_FORMAT_...)` ， 其中参数 `buffer` 是一个静态缓冲区（不能是局部变量）来保存画布的图像 ### 基础使用 要在画布上设置像素，请使用 `lv_canvas_set_px_color(canvas, x, y, color, opa)` 。 对于 `LV_COLOR_FORMAT_I1/2/4/8` 颜色索引需要像这样 `lv_color_from_int(13);` 传递，它将颜色索引 13 作为颜色传递。 `lv_canvas_fill_bg(canvas, lv_color_hex(0x00ff00), LV_OPA_50)` 将整个画布填充为蓝色，不透明度为 50%。 请注意，如果当前颜色格式不支持(例如 `LV_COLOR_FORMAT_A8`)，则该颜色将被忽略。同样，如果不支持不透明度(例如 `LV_COLOR_FORMAT_RGB565`)，不透明度将被忽略。 可以使用 `lv_canvas_copy_buf(canvas, buffer_to_copy, x, y, width, height) `将像素数组复制到画布。缓冲区和画布的颜色格式需要一致。 ## 手动绘制 一些样式属性会让 LVGL 分配一个缓冲区，并首先在那里渲染一个控件及其子部件。 之后，该层将在应用一些转换或其他修改后，被合并到屏幕或其父层 ```c static void ui_canvas_event(lv_event_t * e) { lv_event_code_t code lv_event_get_code(e); static lv_coord_t last_x 65535, last_y 65535; if(code LV_EVENT_PRESSING) { lv_indev_t * indev lv_indev_active(); if(indev NULL) return; lv_point_t point; lv_indev_get_point(indev, &point); if(last_x ! 65535 && last_y ! 65535) { // 初始化一个绘制层 lv_layer_t layer; lv_canvas_init_layer(canvas, &layer); lv_draw_line_dsc_t dsc; // 线条描述符 lv_draw_line_dsc_init(&dsc); dsc.color ui_Draw_para.line_color; dsc.width ui_Draw_para.line_width; dsc.round_end 1; dsc.round_start 1; dsc.p1.x last_x; dsc.p1.y last_y; dsc.p2.x point.x; dsc.p2.y point.y; lv_draw_line(&layer, &dsc); // 应用绘制层到画布 lv_canvas_finish_layer(canvas, &layer); } last_x point.x; last_y point.y; } else if(code LV_EVENT_RELEASED) { last_x 32768; last_y 32768; } } ```"},"/note/嵌入式/第三方移植/lvgl/2024-5-27-06基础部件.html":{"title":"lvgl部件使用","content":" layout: post title: \"lvgl部件使用\" date: 2024 1 11 15:39:08 +0800 tags: stm32 lvgl # 基础部件 ## 编程思想 使用的是面向对象的编程思想, 以抽象的类实现不同的部件 使用lv_obj_t这一个类实例化出来一个lv_obj类, 之后使用这一个类衍生出来其他的类(开关, 标签, 滑块) lvgl在初始化的时候会创建一个活动屏幕对象, 可以使用lv_scr_act这一个函数获取这一个对象 ```c lv_obj_t * switch_obj lv_switch_create(lv_scr_act()); //创建一个对象, 绑定父对象 lv_obj_set_size(switch_obj, 120, 60); lv_obj_align(switch_obj, LV_ALIGN_CENTER, 0, 0); ``` > 默认创建的对象是在父对象的左上角 ```c lv_obj_t * switch_obj lv_switch_create(lv_scr_act()); lv_obj_set_size(switch_obj, 120, 60); lv_obj_t * switch_obj2 lv_switch_create(switch_obj); ``` ![image 20240527233403402](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405272334456.png) ## 基础对象 可以作为一个父对象创建其他的对象, 也可以作为一个部件进行使用, 创建其他的对象的时候, 默认使用活动屏幕作为父对象(基础对象) ![image 20240528091728016](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405280917177.png) ![image 20240528092031458](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405280920492.png) ```c lv_obj_t *obj lv_obj_create(lv_scr_act()); ``` ### 父对象和子对象的关系 1. 子对象会随着父对象进行移动 2. 子对象超出父对象的位置不会进行显示 ![image 20240528092734865](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405280927906.png) ## 基本对象的属性 ```c typedef struct _lv_obj_t { const lv_obj_class_t * class_p; struct _lv_obj_t * parent; _lv_obj_spec_attr_t * spec_attr; _lv_obj_style_t * styles; #if LV_USE_USER_DATA void * user_data; #endif lv_area_t coords; lv_obj_flag_t flags; lv_state_t state; uint16_t layout_inv : 1; uint16_t scr_layout_inv : 1; uint16_t skip_trans : 1; uint16_t style_cnt : 6; uint16_t h_layout : 1; uint16_t w_layout : 1; } lv_obj_t; ``` > 基本属性为 > > + 大小 > + 位置 > + 对齐 > + 样式 > + 事件 ### 大小 ```c void lv_obj_set_width(lv_obj_t * obj, lv_coord_t w); void lv_obj_set_height(lv_obj_t * obj, lv_coord_t h); void lv_obj_set_size(lv_obj_t * obj, lv_coord_t w, lv_coord_t h) ``` ### 位置 设置子对象的位置的时候, 左边原点是在父对象的左上角 ```c void lv_obj_set_x(lv_obj_t * obj, lv_coord_t x); void lv_obj_set_y(lv_obj_t * obj, lv_coord_t y); void lv_obj_set_pos(lv_obj_t * obj, lv_coord_t x, lv_coord_t y); ``` ### 对齐 1. 参照父对象进行对齐(不可以超出父对象) 2. 参照其他的对象进行对齐 ```c void lv_obj_set_align(lv_obj_t * obj, lv_align_t align); void lv_obj_align(lv_obj_t * obj, lv_align_t align, lv_coord_t x_ofs, lv_coord_t y_ofs); ``` > 相对于父对象, 两种, 第二种在对齐的同时可以设置一个偏移 ```c void lv_obj_align_to(lv_obj_t * obj, const lv_obj_t * base, lv_align_t align, lv_coord_t x_ofs, lv_coord_t y_ofs) ``` > 参照其他的对象, 不需要有父子关系 ![image 20240528100929315](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405281009386.png) ```c lv_obj_t *obj lv_obj_create(lv_scr_act()); lv_obj_set_align(obj, LV_ALIGN_CENTER); ``` > 子对象设置的时候不可以设置在外面, 没有父子关系的时候可以随意设置 > > 在使用对齐的时候子对象需要考虑主屏幕的范围, 当两个变量宽度使用的时候外部对齐的下面三个实际的样式是一样的 ![image 20240528101048804](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405281010849.png) ### 样式 用于设置一个部件的外观, 优化显示的界面以及和用户进行交互 #### 如何添加 + 添加普通的样式 ```c static lv_style_t style; //这一个一定要是一个静态的变量 lv_style_init(&style); lv_style_set_bg_color(&style, lv_color_hex(0xf4b183)); //设置背景颜色 lv_obj_t *obj lv_obj_create(lv_scr_act()); lv_obj_add_style(obj, &style, LV_STATE_DEFAULT); //设置部件的样式, 第三个参数是什么状态的时候触发, 以及应用的部分 ``` ![image 20240528123057321](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405281230419.png) + 添加一个本地的样式 ```c lv_obj_t *obj lv_obj_create(lv_scr_act()); lv_obj_set_style_bg_color(obj, lv_color_hex(0xf4b183), LV_PART_MAIN); ``` #### 生效的时间 ```c enum { LV_STATE_DEFAULT 0x0000, //默认状态 LV_STATE_CHECKED 0x0001, //切换或者选中模式 LV_STATE_FOCUSED 0x0002, //通过键盘, 编码器聚焦或通过触摸板鼠标单击 LV_STATE_FOCUS_KEY 0x0004, //键盘, 编码器聚焦 LV_STATE_EDITED 0x0008, //编码器编辑 LV_STATE_HOVERED 0x0010, //鼠标悬停 LV_STATE_PRESSED 0x0020, //已按下 LV_STATE_SCROLLED 0x0040, //滚动状态 LV_STATE_DISABLED 0x0080, //禁用状态 LV_STATE_USER_1 0x1000, LV_STATE_USER_2 0x2000, LV_STATE_USER_3 0x4000, LV_STATE_USER_4 0x8000, LV_STATE_ANY 0xFFFF, /**< Special value can be used in some functions to target all states*/ }; ``` > 这里的状态有的需要进行添加 > > ```c > void lv_obj_add_state(lv_obj_t * obj, lv_state_t state); > void lv_obj_clear_state(lv_obj_t * obj, lv_state_t state) > ``` #### 有的属性 ```c void lv_style_set_width(lv_style_t * style, lv_coord_t value); //宽度 void lv_style_set_min_width(lv_style_t * style, lv_coord_t value); void lv_style_set_max_width(lv_style_t * style, lv_coord_t value); void lv_style_set_height(lv_style_t * style, lv_coord_t value); void lv_style_set_min_height(lv_style_t * style, lv_coord_t value); //最大值 void lv_style_set_max_height(lv_style_t * style, lv_coord_t value); void lv_style_set_x(lv_style_t * style, lv_coord_t value); //设置位置 void lv_style_set_y(lv_style_t * style, lv_coord_t value); void lv_style_set_align(lv_style_t * style, lv_align_t value); //对齐 void lv_style_set_transform_width(lv_style_t * style, lv_coord_t value); //两遍同时变宽 void lv_style_set_transform_height(lv_style_t * style, lv_coord_t value); //同时变高 void lv_style_set_translate_x(lv_style_t * style, lv_coord_t value); //基于现有的位置移动 void lv_style_set_translate_y(lv_style_t * style, lv_coord_t value); void lv_style_set_transform_zoom(lv_style_t * style, lv_coord_t value); //缩放, 256为不缩放 void lv_style_set_transform_angle(lv_style_t * style, lv_coord_t value); //旋转角度 旋转值 / 10 void lv_style_set_pad_top(lv_style_t * style, lv_coord_t value); //填充属性, 设置和父对象的距离 void lv_style_set_pad_bottom(lv_style_t * style, lv_coord_t value); void lv_style_set_pad_left(lv_style_t * style, lv_coord_t value); void lv_style_set_pad_right(lv_style_t * style, lv_coord_t value); void lv_style_set_pad_row(lv_style_t * style, lv_coord_t value); //行列填充, 布局使用 void lv_style_set_pad_column(lv_style_t * style, lv_coord_t value); //栏间距 void lv_style_set_bg_color(lv_style_t * style, lv_color_t value); //背景颜色 void lv_style_set_bg_color_filtered(lv_style_t * style, lv_color_t value); //背景过滤颜色 void lv_style_set_bg_opa(lv_style_t * style, lv_opa_t value); //背景透明度 void lv_style_set_bg_grad_color(lv_style_t * style, lv_color_t value); //背景颜色渐变 void lv_style_set_bg_grad_color_filtered(lv_style_t * style, lv_color_t value); void lv_style_set_bg_grad_dir(lv_style_t * style, lv_grad_dir_t value); //设置渐变的方向 void lv_style_set_bg_main_stop(lv_style_t * style, lv_coord_t value); //设置渐变的起始位置, 0 255 void lv_style_set_bg_grad_stop(lv_style_t * style, lv_coord_t value); //设置渐变的终点 void lv_style_set_bg_grad(lv_style_t * style, const lv_grad_dsc_t * value); void lv_style_set_bg_dither_mode(lv_style_t * style, lv_dither_mode_t value); void lv_style_set_bg_img_src(lv_style_t * style, const void * value); //背景图片 void lv_style_set_bg_img_opa(lv_style_t * style, lv_opa_t value); //背景图片的透明度 void lv_style_set_bg_img_recolor(lv_style_t * style, lv_color_t value); //背景图片重新着色, 默认透明 void lv_style_set_bg_img_recolor_filtered(lv_style_t * style, lv_color_t value); void lv_style_set_bg_img_recolor_opa(lv_style_t * style, lv_opa_t value); //设置着色的透明度 void lv_style_set_bg_img_tiled(lv_style_t * style, bool value); //背景图片平铺(这一个图片重复并覆盖背景) void lv_style_set_border_color(lv_style_t * style, lv_color_t value); //边框颜色 void lv_style_set_border_color_filtered(lv_style_t * style, lv_color_t value); void lv_style_set_border_opa(lv_style_t * style, lv_opa_t value); //边框透明度 void lv_style_set_border_width(lv_style_t * style, lv_coord_t value); //边框的宽度 void lv_style_set_border_side(lv_style_t * style, lv_border_side_t value); //边框的边的选择 void lv_style_set_border_post(lv_style_t * style, bool value); // 设置边框和子对象的绘制顺序 void lv_style_set_outline_width(lv_style_t * style, lv_coord_t value); // 轮廓的宽度 void lv_style_set_outline_color(lv_style_t * style, lv_color_t value); //轮廓的颜色 void lv_style_set_outline_color_filtered(lv_style_t * style, lv_color_t value); void lv_style_set_outline_opa(lv_style_t * style, lv_opa_t value); //轮廓的透明度 void lv_style_set_outline_pad(lv_style_t * style, lv_coord_t value); //轮廓的间隙属性 void lv_style_set_shadow_width(lv_style_t * style, lv_coord_t value); //阴影属性 void lv_style_set_shadow_ofs_x(lv_style_t * style, lv_coord_t value); //阴影在x轴的偏移 void lv_style_set_shadow_ofs_y(lv_style_t * style, lv_coord_t value); //阴影在y轴的偏移 void lv_style_set_shadow_spread(lv_style_t * style, lv_coord_t value); //扩展 void lv_style_set_shadow_color(lv_style_t * style, lv_color_t value); //颜色 void lv_style_set_shadow_color_filtered(lv_style_t * style, lv_color_t value); void lv_style_set_shadow_opa(lv_style_t * style, lv_opa_t value); //透明度 void lv_style_set_img_opa(lv_style_t * style, lv_opa_t value); //透明度 void lv_style_set_img_recolor(lv_style_t * style, lv_color_t value); //重新着色 void lv_style_set_img_recolor_filtered(lv_style_t * style, lv_color_t value); void lv_style_set_img_recolor_opa(lv_style_t * style, lv_opa_t value); //透明度 void lv_style_set_line_width(lv_style_t * style, lv_coord_t value); //线条的宽度 void lv_style_set_line_dash_width(lv_style_t * style, lv_coord_t value); //线条的端点的属性 void lv_style_set_line_dash_gap(lv_style_t * style, lv_coord_t value); //设置虚线的宽度 void lv_style_set_line_rounded(lv_style_t * style, bool value); //线的头部 void lv_style_set_line_color(lv_style_t * style, lv_color_t value); //线的颜色 void lv_style_set_line_color_filtered(lv_style_t * style, lv_color_t value); void lv_style_set_line_opa(lv_style_t * style, lv_opa_t value); //线的透明度 void lv_style_set_arc_width(lv_style_t * style, lv_coord_t value); //圆弧的宽度 void lv_style_set_arc_rounded(lv_style_t * style, bool value); //圆弧的头部是不是圆头 void lv_style_set_arc_color(lv_style_t * style, lv_color_t value); //设置颜色 void lv_style_set_arc_color_filtered(lv_style_t * style, lv_color_t value); void lv_style_set_arc_opa(lv_style_t * style, lv_opa_t value); //透明度 void lv_style_set_arc_img_src(lv_style_t * style, const void * value); void lv_style_set_text_color(lv_style_t * style, lv_color_t value); //文本 void lv_style_set_text_color_filtered(lv_style_t * style, lv_color_t value); void lv_style_set_text_opa(lv_style_t * style, lv_opa_t value); void lv_style_set_text_font(lv_style_t * style, const lv_font_t * value); //设置字体 void lv_style_set_text_letter_space(lv_style_t * style, lv_coord_t value); //文本间的间隙 void lv_style_set_text_line_space(lv_style_t * style, lv_coord_t value); //行间距 void lv_style_set_text_decor(lv_style_t * style, lv_text_decor_t value); //设置下划线的删除 void lv_style_set_text_align(lv_style_t * style, lv_text_align_t value); //设置对齐属性 void lv_style_set_radius(lv_style_t * style, lv_coord_t value); //圆角的属性 void lv_style_set_clip_corner(lv_style_t * style, bool value); //吧圆角上的元素剪切 void lv_style_set_opa(lv_style_t * style, lv_opa_t value); //透明度 void lv_style_set_color_filter_dsc(lv_style_t * style, const lv_color_filter_dsc_t * value); //填充颜色 void lv_style_set_color_filter_opa(lv_style_t * style, lv_opa_t value); void lv_style_set_anim_time(lv_style_t * style, uint32_t value); //动画 void lv_style_set_anim_speed(lv_style_t * style, uint32_t value); void lv_style_set_transition(lv_style_t * style, const lv_style_transition_dsc_t * value); //设置过渡 void lv_style_set_blend_mode(lv_style_t * style, lv_blend_mode_t value); //混合模式 void lv_style_set_layout(lv_style_t * style, uint16_t value); //布局 void lv_style_set_base_dir(lv_style_t * style, lv_base_dir_t value); //设置方向 ``` [Style properties — LVGL documentation](https://docs.lvgl.io/master/overview/style props.html) + size 大小 + position 位置 + background 背景 + outline 轮廓 + border 边框 + shadow 阴影 + others 其他 ![image 20240528131108181](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405281311256.png) #### 边框 ```c lv_obj_t *obj lv_obj_create(lv_scr_act()); lv_obj_set_align(obj, LV_ALIGN_CENTER); lv_obj_set_style_border_color(obj, lv_color_hex(0x2580FF), LV_STATE_DEFAULT); ``` ![image 20240528131324808](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405281313878.png) ```c lv_obj_set_style_border_width(obj, 6, LV_STATE_DEFAULT); //边框宽度 lv_obj_set_style_border_opa(obj, LV_OPA_20, LV_STATE_DEFAULT); //边框透明度, 0 255, 宏是百分比 ``` ![image 20240528131659042](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405281316113.png) ```c lv_obj_set_style_border_color(obj, lv_color_hex(0x2580FF), LV_STATE_DEFAULT); lv_obj_set_style_border_width(obj, 6, LV_STATE_DEFAULT); //边框宽度 lv_obj_set_style_border_opa(obj, LV_OPA_20, LV_STATE_DEFAULT); //边框透明度, 0 255, 宏是百分比 lv_obj_set_style_outline_color(obj, lv_color_hex(0x005312), LV_STATE_DEFAULT); lv_obj_set_style_outline_width(obj, 6, LV_STATE_DEFAULT); //边框宽度 lv_obj_set_style_outline_opa(obj, LV_OPA_20, LV_STATE_DEFAULT); //边框透明度, 0 255, 宏是百分比 ``` ![image 20240528131921807](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405281319886.png) #### 渐变 ```c static lv_style_t style; lv_style_init( &style ); lv_style_set_radius( &style, 20 ); lv_style_set_bg_opa( &style, LV_OPA_COVER ); //设置背景透明度 lv_style_set_bg_color( &style, lv_color_hex(0xff0000) ); //设置背景色 lv_style_set_bg_grad_color( &style, lv_color_hex( 0x0000ff ) ); //设置过度 lv_style_set_bg_grad_dir( &style, LV_GRAD_DIR_HOR ); //设置方向 lv_obj_t* btn lv_btn_create( lv_scr_act() ); lv_obj_set_size( btn, 320, 120 ); lv_obj_center( btn ); lv_obj_add_style( btn, &style, LV_PART_MAIN ); ``` ![image 20240529122053095](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405291220203.png) #### 某一个部分 ```c enum { LV_PART_MAIN 0x000000, /**< A background like rectangle 主体*/ LV_PART_SCROLLBAR 0x010000, /**< The scrollbar(s) 滚动条*/ LV_PART_INDICATOR 0x020000, /**< Indicator, e.g. for slider, bar, switch, or the tick box of the checkbox 指示器(当前值)*/ LV_PART_KNOB 0x030000, /**< Like handle to grab to adjust the value 手柄或者旋钮(调整参数)*/ LV_PART_SELECTED 0x040000, /**< Indicate the currently selected option or section 选项框, 指示当前的选项*/ LV_PART_ITEMS 0x050000, /**< Used if the widget has multiple similar elements (e.g. table cells) 相似的元素, 单元格*/ LV_PART_TICKS 0x060000, /**< Ticks on scale e.g. for a chart or meter 可读*/ LV_PART_CURSOR 0x070000, /**< Mark a specific place e.g. for text area's cursor or on a chart 光标*/ LV_PART_CUSTOM_FIRST 0x080000, /**< Extension point for custom widgets*/ LV_PART_ANY 0x0F0000, /**< Special value can be used in some functions to target all parts*/ }; ``` > ![image 20240528231342976](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405282313066.png) 可以在手册里面查找某一个部件的组成部分 ![image 20240528231931398](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405282319496.png) ![image 20240528233308027](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405282333119.png) ![image 20240528233251301](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405282332467.png) > 这一个在设置的时候不能使用按位或的方式 ```c lv_obj_t *slider lv_slider_create(lv_scr_act()); lv_obj_set_align(slider, LV_ALIGN_CENTER); lv_obj_set_style_bg_color(slider, lv_color_hex(0x00ff00), LV_STATE_DEFAULT LV_PART_INDICATOR); ``` ## 事件 lvgl里面发生用户感兴趣的事件的时候, 可以触发回调函数, 执行相关的函数 ### 添加以及删除 ```c struct _lv_event_dsc_t * lv_obj_add_event_cb(lv_obj_t * obj, lv_event_cb_t event_cb, lv_event_code_t filter,void * user_data); bool lv_obj_remove_event_cb(lv_obj_t * obj, lv_event_cb_t event_cb); ``` > event_cb: 回调函数 > > filter: 事件的类型 > > user_data: 用户的数据 > > ```c > typedef void (*lv_event_cb_t)(lv_event_t * e); > typedef struct _lv_event_t { > struct _lv_obj_t * target; > struct _lv_obj_t * current_target; > lv_event_code_t code; > void * user_data; > void * param; > struct _lv_event_t * prev; > uint8_t deleted : 1; > uint8_t stop_processing : 1; > uint8_t stop_bubbling : 1; > } lv_event_t; > ``` > > [Events — LVGL documentation](https://docs.lvgl.io/master/overview/event.html) ### 事件类型 + Input device events 输入事件 + Drawing events 绘制事件 + Other events 其他事件 + Special events 特殊事件 + Custom events 用户自定义事件 ```c typedef enum { LV_EVENT_ALL 0, /** Input device events*/ LV_EVENT_PRESSED, /**< The object has been pressed 按键按下*/ LV_EVENT_PRESSING, /**< The object is being pressed (called continuously while pressing) 按键按压的时候, 一直触发*/ LV_EVENT_PRESS_LOST, /**< The object is still being pressed but slid cursor/finger off of the object 按下但是光标移动*/ LV_EVENT_SHORT_CLICKED, /**< The object was pressed for a short period of time, then released it. Not called if scrolled. 短按, 滚动不触发*/ LV_EVENT_LONG_PRESSED, /**< Object has been pressed for at least `long_press_time`. Not called if scrolled. 长按, 滚动不触发, 只触发一次*/ LV_EVENT_LONG_PRESSED_REPEAT, /**< Called after `long_press_time` in every `long_press_repeat_time` ms. Not called if scrolled. */ LV_EVENT_CLICKED, /**< Called on release if not scrolled (regardless to long press)*/ LV_EVENT_RELEASED, /**< Called in every cases when the object has been released 被释放*/ LV_EVENT_SCROLL_BEGIN, /**< Scrolling begins 滚动*/ LV_EVENT_SCROLL_END, /**< Scrolling ends*/ LV_EVENT_SCROLL, /**< Scrolling*/ LV_EVENT_GESTURE, /**< A gesture is detected. Get the gesture with `lv_indev_get_gesture_dir(lv_indev_get_act());` */ LV_EVENT_KEY, /**< A key is sent to the object. Get the key with `lv_indev_get_key(lv_indev_get_act());`*/ LV_EVENT_FOCUSED, /**< The object is focused*/ LV_EVENT_DEFOCUSED, /**< The object is defocused*/ LV_EVENT_LEAVE, /**< The object is defocused but still selected*/ LV_EVENT_HIT_TEST, /**< Perform advanced hit testing*/ /** Drawing events*/ LV_EVENT_COVER_CHECK, /**< Check if the object fully covers an area. The event parameter is `lv_cover_check_info_t *`.*/ LV_EVENT_REFR_EXT_DRAW_SIZE, /**< Get the required extra draw area around the object (e.g. for shadow). The event parameter is `lv_coord_t *` to store the size.*/ LV_EVENT_DRAW_MAIN_BEGIN, /**< Starting the main drawing phase*/ LV_EVENT_DRAW_MAIN, /**< Perform the main drawing*/ LV_EVENT_DRAW_MAIN_END, /**< Finishing the main drawing phase*/ LV_EVENT_DRAW_POST_BEGIN, /**< Starting the post draw phase (when all children are drawn)*/ LV_EVENT_DRAW_POST, /**< Perform the post draw phase (when all children are drawn)*/ LV_EVENT_DRAW_POST_END, /**< Finishing the post draw phase (when all children are drawn)*/ LV_EVENT_DRAW_PART_BEGIN, /**< Starting to draw a part. The event parameter is `lv_obj_draw_dsc_t *`. */ LV_EVENT_DRAW_PART_END, /**< Finishing to draw a part. The event parameter is `lv_obj_draw_dsc_t *`. */ /** Special events*/ LV_EVENT_VALUE_CHANGED, /**< The object's value has changed (i.e. slider moved)*/ LV_EVENT_INSERT, /**< A text is inserted to the object. The event data is `char *` being inserted.*/ LV_EVENT_REFRESH, /**< Notify the object to refresh something on it (for the user)*/ LV_EVENT_READY, /**< A process has finished*/ LV_EVENT_CANCEL, /**< A process has been cancelled */ /** Other events*/ LV_EVENT_DELETE, /**< Object is being deleted*/ LV_EVENT_CHILD_CHANGED, /**< Child was removed, added, or its size, position were changed */ LV_EVENT_CHILD_CREATED, /**< Child was created, always bubbles up to all parents*/ LV_EVENT_CHILD_DELETED, /**< Child was deleted, always bubbles up to all parents*/ LV_EVENT_SCREEN_UNLOAD_START, /**< A screen unload started, fired immediately when scr_load is called*/ LV_EVENT_SCREEN_LOAD_START, /**< A screen load started, fired when the screen change delay is expired*/ LV_EVENT_SCREEN_LOADED, /**< A screen was loaded*/ LV_EVENT_SCREEN_UNLOADED, /**< A screen was unloaded*/ LV_EVENT_SIZE_CHANGED, /**< Object coordinates/size have changed*/ LV_EVENT_STYLE_CHANGED, /**< Object's style has changed*/ LV_EVENT_LAYOUT_CHANGED, /**< The children position has changed due to a layout recalculation*/ LV_EVENT_GET_SELF_SIZE, /**< Get the internal size of a widget*/ _LV_EVENT_LAST, /** Number of default events*/ LV_EVENT_PREPROCESS 0x80, /** This is a flag that can be set with an event so it's processed before the class default event processing */ } lv_event_code_t; ``` ### 添加事件 ```c static void event_cb(lv_event_t * obj){ lv_obj_t * label lv_label_create(lv_scr_act()); lv_label_set_text(label, \"Hello world!\"); } void my_gui(void){ lv_obj_t * obj1 lv_obj_create(lv_scr_act()); lv_obj_add_event_cb(obj1, event_cb, LV_EVENT_CLICKED, NULL); } ``` > ```c > lv_event_code_t code lv_event_get_code(obj);//获取这一个事件的类型 > if(code LV_EVENT_CLICKED){ > lv_obj_t * label lv_label_create(lv_scr_act()); > lv_label_set_text(label, \"Hello world!\"); > } > ``` > > ![image 20240529221328542](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405292213670.png) ## 滚动属性 子对象超出父对象的范围区域，则该父对象会自动开启滚动条 ### 设置模式 ```c void lv_obj_set_scrollbar_mode(lv_obj_t * obj, lv_scrollbar_mode_t mode); ``` ```c /** Scrollbar modes: shows when should the scrollbars be visible*/ enum { LV_SCROLLBAR_MODE_OFF, /**< Never show scrollbars*/ LV_SCROLLBAR_MODE_ON, /**< Always show scrollbars*/ LV_SCROLLBAR_MODE_ACTIVE, /**< Show scroll bars when object is being scrolled*/ LV_SCROLLBAR_MODE_AUTO, /**< Show scroll bars when the content is large enough to be scrolled*/ }; typedef uint8_t lv_scrollbar_mode_t; ``` ### 可以触发的事件 ```c LV_EVENT_SCROLL_BEGIN, /**< Scrolling begins 滚动*/ LV_EVENT_SCROLL_END, /**< Scrolling ends*/ LV_EVENT_SCROLL, /**< Scrolling*/ ``` ### 设置滚动方向 ```c void lv_obj_set_scroll_dir(lv_obj_t * obj, lv_dir_t dir); ``` ```c enum { LV_DIR_NONE 0x00, LV_DIR_LEFT (1 << 0), LV_DIR_RIGHT (1 << 1), LV_DIR_TOP (1 << 2), LV_DIR_BOTTOM (1 << 3), LV_DIR_HOR LV_DIR_LEFT LV_DIR_RIGHT, LV_DIR_VER LV_DIR_TOP LV_DIR_BOTTOM, LV_DIR_ALL LV_DIR_HOR LV_DIR_VER, }; ``` ### 其他属性 可以通过`lv_obj_add/clear_flag`进行设置 #### 滚动传递 子对象到达父对象的边缘的时候, 是不是会把滚动的属性传递的父对象, LV_OBJ_FLAG_SCROLL_CHAIN_HOR/VER进行启用 #### 滚动惯性 LV_OBJ_FLAG_SCROLL_MOMENTUM这一个属性进行启用 ### 弹性滚动 超出以后会有一个回弹 ## 动画 [LVGL库入门教程 动画 冰封残烛 博客园 (cnblogs.com)](https://www.cnblogs.com/frozencandles/p/16422019.html) ### 过渡动画 在一个对象的属性发生变化的时候的动画, 需要使用lv_style_transition_dsc_t这一个属性进行设置 ```c typedef struct { const lv_style_prop_t * props; /**< An array with the properties to animate. 需要过度的属性*/ #if LV_USE_USER_DATA void * user_data; /**< A custom user data that will be passed to the animation's user_data */ #endif lv_anim_path_cb_t path_xcb; /**< A path for the animation. 过渡动画*/ uint32_t time; /**< Duration of the transition in [ms] 过度的时间*/ uint32_t delay; /**< Delay before the transition in [ms] 过度的延迟*/ } lv_style_transition_dsc_t; ``` ```c void lv_style_transition_dsc_init( lv_style_transition_dsc_t* tr, const lv_style_prop_t props[], lv_anim_path_cb_t path_cb, uint32_t time, uint32_t delay, void* user_data); ``` > 第一个参数需要提供被初始化的过渡动画结构，第二个参数数组和字符串一样需要以 `0` 结尾。 > > ```c > lv_obj_t * obj1 lv_obj_create(lv_scr_act()); > lv_obj_add_event_cb(obj1, event_cb, LV_EVENT_CLICKED, NULL); > > static lv_style_transition_dsc_t trans; > static const lv_style_prop_t trans_props[] { > LV_STYLE_WIDTH, LV_STYLE_HEIGHT, LV_STYLE_BG_COLOR, 0, > }; > lv_style_transition_dsc_init(&trans, trans_props, lv_anim_path_ease_in_out, 500, 0, NULL); > > static lv_style_t style_trans; > lv_style_init(&style_trans); > lv_style_set_transition(&style_trans, &trans); > > lv_style_set_bg_color(&style_trans, lv_palette_main(LV_PALETTE_RED)); > lv_style_set_width(&style_trans, 150); > lv_style_set_height(&style_trans, 60); > lv_obj_add_style(obj1, &style_trans, LV_STATE_PRESSED); > ``` > > ![image 20240529225228906](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405292252015.png) ![image 20240529224918264](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405292249384.png) ### 通用动画 ①定义一个 lv_anim_t 变量。 ② 调用函数 lv_anim_init 初始化动画。 ③ 调用函数 lv_anim_set_exec_cb 设置动画回调函数。 ④ 调用函数 lv_anim_set_var 设置动画执行的目标。 ⑤ 调用函数 lv_anim_set_time 设置动画时间长度。 ⑥ 调用函数 lv_anim_set_values 设置起始值和结束值。 ⑦ 调用函数 lv_anim_start 开始动画。 ![](https://img2022.cnblogs.com/blog/2829890/202206/2829890 20220629090926155 1644992550.gif) ```c lv_obj_t * obj1 lv_obj_create(lv_scr_act()); lv_anim_t anim; lv_anim_init(&anim); lv_anim_set_var(&anim, obj1); //设置对象 lv_anim_set_exec_cb(&anim, (lv_anim_exec_xcb_t)lv_obj_set_y); //设置回调函数 lv_anim_set_values(&anim, 100, 100); //设置起始位置, 结束位置 lv_anim_set_path_cb(&anim, lv_anim_path_bounce); lv_anim_set_time(&anim, 1000); lv_anim_set_delay(&anim, 1000); lv_anim_start(&anim); ``` path_cb 设置动画变化效果 有以下内置 path 功能： lv_anim_path_linear 线性动画 + lv_anim_path_step 在最后一步更改 + lv_anim_path_ease_in 开始缓慢 + lv_anim_path_ease_out 最后缓慢 + lv_anim_path_ease_in_out 在开始和结束时都很缓慢 + lv_anim_path_overshoot 超出最终值 + lv_anim_path_bounce 从最终值反弹一点（比如撞到墙） ```c static void anim_progress_load(void *obj, int32_t v) { lv_bar_set_start_value(obj, v, LV_ANIM_ON); lv_bar_set_value(obj, 20 + v, LV_ANIM_ON); } lv_obj_t *bar lv_bar_create(lv_scr_act()); lv_bar_set_mode(bar, LV_BAR_MODE_RANGE); static lv_style_t style_bg; static lv_style_t style_indic; //设置样式 lv_style_init(&style_bg); lv_style_set_border_color(&style_bg, lv_palette_main(LV_PALETTE_BLUE)); lv_style_set_border_width(&style_bg, 2); lv_style_set_pad_all(&style_bg, 6); lv_style_set_radius(&style_bg, 6); lv_style_set_anim_time(&style_bg, 1000); lv_style_init(&style_indic); lv_style_set_bg_opa(&style_indic, LV_OPA_COVER); lv_style_set_bg_color(&style_indic, lv_palette_main(LV_PALETTE_BLUE)); lv_style_set_radius(&style_indic, 3); lv_obj_remove_style_all(bar); lv_obj_add_style(bar, &style_bg, 0); lv_obj_add_style(bar, &style_indic, LV_PART_INDICATOR); lv_obj_set_size(bar, 200, 20); lv_obj_align(bar, LV_ALIGN_CENTER, 0, 0); //设置动画 lv_anim_t anim; lv_anim_init(&anim); lv_anim_set_var(&anim, bar); lv_anim_set_exec_cb(&anim, anim_progress_load); //设置回调函数 lv_anim_set_values(&anim, 0, 80); lv_anim_set_path_cb(&anim, lv_anim_path_linear); lv_anim_set_time(&anim, 1500); lv_anim_set_delay(&anim, 0); lv_anim_set_playback_time(&anim, 1500); lv_anim_set_repeat_count(&anim, LV_ANIM_REPEAT_INFINITE); ``` ### 时间线 ```c lv_anim_timeline_t* anim_timeline lv_anim_timeline_create(); lv_anim_timeline_add(anim_timeline, 0, &anim_axis); lv_anim_timeline_add(anim_timeline, 100, &anim_obj_01); lv_anim_timeline_add(anim_timeline, 1100, &anim_obj_02); lv_anim_timeline_add(anim_timeline, 2100, &anim_obj_03); lv_anim_timeline_add(anim_timeline, 300, &anim_label_01); lv_anim_timeline_add(anim_timeline, 1300, &anim_label_02); lv_anim_timeline_add(anim_timeline, 2300, &anim_label_03); ``` > `lv_anim_timeline_start(anim_timeline);`启动这一个时间线"},"/note/嵌入式/第三方移植/lvgl/2024-5-26-04配置文件.html":{"title":"配置文件","content":" layout: post title: \"配置文件\" date: 2024 1 11 15:39:08 +0800 tags: stm32 lvgl # 配置文件 正点原子翻译版本 ```c #if 1 /* 设置为1，以启用内容 */ #ifndef LV_CONF_H #define LV_CONF_H #include <stdint.h> /********************************************************************************* 颜色设置 ***********************************************************************************/ /* 颜色深度:1(1字节每像素)，8(RGB332)， 16(RGB565)， 32(ARGB8888) */ #define LV_COLOR_DEPTH 16 /* 交换2个字节的RGB565颜色，在显示接口是8位的时候有用(例如SPI) */ #define LV_COLOR_16_SWAP 0 /* 1：启用屏幕透明度。 * 这对于OSD菜单、视频播放器和重叠的GUI有用。 * 需要32位深度的颜色，并且屏幕的' bg_opa '应该设置为非LV_OPA_COVER值 */ #define LV_COLOR_SCREEN_TRANSP 0 /* 调整颜色混合功能四舍五入。gpu可能会以不同的方式计算颜色混合。 * 0：向下舍入，64：从 x.75向上舍入，128：从一半向上舍入，192：从x.25 向上舍入，254：向上舍入 */ #define LV_COLOR_MIX_ROUND_OFS (LV_COLOR_DEPTH 32 ? 0: 128) /* 如果使用色度键，将不会绘制这种颜色的图像像素，类似于抠掉绿幕背景的效果 */ #define LV_COLOR_CHROMA_KEY lv_color_hex(0x00ff00) /* 纯绿色 */ /********************************************************************************* 内存设置 ***********************************************************************************/ #define LV_MEM_CUSTOM 0 /* 0：使用LVGL自带的内存管理，1：使用自研内存管理 */ #if LV_MEM_CUSTOM 0 /* 使用LVGL自带内存管理 */ #define LV_MEM_SIZE (48U * 1024U) /* 所管理的空间大小由这里分配，单位：字节 */ #define LV_MEM_ADR 0 /* 0：使用大数组创建内存池；其他：使用地址段来创建内存池 */ #if LV_MEM_ADR 0 /* 使用内存分配函数来创建LVGL的内存池 */ // #define LV_MEM_POOL_INCLUDE your_alloc_library /* 头文件路径 */ // #define LV_MEM_POOL_ALLOC your_alloc /* 内存分配函数 */ #endif #else /* 使用自研内存管理 */ #define LV_MEM_CUSTOM_INCLUDE <stdlib.h> /* 头文件路径 */ #define LV_MEM_CUSTOM_ALLOC malloc /* 内存分配函数 */ #define LV_MEM_CUSTOM_FREE free /* 内存释放函数 */ #define LV_MEM_CUSTOM_REALLOC realloc /* 内存重新分配函数 */ #endif /* 在渲染和其他内部处理机制期间使用的中间内存缓冲区的数量。 * 如果没有足够的缓冲区，你会看到一个错误日志信息 */ #define LV_MEM_BUF_MAX_NUM 16 /* 使用标准的 `memcpy` 和 `memset` 代替LVGL自己的函数 */ #define LV_MEMCPY_MEMSET_STD 0 /********************************************************************************* HAL 设置 ***********************************************************************************/ /* 默认的显示刷新周期。LVGL按这个周期重绘修改过的区域 一般5~30都可以*/ #define LV_DISP_DEF_REFR_PERIOD 5 /*[ms]*/ /* 输入设备的读取周期(以毫秒为单位) */ #define LV_INDEV_DEF_READ_PERIOD 5 /*[ms]*/ /* 0：手动调用 `lv_tick_inc()`以提供时钟源，1：使用自定义时钟源 */ #define LV_TICK_CUSTOM 1 #if LV_TICK_CUSTOM #define LV_TICK_CUSTOM_INCLUDE \"FreeRTOS.h\" /* 系统时间函数头 */ #define LV_TICK_CUSTOM_SYS_TIME_EXPR (xTaskGetTickCount()) /* 计算系统当前时间的表达式(以毫秒为单位) */ #endif /* 默认每英寸的像素数量，用于初始化默认大小（不是很重要），例如小部件大小，样式填充 */ #define LV_DPI_DEF 130 /* [像素/英寸] */ /********************************************************************************* 特征选项 ***********************************************************************************/ /* * 1. 绘制 * */ /* 启用复杂的绘制引擎 * 需要绘制阴影，梯度，圆角，圆，弧，斜线，图像转换或任何蒙版 */ #define LV_DRAW_COMPLEX 1 #if LV_DRAW_COMPLEX ! 0 /* 允许缓冲一些阴影计算 * LV_SHADOW_CACHE_SIZE为最大的缓冲大小，缓冲大小为 `阴影宽度 + 半径` * 将会有 LV_SHADOW_CACHE_SIZE^2 的内存开销 */ #define LV_SHADOW_CACHE_SIZE 0 /* 设置最大缓存循环数据的数量。 * 保存1/4圆的周长用于抗锯齿 * 半径*每个圆使用4个字节(保存最常用的半径) * 0:禁用缓存 */ #define LV_CIRCLE_CACHE_SIZE 4 #endif /* 默认图像缓存大小。图像缓存保持图像打开。 * 如果只使用内置的图像格式，缓存没有真正的优势。(即没有添加新的图像解码器) * 复杂的图像解码器(如PNG或JPG)缓存可以保存连续打开/解码的图像。然而，打开的图像会消耗额外的RAM。 * 0:禁用缓存 */ #define LV_IMG_CACHE_DEF_SIZE 0 /* 每个梯度允许停止的数量。 * 每个额外的停止增加(sizeof(lv_color_t) + 1)字节 */ #define LV_GRADIENT_MAX_STOPS 2 /* 默认梯度缓冲区大小。 * 当LVGL计算梯度“映射”，它可以将它们保存到缓存，以避免再次计算它们。 * LV_GRAD_CACHE_DEF_SIZE设置缓存的大小(以字节为单位)。 * 如果缓存太小，则只在需要绘制时才分配。 * 0表示没有缓存*/ #define LV_GRAD_CACHE_DEF_SIZE 0 /* 允许抖动渐变(在有限的颜色深度显示上实现视觉平滑的颜色渐变) * LV_DITHER_GRADIENT意味着在对象的渲染表面中再分配一两行 * 如果使用错误扩散，内存消耗的增加为(32位*对象宽度)加上24位*对象宽度 */ #define LV_DITHER_GRADIENT 0 #if LV_DITHER_GRADIENT /* 增加了错误扩散抖动的支持。 * 错误扩散抖动得到了更好的视觉效果，但在绘制时意味着更多的CPU和内存消耗。内存消耗增加(24位*对象的宽度) */ #define LV_DITHER_ERROR_DIFFUSION 0 #endif /* 为旋转分配的最大缓冲区大小。仅在显示驱动程序中启用软件旋转时使用 */ #define LV_DISP_ROT_MAX_BUF (10*1024) /* * 2. GPU * */ /* 使用STM32的DMA2D(又名Chrom Art) GPU */ #define LV_USE_GPU_STM32_DMA2D 0 #if LV_USE_GPU_STM32_DMA2D /* 必须定义包括目标处理器的CMSIS头的路径，如：\"stm32f769xx.h\"或\"stm32f429xx.h\"*/ #define LV_GPU_DMA2D_CMSIS_INCLUDE \"stm32f429xx.h\" #endif /* 使用NXP的PXP GPU iMX RTxxx平台 */ #define LV_USE_GPU_NXP_PXP 0 #if LV_USE_GPU_NXP_PXP /* 1：为 PXP（lv_gpu_nxp_pxp_osa.c）添加默认裸机和 FreeRTOS 中断处理例程 * 并在lv_init()期间自动调用 lv_gpu_nxp_pxp_init()。请注意，符号SDK_OS_FREE_RTOS * 必须定义才能使用 FreeRTOS OSA，否则选择裸机实现。 * 0：lv_gpu_nxp_pxp_init()必须在lv_init() 之前手动调用 */ #define LV_USE_GPU_NXP_PXP_AUTO_INIT 0 #endif /* 使用NXP的VG Lite GPU iMX RTxxx平台 */ #define LV_USE_GPU_NXP_VG_LITE 0 /* 使用SDL渲染器API */ #define LV_USE_GPU_SDL 0 #if LV_USE_GPU_SDL #define LV_GPU_SDL_INCLUDE_PATH <SDL2/SDL.h> /* 纹理缓存大小，默认8MB */ #define LV_GPU_SDL_LRU_SIZE (1024 * 1024 * 8) /* 用于蒙版绘制的自定义混合模式，如果需要使用较旧的SDL2库，请禁用 */ #define LV_GPU_SDL_CUSTOM_BLEND_MODE (SDL_VERSION_ATLEAST(2, 0, 6)) #endif /* * 3. 日志 * */ /* 启用日志模块 */ #define LV_USE_LOG 1 #if LV_USE_LOG /* 如何添加重要日志: * LV_LOG_LEVEL_TRACE 记录详细信息（大量日志，不建议） * LV_LOG_LEVEL_INFO 记录重要事件 * LV_LOG_LEVEL_WARN 记录一些不想发生的事情（没有引起问题） * LV_LOG_LEVEL_ERROR 记录只有在系统可能出现故障时才会出现关键问题 * LV_LOG_LEVEL_USER 仅用户自己添加的日志 * LV_LOG_LEVEL_NONE 不要记录任何内容 */ #define LV_LOG_LEVEL LV_LOG_LEVEL_WARN /* * 1: 使用'printf'打印日志; * 0: 用户需要用' lv_log_register_print_cb() '注册回调函数 */ #define LV_LOG_PRINTF 1 /* 在产生大量日志的模块中启用/禁用LV_LOG_TRACE 这一个是具体的日志打印*/ #define LV_LOG_TRACE_MEM 1 #define LV_LOG_TRACE_TIMER 1 #define LV_LOG_TRACE_INDEV 1 #define LV_LOG_TRACE_DISP_REFR 1 #define LV_LOG_TRACE_EVENT 1 #define LV_LOG_TRACE_OBJ_CREATE 1 #define LV_LOG_TRACE_LAYOUT 1 #define LV_LOG_TRACE_ANIM 1 #endif /* * 4. 断言 * */ /* 如果操作失败或发现无效数据，则启用断言。 * 如果启用了LV_USE_LOG，失败时会打印错误信息*/ #define LV_USE_ASSERT_NULL 1 /* 检查参数是否为NULL */ #define LV_USE_ASSERT_MALLOC 1 /* 检查内存是否分配成功 */ #define LV_USE_ASSERT_STYLE 0 /* 检查样式是否正确初始化 */ #define LV_USE_ASSERT_MEM_INTEGRITY 0 /* 关键操作完成后，请检查“lv_mem”的完整性 */ #define LV_USE_ASSERT_OBJ 0 /* 检查对象的类型和存在(例如，未删除) */ /* 当断言发生时，添加一个自定义处理程序，例如重新启动MCU */ #define LV_ASSERT_HANDLER_INCLUDE <stdint.h> #define LV_ASSERT_HANDLER while(1); /* * 5. 其他 * */ /* 1:显示CPU使用率和帧率（FPS） */ #define LV_USE_PERF_MONITOR 0 #if LV_USE_PERF_MONITOR #define LV_USE_PERF_MONITOR_POS LV_ALIGN_BOTTOM_RIGHT #endif /* 1：显示使用的内存和内存碎片 * 当使用LVGL自带的内存管理算法时才有用 */ #define LV_USE_MEM_MONITOR 0 #if LV_USE_MEM_MONITOR #define LV_USE_MEM_MONITOR_POS LV_ALIGN_BOTTOM_LEFT #endif /* 1:在重新绘制的区域上绘制随机的彩色矩形 */ #define LV_USE_REFR_DEBUG 0 /* 改变内置的(v)snprintf函数 */ #define LV_SPRINTF_CUSTOM 0 #if LV_SPRINTF_CUSTOM #define LV_SPRINTF_INCLUDE <stdio.h> #define lv_snprintf snprintf #define lv_vsnprintf vsnprintf #else #define LV_SPRINTF_USE_FLOAT 0 #endif #define LV_USE_USER_DATA 1 /* 垃圾收集器设置 * 如果lvgl绑定到高级语言，并且内存由该语言管理时使用*/ #define LV_ENABLE_GC 0 #if LV_ENABLE_GC ! 0 #define LV_GC_INCLUDE \"gc.h\" #endif /********************************************************************************* 编译器设置 ***********************************************************************************/ /* 对于设置为1的大端序系统 */ #define LV_BIG_ENDIAN_SYSTEM 0 /* 为' lv_tick_inc '函数定义一个自定义属性 */ #define LV_ATTRIBUTE_TICK_INC /* 为' lv_timer_handler '函数定义一个自定义属性 */ #define LV_ATTRIBUTE_TIMER_HANDLER /* 为' lv_disp_flush_ready '函数定义一个自定义属性 */ #define LV_ATTRIBUTE_FLUSH_READY /* 缓冲区所需的对齐大小 */ #define LV_ATTRIBUTE_MEM_ALIGN_SIZE 1 /* 将被添加到需要对齐内存的地方(默认情况下 Os数据可能不会对齐到边界)。 * 如__attribute__((对齐(4))) */ #define LV_ATTRIBUTE_MEM_ALIGN /* 属性来标记大型常量数组，例如字体的位图 */ #define LV_ATTRIBUTE_LARGE_CONST /* RAM中大数组声明的编译器前缀 */ #define LV_ATTRIBUTE_LARGE_RAM_ARRAY /* 将性能关键功能放入更快的内存中(例如RAM) */ #define LV_ATTRIBUTE_FAST_MEM /* 在GPU加速操作中使用的前缀变量，通常需要放置在DMA可访问的RAM段中 */ #define LV_ATTRIBUTE_DMA /* 导出整型常量到绑定。该宏与LV_<CONST> that形式的常量一起使用 * 也应该出现在LVGL绑定API，如Micropython。*/ #define LV_EXPORT_CONST_INT(int_value) struct _silence_gcc_warning /* 默认值只是防止GCC警告 */ /* 扩展默认值 32k..32k坐标范围到 4M..使用int32_t而不是int16_t作为坐标 */ #define LV_USE_LARGE_COORD 0 /********************************************************************************* 字库设置 ***********************************************************************************/ /* ASCII范围的蒙特塞拉特字体和一些使用 bpp 4 的符号 * https://fonts.google.com/specimen/Montserrat */ #define LV_FONT_MONTSERRAT_8 0 #define LV_FONT_MONTSERRAT_10 1 #define LV_FONT_MONTSERRAT_12 1 #define LV_FONT_MONTSERRAT_14 1 #define LV_FONT_MONTSERRAT_16 1 #define LV_FONT_MONTSERRAT_18 0 #define LV_FONT_MONTSERRAT_20 0 #define LV_FONT_MONTSERRAT_22 1 #define LV_FONT_MONTSERRAT_24 0 #define LV_FONT_MONTSERRAT_26 0 #define LV_FONT_MONTSERRAT_28 0 #define LV_FONT_MONTSERRAT_30 0 #define LV_FONT_MONTSERRAT_32 1 #define LV_FONT_MONTSERRAT_34 0 #define LV_FONT_MONTSERRAT_36 0 #define LV_FONT_MONTSERRAT_38 0 #define LV_FONT_MONTSERRAT_40 0 #define LV_FONT_MONTSERRAT_42 0 #define LV_FONT_MONTSERRAT_44 0 #define LV_FONT_MONTSERRAT_46 0 #define LV_FONT_MONTSERRAT_48 0 /* 展示特色 */ #define LV_FONT_MONTSERRAT_12_SUBPX 0 #define LV_FONT_MONTSERRAT_28_COMPRESSED 0 /* bpp 3 */ #define LV_FONT_DEJAVU_16_PERSIAN_HEBREW 0 /* 希伯来语，阿拉伯语，波斯语以及它们的各种形式 */ #define LV_FONT_SIMSUN_16_CJK 0 /* 1000个最常见的CJK自由基 */ /* 像素完美的等宽字体 */ #define LV_FONT_UNSCII_8 0 #define LV_FONT_UNSCII_16 0 /* 声明自定义字体。也可以使用这些字体作为默认字体 * 如：#define LV_FONT_CUSTOM_DECLARE LV_FONT_DECLARE(my_font_1) */ #define LV_FONT_CUSTOM_DECLARE /* 设置默认字体 */ #define LV_FONT_DEFAULT &lv_font_montserrat_14 /* 允许处理大字体或包含大量字符的字体 * 限制取决于字体大小、字体和 bpp * 如果字体需要，将触发编译器错误 */ #define LV_FONT_FMT_TXT_LARGE 0 /* 启用/禁用对压缩字体的支持 */ #define LV_USE_FONT_COMPRESSED 0 /* 启用子像素渲染 */ #define LV_USE_FONT_SUBPX 0 #if LV_USE_FONT_SUBPX /* 设置显示器的像素顺序，RGB通道的物理顺序。对于“正常”字体无关紧要 */ #define LV_FONT_SUBPX_BGR 0 /* 0: RGB;1: BGR */ #endif /********************************************************************************* 文本设置 ***********************************************************************************/ /** * 为字符串选择字符编码 * IDE或编辑器应该具有相同的字符编码 * LV_TXT_ENC_UTF8 * LV_TXT_ENC_ASCII */ #define LV_TXT_ENC LV_TXT_ENC_UTF8 /* 可以在这些字符上中断(换行)文本 */ #define LV_TXT_BREAK_CHARS \" ,.;: _\" /* 如果一个单词至少有这么长，就会在最好的地方断开 * 要禁用，设置一个值< 0 */ #define LV_TXT_LINE_BREAK_LONG_LEN 0 /* 在一个长单词中，在停顿之前放置一行的最小字符数。 * 取决于LV_TXT_LINE_BREAK_LONG_LEN */ #define LV_TXT_LINE_BREAK_LONG_PRE_MIN_LEN 3 /* 在一个长单词中，在停顿后插入一行的最小字符数。 * 取决于LV_TXT_LINE_BREAK_LONG_LEN */ #define LV_TXT_LINE_BREAK_LONG_POST_MIN_LEN 3 /* 用于信令文本重新上色的控制字符 */ #define LV_TXT_COLOR_CMD \"#\" /* 支持双向文本。允许混合从左到右和从右到左的文本。 * 方向会根据Unicode双向算法进行处理: * https://www.w3.org/International/articles/inline bidi markup/uba basics*/ #define LV_USE_BIDI 0 #if LV_USE_BIDI /* 设置默认方向。支持的值: *`LV_BASE_DIR_LTR` 从左到右 *`LV_BASE_DIR_RTL` 从右到左 *`LV_BASE_DIR_AUTO` 检测文本基本方向 */ #define LV_BIDI_BASE_DIR_DEF LV_BASE_DIR_AUTO #endif /* 支持阿拉伯语/波斯处理 * 在这些语言中，字符应该根据其在文本中的位置被替换为其他形式 */ #define LV_USE_ARABIC_PERSIAN_CHARS 0 /********************************************************************************* 核心控件设置 ***********************************************************************************/ /* 小部件的文档:https://docs.lvgl.io/latest/en/html/widgets/index.html */ #define LV_USE_ARC 1 #define LV_USE_ANIMIMG 1 #define LV_USE_BAR 1 #define LV_USE_BTN 1 #define LV_USE_BTNMATRIX 1 #define LV_USE_CANVAS 1 #define LV_USE_CHECKBOX 1 #define LV_USE_DROPDOWN 1 /* 依赖: lv_label */ #define LV_USE_IMG 1 /* 依赖: lv_label */ #define LV_USE_LABEL 1 #if LV_USE_LABEL #define LV_LABEL_TEXT_SELECTION 1 /* 启用标签的选择文本*/ #define LV_LABEL_LONG_TXT_HINT 1 /* 在标签中存储一些额外的信息，以加快绘制非常长的文本 */ #endif #define LV_USE_LINE 1 #define LV_USE_ROLLER 1 /* 依赖: lv_label */ #if LV_USE_ROLLER #define LV_ROLLER_INF_PAGES 7 /* 当滚筒无限时，额外的“页数” */ #endif #define LV_USE_SLIDER 1 /* 依赖: lv_bar*/ #define LV_USE_SWITCH 1 #define LV_USE_TEXTAREA 1 /* 依赖: lv_label*/ #if LV_USE_TEXTAREA ! 0 #define LV_TEXTAREA_DEF_PWD_SHOW_TIME 1500 /*ms*/ #endif #define LV_USE_TABLE 1 /********************************************************************************* 特别功能 ***********************************************************************************/ /* * 1.拓展控件 * */ #define LV_USE_CALENDAR 1 #if LV_USE_CALENDAR #define LV_CALENDAR_WEEK_STARTS_MONDAY 0 #if LV_CALENDAR_WEEK_STARTS_MONDAY #define LV_CALENDAR_DEFAULT_DAY_NAMES {\"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\", \"Su\"} #else #define LV_CALENDAR_DEFAULT_DAY_NAMES {\"Su\", \"Mo\", \"Tu\", \"We\", \"Th\", \"Fr\", \"Sa\"} #endif #define LV_CALENDAR_DEFAULT_MONTH_NAMES {\"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"} #define LV_USE_CALENDAR_HEADER_ARROW 1 #define LV_USE_CALENDAR_HEADER_DROPDOWN 1 #endif #define LV_USE_CHART 1 #define LV_USE_COLORWHEEL 1 #define LV_USE_IMGBTN 1 #define LV_USE_KEYBOARD 1 #define LV_USE_LED 1 #define LV_USE_LIST 1 #define LV_USE_MENU 1 #define LV_USE_METER 1 #define LV_USE_MSGBOX 1 #define LV_USE_SPINBOX 1 #define LV_USE_SPINNER 1 #define LV_USE_TABVIEW 1 #define LV_USE_TILEVIEW 1 #define LV_USE_WIN 1 #define LV_USE_SPAN 1 #if LV_USE_SPAN #define LV_SPAN_SNIPPET_STACK_SIZE 64 /* 一个行文本可以包含最大数量的span描述符 */ #endif /* * 2. 主题 * */ /* 一个非常完整的主题 */ #define LV_USE_THEME_DEFAULT 1 #if LV_USE_THEME_DEFAULT /* 0:浅色模式，1:深色模式 */ #define LV_THEME_DEFAULT_DARK 0 /* 1:启用按下增长 */ #define LV_THEME_DEFAULT_GROW 1 /* 默认转换时间[ms] */ #define LV_THEME_DEFAULT_TRANSITION_TIME 80 #endif /* 一个非常简单的主题，这是自定义主题的良好起点 */ #define LV_USE_THEME_BASIC 1 /* 专为单色显示器设计的主题 */ #define LV_USE_THEME_MONO 1 /* * 3. 布局 * */ /* 类似于CSS中的Flexbox布局 */ #define LV_USE_FLEX 1 /* 类似于CSS中的网格布局 */ #define LV_USE_GRID 1 /* * 4. 第三方库 * */ /* 常见API的文件系统接口 */ /* STDIO */ #define LV_USE_FS_STDIO 0 #if LV_USE_FS_STDIO #define LV_FS_STDIO_LETTER '\\0' /* 设置驱动器可访问的大写字母(例如。“A”) */ #define LV_FS_STDIO_PATH \"\" /* 设置工作目录。文件/目录路径将附加到它 */ #define LV_FS_STDIO_CACHE_SIZE 0 /* >0则在lv_fs_read()中缓存这个字节数 */ #endif /* POSIX */ #define LV_USE_FS_POSIX 0 #if LV_USE_FS_POSIX #define LV_FS_POSIX_LETTER '\\0' /* 设置驱动器可访问的大写字母(例如。“A”) */ #define LV_FS_POSIX_PATH \"\" /* 设置工作目录。文件/目录路径将附加到它 */ #define LV_FS_POSIX_CACHE_SIZE 0 /* >0则在lv_fs_read()中缓存这个字节数 */ #endif /* WIN32 */ #define LV_USE_FS_WIN32 0 #if LV_USE_FS_WIN32 #define LV_FS_WIN32_LETTER '\\0' /* 设置驱动器可访问的大写字母(例如。“A”) */ #define LV_FS_WIN32_PATH \"\" /* 设置工作目录，文件/目录路径将附加到它 */ #define LV_FS_WIN32_CACHE_SIZE 0 /* >0则在lv_fs_read()中缓存这个字节数 */ #endif /* FATFS */ #define LV_USE_FS_FATFS 0 #if LV_USE_FS_FATFS #define LV_FS_FATFS_LETTER '0' /* 设置驱动器可访问的大写字母(例如。“A”) */ #define LV_FS_FATFS_CACHE_SIZE 0 /* >0则在lv_fs_read()中缓存这个字节数 */ #endif /* PNG译码器库 */ #define LV_USE_PNG 0 /* BMP 译码器库 */ #define LV_USE_BMP 0 /* JPG +分割JPG解码器库。 * Split JPG是为嵌入式系统优化的自定义格式 */ #define LV_USE_SJPG 0 /* GIF译码器库 */ #define LV_USE_GIF 0 /* QR译码器库 */ #define LV_USE_QRCODE 0 /* FreeType库 */ #define LV_USE_FREETYPE 0 #if LV_USE_FREETYPE /* FreeType用于缓存字符[bytes]的内存( 1:没有缓存) */ #define LV_FREETYPE_CACHE_SIZE (16 * 1024) #if LV_FREETYPE_CACHE_SIZE > 0 /* 1:位图cache使用sbit cache, 0:位图cache使用图像cache * sbit缓存:对于小的位图(字体大小< 256)，它的内存效率更高 *如果字体大小> 256，必须配置为图像缓存 */ #define LV_FREETYPE_SBIT_CACHE 0 /* 由这个缓存实例管理的打开的FT_Face/FT_Size对象的最大数量。*／ (0:使用系统默认值) */ #define LV_FREETYPE_CACHE_FT_FACES 0 #define LV_FREETYPE_CACHE_FT_SIZES 0 #endif #endif /* Rlottie 库 */ #define LV_USE_RLOTTIE 0 /* FFmpeg库的图像解码和播放视频 * 支持所有主要的图像格式，所以不启用其他图像解码器与它t*/ #define LV_USE_FFMPEG 0 #if LV_USE_FFMPEG /* 将输入信息转储到stderr */ #define LV_FFMPEG_AV_DUMP_FORMAT 0 #endif /* * 5. 其他 * */ /* 1:启用API对对象进行快照 */ #define LV_USE_SNAPSHOT 1 /* 1:使能Monkey测试 */ #define LV_USE_MONKEY 0 /* 1:启用网格导航 */ #define LV_USE_GRIDNAV 0 /********************************************************************************* 实例 ***********************************************************************************/ #define LV_BUILD_EXAMPLES 1 /* 允许用库构建示例 */ /* * 演示使用 */ /* 部件显示实例。对于内存要求较高 */ #define LV_USE_DEMO_WIDGETS 0 #if LV_USE_DEMO_WIDGETS #define LV_DEMO_WIDGETS_SLIDESHOW 0 #endif /* 编码器和键盘使用实例 */ #define LV_USE_DEMO_KEYPAD_AND_ENCODER 0 /* 基准系统实例 */ #define LV_USE_DEMO_BENCHMARK 0 /* LVGL压力测试实例 */ #define LV_USE_DEMO_STRESS 1 /* 音乐播放器实例 */ #define LV_USE_DEMO_MUSIC 0 #if LV_USE_DEMO_MUSIC # define LV_DEMO_MUSIC_SQUARE 0 # define LV_DEMO_MUSIC_LANDSCAPE 0 # define LV_DEMO_MUSIC_ROUND 0 # define LV_DEMO_MUSIC_LARGE 0 # define LV_DEMO_MUSIC_AUTO_PLAY 0 #endif #endif #endif ```"},"/note/嵌入式/第三方移植/lvgl/2025-2-24-13图片字体.html":{"title":"使用字体方式显示图片","content":"# 使用字体方式显示图片 [Image font（图片字体） — LVGL 文档](https://lvgl.100ask.net/master/details/other components/imgfont.html) 建立一个图片字体使用一下的函数`lv_imgfont_create(height, path_cb, user_data)` 第二个回调函数的格式是 `static const void* get_imgfont_path(const lv_font_t * font, uint32_t unicode, uint32_t unicode_next, int32_t * offset_y, void * user_data)` 主要是使用unicode参数进行比对获取实际的图片对象 下面是一个示例, 用于获取`lv_image_dsc_t` ```cpp // 各种图片的引用 extern const lv_image_dsc_t emoji_1f636_64; // neutral ... typedef struct emoji_64 { const lv_image_dsc_t* emoji; uint32_t unicode; } emoji_64_t; static const void* get_imgfont_path(const lv_font_t * font, uint32_t unicode, uint32_t unicode_next, int32_t * offset_y, void * user_data) { static const emoji_64_t emoji_64_table[] { { &emoji_1f636_64, 0x1f636 }, // neutral \t\t... // }; for (size_t i 0; i < sizeof(emoji_64_table) / sizeof(emoji_64_table[0]); i++) { if (emoji_64_table[i].unicode unicode) { return emoji_64_table[i].emoji; } } return NULL; } ```"},"/note/嵌入式/第三方移植/lvgl/2024-1-5-01入门.html":{"title":"入门","content":" layout: post title: \"入门\" date: 2024 1 5 15:39:08 +0800 tags: stm32 lvgl # 入门 ## GUI 图形用户界面, 采用图形化方式显示计算机操作用户界面 ![image 20240111165759197](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111657381.png) ## LVGL https://lvgl.io ![image 20240111165925914](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111659983.png) ## 移植 ## 要求 + 基本需求 需要时16, 32, 64位的微控制器 主控大于16MHz Flash/ROM要求在64KB以上, 建议在180KB RAM>8KB, 建议>24KB 图形缓冲区, > 水平分辨率像素, 建议大于1/10总像素, 用于刷新 + 优化 提高芯片的主频 增大SRAM, 提高读写速度 增大图形缓冲区, 使用双缓存(使用两个缓冲区, 交替进行发送) 减小需要刷新的像素 提高图形的传输速度 > 关键就是减少图像刷新所需要的时间 ## 资料获取 [lvgl/lvgl at release/v8.2 (github.com)](https://github.com/lvgl/lvgl/tree/release/v8.2) ![image 20240111172108375](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111721492.png) > 主要移植的代码在文件src和example ![image 20240111172303718](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111723780.png) ### 文件精简 ![image 20240111172511589](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111725644.png) ![image 20240111172628413](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111726470.png) > 只需要这几个文件 ![image 20240111172655785](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111726840.png)"},"/note/嵌入式/第三方移植/lvgl/2024-5-31-08其他.html":{"title":"其他","content":" layout: post title: \"其他\" date: 2024 1 11 15:39:08 +0800 tags: stm32 lvgl # 其他 ## 时钟timer LVGL has a built in timer system. You can register a function to have it be called periodically. The timers are handled and called in `lv_timer_handler()`, which needs to be called every few milliseconds. See [Porting](https://docs.lvgl.io/porting/timer handler) for more information. 用于每隔一定时间调用一次函数 ### 创建 ```c lv_timer_t * lv_timer_create(lv_timer_cb_t timer_xcb, uint32_t period, void * user_data); ``` > ```c > void (*lv_timer_cb_t)(lv_timer_t *); > ``` ### 执行一次 ```c void lv_timer_ready(lv_timer_t * timer); ``` > makes a timer run on the next call of lv_timer_handler(). ### 重新计时 ```c void lv_timer_reset(lv_timer_t * timer) ``` ### 设置参数 ```c lv_timer_set_cb(timer, new_cb) lv_timer_set_period(timer, new_period) ``` ### 设置执行的次数 ```c void lv_timer_set_repeat_count(lv_timer_t * timer, int32_t repeat_count); ``` ### 启动 ```c void lv_timer_enable(bool en) ``` ### 暂停以及恢复 ```c lv_timer_pause(timer) /pauses the specified timer. lv_timer_resume(timer) resumes the specified timer. ```"},"/note/嵌入式/第三方移植/lvgl/2024-5-30-07部件使用.html":{"title":"lvgl部件使用","content":" layout: post title: \"lvgl部件使用\" date: 2024 1 11 15:39:08 +0800 tags: stm32 lvgl # 部件使用 ## lv_lable标签 主要用于文本的显示, 标题提示信息等 + 主体LV_PART_MAIN + 滚动条LV_PART_SCROLLBAR + 选中的文本LV_PART_SELECTED ### 创建以及设置文本 ```c lv_obj_t *lable lv_label_create(lv_scr_act()); lv_label_set_text(lable, \"Hello World\"); ``` + 设置文本有三种方式 1. 直接设置 ```c void lv_label_set_text(lv_obj_t * obj, const char * text); ``` > 这一个文本放在文本的动态内存里面 2. 文本在指定的缓冲区里面 ```c void lv_label_set_text_static(lv_obj_t * obj, const char * text); ``` > 这一个内存被释放以及被改写的话这一个获取的信息是不可靠的, 这一个文本从代码段过来的话, 是不可以进行修改的 3. With [lv_label_set_text_fmt](https://docs.lvgl.io/master/API/widgets/label/lv_label.html#_CPPv421lv_label_set_text_fmtP8lv_obj_tPKcz)(label, \"Value: %d\", 15) printf formatting can be used to set the text. ```c void lv_label_set_text_fmt(lv_obj_t * obj, const char * fmt, ...) ``` ### 设置长文本模式 当这一个标签没有设置宽度的时候, 会自动扩展, 设置的话需要设置这一个标签的长文本模式 ```c void lv_label_set_long_mode(lv_obj_t *obj, lv_label_long_mode_t long_mode) ``` > ```c > enum { > LV_LABEL_LONG_WRAP, /**< Keep the object width, wrap the too long lines and expand the object height*/ > LV_LABEL_LONG_DOT, /**< 在最后加点*/ > LV_LABEL_LONG_SCROLL, /**< 查出的时候循环(左右移动)*/ > LV_LABEL_LONG_SCROLL_CIRCULAR, /**< 文本超出的时候循环播放(一周)*/ > LV_LABEL_LONG_CLIP, /**< Keep the size and clip the text out of it*/ > }; > ``` ### 设置文本样式 ```c void lv_obj_set_style_text_color(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector); void lv_obj_set_style_text_color_filtered(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector); void lv_obj_set_style_text_opa(struct _lv_obj_t * obj, lv_opa_t value, lv_style_selector_t selector); void lv_obj_set_style_text_font(struct _lv_obj_t * obj, const lv_font_t * value, lv_style_selector_t selector); void lv_obj_set_style_text_letter_space(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector); void lv_obj_set_style_text_line_space(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector); void lv_obj_set_style_text_decor(struct _lv_obj_t * obj, lv_text_decor_t value, lv_style_selector_t selector); void lv_obj_set_style_text_align(struct _lv_obj_t * obj, lv_text_align_t value, lv_style_selector_t selector); ``` 还可以设置背景, 设置背景的时候需要设置透明度, 设置字体的时候需要在lv_conf.h这一个文件里面把这一个字体进行改变 + 设置个别字体的颜色 ```c lv_label_set_recolor(label2, true); lv_label_set_text(label2, \"It is a #ff0000 circularly# scrolling text.\"); ``` > 颜色后面需要有一个空格 + 阴影 实际是把这一个文本绘制两遍, 后面的那一个颜色比较浅 ```c /*Create a style for the shadow*/ static lv_style_t style_shadow; lv_style_init(&style_shadow); lv_style_set_text_opa(&style_shadow, LV_OPA_30); //设置为透明度为30 lv_style_set_text_color(&style_shadow, lv_color_black()); /*Create a label for the shadow first (it's in the background)*/ lv_obj_t * shadow_label lv_label_create(lv_scr_act()); lv_obj_add_style(shadow_label, &style_shadow, 0); /*Create the main label*/ lv_obj_t * main_label lv_label_create(lv_scr_act()); lv_label_set_text(main_label, \"A simple method to create\\n\" \"shadows on a text.\\n\" \"It even works with\\n\\n\" \"newlines and spaces.\"); /*Set the same text for the shadow label*/ lv_label_set_text(shadow_label, lv_label_get_text(main_label)); /*Position the main label*/ lv_obj_align(main_label, LV_ALIGN_CENTER, 0, 0); /*Shift the second label down and to the right by 2 pixel*/ lv_obj_align_to(shadow_label, main_label, LV_ALIGN_TOP_LEFT, 2, 2); ``` ```c static lv_style_t style; lv_style_init(&style); lv_style_set_bg_opa(&style, LV_OPA_40); lv_style_set_bg_color( &style, lv_color_hex(0xff0000) ); //设置背景色 lv_style_set_bg_grad_color( &style, lv_color_hex( 0x0000ff ) ); //设置过度 lv_style_set_bg_grad_dir(&style, LV_GRAD_DIR_HOR); lv_style_set_text_color(&style, lv_color_white()); lv_obj_t *label lv_label_create(lv_scr_act()); lv_label_set_text(label, \"Hello World!\"); lv_obj_add_style(label, &style, LV_STATE_DEFAULT); // lv_obj_set_style_bg_opa(label, LV_OPA_COVER, LV_PART_MAIN); // lv_obj_set_style_bg_color(label, lv_color_hex(0x00ff00), LV_PART_MAIN); lv_obj_align(label, LV_ALIGN_CENTER, 0, 0); ``` ### 设置图标 ```c lv_label_set_text(my_label, LV_SYMBOL_OK); lv_label_set_text(my_label, LV_SYMBOL_OK \"Apply\"); lv_label_set_text(my_label, LV_SYMBOL_OK LV_SYMBOL_WIFI LV_SYMBOL_PLAY); ``` > 这里的SYMBOL实际是一个字符 ## 按钮lv_button 和基础对象相比没有加入新的东西, 默认的点击效果是放大 ```c lv_obj_add_flag(btn, LV_OBJ_FLAG_CLICKABLE); lv_obj_add_event_cb(btn, btn_event_cb, LV_EVENT_CLICKED, NULL); ``` 有两个可以添加的标志LV_OBJ_FLAG_CLICKABLE, 这时候LV_EVENT_VALUE_CHANGED这一个回调会被触发 > 需要设置字体的时候, 需要一个lable对象以这一个按钮位父对象 > > Note that the state of `LV_KEY_ENTER` is translated to `LV_EVENT_PRESSED/PRESSING/RELEASED` etc. ## 开关lv_switch 开关通常用于某一个功能的开启和关闭, 可以直接显示这一个被控对象的状态 + LV_PART_MAIN 没有被选择的时候的部分 + LV_PART_KNOB 手柄 + LV_PART_INDICATOR 指示器, 选择的时候非手柄的部分 ![image 20240531090848085](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405310908149.png) ```c lv_obj_set_style_bg_color(switch2, lv_color_make(0x00, 0x00, 0x00), LV_PART_INDICATOR LV_STATE_CHECKED); ``` > 设置指示器的时候由于不是默认的状态, 所以需要加上这一个状态 ### 设置状态 ```c lv_obj_add_state(switch1, LV_STATE_CHECKED); lv_obj_clear_state(switch1, LV_STATE_CHECKED LV_STATE_DISABLED);//设置为不可以修改 ``` ![image 20240531100029144](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405311000212.png) ### 获取状态 To get the current state of the switch (with `true` being on), use [lv_obj_has_state](https://docs.lvgl.io/master/API/core/lv_obj.html#_CPPv416lv_obj_has_statePK8lv_obj_t10lv_state_t)(obj, [LV_STATE_CHECKED](https://docs.lvgl.io/master/API/core/lv_obj.html#_CPPv4N11_lv_state_t16LV_STATE_CHECKEDE)). ### 事件 [`LV_EVENT_VALUE_CHANGED`](https://docs.lvgl.io/master/API/misc/lv_event.html#_CPPv4N15lv_event_code_t22LV_EVENT_VALUE_CHANGEDE) Sent when the switch changes state. ```c lv_obj_add_event_cb(switch2, btn_event_cb, LV_EVENT_VALUE_CHANGED, NULL); //添加回调函数 void btn_event_cb(lv_event_t * e) { lv_event_code_t event lv_event_get_code(e); if (event LV_EVENT_VALUE_CHANGED) { lv_obj_t *switch1 lv_event_get_target(e); if (lv_obj_has_state(switch1, LV_STATE_CHECKED)) printf(\"ON\\n\"); else printf(\"OFF\\n\"); } } ``` ## 复选框lv_checkbox 选择某一个内容的开启和关闭, 可以理解为一个自带标签的开关 + LV_PART_MAIN 主题部分, 包括标签 + LV_PART_INDICATOR 勾选框 ### 设置文本 The text can be modified with the [lv_checkbox_set_text](https://docs.lvgl.io/master/API/widgets/checkbox/lv_checkbox.html#_CPPv420lv_checkbox_set_textP8lv_obj_tPKc)(cb, \"New text\") function and will be dynamically allocated. ### 设置状态 ```c lv_obj_add_state(cb, LV_STATE_CHECKED); /*Make the checkbox checked*/ lv_obj_remove_state(cb, LV_STATE_CHECKED); /*Make the checkbox unchecked*/ lv_obj_add_state(cb, LV_STATE_CHECKED LV_STATE_DISABLED); /*Make the checkbox checked and disabled*/ ``` To get whether the checkbox is checked or not use: [lv_obj_has_state](https://docs.lvgl.io/master/API/core/lv_obj.html#_CPPv416lv_obj_has_statePK8lv_obj_t10lv_state_t)(cb, [LV_STATE_CHECKED](https://docs.lvgl.io/master/API/core/lv_obj.html#_CPPv4N11_lv_state_t16LV_STATE_CHECKEDE)). ### 设置文本和勾选框间距 ```c void lv_obj_set_style_pad_column(struct _lv_obj_t * obj, lv_coord_t value, lv_style_selector_t selector) ``` ### 事件 [`LV_EVENT_VALUE_CHANGED`](https://docs.lvgl.io/master/API/misc/lv_event.html#_CPPv4N15lv_event_code_t22LV_EVENT_VALUE_CHANGEDE) Sent when the checkbox is toggled. 具体的使用和按钮是一样的 ## 进度条lv_bar 用于显示一个任务的完成进度 + LV_PART_MAIN: The background of the bar and it uses the typical background style properties. Adding padding makes the indicator smaller or larger. The `anim_time` style property sets the animation time if the values set with [`LV_ANIM_ON`](https://docs.lvgl.io/master/API/misc/lv_anim.html#_CPPv4N16lv_anim_enable_t10LV_ANIM_ONE).主体 + LV_PART_INDICATOR: The indicator itself; also uses all the typical background properties.指示器 ### 设置数值 可以设置大小, 当前值, 范围值 ```c lv_obj_t *bar lv_bar_create(lv_scr_act()); lv_obj_set_size(bar, 400, 20); //这一个长和宽的大小会改变这一个进度条是水平的还是垂直的 lv_bar_set_value(bar, 50, LV_ANIM_ON); //设置当前的值,使用动画 lv_bar_set_range(bar, 100, 100); lv_obj_set_style_anim_time(bar, 1000, LV_STATE_DEFAULT); //设置动画的时间 这一个设置必须在设置当前值之前 ``` > 这一个动画时间的设置实际是旧值到新值使用的绘图时间 ### 设置起始点 希望加载的时候不是从起始的位置开始的时候可以设置为其他模式 ```c lv_bar_set_mode(bar, LV_BAR_MODE_RANGE); lv_bar_set_start_value(bar, 10, LV_ANIM_OFF); ``` ![image 20240531194333892](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405311943962.png) ```c enum { LV_BAR_MODE_NORMAL, //默认的模式 LV_BAR_MODE_SYMMETRICAL, //设置为从0开始到当前值(可以为负数) LV_BAR_MODE_RANGE //可以设置起始值, 但是这一个值必须小于当前值 }; ``` ## 加载器部件lv_spinner 提示用户正在加载, 一个圆弧形状的加载条 + LV_PART_MAIN 主题 + LV_PART_INDICATOR 指示器 + LV_PART_KNOB 手柄 ### 创建 ```c lv_obj_t * lv_spinner_create(lv_obj_t * parent, uint32_t time, uint32_t arc_length); ``` ### 设置圆弧的颜色 ```c void lv_obj_set_style_arc_color(struct _lv_obj_t * obj, lv_color_t value, lv_style_selector_t selector) ``` > 使用这一个设置主体以及指示器的颜色 ```c void lv_style_set_arc_width(lv_style_t * style, lv_coord_t value); //圆弧的宽度(主体和指示器) void lv_style_set_arc_rounded(lv_style_t * style, bool value); //圆弧的头部是不是圆头 void lv_style_set_arc_color(lv_style_t * style, lv_color_t value); //设置颜色 void lv_style_set_arc_color_filtered(lv_style_t * style, lv_color_t value); void lv_style_set_arc_opa(lv_style_t * style, lv_opa_t value); //透明度 void lv_style_set_arc_img_src(lv_style_t * style, const void * value); ``` ## LED lv_led + LV_PART_MAIN 不同的版本显示的是不同的 ### 颜色 You can set the color of the LED with [lv_led_set_color](https://docs.lvgl.io/master/API/widgets/led/lv_led.html#_CPPv416lv_led_set_colorP8lv_obj_t10lv_color_t)(led, [lv_color_hex](https://docs.lvgl.io/master/API/misc/lv_color.html#_CPPv412lv_color_hex8uint32_t)(0xff0080)). This will be used as background color, border color, and shadow color. ### 亮度 You can set their brightness with lv_led_set_bright(led, bright). The brightness should be between 0 (darkest) and 255 (lightest). ### 开启以及关闭 Use [lv_led_on](https://docs.lvgl.io/master/API/widgets/led/lv_led.html#_CPPv49lv_led_onP8lv_obj_t)(led) and [lv_led_off](https://docs.lvgl.io/master/API/widgets/led/lv_led.html#_CPPv410lv_led_offP8lv_obj_t)(led) to set the brightness to a predefined ON or OFF value. The [lv_led_toggle](https://docs.lvgl.io/master/API/widgets/led/lv_led.html#_CPPv413lv_led_toggleP8lv_obj_t)(led) toggles between the ON and OFF state. ## 列表部件 用于多选一的时候, 默认会展示多个部件 + LV_PART_MAIN 主题 + LV_PART_SCROLLBAR 滚动条 ### 添加按钮 [lv_list_add_button](https://docs.lvgl.io/master/API/widgets/list/lv_list.html#_CPPv418lv_list_add_buttonP8lv_obj_tPKvPKc)(list, icon, text) adds a full width button with an icon, 可以使用内置的一部分图标LV_SYMBOL_xxx ![../_images/symbols.png](https://docs.lvgl.io/master/_images/symbols.png) ### 添加文本 [lv_list_add_text](https://docs.lvgl.io/master/API/widgets/list/lv_list.html#_CPPv416lv_list_add_textP8lv_obj_tPKc)(list, text) adds a text. ### 获取文本 ```c lv_list_get_button_text(list1, obj) ``` ### 添加选中 ```c lv_obj_add_state(child, LV_STATE_CHECKED); ``` > 实际就是按键的选中 ## 下拉列表lv_dropdown 下拉按钮部分 + [`LV_PART_MAIN`](https://docs.lvgl.io/master/API/core/lv_obj.html#_CPPv4N10_lv_part_t12LV_PART_MAINE) The background of the button. Uses the typical background properties and text properties for the text on it. + [`LV_PART_INDICATOR`](https://docs.lvgl.io/master/API/core/lv_obj.html#_CPPv4N10_lv_part_t17LV_PART_INDICATORE) Typically an arrow symbol that can be an image or a text (`LV_SYMBOL`). 按键部分 [`LV_PART_MAIN`](https://docs.lvgl.io/master/API/core/lv_obj.html#_CPPv4N10_lv_part_t12LV_PART_MAINE) The list itself. Uses the typical background properties. `max_height` can be used to limit the height of the list. [`LV_PART_SCROLLBAR`](https://docs.lvgl.io/master/API/core/lv_obj.html#_CPPv4N10_lv_part_t17LV_PART_SCROLLBARE) The scrollbar background, border, shadow properties and width (for its own width) and right padding for the spacing on the right. [`LV_PART_SELECTED`](https://docs.lvgl.io/master/API/core/lv_obj.html#_CPPv4N10_lv_part_t16LV_PART_SELECTEDE) Refers to the currently pressed, checked or pressed+checked option. Also uses the typical background properties. The list is hidden/shown on open/close. To add styles to it use [lv_dropdown_get_list](https://docs.lvgl.io/master/API/widgets/dropdown/lv_dropdown.html#_CPPv420lv_dropdown_get_listP8lv_obj_t)(dropdown) to get the list object. For example: ```c lv_obj_t * list lv_dropdown_get_list(dropdown) /*Get the list*/ lv_obj_add_style(list, &my_style, selector) /*Add the styles to the list*/ ``` ### 设置内容 Options are passed to the drop down list as a string with [lv_dropdown_set_options](https://docs.lvgl.io/master/API/widgets/dropdown/lv_dropdown.html#_CPPv423lv_dropdown_set_optionsP8lv_obj_tPKc)(dropdown, options). Options should be separated by `\\n`. For example: `\"First\\nSecond\\nThird\"`. This string will be saved in the drop down list, so it can in a local variable. 使用这一个添加一个文本的按钮 The [lv_dropdown_add_option](https://docs.lvgl.io/master/API/widgets/dropdown/lv_dropdown.html#_CPPv422lv_dropdown_add_optionP8lv_obj_tPKc8uint32_t)(dropdown, \"New option\", pos) function inserts a new option to `pos` index.这一个可以选择索引 ### 获取索引 The get the *index* of the selected option, use [lv_dropdown_get_selected](https://docs.lvgl.io/master/API/widgets/dropdown/lv_dropdown.html#_CPPv424lv_dropdown_get_selectedPK8lv_obj_t)(dropdown). [lv_dropdown_get_selected_str](https://docs.lvgl.io/master/API/widgets/dropdown/lv_dropdown.html#_CPPv428lv_dropdown_get_selected_strPK8lv_obj_tPc8uint32_t)(dropdown, buf, buf_size) copies the *name* of the selected option to `buf`. ### 设置选中 lv_dropdown_set_selected(dropdoen, index) ### 事件 [`LV_EVENT_VALUE_CHANGED`](https://docs.lvgl.io/master/API/misc/lv_event.html#_CPPv4N15lv_event_code_t22LV_EVENT_VALUE_CHANGEDE) Sent when the new option is selected or the list is opened/closed. [`LV_EVENT_CANCEL`](https://docs.lvgl.io/master/API/misc/lv_event.html#_CPPv4N15lv_event_code_t15LV_EVENT_CANCELE) Sent when the list is closed [`LV_EVENT_READY`](https://docs.lvgl.io/master/API/misc/lv_event.html#_CPPv4N15lv_event_code_t14LV_EVENT_READYE) Sent when the list is opened ### 设置方向和图标 ```c lv_dropdown_set_dir(dd, LV_DIR_RIGHT); lv_dropdown_set_symbol(dd, LV_SYMBOL_RIGHT); ``` ### 示例 ```c void list_event_cb(lv_event_t * e){ lv_obj_t * dd lv_event_get_target(e); char buf[32]; lv_dropdown_get_selected_str(dd, buf, sizeof(buf)); printf(\"Option: %s\\n\", buf); } void my_gui(void) { lv_obj_t * dd lv_dropdown_create(lv_scr_act()); lv_dropdown_set_options(dd, \"Apple\\nBanana\\nOrange\\nMelon\\nGrape\\nRaspberry\\nCherry\\nKiwi\\nPineapple\\nStrawberry\\n\"); lv_obj_set_pos(dd, 10, 10); lv_obj_set_width(dd, 150); lv_obj_add_event_cb(dd, list_event_cb, LV_EVENT_VALUE_CHANGED, NULL); lv_dropdown_set_selected(dd, 5); } ``` ## 滚轮部件 以滚轮的方式展示选项, 多选一 + LV_PART_MAIN : 主体 + LV_PART_SELECTED : 选项框 ### 设置选项间隔 ```c void lv_style_set_text_line_space(lv_style_t * style, lv_coord_t value); //行间距 ``` ### 设置内容 ```c /** * Set the options on a roller * @param roller pointer to roller object * @param options a string with '\\n' separated options. E.g. \"One\\nTwo\\nThree\" * @param mode `LV_ROLLER_MODE_NORMAL` 到头以后停止or `LV_ROLLER_MODE_INFINITE`一直循环 */ void lv_roller_set_options(lv_obj_t * obj, const char * options, lv_roller_mode_t mode) ``` > 选项之间使用'\\n'进行分割 ### 事件 [`LV_EVENT_VALUE_CHANGED`](https://docs.lvgl.io/master/API/misc/lv_event.html#_CPPv4N15lv_event_code_t22LV_EVENT_VALUE_CHANGEDE) Sent when a new option is selected. ### 获取选项 To get the *index* of the currently selected option use [lv_roller_get_selected](https://docs.lvgl.io/master/API/widgets/roller/lv_roller.html#_CPPv422lv_roller_get_selectedPK8lv_obj_t)(roller). [lv_roller_get_selected_str](https://docs.lvgl.io/master/API/widgets/roller/lv_roller.html#_CPPv426lv_roller_get_selected_strPK8lv_obj_tPc8uint32_t)(roller, buf, buf_size) will copy the name of the selected option to `buf`. ### 设置可见的行数 The number of visible rows can be adjusted with [lv_roller_set_visible_row_count](https://docs.lvgl.io/master/API/widgets/roller/lv_roller.html#_CPPv431lv_roller_set_visible_row_countP8lv_obj_t8uint32_t)(roller, num). ### 设置当前选项 You can select an option manually with [lv_roller_set_selected](https://docs.lvgl.io/master/API/widgets/roller/lv_roller.html#_CPPv422lv_roller_set_selectedP8lv_obj_t8uint32_t16lv_anim_enable_t)(roller, id, [LV_ANIM_ON](https://docs.lvgl.io/master/API/misc/lv_anim.html#_CPPv4N16lv_anim_enable_t10LV_ANIM_ONE)), where *id* is the index of an option. > 这一个部件可以使用add_state设置不可选中 ## 滑块lv_slider 用于调节某一个参数的值, 以直线的方式修改数值 + LV_PART_MAIN 主体 + LV_OART_INDICATOR 指示器 + LV_PART_KNOB 旋钮The knob can be made larger with the `padding` values. Padding values can be asymmetric too. ### 设置值 To set an initial value use [lv_slider_set_value](https://docs.lvgl.io/master/API/widgets/slider/lv_slider.html#_CPPv419lv_slider_set_valueP8lv_obj_t7int32_t16lv_anim_enable_t)(slider, new_value, [LV_ANIM_ON](https://docs.lvgl.io/master/API/misc/lv_anim.html#_CPPv4N16lv_anim_enable_t10LV_ANIM_ONE) / OFF). The animation time is set by the styles' `anim_time` property. 设置当前值 To specify the range (min, max values), [lv_slider_set_range](https://docs.lvgl.io/master/API/widgets/slider/lv_slider.html#_CPPv419lv_slider_set_rangeP8lv_obj_t7int32_t7int32_t)(slider, min, max) can be used. The default range is 0..100, and the default drawing direction is from left to right in horizontal mode and bottom to top in vertical mode. If the minimum value is greater than the maximum value, like 100..0, the drawing direction changes to the opposite direction. 设置范围 ### 模式 [`LV_SLIDER_MODE_NORMAL`](https://docs.lvgl.io/master/API/widgets/slider/lv_slider.html#_CPPv4N17_lv_slider_mode_t21LV_SLIDER_MODE_NORMALE) A normal slider as described above `LV_SLIDER_SYMMETRICAL` Draw the indicator form the zero value to current value. Requires negative minimum range and positive maximum range. 从零开始绘制 `LV_SLIDER_RANGE` Allows setting the start value too by [lv_bar_set_start_value](https://docs.lvgl.io/master/API/widgets/bar/lv_bar.html#_CPPv422lv_bar_set_start_valueP8lv_obj_t7int32_t16lv_anim_enable_t)(bar, new_value, [LV_ANIM_ON](https://docs.lvgl.io/master/API/misc/lv_anim.html#_CPPv4N16lv_anim_enable_t10LV_ANIM_ONE) / OFF). The start value has to be always smaller than the end value. 可以设置起始的值, 这一个模式有两个旋钮, 可以使用lv_slider_set/get_left_value()进行设置以及获取 ### 示例 ```c void slider_event_cb(lv_event_t *e) { lv_event_code_t code lv_event_get_code(e); lv_obj_t *slider lv_event_get_target(e); if (code LV_EVENT_VALUE_CHANGED) { lv_obj_t * lable lv_event_get_user_data(e); uint32_t value lv_slider_get_value(slider); printf(\"value: %d\\n\", value); lv_label_set_text_fmt(lable, \"value left %d value %d\", lv_slider_get_left_value(slider), lv_slider_get_value(slider)); } } void my_gui(void) { lv_obj_t *lable lv_label_create(lv_scr_act()); lv_obj_t *slider lv_slider_create(lv_scr_act()); lv_obj_set_width(slider, 200); lv_obj_align(slider, LV_ALIGN_CENTER, 0, 0); lv_slider_set_range(slider, 0, 100); lv_slider_set_value(slider, 50, LV_ANIM_OFF); lv_obj_add_event_cb(slider, slider_event_cb, LV_EVENT_VALUE_CHANGED, lable); lv_slider_set_mode(slider, LV_SLIDER_MODE_RANGE); lv_slider_set_range(slider, 100, 100); //设置标签 lv_obj_align(lable, LV_ALIGN_CENTER, 0, 50); lv_label_set_text_fmt(lable, \"value left %d value %d\", lv_slider_get_left_value(slider), lv_slider_get_value(slider)); } ``` > ![image 20240601110449251](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406011104385.png) ## 圆弧部件lv_arc 可以用来设置或者显示某一个值 [`LV_PART_MAIN`](https://docs.lvgl.io/master/API/core/lv_obj.html#_CPPv4N10_lv_part_t12LV_PART_MAINE) Draws a background using the typical background style properties and an arc using the arc style properties. The arc's size and position will respect the *padding* style properties. [`LV_PART_INDICATOR`](https://docs.lvgl.io/master/API/core/lv_obj.html#_CPPv4N10_lv_part_t17LV_PART_INDICATORE) Draws another arc using the *arc* style properties. Its padding values are interpreted relative to the background arc. [`LV_PART_KNOB`](https://docs.lvgl.io/master/API/core/lv_obj.html#_CPPv4N10_lv_part_t12LV_PART_KNOBE) Draws a handle on the end of the indicator using all background properties and padding values. With zero padding the knob size is the same as the indicator's width. Larger padding makes it larger, smaller padding makes it smaller. ### 设置数值 A new value can be set using [lv_arc_set_value](https://docs.lvgl.io/master/API/widgets/arc/lv_arc.html#_CPPv416lv_arc_set_valueP8lv_obj_t7int32_t)(arc, new_value). The value is interpreted in a range (minimum and maximum values) which can be modified with [lv_arc_set_range](https://docs.lvgl.io/master/API/widgets/arc/lv_arc.html#_CPPv416lv_arc_set_rangeP8lv_obj_t7int32_t7int32_t)(arc, min, max). The default range is 0..100.设置范围值 To set the start and end angle of the background arc use the [lv_arc_set_bg_angles](https://docs.lvgl.io/master/API/widgets/arc/lv_arc.html#_CPPv420lv_arc_set_bg_anglesP8lv_obj_t18lv_value_precise_t18lv_value_precise_t)(arc, start_angle, end_angle) 背景角度functions or `lv_arc_set_bg_start/end_angle(arc, angle)`.设置圆弧的角度, 前景角度 > 尽量不要使用这一个前景弧度的设置函数, 否则和当前值不同, 会导致问题 > > 设置的时候先设置背景图, 后设置前景图 ![image 20240601111419464](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406011114697.png) ### 设置旋转角度 ```c lv_arc_set_rotation(arc, 180) ``` > 从起始的角度开始旋转(整张图进行旋转) ### 获取当前值 ```c lv_arc_get_value(arc); ``` ### 设置模式, 圆弧的绘制速率 ```c lv_arc_set_mode(arc, LV_ARC_MODE_REVERSE) lv_arc_set_change_rate(arc, 90); //90°每秒 ``` > ```c > LV_ARC_MODE_NORMAL, //正常的模式, 顺时针进行绘制 > LV_ARC_MODE_SYMMETRICAL, //对称的 > LV_ARC_MODE_REVERSE //逆时针绘制 > ``` ### 示例 ```c void arc_callback(lv_event_t * e) { lv_obj_t * arc lv_event_get_target(e); printf(\"arc value: %d\\n\", lv_arc_get_value(arc)); } void my_gui(void) { lv_obj_t * arc lv_arc_create(lv_scr_act()); lv_arc_set_bg_angles(arc, 0, 180); //设置角度 lv_arc_set_angles(arc, 0, 0); //设置显示的角度 lv_obj_set_size(arc, 200, 200); //大小 lv_obj_align(arc, LV_ALIGN_CENTER, 0, 0); //设置位置 lv_arc_set_mode(arc, LV_ARC_MODE_REVERSE); //设置模式为逆时针 lv_obj_add_event_cb(arc, arc_callback, LV_EVENT_VALUE_CHANGED, NULL); lv_arc_set_rotation(arc, 180); //设置旋转 } ``` ![image 20240601121832324](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406011218561.png) ### 去除旋钮 ```c void lv_obj_remove_style(lv_obj_t * obj, lv_style_t * style, lv_style_selector_t selector); lv_obj_remove_style(arc, NULL, LV_PART_INDICATOR); ``` ```c lv_obj_clear_flag(arc, LV_OBJ_FLAG_CLICKABLE); //设置为不可点击 ``` ## 线条部件lv_line 在一组坐标点里面依次绘制直线 The points have to be stored in an [`lv_point_precise_t`](https://docs.lvgl.io/master/API/misc/lv_area.html#_CPPv418lv_point_precise_t) array and passed to the object by the [lv_line_set_points](https://docs.lvgl.io/master/API/widgets/line/lv_line.html#_CPPv418lv_line_set_pointsP8lv_obj_tA_K18lv_point_precise_t8uint32_t)(lines, point_array, point_cnt) function. ```c static lv_point_t line_points[] {{10, 10}, {70, 70}, {120, 10}}; lv_line_set_points(line, line_points, 3); ``` ![image 20240601123747386](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406011237469.png) ### 样式 ```c void lv_style_set_line_width(lv_style_t * style, lv_coord_t value); //线条的宽度 void lv_style_set_line_dash_width(lv_style_t * style, lv_coord_t value); //线条的端点的属性 void lv_style_set_line_dash_gap(lv_style_t * style, lv_coord_t value); //设置虚线的宽度 void lv_style_set_line_rounded(lv_style_t * style, bool value); //线的头部是不是圆的 void lv_style_set_line_color(lv_style_t * style, lv_color_t value); //线的颜色 ``` ### 反转Y轴 By default, the *y 0* point is in the top of the object. It might be counter intuitive in some cases so the y coordinates can be inverted with [lv_line_set_y_invert](https://docs.lvgl.io/master/API/widgets/line/lv_line.html#_CPPv420lv_line_set_y_invertP8lv_obj_tb)(line, true). In this case, *y 0* will be the bottom of the object. *y invert* is disabled by default. > 可以使用这一个部件实现文字下划线, 绘图等(设置多个点实现曲线) > > 在实际使用的时候可以使用对齐以及移动函数对着一个直线进行偏移 ## 图片lv_img 实现图片的显示以及功能界面的优化 + LV_PART_MAIN 主体 ### 设置图片源 ```c LV_IMG_DECLEAR(img); //声明图片 lv_img_set_src(img, &img_bird); ``` > 图片可以来自数组, bin文件, 或者lvgl内置的图标 > > [Online image converter BMP, JPG or PNG to C array or binary LVGL](https://lvgl.io/tools/imageconverter)lvgl官方的转换工具 > > ![image 20240601131032637](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406011310742.png) > > ```c > LV_IMG_DECLARE(lymy); > > > void my_gui(void) > { > lv_obj_t* img1 lv_img_create(lv_scr_act()); > lv_img_set_src(img1, &lymy); > } > ``` > > ```c > lv_image_set_src(img, \"S:folder1/my_img.bin\") > lv_image_set_src(img1, LV_SYMBOL_OK) > ``` > > ### 偏移 ```c lv_img_set_offset_x(img, 100); //图片右移, 超出的部分会回到左侧 ``` ### 缩放以及旋转 ```c lv_img_set_zoom(img, 512); //设置缩放, 从128(1/2)到512(2倍) lv_img_set_angle(img, 900); //顺时针旋转90° ``` [lv_image_set_scale_x](https://docs.lvgl.io/master/API/widgets/image/lv_image.html#_CPPv420lv_image_set_scale_xP8lv_obj_t8uint32_t)(img, factor) and [lv_image_set_scale_y](https://docs.lvgl.io/master/API/widgets/image/lv_image.html#_CPPv420lv_image_set_scale_yP8lv_obj_t8uint32_t)(img, factor) also can be used to the scale independently horizontally and vertically (non uniform scale).水平竖直方向的缩放 The quality of the transformation can be adjusted with [lv_image_set_antialias](https://docs.lvgl.io/master/API/widgets/image/lv_image.html#_CPPv422lv_image_set_antialiasP8lv_obj_tb)(img, true). With enabled anti aliasing the transformations are higher quality but slower.开启抗锯齿 ### 设置中心点 这一个点是用于缩放以及旋转的点 ```c lv_obj_update_layout(img); lv_img_set_pivot(img, x, y); ``` ## 色环部件lv_colorwheel 一般用在颜色选择 + LV_PART_MAIN 主题 + LV_PART_KNOB 旋钮 ### 创建 ```c lv_colorwheel_create(parent, knob_recolor); //设置这一个旋钮会不会重新着色 ``` ### 设置当前颜色 ```c lv_colorwheel_set_rgb(cw, lv_color_hex(color)); ``` ### 获取颜色 ```c lv_colorwheel_get_rgb(cw); //获取颜色 ``` ### 设置模式 ```c lv_colorwheel_set_mode(colorwheel, LV_COLORWHEEL_MODE_HUE/SATURATION/VALUE); //设置, 色相, 饱和度, 明度 lv_colorwheel_set_mode_fixed(colorwheel, true); //固定色环模式, 否则长按的话会进行色环的切换 ``` ## 按钮矩阵lv_btnmatrix 可以在不同的行和列里面显示多个轻量级按钮 + LV_PART_MAIN + LV_PART_ITEMS 按钮 使用一个数组进行设置按钮, \"\\n\"进行换行, 最后必须是一个NULL ```c static char * map[] {\"btn1\", \"btn2\", \"\\n\", \"btn3\", \"\"} lv_btnmatrix_set_map(btnm, my_map) ``` ### 设置按钮的宽度 这一个设置的是按钮的相对宽度 ```c lv_btnmatrix_set_btn_width(btnm, id, width); //索引从0开始, 宽度1 7 ``` ### 获取按钮信息 `lv_btnmatrix_get_selected_btn(btnm)` returns the index of the most recently released or focused button or `LV_BTNMATRIX_BTN_NONE` if no such button. `lv_btnmatrix_get_btn_text(btnm, btn_id)` returns a pointer to the text of `btn_id`th button. ### 设置按钮的属性 ```c lv_btnmatrix_set_btn_ctrl(btnm, id, LV_BTNMATRIX_CTRL_xxx); //设置某一个按钮 lv_btnmatrix_clear_btn_ctrl(btnm, id, LV_BTNMATRIX_CTRL_xxx); lv_btnmatrix_set_btn_ctrl_all(btnm, LV_BTNMATRIX_CTRL_xxx); //设置所有的按钮 ``` > `LV_BTNMATRIX_CTRL_HIDDEN` Makes a button hidden (hidden buttons still take up space in the layout, they are just not visible or clickable) 隐藏, 但是实际有占位 > `LV_BTNMATRIX_CTRL_NO_REPEAT` Disable repeating when the button is long pressed 长按不重复触发 > `LV_BTNMATRIX_CTRL_DISABLED` Makes a button disabled Like `LV_STATE_DISABLED` on normal objects 失能 > `LV_BTNMATRIX_CTRL_CHECKABLE` Enable toggling of a button. I.e. `LV_STATE_CHECHED` will be added/removed as the button is clicked 可以切换状态 > `LV_BTNMATRIX_CTRL_CHECKED` Make the button checked. It will use the `LV_STATE_CHECHKED` styles. 设置选中 > `LV_BTNMATRIX_CTRL_CLICK_TRIG` Enabled: send LV_EVENT_VALUE_CHANGE on CLICK, Disabled: send LV_EVENT_VALUE_CHANGE on PRESS > `LV_BTNMATRIX_CTRL_POPOVER` Show the button label in a popover when pressing this key > `LV_BTNMATRIX_CTRL_RECOLOR` Enable recoloring of button texts with `#`. E.g. `\"It's #ff0000 red#\"` 设置文本重新着色 > `LV_BTNMATRIX_CTRL_CUSTOM_1` Custom free to use flag > `LV_BTNMATRIX_CTRL_CUSTOM_2` Custom free to use flag ### 单次选中 设置只有一个按钮可以选择 ```c lv_btnmatrix_set_one_checked(btnm, true); //需要开启LV_BTNMATRIX_CTRL_CHECKABLE ``` ### 获取选中 ```c bool lv_btnmatrix_has_btn_ctrl(lv_obj_t *obj, uint16_t btn_id, lv_btnmatrix_ctrl_t ctrl); for(i 1; i < 7; i++) { if(lv_btnmatrix_has_btn_ctrl(obj, i, LV_BTNMATRIX_CTRL_CHECKED)) break; } ``` ### 设置透明 ```c lv_obj_set_style_border_width(btnm1, 0, LV_PART_MAIN); lv_obj_set_style_bg_opa(btnm1, 0, LV_PART_MAIN); /*Hide the background*/ lv_obj_set_style_bg_opa(btnm1, 0, LV_PART_ITEMS); /*Hide the background*/ lv_obj_set_style_shadow_width(btnm1, 0, LV_PART_ITEMS); lv_obj_set_style_shadow_width(btnm1, 0, LV_PART_MAIN); ``` ![image 20240601235911025](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406012359142.png) ## 文本区域lv_textarea 文本输入框, 用户可以在里面输入文本内容 + LV_PART_MAIN 主体 + LV_PART_SCROLLBAR 滚动条 + LV_PART_SELECTED 选中文本 + LV_PART_CURSOR 光标 + LV_PART_TEXTAREA_PLACEHOLDER 占位符(默认文字) ### 添加文本 `lv_textarea_add_char(textarea, 'c')` `lv_textarea_add_text(textarea, \"insert this text\")` > To add wide characters like `'á'`, `'ß'` or CJK characters use `lv_textarea_add_text(ta, \"á\")` `lv_textarea_set_text(ta, \"New text\")` changes the whole text. ### 删除文本 To delete a character from the left of the current cursor position use `lv_textarea_del_char(textarea)`. To delete from the right use `lv_textarea_del_char_forward(textarea)` ### 设置占位符 A placeholder text can be specified which is displayed when the Text area is empty with `lv_textarea_set_placeholder_text(ta, \"Placeholder text\")` ### 使用键盘 ```c lv_obj_t *keyboard lv_keyboard_create(lv_src_act()); lv_keyboard_set_textarea(keyboard, ta) ``` ### 设置光标 The cursor position can be modified directly like `lv_textarea_set_cursor_pos(textarea, 10)`. The `0` position means \"before the first characters\", `LV_TA_CURSOR_LAST` means \"after the last character\" `lv_textarea_cursor_right(textarea)` `lv_textarea_cursor_left(textarea)` `lv_textarea_cursor_up(textarea)` `lv_textarea_cursor_down(textarea)` If `lv_textarea_set_cursor_click_pos(textarea, true)` is applied the cursor will jump to the position where the Text area was clicked.设置点击切换光标位置 ### 单行模式 If `lv_textarea_set_one_line(textarea, true)` is applied the cursor will jump to the position where the Text area was clicked. ### 密码模式 `lv_textarea_set_password_mode(textarea, true)`. If the `•` ([Bullet, U+2022](http://www.fileformat.info/info/unicode/char/2022/index.htm)) character exists in the font, the entered characters are converted to it after some time or when a new character is entered. If `•` not exists, `*` will be used. In password mode `lv_textarea_get_text(textarea)` returns the actual text entered, not the bullet characters. 可以使用`lv_textarea_passwd_show_time(ta, time)`设置字符显示的时间, 之后隐藏 The visibility time can be adjusted with `LV_TEXTAREA_DEF_PWD_SHOW_TIME` in `lv_conf.h`还可以通过配置文件` ### 设置可以输入的字符 You can set a list of accepted characters with `lv_textarea_set_accepted_chars(textarea, \"0123456789.+ \")`. Other characters will be ignored. ### 设置最大长度 The maximum number of characters can be limited with `lv_textarea_set_max_length(textarea, max_char_num)` ### 事件 `LV_EVENT_INSERT` Sent right before a character or text is inserted. The event parameter is the text about to be inserted. `lv_textarea_set_insert_replace(textarea, \"New text\")` replaces the text to insert. The new text cannot be in a local variable which is destroyed when the event callback exists. `\"\"` means do not insert anything. `LV_EVENT_VALUE_CHANGED` Sent when the content of the text area has been changed. `LV_EVENT_READY` Sent when `LV_KEY_ENTER` is pressed (or sent) to a one line text area. > 有多个文本框的时候, 可以使用LV_EVENT_FOCUSED这一个事件控制实际聚焦的文本框 ## 键盘lv_keyboard + LV_PART_MAIN主题部分 + LV_PART_ITEMS 按钮 ### 关联文本框 You can assign a [Text area](https://docs.lvgl.io/8.2/widgets/core/textarea.html) to the Keyboard to automatically put the clicked characters there. To assign the text area, use `lv_keyboard_set_textarea(kb, ta)`. ### 设置模式 `LV_KEYBOARD_MODE_TEXT_LOWER` Display lower case letters 小写 `LV_KEYBOARD_MODE_TEXT_UPPER` Display upper case letters 大写 `LV_KEYBOARD_MODE_TEXT_SPECIAL` Display special characters 特殊字符 `LV_KEYBOARD_MODE_NUMBER` Display numbers, +/ sign, and decimal dot 数字 `LV_KEYBOARD_MODE_USER_1` through `LV_KEYBOARD_MODE_USER_4` User defined modes. To set the mode manually, use `lv_keyboard_set_mode(kb, mode)`. The default mode is `LV_KEYBOARD_MODE_TEXT_UPPER`. ### 弹窗 To enable key popovers on press, like on common Android and iOS keyboards, use `lv_keyboard_set_popovers(kb, true)` ### 事件 `LV_EVENT_VALUE_CHANGED` Sent when the button is pressed/released or repeated after long press. The event data is set to the ID of the pressed/released button. `LV_EVENT_READY` The *Ok* button is clicked. `LV_EVENT_CANCEL` The *Close* button is clicked. ### 按键重设 `LV_SYMBOL_OK` Apply. `LV_SYMBOL_CLOSE` or `LV_SYMBOL_KEYBOARD` Close. `LV_SYMBOL_BACKSPACE` Delete on the left. `LV_SYMBOL_LEFT` Move the cursor left. `LV_SYMBOL_RIGHT` Move the cursor right. `LV_SYMBOL_NEW_LINE` New line. *\"ABC\"* Load the uppercase map. *\"abc\"* Load the lower case map. *\"1#\"* Load the lower case map. > You can specify a new map (layout) for the keyboard with `lv_keyboard_set_map(kb, map)` and `lv_keyboard_set_ctrl_map(kb, ctrl_map)` ### 实现切换键盘 ```c void kb_cb(lv_event_t *e){ lv_event_code_t code lv_event_get_code(e); lv_obj_t * obj lv_event_get_target(e); printf(\"there1\\n\"); if(code LV_EVENT_VALUE_CHANGED){ printf(\"there\\n\"); uint16_t id lv_btnmatrix_get_selected_btn(obj); const char * txt lv_btnmatrix_get_btn_text(obj, id); if(strcmp(txt, LV_SYMBOL_KEYBOARD) 0){ if(lv_keyboard_get_mode(obj) LV_KEYBOARD_MODE_NUMBER){ lv_keyboard_set_mode(obj, LV_KEYBOARD_MODE_TEXT_LOWER); }else{ lv_keyboard_set_mode(obj, LV_KEYBOARD_MODE_NUMBER); } } } } ``` > 这里获取信息实际使用的是矩阵键盘的获取方式 ### 示例 ```c Instead of the regular lv_obj_add/clear_state() functions the lv_imgbtn_set_state(imgbtn, LV_IMGBTN_STATE_...) functions should be used to manually set a state. ``` ## 图片按钮 + LV_PART_MAIN ### 设置图片 To set the image in a state, use the `lv_imgbtn_set_src(imgbtn, LV_IMGBTN_STATE_..., src_left, src_center, src_right)`. > 这里可以为不同的状态设置不同的图片源, 同时可以展示三个图片源, 为了显示, 需要计算三个图片的大小 `LV_IMGBTN_STATE_RELEASED` `LV_IMGBTN_STATE_PRESSED` `LV_IMGBTN_STATE_DISABLED` `LV_IMGBTN_STATE_CHECKED_RELEASED` `LV_IMGBTN_STATE_CHECKED_PRESSED` `LV_IMGBTN_STATE_CHECKED_DISABLED` ### 设置状态 Instead of the regular `lv_obj_add/clear_state()` functions the `lv_imgbtn_set_state(imgbtn, LV_IMGBTN_STATE_...)` functions should be used to manually set a state. ```c void event_cb(lv_event_t * e) { lv_obj_t * obj lv_event_get_target(e); lv_event_code_t code lv_event_get_code(e); if (code LV_EVENT_PRESSED) { lv_obj_set_style_img_opa(obj, LV_OPA_50, LV_STATE_DEFAULT); } if (code LV_EVENT_RELEASED) { lv_obj_set_style_img_opa(obj, LV_OPA_100, LV_STATE_DEFAULT); } } void my_gui(void) { lv_obj_t * imgbtn lv_imgbtn_create(lv_scr_act()); lv_imgbtn_set_src(imgbtn, LV_IMGBTN_STATE_RELEASED, NULL, &lymy, NULL); lv_obj_align(imgbtn, LV_ALIGN_CENTER, 0, 0); lv_obj_add_event_cb(imgbtn, event_cb, LV_EVENT_ALL, NULL); } ``` ### 透明度图片 ![image 20240602111243432](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406021112639.png) ## 选项卡 可以实现多个页面的切换 Tab view is built from other widgets: Main container: [lv_obj](https://docs.lvgl.io/8.2/widgets/obj.html)) Tab buttons: [lv_btnmatrix](https://docs.lvgl.io/8.2/widgets/core/btnmatrix.html) Container for the tabs: [lv_obj](https://docs.lvgl.io/8.2/widgets/obj.html) Content of the tabs: [lv_obj](https://docs.lvgl.io/8.2/widgets/obj.html) ### 创建 `lv_tabview_create(parent, tab_pos, tab_size);` creates a new empty Tab view. `tab_pos` can be `LV_DIR_TOP/BOTTOM/LEFT/RIGHT` to position the tab buttons to a side. `tab_size` is the height (in case of `LV_DIR_TOP/BOTTOM`) or width (in case of `LV_DIR_LEFT/RIGHT`) tab buttons. 创建, 同时设置垂直水平以及切换按钮的宽度 ### 添加选项卡 New tabs can be added with `lv_tabview_add_tab(tabview, \"Tab name\")`. This will return a pointer to an [lv_obj](https://docs.lvgl.io/8.2/widgets/obj.html) object where the tab's content can be created. ### 设置当前 Use `lv_tabview_set_act(tabview, id, LV_ANIM_ON/OFF)` function ### 示例 ```c lv_obj_t * tabview lv_tabview_create(lv_scr_act(), LV_DIR_TOP, 25); lv_obj_t * tab1 lv_tabview_add_tab(tabview, \"Tab 1\"); lv_obj_t * tab2 lv_tabview_add_tab(tabview, \"Tab 2\"); lv_obj_t * tab3 lv_tabview_add_tab(tabview, \"Tab 3\"); lv_obj_t * label1 lv_label_create(tab1); lv_label_set_text(label1, \"This is a label on tab 1\"); ``` ![image 20240602124444755](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406021244931.png) ### 获取组件 ```c lv_obj_t * lv_tabview_get_tab_btns(lv_obj_t * tv);//获取按键矩阵 lv_obj_t * lv_tabview_get_content(lv_obj_t * tv); //获取主题 ``` > 可以获取按钮矩阵 ## 平铺视图 可以实现不同方向的页面切换, 使用滑动进行切换 + LV_PART_MAIN + LV_PART_SCROLLBAR ### 添加页面 `lv_tileview_add_tile(tileview, row_id, col_id, dir)` creates a new tile on the `row_id`th row and `col_id`th column. `dir` can be `LV_DIR_LEFT/RIGHT/TOP/BOTTOM/HOR/VER/ALL` or OR ed values to enable moving to the adjacent tiles into the given direction by swiping. 第二三个参数适用于设置页面的位置, 最后一个参数是可以切换的位置 ### 设置当前页面 The Tile view can scroll to a tile with `lv_obj_set_tile(tileview, tile_obj, LV_ANIM_ON/OFF)` or `lv_obj_set_tile_id(tileviewv, col_id, row_id, LV_ANIM_ON/OFF);` ### 移除滚动条 `lv_obj_remove_style(tileview, NULL, LV_PART_SCROLLBAR)` > 这时候设置以主界面为父对象的界面会固定在那里 ### 示例 ```c void my_gui(void) { lv_obj_t * tileview lv_tileview_create(lv_scr_act()); lv_obj_t * tile1 lv_tileview_add_tile(tileview, 0, 0, LV_DIR_ALL); lv_obj_t * tile2 lv_tileview_add_tile(tileview, 1, 0, LV_DIR_ALL); lv_obj_t * tile3 lv_tileview_add_tile(tileview, 1, 1, LV_DIR_ALL); lv_obj_t * tile4 lv_tileview_add_tile(tileview, 0, 1, LV_DIR_ALL); lv_obj_t * label1 lv_label_create(tile1); lv_label_set_text(label1, \"Tile 1\"); lv_obj_t * label2 lv_label_create(tile2); lv_label_set_text(label2, \"Tile 2\"); lv_obj_t * label3 lv_label_create(tile3); lv_label_set_text(label3, \"Tile 3\"); lv_obj_t * label4 lv_label_create(tile4); lv_label_set_text(label4, \"Tile 4\"); lv_obj_center(label1); lv_obj_center(label2); lv_obj_center(label3); lv_obj_center(label4); lv_obj_t * lable_left lv_label_create(lv_scr_act()); lv_label_set_text(lable_left, \"8:00 AM\"); lv_obj_align(lable_left, LV_ALIGN_TOP_LEFT, 0, 0); lv_obj_t * lable_reight lv_label_create(lv_scr_act()); lv_label_set_text(lable_left, LV_SYMBOL_WIFI \" 80%\" LV_SYMBOL_BATTERY_FULL); lv_obj_align(lable_left, LV_ALIGN_TOP_RIGHT, 0, 0); lv_obj_remove_style(tileview, NULL, LV_PART_SCROLLBAR); } ``` ![image 20240602210116808](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406022101914.png) ## 窗口lv_win 可以作为一个容器展示不同的页面 The Window is built from other widgets so you can check their documentation for details: Background: [lv_obj](https://docs.lvgl.io/8.2/widgets/obj.html) Header on the background: [lv_obj](https://docs.lvgl.io/8.2/widgets/obj.html) Title on the header: [lv_label](https://docs.lvgl.io/8.2/widgets/core/label.html) Buttons on the header: [lv_btn](https://docs.lvgl.io/8.2/widgets/core/btn.html) Content area on the background: [lv_obj](https://docs.lvgl.io/8.2/widgets/obj.html) ```c lv_win_create(parent, header_height) //creates a Window with an empty header. ``` ### 添加标题以及按钮 Any number of texts (but typically only one) can be added to the header with `lv_win_add_title(win, \"The title\")`. Control buttons can be added to the window's header with `lv_win_add_btn(win, icon, btn_width)`. `icon` can be any image source, and `btn_width` is the width of the button. ### 获取主体 `lv_win_get_header(win)` returns a pointer to the header, `lv_win_get_content(win)` returns a pointer to the content container to which the content of the window can be added. ### 示例 ```c void win_close_event_cb(lv_event_t * e) { lv_obj_t * win lv_event_get_user_data(e); lv_obj_del(win); } void my_gui(void) { lv_obj_t *win lv_win_create(lv_scr_act(), 30); lv_win_add_title(win, \"Window title\"); lv_obj_set_size(win, 200, 150); lv_obj_align(win, LV_ALIGN_CENTER, 0, 0); lv_obj_set_style_border_width(win, 1, LV_STATE_DEFAULT); lv_obj_set_style_border_opa(win, LV_OPA_20, LV_STATE_DEFAULT); lv_obj_set_style_border_color(win, lv_color_hex3(0x222), LV_STATE_DEFAULT); lv_obj_set_style_radius(win, 10, LV_STATE_DEFAULT); //设置圆角 lv_obj_t *btn lv_win_add_btn(win, LV_SYMBOL_CLOSE, 20); lv_obj_add_event_cb(btn, win_close_event_cb, LV_EVENT_CLICKED, win); lv_obj_set_style_shadow_width(btn, 0, LV_STATE_DEFAULT); lv_obj_set_style_text_color(btn, lv_color_hex3(0), LV_STATE_DEFAULT); lv_obj_set_style_text_color(btn, lv_color_hex3(0xff0000), LV_STATE_PRESSED); lv_obj_set_style_bg_opa(btn, 0, LV_STATE_DEFAULT); } ``` ![image 20240602215120505](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406022151710.png) ## 消息框lv_msgbox Background: [lv_obj](https://docs.lvgl.io/8.2/widgets/obj.html) Close button: [lv_btn](https://docs.lvgl.io/8.2/widgets/core/btn.html) Title and text: [lv_label](https://docs.lvgl.io/8.2/widgets/core/label.html) Buttons: [lv_btnmatrix](https://docs.lvgl.io/8.2/widgets/core/btnmatrix.html) `lv_msgbox_create(parent, title, txt, btn_txts[], add_close_btn)` > If `parent` is `NULL` the message box will be modal. `title` and `txt` are strings for the title and the text. `btn_txts[]` is an array with the buttons' text. E.g. `const char * btn_txts[] {\"Ok\", \"Cancel\", NULL}`. `add_colse_btn` can be `true` or `false` to add/don't add a close button. `lv_obj_t *msgbox lv_msgbox_create(lv_scr_act(), \"title\", \"Hello\", btns, true);` ![image 20240602221936460](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406022219577.png) ### 关闭 `lv_msgbox_close(msgbox)` closes (deletes) the message box. ### 获取部件 ```c lv_obj_t * lv_msgbox_get_title(lv_obj_t * mbox); lv_obj_t * lv_msgbox_get_close_btn(lv_obj_t * mbox); lv_obj_t * lv_msgbox_get_text(lv_obj_t * mbox); lv_obj_t * lv_msgbox_get_btns(lv_obj_t * mbox); ``` ### 事件 `LV_EVENT_VALUE_CHANGED` is sent by the buttons if one of them is clicked. `LV_OBJ_FLAG_EVENT_BUBBLE` is enabled on the buttons so you can add events to the message box itself. In the event handler, `lv_event_get_target(e)` will return the button matrix and **`lv_event_get_current_target(e)` will return the message box.** `lv_msgbox_get_active_btn(msgbox)` and `lv_msgbox_get_active_btn_text(msgbox)` can be used to get the index and text of the clicked button.获取按压的按钮的索引以及文字 ### 显示以及隐藏 ```c lv_obj_add_flag(msgbox, LV_OBJ_FLAG_HIDDEN); lv_obj_clear_flag(msgbox, LV_OBJ_FLAG_HIDDEN); ``` ### 示例 ```c void event_cb(lv_event_t *e){ lv_event_code_t code lv_event_get_code(e); lv_obj_t * obj lv_event_get_current_target(e); //使用这一个才可以获取 if(code LV_EVENT_VALUE_CHANGED){ const char * txt lv_msgbox_get_active_btn_text(obj); printf(\"Button: %s\\n\", txt); lv_obj_del(obj); } } const char* btns[] {\" \", \" \", \"OK\", \"\"}; void my_gui(void) { lv_obj_t *msgbox lv_msgbox_create(lv_scr_act(), LV_SYMBOL_WARNING \"Notice\", \"Excession volume may damage hearing\", btns, true); lv_obj_set_size(msgbox, 220, 148); lv_obj_center(msgbox); lv_obj_set_style_border_width(msgbox, 0, LV_STATE_DEFAULT); lv_obj_set_style_shadow_width(msgbox, 20, LV_STATE_DEFAULT); lv_obj_set_style_shadow_color(msgbox, lv_color_hex3(0xa9a9a9), LV_STATE_DEFAULT); lv_obj_set_style_pad_top(msgbox, 18, LV_STATE_DEFAULT); lv_obj_set_style_pad_left(msgbox, 20, LV_STATE_DEFAULT); //设置填充(左边间距) lv_obj_add_event_cb(msgbox, event_cb, LV_EVENT_VALUE_CHANGED, NULL); lv_obj_t * title lv_msgbox_get_title(msgbox); lv_obj_set_style_text_color(title, lv_color_hex(0xff0000), LV_STATE_DEFAULT); lv_obj_set_style_text_font(title, &lv_font_montserrat_20, LV_STATE_DEFAULT); lv_obj_t * content lv_msgbox_get_content(msgbox); lv_obj_set_style_text_font(content, &lv_font_montserrat_16, LV_STATE_DEFAULT); lv_obj_set_style_text_color(content, lv_color_hex(0x6c6c6c), LV_STATE_DEFAULT); lv_obj_set_style_pad_top(content, 15, LV_STATE_DEFAULT); lv_obj_t * btns_bg lv_msgbox_get_btns(msgbox); lv_obj_set_style_bg_opa(btns_bg, 0, LV_PART_ITEMS); lv_obj_set_style_shadow_width(btns_bg, 0, LV_PART_ITEMS); lv_obj_set_style_border_width(btns_bg, 0, LV_PART_ITEMS); } ``` > ![image 20240602230947649](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406022309915.png) ## 微调器 实际是一个数字文本, 可以精确调节参数的值 + LV_PART_MAIN + LV_PART_CURSOR ### 设置值 `lv_spinbox_set_value(spinbox, 1234)` sets a new value on the Spinbox. 设置当前值 `lv_spinbox_increment(spinbox)` and `lv_spinbox_decrement(spinbox)` increments/decrements the value of the Spinbox according to the currently selected digit. 当前选中的值加减 `lv_spinbox_set_range(spinbox, 1000, 2500)` sets a range. If the value is changed by `lv_spinbox_set_value`, by *Keys*,`lv_spinbox_increment/decrement` this range will be respected. 设置范围 `lv_spinbox_set_step(spinbox, 100)` sets which digits to change on increment/decrement. Only multiples of ten can be set, and not for example 3. 设置步长, 实际是移动一下光标的位置 `lv_spinbox_set_pos(spinbox, 1)` sets the cursor to a specific digit to change on increment/decrement. For example position '0' sets the cursor to the least significant digit. 和上一个会冲突 If an encoder is used as input device, the selected digit is shifted to the right by default whenever the encoder button is clicked. To change this behaviour to shifting to the left, the `lv_spinbox_set_digit_step_direction(spinbox, LV_DIR_LEFT)` can be used 设置选中的移动方向 ### 设置格式 `lv_spinbox_set_digit_format(spinbox, digit_count, separator_position)` sets the number format. `digit_count` is the number of digits excluding the decimal separator and the sign. `separator_position` is the number of digits before the decimal point. If 0, no decimal point is 设置格式, 总的位数以及小数点的位置(第二个参数是整数的位置) > 这一个小数点只是一个显示, 不会改变实际的值 ### 获取当前值 ```c lv_spinbox_get_value(spinbox); ``` ### 示例 ```c void btn1_event_cb(lv_event_t *e) { lv_obj_t *spinbox lv_event_get_user_data(e); lv_spinbox_increment(spinbox); int value lv_spinbox_get_value(spinbox); int value1 value / 1000; int value2 value % 1000; printf(\"Value %d.%d\\n\", value1, value2 > 0 ? value2 : value2); } void btn2_event_cb(lv_event_t *e) { lv_obj_t *spinbox lv_event_get_user_data(e); lv_spinbox_decrement(spinbox); int value lv_spinbox_get_value(spinbox); int value1 value / 1000; int value2 value % 1000; printf(\"Value %d.%d\\n\", value1, value2 > 0 ? value2 : value2); } void my_gui(void) { lv_obj_t *spinbox lv_spinbox_create(lv_scr_act()); lv_spinbox_set_range(spinbox, 10000, 10000); lv_spinbox_set_digit_format(spinbox, 5, 2); lv_spinbox_set_step(spinbox, 100); lv_obj_center(spinbox); lv_obj_t *btn1 lv_btn_create(lv_scr_act()); lv_obj_align_to(btn1, spinbox, LV_ALIGN_OUT_RIGHT_MID, 10, 0); lv_obj_add_event_cb(btn1, btn1_event_cb, LV_EVENT_CLICKED, spinbox); lv_obj_set_style_bg_img_src(btn1, LV_SYMBOL_PLUS, 0); lv_obj_t *btn2 lv_btn_create(lv_scr_act()); lv_obj_align_to(btn2, spinbox, LV_ALIGN_OUT_LEFT_MID, 10, 0); lv_obj_add_event_cb(btn2, btn2_event_cb, LV_EVENT_CLICKED, spinbox); lv_obj_set_style_bg_img_src(btn2, LV_SYMBOL_MINUS, 0); } ``` ![image 20240602235433337](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406022354573.png) ## 表格lv_table `LV_PART_MAIN` The background of the table uses all the typical background style properties. `LV_PART_ITEMS` The cells of the table also use all the typical background style properties and the text properties. ### 设置行列 To explicitly set number of rows and columns use `lv_table_set_row_cnt(table, row_cnt)` and `lv_table_set_col_cnt(table, col_cnt)` 设置行数以及列数 ### 设置内容 `lv_table_set_cell_value(table, row, col, \"Content\")`. The text is saved by the table so it can be even a local variable. `void lv_table_set_cell_value_fmt(lv_obj_t * obj, uint16_t row, uint16_t col, const char * fmt, ...)`格式化输入 > 表格里面可以使用换行符 ### 设置宽度 The width of the columns can be set with `lv_table_set_col_width(table, col_id, width)`. The overall width of the Table object will be set to the sum of columns widths. 高度是里面的内容决定的 ### 水平合并 Cells can be merged horizontally with `lv_table_add_cell_ctrl(table, row, col, LV_TABLE_CELL_CTRL_MERGE_RIGHT)`. To merge more adjacent cells call this function for each cell."},"/note/嵌入式/第三方移植/lvgl/2024-5-26-05lvgl模拟器.html":{"title":"lvgl模拟器","content":" layout: post title: \"lvgl模拟器\" date: 2024 1 11 15:39:08 +0800 tags: stm32 lvgl # lvgl模拟器 [LVGL在VScode中安装模拟器运行配置笔记教程_vscode lvgl CSDN博客](https://blog.csdn.net/weixin_49337111/article/details/136536375) 在PC使用软件模拟lvgl, 不需要嵌入式的硬件 优点: 便于开发, 跨平台开发 [lvgl/lv_port_pc_eclipse at release/v8.2 (github.com)](https://github.com/lvgl/lv_port_pc_eclipse/tree/release/v8.2) 从这一个github库里面获取源码, 这一个库引用了其他两个库, 所以需要一起下载, 这里下载8.2的版本 ![image 20240526232128951](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405262321022.png) 其他两个库也一样 ![image 20240526232154356](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405262321436.png) 下载以后把其他的两个库的文件解压到第一个库的两个文件夹里面 [Releases · libsdl org/SDL (github.com)](https://github.com/libsdl org/SDL/releases/) 从这一个网址下载 ![image 20240526235406171](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405262354209.png) 把![image 20240526235431479](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405262354525.png) 复制到mingw里面 ![image 20240526235511842](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405262355934.png) 实际执行的时候需要这一个库 ![image 20240526235619476](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405262356606.png) 把他和生成的文件放到一个文件夹里面, 使用vscode, cmake就可以运行了 ![image 20240527225606771](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405272256882.png) 配置屏幕的大小lv_drv_conf.h这一个文件;里面"},"/note/嵌入式/第三方移植/lvgl/2025-12-5-14-操作系统使用.html":{"title":"操作系统使用","content":"# 操作系统使用 ## SDL ```c // Linux下面模拟使用 static void lv_linux_disp_init(void) { const int width atoi(getenv(\"LV_SDL_VIDEO_WIDTH\") ? : \"320\"); const int height atoi(getenv(\"LV_SDL_VIDEO_HEIGHT\") ? : \"240\"); lv_sdl_window_create(width, height); } static void lv_linux_indev_init(void) { lv_sdl_mouse_create(); } ``` > 运行SDL库作为模拟器 ## 整个屏幕 ```c // 开发板使用, 使用fb设备 static void lv_linux_disp_init(void) { // 初始化一个屏幕设备 const char *device getenv_default(\"LV_LINUX_FBDEV_DEVICE\", \"/dev/fb0\"); lv_display_t * disp lv_linux_fbdev_create(); lv_linux_fbdev_set_file(disp, device); } // 在Linux图形子系统中，DRI（Direct Rendering Infrastructure，直接渲染基础架构） // 是一套允许应用程序直接与GPU交互的机制，旨在提升3D图形渲染性能并减少延迟。 static void lv_linux_disp_init(void) { const char *device getenv_default(\"LV_LINUX_DRM_CARD\", \"/dev/dri/card0\"); lv_display_t * disp lv_linux_drm_create(); lv_linux_drm_set_file(disp, device, 1); } ```"},"/note/嵌入式/第三方移植/lvgl/2024-6-3-10文件系统移植.html":{"title":"文件系统移植","content":" layout: post title: \"文件系统移植\" date: 2024 1 11 15:39:08 +0800 tags: stm32 lvgl # 文件系统移植 lvgl相关的文件: lvgl release v8.2\\src\\extra\\libs\\fsdrv\\lv_fs_fatfs.c 实际使用的是之前自己移植的那一个fatfs文件系统 ![image 20240603191632550](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406031916602.png) > LV_FS_FATFS_LETTER是盘符 这一个文件实际是对文件系统的又一次封装"},"/note/嵌入式/第三方移植/lvgl/2024-6-3-11-中文字库.html":{"title":"中文字库","content":" layout: post title: \"中文字库\" date: 2024 1 11 15:39:08 +0800 tags: stm32 lvgl # 中文字库 需要字体文件(ttf, otf等) C:\\Windows\\Fonts这一个文件夹里面有, 不是每一个都是可以商用的 [Online font converter TTF or WOFF fonts to C array LVGL](https://lvgl.io/tools/fontconverter)在线转换工具 ![image 20240603192848130](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406031928170.png) ![image 20240603192958067](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406031929102.png) **字符集** **Unicode** **编码范围** 基本汉字 0x4E00 0x9FA5 数字、拉丁字母、标点符号 0x20 0x7E ![image 20240603193753701](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406031937739.png) ```c LV_FONT_DECLARE(Font30) /* 声明字体 */ void my_gui(void) { lv_obj_t *font_label lv_label_create(lv_scr_act()); lv_obj_set_style_text_font(font_label, &Font30, LV_STATE_DEFAULT); lv_label_set_text(font_label, \"我是天才\"); lv_obj_center(font_label); } ``` ## 特殊图标 在使用特殊的图标的时候, 需要使用这一个图标的Unicode码, 之后需要的是UTF 8码，所以，需要把Unicode码转换成UTF 8编码才行。转换编码，可以使用下面的在线工具。 UTF 8工具：https://www.cogsci.ed.ac.uk/~richard/utf 8.cgi?input F146&mode hex ### 天气图标 和风天气官方提供了每个天气状况对应的图标，这些图标可以做成图片显示，也可以做成字体显示 awesome字体：用来显示温湿度的符号。 LVGL已经包含的57个就是awesome图标 awesome字体的下载链接如下。 > 官方下载链接：https://fontawesome.com/download 因为温湿度的符号用键盘打不出来，所以只能在Range一栏写它的Unicode码。 温湿度符号的Unicode码是多少，可以在awesome官方网站对应符号页面看到。 > 温度符号页面链接：https://fontawesome.com/icons/temperature three quarters?f classic&s solid > > 湿度符号页面链接：https://fontawesome.com/icons/droplet?f classic&s solid ![image 20240606202147082](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406062021323.png) 天气图标的Unicode码查看，需要使用一个字体编辑软件查看，比如Font Creator。 > Font Creator软件下载地址：https://www.xitongzhijia.net/soft/116980.html 软件仅供交流学习使用，尊重版权，拒绝盗版，从你我做起。 使用Font Creator软件打开qweather icon.ttf字体文件，就可以看到每个图标的Unicode码了，如下图所示。 天气图标的Unicode码查看，需要使用一个字体编辑软件查看，比如Font Creator。 > Font Creator软件下载地址：https://www.xitongzhijia.net/soft/116980.html 使用Font Creator软件打开qweather icon.ttf字体文件，就可以看到每个图标的Unicode码了 https://dev.qweather.com/docs/resource/icons/ 上面这个链接可以查到各种天气图标对应的图标代码, 之后使用Font Creator软件获取所有需要使用的图标的Unicode编码"},"/note/嵌入式/第三方移植/lvgl/2024-5-26-03初始化.html":{"title":"初始化","content":" layout: post title: \"初始化\" date: 2024 1 11 15:39:08 +0800 tags: stm32 lvgl # 初始化 ## 主函数 ```c \tESP_LOGI(TAG, \"Initialize LVGL library\"); lv_init(); // alloc draw buffers used by LVGL // it's recommended to choose the size of the draw buffer(s) to be at least 1/10 screen sized lv_color_t *buf1 heap_caps_malloc(EXAMPLE_LCD_H_RES * 20 * sizeof(lv_color_t), MALLOC_CAP_DMA); assert(buf1); lv_color_t *buf2 heap_caps_malloc(EXAMPLE_LCD_H_RES * 20 * sizeof(lv_color_t), MALLOC_CAP_DMA); assert(buf2); // initialize LVGL draw buffers lv_disp_draw_buf_init(&disp_buf, buf1, buf2, EXAMPLE_LCD_H_RES * 20); ESP_LOGI(TAG, \"Register display driver to LVGL\"); \tlv_disp_drv_init(&disp_drv); disp_drv.hor_res EXAMPLE_LCD_H_RES; disp_drv.ver_res EXAMPLE_LCD_V_RES; disp_drv.flush_cb example_lvgl_flush_cb; //实际使用的绘制函数 disp_drv.drv_update_cb example_lvgl_port_update_callback; disp_drv.draw_buf &disp_buf; disp_drv.user_data panel_handle; lv_disp_t *disp lv_disp_drv_register(&disp_drv); ESP_LOGI(TAG, \"Install LVGL tick timer\"); // Tick interface for LVGL (using esp_timer to generate 2ms periodic event) const esp_timer_create_args_t lvgl_tick_timer_args { .callback &example_increase_lvgl_tick, .name \"lvgl_tick\" }; esp_timer_handle_t lvgl_tick_timer NULL; ESP_ERROR_CHECK(esp_timer_create(&lvgl_tick_timer_args, &lvgl_tick_timer)); ESP_ERROR_CHECK(esp_timer_start_periodic(lvgl_tick_timer, EXAMPLE_LVGL_TICK_PERIOD_MS * 1000)); #if CONFIG_EXAMPLE_LCD_TOUCH_ENABLED static lv_indev_drv_t indev_drv; // Input device driver (Touch) lv_indev_drv_init(&indev_drv); indev_drv.type LV_INDEV_TYPE_POINTER; indev_drv.disp disp; indev_drv.read_cb example_lvgl_touch_cb; //使用这一个函数获取实际的触摸的位置 indev_drv.user_data tp; lv_indev_drv_register(&indev_drv); #endif ``` > main函数的初始化 ## 输入设备 ```c static void example_lvgl_touch_cb(lv_indev_drv_t * drv, lv_indev_data_t * data) { uint16_t touchpad_x[1] {0}; uint16_t touchpad_y[1] {0}; uint8_t touchpad_cnt 0; /* Read touch controller data */ esp_lcd_touch_read_data(drv >user_data); /* Get coordinates */ bool touchpad_pressed esp_lcd_touch_get_coordinates(drv >user_data, touchpad_x, touchpad_y, NULL, &touchpad_cnt, 1); if (touchpad_pressed && touchpad_cnt > 0) { data >point.x touchpad_x[0]; data >point.y touchpad_y[0]; data >state LV_INDEV_STATE_PRESSED; } else { data >state LV_INDEV_STATE_RELEASED; } } ``` > 获取数模位置的函数 ```c static void example_lvgl_flush_cb(lv_disp_drv_t *drv, const lv_area_t *area, lv_color_t *color_map) { esp_lcd_panel_handle_t panel_handle (esp_lcd_panel_handle_t) drv >user_data; int offsetx1 area >x1; int offsetx2 area >x2; int offsety1 area >y1; int offsety2 area >y2; // copy a buffer's content to a specific area of the display esp_lcd_panel_draw_bitmap(panel_handle, offsetx1, offsety1, offsetx2 + 1, offsety2 + 1, color_map); } ``` > 实际的绘制函数 ```c /* Rotate display and touch, when rotated screen in LVGL. Called when driver parameters are updated. 这一个函数适用于屏幕的旋转的*/ static void example_lvgl_port_update_callback(lv_disp_drv_t *drv) { esp_lcd_panel_handle_t panel_handle (esp_lcd_panel_handle_t) drv >user_data; switch (drv >rotated) { case LV_DISP_ROT_NONE: // Rotate LCD display esp_lcd_panel_swap_xy(panel_handle, false); esp_lcd_panel_mirror(panel_handle, true, false); #if CONFIG_EXAMPLE_LCD_TOUCH_ENABLED // Rotate LCD touch esp_lcd_touch_set_mirror_y(tp, false); esp_lcd_touch_set_mirror_x(tp, false); #endif break; case LV_DISP_ROT_90: // Rotate LCD display esp_lcd_panel_swap_xy(panel_handle, true); esp_lcd_panel_mirror(panel_handle, true, true); #if CONFIG_EXAMPLE_LCD_TOUCH_ENABLED // Rotate LCD touch esp_lcd_touch_set_mirror_y(tp, false); esp_lcd_touch_set_mirror_x(tp, false); #endif break; case LV_DISP_ROT_180: // Rotate LCD display esp_lcd_panel_swap_xy(panel_handle, false); esp_lcd_panel_mirror(panel_handle, false, true); #if CONFIG_EXAMPLE_LCD_TOUCH_ENABLED // Rotate LCD touch esp_lcd_touch_set_mirror_y(tp, false); esp_lcd_touch_set_mirror_x(tp, false); #endif break; case LV_DISP_ROT_270: // Rotate LCD display esp_lcd_panel_swap_xy(panel_handle, true); esp_lcd_panel_mirror(panel_handle, false, false); #if CONFIG_EXAMPLE_LCD_TOUCH_ENABLED // Rotate LCD touch esp_lcd_touch_set_mirror_y(tp, false); esp_lcd_touch_set_mirror_x(tp, false); #endif break; } } ``` ## 输入设备 ### 按键 ```c /* * Button * */ /*Initialize your button if you have*/ button_init(); /*Register a button input device*/ lv_indev_drv_init(&indev_drv); indev_drv.type LV_INDEV_TYPE_BUTTON; indev_drv.read_cb button_read; indev_button lv_indev_drv_register(&indev_drv); /*Assign buttons to points on the screen*/ static const lv_point_t btn_points[2] { {10, 10}, /*Button 0 > x:10; y:10*/ {40, 100}, /*Button 1 > x:40; y:100*/ }; lv_indev_set_button_points(indev_button, btn_points); ``` > 这一个是官方的按键的设置 ```c /*Will be called by the library to read the button*/ static void button_read(lv_indev_drv_t * indev_drv, lv_indev_data_t * data) { static uint8_t last_btn 0; /*Get the pressed button's ID*/ int8_t btn_act button_get_pressed_id(); if(btn_act > 0) { data >state LV_INDEV_STATE_PR; last_btn btn_act; } else { data >state LV_INDEV_STATE_REL; } /*Save the last pressed button's ID*/ data >btn_id last_btn; } /*Get ID (0, 1, 2 ..) of the pressed button*/ static int8_t button_get_pressed_id(void) { uint8_t i; /*Check to buttons see which is being pressed (assume there are 2 buttons)*/ for(i 0; i < 2; i++) { /*Return the pressed button's ID*/ if(button_is_pressed(i)) { return i; } } /*No button pressed*/ return 1; } /*Test if `id` button is pressed or not*/ static bool button_is_pressed(uint8_t id) { /*Your code comes here*/ return false; } ``` + 在ESP IDF里面添加一个按键 ```c //按键 gpio_config_t key_gpio_config { .mode GPIO_MODE_INPUT, .pin_bit_mask 1ULL << GPIO_NUM_23, .pull_up_en 1, .pull_down_en 0, .intr_type GPIO_INTR_DISABLE, }; ESP_ERROR_CHECK(gpio_config(&key_gpio_config)); ``` ```c //按键初始化 lv_indev_t * indev_button; static lv_indev_drv_t indev_drv; // Input device driver (Touch) /*Register a button input device*/ lv_indev_drv_init(&indev_drv); indev_drv.type LV_INDEV_TYPE_BUTTON; indev_drv.read_cb button_read; indev_button lv_indev_drv_register(&indev_drv); /*Assign buttons to points on the screen*/ static const lv_point_t btn_points[2] { {64, 80}, /*Button 0 > x:10; y:10*/ }; lv_indev_set_button_points(indev_button, btn_points); ``` ```c /*Will be called by the library to read the button*/ static void button_read(lv_indev_drv_t * indev_drv, lv_indev_data_t * data) { if(gpio_get_level(GPIO_NUM_23) 0) { ESP_LOGI(TAG, \"KEY_PRESS\"); data >state LV_INDEV_STATE_PR; } else { data >state LV_INDEV_STATE_REL; } /*Save the last pressed button's ID*/ data >btn_id 0; } ``` ### 触摸屏 ```c /* * Touchpad * */ /*Initialize your touchpad if you have*/ touchpad_init(); /*Register a touchpad input device*/ lv_indev_drv_init(&indev_drv); indev_drv.type LV_INDEV_TYPE_POINTER; indev_drv.read_cb touchpad_read; indev_touchpad lv_indev_drv_register(&indev_drv); ``` ```c /*Will be called by the library to read the touchpad*/ static void touchpad_read(lv_indev_drv_t * indev_drv, lv_indev_data_t * data) { static lv_coord_t last_x 0; static lv_coord_t last_y 0; /*Save the pressed coordinates and the state*/ if(touchpad_is_pressed()) { touchpad_get_xy(&last_x, &last_y); data >state LV_INDEV_STATE_PR; } else { data >state LV_INDEV_STATE_REL; } /*Set the last pressed coordinates*/ data >point.x last_x; data >point.y last_y; } ``` ## 时基 ```c // Tick interface for LVGL (using esp_timer to generate 2ms periodic event) const esp_timer_create_args_t lvgl_tick_timer_args { .callback &example_increase_lvgl_tick, .name \"lvgl_tick\" }; esp_timer_handle_t lvgl_tick_timer NULL; ESP_ERROR_CHECK(esp_timer_create(&lvgl_tick_timer_args, &lvgl_tick_timer)); ESP_ERROR_CHECK(esp_timer_start_periodic(lvgl_tick_timer, EXAMPLE_LVGL_TICK_PERIOD_MS * 1000)); ``` ```c //在这一个函数里面调用lvgl的时基增加的函数 static void example_increase_lvgl_tick(void *arg) { /* Tell LVGL how many milliseconds has elapsed */ lv_tick_inc(EXAMPLE_LVGL_TICK_PERIOD_MS); } ``` ```c /*Use a custom tick source that tells the elapsed time in milliseconds. *It removes the need to manually update the tick with `lv_tick_inc()`)*/ #define LV_TICK_CUSTOM 0 #if LV_TICK_CUSTOM #define LV_TICK_CUSTOM_INCLUDE \"Arduino.h\" /*Header for the system time function*/ #define LV_TICK_CUSTOM_SYS_TIME_EXPR (millis()) /*Expression evaluating to current system time in ms*/ #endif /*LV_TICK_CUSTOM*/ ``` > 在lv_config.h这一个文件里面可以设置使用外部的时基"},"/note/嵌入式/第三方移植/lvgl/2024-1-11-02移植.html":{"title":"移植","content":" layout: post title: \"移植\" date: 2024 1 11 15:39:08 +0800 tags: stm32 lvgl # 移植 ## 移植关键点 ![image 20240111173245328](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111732382.png) > 显示是必须的 ![image 20240111175122572](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111751637.png) ![image 20240111175227364](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111752418.png) ![image 20240111175304448](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111753501.png) ## 实际移植 ![image 20240111180612620](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111806671.png) > 把库文件放在GUI/lvgl文件夹里面 > > 把示例文件放在GUI_APP文件夹里面 ![image 20240111181745589](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111817659.png) ![image 20240111183043644](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111830696.png) > 出现问题, 找不到文件lv_conf.h, 需要把跟文件夹下面的lv_conf_template.h改名 ### 输入输出配置 ![image 20240111184612136](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111846194.png) > 缓冲有三种: > > 1. 单缓冲: 当屏幕的大小是800*480的时候, 设置的buf大小是十行的像素的大小 > 2. 双缓冲: 有两个十行大小的buf, 交替使用(这个版本的优化不是很好) > 3. 全屏幕双缓冲 > 4. ![image 20240111192347243](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111923300.png) > > > 这里使用第一种, 添加宽度的宏定义, 之后屏蔽后面的代码 在设置屏幕的显示等都是在函数lv_port_disp_init里面实现的 ![image 20240111192639200](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111926236.png) > 设置屏幕尺寸, 分别是水平和竖直的长度 > > ![image 20240111192920909](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111929953.png) ![image 20240111193047629](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111930672.png) > 设置打点的方式 > > ![image 20240111193355336](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111933380.png) ### 输入设备配置 ![image 20240111193513093](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111935154.png) ![image 20240111193856557](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111938593.png) > 删除其他设备的函数声明和结构体 lv_port_indev_init函数里面把不需要的设备删除 ![image 20240111195329701](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111953730.png) > 初始化 ![image 20240111195611635](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111956668.png) > 检测是否有触摸 ![image 20240111195744803](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111957843.png) > 获取坐标 ### 提供时基 ![image 20240111195843890](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111958940.png) ![image 20240111200119155](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401112001191.png) > 在这个函数里面主要就是增加时基 > > ```c > LV_ATTRIBUTE_TICK_INC void lv_tick_inc(uint32_t tick_period) > { > tick_irq_flag 0; > sys_time + tick_period; > } > ``` ### 测试 ![image 20240111200616599](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401112006664.png) > 在这一步会报错, 因为使用的内存过大 ## 使用外部的SRAM ### 管理空间 ![image 20240526130657965](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405261306063.png) > 把内部管理空间放在外面, 这一个不推荐, 会使得速度降低 ### 绘图空间 在创建缓冲区的时候, 放在外部的空间 ## 内存管理 LVGL使用内存的地方是LVGL的管理, 图形缓冲区, OS以及其他一般使用15~40K字节 ### 自研内存管理 + 配置需要的内存池大小 + 初始化需要的内存池 + 配置自己的算法 编写lvgl的内存分配, 内存释放, 内存重新分配这三个函数, 在lv_conf.h这一个文件里面 ![image 20240526205020123](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405262050198.png) ### 自带内存管理 这一个内存的大小是通过lv_conf.h文件里面的LV_MEM_SIZE这一个宏定义进行控制 创建一个需要管理的内存池有三种方法1. 大数组(默认) 2. 地址段 3. 内存分配 ```c /********************** * GLOBAL FUNCTIONS **********************/ /** * Initialize the dyn_mem module (work memory and other variables) */ void lv_mem_init(void) { #if LV_MEM_CUSTOM 0 #if LV_MEM_ADR 0 #ifdef LV_MEM_POOL_ALLOC //使用函数进行分配 tlsf lv_tlsf_create_with_pool((void *)LV_MEM_POOL_ALLOC(LV_MEM_SIZE), LV_MEM_SIZE); #else /*Allocate a large array to store the dynamically allocated data*/ //定义一个大数组, 这一个是默认的方法 static LV_ATTRIBUTE_LARGE_RAM_ARRAY MEM_UNIT work_mem_int[LV_MEM_SIZE / sizeof(MEM_UNIT)]; tlsf lv_tlsf_create_with_pool((void *)work_mem_int, LV_MEM_SIZE); #endif #else //使用一块内存地址 tlsf lv_tlsf_create_with_pool((void *)LV_MEM_ADR, LV_MEM_SIZE); #endif #endif #if LV_MEM_ADD_JUNK LV_LOG_WARN(\"LV_MEM_ADD_JUNK is enabled which makes LVGL much slower\"); #endif } ``` ## 使用DMA2D lv_conf.h文件里面 ```c /* * GPU * */ /*Use STM32's DMA2D (aka Chrom Art) GPU*/ #define LV_USE_GPU_STM32_DMA2D 0 #if LV_USE_GPU_STM32_DMA2D /*Must be defined to include path of CMSIS header of target processor e.g. \"stm32f769xx.h\" or \"stm32f429xx.h\"*/ #define LV_GPU_DMA2D_CMSIS_INCLUDE #endif ``` > 之后在这里加一下头文件, 在MDK配置里面添加一下这一个芯片的宏定义, 实际使用的时候还是在之前自己写的那一个填充函数里面使用DMA2D ## 文件 + lv_port_disp_template.c/h 输出设备的配置文件 + lv_port_indev_template.c/h 输入设备的配置文件 + lv_conf.h 配置文件 ### lv_conf.h文件 1. 颜色, 深度, 字节交换, 屏幕透明 2. 内存, 算法的选择, 内存的大小 3. 硬件层, 显示的周期以及输入设备的读取周期 4. 特征, 绘图, 日志, 以及帧率显示 5. 编辑器, 大数组前缀, 内存对齐 6. 字体, 系统字体以及自定义字体 7. 文本, 字符编码, 文本特性 8. 核心部件, 使能以及失能部件 9. 拓展, 使能失能第三方部件 10. 实例"},"/note/嵌入式/第三方移植/lvgl/2024-6-3-12屏幕切换.html":{"title":"屏幕切换","content":" layout: post title: \"屏幕切换\" date: 2024 1 11 15:39:08 +0800 tags: stm32 lvgl # 屏幕切换 [LVGL如何创建页面并实现页面的切换_lvgl 页面切换 CSDN博客](https://blog.csdn.net/qq_28576837/article/details/136545143) 可以使用`lv_obj_clean()`这一个函数把当前屏幕里面的内容进行清理 也可以创建一个新的以NULL为父对象`lv_obj_create(NULL)`的普通对象, 然后使用`lv_scr_load()`进行加载"},"/note/嵌入式/第三方移植/libpeer/2025-6-2-MIPI.html":{"title":"MIPI","content":"# MIPI Mobile Industry Processor Interface MIPI 联盟主要是为移动处理器定制标准接口和规范，开发的接口广泛应用于处理器、相机、 显示屏、基带调制解调器等设备。 ![image 20250602095849805](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506020958092.png) ![image 20250602095908399](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506020959516.png) ### Multimedia ![image 20250602095937920](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506020959181.png) Multimedia 就是多媒体部分，分为如下几部分： + 摄像头，应用层有 CCS，协议层主要有 CSI 2、CSI 3，物理层有 A PHY、C PHY、D PHY和M PHY。 + 屏幕，应用层有DCS，协议层主要有DSI，物理层有A PHY、C PHY、D PHY。 ·触摸，应用层有TCS，协议层是I3C。 + 存储，UFS协议，这个是目前手机以及平板上最常用的存储协议，物理层为M PHY。 + 音频，协议层有SLIMIbus和SoundWire。 多媒体部分我们用的最多就是DSI和CSI，DSI应用于屏幕，CSI用于摄像头。对应的物理 层协议有A PHY、C PHY、D PHY和M PHY。 D PHY：目前用的最多的接口，不管是摄像头还是屏幕，D PHY接口为 1/2/4lane（lane 可 以理解为通道，也就是1/2/3/4通道，每个通道2条差分线），外加一对时钟线，数据线和时钟线 都是差分线，为电流驱动型，不同版本的D PHY速度不同，比如ESP32 P4用的V1.1版本的D PHY双lane最高可到3Gbps。D PHY最多10根线，有专门的时钟线来进行同步。 C PHY：随着屏幕和摄像头的分辨率以及帧率越来越高，D PHY 的带宽越来越不够用。C PHY应运而生，C PHY接口是1/2/3 Trio，每个Trio有3根线，最高9根线，没有专用的时钟线 了。C PHY目前在高端旗舰手机芯片中可能会用到 A PHY：主要为汽车自动驾驶而生，目前汽车自动驾驶发展非常迅猛， ADAS（高级驾驶 员辅助系统）摄像头于车载娱乐屏幕越来越多，分辨率也越来越高，而且车载摄像头和娱乐屏 幕分布比较分散，到主控的距离一般比较长。但是 C PHY和 D PHY的距离太短，最多不超过 15CM，显然不适合用在当今高度智能化的车载领域。A PHY于2020年9月发布，用于长距离、 超高速的汽车应用中，比如ADAS、自动驾驶系统 （ADS）、车载信息娱乐系统 （IVI） 和其他 环绕传感器。 M PHY：目前主要用在USF存储中。 ### Control&Data ![image 20250602100246731](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506021002962.png) ### Chip to Chip Inter Process Communications ![image 20250602100412782](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506021004997.png) ### Debug&Trace ![image 20250602100440727](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506021004930.png) ## MIPI DSI Display Serial Interface ![image 20250602100529883](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506021005960.png) MIPI DSI接口分为数据线和时钟线，均为差分信号。数据线可选择1/2/3/4 lanes，时钟线有 一对，最多 10 根线。MIPI DSI 以串行的方式发送指令和数据给屏幕，也可以读取屏幕中的信 息。如果屏幕的分辨率和帧率越高，需要的带宽就越大，就需要更多的数据线来传输图像数据， 但是ESP32 P4只支持使用2lanes来驱动MIPI屏幕。对于MIPI DSI接口而言，最常用的就是2 lanes 和 4 lanes。 ### MIPI DSI 分层 ![image 20250602100613838](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506021006942.png) 1. 应用层 应用层处理更高层次的编码，将要显示的数据打包进数据流中，下层会处理并发送应用层 的数据流。发送端将命令以及数据编码成MIPI DSI规格的格式，接收端则将接收到的数据还原 为原始的数据。 2. 协议层 协议层主要是打包数据，在原始的数据上添加ECC和校验和等东西。应用层传递下来的数 据会打包成两种格式的数据：长数据包和短数据包，关于长短数据包后面会有详细讲解。发送 端将原始数据打包好，添加包头和包尾，然后将打包好的数据发送给下层。接收端介绍到下层 传来的数据包以后执行相反的操作，去除包头和包尾，然后使用ECC进行校验接收到的数据， 如果没问题就将解包后的原始数据交给应用层。 3. 链路层 链路层负责如何将数据分配到具体的通道上，若MIPI DSI可以支持1/2/3/4 Lane，采用几通 道取决于你的实际应用，如果带宽需求低，那么2 Lane就够了，带宽高的话就要4 Lane。协议 层下来的数据包都是串行的，如果只有1 Lane的话，那就直接使用这1 Lane将数据串行的发送 出去，如果是2/4 Lane的话数据该如何发送呢？ ![image 20250602100703231](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506021007334.png) 如果要发送的数据和通道数不是整数倍数，那么先发送完的数据通道就进入EoT（End of Transmission）模式。 ![image 20250602100732170](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506021007279.png) 4. 物理层 物理层就是最底层了，完成MIPI DSI数据在具体电路上的发送与接收，与物理层紧密相关 的就是D PHY。物理层规定了MIPI DSI的整个电气属性，信号传输的时候电压等 ### 物理层 显示领域使用的D PHY比较多, 所以这里讲解D PHY D PHY是一个源同步、高速、低功耗、低开销的PHY，特别适合移动领域。D PHY主要用 于主处理器的摄像头和显示器外设，比如 MIPI 摄像头和屏幕。 D PHY 提供了一个同步通信接 口来连接主机和外设，在实际使用中提供一对时钟线以及一对或多对信号线。时钟线是单向的， 由主控产生，发送给设备。数据线根据实际配置，可以有 1~4 Lane，只有 Data0 这一组数据线 可以是单向也可以是双向的，其他组的数据线都是单向的。 数据链路分为High Speed模式和Low Power模式，也就是图22.2.1.1中的HS和LP。HS模 式用来传输高速数据，比如屏幕像素数据。LP 模式用来传输低速的异步信号，一般是配置指令， 屏幕的配置参数就是用LP模式传输的。HS模式下每个数据通道速率为80~1500Mbps， LP模式 下最高10Mbps。 #### Lane MIPI DSI包括一个时钟Lane和多个数据Lane，每条Lane 使用2根差分线来连接主控和外设。收发端都有对应的Lane模块来处理相关的数据 ![image 20250602101553576](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506021015737.png) 一个通用的Lane模块，包括一个高速收发器和一个低速收发器， 其中高速收发器有HS TX、HS RX，低速收发器有LP RX和LP TX，以及一个低速竞争检测器 LP CD。 对于高速单向数据通道，可能只 有HS TX或者HS RX。 #### 信号电平 Lane 分为 HS和LP两种模式，其中HS采用低压差分信号，传输速度高，但是功耗大，信号电压幅度 100mv~300mV，中心电平 200mV。LP 模式下采用单端驱动，功耗小，速率低 （<10Mbps），信号电压幅度 0~1.2V。 在 LP模式下只使用Lane0（也就是数据通道0），不需要 时钟信号，通信过程的时钟信号通过Lane0两个差分线异或得到，而且是双向通信。 ![image 20250602101848267](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506021018356.png) #### 通道状态 HS模式下是单向差分信号，主控发送（HS_TX），外设接收（HS_RX）。而LP是 双向单端信号，接收和发送端都有LP_TX和LP_RX，注意只有Lane0能做LP。 由于HS采用差分信号，所以只有两种状态： + HS 0：高速模式下Dp信号低电平，Dn信号高电平的时候。 + HS 1：高速模式下Dp信号高电平，Dn信号低电平的时候。 LP模式下有两根独立的信号线驱动，所以有4个状态 ![image 20250606223609483](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506062236617.png) #### 数据 Lane三种工作模式 通过 Lane 的不同状态转换有三种工作模式：控制模式、高速模式 （Burst Mode）和 Escape模式。控制模式和Escape模式都属于LP，高速模式属于HS。正常情 况下，数据Lane工作在控制模式或者高速模式下。 ##### 高速模式 于传输实际的屏幕像素数据，采用突发（Burst）传输方式。为了帮助接收端同 步，需要在数据头尾添加一些序列，接收端在接收到数据以后要把头尾去掉。 高速数据传输起 始于STOP状态（LP 11），并且也终止于STOP状态（LP 11） 在高速模式下传输数据的时候， Lane 始终工作于HS模式，提供DDR时钟，也就是双边沿时钟，在时钟频率不变的情况下，传 输速率提高一倍，这样可以有效利用带宽。 当数据传输请求发出以后，数据 Lane 退出 STOP 模式进入到高速模式，顺序是：LP 11→ LP 01→LP 00。然后发出一个 SoT 序列（Start of Transmission）， SoT 后面跟着的就是实际的负 载数据。当负载数据传输结束以后会紧跟一个EoT序列（End of Transmission）序列，数据线直 接进入到STOP模式。 ![image 20250606224536494](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506062245630.png) ![image 20250606224835606](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506062248690.png) ##### Escape模式 Escape是运行在LP状态下的一个特殊模式，在此模式下可以实现一些特殊的功能，我们给 屏幕发送配置信息就需要运行在Escape模式下。数据线进入Escape模式的方式为：LP 11→LP 10→LP 00→LP 01→LP 00。退出 Escape 模式的方式为：LP 00→LP 10→LP 11，也就是最后会 进入到STOP模式 ![image 20250606224944782](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506062249944.png) 对于数据Lanes，进入 Escape 模式以后，应该紧接着发送一个 8bit的命令来表示接下来要 做的操作 ![image 20250606225040652](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506062250748.png) + LPDT命令 命令序列为11100001，注意低bit先发送，所以对 应的十六进制就是0X87（0X10000111） LPDT直译过来就是低功耗数据传输，我们在初始化 MIPI屏幕的时候发送的初始化序列就需要用LPDT命令 LPDT命令序列后面紧跟着就是要发送的数据，分为长包和短包两种，长短包结构 后面会详细讲解。 + ULPS命令 进入超低功耗模式。 + Remote Trigger命令 有的资料叫做Remote Trigger，有的叫做Reset Trigger 因为本质是Remote Application，但是做的是Reset的工作，所以就产生了两种 叫法，目前此命令就是用于远程复位。 ![image 20250606225305796](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506062253930.png) ### 链路层 在 MIPI DSI 的链路层有两种模式：video（视频）和 command（命令）模式 #### command 模式 command 模式一般是针对那些含有buffer的 MCU屏幕，比如STM32单片机驱动MCU屏 的时候就是command模式。当画面有变化的时候，DSI Host端将数据发给屏幕，主控只有在画 面需要更改的时候发送像素数据，画面不变化的时候屏幕驱动芯片从自己内部 buffer 里面提取 数据显示 command 模式下需要双向数据接口。一般此种模式的屏幕尺寸和分辨率不大，一般 用在单片机等低端领域。 ![image 20250606230043778](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506062300885.png) #### video 模式 video 模式没有 framebuffer，需要主控一直发送数据给屏幕，和我们使用过的 RGB 接口屏 幕类似。但是MIPI DSI没有专用的信号线发送同步信息，比如VSYNC、HSYNC等，所以这些 控制信号和RGB图像数据以报文的形式在MIPI数据线上传输。基本上我们说的“MIPI屏”就 是工作在 video 模式下 ![image 20250606230130885](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506062301974.png) ##### DPI格式 MIPI DSI 接口的屏幕里面传输的是 DPI格式的数据。DPI格式的数据时序，主要就是要关 注一些时序参数，比如thpw、thb、thfp、tvpw、tvb和tvfp。这些参数都是为了锁定有效的像素 数据，都可以从MIPI LCD屏幕数据手册中找到。 对于video模式下的数据传输有三种时序模式： + Non Burst Mode with Sync Pulses：外设可以准确的重建原始的视频时序，包括同步脉冲 宽度。 通过在DSI接口上发送DPI时 序，可以精确的匹配 DPI 像素传输速率以及时序宽度等，比如同步脉冲。所以此模式下每一个 Sync Start（HSA）都要有一个对应的 Sync End（HSE） ![image 20250606232524219](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506062325316.png) + Non Burst Mode with Sync Events：和上面的模式类似，但是不需要精准的重建同步脉冲 宽度，取而代之的是发送一个“Sync event”包。 ![image 20250606232723747](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506062327834.png) + Burst Mode：此模式下发送RGB数据包的时间被压缩，这样可以在发送一行数据以后尽 快进入到LP模式，以节省功耗。 ![image 20250606232804034](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202506062328189.png)"},"/note/嵌入式/第三方移植/libpeer/2025-5-29-WebRTC.html":{"title":"WebRTC","content":"# WebRTC Web Real Time Communication实时网络通信协议, 是一个P2P的实时通信, 点对点通信 WebRTC虽然冠以“web”之名，但并不受限于传统互联网应用或浏览器的终端运行环境。实际上无论终端运行环境是 浏览器、桌面应用、移动设备（Android或iOS）还是IoT设备，只要IP连接可到达且符合WebRTC规范就可以互通。 这一点释放了大量智能终端（或运行在智能终端上的app）的实时通信能力，打开了许多对于实时交互性要求较高的 应用场景的想象空间，譬如在线教育、视频会议、视频社交、远程协助、远程操控等等都是其合适的应用领域。 + 点对点视频聊天 + 多人在线会议 + 直播 可以实现两个客户端之间之间通信, , 只需要服务器交换一部分数据 1. 如何发现对方, 双方需要交换一部分媒体信息, 网络数据(信令signaling), 有一个信令服务器(房间服务器) 2. 不同编码的音视频如何沟通, 交换两方都支持的解码 3. 怎么联系上对面, 网络协商, 了解对方的网络情况, 不是外网的地址需要使用NAT进行网络地址转换 使用ICE机制建立一下网络连接, 通过一系列的技术, 比如STUN, TURN之类的获取候选地址, 私有的和共有的, 通过STUN和TURN获取候选地址, 测试以后使用最佳的地址进行通信 > 获取媒体信息SDP, 网络信息candidate, 通过信令服务器交换 ![image 20250529214324017](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202505292143434.png) 绿色部分，核心层，分为四层： C++层，PeerConnection对等连接，其中包含很多API：传输质量，传输数据，传输统计报告，音视频设备管理，采集，等 session层，上下文管理 音视频引擎和传输（音频：编码器/防抖动/回音消除和降噪，视频：编码器/防抖动buffer/图像增强，传输：底层UDP，应用层RTP/SRTP/RTCP） 音频的采集和渲染，视频的采集（没有视频渲染，需要浏览器应用层自己做）【虚线部分允许浏览器自己进行重载】 + 上图的框架对于不同的开发人员关注点不同： （1）紫色部分是Web应用开发者API层 （2）蓝色实线部分是面向浏览器厂商的API层 （3）蓝色虚线部分浏览器厂商可以自定义实现 ## 网络连接 我们的电脑和电脑之前或大或小都是在某个局域网中，需要NAT（Network Address Translation，网络 地址转换），显示情况如下图 ![image 20250529220020946](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202505292200101.png) 实际是映射到一个外网ip和端口 在解决WebRTC使用过程中的上述问题的时候，我们需要用到STUN和TURN。 ### STUN STUN（Session Traversal Utilities for NAT，NAT会话穿越应用程序）是一种网络协议，它允许位于NAT（或多重 NAT）后的客户端找出自己的公网地址，查出自己位于哪种类型的NAT之后以及NAT为某一个本地端口所绑定的 Internet端端口。这些信息被用来在两个同时处于NAT路由器之后的主机之间创建UDP通信。该协议由RFC 5389定义。 在遇到上述情况的时候，我们可以建立一个STUN服务器，这个服务器做什么用的呢？主要是给无法在公网环境下的 视频通话设备分配公网IP用的。这样两台电脑就可以在公网IP中进行通话 使用一句话说明STUN做的事情就是：告诉我你的公网IP地址+端口是什么。搭建STUN服务器很简单，媒体流传输是 按照P2P的方式。 那么问题来了，STUN并不是每次都能成功的为需要NAT的通话设备分配IP地址的，P2P在传输媒体流时，使用的本地带宽，在多人视频通话的过程中，通话质量的好坏往往需要根据使用者本地的带宽确定。那么怎么办？TURN可以 很好的解决这个问题 ### TURN TURN的全称为Traversal Using Relays around NAT，是STUN/RFC5389的一个拓展，主要添加了Relay功能。如果 终端在NAT之后， 那么在特定的情景下，有可能使得终端无法和其对等端（peer）进行直接的通信，这时就需要公网 的服务器作为一个中继， 对来往的数据进行转发。这个转发的协议就被定义为TURN ![image 20250529222833998](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202505292228157.png) 在STUN分配公网IP失败后，可以通过TURN服务器请求公网IP地址作为中继地址。这种方式的带宽由服务器端承 担，在多人视频聊天的时候，本地带宽压力较小，并且，根据Google的说明，TURN协议可以使用在所有的环境中。 （单向数据200kbps 一对一通话） 以上是WebRTC中经常用到的2个协议，STUN和TURN服务器我们使用 coturn开源项目来搭建。 > 补充：ICE跟STUN和TURN不一样，ICE不是一种协议，而是一个框架（Framework），它整合了STUN和TURN。 coturn开源项目集成了STUN和TURN的功能。 在WebRTC中用来描述 网络信息的术语叫candidate"},"/note/嵌入式/第三方移植/lwIP/2024-7-14-18MQTT.html":{"title":"MQTT","content":" layout: post title: \"MQTT\" date: 2024 7 14 15:39:08 +0800 tags: Linux 网络 # MQTT ![image 20240714223215953](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407142232053.png) ![image 20240714224953895](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407142249936.png) ![image 20240714225625427](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407142256471.png) ![image 20240714225715707](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407142257790.png) ![image 20240714230254033](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407142302132.png) ![image 20240714230511675](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407142305766.png) ![image 20240714230556579](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407142305672.png) ## 使用 ![image 20240714230707931](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407142307983.png) ![image 20240714230726848](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407142307902.png) ![image 20240714230743417](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407142307472.png)"},"/note/嵌入式/第三方移植/lwIP/2024-7-12-14WebServer.html":{"title":"WebServer","content":" layout: post title: \"WebServer\" date: 2024 7 12 15:39:08 +0800 tags: stm32 lwIP # WebServer 主要实现的功能是, 存储处理以及传递网页给客户端 只需要支持HTTP协议, HTML文档格式以及URL就可以和网络浏览器配合使用 [STM32 网络通信Web Server中 SSI与CGI的应用解析_cgi ssi CSDN博客](https://blog.csdn.net/u014471291/article/details/89285456) ## 使用的技术 ### CGI技术 CGI技术 : 通用网关接口（Common Gateway Interface）是一个Web服务器主机提供信息服务的标准接口。通过CGI接口，Web服务器就能够获取客户端提交的信息，转交给服务器端的CGI程序进行处理，最后返回结果给客户端。 实际是使用这个让服务器执行另一个程序, **起到HTML文本转为C语言的作用**, 使用这一个最后获取到的是数据 ![image 20240712144953692](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407121449755.png) > 在网页中，CGI（Common Gateway Interface）起着关键作用。以下是一些常见的 CGI 在网页中的应用： > > 1. 动态内容生成：CGI 可以根据用户请求动态地生成网页内容。通过处理用户提交的表单数据或其他输入，CGI 脚本能够生成个性化和实时更新的内容，使每个用户都能够获得适合自己需求的页面。 > 2. 用户交互：通过 CGI 技术，网页可以与用户进行交互。例如，在一个在线购物网站上，当用户选择了某个商品并点击“添加到购物车”按钮时，后台 CGI 脚本会接收这些信息，并将商品保存到购物车中。 > 3. 数据库连接和操作：CGI 可以连接数据库，并执行查询、插入、更新等操作。这使得网站能够动态地从数据库中读取数据，并将其展示给用户。 > 4. 用户认证和权限控制：通过 CGI 技术，可以对访问者进行身份验证，并根据其权限提供不同级别的服务。例如，在一个论坛或社交网络上发布帖子可能需要登录并拥有特定权限才能完成。 > 5. 文件上传和下载：使用 CGI 技术可以实现文件上传功能，允许用户向服务器发送文件并存储起来。同时也可以提供文件下载功能，允许用户从服务器获取特定文件。 > > 总之，在网页开发过程中利用 CGI 技术可以实现更多动态、个性化和高度交互性质感觉到功能效果，并提升整体使用体验 ### SSI技术 Server Side Include，是一种类似于ASP的基于服务器的网页制作技术。大多数的WEB服务器等均支持SSI命令。将内容发送到浏览器之前，可以使用“服务器端包含 (SSI）”指令将文本、图形或应用程序信息包含到网页中。 SSI用在.shtml，.stm，.shtm文件中，以<! #XXX >的形式写在网页文件中，在服务端接收到浏览器请求后，就会将网页文件中查找到的<! #XXX >替换成服务器中的Tag对应内容，然后连同网页数据一起发送给浏览器。 使用这一个最后获取到的是网页, 如果服务器没有使用这一个技术, 这些标签会被识别为注释 > CGI（Common Gateway Interface）和 SSI（Server Side Includes）都是用于在服务器端处理和生成网页的技术，但它们有一些不同之处。 > > 1. CGI 是一种通用的、功能强大的技术，可以编写以各种编程语言编写的脚本来创建动态内容。CGI 脚本能够接收用户请求，并生成基于这些请求的动态内容。与之相对，SSI 主要是用来包含静态内容或执行简单操作，比如在页面中包含其他文件或当前日期等。 > 2. 在使用上，SSI 更适合于简单而静态化的任务。例如，在很多静态网页中可能会使用 SSI 来引入共享导航菜单、页脚等信息；而对于需要更复杂交互性质感觉到计算和处理的任务则更适合采用 CGI 技术。 > > 尽管两者有区别，但在实际应用中它们也可以结合起来使用。比如一个网站可以使用 SSI 来包含共享部分（如导航栏），同时使用 CGI 脚本来处理用户提交的表单数据并返回相应结果。 > > 总体而言，SSI 和 CGI 都是为了增强服务器端处理能力而设计的技术，在特定情况下也可组合使用以达到更好效果。 基本原理就是：SSI在HTML文件中，可以通过注释行调用命令或指针，即允许通过在HTML页面注入脚本或远程执行任意代码。 CGI：调用 Web 服务器外的程序 SSI：Web 服务器本身执行直接写在 HTML 中的指令 > SSI是对网页里面的数据进行替换, CGI是实际可以生成一个数据进行发送 还有一个特殊的 SSI 命令，“exec”。通过指定外部程序，这可以像 CGI 一样运行，并且可以按原样执行 Linux / Unix 命令。 尤其是后一个对OS的命令可以原样执行的问题，根据使用方法的不同，有可能对服务器造成严重的故障。因此，许多租用服务器（共享服务器）禁止使用此“exec”命令或设置一些限制。 ## 实际实现 ![image 20240712150303758](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407121503824.png) > Middlewares\\lwip\\src\\apps\\http\\httpd.c和fs.c > > fs.c/h是文件的操作 > > httpd.c/h是网页服务器 [lwip 2.1.3自带的httpd网页服务器使用教程（二）使用SSI动态生成网页部分内容_ssi的tag CSDN博客](https://blog.csdn.net/ZLK1214/article/details/131738736) ![image 20240712152438741](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407121524777.png) > 在lwipopts.h文件里面, 第三个选项设置为0的时候会从fsdata.c文件获取数据, 1会从fsdata_custom.c文件里面获取数据 ![image 20240712154834406](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407121548476.png) > 使用makefsdata i, 可以把fs文件夹下面的网页转换为一个fsdata.c文件 > > ![image 20240712160125634](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407121601680.png) > > 获取的这一个文件不需要添加到工程里面, 实际使用的时候会使用`#include`进行添加 > > 实际是把这些文件转换为一个 > > ```c > struct fsdata_file { > const struct fsdata_file *next; > const unsigned char *name; > const unsigned char *data; > int len; > u8_t flags; > }; > > ``` > > 格式的文件, 数据在一个大数组里面 ```c /** * @brief lwip_demo 测试 * @param 无 * @retval 无 */ void lwip_demo(void) { /* Httpd Init 主要是进行http连接*/ httpd_init(); /* 配置SSI处理程序 */ httpd_ssi_init(); /* 配置CGI处理器 */ httpd_cgi_init(); } ``` > 第一个函数是httpd.c文件里面的, 会初始化一个tcp_pcb进行管理, 获取连接进来的客户 > > 第二个函数最后调用函数http_set_ssi_handler, 初始化符号链表 > > ```c > /** > * @ingroup httpd > * Set the SSI handler function. > * > * @param ssi_handler the SSI handler function > * @param tags an array of SSI tag strings to search for in SSI enabled files > * @param num_tags number of tags in the 'tags' array > */ > void http_set_ssi_handler(tSSIHandler ssi_handler, const char **tags, int num_tags) > ``` > > 第一个参数是处理函数, 第二个是符号表, 第三个是符号的个数 > > ```c > /** > * @breif SSI的Handler句柄 > * @param iIndex : > * @param pcInsert : > * @param iInsertLen : > * @retval 无 > */ > static u16_t SSIHandler(int iIndex, char *pcInsert, int iInsertLen) > { > switch (iIndex) > { > case 0: > ADC_Handler(pcInsert); > break; > \t\t//...处理其他的的标号 > } > > return strlen(pcInsert); > } > > static const char *ppcTAGs[] /* SSI的Tag */ > { > \"t\", /* ADC值 */ > \"w\", /* 温度值 */ > \"h\", /* 时间 */ > \"y\" /* 日期 */ > }; > > http_set_ssi_handler(SSIHandler, ppcTAGs, NUM_CONFIG_SSI_TAGS); /* 配置SSI句柄 */ > ``` > > 第三个函数最后调用http_set_cgi_handlers, 用处是设置cgi的处理函数 > > ```c > /** > * @ingroup httpd > * Set an array of CGI filenames/handler functions > * > * @param cgis an array of CGI filenames/handler functions > * @param num_handlers number of elements in the 'cgis' array > */ > void > http_set_cgi_handlers(const tCGI *cgis, int num_handlers) > ``` > > ```c > > /** > * @breif CGI LED控制句柄 > * @param iIndex : CGI句柄索引号 > * @param iNumParams : > * @param pcParam : > * @param pcValue : > * @retval 无 > */ > const char *LEDS_CGI_Handler(int iIndex, int iNumParams, char *pcParam[], char *pcValue[]); > > static const tCGI ppcURLs[] /* cgi程序 */ > { > {\"/leds.cgi\", LEDS_CGI_Handler}, > {\"/beep.cgi\", BEEP_CGI_Handler}, > }; > > http_set_cgi_handlers(ppcURLs, NUM_CONFIG_CGI_URIS); /* 配置CGI句柄 */ > ``` ### 处理函数 ```c /** * @breif SSIHandler中需要用到的处理RTC时间的函数 * @param pcInsert : 一个待处理的字符串 * @retval 无 */ void RTCTime_Handler(char *pcInsert) { RTC_TimeTypeDef RTC_TimeStruct; uint8_t hour, min, sec; HAL_RTC_GetTime(&g_rtc_handle, &RTC_TimeStruct, RTC_FORMAT_BIN); hour RTC_TimeStruct.Hours; min RTC_TimeStruct.Minutes; sec RTC_TimeStruct.Seconds; *pcInsert (char)((hour / 10) + 0x30); *(pcInsert + 1) (char)((hour % 10) + 0x30); *(pcInsert + 2) ':'; *(pcInsert + 3) (char)((min / 10) + 0x30); *(pcInsert + 4) (char)((min % 10) + 0x30); *(pcInsert + 5) ':'; *(pcInsert + 6) (char)((sec / 10) + 0x30); *(pcInsert + 7) (char)((sec % 10) + 0x30); } ``` > ```html > <tr> > <td width \"200\">ADC1_CH5电压值</td> > <td width \"200\"><! #t >mv</td> > </tr> > ``` > > 这一个在发送到服务器以后, 会找到t对应的标签, 进行替换 ```c /** * @breif CGI LED控制句柄 * @param iIndex : CGI句柄索引号 * @param iNumParams : * @param pcParam : * @param pcValue : * @retval 无 */ const char *LEDS_CGI_Handler(int iIndex, int iNumParams, char *pcParam[], char *pcValue[]) { uint8_t i 0; /* 注意根据自己的GET的参数的多少来选择i值范围 */ iIndex FindCGIParameter(\"LED1\", pcParam, iNumParams); /* 找到led的索引号 */ /* 只有一个CGI句柄 iIndex 0 */ if (iIndex ! 1) { LED1(1); /* 关闭所有的LED1灯 */ for (i 0; i < iNumParams; i++) /* 检查CGI参数: example GET /leds.cgi?led 2&led 4 */ { if (strcmp(pcParam[i], \"LED1\") 0) /* 检查参数\"led\" */ { if (strcmp(pcValue[i], \"LED1ON\") 0) /* 改变LED1状态 */ { LED1(0); /* 打开LED1 */ } else if (strcmp(pcValue[i], \"LED1OFF\") 0) { LED1(1); /* 关闭LED1 */ } } } } if (HAL_GPIO_ReadPin(LED1_GPIO_PORT,LED1_GPIO_PIN) 0 && pcf8574_read_bit(BEEP_IO) 0) { return \"/STM32F407LED_ON_BEEP_OFF.shtml\"; /* LED1开,BEEP关 */ } else if (HAL_GPIO_ReadPin(LED1_GPIO_PORT,LED1_GPIO_PIN) 0 && pcf8574_read_bit(BEEP_IO) 1) { return \"/STM32F407LED_ON_BEEP_ON.shtml\"; /* LED1开,BEEP开 */ } else if (HAL_GPIO_ReadPin(LED1_GPIO_PORT,LED1_GPIO_PIN) 1 && pcf8574_read_bit(BEEP_IO) 1) { return \"/STM32F407LED_OFF_BEEP_ON.shtml\"; /* LED1关,BEEP开 */ } else { return \"/STM32F407LED_OFF_BEEP_OFF.shtml\"; /* LED1关,BEEP关 */ } } ``` ![image 20240712163502079](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407121635152.png) > 返回的是这些页面的值 > > ```http > <div style \"margin top:30px; text align:center;\"> > <form method \"get\" action \"/leds.cgi\"> > LED1: > <input type \"radio\" name \"LED1\" value \"LED1ON\" id \"LED1_0\" checked>ON > <input name \"LED1\" type \"radio\" id \"LED1_1\" value \"LED1OFF\" >OFF<BR> > <br> > <input type \"submit\" name \"button2\" id \"button2\" value \"SEND\"> > </form> > </div> > ``` > > 这是一个HTML表单，用于控制LED灯的开关。用户可以选择将LED1打开或关闭，并通过点击“SEND”按钮发送请求。 > > 在表单中，有两个选项供用户选择： > > `ON`：表示将LED1打开； > `OFF`：表示将LED1关闭。 > > 默认情况下，选中的是\"ON\"，即将LED1打开。 > > 当用户点击“SEND”按钮时，表单会向服务器发送一个GET请求，并在URL参数中包含所选择的状态。服务器收到请求后可以执行相应操作来控制LED灯的状态。 实际调用这不同的处理函数是在http_find_file函数里面"},"/note/嵌入式/第三方移植/lwIP/2024-7-5-10IP协议.html":{"title":"IP协议","content":" layout: post title: \"IP协议\" date: 2024 6 3 15:39:08 +0800 tags: stm32 lwIP # IP协议 IP协议是TCP/IP协议族中最为核心的协议，TCP、UDP、ICMP、IGMP数据都以IP数据报格式传输（IPv4、IPv6） 提供了一个无状态, 无连接, 不可靠的协议 > 无状态: 所有IP数据报的发送、传输和接收都是相互独立、没有上下文关系的。这种服务最大的缺点就是无法处理乱序和重复的IP数据报。 > > 无连接: IP协议不会记录对方的信息, 所以上层发送信息的时候都需要提供对方的IP地址 > > 不可控: 不能保证这一个数据会发送给对方, 发送失败的时候会通知上层协议, 不会试图重发 ![image 20240705213126673](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407052131712.png) ![image 20240705220945235](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407052209280.png) IP地址在整个发送的过程中是不会变化的, 是用于确认路标的 ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404022254601.jpg) IP数据报格式 + IP数据报的首部长度和数据长度都是可变长的，但总是4字节的整数倍。 + 对于IPv4，4位版本字段是4。 + 4位首部长度的数值是以4字节为单位的，最小值为5，也就是说首部长度最小是4x5 20字节，也就是不带任何选项的IP首部，4位能表示的最大值是15，也就是说首部长度最大是60字节。 + 8位TOS字段有3个位用来指定IP数据报的优先级（目前已经废弃不用），还有4个位表示可选的服务类型（最小延迟、最大?吐量、最大可靠性、最小成本），还有一个位总是0。 + 总长度是整个数据报（包括IP首部和IP层payload）的字节数。 + 每传一个IP数据报，16位的标识加1，可用于分片和重新组装数据报。 + 3位标志 ![image 20240705225852731](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407052258906.png) + 13位分片偏移是分片相对原始IP数据报开始处(仅指数据部分)的偏移。实际的偏移值是该值左移3位（乘8）后得到的。由于这个原因，除了最后一个IP分片外，每个IP分片的数据部分的长度必须是8的整数倍(这样才能保证后面的IP分片拥有一个合适的偏移量)。 + TTL（Time to live)是这样用的：源主机为数据包设定一个生存时间，比如64，每过一个路由器就把该值减1，如果减到0就表示路由已经太长了仍然找不到目的主机的网络，就丢弃该包，因此这个生存时间的单位不是秒，而是跳（hop）。 + 协议字段指示上层协议是TCP、UDP、ICMP还是IGMP。 + 然后是校验和，只校验IP首部，数据的校验由更高层协议负责。IPv4的IP地址长度为32位。 默认的时候最大的传输单元是1500字节, 如果比这一个数据大的话, 需要进行分片, 这一个长度是加上IP首部以后的, 实际可以发送的数字最大长度为1480 > 实际使用的时候需要进行分片的是UDP协议, 使用TCP协议的时候会在传输层进行分片 ## LWIP ### 分片 1. 申请一个pbuf, 需要预留一个54字节的头部(20TCP头部(传输层) + 20IP头部(网络层) + 14网络层头部) 2. 使用函数ip4_frag进行分层, 这一个函数会在ip4_output_if_src函数里面进行调用 ip4_output_if_src函数首先会添加IP层的首部, 使用`struct ip_hdr`这一个结构体进行初始化头部信息, 初始化以后根据发送数据的长度使用ip4_frag分层以后发送, 或直接使用etharp_output进行发送 ```c struct pbuf_custom { /** The actual pbuf */ struct pbuf pbuf; /** This function is called when pbuf_free deallocates this pbuf(_custom) */ pbuf_free_custom_fn custom_free_function; }; struct pbuf_custom_ref { /** 'base class' */ struct pbuf_custom pc; /** pointer to the original pbuf that is referenced */ struct pbuf *original; }; ``` 先申请一个保存分片IP首部的pbuf：`rambuf`。 然后再申请一个`pbuf_custom_ref`数据结构的伪pbuf：`pcr`。 然后把未分片的IP报文的pbuf对应分片的数据区地址给到`pcr >pc >pbuf >payload`，共享数据区内存嘛。 然后把分片IP首部的pbuf和分片IP的数据pbuf拼接起来：`pbuf_cat(rambuf, pcr >pc >pbuf >payload);`，这样就组成了分片的IP报文了。 ![image 20240705225852731](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407062306128.png) ## 重装 由于到达的顺序是不确定的, 所以后发送的分组可能前到达 1. 接收到的分片暂存起来 2. 对分片进行排序 3. 所有分片接收完成后，再将数据递交给传输层处理 ```c /** IP reassembly helper struct. * This is exported because memp needs to know the size. */ struct ip_reassdata { struct ip_reassdata *next;\t//指向下一个需要组合的IP数据包 struct pbuf *p;\t\t\t //指向pbuf分片 struct ip_hdr iphdr;\t\t //IP数据报首部 u16_t datagram_len;\t\t //获取的数据的长度 u8_t flags;\t\t\t\t //是否获取最后一个数据包 u8_t timer;\t\t\t\t //超时时间 }; ``` > 这一个结构体表示一个正在重装的IP数据报, 收到分组的时候, 会把pbuf连接起来, 到ip_reassdata里面的pbuf表, 所有的pbuf都获取以后才会上传 ![image 20240707212137747](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407072121816.png) ```c struct ip_reass_helper { PACK_STRUCT_FIELD(struct pbuf *next_pbuf); PACK_STRUCT_FIELD(u16_t start);\t\t//使用这两个记录数据的序号, 用于确定分片的位置 PACK_STRUCT_FIELD(u16_t end); } PACK_STRUCT_STRUCT; ``` > 使用这一个结构体进行强转, 所有的数据获取以后把第一个pbuf的偏移指向(重新填充)IP首部, 其余的指向数据 使用函数ip4_reass进行重装 + 首先获取IP首部, 从这里获取数据长度以及数据的数据的偏移量 + 从重装链表里面获取对应的reassdatagrams(通过判断ip首部是不是一样的), 没有找到的话获取一个新的 + 如果这一个pbuf是第一个的话(偏移是0), 会使用iphdr记录他的ip首部 + 如果获取的是最后一个分组, 会使用他的偏移以及他的长度计算总长度 + 使用ip_reass_chain_frag_into_datagram_and_validate函数把pbuf插入对应的链表位置, 以及把ip_reass_helper初始化, 同时会在这一个函数里面判断这一个pbuf的数据的位置是不是有问题的, 是的话进行丢弃, 在获取到最后一个分组以后, 会在获取分片的时候判断所有的分片是不是已经连续了, 是的话返回IP_REASS_VALIDATE_TELEGRAM_FINISHED + 在获取全部接收以后会把第一个pbuf的ip首部复原, 之后把全部的pbuf的偏移指向数据, 然后把所有的pbuf关联起来 + 之后释放ipr, 但是不释放pbuf 这一个过程是在ip4_input函数里面调用的, 获取到这一个完整的数据以后, 记录一下IP首部的信息, 然后把第一个的IP首部数据偏移减去, 根据首部的信息进行不同的处理 ![image 20240707230608202](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407072306347.png) ![image 20240707230652445](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407072306522.png) ![image 20240707230730602](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407072307679.png) ![](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407072307449.png)"},"/note/嵌入式/第三方移植/lwIP/2024-7-8-12传输协议.html":{"title":"传输协议","content":" layout: post title: \"传输协议\" date: 2024 7 8 15:39:08 +0800 tags: stm32 lwIP # 传输协议 主要有两个, TCP和UDP ## UDP ![image 20240710215539047](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407102155152.png) ```c struct udp_hdr { PACK_STRUCT_FIELD(u16_t src); PACK_STRUCT_FIELD(u16_t dest); /* src/dest UDP ports */ PACK_STRUCT_FIELD(u16_t len); PACK_STRUCT_FIELD(u16_t chksum); } PACK_STRUCT_STRUCT; ``` > 实际使用的时候应用层需要一个头部为54字节的pbuf, 可以兼容TCP协议, 之后根据使用的协议进行添加首部 ![image 20240710220757821](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407102207875.png) > 实际连接的时候使用的控制块, 实际处理的时候会判断获取的UDP数据是不是和端口是一致的, 如果是的话使用回调函数进行处理 > > ![image 20240710222714146](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407102227203.png) ![image 20240710222015503](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407102220547.png) ## TCP 使用这一个协议的时候是不会进行IP分片的, 如果数据比较大, 只会在传输层进行分包 这一个协议栈里面定义了MSS, 为了提高性能, lwIP定义为1460 > TCP协议中的MSS（Maximum Segment Size）指的是在TCP通信中，一个TCP报文段的最大有效载荷数据量，即TCP头部和TCP数据部分的最大长度。MSS是在TCP连接建立时由双方协商确定的，通常取决于网络设备和操作系统的配置。 > > 以下是关于TCP协议的MSS的一些重要信息： > > 1. **协商过程**： > 在TCP连接建立的握手阶段（三次握手），客户端和服务器会交换彼此支持的MSS值。 > 客户端会在SYN报文段的TCP选项中发送其MSS值给服务器。 > 服务器收到SYN报文段后，也会在发送SYN ACK报文段时回复其MSS值给客户端。 > 客户端收到服务器的SYN ACK后，最后发送一个ACK报文段确认连接建立，此时双方已确认并协商了MSS。 > 2. **影响因素**： > MSS的大小可以受到网络设备（如防火墙）和操作系统配置的影响。 > 一般情况下，MSS的大小会被设备和操作系统限制为一定的值，通常是通过TCP栈的配置参数来调整。 > 3. **默认值**： > 在大多数情况下，MSS的默认值是根据网络接口的最大传输单元（MTU，Maximum Transmission Unit）来确定的，减去TCP头部和IP头部的长度后留下的有效载荷大小。 > 在以太网上，MTU通常为1500字节，因此默认的MSS可能会设为1460字节（1500 40，TCP头部20字节，IP头部20字节）。 > 4. **优化和调整**： > 在特定的网络环境下，可以通过调整操作系统的TCP参数或者中间设备的配置来优化MSS的大小，以提高TCP传输效率和减少报文段重组的需求。 > 5. **应用**： > MSS的大小对TCP连接的性能有一定影响，过大的MSS可能导致分段重组的增加，而过小的MSS则可能导致报文段的浪费和TCP效率的下降。 > TCP/IP协议栈在发送数据时，会根据MSS值将数据分段，并在接收端重新组装成完整的数据流。 > > 总之，MSS在TCP连接中起着重要的作用，它影响了数据传输的效率和网络吞吐量，因此在配置和优化网络性能时需要特别注意和理解MSS的设定和影响。 ### 数据格式 ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404032022193.jpg) TCP数据段 + 与UDP协议一样也有源端口号和目的端口号，通讯的双方由IP地址和端口号标识。 + 32位序号: 以一个随机数为起始, 每一次加上数据的长度 + 32位确认序号: 发送期望得到的数据的起始位置 + 4位首部长度和IP协议头类似，表示TCP协议头的长度，以4字节为单位，因此TCP协议头最长可以是4x15 60字节，如果没有选项字段，TCP协议头最短20字节。 + URG、ACK、PSH、RST、SYN、FIN是六个控制位 > ACK：确认序号有效 > RST：重置连接 > SYN：发起了一个新连接 > FIN：释放一个连接 > PSH: 当 PSH 1 的时候，表示该报文段高优先级 + 16位窗口: 告诉对方本端的 TCP 接收缓冲区还能容纳多少字节的数据 + 16位检验和将TCP协议头和数据都计算在内。 + 紧急指针: 仅在 URG 1 时才有意义，它指出本报文段中的紧急数据的字节数。 + 各种选项 > 在实际实现的时候, 需要实现滑动窗口以及三次握手, 四次挥手 ```c struct tcp_hdr { PACK_STRUCT_FIELD(u16_t src); PACK_STRUCT_FIELD(u16_t dest); PACK_STRUCT_FIELD(u32_t seqno); PACK_STRUCT_FIELD(u32_t ackno); PACK_STRUCT_FIELD(u16_t _hdrlen_rsvd_flags); PACK_STRUCT_FIELD(u16_t wnd); PACK_STRUCT_FIELD(u16_t chksum); PACK_STRUCT_FIELD(u16_t urgp); } PACK_STRUCT_STRUCT; ``` ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404061029712.jpg) ```c enum tcp_state { CLOSED 0, LISTEN 1, SYN_SENT 2, SYN_RCVD 3, ESTABLISHED 4, FIN_WAIT_1 5, FIN_WAIT_2 6, CLOSE_WAIT 7, CLOSING 8, LAST_ACK 9, TIME_WAIT 10 }; ```"},"/note/嵌入式/第三方移植/lwIP/2024-7-1-03移植.html":{"title":"移植","content":" layout: post title: \"移植\" date: 2024 6 3 15:39:08 +0800 tags: stm32 lwIP # 移植 [lwIP A Lightweight TCP/IP stack Summary [Savannah\\] (nongnu.org)](http://savannah.nongnu.org/projects/lwip/) 从这一个网页里面下载contrib包(移植文件以及示例)和lwIP源码(协议栈的核心文件) ![image 20240701103410718](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407011034839.png) ## 文件 ![image 20240701113448146](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407011134206.png) > contrib包, 主要使用的是app文件夹, examples文件夹, ports文件夹 > > ![image 20240701113534933](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407011135966.png) ![image 20240701113925149](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407011139198.png) ![image 20240701143148124](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407011431199.png) > core文件: > > ipv4文件夹, jpv6文件夹: 相关的源码(DHCP, ARP, ICMP, IGMP) > > altcp.c, altcp_alloc.c, altcp_tcp.c: 应用的抽象层, 用于TCP连接的API > > def.c: lwIP基础类函数定义, 主机序列和网络序列转换, 字符串查找比较, 整数转字符串 > > dns.c: 域名解析 > > inet_chksum.c : 计算校验和功能(计算TCP, IP, UDP协议的校验和) > > init.c: 检测宏定义和配置的错误和提示 > > ip.c: IP协议相关的函数(和文件夹里面的文件相关) > > mem.c: 动态内存池管理 > > memp.c: 静态内存堆管理 > > netif.c: lwIP网卡的操作, 注册删除, 使能禁用, 设置IP等 > > pbuf.c: 网络数据包的操作 > > raw.c: 传输协议框架 > > stats.c: lwIP里面的内核统计系统 > > sys.c: sys模块 > > tcp.c, tcp_in.c, tcp_out.c: tcp相关的操作, TCP连接, 数据包的输入输出, 定时器等 > > timeouts.c: lwIP内核的超时处理 > > udp.c: UDP的操作, 连接以及数据包操作 ## 移植 [LwIP应用开发笔记之一：LwIP无操作系统基本移植 Moonan 博客园 (cnblogs.com)](https://www.cnblogs.com/foxclever/p/11255217.html) 　首先我们说需要定义的头文件。根据sys_arch.txt文件中的要求，我们需要实现cc.h、lwipopts.h和perf.h三个头文件，线描述如下： **cc.h**文件主要完成协议栈内部使用的数据类型的定义，以保证平台无关性。 **lwipopts.h**文件包含了用户对协议栈内核参数进行的配置。 **perf.h**文件是实现与系统统计和测量相关的功能。 　　其次要实现网卡的驱动，事实上我们采用STM32F407自带的网卡，以及ST的开发库时，驱动大部分都写好了，我们只需要完成硬件IO部分的配置以及一些必要的参数配置就可以了。 　　接下来就是实现几个必要的函数，按照LwIP作者给出的模板，需要实现5个函数如下： **low_level_init** 调用以太网驱动函数，初始化 STM32F4xx 和 STM32F2x7xx 以太网外设 **low_level_output** 调用以太网驱动函数以发送以太网包 **low_level_input** 调用以太网驱动函数以接收以太网包 **ethernetif_init** 初始化网络接口结构 （netif, 主要是记录函数句柄）并调用low_level_init以初始化以太网外设 **ethernetif_input** 调用low_level_input接收包，然后将其提供给LwIP栈 **sys_now** 提供lwIp的时基 　　以上这些函数都实现后，我们需要使协议运转起来，所以我们还需要做两件事，一是对协议及网卡初始化；二是实现对数据的轮询，当然也可使用中断方式，不过在这里我们使用查询方式。 　　初始化部分，除了初始化默认网络接口的参数外，需要注册2个函数，一是初始化网络接口函数ethernetif_init;一是数据包接收函数ethernet_input。 > 这两个函数在netif_add函数里面进行注册 ![image 20240701145528895](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407011455969.png) ethernet.c和ethernet.h两个文件包含了以太网驱动初始化和MAC的驱动程序，这里需要用户自己根据自己的以太网芯片进行设置，通过设置以太网句柄ETH_HandleTypeDef进行设置。 ## 添加系统 移植freertos lwip添加sys_arch.c/h文件 之后需要更改文件 1. lwipopts.h文件里面的配置, 实际是使用stm32的配置文件, 之后把里面的LWIP_PROVIDE_ERRNO选项改为1,FW_F4V1.26.0\\Projects\\STM32469I_EVAL\\Applications\\LwIP\\LwIP_HTTP_Server_Netconn_RTOS\\Inc\\lwipopts.h文件进行替换 2. cc.h文件里面有一个重复的变量, 把里面的`typedef int sys_prot_t;`进行注销, 重复定了 3. lwip_comm.c/h 把里面的lwip_periodic_handle函数删除(这是一个轮询函数)和修改lwip_comm_init函数, 把开启DHCP处理放在启动任务里面(之前是在main函数里面) 4. ethernetif.h/c文件改为使用操作系统的网卡驱动, 主要是low_level_init函数以及ethernetif_input函数, 添加信号量 5. ethrnet.c中断优先级, 使得FreeRTOS里面的函数可以在中断里面使用 实际使用时候把low_level_init函数注册为一个任务, 中断里面释放信号量"},"/note/嵌入式/第三方移植/lwIP/2024-7-4-08超时定时器.html":{"title":"超时定时器","content":" layout: post title: \"超时定时器\" date: 2024 7 3 15:39:08 +0800 tags: stm32 lwIP # 超时定时器 timeout.c 为每个与外界网络连接的任务都设定了timeout属性，即等待超时时间，例如TCP建立连接超时、ARP缓存表项的时间管理等，都需要超时操作来处理 ![image 20240704220035884](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407042200933.png) > 事件是按照触发的事件进行排序的 ![image 20240704221330240](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407042213298.png) > 在实际实现的时候会使用`const struct lwip_cyclic_timer lwip_cyclic_timers[];`进行管理默认的事件, 在函数sys_timeouts_init里面进行注册 > > 实际注册的时候会通过当前的时间计算超时的时间, 申请一个sys_timeo结构体进行记录信息, 之后按照超时的时间把这一个结构体插入链表 > > 使用链表next_timeout记录所有需要处理的超时事件 ```c void sys_timeout(u32_t msecs, sys_timeout_handler handler, void *arg) ``` > 注册一个事件 ```c void sys_untimeout(sys_timeout_handler handler, void *arg) ``` > 删除一个事件 + 查询 裸机的时候需要定时调用sys_check_timeouts这一个函数 操作系统的时候会在tcpip的线程里面调用函数tcpip_timeouts_mbox_fetch"},"/note/嵌入式/第三方移植/lwIP/2024-7-14-17Jpref测速.html":{"title":"Jperf测速","content":" layout: post title: \"Jperf测速\" date: 2024 7 13 15:39:08 +0800 tags: Linux 网络 # Jperf网络测速 iperf是一个命令行网络测速工具, Jperf是图形化的这一个测试工具 ![image 20240714212236667](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407142122744.png) ![image 20240714213807108](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407142138159.png) ![image 20240714213824834](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407142138878.png) ![image 20240714213849128](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407142138180.png) ![image 20240714213905069](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407142139113.png) ![image 20240714213928243](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407142139286.png) ![image 20240714213941679](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407142139713.png) ![image 20240714213956774](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407142139823.png) ![image 20240714214008009](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407142140042.png)"},"/note/嵌入式/第三方移植/lwIP/2024-6-3-LWIP.html":{"title":"LWIP","content":" layout: post title: \"LWIP\" date: 2024 6 3 15:39:08 +0800 tags: stm32 lwIP # 简介 [lwip tcpip/lwip: lwIP mirror from http://git.savannah.gnu.org/cgit/lwip.git (github.com)](https://github.com/lwip tcpip/lwip?tab readme ov file) [lwIP Wiki Fandom](https://lwip.fandom.com/wiki/LwIP_Wiki) 是一个小型的开源的TCP/IP协议栈(阉割版) 作用: 云台接入, 无线网关, 远程模块, 工控控制器, 嵌入式NAT无线路由器, 网络摄像头 lwIP没有实现NAT协议, 这一个协议是路由器必备的协议,, 但是可以进行添加 ![image 20240630171756646](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301717726.png) ![image 20240630171809758](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301718814.png) ## 结构 ![image 20240630172443860](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301724917.png)"},"/note/嵌入式/第三方移植/lwIP/2024-7-5-09ARP协议.html":{"title":"ARP协议","content":" layout: post title: \"ARP协议\" date: 2024 6 3 15:39:08 +0800 tags: stm32 lwIP # ARP协议 Address Resolution Protocol地址解析协议 ARP协议就是根据目标IP地址以广播方式获取相应的MAC地址，并将MAC地址存入ARP缓存表, 是TCP/IP协议里面的其中一个 ![image 20240705192922908](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407051929955.png) 在发送数据包的时候需要使用这一个格式(以太网帧), 需要知道对方的MAC地址, IP地址主要使用在广域网里面, 是一个可变的, 解决数据在外网里面传输的问题, MAC地址是使用在内网里面, 是不可变的唯一的地址 实际获取的是路由器的MAC地址, 在到达路由器以后路由器会重新进行填充 ## 发送ARP请求 主要是在etharp文件里面实现的 ![image 20240705193849296](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407051938353.png) > 函数的名字是etharp_output() ```c struct etharp_entry { /** Pointer to a single pending outgoing packet on this ARP entry. */ struct pbuf *q;\t\t\t\t//挂起数据 ip4_addr_t ipaddr;\t\t\t//目标的地址 struct netif *netif;\t\t\t//当前使用的网卡 struct eth_addr ethaddr;\t\t//MAC地址 u16_t ctime;\t\t\t\t //保存的时间 u8_t state;\t\t\t\t //状态 }; ``` > 使用这一个结构体记录ARP缓存表, 这里面记录的信息是有时效的 > > ```c > /** ARP states */ > enum etharp_state { > ETHARP_STATE_EMPTY 0,\t\t\t//ARP缓存表处于初始化的状态 > ETHARP_STATE_PENDING,\t\t\t\t//只记录IP地址, 还没有获取MAC地址 > ETHARP_STATE_STABLE,\t\t\t\t//应答前, 数据包被挂起了, 应答以后更新以及发送数据 > ETHARP_STATE_STABLE_REREQUESTING_1,//发送状态 > ETHARP_STATE_STABLE_REREQUESTING_2 > }; > ``` etharp_output函数调用的时候, 如果可以在这一个表里面获取到对方的MAC地址, 进行添加以太网的头部(etharp_output_to_arp_index > ethernet_output函数里面进行), 然后发送数据 ![image 20240705195841975](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407051958123.png) 找不到的话会使用etharp_query这一个函数 这一个函数首先调用etharp_find_entry再次进行查找, 如果没有的话返回一个可以使用的etharp_entry表项的索引, 记录ip地址, 这时候他的状态是ETHARP_EMPTY 之后在etharp_query函数里面对这一个结构体进行初始化, 以及使用函数etharp_request发送一个ARP包, 最后调用的是etharp_raw函数, 会在这个函数里面构建一个pbuf进行发送 ![image 20240705201929248](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407052019302.png) ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404021250602.png) ARP帧（28字节） 000e: 00 01 0010: 08 00 06 04 00 01 00 05 5d 61 58 a8 c0 a8 00 37 0020: 00 00 00 00 00 00 c0 a8 00 02 > 00 01: 硬件为以太网 > > 08 00 : 解析一个IP地址 > > 06 :硬件地址长度 > > 04 :协议地址长度, 表示ip地址长度 > > 00 01 : op字段为1表示ARP请求，op字段为2表示ARP应答。 > > 00 05 5d 61 58 a8 : 自己的MAC地址 > > c0 a8 00 37 : IP地址192.168.0.55 > > 00 00 00 00 00 00 : 目的MAC地址, 未知填0 > > c0 a8 00 02 : 目的地ip地址 ```c struct etharp_hdr { PACK_STRUCT_FIELD(u16_t hwtype); PACK_STRUCT_FIELD(u16_t proto); PACK_STRUCT_FLD_8(u8_t hwlen); PACK_STRUCT_FLD_8(u8_t protolen); PACK_STRUCT_FIELD(u16_t opcode); PACK_STRUCT_FLD_S(struct eth_addr shwaddr); PACK_STRUCT_FLD_S(struct ip4_addr_wordaligned sipaddr); PACK_STRUCT_FLD_S(struct eth_addr dhwaddr); PACK_STRUCT_FLD_S(struct ip4_addr_wordaligned dipaddr); } PACK_STRUCT_STRUCT; ``` > 使用这一个进行填充, 最后使用ethernet_output进行发送 ![image 20240705210238596](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407052102674.png) ![image 20240705210714742](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407052107819.png) > 会在ethernet_input这一个函数里面去除以太网首部, 以及根类型调用不同的处理函数"},"/note/嵌入式/第三方移植/lwIP/2024-7-8-11ICMP协议.html":{"title":"ICMP协议","content":" layout: post title: \"ICMP协议\" date: 2024 7 8 15:39:08 +0800 tags: stm32 lwIP # ICMP协议 网络层的一个协议, 起到对IP协议辅助的功能 ICMP协议是一个网络层协议。 一个新搭建好的网络，往往需要先进行一个简单的测试，来验证网络是否畅通；但是IP协议并不提供可靠传输。如果丢包了，IP协议并不能通知传输层是否丢包以及丢包的原因。因此我们需要ICMP协议来完成这样的功能 + 存在的原因 1. IP 协议本身不提供差错报告和差错控制机制来保证数据报递交的有效性，例如：数据报在网络中被丢弃了，源主机更希望等到该数据报递交过程中的异常信息 2. IP 协议不能进行主机管理与查询机制，例如：不知道对方主机或者路由器的活跃，对于不活跃的主机和路由器就没有必要发送数据报。 > 包含两部分, 差错报文, 以及ping, 从而实现有效的转发数据报以及提高成功的机会 ![image 20240708192624552](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407081926630.png) + 差错报文 ![image 20240708192710563](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407081927630.png) > LWIP实现的是绿色的部分 + 查询报文 ![image 20240708192935819](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407081929870.png) ![image 20240708193534225](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407081935281.png) ## 数据格式 ```c struct icmp_echo_hdr { PACK_STRUCT_FLD_8(u8_t type);\t\t\t//类型 PACK_STRUCT_FLD_8(u8_t code);\t\t\t//代码 PACK_STRUCT_FIELD(u16_t chksum);\t\t//校验和 PACK_STRUCT_FIELD(u16_t id);\t\t\t//标志位 PACK_STRUCT_FIELD(u16_t seqno);\t\t//序号 } PACK_STRUCT_STRUCT; ``` ![image 20240708194332731](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407081943772.png) # 发送 ### 错误报文 lwIP只实现目的不可达、超时差错报文，它们分别为icmp_dest_unreach和icmp_time_exceeded函数, 最后的发送使用函数icmp_send_response ![image 20240708210814243](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407082108300.png) > 4字节是以太网首部以及IP首部 ```c /** * Send a 'time exceeded' packet, called from ip_forward() if TTL is 0. * * @param p the input packet for which the 'time exceeded' should be sent, * p >payload pointing to the IP header * @param t type of the 'time exceeded' packet */ void icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t) { MIB2_STATS_INC(mib2.icmpouttimeexcds); icmp_send_response(p, ICMP_TE, t); } ``` > 最后使用函数icmp_send_response进行发送, 获取一个pbuf, 之后把收获pbuf里面的前一部分数据进行拷贝, 然后添加头部, 同时从收获的pbuf里面获取对方的IP地址 ## 接收 ### 查询报文 对方发送的数据不需要更改, 改变一下ICMP头部即可 ![image 20240708212758992](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407082127048.png) > 使用函数icmp_input函数 在ip4_input这一个函数里面会获取接收的pbuf里面的IP头部中的类型, 如果是ICMP, 调用icmp_input icmp_input函数里面, 判断一下, 是回送请求的时候改一下类型, 以及改变IP首部, 之后ip4_output_if函数进行发送 ![image 20240708215302725](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407082153768.png) > 发送的时候IP地址为NULL, 所以不会再次添加首部"},"/note/嵌入式/第三方移植/lwIP/2024-7-10-13RAW接口.html":{"title":"RAW接口","content":" layout: post title: \"RAW接口\" date: 2024 7 13 15:39:08 +0800 tags: stm32 lwIP # RAW接口 ![image 20240712175034919](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407121750009.png) 但是这一个使用的时候代码的可读性比较差, 并且逻辑比较复杂 ## UDP ### API ![image 20240712175130749](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407121751804.png) ```c /** * @ingroup udp_raw * Creates a new UDP pcb which can be used for UDP communication. The * pcb is not active until it has either been bound to a local address * or connected to a remote address. * @see MEMP_NUM_UDP_PCB * * @return The UDP PCB which was created. NULL if the PCB data structure * could not be allocated. * * @see udp_remove() */ struct udp_pcb * udp_new(void); ``` ```c /** * @ingroup udp_raw * Removes and deallocates the pcb. * * @param pcb UDP PCB to be removed. The PCB is removed from the list of * UDP PCB's and the data structure is freed from memory. * * @see udp_new() */ void udp_remove(struct udp_pcb *pcb); ``` ```c /** * @ingroup udp_raw * Bind an UDP PCB. * * @param pcb UDP PCB to be bound with a local address ipaddr and port. * @param ipaddr local IP address to bind with. Use IP_ANY_TYPE to * bind to all local interfaces. * @param port local UDP port to bind with. Use 0 to automatically bind * to a random port between UDP_LOCAL_PORT_RANGE_START and * UDP_LOCAL_PORT_RANGE_END. * * ipaddr & port are expected to be in the same byte order as in the pcb. * * @return lwIP error code. * ERR_OK. Successful. No error occurred. * ERR_USE. The specified ipaddr and port are already bound to by * another UDP PCB. * * @see udp_disconnect() */ err_t udp_bind(struct udp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port) ``` > 之后会使用这一个端口号进行获取数据 ```c /** * @ingroup udp_raw * Sets the remote end of the pcb. This function does not generate any * network traffic, but only sets the remote address of the pcb. * * @param pcb UDP PCB to be connected with remote address ipaddr and port. * @param ipaddr remote IP address to connect with. * @param port remote UDP port to connect with. * * @return lwIP error code * * ipaddr & port are expected to be in the same byte order as in the pcb. * * The udp pcb is bound to a random local port if not already bound. * * @see udp_disconnect() */ err_t udp_connect(struct udp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port); ``` > 进行一个远程的连接, 连接以后可以发送数据 ```c /** * @ingroup udp_raw * Remove the remote end of the pcb. This function does not generate * any network traffic, but only removes the remote address of the pcb. * * @param pcb the udp pcb to disconnect. */ void udp_disconnect(struct udp_pcb *pcb); ``` ```c /** * @ingroup udp_raw * Sends the pbuf p using UDP. The pbuf is not deallocated. * * * @param pcb UDP PCB used to send the data. * @param p chain of pbuf's to be sent. * * The datagram will be sent to the current remote_ip & remote_port * stored in pcb. If the pcb is not bound to a port, it will * automatically be bound to a random port. * * @return lwIP error code. * ERR_OK. Successful. No error occurred. * ERR_MEM. Out of memory. * ERR_RTE. Could not find route to destination address. * ERR_VAL. No PCB or PCB is dual stack * More errors could be returned by lower protocol layers. * * @see udp_disconnect() udp_sendto() */ err_t udp_send(struct udp_pcb *pcb, struct pbuf *p) ``` > 发送数据, 发送的时候使用pbuf ```c /** * @ingroup udp_raw * Set a receive callback for a UDP PCB. * This callback will be called when receiving a datagram for the pcb. * * @param pcb the pcb for which to set the recv callback * @param recv function pointer of the callback function * @param recv_arg additional argument to pass to the callback function */ void udp_recv(struct udp_pcb *pcb, udp_recv_fn recv, void *recv_arg); ``` > 注册一个接收使用的函数 > > ```c > /** > * @brief UDP服务器回调函数 > * @param arg ：传入参数 > * @param upcb：UDP控制块 > * @param p : 网络数据包 > * @param addr：IP地址 > * @param port：端口号 > * @retval 无 > */ > static void lwip_udp_callback(void *arg, struct udp_pcb *upcb, struct pbuf *p, const ip_addr_t *addr, u16_t port); > ``` > > 这一个函数里面的pbuf可以获取接收的数据 ### 实际使用 ```c udppcb udp_new(); if (udppcb) /* 创建成功 */ { IP4_ADDR(&rmtipaddr, g_lwipdev.remoteip[0], g_lwipdev.remoteip[1], g_lwipdev.remoteip[2], g_lwipdev.remoteip[3]); err udp_connect(udppcb, &rmtipaddr, LWIP_DEMO_PORT); /* UDP客户端连接到指定IP地址和端口号的服务器 */ if (err ERR_OK) { err udp_bind(udppcb, IP_ADDR_ANY, LWIP_DEMO_PORT); /* 绑定本地IP地址与端口号 */ if (err ERR_OK) /* 绑定完成 */ { udp_recv(udppcb,lwip_udp_callback, NULL); /* 注册接收回调函数 */ } else res 1; } else res 1; } else res 1; ``` ## TCP ![image 20240712191144150](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407121911225.png) > 实际使用的时候需要初始化这些回调函数 ![image 20240712191331506](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407121913560.png) ![image 20240712191353958](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407121913043.png) ### API #### 建立连接 ```c /** * @ingroup tcp_raw * Creates a new TCP protocol control block but doesn't place it on * any of the TCP PCB lists. * The pcb is not put on any list until binding using tcp_bind(). * If memory is not available for creating the new pcb, NULL is returned. * @see MEMP_NUM_TCP_PCB_LISTEN and MEMP_NUM_TCP_PCB * * @internal: Maybe there should be a idle TCP PCB list where these * PCBs are put on. Port reservation using tcp_bind() is implemented but * allocated pcbs that are not bound can't be killed automatically if wanting * to allocate a pcb with higher prio (@see tcp_kill_prio()) * * @return a new tcp_pcb that initially is in state CLOSED */ struct tcp_pcb * tcp_new(void); ``` ```c /** * @ingroup tcp_raw * Binds the connection to a local port number and IP address. If the * IP address is not given (i.e., ipaddr IP_ANY_TYPE), the connection is * bound to all local IP addresses. * If another connection is bound to the same port, the function will * return ERR_USE, otherwise ERR_OK is returned. * @see MEMP_NUM_TCP_PCB_LISTEN and MEMP_NUM_TCP_PCB * * @param pcb the tcp_pcb to bind (no check is done whether this pcb is * already bound!) * @param ipaddr the local ip address to bind to (use IPx_ADDR_ANY to bind * to any local address * @param port the local port to bind to * @return ERR_USE if the port is already in use * ERR_VAL if bind failed because the PCB is not in a valid state * ERR_OK if bound */ err_t tcp_bind(struct tcp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port) ``` > 绑定一个本地端口, 用于进行连接 ```c #define tcp_listen(pcb) tcp_listen_with_backlog(pcb, TCP_DEFAULT_LISTEN_BACKLOG) /** * @ingroup tcp_raw * Set the state of the connection to be LISTEN, which means that it * is able to accept incoming connections. The protocol control block * is reallocated in order to consume less memory. Setting the * connection to LISTEN is an irreversible process. * When an incoming connection is accepted, the function specified with * the tcp_accept() function will be called. The pcb has to be bound * to a local port with the tcp_bind() function. * * The tcp_listen() function returns a new connection identifier, and * the one passed as an argument to the function will be * deallocated. The reason for this behavior is that less memory is * needed for a connection that is listening, so tcp_listen() will * reclaim the memory needed for the original connection and allocate a * new smaller memory block for the listening connection. * * tcp_listen() may return NULL if no memory was available for the * listening connection. If so, the memory associated with the pcb * passed as an argument to tcp_listen() will not be deallocated. * * The backlog limits the number of outstanding connections * in the listen queue to the value specified by the backlog argument. * To use it, your need to set TCP_LISTEN_BACKLOG 1 in your lwipopts.h. * * @param pcb the original tcp_pcb * @param backlog the incoming connections queue limit * @return tcp_pcb used for listening, consumes less memory. * * @note The original tcp_pcb is freed. This function therefore has to be * called like this: * tpcb tcp_listen_with_backlog(tpcb, backlog); */ struct tcp_pcb * tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog) ``` > 实际限制了可以同时连接的个数, 默认是0xff最大值 ```c /** * @ingroup tcp_raw * Used for specifying the function that should be called when a * LISTENing connection has been connected to another host. * @see MEMP_NUM_TCP_PCB_LISTEN and MEMP_NUM_TCP_PCB * * @param pcb tcp_pcb to set the accept callback * @param accept callback function to call for this pcb when LISTENing * connection has been connected to another host */ void tcp_accept(struct tcp_pcb *pcb, tcp_accept_fn accept); /** Function prototype for tcp accept callback functions. Called when a new * connection can be accepted on a listening pcb. * * @param arg Additional argument to pass to the callback function (@see tcp_arg()) * @param newpcb The new connection pcb * @param err An error code if there has been an error accepting. * Only return ERR_ABRT if you have called tcp_abort from within the * callback function! */ typedef err_t (*tcp_accept_fn)(void *arg, struct tcp_pcb *newpcb, err_t err); ``` > 使用这一个函数设置一个连接的时候回调函数 ```c /** * @ingroup tcp_raw * Connects to another host. The function given as the \"connected\" * argument will be called when the connection has been established. * Sets up the pcb to connect to the remote host and sends the * initial SYN segment which opens the connection. * * The tcp_connect() function returns immediately; it does not wait for * the connection to be properly setup. Instead, it will call the * function specified as the fourth argument (the \"connected\" argument) * when the connection is established. If the connection could not be * properly established, either because the other host refused the * connection or because the other host didn't answer, the \"err\" * callback function of this pcb (registered with tcp_err, see below) * will be called. * * The tcp_connect() function can return ERR_MEM if no memory is * available for enqueueing the SYN segment. If the SYN indeed was * enqueued successfully, the tcp_connect() function returns ERR_OK. * * @param pcb the tcp_pcb used to establish the connection * @param ipaddr the remote ip address to connect to * @param port the remote tcp port to connect to * @param connected callback function to call when connected (on error, the err calback will be called) * @return ERR_VAL if invalid arguments are given * ERR_OK if connect request has been sent * other err_t values if connect request couldn't be sent */ err_t tcp_connect(struct tcp_pcb *pcb, const ip_addr_t *ipaddr, u16_t port, tcp_connected_fn connected); /** Function prototype for tcp connected callback functions. Called when a pcb * is connected to the remote side after initiating a connection attempt by * calling tcp_connect(). * * @param arg Additional argument to pass to the callback function (@see tcp_arg()) * @param tpcb The connection pcb which is connected * @param err An unused error code, always ERR_OK currently ; ) @todo! * Only return ERR_ABRT if you have called tcp_abort from within the * callback function! * * @note When a connection attempt fails, the error callback is currently called! */ typedef err_t (*tcp_connected_fn)(void *arg, struct tcp_pcb *tpcb, err_t err); ``` > 连接另一个设备, 使用IP地址和对方的端口, 还需要一个连接成功的回调函数 #### 发送数据 ```c /** * @ingroup tcp_raw * Write data for sending (but does not send it immediately). * * It waits in the expectation of more data being sent soon (as * it can send them more efficiently by combining them together). * To prompt the system to send data now, call tcp_output() after * calling tcp_write(). * * This function enqueues the data pointed to by the argument dataptr. The length of * the data is passed as the len parameter. The apiflags can be one or more of: * TCP_WRITE_FLAG_COPY: indicates whether the new memory should be allocated * for the data to be copied into. If this flag is not given, no new memory * should be allocated and the data should only be referenced by pointer. This * also means that the memory behind dataptr must not change until the data is * ACKed by the remote host * TCP_WRITE_FLAG_MORE: indicates that more data follows. If this is omitted, * the PSH flag is set in the last segment created by this call to tcp_write. * If this flag is given, the PSH flag is not set. * * The tcp_write() function will fail and return ERR_MEM if the length * of the data exceeds the current send buffer size or if the length of * the queue of outgoing segment is larger than the upper limit defined * in lwipopts.h. The number of bytes available in the output queue can * be retrieved with the tcp_sndbuf() function. * * The proper way to use this function is to call the function with at * most tcp_sndbuf() bytes of data. If the function returns ERR_MEM, * the application should wait until some of the currently enqueued * data has been successfully received by the other host and try again. * * @param pcb Protocol control block for the TCP connection to enqueue data for. * @param arg Pointer to the data to be enqueued for sending. * @param len Data length in bytes * @param apiflags combination of following flags : * TCP_WRITE_FLAG_COPY (0x01) data will be copied into memory belonging to the stack * TCP_WRITE_FLAG_MORE (0x02) for TCP connection, PSH flag will not be set on last segment sent, * @return ERR_OK if enqueued, another err_t on error */ err_t tcp_write(struct tcp_pcb *pcb, const void *arg, u16_t len, u8_t apiflags) ``` > 发送数据但是不是立即发送, 可以把多个数据进行合并 ```c /** * @ingroup tcp_raw * Specifies the callback function that should be called when data has * successfully been received (i.e., acknowledged) by the remote * host. The len argument passed to the callback function gives the * amount bytes that was acknowledged by the last acknowledgment. * * @param pcb tcp_pcb to set the sent callback * @param sent callback function to call for this pcb when data is successfully sent */ void tcp_sent(struct tcp_pcb *pcb, tcp_sent_fn sent) ``` > 设置发送结束的回调函数 ```c /** * @ingroup tcp_raw * Find out what we can send and send it * * @param pcb Protocol control block for the TCP connection to send data * @return ERR_OK if data has been sent or nothing to send * another err_t on error */ err_t tcp_output(struct tcp_pcb *pcb) ``` > 把缓冲区里面的数据发送出去 #### 接收数据 ```c /** * @ingroup tcp_raw * Sets the callback function that will be called when new data * arrives. The callback function will be passed a NULL pbuf to * indicate that the remote host has closed the connection. If the * callback function returns ERR_OK or ERR_ABRT it must have * freed the pbuf, otherwise it must not have freed it. * * @param pcb tcp_pcb to set the recv callback * @param recv callback function to call for this pcb when data is received */ void tcp_recv(struct tcp_pcb *pcb, tcp_recv_fn recv) ``` > 设置接收数据的回调函数 ```c /** * @ingroup tcp_raw * This function should be called by the application when it has * processed the data. The purpose is to advertise a larger window * when the data has been processed. * * @param pcb the tcp_pcb for which data is read * @param len the amount of bytes that have been read by the application */ void tcp_recved(struct tcp_pcb *pcb, u16_t len) ``` #### 断开 ```c /** * @ingroup tcp_raw * Closes the connection held by the PCB. * * Listening pcbs are freed and may not be referenced any more. * Connection pcbs are freed if not yet connected and may not be referenced * any more. If a connection is established (at least SYN received or in * a closing state), the connection is closed, and put in a closing state. * The pcb is then automatically freed in tcp_slowtmr(). It is therefore * unsafe to reference it (unless an error is returned). * * The function may return ERR_MEM if no memory * was available for closing the connection. If so, the application * should wait and try again either by using the acknowledgment * callback or the polling functionality. If the close succeeds, the * function returns ERR_OK. * * @param pcb the tcp_pcb to close * @return ERR_OK if connection has been closed * another err_t if closing failed and pcb is not freed */ err_t tcp_close(struct tcp_pcb *pcb) ``` > 断开链接, 这一个pcb不再进行连接, 并释放已经进行的连接和这一个控制块, 用于监听pcb ```c /** * @ingroup tcp_raw * Aborts the connection by sending a RST (reset) segment to the remote * host. The pcb is deallocated. This function never fails. * * ATTENTION: When calling this from one of the TCP callbacks, make * sure you always return ERR_ABRT (and never return ERR_ABRT otherwise * or you will risk accessing deallocated memory or memory leaks! * * @param pcb the tcp pcb to abort */ void tcp_abort(struct tcp_pcb *pcb); ``` > 一个普通的pcb断开连接, 在回调函数里面调用的时候, 回调函数需要返回一个ERR_ABRT ### 使用 #### 客户端 ```c tcppcb tcp_new(); /* 创建一个新的pcb */ if (tcppcb) /* 创建成功 */ { IP4_ADDR(&rmtipaddr, g_lwipdev.remoteip[0], g_lwipdev.remoteip[1], g_lwipdev.remoteip[2], g_lwipdev.remoteip[3]); tcp_connect(tcppcb, &rmtipaddr, LWIP_DEMO_PORT, lwip_tcp_client_connected); /* 连接到目的地址的指定端口上,当连接成功后回调lwip_tcp_client_connected()函数 */ } else res 1; ``` > 使用这一个方式进行连接 + 连接回调函数 ```c /** * @brief lwIP TCP连接建立后调用回调函数 * @param arg : 回调函数传入的参数 * @param tpcb : TCP控制块 * @param err : 错误码 * @retval 返回错误码 */ err_t lwip_tcp_client_connected(void *arg, struct tcp_pcb *tpcb, err_t err) { struct tcp_client_struct *es NULL; if (err ERR_OK) { es (struct tcp_client_struct *)mem_malloc(sizeof(struct tcp_client_struct)); /* 申请内存 */ if (es) /* 内存申请成功 */ { es >state ES_TCPCLIENT_CONNECTED; /* 状态为连接成功 */ es >pcb tpcb; es >p NULL; tcp_arg(tpcb, es); /* 使用es更新tpcb的callback_arg */ tcp_recv(tpcb, lwip_tcp_client_recv); /* 初始化LwIP的tcp_recv回调功能 */ tcp_err(tpcb, lwip_tcp_client_error); /* 初始化tcp_err()回调函数 */ tcp_sent(tpcb, lwip_tcp_client_sent); /* 初始化LwIP的tcp_sent回调功能 */ tcp_poll(tpcb, lwip_tcp_client_poll, 1); /* 初始化LwIP的tcp_poll回调功能 */ g_lwip_send_flag 1 << 5; /* 标记连接到服务器了 */ err ERR_OK; } else { lwip_tcp_client_connection_close(tpcb, es); /* 关闭连接 */ err ERR_MEM; /* 返回内存分配错误 */ } } else { lwip_tcp_client_connection_close(tpcb, 0); /* 关闭连接 实际是设置回调函数为NULL*/ } return err; } ``` + 断开连接 ```c /** * @brief 关闭与服务器的连接 * @param tpcb: TCP控制块 * @param es : LWIP回调函数使用的结构体 * @retval 无 */ void lwip_tcp_client_connection_close(struct tcp_pcb *tpcb, struct tcp_client_struct *es) { /* 移除回调 */ tcp_abort(tpcb); /* 终止连接,删除pcb控制块 */ tcp_arg(tpcb, NULL); tcp_recv(tpcb, NULL); tcp_sent(tpcb, NULL); tcp_err(tpcb, NULL); tcp_poll(tpcb, NULL, 0); if (es)mem_free(es); g_lwip_send_flag & ~(1 << 5); /* 标记连接断开了 */ } ``` + 轮询函数 ```c /** * @brief lwIP tcp_poll的回调函数 * @param arg : 回调函数传入的参数 * @param tpcb: TCP控制块 * @retval ERR_OK */ err_t lwip_tcp_client_poll(void *arg, struct tcp_pcb *tpcb) { err_t ret_err; struct tcp_client_struct *es; es (struct tcp_client_struct *)arg; if (es >state ES_TCPCLIENT_CLOSING) /* 连接断开 */ { lwip_tcp_client_connection_close(tpcb, es); /* 关闭TCP连接 */ } ret_err ERR_OK; return ret_err; } ``` > 循环的回调函数, 这一个函数会被循环调用 + 发送函数 ```c /** * @brief lwIP tcp_sent的回调函数(当从远端主机接收到ACK信号后发送数据) * @param arg : 回调函数传入的参数 * @param tpcb: TCP控制块 * @param len : 长度 * @retval ERR_OK */ err_t lwip_tcp_client_sent(void *arg, struct tcp_pcb *tpcb, u16_t len) { struct tcp_client_struct *es; LWIP_UNUSED_ARG(len); es (struct tcp_client_struct *)arg; if (es >p)lwip_tcp_client_senddata(tpcb, es); /* 发送数据 */ return ERR_OK; } /** * @brief 用来发送数据 * @param tpcb: TCP控制块 * @param es : LWIP回调函数使用的结构体 * @retval 无 */ void lwip_tcp_client_senddata(struct tcp_pcb *tpcb, struct tcp_client_struct *es) { struct pbuf *ptr; err_t wr_err ERR_OK; while ((wr_err ERR_OK) && es >p && (es >p >len < tcp_sndbuf(tpcb))) /* 将要发送的数据加入到发送缓冲队列中 */ { ptr es >p; wr_err tcp_write(tpcb, ptr >payload, ptr >len, 1); //把数据加入缓冲里面 if (wr_err ERR_OK) { es >p ptr >next; /* 指向下一个pbuf */ if (es >p)pbuf_ref(es >p); /* pbuf的ref加一 */ pbuf_free(ptr); /* 释放ptr */ } else if (wr_err ERR_MEM)es >p ptr; tcp_output(tpcb); /* 将发送缓冲队列中的数据立即发送出去 */ } } ``` > 实际发送的时候, 可以直接调用lwip_tcp_client_senddata函数进行发送 + 接收函数 ```c /** * @brief lwIP tcp_recv()函数的回调函数 * @param arg : 回调函数传入的参数 * @param tpcb : TCP控制块 * @param p : 网络数据包 * @param err : 错误码 * @retval 返回错误码 */ err_t lwip_tcp_client_recv(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err) { uint32_t data_len 0; struct pbuf *q; struct tcp_client_struct *es; err_t ret_err; LWIP_ASSERT(\"arg ! NULL\", arg ! NULL); es (struct tcp_client_struct *)arg; if (p NULL) /* 如果从服务器接收到空的数据帧就关闭连接 */ { es >state ES_TCPCLIENT_CLOSING; /* 需要关闭TCP 连接了 */ es >p p; ret_err ERR_OK; } else if (err ! ERR_OK) /* 当接收到一个非空的数据帧,但是err! ERR_OK */ { if (p)pbuf_free(p); /* 释放接收pbuf */ ret_err err; } else if (es >state ES_TCPCLIENT_CONNECTED) /* 当处于连接状态时 */ { if (p ! NULL) /* 当处于连接状态并且接收到的数据不为空时 */ { memset(g_lwip_demo_recvbuf, 0, LWIP_DEMO_RX_BUFSIZE); /* 数据接收缓冲区清零 */ for (q p; q ! NULL; q q >next) /* 遍历完整个pbuf链表 */ { /* 判断要拷贝到LWIP_DEMO_RX_BUFSIZE中的数据是否大于LWIP_DEMO_RX_BUFSIZE的剩余空间，如果大于 */ /* 的话就只拷贝LWIP_DEMO_RX_BUFSIZE中剩余长度的数据，否则的话就拷贝所有的数据 */ if (q >len > (LWIP_DEMO_RX_BUFSIZE data_len)) memcpy(g_lwip_demo_recvbuf + data_len, q >payload, (LWIP_DEMO_RX_BUFSIZE data_len)); /* 拷贝数据 */ else memcpy(g_lwip_demo_recvbuf + data_len, q >payload, q >len); data_len + q >len; if (data_len > LWIP_DEMO_RX_BUFSIZE) break; /* 超出TCP客户端接收数组,跳出 */ } g_lwip_send_flag 1 << 6; /* 标记接收到数据了 */ tcp_recved(tpcb, p >tot_len); /* 用于获取接收数据,通知LWIP可以获取更多数据 */ pbuf_free(p); /* 释放内存 */ ret_err ERR_OK; } } else /* 接收到数据但是连接已经关闭 */ { tcp_recved(tpcb, p >tot_len); /* 用于获取接收数据,通知LWIP可以获取更多数据 */ es >p NULL; pbuf_free(p); /* 释放内存 */ ret_err ERR_OK; } return ret_err; } ``` #### 服务器 ```c tcppcbnew tcp_new(); /* 创建一个新的pcb */ if (tcppcbnew) /* 创建成功 */ { err tcp_bind(tcppcbnew, IP_ADDR_ANY, LWIP_DEMO_PORT); /* 将本地IP与指定的端口号绑定在一起,IP_ADDR_ANY为绑定本地所有的IP地址 */ if (err ERR_OK) /* 绑定完成 */ { tcppcbconn tcp_listen(tcppcbnew); /* 设置tcppcb进入监听状态 */ tcp_accept(tcppcbconn, lwip_tcp_server_accept); /* 初始化LWIP的tcp_accept的回调函数 */ } else res 1; } else res 1; ``` ```c /** * @brief lwIP tcp_accept()的回调函数 * @param arg ：传入的参数 * @param newpcb：TCP控制块 * @param err ：错误码 * @retval 返回 ret_err */ err_t lwip_tcp_server_accept(void *arg, struct tcp_pcb *newpcb, err_t err) { err_t ret_err; struct tcp_server_struct *es; LWIP_UNUSED_ARG(arg); LWIP_UNUSED_ARG(err); tcp_setprio(newpcb, TCP_PRIO_MIN); /* 设置新创建的pcb优先级 */ es (struct tcp_server_struct *)mem_malloc(sizeof(struct tcp_server_struct)); /* 分配内存 */ if (es ! NULL) /* 内存分配成功 */ { es >state ES_TCPSERVER_ACCEPTED; /* 接收连接 */ es >pcb newpcb; es >p NULL; tcp_arg(newpcb, es); tcp_recv(newpcb, lwip_tcp_server_recv); /* 初始化tcp_recv()的回调函数 */ tcp_err(newpcb, lwip_tcp_server_error); /* 初始化tcp_err()回调函数 */ tcp_poll(newpcb, lwip_tcp_server_poll, 1); /* 初始化tcp_poll回调函数 */ tcp_sent(newpcb, lwip_tcp_server_sent); /* 初始化发送回调函数 */ g_lwip_send_flag 1 << 5; /* 标记有客户端连上了 */ g_lwipdev.remoteip[0] newpcb >remote_ip.addr & 0xff; /* IADDR4 */ g_lwipdev.remoteip[1] (newpcb >remote_ip.addr >> 8) & 0xff; /* IADDR3 */ g_lwipdev.remoteip[2] (newpcb >remote_ip.addr >> 16) & 0xff; /* IADDR2 */ g_lwipdev.remoteip[3] (newpcb >remote_ip.addr >> 24) & 0xff; /* IADDR1 */ ret_err ERR_OK; } else { ret_err ERR_MEM; } return ret_err; } ```"},"/note/嵌入式/第三方移植/lwIP/2024-7-2-05内存管理.html":{"title":"内存管理","content":" layout: post title: \"内存管理\" date: 2024 6 3 15:39:08 +0800 tags: stm32 lwIP # 内存管理 ![image 20240702193327764](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407021933915.png) ![image 20240702194053751](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407021940814.png) ## 选择 ![image 20240702214453671](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407022144733.png) ## 内存堆 lwIP内存堆是一种可变长分配策略，可以随意申请任意大小的内存 ![image 20240702194310034](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407021943088.png) 有三个函数 + mem_init()内存堆的初始化 + mem_malloc()申请内存堆 + mem_free()释放内存堆 > 主要的实现在mem.c文件里面 ```c /** * The heap is made up as a list of structs of this type. * This does not have to be aligned since for getting its size, * we only use the macro SIZEOF_STRUCT_MEM, which automatically aligns. */ //① ********************** 内存块控制块结构 ********************************************* struct mem { /** index ( > ram[next]) of the next struct */ mem_size_t next; // 指向下一个节点 /** index ( > ram[prev]) of the previous struct */ mem_size_t prev; // 指向上一个节点 /** 1: this area is used; 0: this area is unused */ u8_t used; // 描述内存块是否可用 0 ：未使用；1 ：已使用 }; ``` > 一个描述符结构体 ```c /** All allocated blocks will be MIN_SIZE bytes big, at least! * MIN_SIZE can be overridden to suit your needs. Smaller values save space, * larger values could prevent too small blocks to fragment the RAM too much. */ //② ********************** 最小分配内存 ****************** #ifndef MIN_SIZE #define MIN_SIZE 12 #endif /* MIN_SIZE */ ``` ```c /** Calculate memory size for an aligned buffer returns the next highest * multiple of MEM_ALIGNMENT (e.g. LWIP_MEM_ALIGN_SIZE(3) and * LWIP_MEM_ALIGN_SIZE(4) will both yield 4 for MEM_ALIGNMENT 4). 对齐计算 */ #ifndef LWIP_MEM_ALIGN_SIZE #define LWIP_MEM_ALIGN_SIZE(size) (((size) + MEM_ALIGNMENT 1U) & ~(MEM_ALIGNMENT 1U)) #endif /* some alignment macros: we define them here for better source code layout */ //③ ********************** 对齐操作 ****************** #define MIN_SIZE_ALIGNED LWIP_MEM_ALIGN_SIZE(MIN_SIZE) //最小分配内存大小对齐 12字节 #define SIZEOF_STRUCT_MEM LWIP_MEM_ALIGN_SIZE(sizeof(struct mem)) // 内存控制块对齐 8字节 #define MEM_SIZE_ALIGNED LWIP_MEM_ALIGN_SIZE(MEM_SIZE) // 内存堆对齐 lwipopts.h文件下MEM_SIZE配置项 ``` ```c /** the heap. we need one struct mem at the end and some room for alignment */ //④ ********************** 内存堆定义 大数组 ****************** //这一个使用的对齐方式是直接请求一个比对齐小1byte的区域 //之后可以使用这一个区域里面的对齐的位置 LWIP_DECLARE_MEMORY_ALIGNED(ram_heap, MEM_SIZE_ALIGNED + (2U * SIZEOF_STRUCT_MEM)); // // // ram_heap[(((MEM_SIZE_ALIGNED + (2U * SIZEOF_STRUCT_MEM)) + MEM_ALIGNMENT 1U))] #define LWIP_RAM_HEAP_POINTER ram_heap //进行一次重命名 ``` > 使用一个大数组作为可以使用的内存 ```c //⑤ ********************** 内存堆所需要的指针变量 ****************** /** pointer to the heap (ram_heap): for alignment, ram is now a pointer instead of an array */ static u8_t *ram; // 指向内存堆对齐后起始地址 /** the last entry, always unused! */ static struct mem *ram_end; // 指向系统最后一个内存块 ``` ```c /** pointer to the lowest free block, this is used for faster search */ //⑥ ********************** 指向当前系统具有最低地址的空闲内存块 ****************** static struct mem * LWIP_MEM_LFREE_VOLATILE lfree; ``` ![image 20240702220902178](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407022209262.png) ![image 20240702224247260](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407022242340.png) 释放的时候实际是吧记录当前空闲的lfree进行更改, 之后使用plug_holes函数判断一下前后的块是不是可以进行合并, 是的话进行合并 ## 内存池 在使用的时候把内存分成多个大小相同的内存块, 使用链表进行连接, 使用的时候不需要切割, 直接进行分配, 释放的时候也不需要进行合并相邻的内存块 优点: 分配的速度快, 防止内存碎片化, 回收便捷 缺点: 浪费, 使用大内存的时候可能申请失败 ![image 20240703194938449](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407031949604.png) ### memp_priv.h 定义结构体memp, 实际是一个链表项, 只有一个next成员 memp_desc, 记录内存池的每一个内存块的大小, 数量, 基地址, 以及第一个空闲块的链表 ![image 20240703195734902](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407031957006.png) ### mem_std.h 根据使用的不同的模块, 初始化不同大小的内存池, 一般在lwipopts.h文件里面启用不同的模块 ```c #define MEMP_NUM_UDP_PCB 6 #if LWIP_UDP LWIP_MEMPOOL(UDP_PCB, MEMP_NUM_UDP_PCB, sizeof(struct udp_pcb), \"UDP_PCB\") #endif /* LWIP_UDP */ ``` ### memp.h ```c /** Create the list of all memory pools managed by memp. MEMP_MAX represents a NULL pool at the end */ typedef enum { #define LWIP_MEMPOOL(name,num,size,desc) MEMP_##name, #include \"lwip/priv/memp_std.h\" MEMP_MAX } memp_t; ``` 可以转换为 ```c /** Create the list of all memory pools managed by memp. MEMP_MAX represents a NULL pool at the end */ typedef enum { \tMEMP_UDP_PCB, ... \tMEMP_MAX } memp_t; ``` ### mem.c ```c #define LWIP_DECLARE_MEMORY_ALIGNED(variable_name, size) u8_t variable_name[LWIP_MEM_ALIGN_BUFFER(size)] #define LWIP_MEM_ALIGN_BUFFER(size) (((size) + MEM_ALIGNMENT 1U)) #define LWIP_MEMPOOL_DECLARE_STATS_INSTANCE(name) #define MEMP_SIZE (LWIP_MEM_ALIGN_SIZE(sizeof(struct memp)) + MEM_SANITY_REGION_BEFORE_ALIGNED) #define LWIP_MEMPOOL(name,num,size,desc) LWIP_MEMPOOL_DECLARE(name,num,size,desc) #define LWIP_MEMPOOL_DECLARE(name,num,size,desc) \\ LWIP_DECLARE_MEMORY_ALIGNED(memp_memory_ ## name ## _base, ((num) * (MEMP_SIZE + MEMP_ALIGN_SIZE(size)))); \\ \\ LWIP_MEMPOOL_DECLARE_STATS_INSTANCE(memp_stats_ ## name) \\ \\ static struct memp *memp_tab_ ## name; \\ \\ const struct memp_desc memp_ ## name { \\ DECLARE_LWIP_MEMPOOL_DESC(desc) \\ LWIP_MEMPOOL_DECLARE_STATS_REFERENCE(memp_stats_ ## name) \\ LWIP_MEM_ALIGN_SIZE(size), \\ (num), \\ memp_memory_ ## name ## _base, \\ &memp_tab_ ## name \\ }; ``` 展开以后 ```c #define LWIP_MEMPOOL_DECLARE(UDP_PCB, 6, sizeof(struct udp_pcb), \"UDP_PCB\") \\ u8_t memp_memory_UDP_PCB_base[(6 * (sizeof(struct memp) + 16 + sizeof(struct memp))))]; \\ static struct memp *memp_tab_UDP_PCB; \\ const struct memp_desc memp_UDP_PCB { \\ UDP_PCB, \\ 6, \\ memp_memory_UDP_PCB_base, \\ &memp_tab_UDP_PCB \\ }; ``` ```c const struct memp_desc *const memp_pools[MEMP_MAX] { #define LWIP_MEMPOOL(name,num,size,desc) &memp_ ## name, #include \"lwip/priv/memp_std.h\" }; 展开后的代码 V const struct memp_desc *const memp_pools[MEMP_MAX] { &memp_TCPIP_MSG_API, &memp_TCPIP_MSG_INPKT, ......... }; ``` ### 重要的函数 ```c memp_init(); // 初始化 memp_malloc(); //获取某一个类型的内存池 memp_free(); //释放内存池 ``` ```c void memp_init(void) { u16_t i; /* for every pool: */ for (i 0; i < LWIP_ARRAYSIZE(memp_pools); i++) { memp_init_pool(memp_pools[i]); } } ``` ```c void memp_init_pool(const struct memp_desc *desc) { int i; struct memp *memp; *desc >tab NULL; memp (struct memp *)LWIP_MEM_ALIGN(desc >base); //获取一下地址 /* create a linked list of memp elements */ for (i 0; i < desc >num; ++i) { memp >next *desc >tab; *desc >tab memp; //记录第一个空闲位置 /* cast through void* to get rid of alignment warnings */ memp (struct memp *)(void *)((u8_t *)memp + MEMP_SIZE + desc >size); //偏移到下一个位置 } } ``` > desc >tab会指向最后一个, memp >next指向前一个 ![image 20240703214545092](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407032145192.png) ![image 20240703214725751](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407032147833.png) ```c void * memp_malloc(memp_t type) { void *memp; LWIP_ERROR(\"memp_malloc: type < MEMP_MAX\", (type < MEMP_MAX), return NULL;); memp do_memp_malloc_pool(memp_pools[type]); return memp; } ``` > 之后实际就是对链表的操作"},"/note/嵌入式/第三方移植/lwIP/2024-6-30-02MAC简介.html":{"title":"MAC简介","content":" layout: post title: \"MAC简介\" date: 2024 6 3 15:39:08 +0800 tags: stm32 lwIP # MAC简介 [以太网基础 MAC和PHY CSDN博客](https://blog.csdn.net/u012489236/article/details/108669679) 从硬件的角度来分析，以太网的电路接口一般由CPU、MAC(Media Access Control)控制器和物理层接口(physical Layer PHY)组成，如下图所示 ![image 20240630174052836](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301740887.png) 对于上述三部分，并不一定都是独立的芯片，主要有以下几种情况 CPU内部集成了MAC和PHY，难度较高 CPU内部集成MAC,PHY采用独立芯片(主流方案) CPU不集成MAC和PHY，MAC和PHY采用独立芯片或者集成芯片(高端采用) PHY整合了大量模拟硬件，而MAC是典型的全数字器件，芯片面积及模拟/数字混合架构是为什么先将MAC集成进微控制器而将PHY留在片外的原因。更灵活、密度更高的芯片技术已经可以实现MAC和PHY的单芯片整合 对于这种方案，其硬件方案比独立的相对于更简单，PHY与MAC之间有以下两个重要的硬件接口 MDIO总线接口，主要是完成CPU对于PHY芯片的寄存器配置 MII总线接口，主要是完成数据收发相关的业务 > PHY实际的作用是把数据转换成可以发送出去的信号 ## STM32实现 STM32里面自带有一个10/100Mbit/s的以太网MAC内核, 他提供地址以及媒体访问的控制方式 特性: + 传输速率: 支持外部的PHY接口实现10/100Mbit/s的传输速率 + 协议标准: 符合IEEE802.3/3u的MII和RMII接口与以太网PHY通信 + 支持全双工以及半双工 + 支持通过MDIO接口配置以及管理PHY设备 ### MAC与PHY接口 ![image 20240630181614445](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301816509.png) ### MII/RMII接口 MII（Media Independent Interface）即媒体独立接口，MII接口是MAC与PHY连接的标准接口。它是IEEE 802.3定义的以太网行业标准。MII接口提供了MAC与PHY之间、PHY与STA(Station Management)之间的互联技术。媒体独立表明在不对MAC硬件重新设计或替换的情况下,任何类型的PHY设备都可以正常工作.它包括一个数据接口,以及一个MAC和PHY之间的管理接口。MII接口有MII、RMII、SMII、SSMII、SSSMII、GMII、SGMII、RGMII等。这里简要介绍其中的MII和RGMII。 MII接口主要包括以下三个部分： + 从MAC层到PHY层的发送数据接口 + 从PHY层到MAC层的接收数据接口 + 从MAC层和PHY层之间寄存器控制和信息获取的MDIO接口 首先来看看MII的MAC层定义接口 ![image 20240630182840430](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301828503.png) MII 数据接口总共需要 16 个信号，包括 TX_ER，TXD[3:0]，TX_EN，TX_CLK，COL，RXD[3:0]，RX_ER，RX_CLK，CRS，RX_DV 等。MII的时钟为25MHz，传输速率为10/100Mbps。所以MII的特性如下： + 支持10Mb/s和100Mb/s的数据速率 + 100M工作模式下，参考时钟是25MHz；10M工作模式下，信号参考时钟是2.5MHz + 支持全双工、半双工两种工作模式 + 发送和接收数据时采用,4bit方式 > RMII的用途： > RMII是简化的MII接口，在数据的收发上它比MII接口少了一倍的信号线（2数据位），所以它一般要求是50MHz的总线时钟。RMII一般用在多端口的交换机，所有的数据端口公用一个时钟用于所有端口的收发,这里就节省了不少的端口数目.RMII的一个端口要求7个数据线,比MII少了一倍,所以交换机能够接入多一倍数据的端口.和MII一样,RMII支持10Mbps和100Mbps的总线接口速度. > > ![image 20240630190240922](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301902974.png) ![image 20240630185126783](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301851838.png) ![image 20240630185813985](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301858053.png) ![image 20240630190149395](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301901461.png) 后来为了支持千兆网口，也就开始有了千兆网的MII接口，也就是GMII接口。现在比较常用的是RGMII，减小了MAC和PHY之间的引脚数量。数据信号和控制信号混合在一起，并且在工作时钟的上升沿和下降沿同时采样，其对应关系图如下： + 10M带宽对应的是2.5MHz，因为4bit*2.5M 10Mbps* + *100M带宽对应的是25MHz，因为4bit*25M 100Mbps + 1000M带宽对应的是125MHz，因为250MHz频率太高，所以采用双边沿采样技术（会带来设计复杂度）。4bit125M2 1000Mbps ![image 20240630183143714](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301831761.png) ### SMI管理系统 管理通道是下面的两条线, 实际的作用是管理多个PHY设备, 最多可以有32个PHY芯片 + MDC: 时钟引脚, 最大2.5MHz + MDIC: 数据输出/输入比特流 ![image 20240630182132712](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301821756.png) ![image 20240630182304639](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301823689.png) ## PHY芯片 是一个模数混合的芯片, 这一个芯片可以接受光电信号, 经过解调和AD转换以后通过MII和RMII信号传递给MAC内核 ![image 20240630210603265](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406302106327.png) 它们都是低功耗的10/100M以太网PHY层芯片，支持MII以及RMII接口与以太网MAC层通信。支持Auto MDIX自动翻转功能，无需更换网线即可将连接更改为直连或交叉连接。 > Auto MDIX（Automatic Medium Dependent Interface Crossover）是一种以太网技术，它允许设备自动检测和纠正线中的连接错误。这样可以使得使用直通线缆（般用于连接计算机和交换机）或交叉线缆一般用于连接交换机和路由器）来连接设备都能正常工作。 > > 在网络设备上启用Auto MDIX后，它将自动识别所使用的网线类型，并根据需要内部调整以适应该类型的网线。因此，用户无需关心所使用的是直通线还是交叉。 地址: SMI站管理通过PHY的地址访问指定的PHY芯片, 简称标识, 一般使用芯片的引脚进行设置 ### 时钟模式 ![image 20240630211830215](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406302118276.png) ![image 20240630212204806](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406302122894.png) ![image 20240630212235619](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406302122710.png) ### 寄存器 ![image 20240630212746391](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406302127459.png) > 可以通过BCR寄存器(0)设置速率以及, 13位为速度, 8位为全双工半双工 ## 以太网DMA描述符 实际发送数据的时候需要使用以太网DMA, 在实际的工程里面它起到的作用是发送的时候把描述符指向的缓冲区数据传递到TxFIFO里面吗接收的时候吧RxFIFO里面的数据传递到指向的缓冲区里面 ![image 20240630232217245](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406302322328.png) ```c typedef struct { \t__IO uint32_t Status; \t\t/* 状态 */ \tuint32_t ControlBufferSize; \t/* 缓冲区1和2的大小 */ \tuint32_t Buffer1Addr; \t\t/* 缓冲区1的地址 */ \tuint32_t Buffer2NextDescAddr; /* 缓冲区2的地址/指向下一个描述符 */ \t/* 以下成员变量为增强描述符的 */ \t/* ……………………*/ } ETH_DMADescTypeDef; ``` > ![image 20240630232713890](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406302327956.png) > > ![image 20240630233101338](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406302331404.png) ![image 20240630233138373](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406302331412.png) 在实际实现的时候, 使用ETH_InitTypeDef里面的两个变量, RxDesc和TxDesc进行追踪"},"/note/嵌入式/第三方移植/lwIP/2024-7-3-06网络接口.html":{"title":"网络接口","content":" layout: post title: \"网络接口\" date: 2024 7 3 15:39:08 +0800 tags: stm32 lwIP # 网络接口 网卡的管理接口, lwIP支持多种不同的网卡, 直接和底层打交道, 硬件的处理是不同的, 所以需要用户提供底层接口函数, lwIP的统一接口需要用户实现(ethernetif.c), 使用结构体netif进行管理, 记录有发送函数以及接收等函数以及网卡的状态, 最后把netif使用链表连接起来 ![image 20240703222255794](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407032222857.png) ![image 20240703222628246](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407032226314.png) 使用netif函数的时候 ![image 20240703222232516](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407032222589.png) ### 相关函数变量 ![image 20240704184443521](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407041844585.png) ![image 20240704184628865](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407041846934.png) ```c struct netif * netif_add(struct netif *netif, const ip4_addr_t *ipaddr, const ip4_addr_t *netmask, const ip4_addr_t *gw, void *state, netif_init_fn init, netif_input_fn input) ``` > 如果IP地址, 网关, 子网掩码为NULL, 会使用默认的值 > > 之后初始化netif里面的函数, 参数等 > > 之后把网卡加入链表里面 ```c void netif_remove(struct netif *netif) ``` > 会把这一个netif从链表里面移除, 以及关闭和从默认的网卡位置移除"},"/note/嵌入式/第三方移植/lwIP/2024-7-4-07网络数据包.html":{"title":"网络数据包","content":" layout: post title: \"网络数据包\" date: 2024 7 3 15:39:08 +0800 tags: stm32 lwIP # 网络数据包 TCP/IP是一种数据通信机制，因此，协议栈的实现本质上就是对数据包进行处理，为了实现高效的效率，lwIP数据包管理要提供一种高效处理的机制。协议栈各层能对数据包进行灵活的处理，同时减少数据在各层间传递时的时间与空间开销，这是提高协议栈工作效率的关键点。在lwIP中它称之为pbuf。 一般使用的时候会申请一个pbuf数据包, 填充数据以后依次在应用层, 传输层, 网络层之间传递依次添加头部, 然后把这一个数据复制到缓冲区里面, 然后使用DMA进行传递以及发送 ![image 20240704195659878](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407041956931.png) > 这是一个模糊分层的tcp/ip协议栈, 大大提升传输的速率 ![image 20240704201544886](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407042015012.png) ```c /** * @ingroup pbuf * Enumeration of pbuf layers */ typedef enum { /** Includes spare room for transport layer header, e.g. UDP header. * Use this if you intend to pass the pbuf to functions like udp_send(). */ PBUF_TRANSPORT PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN + PBUF_TRANSPORT_HLEN, /** Includes spare room for IP header. * Use this if you intend to pass the pbuf to functions like raw_send(). */ PBUF_IP PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN + PBUF_IP_HLEN, /** Includes spare room for link layer header (ethernet header). * Use this if you intend to pass the pbuf to functions like ethernet_output(). * @see PBUF_LINK_HLEN */ PBUF_LINK PBUF_LINK_ENCAPSULATION_HLEN + PBUF_LINK_HLEN, /** Includes spare room for additional encapsulation header before ethernet * headers (e.g. 802.11). * Use this if you intend to pass the pbuf to functions like netif >linkoutput(). * @see PBUF_LINK_ENCAPSULATION_HLEN */ PBUF_RAW_TX PBUF_LINK_ENCAPSULATION_HLEN, /** Use this for input packets in a netif driver when calling netif >input() * in the most common case ethernet layer netif driver. */ PBUF_RAW 0 } pbuf_layer; ``` ![image 20240704201932861](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407042019943.png) > PBUF_RAM 类型： > PBUF_RAM 类型的pbuf的数据存放在RAM中(由内存堆分配而来)，常用于发送数据的情况。 > 在申请这种类型的pbuf时，协议栈会根据所需要的大小申请对应内存空间。 > 其中，申请的内存包含pbuf数据结构大小以及所需要的数据空间大小。 > PBUF_POOL 类型： > PBUF_POOL类型的pbuf的数据结构大小以及所需要的数据空间大小也是连续的内存块中。 > 但是这个连续的内存块是由内存池进行分配的。 > PBUF_ROM 与 PBUF_PEF 类型 > PBUF_ROM 与 PBUF_PEF ，在内存池申请的pbuf只包含pbuf的数据结构大小。 > PBUF_ROM 存放的数据区域在ROM中。 > PBUF_PEF 存放的数据区域在RAM中。(与PBUF_RAM 相比，就是pbuf数据结构内存与所存放数据区域的内存是不连续的) ## API函数 ![image 20240704202005053](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407042020206.png) > pbuf.c文件里面实现 ```c struct pbuf * pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type) ``` > pbuf_layer: 偏移的类型 > > length: 数据的长度 > > type: 类型 > > 会根据不同的类型进行不同的分配方式, 使用PBUF_REF/ROM的时候, 会直接分配一个pbuf并进行初始化 > > 在使用PBUF_POOL的时候, 会使用链表把这几个获取的pbuf连接起来 > > ![image 20240704211146887](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407042111941.png) > > ![image 20240704213026137](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407042130199.png) > > 直接获取一个大的位置 ```c u8_t pbuf_free(struct pbuf *p) ``` > 在实际释放的时候, 会检测这一个pbuf还有没有在使用"},"/note/嵌入式/第三方移植/lwIP/2024-7-1-04启动流程.html":{"title":"启动流程","content":" layout: post title: \"启动流程\" date: 2024 6 3 15:39:08 +0800 tags: stm32 lwIP # 启动流程 ## 旧版 ![image 20240701172602037](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407011726089.png) 1. 申请内存, 获取四个缓冲区ethernet_mem_malloc 2. 初始化一下静态的ip, 实际是一个自己定义的信息结构体lwip_comm_default_ip_set ```c /*lwip控制结构体*/ typedef struct { uint8_t mac[6]; /* MAC地址 */ uint8_t remoteip[4]; /* 远端主机IP地址 */ uint8_t ip[4]; /* 本机IP地址 */ uint8_t netmask[4]; /* 子网掩码 */ uint8_t gateway[4]; /* 默认网关的IP地址 */ uint8_t dhcpstatus; /* dhcp状态 */ /* 0, 未获取DHCP地址;*/ /* 1, 进入DHCP获取状态*/ /* 2, 成功获取DHCP地址*/ /* 0XFF,获取失败 */ }__lwip_dev; ``` > 之后会使用这一个结构体里面的信息进行初始化lwIP 3. ethernet_init初始化一下HAL库的MAC驱动, 间接调用HAL_ETH_MspInit这一个函数 在HAL_ETH_MspInit里面初始化各种IO, 以及使用硬件复位一下PHY芯片, 以及设置网络的中断优先级 4. lwip_init初始化一下lwIP的内核, 使用不同的宏定义初始化不同的部件, tcpip_init >建立处理任务 5. netif_add添加一个网口, 这一个函数设置以太网的IP地址, 以及传进去两个函数, 一个是网卡初始化, 另一个是以太网数据包输入的函数 ```c netif_init_flag netif_add(&lwip_netif, (const ip_addr_t *)&ipaddr, (const ip_addr_t *)&netmask, (const ip_addr_t *)&gw, NULL, &ethernetif_init, &ethernet_input); ``` > ethernetif_init: 会在这一个函数里面记录虚拟网卡的名字, 使用的函数(如下), 最后调用low_level_init初始化缓冲区链表以及使能ETH > > > 比如etharp_output函数, 会使用这一个函数判断IP地址有没有对应的Mac地址, 没有的话使用ARP获取, low_level_output函数, 这一个函数把pbuf里面的数据复制到缓冲区里面, 然后启动DMA > > ethernet_input: 会把pbuf里面的信息发送到网络层里面 > > ![image 20240701183942729](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407011839776.png) 6. 收数据的处理 中断里面判断是获取了数据, lwip_pkt_handle >ethernetif_input >low_level_input, 在这一个函数把DMA获取的数据复制到pbuf里面, 返回的是puf链表的第一个pbuf 之后会调用ethernet_input(netif >input)函数把数据包提交到网络层 ![image 20240701185526340](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407011855396.png) ![image 20240701185653526](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407011856571.png) ## 新版 ![image 20240701171437347](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407011714419.png) 1. 初始化缓冲区, 使用一个数组 2. 初始化lwIP的内核lwip_init 3. 初始化默认的信息lwip_comm_default_ip_set ```c /*lwip控制结构体*/ typedef struct { uint8_t mac[6]; /* MAC地址 */ uint8_t remoteip[4]; /* 远端主机IP地址 */ uint8_t ip[4]; /* 本机IP地址 */ uint8_t netmask[4]; /* 子网掩码 */ uint8_t gateway[4]; /* 默认网关的IP地址 */ uint8_t dhcpstatus; /* dhcp状态 0, 未获取DHCP地址 1, 进入DHCP获取状态 2, 成功获取DHCP地址 0XFF,获取失败 */ }__lwip_dev; ``` > 实际是对这一个结构体的填充 4. netif_add添加网络驱动 在添加的时候调用ethernetif_init这一个函数进行初始化, 以及设置一下输出函数 最后调用low_level_init函数下面是这一个函数的作用 里面的函数会在eth_chip_init里面进行初始化函数调用, 同时在里面遍历所有的地址, 获取实际有用的地址, 之后使用获取的这一个地址进行一次软件复位 eth_chip_start_auto_nego函数里面使用之前获取的地址, 以及写寄存器的函数进行设置, 启用自动协商 eth_chip_get_link_state获取一下使用速度以及是否使用全双工, 使用获取的参数使能ETH, 开启虚拟网卡, 使能ETH的时候会初始化GPIO, 软件复位以及启动中断, 在eth_chip_regster_bus_io里面设置io对应的函数, 设置一下初始化(设置时钟), 读写寄存器, 获取时钟的函数 ![image 20240701215923315](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407012159383.png) 5. pcf8574_init在这一个里面初始化PHY芯片 ![image 20240701215950873](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407012159925.png) ## 有操作系统 ![image 20240702153518793](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407021535854.png) ![image 20240702153700490](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407021537583.png) 1. 在任务里面调用lwip_comm_init函数 2. tcpip_init, 会在这一个里面调用lwip_init函数, 以及建立一个tcpip_thread线程(会使用lvipopt.h里面的配置), 以及建立一个用于传递数据的邮箱tcpip_mbox, 之后pbuf的传递也会使用这一个 3. netif_add, 在里面调用ethernetif_init函数, 以及初始化netif, ethernetif_init函数里面会调用low_level_init, 以及设置netif的战术, low_level_init会进行ethernetif_input任务的创建, 以及两个二值信号量 4. lwip_comm_default_ip_set, 记录一下初始化的信息 5. 创建lwip_link_thread任务, 通过读取PHY芯片的寄存器, 判断是不是连接, 不是的话进行处理 6. 创建lwip_periodic_handle任务, 通过DHCP获取ip 把里面的操作改为使用任务实现 ### start_task初始化 起始任务, 初始化的时候开启的第一个任务, 会在这一个函数里面调用lwip_comm_init函数, 之后通过读取寄存器的方式进行获取是不是链接成功, 之后通过DHCP获取IP, 然后创建lwip_demo_task任务 ### ethernetif_input接收数据 在这一个任务里面获取信号量, s_xSemaphore, 这一个信号量是在获取数据的中断里面进行释放的, 使用low_level_input获取信息, 返回一个pbuf, 进一步调用tcpip_input等函数把这一个信息交给网络层, 使用tcpip_inpkt函数构建一个msg结构体, 把信息交给队列tcpip_thread函数进行处理, 使用邮箱tcpip_mbox > ![image 20240702182018246](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407021820286.png) > > input_fn 指向函数 ethernet_input > LWIP_FREERTOS_THREAD_STACKSIZE_IS_STACKWORDS这一个宏定义设置为1的时候会使用word作为申请任务的时候栈的大小, 在sys_srch.c ### tcpip_thread数据分类 获等待获取邮箱发送过来的信息, tcpip_input >tcpip_inpkt >sys_mbox_trypost 获取邮箱里面的消息(阻塞), 根据获取的信息进行判断, 使用tcpip_thread_handle_msg进行处理消息, 根据不同类别的消息进行不同的处理, 如果是TCPIP_MSG_INPKT这一个类型的话, 会把这一个消息传出去 这一个消息最后会到达ethernet_input这一个函数, 判断获取的包的类型, 如果是一个ARP类型的数据, 使用etharp_input函数进行处理, 否则使用ipv4_input函数进行处理 ### lwip_link_thread 读取PHY芯片的状态寄存器, 获取连接的信息, 查看网线是不是接入了, 有的话打开网络中断以及启动虚拟网卡, 否则的话关闭 ![image 20240702183722104](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407021837152.png) ### lwip_periodic_handle 通过DHCP的状态机获取DHCP分配的ip地址 ### 发送数据 ![image 20240702184447900](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407021844941.png) low_level_output函数里面进行底层的发送数据, 把pbuf里面的数据移动到缓冲区里面, 发送以后会等待信号量g_TxSemaphore, 会在中断的HAL_ETH_TxCpltCallback回调函数里面进行释放, 获取到这一个信号量以后说明信息已经发送出去了, 这时候可以释放pbuf"},"/note/嵌入式/第三方移植/lwIP/2024-7-12-15NETCONN.html":{"title":"NETCONN","content":" layout: post title: \"NETCONN\" date: 2024 7 12 15:39:08 +0800 tags: stm32 lwIP # NETCONN 使用操作系统的IPC机制, 对网络连接进行抽象, 使用同一个接口实现UDP和TCP连接 实际是对RAW接口的封装, 或者直接调用底层的函数, 默认的时候是直接调用底层函数 ## 数据类型 ![image 20240712234610546](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407122346628.png) > 使用这一个结构体进行管理 ![image 20240712234953500](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407122349575.png) > 使用这一个结构体进行管理数据 ```c /** * LWIP_SO_SNDTIMEO 1: Enable send timeout for sockets/netconns and * SO_SNDTIMEO processing. */ #if !defined LWIP_SO_SNDTIMEO defined __DOXYGEN__ #define LWIP_SO_SNDTIMEO 0 #endif /** * LWIP_SO_RCVTIMEO 1: Enable receive timeout for sockets/netconns and * SO_RCVTIMEO processing. */ #if !defined LWIP_SO_RCVTIMEO defined __DOXYGEN__ #define LWIP_SO_RCVTIMEO 1 #endif ``` > 把这一个配置为1的时候, 发送以及接收有一个超时时间, 控制块里面有一个send_timeout, recv_timeout变量, 用于设置超时时间 ![image 20240713103011627](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407131030727.png) ## API ![image 20240713103353573](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407131033642.png) ### 连接 ```c #define netconn_new(t) netconn_new_with_proto_and_callback(t, 0, NULL) /** * Create a new netconn (of a specific type) that has a callback function. * The corresponding pcb is also created. * * @param t the type of 'connection' to create (@see enum netconn_type) * @param proto the IP protocol for RAW IP pcbs * @param callback a function to call on status changes (RX available, TX'ed) * @return a newly allocated struct netconn or * NULL on memory error */ struct netconn * netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback); ``` > 建立了一个没有默认IP和状态改变回调函数的控制块 > > ```c > /** @ingroup netconn_common > * Protocol family and type of the netconn > */ > enum netconn_type { > NETCONN_INVALID 0, > /** TCP IPv4 */ > NETCONN_TCP 0x10, > /** UDP IPv4 */ > NETCONN_UDP 0x20, > /** UDP IPv4 lite */ > NETCONN_UDPLITE 0x21, > /** UDP IPv4 no checksum */ > NETCONN_UDPNOCHKSUM 0x22, > /** Raw connection IPv4 */ > NETCONN_RAW 0x40 > }; > ``` ```c /** * @ingroup netconn_common * Close a netconn 'connection' and free its resources. * UDP and RAW connection are completely closed, TCP pcbs might still be in a waitstate * after this returns. * * @param conn the netconn to delete * @return ERR_OK if the connection was deleted */ err_t netconn_delete(struct netconn *conn) ``` > 断开连接以及释放资源 ```c /** * @ingroup netconn_common * Bind a netconn to a specific local IP address and port. * Binding one netconn twice might not always be checked correctly! * * @param conn the netconn to bind * @param addr the local IP address to bind the netconn to * (use IP4_ADDR_ANY/IP6_ADDR_ANY to bind to all addresses) * @param port the local port to bind the netconn to (not used for RAW) * @return ERR_OK if bound, any other err_t on failure */ err_t netconn_bind(struct netconn *conn, const ip_addr_t *addr, u16_t port) ``` > 绑定本地的IP地址 ```c /** * @ingroup netconn_common * Connect a netconn to a specific remote IP address and port. * * @param conn the netconn to connect * @param addr the remote IP address to connect to * @param port the remote port to connect to (no used for RAW) * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise */ err_t netconn_connect(struct netconn *conn, const ip_addr_t *addr, u16_t port) ``` > 建立连接 ```c /** * @ingroup netconn_udp * Disconnect a netconn from its current peer (only valid for UDP netconns). * * @param conn the netconn to disconnect * @return See @ref err_t */ err_t netconn_disconnect(struct netconn *conn) ``` > 断开连接 ```c #define\tTCP_DEFAULT_LISTEN_BACKLOG\t\t\t0xff #define netconn_listen(conn) netconn_listen_with_backlog(conn, TCP_DEFAULT_LISTEN_BACKLOG) /** * @ingroup netconn_tcp * Set a TCP netconn into listen mode * * @param conn the tcp netconn to set to listen mode * @param backlog the listen backlog, only used if TCP_LISTEN_BACKLOG 1 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns * don't return any error (yet?)) */ err_t netconn_listen_with_backlog(struct netconn *conn, u8_t backlog) ``` ```c /** * @ingroup netconn_tcp * Accept a new connection on a TCP listening netconn. * * @param conn the TCP listen netconn * @param new_conn pointer where the new connection is stored * @return ERR_OK if a new connection has been received or an error * code otherwise */ err_t netconn_accept(struct netconn *conn, struct netconn **new_conn) ``` > 获取一个TCP连接 ### 数据 ```c /** * @ingroup netconn_common * Receive data (in form of a netbuf containing a packet buffer) from a netconn * * @param conn the netconn from which to receive data * @param new_buf pointer where a new netbuf is stored when received data * @return ERR_OK if data has been received, an error code otherwise (timeout, * memory error or another error) */ err_t netconn_recv(struct netconn *conn, struct netbuf **new_buf) ``` > 获取数据, 获取的数据是一个netbuf类型的数据 ```c /** * @ingroup netconn_udp * Send data over a UDP or RAW netconn (that is already connected). * * @param conn the UDP or RAW netconn over which to send data * @param buf a netbuf containing the data to send * @return ERR_OK if data was sent, any other err_t on error */ err_t netconn_send(struct netconn *conn, struct netbuf *buf) ``` > 发送UDP数据 ```c #define netconn_write(conn, dataptr, size, apiflags) \\ netconn_write_partly(conn, dataptr, size, apiflags, NULL) /** * @ingroup netconn_tcp * Send data over a TCP netconn. * * @param conn the TCP netconn over which to send data * @param dataptr pointer to the application buffer that contains the data to send * @param size size of the application data to send * @param apiflags combination of following flags : * NETCONN_COPY: data will be copied into memory belonging to the stack * NETCONN_MORE: for TCP connection, PSH flag will be set on last segment sent * NETCONN_DONTBLOCK: only write the data if all data can be written at once * @param bytes_written pointer to a location that receives the number of written bytes * @return ERR_OK if data was sent, any other err_t on error */ err_t netconn_write_partly(struct netconn *conn, const void *dataptr, size_t size, u8_t apiflags, size_t *bytes_written) ``` > 发送TCP数据 ### 数据块 ```c /** * @ingroup netbuf * Create (allocate) and initialize a new netbuf. * The netbuf doesn't yet contain a packet buffer! * * @return a pointer to a new netbuf * NULL on lack of memory */ struct netbuf *netbuf_new(void) ``` > 获取一个数据控制块 ```c /** * @ingroup netbuf * Allocate memory for a packet buffer for a given netbuf. * * @param buf the netbuf for which to allocate a packet buffer * @param size the size of the packet buffer to allocate * @return pointer to the allocated memory * NULL if no memory could be allocated */ void * netbuf_alloc(struct netbuf *buf, u16_t size) ``` > 申请数据区域 ```c /** * Get the local or remote IP address and port of a netconn. * For RAW netconns, this returns the protocol instead of a port! * * @param conn the netconn to query * @param addr a pointer to which to save the IP address * @param port a pointer to which to save the port (or protocol for RAW) * @param local 1 to get the local IP address, 0 to get the remote one * @return ERR_CONN for invalid connections * ERR_OK if the information was retrieved */ err_t netconn_getaddr(struct netconn *conn, ip_addr_t *addr, u16_t *port, u8_t local) ``` > 获取本地或对方的IP地址和端口号 ### 解析域名 ```c /** * @ingroup netconn_common * Execute a DNS query, only one IP address is returned * * @param name a string representation of the DNS host name to query * @param addr a preallocated ip_addr_t where to store the resolved IP address * @param dns_addrtype IP address type (IPv4 / IPv6) * @return ERR_OK: resolving succeeded * ERR_MEM: memory error, try again later * ERR_ARG: dns client not initialized or invalid hostname * ERR_VAL: dns server response was invalid */ err_t netconn_gethostbyname(const char *name, ip_addr_t *addr) ``` > 解析域名 ## UDP 1. 使用netconn_new创建一个控制块 2. 定义时间超时函数 3. 使用netconn_bind绑定本地的IP和端口 4. 使用netconn_connect建立连接 ```c void lwip_demo(void) { err_t err; static struct netconn *udpconn; static struct netbuf *recvbuf; static struct netbuf *sentbuf; ip_addr_t destipaddr; uint32_t data_len 0; struct pbuf *q; BaseType_t lwip_err; /* 第一步：创建udp控制块 */ udpconn netconn_new(NETCONN_UDP); /* 定义接收超时时间 */ udpconn >recv_timeout 10; if (udpconn ! NULL) /* 判断创建控制块释放成功 */ { /* 第二步：绑定控制块、本地IP和端口 */ err netconn_bind(udpconn, IP_ADDR_ANY, LWIP_DEMO_PORT); /*构造目的IP地址 */ IP4_ADDR(&destipaddr, DEST_IP_ADDR0,DEST_IP_ADDR1,DEST_IP_ADDR2,DEST_IP_ADDR3); /* 第三步：连接或者建立对话框 */ netconn_connect(udpconn, &destipaddr, LWIP_DEMO_PORT); /* 连接到远端主机 */ if (err ERR_OK) /* 绑定完成 */ { while (1) { /* 第四步：如果指定的按键按下时，会发送信息 */ if ((g_lwip_send_flag & LWIP_SEND_DATA) LWIP_SEND_DATA) { sentbuf netbuf_new(); netbuf_alloc(sentbuf, strlen((char *)g_lwip_demo_sendbuf)); memcpy(sentbuf >p >payload, (void *)g_lwip_demo_sendbuf, strlen((char *)g_lwip_demo_sendbuf)); err netconn_send(udpconn, sentbuf); /* 将netbuf中的数据发送出去 */ if (err ! ERR_OK) { printf(\"发送失败\\r\\n\"); netbuf_delete(sentbuf); /* 删除buf */ } g_lwip_send_flag & ~LWIP_SEND_DATA; /* 清除数据发送标志 */ netbuf_delete(sentbuf); /* 删除buf */ } /* 第五步：接收数据 */ netconn_recv(udpconn, &recvbuf); if (recvbuf ! NULL) /* 接收到数据 */ { memset(g_lwip_demo_recvbuf, 0, LWIP_DEMO_RX_BUFSIZE); /* 数据接收缓冲区清零 */ for (q recvbuf >p; q ! NULL; q q >next) /* 遍历完整个pbuf链表 */ { /* 判断要拷贝到UDP_DEMO_RX_BUFSIZE中的数据是否大于UDP_DEMO_RX_BUFSIZE的剩余空间，如果大于 */ /* 的话就只拷贝UDP_DEMO_RX_BUFSIZE中剩余长度的数据，否则的话就拷贝所有的数据 */ if (q >len > (LWIP_DEMO_RX_BUFSIZE data_len)) memcpy(g_lwip_demo_recvbuf + data_len, q >payload, (LWIP_DEMO_RX_BUFSIZE data_len)); /* 拷贝数据 */ else memcpy(g_lwip_demo_recvbuf + data_len, q >payload, q >len); data_len + q >len; if (data_len > LWIP_DEMO_RX_BUFSIZE) break; /* 超出TCP客户端接收数组,跳出 */ } data_len 0; /* 复制完成后data_len要清零 */ \t\t\t\t //获取的数据在另一个任务里面进行处理 lwip_err xQueueSend(g_display_queue,&g_lwip_demo_recvbuf,0); if (lwip_err errQUEUE_FULL) { printf(\"队列Key_Queue已满，数据发送失败!\\r\\n\"); } netbuf_delete(recvbuf); /* 删除buf */ } else vTaskDelay(5); /* 延时5ms */ vTaskDelay(10); } } else printf(\"UDP绑定失败\\r\\n\"); } else printf(\"UDP连接创建失败\\r\\n\"); } ``` ## TCP ### 客户端 1. 使用netconn_new获取一个控制块 2. 使用函数netconn_connet连接服务器 3. 使用netconn_getaddr获取本地的ip和端口 4. 使用netconn_recv和netconn_write进行数据交流 ```c /** * @brief lwip_demo实验入口 * @param 无 * @retval 无 */ void lwip_demo(void) { static struct netconn *tcp_clientconn NULL; /* TCP CLIENT网络连接结构体 */ uint32_t data_len 0; struct pbuf *q; err_t err,recv_err; ip4_addr_t server_ipaddr,loca_ipaddr; static uint16_t server_port,loca_port; BaseType_t lwip_err; char *tbuf; server_port LWIP_DEMO_PORT; IP4_ADDR(&server_ipaddr,DEST_IP_ADDR0,DEST_IP_ADDR1,DEST_IP_ADDR2,DEST_IP_ADDR3); //构造目的IP地址 tbuf mymalloc(SRAMIN, 200); /* 申请内存 */ sprintf((char *)tbuf, \"Port:%d\", LWIP_DEMO_PORT); /* 客户端端口号 */ lcd_show_string(5, 150, 200, 16, 16, tbuf, BLUE); while (1) { tcp_clientconn netconn_new(NETCONN_TCP);/* 创建一个TCP链接 */ err netconn_connect(tcp_clientconn,&server_ipaddr,server_port);/* 连接服务器 */ if(err ! ERR_OK) { printf(\"接连失败\\r\\n\"); netconn_delete(tcp_clientconn);/* 返回值不等于ERR_OK,删除tcp_clientconn连接 */ } else if (err ERR_OK)/* 处理新连接的数据 */ { struct netbuf *recvbuf; tcp_clientconn >recv_timeout 10; netconn_getaddr(tcp_clientconn,&loca_ipaddr,&loca_port,1);/* 获取本地IP主机IP地址和端口号 */ printf(\"连接上服务器%d.%d.%d.%d,本机端口号为:%d\\r\\n\",DEST_IP_ADDR0,DEST_IP_ADDR1, DEST_IP_ADDR2,DEST_IP_ADDR3,loca_port); lcd_show_string(5, 90, 200, 16, 16, \"State:Connection Successful\", BLUE); while(1) { if((g_lwip_send_flag & LWIP_SEND_DATA) LWIP_SEND_DATA)/* 有数据要发送 */ { err netconn_write(tcp_clientconn ,g_lwip_demo_sendbuf,strlen((char*)g_lwip_demo_sendbuf),NETCONN_COPY); /* 发送tcp_server_sentbuf中的数据 */ if(err ! ERR_OK) { printf(\"发送失败\\r\\n\"); } g_lwip_send_flag & ~LWIP_SEND_DATA; } if((recv_err netconn_recv(tcp_clientconn,&recvbuf)) ERR_OK)/* 接收到数据 */ { taskENTER_CRITICAL(); /* 进入临界区 */ memset(g_lwip_demo_recvbuf,0,LWIP_DEMO_RX_BUFSIZE); /* 数据接收缓冲区清零 */ for(q recvbuf >p;q ! NULL;q q >next) /* 遍历完整个pbuf链表 */ { /* 判断要拷贝到TCP_CLIENT_RX_BUFSIZE中的数据是否大于TCP_CLIENT_RX_BUFSIZE的剩余空间，如果大于 */ /* 的话就只拷贝TCP_CLIENT_RX_BUFSIZE中剩余长度的数据，否则的话就拷贝所有的数据 */ if(q >len > (LWIP_DEMO_RX_BUFSIZE data_len)) { memcpy(g_lwip_demo_recvbuf + data_len,q >payload,(LWIP_DEMO_RX_BUFSIZE data_len));/* 拷贝数据 */ } else { memcpy(g_lwip_demo_recvbuf + data_len,q >payload,q >len); } data_len + q >len; if(data_len > LWIP_DEMO_RX_BUFSIZE) { break; /* 超出TCP客户端接收数组,跳出 */ } } taskEXIT_CRITICAL(); /* 退出临界区 */ data_len 0; /* 复制完成后data_len要清零 */ lwip_err xQueueSend(g_display_queue,&g_lwip_demo_recvbuf,0); if (lwip_err errQUEUE_FULL) { printf(\"队列Key_Queue已满，数据发送失败!\\r\\n\"); } netbuf_delete(recvbuf); } else if(recv_err ERR_CLSD) /* 关闭连接 */ { netconn_close(tcp_clientconn); netconn_delete(tcp_clientconn); printf(\"服务器%d.%d.%d.%d断开连接\\r\\n\",DEST_IP_ADDR0,DEST_IP_ADDR1, DEST_IP_ADDR2,DEST_IP_ADDR3); lcd_fill(5, 89, lcddev.width,110, WHITE); lcd_show_string(5, 90, 200, 16, 16, \"State:Disconnect\", BLUE); myfree(SRAMIN, tbuf); break; } } } } } ``` ### 服务器 1. 调用函数netconn_new建立一个控制块 2. 使用netconn_bind绑定TCP控制块, 本地的IP以及端口 3. netconn_listen进入监听模式 4. netconn_accept接收连接请求 5. netconn_getaddr获取远端的IP以及端口 6. netconn_write和recv进行数据的交流 ```c /** * @brief lwip_demo实验入口 * @param 无 * @retval 无 */ void lwip_demo(void) { static struct netconn *tcp_serverconn NULL; /* TCP SERVER网络连接结构体 */ uint32_t data_len 0; struct pbuf *q; err_t err,recv_err; uint8_t remot_addr[4]; struct netconn *newconn; static ip_addr_t ipaddr; static u16_t port; BaseType_t lwip_err; char *tbuf; tbuf mymalloc(SRAMIN, 200); /* 申请内存 */ sprintf((char *)tbuf, \"Port:%d\", LWIP_DEMO_PORT); /* 客户端端口号 */ lcd_show_string(5, 150, 200, 16, 16, tbuf, BLUE); /* 第一步：创建一个TCP控制块 */ tcp_serverconn netconn_new(NETCONN_TCP); /* 创建一个TCP链接 */ /* 第二步：绑定TCP控制块、本地IP地址和端口号 */ netconn_bind(tcp_serverconn,IP_ADDR_ANY,LWIP_DEMO_PORT); /* 绑定端口 8080号端口 */ /* 第三步：监听 */ netconn_listen(tcp_serverconn); /* 进入监听模式 */ tcp_serverconn >recv_timeout 10; /* 禁止阻塞线程 等待10ms */ while (1) { /* 第四步：接收连接请求 */ err netconn_accept(tcp_serverconn,&newconn); /* 接收连接请求 */ if(err ERR_OK) newconn >recv_timeout 10; if (err ERR_OK) /* 处理新连接的数据 */ { struct netbuf *recvbuf; netconn_getaddr(newconn,&ipaddr,&port,0); /* 获取远端IP地址和端口号 */ remot_addr[3] (uint8_t)(ipaddr.addr >> 24); remot_addr[2] (uint8_t)(ipaddr.addr>> 16); remot_addr[1] (uint8_t)(ipaddr.addr >> 8); remot_addr[0] (uint8_t)(ipaddr.addr); printf(\"主机%d.%d.%d.%d连接上服务器,主机端口号为:%d\\r\\n\",remot_addr[0], remot_addr[1],remot_addr[2],remot_addr[3],port); lcd_show_string(5, 90, 200, 16, 16, \"State:Connection Successful\", BLUE); while(1) { if((g_lwip_send_flag & LWIP_SEND_DATA) LWIP_SEND_DATA) /* 有数据要发送 */ { err netconn_write(newconn , g_lwip_demo_sendbuf,strlen((char*)g_lwip_demo_sendbuf),NETCONN_COPY); /* 发送g_lwip_demo_sendbuf中的数据 */ if(err ! ERR_OK) { printf(\"发送失败\\r\\n\"); } g_lwip_send_flag & ~LWIP_SEND_DATA; } if((recv_err netconn_recv(newconn,&recvbuf)) ERR_OK) /* 接收到数据 */ { taskENTER_CRITICAL();/* 进入临界区 */ memset(g_lwip_demo_recvbuf,0,LWIP_DEMO_RX_BUFSIZE);/* 数据接收缓冲区清零 */ for(q recvbuf >p;q ! NULL;q q >next) /* 遍历完整个pbuf链表 */ { /* 判断要拷贝到LWIP_DEMO_RX_BUFSIZE中的数据是否大于LWIP_DEMO_RX_BUFSIZE 的剩余空间，如果大于 */ /* 的话就只拷贝LWIP_DEMO_RX_BUFSIZE中剩余长度的数据，否则的话就拷贝所有的数据 */ if(q >len > (LWIP_DEMO_RX_BUFSIZE data_len)) { memcpy(g_lwip_demo_recvbuf + data_len,q >payload, (LWIP_DEMO_RX_BUFSIZE data_len));/* 拷贝数据 */ } else { memcpy(g_lwip_demo_recvbuf + data_len,q >payload,q >len); } data_len + q >len; if(data_len > LWIP_DEMO_RX_BUFSIZE) { break; /*超出TCP客户端接收数组,跳出*/ } } taskEXIT_CRITICAL(); /* 退出临界区 */ data_len 0; /* 复制完成后data_len要清零 */ lwip_err xQueueSend(g_display_queue,&g_lwip_demo_recvbuf,0); if (lwip_err errQUEUE_FULL) { printf(\"队列Key_Queue已满，数据发送失败!\\r\\n\"); } netbuf_delete(recvbuf); } else if(recv_err ERR_CLSD) /* 关闭连接 */ { netconn_close(newconn); netconn_delete(newconn); printf(\"主机:%d.%d.%d.%d断开与服务器的连接\\r\\n\",remot_addr[0], remot_addr[1],remot_addr[2],remot_addr[3]); lcd_fill(5, 89, lcddev.width,110, WHITE); lcd_show_string(5, 90, 200, 16, 16, \"State:Disconnect\", BLUE); myfree(SRAMIN, tbuf); break; } } } } } ```"},"/note/嵌入式/第三方移植/lwIP/2024-7-13-16NTP获取时间.html":{"title":"NTP获取时间","content":" layout: post title: \"NTP获取时间\" date: 2024 7 13 15:39:08 +0800 tags: Linux 网络 # NTP获取时间 ![image 20240713232047443](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407132320522.png) ![image 20240713232618790](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407132326840.png) NTP报文格式如上图所示，它的字段含义参考如下： LI 闰秒标识器，占用2个bit VN 版本号，占用3个bits，表示NTP的版本号，现在为3 Mode 模式，占用3个bits，表示模式 stratum（层），占用8个bits Poll 测试间隔，占用8个bits，表示连续信息之间的最大间隔 Precision 精度，占用8个bits，，表示本地时钟精度 Root Delay根时延，占用8个bits，表示在主参考源之间往返的总共时延 Root Dispersion根离散，占用8个bits，表示在主参考源有关的名义错误 Reference Identifier参考时钟标识符，占用8个bits，用来标识特殊的参考源 参考时间戳，64bits时间戳，本地时钟被修改的最新时间。 原始时间戳，客户端发送的时间，64bits。 接受时间戳，服务端接受到的时间，64bits。 传送时间戳，服务端送出应答的时间，64bits。 ## 实现 1. 以 UDP 协议连接阿里云 NTP 服务器。 2. 发送 NTP 报文到阿里云 NTP 服务器。 3. 获取阿里云 NTP 服务器返回的数据，取第 40 位到 43 位的十六进制数值。 4. 把 40 位到 43 位的十六进制数值转成十进制。 5. 把十进制数值减去 1900 1970 的时间差（2208988800 秒）。 6. 数值转成年月日时分秒。 ```c /** *@brief 计算日期时间 *@param seconds UUTC 世界标准时间 *@retval 无 */ void lwip_calc_date_time(unsigned long long time) { unsigned int Pass4year; int hours_per_year; if (time < 0) { time 0; } g_nowdate.second (int)(time % 60); /* 取秒时间 */ time / 60; g_nowdate.minute (int)(time % 60); /* 取分钟时间 */ time / 60; g_nowdate.hour (int)(time % 24); /* 小时数 */ Pass4year ((unsigned int)time / (1461L * 24L));/*取过去多少个四年,每四年有 1461*24 小时 */ g_nowdate.year (Pass4year << 2) + 1970; /* 计算年份 */ time % 1461 * 24; /* 四年中剩下的小时数 */ for (;;) /* 校正闰年影响的年份，计算一年中剩下的小时数 */ { hours_per_year 365 * 24; /* 一年的小时数 */ if ((g_nowdate.year & 3) 0) /* 判断闰年 */ { hours_per_year + 24; /* 是闰年，一年则多24小时，即一天 */ } if (time < hours_per_year) { break; } g_nowdate.year++; time hours_per_year; } time / 24; /* 一年中剩下的天数 */ time++; /* 假定为闰年 */ if ((g_nowdate.year & 3) 0) /* 校正闰年的误差，计算月份，日期 */ { if (time > 60) { time ; } else { if (time 60) { g_nowdate.month 1; g_nowdate.day 29; return ; } } } for (g_nowdate.month 0; g_days[g_nowdate.month] < time; g_nowdate.month++) /* 计算月日 */ { time g_days[g_nowdate.month]; } g_nowdate.day (int)(time); return; } ``` ```c typedef struct _NPTformat { char version; /* 版本号 */ char leap; /* 时钟同步 */ char mode; /* 模式 */ char stratum; /* 系统时钟的层数 */ char poll; /* 更新间隔 */ signed char precision; /* 精密度 */ unsigned int rootdelay; /* 本地到主参考时钟源的往返时间 */ unsigned int rootdisp; /* 统时钟相对于主参考时钟的最大误差 */ char refid; /* 参考识别码 */ unsigned long long reftime;/* 参考时间 */ unsigned long long org; /* 开始的时间戳 */ unsigned long long rec; /* 收到的时间戳 */ unsigned long long xmt; /* 传输时间戳 */ } NPTformat; ``` ```c /** *@brief 初始化请求报文 *@param 无 *@retval 无 */ void lwip_ntp_client_init(void) { uint8_t flag; g_ntpformat.leap 0; /* leap indicator */ g_ntpformat.version 3; /* version number */ g_ntpformat.mode 3; /* mode */ g_ntpformat.stratum 0; /* stratum */ g_ntpformat.poll 0; /* poll interval */ g_ntpformat.precision 0; /* precision */ g_ntpformat.rootdelay 0; /* root delay */ g_ntpformat.rootdisp 0; /* root dispersion */ g_ntpformat.refid 0; /* reference ID */ g_ntpformat.reftime 0; /* reference time */ g_ntpformat.org 0; /* origin timestamp */ g_ntpformat.rec 0; /* receive timestamp */ g_ntpformat.xmt 0; /* transmit timestamp */ flag (g_ntpformat.version << 3) + g_ntpformat.mode; /* one byte Flag */ memcpy(g_ntp_message, (void const *)(&flag), 1);//第一位是0x1b } ```"},"/note/嵌入式/第三方移植/文件系统/2024-1-9-01FATFS.html":{"title":"FATFS","content":" layout: post title: \"FATFS\" date: 2024 1 9 15:39:08 +0800 tags: HAL库 stm32 # FATFS ## 文件系统简介 没有文件系统的时候不同设备之间的文件拷贝会十分麻烦, 并且文件的访问会很麻烦 比较常用的文件系统有FAT12, FAT16, FAT32, exFAT, NTFS FAT32的兼容性比较好, 但是不支持4GB以上的文件 exFAT可以保存4GB以上的文件 NTFS基于安全性的文件系统, 是Windows使用的文件系统, 支持大文件和超大文件分区 FATFS支持FAT32和exFAT FAT: File Alloction Table文件分配表 ![image 20240109115212344](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091152455.png) ![image 20240109115446592](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091154757.png) ## FATFS文件系统简介 ![image 20240109115711606](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091157669.png) ### 层次架构 ![image 20240109115850756](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091158830.png) ![image 20240109120006766](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091200860.png) ![image 20240109121128970](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091211050.png) ### 配置项 [FatFs Configuration Options (elm chan.org)](http://elm chan.org/fsw/ff/doc/config.html) ![image 20240109121821918](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091218001.png) ### 底层函数 ![image 20240109122211855](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091222001.png) ![image 20240109122430562](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091224636.png) ![image 20240109122505968](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091225049.png) ![image 20240109122620485](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091226554.png) ![image 20240109122638261](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091226325.png) ![image 20240109122735914](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091227982.png) ![image 20240109122808517](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091228582.png) ![image 20240109124650340](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091246440.png) ## 源文件移植 ![image 20240109125449051](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091254141.png) ### 扩展代码(优化) ![image 20240109131646442](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091316524.png) + ff.c文件 把dir_sdi函数的static解除, 方便之后的图片操作 还有就是一些在使用OS的时候需要进行修改的代码 ### 优化 在使用长文件名的时候会使用到两个数组 ![image 20240109172910471](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091729509.png) ![image 20240109172915554](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091729672.png) > 主要就是会在两个数组中进行两种编码的转换, 可以把这两个数组放在NOR Flash里面, 之后从Flash里面读取, 主要就是在这个数组里面找到现在的字符对应的编码, 之后从他后面的位置获取到转换后的代码 ```c WCHAR ff_uni2oem ( /* Returns OEM code character, zero on error */ DWORD uni, /* UTF 16 encoded character to be converted */ WORD cp /* Code page for the conversion */ ) { WCHAR t[2]; WCHAR c; uint32_t i, li, hi; uint16_t n; uint32_t gbk2uni_offset 0; if (uni < 0x80) { c uni; /* ASCII,直接不用转换 */ } else { hi ftinfo.ugbksize / 2; /* 对半开 */ hi hi / 4 1; li 0; for (n 16; n; n ) /* 二分法查找 */ { i li + (hi li) / 2; norflash_read((uint8_t *)&t, ftinfo.ugbkaddr + i * 4 + gbk2uni_offset, 4); /* 读出4个字节 */ if (uni t[0]) break;//找到了 if (uni > t[0]) { li i;//进行位置的偏移 } else { hi i; } } c n ? t[1] : 0;//查看是不是找到了,是的话更新 } return c; } ``` ## CubeMX移植 [STM32CubeMX系列09——SDIO（SD卡读写、SD卡移植FATFS文件系统）_st cube sd卡 CSDN博客](https://blog.csdn.net/weixin_46253745/article/details/127865071)"},"/note/嵌入式/第三方移植/MySTMOS/2023-8-29-day16多任务.html":{"title":"day16多任务","content":" layout: post title: \"day16多任务\" date: 2023 8 29 15:39:08 +0800 tags: MyOS # 多任务 ## 任务的自动化管理 ```c struct TSS32 { \tint backlink, esp0, ss0, esp1, ss1, esp2, ss2, cr3; \tint eip, eflags, eax, ecx, edx, ebx, esp, ebp, esi, edi; \tint es, cs, ss, ds, fs, gs; \tint ldtr, iomap; }; struct TASK { \tint sel, flags; /* sel记录任务的GDT */ \tstruct TSS32 tss; }; struct TASKCTL { \tint running; /* 运行的个数 */ \tint now; /* 正在运行的 */ \tstruct TASK *tasks[MAX_TASKS]; \tstruct TASK tasks0[MAX_TASKS]; }; ``` ```c struct TASKCTL *taskctl; struct TIMER *task_timer; struct TASK *task_init(struct MEMMAN *memman) { \tint i; \tstruct TASK *task; \tstruct SEGMENT_DESCRIPTOR *gdt (struct SEGMENT_DESCRIPTOR *) ADR_GDT; \ttaskctl (struct TASKCTL *) memman_alloc_4k(memman, sizeof (struct TASKCTL)); \tfor (i 0; i < MAX_TASKS; i++) { \t\ttaskctl >tasks0[i].flags 0; \t\ttaskctl >tasks0[i].sel (TASK_GDT0 + i) * 8; \t\tset_segmdesc(gdt + TASK_GDT0 + i, 103, (int) &taskctl >tasks0[i].tss, AR_TSS32); \t} \ttask task_alloc(); \ttask >flags 2; /* 设置正在运行中 */ \ttaskctl >running 1; \ttaskctl >now 0; \ttaskctl >tasks[0] task; \tload_tr(task >sel); \ttask_timer timer_alloc(); \ttimer_settime(task_timer, 2); \treturn task; } ``` ```c struct TASK *task_alloc(void) { \tint i; \tstruct TASK *task; \tfor (i 0; i < MAX_TASKS; i++) { \t\tif (taskctl >tasks0[i].flags 0) { \t\t\ttask &taskctl >tasks0[i]; \t\t\ttask >flags 1; /* 使用中 */ \t\t\ttask >tss.eflags 0x00000202; /* IF 1; */ \t\t\ttask >tss.eax 0; /* 先设置为0 */ \t\t\ttask >tss.ecx 0; \t\t\ttask >tss.edx 0; \t\t\ttask >tss.ebx 0; \t\t\ttask >tss.ebp 0; \t\t\ttask >tss.esi 0; \t\t\ttask >tss.edi 0; \t\t\ttask >tss.es 0; \t\t\ttask >tss.ds 0; \t\t\ttask >tss.fs 0; \t\t\ttask >tss.gs 0; \t\t\ttask >tss.ldtr 0; \t\t\ttask >tss.iomap 0x40000000; \t\t\treturn task; \t\t} \t} \treturn 0; /* 所有的任务都在使用中 */ } ``` ```c void task_sleep(struct TASK *task) { \tint i; \tchar ts 0; \tif (task >flags 2) {\t\t/* 当前的任务在运行 */ \t\tif (task taskctl >tasks[taskctl >now]) { \t\t\tts 1; /* 设置标志位 */ \t\t} \t\t/* task的位置寻找 */ \t\tfor (i 0; i < taskctl >running; i++) { \t\t\tif (taskctl >tasks[i] task) { \t\t\t\t/* 找到了 */ \t\t\t\tbreak; \t\t\t} \t\t} \t\ttaskctl >running ; \t\tif (i < taskctl >now) { \t\t\ttaskctl >now ; /* 睡眠的任务在运行的任务之前 */ \t\t} \t\t/* 重新排列 */ \t\tfor (; i < taskctl >running; i++) { \t\t\ttaskctl >tasks[i] taskctl >tasks[i + 1]; \t\t} \t\ttask >flags 1; /*设置状态 */ \t\tif (ts ! 0) { \t\t\t/* 当前的任务在运行 */ \t\t\tif (taskctl >now > taskctl >running) { \t\t\t\t/* now错误修正 */ \t\t\t\ttaskctl >now 0; \t\t\t} //更换任务 \t\t\tfarjmp(0, taskctl >tasks[taskctl >now] >sel); \t\t} \t} \treturn; } ``` ```c void task_switch(void) { \ttimer_settime(task_timer, 2); \tif (taskctl >running > 2) { \t\ttaskctl >now++; \t\tif (taskctl >now taskctl >running) { \t\t\ttaskctl >now 0; \t\t} \t\tfarjmp(0, taskctl >tasks[taskctl >now] >sel); \t} \treturn; } ``` ## 添加任务进入睡眠的信号 ```c struct FIFO32 { \tint *buf; \tint p, q, size, free, flags; \tstruct TASK *task; }; ``` ```c int fifo32_put(struct FIFO32 *fifo, int data) /* FIFO */ { \tif (fifo >free 0) { \t\t/* 没有空间溢出 */ \t\tfifo >flags FLAGS_OVERRUN; \t\treturn 1; \t} \tfifo >buf[fifo >p] data; \tfifo >p++; \tif (fifo >p fifo >size) { \t\tfifo >p 0; \t} \tfifo >free ; \tif (fifo >task ! 0) { //存在fifo相关的任务 \t\tif (fifo >task >flags ! 2) { /* 任务没有在执行 */ \t\t\ttask_run(fifo >task); /* 让任务进行运行 */ \t\t} \t} \treturn 0; } ``` > 在写入的时候如果FIFO的任务没有在运行, 就将任务唤醒 ## 实现多个任务 ```c \tunsigned char *buf_back, buf_mouse[256], *buf_win, *buf_win_b; \tstruct SHEET *sht_back, *sht_mouse, *sht_win, *sht_win_b[3];//在这里初始化多个窗口图层 \tstruct TASK *task_a, *task_b[3];\t//初始化多个任务 \tstruct TIMER *timer; ``` ```c \tinit_palette();\t//初始化画板 \tshtctl shtctl_init(memman, binfo >vram, binfo >scrnx, binfo >scrny);\t//初始化屏幕控制结构体 \ttask_a task_init(memman);\t\t// 初始化任务a \tfifo.task task_a;\t\t\t\t//将FIFO和任务挂载 \t/* sht_back */ \tsht_back sheet_alloc(shtctl);\t\t//申请一个图层控制块 \tbuf_back (unsigned char *) memman_alloc_4k(memman, binfo >scrnx * binfo >scrny);//获取桌面图层信息数组 \tsheet_setbuf(sht_back, buf_back, binfo >scrnx, binfo >scrny, 1); /* 透明色为没有,初始化桌面图层 */ \tinit_screen8(buf_back, binfo >scrnx, binfo >scrny);\t//桌面结构体初始化 \t/* sht_win_b初始化三个窗口的结构体 */ \tfor (i 0; i < 3; i++) { \t\tsht_win_b[i] sheet_alloc(shtctl); \t\tbuf_win_b (unsigned char *) memman_alloc_4k(memman, 144 * 52); \t\tsheet_setbuf(sht_win_b[i], buf_win_b, 144, 52, 1); /* 透明色なし */ \t\tsprintf(s, \"task_b%d\", i); \t\tmake_window8(buf_win_b, 144, 52, s, 0); \t\ttask_b[i] task_alloc(); \t\ttask_b[i] >tss.esp memman_alloc_4k(memman, 64 * 1024) + 64 * 1024 8; \t\ttask_b[i] >tss.eip (int) &task_b_main;//在这里设置的是所有任务使用的是同一个任务函数 \t\ttask_b[i] >tss.es 1 * 8; \t\ttask_b[i] >tss.cs 2 * 8; \t\ttask_b[i] >tss.ss 1 * 8; \t\ttask_b[i] >tss.ds 1 * 8; \t\ttask_b[i] >tss.fs 1 * 8; \t\ttask_b[i] >tss.gs 1 * 8; \t\t*((int *) (task_b[i] >tss.esp + 4)) (int) sht_win_b[i]; \t\ttask_run(task_b[i]);\t//任务开始运行 \t} \t/* sht_win */ \tsht_win sheet_alloc(shtctl); \tbuf_win (unsigned char *) memman_alloc_4k(memman, 160 * 52); \tsheet_setbuf(sht_win, buf_win, 144, 52, 1); /* 没有透明色的窗口数组初始化 */ \tmake_window8(buf_win, 144, 52, \"task_a\", 1); \tmake_textbox8(sht_win, 8, 28, 128, 16, COL8_FFFFFF); \tcursor_x 8; \tcursor_c COL8_FFFFFF; \ttimer timer_alloc(); \ttimer_init(timer, &fifo, 1); \ttimer_settime(timer, 50); \t/* sht_mouse */ \tsht_mouse sheet_alloc(shtctl); \tsheet_setbuf(sht_mouse, buf_mouse, 16, 16, 99); \tinit_mouse_cursor8(buf_mouse, 99); \tmx (binfo >scrnx 16) / 2; /* 画面中央 */ \tmy (binfo >scrny 28 16) / 2; \tsheet_slide(sht_back, 0, 0); \tsheet_slide(sht_win_b[0], 168, 56); \tsheet_slide(sht_win_b[1], 8, 116); \tsheet_slide(sht_win_b[2], 168, 116); \tsheet_slide(sht_win, 8, 56); \tsheet_slide(sht_mouse, mx, my); \tsheet_updown(sht_back, 0); \tsheet_updown(sht_win_b[0], 1); \tsheet_updown(sht_win_b[1], 2); \tsheet_updown(sht_win_b[2], 3); \tsheet_updown(sht_win, 4); \tsheet_updown(sht_mouse, 5); \tsprintf(s, \"(%3d, %3d)\", mx, my); \tputfonts8_asc_sht(sht_back, 0, 0, COL8_FFFFFF, COL8_008484, s, 10); \tsprintf(s, \"memory %dMB free : %dKB\", \t\t\tmemtotal / (1024 * 1024), memman_total(memman) / 1024); \tputfonts8_asc_sht(sht_back, 0, 32, COL8_FFFFFF, COL8_008484, s, 40); ``` ```c void make_window8(unsigned char *buf, int xsize, int ysize, char *title, char act) { \tstatic char closebtn[14][16] { \t\t\"OOOOOOOOOOOOOOO@\", \t\t\"OQQQQQQQQQQQQQ$@\", \t\t\"OQQQQQQQQQQQQQ$@\", \t\t\"OQQQ@@QQQQ@@QQ$@\", \t\t\"OQQQQ@@QQ@@QQQ$@\", \t\t\"OQQQQQ@@@@QQQQ$@\", \t\t\"OQQQQQQ@@QQQQQ$@\", \t\t\"OQQQQQ@@@@QQQQ$@\", \t\t\"OQQQQ@@QQ@@QQQ$@\", \t\t\"OQQQ@@QQQQ@@QQ$@\", \t\t\"OQQQQQQQQQQQQQ$@\", \t\t\"OQQQQQQQQQQQQQ$@\", \t\t\"O$$$$$$$$$$$$$$@\", \t\t\"@@@@@@@@@@@@@@@@\" \t}; \tint x, y; \tchar c, tc, tbc; \tif (act ! 0) { \t\ttc COL8_FFFFFF; \t\ttbc COL8_000084; \t} else { \t\ttc COL8_C6C6C6; \t\ttbc COL8_848484; \t} \tboxfill8(buf, xsize, COL8_C6C6C6, 0, 0, xsize 1, 0 ); \tboxfill8(buf, xsize, COL8_FFFFFF, 1, 1, xsize 2, 1 ); \tboxfill8(buf, xsize, COL8_C6C6C6, 0, 0, 0, ysize 1); \tboxfill8(buf, xsize, COL8_FFFFFF, 1, 1, 1, ysize 2); \tboxfill8(buf, xsize, COL8_848484, xsize 2, 1, xsize 2, ysize 2); \tboxfill8(buf, xsize, COL8_000000, xsize 1, 0, xsize 1, ysize 1); \tboxfill8(buf, xsize, COL8_C6C6C6, 2, 2, xsize 3, ysize 3); \tboxfill8(buf, xsize, tbc, 3, 3, xsize 4, 20 ); \tboxfill8(buf, xsize, COL8_848484, 1, ysize 2, xsize 2, ysize 2); \tboxfill8(buf, xsize, COL8_000000, 0, ysize 1, xsize 1, ysize 1); \tputfonts8_asc(buf, xsize, 24, 4, tc, title); \tfor (y 0; y < 14; y++) { \t\tfor (x 0; x < 16; x++) { \t\t\tc closebtn[y][x]; \t\t\tif (c '@') { \t\t\t\tc COL8_000000; \t\t\t} else if (c '$') { \t\t\t\tc COL8_848484; \t\t\t} else if (c 'Q') { \t\t\t\tc COL8_C6C6C6; \t\t\t} else { \t\t\t\tc COL8_FFFFFF; \t\t\t} \t\t\tbuf[(5 + y) * xsize + (xsize 21 + x)] c; \t\t} \t} \treturn; } ``` > 绘制两种状态的窗口, 一种是活跃状态, 一种是后台状态 ```c //实际的任务 void task_b_main(struct SHEET *sht_win_b) { //设置一个单独的FIFO, 不会相互干扰 \tstruct FIFO32 fifo; \tstruct TIMER *timer_1s; \tint i, fifobuf[128], count 0, count0 0; \tchar s[12]; \tfifo32_init(&fifo, 128, fifobuf, 0); \ttimer_1s timer_alloc(); \ttimer_init(timer_1s, &fifo, 100); \ttimer_settime(timer_1s, 100); \tfor (;;) { \t\tcount++; \t\tio_cli(); \t\tif (fifo32_status(&fifo) 0) { \t\t\tio_sti(); \t\t} else { \t\t\ti fifo32_get(&fifo); \t\t\tio_sti(); \t\t\tif (i 100) { \t\t\t\tsprintf(s, \"%11d\", count count0); \t\t\t\tputfonts8_asc_sht(sht_win_b, 24, 28, COL8_000000, COL8_C6C6C6, s, 11); \t\t\t\tcount0 count; \t\t\t\ttimer_settime(timer_1s, 100); \t\t\t} \t\t} \t} } ``` ## 进行多优先级的设置 ```c struct TASK { \tint sel, flags; /* sel是GDT的编号 */ \tint priority;\t//设置任务的优先级 \tstruct TSS32 tss; }; ``` ```c struct TASK *task_init(struct MEMMAN *memman) { \tint i; \tstruct TASK *task; \tstruct SEGMENT_DESCRIPTOR *gdt (struct SEGMENT_DESCRIPTOR *) ADR_GDT; \ttaskctl (struct TASKCTL *) memman_alloc_4k(memman, sizeof (struct TASKCTL)); \tfor (i 0; i < MAX_TASKS; i++) { \t\ttaskctl >tasks0[i].flags 0; \t\ttaskctl >tasks0[i].sel (TASK_GDT0 + i) * 8; \t\tset_segmdesc(gdt + TASK_GDT0 + i, 103, (int) &taskctl >tasks0[i].tss, AR_TSS32); \t} \ttask task_alloc(); \ttask >flags 2; /* 活动中的标志 */ \ttask >priority 2; /* 0.02秒设置优先级 */ \ttaskctl >running 1; \ttaskctl >now 0; \ttaskctl >tasks[0] task; \tload_tr(task >sel); \ttask_timer timer_alloc(); \ttimer_settime(task_timer, task >priority); \treturn task; } ``` ## 任务优先级2 有一些任务需要高响应优先级, 比如说鼠标键盘和网络, 在设置的时候如果只是提高运行的时间当有两个同等优先级的任务的时候还是会出现问题 + 解决方法 创建多个优先级组, 高优先级有一个任务的时候就会忽略其他优先级的任务, 只在最高优先级里面进行切换 ```c struct TASK { \tint sel, flags; \tint level, priority; \tstruct TSS32 tss; }; struct TASKLEVEL { \tint running; /* 正在运行的任务的数量数量 */ \tint now; /* 记录当前正在运行的任务 */ \tstruct TASK *tasks[MAX_TASKS_LV]; }; struct TASKCTL { \tint now_lv; /* 现在活动中的LEVEL */ \tchar lv_change; /* 下次切换的时候是否需要切换LEVEL */ \tstruct TASKLEVEL level[MAX_TASKLEVELS]; \tstruct TASK tasks0[MAX_TASKS]; }; ``` ```c //获取现在正在运行的任务的指针 struct TASK *task_now(void) { \tstruct TASKLEVEL *tl &taskctl >level[taskctl >now_lv]; \treturn tl >tasks[tl >now]; } //添加一个任务到任务控制块的运行中的等级里面 void task_add(struct TASK *task) { \tstruct TASKLEVEL *tl &taskctl >level[task >level]; \ttl >tasks[tl >running] task; \ttl >running++; \ttask >flags 2; /* 動作中 */ \treturn; } //移除一个任务从运行中的任务组里面 void task_remove(struct TASK *task) { \tint i; \tstruct TASKLEVEL *tl &taskctl >level[task >level]; \t/* 寻找任务的位置 */ \tfor (i 0; i < tl >running; i++) { //遍历任务的优先度等级 \t\tif (tl >tasks[i] task) { \t\t\t/* 找到任务,如果任务是在正在运行的等级里面 */ \t\t\tbreak; \t\t} \t} \t//当前的人物等级下面的任务数量减一 \ttl >running ; \tif (i < tl >now) { \t\ttl >now ; /* 正在运行的任务减少一个 */ \t} \tif (tl >now > tl >running) { \t\t/* 当亲运行的任务调整 */ \t\ttl >now 0; \t} \ttask >flags 1; /* 设置这个任务的标志位 */ \t/* 调整其他任务的位置 */ \tfor (; i < tl >running; i++) { \t\ttl >tasks[i] tl >tasks[i + 1]; \t} \treturn; } //这一个会遍历所有的任务等级, 之后找到最高等级的存在正在运行任务的优先级,并对控制块进行调整 void task_switchsub(void) { \tint i; \t/* 遍历所有的任务等级 */ \tfor (i 0; i < MAX_TASKLEVELS; i++) { \t\tif (taskctl >level[i].running > 0) { \t\t\tbreak; /* 找到存在任务的等级 */ \t\t} \t} \ttaskctl >now_lv i; \ttaskctl >lv_change 0; \treturn; } //初始化任务控制块 struct TASK *task_init(struct MEMMAN *memman) { \tint i; \tstruct TASK *task; \tstruct SEGMENT_DESCRIPTOR *gdt (struct SEGMENT_DESCRIPTOR *) ADR_GDT; \ttaskctl (struct TASKCTL *) memman_alloc_4k(memman, sizeof (struct TASKCTL)); \tfor (i 0; i < MAX_TASKS; i++) { \t\ttaskctl >tasks0[i].flags 0; \t\ttaskctl >tasks0[i].sel (TASK_GDT0 + i) * 8; \t\tset_segmdesc(gdt + TASK_GDT0 + i, 103, (int) &taskctl >tasks0[i].tss, AR_TSS32); \t} \tfor (i 0; i < MAX_TASKLEVELS; i++) { \t\ttaskctl >level[i].running 0; \t\ttaskctl >level[i].now 0; \t} \ttask task_alloc(); \ttask >flags 2;\t/* 初始化一个初始的任务 */ \ttask >priority 2; /* 设置默认的任务的时间 */ \ttask >level 0;\t/* 设置为最高优先级 */ \ttask_add(task); \ttask_switchsub();\t/* 遍历一遍所有的等级,更新优先运行的任务等级 */ \tload_tr(task >sel); \ttask_timer timer_alloc(); \ttimer_settime(task_timer, task >priority); \treturn task; } //申请一个任务 struct TASK *task_alloc(void) { \tint i; \tstruct TASK *task; \tfor (i 0; i < MAX_TASKS; i++) { //遍历所有任务获取其中一个没有使用的任务 \t\tif (taskctl >tasks0[i].flags 0) { \t\t\ttask &taskctl >tasks0[i]; \t\t\ttask >flags 1; /* 使用中 */ \t\t\ttask >tss.eflags 0x00000202; /* IF 1; */ \t\t\ttask >tss.eax 0; /* */ \t\t\ttask >tss.ecx 0; \t\t\ttask >tss.edx 0; \t\t\ttask >tss.ebx 0; \t\t\ttask >tss.ebp 0; \t\t\ttask >tss.esi 0; \t\t\ttask >tss.edi 0; \t\t\ttask >tss.es 0; \t\t\ttask >tss.ds 0; \t\t\ttask >tss.fs 0; \t\t\ttask >tss.gs 0; \t\t\ttask >tss.ldtr 0; \t\t\ttask >tss.iomap 0x40000000; \t\t\treturn task; \t\t} \t} \treturn 0; /* 所有任务都在使用 */ } //让一个任务运行起来 void task_run(struct TASK *task, int level, int priority) { \tif (level < 0) { \t\tlevel task >level; /* 改变任务的运行等级 */ \t} \tif (priority > 0) { \t\ttask >priority priority; \t} \tif (task >flags 2 && task >level ! level) { /* 之前就在运行中 */ \t\ttask_remove(task); /* 首先将任务进行移除 */ \t} \tif (task >flags ! 2) { \t\t/* 任务没有运行 */ \t\ttask >level level; \t\ttask_add(task); \t} \ttaskctl >lv_change 1; /* 有任务加入运行或者更换运行的等级 */ \treturn; } void task_sleep(struct TASK *task) { \tstruct TASK *now_task; \tif (task >flags 2) { \t\t/* 获取当前的任务 */ \t\tnow_task task_now(); \t\ttask_remove(task); /* 把这一个任务设置为睡眠 */ \t\tif (task now_task) { \t\t\t/* 睡眠的任务就是当前运行的任务 */ \t\t\ttask_switchsub();\t\t//重新设置当前的任务优先级 \t\t\tnow_task task_now(); /* 获取新的当前的任务 */ \t\t\tfarjmp(0, now_task >sel);\t//进行切换 \t\t} \t} \treturn; } void task_switch(void) { \tstruct TASKLEVEL *tl &taskctl >level[taskctl >now_lv]; \tstruct TASK *new_task, *now_task tl >tasks[tl >now]; \ttl >now++; \tif (tl >now tl >running) { \t\ttl >now 0; \t} \tif (taskctl >lv_change ! 0) { \t\ttask_switchsub(); \t\ttl &taskctl >level[taskctl >now_lv]; \t} \tnew_task tl >tasks[tl >now]; \ttimer_settime(task_timer, new_task >priority); \tif (new_task ! now_task) { \t\tfarjmp(0, new_task >sel); \t} \treturn; } ```"},"/note/嵌入式/第三方移植/MySTMOS/2023-7-21-day3进入32位系统以及C语言.html":{"title":"day3进入32位系统以及C语言","content":" layout: post title: \"day3进入32位系统以及C语言\" date: 2023 7 21 15:39:08 +0800 tags: MyOS # day3进入32位系统以及C语言 ```assembly ; haribote ipl ; TAB 4 \t\tORG\t\t0x7c00\t\t\t; 程序的地址 ; \t\tJMP\t\tentry \t\tDB\t\t0x90 \t\tDB\t\t\"HARIBOTE\"\t\t \t\tDW\t\t512\t\t\t\t \t\tDB\t\t1\t\t\t\t \t\tDW\t\t1\t\t\t\t \t\tDB\t\t2\t\t\t\t \t\tDW\t\t224\t\t\t\t \t\tDW\t\t2880\t\t \t\tDB\t\t0xf0\t\t \t\tDW\t\t9\t\t \t\tDW\t\t18\t\t\t \t\tDW\t\t2\t\t\t \t\tDD\t\t0\t\t\t \t\tDD\t\t2880\t\t \t\tDB\t\t0,0,0x29\t \t\tDD\t\t0xffffffff\t \t\tDB\t\t\"HARIBOTEOS \"\t \t\tDB\t\t\"FAT12 \"\t \t\tRESB\t18\t\t\t ; entry: \t\tMOV\t\tAX,0\t\t\t; 初始化寄存器 \t\tMOV\t\tSS,AX \t\tMOV\t\tSP,0x7c00 \t\tMOV\t\tDS,AX\t\t\t;设置段地址 ; \t\tMOV\t\tAX,0x0820\t\t \t\tMOV\t\tES,AX\t\t\t;设置读取后的位置 \t\tMOV\t\tCH,0\t\t\t; 设置柱面 \t\tMOV\t\tDH,0\t\t\t; 设置柱头 \t\tMOV\t\tCL,2\t\t\t; 设置扇面 \t\tMOV\t\tAH,0x02\t\t\t; AH 0x02 : 读盘 \t\tMOV\t\tAL,1\t\t\t; 1个扇区 \t\tMOV\t\tBX,0\t\t\t;设置读取文件存放的位置 \t\tMOV\t\tDL,0x00\t\t\t; A驱动器 \t\tINT\t\t0x13\t\t\t; 调用BIOS \t\tJC\t\terror\t\t\t; 如果进位标志为1, 就进行跳转 ; 这里是成功之后的死循环 fin: \t\tHLT\t\t\t\t\t\t \t\tJMP\t\tfin\t\t\t ; 打印错误信息 error: \t\tMOV\t\tSI,msg putloop: \t\tMOV\t\tAL,[SI] \t\tADD\t\tSI,1\t\t \t\tCMP\t\tAL,0 \t\tJE\t\tfin \t\tMOV\t\tAH,0x0e\t\t\t \t\tMOV\t\tBX,15\t\t \t\tINT\t\t0x10\t\t\t \t\tJMP\t\tputloop msg: \t\tDB\t\t0x0a, 0x0a\t \t\tDB\t\t\"load error\" \t\tDB\t\t0x0a\t\t \t\tDB\t\t0 \t\tRESB\t0x7dfe $\t\t \t\tDB\t\t0x55, 0xaa ``` > INT0x13: AH 0x02读盘, AH 0x03写盘, AH 0x04校验, AH 0x0c巡道, AL 处理的扇区数, CH 柱面号, DH 磁头号, DL 驱动器号, ES:BX 缓冲地址, 校验以及寻道的时候不需要, 返回值FLACS:CF 0, 没有错误AH 0, FLAGCS:CF 1, 有错误, 存入AH > 设置的是软盘的读取, 一个软盘有80个柱面, 2个磁头, 18个扇区 > BX设置的是读取的文件存放的位置, 只有16位, 使用的时候可以使用`MOV AL,[ES:BX]`, 实际上是ES*16+BX, 达到1M的大小 > 这里设置ES 0x8020, 原因是0x8000~0x81ff的位置是启动区的, 之后的内存是随意使用的 > > 0x7c00到0x7dff的位置是启动区, 之后0x7e00到0x9fbff没有规定 > 在使用的时候, 需要注意段寄存器,DS, 在不表示的情况下一般可以省略, MOV CX,[SI]实际上是MOV AL,[DS:SI] ## 改进一次 ```assembly ; 初始化寄存器 entry: \t\tMOV\t\tAX,0\t\t\t; レジスタ初期化 \t\tMOV\t\tSS,AX \t\tMOV\t\tSP,0x7c00 \t\tMOV\t\tDS,AX ; 读磁盘 \t\tMOV\t\tAX,0x0820 \t\tMOV\t\tES,AX \t\tMOV\t\tCH,0\t\t\t; 柱面0 \t\tMOV\t\tDH,0\t\t\t; 磁头0 \t\tMOV\t\tCL,2\t\t\t; 扇区0 \t\tMOV\t\tSI,0\t\t\t; 记录失败的次数 retry: \t\tMOV\t\tAH,0x02\t\t\t \t\tMOV\t\tAL,1\t\t\t \t\tMOV\t\tBX,0 \t\tMOV\t\tDL,0x00\t\t\t \t\tINT\t\t0x13\t\t\t \t\tJNC\t\tfin\t\t\t\t \t\tADD\t\tSI,1\t\t\t; SI加一 \t\tCMP\t\tSI,5\t\t\t; SI比较 \t\tJAE\t\terror\t\t\t; SI > 5 出错 \t\tMOV\t\tAH,0x00 \t\tMOV\t\tDL,0x00\t\t\t; \t\tINT\t\t0x13\t\t\t; 设置系统复位 \t\tJMP\t\tretry ``` ## 读取到18 ```assembly ; 读磁盘 \t\tMOV\t\tAX,0x0820 \t\tMOV\t\tES,AX \t\tMOV\t\tCH,0\t\t\t \t\tMOV\t\tDH,0\t\t\t \t\tMOV\t\tCL,2\t\t\t readloop: \t\tMOV\t\tSI,0\t\t\t retry: \t\tMOV\t\tAH,0x02\t\t\t; AH 0x02 : 读取 \t\tMOV\t\tAL,1\t\t\t; 一个扇区 \t\tMOV\t\tBX,0 \t\tMOV\t\tDL,0x00\t\t\t; A驱动器 \t\tINT\t\t0x13\t\t\t; 调用BIOS \t\tJNC\t\tnext\t\t\t; 出错跳到next \t\tADD\t\tSI,1\t\t\t; SIに1を足す \t\tCMP\t\tSI,5\t\t\t; SIと5を比較 \t\tJAE\t\terror\t\t\t; SI > 5 だったらerrorへ \t\tMOV\t\tAH,0x00 \t\tMOV\t\tDL,0x00\t\t\t; Aドライブ \t\tINT\t\t0x13\t\t\t; ドライブのリセット \t\tJMP\t\tretry next: \t\tMOV\t\tAX,ES\t\t\t; 内存地址后移 \t\tADD\t\tAX,0x0020\t\t; 相当于加上0x200 \t\tMOV\t\tES,AX\t\t\t; 写入ES \t\tADD\t\tCL,1\t\t\t; CL加1 \t\tCMP\t\tCL,18\t\t\t; CL与18比较 \t\tJBE\t\treadloop\t\t; CL < 18 继续读取 ``` + 增加读取到反面 ```assembly CYLS\tEQU\t\t10\t\t\t\t; 相当于define ..... ; \t\tMOV\t\tAX,0x0820 \t\tMOV\t\tES,AX \t\tMOV\t\tCH,0\t\t\t; シリンダ0 \t\tMOV\t\tDH,0\t\t\t; ヘッド0 \t\tMOV\t\tCL,2\t\t\t; セクタ2 readloop: \t\tMOV\t\tSI,0\t\t\t; 失敗回数を数えるレジスタ retry: \t\tMOV\t\tAH,0x02\t\t\t \t\tMOV\t\tAL,1\t\t\t \t\tMOV\t\tBX,0 \t\tMOV\t\tDL,0x00\t\t\t \t\tINT\t\t0x13\t\t\t \t\tJNC\t\tnext\t\t\t \t\tADD\t\tSI,1\t\t\t \t\tCMP\t\tSI,5\t\t \t\tJAE\t\terror\t\t \t\tMOV\t\tAH,0x00 \t\tMOV\t\tDL,0x00\t\t \t\tINT\t\t0x13\t\t\t; ドライブのリセット \t\tJMP\t\tretry next: \t\tMOV\t\tAX,ES\t\t\t \t\tADD\t\tAX,0x0020 \t\tMOV\t\tES,AX\t\t\t \t\tADD\t\tCL,1\t\t\t \t\tCMP\t\tCL,18\t\t\t \t\tJBE\t\treadloop\t\t \t\tMOV\t\tCL,1\t\t\t; 归零 \t\tADD\t\tDH,1\t\t\t; 更换柱头, 加一, 第二次加一之后会进入后面的程序 \t\tCMP\t\tDH,2\t\t\t;进行比较 \t\tJB\t\treadloop\t\t; DH<2 \t\tMOV\t\tDH,0\t\t\t; 设置柱头归零 \t\tADD\t\tCH,1\t\t\t; 设置柱面加一 \t\tCMP\t\tCH,CYLS \t\tJB\t\treadloop\t\t; CH < CYLS だったらreadloopへ ``` > C0 H0 S18到C0 H1 S1再到C9 H1 S18 > 最初的180KB存入内存 + 添加其他文件 ```assembly fin: \t\tHLT \t\tJMP\t\tfin ``` ```makefile TOOLPATH ../z_tools/ MAKE $(TOOLPATH)make.exe r NASK $(TOOLPATH)nask.exe EDIMG $(TOOLPATH)edimg.exe IMGTOL $(TOOLPATH)imgtol.com COPY copy DEL del # デフォルト動作 default : \t$(MAKE) img # ファイル生成規則 ipl.bin : ipl.nas Makefile \t$(NASK) ipl.nas ipl.bin ipl.lst haribote.sys : haribote.nas Makefile \t$(NASK) haribote.nas haribote.sys haribote.lst haribote.img : ipl.bin haribote.sys Makefile \t$(EDIMG) imgin:../z_tools/fdimg0at.tek \\ \t\twbinimg src:ipl.bin len:512 from:0 to:0 \\ \t\tcopy from:haribote.sys to:@: \\ \t\timgout:haribote.img # コマンド img : \t$(MAKE) haribote.img run : \t$(MAKE) img \t$(COPY) haribote.img ..\\z_tools\\qemu\\fdimage0.bin \t$(MAKE) C ../z_tools/qemu install : \t$(MAKE) img \t$(IMGTOL) w a: haribote.img clean : \t $(DEL) ipl.bin \t $(DEL) ipl.lst \t $(DEL) haribote.sys \t $(DEL) haribote.lst src_only : \t$(MAKE) clean \t $(DEL) haribote.img ``` ![image 20230721124543952](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242301917.png) ![image 20230721124523348](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242301918.png) > 软盘上在0x002600设置的是文件名的位置, 0x004200的位置是文件的内容 > 程序的调用: 软盘的程序被复制到0x8000之后, 程序在0xc200 > > ```assembly > ; haribote os > ; TAB 4 > > \t\tORG\t\t0xc200\t\t\t; 偙偺僾儘僌儔儉偑偳偙偵撉傒崬傑傟傞偺偐 > > \t\tMOV\t\tAL,0x13\t\t\t; VGA僌儔僼傿僢僋僗丄320x200x8bit僇儔乕 > \t\tMOV\t\tAH,0x00 > \t\tINT\t\t0x10 > fin: > \t\tHLT > \t\tJMP\t\tfin > > ``` > > > 这里可以设置显示的模式, AH 0x00, AL 模式, 0x30: 16色模式, 0x12VGA图形模式640x480x4, 0x12VGA图形模式320x200x8, 调色板模式, 0x6a扩展VGA模式800x600x4 ```assembly \t\tMOV\t\t[0x0ff0],CH\t\t; 记录读取的扇区数 \t\tJMP\t\t0xc200\t\t\t; 跳转到程序 ``` ## 进入32位 16位的机器码在32位时候不能使用, 32位可以使用的内存变大, 而且可以使用CPU的自我保护模式但是不能使用BIOS ```assembly ; haribote os ; TAB 4 ; BOOT_INFO娭學 CYLS\tEQU\t\t0x0ff0\t\t\t; 设定启动区 LEDS\tEQU\t\t0x0ff1 VMODE\tEQU\t\t0x0ff2\t\t\t; 设定颜色的数目 SCRNX\tEQU\t\t0x0ff4\t\t\t; 分辨率x SCRNY\tEQU\t\t0x0ff6\t\t\t; Y VRAM\tEQU\t\t0x0ff8\t\t\t; 图像缓冲区的位置 \t\tORG\t\t0xc200\t\t\t; 程序的保存地址 \t\tMOV\t\tAL,0x13\t\t\t; 设置显卡 \t\tMOV\t\tAH,0x00 \t\tINT\t\t0x10 \t\tMOV\t\tBYTE [VMODE],8\t; 记录画面模式 \t\tMOV\t\tWORD [SCRNX],320 \t\tMOV\t\tWORD [SCRNY],200 \t\tMOV\t\tDWORD [VRAM],0x000a0000 ; 使用BIOS获取键盘上的各种LED的状态 \t\tMOV\t\tAH,0x02 \t\tINT\t\t0x16 \t\t\t; keyboard BIOS \t\tMOV\t\t[LEDS],AL\t\t; 保存状态 fin: \t\tHLT \t\tJMP\t\tfin ``` > 不同模式下的VRAM的位置不同 ## 正式进入C语言 ```assembly ; haribote os boot asm ; TAB 4 BOTPAK\tEQU\t\t0x00280000\t\t; 设置地址 DSKCAC\tEQU\t\t0x00100000\t\t; DSKCAC0\tEQU\t\t0x00008000\t\t; ; BOOT_INFO记录 CYLS\tEQU\t\t0x0ff0\t\t\t LEDS\tEQU\t\t0x0ff1 VMODE\tEQU\t\t0x0ff2\t\t\t SCRNX\tEQU\t\t0x0ff4\t\t\t SCRNY\tEQU\t\t0x0ff6\t\t\t VRAM\tEQU\t\t0x0ff8\t\t\t \t\tORG\t\t0xc200\t\t\t ; 设置显示 \t\tMOV\t\tAL,0x13\t\t\t; VGA僌儔僼傿僢僋僗丄320x200x8bit僇儔乕 \t\tMOV\t\tAH,0x00 \t\tINT\t\t0x10 \t\tMOV\t\tBYTE [VMODE],8\t; 夋柺儌乕僪傪儊儌偡傞乮C尵岅偑嶲徠偡傞乯 \t\tMOV\t\tWORD [SCRNX],320 \t\tMOV\t\tWORD [SCRNY],200 \t\tMOV\t\tDWORD [VRAM],0x000a0000 ; 读取键盘 \t\tMOV\t\tAH,0x02 \t\tINT\t\t0x16 \t\t\t; keyboard BIOS \t\tMOV\t\t[LEDS],AL \t\tMOV\t\tAL,0xff \t\tOUT\t\t0x21,AL \t\tNOP\t\t\t\t\t\t; \t\tOUT\t\t0xa1,AL \t\tCLI\t\t\t\t\t\t; ; \t\tCALL\twaitkbdout \t\tMOV\t\tAL,0xd1 \t\tOUT\t\t0x64,AL \t\tCALL\twaitkbdout \t\tMOV\t\tAL,0xdf\t\t\t; enable A20 \t\tOUT\t\t0x60,AL \t\tCALL\twaitkbdout ; [INSTRSET \"i486p\"]\t\t\t\t; 486 \t\tLGDT\t[GDTR0]\t\t\t; \t\tMOV\t\tEAX,CR0 \t\tAND\t\tEAX,0x7fffffff\t; \t\tOR\t\tEAX,0x00000001\t; \t\tMOV\t\tCR0,EAX \t\tJMP\t\tpipelineflush pipelineflush: \t\tMOV\t\tAX,1*8\t\t\t; \t\tMOV\t\tDS,AX \t\tMOV\t\tES,AX \t\tMOV\t\tFS,AX \t\tMOV\t\tGS,AX \t\tMOV\t\tSS,AX ; bootpack偺揮憲 \t\tMOV\t\tESI,bootpack\t; \t\tMOV\t\tEDI,BOTPAK\t\t; \t\tMOV\t\tECX,512*1024/4 \t\tCALL\tmemcpy ; ; \t\tMOV\t\tESI,0x7c00\t\t; \t\tMOV\t\tEDI,DSKCAC\t\t; \t\tMOV\t\tECX,512/4 \t\tCALL\tmemcpy ; \t\tMOV\t\tESI,DSKCAC0+512\t; \t\tMOV\t\tEDI,DSKCAC+512\t; \t\tMOV\t\tECX,0 \t\tMOV\t\tCL,BYTE [CYLS] \t\tIMUL\tECX,512*18*2/4\t; \t\tSUB\t\tECX,512/4\t\t; \t\tCALL\tmemcpy ; ;\t ; \t\tMOV\t\tEBX,BOTPAK \t\tMOV\t\tECX,[EBX+16] \t\tADD\t\tECX,3\t\t\t; \t\tSHR\t\tECX,2\t\t\t; \t\tJZ\t\tskip\t\t\t; \t\tMOV\t\tESI,[EBX+20]\t; \t\tADD\t\tESI,EBX \t\tMOV\t\tEDI,[EBX+12]\t; \t\tCALL\tmemcpy skip: \t\tMOV\t\tESP,[EBX+12]\t; \t\tJMP\t\tDWORD 2*8:0x0000001b waitkbdout: \t\tIN\t\t AL,0x64 \t\tAND\t\t AL,0x02 \t\tJNZ\t\twaitkbdout\t\t; \t\tRET memcpy: \t\tMOV\t\tEAX,[ESI] \t\tADD\t\tESI,4 \t\tMOV\t\t[EDI],EAX \t\tADD\t\tEDI,4 \t\tSUB\t\tECX,1 \t\tJNZ\t\tmemcpy\t\t\t; \t\tRET ; \t\tALIGNB\t16 GDT0: \t\tRESB\t8\t\t\t\t; \t\tDW\t\t0xffff,0x0000,0x9200,0x00cf\t; \t\tDW\t\t0xffff,0x0000,0x9a28,0x0047\t; \t\tDW\t\t0 GDTR0: \t\tDW\t\t8*3 1 \t\tDD\t\tGDT0 \t\tALIGNB\t16 bootpack: ``` ```c void HariMain(void) { fin: \t/* C语言不能使用HLT, 这里是一个循环 */ \tgoto fin; } ``` > 编译 > > 1. cc1.exe从bootpack.c生成bootpack.gas, 使用C编译器, 转换为汇编 > 2. gas2nask.exe从bootpack.gas生成bootpack.nas, 机器语言 > 3. nask.exe从bootpack.nas生成bootpack.obj, 目标文件, 是一种特殊的机器语言文件, 需要链接使用 > 4. 使用obj2bim.exe从bootpack.obj生成bootpack.bim, 二进制镜像文件, 需要针对不同的操作系统加上头文件以及压缩等 > 5. 使用bim2hrb.exe从bootpack.bim生成bootpack.hrb为机器语言 > 6. 最后使用copy把bootpack.hrb和bootpack.hrb文件粘贴起来, 生成haribote.sys ```makefile TOOLPATH ../z_tools/ INCPATH ../z_tools/haribote/ MAKE $(TOOLPATH)make.exe r NASK $(TOOLPATH)nask.exe CC1 $(TOOLPATH)cc1.exe I$(INCPATH) Os Wall quiet GAS2NASK $(TOOLPATH)gas2nask.exe a OBJ2BIM $(TOOLPATH)obj2bim.exe BIM2HRB $(TOOLPATH)bim2hrb.exe RULEFILE $(TOOLPATH)haribote/haribote.rul EDIMG $(TOOLPATH)edimg.exe IMGTOL $(TOOLPATH)imgtol.com COPY copy DEL del # default : \t$(MAKE) img # 生成文件 ipl10.bin : ipl10.nas Makefile \t$(NASK) ipl10.nas ipl10.bin ipl10.lst asmhead.bin : asmhead.nas Makefile \t$(NASK) asmhead.nas asmhead.bin asmhead.lst bootpack.gas : bootpack.c Makefile \t$(CC1) o bootpack.gas bootpack.c bootpack.nas : bootpack.gas Makefile \t$(GAS2NASK) bootpack.gas bootpack.nas bootpack.obj : bootpack.nas Makefile \t$(NASK) bootpack.nas bootpack.obj bootpack.lst naskfunc.obj : naskfunc.nas Makefile \t$(NASK) naskfunc.nas naskfunc.obj naskfunc.lst bootpack.bim : bootpack.obj naskfunc.obj Makefile \t$(OBJ2BIM) @$(RULEFILE) out:bootpack.bim stack:3136k map:bootpack.map \\ \t\tbootpack.obj naskfunc.obj # 3MB+64KB 3136KB bootpack.hrb : bootpack.bim Makefile \t$(BIM2HRB) bootpack.bim bootpack.hrb 0 haribote.sys : asmhead.bin bootpack.hrb Makefile \tcopy /B asmhead.bin+bootpack.hrb haribote.sys haribote.img : ipl10.bin haribote.sys Makefile \t$(EDIMG) imgin:../z_tools/fdimg0at.tek \\ \t\twbinimg src:ipl10.bin len:512 from:0 to:0 \\ \t\tcopy from:haribote.sys to:@: \\ \t\timgout:haribote.img # コマンド img : \t$(MAKE) haribote.img run : \t$(MAKE) img \t$(COPY) haribote.img ..\\z_tools\\qemu\\fdimage0.bin \t$(MAKE) C ../z_tools/qemu install : \t$(MAKE) img \t$(IMGTOL) w a: haribote.img clean : \t $(DEL) *.bin \t $(DEL) *.lst \t $(DEL) *.gas \t $(DEL) *.obj \t $(DEL) bootpack.nas \t $(DEL) bootpack.map \t $(DEL) bootpack.bim \t $(DEL) bootpack.hrb \t $(DEL) haribote.sys src_only : \t$(MAKE) clean \t $(DEL) haribote.img ``` ## 实现HLT ```assembly ; naskfunc ; TAB 4 [FORMAT \"WCOFF\"]\t\t\t\t; 文件格式 [BITS 32]\t\t\t\t\t\t; 32位操作系 ; 制作目标文件的名字 [FILE \"naskfunc.nas\"]\t\t\t; 此文件名 \t\tGLOBAL\t_io_hlt\t\t\t; 函数名 ; [SECTION .text]\t\t; 目?文件中写入?些再?行 _io_hlt:\t; void io_hlt(void); \t\tHLT \t\tRET\t\t; 相当于return ``` ## JiaoOS + 移植OLED + 触摸屏 + LED + 串口 出现问题, 没有定义 + 使用__inline在C99模式下前面加static + 文件没有添加 ```c #include \"stm32f10x.h\" #include \"bsp_led.h\" #include \"bsp_usart.h\" #include \"bsp_ili9341_lcd.h\" #include \"bsp_xpt2046_lcd.h\" void Hareware_Init(void); int main() { \tint i; \tHareware_Init(); \twhile(1){ \tXPT2046_TouchEvenHandler(); \t\t \t\tfor(i 0;i<10000;i++); \t\t \t} \t } void Hareware_Init(void) { \t//初始化串口 \tUSART_Config(); \tLED_GPIO_Config(); \tprintf(\"你好\\n\"); \t//初始化屏幕 \tILI9341_Init(); \tprintf(\"初始化屏幕\\n\"); \tILI9341_Clear(0, 0, ILI9341_LESS_PIXEL, ILI9341_MORE_PIXEL); \t \t//从FLASH里获取校正参数，若FLASH无参数，则使用模式3进行校正 \tCalibrate_or_Get_TouchParaWithFlash(3,0); \tXPT2046_Init(); \tprintf(\"初始化触摸屏\\n\"); } ```"},"/note/嵌入式/第三方移植/MySTMOS/2023-7-19-day1.html":{"title":"Day1","content":" layout: post title: \"Day1\" date: 2023 7 19 15:39:08 +0800 tags: MyOS # Day1 ```assembly ; hello os ; TAB 4 ; 以下是Fat12格式的软盘专用代码 \t\tDB\t\t0xeb, 0x4e, 0x90\t;DB: define byte写入一个字节的指令 \t\tDB\t\t\"HELLOIPL\"\t\t; 启动区的名字,任意的字符, 8字节 \t\tDW\t\t512\t\t\t\t; 一个扇区的大小 \t\tDB\t\t1\t\t\t\t; 一个簇的大小 \t\tDW\t\t1\t\t\t\t; FAT的起始位置 \t\tDB\t\t2\t\t\t\t; FAT的个数 \t\tDW\t\t224\t\t\t\t; 根目录的大小,一般为224 \t\tDW\t\t2880\t\t\t; 磁盘大小 \t\tDB\t\t0xf0\t\t\t; 磁盘的种类 \t\tDW\t\t9\t\t\t\t; FAT的长度 \t\tDW\t\t18\t\t\t\t; 一个磁轨的扇区数 \t\tDW\t\t2\t\t\t\t; 磁头数 \t\tDD\t\t0\t\t\t\t; 不用进行分盘 \t\tDD\t\t2880\t\t\t; 重写一次的磁盘大小 \t\tDB\t\t0,0,0x29\t\t; 意义不明, 固定 \t\tDD\t\t0xffffffff\t\t; \t\tDB\t\t\"HELLO OS \"\t; 磁盘的名字11字节 \t\tDB\t\t\"FAT12 \"\t\t; 磁盘格式的名字 \t\tRESB\t18\t\t\t\t; 空出18字节, reserve byte: 空出字节 ; 程序主体 \t\tDB\t\t0xb8, 0x00, 0x00, 0x8e, 0xd0, 0xbc, 0x00, 0x7c \t\tDB\t\t0x8e, 0xd8, 0x8e, 0xc0, 0xbe, 0x74, 0x7c, 0x8a \t\tDB\t\t0x04, 0x83, 0xc6, 0x01, 0x3c, 0x00, 0x74, 0x09 \t\tDB\t\t0xb4, 0x0e, 0xbb, 0x0f, 0x00, 0xcd, 0x10, 0xeb \t\tDB\t\t0xee, 0xf4, 0xeb, 0xfd ; 显示的内容 \t\tDB\t\t0x0a, 0x0a\t\t; \\n\\n \t\tDB\t\t\"hello, world\" \t\tDB\t\t0x0a\t\t\t; \\n \t\tDB\t\t0 \t\tRESB\t0x1fe $\t\t\t; 写入0x00直到0x1fe, $代表自己本身的位置地址 \t\tDB\t\t0x55, 0xaa\t\t;固定的结尾 ; 启动区以外的输出 \t\tDB\t\t0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00 \t\tRESB\t4600 \t\tDB\t\t0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00 \t\tRESB\t1469432 ``` > FAT12: 软盘格式 > > 启动区: 软盘的第一个区 > > IPL: inital program loader启动程序加载器"},"/note/嵌入式/第三方移植/MySTMOS/2023-7-20-day2汇编指令以及Makefile.html":{"title":"Day2汇编指令以及Makefile","content":" layout: post title: \"Day2汇编指令以及Makefile\" date: 2023 7 20 15:39:08 +0800 tags: MyOS # Day2汇编指令以及Makefile ```c ; hello os ; TAB 4 \t\tORG\t\t0x7c00\t\t\t; 记录程序加载的地方 ; 用于标准的Fat12格式 \t\tJMP\t\tentry \t\tDB\t\t0x90 \t\tDB\t\t\"HELLOIPL\"\t \t\tDW\t\t512\t\t\t\t \t\tDB\t\t1\t\t\t\t \t\tDW\t\t1\t\t\t \t\tDB\t\t2\t\t\t \t\tDW\t\t224\t\t\t\t \t\tDW\t\t2880\t\t\t \t\tDB\t\t0xf0\t\t\t \t\tDW\t\t9\t\t\t\t \t\tDW\t\t18\t\t\t \t\tDW\t\t2\t\t\t\t \t\tDD\t\t0\t\t\t\t \t\tDD\t\t2880\t\t\t \t\tDB\t\t0,0,0x29\t\t \t\tDD\t\t0xffffffff\t \t\tDB\t\t\"HELLO OS \"\t \t\tDB\t\t\"FAT12 \"\t\t \t\tRESB\t18\t\t\t\t ; 核心程序 entry: \t\tMOV\t\tAX,0\t\t\t; 初始化寄存器 \t\tMOV\t\tSS,AX \t\tMOV\t\tSP,0x7c00 \t\tMOV\t\tDS,AX \t\tMOV\t\tES,AX \t\tMOV\t\tSI,msg putloop: \t\tMOV\t\tAL,[SI]\t\t\t;获取一个字符 \t\tADD\t\tSI,1\t\t\t; SI加一 \t\tCMP\t\tAL,0 \t\tJE\t\tfin \t\tMOV\t\tAH,0x0e\t\t\t; 显示一个文字 \t\tMOV\t\tBX,15\t\t\t; 指定文字的颜色 \t\tINT\t\t0x10\t\t\t; 使用BIOS的中断函数 \t\tJMP\t\tputloop fin: \t\tHLT\t\t\t\t\t\t; CPU停止, 等待 \t\tJMP\t\tfin\t\t\t\t; 循环 msg: \t\tDB\t\t0x0a, 0x0a\t\t; 实际的打印内容 \t\tDB\t\t\"hello, world\" \t\tDB\t\t0x0a\t\t\t \t\tDB\t\t0 \t\tRESB\t0x7dfe $\t\t \t\tDB\t\t0x55, 0xaa ; 启动区之外的输出 \t\tDB\t\t0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00 \t\tRESB\t4600 \t\tDB\t\t0xf0, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00 \t\tRESB\t1469432 ``` > ORG: 开始执行的时候把机器指令加载到的位置, 这里是0x7c00 + AX: 累加寄存器 + CX: 计数寄存器 + DX: 数据寄存器 + BX: 基址寄存器 + SP: 栈地址寄存器 + BP: 基地址寄存器 + SI: 源变址寄存器 + DI: 目的变址寄存器 > 以上的寄存器是16位的 + AL: 累加寄存器低位 + CL: 计数寄存器低位 + DL: 数据寄存器低位 + BL: 基地址寄存器低位 + AH: 高位 + CH + DH + BH AX的低8位是AL > 以上的是八位的 EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI > 这是32位的寄存器 只有BX, BP, SI, DI这几个寄存器的值可以使用[ x ]来进行取地址 + BOIS 储存在电脑的主板上面的ROM里面, INT16是用来控制显卡的 AH 0x0e, AL: character code, BH 0, BL color code, 返回值无 + 初始地址 最开始的内存是BIOS实现功能使用的, 在0xf000附近存在BIOS本体 ![image 20230720185103853](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242256921.png) 在0xfc00到0xfdff是启动区的位置 ## Makefile > 1. \"make r\"选项用于指示make命令在解析Makefile时不使用默认的规则和隐式规则。这个选项通常用于覆盖默认的行为，以便更精确地控制构建过程。 > 2. 当使用`make C`命令时，` C`选项用于指定要在其中执行`make`命令的目录。这对于在不同的目录中构建和管理代码非常有用。 ```makefile # 默认 default : \t../z_tools/make.exe img # 实际的生成规则 ipl.bin : ipl.nas Makefile \t../z_tools/nask.exe ipl.nas ipl.bin ipl.lst helloos.img : ipl.bin Makefile \t../z_tools/edimg.exe imgin:../z_tools/fdimg0at.tek \\ \t\twbinimg src:ipl.bin len:512 from:0 to:0 imgout:helloos.img # asm : \t../z_tools/make.exe r ipl.bin # 这个是之后启动虚拟机使用的文件 img : \t../z_tools/make.exe r helloos.img # 生成img文件之后启动 run : \t../z_tools/make.exe img \tcopy helloos.img ..\\z_tools\\qemu\\fdimage0.bin \t../z_tools/make.exe C ../z_tools/qemu # 这个是安装命令, 一般不需要 install : \t../z_tools/make.exe img \t../z_tools/imgtol.com w a: helloos.img clean : \t del ipl.bin \t del ipl.lst src_only : \t../z_tools/make.exe clean \t del helloos.img ``` ```c default : \tqemu win.bat ``` > run最后调用的 ```bat @set SDL_VIDEODRIVER windib @set QEMU_AUDIO_DRV none @set QEMU_AUDIO_LOG_TO_MONITOR 0 qemu.exe L . m 32 localtime std vga fda fdimage0.bin ```"},"/note/嵌入式/第三方移植/MySTMOS/2023-7-25-day6分割编译与中断处理.html":{"title":"day6分割编译与中断处理","content":" layout: post title: \"day6分割编译与中断处理\" date: 2023 7 25 15:39:08 +0800 tags: MyOS # day6分割编译与中断处理 ```bash ..\\z_tools\\make.exe %1 %2 %3 %4 %5 %6 %7 %8 %9 ``` > make.bat, 使用make命令的时候实际上实行的命令 ```c /* bootpackのメイン */ #include <stdio.h> void io_hlt(void); void io_cli(void); void io_out8(int port, int data); int io_load_eflags(void); void io_store_eflags(int eflags); void init_palette(void); void set_palette(int start, int end, unsigned char *rgb); void boxfill8(unsigned char *vram, int xsize, unsigned char c, int x0, int y0, int x1, int y1); void init_screen8(char *vram, int x, int y); void putfont8(char *vram, int xsize, int x, int y, char c, char *font); void putfonts8_asc(char *vram, int xsize, int x, int y, char c, unsigned char *s); void init_mouse_cursor8(char *mouse, char bc); void putblock8_8(char *vram, int vxsize, int pxsize, \tint pysize, int px0, int py0, char *buf, int bxsize); #define COL8_000000\t\t0 #define COL8_FF0000\t\t1 #define COL8_00FF00\t\t2 #define COL8_FFFF00\t\t3 #define COL8_0000FF\t\t4 #define COL8_FF00FF\t\t5 #define COL8_00FFFF\t\t6 #define COL8_FFFFFF\t\t7 #define COL8_C6C6C6\t\t8 #define COL8_840000\t\t9 #define COL8_008400\t\t10 #define COL8_848400\t\t11 #define COL8_000084\t\t12 #define COL8_840084\t\t13 #define COL8_008484\t\t14 #define COL8_848484\t\t15 //这里是自己保存的内容 struct BOOTINFO { \tchar cyls, leds, vmode, reserve; \tshort scrnx, scrny; \tchar *vram; }; //GDT struct SEGMENT_DESCRIPTOR { \tshort limit_low, base_low; \tchar base_mid, access_right; \tchar limit_high, base_high; }; //IDT struct GATE_DESCRIPTOR { \tshort offset_low, selector; \tchar dw_count, access_right; \tshort offset_high; }; //其他文件的函数 void init_gdtidt(void); void set_segmdesc(struct SEGMENT_DESCRIPTOR *sd, unsigned int limit, int base, int ar); void set_gatedesc(struct GATE_DESCRIPTOR *gd, int offset, int selector, int ar); void load_gdtr(int limit, int addr); void load_idtr(int limit, int addr); void HariMain(void) { \tstruct BOOTINFO *binfo (struct BOOTINFO *) 0x0ff0; \tchar s[40], mcursor[256]; \tint mx, my; \tinit_gdtidt(); \tinit_palette(); \tinit_screen8(binfo >vram, binfo >scrnx, binfo >scrny); \tmx (binfo >scrnx 16) / 2; /* 计算鼠标的位置 */ \tmy (binfo >scrny 28 16) / 2; \tinit_mouse_cursor8(mcursor, COL8_008484); \tputblock8_8(binfo >vram, binfo >scrnx, 16, 16, mx, my, mcursor, 16); \tsprintf(s, \"(%d, %d)\", mx, my); \tputfonts8_asc(binfo >vram, binfo >scrnx, 0, 0, COL8_FFFFFF, s); \tfor (;;) { \t\tio_hlt(); \t} } ``` > bootpack.c ```c /* 使用的结构体 */ struct SEGMENT_DESCRIPTOR { \tshort limit_low, base_low; \tchar base_mid, access_right; \tchar limit_high, base_high; }; struct GATE_DESCRIPTOR { \tshort offset_low, selector; \tchar dw_count, access_right; \tshort offset_high; }; void init_gdtidt(void); void set_segmdesc(struct SEGMENT_DESCRIPTOR *sd, unsigned int limit, int base, int ar); void set_gatedesc(struct GATE_DESCRIPTOR *gd, int offset, int selector, int ar); void load_gdtr(int limit, int addr); void load_idtr(int limit, int addr); //初始化 void init_gdtidt(void) { \tstruct SEGMENT_DESCRIPTOR *gdt (struct SEGMENT_DESCRIPTOR *) 0x00270000; \tstruct GATE_DESCRIPTOR *idt (struct GATE_DESCRIPTOR *) 0x0026f800; \tint i; \t/* GDT初始化 */ \tfor (i 0; i < 8192; i++) { \t\tset_segmdesc(gdt + i, 0, 0, 0); \t} \tset_segmdesc(gdt + 1, 0xffffffff, 0x00000000, 0x4092); \tset_segmdesc(gdt + 2, 0x0007ffff, 0x00280000, 0x409a); \tload_gdtr(0xffff, 0x00270000); \t/* IDT初始化 */ \tfor (i 0; i < 256; i++) { \t\tset_gatedesc(idt + i, 0, 0, 0); \t} \tload_idtr(0x7ff, 0x0026f800); \treturn; } void set_segmdesc(struct SEGMENT_DESCRIPTOR *sd, unsigned int limit, int base, int ar) { \tif (limit > 0xfffff) { \t\tar 0x8000; /* G_bit 1 */ \t\tlimit / 0x1000; \t} \tsd >limit_low limit & 0xffff; \tsd >base_low base & 0xffff; \tsd >base_mid (base >> 16) & 0xff; \tsd >access_right ar & 0xff; \tsd >limit_high ((limit >> 16) & 0x0f) ((ar >> 8) & 0xf0); \tsd >base_high (base >> 24) & 0xff; \treturn; } void set_gatedesc(struct GATE_DESCRIPTOR *gd, int offset, int selector, int ar) { \tgd >offset_low offset & 0xffff; \tgd >selector selector; \tgd >dw_count (ar >> 8) & 0xff; \tgd >access_right ar & 0xff; \tgd >offset_high (offset >> 16) & 0xffff; \treturn; } ``` > dsctbl.c ```c /* 图形处理 */ void io_hlt(void); void io_cli(void); void io_out8(int port, int data); int io_load_eflags(void); void io_store_eflags(int eflags); void init_palette(void); void set_palette(int start, int end, unsigned char *rgb); void boxfill8(unsigned char *vram, int xsize, unsigned char c, int x0, int y0, int x1, int y1); void init_screen8(char *vram, int x, int y); void putfont8(char *vram, int xsize, int x, int y, char c, char *font); void putfonts8_asc(char *vram, int xsize, int x, int y, char c, unsigned char *s); void init_mouse_cursor8(char *mouse, char bc); void putblock8_8(char *vram, int vxsize, int pxsize, \tint pysize, int px0, int py0, char *buf, int bxsize); #define COL8_000000\t\t0 #define COL8_FF0000\t\t1 #define COL8_00FF00\t\t2 #define COL8_FFFF00\t\t3 #define COL8_0000FF\t\t4 #define COL8_FF00FF\t\t5 #define COL8_00FFFF\t\t6 #define COL8_FFFFFF\t\t7 #define COL8_C6C6C6\t\t8 #define COL8_840000\t\t9 #define COL8_008400\t\t10 #define COL8_848400\t\t11 #define COL8_000084\t\t12 #define COL8_840084\t\t13 #define COL8_008484\t\t14 #define COL8_848484\t\t15 void init_palette(void) { \tstatic unsigned char table_rgb[16 * 3] { \t\t0x00, 0x00, 0x00,\t/* 0:黒 */ \t\t0xff, 0x00, 0x00,\t/* 1:明るい赤 */ \t\t0x00, 0xff, 0x00,\t/* 2:明るい緑 */ \t\t0xff, 0xff, 0x00,\t/* 3:明るい黄色 */ \t\t0x00, 0x00, 0xff,\t/* 4:明るい青 */ \t\t0xff, 0x00, 0xff,\t/* 5:明るい紫 */ \t\t0x00, 0xff, 0xff,\t/* 6:明るい水色 */ \t\t0xff, 0xff, 0xff,\t/* 7:白 */ \t\t0xc6, 0xc6, 0xc6,\t/* 8:明るい灰色 */ \t\t0x84, 0x00, 0x00,\t/* 9:暗い赤 */ \t\t0x00, 0x84, 0x00,\t/* 10:暗い緑 */ \t\t0x84, 0x84, 0x00,\t/* 11:暗い黄色 */ \t\t0x00, 0x00, 0x84,\t/* 12:暗い青 */ \t\t0x84, 0x00, 0x84,\t/* 13:暗い紫 */ \t\t0x00, 0x84, 0x84,\t/* 14:暗い水色 */ \t\t0x84, 0x84, 0x84\t/* 15:暗い灰色 */ \t}; \tset_palette(0, 15, table_rgb); \treturn; \t/* static char 命令は、データにしか使えないけどDB命令相当 */ } //设置调色盘 void set_palette(int start, int end, unsigned char *rgb) { \tint i, eflags; \teflags io_load_eflags();\t \tio_cli(); \t\t\t\t\t \tio_out8(0x03c8, start); \tfor (i start; i < end; i++) { \t\tio_out8(0x03c9, rgb[0] / 4); \t\tio_out8(0x03c9, rgb[1] / 4); \t\tio_out8(0x03c9, rgb[2] / 4); \t\trgb + 3; \t} \tio_store_eflags(eflags);\t \treturn; } void boxfill8(unsigned char *vram, int xsize, unsigned char c, int x0, int y0, int x1, int y1) { \tint x, y; \tfor (y y0; y < y1; y++) { \t\tfor (x x0; x < x1; x++) \t\t\tvram[y * xsize + x] c; \t} \treturn; } //绘制桌面 void init_screen8(char *vram, int x, int y) { \tboxfill8(vram, x, COL8_008484, 0, 0, x 1, y 29); \tboxfill8(vram, x, COL8_C6C6C6, 0, y 28, x 1, y 28); \tboxfill8(vram, x, COL8_FFFFFF, 0, y 27, x 1, y 27); \tboxfill8(vram, x, COL8_C6C6C6, 0, y 26, x 1, y 1); \tboxfill8(vram, x, COL8_FFFFFF, 3, y 24, 59, y 24); \tboxfill8(vram, x, COL8_FFFFFF, 2, y 24, 2, y 4); \tboxfill8(vram, x, COL8_848484, 3, y 4, 59, y 4); \tboxfill8(vram, x, COL8_848484, 59, y 23, 59, y 5); \tboxfill8(vram, x, COL8_000000, 2, y 3, 59, y 3); \tboxfill8(vram, x, COL8_000000, 60, y 24, 60, y 3); \tboxfill8(vram, x, COL8_848484, x 47, y 24, x 4, y 24); \tboxfill8(vram, x, COL8_848484, x 47, y 23, x 47, y 4); \tboxfill8(vram, x, COL8_FFFFFF, x 47, y 3, x 4, y 3); \tboxfill8(vram, x, COL8_FFFFFF, x 3, y 24, x 3, y 3); \treturn; } void putfont8(char *vram, int xsize, int x, int y, char c, char *font) { \tint i; \tchar *p, d /* data */; \tfor (i 0; i < 16; i++) { \t\tp vram + (y + i) * xsize + x; \t\td font[i]; \t\tif ((d & 0x80) ! 0) { p[0] c; } \t\tif ((d & 0x40) ! 0) { p[1] c; } \t\tif ((d & 0x20) ! 0) { p[2] c; } \t\tif ((d & 0x10) ! 0) { p[3] c; } \t\tif ((d & 0x08) ! 0) { p[4] c; } \t\tif ((d & 0x04) ! 0) { p[5] c; } \t\tif ((d & 0x02) ! 0) { p[6] c; } \t\tif ((d & 0x01) ! 0) { p[7] c; } \t} \treturn; } //这里是打印一个字 void putfonts8_asc(char *vram, int xsize, int x, int y, char c, unsigned char *s) { \textern char hankaku[4096]; \tfor (; *s ! 0x00; s++) { \t\tputfont8(vram, xsize, x, y, c, hankaku + *s * 16); \t\tx + 8; \t} \treturn; } void init_mouse_cursor8(char *mouse, char bc) /* 这是鼠标结构体初始化 */ { \tstatic char cursor[16][16] { \t\t\"**************..\", \t\t\"*OOOOOOOOOOO*...\", \t\t\"*OOOOOOOOOO*....\", \t\t\"*OOOOOOOOO*.....\", \t\t\"*OOOOOOOO*......\", \t\t\"*OOOOOOO*.......\", \t\t\"*OOOOOOO*.......\", \t\t\"*OOOOOOOO*......\", \t\t\"*OOOO**OOO*.....\", \t\t\"*OOO*..*OOO*....\", \t\t\"*OO*....*OOO*...\", \t\t\"*O*......*OOO*..\", \t\t\"**........*OOO*.\", \t\t\"*..........*OOO*\", \t\t\"............*OO*\", \t\t\".............***\" \t}; \tint x, y; \tfor (y 0; y < 16; y++) { \t\tfor (x 0; x < 16; x++) { \t\t\tif (cursor[y][x] '*') { \t\t\t\tmouse[y * 16 + x] COL8_000000; \t\t\t} \t\t\tif (cursor[y][x] 'O') { \t\t\t\tmouse[y * 16 + x] COL8_FFFFFF; \t\t\t} \t\t\tif (cursor[y][x] '.') { \t\t\t\tmouse[y * 16 + x] bc; \t\t\t} \t\t} \t} \treturn; } //绘制鼠标 void putblock8_8(char *vram, int vxsize, int pxsize, \tint pysize, int px0, int py0, char *buf, int bxsize) { \tint x, y; \tfor (y 0; y < pysize; y++) { \t\tfor (x 0; x < pxsize; x++) { \t\t\tvram[(py0 + y) * vxsize + (px0 + x)] buf[y * bxsize + x]; \t\t} \t} \treturn; } ``` > graphic.c ```makefile TOOLPATH ../z_tools/ INCPATH ../z_tools/haribote/ MAKE $(TOOLPATH)make.exe r NASK $(TOOLPATH)nask.exe CC1 $(TOOLPATH)cc1.exe I$(INCPATH) Os Wall quiet GAS2NASK $(TOOLPATH)gas2nask.exe a OBJ2BIM $(TOOLPATH)obj2bim.exe MAKEFONT $(TOOLPATH)makefont.exe BIN2OBJ $(TOOLPATH)bin2obj.exe BIM2HRB $(TOOLPATH)bim2hrb.exe RULEFILE $(TOOLPATH)haribote/haribote.rul EDIMG $(TOOLPATH)edimg.exe IMGTOL $(TOOLPATH)imgtol.com COPY copy DEL del # 默认 default : \t$(MAKE) img # 生成规则 # 汇编文件 ipl10.bin : ipl10.nas Makefile \t$(NASK) ipl10.nas ipl10.bin ipl10.lst asmhead.bin : asmhead.nas Makefile \t$(NASK) asmhead.nas asmhead.bin asmhead.lst # 这里是c文件 bootpack.gas : bootpack.c Makefile \t$(CC1) o bootpack.gas bootpack.c bootpack.nas : bootpack.gas Makefile \t$(GAS2NASK) bootpack.gas bootpack.nas bootpack.obj : bootpack.nas Makefile \t$(NASK) bootpack.nas bootpack.obj bootpack.lst # 另一个汇编 naskfunc.obj : naskfunc.nas Makefile \t$(NASK) naskfunc.nas naskfunc.obj naskfunc.lst # 字库文件 hankaku.bin : hankaku.txt Makefile \t$(MAKEFONT) hankaku.txt hankaku.bin hankaku.obj : hankaku.bin Makefile \t$(BIN2OBJ) hankaku.bin hankaku.obj _hankaku # 绘图c文件 graphic.gas : graphic.c Makefile \t$(CC1) o graphic.gas graphic.c graphic.nas : graphic.gas Makefile \t$(GAS2NASK) graphic.gas graphic.nas graphic.obj : graphic.nas Makefile \t$(NASK) graphic.nas graphic.obj graphic.lst dsctbl.gas : dsctbl.c Makefile \t$(CC1) o dsctbl.gas dsctbl.c dsctbl.nas : dsctbl.gas Makefile \t$(GAS2NASK) dsctbl.gas dsctbl.nas dsctbl.obj : dsctbl.nas Makefile \t$(NASK) dsctbl.nas dsctbl.obj dsctbl.lst # 链接 bootpack.bim : bootpack.obj naskfunc.obj hankaku.obj graphic.obj dsctbl.obj Makefile \t$(OBJ2BIM) @$(RULEFILE) out:bootpack.bim stack:3136k map:bootpack.map \\ \t\tbootpack.obj naskfunc.obj hankaku.obj graphic.obj dsctbl.obj # 3MB+64KB 3136KB bootpack.hrb : bootpack.bim Makefile \t$(BIM2HRB) bootpack.bim bootpack.hrb 0 haribote.sys : asmhead.bin bootpack.hrb Makefile \tcopy /B asmhead.bin+bootpack.hrb haribote.sys haribote.img : ipl10.bin haribote.sys Makefile \t$(EDIMG) imgin:../z_tools/fdimg0at.tek \\ \t\twbinimg src:ipl10.bin len:512 from:0 to:0 \\ \t\tcopy from:haribote.sys to:@: \\ \t\timgout:haribote.img # 命令 img : \t$(MAKE) haribote.img run : \t$(MAKE) img \t$(COPY) haribote.img ..\\z_tools\\qemu\\fdimage0.bin \t$(MAKE) C ../z_tools/qemu install : \t$(MAKE) img \t$(IMGTOL) w a: haribote.img clean : \t $(DEL) *.bin \t $(DEL) *.lst \t $(DEL) *.gas \t $(DEL) *.obj \t $(DEL) bootpack.nas \t $(DEL) graphic.nas \t $(DEL) dsctbl.nas \t $(DEL) bootpack.map \t $(DEL) bootpack.bim \t $(DEL) bootpack.hrb \t $(DEL) haribote.sys src_only : \t$(MAKE) clean \t $(DEL) haribote.img ``` ## Makefile简化 ```makefile # 所需要的所有文件 OBJS_BOOTPACK bootpack.obj naskfunc.obj hankaku.obj graphic.obj dsctbl.obj TOOLPATH ../z_tools/ INCPATH ../z_tools/haribote/ MAKE $(TOOLPATH)make.exe r NASK $(TOOLPATH)nask.exe CC1 $(TOOLPATH)cc1.exe I$(INCPATH) Os Wall quiet GAS2NASK $(TOOLPATH)gas2nask.exe a OBJ2BIM $(TOOLPATH)obj2bim.exe MAKEFONT $(TOOLPATH)makefont.exe BIN2OBJ $(TOOLPATH)bin2obj.exe BIM2HRB $(TOOLPATH)bim2hrb.exe RULEFILE $(TOOLPATH)haribote/haribote.rul EDIMG $(TOOLPATH)edimg.exe IMGTOL $(TOOLPATH)imgtol.com COPY copy DEL del # デフォルト動作 default : \t$(MAKE) img # ファイル生成規則 # 启动文件 ipl10.bin : ipl10.nas Makefile \t$(NASK) ipl10.nas ipl10.bin ipl10.lst asmhead.bin : asmhead.nas Makefile \t$(NASK) asmhead.nas asmhead.bin asmhead.lst # 生成字摸文件 hankaku.bin : hankaku.txt Makefile \t$(MAKEFONT) hankaku.txt hankaku.bin hankaku.obj : hankaku.bin Makefile \t$(BIN2OBJ) hankaku.bin hankaku.obj _hankaku bootpack.bim : $(OBJS_BOOTPACK) Makefile \t$(OBJ2BIM) @$(RULEFILE) out:bootpack.bim stack:3136k map:bootpack.map \\ \t\t$(OBJS_BOOTPACK) # 3MB+64KB 3136KB bootpack.hrb : bootpack.bim Makefile \t$(BIM2HRB) bootpack.bim bootpack.hrb 0 haribote.sys : asmhead.bin bootpack.hrb Makefile \tcopy /B asmhead.bin+bootpack.hrb haribote.sys haribote.img : ipl10.bin haribote.sys Makefile \t$(EDIMG) imgin:../z_tools/fdimg0at.tek \\ \t\twbinimg src:ipl10.bin len:512 from:0 to:0 \\ \t\tcopy from:haribote.sys to:@: \\ \t\timgout:haribote.img # 一般規則 %.gas : %.c Makefile \t$(CC1) o $*.gas $*.c %.nas : %.gas Makefile \t$(GAS2NASK) $*.gas $*.nas %.obj : %.nas Makefile \t$(NASK) $*.nas $*.obj $*.lst # 实际命令 img : \t$(MAKE) haribote.img run : \t$(MAKE) img \t$(COPY) haribote.img ..\\z_tools\\qemu\\fdimage0.bin \t$(MAKE) C ../z_tools/qemu install : \t$(MAKE) img \t$(IMGTOL) w a: haribote.img clean : \t $(DEL) *.bin \t $(DEL) *.lst \t $(DEL) *.obj \t $(DEL) bootpack.map \t $(DEL) bootpack.bim \t $(DEL) bootpack.hrb \t $(DEL) haribote.sys src_only : \t$(MAKE) clean \t $(DEL) haribote.img ``` + 把重复的声明放在一个头文件中 ```c /* asmhead.nas */ struct BOOTINFO { /* 0x0ff0 0x0fff */ \tchar cyls; /* 启动区的硬盘读取到何处 */ \tchar leds; /* 键盘指示灯的状态 */ \tchar vmode; /* 显卡的模式 */ \tchar reserve; \tshort scrnx, scrny; /* 画面分辨率 */ \tchar *vram; }; #define ADR_BOOTINFO\t0x00000ff0 /* naskfunc.nas */ void io_hlt(void); void io_cli(void); void io_out8(int port, int data); int io_load_eflags(void); void io_store_eflags(int eflags); void load_gdtr(int limit, int addr); void load_idtr(int limit, int addr); /* graphic.c 画面相关的函数*/ void init_palette(void); void set_palette(int start, int end, unsigned char *rgb); void boxfill8(unsigned char *vram, int xsize, unsigned char c, int x0, int y0, int x1, int y1); void init_screen8(char *vram, int x, int y); void putfont8(char *vram, int xsize, int x, int y, char c, char *font); void putfonts8_asc(char *vram, int xsize, int x, int y, char c, unsigned char *s); void init_mouse_cursor8(char *mouse, char bc); void putblock8_8(char *vram, int vxsize, int pxsize, \tint pysize, int px0, int py0, char *buf, int bxsize); #define COL8_000000\t\t0 #define COL8_FF0000\t\t1 #define COL8_00FF00\t\t2 #define COL8_FFFF00\t\t3 #define COL8_0000FF\t\t4 #define COL8_FF00FF\t\t5 #define COL8_00FFFF\t\t6 #define COL8_FFFFFF\t\t7 #define COL8_C6C6C6\t\t8 #define COL8_840000\t\t9 #define COL8_008400\t\t10 #define COL8_848400\t\t11 #define COL8_000084\t\t12 #define COL8_840084\t\t13 #define COL8_008484\t\t14 #define COL8_848484\t\t15 /* dsctbl.c */ struct SEGMENT_DESCRIPTOR { \tshort limit_low, base_low; \tchar base_mid, access_right; \tchar limit_high, base_high; }; struct GATE_DESCRIPTOR { \tshort offset_low, selector; \tchar dw_count, access_right; \tshort offset_high; }; void init_gdtidt(void); void set_segmdesc(struct SEGMENT_DESCRIPTOR *sd, unsigned int limit, int base, int ar); void set_gatedesc(struct GATE_DESCRIPTOR *gd, int offset, int selector, int ar); #define ADR_IDT\t\t\t0x0026f800\t\t//IDT #define LIMIT_IDT\t\t0x000007ff #define ADR_GDT\t\t\t0x00270000\t\t//GDT #define LIMIT_GDT\t\t0x0000ffff #define ADR_BOTPAK\t\t0x00280000\t\t//bootpack文件起始位置 #define LIMIT_BOTPAK\t0x0007ffff \t\t//??文件大小 #define AR_DATA32_RW\t0x4092 #define AR_CODE32_ER\t0x409a ``` > 放在文件bootpack.h文件里面 ## 中断处理器PIC PIC(programmable interrupt controller), 可编程中断控制器 CPU只能处理一个中断, PIC将八个中断汇集成一个中断, 每一个管脚是一个IRQ, IRQ2连接从PIC 主PIC处理0 7, 从PIC处理8 15 ```c /* 割り込み関係 */ #include \"bootpack.h\" #define PIC0_ICW1\t\t0x0020 #define PIC0_OCW2\t\t0x0020 #define PIC0_IMR\t\t0x0021 #define PIC0_ICW2\t\t0x0021 #define PIC0_ICW3\t\t0x0021 #define PIC0_ICW4\t\t0x0021 #define PIC1_ICW1\t\t0x00a0 #define PIC1_OCW2\t\t0x00a0 #define PIC1_IMR\t\t0x00a1 #define PIC1_ICW2\t\t0x00a1 #define PIC1_ICW3\t\t0x00a1 #define PIC1_ICW4\t\t0x00a1 void init_pic(void) /* PICの初期化 */ { //外部的设备使用out命令进行操作 \tio_out8(PIC0_IMR, 0xff ); /* 禁止所有的中断 */ \tio_out8(PIC1_IMR, 0xff ); /* 禁止所有的中断 */ \tio_out8(PIC0_ICW1, 0x11 ); /* 边沿触发模式 */ \tio_out8(PIC0_ICW2, 0x20 ); /* IRQ0 7由INT20 27接受 */ \tio_out8(PIC0_ICW3, 1 << 2); /* PIC1由IRQ2连接 */ \tio_out8(PIC0_ICW4, 0x01 ); /* 无缓冲区模式 */ \tio_out8(PIC1_ICW1, 0x11 ); /* 边沿触发 */ \tio_out8(PIC1_ICW2, 0x28 ); /* IRQ8 15由INT28 2f接收 */ \tio_out8(PIC1_ICW3, 2 ); /* PIC由IRQ2连接 */ \tio_out8(PIC1_ICW4, 0x01 ); /* 无缓冲区模式 */ \tio_out8(PIC0_IMR, 0xfb ); /* 11111011 PIC1以外全部禁止 */ \tio_out8(PIC1_IMR, 0xff ); /* 11111111 禁止所有中断 */ \treturn; } ``` > PIC寄存器都是8位寄存器 > > IMR(interrupt mask register)是中断屏蔽寄存器, 对应8路的信号 > > ICW(interrupt control word)初始化控制数据 > > ICW1, ICW4表示的是PIC的主板配线, 中断信号, 电气特性, 不能更改 > > ICW3设置的是主从连接的方式, 硬件控制 > > ICW2, 决定了通知CPU的中断 + 如果CPU可以处理某一个中断, 会命令PIC发送两个字节, 发送过来的数字是0xcd 0x??, 0xcd实际上就是调用BOIS的时候使用的INT指令, CPU会当做指令直接执行 + INT指令的前几个已经被使用了, 所以不能使用 鼠标的中断是IRQ12, 键盘的中断是IQ1 ```c void inthandler21(int *esp) /* 键盘的中断 */ { \tstruct BOOTINFO *binfo (struct BOOTINFO *) ADR_BOOTINFO; \tboxfill8(binfo >vram, binfo >scrnx, COL8_000000, 0, 0, 32 * 8 1, 15); \tputfonts8_asc(binfo >vram, binfo >scrnx, 0, 0, COL8_FFFFFF, \"INT 21 (IRQ 1) : PS/2 keyboard\"); \tfor (;;) { \t\tio_hlt(); \t} } void inthandler2c(int *esp) /* PS/2マウスからの割り込み */ { \tstruct BOOTINFO *binfo (struct BOOTINFO *) ADR_BOOTINFO; \tboxfill8(binfo >vram, binfo >scrnx, COL8_000000, 0, 0, 32 * 8 1, 15); \tputfonts8_asc(binfo >vram, binfo >scrnx, 0, 0, COL8_FFFFFF, \"INT 2C (IRQ 12) : PS/2 mouse\"); \tfor (;;) { \t\tio_hlt(); \t} } void inthandler27(int *esp) /*有的机器在初始化PIC的时候会产生这个中断*/ { \tio_out8(PIC0_OCW2, 0x67); /* 通知PIC已经知道发生中断了 */ \treturn; } ``` > 中断处理之后需要执行IRETD指令 ```assembly _asm_inthandler21: \t\tPUSH\tES \t\tPUSH\tDS \t\tPUSHAD \t\tMOV\t\tEAX,ESP \t\tPUSH\tEAX \t\tMOV\t\tAX,SS \t\tMOV\t\tDS,AX \t\tMOV\t\tES,AX \t\tCALL\t_inthandler21 \t\tPOP\t\tEAX \t\tPOPAD \t\tPOP\t\tDS \t\tPOP\t\tES \t\tIRETD _asm_inthandler27: \t\tPUSH\tES \t\tPUSH\tDS \t\tPUSHAD \t\tMOV\t\tEAX,ESP \t\tPUSH\tEAX \t\tMOV\t\tAX,SS \t\tMOV\t\tDS,AX \t\tMOV\t\tES,AX \t\tCALL\t_inthandler27 \t\tPOP\t\tEAX \t\tPOPAD \t\tPOP\t\tDS \t\tPOP\t\tES \t\tIRETD _asm_inthandler2c: \t\tPUSH\tES \t\tPUSH\tDS \t\tPUSHAD \t\tMOV\t\tEAX,ESP \t\tPUSH\tEAX \t\tMOV\t\tAX,SS \t\tMOV\t\tDS,AX \t\tMOV\t\tES,AX \t\tCALL\t_inthandler2c \t\tPOP\t\tEAX \t\tPOPAD \t\tPOP\t\tDS \t\tPOP\t\tES \t\tIRETD ``` > PUSHAD相当于保存当前CPU的寄存器EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI > 这里就是把寄存器保存起来, 之后调整DS,ES,SS的数值相等, 设置段寄存器以及堆栈寄存器的数值相等, 这里是C语言的要求 + 之后进行函数的注册 ```c #define AR_INTGATE32\t0x008e \t \t/* IDT的设置 */ \tset_gatedesc(idt + 0x21, (int) asm_inthandler21, 2 * 8, AR_INTGATE32); \tset_gatedesc(idt + 0x27, (int) asm_inthandler27, 2 * 8, AR_INTGATE32); \tset_gatedesc(idt + 0x2c, (int) asm_inthandler2c, 2 * 8, AR_INTGATE32); ``` > 之后在发生中断之后会执行对应的函数 > > 这里的2*8表示的是使用第二段, 乘以8是因为低三位有其他的表示内容 > > 设置IDT的属性是0x8e表示为有效的属性 ```assembly ; 设置为CPU不接受中断, 之前在进入C环境的时候关闭了接受中断 _io_cli:\t; void io_cli(void); \t\tCLI \t\tRET ; 设置为CPU接受中断, 在main函数中调用 _io_sti:\t; void io_sti(void); \t\tSTI \t\tRET ``` > 这里实际上设置的是IF标志位, 控制CPU的中断有效 ```c void HariMain(void) { \tstruct BOOTINFO *binfo (struct BOOTINFO *) ADR_BOOTINFO; \tchar s[40], mcursor[256]; \tint mx, my; \tinit_gdtidt(); \tinit_pic(); \tio_sti(); /* 使能中断 */ \tinit_palette(); \tinit_screen8(binfo >vram, binfo >scrnx, binfo >scrny); \tmx (binfo >scrnx 16) / 2; /* 画面中央になるように座標計算 */ \tmy (binfo >scrny 28 16) / 2; \tinit_mouse_cursor8(mcursor, COL8_008484); \tputblock8_8(binfo >vram, binfo >scrnx, 16, 16, mx, my, mcursor, 16); \tsprintf(s, \"(%d, %d)\", mx, my); \tputfonts8_asc(binfo >vram, binfo >scrnx, 0, 0, COL8_FFFFFF, s); \tio_out8(PIC0_IMR, 0xf9); /* 控制中断屏蔽位的数字 */ \tio_out8(PIC1_IMR, 0xef); /* マウスを許可(11101111) */ \tfor (;;) { \t\tio_hlt(); \t} } ```"},"/note/嵌入式/第三方移植/MySTMOS/2023-9-5-day17命令行窗口.html":{"title":"day17命令行窗口","content":" layout: post title: \"day17命令行窗口\" date: 2023 9 5 15:39:08 +0800 tags: MyOS # day17命令行窗口 ## 闲置任务 当所有任务都进入睡眠的时候会执行的一个任务 添加卫兵 ```c struct TASK *task_init(struct MEMMAN *memman) { \tint i; \tstruct TASK *task, *idle; \tstruct SEGMENT_DESCRIPTOR *gdt (struct SEGMENT_DESCRIPTOR *) ADR_GDT; \ttaskctl (struct TASKCTL *) memman_alloc_4k(memman, sizeof (struct TASKCTL)); \tfor (i 0; i < MAX_TASKS; i++) { \t\ttaskctl >tasks0[i].flags 0; \t\ttaskctl >tasks0[i].sel (TASK_GDT0 + i) * 8; \t\tset_segmdesc(gdt + TASK_GDT0 + i, 103, (int) &taskctl >tasks0[i].tss, AR_TSS32); \t} \tfor (i 0; i < MAX_TASKLEVELS; i++) { \t\ttaskctl >level[i].running 0; \t\ttaskctl >level[i].now 0; \t} \ttask task_alloc(); \ttask >flags 2;\t \ttask >priority 2; \ttask >level 0;\t \ttask_add(task); \ttask_switchsub();\t \tload_tr(task >sel); \ttask_timer timer_alloc(); \ttimer_settime(task_timer, task >priority); \t//获取一个卫兵的任务 \tidle task_alloc(); \tidle >tss.esp memman_alloc_4k(memman, 64 * 1024) + 64 * 1024; \tidle >tss.eip (int) &task_idle; \tidle >tss.es 1 * 8; \tidle >tss.cs 2 * 8; \tidle >tss.ss 1 * 8; \tidle >tss.ds 1 * 8; \tidle >tss.fs 1 * 8; \tidle >tss.gs 1 * 8; \ttask_run(idle, MAX_TASKLEVELS 1, 1);//设置为最低的优先级 \treturn task; } ``` ## 创建命令行窗口 ```c /* sht_cons创建一个命令行任务 */ sht_cons sheet_alloc(shtctl); buf_cons (unsigned char *) memman_alloc_4k(memman, 256 * 165); sheet_setbuf(sht_cons, buf_cons, 256, 165, 1); /* 透明色なし */ make_window8(buf_cons, 256, 165, \"console\", 0); make_textbox8(sht_cons, 8, 28, 240, 128, COL8_000000); task_cons task_alloc(); task_cons >tss.esp memman_alloc_4k(memman, 64 * 1024) + 64 * 1024 8; task_cons >tss.eip (int) &console_task; task_cons >tss.es 1 * 8; task_cons >tss.cs 2 * 8; task_cons >tss.ss 1 * 8; task_cons >tss.ds 1 * 8; task_cons >tss.fs 1 * 8; task_cons >tss.gs 1 * 8; *((int *) (task_cons >tss.esp + 4)) (int) sht_cons;\t//这里是要传入的参数 task_run(task_cons, 2, 2); /* level 2, priority 2 */ ``` ```c //命令行任务 void console_task(struct SHEET *sheet) { \tstruct FIFO32 fifo; \tstruct TIMER *timer; \tstruct TASK *task task_now(); \tint i, fifobuf[128], cursor_x 8, cursor_c COL8_000000; \tfifo32_init(&fifo, 128, fifobuf, task); \ttimer timer_alloc(); \ttimer_init(timer, &fifo, 1); \ttimer_settime(timer, 50); \tfor (;;) { \t\tio_cli(); //由于存在哨兵所以可以直接进行睡眠 \t\tif (fifo32_status(&fifo) 0) { \t\t\ttask_sleep(task); \t\t\tio_sti(); \t\t} else { \t\t\ti fifo32_get(&fifo); \t\t\tio_sti(); \t\t\tif (i < 1) { /* 光标使用的定时器 */ \t\t\t\tif (i ! 0) { \t\t\t\t\ttimer_init(timer, &fifo, 0); /* 下次置0 */ \t\t\t\t\tcursor_c COL8_FFFFFF; \t\t\t\t} else { \t\t\t\t\ttimer_init(timer, &fifo, 1); /* 下次置 */ \t\t\t\t\tcursor_c COL8_000000; \t\t\t\t} \t\t\t\ttimer_settime(timer, 50); \t\t\t\tboxfill8(sheet >buf, sheet >bxsize, cursor_c, cursor_x, 28, cursor_x + 7, 43); \t\t\t\tsheet_refresh(sheet, cursor_x, 28, cursor_x + 8, 44); \t\t\t} \t\t} \t} } ``` # 对话框的分开绘制 ```c void make_window8(unsigned char *buf, int xsize, int ysize, char *title, char act) { \tboxfill8(buf, xsize, COL8_C6C6C6, 0, 0, xsize 1, 0 ); \tboxfill8(buf, xsize, COL8_FFFFFF, 1, 1, xsize 2, 1 ); \tboxfill8(buf, xsize, COL8_C6C6C6, 0, 0, 0, ysize 1); \tboxfill8(buf, xsize, COL8_FFFFFF, 1, 1, 1, ysize 2); \tboxfill8(buf, xsize, COL8_848484, xsize 2, 1, xsize 2, ysize 2); \tboxfill8(buf, xsize, COL8_000000, xsize 1, 0, xsize 1, ysize 1); \tboxfill8(buf, xsize, COL8_C6C6C6, 2, 2, xsize 3, ysize 3); \tboxfill8(buf, xsize, COL8_848484, 1, ysize 2, xsize 2, ysize 2); \tboxfill8(buf, xsize, COL8_000000, 0, ysize 1, xsize 1, ysize 1); \tmake_wtitle8(buf, xsize, title, act); \treturn; } void make_wtitle8(unsigned char *buf, int xsize, char *title, char act) { \tstatic char closebtn[14][16] { \t\t\"OOOOOOOOOOOOOOO@\", \t\t\"OQQQQQQQQQQQQQ$@\", \t\t\"OQQQQQQQQQQQQQ$@\", \t\t\"OQQQ@@QQQQ@@QQ$@\", \t\t\"OQQQQ@@QQ@@QQQ$@\", \t\t\"OQQQQQ@@@@QQQQ$@\", \t\t\"OQQQQQQ@@QQQQQ$@\", \t\t\"OQQQQQ@@@@QQQQ$@\", \t\t\"OQQQQ@@QQ@@QQQ$@\", \t\t\"OQQQ@@QQQQ@@QQ$@\", \t\t\"OQQQQQQQQQQQQQ$@\", \t\t\"OQQQQQQQQQQQQQ$@\", \t\t\"O$$$$$$$$$$$$$$@\", \t\t\"@@@@@@@@@@@@@@@@\" \t}; \tint x, y; \tchar c, tc, tbc; \tif (act ! 0) { \t\ttc COL8_FFFFFF; \t\ttbc COL8_000084; \t} else { \t\ttc COL8_C6C6C6; \t\ttbc COL8_848484; \t} \tboxfill8(buf, xsize, tbc, 3, 3, xsize 4, 20); \tputfonts8_asc(buf, xsize, 24, 4, tc, title); \tfor (y 0; y < 14; y++) { \t\tfor (x 0; x < 16; x++) { \t\t\tc closebtn[y][x]; \t\t\tif (c '@') { \t\t\t\tc COL8_000000; \t\t\t} else if (c '$') { \t\t\t\tc COL8_848484; \t\t\t} else if (c 'Q') { \t\t\t\tc COL8_C6C6C6; \t\t\t} else { \t\t\t\tc COL8_FFFFFF; \t\t\t} \t\t\tbuf[(5 + y) * xsize + (xsize 21 + x)] c; \t\t} \t} \treturn; } ``` > 这样方便对于对话框的头部的颜色的改变 ```c if (i 256 + 0x0f) { /* Tab改变两个对话框之间进行切换 */ if (key_to 0) { key_to 1; make_wtitle8(buf_win, sht_win >bxsize, \"task_a\", 0); make_wtitle8(buf_cons, sht_cons >bxsize, \"console\", 1); } else { key_to 0; make_wtitle8(buf_win, sht_win >bxsize, \"task_a\", 1); make_wtitle8(buf_cons, sht_cons >bxsize, \"console\", 0); } sheet_refresh(sht_win, 0, 0, sht_win >bxsize, 21); sheet_refresh(sht_cons, 0, 0, sht_cons >bxsize, 21); } /* 重新显示光标 */ boxfill8(sht_win >buf, sht_win >bxsize, cursor_c, cursor_x, 28, cursor_x + 7, 43); sheet_refresh(sht_win, cursor_x, 28, cursor_x + 8, 44); } ```"},"/note/嵌入式/第三方移植/MySTMOS/2023-7-21-day4C语言以及显示.html":{"title":"day4C语言以及显示","content":" layout: post title: \"day4C语言以及显示\" date: 2023 7 21 15:39:08 +0800 tags: MyOS # day4C语言以及显示 ```assembly [INSTRSET \"i486p\"]\t\t\t\t; 486这个程序的应用位置, nask使用的指令 _write_mem8:\t; void write_mem8(int addr, int data); \t\tMOV\t\tECX,[ESP+4]\t\t; [ESP+4]存放的是地址 \t\tMOV\t\tAL,[ESP+8]\t\t; [ESP+8]存放的是数据 \t\tMOV\t\t[ECX],AL \t\tRET ``` > 在使用C语言的时候可以使用的寄存器有EAX, ECX, EDX > 英特尔系列 > > 8086 >80186 >286 >386 >Pentium >PentiumPro >PentiumII >PentiumIII... + 之后使用C语言的指针以及数组 略 + 使用RGB颜色 由于这个模式只能使用一个字节决定一个颜色, 所以只可以使用255种颜色, 但是可以自己设置 ```c void io_hlt(void); void io_cli(void); void io_out8(int port, int data); int io_load_eflags(void); void io_store_eflags(int eflags); /* 実は同じソースファイルに書いてあっても、定義する前に使うのなら、 \tやっぱり宣言しておかないといけない。 */ void init_palette(void); void set_palette(int start, int end, unsigned char *rgb); void HariMain(void) { \tint i; \tchar *p; \tinit_palette(); //初始化画板 \tp (char *) 0xa0000; /* 指定地址 */ \tfor (i 0; i < 0xffff; i++) { \t\tp[i] i & 0x0f; \t} \tfor (;;) { \t\tio_hlt(); \t} } void init_palette(void) { \tstatic unsigned char table_rgb[16 * 3] { \t\t0x00, 0x00, 0x00,\t/* 0:黒 */ \t\t0xff, 0x00, 0x00,\t/* 1:亮红 */ \t\t0x00, 0xff, 0x00,\t/* 2:绿 */ \t\t0xff, 0xff, 0x00,\t/* 3:黄 */ \t\t0x00, 0x00, 0xff,\t/* 4:蓝 */ \t\t0xff, 0x00, 0xff,\t/* 5:紫 */ \t\t0x00, 0xff, 0xff,\t/* 6:浅蓝*/ \t\t0xff, 0xff, 0xff,\t/* 7:白 */ \t\t0xc6, 0xc6, 0xc6,\t/* 8:灰 */ \t\t0x84, 0x00, 0x00,\t/* 9:暗红 */ \t\t0x00, 0x84, 0x00,\t/* 10:暗緑 */ \t\t0x84, 0x84, 0x00,\t/* 11:暗黄色 */ \t\t0x00, 0x00, 0x84,\t/* 12:暗青 */ \t\t0x84, 0x00, 0x84,\t/* 13:暗紫 */ \t\t0x00, 0x84, 0x84,\t/* 14:暗蓝色 */ \t\t0x84, 0x84, 0x84\t/* 15:暗灰色 */ \t}; \tset_palette(0, 15, table_rgb); \treturn; } void set_palette(int start, int end, unsigned char *rgb) { \tint i, eflags; \teflags io_load_eflags();\t/* 记录中断许可为,从EFLGS寄存器中 */ \tio_cli(); \t\t\t\t\t/* 禁止中断 */ \tio_out8(0x03c8, start); \tfor (i start; i < end; i++) { \t\tio_out8(0x03c9, rgb[0] / 4); \t\tio_out8(0x03c9, rgb[1] / 4); \t\tio_out8(0x03c9, rgb[2] / 4); \t\trgb + 3; \t} \tio_store_eflags(eflags);\t/* 复原中断 */ \treturn; } ``` > 在设置的时候需要以下几步 > > > 操控设备主要使用的是OUT命令, 获取信息使用的是IN指令, 使用设备号进行区分 > > + 屏蔽中断CLI > + 在设定的调色板号码写入0x03c8, 之后按照RGB写入0x03c9 > + 想要读取: 将调色盘号码写入0x03c7, 之后从0x03c9读取 > + 打开中断STI ```c ; naskfunc ; TAB 4 [FORMAT \"WCOFF\"]\t\t\t\t; 僆僽僕僃僋僩僼傽僀儖傪嶌傞儌乕僪\t [INSTRSET \"i486p\"]\t\t\t\t; 486偺柦椷傑偱巊偄偨偄偲偄偆婰弎 [BITS 32]\t\t\t\t\t\t; 32價僢僩儌乕僪梡偺婡夿岅傪嶌傜偣傞 [FILE \"naskfunc.nas\"]\t\t\t; 僜乕僗僼傽僀儖柤忣曬 \t\tGLOBAL\t_io_hlt, _io_cli, _io_sti, _io_stihlt \t\tGLOBAL\t_io_in8, _io_in16, _io_in32 \t\tGLOBAL\t_io_out8, _io_out16, _io_out32 \t\tGLOBAL\t_io_load_eflags, _io_store_eflags [SECTION .text] _io_hlt:\t; void io_hlt(void); \t\tHLT \t\tRET _io_cli:\t; void io_cli(void); \t\tCLI \t\tRET _io_sti:\t; void io_sti(void); \t\tSTI \t\tRET _io_stihlt:\t; void io_stihlt(void); \t\tSTI \t\tHLT \t\tRET _io_in8:\t; int io_in8(int port); \t\tMOV\t\tEDX,[ESP+4]\t\t; port \t\tMOV\t\tEAX,0 \t\tIN\t\tAL,DX \t\tRET _io_in16:\t; int io_in16(int port); \t\tMOV\t\tEDX,[ESP+4]\t\t; port \t\tMOV\t\tEAX,0 \t\tIN\t\tAX,DX \t\tRET _io_in32:\t; int io_in32(int port); \t\tMOV\t\tEDX,[ESP+4]\t\t; port \t\tIN\t\tEAX,DX \t\tRET _io_out8:\t; void io_out8(int port, int data); \t\tMOV\t\tEDX,[ESP+4]\t\t; port \t\tMOV\t\tAL,[ESP+8]\t\t; data \t\tOUT\t\tDX,AL \t\tRET _io_out16:\t; void io_out16(int port, int data); \t\tMOV\t\tEDX,[ESP+4]\t\t; port \t\tMOV\t\tEAX,[ESP+8]\t\t; data \t\tOUT\t\tDX,AX \t\tRET _io_out32:\t; void io_out32(int port, int data); \t\tMOV\t\tEDX,[ESP+4]\t\t; port \t\tMOV\t\tEAX,[ESP+8]\t\t; data \t\tOUT\t\tDX,EAX \t\tRET _io_load_eflags:\t; int io_load_eflags(void); \t\tPUSHFD\t\t; PUSH EFLAGS 偲偄偆堄枴 \t\tPOP\t\tEAX \t\tRET _io_store_eflags:\t; void io_store_eflags(int eflags); \t\tMOV\t\tEAX,[ESP+4] \t\tPUSH\tEAX \t\tPOPFD\t\t; POP EFLAGS \t\tRET ``` > 只可以使用PUSHFD以及POPFD"},"/note/嵌入式/第三方移植/MySTMOS/2023-8-24-day13定时器.html":{"title":"day13定时器","content":" layout: post title: \"day13定时器\" date: 2023 8 24 15:39:08 +0800 tags: MyOS # day13定时器 ## 优化字符显示的函数 ```c // 要改变的图层, 初始位置, 字符的颜色, 背景的颜色, 字符串, 长度 void putfonts8_asc_sht(struct SHEET *sht, int x, int y, int c, int b, char *s, int l) { \tboxfill8(sht >buf, sht >bxsize, b, x, y, x + l * 8 1, y + 15); \tputfonts8_asc(sht >buf, sht >bxsize, x, y, c, s); \tsheet_refresh(sht, x, y, x + l * 8, y + 16); \treturn; } ``` > 把三个函数整合到一个函数 ## 所有的中断信号使用同一个FIFO + 0 1\t光标闪烁使用的定时器 + 3 3秒的定时器 + 10 10秒的定时器 + 256 511 键盘输入 + 512 767 鼠标输入 ### 首先实现32位的FIFO ```c void fifo32_init(struct FIFO32 *fifo, int size, int *buf) /* FIFO初始化 */ { \tfifo >size size; \tfifo >buf buf; \tfifo >free size; /* 空き */ \tfifo >flags 0; \tfifo >p 0; /* 書き込み位置 */ \tfifo >q 0; /* 読み込み位置 */ \treturn; } int fifo32_put(struct FIFO32 *fifo, int data) /* FIFO放入一个数据 */ { \tif (fifo >free 0) { \t\t/* 没有空位了 */ \t\tfifo >flags FLAGS_OVERRUN; \t\treturn 1; \t} \tfifo >buf[fifo >p] data; \tfifo >p++; \tif (fifo >p fifo >size) { \t\tfifo >p 0; \t} \tfifo >free ; \treturn 0; } int fifo32_get(struct FIFO32 *fifo) /* FIFO获取其中一个 */ { \tint data; \tif (fifo >free fifo >size) { \t\t/* 没有数据 */ \t\treturn 1; \t} \tdata fifo >buf[fifo >q]; \tfifo >q++; \tif (fifo >q fifo >size) { \t\tfifo >q 0; \t} \tfifo >free++; \treturn data; } int fifo32_status(struct FIFO32 *fifo) /* 获取剩余的数量 */ { \treturn fifo >size fifo >free; } ``` ```c struct FIFO32 *keyfifo; int keydata0; void inthandler21(int *esp) { \tint data; \tio_out8(PIC0_OCW2, 0x61);\t/* IRQ 01 */ \tdata io_in8(PORT_KEYDAT); //偏移 \tfifo32_put(keyfifo, data + keydata0); \treturn; } void init_keyboard(struct FIFO32 *fifo, int data0) { \t/* 将FIFO的信息保存起来,以及保存偏移 */ \tkeyfifo fifo; \tkeydata0 data0; \t/* 进行初始化 */ \twait_KBC_sendready(); \tio_out8(PORT_KEYCMD, KEYCMD_WRITE_MODE); \twait_KBC_sendready(); \tio_out8(PORT_KEYDAT, KBC_MODE); \treturn; } ``` ```c struct FIFO32 *mousefifo; int mousedata0; void inthandler2c(int *esp) /* PS/2鼠标的中断 */ { \tint data; \tio_out8(PIC1_OCW2, 0x64);\t \tio_out8(PIC0_OCW2, 0x62);\t \tdata io_in8(PORT_KEYDAT); //偏移 \tfifo32_put(mousefifo, data + mousedata0); \treturn; } #define KEYCMD_SENDTO_MOUSE\t\t0xd4 #define MOUSECMD_ENABLE\t\t\t0xf4 void enable_mouse(struct FIFO32 *fifo, int data0, struct MOUSE_DEC *mdec) { \t/* 记录偏移量以及fifo */ \tmousefifo fifo; \tmousedata0 data0; \t/* 初始化 */ \twait_KBC_sendready(); \tio_out8(PORT_KEYCMD, KEYCMD_SENDTO_MOUSE); \twait_KBC_sendready(); \tio_out8(PORT_KEYDAT, MOUSECMD_ENABLE); \t/* 顺利的话会发送0xfa */ \tmdec >phase 0; /* 等待鼠标 */ \treturn; } ``` ```c void HariMain(void) { \tstruct BOOTINFO *binfo (struct BOOTINFO *) ADR_BOOTINFO; \tstruct FIFO32 fifo; \tchar s[40]; \tint fifobuf[128]; \tstruct TIMER *timer, *timer2, *timer3; \tint mx, my, i, count 0; \tunsigned int memtotal; \tstruct MOUSE_DEC mdec; \tstruct MEMMAN *memman (struct MEMMAN *) MEMMAN_ADDR; \tstruct SHTCTL *shtctl; \tstruct SHEET *sht_back, *sht_mouse, *sht_win; \tunsigned char *buf_back, buf_mouse[256], *buf_win; \tinit_gdtidt(); \tinit_pic(); \tio_sti(); /* IDT/PICの初期化が終わったのでCPUの割り込み禁止を解除 */ \tfifo32_init(&fifo, 128, fifobuf); \tinit_pit(); //设置偏移以及fifo \tinit_keyboard(&fifo, 256); \tenable_mouse(&fifo, 512, &mdec); \tio_out8(PIC0_IMR, 0xf8); /* PITとPIC1とキーボードを許可(11111000) */ \tio_out8(PIC1_IMR, 0xef); /* マウスを許可(11101111) */ \ttimer timer_alloc(); \ttimer_init(timer, &fifo, 10); \ttimer_settime(timer, 1000); \ttimer2 timer_alloc(); \ttimer_init(timer2, &fifo, 3); \ttimer_settime(timer2, 300); \ttimer3 timer_alloc(); \ttimer_init(timer3, &fifo, 1); \ttimer_settime(timer3, 50); \tmemtotal memtest(0x00400000, 0xbfffffff); \tmemman_init(memman); \tmemman_free(memman, 0x00001000, 0x0009e000); /* 0x00001000 0x0009efff */ \tmemman_free(memman, 0x00400000, memtotal 0x00400000); \tinit_palette(); \tshtctl shtctl_init(memman, binfo >vram, binfo >scrnx, binfo >scrny); \tsht_back sheet_alloc(shtctl); \tsht_mouse sheet_alloc(shtctl); \tsht_win sheet_alloc(shtctl); \tbuf_back (unsigned char *) memman_alloc_4k(memman, binfo >scrnx * binfo >scrny); \tbuf_win (unsigned char *) memman_alloc_4k(memman, 160 * 52); \tsheet_setbuf(sht_back, buf_back, binfo >scrnx, binfo >scrny, 1); /* 透明色なし */ \tsheet_setbuf(sht_mouse, buf_mouse, 16, 16, 99); \tsheet_setbuf(sht_win, buf_win, 160, 52, 1); /* 透明色なし */ \tinit_screen8(buf_back, binfo >scrnx, binfo >scrny); \tinit_mouse_cursor8(buf_mouse, 99); \tmake_window8(buf_win, 160, 52, \"counter\"); \tsheet_slide(sht_back, 0, 0); \tmx (binfo >scrnx 16) / 2; /* 画面中央になるように座標計算 */ \tmy (binfo >scrny 28 16) / 2; \tsheet_slide(sht_mouse, mx, my); \tsheet_slide(sht_win, 80, 72); \tsheet_updown(sht_back, 0); \tsheet_updown(sht_win, 1); \tsheet_updown(sht_mouse, 2); \tsprintf(s, \"(%3d, %3d)\", mx, my); \tputfonts8_asc_sht(sht_back, 0, 0, COL8_FFFFFF, COL8_008484, s, 10); \tsprintf(s, \"memory %dMB free : %dKB\", \t\t\tmemtotal / (1024 * 1024), memman_total(memman) / 1024); \tputfonts8_asc_sht(sht_back, 0, 32, COL8_FFFFFF, COL8_008484, s, 40); \tfor (;;) { \t\tcount++; \t\tio_cli(); \t\tif (fifo32_status(&fifo) 0) { \t\t\tio_sti(); \t\t} else { \t\t\ti fifo32_get(&fifo); \t\t\tio_sti(); \t\t\tif (256 < i && i < 511) { /* キーボードデータ */ \t\t\t\tsprintf(s, \"%02X\", i 256); \t\t\t\tputfonts8_asc_sht(sht_back, 0, 16, COL8_FFFFFF, COL8_008484, s, 2); \t\t\t} else if (512 < i && i < 767) { /* マウスデータ */ \t\t\t\tif (mouse_decode(&mdec, i 512) ! 0) { \t\t\t\t\t/* 这里面的是鼠标的数据 */ \t\t\t\t\tsprintf(s, \"[lcr %4d %4d]\", mdec.x, mdec.y); \t\t\t\t\tif ((mdec.btn & 0x01) ! 0) { \t\t\t\t\t\ts[1] 'L'; \t\t\t\t\t} \t\t\t\t\tif ((mdec.btn & 0x02) ! 0) { \t\t\t\t\t\ts[3] 'R'; \t\t\t\t\t} \t\t\t\t\tif ((mdec.btn & 0x04) ! 0) { \t\t\t\t\t\ts[2] 'C'; \t\t\t\t\t} \t\t\t\t\tputfonts8_asc_sht(sht_back, 32, 16, COL8_FFFFFF, COL8_008484, s, 15); \t\t\t\t\t/* 对鼠标的位置进行变换 */ \t\t\t\t\tmx + mdec.x; \t\t\t\t\tmy + mdec.y; \t\t\t\t\tif (mx < 0) { \t\t\t\t\t\tmx 0; \t\t\t\t\t} \t\t\t\t\tif (my < 0) { \t\t\t\t\t\tmy 0; \t\t\t\t\t} \t\t\t\t\tif (mx > binfo >scrnx 1) { \t\t\t\t\t\tmx binfo >scrnx 1; \t\t\t\t\t} \t\t\t\t\tif (my > binfo >scrny 1) { \t\t\t\t\t\tmy binfo >scrny 1; \t\t\t\t\t} \t\t\t\t\tsprintf(s, \"(%3d, %3d)\", mx, my); \t\t\t\t\tputfonts8_asc_sht(sht_back, 0, 0, COL8_FFFFFF, COL8_008484, s, 10); \t\t\t\t\tsheet_slide(sht_mouse, mx, my); \t\t\t\t} \t\t\t} else if (i 10) { /* 10秒 */ \t\t\t\tputfonts8_asc_sht(sht_back, 0, 64, COL8_FFFFFF, COL8_008484, \"10[sec]\", 7); \t\t\t\tsprintf(s, \"%010d\", count); \t\t\t\tputfonts8_asc_sht(sht_win, 40, 28, COL8_000000, COL8_C6C6C6, s, 10); \t\t\t} else if (i 3) { /* 3秒 */ \t\t\t\tputfonts8_asc_sht(sht_back, 0, 80, COL8_FFFFFF, COL8_008484, \"3[sec]\", 6); \t\t\t\tcount 0; /* 开始检测 */ \t\t\t} else if (i 1) { /* 这个是闪烁 */ \t\t\t\ttimer_init(timer3, &fifo, 0); /* 设置为返回0 */ \t\t\t\tboxfill8(buf_back, binfo >scrnx, COL8_FFFFFF, 8, 96, 15, 111); \t\t\t\ttimer_settime(timer3, 50); \t\t\t\tsheet_refresh(sht_back, 8, 96, 16, 112); \t\t\t} else if (i 0) { /* 设置为返回1 */ \t\t\t\ttimer_init(timer3, &fifo, 1); /* 次は1を */ \t\t\t\tboxfill8(buf_back, binfo >scrnx, COL8_008484, 8, 96, 15, 111); \t\t\t\ttimer_settime(timer3, 50); \t\t\t\tsheet_refresh(sht_back, 8, 96, 16, 112); \t\t\t} \t\t} \t} } ``` ## 引入链表 ```c struct TIMER { \tstruct TIMER *next; \tunsigned int timeout, flags; \tstruct FIFO32 *fifo; \tint data; }; struct TIMERCTL { \tunsigned int count, next, using; \tstruct TIMER *t0; \tstruct TIMER timers0[MAX_TIMER]; }; ``` ````c void inthandler20(int *esp) { \tint i; \tstruct TIMER *timer; \tio_out8(PIC0_OCW2, 0x60);\t/* IRQ 00 */ \ttimerctl.count++; \tif (timerctl.next > timerctl.count) { \t\treturn; \t} \ttimer timerctl.t0; /* 获取链表的头部 */ \tfor (i 0; i < timerctl.using; i++) { \t\t/* 处理到时间的, 获取下一位需处理的链表 */ \t\tif (timer >timeout > timerctl.count) { \t\t\tbreak; \t\t} \t\t/* 设置标志位 */ \t\ttimer >flags TIMER_FLAGS_ALLOC; \t\tfifo32_put(timer >fifo, timer >data); \t\ttimer timer >next; /* 来到下一个链表 */ \t} \ttimerctl.using i; \t/* 更新 */ \ttimerctl.t0 timer; \t/* timerctl.next的设置, 还有时钟在使用的话就进行设置 */ \tif (timerctl.using > 0) { \t\ttimerctl.next timerctl.t0 >timeout; \t} else { \t\ttimerctl.next 0xffffffff; \t} \treturn; } ```` ```c void timer_settime(struct TIMER *timer, unsigned int timeout) { \tint e; \tstruct TIMER *t, *s; //获取实际超时的时间 \ttimer >timeout timeout + timerctl.count; \ttimer >flags TIMER_FLAGS_USING; \t//进入临界区 e io_load_eflags(); \tio_cli(); \ttimerctl.using++; \tif (timerctl.using 1) { \t\t/* 正在使用的链表只有他自己 */ \t\ttimerctl.t0 timer; \t\ttimer >next 0; /* 没有下一个*/ \t\ttimerctl.next timer >timeout; \t\tio_store_eflags(e); \t\treturn; \t} //获取当前的时钟 \tt timerctl.t0; \tif (timer >timeout < t >timeout) { \t\t/* 当前的时钟下一次的时间大于新设置的时间 */ \t\ttimerctl.t0 timer; \t\ttimer >next t; /* 设置链表的下一项 */ \t\ttimerctl.next timer >timeout; \t\tio_store_eflags(e); \t\treturn; \t} \t/* 另一种情况 */ \tfor (;;) { \t\ts t; \t\tt t >next; \t\tif (t 0) { \t\t\tbreak; /* 没有下一个了 */ \t\t} \t\tif (timer >timeout < t >timeout) { \t\t\t/* 找到合适的位置,s保留上一个,t保留下一个 */ \t\t\ts >next timer; /* 设置 */ \t\t\ttimer >next t; /* timer */ \t\t\tio_store_eflags(e); \t\t\treturn; \t\t} \t} \t/* 没有两个中间合适 */ \ts >next timer; \ttimer >next 0; \tio_store_eflags(e); \treturn; } ``` ## 添加一个哨兵 用来简化程序 ```c void init_pit(void) { \tint i; \tstruct TIMER *t; \tio_out8(PIT_CTRL, 0x34); \tio_out8(PIT_CNT0, 0x9c); \tio_out8(PIT_CNT0, 0x2e); \ttimerctl.count 0; \tfor (i 0; i < MAX_TIMER; i++) { \t\ttimerctl.timers0[i].flags 0; /* 所有的都设置为没有使用 */ \t} \tt timer_alloc(); /* 申请哨兵 */ \tt >timeout 0xffffffff; \tt >flags TIMER_FLAGS_USING; \tt >next 0; /* 没有下一个 */ \ttimerctl.t0 t; /* 设置第一个是哨兵 */ \ttimerctl.next 0xffffffff; /* 设置时刻为最大值 */ \treturn; } ```"},"/note/嵌入式/第三方移植/MySTMOS/2023-8-14-day7FIFO与鼠标控制.html":{"title":"day7FIFO与鼠标控制","content":" layout: post title: \"day7FIFO与鼠标控制\" date: 2023 8 14 15:39:08 +0800 tags: MyOS # day7FIFO与鼠标控制 ## 获取按键编码 ```c #define PORT_KEYDAT\t\t0x0060 void inthandler21(int *esp) { //初始化相关的数据 \tstruct BOOTINFO *binfo (struct BOOTINFO *) ADR_BOOTINFO; \tunsigned char data, s[4]; \tio_out8(PIC0_OCW2, 0x61);\t/* IRQ 01的PIC已经受理完毕 */ \tdata io_in8(PORT_KEYDAT);\t//获取键盘的返回值 \tsprintf(s, \"%02X\", data); //对获取的键盘的值进行打印 \tboxfill8(binfo >vram, binfo >scrnx, COL8_008484, 0, 16, 15, 31); \tputfonts8_asc(binfo >vram, binfo >scrnx, 0, 16, COL8_FFFFFF, s); \treturn; } ``` > 在告诉收到信号的时候, 实际输出的是'0x60 + IRQ号码', 执行之后PIC会继续进行检测 ## 把处理函数放在中断函数之外 ```c struct KEYBUF { \tunsigned char data, flag; }; struct KEYBUF keybuf; void inthandler21(int *esp) { \tunsigned char data; \tio_out8(PIC0_OCW2, 0x61);\t/* 清空中断标志位 */ \tdata io_in8(PORT_KEYDAT); \tif (keybuf.flag 0) { \t\tkeybuf.data data; \t\tkeybuf.flag 1; \t} \treturn; } ``` ```c for (;;) { io_cli(); if (keybuf.flag 0) { io_stihlt(); } else { i keybuf.data; keybuf.flag 0; io_sti(); sprintf(s, \"%02X\", i); boxfill8(binfo >vram, binfo >scrnx, COL8_008484, 0, 16, 15, 31); putfonts8_asc(binfo >vram, binfo >scrnx, 0, 16, COL8_FFFFFF, s); } } ``` > 修改main函数 > > io_stihlt();这里使用这个函数是因为如果在sti函数之后发生中断数据就会存入, 但是没有被察觉到, 如果两个指令在一起CPU会屏蔽中间的中断 这时候的键盘返回的数据如果有两个会被吞掉, 因为一次按键只会产生两个中断, 但是直接收了每一次中断输出的第一个数据, 第二个数据在第二次中断的时候被舍弃了, 因为第二个数据到来的时候第一个数据没有处理完, 这时候会进入睡眠而不是进入再次处理 ## 引入数据结构FIFO ```c /* FIFO */ #include \"bootpack.h\" #define FLAGS_OVERRUN\t\t0x0001 void fifo8_init(struct FIFO8 *fifo, int size, unsigned char *buf) /* FIFO初始化 */ { \tfifo >size size; \tfifo >buf buf; \tfifo >free size; /* 空き */ \tfifo >flags 0; \tfifo >p 0; /* 書き込み位置 */ \tfifo >q 0; /* 読み込み位置 */ \treturn; } int fifo8_put(struct FIFO8 *fifo, unsigned char data) /* FIFO放入数据 */ { \tif (fifo >free 0) { \t\t/* 检测是否溢出た */ \t\tfifo >flags FLAGS_OVERRUN; \t\treturn 1; \t} \tfifo >buf[fifo >p] data; \tfifo >p++; \tif (fifo >p fifo >size) { \t\tfifo >p 0; \t} \tfifo >free ; \treturn 0; } int fifo8_get(struct FIFO8 *fifo) /* FIFO会的一个数据 */ { \tint data; \tif (fifo >free fifo >size) { \t\t/* 数组为空返回 1 */ \t\treturn 1; \t} \tdata fifo >buf[fifo >q]; \tfifo >q++; \tif (fifo >q fifo >size) { \t\tfifo >q 0; \t} \tfifo >free++; \treturn data; } //存放数据的个数 int fifo8_status(struct FIFO8 *fifo) { \treturn fifo >size fifo >free; } ``` ## 鼠标 在初期的时候大多数的操作系统不支持鼠标, 所以鼠标的电路在不被激活的时候 在不激活的时候, 鼠标是不会产生中断的, 需要让鼠标的控制电路以及鼠标本身有效, 鼠标的控制电路包含在键盘的控制电路里面, 键盘的控制电路初始化的时候鼠标的初始化也就完成了 ```c #define PORT_KEYDAT\t\t\t\t0x0060 #define PORT_KEYSTA\t\t\t\t0x0064 #define PORT_KEYCMD\t\t\t\t0x0064 #define KEYSTA_SEND_NOTREADY\t0x02 #define KEYCMD_WRITE_MODE\t\t0x60 #define KBC_MODE\t\t\t\t0x47 void wait_KBC_sendready(void) { \t/* 等待键盘控制电路初始化完成 */ \tfor (;;) { \t\tif ((io_in8(PORT_KEYSTA) & KEYSTA_SEND_NOTREADY) 0) { \t\t\tbreak; \t\t} \t} \treturn; } void init_keyboard(void) { \t/* 初始化键盘的控制电路 */ \twait_KBC_sendready(); \tio_out8(PORT_KEYCMD, KEYCMD_WRITE_MODE); \twait_KBC_sendready(); \tio_out8(PORT_KEYDAT, KBC_MODE); \treturn; } ``` > 在确认可以发送信息之后设置模式的命令是0x60, 使用鼠标的模式是0x47 ```c #define KEYCMD_SENDTO_MOUSE\t\t0xd4 #define MOUSECMD_ENABLE\t\t\t0xf4 void enable_mouse(void) { \t/* 激活鼠标,先对键盘发送0xd4,之后的数据就会发送给鼠标 */ \twait_KBC_sendready(); \tio_out8(PORT_KEYCMD, KEYCMD_SENDTO_MOUSE); \twait_KBC_sendready(); \tio_out8(PORT_KEYDAT, MOUSECMD_ENABLE); \treturn; /* 顺利的话的返回ACK(0xfa) */ } ``` > 这时候因为会返回一个数值, 所以会直接产生一个中断 ## 对从鼠标获取的数据进行处理 ```c struct FIFO8 mousefifo; void inthandler2c(int *esp) /* 来自鼠标的中断 */ { \tunsigned char data; \tio_out8(PIC1_OCW2, 0x64);\t/* 通知PIC1 IRQ12的中断已经响应 */ \tio_out8(PIC0_OCW2, 0x62);\t/* 通知PIC0 IRQ12的中断已经响应 */ \tdata io_in8(PORT_KEYDAT); \tfifo8_put(&mousefifo, data); \treturn; } ``` ```c void HariMain(void) { \tstruct BOOTINFO *binfo (struct BOOTINFO *) ADR_BOOTINFO; \tchar s[40], mcursor[256], keybuf[32], mousebuf[128]; \tint mx, my, i; \tinit_gdtidt(); \tinit_pic(); \tio_sti(); /* 初始化结束之后打开中断 */ //初始化两个FIFO \tfifo8_init(&keyfifo, 32, keybuf); \tfifo8_init(&mousefifo, 128, mousebuf); \tio_out8(PIC0_IMR, 0xf9); /* 许可中断 */ \tio_out8(PIC1_IMR, 0xef); /* 许可中断 */ \t//初始化键盘 \tinit_keyboard(); \t//初始化花瓣 \tinit_palette(); \tinit_screen8(binfo >vram, binfo >scrnx, binfo >scrny); \tmx (binfo >scrnx 16) / 2; /* 画面中央になるように座標計算 */ \tmy (binfo >scrny 28 16) / 2; \tinit_mouse_cursor8(mcursor, COL8_008484); \tputblock8_8(binfo >vram, binfo >scrnx, 16, 16, mx, my, mcursor, 16); \tsprintf(s, \"(%d, %d)\", mx, my); \tputfonts8_asc(binfo >vram, binfo >scrnx, 0, 0, COL8_FFFFFF, s); \t//初始化鼠标 \tenable_mouse(); \tfor (;;) { \t\tio_cli();//关闭中断 \t\tif (fifo8_status(&keyfifo) + fifo8_status(&mousefifo) 0) { //没有数据打开中断进入睡眠 \t\t\tio_stihlt(); \t\t} else { \t\t\tif (fifo8_status(&keyfifo) ! 0) { \t\t\t\ti fifo8_get(&keyfifo); \t\t\t\tio_sti(); \t\t\t\tsprintf(s, \"%02X\", i); \t\t\t\tboxfill8(binfo >vram, binfo >scrnx, COL8_008484, 0, 16, 15, 31); \t\t\t\tputfonts8_asc(binfo >vram, binfo >scrnx, 0, 16, COL8_FFFFFF, s); \t\t\t} else if (fifo8_status(&mousefifo) ! 0) { \t\t\t\ti fifo8_get(&mousefifo); \t\t\t\tio_sti(); \t\t\t\tsprintf(s, \"%02X\", i); \t\t\t\tboxfill8(binfo >vram, binfo >scrnx, COL8_008484, 32, 16, 47, 31); \t\t\t\tputfonts8_asc(binfo >vram, binfo >scrnx, 32, 16, COL8_FFFFFF, s); \t\t\t} \t\t} \t} } ```"},"/note/嵌入式/第三方移植/MySTMOS/2023-8-17-day9内存管理.html":{"title":"day9内存管理","content":" layout: post title: \"day9内存管理\" date: 2023 8 17 15:39:08 +0800 tags: MyOS # 内存管理 ## 整理文件 ```makefile OBJS_BOOTPACK bootpack.obj naskfunc.obj hankaku.obj graphic.obj dsctbl.obj \\ \t\tint.obj fifo.obj keyboard.obj mouse.obj TOOLPATH ../z_tools/ INCPATH ../z_tools/haribote/ MAKE $(TOOLPATH)make.exe r NASK $(TOOLPATH)nask.exe CC1 $(TOOLPATH)cc1.exe I$(INCPATH) Os Wall quiet GAS2NASK $(TOOLPATH)gas2nask.exe a OBJ2BIM $(TOOLPATH)obj2bim.exe MAKEFONT $(TOOLPATH)makefont.exe BIN2OBJ $(TOOLPATH)bin2obj.exe BIM2HRB $(TOOLPATH)bim2hrb.exe RULEFILE $(TOOLPATH)haribote/haribote.rul EDIMG $(TOOLPATH)edimg.exe IMGTOL $(TOOLPATH)imgtol.com COPY copy DEL del # デフォルト動作 default : \t$(MAKE) img # ファイル生成規則 ipl10.bin : ipl10.nas Makefile \t$(NASK) ipl10.nas ipl10.bin ipl10.lst asmhead.bin : asmhead.nas Makefile \t$(NASK) asmhead.nas asmhead.bin asmhead.lst hankaku.bin : hankaku.txt Makefile \t$(MAKEFONT) hankaku.txt hankaku.bin hankaku.obj : hankaku.bin Makefile \t$(BIN2OBJ) hankaku.bin hankaku.obj _hankaku bootpack.bim : $(OBJS_BOOTPACK) Makefile \t$(OBJ2BIM) @$(RULEFILE) out:bootpack.bim stack:3136k map:bootpack.map \\ \t\t$(OBJS_BOOTPACK) # 3MB+64KB 3136KB bootpack.hrb : bootpack.bim Makefile \t$(BIM2HRB) bootpack.bim bootpack.hrb 0 haribote.sys : asmhead.bin bootpack.hrb Makefile \tcopy /B asmhead.bin+bootpack.hrb haribote.sys haribote.img : ipl10.bin haribote.sys Makefile \t$(EDIMG) imgin:../z_tools/fdimg0at.tek \\ \t\twbinimg src:ipl10.bin len:512 from:0 to:0 \\ \t\tcopy from:haribote.sys to:@: \\ \t\timgout:haribote.img # 一般規則 %.gas : %.c bootpack.h Makefile \t$(CC1) o $*.gas $*.c %.nas : %.gas Makefile \t$(GAS2NASK) $*.gas $*.nas %.obj : %.nas Makefile \t$(NASK) $*.nas $*.obj $*.lst # コマンド img : \t$(MAKE) haribote.img run : \t$(MAKE) img \t$(COPY) haribote.img ..\\z_tools\\qemu\\fdimage0.bin \t$(MAKE) C ../z_tools/qemu install : \t$(MAKE) img \t$(IMGTOL) w a: haribote.img clean : \t $(DEL) *.bin \t $(DEL) *.lst \t $(DEL) *.obj \t $(DEL) bootpack.map \t $(DEL) bootpack.bim \t $(DEL) bootpack.hrb \t $(DEL) haribote.sys src_only : \t$(MAKE) clean \t $(DEL) haribote.img ``` ## 内存容量检查 在进行检测之前需要首先关闭高速缓存 内存检测的时候需要向内存写入数据之后读取回来, 检测是否相等, 有缓存的话会导致结果不正确, 386之前的CPU没有使用缓存 ```c #define EFLAGS_AC_BIT\t\t0x00040000 #define CR0_CACHE_DISABLE\t0x60000000 unsigned int memtest(unsigned int start, unsigned int end) { \tchar flg486 0; \tunsigned int eflg, cr0, i; \t/* 检测CPU的版本 */ \teflg io_load_eflags();\t/* 获取标志位 */ \teflg EFLAGS_AC_BIT; /* AC bit 1 */ \tio_store_eflags(eflg); \teflg io_load_eflags(); \tif ((eflg & EFLAGS_AC_BIT) ! 0) { /* 如果是386把AC设置为1会自己返回到0 */ \t\tflg486 1; \t} \teflg & ~EFLAGS_AC_BIT; /* AC bit 0恢复原状 */ \tio_store_eflags(eflg); \tif (flg486 ! 0) { \t\tcr0 load_cr0(); \t\tcr0 CR0_CACHE_DISABLE; /* 禁止缓存 */ \t\tstore_cr0(cr0); \t} \ti memtest_sub(start, end); \tif (flg486 ! 0) { \t\tcr0 load_cr0(); \t\tcr0 & ~CR0_CACHE_DISABLE; /* キャッシュ許可 */ \t\tstore_cr0(cr0); \t} \treturn i; } unsigned int memtest_sub(unsigned int start, unsigned int end) { \tunsigned int i, *p, old, pat0 0xaa55aa55, pat1 0x55aa55aa; \tfor (i start; i < end; i + 0x1000) {//这里一次检测的是4KB, 为了加快检测的速度 \t\tp (unsigned int *) (i + 0xffc);//只检测每一块的最后几位 \t\told *p;\t\t\t/* 记住修改前的值 */ \t\t*p pat0;\t\t\t/* 试写 */ \t\t*p ^ 0xffffffff;\t/* 反转 */ \t\tif (*p ! pat1) {\t/* 反転結果检查反转的结果 */ not_memory: \t\t\t*p old; \t\t\tbreak; \t\t} \t\t*p ^ 0xffffffff;\t/* 再次反转 */ \t\tif (*p ! pat0) {\t/* 检测是否复原 */ \t\t\tgoto not_memory; \t\t} \t\t*p old;\t\t\t/* 恢复修改前的值 */ \t} \treturn i; } ``` ![image 20230817165049390](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259065.png) ```assembly _load_cr0:\t\t; int load_cr0(void); \t\tMOV\t\tEAX,CR0 \t\tRET _store_cr0:\t\t; void store_cr0(int cr0); \t\tMOV\t\tEAX,[ESP+4] \t\tMOV\t\tCR0,EAX \t\tRET ``` ```c i memtest(0x00400000, 0xbfffffff) / (1024 * 1024); sprintf(s, \"memory %dMB\", i); putfonts8_asc(binfo >vram, binfo >scrnx, 0, 32, COL8_FFFFFF, s); ``` > 但是这样处理编译器会自动忽略翻转以及填充的动作,所以把程序改为汇编程序 ## 汇编免除优化 ```assembly _memtest_sub:\t; unsigned int memtest_sub(unsigned int start, unsigned int end) \t\tPUSH\tEDI\t\t\t\t\t\t; （EBX, ESI, EDI 需要使用, 所以进行保留） \t\tPUSH\tESI \t\tPUSH\tEBX \t\tMOV\t\tESI,0xaa55aa55\t\t\t; pat0 0xaa55aa55; \t\tMOV\t\tEDI,0x55aa55aa\t\t\t; pat1 0x55aa55aa; \t\tMOV\t\tEAX,[ESP+12+4]\t\t\t; i start; mts_loop: \t\tMOV\t\tEBX,EAX \t\tADD\t\tEBX,0xffc\t\t\t\t; p i + 0xffc; \t\tMOV\t\tEDX,[EBX]\t\t\t\t; old *p; \t\tMOV\t\t[EBX],ESI\t\t\t\t; *p pat0; \t\tXOR\t\tDWORD [EBX],0xffffffff\t; *p ^ 0xffffffff; \t\tCMP\t\tEDI,[EBX]\t\t\t\t; if (*p ! pat1) goto fin; \t\tJNE\t\tmts_fin \t\tXOR\t\tDWORD [EBX],0xffffffff\t; *p ^ 0xffffffff; \t\tCMP\t\tESI,[EBX]\t\t\t\t; if (*p ! pat0) goto fin; \t\tJNE\t\tmts_fin \t\tMOV\t\t[EBX],EDX\t\t\t\t; *p old; \t\tADD\t\tEAX,0x1000\t\t\t\t; i + 0x1000; \t\tCMP\t\tEAX,[ESP+12+8]\t\t\t; if (i < end) goto mts_loop; \t\tJBE\t\tmts_loop \t\tPOP\t\tEBX \t\tPOP\t\tESI \t\tPOP\t\tEDI \t\tRET mts_fin: \t\tMOV\t\t[EBX],EDX\t\t\t\t; *p old; \t\tPOP\t\tEBX \t\tPOP\t\tESI \t\tPOP\t\tEDI \t\tRET ``` ### 使用的方法 1. 使用一个数组, 4KB为一个单位, 使用的话就进行标记, 但是数组的占用内存很大 2. 链表管理方法, 把地址的信息记录在链表里面 ```c #define MEMMAN_FREES\t\t4090\t/* 大约专用32KB */ #define MEMMAN_ADDR\t\t\t0x003c0000 struct FREEINFO {\t/* 可以使用的信息 */ \tunsigned int addr, size; }; struct MEMMAN {\t\t/* 内存管理 */ \tint frees, maxfrees, lostsize, losts; \tstruct FREEINFO free[MEMMAN_FREES]; }; void memman_init(struct MEMMAN *man) { \tman >frees 0;\t\t\t/* 可用的信息为0 */ \tman >maxfrees 0;\t\t/* 用于观察可用的状况,frees的最大值 */ \tman >lostsize 0;\t\t/* 释放失败的内存的大小 */ \tman >losts 0;\t\t\t/* 释放失败的次数 */ \treturn; } unsigned int memman_total(struct MEMMAN *man) /* 报告剩余内存的大小 */ { \tunsigned int i, t 0; \tfor (i 0; i < man >frees; i++) { \t\tt + man >free[i].size; \t} \treturn t; } unsigned int memman_alloc(struct MEMMAN *man, unsigned int size) /* 分配 */ { \tunsigned int i, a; \tfor (i 0; i < man >frees; i++) { \t\tif (man >free[i].size > size) { \t\t\t/* 找到足够大的内存 */ \t\t\ta man >free[i].addr; \t\t\tman >free[i].addr + size; \t\t\tman >free[i].size size; \t\t\tif (man >free[i].size 0) { \t\t\t\t/* free[i]全部使用掉饿了 */ \t\t\t\tman >frees ; \t\t\t\tfor (; i < man >frees; i++) { \t\t\t\t\tman >free[i] man >free[i + 1]; /* 结构体重整 */ \t\t\t\t} \t\t\t} \t\t\treturn a; \t\t} \t} \treturn 0; /* あきがない */ } int memman_free(struct MEMMAN *man, unsigned int addr, unsigned int size) /* 释放内存 */ { \tint i, j; \t/* 为了方便管理, 将free按照地址的顺序进行管理 */ \t/* 首先确定内存的位置 */ \tfor (i 0; i < man >frees; i++) { \t\tif (man >free[i].addr > addr) { \t\t\tbreak; \t\t} \t} \t/* free[i 1].addr < addr < free[i].addr, 插入的地址位于这两个之间 */ \tif (i > 0) { \t\t/* 前面有可以使用的内存 */ \t\tif (man >free[i 1].addr + man >free[i 1].size addr) { \t\t\t/* 和前面的内存合并 */ \t\t\tman >free[i 1].size + size; \t\t\tif (i < man >frees) { \t\t\t\t/* 检查后面 */ \t\t\t\tif (addr + size man >free[i].addr) { \t\t\t\t\t/* 可以和后面的融合 */ \t\t\t\t\tman >free[i 1].size + man >free[i].size; \t\t\t\t\t/* man >free[i]删除 */ \t\t\t\t\t/* free[i]变成0归纳道歉卖你 */ \t\t\t\t\tman >frees ; \t\t\t\t\tfor (; i < man >frees; i++) { \t\t\t\t\t\tman >free[i] man >free[i + 1]; /* 構造体の代入 */ \t\t\t\t\t} \t\t\t\t} \t\t\t} \t\t\treturn 0; /* 成功了 */ \t\t} \t} \t/* 前面的不可以合并 */ \tif (i < man >frees) { \t\t/* 后面还有 */ \t\tif (addr + size man >free[i].addr) { \t\t\t/* 可以和后面的融合 */ \t\t\tman >free[i].addr addr; \t\t\tman >free[i].size + size; \t\t\treturn 0; /* 成功了 */ \t\t} \t} \t/* 不可以进行归纳 */ \tif (man >frees < MEMMAN_FREES) { \t\t/* free[i]之后的、向右移动、腾出空间 */ \t\tfor (j man >frees; j > i; j ) { \t\t\tman >free[j] man >free[j 1]; \t\t} \t\tman >frees++; \t\tif (man >maxfrees < man >frees) { \t\t\tman >maxfrees man >frees; /* 更新最大值 */ \t\t} \t\tman >free[i].addr addr; \t\tman >free[i].size size; \t\treturn 0; /* 成功終了 */ \t} \t/* 不能向后移动 */ \tman >losts++; \tman >lostsize + size; \treturn 1; /* 失敗了 */ } ``` ```c unsigned int memtotal; struct MEMMAN *memman (struct MEMMAN *) MEMMAN_ADDR;\t\t\t\t//初始化管理的结构体 memtotal memtest(0x00400000, 0xbfffffff);\t\t\t//获得可以使用的内存的大小 memman_init(memman);\t\t\t\t\t\t\t\t//初始化 ?置所有?0 memman_free(memman, 0x00001000, 0x0009e000); /* 0x00001000 0x0009efff */ memman_free(memman, 0x00400000, memtotal 0x00400000);//保存可以使用的内存 ```"},"/note/嵌入式/第三方移植/MySTMOS/2023-8-23-day12定时器.html":{"title":"day12定时器","content":" layout: post title: \"day12定时器\" date: 2023 8 23 15:39:08 +0800 tags: MyOS # 2023 8 23 day12定时器 ## 使用定时器 计算机获得准确时间的方式, 使用电脑的定时器, 需要对PIT(Prongrammable Interval Timer)进行设置, 连接IRQ的0号 实际的操作 + 设置AL 0x43, OUT 0x43, AL + 设置AL 中断周期的低八位, OUT 0x40, AL + 设置AL 中断周期的高八位, OUT 0x40, AL ```c //初始化定时器, 依次对寄存器写入对应的数据 #define PIT_CTRL\t0x0043 #define PIT_CNT0\t0x0040 void init_pit(void) { \tio_out8(PIT_CTRL, 0x34); \tio_out8(PIT_CNT0, 0x9c); \tio_out8(PIT_CNT0, 0x2e); \treturn; } void inthandler20(int *esp) { \tio_out8(PIC0_OCW2, 0x60);\t/* IRQ 00接收到了信号 */ \t/* 暂时什么也不做 */ \treturn; } ``` ```c _asm_inthandler20: \t\tPUSH\tES \t\tPUSH\tDS \t\tPUSHAD \t\tMOV\t\tEAX,ESP \t\tPUSH\tEAX \t\tMOV\t\tAX,SS \t\tMOV\t\tDS,AX \t\tMOV\t\tES,AX \t\tCALL\t_inthandler20 \t\tPOP\t\tEAX \t\tPOPAD \t\tPOP\t\tDS \t\tPOP\t\tES \t\tIRETD ``` ```c void HariMain(void) { ... \tinit_gdtidt(); \tinit_pic(); \tio_sti(); /* 解除CPU的所有中断 */ \tfifo8_init(&keyfifo, 32, keybuf); \tfifo8_init(&mousefifo, 128, mousebuf); \tinit_pit(); \tio_out8(PIC0_IMR, 0xf8); /* 在这里打开端口0的屏蔽(11111000) */ \tio_out8(PIC1_IMR, 0xef); /* (11101111) */ ... } ``` ```c void init_gdtidt(void) { \tstruct SEGMENT_DESCRIPTOR *gdt (struct SEGMENT_DESCRIPTOR *) ADR_GDT; \tstruct GATE_DESCRIPTOR *idt (struct GATE_DESCRIPTOR *) ADR_IDT; \tint i; \t/* GDTの初期化 */ \tfor (i 0; i < LIMIT_GDT / 8; i++) { \t\tset_segmdesc(gdt + i, 0, 0, 0); \t} \tset_segmdesc(gdt + 1, 0xffffffff, 0x00000000, AR_DATA32_RW); \tset_segmdesc(gdt + 2, LIMIT_BOTPAK, ADR_BOTPAK, AR_CODE32_ER); \tload_gdtr(LIMIT_GDT, ADR_GDT); \t/* IDT */ \tfor (i 0; i < LIMIT_IDT / 8; i++) { \t\tset_gatedesc(idt + i, 0, 0, 0); \t} \tload_idtr(LIMIT_IDT, ADR_IDT); \t/* IDT */ \tset_gatedesc(idt + 0x20, (int) asm_inthandler20, 2 * 8, AR_INTGATE32); \tset_gatedesc(idt + 0x21, (int) asm_inthandler21, 2 * 8, AR_INTGATE32); \tset_gatedesc(idt + 0x27, (int) asm_inthandler27, 2 * 8, AR_INTGATE32); \tset_gatedesc(idt + 0x2c, (int) asm_inthandler2c, 2 * 8, AR_INTGATE32); \treturn; } ``` > 添加进中断向量表 ## 添加时间的计算标志位 ```c struct TIMERCTL { \tunsigned int count; }; struct TIMERCTL timerctl; ``` > 初始化为0, 中断中每次加一\t ## 添加超时 ```c struct TIMERCTL { \tunsigned int count; \tunsigned int timeout; \tstruct FIFO8 *fifo; \tunsigned char data; }; ``` > 在处理的时候同时进行count++, 以及timeout ```c void inthandler20(int *esp) { \tio_out8(PIC0_OCW2, 0x60);\t/* 清除中断 */ \ttimerctl.count++; \tif (timerctl.timeout > 0) { /* 检测是否开启了时钟超时 */ \t\ttimerctl.timeout ; \t\tif (timerctl.timeout 0) { \t\t\tfifo8_put(timerctl.fifo, timerctl.data); \t\t} \t} \treturn; } void settimer(unsigned int timeout, struct FIFO8 *fifo, unsigned char data) { \tint eflags; \teflags io_load_eflags(); \tio_cli(); \ttimerctl.timeout timeout; \ttimerctl.fifo fifo; \ttimerctl.data data; \tio_store_eflags(eflags); \treturn; } ``` ## 设置多个定时器 ```c #define MAX_TIMER\t\t500 struct TIMER { \tunsigned int timeout, flags; \tstruct FIFO8 *fifo; \tunsigned char data; }; struct TIMERCTL { \tunsigned int count; \tstruct TIMER timer[MAX_TIMER]; }; ``` ```c #define TIMER_FLAGS_ALLOC\t\t1\t/* 已经配置了的状态 */ #define TIMER_FLAGS_USING\t\t2\t/* 定时器运行中 */ void init_pit(void) { \tint i; \tio_out8(PIT_CTRL, 0x34); \tio_out8(PIT_CNT0, 0x9c); \tio_out8(PIT_CNT0, 0x2e); \ttimerctl.count 0; \tfor (i 0; i < MAX_TIMER; i++) { \t\ttimerctl.timer[i].flags 0; /* 未使用 */ \t} \treturn; } struct TIMER *timer_alloc(void) { \tint i; \tfor (i 0; i < MAX_TIMER; i++) { \t\tif (timerctl.timer[i].flags 0) { \t\t\ttimerctl.timer[i].flags TIMER_FLAGS_ALLOC; \t\t\treturn &timerctl.timer[i]; \t\t} \t} \treturn 0; /* 申请失败 */ } void timer_free(struct TIMER *timer) { \ttimer >flags 0; /* 未使用 */ \treturn; } void timer_init(struct TIMER *timer, struct FIFO8 *fifo, unsigned char data) { \ttimer >fifo fifo; \ttimer >data data; \treturn; } void timer_settime(struct TIMER *timer, unsigned int timeout) { \ttimer >timeout timeout; \ttimer >flags TIMER_FLAGS_USING; \treturn; } void inthandler20(int *esp) { \tint i; \tio_out8(PIC0_OCW2, 0x60);\t/* 清除中断 */ \ttimerctl.count++; \tfor (i 0; i < MAX_TIMER; i++) { \t\tif (timerctl.timer[i].flags TIMER_FLAGS_USING) { \t\t\ttimerctl.timer[i].timeout ; \t\t\tif (timerctl.timer[i].timeout 0) { \t\t\t\ttimerctl.timer[i].flags TIMER_FLAGS_ALLOC; \t\t\t\tfifo8_put(timerctl.timer[i].fifo, timerctl.timer[i].data); \t\t\t} \t\t} \t} \treturn; } ``` ## 再次加快中断处理 ```c void inthandler20(int *esp) { \tint i, j; \tio_out8(PIC0_OCW2, 0x60);\t/* IRQ 00受付完了をPICに通知 */ \ttimerctl.count++; \tif (timerctl.next > timerctl.count) { \t\treturn; \t} \tfor (i 0; i < timerctl.using; i++) { \t\t/* 获得时间结束的所有时钟的个数 */ \t\tif (timerctl.timers[i] >timeout > timerctl.count) { \t\t\tbreak; \t\t} \t\t/* 处理时间到的时钟 */ \t\ttimerctl.timers[i] >flags TIMER_FLAGS_ALLOC; \t\tfifo8_put(timerctl.timers[i] >fifo, timerctl.timers[i] >data); \t} \t/* 获取下一次的时钟提示时间 */ \ttimerctl.using i; \tfor (j 0; j < timerctl.using; j++) { \t\ttimerctl.timers[j] timerctl.timers[i + j]; \t} \tif (timerctl.using > 0) { \t\ttimerctl.next timerctl.timers[0] >timeout; \t} else { \t\ttimerctl.next 0xffffffff; \t} \treturn; } ``` ```c void timer_settime(struct TIMER *timer, unsigned int timeout) { \tint e, i, j; \ttimer >timeout timeout + timerctl.count; \ttimer >flags TIMER_FLAGS_USING; \te io_load_eflags(); \tio_cli(); \t/* 获得插入的位置 */ \tfor (i 0; i < timerctl.using; i++) { \t\tif (timerctl.timers[i] >timeout > timer >timeout) { \t\t\tbreak; \t\t} \t} \t/* 重新排序 */ \tfor (j timerctl.using; j > i; j ) { \t\ttimerctl.timers[j] timerctl.timers[j 1]; \t} \ttimerctl.using++; \t/* 设置下一次的时间 */ \ttimerctl.timers[i] timer; \ttimerctl.next timerctl.timers[0] >timeout; \tio_store_eflags(e); \treturn; } ```"},"/note/嵌入式/第三方移植/MySTMOS/2023-8-25-day14高分辨率以及键盘输入.html":{"title":"day14高分辨率以及键盘输入","content":" layout: post title: \"day14高分辨率以及键盘输入\" date: 2023 8 25 15:39:08 +0800 tags: MyOS # day14高分辨率以及键盘输入 ## 提高系统的分辨率 ```assembly ; 画面 \t\tMOV\t\tBX,0x4101\t\t \t\tMOV\t\tAX,0x4f02 \t\tINT\t\t0x10\t\t\t; 使用这两个数字就可以进行调整 \t\tMOV\t\tBYTE [VMODE],8\t; 保存画面的信息 \t\tMOV\t\tWORD [SCRNX],640 \t\tMOV\t\tWORD [SCRNY],480 \t\tMOV\t\tDWORD [VRAM],0xe0000000 ``` > 在最初的时候, 所有的公司使用的是IBM公司的标准, 但是之后有的公司制作的显卡的性能超过了IBM, 使得自己设定显卡的模式设定, 之后VESA协会出台, 制作专门的BIOS, 可以利用它进行提高分辨率, 成为VBE > > 切换到不适用VBE的模式, 设置AH 0, AL 画面号码, 使用AH 0x4f02, BX 画面号码 > > + 0x101 640x480 8bit > + 0x103 800x600 8bit > + 0x105 1024x768 8bit > + 0x107 1280x1024 8bit > > 在虚拟机使用的时候需要加上0x4000 ```assembly ; 检测VBE是否存在 \t\tMOV\t\tAX,0x9000 \t\tMOV\t\tES,AX \t\tMOV\t\tDI,0 \t\tMOV\t\tAX,0x4f00 \t\tINT\t\t0x10 \t\tCMP\t\tAX,0x004f \t\tJNE\t\tscrn320 ``` > 存在的话AX会变为0x004f ```assembly \t\tMOV\t\tAX,[ES:DI+4] \t\tCMP\t\tAX,0x0200 \t\tJB\t\tscrn320\t\t\t; if (AX < 0x0200) goto scrn320 ``` > 检测版本, 版本过低就进行跳转 ```assembly \t\tMOV\t\tCX,VBEMODE \t\tMOV\t\tAX,0x4f01 \t\tINT\t\t0x10 \t\tCMP\t\tAX,0x004f \t\tJNE\t\tscrn320 ``` > 在这里检测模式是否可用, 信息会被放在[ES:DI]开始的256个字节里面 > > + [ES:DI + 0x00] 模式的属性, bit7是1, 因为在设置的时候需要加上0x4000 > + [ES:DI + 0x12] X的分辨率 > + [ES:DI + 0x14] Y的分辨率 > + [ES:DI + 0x19] 颜色数 > + [ES:DI + 0x1b] 颜色的指定方法, 必须为4 > + [ES:DI + 0x28] VRAM的地址 ```assembly \t\tCMP\t\tBYTE [ES:DI+0x19],8 \t\tJNE\t\tscrn320 \t\tCMP\t\tBYTE [ES:DI+0x1b],4 \t\tJNE\t\tscrn320 \t\tMOV\t\tAX,[ES:DI+0x00] \t\tAND\t\tAX,0x0080 \t\tJZ\t\tscrn320\t\t\t; bit7是0所以放弃 ``` > 对信息进行确认, 失败的话仍使用原来的模式 ```assembly \t\tMOV\t\tBX,VBEMODE+0x4000 \t\tMOV\t\tAX,0x4f02 \t\tINT\t\t0x10 \t\tMOV\t\tBYTE [VMODE],8\t; 进行切换 \t\tMOV\t\tAX,[ES:DI+0x12] \t\tMOV\t\t[SCRNX],AX \t\tMOV\t\tAX,[ES:DI+0x14] \t\tMOV\t\t[SCRNY],AX \t\tMOV\t\tEAX,[ES:DI+0x28] \t\tMOV\t\t[VRAM],EAX \t\tJMP\t\tkeystatus ``` > 切换之后记录下各种信息 ## 键盘输入 键盘按下抬起的时候传回去不同的数字 ```c if (256 < i && i < 511) { /* 处理的数字来自键盘 */ sprintf(s, \"%02X\", i 256); putfonts8_asc_sht(sht_back, 0, 16, COL8_FFFFFF, COL8_008484, s, 2);//打印出得到的数字 if (i 0x1e + 256) { putfonts8_asc_sht(sht_win, 40, 28, COL8_000000, COL8_C6C6C6, \"A\", 1);//获得的按键是A } } ``` > 对键盘的数字进行处理 ```c static char keytable[0x54] { 0, 0, '1', '2', '3', '4', '5', '6', '7', '8', '9', '0', ' ', '^', 0, 0, 'Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P', '@', '[', 0, 0, 'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', ';', ':', 0, 0, ']', 'Z', 'X', 'C', 'V', 'B', 'N', 'M', ',', '.', '/', 0, '*', 0, ' ', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '7', '8', '9', ' ', '4', '5', '6', '+', '1', '2', '3', '0', '.' }; if (256 < i && i < 511) { /* キーボードデータ */ sprintf(s, \"%02X\", i 256); putfonts8_asc_sht(sht_back, 0, 16, COL8_FFFFFF, COL8_008484, s, 2); if (i < 256 + 0x54) { if (keytable[i 256] ! 0) { s[0] keytable[i 256]; s[1] 0; putfonts8_asc_sht(sht_win, 40, 28, COL8_000000, COL8_C6C6C6, s, 1); } } } ``` ## 实现退格 ```c if (256 < i && i < 511) { /* キーボードデータ */ sprintf(s, \"%02X\", i 256); putfonts8_asc_sht(sht_back, 0, 16, COL8_FFFFFF, COL8_008484, s, 2); if (i < 0x54 + 256) { if (keytable[i 256] ! 0 && cursor_x < 144) { /* 通常文字 */ /* 文字进行显示 */ s[0] keytable[i 256]; s[1] 0; putfonts8_asc_sht(sht_win, cursor_x, 28, COL8_000000, COL8_FFFFFF, s, 1); cursor_x + 8;//设置打印的位置 } } if (i 256 + 0x0e && cursor_x > 8) { /* バックスペース */ /* 如果这个是退格键, 这是为了删去光标 */ putfonts8_asc_sht(sht_win, cursor_x, 28, COL8_000000, COL8_FFFFFF, \" \", 1); cursor_x 8; } /* 光标再次显示 */ boxfill8(sht_win >buf, sht_win >bxsize, cursor_c, cursor_x, 28, cursor_x + 7, 43); sheet_refresh(sht_win, cursor_x, 28, cursor_x + 8, 44); } ``` ```c // 这个函数是在窗口中绘制一个文本框 void make_textbox8(struct SHEET *sht, int x0, int y0, int sx, int sy, int c) { \tint x1 x0 + sx, y1 y0 + sy; \tboxfill8(sht >buf, sht >bxsize, COL8_848484, x0 2, y0 3, x1 + 1, y0 3); \tboxfill8(sht >buf, sht >bxsize, COL8_848484, x0 3, y0 3, x0 3, y1 + 1); \tboxfill8(sht >buf, sht >bxsize, COL8_FFFFFF, x0 3, y1 + 2, x1 + 1, y1 + 2); \tboxfill8(sht >buf, sht >bxsize, COL8_FFFFFF, x1 + 2, y0 3, x1 + 2, y1 + 2); \tboxfill8(sht >buf, sht >bxsize, COL8_000000, x0 1, y0 2, x1 + 0, y0 2); \tboxfill8(sht >buf, sht >bxsize, COL8_000000, x0 2, y0 2, x0 2, y1 + 0); \tboxfill8(sht >buf, sht >bxsize, COL8_C6C6C6, x0 2, y1 + 1, x1 + 0, y1 + 1); \tboxfill8(sht >buf, sht >bxsize, COL8_C6C6C6, x1 + 1, y0 2, x1 + 1, y1 + 1); \tboxfill8(sht >buf, sht >bxsize, c, x0 1, y0 1, x1 + 0, y1 + 0); \treturn; } ``` ## 增加鼠标移动窗口 ```c if (512 < i && i < 767) { /* マウスデータ */ if (mouse_decode(&mdec, i 512) ! 0) { /* データが3バイト揃ったので表示 */ sprintf(s, \"[lcr %4d %4d]\", mdec.x, mdec.y); if ((mdec.btn & 0x01) ! 0) { s[1] 'L'; } if ((mdec.btn & 0x02) ! 0) { s[3] 'R'; } if ((mdec.btn & 0x04) ! 0) { s[2] 'C'; } putfonts8_asc_sht(sht_back, 32, 16, COL8_FFFFFF, COL8_008484, s, 15); /* 记录鼠标的移动 */ mx + mdec.x; my + mdec.y; if (mx < 0) { mx 0; } if (my < 0) { my 0; } if (mx > binfo >scrnx 1) { mx binfo >scrnx 1; } if (my > binfo >scrny 1) { my binfo >scrny 1; } sprintf(s, \"(%3d, %3d)\", mx, my); putfonts8_asc_sht(sht_back, 0, 0, COL8_FFFFFF, COL8_008484, s, 10); sheet_slide(sht_mouse, mx, my); if ((mdec.btn & 0x01) ! 0) { /* 鼠标左键按下 */ sheet_slide(sht_win, mx 80, my 8); } } } ```"},"/note/嵌入式/第三方移植/MySTMOS/2023-8-26-day15多任务.html":{"title":"day15多任务","content":" layout: post title: \"day15多任务\" date: 2023 8 26 15:39:08 +0800 tags: MyOS # day15多任务 ## 任务切换 任务状态段TSS, 有16位和32位两个版本, 也是内存的一部分, 在定义了GDT之后使用 ```c struct TSS32 { //这一行的保存任务设置相关的信息 \tint backlink, esp0, ss0, esp1, ss1, esp2, ss2, cr3; \t//32位的寄存器, epi记录执行到的位置 int eip, eflags, eax, ecx, edx, ebx, esp, ebp, esi, edi; \t//16位的寄存器 int es, cs, ss, ds, fs, gs; //任务设置相关的, 设置为0和0x40000000 \tint ldtr, iomap; }; ``` > 实际上切换任务就是使用JMP改变EIP, 有两种, 只改变EIP的叫做near模式, 同时改变CS的叫做far模式 > > JMP跳转的位置是TSS的话就会进行任务切换 ```c struct TSS32 tss_a, tss_b; tss_a.ldtr 0; tss_a.iomap 0x40000000; tss_b.ldtr 0; tss_b.iomap 0x40000000; ``` ```c #define AR_TSS32\t\t0x0089 struct SEGMENT_DESCRIPTOR *gdt (struct SEGMENT_DESCRIPTOR *) ADR_GDT; //设置两个段 set_segmdesc(gdt + 3, 103, (int) &tss_a, AR_TSS32); set_segmdesc(gdt + 4, 103, (int) &tss_b, AR_TSS32); load_tr(3 * 8); ``` ```assembly _load_tr:\t\t; void load_tr(int tr); \t\tLTR\t\t[ESP+4]\t\t\t; tr \t\tRET ``` > 这个是向task register任务寄存器TR写入GDT的值, 需要乘8, 这时候切换任务会自动记录当前的值 ```c _taskswitch4:\t; void taskswitch4(void); \t\tJMP\t\t4*8:0 \t\tRET ``` > RET这个是在任务结束之后可能会返回, 之后返回C的主函数 ```c //申请一个栈\t task_b_esp memman_alloc_4k(memman, 64 * 1024) + 64 * 1024; //这里直接设置为栈的尾部 //这个是返回的位置 tss_b.eip (int) &task_b_main; tss_b.eflags 0x00000202; /* IF 1; */ tss_b.eax 0; tss_b.ecx 0; tss_b.edx 0; tss_b.ebx 0; tss_b.esp task_b_esp; tss_b.ebp 0; tss_b.esi 0; tss_b.edi 0; tss_b.es 1 * 8; tss_b.cs 2 * 8; tss_b.ss 1 * 8; tss_b.ds 1 * 8; tss_b.fs 1 * 8; tss_b.gs 1 * 8; ``` > 在这里设置的段和bootpack.c相同 ## 之后设置切换回去 ```c void task_b_main(void) { \tstruct FIFO32 fifo; \tstruct TIMER *timer; \tint i, fifobuf[128]; \tfifo32_init(&fifo, 128, fifobuf); \ttimer timer_alloc(); \ttimer_init(timer, &fifo, 1); \ttimer_settime(timer, 500); \tfor (;;) { \t\tio_cli(); \t\tif (fifo32_status(&fifo) 0) { \t\t\tio_sti(); \t\t\tio_hlt(); \t\t} else { \t\t\ti fifo32_get(&fifo); \t\t\tio_sti(); \t\t\tif (i 1) { /* 5秒タイムアウト */ \t\t\t\ttaskswitch3(); /* タスクAにもどる */ \t\t\t} \t\t} \t} } ``` ```c _taskswitch3:\t; void taskswitch3(void); \t\tJMP\t\t3*8:0 \t\tRET ``` ## 抽象切换任务 ```c _farjmp:\t\t; void farjmp(int eip, int cs); \t\tJMP\t\tFAR\t[ESP+4]\t\t\t\t; eip, cs \t\tRET ``` ```c if (i 2) { farjmp(0, 4 * 8); timer_settime(timer_ts, 2); } ``` > 时间到就进行切换, 切换回来之后设置另一个定时器 ```c void task_b_main(void) { \tstruct FIFO32 fifo; \tstruct TIMER *timer_ts; \tint i, fifobuf[128]; \tfifo32_init(&fifo, 128, fifobuf); \ttimer_ts timer_alloc(); \ttimer_init(timer_ts, &fifo, 1); \ttimer_settime(timer_ts, 2); \tfor (;;) { \t\tio_cli(); \t\tif (fifo32_status(&fifo) 0) { \t\t\tio_sti(); \t\t\tio_hlt(); \t\t} else { \t\t\ti fifo32_get(&fifo); \t\t\tio_sti(); \t\t\tif (i 1) { /* 时间到了 */ \t\t\t\tfarjmp(0, 3 * 8); \t\t\t\ttimer_settime(timer_ts, 2); \t\t\t} \t\t} \t} } ``` ## 实现在任务中打印 需要传递图层的结构体 ```c //把图层的信息存储在这个位置 *((int *) 0x0fec) (int) sht_back; void task_b_main(void) { \tstruct FIFO32 fifo; \tstruct TIMER *timer_ts; \tint i, fifobuf[128], count 0; \tchar s[11]; \tstruct SHEET *sht_back; \tfifo32_init(&fifo, 128, fifobuf); \ttimer_ts timer_alloc(); \ttimer_init(timer_ts, &fifo, 1); \ttimer_settime(timer_ts, 2); //获取图层 \tsht_back (struct SHEET *) *((int *) 0x0fec); \tfor (;;) { \t\tcount++; \t\tsprintf(s, \"%10d\", count); \t\tputfonts8_asc_sht(sht_back, 0, 144, COL8_FFFFFF, COL8_008484, s, 10); \t\tio_cli(); \t\tif (fifo32_status(&fifo) 0) { \t\t\tio_sti(); \t\t} else { \t\t\ti fifo32_get(&fifo); \t\t\tio_sti(); \t\t\tif (i 1) { /* 任务的时间到了 */ \t\t\t\tfarjmp(0, 3 * 8); \t\t\t\ttimer_settime(timer_ts, 2); \t\t\t} \t\t} \t} } ``` ## 减少不必要的打印 ```c void task_b_main(struct SHEET *sht_back) { \tstruct FIFO32 fifo; \tstruct TIMER *timer_ts, *timer_put; \tint i, fifobuf[128], count 0; \tchar s[12]; \tfifo32_init(&fifo, 128, fifobuf); \ttimer_ts timer_alloc(); \ttimer_init(timer_ts, &fifo, 2); \ttimer_settime(timer_ts, 2); \ttimer_put timer_alloc(); \ttimer_init(timer_put, &fifo, 1); \ttimer_settime(timer_put, 1); \tfor (;;) { \t\tcount++; \t\tio_cli(); \t\tif (fifo32_status(&fifo) 0) { \t\t\tio_sti(); \t\t} else { \t\t\ti fifo32_get(&fifo); \t\t\tio_sti(); \t\t\tif (i 1) { \t\t\t\tsprintf(s, \"%11d\", count); \t\t\t\tputfonts8_asc_sht(sht_back, 0, 144, COL8_FFFFFF, COL8_008484, s, 11); \t\t\t\ttimer_settime(timer_put, 1); \t\t\t} else if (i 2) { \t\t\t\tfarjmp(0, 3 * 8); \t\t\t\ttimer_settime(timer_ts, 2); \t\t\t} \t\t} \t} ``` ## 改变传递的方式 在Intel架构里面传递的信息是在ESP+4的位置, 所以可以使用这个方式进行传递, ESP记录的是返回的地址 ```c \ttask_b_esp memman_alloc_4k(memman, 64 * 1024) + 64 * 1024 8; \ttss_b.eip (int) &task_b_main; \ttss_b.eflags 0x00000202; /* IF 1; */ \ttss_b.eax 0; \ttss_b.ecx 0; \ttss_b.edx 0; \ttss_b.ebx 0; \ttss_b.esp task_b_esp; \ttss_b.ebp 0; \ttss_b.esi 0; \ttss_b.edi 0; \ttss_b.es 1 * 8; \ttss_b.cs 2 * 8; \ttss_b.ss 1 * 8; \ttss_b.ds 1 * 8; \ttss_b.fs 1 * 8; \ttss_b.gs 1 * 8; //在这里设置传入的数据 \t*((int *) (task_b_esp + 4)) (int) sht_back; ``` > 如果在最初的时候减的是4会在最后导致溢出, 因为这里的内存计算是从0开始的 ```c int mt_tr; void mt_init(void) { //初始化一个计数器 \tmt_timer timer_alloc(); \t/* timer_init设置一个时间 */ \ttimer_settime(mt_timer, 2); // 初始化主任务 \tmt_tr 3 * 8; \treturn; } //切换的函数 void mt_taskswitch(void) { \tif (mt_tr 3 * 8) { \t\tmt_tr 4 * 8; \t} else { \t\tmt_tr 3 * 8; \t} \ttimer_settime(mt_timer, 2); \tfarjmp(0, mt_tr); \treturn; } ``` ## 进阶任务切换 ```c void inthandler20(int *esp) { \tstruct TIMER *timer; \tchar ts 0; \tio_out8(PIC0_OCW2, 0x60);\t/* IRQ 00受付完了をPICに通知 */ \ttimerctl.count++; \tif (timerctl.next > timerctl.count) { \t\treturn; \t} \ttimer timerctl.t0; /* とりあえず先頭の番地をtimerに代入 */ \tfor (;;) { \t\t/* timers循环找到 */ \t\tif (timer >timeout > timerctl.count) { \t\t\tbreak; \t\t} \t\t/* タイムアウト */ \t\ttimer >flags TIMER_FLAGS_ALLOC; \t\tif (timer ! mt_timer) { \t\t\tfifo32_put(timer >fifo, timer >data); \t\t} else { \t\t\tts 1; /* 这个是任务切换的时间到了 */ \t\t} \t\ttimer timer >next; /* 更新下一个是时钟 */ \t} \ttimerctl.t0 timer; \ttimerctl.next timer >timeout; \tif (ts ! 0) { \t\tmt_taskswitch(); \t} \treturn; } ```"},"/note/嵌入式/第三方移植/MySTMOS/2023-8-19-day11制作窗口.html":{"title":"day11制作窗口","content":" layout: post title: \"day11制作窗口\" date: 2023 8 17 15:39:08 +0800 tags: MyOS # day11制作窗口 ## 优化鼠标 鼠标加入边界判定 ```c if (mx > binfo >scrnx 1) { mx binfo >scrnx 1; } if (my > binfo >scrny 1) { my binfo >scrny 1; } ``` ```c void sheet_refreshsub(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1) { \tint h, bx, by, vx, vy, bx0, by0, bx1, by1; \tunsigned char *buf, c, *vram ctl >vram; \tstruct SHEET *sht; \t/* refresh範囲が画面外にはみ出していたら補正 */ \tif (vx0 < 0) { vx0 0; } \tif (vy0 < 0) { vy0 0; } \tif (vx1 > ctl >xsize) { vx1 ctl >xsize; } \tif (vy1 > ctl >ysize) { vy1 ctl >ysize; } \tfor (h 0; h < ctl >top; h++) { \t\tsht ctl >sheets[h]; \t\tbuf sht >buf; \t\t/* vx0～vy1を使って、bx0～by1を逆算する */ \t\tbx0 vx0 sht >vx0; \t\tby0 vy0 sht >vy0; \t\tbx1 vx1 sht >vx0; \t\tby1 vy1 sht >vy0; \t\tif (bx0 < 0) { bx0 0; } \t\tif (by0 < 0) { by0 0; } \t\tif (bx1 > sht >bxsize) { bx1 sht >bxsize; } \t\tif (by1 > sht >bysize) { by1 sht >bysize; } \t\tfor (by by0; by < by1; by++) { \t\t\tvy sht >vy0 + by; \t\t\tfor (bx bx0; bx < bx1; bx++) { \t\t\t\tvx sht >vx0 + bx; \t\t\t\tc buf[by * sht >bxsize + bx]; \t\t\t\tif (c ! sht >col_inv) { \t\t\t\t\tvram[vy * ctl >xsize + vx] c; \t\t\t\t} \t\t\t} \t\t} \t} \treturn; } ``` ## 之后把两个结构体关联起来 ```c #define MAX_SHEETS\t\t256 struct SHEET { \tunsigned char *buf; \tint bxsize, bysize, vx0, vy0, col_inv, height, flags; \tstruct SHTCTL *ctl;\t//在这里添加一个接口 }; struct SHTCTL { \tunsigned char *vram; \tint xsize, ysize, top; \tstruct SHEET *sheets[MAX_SHEETS]; \tstruct SHEET sheets0[MAX_SHEETS]; }; ``` ```c struct SHTCTL *shtctl_init(struct MEMMAN *memman, unsigned char *vram, int xsize, int ysize) { \tstruct SHTCTL *ctl; \tint i; \tctl (struct SHTCTL *) memman_alloc_4k(memman, sizeof (struct SHTCTL)); \tif (ctl 0) { \t\tgoto err; \t} \tctl >vram vram; \tctl >xsize xsize; \tctl >ysize ysize; \tctl >top 1; /* 初始化为没有图层 */ \tfor (i 0; i < MAX_SHEETS; i++) { \t\tctl >sheets0[i].flags 0; /* 在这里修改标志位 */ \t\tctl >sheets0[i].ctl ctl; /* 在这里链接控制器 */ \t} err: \treturn ctl; } ``` > 之后在其他的函数里面调用的时候就比较简单了, 对其他函数进行修改 ## 显示窗口 ```c void make_window8(unsigned char *buf, int xsize, int ysize, char *title) { //这个是右上角的叉号 \tstatic char closebtn[14][16] { \t\t\"OOOOOOOOOOOOOOO@\", \t\t\"OQQQQQQQQQQQQQ$@\", \t\t\"OQQQQQQQQQQQQQ$@\", \t\t\"OQQQ@@QQQQ@@QQ$@\", \t\t\"OQQQQ@@QQ@@QQQ$@\", \t\t\"OQQQQQ@@@@QQQQ$@\", \t\t\"OQQQQQQ@@QQQQQ$@\", \t\t\"OQQQQQ@@@@QQQQ$@\", \t\t\"OQQQQ@@QQ@@QQQ$@\", \t\t\"OQQQ@@QQQQ@@QQ$@\", \t\t\"OQQQQQQQQQQQQQ$@\", \t\t\"OQQQQQQQQQQQQQ$@\", \t\t\"O$$$$$$$$$$$$$$@\", \t\t\"@@@@@@@@@@@@@@@@\" \t}; \tint x, y; \tchar c; \tboxfill8(buf, xsize, COL8_C6C6C6, 0, 0, xsize 1, 0 ); \tboxfill8(buf, xsize, COL8_FFFFFF, 1, 1, xsize 2, 1 ); \tboxfill8(buf, xsize, COL8_C6C6C6, 0, 0, 0, ysize 1); \tboxfill8(buf, xsize, COL8_FFFFFF, 1, 1, 1, ysize 2); \tboxfill8(buf, xsize, COL8_848484, xsize 2, 1, xsize 2, ysize 2); \tboxfill8(buf, xsize, COL8_000000, xsize 1, 0, xsize 1, ysize 1); \tboxfill8(buf, xsize, COL8_C6C6C6, 2, 2, xsize 3, ysize 3); \tboxfill8(buf, xsize, COL8_000084, 3, 3, xsize 4, 20 ); \tboxfill8(buf, xsize, COL8_848484, 1, ysize 2, xsize 2, ysize 2); \tboxfill8(buf, xsize, COL8_000000, 0, ysize 1, xsize 1, ysize 1); \tputfonts8_asc(buf, xsize, 24, 4, COL8_FFFFFF, title); \tfor (y 0; y < 14; y++) { \t\tfor (x 0; x < 16; x++) { \t\t\tc closebtn[y][x]; \t\t\tif (c '@') { \t\t\t\tc COL8_000000; \t\t\t} else if (c '$') { \t\t\t\tc COL8_848484; \t\t\t} else if (c 'Q') { \t\t\t\tc COL8_C6C6C6; \t\t\t} else { \t\t\t\tc COL8_FFFFFF; \t\t\t} \t\t\tbuf[(5 + y) * xsize + (xsize 21 + x)] c; \t\t} \t} \treturn; } ``` > 这个是绘制一个窗口 ## 消除闪烁 由于每一次在刷新图层的时候都是从最底层的位置开始刷新的, 所以会产生闪烁, 在之后的刷新的时候只刷新图层上方的颜色 ```c void sheet_refreshsub(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1, int h0) { \tint h, bx, by, vx, vy, bx0, by0, bx1, by1; \tunsigned char *buf, c, *vram ctl >vram; \tstruct SHEET *sht; \t/* refresh範囲が画面外にはみ出していたら補正 */ \tif (vx0 < 0) { vx0 0; } \tif (vy0 < 0) { vy0 0; } \tif (vx1 > ctl >xsize) { vx1 ctl >xsize; } \tif (vy1 > ctl >ysize) { vy1 ctl >ysize; } \tfor (h h0; h < ctl >top; h++) { \t\tsht ctl >sheets[h]; \t\tbuf sht >buf; \t\t/* vx0～vy1を使って、bx0～by1を逆算する */ \t\tbx0 vx0 sht >vx0; \t\tby0 vy0 sht >vy0; \t\tbx1 vx1 sht >vx0; \t\tby1 vy1 sht >vy0; \t\tif (bx0 < 0) { bx0 0; } \t\tif (by0 < 0) { by0 0; } \t\tif (bx1 > sht >bxsize) { bx1 sht >bxsize; } \t\tif (by1 > sht >bysize) { by1 sht >bysize; } \t\tfor (by by0; by < by1; by++) { \t\t\tvy sht >vy0 + by; \t\t\tfor (bx bx0; bx < bx1; bx++) { \t\t\t\tvx sht >vx0 + bx; \t\t\t\tc buf[by * sht >bxsize + bx]; \t\t\t\tif (c ! sht >col_inv) { \t\t\t\t\tvram[vy * ctl >xsize + vx] c; \t\t\t\t} \t\t\t} \t\t} \t} \treturn; } ``` > 添加一个参数, 记录刷新的图层的层数 ```c void sheet_slide(struct SHEET *sht, int vx0, int vy0) { \tint old_vx0 sht >vx0, old_vy0 sht >vy0; \tsht >vx0 vx0; \tsht >vy0 vy0; \tif (sht >height > 0) { /* 刷新的时候原来位置从最底层进行刷新 */ \t\tsheet_refreshsub(sht >ctl, old_vx0, old_vy0, old_vx0 + sht >bxsize, old_vy0 + sht >bysize, 0); \t\tsheet_refreshsub(sht >ctl, vx0, vy0, vx0 + sht >bxsize, vy0 + sht >bysize, sht >height); \t} \treturn; } ``` > 对调用函数的地方进行修改 > 出新问题, 刷新的图层上方的位置的图层会进行闪烁 ## 创建地图记录画面信息 这个地图用来记录地图上的某一个点是某一个图层的像素 ```c struct SHTCTL { \tunsigned char *vram, *map;//添加图层的位置 \tint xsize, ysize, top; \tstruct SHEET *sheets[MAX_SHEETS]; \tstruct SHEET sheets0[MAX_SHEETS]; }; ``` ```c struct SHTCTL *shtctl_init(struct MEMMAN *memman, unsigned char *vram, int xsize, int ysize) { \tstruct SHTCTL *ctl; \tint i; \tctl (struct SHTCTL *) memman_alloc_4k(memman, sizeof (struct SHTCTL)); \tif (ctl 0) { \t\tgoto err; \t} //在这里对内存进行申请 \tctl >map (unsigned char *) memman_alloc_4k(memman, xsize * ysize); \tif (ctl >map 0) { \t\tmemman_free_4k(memman, (int) ctl, sizeof (struct SHTCTL)); \t\tgoto err; \t} \tctl >vram vram; \tctl >xsize xsize; \tctl >ysize ysize; \tctl >top 1; /* シートは一枚もない */ \tfor (i 0; i < MAX_SHEETS; i++) { \t\tctl >sheets0[i].flags 0; /* 未使用マーク */ \t\tctl >sheets0[i].ctl ctl; /* 所属を記録 */ \t} err: \treturn ctl; } ``` ```c void sheet_refreshmap(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1, int h0) { \tint h, bx, by, vx, vy, bx0, by0, bx1, by1; \tunsigned char *buf, sid, *map ctl >map; \tstruct SHEET *sht; \tif (vx0 < 0) { vx0 0; } \tif (vy0 < 0) { vy0 0; } \tif (vx1 > ctl >xsize) { vx1 ctl >xsize; } \tif (vy1 > ctl >ysize) { vy1 ctl >ysize; } \tfor (h h0; h < ctl >top; h++) { \t\tsht ctl >sheets[h]; \t\tsid sht ctl >sheets0; /* 番地を引き算してそれを下じき番号として利用 */ \t\tbuf sht >buf; \t\tbx0 vx0 sht >vx0; \t\tby0 vy0 sht >vy0; \t\tbx1 vx1 sht >vx0; \t\tby1 vy1 sht >vy0; \t\tif (bx0 < 0) { bx0 0; } \t\tif (by0 < 0) { by0 0; } \t\tif (bx1 > sht >bxsize) { bx1 sht >bxsize; } \t\tif (by1 > sht >bysize) { by1 sht >bysize; } \t\tfor (by by0; by < by1; by++) { \t\t\tvy sht >vy0 + by; \t\t\tfor (bx bx0; bx < bx1; bx++) { \t\t\t\tvx sht >vx0 + bx; \t\t\t\tif (buf[by * sht >bxsize + bx] ! sht >col_inv) { \t\t\t\t\tmap[vy * ctl >xsize + vx] sid; \t\t\t\t} \t\t\t} \t\t} \t} \treturn; } ``` > 这个地图里面保存了最高层的图层 ```c void sheet_refreshsub(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1, int h0, int h1) { \tint h, bx, by, vx, vy, bx0, by0, bx1, by1; \tunsigned char *buf, *vram ctl >vram, *map ctl >map, sid; \tstruct SHEET *sht; \t/* refresh範囲が画面外にはみ出していたら補正 */ \tif (vx0 < 0) { vx0 0; } \tif (vy0 < 0) { vy0 0; } \tif (vx1 > ctl >xsize) { vx1 ctl >xsize; } \tif (vy1 > ctl >ysize) { vy1 ctl >ysize; } \tfor (h h0; h < h1; h++) { \t\tsht ctl >sheets[h]; \t\tbuf sht >buf; \t\tsid sht ctl >sheets0;//计算当前图层高度 \t\t/* vx0～vy1を使って、bx0～by1を逆算する */ \t\tbx0 vx0 sht >vx0; \t\tby0 vy0 sht >vy0; \t\tbx1 vx1 sht >vx0; \t\tby1 vy1 sht >vy0; \t\tif (bx0 < 0) { bx0 0; } \t\tif (by0 < 0) { by0 0; } \t\tif (bx1 > sht >bxsize) { bx1 sht >bxsize; } \t\tif (by1 > sht >bysize) { by1 sht >bysize; } \t\tfor (by by0; by < by1; by++) { \t\t\tvy sht >vy0 + by; \t\t\tfor (bx bx0; bx < bx1; bx++) { \t\t\t\tvx sht >vx0 + bx; \t\t\t\tif (map[vy * ctl >xsize + vx] sid) {//依据当前的图层进行刷新 \t\t\t\t\tvram[vy * ctl >xsize + vx] buf[by * sht >bxsize + bx]; \t\t\t\t} \t\t\t} \t\t} \t} \treturn; } ``` > 再一次添加新的参数, 刷新图层的上限, 没有必要全部刷新 ```c void sheet_slide(struct SHEET *sht, int vx0, int vy0) { \tstruct SHTCTL *ctl sht >ctl; \tint old_vx0 sht >vx0, old_vy0 sht >vy0; \tsht >vx0 vx0; \tsht >vy0 vy0; \tif (sht >height > 0) { /* 在刷新之前进行刷新地图 */ \t\tsheet_refreshmap(ctl, old_vx0, old_vy0, old_vx0 + sht >bxsize, old_vy0 + sht >bysize, 0); \t\tsheet_refreshmap(ctl, vx0, vy0, vx0 + sht >bxsize, vy0 + sht >bysize, sht >height); \t\tsheet_refreshsub(ctl, old_vx0, old_vy0, old_vx0 + sht >bxsize, old_vy0 + sht >bysize, 0, sht >height 1);//只需要对移走的图层下面的位置的图层进行刷新 \t\tsheet_refreshsub(ctl, vx0, vy0, vx0 + sht >bxsize, vy0 + sht >bysize, sht >height, sht >height); \t} \treturn; } ``` ```c void sheet_updown(struct SHEET *sht, int height) { \tstruct SHTCTL *ctl sht >ctl; \tint h, old sht >height; /* 設定前の高さを記憶する */ \t/* 指定が低すぎや高すぎだったら、修正する */ \tif (height > ctl >top + 1) { \t\theight ctl >top + 1; \t} \tif (height < 1) { \t\theight 1; \t} \tsht >height height; /* 高さを設定 */ \t/* 以下は主にsheets[]の並べ替え */ \tif (old > height) {\t/* 以前よりも低くなる */ \t\tif (height > 0) { \t\t\t/* 間のものを引き上げる */ \t\t\tfor (h old; h > height; h ) { \t\t\t\tctl >sheets[h] ctl >sheets[h 1]; \t\t\t\tctl >sheets[h] >height h; \t\t\t} \t\t\tctl >sheets[height] sht; \t\t\tsheet_refreshmap(ctl, sht >vx0, sht >vy0, sht >vx0 + sht >bxsize, sht >vy0 + sht >bysize, height + 1); \t\t\tsheet_refreshsub(ctl, sht >vx0, sht >vy0, sht >vx0 + sht >bxsize, sht >vy0 + sht >bysize, height + 1, old); \t\t} else {\t/* 非表示化 */ \t\t\tif (ctl >top > old) { \t\t\t\t/* 上になっているものをおろす */ \t\t\t\tfor (h old; h < ctl >top; h++) { \t\t\t\t\tctl >sheets[h] ctl >sheets[h + 1]; \t\t\t\t\tctl >sheets[h] >height h; \t\t\t\t} \t\t\t} \t\t\tctl >top ; /* 表示中の下じきが一つ減るので、一番上の高さが減る */ \t\t\tsheet_refreshmap(ctl, sht >vx0, sht >vy0, sht >vx0 + sht >bxsize, sht >vy0 + sht >bysize, 0); \t\t\tsheet_refreshsub(ctl, sht >vx0, sht >vy0, sht >vx0 + sht >bxsize, sht >vy0 + sht >bysize, 0, old 1); \t\t} \t} else if (old < height) {\t/* 以前よりも高くなる */ \t\tif (old > 0) { \t\t\t/* 間のものを押し下げる */ \t\t\tfor (h old; h < height; h++) { \t\t\t\tctl >sheets[h] ctl >sheets[h + 1]; \t\t\t\tctl >sheets[h] >height h; \t\t\t} \t\t\tctl >sheets[height] sht; \t\t} else {\t/* 非表示状態から表示状態へ */ \t\t\t/* 上になるものを持ち上げる */ \t\t\tfor (h ctl >top; h > height; h ) { \t\t\t\tctl >sheets[h + 1] ctl >sheets[h]; \t\t\t\tctl >sheets[h + 1] >height h + 1; \t\t\t} \t\t\tctl >sheets[height] sht; \t\t\tctl >top++; /* 表示中の下じきが一つ増えるので、一番上の高さが増える */ \t\t} \t\tsheet_refreshmap(ctl, sht >vx0, sht >vy0, sht >vx0 + sht >bxsize, sht >vy0 + sht >bysize, height); \t\tsheet_refreshsub(ctl, sht >vx0, sht >vy0, sht >vx0 + sht >bxsize, sht >vy0 + sht >bysize, height, height); \t} \treturn; } ```"},"/note/嵌入式/第三方移植/MySTMOS/2023-8-17-day10叠加处理.html":{"title":"day10叠加处理","content":" layout: post title: \"day10叠加处理\" date: 2023 8 17 15:39:08 +0800 tags: MyOS # day10叠加处理 ## 内存分配的时候按照4K进行 ```c unsigned int memman_alloc_4k(struct MEMMAN *man, unsigned int size) { \tunsigned int a; \tsize (size + 0xfff) & 0xfffff000; \ta memman_alloc(man, size); \treturn a; } int memman_free_4k(struct MEMMAN *man, unsigned int addr, unsigned int size) { \tint i; \tsize (size + 0xfff) & 0xfffff000; \ti memman_free(man, addr, size); \treturn i; } ``` ## 叠加(图层) ```c #define MAX_SHEETS\t\t256 struct SHEET { \tunsigned char *buf; //长和宽, 起始的位置, 透明颜色, 图层高度, 标志位 \tint bxsize, bysize, vx0, vy0, col_inv, height, flags; }; struct SHTCTL { //显卡的位置 \tunsigned char *vram; //窗口的大小, 最高层 \tint xsize, ysize, top; \tstruct SHEET *sheets[MAX_SHEETS]; \tstruct SHEET sheets0[MAX_SHEETS]; }; ``` ```c #define SHEET_USE\t\t1 struct SHTCTL *shtctl_init(struct MEMMAN *memman, unsigned char *vram, int xsize, int ysize) { \tstruct SHTCTL *ctl; \tint i; \tctl (struct SHTCTL *) memman_alloc_4k(memman, sizeof (struct SHTCTL)); \tif (ctl 0) { \t\tgoto err; \t} \tctl >vram vram; \tctl >xsize xsize; \tctl >ysize ysize; \tctl >top 1; /* 设置为没有图层正在使用 */ \tfor (i 0; i < MAX_SHEETS; i++) { \t\tctl >sheets0[i].flags 0; /* 所有的标志设置为无效 */ \t} err: \treturn ctl; } struct SHEET *sheet_alloc(struct SHTCTL *ctl) { //获取未使用的图层 \tstruct SHEET *sht; \tint i; \tfor (i 0; i < MAX_SHEETS; i++) { \t\tif (ctl >sheets0[i].flags 0) { \t\t\tsht &ctl >sheets0[i]; \t\t\tsht >flags SHEET_USE; /* 标志位设置为使用中 */ \t\t\tsht >height 1; /* 高度是隐藏 */ \t\t\treturn sht; \t\t} \t} \treturn 0;\t/* 所有的图层都在使用中 */ } //设置涂层的大小以及透明色 void sheet_setbuf(struct SHEET *sht, unsigned char *buf, int xsize, int ysize, int col_inv) { \tsht >buf buf; \tsht >bxsize xsize; \tsht >bysize ysize; \tsht >col_inv col_inv; \treturn; } //设定图层的高度 void sheet_updown(struct SHTCTL *ctl, struct SHEET *sht, int height) { \tint h, old sht >height; /* 对图层的高度进项保存 */ \t/* 图层高度是否设计的过高 */ \tif (height > ctl >top + 1) { \t\theight ctl >top + 1; \t} \tif (height < 1) { \t\theight 1; \t} \tsht >height height; /* 设置图层的高度 */ \t/* 以下主要是对sheets图层进行重新排列 */ \tif (old > height) {\t/* 比之前低 */ \t\tif (height > 0) { \t\t\t/* 进行降级 */ \t\t\tfor (h old; h > height; h ) { \t\t\t\tctl >sheets[h] ctl >sheets[h 1]; \t\t\t\tctl >sheets[h] >height h; \t\t\t} \t\t\tctl >sheets[height] sht; \t\t} else {\t/* 隐藏图层 */ \t\t\tif (ctl >top > old) { \t\t\t\t/* 把上面的图层降下来 */ \t\t\t\tfor (h old; h < ctl >top; h++) { \t\t\t\t\tctl >sheets[h] ctl >sheets[h + 1]; \t\t\t\t\tctl >sheets[h] >height h; \t\t\t\t} \t\t\t} \t\t\tctl >top ; /* 最上层的图层降低 */ \t\t} \t\tsheet_refresh(ctl); /* 重新绘制图形 */ \t} else if (old < height) {\t/* 比之前的高 */ \t\tif (old > 0) { \t\t\t/* 之前图形存在 */ \t\t\tfor (h old; h < height; h++) { \t\t\t\tctl >sheets[h] ctl >sheets[h + 1]; \t\t\t\tctl >sheets[h] >height h; \t\t\t} \t\t\tctl >sheets[height] sht; \t\t} else {\t/* 隐藏状态转换为显示状态 */ \t\t\t/* 把比他高的图层提上去 */ \t\t\tfor (h ctl >top; h > height; h ) { \t\t\t\tctl >sheets[h + 1] ctl >sheets[h]; \t\t\t\tctl >sheets[h + 1] >height h + 1; \t\t\t} \t\t\tctl >sheets[height] sht; \t\t\tctl >top++; /* 显示的图层加一 */ \t\t} \t\tsheet_refresh(ctl); /* 重新绘制图形 */ \t} \treturn; } //重新绘制图形 void sheet_refresh(struct SHTCTL *ctl) { \tint h, bx, by, vx, vy; \tunsigned char *buf, c, *vram ctl >vram; \tstruct SHEET *sht; //所有的图层依次调取 \tfor (h 0; h < ctl >top; h++) { \t\tsht ctl >sheets[h]; \t\tbuf sht >buf; \t\tfor (by 0; by < sht >bysize; by++) { \t\t\tvy sht >vy0 + by; \t\t\tfor (bx 0; bx < sht >bxsize; bx++) { \t\t\t\tvx sht >vx0 + bx; \t\t\t\tc buf[by * sht >bxsize + bx]; \t\t\t\tif (c ! sht >col_inv) { //颜色不是透明的话就进行显示 \t\t\t\t\tvram[vy * ctl >xsize + vx] c; \t\t\t\t} \t\t\t} \t\t} \t} \treturn; } //图层滑动 void sheet_slide(struct SHTCTL *ctl, struct SHEET *sht, int vx0, int vy0) { \tsht >vx0 vx0; \tsht >vy0 vy0; \tif (sht >height > 0) { /* 图层如果正在显示 */ \t\tsheet_refresh(ctl); /* 更新图层的内容 */ \t} \treturn; } //释放一个图层 void sheet_free(struct SHTCTL *ctl, struct SHEET *sht) { \tif (sht >height > 0) { \t\tsheet_updown(ctl, sht, 1); /* 将图层首先从显示中取出 */ \t} \tsht >flags 0; /* 设置为没有使用 */ \treturn; } ``` ```c void HariMain(void) { \tstruct BOOTINFO *binfo (struct BOOTINFO *) ADR_BOOTINFO; \tchar s[40], keybuf[32], mousebuf[128]; \tint mx, my, i; \tunsigned int memtotal; \tstruct MOUSE_DEC mdec; \tstruct MEMMAN *memman (struct MEMMAN *) MEMMAN_ADDR; \tstruct SHTCTL *shtctl;\t\t\t\t\t\t\t\t\t\t\t//图层管理设置 \tstruct SHEET *sht_back, *sht_mouse;\t\t\t\t\t\t\t\t//两个图层的指针 \tunsigned char *buf_back, buf_mouse[256]; \tinit_gdtidt(); \tinit_pic(); \tio_sti(); /* 解除 */ \tfifo8_init(&keyfifo, 32, keybuf); \tfifo8_init(&mousefifo, 128, mousebuf); \tio_out8(PIC0_IMR, 0xf9); /* (11111001) */ \tio_out8(PIC1_IMR, 0xef); /* (11101111) */ \tinit_keyboard(); \tenable_mouse(&mdec); \tmemtotal memtest(0x00400000, 0xbfffffff); \tmemman_init(memman);\t\t\t\t\t\t\t\t//地址初始化 \tmemman_free(memman, 0x00001000, 0x0009e000); /* 0x00001000 0x0009efff */ \tmemman_free(memman, 0x00400000, memtotal 0x00400000); \tinit_palette(); \tshtctl shtctl_init(memman, binfo >vram, binfo >scrnx, binfo >scrny);\t\t//初始化图层管理 \tsht_back sheet_alloc(shtctl);\t\t\t\t\t\t\t\t\t\t\t//申请两个图层 \tsht_mouse sheet_alloc(shtctl); \tbuf_back (unsigned char *) memman_alloc_4k(memman, binfo >scrnx * binfo >scrny);\t\t//申请背景图层的位置 \tsheet_setbuf(sht_back, buf_back, binfo >scrnx, binfo >scrny, 1); /* 初始化背景图层 */ \tsheet_setbuf(sht_mouse, buf_mouse, 16, 16, 99);\t//鼠标图层初始化 \tinit_screen8(buf_back, binfo >scrnx, binfo >scrny);\t\t\t//初始化桌面结构体 \tinit_mouse_cursor8(buf_mouse, 99); \t\t\t\t//初始化鼠标的结构体 \tsheet_slide(shtctl, sht_back, 0, 0);\t\t\t\t//设置背景图层的位置 \tmx (binfo >scrnx 16) / 2; \tmy (binfo >scrny 28 16) / 2; \tsheet_slide(shtctl, sht_mouse, mx, my);\t\t\t\t//设置鼠标图层的位置 \tsheet_updown(shtctl, sht_back, 0); \tsheet_updown(shtctl, sht_mouse, 1); \tsprintf(s, \"(%3d, %3d)\", mx, my); \tputfonts8_asc(buf_back, binfo >scrnx, 0, 0, COL8_FFFFFF, s); \tsprintf(s, \"memory %dMB free : %dKB\", \t\t\tmemtotal / (1024 * 1024), memman_total(memman) / 1024); \tputfonts8_asc(buf_back, binfo >scrnx, 0, 32, COL8_FFFFFF, s); \tsheet_refresh(shtctl); \tfor (;;) { \t\tio_cli(); \t\tif (fifo8_status(&keyfifo) + fifo8_status(&mousefifo) 0) { \t\t\tio_stihlt(); \t\t} else { \t\t\tif (fifo8_status(&keyfifo) ! 0) { \t\t\t\ti fifo8_get(&keyfifo); \t\t\t\tio_sti(); \t\t\t\tsprintf(s, \"%02X\", i); \t\t\t\tboxfill8(buf_back, binfo >scrnx, COL8_008484, 0, 16, 15, 31); \t\t\t\tputfonts8_asc(buf_back, binfo >scrnx, 0, 16, COL8_FFFFFF, s); \t\t\t\tsheet_refresh(shtctl); \t\t\t} else if (fifo8_status(&mousefifo) ! 0) { \t\t\t\ti fifo8_get(&mousefifo); \t\t\t\tio_sti(); \t\t\t\tif (mouse_decode(&mdec, i) ! 0) { \t\t\t\t\t/* データが3バイト揃ったので表示 */ \t\t\t\t\tsprintf(s, \"[lcr %4d %4d]\", mdec.x, mdec.y); \t\t\t\t\tif ((mdec.btn & 0x01) ! 0) { \t\t\t\t\t\ts[1] 'L'; \t\t\t\t\t} \t\t\t\t\tif ((mdec.btn & 0x02) ! 0) { \t\t\t\t\t\ts[3] 'R'; \t\t\t\t\t} \t\t\t\t\tif ((mdec.btn & 0x04) ! 0) { \t\t\t\t\t\ts[2] 'C'; \t\t\t\t\t} \t\t\t\t\tboxfill8(buf_back, binfo >scrnx, COL8_008484, 32, 16, 32 + 15 * 8 1, 31); \t\t\t\t\tputfonts8_asc(buf_back, binfo >scrnx, 32, 16, COL8_FFFFFF, s); \t\t\t\t\t/* マウスカーソルの移動 */ \t\t\t\t\tmx + mdec.x; \t\t\t\t\tmy + mdec.y; \t\t\t\t\tif (mx < 0) { \t\t\t\t\t\tmx 0; \t\t\t\t\t} \t\t\t\t\tif (my < 0) { \t\t\t\t\t\tmy 0; \t\t\t\t\t} \t\t\t\t\tif (mx > binfo >scrnx 16) { \t\t\t\t\t\tmx binfo >scrnx 16; \t\t\t\t\t} \t\t\t\t\tif (my > binfo >scrny 16) { \t\t\t\t\t\tmy binfo >scrny 16; \t\t\t\t\t} \t\t\t\t\tsprintf(s, \"(%3d, %3d)\", mx, my); \t\t\t\t\tboxfill8(buf_back, binfo >scrnx, COL8_008484, 0, 0, 79, 15); /* 座標消す */ \t\t\t\t\tputfonts8_asc(buf_back, binfo >scrnx, 0, 0, COL8_FFFFFF, s); /* 座標書く */ \t\t\t\t\tsheet_slide(shtctl, sht_mouse, mx, my); /* sheet_refreshを含む */ \t\t\t\t} \t\t\t} \t\t} \t} } ``` ## 对绘制进行优化 ```c //可以指定重新绘制的位置 void sheet_refreshsub(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1) { \tint h, bx, by, vx, vy; \tunsigned char *buf, c, *vram ctl >vram; \tstruct SHEET *sht; \tfor (h 0; h < ctl >top; h++) { \t\tsht ctl >sheets[h]; \t\tbuf sht >buf; \t\tfor (by 0; by < sht >bysize; by++) { \t\t\tvy sht >vy0 + by; \t\t\tfor (bx 0; bx < sht >bxsize; bx++) { \t\t\t\tvx sht >vx0 + bx; \t\t\t\tif (vx0 < vx && vx < vx1 && vy0 < vy && vy < vy1) { \t\t\t\t\tc buf[by * sht >bxsize + bx]; \t\t\t\t\tif (c ! sht >col_inv) { \t\t\t\t\t\tvram[vy * ctl >xsize + vx] c; \t\t\t\t\t} \t\t\t\t} \t\t\t} \t\t} \t} \treturn; } ``` ```c //某一个图层被修改之后使用的函数, 输入的参数是在这一个图层上的相对位置 //这样修改可以用来在打印字之后刷新 void sheet_refresh(struct SHTCTL *ctl, struct SHEET *sht, int bx0, int by0, int bx1, int by1) { \tif (sht >height > 0) { /* 如果正在显示就按照图层进行刷新 */ \t\tsheet_refreshsub(ctl, sht >vx0 + bx0, sht >vy0 + by0, sht >vx0 + bx1, sht >vy0 + by1); \t} \treturn; } ``` ## 再次优化 ```c void sheet_refreshsub(struct SHTCTL *ctl, int vx0, int vy0, int vx1, int vy1) { \tint h, bx, by, vx, vy, bx0, by0, bx1, by1; \tunsigned char *buf, c, *vram ctl >vram; \tstruct SHEET *sht; \tfor (h 0; h < ctl >top; h++) { //便利所有的图层 \t\tsht ctl >sheets[h]; \t\tbuf sht >buf; \t\t/* 计算图层相对于绘制位置的偏移 */ \t\tbx0 vx0 sht >vx0; \t\tby0 vy0 sht >vy0; \t\tbx1 vx1 sht >vx0; \t\tby1 vy1 sht >vy0; /* 重新绘制的位置在图层之外的重新处理 */ \t\tif (bx0 < 0) { bx0 0; } \t\tif (by0 < 0) { by0 0; } \t\tif (bx1 > sht >bxsize) { bx1 sht >bxsize; } \t\tif (by1 > sht >bysize) { by1 sht >bysize; } //只对在图层内的进行重新绘制 \t\tfor (by by0; by < by1; by++) { \t\t\tvy sht >vy0 + by; \t\t\tfor (bx bx0; bx < bx1; bx++) { \t\t\t\tvx sht >vx0 + bx; \t\t\t\tc buf[by * sht >bxsize + bx]; \t\t\t\tif (c ! sht >col_inv) { \t\t\t\t\tvram[vy * ctl >xsize + vx] c; \t\t\t\t} \t\t\t} \t\t} \t} \treturn; } ```"},"/note/嵌入式/第三方移植/MySTMOS/2023-7-19-a所有文件的作用记录.html":{"title":"文件的作用","content":" layout: post title: \"文件的作用\" date: 2023 7 19 15:39:08 +0800 tags: MyOS # 文件的作用 ## day3 ![image 20230721133110106](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259924.png) + ipl10.nas, 初始区记录信息, 读取软盘, 进入asmhead.nas + asmhead.nas, 记录一些信息, 之后初始化显卡以及键盘, 切换为32位模式,最后初始化C环境并进入 + bootpack.c: 有main函数的文件 + naskfunc.nas: 一些使用汇编实现的函数 ## day5 ![image 20230725094225382](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259925.png) + hankaku.txt: 记录字模 ## day6 ![image 20230725095649962](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259926.png) + dsctbl.c: 关于GDT, IDT的内容 + graphic.c : 记录的是绘画的处理 + bootpack.c其他处理 ![image 20230814174303633](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259927.png) + int.c: 处理中断的相关内容 + bootpack.h所有文件的头文件 ## day9 ![image 20230817153844339](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259928.png) + keyboard.c: 键盘初始化以及中断 + mouse.c: 鼠标的初始化以及中断 ## day10 ![image 20230817182302869](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259929.png) + memory.c 内存管理 ## day12 ![image 20230823165149959](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259930.png) + timer.c 记录定时器相关的内容 ## day15 ![image 20230826162546557](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242259931.png) + mtask.c 任务相关的函数"},"/note/嵌入式/第三方移植/MySTMOS/2023-7-23-day5结构体文字显示与GDTIDT初始化.html":{"title":"day5结构体文字显示与GDT/IDT初始化","content":" layout: post title: \"day5结构体文字显示与GDT/IDT初始化\" date: 2023 7 23 15:39:08 +0800 tags: MyOS # day5结构体文字显示与GDT/IDT初始化 + 从之前保存在内存中的位置获取信息 ```c \tbinfo_scrnx (short *) 0x0ff4; \tbinfo_scrny (short *) 0x0ff6; \tbinfo_vram (int *) 0x0ff8; \txsize *binfo_scrnx; \tysize *binfo_scrny; \tvram (char *) *binfo_vram; ``` ```assembly SCRNX\tEQU\t\t0x0ff4\t\t\t; 分辨率x SCRNY\tEQU\t\t0x0ff6\t\t\t; Y VRAM\tEQU\t\t0x0ff8\t\t\t; 图像缓冲区的位置 ``` + 使用一个结构体 ```c struct BOOTINFO { //获取启动区, 键盘状态, 设置的颜色种类, 保留 \tchar cyls, leds, vmode, reserve; //获取长宽 \tshort scrnx, scrny; //获取地址 \tchar *vram; }; void HariMain(void) { \tchar *vram; \tint xsize, ysize; \tstruct BOOTINFO *binfo; \tinit_palette(); //设置结构体的位置 \tbinfo (struct BOOTINFO *) 0x0ff0; \txsize (*binfo).scrnx; \tysize (*binfo).scrny; \tvram (*binfo).vram; ... } ``` ```assembly ; haribote os ; TAB 4 ; BOOT_INFO娭學 CYLS\tEQU\t\t0x0ff0\t\t\t; 设定启动区 LEDS\tEQU\t\t0x0ff1 VMODE\tEQU\t\t0x0ff2\t\t\t; 设定颜色的数目 SCRNX\tEQU\t\t0x0ff4\t\t\t; 分辨率x SCRNY\tEQU\t\t0x0ff6\t\t\t; Y VRAM\tEQU\t\t0x0ff8\t\t\t; 图像缓冲区的位置 \t\tORG\t\t0xc200\t\t\t; 程序的保存地址 \t\tMOV\t\tAL,0x13\t\t\t; 设置显卡 \t\tMOV\t\tAH,0x00 \t\tINT\t\t0x10 \t\tMOV\t\tBYTE [VMODE],8\t; 记录画面模式 \t\tMOV\t\tWORD [SCRNX],320 \t\tMOV\t\tWORD [SCRNY],200 \t\tMOV\t\tDWORD [VRAM],0x000a0000 ; 使用BIOS获取键盘上的各种LED的状态 \t\tMOV\t\tAH,0x02 \t\tINT\t\t0x16 \t\t\t; keyboard BIOS \t\tMOV\t\t[LEDS],AL\t\t; 保存状态 ``` + 显示文字 ```c /* *参数1: 显卡的地址 * 2: 一行的距离 * 3.横纵坐标 * 4.显示的颜色 * 5.字模 */ void putfont8(char *vram, int xsize, int x, int y, char c, char *font) { \tint i; \tchar *p, d /* data */; \tfor (i 0; i < 16; i++) { \t\tp vram + (y + i) * xsize + x; \t\td font[i]; \t\tif ((d & 0x80) ! 0) { p[0] c; } \t\tif ((d & 0x40) ! 0) { p[1] c; } \t\tif ((d & 0x20) ! 0) { p[2] c; } \t\tif ((d & 0x10) ! 0) { p[3] c; } \t\tif ((d & 0x08) ! 0) { p[4] c; } \t\tif ((d & 0x04) ! 0) { p[5] c; } \t\tif ((d & 0x02) ! 0) { p[6] c; } \t\tif ((d & 0x01) ! 0) { p[7] c; } \t} \treturn; } ``` ```c void putfonts8_asc(char *vram, int xsize, int x, int y, char c, unsigned char *s) { //获取字库 \textern char hankaku[4096]; \tfor (; *s ! 0x00; s++) { //传入地址以及计算出的字模 \t\tputfont8(vram, xsize, x, y, c, hankaku + *s * 16); \t\tx + 8; \t} \treturn; } ``` ## GDT 在汇编文件的时候使用ORG声明程序写入的位置, 但是如果写入的位置错误, 就会出现问题 这种的使用十分的麻烦, 解决方法就是分层, 每一层的的地址看起来都是0开始的, 也可以使用分页解决 是通过段寄存器实现的, 比如MOV AL, [DS:EBX], DS保存的实际上是段的起始地址, 16位的时候则使用的是DS*16 + 表示一个段 > 段的大小 > > 段的起始位置 > > 段的属性管理 系统使用64位的数据表示这些信息 段寄存器使用的是16位, 但是由于低三位不能使用, 可以表示的有8191位的数字 记录的数据记录在GDT里面 ```c struct SEGMENT_DESCRIPTOR { \tshort limit_low, base_low; \tchar base_mid, access_right; \tchar limit_high, base_high; }; ``` > 初始化的位置在0x00270000 0x0027ffff, 是随机选择的, 存在GDTR寄存器里面 > ![image 20230724221323463](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242256010.png) > > 段限长设置的是段的地址, 最小单位是G决定的, 0表示一字节, 1表示4KB > > 段基地址表示开始的地址,type表示的是段的属性, DPK设置的是段的限权, 设备只有有限权才可以访问, 有四级 > > P 1说明这一段可以使用, 如不可用使用段强行访问会发生中断 > > AVl是软件设置的 > > D/B有两种, 被type设置为代码段的时候D 1是32位程序, D 0是16位程序, 如果是向下扩展的数据段则是B, B 1代表可以访问4GB, 否则是64K, 表示的是堆栈的时候B 1表示的是esp为段顶寄存器, 否则是sp > > ## IDT 中断记录表, 初始化之前最好先初始化GDT ```c struct GATE_DESCRIPTOR { \tshort offset_low, selector; \tchar dw_count, access_right; \tshort offset_high; }; ``` > 初始化在0x26f800 26ffff, 在0x280000 0x2f ffff的位置是bootpack.h > > 可以在任意地址, 由IDTR设置 > IDT 表中可以存放三种类型的门描述符: > > 中断门描述符 > 陷阱门描述符 > 任务门描述符 > > 中断门和陷阱门含有一个长指针(即段选择符和偏移值)，处理器使用这个长指针把程序执行权转移到代码段中的异常或中断的处理程序中。这两个段的主要区别在于处理器操作EFLAGS寄存器IF标志上。IDT中任务门描述符的格式与GDT和LDT中任务门的格式相同。 > > 任务门描述符中含有一个任务TSS段的选择符，该任务用于处理异常和/或中断。 > > ![image 20230724222911339](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242256011.png) ## 初始化 ```c void init_gdtidt(void) { \t//初始化地址 \tstruct SEGMENT_DESCRIPTOR *gdt (struct SEGMENT_DESCRIPTOR *) 0x00270000;//设置地址 \tstruct GATE_DESCRIPTOR *idt (struct GATE_DESCRIPTOR *) 0x0026f800; \tint i; \t/* GDT初始化 */ \tfor (i 0; i < 8192; i++) { \t\tset_segmdesc(gdt + i, 0, 0, 0); \t} \tset_segmdesc(gdt + 1, 0xffffffff, 0x00000000, 0x4092);//设置第一段, 大小是4GB, 地址是0, 属性是0x4092 \tset_segmdesc(gdt + 2, 0x0007ffff, 0x00280000, 0x409a);//设置第一段, 大小是512K, 地址是0x00280000, 属性是0x409a, 这是为了bootpack.hrb的位置, hrb是以ORG为1为前提翻译的机器语言 \tload_gdtr(0xffff, 0x00270000); \t/* IDT初始化 */ \tfor (i 0; i < 256; i++) { \t\tset_gatedesc(idt + i, 0, 0, 0); \t} //设置GDTR寄存器 \tload_idtr(0x7ff, 0x0026f800); \treturn; } void set_segmdesc(struct SEGMENT_DESCRIPTOR *sd, unsigned int limit, int base, int ar) { \tif (limit > 0xfffff) { \t\tar 0x8000; /* G_bit 1 */ \t\tlimit / 0x1000; \t} \tsd >limit_low limit & 0xffff; \tsd >base_low base & 0xffff; \tsd >base_mid (base >> 16) & 0xff; \tsd >access_right ar & 0xff; \tsd >limit_high ((limit >> 16) & 0x0f) ((ar >> 8) & 0xf0); \tsd >base_high (base >> 24) & 0xff; \treturn; } //第一个参数是地址, 第二个参数是函数指针, 第三个参数是段地址, 第四个参数是段的属性 void set_gatedesc(struct GATE_DESCRIPTOR *gd, int offset, int selector, int ar) { \tgd >offset_low offset & 0xffff; \tgd >selector selector; \tgd >dw_count (ar >> 8) & 0xff; \tgd >access_right ar & 0xff; \tgd >offset_high (offset >> 16) & 0xffff; \treturn; } ``` ```assembly _load_gdtr:\t\t; void load_gdtr(int limit, int addr); \t\tMOV\t\tAX,[ESP+4]\t\t; limit \t\tMOV\t\t[ESP+6],AX \t\tLGDT\t[ESP+6] \t\tRET _load_idtr:\t\t; void load_idtr(int limit, int addr); \t\tMOV\t\tAX,[ESP+4]\t\t; limit \t\tMOV\t\t[ESP+6],AX \t\tLIDT\t[ESP+6] \t\tRET ```"},"/note/嵌入式/第三方移植/MySTMOS/2023-8-17-day8鼠标控制以及32位转换.html":{"title":"day7FIFO与鼠标控制","content":" layout: post title: \"day7FIFO与鼠标控制\" date: 2023 8 17 15:39:08 +0800 tags: MyOS # day7FIFO与鼠标控制 ## 鼠标数据的解读 ```c for (;;) { io_cli(); if (fifo8_status(&keyfifo) + fifo8_status(&mousefifo) 0) { io_stihlt(); } else { if (fifo8_status(&keyfifo) ! 0) { //这里是键盘的处理程序 i fifo8_get(&keyfifo); io_sti(); sprintf(s, \"%02X\", i); boxfill8(binfo >vram, binfo >scrnx, COL8_008484, 0, 16, 15, 31); putfonts8_asc(binfo >vram, binfo >scrnx, 0, 16, COL8_FFFFFF, s); } else if (fifo8_status(&mousefifo) ! 0) { //获取第一个数据 i fifo8_get(&mousefifo); io_sti(); //这一个变量是用来记录获得的数据的位数 if (mouse_phase 0) { /* 等待0xfa的状态标志位,这是初始化完成之后的返回值 */ if (i 0xfa) { mouse_phase 1; } } else if (mouse_phase 1) { //初始化完成之后获得的第一个数据 /* 获取第一字节的数据 */ mouse_dbuf[0] i; mouse_phase 2; } else if (mouse_phase 2) { /* 第二字节的数据 */ mouse_dbuf[1] i; mouse_phase 3; } else if (mouse_phase 3) { /* 第三字节的数据 */ mouse_dbuf[2] i; //把数据的位数重新恢复成1 mouse_phase 1; /* 获得三个数据之后把数据打印出来 */ sprintf(s, \"%02X %02X %02X\", mouse_dbuf[0], mouse_dbuf[1], mouse_dbuf[2]); boxfill8(binfo >vram, binfo >scrnx, COL8_008484, 32, 16, 32 + 8 * 8 1, 31); putfonts8_asc(binfo >vram, binfo >scrnx, 32, 16, COL8_FFFFFF, s); } } } } ``` ## 整理 ```c struct MOUSE_DEC { //三个存放数据的位置,以及一个标志位 \tunsigned char buf[3], phase; }; ``` > 创建一个鼠标的结构体 ```c void HariMain(void) { \tstruct BOOTINFO *binfo (struct BOOTINFO *) ADR_BOOTINFO; \tchar s[40], mcursor[256], keybuf[32], mousebuf[128]; \tint mx, my, i; \tstruct MOUSE_DEC mdec; \tinit_gdtidt(); \tinit_pic(); \tio_sti(); /* 打开中断 */ \tfifo8_init(&keyfifo, 32, keybuf); \tfifo8_init(&mousefifo, 128, mousebuf); \tio_out8(PIC0_IMR, 0xf9); /* 中断屏蔽 */ \tio_out8(PIC1_IMR, 0xef); \tinit_keyboard(); \tinit_palette(); \tinit_screen8(binfo >vram, binfo >scrnx, binfo >scrny); \tmx (binfo >scrnx 16) / 2; /* 画面中央になるように座標計算 */ \tmy (binfo >scrny 28 16) / 2; \tinit_mouse_cursor8(mcursor, COL8_008484); \tputblock8_8(binfo >vram, binfo >scrnx, 16, 16, mx, my, mcursor, 16); \tsprintf(s, \"(%d, %d)\", mx, my); \tputfonts8_asc(binfo >vram, binfo >scrnx, 0, 0, COL8_FFFFFF, s); \t//使能鼠标, 初始化鼠标的结构体 \tenable_mouse(&mdec); \tfor (;;) { \t\tio_cli(); \t\tif (fifo8_status(&keyfifo) + fifo8_status(&mousefifo) 0) { \t\t\tio_stihlt(); \t\t} else { \t\t\tif (fifo8_status(&keyfifo) ! 0) { \t\t\t\ti fifo8_get(&keyfifo); \t\t\t\tio_sti(); \t\t\t\tsprintf(s, \"%02X\", i); \t\t\t\tboxfill8(binfo >vram, binfo >scrnx, COL8_008484, 0, 16, 15, 31); \t\t\t\tputfonts8_asc(binfo >vram, binfo >scrnx, 0, 16, COL8_FFFFFF, s); \t\t\t} else if (fifo8_status(&mousefifo) ! 0) { \t\t\t\ti fifo8_get(&mousefifo); \t\t\t\tio_sti(); \t\t\t\tif (mouse_decode(&mdec, i) ! 0) { \t\t\t\t\t/* 有三个字节进行处理 */ \t\t\t\t\tsprintf(s, \"%02X %02X %02X\", mdec.buf[0], mdec.buf[1], mdec.buf[2]); \t\t\t\t\tboxfill8(binfo >vram, binfo >scrnx, COL8_008484, 32, 16, 32 + 8 * 8 1, 31); \t\t\t\t\tputfonts8_asc(binfo >vram, binfo >scrnx, 32, 16, COL8_FFFFFF, s); \t\t\t\t} \t\t\t} \t\t} \t} } ``` ```c //鼠标数据的接受 int mouse_decode(struct MOUSE_DEC *mdec, unsigned char dat) { \tif (mdec >phase 0) { \t\t/* 等待初始化 */ \t\tif (dat 0xfa) { \t\t\tmdec >phase 1; \t\t} \t\treturn 0; \t} \tif (mdec >phase 1) { \t\t/* 接受第一个数据 */ \t\tmdec >buf[0] dat; \t\tmdec >phase 2; \t\treturn 0; \t} \tif (mdec >phase 2) { \t\tmdec >buf[1] dat; \t\tmdec >phase 3; \t\treturn 0; \t} \tif (mdec >phase 3) { \t\tmdec >buf[2] dat; \t\tmdec >phase 1; \t\treturn 1; \t} \treturn 1; /* 出错了 */ } ``` ## 鼠标信息的解读 ```c struct MOUSE_DEC { \tunsigned char buf[3], phase; //存放鼠标的位置信息,以及按键的属性 \tint x, y, btn; }; ``` ```c int mouse_decode(struct MOUSE_DEC *mdec, unsigned char dat) { \tif (mdec >phase 0) { \t\t/* マウスの0xfaを待っている段階 */ \t\tif (dat 0xfa) { \t\t\tmdec >phase 1; \t\t} \t\treturn 0; \t} \tif (mdec >phase 1) { \t\t/* 添加了一个判断, 判断移动数据的位置信息以及按键信息是否符合标准 1. 有移动反应的是否在0~3之间 2. 第一字节的按键状态是否在8~f之间 0xc8 11001000*/ \t\tif ((dat & 0xc8) 0x08) { \t\t\t/* 第一字节正确 */ \t\t\tmdec >buf[0] dat; \t\t\tmdec >phase 2; \t\t} \t\treturn 0; \t} \tif (mdec >phase 2) { \t\tmdec >buf[1] dat; \t\tmdec >phase 3; \t\treturn 0; \t} \tif (mdec >phase 3) { \t\tmdec >buf[2] dat; \t\tmdec >phase 1; //对数据进行解读 //获取表示状态的低三位 \t\tmdec >btn mdec >buf[0] & 0x07; \t\tmdec >x mdec >buf[1]; \t\tmdec >y mdec >buf[2]; //通过第一字节对数据进行处理 \t\tif ((mdec >buf[0] & 0x10) ! 0) { \t\t\tmdec >x 0xffffff00; \t\t} \t\tif ((mdec >buf[0] & 0x20) ! 0) { \t\t\tmdec >y 0xffffff00; \t\t} \t\tmdec >y mdec >y; /* マウスではy方向の符号が画面と反対 */ \t\treturn 1; \t} \treturn 1; /* ここに来ることはないはず */ } ``` > 鼠标按键的状态在第一数据的低三位, 并通过第一字节的地两位确定是否对xy的值高位设置为1 ```c for (;;) { io_cli(); if (fifo8_status(&keyfifo) + fifo8_status(&mousefifo) 0) { io_stihlt(); } else { if (fifo8_status(&keyfifo) ! 0) { i fifo8_get(&keyfifo); io_sti(); sprintf(s, \"%02X\", i); boxfill8(binfo >vram, binfo >scrnx, COL8_008484, 0, 16, 15, 31); putfonts8_asc(binfo >vram, binfo >scrnx, 0, 16, COL8_FFFFFF, s); } else if (fifo8_status(&mousefifo) ! 0) { i fifo8_get(&mousefifo); io_sti(); if (mouse_decode(&mdec, i) ! 0) { /* 有按键按下的话修改显示的内容 */ sprintf(s, \"[lcr %4d %4d]\", mdec.x, mdec.y); if ((mdec.btn & 0x01) ! 0) { s[1] 'L'; } if ((mdec.btn & 0x02) ! 0) { s[3] 'R'; } if ((mdec.btn & 0x04) ! 0) { s[2] 'C'; } boxfill8(binfo >vram, binfo >scrnx, COL8_008484, 32, 16, 32 + 15 * 8 1, 31); putfonts8_asc(binfo >vram, binfo >scrnx, 32, 16, COL8_FFFFFF, s); } } } } ``` > 之后进行显示的修改 ## 通往32位的模式之路 ```assembly ; haribote os boot asm ; TAB 4 BOTPAK\tEQU\t\t0x00280000\t\t; bootpack文件起始地址设置地址 DSKCAC\tEQU\t\t0x00100000\t\t DSKCAC0\tEQU\t\t0x00008000\t\t ; 记录一些数据 CYLS\tEQU\t\t0x0ff0\t\t\t LEDS\tEQU\t\t0x0ff1 VMODE\tEQU\t\t0x0ff2\t\t\t SCRNX\tEQU\t\t0x0ff4\t\t\t SCRNY\tEQU\t\t0x0ff6\t\t\t VRAM\tEQU\t\t0x0ff8\t\t\t \t\tORG\t\t0xc200\t\t\t;设置文件的地址 ; 画面的一些设置 \t\tMOV\t\tAL,0x13\t\t\t; 对画面进行设置 \t\tMOV\t\tAH,0x00 \t\tINT\t\t0x10 \t\tMOV\t\tBYTE [VMODE],8\t; 画面设置的记录 \t\tMOV\t\tWORD [SCRNX],320 \t\tMOV\t\tWORD [SCRNY],200 \t\tMOV\t\tDWORD [VRAM],0x000a0000 ; キーボードのLED状態をBIOSに教えてもらう \t\tMOV\t\tAH,0x02 \t\tINT\t\t0x16 \t\t\t; keyboard BIOS获取键盘的数据 \t\tMOV\t\t[LEDS],AL ; PIC关闭所有的中断 ;\t在这里初始化PIC ;\t必须在CLI之前,否则可能会挂起 ;\t之后践行初始化 \t\tMOV\t\tAL,0xff \t\tOUT\t\t0x21,AL \t\tNOP\t\t\t\t\t\t; 设置PIC禁止所有的中断,这里有一个停顿, 硬件需求 \t\tOUT\t\t0xa1,AL \t\tCLI\t\t\t\t\t\t; 禁止CPU的所有中断 ; 为了让CPU可以访问1MB以外的内存, 所以需要设定A20GATE, 实际上设置的是地址位使用16位以上的线路 \t\tCALL\twaitkbdout\t\t; 这是一个循环等待硬件响应 \t\tMOV\t\tAL,0xd1\t \t\tOUT\t\t0x64,AL\t\t\t; 键盘的一个附属端口 \t\tCALL\twaitkbdout \t\tMOV\t\tAL,0xdf\t\t\t; enable A20, 发送命令 \t\tOUT\t\t0x60,AL \t\tCALL\twaitkbdout ; 切换到保护模式 [INSTRSET \"i486p\"]\t\t\t\t; 486命令使用的标志, 这是一个命令, 以后可以使用LGDT, EAX, CR0等, CR0是系统控制寄存器 \t\tLGDT\t[GDTR0]\t\t\t; 设置一个临时的GDT, 参数是六位的, 分别是长度以及位置 \t\tMOV\t\tEAX,CR0 \t\tAND\t\tEAX,0x7fffffff\t; bit31为0(禁止分页) \t\tOR\t\tEAX,0x00000001\t; bit0位1(切换为保护模式) \t\tMOV\t\tCR0,EAX \t\tJMP\t\tpipelineflush\t; 在设置以后需要使用一次JMP命令 pipelineflush: \t\tMOV\t\tAX,1*8\t\t\t; 之后会把除了CS之外的段寄存器设置为GDT1(低三位无效, 从8开始计算) \t\tMOV\t\tDS,AX \t\tMOV\t\tES,AX \t\tMOV\t\tFS,AX \t\tMOV\t\tGS,AX \t\tMOV\t\tSS,AX ; bootpack的复制 \t\tMOV\t\tESI,bootpack\t; 传送的原地址, 这里设置的是在这个文件之后的位置, 从Makefile得知是C文件的位置 \t\tMOV\t\tEDI,BOTPAK\t\t; 传送的目的地址 \t\tMOV\t\tECX,512*1024/4 \t\tCALL\tmemcpy ; 磁盘的数据存送到本来的位置 ; 从启动区开支 \t\tMOV\t\tESI,0x7c00\t\t; 原位置 \t\tMOV\t\tEDI,DSKCAC\t\t; 目的地 \t\tMOV\t\tECX,512/4 \t\tCALL\tmemcpy ; 剩下的所有 \t\tMOV\t\tESI,DSKCAC0+512\t; 原地址 \t\tMOV\t\tEDI,DSKCAC+512\t; 目的地址 \t\tMOV\t\tECX,0 \t\tMOV\t\tCL,BYTE [CYLS] \t\tIMUL\tECX,512*18*2/4\t; 计算大小 \t\tSUB\t\tECX,512/4\t\t \t\tCALL\tmemcpy ; asmhead完成工作 ;\t以后交给bootpack完成 ; bootpack启动 \t\tMOV\t\tEBX,BOTPAK \t\tMOV\t\tECX,[EBX+16] \t\tADD\t\tECX,3\t\t\t; ECX + 3; \t\tSHR\t\tECX,2\t\t\t; ECX / 4; \t\tJZ\t\tskip\t\t\t; 没有传送的东西的时候, 这些数字是根据bin文件得知的 \t\tMOV\t\tESI,[EBX+20]\t; 复制的原位置 \t\tADD\t\tESI,EBX \t\tMOV\t\tEDI,[EBX+12]\t; 目的位置 \t\tCALL\tmemcpy skip: \t\tMOV\t\tESP,[EBX+12]\t; 初始化栈 \t\tJMP\t\tDWORD 2*8:0x0000001b\t; 开始执行main函数 waitkbdout: \t\tIN\t\t AL,0x64 \t\tAND\t\t AL,0x02 \t\tJNZ\t\twaitkbdout\t\t; ANDの結果が0でなければwaitkbdoutへ \t\tRET memcpy: \t\tMOV\t\tEAX,[ESI] \t\tADD\t\tESI,4 \t\tMOV\t\t[EDI],EAX \t\tADD\t\tEDI,4 \t\tSUB\t\tECX,1 \t\tJNZ\t\tmemcpy\t\t\t; 引き算した結果が0でなければmemcpyへ \t\tRET ; memcpyはアドレスサイズプリフィクスを入れ忘れなければ、ストリング命令でも書ける \t\tALIGNB\t16 GDT0: \t\t; 由于低三位无效,这里设置的实际上是第一个段 \t\tRESB\t8\t\t\t\t; 0段不可以存东西 \t\tDW\t\t0xffff,0x0000,0x9200,0x00cf\t; 可以读写的段32bit \t\tDW\t\t0xffff,0x0000,0x9a28,0x0047\t;可以执行的段bootpack使用 \t\tDW\t\t0 GDTR0: \t\tDW\t\t8*3 1\t \t\tDD\t\tGDT0 \t\tALIGNB\t16\t\t; 添加DB0到地址可以被16整除 bootpack: ``` > 1. 禁止所有中断 > 2. 转换为32位的模式 > 3. 由于可以使用的内存增大, 所以把硬盘内容以及C文件的内容重新存储, 把bootpack文件移动到0x00280000位置, 启动区和其他的软盘内容dao0x10000000位置 + 0x00000000 0x000fffff: 启动时候使用的1M内存 + 0x00100000 0x00267fff: 保存软盘 + 0x00268000 0x26f7ff : 空 + 0x0026f800 0x0026ffff IDT + 0x00270000 0x0027ffff GDT + 0x00280000 0x002fffff bootpack.hrb + 0x00300000 0x003fffff 栈 + 0x00400000 其他"},"/note/嵌入式/第三方移植/freeRTOS/2023-7-11-fire6支持任务多优先级.html":{"title":"支持任务多优先级","content":" layout: post title: \"支持任务多优先级\" date: 2023 7 11 15:39:08 +0800 tags: FreeRTOS # 支持任务多优先级 找到最高优先级的任务的任务块 ```c /* ************************************************************************* * 宏定义 ************************************************************************* */ /* 将任务添加到就绪列表 */ #define prvAddTaskToReadyList( pxTCB )\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\ \ttaskRECORD_READY_PRIORITY( ( pxTCB ) >uxPriority );\t\t\t\t\t\t\t\t\t\t\t\t \\ \tvListInsertEnd( &( pxReadyTasksLists[ ( pxTCB ) >uxPriority ] ), &( ( pxTCB ) >xStateListItem ) ); \\ /* 查找最高优先级的就绪任务：通用方法 */ #if ( configUSE_PORT_OPTIMISED_TASK_SELECTION 0 ) \t/* uxTopReadyPriority 存的是就绪任务的最高优先级 */ \t#define taskRECORD_READY_PRIORITY( uxPriority )\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\ \t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\ \t\tif( ( uxPriority ) > uxTopReadyPriority )\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\ \t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\tuxTopReadyPriority ( uxPriority );\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\ \t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\ \t} /* taskRECORD_READY_PRIORITY */ \t/* */ \t#define taskSELECT_HIGHEST_PRIORITY_TASK()\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\ \t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\ \tUBaseType_t uxTopPriority uxTopReadyPriority;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\ \t\t/* 寻找包含就绪任务的最高优先级的队列 */ \\ \t\twhile( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopPriority ] ) ) )\t\t\t\t\t\t\t\\ \t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\t uxTopPriority;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\ \t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\ \t\t/* 获取优先级最高的就绪任务的TCB，然后更新到pxCurrentTCB */\t\t\t\t\t\t\t \\ \t\tlistGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );\t\t\t\\ \t\t/* 更新uxTopReadyPriority */ \\ \t\tuxTopReadyPriority uxTopPriority;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\ \t} /* taskSELECT_HIGHEST_PRIORITY_TASK */ \t/* */ \t/* 这两个宏定义只有在选择优化方法时才用，这里定义为空 */ \t#define taskRESET_READY_PRIORITY( uxPriority ) \t#define portRESET_READY_PRIORITY( uxPriority, uxTopReadyPriority ) /* 查找最高优先级的就绪任务：根据处理器架构优化后的方法 */ #else /* configUSE_PORT_OPTIMISED_TASK_SELECTION */ \t#define taskRECORD_READY_PRIORITY( uxPriority )\tportRECORD_READY_PRIORITY( uxPriority, uxTopReadyPriority ) \t/* */ \t#define taskSELECT_HIGHEST_PRIORITY_TASK()\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\ \t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\ \tUBaseType_t uxTopPriority;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\ \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\ \t\t/* 寻找最高优先级 */\t\t\t\t\t\t\t\t \\ \t\tportGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );\t\t\t\t\t\t\t\t \\ \t\t/* 获取优先级最高的就绪任务的TCB，然后更新到pxCurrentTCB */ \\ \t\tlistGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );\t\t \\ \t} /* taskSELECT_HIGHEST_PRIORITY_TASK() */ \t/* */ #if 0 \t#define taskRESET_READY_PRIORITY( uxPriority )\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\ \t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\ \t\tif( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ ( uxPriority ) ] ) ) ( UBaseType_t ) 0 )\t\\ \t\t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\ \t\t\tportRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );\t\t\t\t\t\t\t\\ \t\t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\ \t} #else #define taskRESET_READY_PRIORITY( uxPriority )\t\t\t\t\t\t\t\t\t\t\t \\ {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\ portRESET_READY_PRIORITY( ( uxPriority ), ( uxTopReadyPriority ) );\t\t\t\t\t \\ } #endif #endif /* configUSE_PORT_OPTIMISED_TASK_SELECTION */ ``` > 添加一个新的任务到优先级队列之中 > > 没有优化 > > taskRECORD_READY_PRIORITY( uxPriority )在当前优先级保存现在的优先级 > > taskSELECT_HIGHEST_PRIORITY_TASK()寻找最高优先级 > > 优化方法: 有一个指令CLZ, 会返回一个数字最高的出现1前面的0的个数 > > taskRECORD_READY_PRIORITY( uxPriority )把当前优先级某一个位设置为1 > > taskSELECT_HIGHEST_PRIORITY_TASK()寻找最高优先级 > > taskRESET_READY_PRIORITY( uxPriority )清零某一个位 ```c //设置在添加任务的时候是否使用优化 #ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION \t#define configUSE_PORT_OPTIMISED_TASK_SELECTION 1 #endif #if configUSE_PORT_OPTIMISED_TASK_SELECTION 1 \t/* 检测优先级配置 */ \t#if( configMAX_PRIORITIES > 32 ) \t\t#error configUSE_PORT_OPTIMISED_TASK_SELECTION can only be set to 1 when configMAX_PRIORITIES is less than or equal to 32. It is very rare that a system requires more than 10 to 15 difference priorities as tasks that share a priority will time slice. \t#endif \t/* 根据优先级设置/清除优先级位图中相应的位 */ \t#define portRECORD_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) ( 1UL << ( uxPriority ) ) \t#define portRESET_READY_PRIORITY( uxPriority, uxReadyPriorities ) ( uxReadyPriorities ) & ~( 1UL << ( uxPriority ) ) \t/* */ \t#define portGET_HIGHEST_PRIORITY( uxTopPriority, uxReadyPriorities ) uxTopPriority ( 31UL ( uint32_t ) __clz( ( uxReadyPriorities ) ) ) #endif /* taskRECORD_READY_PRIORITY */ ``` > 使用优化方法时候的宏定义, 实际上就是31减去clz指令获得的数字, 得到第几位是1 + 修改任务控制块, 添加优先级变量 ```c { \t//栈顶 \tvolatile StackType_t\t*pxTopOfStack;\t\t \t \t//任务节点 \tListItem_t\t\t\t\txStateListItem;\t \tStackType_t \t\t\t*pxStack; \t\t//任务栈的起始位置 \t \tchar \t\t\t\t\tpcTaskName[configMAX_TASK_NAME_LEN]; \t \tTickType_t xTicksToDelay; /* 用于延时 */ \t\t//优先级 UBaseType_t\t\t\tuxPriority; }tskTCB; ``` + 创建任务的时候传进去优先级 ```c prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters,uxPriority, &xReturn, pxNewTCB); ``` ```c /* 初始化优先级 */ \tif( uxPriority > ( UBaseType_t ) configMAX_PRIORITIES ) \t{ \t\tuxPriority ( UBaseType_t ) configMAX_PRIORITIES ( UBaseType_t ) 1U; \t} \tpxNewTCB >uxPriority uxPriority; ``` > 大于最大优先级, 就设置为最大优先级 + 实现自动添加到列表 ```c /* 将任务添加到就绪列表 */ prvAddNewTaskToReadyList( pxNewTCB ); ``` ```c static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB ) { \t/* 进入临界段 */ \ttaskENTER_CRITICAL(); \t{ \t\t/* 全局任务计时器加一操作 */ uxCurrentNumberOfTasks++; /* 如果pxCurrentTCB为空，则将pxCurrentTCB指向新创建的任务 */ \t\tif( pxCurrentTCB NULL ) \t\t{ \t\t\tpxCurrentTCB pxNewTCB; \t\t\t/* 如果是第一次创建任务，则需要初始化任务相关的列表 */ if( uxCurrentNumberOfTasks ( UBaseType_t ) 1 ) \t\t\t{ \t\t\t\t/* 初始化任务相关的列表 */ prvInitialiseTaskLists(); \t\t\t} \t\t} \t\telse /* 如果pxCurrentTCB不为空，则根据任务的优先级将pxCurrentTCB指向最高优先级任务的TCB */ \t\t{ \t\t\t\tif( pxCurrentTCB >uxPriority < pxNewTCB >uxPriority ) \t\t\t\t{ \t\t\t\t\tpxCurrentTCB pxNewTCB; \t\t\t\t} \t\t} \t\tuxTaskNumber++; \t\t/* 将任务添加到就绪列表 */ prvAddTaskToReadyList( pxNewTCB ); \t} \t/* 退出临界段 */ \ttaskEXIT_CRITICAL(); } ``` > 这一次创建任务的时候会自动修改当前的任务, 以及添加链表 > > 还需要修改开启任务调度的函数 + 修改Delay函数 ```c /* 将任务从就绪列表移除 */ //uxListRemove( &( pxTCB >xStateListItem ) ); taskRESET_READY_PRIORITY( pxTCB >uxPriority ); ``` > 暂时不能移除, 但是需要标志位清零, 因为现在通过扫描列表来实现延迟 + 修改修改任务的函数 ```c void vTaskSwitchContext( void ) { \t/* 获取优先级最高的就绪任务的TCB，然后更新到pxCurrentTCB */ taskSELECT_HIGHEST_PRIORITY_TASK(); } ``` + 计时器调用函数 ```c /* 延时时间到，将任务就绪 */ if( pxTCB >xTicksToDelay 0 ) { taskRECORD_READY_PRIORITY( pxTCB >uxPriority ); } ``` ## 总结 在创建函数的时候会把自身优先级设置为1 在调用delay函数之后会清除自身优先级, 然后进行函数切换 在时钟每次中断的时候会进行任务切换, 选择优先级最高的函数 切换函数的时候会调用xPortPendSVHandler函数, 在这个函数中会更新TCB然后更换函数 这里实现的每个优先级只能有一个函数 ## 实际的FreeRTOS ```c #define taskSELECT_HIGHEST_PRIORITY_TASK()\t\t\t\t\t\t\t\t\t\\ \t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\ \tUBaseType_t uxTopPriority;\t\t\t\t\t\t\t\t\t\t\t \\ \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\ \t\t/* Find the highest priority list that contains ready tasks. */\t\t \\ portGET_HIGHEST_PRIORITY( uxTopPriority, uxTopReadyPriority );\t \\ configASSERT( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ uxTopPriority ] ) ) > 0 );\\ listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopPriority ] ) );\\ } /* taskSELECT_HIGHEST_PRIORITY_TASK() */ ``` ```c #define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )\t\t\t\t\t\t\t\t \\ {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \\ List_t * const pxConstList ( pxList );\t\t\t\t\t\t\t\t\t\t\t \\ \t/* Increment the index to the next item and return the item, ensuring */\t\t\t\\ \t/* we don't return the marker used at the end of the list. */\t\t\t\t\t \\ \t( pxConstList ) >pxIndex ( pxConstList ) >pxIndex >pxNext;\t\t\t\t\t \\ \tif( ( void * ) ( pxConstList ) >pxIndex ( void * ) &( ( pxConstList ) >xListEnd ) )\t\\ \t{\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\ \t\t( pxConstList ) >pxIndex ( pxConstList ) >pxIndex >pxNext;\t\t\t\t\t \\ \t}\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\ \t( pxTCB ) ( pxConstList ) >pxIndex >pvOwner;\t\t\t\t\t\t\t\t\t\t\\ } ``` > 这一个宏定义会把首位的链表改为下一个链表"},"/note/嵌入式/第三方移植/freeRTOS/0000-0-0-00实际使用.html":{"title":"实际使用","content":" layout: post title: \"实际使用\" date: 2023 11 22 15:39:08 +0800 tags: FreeRTOS # 实际使用 ## 宏定义 ### 任务 ```c #define configUSE_PREEMPTION 1 ``` > 配置内核调度方式 1为抢占式 0为合作式(时间片) ```c #define configUSE_IDLE_HOOK 0 ``` > 是否使用空闲函数的钩子函数 ```c #define configUSE_TICK_HOOK 0 ``` > 是否使用TICK滴答任务钩子函数 ```c #define configMAX_PRIORITIES ( 5 ) ``` > 任务优先级 ```c #define configMINIMAL_STACK_SIZE ( ( unsigned short ) 128 ) ``` > 设置任务的最小的栈的大小, 实际上好像只用在了空闲任务 ```c #define configMAX_TASK_NAME_LEN ( 16 ) ``` > 任务的名字的长度 ```c #define configUSE_CO_ROUTINES 0 ``` > 配置是否使能合作式调度相关函数 ```c #define configIDLE_SHOULD_YIELD 1 ``` > 此参数用于使能与空闲任务同优先级的任务，只有满足以下两个条件时，此参数才有效果： > 1.使能抢占式调度器。 > 2.有创建与空闲任务同优先级的任务。 > 配置为1，就可以使能此特性了，实际应用中不建议用户使用此功能，将其配置为0即可 ```c #define configMAX_CO_ROUTINE_PRIORITIES ( 2 ) ``` > 定义可供用户使用的最大的合作式任务优先级数 ```c #define INCLUDE_vTaskPrioritySet 1 //设置任务优先级 #define INCLUDE_uxTaskPriorityGet 1 //获取任务优先级 #define INCLUDE_vTaskDelete 1 //删除任务 #define INCLUDE_vTaskCleanUpResources 0 //清理任务资源 #define INCLUDE_vTaskSuspend 1 //挂起任务 #define INCLUDE_vTaskDelayUntil 1 //延时直至 #define INCLUDE_vTaskDelay 1 //延时 ``` > 是否包含这些函数 ### 内存 ```c #define configTOTAL_HEAP_SIZE ( ( size_t ) ( 17 * 1024 ) ) ``` > FreeRTOS可以使用的堆的大小 ### 时钟 ```c #define configCPU_CLOCK_HZ ( ( unsigned long ) 72000000 ) ``` > //配置CPU主频(HZ) ```c #define configTICK_RATE_HZ ( ( TickType_t ) 1000 ) ``` > 配置系统时钟节拍数(HZ ### 其他 ```c #define configUSE_PORT_OPTIMISED_TASK_SELECTION 1 ``` > 设置使用硬件优化 ```c #define configUSE_TRACE_FACILITY 0 ``` > 可视化跟踪调试 ```c #define configUSE_16_BIT_TICKS 0 ``` > 使用16位的时钟计数 ### 中断 ```c #define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY 5 ``` > 设置FreeRTOS可以使用中断的最大优先级 ```c #define configPRIO_BITS 4 ``` > 支持的优先级的位数 ```c #define configMAX_SYSCALL_INTERRUPT_PRIORITY (configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY << (8 configPRIO_BITS)) ``` > 支持的实际的寄存器里面的值 ```c #define configKERNEL_INTERRUPT_PRIORITY \t\t( configLIBRARY_LOWEST_INTERRUPT_PRIORITY << (8 configPRIO_BITS) ) ``` > 内核的中断的优先级的个数 ### 时钟 ```c #define configUSE_TIMERS 1 ``` > 使用时钟之后需要定义以下的宏定义 ```c #define configTIMER_TASK_PRIORITY\t\t\t\t 1 #define configTIMER_QUEUE_LENGTH\t\t\t\t 5 #define configTIMER_TASK_STACK_DEPTH\t\t\t 100 ``` > 设置以后会初始化一个时钟相关的任务 ### 互斥锁 ```c #define configUSE_RECURSIVE_MUTEXES 1 ``` > 支持递归互斥锁 ## 任务 ### 创建任务 ```c BaseType_t xTaskCreate(\tTaskFunction_t pxTaskCode, const char * const pcName, const configSTACK_DEPTH_TYPE usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask ) ``` > 参数一: 要使用的函数 typedef void (*TaskFunction_t)( void * ); > > 参数二: 函数的名字, 最大16个字符 > > 参数三: 栈的大小 > > 参数四: 传进去的参数 > > 参数五: 优先级, configMAX_PRIORITIES设置最大优先级, 优先级数字越大优先级越高 > > 参数六: 任务控制句柄 ### 开启任务 ```c void vTaskStartScheduler( void ) ``` > 直接调用, 里面会创建一个空闲任务(使用时总的话会初始化一个时钟任务), 初始化一下时钟的参数 > > 还会在这里面设置可以使用FromIRQ的中断的最大优先级, 时钟等设置 ### 任务状态的改变 + 任务挂起 ```c void vTaskSuspend( TaskHandle_t xTaskToSuspend ) ``` > 参数就是想要挂起的任务句柄, 为NULL的时候就是当前的任务 + 挂起所有 ```c void vTaskSuspendAll( void) ``` > 主要就是设置一个标志位uxSchedulerSuspended, + 恢复挂起 ```c void vTaskResume( TaskHandle_t xTaskToResume ) ``` + 恢复挂起从中断 ```c BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ) ``` > 无论通过调用一次或多次vTaskSuspend()函数而被挂起的任务，也只需调用一次xTaskResumeFromISR()函数即可解挂 > > 返回的值进行表明是不是需要任务切换, 当任务恢复成功并且需要任务切换的话则重置为pdTRUE > > 使用portYIELD_FROM_ISR()进行上下文切换 > > 通常被认为是一个危险的函数，因为它的调用并非是固定的，中断可能随时来来临。所以，xTaskResumeFromISR()不能用于任务和中断间的同步，如果中断恰巧在任务被挂起之前到达，这就会导致一次中断丢失 + 恢复所有的 ```c BaseType_t xTaskResumeAll( void) ``` ### 任务删除 ```c void vTaskDelete( TaskHandle_t xTaskToDelete ) ``` > 删除任务, NULL删除当前任务 > > 这时候删除的任务, 会在空闲任务里面的prvCheckTasksWaitingTermination(), 释放内存 ### 延时函数 ```c void vTaskDelay( constTickType_t xTicksToDelay ) ``` > 阻塞延时, 经过一定时间以后接触阻塞, 并不适用与周期性执行任务的场合 > > 其它任务和中断活动，也会影响到vTaskDelay()的调用 ```c void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) ``` > 绝对延时函数vTaskDelayUntil()，这个绝对延时常用于较精确的周期运行任务 > > 适用于周期性执行的任务。当(*pxPreviousWakeTime + xTimeIncrement)时间到达后，vTaskDelayUntil()函数立刻返回，如果任务是最高优先级的，那么任务会立马解除阻塞 > > 参数: > > 指针，指向一个变量，该变量保存任务最后一次解除阻塞的的时刻。第一次使用时，该变量必须初始化为当前时间，之后这个变量会在vTaskDelayUntil()函数内自动更新。 > > 周期循环时间: 当时间等于(*pxPreviousWakeTime + xTimeIncrement)时，任务解除阻塞 > > 可以使用函数pdMS_TO_TICKS(1000)获取参数二, xTaskGetTickCount()获取参数一 ## 消息队列Queue 用于任务之间的信息传递, 没有任务的时候, 会进入阻塞, 支持FIFO和LIFO, 消息可以设置大小以及个数, 传递的时候使用的是copy ### 创建 ```c #define xQueueCreate( uxQueueLength, uxItemSize ) xQueueGenericCreate( ( uxQueueLength ), ( uxItemSize ), ( queueQUEUE_TYPE_BASE ) ) //相当于 QueueHandle_t xQueueCreate( UBaseType_t uxQueueLength,UBaseType_t uxItemSize ); ``` > uxQueueLength队列能够存储的最大消息单元数目，即队列长度。 > > uxItemSize队列中消息单元的大小，以字节为单位。 > > 如果创建成功则返回一个队列句柄，用于访问创建的队列。如果创建不成功则返回NULL ````c QueueHandle_t xQueueCreateStatic(UBaseType_t uxQueueLength, UBaseType_t uxItemSize, uint8_t *pucQueueStorageBuffer, StaticQueue_t *pxQueueBuffer ); ```` > uxQueueLength队列能够存储的最大单元数目，即队列深度。 > > uxItemSize队列中数据单元的长度，以字节为单位。 > > pucQueueStorageBuffer指针，指向一个uint8_t类型的数组，数组的大小至少有uxQueueLength*uxItemSize个字节。当uxItemSize为0时，pucQueueStorageBuffer可以为NULL。 > > pxQueueBuffer指针，指向StaticQueue_t类型的变量，该变量用于存储队列 > > 如果创建成功则返回一个队列句柄，用于访问创建的队列。如果创建不成功则返回NULL，可能原因是创建队列需要的RAM无法分配成功 ### 删除 ```c void vQueueDelete( QueueHandle_t xQueue ) ``` > 如果删除消息队列时，有任务正在等待消息，则不应该进行删除操作 > > 官方说的是不允许进行删除操作，但是源码并没有禁止删除的操作，使用的时候注意一下就行了 ### 发送消息 ```c #define xQueueSend( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK ) ``` > 用于向队列尾部发送一个队列消息。消息以拷贝的形式入队，而不是以引用的形式。该函数绝对不能在中断服务程序里面被调用，中断中必须使用带有中断保护功能的xQueueSendFromISR()来代替 > > xQueue队列句柄。 > > pvItemToQueue指针，指向要发送到队列尾部的队列消息。 > > xTicksToWait队列满时，等待队列空闲的最大超时时间。如果队列满并且xTicksToWait被设置成0，函数立刻返回。超时时间的单位为系统节拍周期，常量portTICK_PERIOD_MS用于辅助计算真实的时间，单位为ms。如果INCLUDE_vTaskSuspend设置成1，并且指定延时为portMAX_DELAY将导致任务挂起（没有超时）。 > > 消息发送成功成功返回pdTRUE，否则返回errQUEUE_FULL。 ```c #define xQueueSendToFrontFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_FRONT ) #define xQueueSendToBackFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_BACK ) ``` > xQueueSendToBackFromISR等同于xQueueSendFromISR()。 > > xQueue队列句柄。 > > pvItemToQueue指针，指向要发送到队列尾部的消息。 > > pxHigherPriorityTaskWoken如果入队导致一个任务解锁，并且解锁的任务优先级高于当前被中断的任务，则将*pxHigherPriorityTaskWoken设置成pdTRUE，然后在中断退出前需要进行一次上下文切换，去执行被唤醒的优先级更高的任务。从FreeRTOS V7.3.0起，pxHigherPriorityTaskWoken作为一个可选参数，可以设置为NULL。 > > 消息发送成功返回pdTRUE，否则返回errQUEUE_FULL ```c #define xQueueSendToFront( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_FRONT ) ``` > xQueue队列句柄。 > > pvItemToQueue指针，指向要发送到队首的消息。 > > xTicksToWait队列满时，等待队列空闲的最大超时时间。如果队列满并且xTicksToWait被设置成0，函数立刻返回。超时时间的单位为系统节拍周期，常量portTICK_PERIOD_MS用于辅助计算真实的时间，单位为ms。如果INCLUDE_vTaskSuspend设置成1，并且指定延时为portMAX_DELAY将导致任务无限阻塞（没有超时）。 ```c BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition ) ``` > 实际上调用的函数 > > 第一个参数: 一个队列 > > 第二个参数: 要写入的值 > > 第三个参数: 等待的时间 > > 第四个参数: queueSEND_TO_BACK, queueSEND_TO_FRONT ```c BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition ) ``` > 第一个参数: 一个队列 > > 第二个参数: 要写入的值 > > 第三个参数:是否要 > > 第四个参数: queueSEND_TO_BACK, queueSEND_TO_FRONT ### 接受消息 ```c BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait ); ``` > xQueue队列句柄。pvBuffer指针，指向接收到要保存的数据。 > > xTicksToWait队列空时，阻塞超时的最大时间。如果该参数设置为0，函数立刻返回。超时时间的单位为系统节拍周期，常量 > > portTICK_PERIOD_MS用于辅助计算真实的时间，单位为ms。如果INCLUDE_vTaskSuspend设置成1，并且指定延时为portMAX_DELAY将导致任务无限阻塞（没有超时） > > 队列项接收成功返回pdTRUE，否则返回pdFALSE ```c BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait ) ``` > 偷看函数, 不会从队列里面去除数据 ```c BaseType_t xQueueReceiveFromISR(QueueHandle_t xQueue,void *pvBuffer,BaseType_t *pxHigherPriorityTaskWoken); BaseType_t xQueuePeekFromISR(QueueHandle_t xQueue,void *pvBuffer); ``` > 中断中的函数 ```c BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void*pvBuffer TickType_t xTicksToWait BaseType_t xJustPeek) ``` > 多了一个函数参数xJustPeek当为pdTRUE的时候就不用删除，也就是说再调用函数xQueueReceive()获取到的队列项是一样的。当为pdFALSE的时候就会删除掉这个队列项。 > > **这个函数没找到** ## 信号量Semaphore 一个非负的整数, 获取的任务减一, 为0的时候获取就阻塞 通常一个信号量的计数值用于对应有效的资源数，表示剩下的可被占用的互斥资源数 **二值信号量: ** 互斥, 但是优先级不继承, 在信号量中，由于已经不存在可用的信号量，任务递归获取信号量时会发生主动挂起任务最终形成死锁。 **互斥信号量: **有优先级继承的二值信号量 **递归信号量: **获取到信号量的任务可以重复获取信号量, 获取几次就需要释放几次 信号量API函数实际上都是宏，它使用现有的队列机制，这些宏定义在semphr.h文件中，如果使用信号量或者互斥量，需要包含semphr.h头文件 ### 二值信号量 #### 创建 ```c #define xSemaphoreCreateBinary() xQueueGenericCreate( ( UBaseType_t ) 1, semSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_BINARY_SEMAPHORE ) ``` > 实际上就是一个长度为1, 每一个信息大小是1的队列结构体 ### 计数信号量 #### 创建 ```c #define xSemaphoreCreateCounting( uxMaxCount, uxInitialCount ) xQueueCreateCountingSemaphore( ( uxMaxCount ), ( uxInitialCount ) ) ``` > uxMaxCount计数信号量的最大值，当达到这个值的时候，信号量不能再被释放。 > > uxInitialCount创建计数信号量的初始值。 ### 通用 #### 删除 ```c void vSemaphoreDelete( SemaphoreHandle_t xSemaphore ); ``` > xSemaphore信号量句柄。 > > 不会取消任务的阻塞, 不建议使用 #### 释放 ```c #define xSemaphoreGive( xSemaphore )\t\txQueueGenericSend( ( QueueHandle_t ) ( xSemaphore ), NULL, semGIVE_BLOCK_TIME, queueSEND_TO_BACK ) ``` ```c #define xSemaphoreGiveFromISR( xSemaphore, pxHigherPriorityTaskWoken )\txQueueGiveFromISR( ( QueueHandle_t ) ( xSemaphore ), ( pxHigherPriorityTaskWoken ) ) ``` ### 获取 ```c #define xSemaphoreTake( xSemaphore, xBlockTime )\t\txQueueSemaphoreTake( ( xSemaphore ), ( xBlockTime ) ) ``` > xSemaphore信号量句柄。 > > xBlockTime等待信号量可用的最大超时时间，单位为tick（即系统节拍周期）。如果宏INCLUDE_vTaskSuspend定义为1且形参xTicksToWait设置为portMAX_DELAY ，则任务将一直阻塞在该信号量上（即没有超时时间）。 > > 获取成功则返回pdTRUE，在指定的超时时间中没有获取成功则返回errQUEUE_EMPTY。 ```c #define xSemaphoreTakeFromISR( xSemaphore, pxHigherPriorityTaskWoken )\txQueueReceiveFromISR( ( QueueHandle_t ) ( xSemaphore ), NULL, ( pxHigherPriorityTaskWoken ) ) ``` ## 互斥量 特殊的二值信号量, 它支持互斥量所有权、递归访问以及防止优先级翻转的特性 持有该互斥量的任务也能够再次获得这个锁而不被挂起，这就是递归访问，也就是递归互斥量的特性 另外需要注意的是互斥量不能在中断服务函数中使用，因为其特有的优先级继承机制只在任务起作用，在中断的上下文环境毫无意义。 ### 创建(普通) ```c #define xSemaphoreCreateMutex() xQueueCreateMutex( queueQUEUE_TYPE_MUTEX ) #define xSemaphoreCreateMutexStatic( pxMutexBuffer ) xQueueCreateMutexStatic( queueQUEUE_TYPE_MUTEX, ( pxMutexBuffer ) ) ``` > 创建并且初始化uxQueueType ### 创建(递归) ```c #define xSemaphoreCreateRecursiveMutex() xQueueCreateMutex( queueQUEUE_TYPE_RECURSIVE_MUTEX ) ``` ### 删除 ```c void vSemaphoreDelete( SemaphoreHandle_t xSemaphore ); ``` ### 获取 ```c #define xSemaphoreTake( xSemaphore, xBlockTime )\t\txQueueSemaphoreTake( ( xSemaphore ), ( xBlockTime ) ) ``` ### 获取(递归) ```c #define xSemaphoreTakeRecursive( xMutex, xBlockTime )\txQueueTakeMutexRecursive( ( xMutex ), ( xBlockTime ) ) ``` ### 释放 ```c #define xSemaphoreGive( xSemaphore )\t\txQueueGenericSend( ( QueueHandle_t ) ( xSemaphore ), NULL, semGIVE_BLOCK_TIME, queueSEND_TO_BACK ) ``` ### 释放(递归) ```c #define xSemaphoreGiveRecursive( xMutex )\txQueueGiveMutexRecursive( ( xMutex ) ) ``` ## 事件 可以实现任务之间的信息传递, 可以一对多, 多对多, 只可以用于同步, 不可以传递数据 可以是任意一个事件发生时唤醒任务进行事件处理；也可以是几个事件都发生后才唤醒任务进行事件处理。同样，也可以是多个任务同步多个事件。 事件组存储在一个EventBits_t类型的变量中, 有24个位用来实现事件标志组。每一位代表一个事件，任务通过“逻辑与”或“逻辑或”与一个或多个事件建立关联，形成一个事件组。 ### 获取 ```c EventGroupHandle_t xEventGroupCreate( void ) EventGroupHandle_t xEventGroupCreateStatic( StaticEventGroup_t *pxEventGroupBuffer ) ``` ### 删除 ```c void vEventGroupDelete( EventGroupHandle_t xEventGroup ) ``` ### 置位 ```c EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet ) ``` > 参数是要设置的那几个位, 用的是或的方式 ````c #define xEventGroupSetBitsFromISR( xEventGroup, uxBitsToSet, pxHigherPriorityTaskWoken ) xTimerPendFunctionCallFromISR( vEventGroupSetBitsCallback, ( void * ) xEventGroup, ( uint32_t ) uxBitsToSet, pxHigherPriorityTaskWoken ) ```` > xEventGroupSetBitsFromISR()给FreeRTOS的守护任务发送一个消息，让置位事件组的操作在守护任务里面完成 > > 因此FreeRTOS的守护任务与其他任务一样，都是系统调度器根据其优先级进行任务调度的，但守护任务的优先级必须比任何任务的优先级都要高，保证在需要的时候能立即切换任务从而达到快速处理的目的 > > 必须把configUSE_TIMERS 和INCLUDE_xTimerPendFunctionCall这些宏在FreeRTOSConfig.h中都定义为1，并且把FreeRTOS/source/event_groups.c这个C文件添加到工程中编译。 ### 等待标志位 ```c EventBits_t xEventGroupWaitBits(const EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait ); ``` > xEventGroup事件句柄。 > > uxBitsToWaitFor一个按位或的值，指定需要等待事件组中的哪些位置1。如果需要等待bit 0 and/or bit 2那么uxBitsToWaitFor配置为0x05(0101b)。如果需要等待bits 0 and/or bit 1 and/or bit 2那么uxBitsToWaitFor配置为0x07(0111b)。 > > xClearOnExit: pdTRUE：当xEventGroupWaitBits()等待到满足任务唤醒的事件时，系统将清除由形参uxBitsToWaitFor指定的事件标志位。pdFALSE：不会清除由形参uxBitsToWaitFor指定的事件标志位。 > > xWaitForAllBits: pdTRUE：当形参uxBitsToWaitFor指定的位都置位的时候，xEventGroupWaitBits()才满足任务唤醒的条件，这也是“逻辑与”等待事件，并且在没有超时的情况下返回对应的事件标志位的值。pdFALSE：当形参uxBitsToWaitFor指定的位有其中任意一个置位的时候，这也是常说的“逻辑或”等待事件，在没有超时的情况下函数返回对应的事件标志位的值。 > > xTicksToWait最大超时时间，单位为系统节拍周期，常量portTICK_PERIOD_MS用于辅助把时间转换成MS。 ### 清除事件标志位 ```c EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear ) ``` ```c BaseType_t xEventGroupClearBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear ) ``` > 这个任务实际上就是会把清除放在一个高优先级的任务里面 ### 获取当前的事件 ```c #define xEventGroupGetBits( xEventGroup ) xEventGroupClearBits( xEventGroup, 0 ) ``` ## 软件定时器 而使用软件定时器时，需要我们在创建软件定时器时指定时间到达后要调用的函数 FreeRTOS提供的软件定时器支持单次模式和周期模式，单次模式和周期模式的定时时间到之后都会调用软件定时器的回调函数 ### 创建时钟 ```c TimerHandle_t xTimerCreate(\tconst char * const pcTimerName,\t const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction ) ``` > pcTimerName: 名字 > > xTimerPeriodInTicks: 记录周期 > > uxAutoReload: 设置为pdTRUE，那么软件定时器的工作模式就是周期模式，一直会以用户指定的xTimerPeriod周期去执行回调函数。如果uxAutoReload 设置为pdFALSE，那么软件定时器就在用户指定的xTimerPeriod周期下运行一次后就进入休眠态。 > > 软件定时器ID，数字形式 > > 回调函数 ### 启动 ```c #define xTimerStart( xTimer, xTicksToWait ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_START, ( xTaskGetTickCount() ), NULL, ( xTicksToWait ) ) ``` > 实际上是给时钟的处理函数发送一个命令 ```c #define xTimerStartFromISR( xTimer, pxHigherPriorityTaskWoken ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_START_FROM_ISR, ( xTaskGetTickCountFromISR() ),( pxHigherPriorityTaskWoken ), 0U ) ``` ### 时钟停止 ```c #define xTimerStop( xTimer, xTicksToWait ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_STOP, 0U, NULL, ( xTicksToWait ) ) ``` ```c #define xTimerStopFromISR( xTimer, pxHigherPriorityTaskWoken ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_STOP_FROM_ISR, 0, ( pxHigherPriorityTaskWoken ), 0U ) ``` ### 时钟删除 ```c #define xTimerDelete( xTimer, xTicksToWait ) xTimerGenericCommand( ( xTimer ), tmrCOMMAND_DELETE, 0U, NULL, ( xTicksToWait ) ) ``` ## 任务通知 每个任务都有一个32位的通知值，在大多数情况下，任务通知可以替代二值信号量、计数信号量、事件组，也可以替代长度为1的队列 + 发送通知给任务，如果有通知未读，不覆盖通知值。 + 发送通知给任务，直接覆盖通知值。 + 发送通知给任务，设置通知值的一个或者多个位，可以当做事件组来使用。 + 发送通知给任务，递增通知值，可以当做计数信号量使用。 缺点 + 只能有一个任务接收通知消息，因为必须指定接收通知的任务。。 + 只有等待通知的任务可以被阻塞，发送通知的任务，在任何情况下都不会因为发送失败而进入阻塞态。 ### 可以使用的模式 + eNoAction: 对象任务接收任务通知，但是任务自身的任务通知值不更新，即形参ulValue没有用。 + eSetBits: 对象任务接收任务通知，同时任务自身的任务通知值与ulValue按位或。如果ulValue设置为0x01，那么任务的通知值的位0将被置为1。同样的如果ulValue设置为0x04，那么任务的通知值的位2将被置为1。在这种方式下，任务通知可以看成是事件标志的一种轻量型的实现，速度更快。 + eIncrement: 对象任务接收任务通知，任务自身的任务通知值加1，即形参ulValue没有用。这个时候调用xTaskNotify()等同于调用xTaskNotifyGive()。 + eSetValueWithOverwrite对象任务接收任务通知，且任务自身的任务通知值会无条件的被设置为ulValue。在这种方式下，任务通知可以看成是函数xQueueOverwrite()的一种轻量型的实现，速度更快。 + eSetValueWithoutOverwrite: 对象任务接收任务通知，且对象任务没有通知值，那么通知值就会被设置为ulValue。 ### 发送一个任务通知 ```c BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue ) ``` > xTaskToNotify: 通知的任务 > > ulValue: 要发送的值 > > eAction: 一个枚举类型, 指明更新的方式 > > pulPreviousNotificationValue: 返回原来的值 ```c BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken ) ``` > 多了一个需要进行切换的标志位 ### 使用(发送) ```c xTaskNotifyGive()#define xTaskNotifyGive( xTaskToNotify ) xTaskGenericNotify( ( xTaskToNotify ), ( 0 ), eIncrement, NULL ) ``` > 即向一个任务发送通知，并将对方的任务通知值加1。 ```c void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken ) ``` > 中断中使用 ```c #define xTaskNotify( xTaskToNotify, ulValue, eAction ) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL ) ``` > xTaskToNotify需要接收通知的任务句柄。ulValue用于更新接收任务通知的任务通知值，具体如何更新由形参eAction决定。eAction任务通知值更新方式 > > 实际上就是一个不需要返回值的xTaskGenericNotify ```c #define xTaskNotifyFromISR( xTaskToNotify, ulValue, eAction, pxHigherPriorityTaskWoken ) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL, ( pxHigherPriorityTaskWoken ) ) ``` > 同上 ```c #define xTaskNotifyAndQuery( xTaskToNotify, ulValue, eAction, pulPreviousNotifyValue ) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotifyValue ) ) ``` ```c #define xTaskNotifyAndQueryFromISR( xTaskToNotify, ulValue, eAction, pulPreviousNotificationValue, pxHigherPriorityTaskWoken ) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotificationValue ), ( pxHigherPriorityTaskWoken ) ) ``` > 这个的使用就是xTaskGenericNotify ### 使用(接收) **获取任务通知函数只能用在任务中，没有带中断保护版本** ```c uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait ) ``` > 使得值减一 ```c BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait ) ``` > ulBitsToClearOnEntry: ulBitsToClearOnEntry表示在使用通知之前，将任务通知值的哪些位 清0，实现 过程就是将任务的通知值与参数ulBitsToClearOnEntry的按位取反值按位与操作。 > > ulBitsToClearOnExitulBitsToClearOnExit表示在函数xTaskNotifyWait()退出前，决定任务接收到的通知值的哪些位会被清0，实现过程就是将任务的通知值与参数ulBitsToClearOnExit的按位取反值按位与操作。在清0前，接收到的任务通知值会先被保存到形参*pulNotificationValue中。 > > pulNotificationValue用于保存接收到的任务通知值。如果接收到的任务通知不需要使用， 则设置 为NULL即可。这个通知值在参 数ulBitsToClearOnExit起 作 用 前 将 通 知 值 拷 贝 到*pulNotificationValue中。 > > xTicksToWait等待超时时间，单位为系统节拍周期。宏pdMS_TO_TICKS用于将单位毫秒转化为系统节拍数。 ## 内存管理 嵌入式时实时操作系统的需求是 1. 实时性, 分配使用的时间是确定的 2. 需要的内存比较小 3. 操控的内存不会碎片化 ### 实现的接口 ```c void*pvPortMalloc( size_txSize ); //内存申请函数 voidvPortFree( void*pv ); //内存释放函数 voidvPortInitialiseBlocks( void); //初始化内存堆函数 size_txPortGetFreeHeapSize( void); //获取当前未分配的内存堆大小 size_txPortGetMinimumEverFreeHeapSize( void); //获取未分配的内存堆历史最小值 ``` ### 不同的实现 heap_1, heap_2, heap_4使用的方案是有一个大的数组, heap_3对C库的malloc和free进行封装, heap_5允许用户使用多个不连续的内存, 每个内存堆的起始地址和大小由用户定义 ### heap_1 它只能申请内存而不能进行内存释放，并且申请内存的时间是一个常量，这样子对于要求安全的嵌入式设备来说是最好的，因为不允许内存释放，就不会产生内存碎片而导致系统崩溃 ### heap_2 可以进行申请和释放, 返回的是大小最接近的一个内存的位置, 但是不能进行相邻内存的合并, 适用于分配的内存大小比较接近的情况 ### heap_3 只是简单的封装了标准C库中的malloc()和free()函数 重新封装后的malloc()和free()函数具有保护功能，采用的封装方式是操作内存前挂起调度器、完成后再恢复调度器 使用heap_3.c方案时，FreeRTOSConfig.h文 件 中 的configTOTAL_HEAP_SIZE宏定义不起作用 ### heap_4 heap_4.c方案与heap_2.c方案一样都采用最佳匹配算法来实现动态的内存分配，但是不一样的是heap_4.c方案还包含了一种合并算法，能把相邻的空闲的内存块合并成一个更大的块，这样可以减少内存碎片 移植层中可以直接使用pvPortMalloc()和vPortFree()函数来分配和释放内存的代码 ### heap_5 在4的基础上加了一个可以使用多块内存 通过调用vPortDefineHeapRegions()函数来实现系统管理的内存初始化 ```c void vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions ) ``` ```c typedef struct HeapRegion { uint8_t * pucStartAddress; size_t xSizeInBytes; } HeapRegion_t; ``` > 用户需要指定每个内存堆区域的起始地址和内存堆大小、将它们放在一个HeapRegion_t结构体类型数组中，这个数组必须用一个NULL指针和0作为结尾，起始地址必须从小到大排列。 ## 中断管理 用户可以定义中断的优先级, 在比这个优先级高的中断函数里面不可以使用FreeRTOS的API函数 ## CPU使用率统计 会使用一个频率很高的时钟进行统计, 这个记录有一个毛病, 没有做时钟溢出的处理, 一旦溢出就会导致出问题 需要配置两个宏定义 ```c //启动运行时间统计 #define configGENERATE_RUN_TIME_STATS 1 //启用一个可视化的跟踪 #define configUSE_TRACE_FACILITY\t\t1 ``` ```c //一个恢复时钟为0的宏定义, 这一个宏实际的用途的初始化 #define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() (CPU_RunTime 0ul) //一个获取时钟的宏 #define portGET_RUN_TIME_COUNTER_VALUE() CPU_RunTime ``` > * portGET_RUN_TIME_COUNTER_VALUE()：直接返回时钟值 > * portALT_GET_RUN_TIME_COUNTER_VALUE(Time)：设置Time变量等于时钟值 > > 需要实现其中一个, 用于获取时钟 ```c void vTaskList( char * pcWriteBuffer ); //获取任务运行时间信息 printf(\" \\r\\n\"); printf(\"任务名任务状态优先级剩余栈任务序号\\r\\n\"); printf(\"%s\", CPU_RunInfo); printf(\" \\r\\n\"); void vTaskGetRunTimeStats( char *pcWriteBuffer ); printf(\"任务名运行计数使用率\\r\\n\"); printf(\"%s\", CPU_RunInfo); printf(\" \\r\\n\\n\"); ``` ## 使用的时候出现的问题 ### 中断开启时间 FreeRTOS的中断里面如果使用FromIRQ函数, 需要在开启任务以后 ### 中断优先级 设置的中断如果使用FromIRQ函数需要优先级比较低 ![QQ图片20240124230127](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401242301196.png)"},"/note/嵌入式/第三方移植/freeRTOS/2023-11-23-08wds优化.html":{"title":"优化","content":" layout: post title: \"优化\" date: 2023 11 22 15:39:08 +0800 tags: FreeRTOS # 优化 ## 栈的使用情况 在创建任务时分配了栈，可以填入固定的数值比如0xa5，以后可以使用以下函数查看\"栈的高水位\"，也就是还有多少空余的栈空间： ```c UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ); ``` 原理是：从栈底往栈顶逐个字节地判断，它们的值持续是0xa5就表示它是空闲的。 > 任务运行时、任务被切换时，都会用到栈。栈里原来值(0xa5)就会被覆盖。逐个函数从栈的尾部判断栈的值连续为0xa5的个数，它就是任务运行过程中空闲内存容量的最小值。注意：假设从栈尾开始连续为0xa5的栈空间是N字节，返回值是N/4。 ## 任务的运行时间统计 对于同优先级的任务，它们按照时间片轮流运行：你执行一个Tick，我执行一个Tick。 是否可以在Tick中断函数中，统计当前任务的累计运行时间？ 不行！很不精确，因为有更高优先级的任务就绪时，当前任务还没运行一个完整的Tick就被抢占了。 我们需要比Tick更快的时钟，比如Tick周期时1ms，我们可以使用另一个定时器，让它发生中断的周期时0.1ms甚至更短。 使用这个定时器来衡量一个任务的运行时间 ![image 20231123200019498](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311232000553.png) * 切换到Task1时，使用更快的定时器记录当前时间T1 * Task1被切换出去时，使用更快的定时器记录当前时间T4 * (T4 T1)就是它运行的时间，累加起来 * 关键点：在`vTaskSwitchContext`函数中，使用**更快的定时器**统计运行时间 > 还可以使用一个变量count记录当前的时钟中断的个数, 在任务切换的时候记录Timer的值, 在加上之前记录count从而获得精确地数值 配置 ```c #define configGENERATE_RUN_TIME_STATS 1 //初始化这一个以后需要再定义一个初始化我们使用的时钟的函数 #define configCONFIGURE_TIMER_FOR_RUN_TIME_STATS Timer_Init //一个获取这个时间的函数 /* #ifdef portALT_GET_RUN_TIME_COUNTER_VALUE //记录总的运行时间 portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime ); #else ulTotalRunTime portGET_RUN_TIME_COUNTER_VALUE(); #endif */ #define configUSE_TRACE_FACILITY 1 #define configUSE_STATS_FORMATTING_FUNCTIONS 1 ``` * 实现宏`portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()`，它用来初始化更快的定时器 * 实现这两个宏之一，它们用来返回当前时钟值(更快的定时器) * portGET_RUN_TIME_COUNTER_VALUE()：直接返回时钟值 * portALT_GET_RUN_TIME_COUNTER_VALUE(Time)：设置Time变量等于时钟值 > 可以使用初始化一个外设时钟, 之后使用这一个时钟进行获取时间 ```c #if ( configGENERATE_RUN_TIME_STATS 1 ) { #ifdef portALT_GET_RUN_TIME_COUNTER_VALUE //记录总的运行时间 portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime ); #else ulTotalRunTime portGET_RUN_TIME_COUNTER_VALUE(); #endif /* Add the amount of time the task has been running to the * accumulated time so far. The time the task started running was * stored in ulTaskSwitchedInTime. Note that there is no overflow * protection here so count values are only valid until the timer * overflows. The guard against negative values is to protect * against suspect run time stat counter implementations which * are provided by the application, not the kernel. */ if( ulTotalRunTime > ulTaskSwitchedInTime ) { pxCurrentTCB >ulRunTimeCounter + ( ulTotalRunTime ulTaskSwitchedInTime ); }//把这一次的运行时间进行累加 else { mtCOVERAGE_TEST_MARKER(); } ulTaskSwitchedInTime ulTotalRunTime; } #endif /* configGENERATE_RUN_TIME_STATS */ ``` > 在切换任务的时候如果有这一个宏 ### 信息获取 获得统计信息，可以使用下列函数 * uxTaskGetSystemState：对于每个任务它的统计信息都放在一个TaskStatus_t结构体里 * vTaskList：得到的信息是可读的字符串，比如 * vTaskGetRunTimeStats： 得到的信息是可读的字符串，比如 * uxTaskGetSystemState：获得任务的统计信息 ```c UBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime ); ``` 参数 描述 pxTaskStatusArray 指向一个TaskStatus_t结构体数组，用来保存任务的统计信息。<br />有多少个任务？可以用`uxTaskGetNumberOfTasks()`来获得。 uxArraySize 数组大小、数组项个数，必须大于或等于`uxTaskGetNumberOfTasks()` pulTotalRunTime 用来保存当前总的运行时间(更快的定时器)，可以传入NULL 返回值 传入的pxTaskStatusArray数组，被设置了几个数组项。<br />注意：如果传入的uxArraySize小于`uxTaskGetNumberOfTasks()`，返回值就是0 vTaskList ：获得任务的统计信息，形式为可读的字符串。注意，pcWriteBuffer必须足够大。 * vTaskList ：获得任务的统计信息，形式为可读的字符串。注意，pcWriteBuffer必须足够大。 ```c void vTaskList( signed char *pcWriteBuffer ); ``` 可读信息格式如下： ![image 20231123201628469](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311232016515.png) * vTaskGetRunTimeStats：获得任务的运行信息，形式为可读的字符串。注意，pcWriteBuffer必须足够大。 ```c void vTaskGetRunTimeStats( signed char *pcWriteBuffer ); ``` 可读信息格式如下： ![image 20231123201642764](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311232016803.png)"},"/note/嵌入式/第三方移植/freeRTOS/2023-7-12-fire9移植.html":{"title":"移植","content":" layout: post title: \"移植\" date: 2023 7 12 15:39:08 +0800 tags: FreeRTOS # 移植 + Source + + portable文件夹, 编译器相关文件 + MenMang内存管理 + Demo各种开发平台 + License文件夹, 许可证 + FreeRTOS Plus第三方产品 1. 复制GPIO固件库点灯实验 2. 创建FreeRTOS文件夹 3. 移植源码 ![image 20230712164932158](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401251341393.png) ![image 20230712164943637](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401251341394.png) ![image 20230712164954799](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401251341395.png) > 从Demo选择最相似的文件从中拷贝配置文件 ![image 20230712165141311](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401251341396.png) ![image 20230712165706895](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401251341397.png) ## FreeRTOSConfig ```c /* FreeRTOS V9.0.0 Copyright (C) 2016 Real Time Engineers Ltd. All rights reserved VISIT http://www.FreeRTOS.org TO ENSURE YOU ARE USING THE LATEST VERSION. This file is part of the FreeRTOS distribution. FreeRTOS is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License (version 2) as published by the Free Software Foundation >>>> AND MODIFIED BY <<<< the FreeRTOS exception. *************************************************************************** >>! NOTE: The modification to the GPL is included to allow you to !<< >>! distribute a combined work that includes FreeRTOS without being !<< >>! obliged to provide the source code for proprietary components !<< >>! outside of the FreeRTOS kernel. !<< *************************************************************************** FreeRTOS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. Full license text is available on the following link: http://www.freertos.org/a00114.html *************************************************************************** * * * FreeRTOS provides completely free yet professionally developed, * * robust, strictly quality controlled, supported, and cross * * platform software that is more than just the market leader, it * * is the industry's de facto standard. * * * * Help yourself get started quickly while simultaneously helping * * to support the FreeRTOS project by purchasing a FreeRTOS * * tutorial book, reference manual, or both: * * http://www.FreeRTOS.org/Documentation * * * *************************************************************************** http://www.FreeRTOS.org/FAQHelp.html Having a problem? Start by reading the FAQ page \"My application does not run, what could be wrong?\". Have you defined configASSERT()? http://www.FreeRTOS.org/support In return for receiving this top quality embedded software for free we request you assist our global community by participating in the support forum. http://www.FreeRTOS.org/training Investing in training allows your team to be as productive as possible as early as possible. Now you can receive FreeRTOS training directly from Richard Barry, CEO of Real Time Engineers Ltd, and the world's leading authority on the world's leading RTOS. http://www.FreeRTOS.org/plus A selection of FreeRTOS ecosystem products, including FreeRTOS+Trace an indispensable productivity tool, a DOS compatible FAT file system, and our tiny thread aware UDP/IP stack. http://www.FreeRTOS.org/labs Where new FreeRTOS products go to incubate. Come and try FreeRTOS+TCP, our new open source TCP/IP stack for FreeRTOS. http://www.OpenRTOS.com Real Time Engineers ltd. license FreeRTOS to High Integrity Systems ltd. to sell under the OpenRTOS brand. Low cost OpenRTOS licenses offer ticketed support, indemnification and commercial middleware. http://www.SafeRTOS.com High Integrity Systems also provide a safety engineered and independently SIL3 certified version for use in safety and mission critical applications that require provable dependability. */ #ifndef FREERTOS_CONFIG_H #define FREERTOS_CONFIG_H #include \"stm32f10x.h\" #include \"bsp_usart.h\" //针对不同的编译器调用不同的stdint.h文件 #if defined(__ICCARM__) defined(__CC_ARM) defined(__GNUC__) #include <stdint.h> extern uint32_t SystemCoreClock; #endif //断言 #define vAssertCalled(char,int) printf(\"Error:%s,%d\\r\\n\",char,int) #define configASSERT(x) if((x) 0) vAssertCalled(__FILE__,__LINE__) /************************************************************************ * FreeRTOS基础配置配置选项 *********************************************************************/ /* 置1：RTOS使用抢占式调度器；置0：RTOS使用协作式调度器（时间片） * * 注：在多任务管理机制上，操作系统可以分为抢占式和协作式两种。 * 协作式操作系统是任务主动释放CPU后，切换到下一个任务。 * 任务切换的时机完全取决于正在运行的任务。 */ #define configUSE_PREEMPTION\t\t\t\t\t 1 //1使能时间片调度(默认式使能的) #define configUSE_TIME_SLICING\t\t\t\t\t1\t\t /* 某些运行FreeRTOS的硬件有两种方法选择下一个要执行的任务： * 通用方法和特定于硬件的方法（以下简称“特殊方法”）。 * * 通用方法： * 1.configUSE_PORT_OPTIMISED_TASK_SELECTION 为 0 或者硬件不支持这种特殊方法。 * 2.可以用于所有FreeRTOS支持的硬件 * 3.完全用C实现，效率略低于特殊方法。 * 4.不强制要求限制最大可用优先级数目 * 特殊方法： * 1.必须将configUSE_PORT_OPTIMISED_TASK_SELECTION设置为1。 * 2.依赖一个或多个特定架构的汇编指令（一般是类似计算前导零[CLZ]指令）。 * 3.比通用方法更高效 * 4.一般强制限定最大可用优先级数目为32 * 一般是硬件计算前导零指令，如果所使用的，MCU没有这些硬件指令的话此宏应该设置为0！ */ #define configUSE_PORT_OPTIMISED_TASK_SELECTION\t 1 /* 置1：使能低功耗tickless模式；置0：保持系统节拍（tick）中断一直运行 * 假设开启低功耗的话可能会导致下载出现问题，因为程序在睡眠中,可用以下办法解决 * * 下载方法： * 1.将开发版正常连接好 * 2.按住复位按键，点击下载瞬间松开复位按键 * * 1.通过跳线帽将 BOOT 0 接高电平(3.3V) * 2.重新上电，下载 * * \t\t\t1.使用FlyMcu擦除一下芯片，然后进行下载 *\t\t\tSTMISP > 清除芯片(z) */ #define configUSE_TICKLESS_IDLE\t\t\t\t\t\t\t\t\t\t\t\t\t0 /* * 写入实际的CPU内核时钟频率，也就是CPU指令执行频率，通常称为Fclk * Fclk为供给CPU内核的时钟信号，我们所说的cpu主频为 XX MHz， * 就是指的这个时钟信号，相应的，1/Fclk即为cpu时钟周期； */ #define configCPU_CLOCK_HZ\t\t\t\t\t\t (SystemCoreClock) //RTOS系统节拍中断的频率。即一秒中断的次数，每次中断RTOS都会进行任务调度 #define configTICK_RATE_HZ\t\t\t\t\t\t (( TickType_t )1000) //可使用的最大优先级 #define configMAX_PRIORITIES\t\t\t\t\t (32) //空闲任务使用的堆栈大小 #define configMINIMAL_STACK_SIZE\t\t\t\t((unsigned short)128) //任务名字字符串长度 #define configMAX_TASK_NAME_LEN\t\t\t\t\t(16) //系统节拍计数器变量数据类型，1表示为16位无符号整形，0表示为32位无符号整形 #define configUSE_16_BIT_TICKS\t\t\t\t\t0 //空闲任务放弃CPU使用权给其他同优先级的用户任务 #define configIDLE_SHOULD_YIELD\t\t\t\t\t1 //启用队列集合, 可以吧多个队列加入到一个集合里面, 同时等待, 许任务同时监听多个队列或信号量，并在其中任何一个有数据时唤醒任务。 #define configUSE_QUEUE_SETS\t\t\t\t\t 0 //开启任务通知功能，默认开启 #define configUSE_TASK_NOTIFICATIONS 1 //使用互斥信号量 #define configUSE_MUTEXES\t\t\t\t\t\t 0 //使用递归互斥信号量 #define configUSE_RECURSIVE_MUTEXES\t\t\t0 //为1时使用计数信号量 #define configUSE_COUNTING_SEMAPHORES\t\t0 /* 设置可以注册的信号量和消息队列个数 */ #define configQUEUE_REGISTRY_SIZE\t\t\t\t10 #define configUSE_APPLICATION_TASK_TAG\t\t 0 /***************************************************************** FreeRTOS与内存申请有关配置选项 *****************************************************************/ //支持动态内存申请 #define configSUPPORT_DYNAMIC_ALLOCATION 1 //支持静态内存 #define configSUPPORT_STATIC_ALLOCATION\t\t\t\t\t0\t\t\t\t\t //系统所有总的堆大小 #define configTOTAL_HEAP_SIZE\t\t\t\t\t((size_t)(36*1024)) /*************************************************************** FreeRTOS与钩子函数有关的配置选项 **************************************************************/ /* 置1：使用空闲钩子（Idle Hook类似于回调函数）；置0：忽略空闲钩子 * * 空闲任务钩子是一个函数，这个函数由用户来实现， * FreeRTOS规定了函数的名字和参数：void vApplicationIdleHook(void )， * 这个函数在每个空闲任务周期都会被调用 * 对于已经删除的RTOS任务，空闲任务可以释放分配给它们的堆栈内存。 * 因此必须保证空闲任务可以被CPU执行 * 使用空闲钩子函数设置CPU进入省电模式是很常见的 * 不可以调用会引起空闲任务阻塞的API函数 */ #define configUSE_IDLE_HOOK\t\t\t\t\t\t0 /* 置1：使用时间片钩子（Tick Hook）；置0：忽略时间片钩子 * * * 时间片钩子是一个函数，这个函数由用户来实现， * FreeRTOS规定了函数的名字和参数：void vApplicationTickHook(void ) * 时间片中断可以周期性的调用 * 函数必须非常短小，不能大量使用堆栈， * 不能调用以”FromISR\" 或 \"FROM_ISR”结尾的API函数 */ /*xTaskIncrementTick函数是在xPortSysTickHandler中断函数中被调用的。因此，vApplicationTickHook()函数执行的时间必须很短才行*/ #define configUSE_TICK_HOOK\t\t\t\t\t\t0 //使用内存申请失败钩子函数 #define configUSE_MALLOC_FAILED_HOOK\t\t\t0 /* * 大于0时启用堆栈溢出检测功能，如果使用此功能 * 用户必须提供一个栈溢出钩子函数，如果使用的话 * 此值可以为1或者2，因为有两种栈溢出检测方法 */ #define configCHECK_FOR_STACK_OVERFLOW\t\t\t0 /******************************************************************** FreeRTOS与运行时间和任务状态收集有关的配置选项 **********************************************************************/ //启用运行时间统计功能 #define configGENERATE_RUN_TIME_STATS\t 0 //启用可视化跟踪调试 #define configUSE_TRACE_FACILITY\t\t\t\t 0 /* 与宏configUSE_TRACE_FACILITY同时为1时会编译下面3个函数 * prvWriteNameToBuffer() * vTaskList(), * vTaskGetRunTimeStats() */ #define configUSE_STATS_FORMATTING_FUNCTIONS\t1 /******************************************************************** FreeRTOS与协程有关的配置选项 *********************************************************************/ //启用协程，启用协程以后必须添加文件croutine.c #define configUSE_CO_ROUTINES \t\t\t 0 //协程的有效优先级数目 #define configMAX_CO_ROUTINE_PRIORITIES ( 2 ) /*********************************************************************** FreeRTOS与软件定时器有关的配置选项 **********************************************************************/ //启用软件定时器 #define configUSE_TIMERS\t\t\t\t 0 //软件定时器优先级 #define configTIMER_TASK_PRIORITY\t\t (configMAX_PRIORITIES 1) //软件定时器队列长度 #define configTIMER_QUEUE_LENGTH\t\t 10 //软件定时器任务堆栈大小 #define configTIMER_TASK_STACK_DEPTH\t (configMINIMAL_STACK_SIZE*2) /************************************************************ FreeRTOS可选函数配置选项 ************************************************************/ #define INCLUDE_xTaskGetSchedulerState 1 #define INCLUDE_vTaskPrioritySet\t\t 1 #define INCLUDE_uxTaskPriorityGet\t\t 1 #define INCLUDE_vTaskDelete\t\t\t\t 1 #define INCLUDE_vTaskCleanUpResources\t 1 #define INCLUDE_vTaskSuspend\t\t\t 1 #define INCLUDE_vTaskDelayUntil\t\t\t 1 #define INCLUDE_vTaskDelay\t\t\t\t 1 #define INCLUDE_eTaskGetState\t\t\t 1 #define INCLUDE_xTimerPendFunctionCall\t 0 //#define INCLUDE_xTaskGetCurrentTaskHandle 1 //#define INCLUDE_uxTaskGetStackHighWaterMark 0 //#define INCLUDE_xTaskGetIdleTaskHandle 0 /****************************************************************** FreeRTOS与中断有关的配置选项 ******************************************************************/ #ifdef __NVIC_PRIO_BITS \t#define configPRIO_BITS \t\t__NVIC_PRIO_BITS #else \t#define configPRIO_BITS \t\t4 #endif //中断最低优先级 #define configLIBRARY_LOWEST_INTERRUPT_PRIORITY\t\t\t15 //系统可管理的最高中断优先级 #define configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY\t5 #define configKERNEL_INTERRUPT_PRIORITY \t\t( configLIBRARY_LOWEST_INTERRUPT_PRIORITY << (8 configPRIO_BITS) )\t/* 240 */ #define configMAX_SYSCALL_INTERRUPT_PRIORITY \t( configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY << (8 configPRIO_BITS) ) /**************************************************************** FreeRTOS与中断服务函数有关的配置选项 ****************************************************************/ #define xPortPendSVHandler \tPendSV_Handler #define vPortSVCHandler \tSVC_Handler /* 以下为使用Percepio Tracealyzer需要的东西，不需要时将 configUSE_TRACE_FACILITY 定义为 0 */ #if ( configUSE_TRACE_FACILITY 1 ) #include \"trcRecorder.h\" #define INCLUDE_xTaskGetCurrentTaskHandle 1 // 启用一个可选函数（该函数被 Trace源码使用，默认该值为0 表示不用） #endif #endif /* FREERTOS_CONFIG_H */ ``` > 之后添加串口文件 SVC和PendSV中断重复实现, 所以需要把stm32f10x_it.h文件夹下面的注释掉 + 由于这时候Systick函数使用的是stm32官方的函数所以需要调用FreeRTOS的函数 ```c void SysTick_Handler(void) { \txPortSysTickHandler(); } ```"},"/note/嵌入式/第三方移植/freeRTOS/2023-11-23-wds07调试.html":{"title":"调试","content":" layout: post title: \"调试\" date: 2023 11 22 15:39:08 +0800 tags: FreeRTOS # 调试 一般来说有四种方式 1. 微库打印 2. 断言 3. Trace 4. Hook函数(回调函数) ## 打印 使用微库函数的时候可以使用printf进行打印 ## 断言 一般在C库里面断言就是一个函数 ```c void assert(scalar expression); ``` > 作用就是确定expression是真的话就终止程序 在FreeRTOS里面使用的是configASSERT(x) 默认是空的, 一般FreeRTOS里面会调用很多次这个, 来判断参数是否有效 在FreeRTOS里，使用`configASSERT()`，比如： ```c #define configASSERT(x) if (!x) while(1); ``` 我们可以让它提供更多信息，比如： ```c #define configASSERT(x) \\ \tif (!x) \\ \t{ \t\tprintf(\"%s %s %d\\r\\n\", __FILE__, __FUNCTION__, __LINE__); \\ while(1); \\ \t} ``` ## Trace FreeRTOS里面有很多个以这个开头的宏, 会被放在一些关键位置 它们一般都是空的宏，这不会影响代码：不影响编程处理的程序大小、不影响运行时间。 我们要调试某些功能时，可以修改宏：修改某些标记变量、打印信息等待。 trace宏 描述 traceTASK_INCREMENT_TICK(xTickCount) 当tick计数自增之前此宏函数被调用。参数xTickCount当前的Tick值，它还没有增加。 traceTASK_SWITCHED_OUT() vTaskSwitchContext中，把当前任务切换出去之前调用此宏函数。 traceTASK_SWITCHED_IN() vTaskSwitchContext中，新的任务已经被切换进来了，就调用此函数。 traceBLOCKING_ON_QUEUE_RECEIVE(pxQueue) 当正在执行的当前任务因为试图去读取一个空的队列、信号或者互斥量而进入阻塞状态时，此函数会被立即调用。参数pxQueue保存的是试图读取的目标队列、信号或者互斥量的句柄，传递给此宏函数。 traceBLOCKING_ON_QUEUE_SEND(pxQueue) 当正在执行的当前任务因为试图往一个已经写满的队列或者信号或者互斥量而进入了阻塞状态时，此函数会被立即调用。参数pxQueue保存的是试图写入的目标队列、信号或者互斥量的句柄，传递给此宏函数。 traceQUEUE_SEND(pxQueue) 当一个队列或者信号发送成功时，此宏函数会在内核函数xQueueSend(),xQueueSendToFront(),xQueueSendToBack(),以及所有的信号give函数中被调用，参数pxQueue是要发送的目标队列或信号的句柄，传递给此宏函数。 traceQUEUE_SEND_FAILED(pxQueue) 当一个队列或者信号发送失败时，此宏函数会在内核函数xQueueSend(),xQueueSendToFront(),xQueueSendToBack(),以及所有的信号give函数中被调用，参数pxQueue是要发送的目标队列或信号的句柄，传递给此宏函数。 traceQUEUE_RECEIVE(pxQueue) 当读取一个队列或者接收信号成功时，此宏函数会在内核函数xQueueReceive()以及所有的信号take函数中被调用，参数pxQueue是要接收的目标队列或信号的句柄，传递给此宏函数。 traceQUEUE_RECEIVE_FAILED(pxQueue) 当读取一个队列或者接收信号失败时，此宏函数会在内核函数xQueueReceive()以及所有的信号take函数中被调用，参数pxQueue是要接收的目标队列或信号的句柄，传递给此宏函数。 traceQUEUE_SEND_FROM_ISR(pxQueue) 当在中断中发送一个队列成功时，此函数会在xQueueSendFromISR()中被调用。参数pxQueue是要发送的目标队列的句柄。 traceQUEUE_SEND_FROM_ISR_FAILED(pxQueue) 当在中断中发送一个队列失败时，此函数会在xQueueSendFromISR()中被调用。参数pxQueue是要发送的目标队列的句柄。 traceQUEUE_RECEIVE_FROM_ISR(pxQueue) 当在中断中读取一个队列成功时，此函数会在xQueueReceiveFromISR()中被调用。参数pxQueue是要发送的目标队列的句柄。 traceQUEUE_RECEIVE_FROM_ISR_FAILED(pxQueue) 当在中断中读取一个队列失败时，此函数会在xQueueReceiveFromISR()中被调用。参数pxQueue是要发送的目标队列的句柄。 traceTASK_DELAY_UNTIL() 当一个任务因为调用了vTaskDelayUntil()进入了阻塞状态的前一刻此宏函数会在vTaskDelayUntil()中被立即调用。 traceTASK_DELAY() 当一个任务因为调用了vTaskDelay()进入了阻塞状态的前一刻此宏函数会在vTaskDelay中被立即调用。 ## Malloc Hook函数 编程的时候越界以及栈溢出的问题很难解决, 一般堆使用的过程中发生越界很难被察觉, 堆就是malloc函数获得的内存 * 使用pvPortMalloc失败时，如果在FreeRTOSConfig.h里配置`configUSE_MALLOC_FAILED_HOOK`为1，会调用： ```c void vApplicationMallocFailedHook( void ); ``` ## 栈溢出的Hook函数 在切换任务(vTaskSwitchContext)时调用taskCHECK_FOR_STACK_OVERFLOW来检测栈是否溢出，如果溢出会调用： ```c void vApplicationStackOverflowHook( TaskHandle_t xTask, char * pcTaskName ); ``` 怎么判断栈溢出？有两种方法： * 方法1： * 当前任务被切换出去之前，它的整个运行现场都被保存在栈里，这时**很可能**就是它对栈的使用到达了峰值。 * 这方法很高效，但是并不精确 * 比如：任务在运行过程中调用了函数A大量地使用了栈，调用完函数A后才被调度。 方法2： * 创建任务时，它的栈被填入固定的值，比如：0xa5 * 检测栈里最后16字节的数据，如果不是0xa5的话表示栈即将、或者已经被用完了 * 没有方法1快速，但是也足够快 * 能捕获**几乎所有**的栈溢出 * 为什么是几乎所有？可能有些函数使用栈时，非常凑巧地把栈设置为0xa5：几乎不可能 > 方法的切换使用的宏configCHECK_FOR_STACK_OVERLOW, 使用1的时候为第一种方法, 配置为大于1的时候使用的是第二种方法"},"/note/嵌入式/第三方移植/freeRTOS/2023-7-13-fire10创建任务.html":{"title":"创建任务","content":" layout: post title: \"创建任务\" date: 2023 7 12 15:39:08 +0800 tags: FreeRTOS # 创建任务 ## 静态任务 创建任务栈, 指定大小, 地址 + 硬件初始化 放在函数BSP_Init()里面 ```c static void BSP_Init(void) { \t//优先级设置, 统一设置 \tNVIC_PriorityGroupConfig(NVIC_PriorityGroup_4); \t \tLED_GPIO_Config(); \t \tUSART_Config(); \tprintf(\"初始化完成\\n\"); } ``` + 创建启动任务 在启动任务中创建其他任务, 之后再进行删除启动任务 ```c static void AppTaskCreate(void) { taskENTER_CRITICAL(); //进入临界区 /* 创建LED_Task任务 */ \tLED_Task_Handle xTaskCreateStatic((TaskFunction_t\t)LED_Task,\t\t//任务函数 \t\t\t\t\t\t\t\t\t\t\t\t\t\t(const char* \t)\"LED_Task\",//任务名称 \t\t\t\t\t\t\t\t\t\t\t\t\t(uint32_t \t\t)128,//任务堆栈大小 \t\t\t\t\t\t\t\t\t\t\t\t\t(void* \t\t \t)NULL,//传递给任务函数的参数 \t\t\t\t\t\t\t\t\t\t\t\t\t(UBaseType_t \t)4, //任务优先级 \t\t\t\t\t\t\t\t\t\t\t\t\t(StackType_t* )LED_Task_Stack,//任务堆栈 \t\t\t\t\t\t\t\t\t\t\t\t\t(StaticTask_t* )&LED_Task_TCB);//任务控制块 \tif(NULL ! LED_Task_Handle)/* 创建成功 */ \t\tprintf(\"LED_Task任务创建成功!\\n\"); \telse \t\tprintf(\"LED_Task任务创建失败!\\n\"); \t vTaskDelete(AppTaskCreate_Handle); //删除AppTaskCreate任务 taskEXIT_CRITICAL(); //退出临界区 } ``` ```c static void LED_Task(void* parameter) {\t while (1) { LED1_ON; vTaskDelay(500); /* 延时500个tick */ printf(\"LED_Task Running,LED1_ON\\r\\n\"); LED1_OFF; vTaskDelay(500); /* 延时500个tick */\t\t \t\t printf(\"LED_Task Running,LED1_OFF\\r\\n\"); } } ``` > 实现的任务函数 ```c /** ********************************************************************** * @brief 获取空闲任务的任务堆栈和任务控制块内存 \t*\t\t\t\t\tppxTimerTaskTCBBuffer\t:\t\t任务控制块内存 \t*\t\t\t\t\tppxTimerTaskStackBuffer\t:\t任务堆栈内存 \t*\t\t\t\t\tpulTimerTaskStackSize\t:\t\t任务堆栈大小 * @author fire * @version V1.0 * @date 2018 xx xx ********************************************************************** */ void vApplicationGetIdleTaskMemory(StaticTask_t **ppxIdleTaskTCBBuffer, \t\t\t\t\t\t\t\t StackType_t **ppxIdleTaskStackBuffer, \t\t\t\t\t\t\t\t uint32_t *pulIdleTaskStackSize) { \t*ppxIdleTaskTCBBuffer &Idle_Task_TCB;/* 任务控制块内存 */ \t*ppxIdleTaskStackBuffer Idle_Task_Stack;/* 任务堆栈内存 */ \t*pulIdleTaskStackSize configMINIMAL_STACK_SIZE;/* 任务堆栈大小 */ } /** ********************************************************************* * @brief 获取定时器任务的任务堆栈和任务控制块内存 \t*\t\t\t\t\tppxTimerTaskTCBBuffer\t:\t\t任务控制块内存 \t*\t\t\t\t\tppxTimerTaskStackBuffer\t:\t任务堆栈内存 \t*\t\t\t\t\tpulTimerTaskStackSize\t:\t\t任务堆栈大小 * @author fire * @version V1.0 * @date 2018 xx xx ********************************************************************** */ void vApplicationGetTimerTaskMemory(StaticTask_t **ppxTimerTaskTCBBuffer, \t\t\t\t\t\t\t\t\tStackType_t **ppxTimerTaskStackBuffer, \t\t\t\t\t\t\t\t\tuint32_t *pulTimerTaskStackSize) { \t*ppxTimerTaskTCBBuffer &Timer_Task_TCB;/* 任务控制块内存 */ \t*ppxTimerTaskStackBuffer Timer_Task_Stack;/* 任务堆栈内存 */ \t*pulTimerTaskStackSize configTIMER_TASK_STACK_DEPTH;/* 任务堆栈大小 */ } ``` > 这两个函数会在task.c文件中调用, 使用静态创建函数的时候必须创建 + 创建任务栈 ```c /* 创建任务句柄 */ static TaskHandle_t AppTaskCreate_Handle; /* LED任务句柄 */ static TaskHandle_t LED_Task_Handle; /******************************* 全局变量声明 ************************************/ /* * 当我们在写应用程序的时候，可能需要用到一些全局变量。 */ /* AppTaskCreate任务任务堆栈 */ static StackType_t AppTaskCreate_Stack[128]; /* LED任务堆栈 */ static StackType_t LED_Task_Stack[128]; /* AppTaskCreate 任务控制块 */ static StaticTask_t AppTaskCreate_TCB; /* AppTaskCreate 任务控制块 */ static StaticTask_t LED_Task_TCB; /* 空闲任务任务堆栈 */ static StackType_t Idle_Task_Stack[configMINIMAL_STACK_SIZE]; /* 定时器任务堆栈 */ static StackType_t Timer_Task_Stack[configTIMER_TASK_STACK_DEPTH]; /* 空闲任务控制块 */ static StaticTask_t Idle_Task_TCB;\t /* 定时器任务控制块 */ static StaticTask_t Timer_Task_TCB; ``` ## 动态内存 使用的是堆内存, FreeRTOS使用的是一个大数组, 在FreeRTOSConfig中定义堆的大小 ![image 20230719133413949](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242301826.png) 1. 定义任务函数 2. 定义任务控制模块 3. 动态创建任务 4. 启动任务 直接使用创建的函数就行 ```c \txReturn xTaskCreate(\t(TaskFunction_t)LED_Task, \t\t\t\t\t\t\t(const char *)\"LEDCreat\", \t\t\t\t\t\t\t(uint16_t)128, \t\t\t\t\t\t\t(void *)NULL, \t\t\t\t\t\t\t(UBaseType_t)3, \t\t\t\t\t\t\t&LED_Task_Handle ); ```"},"/note/嵌入式/第三方移植/freeRTOS/2023-11-17-wds02互斥量.html":{"title":"互斥量","content":" layout: post title: \"互斥量\" date: 2023 11 15 15:39:08 +0800 tags: FreeRTOS # 互斥量 ## 队列的使用FIFO 队列: 可以包含若干个数据, 有若干项, 数据大小固定, 创建的时候指定长度, 采用先进先出 相当于一个传送带 使用的时候有两种: + 拷贝: 把数据, 变量复制到队列里面 + 引用: 把数据, 变量的地址复制到队列里面 ![image 20231117195425622](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311171954699.png) ![image 20231117195442317](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311171954342.png) 任务读写的时候如果不成功就进入阻塞状态, 可以指定阻塞时间, 一旦有数据就会恢复就绪态 多个任务如果读取同一个队列, 都进入阻塞, 有数据的时候优先级比较高的任务进入就绪态, 优先级相同的时候等待时间最长的任务会进入就绪状态 当数据满了的时候也需要一个进入阻塞 ### 实际实现 猜测: 有一个存储数据的部分, 一个链表保存要读取数据阻塞的任务, 一个链表保存写入数据的链表 ```c typedef struct QueuePointers { int8_t * pcTail; /*< Points to the byte at the end of the queue storage area. Once more byte is allocated than necessary to store the queue items, this is used as a marker. 尾部*/ int8_t * pcReadFrom; /*< Points to the last place that a queued item was read from when the structure is used as a queue. 读指针*/ } QueuePointers_t; typedef struct QueueDefinition /* The old naming convention is used to prevent breaking kernel aware debuggers. */ { int8_t * pcHead;\t/*< Points to the beginning of the queue storage area. 指向头部*/ int8_t * pcWriteTo;\t/*< Points to the free next place in the storage area. 读写指针*/ union { QueuePointers_t xQueue;/*< Data required exclusively when this structure is used as a queue. */ SemaphoreData_t xSemaphore;/*< Data required exclusively when this structure is used as a semaphore. */ } u; List_t xTasksWaitingToSend;/*< List of tasks that are blocked waiting to post onto this queue. Stored in priority order. */ List_t xTasksWaitingToReceive;/*< List of tasks that are blocked waiting to read from this queue. Stored in priority order. 两组任务*/ volatile UBaseType_t uxMessagesWaiting; /*< The number of items currently in the queue. 当前的数据数量*/ UBaseType_t uxLength;/*< The length of the queue defined as the number of items it will hold, not the number of bytes. 保存的最大数量*/ UBaseType_t uxItemSize;/*< The size of each items that the queue will hold. 一个单位的长度*/ volatile int8_t cRxLock;/*< Stores the number of items received from the queue (removed from the queue) while the queue was locked. Set to queueUNLOCKED when the queue is not locked. */ volatile int8_t cTxLock;/*< Stores the number of items transmitted to the queue (added to the queue) while the queue was locked. Set to queueUNLOCKED when the queue is not locked. */ #if ( ( configSUPPORT_STATIC_ALLOCATION 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION 1 ) ) uint8_t ucStaticallyAllocated; /*< Set to pdTRUE if the memory used by the queue was statically allocated to ensure no attempt is made to free the memory. */ #endif #if ( configUSE_QUEUE_SETS 1 ) struct QueueDefinition * pxQueueSetContainer; #endif #if ( configUSE_TRACE_FACILITY 1 ) UBaseType_t uxQueueNumber; uint8_t ucQueueType; #endif } xQUEUE; ``` ### 实际使用 + 创建 ```c QueueHandle_t xQueueCreate( UBaseType_t uxQueueLength, UBaseType_t uxItemSize ); ``` > 队列的长度以及队列一个项的大小(单位是字节), 返回值是一个队列的结构体 ```c QueueHandle_t xQueueCreateStatic(UBaseType_t uxQueueLength, UBaseType_t uxItemSize, uint8_t *pucQueueStorageBuffer, StaticQueue_t *pxQueueBuffer ); ``` > 静态创建: 队列的长度, 队列一个单位的大小, 队列的数组, 队列的结构体, 返回指向结构体的句柄 + 复位 ```c BaseType_t xQueueReset( QueueHandle_t pxQueue); ``` + 删除 ```c void vQueueDelete( QueueHandle_t xQueue ); ``` > 删除动态创建的队列, 释放内存 + 写队列 ```c BaseType_t xQueueSend(QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait ); ``` > 向队列尾部写入数据, 等待的时间是xTicksToWait ````c BaseType_t xQueueSendToBack(QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait ); ```` ```c BaseType_t xQueueSendToBackFromISR(QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t *pxHigherPriorityTaskWoken ); ``` > 可以在中断中使用 ```c BaseType_t xQueueSendToFront(QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait ); ``` > 向头部写入数据 ```c BaseType_t xQueueSendToFrontFromISR(QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t *pxHigherPriorityTaskWoken ); ``` > 头部写入, 不可阻塞, 中断中使用 ![image 20231117201539734](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311172015773.png) > 可以使用portMAX_DELAY一直等待 + 读取 ```c BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait ); BaseType_t xQueueReceiveFromISR(QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxTaskWoken ); ``` + 查询 ```c /* * 返回队列中可用数据的个数 */ UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue ); /* * 返回队列中可用空间的个数 */ UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue ); ``` + 覆盖 ```c /* 覆盖队列 * xQueue: 写哪个队列 * pvItemToQueue: 数据地址 * 返回值: pdTRUE表示成功, pdFALSE表示失败 */ BaseType_t xQueueOverwrite( QueueHandle_t xQueue, const void * pvItemToQueue ); BaseType_t xQueueOverwriteFromISR( QueueHandle_t xQueue, const void * pvItemToQueue, BaseType_t *pxHigherPriorityTaskWoken ); ``` > 队列长度为1的时候使用这一个函数对队列进行覆盖 + 窥视 ```c /* 偷看队列 * xQueue: 偷看哪个队列 * pvItemToQueue: 数据地址, 用来保存复制出来的数据 * xTicksToWait: 没有数据的话阻塞一会 * 返回值: pdTRUE表示成功, pdFALSE表示失败 */ BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait ); BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue, void *pvBuffer, ); ``` > 读取一个数据, 但是不更改读指针的位置 ### 实现一个锁 ```c int InitUARTLock(void) { int val; xQueueUARTcHandle xQueueCreat(1, sizeof(int)); if(xQueueUARTcHandle NULL) { printf(\"can not creat queue\\r\\n\"); return 1; } xQueueSend(xQueueUARTcHandle, &val, portMAX_DELAY); } void GetUARTLock(void) { int val; xQueueReceive(xQueueUARTcHandle, &val, portMAX_DELAY); } void PutUARTLock(void) { int val; xQueueSend(xQueueUARTcHandle, &val, portMAX_DELAY); } ``` > 当队列里面有数据的时候表示空闲 ```c void Task1Function( void * param){ while(1){ Task1Flog 1; Task2Flog 0; Task3Flog 0; GetUARTLock(); printf(\"This is task 1\\r\\n\"); PutUARTLock(); vTaskDelay(1);\t//保证另一个任务可以运行 } } ``` ![image 20231117205600322](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311172056352.png) ## 邮箱 ![image 20231117215121960](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311172151995.png) ## 队列集 从多个队列里面获取一个数据 比如需要同时获取鼠标, 键盘以及触摸屏的数据的时候可以使用这一个数据类型 1. 创建一个队列集 2. 队列集的长度是队列的handle长度 3. 使用的各个单独的队列都会有一个参数指向这一个队列集, 建立联系 4. 之后有数据的时候, 在写数据的时候会把数据写入队列里面, 并且把队列的handle写入队列集里面 5. 读取队列集的时候会返回一个handle, 之后用这一个handle读取队列 ### 函数 ```c QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength ); ``` > configUSE_QUEUE_SETS宏定义, 参数是监视的所有队列的长度之和 + 添加/建立联系 ```c BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ); ``` > 参数是队列和队列集 + 获取 ```c QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, TickType_t const xTicksToWait ); ``` ### 示例 ```c xTaskCreate(Task1Function, \"Task1\", 100, NULL, 1, &xHandleTask1); xTaskCreate(Task2Function, \"Task2\", 100, NULL, 1, &xHandleTask2); xTaskCreate(Task3Function, \"Task3\", 100, NULL, 1, &xHandleTask3); xTask1Queue xQueueCreate(2, sizeof(int)); xTask2Queue xQueueCreate(2, sizeof(int)); xQueueSet xQueueCreateSet(4); xQueueAddToSet(xTask1Queue, xQueueSet); xQueueAddToSet(xTask2Queue, xQueueSet); ``` ```c void Task2Function( void * param){ int i 1; while(1){ Task1Flog 0; Task2Flog 1; Task3Flog 0; xQueueSend(xTask2Queue, &i, portMAX_DELAY); i ; vTaskDelay(10); } } void Task1Function( void * param){ int i 0; while(1){ Task1Flog 1; Task2Flog 0; Task3Flog 0; xQueueSend(xTask1Queue, &i, portMAX_DELAY); i++; vTaskDelay(20); } } //钩子函数会在空闲任务里面执行 void Task3Function( void * param){ QueueSetMemberHandle_t handle; int i; while(1){ Task1Flog 0; Task2Flog 0; Task3Flog 1; handle xQueueSelectFromSet(xQueueSet, portMAX_DELAY); xQueueReceive(handle, &i, 0); printf(\"%d\\n\", i); } //printf(\"3\"); } ``` ## 信号量 有一个计数值, 任务完成让信号量加一, 使用的时候使信号量减一 信号: 通知作用 量: 表示资源的数量 > 量没有限制的时候就是计数型信号量 > > 只有0, 1两种的时候就是二进制信号量 支持的行为: 产生信号的时候give信号量加一, 处理事件的时候take, 信号量减一 访问的时候先take, 访问结束give ![image 20231119095715364](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311190957504.png) ![image 20231119095745304](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311190957343.png) ### 函数 + 创建 ![image 20231119095759865](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311190957899.png) ```c /* 创建一个二进制信号量，返回它的句柄。 * 此函数内部会分配信号量结构体 * 返回值: 返回句柄，非NULL表示成功 */ SemaphoreHandle_t xSemaphoreCreateBinary( void ); //默认获取的时候计数值为0 /* 创建一个二进制信号量，返回它的句柄。 * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针 * 返回值: 返回句柄，非NULL表示成功 */ SemaphoreHandle_t xSemaphoreCreateBinaryStatic( StaticSemaphore_t *pxSemaphoreBuffer ); ``` ```c /* 创建一个计数型信号量，返回它的句柄。 * 此函数内部会分配信号量结构体 * uxMaxCount: 最大计数值 * uxInitialCount: 初始计数值 * 返回值: 返回句柄，非NULL表示成功 */ SemaphoreHandle_t xSemaphoreCreateCounting(UBaseType_t uxMaxCount, UBaseType_t uxInitialCount); /* 创建一个计数型信号量，返回它的句柄。 * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针 * uxMaxCount: 最大计数值 * uxInitialCount: 初始计数值 * pxSemaphoreBuffer: StaticSemaphore_t结构体指针 * 返回值: 返回句柄，非NULL表示成功 */ SemaphoreHandle_t xSemaphoreCreateCountingStatic( UBaseType_t uxMaxCount, UBaseType_t uxInitialCount, StaticSemaphore_t *pxSemaphoreBuffer ); ``` > 他的本质还是一个队列, 使用队列结构体个uxMessagegsWaiting变量保存当前的总的资源的数量 + 删除 ```c /* * xSemaphore: 信号量句柄，你要删除哪个信号量 */ void vSemaphoreDelete( SemaphoreHandle_t xSemaphore ); ``` + 使用 ![image 20231119100135553](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311191001587.png) ```c BaseType_t xSemaphoreGive( SemaphoreHandle_t xSemaphore ); ``` > 返回的是pdTRUE的时候表示成功, 如果超过最大值会返回失败 ````c BaseType_t xSemaphoreGiveFromISR(SemaphoreHandle_t xSemaphore, \t\t\t\t\t\tBaseType_t *pxHigherPriorityTaskWoken ); ```` > 第一个参数是要操作的信号量, 第二个参数是是否有高优先级的任务被唤醒, 有的话返回pdTRUE > > 返回值同上 ```c BaseType_t xSemaphoreTake(SemaphoreHandle_t xSemaphore, \t\t\t\t\tTickType_t xTicksToWait ); ``` > 使用这一个如果信号量为0的时候会阻塞 ```c BaseType_t xSemaphoreTakeFromISR(SemaphoreHandle_t xSemaphore, \t\t\t\t\tBaseType_t *pxHigherPriorityTaskWoken ); ``` > 信号量句柄, 高优先级任务是否被唤醒 ### 实际使用 使用二进制信号量的时候由于最大只有1, 所以有多次提醒的时候有可能只会接收到一次, 可以使用一个缓冲区, 把所有数据放进去, 最后提取的时候使用一次性把所有的数据提取出来 ## 互斥量 > **不要在中断里面使用!!!!** 相对于信号量有可能会在上锁以后进行任务切换, 切换以后在其他的任务里面对信号量进行解锁(不能实现由谁上锁就是谁来解锁) 互斥量也不能实现这一点, 但是可以解决优先级反转以及递归上锁解锁 > **没有解决的时候出现的问题: ** 优先级为1的任务使用一个资源进行上锁, 这时候优先级为2的任务开始运行, 然后又有优先级为3的任务开始运行, 优先级为三的任务也想使用, 进入阻塞, 这时候如果优先级为2的任务一直在运行, 优先级为1的任务就不能进行, 资源不能释放 > > **结果:** 优先级为2的任务把优先级为3的任务抢占了 > > **解决方法: **优先级继承, 在优先级为3进入休眠的时候会提高比较低的优先级任务的优先级, 等他释放的时候返回之前的优先级 > **二次上锁: **有一个任务多次获取同一个信号量, 由于自己阻塞了, 所以没有人可以进行释放, 就会进入死锁 > > **解决方式: **递归锁, 在你持有这一个锁的时候可以递归上锁, 再次获取自己的锁 > **注意: **互斥量只实现了优先级继承, 递归锁是另一种特殊的互斥量 ### 使用场景 在有多个任务访问同一个全局变量时候, 如果在任务一获取进行处理但是没有更新的时候任务二对这一个变量进行操作, 会导致操作结果不是预期的的问题 + 问题原因 没有使用原子操作的变量(按照机器的位数进行使用变量), 比如在16位机器上使用32位的变量, 操作可能会被打断 函数不可重用(使用全局变量, 局部变量) ### 实际使用 + 创建 ```c /* 创建一个互斥量，返回它的句柄。 * 此函数内部会分配互斥量结构体 * 返回值: 返回句柄，非NULL表示成功 */ SemaphoreHandle_t xSemaphoreCreateMutex( void ); /* 创建一个互斥量，返回它的句柄。 * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针 * 返回值: 返回句柄，非NULL表示成功 */ SemaphoreHandle_t xSemaphoreCreateMutexStatic( StaticSemaphore_t *pxMutexBuffer ); ``` > 在创建的时候会把值设置为1 + give/take**注意: 互斥量不能在中断中使用** ```c /* * xSemaphore: 信号量句柄，你要删除哪个信号量, 互斥量也是一种信号量 */ void vSemaphoreDelete( SemaphoreHandle_t xSemaphore ); /* 释放 */ BaseType_t xSemaphoreGive( SemaphoreHandle_t xSemaphore ); /* 释放(ISR版本) */ BaseType_t xSemaphoreGiveFromISR( SemaphoreHandle_t xSemaphore, BaseType_t *pxHigherPriorityTaskWoken ); /* 获得 */ BaseType_t xSemaphoreTake( SemaphoreHandle_t xSemaphore, TickType_t xTicksToWait ); /* 获得(ISR版本) */ xSemaphoreGiveFromISR( SemaphoreHandle_t xSemaphore, BaseType_t *pxHigherPriorityTaskWoken ); ``` ### 缺陷以及递归锁 没有检测是否是本人在释放 可能会产生监守自盗的情况 ```c static void vGiveAndTakeTask( void *pvParameters ) { \tconst TickType_t xTicksToWait pdMS_TO_TICKS( 10UL );\t \tBaseType_t xStatus; \t/* 尝试获得互斥量: 上锁 */ \txStatus xSemaphoreTake(xMutex, 0); \tprintf(\"Task2: at first, take the Mutex %s\\r\\n\", \\ \t\t(xStatus pdTRUE)? \"Success\" : \"Failed\"); \t \t/* 如果失败则监守自盗: 开锁 */ \tif (xStatus ! pdTRUE) \t{ \t\txStatus xSemaphoreGive(xMutex); \t\tprintf(\"Task2: give Mutex %s\\r\\n\", \\ \t\t\t(xStatus pdTRUE)? \"Success\" : \"Failed\"); \t} \t/* 最后成功获得互斥量 */ \txStatus xSemaphoreTake(xMutex, portMAX_DELAY); \tprintf(\"Task2: and then, take the Mutex %s\\r\\n\", \\ \t\t(xStatus pdTRUE)? \"Success\" : \"Failed\"); \t \t/* 无限循环 */ \tfor( ;; ) \t{\t \t\t/* 什么都不做 */ \t\tvTaskDelay(xTicksToWait); \t} } ``` + 解决 使用递归锁, 实现谁持有就有谁有放 ![image 20231119114023325](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311191140368.png) ```c /* 创建一个递归锁，返回它的句柄。 * 此函数内部会分配互斥量结构体 * 返回值: 返回句柄，非NULL表示成功 */ SemaphoreHandle_t xSemaphoreCreateRecursiveMutex( void ); /* 释放 */ BaseType_t xSemaphoreGiveRecursive( SemaphoreHandle_t xSemaphore ); /* 获得 */ BaseType_t xSemaphoreTakeRecursive(SemaphoreHandle_t xSemaphore, \tTickType_t xTicksToWait ); ``` ## 事件组 之前介绍的手段都没有办法实现有多个事件的处理 可以认为是一个整数, 使用它的不同的位表述不同的事件 1表示事件发生, 0表示事件没有发生 事件组用一个整数表示, 高八位是给内核使用的 ![image 20231119194438693](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311191944900.png) ![image 20231119194507468](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311191945507.png) ![image 20231119194533066](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311191945113.png) ### 实现使用的函数 ```c typedef struct EventGroupDef_t { EventBits_t uxEventBits;//一个整数, 每一位都是一个事件 List_t xTasksWaitingForBits; /*< List of tasks waiting for a bit to be set. */ #if ( configUSE_TRACE_FACILITY 1 ) UBaseType_t uxEventGroupNumber; #endif #if ( ( configSUPPORT_STATIC_ALLOCATION 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION 1 ) ) uint8_t ucStaticallyAllocated; /*< Set to pdTRUE if the event group is statically allocated to ensure no attempt is made to free the memory. */ #endif } EventGroup_t; ``` + 创建 ```c /* 创建一个事件组，返回它的句柄。 * 此函数内部会分配事件组结构体 * 返回值: 返回句柄，非NULL表示成功 */ EventGroupHandle_t xEventGroupCreate( void ); /* 创建一个事件组，返回它的句柄。 * 此函数无需动态分配内存，所以需要先有一个StaticEventGroup_t结构体，并传入它的指针 * 返回值: 返回句柄，非NULL表示成功 */ EventGroupHandle_t xEventGroupCreateStatic( StaticEventGroup_t * pxEventGroupBuffer ); ``` + 删除 ```c /* * xEventGroup: 事件组句柄，你要删除哪个事件组 */ void vEventGroupDelete( EventGroupHandle_t xEventGroup ) ``` + 设置事件 ```c /* 设置事件组中的位 * xEventGroup: 哪个事件组 * uxBitsToSet: 设置哪些位? * 如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1 * 可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0 * 返回值: 返回原来的事件值(没什么意义, 因为很可能已经被其他任务修改了) */ EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, \t\t\t\t\tconst EventBits_t uxBitsToSet ); /* 设置事件组中的位 * xEventGroup: 哪个事件组 * uxBitsToSet: 设置哪些位? * 如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1 * 可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0 * pxHigherPriorityTaskWoken: 有没有导致更高优先级的任务进入就绪态? pdTRUE 有, pdFALSE 没有 * 返回值: pdPASS 成功, pdFALSE 失败 */ BaseType_t xEventGroupSetBitsFromISR( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, BaseType_t * pxHigherPriorityTaskWoken ); ``` > 设置事件组的时候有可能会有多个任务被唤醒, 这会带来很大的不确定性。所以 xEventGroupSetBitsFromISR 函数不是直接去设置事件组，而是给一个FreeRTOS后台任务(daemon task)发送队列数据，由这个任务来设置事件组。 > > 如果后台任务的优先级比当前被中断的任务优先级高， xEventGroupSetBitsFromISR 会设置 *pxHigherPriorityTaskWoken 为pdTRUE。 > > 如果daemon task成功地把队列数据发送给了后台任务，那么 xEventGroupSetBitsFromISR 的返回值 就是pdPASS。 + 等待事件 ```c EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait ); ``` > 参数是: 事件组, 等待哪些事件, 返回时候是否会清除, 是否等待所有时间(pdTRUE 都等待与, pdFALSE则是或), 等待的时间 + 同步点 ```c EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait ); ``` > 当有多个任务协调控控制某一个事件的时候, 使用这一个函数设置一个位等待其他的事件 # FreeRTOS代码分析 + queueQUEUE_TYPE_BASE：表示队列。 + queueQUEUE_TYPE_SET：表示队列集合。 + queueQUEUE_TYPE_MUTEX：表示互斥量。 + queueQUEUE_TYPE_COUNTING_SEMAPHORE：表示计数信号量。 + queueQUEUE_TYPE_BINARY_SEMAPHORE：表示二进制信号量。 + queueQUEUE_TYPE_RECURSIVE_MUTEX ：表示递归互斥量。 ## 消息队列 ![image 20240121162745588](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401211627813.png) 系统会为控制块分配对应的内存空间，用于保存消息队列的一些信息如消息的存储位置，头指针pcHead、尾指针pcTail、消息大小uxItemSize以及队列长度uxLength等 实际就是一个环形缓冲区 ### 结构体 ```c typedef struct QueueDefinition { \tint8_t *pcHead;\t\t\t\t\t/*< 队列的起始位置 */ \tint8_t *pcTail;\t\t\t\t\t/* 消息存储的结束位置 */ \tint8_t *pcWriteTo;\t\t\t\t/* 下一个写的位置 */ \tunion \t{ \t\tint8_t *pcReadFrom;\t\t\t/* 队列使用, 指向队列最后, 记录下一个读取的位置 */ \t\tUBaseType_t uxRecursiveCallCount;/* 记录锁被使用的数值(递归调用) */ \t} u; \tList_t xTasksWaitingToSend;\t\t/*< 消息阻塞队列 */ \tList_t xTasksWaitingToReceive;\t/*< 消息接受队列 */ \tvolatile UBaseType_t uxMessagesWaiting;/*< 当前的消息数量 */ \tUBaseType_t uxLength;\t\t\t/*< 可以存放的消息的个数 */ \tUBaseType_t uxItemSize;\t\t\t/*< 单个消息的大小 */ \tvolatile int8_t cRxLock;\t\t/* 队列上锁的时候记录这时候插入到队列的接接收任务个数, 不上锁的时候为queueUNLOCKED */ \tvolatile int8_t cTxLock;\t\t/*< 队列上锁的时候记录这时候插入到队列的接发送任务个数, 不上锁的时候为queueUNLOCKED*/ \t#if( ( configSUPPORT_STATIC_ALLOCATION 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION 1 ) ) \t\tuint8_t ucStaticallyAllocated;\t/*< Set to pdTRUE if the memory used by the queue was statically allocated to ensure no attempt is made to free the memory. */ \t#endif \t#if ( configUSE_QUEUE_SETS 1 ) \t\tstruct QueueDefinition *pxQueueSetContainer; \t#endif \t#if ( configUSE_TRACE_FACILITY 1 ) \t\tUBaseType_t uxQueueNumber; \t\tuint8_t ucQueueType; \t#endif } xQUEUE; ``` ### 创建 ```c QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType ) { Queue_t *pxNewQueue; size_t xQueueSizeInBytes; uint8_t *pucQueueStorage; configASSERT( uxQueueLength > ( UBaseType_t ) 0 ); if( uxItemSize ( UBaseType_t ) 0 ) { /* 不会有存储信息的位置 */ xQueueSizeInBytes ( size_t ) 0; } else { /* 计算需要的空间的大小 */ xQueueSizeInBytes ( size_t ) ( uxQueueLength * uxItemSize ); } pxNewQueue ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes ); if( pxNewQueue ! NULL ) { /* 计算出来消息的大小 */ pucQueueStorage ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t ); prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue ); } else { traceQUEUE_CREATE_FAILED( ucQueueType ); } return pxNewQueue; } ``` ```c static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue ) { \t/* nin消除 */ \t( void ) ucQueueType; \tif( uxItemSize ( UBaseType_t ) 0 ) \t{ \t\t/* 没有数据但是不能设置为0, 因为mutex用了 */ \t\tpxNewQueue >pcHead ( int8_t * ) pxNewQueue; \t} \telse \t{ \t\t/* Set the head to the start of the queue storage area. */ \t\tpxNewQueue >pcHead ( int8_t * ) pucQueueStorage; \t} \t/* Initialise the queue members as described where the queue type is \tdefined. */ \tpxNewQueue >uxLength uxQueueLength; \tpxNewQueue >uxItemSize uxItemSize; \t( void ) xQueueGenericReset( pxNewQueue, pdTRUE ); \ttraceQUEUE_CREATE( pxNewQueue ); } ``` ```c BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue ) { Queue_t * const pxQueue ( Queue_t * ) xQueue; configASSERT( pxQueue ); taskENTER_CRITICAL(); { pxQueue >pcTail pxQueue >pcHead + ( pxQueue >uxLength * pxQueue >uxItemSize ); pxQueue >uxMessagesWaiting ( UBaseType_t ) 0U; pxQueue >pcWriteTo pxQueue >pcHead; pxQueue >u.pcReadFrom pxQueue >pcHead + ( ( pxQueue >uxLength ( UBaseType_t ) 1U ) * pxQueue >uxItemSize ); pxQueue >cRxLock queueUNLOCKED; pxQueue >cTxLock queueUNLOCKED; if( xNewQueue pdFALSE ) { /* 如果不是新建一个消息队列，那么之前的消息队列可能阻塞了一些任务，需要将其解除阻塞。如果有发送消息任务被阻塞，那么需要将它恢复，而如果任务是因为读取消息而阻塞，那么重置之后的消息队列也是空的，则无需被恢复。 */ if( listLIST_IS_EMPTY( &( pxQueue >xTasksWaitingToSend ) ) pdFALSE ) { if( xTaskRemoveFromEventList( &( pxQueue >xTasksWaitingToSend ) ) ! pdFALSE ) { queueYIELD_IF_USING_PREEMPTION(); } } } else { /* 之前没有初始化. */ vListInitialise( &( pxQueue >xTasksWaitingToSend ) ); vListInitialise( &( pxQueue >xTasksWaitingToReceive ) ); } } taskEXIT_CRITICAL(); return pdPASS; } ``` ```c BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList ) { TCB_t *pxUnblockedTCB; BaseType_t xReturn; \tpxUnblockedTCB ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList ); \tconfigASSERT( pxUnblockedTCB ); \t( void ) uxListRemove( &( pxUnblockedTCB >xEventListItem ) ); \tif( uxSchedulerSuspended ( UBaseType_t ) pdFALSE ) \t{ //可以进行任务切换 \t\t( void ) uxListRemove( &( pxUnblockedTCB >xStateListItem ) ); \t\tprvAddTaskToReadyList( pxUnblockedTCB ); \t} \telse \t{ \t\t/*不可以切换 */ \t\tvListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB >xEventListItem ) ); \t} \tif( pxUnblockedTCB >uxPriority > pxCurrentTCB >uxPriority ) \t{ \t\t/* 解锁一个高优先级的任务 */ \t\txReturn pdTRUE; \t\txYieldPending pdTRUE; \t} \telse \t{ \t\txReturn pdFALSE; \t} \treturn xReturn; } ``` ![image 20240121175154702](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401211751886.png) ### 删除 ```c void vQueueDelete( QueueHandle_t xQueue ) { Queue_t * const pxQueue ( Queue_t * ) xQueue; \tconfigASSERT( pxQueue ); \ttraceQUEUE_DELETE( pxQueue ); \t#if ( configQUEUE_REGISTRY_SIZE > 0 ) \t{ /* 将消息队列从注册表中删除，我们目前没有添加到注册表中，暂时不用理会*/ \t\tvQueueUnregisterQueue( pxQueue ); \t} \t#endif \t#if( ( configSUPPORT_DYNAMIC_ALLOCATION 1 ) && ( configSUPPORT_STATIC_ALLOCATION 0 ) ) \t{ \t\t/* The queue can only have been allocated dynamically free it \t\tagain. */ \t\tvPortFree( pxQueue ); \t} } ``` ### 发送消息 ```c BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition ) { BaseType_t xEntryTimeSet pdFALSE, xYieldRequired; TimeOut_t xTimeOut; Queue_t * const pxQueue ( Queue_t * ) xQueue; for( ;; ) { taskENTER_CRITICAL(); { \t\t\t//队列没有满, 或者可以覆盖 if( ( pxQueue >uxMessagesWaiting < pxQueue >uxLength ) ( xCopyPosition queueOVERWRITE ) ) { traceQUEUE_SEND( pxQueue ); //复制数据 xYieldRequired prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition ); /* 有任务在等数据 */ if( listLIST_IS_EMPTY( &( pxQueue >xTasksWaitingToReceive ) ) pdFALSE ) { if( xTaskRemoveFromEventList( &( pxQueue >xTasksWaitingToReceive ) ) ! pdFALSE ) { /* 恢复的任务优先级比较高 */ queueYIELD_IF_USING_PREEMPTION(); } else { mtCOVERAGE_TEST_MARKER(); } } else if( xYieldRequired ! pdFALSE ) { /* 这个是任务有多个互斥锁, 并且返回的顺序不对 */ queueYIELD_IF_USING_PREEMPTION(); } else { mtCOVERAGE_TEST_MARKER(); } taskEXIT_CRITICAL(); return pdPASS; } else { //队列是满的 if( xTicksToWait ( TickType_t ) 0 ) { /* 不设置退出的时间,直接退出 */ taskEXIT_CRITICAL(); traceQUEUE_SEND_FAILED( pxQueue ); return errQUEUE_FULL; } else if( xEntryTimeSet pdFALSE ) { /* 初始化超时的结构体 */ vTaskInternalSetTimeOutState( &xTimeOut ); xEntryTimeSet pdTRUE; } else { /* 设置过时间了 */ mtCOVERAGE_TEST_MARKER(); } } } taskEXIT_CRITICAL(); /* Interrupts and other tasks can send to and receive from the queue \t\tnow the critical section has been exited. */ vTaskSuspendAll(); prvLockQueue( pxQueue ); /* 检测时间有没有超过 */ if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) pdFALSE ) { //检测可不可以发送 if( prvIsQueueFull( pxQueue ) ! pdFALSE ) { //队列是满的 traceBLOCKING_ON_QUEUE_SEND( pxQueue ); //把任务添加到任务队列里面, 以及添加到等待队列里面 vTaskPlaceOnEventList( &( pxQueue >xTasksWaitingToSend ), xTicksToWait ); /* 队列解锁 */ prvUnlockQueue( pxQueue ); /* 恢复调度器, 这个会在一个时钟切换周期以后调用 */ if( xTaskResumeAll() pdFALSE ) { portYIELD_WITHIN_API(); } //这时候可以是Delay结束或者是被其他任务唤醒 } else { /* 有空闲的消息空间. 重新回到最上面进行尝试*/ prvUnlockQueue( pxQueue ); ( void ) xTaskResumeAll(); } } else { /* The timeout has expired. */ prvUnlockQueue( pxQueue ); ( void ) xTaskResumeAll(); traceQUEUE_SEND_FAILED( pxQueue ); return errQUEUE_FULL; } } } ``` ### 接收消息 ```c BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait ) { BaseType_t xEntryTimeSet pdFALSE; TimeOut_t xTimeOut; Queue_t * const pxQueue ( Queue_t * ) xQueue; \t/* This function relaxes the coding standard somewhat to allow return \tstatements within the function itself. This is done in the interest \tof execution time efficiency. */ \tfor( ;; ) \t{ \t\ttaskENTER_CRITICAL(); \t\t{ \t\t\tconst UBaseType_t uxMessagesWaiting pxQueue >uxMessagesWaiting; \t\t\t/* Is there data in the queue now? To be running the calling task \t\t\tmust be the highest priority task wanting to access the queue. */ \t\t\tif( uxMessagesWaiting > ( UBaseType_t ) 0 ) \t\t\t{ \t\t\t\t/* 获取信息*/ \t\t\t\tprvCopyDataFromQueue( pxQueue, pvBuffer ); \t\t\t\ttraceQUEUE_RECEIVE( pxQueue ); \t\t\t\tpxQueue >uxMessagesWaiting uxMessagesWaiting ( UBaseType_t ) 1; \t\t\t\t/* 看看有没有等待发送的信息的任务 */ \t\t\t\tif( listLIST_IS_EMPTY( &( pxQueue >xTasksWaitingToSend ) ) pdFALSE ) \t\t\t\t{ \t\t\t\t\tif( xTaskRemoveFromEventList( &( pxQueue >xTasksWaitingToSend ) ) ! pdFALSE ) \t\t\t\t\t{ \t\t\t\t\t\tqueueYIELD_IF_USING_PREEMPTION(); \t\t\t\t\t} \t\t\t\t\telse \t\t\t\t\t{ \t\t\t\t\t\tmtCOVERAGE_TEST_MARKER(); \t\t\t\t\t} \t\t\t\t} \t\t\t\telse \t\t\t\t{ \t\t\t\t\tmtCOVERAGE_TEST_MARKER(); \t\t\t\t} \t\t\t\ttaskEXIT_CRITICAL(); \t\t\t\treturn pdPASS; \t\t\t} \t\t\telse \t\t\t{ \t\t\t\tif( xTicksToWait ( TickType_t ) 0 ) \t\t\t\t{ \t\t\t\t\t/* 不想等待 */ \t\t\t\t\ttaskEXIT_CRITICAL(); \t\t\t\t\ttraceQUEUE_RECEIVE_FAILED( pxQueue ); \t\t\t\t\treturn errQUEUE_EMPTY; \t\t\t\t} \t\t\t\telse if( xEntryTimeSet pdFALSE ) \t\t\t\t{ \t\t\t\t\t/* The queue was empty and a block time was specified so \t\t\t\t\tconfigure the timeout structure. */ \t\t\t\t\tvTaskInternalSetTimeOutState( &xTimeOut ); \t\t\t\t\txEntryTimeSet pdTRUE; \t\t\t\t} \t\t\t\telse \t\t\t\t{ \t\t\t\t\t/* Entry time was already set. */ \t\t\t\t\tmtCOVERAGE_TEST_MARKER(); \t\t\t\t} \t\t\t} \t\t} \t\ttaskEXIT_CRITICAL(); \t\t/* Interrupts and other tasks can send to and receive from the queue \t\tnow the critical section has been exited. */ \t\tvTaskSuspendAll(); \t\tprvLockQueue( pxQueue ); \t\t/* Update the timeout state to see if it has expired yet. */ \t\tif( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) pdFALSE ) \t\t{ \t\t\t/* The timeout has not expired. If the queue is still empty place \t\t\tthe task on the list of tasks waiting to receive from the queue. */ \t\t\tif( prvIsQueueEmpty( pxQueue ) ! pdFALSE ) \t\t\t{ \t\t\t\ttraceBLOCKING_ON_QUEUE_RECEIVE( pxQueue ); \t\t\t\tvTaskPlaceOnEventList( &( pxQueue >xTasksWaitingToReceive ), xTicksToWait ); \t\t\t\tprvUnlockQueue( pxQueue ); \t\t\t\tif( xTaskResumeAll() pdFALSE ) \t\t\t\t{ \t\t\t\t\tportYIELD_WITHIN_API(); \t\t\t\t} \t\t\t\telse \t\t\t\t{ \t\t\t\t\tmtCOVERAGE_TEST_MARKER(); \t\t\t\t} \t\t\t} \t\t\telse \t\t\t{ \t\t\t\t/* The queue contains data again. Loop back to try and read the \t\t\t\tdata. */ \t\t\t\tprvUnlockQueue( pxQueue ); \t\t\t\t( void ) xTaskResumeAll(); \t\t\t} \t\t} \t\telse \t\t{ \t\t\t/* Timed out. If there is no data in the queue exit, otherwise loop \t\t\tback and attempt to read the data. */ \t\t\tprvUnlockQueue( pxQueue ); \t\t\t( void ) xTaskResumeAll(); \t\t\tif( prvIsQueueEmpty( pxQueue ) ! pdFALSE ) \t\t\t{ \t\t\t\ttraceQUEUE_RECEIVE_FAILED( pxQueue ); \t\t\t\treturn errQUEUE_EMPTY; \t\t\t} \t\t\telse \t\t\t{ \t\t\t\tmtCOVERAGE_TEST_MARKER(); \t\t\t} \t\t} \t} } ``` ```c BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait ) { BaseType_t xEntryTimeSet pdFALSE; TimeOut_t xTimeOut; int8_t *pcOriginalReadPosition; Queue_t * const pxQueue ( Queue_t * ) xQueue; \tfor( ;; ) \t{ \t\ttaskENTER_CRITICAL(); \t\t{ \t\t\tconst UBaseType_t uxMessagesWaiting pxQueue >uxMessagesWaiting; \t\t\t/* Is there data in the queue now? To be running the calling task \t\t\tmust be the highest priority task wanting to access the queue. */ \t\t\tif( uxMessagesWaiting > ( UBaseType_t ) 0 ) \t\t\t{ \t\t\t\t/* 记录数据的位置 */ \t\t\t\tpcOriginalReadPosition pxQueue >u.pcReadFrom; \t\t\t\tprvCopyDataFromQueue( pxQueue, pvBuffer ); \t\t\t\ttraceQUEUE_PEEK( pxQueue ); \t\t\t\t/* 不改变数据的位置 */ \t\t\t\tpxQueue >u.pcReadFrom pcOriginalReadPosition; \t\t\t\t/* 有任务在等数据 */ \t\t\t\tif( listLIST_IS_EMPTY( &( pxQueue >xTasksWaitingToReceive ) ) pdFALSE ) \t\t\t\t{ \t\t\t\t\tif( xTaskRemoveFromEventList( &( pxQueue >xTasksWaitingToReceive ) ) ! pdFALSE ) \t\t\t\t\t{ \t\t\t\t\t\t/* 需要切换 */ \t\t\t\t\t\tqueueYIELD_IF_USING_PREEMPTION(); \t\t\t\t\t} \t\t\t\t\telse \t\t\t\t\t{ \t\t\t\t\t\tmtCOVERAGE_TEST_MARKER(); \t\t\t\t\t} \t\t\t\t} \t\t\t\telse \t\t\t\t{ \t\t\t\t\tmtCOVERAGE_TEST_MARKER(); \t\t\t\t} \t\t\t\ttaskEXIT_CRITICAL(); \t\t\t\treturn pdPASS; \t\t\t} \t\t\telse \t\t\t{ \t\t\t\tif( xTicksToWait ( TickType_t ) 0 ) \t\t\t\t{ \t\t\t\t\t/* 不等待 */ \t\t\t\t\ttaskEXIT_CRITICAL(); \t\t\t\t\ttraceQUEUE_PEEK_FAILED( pxQueue ); \t\t\t\t\treturn errQUEUE_EMPTY; \t\t\t\t} \t\t\t\telse if( xEntryTimeSet pdFALSE ) \t\t\t\t{ \t\t\t\t\t/* */ \t\t\t\t\tvTaskInternalSetTimeOutState( &xTimeOut ); \t\t\t\t\txEntryTimeSet pdTRUE; \t\t\t\t} \t\t\t\telse \t\t\t\t{ \t\t\t\t\t/* Entry time was already set. */ \t\t\t\t\tmtCOVERAGE_TEST_MARKER(); \t\t\t\t} \t\t\t} \t\t} \t\ttaskEXIT_CRITICAL(); \t\t/* Interrupts and other tasks can send to and receive from the queue \t\tnow the critical section has been exited. */ \t\tvTaskSuspendAll(); \t\tprvLockQueue( pxQueue ); \t\t/* Update the timeout state to see if it has expired yet. */ \t\tif( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) pdFALSE ) \t\t{ \t\t\t/* 还有时间 */ \t\t\tif( prvIsQueueEmpty( pxQueue ) ! pdFALSE ) \t\t\t{ \t\t\t\ttraceBLOCKING_ON_QUEUE_PEEK( pxQueue ); \t\t\t\tvTaskPlaceOnEventList( &( pxQueue >xTasksWaitingToReceive ), xTicksToWait ); \t\t\t\tprvUnlockQueue( pxQueue ); \t\t\t\tif( xTaskResumeAll() pdFALSE ) \t\t\t\t{ \t\t\t\t\tportYIELD_WITHIN_API(); \t\t\t\t} \t\t\t\telse \t\t\t\t{ \t\t\t\t\tmtCOVERAGE_TEST_MARKER(); \t\t\t\t} \t\t\t} \t\t\telse \t\t\t{ \t\t\t\t/* 有位置了, 再来一次 */ \t\t\t\tprvUnlockQueue( pxQueue ); \t\t\t\t( void ) xTaskResumeAll(); \t\t\t} \t\t} \t\telse \t\t{ \t\t\t/* 超时了 */ \t\t\tprvUnlockQueue( pxQueue ); \t\t\t( void ) xTaskResumeAll(); \t\t\tif( prvIsQueueEmpty( pxQueue ) ! pdFALSE ) \t\t\t{ \t\t\t\ttraceQUEUE_PEEK_FAILED( pxQueue ); \t\t\t\treturn errQUEUE_EMPTY; \t\t\t} \t\t\telse \t\t\t{ \t\t\t\tmtCOVERAGE_TEST_MARKER(); \t\t\t} \t\t} \t} } ``` ## 信号量 ### 结构体 ```c typedef struct QueueDefinition { \tint8_t *pcHead;\t\t\t\t\t \tint8_t *pcTail;\t\t\t\t\t \tint8_t *pcWriteTo;\t\t\t \tunion\t\t\t\t\t\t \t{ \t\tint8_t *pcReadFrom;\t\t \t\tUBaseType_t uxRecursiveCallCount; \t} u; \tList_t xTasksWaitingToSend;\t\t \tList_t xTasksWaitingToReceive;\t \tvolatile UBaseType_t uxMessagesWaiting; //记录可以使用的设备的个数 \tUBaseType_t uxLength;\t\t\t//记录最大的可以使用的个数, 二值信号量的时候为0 \tUBaseType_t uxItemSize;\t\t\t//0 \tvolatile int8_t cRxLock;\t\t \tvolatile int8_t cTxLock;\t\t \t#if( ( configSUPPORT_STATIC_ALLOCATION 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION 1 ) ) \t\tuint8_t ucStaticallyAllocated;\t \t#endif \t#if ( configUSE_QUEUE_SETS 1 ) \t\tstruct QueueDefinition *pxQueueSetContainer; \t#endif \t#if ( configUSE_TRACE_FACILITY 1 ) \t\tUBaseType_t uxQueueNumber; \t\tuint8_t ucQueueType; \t#endif } xQUEUE; ``` ### 二值信号量 ### 计数信号量 #### 创建 ```c QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount ) { QueueHandle_t xHandle; configASSERT( uxMaxCount ! 0 ); configASSERT( uxInitialCount < uxMaxCount ); xHandle xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE ); if( xHandle ! NULL ) { ( ( Queue_t * ) xHandle ) >uxMessagesWaiting uxInitialCount;//设置一个初始值 traceCREATE_COUNTING_SEMAPHORE(); } else { traceCREATE_COUNTING_SEMAPHORE_FAILED(); } return xHandle; } ``` #### 释放 ``` c #define xSemaphoreGive( xSemaphore )\t\txQueueGenericSend( ( QueueHandle_t ) ( xSemaphore ), NULL, semGIVE_BLOCK_TIME, queueSEND_TO_BACK ) ``` > 实际上是一个不发发送数据的, 不阻塞的信息 ```c if( pxQueue >uxItemSize ( UBaseType_t ) 0 ) { #if ( configUSE_MUTEXES 1 ) { if( pxQueue >uxQueueType queueQUEUE_IS_MUTEX ) { /* The mutex is no longer being held. 优先级翻转*/ xReturn xTaskPriorityDisinherit( ( void * ) pxQueue >pxMutexHolder ); pxQueue >pxMutexHolder NULL; } else { mtCOVERAGE_TEST_MARKER(); } } #endif /* configUSE_MUTEXES */ } pxQueue >uxMessagesWaiting uxMessagesWaiting + ( UBaseType_t ) 1; ``` ### 获取 ````c BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait ) { BaseType_t xEntryTimeSet pdFALSE; TimeOut_t xTimeOut; Queue_t * const pxQueue ( Queue_t * ) xQueue; #if( configUSE_MUTEXES 1 ) \tBaseType_t xInheritanceOccurred pdFALSE; #endif \t/* This function relaxes the coding standard somewhat to allow return \tstatements within the function itself. This is done in the interest \tof execution time efficiency. */ \tfor( ;; ) \t{ \t\ttaskENTER_CRITICAL(); \t\t{ \t\t\t/* 获取可以使用的数量 */ \t\t\tconst UBaseType_t uxSemaphoreCount pxQueue >uxMessagesWaiting; \t\t\t/* 有可以使用的设备 */ \t\t\tif( uxSemaphoreCount > ( UBaseType_t ) 0 ) \t\t\t{ \t\t\t\ttraceQUEUE_RECEIVE( pxQueue ); \t\t\t\t/* 更新数量 */ \t\t\t\tpxQueue >uxMessagesWaiting uxSemaphoreCount ( UBaseType_t ) 1; \t\t\t\t#if ( configUSE_MUTEXES 1 ) \t\t\t\t{ //检测尾变量是不是NULL, 判断是不是MUTEX(有两种) \t\t\t\t\tif( pxQueue >uxQueueType queueQUEUE_IS_MUTEX ) \t\t\t\t\t{ //这是一个锁 \t\t\t\t\t\t/* 当前的任务有的锁数量加一, 返回当前的任务, 并记录, Muxtex只有一个使用权 */ \t\t\t\t\t\tpxQueue >pxMutexHolder ( int8_t * ) pvTaskIncrementMutexHeldCount(); \t\t\t\t\t} \t\t\t\t\telse \t\t\t\t\t{ \t\t\t\t\t} \t\t\t\t} \t\t\t\t#endif /* configUSE_MUTEXES */ \t\t\t\t/* 有在等待的任务 */ \t\t\t\tif( listLIST_IS_EMPTY( &( pxQueue >xTasksWaitingToSend ) ) pdFALSE ) \t\t\t\t{ \t\t\t\t\tif( xTaskRemoveFromEventList( &( pxQueue >xTasksWaitingToSend ) ) ! pdFALSE ) \t\t\t\t\t{ //释放的优先级比较高, 切换 \t\t\t\t\t\tqueueYIELD_IF_USING_PREEMPTION(); \t\t\t\t\t} \t\t\t\t\telse \t\t\t\t\t{ \t\t\t\t\t} \t\t\t\t} \t\t\t\telse \t\t\t\t{ \t\t\t\t\tmtCOVERAGE_TEST_MARKER(); \t\t\t\t} \t\t\t\ttaskEXIT_CRITICAL(); \t\t\t\treturn pdPASS; \t\t\t} \t\t\telse \t\t\t{ //没有可以使用的设备 \t\t\t\tif( xTicksToWait ( TickType_t ) 0 ) \t\t\t\t{ \t\t\t\t\t/* 不等待 */ \t\t\t\t\t#if( configUSE_MUTEXES 1 ) \t\t\t\t\t{ \t\t\t\t\t\tconfigASSERT( xInheritanceOccurred pdFALSE ); \t\t\t\t\t} \t\t\t\t\t#endif /* configUSE_MUTEXES */ \t\t\t\t\t/* The semaphore count was 0 and no block time is specified \t\t\t\t\t(or the block time has expired) so exit now. */ \t\t\t\t\ttaskEXIT_CRITICAL(); \t\t\t\t\treturn errQUEUE_EMPTY; \t\t\t\t} \t\t\t\telse if( xEntryTimeSet pdFALSE ) \t\t\t\t{ //第一次进来, 初始化一下等待的结构体 \t\t\t\t\t/* The semaphore count was 0 and a block time was specified \t\t\t\t\tso configure the timeout structure ready to block. */ \t\t\t\t\tvTaskInternalSetTimeOutState( &xTimeOut ); \t\t\t\t\txEntryTimeSet pdTRUE; \t\t\t\t} \t\t\t\telse \t\t\t\t{ \t\t\t\t} \t\t\t} \t\t} \t\ttaskEXIT_CRITICAL(); \t\t/* Interrupts and other tasks can give to and take from the semaphore \t\tnow the critical section has been exited. */ \t\tvTaskSuspendAll(); \t\tprvLockQueue( pxQueue ); \t\t/* Update the timeout state to see if it has expired yet. */ \t\tif( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) pdFALSE ) \t\t{ \t\t\t//还有等待的时间 \t\t\tif( prvIsQueueEmpty( pxQueue ) ! pdFALSE ) \t\t\t{ \t\t\t\ttraceBLOCKING_ON_QUEUE_RECEIVE( pxQueue ); \t\t\t\t#if ( configUSE_MUTEXES 1 ) \t\t\t\t{ \t\t\t\t\tif( pxQueue >uxQueueType queueQUEUE_IS_MUTEX ) \t\t\t\t\t{ \t\t\t\t\t\ttaskENTER_CRITICAL(); \t\t\t\t\t\t{ //是一个锁, 进行优先级继承, 记录有没有继承 \t\t\t\t\t\t\txInheritanceOccurred xTaskPriorityInherit( ( void * ) pxQueue >pxMutexHolder ); \t\t\t\t\t\t} \t\t\t\t\t\ttaskEXIT_CRITICAL(); \t\t\t\t\t} \t\t\t\t\telse \t\t\t\t\t{ \t\t\t\t\t\tmtCOVERAGE_TEST_MARKER(); \t\t\t\t\t} \t\t\t\t} \t\t\t\t#endif \t\t\t\tvTaskPlaceOnEventList( &( pxQueue >xTasksWaitingToReceive ), xTicksToWait ); \t\t\t\tprvUnlockQueue( pxQueue ); \t\t\t\tif( xTaskResumeAll() pdFALSE ) \t\t\t\t{ \t\t\t\t\tportYIELD_WITHIN_API(); \t\t\t\t} \t\t\t\telse \t\t\t\t{ \t\t\t\t\tmtCOVERAGE_TEST_MARKER(); \t\t\t\t} \t\t\t} \t\t\telse \t\t\t{ \t\t\t\t/* There was no timeout and the semaphore count was not 0, so \t\t\t\tattempt to take the semaphore again. */ \t\t\t\tprvUnlockQueue( pxQueue ); \t\t\t\t( void ) xTaskResumeAll(); \t\t\t} \t\t} \t\telse \t\t{ \t\t\t/* Timed out. */ \t\t\tprvUnlockQueue( pxQueue ); \t\t\t( void ) xTaskResumeAll(); \t\t\t/* If the semaphore count is 0 exit now as the timeout has \t\t\texpired. Otherwise return to attempt to take the semaphore that is \t\t\tknown to be available. As semaphores are implemented by queues the \t\t\tqueue being empty is equivalent to the semaphore count being 0. */ \t\t\tif( prvIsQueueEmpty( pxQueue ) ! pdFALSE ) \t\t\t{ \t\t\t\t#if ( configUSE_MUTEXES 1 ) \t\t\t\t{ \t\t\t\t\t/* xInheritanceOccurred could only have be set if \t\t\t\t\tpxQueue >uxQueueType queueQUEUE_IS_MUTEX so no need to \t\t\t\t\ttest the mutex type again to check it is actually a mutex. */ \t\t\t\t\tif( xInheritanceOccurred ! pdFALSE ) \t\t\t\t\t{ //继承过优先级, 但是现在被降级了 \t\t\t\t\t\ttaskENTER_CRITICAL(); \t\t\t\t\t\t{ \t\t\t\t\t\t\tUBaseType_t uxHighestWaitingPriority; \t\t\t\t\t\t\t/* 记录一下现在等待的任务的最高优先级 */ \t\t\t\t\t\t\tuxHighestWaitingPriority prvGetDisinheritPriorityAfterTimeout( pxQueue ); \t\t\t\t\t\t\tvTaskPriorityDisinheritAfterTimeout( ( void * ) pxQueue >pxMutexHolder, uxHighestWaitingPriority ); \t\t\t\t\t\t} \t\t\t\t\t\ttaskEXIT_CRITICAL(); \t\t\t\t\t} \t\t\t\t} \t\t\t\t#endif /* configUSE_MUTEXES */ \t\t\t\ttraceQUEUE_RECEIVE_FAILED( pxQueue ); \t\t\t\treturn errQUEUE_EMPTY; \t\t\t} \t\t\telse \t\t\t{ \t\t\t\tmtCOVERAGE_TEST_MARKER(); \t\t\t} \t\t} \t} } ```` ### 优先级继承 ```c BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder ) { TCB_t * const pxMutexHolderTCB ( TCB_t * ) pxMutexHolder; BaseType_t xReturn pdFALSE; /* 检测这个锁有没有被中断释放 */ if( pxMutexHolder ! NULL ) { /* 需要继承优先级 */ if( pxMutexHolderTCB >uxPriority < pxCurrentTCB >uxPriority ) { /* 进行调整 */ if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB >xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) 0UL ) { listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB >xEventListItem ), ( TickType_t ) configMAX_PRIORITIES ( TickType_t ) pxCurrentTCB >uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */ } else { mtCOVERAGE_TEST_MARKER(); } /* 调整他的列表 */ if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB >uxPriority ] ), &( pxMutexHolderTCB >xStateListItem ) ) ! pdFALSE ) { //在拥有者在Ready队列里面 if( uxListRemove( &( pxMutexHolderTCB >xStateListItem ) ) ( UBaseType_t ) 0 ) { taskRESET_READY_PRIORITY( pxMutexHolderTCB >uxPriority ); } else { mtCOVERAGE_TEST_MARKER(); } /* 继承优先级 */ pxMutexHolderTCB >uxPriority pxCurrentTCB >uxPriority; prvAddTaskToReadyList( pxMutexHolderTCB ); } else { //不在Ready的列表里面, 不需要改列表 /* Just inherit the priority. */ pxMutexHolderTCB >uxPriority pxCurrentTCB >uxPriority; } traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB >uxPriority ); /* Inheritance occurred. */ xReturn pdTRUE; } else { if( pxMutexHolderTCB >uxBasePriority < pxCurrentTCB >uxPriority ) { //基础优先级比较低, 但是现在实际的优先级不低, 不需要继承 /* The base priority of the mutex holder is lower than the \t\t\t\t\tpriority of the task attempting to take the mutex, but the \t\t\t\t\tcurrent priority of the mutex holder is not lower than the \t\t\t\t\tpriority of the task attempting to take the mutex. \t\t\t\t\tTherefore the mutex holder must have already inherited a \t\t\t\t\tpriority, but inheritance would have occurred if that had \t\t\t\t\tnot been the case. */ xReturn pdTRUE; } else { mtCOVERAGE_TEST_MARKER(); } } } else { mtCOVERAGE_TEST_MARKER(); } return xReturn; } ``` ```c //返回没有继承的时候的优先级 BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder ) { TCB_t * const pxTCB ( TCB_t * ) pxMutexHolder; BaseType_t xReturn pdFALSE; if( pxMutexHolder ! NULL ) { ( pxTCB >uxMutexesHeld ) ; /* 检测之前有没有继承过优先级 */ if( pxTCB >uxPriority ! pxTCB >uxBasePriority ) { /* 当前没有需要保持优先级的锁了 */ if( pxTCB >uxMutexesHeld ( UBaseType_t ) 0 ) { /* A task can only have an inherited priority if it holds \t\t\t\t\tthe mutex. If the mutex is held by a task then it cannot be \t\t\t\t\tgiven from an interrupt, and if a mutex is given by the \t\t\t\t\tholding task then it must be the running state task. Remove \t\t\t\t\tthe holding task from the ready list. */ if( uxListRemove( &( pxTCB >xStateListItem ) ) ( UBaseType_t ) 0 ) { taskRESET_READY_PRIORITY( pxTCB >uxPriority ); } else { mtCOVERAGE_TEST_MARKER(); } /* Disinherit the priority before adding the task into the \t\t\t\t\tnew\tready list. */ traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB >uxBasePriority ); pxTCB >uxPriority pxTCB >uxBasePriority; /* Reset the event list item value. It cannot be in use for \t\t\t\t\tany other purpose if this task is running, and it must be \t\t\t\t\trunning to give back the mutex. */ listSET_LIST_ITEM_VALUE( &( pxTCB >xEventListItem ), ( TickType_t ) configMAX_PRIORITIES ( TickType_t ) pxTCB >uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */ prvAddTaskToReadyList( pxTCB ); /* Return true to indicate that a context switch is required. \t\t\t\t\tThis is only actually required in the corner case whereby \t\t\t\t\tmultiple mutexes were held and the mutexes were given back \t\t\t\t\tin an order different to that in which they were taken. \t\t\t\t\tIf a context switch did not occur when the first mutex was \t\t\t\t\treturned, even if a task was waiting on it, then a context \t\t\t\t\tswitch should occur when the last mutex is returned whether \t\t\t\t\ta task is waiting on it or not. */ xReturn pdTRUE; } else { mtCOVERAGE_TEST_MARKER(); } } else { mtCOVERAGE_TEST_MARKER(); } } else { mtCOVERAGE_TEST_MARKER(); } return xReturn; } ``` ```c //一个锁超时没有获得资源,需要获取拥有者现在的等待者里面最高优先级 static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue ) { UBaseType_t uxHighestPriorityOfWaitingTasks; /* If a task waiting for a mutex causes the mutex holder to inherit a \t\tpriority, but the waiting task times out, then the holder should \t\tdisinherit the priority but only down to the highest priority of any \t\tother tasks that are waiting for the same mutex. For this purpose, \t\treturn the priority of the highest priority task that is waiting for the \t\tmutex. */ if( listCURRENT_LIST_LENGTH( &( pxQueue >xTasksWaitingToReceive ) ) > 0 ) { uxHighestPriorityOfWaitingTasks configMAX_PRIORITIES listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue >xTasksWaitingToReceive ) ); } else { uxHighestPriorityOfWaitingTasks tskIDLE_PRIORITY; } return uxHighestPriorityOfWaitingTasks; } ``` ```c //一个拥有者在申请者超时以后的处理 void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask ) { TCB_t * const pxTCB ( TCB_t * ) pxMutexHolder; UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse; const UBaseType_t uxOnlyOneMutexHeld ( UBaseType_t ) 1; if( pxMutexHolder ! NULL ) { /* 检测需要改为新的继承等级吗? */ if( pxTCB >uxBasePriority < uxHighestPriorityWaitingTask ) { uxPriorityToUse uxHighestPriorityWaitingTask; } else { uxPriorityToUse pxTCB >uxBasePriority; } /* Does the priority need to change? */ if( pxTCB >uxPriority ! uxPriorityToUse ) { /* 进行了优先级的切换 */ if( pxTCB >uxMutexesHeld uxOnlyOneMutexHeld ) { //这时候这一个任务只有一个锁, 不会影响别的锁 /* 检测这个超时的任务不是要更改的任务 */ configASSERT( pxTCB ! pxCurrentTCB ); \t\t\t\t uxPriorityUsedOnEntry pxTCB >uxPriority; pxTCB >uxPriority uxPriorityToUse; /* Only reset the event list item value if the value is not \t\t\t\t\tbeing used for anything else. */ if( ( listGET_LIST_ITEM_VALUE( &( pxTCB >xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) 0UL ) { listSET_LIST_ITEM_VALUE( &( pxTCB >xEventListItem ), ( TickType_t ) configMAX_PRIORITIES ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */ } /* 更换所在的列表 */ if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB >xStateListItem ) ) ! pdFALSE ) { if( uxListRemove( &( pxTCB >xStateListItem ) ) ( UBaseType_t ) 0 ) { taskRESET_READY_PRIORITY( pxTCB >uxPriority ); } prvAddTaskToReadyList( pxTCB ); } } } } else { mtCOVERAGE_TEST_MARKER(); } } ``` ## 互斥量 ```c typedef struct QueueDefinition /* The old naming convention is used to prevent breaking kernel aware debuggers. */ { ... union { QueuePointers_t xQueue; SemaphoreData_t xSemaphore; /*< 记录递归调用的次数 */ } u; ... volatile UBaseType_t uxMessagesWaiting; /*1: 可以使用 0: 被占用了*/ UBaseType_t uxLength; /* 1*/ UBaseType_t uxItemSize; /* 0*/ ... } xQUEUE; ``` ````c #define pxMutexHolder\t\t\t\t\tpcTail #define uxQueueType\t\t\t\t\t\tpcHead #define queueQUEUE_IS_MUTEX\t\t\t\tNULL ```` pcTail与pcHead用于指向消息存储区域的, pxMutexHolder就被用于指向持有互斥量的任务控制块，现在初始化的时候，就初始化为NULL，表示没有任务持有互斥量。uxQueueType表示队列的类型，设置为queueQUEUE_IS_MUTEX（NULL），表示的是用作互斥量 ```c static void prvInitialiseMutex( Queue_t *pxNewQueue ) { if( pxNewQueue ! NULL ) { /* The queue create function will set all the queue structure members \t\t\tcorrectly for a generic queue, but this function is creating a \t\t\tmutex. Overwrite those members that need to be set differently \t\t\tin particular the information required for priority inheritance. */ pxNewQueue >pxMutexHolder NULL; pxNewQueue >uxQueueType queueQUEUE_IS_MUTEX; /* In case this is a recursive mutex. */ pxNewQueue >u.uxRecursiveCallCount 0; traceCREATE_MUTEX( pxNewQueue ); /* Start with the semaphore in the expected state. */ ( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK ); } else { traceCREATE_MUTEX_FAILED(); } } ``` ### 递归互斥量 ```c BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait ) { BaseType_t xReturn; Queue_t * const pxMutex ( Queue_t * ) xMutex; \t//当前任务多次调用 if( pxMutex >pxMutexHolder ( void * ) xTaskGetCurrentTaskHandle() ) { ( pxMutex >u.uxRecursiveCallCount )++; xReturn pdPASS; } else { xReturn xQueueSemaphoreTake( pxMutex, xTicksToWait ); /* pdPASS will only be returned if the mutex was successfully \t\t\tobtained. The calling task may have entered the Blocked state \t\t\tbefore reaching here. */ if( xReturn ! pdFAIL ) { ( pxMutex >u.uxRecursiveCallCount )++; } } return xReturn; } ``` ## 事件组 ```c typedef struct xEventGroupDefinition { \tEventBits_t uxEventBits; \tList_t xTasksWaitingForBits;\t\t/* 记录等待的任务 */ \t#if( configUSE_TRACE_FACILITY 1 ) \t\tUBaseType_t uxEventGroupNumber;\t//用于可视化追踪 \t#endif \t#if( ( configSUPPORT_STATIC_ALLOCATION 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION 1 ) ) \t\tuint8_t ucStaticallyAllocated; //记录是不是静态分配的 \t#endif } EventGroup_t; ``` ### 设置 ![image 20240122195201868](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401221952112.png) ```c EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet ) { ListItem_t *pxListItem, *pxNext; ListItem_t const *pxListEnd; List_t *pxList; EventBits_t uxBitsToClear 0, uxBitsWaitedFor, uxControlBits; EventGroup_t *pxEventBits ( EventGroup_t * ) xEventGroup; BaseType_t xMatchFound pdFALSE; \tpxList &( pxEventBits >xTasksWaitingForBits ); \tpxListEnd listGET_END_MARKER( pxList ); \tvTaskSuspendAll(); \t{ \t\ttraceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet ); \t\tpxListItem listGET_HEAD_ENTRY( pxList ); \t\t/* Set the bits. */ \t\tpxEventBits >uxEventBits uxBitsToSet; \t\t/* See if the new bit value should unblock any tasks. */ \t\twhile( pxListItem ! pxListEnd ) \t\t{ \t\t\tpxNext listGET_NEXT( pxListItem ); \t\t\tuxBitsWaitedFor listGET_LIST_ITEM_VALUE( pxListItem ); \t\t\txMatchFound pdFALSE; \t\t\t/* Split the bits waited for from the control bits. */ \t\t\tuxControlBits uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES; \t\t\tuxBitsWaitedFor & ~eventEVENT_BITS_CONTROL_BYTES; \t\t\tif( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) ( EventBits_t ) 0 ) \t\t\t{ \t\t\t\t/* 有一个bit匹配就可以了 */ \t\t\t\tif( ( uxBitsWaitedFor & pxEventBits >uxEventBits ) ! ( EventBits_t ) 0 ) \t\t\t\t{ \t\t\t\t\txMatchFound pdTRUE; \t\t\t\t} \t\t\t\telse \t\t\t\t{ \t\t\t\t\tmtCOVERAGE_TEST_MARKER(); \t\t\t\t} \t\t\t} \t\t\telse if( ( uxBitsWaitedFor & pxEventBits >uxEventBits ) uxBitsWaitedFor ) \t\t\t{ \t\t\t\t/* 所有的bit都需要匹配. */ \t\t\t\txMatchFound pdTRUE; \t\t\t} \t\t\tif( xMatchFound ! pdFALSE ) \t\t\t{ \t\t\t\t/* 需要切换 */ \t\t\t\tif( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) ! ( EventBits_t ) 0 ) \t\t\t\t{ //需要进行bit的清除 \t\t\t\t\tuxBitsToClear uxBitsWaitedFor; \t\t\t\t} \t\t\t\t//从列表里面移除, 同时设置标志位 \t\t\t\tvTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits >uxEventBits eventUNBLOCKED_DUE_TO_BIT_SET ); \t\t\t} \t\t\t/* 获取下一个(这个时候已经改变表的位置了) */ \t\t\tpxListItem pxNext; \t\t} \t\t/* 如果需要清除的话就进行清除 */ \t\tpxEventBits >uxEventBits & ~uxBitsToClear; \t} \t( void ) xTaskResumeAll(); \treturn pxEventBits >uxEventBits; } ``` ```c EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait ) { EventGroup_t *pxEventBits ( EventGroup_t * ) xEventGroup; EventBits_t uxReturn, uxControlBits 0; BaseType_t xWaitConditionMet, xAlreadyYielded; BaseType_t xTimeoutOccurred pdFALSE; \tvTaskSuspendAll(); \t{ \t\tconst EventBits_t uxCurrentEventBits pxEventBits >uxEventBits; \t\t/* 检测是不是匹配得上 */ \t\txWaitConditionMet prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits ); \t\tif( xWaitConditionMet ! pdFALSE ) \t\t{ \t\t\t/* 已经满足了 */ \t\t\tuxReturn uxCurrentEventBits; \t\t\txTicksToWait ( TickType_t ) 0; \t\t\t/* 清空对应的标志位o. */ \t\t\tif( xClearOnExit ! pdFALSE ) \t\t\t{ \t\t\t\tpxEventBits >uxEventBits & ~uxBitsToWaitFor; \t\t\t} \t\t} \t\telse if( xTicksToWait ( TickType_t ) 0 ) \t\t{ \t\t\t/* 不等待, 直接退出 */ \t\t\tuxReturn uxCurrentEventBits; \t\t\txTimeoutOccurred pdTRUE; \t\t} \t\telse \t\t{ \t\t\t/* 记录一下条件 */ \t\t\tif( xClearOnExit ! pdFALSE ) \t\t\t{ \t\t\t\tuxControlBits eventCLEAR_EVENTS_ON_EXIT_BIT; \t\t\t} \t\t\tif( xWaitForAllBits ! pdFALSE ) \t\t\t{ \t\t\t\tuxControlBits eventWAIT_FOR_ALL_BITS; \t\t\t} \t\t\t/* 把这个加入到Delay和事件的等待队列里面, 同时使用EventList的参数保存一下当前状态 */ \t\t\tvTaskPlaceOnUnorderedEventList( &( pxEventBits >xTasksWaitingForBits ), ( uxBitsToWaitFor uxControlBits ), xTicksToWait ); \t\t\t \t\t\tuxReturn 0; \t\t\ttraceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor ); \t\t} \t} \txAlreadyYielded xTaskResumeAll(); \tif( xTicksToWait ! ( TickType_t ) 0 ) \t{ \t\tif( xAlreadyYielded pdFALSE ) \t\t{ \t\t\tportYIELD_WITHIN_API(); \t\t} \t\t/* 恢复之前用来记录的vEventList的值, 返回的是记录的事件的值 */ uxReturn uxTaskResetEventItemValue(); \t\tif( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) ( EventBits_t ) 0 ) \t\t{ //超时了 \t\t\ttaskENTER_CRITICAL(); \t\t\t{ \t\t\t\tuxReturn pxEventBits >uxEventBits; \t\t\t\t/* 最后检测一下是不是达标了 */ \t\t\t\tif( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) ! pdFALSE ) \t\t\t\t{ \t\t\t\t\tif( xClearOnExit ! pdFALSE ) \t\t\t\t\t{ \t\t\t\t\t\tpxEventBits >uxEventBits & ~uxBitsToWaitFor; \t\t\t\t\t} \t\t\t\t} \t\t\t\txTimeoutOccurred pdTRUE; \t\t\t} \t\t\ttaskEXIT_CRITICAL(); \t\t} \t\t/* 记录所有的标志位 */ \t\tuxReturn & ~eventEVENT_BITS_CONTROL_BYTES; \t} \treturn uxReturn; } ```"},"/note/嵌入式/第三方移植/freeRTOS/2023-7-9-fire3任务创建切换.html":{"title":"任务切换创建","content":" layout: post title: \"任务切换创建\" date: 2023 7 9 15:39:08 +0800 tags: FreeRTOS # 任务创建切换 把系统分割为一个个独立无法返回的函数, 函数称之为任务 + 为每一个任务分配栈空间 ```c /***********定义任务栈************/ #define TASK1_STACK_SIZE\t\t\t20 StackType_t Task1Stack[TASK1_STACK_SIZE]; TCB_t TASK1_TCB; #define TASK2_STACK_SIZE\t\t\t20 StackType_t Task2Stack[TASK2_STACK_SIZE]; TCB_t TASK2_TCB; /*************测试任务用的标志*************/ portCHAR flag1; portCHAR flag2; ``` 创建任务的PCB ```c typedef struct tskTaskControlBlock { \t//栈顶 \tvolatile StackType_t\t*pxTopOfStack;\t\t \t \t//任务节点 \tListItem_t\t\t\t\txStateListItem;\t \tStackType_t \t\t\t*pxStack; \t\t//任务栈的起始位置 \t \tchar \t\t\t\t\tpcTaskName[configMAX_TASK_NAME_LEN]; }tskTCB; typedef tskTCB TCB_t; ``` + 任务的创建 静态创建, 控制块内存事先定义好, 静态内存, 删除任务的时候不能释放 ```c TaskHandle_t xTaskCreateStatic(\tTaskFunction_t pxTaskCode, /* 任务入口, 就是任务实际进行的函数 */ \t\t\t\t\t const char * const pcName, /* 任务名称，字符串形式 */ \t\t\t\t\t const uint32_t ulStackDepth, /* 任务栈大小，单位为字 */ \t\t\t\t\t void * const pvParameters, /* 任务形参 */ \t\t\t\t\t StackType_t * const puxStackBuffer, /* 任务栈起始地址 */ \t\t\t\t\t TCB_t * const pxTaskBuffer ) /* 任务控制块指针 */ { \tTCB_t *pxNewTCB; \tTaskHandle_t xReturn;\t\t//返回值,实际上是一个空指针 \tif( ( pxTaskBuffer ! NULL ) && ( puxStackBuffer ! NULL ) ) \t{\t //任务控制块和栈指针都不为空,初始化控制块的栈地址 \t\tpxNewTCB ( TCB_t * ) pxTaskBuffer; \t\tpxNewTCB >pxStack ( StackType_t * ) puxStackBuffer; \t\t/* 创建新的任务 */ \t\tprvInitialiseNewTask( pxTaskCode, /* 任务入口 */ pcName, /* 任务名称，字符串形式 */ ulStackDepth, /* 任务栈大小，单位为字 */ pvParameters, /* 任务形参 */ &xReturn, /* 任务句柄 */ pxNewTCB); /* 任务栈起始地址 */ \t} \telse \t{ \t\txReturn NULL; \t} \t/* 返回任务句柄，如果任务创建成功，此时xReturn应该指向任务控制块 */ return xReturn; } ``` + 任务的初始化 ```c static void prvInitialiseNewTask( \tTaskFunction_t pxTaskCode, /* 任务入口 */ \t\t\t\t\t\t\t\t\tconst char * const pcName, /* 任务名称，字符串形式 */ \t\t\t\t\t\t\t\t\tconst uint32_t ulStackDepth, /* 任务栈大小，单位为字 */ \t\t\t\t\t\t\t\t\tvoid * const pvParameters, /* 任务形参 */ \t\t\t\t\t\t\t\t\tTaskHandle_t * const pxCreatedTask, /* 任务句柄 */ \t\t\t\t\t\t\t\t\tTCB_t *pxNewTCB ) /* 任务控制块指针 */ { \tStackType_t *pxTopOfStack; \tUBaseType_t x;\t \t \t/* 获取栈顶地址 */ \tpxTopOfStack pxNewTCB >pxStack + ( ulStackDepth ( uint32_t ) 1 ); \t//pxTopOfStack ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); \t/* 向下做8字节对齐, 前三位直接置零 */ \tpxTopOfStack ( StackType_t * ) ( ( ( uint32_t ) pxTopOfStack ) & ( ~( ( uint32_t ) 0x0007 ) ) );\t \t/* 将任务的名字存储在TCB中 */ \tfor( x ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ ) \t{ \t\tpxNewTCB >pcTaskName[ x ] pcName[ x ]; \t\tif( pcName[ x ] 0x00 ) \t\t{ \t\t\tbreak; \t\t} \t} \t/* 任务名字的长度不能超过configMAX_TASK_NAME_LEN,最后加上结尾标志 */ \tpxNewTCB >pcTaskName[ configMAX_TASK_NAME_LEN 1 ] '\\0'; /* 初始化TCB中的xStateListItem节点,这里是把所在的列表指向NULL */ vListInitialiseItem( &( pxNewTCB >xStateListItem ) ); /* 设置xStateListItem节点的拥有者 */ \tlistSET_LIST_ITEM_OWNER( &( pxNewTCB >xStateListItem ), pxNewTCB ); /* 初始化任务栈, 填入栈中的CPU的寄存器的值 */ \tpxNewTCB >pxTopOfStack pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters ); \t/* 让任务句柄指向任务控制块 */ if( ( void * ) pxCreatedTask ! NULL ) \t{\t\t \t\t*pxCreatedTask ( TaskHandle_t ) pxNewTCB; \t} } ``` > 硬件有关的函数初始化在port.c文件中 > > 声明在portable.h文件中 ![image 20230710103937220](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401251337304.png) 在初始化一个任务的时候, 需要实现的内容 ```c static void prvTaskExitError( void ) { \t//默认任务不返回, 返回进入死循环 /* 函数停止在这里 */ for(;;); } StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters ) { /* 异常发生时，自动加载到CPU寄存器的内容 */ \tpxTopOfStack ; \t*pxTopOfStack portINITIAL_XPSR;\t /* xPSR的bit24必须置1 */ \tpxTopOfStack ; \t*pxTopOfStack ( ( StackType_t ) pxCode ) & portSTART_ADDRESS_MASK;\t/* PC，即任务入口函数 */ \tpxTopOfStack ; \t*pxTopOfStack ( StackType_t ) prvTaskExitError;\t /* LR，函数返回地址 */ \tpxTopOfStack 5;\t/* R12, R3, R2 and R1 默认初始化为0 */ \t*pxTopOfStack ( StackType_t ) pvParameters;\t /* R0，任务形参 */ /* 异常发生时，手动加载到CPU寄存器的内容 */ \tpxTopOfStack 8;\t/* R11, R10, R9, R8, R7, R6, R5 and R4默认初始化为0 */ \t/* 返回栈顶指针，此时pxTopOfStack指向空闲栈 */ return pxTopOfStack; } ``` > 任务第一次运行的时候, 需要手动加载8个字的内容到CPU寄存器, 剩下的八个会自动加载, 从而完成任务的跳转 + 创建任务列表 ```c List_t pxReadTasksLists[configMAX_PRIORITIES]; ``` > 这是根节点, 设置优先级 ```c void prvInitialiseTaskLists( void ) { UBaseType_t uxPriority; for( uxPriority ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ ) \t{ \t\tvListInitialist( &( pxReadyTasksLists[ uxPriority ] ) ); \t} } ``` > 之后可以使用插入函数把任务插入列表 ### 实现任务切换 ```c extern TCB_t Task1TCB; extern TCB_t Task2TCB; void vTaskStartScheduler( void ) { /* 手动指定第一个运行的任务,这是一个全局变量指针, 指向正在运行的程序 */ pxCurrentTCB &Task1TCB; /* 启动调度器 */ if( xPortStartScheduler() ! pdFALSE ) { /* 调度器启动成功，则不会返回，即不会来到这里 */ } } ``` ```c BaseType_t xPortStartScheduler( void ) { /* 配置PendSV 和 SysTick 的中断优先级为最低, 直接控制寄存器实现 */ \tportNVIC_SYSPRI2_REG portNVIC_PENDSV_PRI; \tportNVIC_SYSPRI2_REG portNVIC_SYSTICK_PRI; \t/* 启动第一个任务，不再返回 */ \tprvStartFirstTask(); \t/* 不应该运行到这里 */ \treturn 0; } ``` > PendSV（可悬起的系统调用），它是一种CPU系统级别的异常，它可以像普通外设中断一样被悬起，而不会像SVC服务那样，因为没有及时响应处理，而触发Fault。 > > SCV(系统服务调用) > > 在产生中断的时候, 如果产生了一个任务切换, 会在切换之后返回新的任务而不是中断函数, 导致出错, 还会导致任务处理不及时 > > 如果把Systick优先级放在最低, 在期间处理任务, 会导致时间过长, 实时性降低 > > > 采用滴答定时器中断, 制作业务调度之前判断, 不切换, 触发PendSV, PendSV不会立刻执行, 应为优先级最低, 所有中断处理完之后执行PendSV执行任务调度 ```c __asm void prvStartFirstTask( void ) { \tPRESERVE8 \t/* 在Cortex M中，0xE000ED08是SCB_VTOR这个寄存器的地址， 里面存放的是向量表的起始地址，即MSP的地址 */ \tldr r0, 0xE000ED08 \tldr r0, [r0]\t\t\t//这里加载的是内存的首地址 \tldr r0, [r0]\t\t\t//首地址的内容加载到r0 \t/* 设置主堆栈指针msp的值 */ \tmsr msp, r0\t\t\t//设置主栈的栈顶指针 \t/* 使能全局中断, 异常 */ \tcpsie i \tcpsie f \tdsb \tisb \t /* 调用SVC去启动第一个任务 */ \tsvc 0 \tnop \tnop } ``` > 手动启动一个任务, 从0xE000ED08这个位置解读出来主堆栈的指针(中断向量表的第一个位置记录上电时候的初始化值), 重新设置一下msp主栈指针 > Cortex M3中为了快速打开中断有四个指令 > > ```assembly > CPSID \tI\t;关中断 > CPSIE\tI\t;开中断 > CPSID\tF\t;关异常 > CPSIE\tF\t;开异常 > ``` > > 使用了三个寄存器实现 > > PRIMASK: 设置为1以后关闭所有可屏蔽中断, 只剩下NMI和硬FSULT可以响应 > > FAULTMASK, 设置为1, 只有NMI可以响应 > > BASEPRI: 最多有九位, 设置为一个数, 优先级比他大的都屏蔽 **数据存储屏障（Data Memory Barrier，DMB）指令：**仅当所有在它前面的存储器访问操作都执行完毕后，才提交（commit）在它后面的访问指令。DMB指令保证的是DMB指令之前的所有内存访问指令和DMB指令之后的所有内存访问指令的执行顺序。也就是说，DMB指令之后的内存访问指令不会被处理器重排到DMB指令的前面。DMB指令不会保证内存访问指令在内存屏障指令之前完成，它仅仅保证内存屏障指令前后的内存访问的执行顺序。DMB指令仅仅影响内存访问指令、数据高速缓存指令以及高速缓存管理指令等，并不会影响其他指令（例如算术运算指令等）的顺序。 **数据同步屏障（Data Synchronization Barrier，DSB）指令：**比DMB指令要严格一些，仅当所有在它前面的内存访问指令都执行完毕后，才会执行在它后面的指令，即任何指令都要等待DSB指令前面的内存访问指令完成。位于此指令前的所有缓存（如分支预测和TLB维护）操作需要全部完成。 **指令同步屏障（Instruction Synchronization Barrier，ISB）指令：**确保所有在ISB指令之后的指令都从指令高速缓存或内存中重新预取。它刷新流水线（flush pipeline）和预取缓冲区后才会从指令高速缓存或者内存中预取ISB指令之后的指令。ISB指令通常用来保证上下文切换（如ASID更改、TLB维护操作等）的效果。 + 可以使用SVC指令，然后执行操作系统中的软件异常处理程序，并提供用户应用程序请求的服务。 ```assembly __asm void vPortSVCHandler( void ) { extern pxCurrentTCB; PRESERVE8 \tldr\tr3, pxCurrentTCB\t/* 加载pxCurrentTCB的地址到r3 */ \tldr r1, [r3]\t\t\t/* 加载pxCurrentTCB到r1 */ \tldr r0, [r1]\t\t\t/* 加载pxCurrentTCB指向的值到r0，目前r0的值等于第一个任务堆栈的栈顶, 应为这是结构体的第一个参数 */ \tldmia r0!, {r4 r11}\t\t/* 以r0为基地址，将栈里面的内容加载到r4~r11寄存器，同时r0会递增 */ \tmsr psp, r0\t\t\t\t/* 将r0的值，即任务的栈指针更新到psp */ \tisb \tmov r0, #0 /* 设置r0的值为0 */ \tmsr\tbasepri, r0 /* 设置basepri寄存器的值为0，即所有的中断都没有被屏蔽 */ \torr r14, #0xd /* 当从SVC中断服务退出前,通过向r14寄存器最后4位按位或上0x0D,使得硬件在退出时使用进程堆栈指针PSP完成出栈操作并返回后进入线程模式、返回Thumb状态 */ \tbx r14 /* 异常返回，这个时候栈中的剩下内容将会自动加载到CPU寄存器： xPSR，PC（任务入口地址），R14，R12，R3，R2，R1，R0（任务的形参） 同时PSP的值也将更新，即指向任务栈的栈顶 */ } ``` > msp: 主栈指针 > > psp: 进程栈指针 > 当R14的值为子程序链接寄存器, 保存返回地址(但是在中断中返回的时候使用的是EXC_RETURN数值) > > 他的bit1设置为0表示使用的栈指针是psp > > bit2表示使用用户模式还是特权模式, 设置为1为用户模式 > > ![image 20240116190859171](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401161908223.png) > > ![image 20240116190921195](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401161909231.png) ```c #define xPortPendSVHandler PendSV_Handler #define xPortSysTickHandler SysTick_Handler #define vPortSVCHandler SVC_Handler ``` > 在这里声明为stm32的函数名字 ### 实现切换 实际上就是把PandSV中断悬起, 当没有其他中断的时候, 就会响应这个中断 ```c //这个是在portmacro.h文件中实现的, 目的是使能PendSV /* 中断控制状态寄存器：0xe000ed04 * Bit 28 PENDSVSET: PendSV 悬起位 */ //定义控制器的地址 #define portNVIC_INT_CTRL_REG\t\t( * ( ( volatile uint32_t * ) 0xe000ed04 ) ) //设置为悬起的控制位 #define portNVIC_PENDSVSET_BIT\t\t( 1UL << 28UL ) #define portSY_FULL_READ_WRITE\t\t( 15 ) #define portYIELD()\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\ {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\ \t/* 触发PendSV，产生上下文切换 */\t\t\t\t\t\t\t\t \\ \tportNVIC_INT_CTRL_REG portNVIC_PENDSVSET_BIT;\t\t\t\t\t\t\t\t\\ \t__dsb( portSY_FULL_READ_WRITE );\t\t\t\t\t\t\t\t\t\t\t\\ \t__isb( portSY_FULL_READ_WRITE );\t\t\t\t\t\t\t\t\t\t\t\\ } ``` > \\_\\_dsb和\\_\\_isb的作用是 > > ![image 20240120184442790](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401201844903.png) ```c //实现在task.h文件 #define taskYIELD()\t\t\tportYIELD() ``` ```c __asm void xPortPendSVHandler( void ) { \textern pxCurrentTCB;\t\t\t//指向现在运行的任务的指针 \textern vTaskSwitchContext;\t\t//切换指向的函数 \tPRESERVE8 /* 当进入PendSVC Handler时，上一个任务运行的环境即： xPSR，PC（任务入口地址），R14，R12，R3，R2，R1，R0（任务的形参） 这些CPU寄存器的值会自动保存到任务的栈中，剩下的r4~r11需要手动保存 */ /* 获取任务栈指针到r0 */ \tmrs r0, psp \tisb \tldr\tr3, pxCurrentTCB\t\t/* 加载pxCurrentTCB的地址到r3 */ \tldr\tr2, [r3] /* 加载pxCurrentTCB到r2 实际上就是栈顶的指针*/ \tstmdb r0!, {r4 r11}\t\t\t/* 将CPU寄存器r4~r11的值存储到r0指向的地址, 保存在任务的栈中 */ \tstr r0, [r2] /* 将任务栈的新的栈顶指针存储到当前任务TCB的第一个成员，即栈顶指针 */\t\t\t\t \tstmdb sp!, {r3, r14} /* 将R3和R14临时压入堆栈，因为即将调用函数vTaskSwitchContext, 这里由于在中断中所以所使用的栈是MSP调用函数时,返回地址自动保存到R14中,所以一旦调用发生,R14的值会被覆盖,因此需要入栈保护;R3保存的当前激活的任务TCB指针(pxCurrentTCB)地址,函数调用后会用到,因此也要入栈保护 */ \tmov r0, #configMAX_SYSCALL_INTERRUPT_PRIORITY /* 进入临界段 */ \tmsr basepri, r0 \tdsb \tisb \tbl vTaskSwitchContext /* 调用函数vTaskSwitchContext，寻找新的任务运行,通过使变量pxCurrentTCB指向新的任务来实现任务切换 */ \tmov r0, #0 /* 退出临界段 */ \tmsr basepri, r0\t\t\t\t//打开中断 \tldmia sp!, {r3, r14} /* 恢复r3和r14 */ \tldr r1, [r3]\t\t\t\t//r1保存当前的TCB, 这里的值已经更新 \tldr r0, [r1] \t\t\t\t/* 当前激活的任务TCB第一项保存了任务堆栈的栈顶,现在栈顶值存入R0*/ \tldmia r0!, {r4 r11}\t\t\t/* 出栈, 恢复新任务中断之前的状态 */ \tmsr psp, r0\t\t\t\t\t//栈的指针保存当前的R0的位置 \tisb \tbx r14 /* 异常发生时,R14中保存异常返回标志,包括返回后进入线程模式还是处理器模式、 使用PSP堆栈指针还是MSP堆栈指针，当调用 bx r14指令后，硬件会知道要从异常返回， 然后出栈，这个时候堆栈指针PSP已经指向了新任务堆栈的正确位置， 当新任务的运行地址被出栈到PC寄存器后，新的任务也会被执行。*/ \tnop } ``` > 中断服务函数 > > ![image 20230710140941934](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401251337305.png) > > **栈顶指针是会变化的** ## 使用总结 首先初始化函数的TCB, 以及初始化函数的栈空间以及内容 之后在创建任务的时候把他归入列表之中 实现任务的创建, 并且调动第一个任务, 之后开启任务的切换 ```c #include \"list.h\" #include \"task.h\" /***********定义任务栈以及TCB************/ #define TASK1_STACK_SIZE\t\t\t20 StackType_t Task1Stack[TASK1_STACK_SIZE]; TCB_t TASK1_TCB; #define TASK2_STACK_SIZE\t\t\t20 StackType_t Task2Stack[TASK2_STACK_SIZE]; TCB_t TASK2_TCB; /*************测试任务用的标志*************/ portCHAR flag1; portCHAR flag2; extern List_t pxReadyTasksLists[configMAX_PRIORITIES]; /************定义文件句柄***********/ TaskHandle_t Task1_Handle; TaskHandle_t Task2_Handle; /**************任务函数声明**************/ void delay(uint32_t count); void Task1_Entry(void *p_arg); void Task2_Entry(void *p_arg); int main(void) { \tprvInitialiseTaskLists(); \t//创建任务 \tTask1_Handle xTaskCreateStatic(Task1_Entry, \"Task1_Entry\", TASK1_STACK_SIZE, NULL, Task1Stack, &TASK1_TCB);\t \tvListInsert(&pxReadyTasksLists[1], &TASK1_TCB.xStateListItem);\t \t \tTask1_Handle xTaskCreateStatic(Task2_Entry, \"Task2_Entry\", TASK2_STACK_SIZE, NULL, Task2Stack, &TASK2_TCB); \tvListInsert(&pxReadyTasksLists[1], &TASK1_TCB.xStateListItem);\t \tvTaskStartScheduler(); \tfor(;;) \t{ \t\t/*空函数*/ \t} } //定义一个函数,是一个无限的循环 void Task1_Entry(void *p_arg) { \tfor(;;) \t{ \t\tflag1 1; \t\tdelay(100); \t\t \t\tflag1 0; \t\tdelay(100); \t\tportYIELD(); \t} } void Task2_Entry(void *p_arg) { \tfor(;;) \t{ \t\tflag2 1; \t\tdelay(100); \t\t \t\tflag2 0; \t\tdelay(100); \t\t//进行切换 \t\tportYIELD(); \t} } void delay(uint32_t count) { \tfor(;count ! 0;count ); } ``` ## 实际FreeRTOS分析 ```c BaseType_t xPortStartScheduler( void ) { \t#if( configASSERT_DEFINED 1 ) \t{ \t\tvolatile uint32_t ulOriginalPriority; //获取第一个用户的优先级设置的寄存器地址 \t\tvolatile uint8_t * const pucFirstUserPriorityRegister ( uint8_t * ) ( portNVIC_IP_REGISTERS_OFFSET_16 + portFIRST_USER_INTERRUPT_NUMBER ); \t\tvolatile uint8_t ucMaxPriorityValue; \t\t//保存当前的优先级 \t\tulOriginalPriority *pucFirstUserPriorityRegister; \t\t//向里面写入0xff \t\t*pucFirstUserPriorityRegister portMAX_8_BIT_VALUE; \t\t//读取 \t\tucMaxPriorityValue *pucFirstUserPriorityRegister; \t\t//断言判断一下设置的 \t\tconfigASSERT( ucMaxPriorityValue ( configKERNEL_INTERRUPT_PRIORITY & ucMaxPriorityValue ) ); //计算一下前面的0的位数 \t\tulMaxPRIGROUPValue portMAX_PRIGROUP_BITS; \t\twhile( ( ucMaxPriorityValue & portTOP_BIT_OF_BYTE ) portTOP_BIT_OF_BYTE ) \t\t{ \t\t\tulMaxPRIGROUPValue ; \t\t\tucMaxPriorityValue << ( uint8_t ) 0x01; \t\t} \t\t#ifdef configPRIO_BITS \t\t{ \t\t\t/* 测试一下实际的设置宏定义对不对 */ \t\t\tconfigASSERT( ( portMAX_PRIGROUP_BITS ulMaxPRIGROUPValue ) configPRIO_BITS ); \t\t} \t\t#endif \t\t/* 记录一下实际的NVIC的优先级需要的的值*/ \t\tulMaxPRIGROUPValue << portPRIGROUP_SHIFT; \t\tulMaxPRIGROUPValue & portPRIORITY_GROUP_MASK; \t\t/* 返回之前的值 */ \t\t*pucFirstUserPriorityRegister ulOriginalPriority; \t} \t#endif /* conifgASSERT_DEFINED */ \t/* 设置一下优先级 */ \tportNVIC_SYSPRI2_REG portNVIC_PENDSV_PRI; \tportNVIC_SYSPRI2_REG portNVIC_SYSTICK_PRI; \t/* 设置一下使用的时钟, 时钟源, 时钟的装载值等 */ \tvPortSetupTimerInterrupt(); \t/*`uxCriticalNesting`是临界区嵌套层数，FreeRTOS允许临界区嵌套，这个变量是为了避免在较低级别的临界区内部发生不必要的任务切换或中断处理，从而提高系统的可靠性和响应性。*/ \tuxCriticalNesting 0; \t/* 进入第一个任务 */ \tprvStartFirstTask(); \t/* Should not get here! */ \treturn 0; } ```"},"/note/嵌入式/第三方移植/freeRTOS/2023-11-15-wds01使用.html":{"title":"使用","content":" layout: post title: \"使用\" date: 2023 11 15 15:39:08 +0800 tags: FreeRTOS # 使用 ## 创建任务 ```c BaseType_t xTaskCreate( TaskFunction_t pxTaskCode, const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */ const configSTACK_DEPTH_TYPE usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask ) ``` > + 函数名 > + 栈的深度 > + 函数的参数 > + 优先级 > + 函数的句柄 > > 使用这一个函数的时候会动态进行分配任务的控制块, 使用malloc函数, 这个函数会分配一块heap的内存, 之后可以使用free函数进行释放, 释放的时候一般在这一段内存的前面会有一块内存保存有这一段内存的长度等信息用于内存管理 ```c TaskHandle_t xTaskCreateStatic( TaskFunction_t pxTaskCode, const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */ const uint32_t ulStackDepth, void * const pvParameters, UBaseType_t uxPriority, StackType_t * const puxStackBuffer, StaticTask_t * const pxTaskBuffer ) ``` > 使用的时候需要打开对应的宏 > > ```c > vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize ); > > StackType_t xIdleTaskStack[100]; > StaticTask_t xIdleTaskTCB; > void vApplicationGetIdleTaskMemory( StaticTask_t ** ppxIdleTaskTCBBuffer, > StackType_t ** ppxIdleTaskStackBuffer, > uint32_t * pulIdleTaskStackSize ){ > *ppxIdleTaskTCBBuffer &xIdleTaskTCB; > *ppxIdleTaskStackBuffer xIdleTaskStack; > *pulIdleTaskStackSize 100; > } > ``` > > > 需要实现这一个函数, 初始化一个空闲任务 + 优先级 设置的数值越小优先级越低, 最高为configMAX_PRIORITIES 1 ![image 20231116094523489](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311160945602.png) ![image 20231116094607339](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311160946366.png) ![image 20231116094637695](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311160946730.png) > 优先级相同的时候 ![image 20231116094859614](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311160948640.png) > 在当前的调度模式下面高优先级的任务会一直霸占CPU + 删除函数 可以在其他函数里面进行删除另一个任务 ```c /* If null is passed in here then it is the calling task that is * being deleted. */ void vTaskDelete( TaskHandle_t xTaskToDelete ); ``` > 在参数为NULL的时候会把自己删除掉 > > 使用动态创建的时候最后传入的TCB就是参数, 使用静态创建的时候使用的是返回的参数 + 栈长度 在任务中保存有这一些函数的参数等信息, 如果溢出就会破坏掉下一块的头部和TCB等信息 ### 延时函数 + vTaskDelay 任务进去和退出的时间, 时间是固定的, 传入的参数是任务休息的时钟数 ![image 20231116191401056](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311161914108.png) > 执行时间不同, 但是间隔时间相同 + vTaskDelayUntil 如果希望一个任务在执行的间隔是相等的使用这一个函数, 周期性的执行这一个函数, 当其他函数执行的时间不确定的时候还是可以保证任务间隔不变, 指定一个终点的时间 有两个参数, 使用函数xTaskGetTickCount()函数可以获取当前的时钟, 第一个参数是上面那个函数的返回值为TickType_t类型的, 传入的为指针, 返回的时候会更新里面的值, 第二个参数为下次执行的时间 ![image 20231116191619004](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311161916036.png) > 任务的启动是周期性的 ### 空闲函数以及钩子函数 **测试:**在一个任务里面不断的创建删除任务, 测试堆是否会被消耗完 结果: 程序没有崩溃 **测试:**在一个任务中创建另外一个任务, 在另一个任务里面自己终结自己 结果: 程序崩溃了 > 一个函数在自己终结自己的时候由于没有办法继续执行, 所以有一些内存没有办法清除, 需要有空闲任务帮助自己清理掉 + 空闲任务 会在vTaskStartScheduler();函数里面创建, 可以添加一个空闲任务的钩子函数 1. 执行一些低优先级, 后台的, 需要连续执行的函数 2. 测量系统的空闲时间, 算出CPU占用率 3. 让系统进入省电模式 > 使用一个宏configUSE_IDLE_HOOK > > ```c > #if ( configUSE_IDLE_HOOK 1 ) > { > extern void vApplicationIdleHook( void ); > > /* Call the user defined function from within the idle task. This > * allows the application designer to add background functionality > * without the overhead of a separate task. > * NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES, > * CALL A FUNCTION THAT MIGHT BLOCK. */ > vApplicationIdleHook(); > } > ``` > > 不能让空闲任务进入阻塞或者暂停状态, 建议不要占据太多的时间 > > ![image 20231116194041819](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311161940852.png) > > > 在优先级比较高的函数里面使用延时函数, 这时候就不会因为创建内存让所有的内存消耗掉 ### 任务调度算法 + 是否抢占: configUSE_PREEMPTION + + 可以: 可抢占调度, 高优先级马上执行 + 不可以, 成为合作调度模式 + + 当前任务执行的时候高优先级的任务不能马上执行, 只能等待当前的任务让出CPU + 其他优先级相同的任务也只能等待, 更高优先级的任务也不能抢占, 平级的更不可以了 + 在可以抢占的时候其他的任务是否可以执行configUSE_TIME_SLICING时间片轮转 + + 不使用的时候就会一直执行到一个任务主动放弃CPU + 时间片轮转的时候空闲任务会不会进行礼让configIDLE_SHOULD_YIELD + + 使用的时候当有与空闲任务相同优先级的任务时候, 空闲任务会主动触发调度, 礼让给其他的函数 > ```c > #if ( ( configUSE_PREEMPTION 1 ) && ( configIDLE_SHOULD_YIELD 1 ) ) > { > /* When using preemption tasks of equal priority will be > * timesliced. If a task that is sharing the idle priority is ready > * to run then the idle task should yield before the end of the > * timeslice. > * > * A critical region is not required here as we are just reading from > * the list, and an occasional incorrect value will not matter. If > * the ready list at the idle priority contains more than one task > * then a task other than the idle task is ready to execute. */ > if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 ) > { > taskYIELD(); > } > else > { > mtCOVERAGE_TEST_MARKER(); > } > } > #endif /* ( ( configUSE_PREEMPTION 1 ) && ( configIDLE_SHOULD_YIELD 1 ) ) */ > ``` ### 描述一个任务 使用面向对象的思想, 使用一个结构体描述任务 ```c /* * Task control block. A task control block (TCB) is allocated for each task, * and stores task state information, including a pointer to the task's context * (the task's run time environment, including register values) */ typedef struct tskTaskControlBlock /* The old naming convention is used to prevent breaking kernel aware debuggers. */ { volatile StackType_t * pxTopOfStack; /*< Points to the location of the last item placed on the tasks stack. THIS MUST BE THE FIRST MEMBER OF THE TCB STRUCT. */ #if ( portUSING_MPU_WRAPPERS 1 ) xMPU_SETTINGS xMPUSettings; /*< The MPU settings are defined as part of the port layer. THIS MUST BE THE SECOND MEMBER OF THE TCB STRUCT. */ #endif ListItem_t xStateListItem; /*< The list that the state list item of a task is reference from denotes the state of that task (Ready, Blocked, Suspended ). */ ListItem_t xEventListItem; /*< Used to reference a task from an event list. */ UBaseType_t uxPriority; /*< The priority of the task. 0 is the lowest priority. */ StackType_t * pxStack; /*< Points to the start of the stack. */ char pcTaskName[ configMAX_TASK_NAME_LEN ]; /*< Descriptive name given to the task when created. Facilitates debugging only. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */ #if ( ( portSTACK_GROWTH > 0 ) ( configRECORD_STACK_HIGH_ADDRESS 1 ) ) StackType_t * pxEndOfStack; /*< Points to the highest valid address for the stack. */ #endif #if ( portCRITICAL_NESTING_IN_TCB 1 ) UBaseType_t uxCriticalNesting; /*< Holds the critical section nesting depth for ports that do not maintain their own count in the port layer. */ #endif #if ( configUSE_TRACE_FACILITY 1 ) UBaseType_t uxTCBNumber; /*< Stores a number that increments each time a TCB is created. It allows debuggers to determine when a task has been deleted and then recreated. */ UBaseType_t uxTaskNumber; /*< Stores a number specifically for use by third party trace code. */ #endif #if ( configUSE_MUTEXES 1 ) UBaseType_t uxBasePriority; /*< The priority last assigned to the task used by the priority inheritance mechanism. */ UBaseType_t uxMutexesHeld; #endif #if ( configUSE_APPLICATION_TASK_TAG 1 ) TaskHookFunction_t pxTaskTag; #endif #if ( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 ) void * pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ]; #endif #if ( configGENERATE_RUN_TIME_STATS 1 ) configRUN_TIME_COUNTER_TYPE ulRunTimeCounter; /*< Stores the amount of time the task has spent in the Running state. */ #endif #if ( ( configUSE_NEWLIB_REENTRANT 1 ) ( configUSE_C_RUNTIME_TLS_SUPPORT 1 ) ) configTLS_BLOCK_TYPE xTLSBlock; /*< Memory block used as Thread Local Storage (TLS) Block for the task. */ #endif #if ( configUSE_TASK_NOTIFICATIONS 1 ) volatile uint32_t ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ]; volatile uint8_t ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ]; #endif /* See the comments in FreeRTOS.h with the definition of * tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE. */ #if ( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE ! 0 ) /*lint !e731 !e9029 Macro has been consolidated for readability reasons. */ uint8_t ucStaticallyAllocated; /*< Set to pdTRUE if the task is a statically allocated to ensure no attempt is made to free the memory. */ #endif #if ( INCLUDE_xTaskAbortDelay 1 ) uint8_t ucDelayAborted; #endif #if ( configUSE_POSIX_ERRNO 1 ) int iTaskErrno; #endif } tskTCB; ``` ### 任务的切换原理 会使用一个tick中断, 在运行的时候后创建的任务会先运行 ```c #define configTICK_RATE_HZ\t\t\t( ( TickType_t ) 1000 ) ``` > 配置切换任务的时间 + 任务的状态 1. 运行状态 2. ready状态: 等待运行 3. 阻塞状态: 等待某事发生以后运行 4. 暂停状态: 主动(被动)休息 ![image 20231116105641774](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311161056814.png) > 事件可以是中断也可以是其他函数 > > 事件有两类 > > + 时间相关的 > + + 设置超时时间, 在指定时间里面阻塞 > + 使用时间相关的函数, 可以实现周期性的功能 > + 同步事件 > + + 在任务等待某些信息, 别的任务或者中断中的任务会给他发送信息 > + 怎么发送 > + + 任务通知 > + 队列 > + 事件组 > + 信号量 > + 互斥量 + 管理 使用链表 属于某一个状态的任务会在某一个链表里面 ### 同步与互斥的概念 同步是指在多个进程或线程之间协调执行的方式。同步的目的是为了保证程序以预期的方式运行，确保多个进程或线程协同工作，避免出现竞争条件，比如一个线程在另一个线程还没有完成相关操作之前完成了操作。 互斥是一种同步机制，用于控制并发进程或线程对共享资源的访问。互斥允许一个进程或线程独占资源，其他进程或线程必须等待资源释放后才能访问。互斥锁是一种互斥机制，用于保护数据结构，控制对共享资源的并发访问，避免出现数据竞争和不一致性问题。 综上所述，同步和互斥是一种针对多进程或线程间协作的机制，同步可以保证多个进程或线程按照一定的顺序协调工作，而互斥可以保证多个进程或线程访问共享资源时不会发生冲突。 + 具体的问题 多个任务使用串口的时候打印的信息会缠在一起 **使用全局变量的时候会出现的问题** ```c if(!flog) { //如果在这里切换任务就会出问题 flog 1; 任务 flog 0; vTaskDelay(1);//保证其他的任务可以执行,否则会因为立即进入循环而循环的时间比较长导致这一个任务一直使用 } ``` > 需要实现 > > + 正确性 > + 效率: 等待的时候进入阻塞 > + 多种解决方式 + 具体的实现 1. 队列, FIFO 2. 事件组event group, 使用一个变量的不同位表示不同的事件状态, 任务等待若干个事件的状态 3. 信号量: 使用一个计数值, 对计数值加一或者减一 4. 任务通知 5. 互斥量 ## 文件 每一个版本的FreeRTOS里面都有一个protmacro.h文件, 里面有两个数据类型 + TickType_t: + + 配置了一个周期性的时钟中断Tick Interrupt + 每一次发生时钟中断, 这一个数值就增加一下tick count + 这个变量的类型就是上面的TickType_t + 可以是16位或者是32位的 + 对于32位的架构建议配置为32位 + BaseType_t + + 架构最高效的数据类型 + 32位里面就是uint32_t + 通常作为简单的函数返回值, 还有逻辑值pdTRUE/pdFALSE ### 变量名 变量使用前缀名加上一个描述符 函数名则使用返回类型, 存在的文件以及函数名, prv >私有函数 ![image 20231115215329139](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311152153179.png) ### 函数名 包括前缀, 文件名, 函数名 ![image 20231115215402882](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311152154913.png) ### 宏 宏的前缀是文件名 信号量的函数是一个宏定义, 但是是遵循函数名的命名方法, 有一个小写的前缀 ![image 20230706103041491](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311152151867.png) ![image 20231115215418497](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311152154527.png)"},"/note/嵌入式/第三方移植/freeRTOS/2023-11-22-wds05中断管理.html":{"title":"中断管理","content":" layout: post title: \"中断管理\" date: 2023 11 22 15:39:08 +0800 tags: FreeRTOS # 中断管理 中断是在内核进行的, 执行的时候用户的任务没有办法执行, 所以应该尽快执行 遇到非常耗时的中断应该把中断作为触发任务的手段, 将复杂的任务放在任务里面执行 任务只有在没有没有中断的时候才可以进行 > IRQ (Interrupt Request) 是一种中断请求，是一种通知处理器进行处理的信号。当外部设备或者内部硬件发生某种事件时，就会向处理器发送 IRQ 信号，请求处理器暂停当前任务，进行中断处理。 > > ISR (Interrupt Service Routine) 是中断服务例程，也就是中断处理程序。当处理器收到 IRQ 信号后，会执行 ISR，ISR 会完成中断处理，并将处理结果返回给处理器，处理器再继续执行原来的任务。ISR 可以是预先编写的固定代码，也可以是动态生成的代码。 在很多的是偶FreeRTOS有两套操作函数, 后缀里面有FromISR的函数不会使得任务进入阻塞 ![image 20231122141607311](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311221416351.png) ![image 20231122141755955](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311221417990.png) ![image 20231122141812626](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311221418661.png) ![image 20231122141824006](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311221418040.png) > 函数的区别: > > 是否可以阻塞, 在任务里面执行的时候有一个死循环 > > 在判断是否有在等待的任务以后会把这个任务从等待的队列里面删除, 之后判断释放出来的优先级比较高, 就在任务中会进行任务的切换, 在中断里面只是进行一次记录 > > 在队列是满的的时候在任务里面会判断当前的等待时间是不是0, 是的话返回错误, 不是的话会把任务加入到等待的队列里面, 按照优先级进行排列, 之后切换任务 > > 在中断里面的时候会直接返回一个错误 + xHigherPriorityTaskWoken参数 是否有更高优先级的任务被唤醒了。如果为pdTRUE，则意味着 后面要进行任务切换。 在正常情况下使用写队列的函数的时候会有三种情况 1. 队列满了进入阻塞 2. 队列没有满, 但是写入以后会使得一个高优先级的任务被唤醒, 优先级比较高的任务应该先运行 3. 队列没有满写入成功立即返回 可以看到，在任务中调用API函数可能导致任务阻塞、任务切换，这叫做\"context switch\"，上下文切 换。这个函数可能很长时间才返回，在函数的内部实现了任务切换。 xQueueSendToBackFromISR() 函数也可能导致任务切换，但是不会在函数内部进行切换，而是返回一 个参数：表示是否需要切换，函数原型与用法如下： ```c /* * 往队列尾部写入数据，此函数可以在中断函数中使用，不可阻塞 */ BaseType_t xQueueSendToBackFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t *pxHigherPriorityTaskWoken ); /* 用法示例 */ BaseType_t xHigherPriorityTaskWoken pdFALSE; xQueueSendToBackFromISR(xQueue, pvItemToQueue, &xHigherPriorityTaskWoken); if (xHigherPriorityTaskWoken pdTRUE) { /* 任务切换 */ } ``` > xHigherPriorityTaskWoken会保存函数的结果是否需要进行任务切换 + 不在函数里面直接切换的原因 为了效率, 因为如果多次调用这这类函数的话就会进行多次的判断然后切换 ```c void XXX_ISR() { int i; BaseType_t xHigherPriorityTaskWoken pdFALSE; for (i 0; i < N; i++) { \txQueueSendToBackFromISR(..., &xHigherPriorityTaskWoken); /* 被多次调用 */ } /* 最后再决定是否进行任务切换 */ if (xHigherPriorityTaskWoken pdTRUE) { \t/* 任务切换 */ } } ``` ![image 20231122143335865](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311221433901.png) ## 切换任务 ```c portEND_SWITCHING_ISR( xHigherPriorityTaskWoken ); 或 portYIELD_FROM_ISR( xHigherPriorityTaskWoken ); ``` > 老版本前一个使用汇编实现, 后一个使用C语言实现, 新的版本里面统一使用的后面那一个 > > 在参数里面传入在上面获得的是否需要切换的值"},"/note/嵌入式/第三方移植/freeRTOS/2024-1-21-02实际使用CubeMX封装.html":{"title":"实际使用CubeMX封装","content":" layout: post title: \"实际使用CubeMX封装\" date: 2024 1 21 15:39:08 +0800 tags: FreeRTOS # 实际使用CubeMX封装 ## 任务 ### 创建 ```c osThreadDef(defaultTask, StartDefaultTask, osPriorityNormal, 0, 128); defaultTaskHandle osThreadCreate(osThread(defaultTask), NULL); ``` > osThreadDef(名字, 任务函数, 优先级, 没用, 栈大小) > > osThreadCreate(名字(和上面一样, 任务参数))"},"/note/嵌入式/第三方移植/freeRTOS/2023-11-23-wds09内存管理.html":{"title":"内存管理","content":" layout: post title: \"内存管理\" date: 2023 11 22 15:39:08 +0800 tags: FreeRTOS # 内存管理 ## heap_1 ```c static size_txNextFreeByte ( size_t) 0; static uint8_t*pucAlignedHeap NULL; ``` > xNextFreeByte用来定位下一个空闲的内存堆位置。真正的运作过程是记录已经被分配的内存大小，在每次申请内存成功后，都会增加申请内存的字节数目 > > pucAlignedHeap是一个指向对齐后的内存堆起始地址，我们使用一个数组作为堆内存，但是数组的起始地址并不一定是对齐的内存地址，所以我们需要得到FreeRTOS管理的内存空间对齐后的起始地址，并且保存在静态变量pucAlignedHeap中 ```c void * pvPortMalloc( size_t xWantedSize ) { void * pvReturn NULL; static uint8_t * pucAlignedHeap NULL; /* Ensure that blocks are always aligned. */ #if ( portBYTE_ALIGNMENT ! 1 ) { if( xWantedSize & portBYTE_ALIGNMENT_MASK ) { /* Byte alignment required. Check for overflow. */ if( ( xWantedSize + ( portBYTE_ALIGNMENT ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ) ) > xWantedSize ) { //获取一个八字节对齐的大小 xWantedSize + ( portBYTE_ALIGNMENT ( xWantedSize & portBYTE_ALIGNMENT_MASK ) ); } else { xWantedSize 0; } } } #endif /* if ( portBYTE_ALIGNMENT ! 1 ) */ vTaskSuspendAll(); { if( pucAlignedHeap NULL ) { //第一次使用需要确定这一个的起始位置是对齐的 /* Ensure the heap starts on a correctly aligned boundary. */ pucAlignedHeap ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT 1 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); } \t\t//检测一下边界 /* Check there is enough room left for the allocation and. */ if( ( xWantedSize > 0 ) && /* valid size */ ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) && ( ( xNextFreeByte + xWantedSize ) > xNextFreeByte ) ) /* Check for overflow. */ { /* Return the next free byte then increment the index past this * block. */ pvReturn pucAlignedHeap + xNextFreeByte; xNextFreeByte + xWantedSize; } traceMALLOC( pvReturn, xWantedSize ); } ( void ) xTaskResumeAll(); return pvReturn; } ``` ```c void vPortInitialiseBlocks( void ) { /* Only required when static memory is not cleared. */ xNextFreeByte ( size_t ) 0; } ``` ```c size_t xPortGetFreeHeapSize( void ) { return( configADJUSTED_HEAP_SIZE xNextFreeByte ); } ``` ## heap_2 采用一种最佳匹配算法, 会返回一块内存大小最接近的碎片的起始地址 它不能把相邻的两个小的内存块合成一个大的内存块，对于每次申请内存大小都比较固定的，这个方式是没有问题的 对于每次申请并不是固定内存大小的则会造成内存碎片 采用链表的数据结构记录空闲内存块，将所有的空闲内存块组成一个空闲内存块链表 ```c void * pvPortMalloc( size_t xWantedSize ) { BlockLink_t * pxBlock; BlockLink_t * pxPreviousBlock; BlockLink_t * pxNewBlockLink; PRIVILEGED_DATA static BaseType_t xHeapHasBeenInitialised pdFALSE; void * pvReturn NULL; size_t xAdditionalRequiredSize; vTaskSuspendAll(); { /* 第一次进来进行初始化 */ if( xHeapHasBeenInitialised pdFALSE ) { prvHeapInit(); xHeapHasBeenInitialised pdTRUE; } if( xWantedSize > 0 ) { /* 大小对齐一下, 每一块加一个控制结构体的大小 */ xAdditionalRequiredSize heapSTRUCT_SIZE + portBYTE_ALIGNMENT ( xWantedSize & portBYTE_ALIGNMENT_MASK ); if( heapADD_WILL_OVERFLOW( xWantedSize, xAdditionalRequiredSize ) 0 ) { xWantedSize + xAdditionalRequiredSize; } else { xWantedSize 0; } } /* 检测一下有的大小够不够 */ if( heapBLOCK_SIZE_IS_VALID( xWantedSize ) ! 0 ) { if( ( xWantedSize > 0 ) && ( xWantedSize < xFreeBytesRemaining ) ) { /* 通过一个遍历找到一个大小合适的位置 */ pxPreviousBlock &xStart; pxBlock xStart.pxNextFreeBlock; while( ( pxBlock >xBlockSize < xWantedSize ) && ( pxBlock >pxNextFreeBlock ! NULL ) ) { pxPreviousBlock pxBlock; pxBlock pxBlock >pxNextFreeBlock; } /* 有合适的位子 */ if( pxBlock ! &xEnd ) { /* 记录一下可以使用的地址 */ pvReturn ( void * ) ( ( ( uint8_t * ) pxPreviousBlock >pxNextFreeBlock ) + heapSTRUCT_SIZE ); /* 把这个已经改变的地址先退出来 */ pxPreviousBlock >pxNextFreeBlock pxBlock >pxNextFreeBlock; /* 计算一下剩下的大小还可不可以用了 */ if( ( pxBlock >xBlockSize xWantedSize ) > heapMINIMUM_BLOCK_SIZE ) { /* 计算一下下一个地址的位置(xWantedSize是需求和控制结构体大小的和) */ pxNewBlockLink ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize ); /* Calculate the sizes of two blocks split from the single * block. */ pxNewBlockLink >xBlockSize pxBlock >xBlockSize xWantedSize; pxBlock >xBlockSize xWantedSize; /* Insert the new block into the list of free blocks. */ prvInsertBlockIntoFreeList( ( pxNewBlockLink ) ); } xFreeBytesRemaining pxBlock >xBlockSize; /* The block is being returned it is allocated and owned * by the application and has no \"next\" block. */ heapALLOCATE_BLOCK( pxBlock ); pxBlock >pxNextFreeBlock NULL; } } } traceMALLOC( pvReturn, xWantedSize ); } ( void ) xTaskResumeAll(); #if ( configUSE_MALLOC_FAILED_HOOK 1 ) { if( pvReturn NULL ) { vApplicationMallocFailedHook(); } } #endif return pvReturn; } ``` ```c static void prvHeapInit( void ) /* PRIVILEGED_FUNCTION */ { BlockLink_t * pxFirstFreeBlock; uint8_t * pucAlignedHeap; /* 计算一下对齐的起始位置 */ pucAlignedHeap ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) & ucHeap[ portBYTE_ALIGNMENT 1 ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /* 记录一下内存管理的起始位置 */ xStart.pxNextFreeBlock ( void * ) pucAlignedHeap; xStart.xBlockSize ( size_t ) 0; /* 记录一下结束的位置 */ xEnd.xBlockSize configADJUSTED_HEAP_SIZE; xEnd.pxNextFreeBlock NULL; /* To start with there is a single free block that is sized to take up the * entire heap space. */ pxFirstFreeBlock ( BlockLink_t * ) pucAlignedHeap; pxFirstFreeBlock >xBlockSize configADJUSTED_HEAP_SIZE; pxFirstFreeBlock >pxNextFreeBlock &xEnd; } ``` ```c #define prvInsertBlockIntoFreeList( pxBlockToInsert ) \\ { \\ BlockLink_t * pxIterator; \\ size_t xBlockSize; \\ xBlockSize pxBlockToInsert >xBlockSize; \\ /* 则一个循环的作用是找到需要插入的位置 */ \\ for( pxIterator &xStart; pxIterator >pxNextFreeBlock >xBlockSize < xBlockSize; pxIterator pxIterator >pxNextFreeBlock ) \\ { \\ /* There is nothing to do here just iterate to the correct position. */ \\ } \\ /* Update the list to include the block being inserted in the correct */ \\ /* position. */ \\ pxBlockToInsert >pxNextFreeBlock pxIterator >pxNextFreeBlock; \\ pxIterator >pxNextFreeBlock pxBlockToInsert; \t \\ } ``` ```c void vPortFree( void * pv ) { uint8_t * puc ( uint8_t * ) pv; BlockLink_t * pxLink; if( pv ! NULL ) { /* 找到对的位置 */ puc heapSTRUCT_SIZE; pxLink ( void * ) puc; \t\t//检测一下这个地址是不是合格的 if( heapBLOCK_IS_ALLOCATED( pxLink ) ! 0 ) { if( pxLink >pxNextFreeBlock NULL ) { /* 这一个控制块不是被重复返回的 */ heapFREE_BLOCK( pxLink ); vTaskSuspendAll(); { \t/* Add this block to the list of free blocks. */ prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) ); xFreeBytesRemaining + pxLink >xBlockSize; traceFREE( pv, pxLink >xBlockSize ); } ( void ) xTaskResumeAll(); } } } } ``` ```c size_t xPortGetFreeHeapSize( void ) { return xFreeBytesRemaining; } ``` ## heap_3 一个叫简单的封装 ```c void * pvPortMalloc( size_t xWantedSize ) { void * pvReturn; vTaskSuspendAll(); { pvReturn malloc( xWantedSize ); traceMALLOC( pvReturn, xWantedSize ); } ( void ) xTaskResumeAll(); return pvReturn; } void vPortFree( void * pv ) { if( pv ! NULL ) { vTaskSuspendAll(); { free( pv ); traceFREE( pv, 0 ); } ( void ) xTaskResumeAll(); } } ``` ## heap_4 空闲块链表不是以内存块大小进行排序的，而是以内存块起始地址大小排序，内存地址小的在前，地址大的在后 ```c void * pvPortMalloc( size_t xWantedSize ) { BlockLink_t * pxBlock; BlockLink_t * pxPreviousBlock; BlockLink_t * pxNewBlockLink; void * pvReturn NULL; size_t xAdditionalRequiredSize; vTaskSuspendAll(); { /* 检测一下有没有初始化 */ if( pxEnd NULL ) { prvHeapInit(); } if( xWantedSize > 0 ) { /* 记录一下对齐的请求的大小并加上一个控制块的大小 */ xAdditionalRequiredSize xHeapStructSize + portBYTE_ALIGNMENT ( xWantedSize & portBYTE_ALIGNMENT_MASK ); \t\t\t//防止溢出 if( heapADD_WILL_OVERFLOW( xWantedSize, xAdditionalRequiredSize ) 0 ) { xWantedSize + xAdditionalRequiredSize; } } else { mtCOVERAGE_TEST_MARKER(); } /* 再次检测一下大小合格*/ if( heapBLOCK_SIZE_IS_VALID( xWantedSize ) ! 0 ) { //有足够的内存 if( ( xWantedSize > 0 ) && ( xWantedSize < xFreeBytesRemaining ) ) { /* 开始遍历*/ pxPreviousBlock &xStart; pxBlock xStart.pxNextFreeBlock; while( ( pxBlock >xBlockSize < xWantedSize ) && ( pxBlock >pxNextFreeBlock ! NULL ) ) { pxPreviousBlock pxBlock; pxBlock pxBlock >pxNextFreeBlock; } /* 么找到合适的位置*/ if( pxBlock ! pxEnd ) { /* 记录一下返回的值 */ pvReturn ( void * ) ( ( ( uint8_t * ) pxPreviousBlock >pxNextFreeBlock ) + xHeapStructSize ); /* 先取出来这一个控制块 */ pxPreviousBlock >pxNextFreeBlock pxBlock >pxNextFreeBlock; /* 再看看这一个可不可以使用了 */ if( ( pxBlock >xBlockSize xWantedSize ) > heapMINIMUM_BLOCK_SIZE ) { /* 在下一个的起始位置放一个控制块 */ pxNewBlockLink ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize ); configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) 0 ); /* 记录一下信息 */ pxNewBlockLink >xBlockSize pxBlock >xBlockSize xWantedSize; pxBlock >xBlockSize xWantedSize; /* 放进链表 */ prvInsertBlockIntoFreeList( pxNewBlockLink ); } else { mtCOVERAGE_TEST_MARKER(); } \t\t\t\t//记录一下数据 xFreeBytesRemaining pxBlock >xBlockSize; if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining ) { xMinimumEverFreeBytesRemaining xFreeBytesRemaining; } /* 这一个不在链表里面了, 设置一下标志位 */ heapALLOCATE_BLOCK( pxBlock ); pxBlock >pxNextFreeBlock NULL; xNumberOfSuccessfulAllocations++; } } } traceMALLOC( pvReturn, xWantedSize ); } ( void ) xTaskResumeAll(); \tconfigASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) 0 ); return pvReturn; } ``` ```c static void prvHeapInit( void ) /* PRIVILEGED_FUNCTION */ { BlockLink_t * pxFirstFreeBlock; uint8_t * pucAlignedHeap; portPOINTER_SIZE_TYPE uxAddress; size_t xTotalHeapSize configTOTAL_HEAP_SIZE; /* 记录一下可以使用的地址对齐的位置 */ uxAddress ( portPOINTER_SIZE_TYPE ) ucHeap; if( ( uxAddress & portBYTE_ALIGNMENT_MASK ) ! 0 ) { uxAddress + ( portBYTE_ALIGNMENT 1 ); uxAddress & ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ); xTotalHeapSize uxAddress ( portPOINTER_SIZE_TYPE ) ucHeap; } pucAlignedHeap ( uint8_t * ) uxAddress; /* 在链表的起始记录一下可以使用的地址 */ xStart.pxNextFreeBlock ( void * ) pucAlignedHeap; xStart.xBlockSize ( size_t ) 0; /* 计算一下可以使用的地址的结尾 */ uxAddress ( ( portPOINTER_SIZE_TYPE ) pucAlignedHeap ) + xTotalHeapSize; uxAddress xHeapStructSize; uxAddress & ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ); pxEnd ( BlockLink_t * ) uxAddress; pxEnd >xBlockSize 0; pxEnd >pxNextFreeBlock NULL; /* 初始化一个可以使用的列表项, 记录整个数组 */ pxFirstFreeBlock ( BlockLink_t * ) pucAlignedHeap; pxFirstFreeBlock >xBlockSize ( size_t ) ( uxAddress ( portPOINTER_SIZE_TYPE ) pxFirstFreeBlock ); pxFirstFreeBlock >pxNextFreeBlock pxEnd; /* 记录一下最小的内存的大小以及可以使用的大小 */ xMinimumEverFreeBytesRemaining pxFirstFreeBlock >xBlockSize; xFreeBytesRemaining pxFirstFreeBlock >xBlockSize; } ``` ```c static void prvInsertBlockIntoFreeList( BlockLink_t * pxBlockToInsert ) /* PRIVILEGED_FUNCTION */ { BlockLink_t * pxIterator; uint8_t * puc; /* 按照地址进行插入, 记录一下插入位置的内存前面的哪一块的指针 */ for( pxIterator &xStart; pxIterator >pxNextFreeBlock < pxBlockToInsert; pxIterator pxIterator >pxNextFreeBlock ) { /* Nothing to do here, just iterate to the right position. */ } /* Do the block being inserted, and the block it is being inserted after * make a contiguous block of memory? */ puc ( uint8_t * ) pxIterator; \t//看看可不可以和前面的进行合并 if( ( puc + pxIterator >xBlockSize ) ( uint8_t * ) pxBlockToInsert ) { //可以合并的话, 直接记录这一块前面的那一块的地址 pxIterator >xBlockSize + pxBlockToInsert >xBlockSize; pxBlockToInsert pxIterator; } /* Do the block being inserted, and the block it is being inserted before * make a contiguous block of memory? */ puc ( uint8_t * ) pxBlockToInsert; if( ( puc + pxBlockToInsert >xBlockSize ) ( uint8_t * ) pxIterator >pxNextFreeBlock ) { //可以和后面的那一块的内存进行合并 if( pxIterator >pxNextFreeBlock ! pxEnd ) { /* 把这一块的大小扩大以及连接后面的那一块 */ pxBlockToInsert >xBlockSize + pxIterator >pxNextFreeBlock >xBlockSize; pxBlockToInsert >pxNextFreeBlock pxIterator >pxNextFreeBlock >pxNextFreeBlock; } else { pxBlockToInsert >pxNextFreeBlock pxEnd; } } else { //链接后面的一块 pxBlockToInsert >pxNextFreeBlock pxIterator >pxNextFreeBlock; } /* 前面一块没有连接 */ if( pxIterator ! pxBlockToInsert ) { pxIterator >pxNextFreeBlock pxBlockToInsert; } else { mtCOVERAGE_TEST_MARKER(); } } ``` ```c void vPortFree( void * pv ) { uint8_t * puc ( uint8_t * ) pv; BlockLink_t * pxLink; if( pv ! NULL ) { /* 获取控制块的位置 */ puc xHeapStructSize; /* This casting is to keep the compiler from issuing warnings. */ pxLink ( void * ) puc; if( heapBLOCK_IS_ALLOCATED( pxLink ) ! 0 ) { if( pxLink >pxNextFreeBlock NULL ) { /* 检测值一个是不是有效的一块内存 */ heapFREE_BLOCK( pxLink ); vTaskSuspendAll(); { /* 添加这一块到对的位置 */ xFreeBytesRemaining + pxLink >xBlockSize; prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) ); xNumberOfSuccessfulFrees++; } ( void ) xTaskResumeAll(); } } } } ``` ```c void vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions ) { BlockLink_t * pxFirstFreeBlockInRegion NULL; BlockLink_t * pxPreviousFreeBlock; portPOINTER_SIZE_TYPE xAlignedHeap; size_t xTotalRegionSize, xTotalHeapSize 0; BaseType_t xDefinedRegions 0; portPOINTER_SIZE_TYPE xAddress; const HeapRegion_t * pxHeapRegion; pxHeapRegion &( pxHeapRegions[ xDefinedRegions ] ); \t//这里面还有新的数据 while( pxHeapRegion >xSizeInBytes > 0 ) { xTotalRegionSize pxHeapRegion >xSizeInBytes; /* 计算一下这一个地址可以使用的对齐的位置 */ xAddress ( portPOINTER_SIZE_TYPE ) pxHeapRegion >pucStartAddress; if( ( xAddress & portBYTE_ALIGNMENT_MASK ) ! 0 ) { xAddress + ( portBYTE_ALIGNMENT 1 ); xAddress & ~portBYTE_ALIGNMENT_MASK; /* 调整一下大小 */ xTotalRegionSize ( size_t ) ( xAddress ( portPOINTER_SIZE_TYPE ) pxHeapRegion >pucStartAddress ); } xAlignedHeap xAddress; if( xDefinedRegions 0 ) { /* 这是第一块 */ xStart.pxNextFreeBlock ( BlockLink_t * ) xAlignedHeap; xStart.xBlockSize ( size_t ) 0; } /* Remember the location of the end marker in the previous region, if * any. */ pxPreviousFreeBlock pxEnd; /* pxEnd is used to mark the end of the list of free blocks and is * inserted at the end of the region space. */ xAddress xAlignedHeap + xTotalRegionSize; xAddress xHeapStructSize; xAddress & ~( ( size_t ) portBYTE_ALIGNMENT_MASK ); pxEnd ( BlockLink_t * ) xAddress; pxEnd >xBlockSize 0; pxEnd >pxNextFreeBlock NULL; /* To start with there is a single free block in this region that is * sized to take up the entire heap region minus the space taken by the * free block structure. */ pxFirstFreeBlockInRegion ( BlockLink_t * ) xAlignedHeap; pxFirstFreeBlockInRegion >xBlockSize ( size_t ) ( xAddress ( portPOINTER_SIZE_TYPE ) pxFirstFreeBlockInRegion ); pxFirstFreeBlockInRegion >pxNextFreeBlock pxEnd; /* If this is not the first region that makes up the entire heap space * then link the previous region to this region. */ if( pxPreviousFreeBlock ! NULL ) { pxPreviousFreeBlock >pxNextFreeBlock pxFirstFreeBlockInRegion; } xTotalHeapSize + pxFirstFreeBlockInRegion >xBlockSize; /* Move onto the next HeapRegion_t structure. */ xDefinedRegions++; pxHeapRegion &( pxHeapRegions[ xDefinedRegions ] ); } xMinimumEverFreeBytesRemaining xTotalHeapSize; xFreeBytesRemaining xTotalHeapSize; /* Check something was actually defined before it is accessed. */ configASSERT( xTotalHeapSize ); } ```"},"/note/嵌入式/第三方移植/freeRTOS/2023-7-19-fire11FreeRTOS启动任务管理.html":{"title":"启动以及任务管理","content":" layout: post title: \"启动以及任务管理\" date: 2023 7 19 15:39:08 +0800 tags: FreeRTOS # 启动以及任务管理 ## 万事俱备,只欠东风 main函数中初始化硬件, 之后创建任务, 然后启动调度器 所有的任务都是一个阻塞 ## 小心翼翼 初始化硬件之后, 创建一个启动函数, 之后启动调度器, 启动任务中创建其他任务, 最后把自己删除 ## 初始化 创建任务之后, 通过pvPortMalloc >prvHeapInit初始化堆栈 之后的启动流程在之前自己实现过"},"/note/嵌入式/第三方移植/freeRTOS/2023-11-19-wds03任务通知.html":{"title":"任务通知","content":" layout: post title: \"任务通知\" date: 2023 11 19 15:39:08 +0800 tags: FreeRTOS # 任务通知 使用之前的彼变量的时候我们并不知道对方是谁, 使用任务通知的时候可以明确指定, 通知哪一个任务 使用任务东芝的时候不需要单独创建一个结构体, TCB里面包含有这一个对象 ![image 20231119202528802](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311192025838.png) ![image 20231119202546285](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311192025335.png) ```c #if ( configUSE_TASK_NOTIFICATIONS 1 ) volatile uint32_t ulNotifiedValue[ configTASK_NOTIFICATION_ARRAY_ENTRIES ]; volatile uint8_t ucNotifyState[ configTASK_NOTIFICATION_ARRAY_ENTRIES ];//通知的状态 #endif ``` > TCB里面使用这两个值进行信息的传递 > > ```c > #define configTASK_NOTIFICATION_ARRAY_ENTRIES 1 > ``` > > 其他任务向里面放入数据的时候不会进入阻塞, 只有成功和失败, 但是读取的时候可以进入等待 状态有三种 + taskNOT_WAITING_NOTIFICATION：任务没有在等 + taskWAITING_NOTIFICATION：任务在等待通知 + taskNOTIFICATION_RECEIVED：任务接收到了通知，也被称为pending(有数据了，待处理) ```c #define taskNOT_WAITING_NOTIFICATION ( ( uint8_t ) 0 ) /* 也是初始 状态 */ #define taskWAITING_NOTIFICATION ( ( uint8_t ) 1 ) #define taskNOTIFICATION_RECEIVED ( ( uint8_t ) 2 ) ``` > 在写入数据的时候会顺带更改状态的值 ## 函数 ![image 20231119203447988](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311192034017.png) + 发送数据和接收 ```c BaseType_t xTaskNotifyGive( TaskHandle_t xTaskToNotify ); void vTaskNotifyGiveFromISR( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken ); uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait ); ``` > 使用give会使得任务的通知值加一, 状态变为taskNOTIFICATION_RECEIVED > > 接收的时候通知值为0则阻塞, 通知大于零时候接收, 设置第一个参数为pdTRUE返回之前会清理把通知值清零, 设置为为pdFALSE的时候会把它减一, 返回的是值没有变化之前的通知值 > **总结: **相当于一个轻量级信号量 + 高级函数 ```c BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction ); BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken ); ``` > Notify的参数1是要通知的任务, 参数二是设置的值, 参数三设置怎么使用 > > ![image 20231119204527429](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311192045459.png) ![image 20231119204605510](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311192046544.png) ![image 20231119204620528](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311192046552.png) ```c BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait ); ``` ![image 20231119205104287](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311192051351.png) # FreeRTOS实现 ```c typedef struct tskTaskControlBlock { \t... \t#if( configUSE_TASK_NOTIFICATIONS 1 ) \t\tvolatile uint32_t ulNotifiedValue;\t//记录任务通知的值 \t\tvolatile uint8_t ucNotifyState;\t\t//记录任务是不是在等待任务通知 \t#endif \t... } tskTCB; ``` ```c BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue ) { TCB_t * pxTCB; BaseType_t xReturn pdPASS; uint8_t ucOriginalNotifyState; configASSERT( xTaskToNotify ); pxTCB ( TCB_t * ) xTaskToNotify; taskENTER_CRITICAL(); { //记录一下之前的值 if( pulPreviousNotificationValue ! NULL ) { *pulPreviousNotificationValue pxTCB >ulNotifiedValue; } //获取当前的状态 ucOriginalNotifyState pxTCB >ucNotifyState; pxTCB >ucNotifyState taskNOTIFICATION_RECEIVED; //判断需要的操作 switch( eAction ) { case eSetBits\t: pxTCB >ulNotifiedValue ulValue; break; case eIncrement\t: ( pxTCB >ulNotifiedValue )++; break; case eSetValueWithOverwrite\t: pxTCB >ulNotifiedValue ulValue; break; case eSetValueWithoutOverwrite : if( ucOriginalNotifyState ! taskNOTIFICATION_RECEIVED ) { pxTCB >ulNotifiedValue ulValue; } else { /* The value could not be written to the task. */ xReturn pdFAIL; } break; case eNoAction: /* The task is being notified without its notify value being \t\t\t\t\tupdated. */ break; } /* 检查一下是不是在等待一个通知 */ if( ucOriginalNotifyState taskWAITING_NOTIFICATION ) { ( void ) uxListRemove( &( pxTCB >xStateListItem ) ); prvAddTaskToReadyList( pxTCB ); if( pxTCB >uxPriority > pxCurrentTCB >uxPriority ) { /* The notified task has a priority above the currently \t\t\t\t\texecuting task so a yield is required. */ taskYIELD_IF_USING_PREEMPTION(); } else { mtCOVERAGE_TEST_MARKER(); } } else { mtCOVERAGE_TEST_MARKER(); } } taskEXIT_CRITICAL(); return xReturn; } ``` >"},"/note/嵌入式/stc32/2023-9-17-01.html":{"title":"时钟","content":"# 时钟 ![image 20230917180559127](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242305666.png)"},"/note/嵌入式/ROS/ROS2/2026-1-24-25-slam_toolbox.html":{"title":"slam_toolbox","content":"# slam_toolbox 这是一个二维的, 开箱即用的一个建模工具 ```bash sudo apt get install ros $ROS_DISTRO slam toolbox ros2 launch slam_toolbox online_async_launch.py use_sim_time: True ``` ![image 20260124142219219](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601241422388.png) ![image 20260124143450100](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601241434298.png) ![image 20260124143609516](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601241436630.png) ## 地图保存 ```bash sudo apt get install ros $ROS_DISTRO nav2 map server ros2 run nav2_map_server map_saver_cli f room ``` ![image 20260124145705565](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601241457650.png)"},"/note/嵌入式/ROS/ROS2/2026-1-27-40-消息过滤器同步数据.html":{"title":"消息过滤器同步","content":"# 消息过滤器同步 `message_filters`是 ROS 提供的一套**消息处理工具集**，它封装了普通的话题订阅逻辑，解决了单纯`create_subscription`无法高效处理的场景 —— 比如 “同步多个话题的消息”“按条件过滤消息”“缓存消息供后续回溯” 等。普通订阅器是 “来一个消息处理一个”，而`message_filters`能让你对消息做 “筛选、排序、同步、缓存” 等精细化操作，是 ROS 开发中处理多传感器数据的核心工具。 + Subscriber: 订阅者, 消息过滤器中的订阅者是基于ROS2里面的订阅者封装而来, 主要是配合时间同步器使用, 使用的时候可以为他注册单独的回调函数, 收到订阅消息的时候使用回调函数 + Sync Policies: 同步策略, ROS2 里面提供多个同步策略的实现, 有严格的时间对齐, 大约时间对齐, 最新时间对齐 + Synchronizer: 时间同步器, 我们把同步策略以及订阅者传递给时间同步器, 由他实现时间同步, 调用相关回调函数传递同步结果 严格时间同步: 只有当`Imu`消息和`Odometry`消息的`header.stamp`（时间戳）**精确到纳秒完全一致**时，才会触发同步回调。哪怕两个消息的时间戳差 1 纳秒，也会被判定为 “不同步”，消息会被缓存 / 丢弃，回调不触发。 近似时间同步: 不要求时间戳完全一致，只要`Imu`和`Odometry`消息的时间戳差值在你设定的`slop`（时间容忍度，单位：秒）范围内，就认为是 “同步的”，触发回调。 最新时间同步: 只要任意一个话题（比如 IMU）有新消息到达，就立刻取该话题的 “最新消息” + 其他话题（比如 Odometry）缓存中 “最新的消息”，组合起来触发一次回调。 ## 实现 ### python ```python import rclpy from rclpy.node import Node from sensor_msgs.msg import Imu from nav_msgs.msg import Odometry from message_filters import Subscriber, ApproximateTimeSynchronizer class TimeSyncTestNode(Node): def __init__(self): super().__init__('sync_node') # 1. 订阅 imu 话题并注册回调并打印时间戳 self.imu_sub Subscriber(self, Imu, 'imu') self.imu_sub.registerCallback(self.imu_callback) # 2. 订阅 odom 话题并注册回调函数打印时间戳 self.odom_sub Subscriber(self, Odometry, 'odom') self.odom_sub.registerCallback(self.odom_callback) # 3. 创建对应策略的同步器同步两个话题，并注册回调函数打印数据 # 两个消息的时间戳小于0.01s的时候, 使用回调函数 self.synchronizer ApproximateTimeSynchronizer( [self.imu_sub, self.odom_sub], 10, slop 0.01, # slop 表示时间窗口单位为秒 ) self.synchronizer.registerCallback(self.result_callback) def imu_callback(self, imu_msg): self.get_logger().info( f'imu({imu_msg.header.stamp.sec},{imu_msg.header.stamp.nanosec})') def odom_callback(self, odom_msg): self.get_logger().info( f'odom({odom_msg.header.stamp.sec},{odom_msg.header.stamp.nanosec})') def result_callback(self, imu_msg, odom_msg): self.get_logger().info( f'imu({imu_msg.header.stamp.sec},{imu_msg.header.stamp.nanosec}),odom({odom_msg.header.stamp.sec},{odom_msg.header.stamp.nanosec})') def main(args None): rclpy.init(args args) node TimeSyncTestNode() rclpy.spin(node) rclpy.shutdown() ``` ### cpp ```cpp #include \"message_filters/subscriber.h\" #include \"message_filters/sync_policies/approximate_time.h\" #include \"message_filters/sync_policies/exact_time.h\" #include \"message_filters/sync_policies/latest_time.h\" #include \"message_filters/time_synchronizer.h\" #include \"nav_msgs/msg/odometry.hpp\" #include \"rclcpp/rclcpp.hpp\" #include \"sensor_msgs/msg/imu.hpp\" using Imu sensor_msgs::msg::Imu; using Odometry nav_msgs::msg::Odometry; using namespace message_filters; // 同步策略：严格时间对齐策略 // using MySyncPolicy sync_policies::ExactTime<Imu, Odometry>; // 同步策略：大约时间对齐策略 // using MySyncPolicy sync_policies::ApproximateTime<Imu, Odometry>; // 同步策略：最新时间对齐策略 using MySyncPolicy sync_policies::LatestTime<Imu, Odometry>; class TimeSyncTestNode : public rclcpp::Node { public: TimeSyncTestNode() : Node(\"sync_node\") { // 1.订阅 imu 话题并注册回调并打印时间戳 imu_sub_ std::make_shared<Subscriber<Imu>>(this, \"imu\"); imu_sub_ >registerCallback<Imu::SharedPtr>( [&](const Imu::SharedPtr &imu_msg) { RCLCPP_INFO(get_logger(), \"imu(%u,%u)\", imu_msg >header.stamp.sec, imu_msg >header.stamp.nanosec); }); // 2.订阅 odom 话题并注册回调函数打印时间戳 odom_sub_ std::make_shared<Subscriber<Odometry>>(this, \"odom\"); odom_sub_ >registerCallback<Odometry::SharedPtr>( [&](const Odometry::SharedPtr &odom_msg) { RCLCPP_INFO(get_logger(), \"odom(%u,%u)\", odom_msg >header.stamp.sec, odom_msg >header.stamp.nanosec); }); // 3.创建对应策略的同步器同步两个话题，并注册回调函数打印数据 // synchronizer_ std::make_shared<Synchronizer<MySyncPolicy>>( // MySyncPolicy(10), *imu_sub_, *odom_sub_); // 3.创建对应策略的同步器同步两个话题，并注册回调函数打印数据 synchronizer_ std::make_shared<Synchronizer<MySyncPolicy>>( MySyncPolicy(), *imu_sub_, *odom_sub_); synchronizer_ >registerCallback( std::bind(&TimeSyncTestNode::result_callback, this, std::placeholders::_1, std::placeholders::_2)); } private: void result_callback(const Imu::ConstSharedPtr imu_msg, const Odometry::ConstSharedPtr odom_msg) { RCLCPP_INFO(get_logger(), \"imu(%u,%u),odom(%u,%u))\", imu_msg >header.stamp.sec, imu_msg >header.stamp.nanosec, odom_msg >header.stamp.sec, odom_msg >header.stamp.nanosec); } std::shared_ptr<Subscriber<Imu>> imu_sub_; std::shared_ptr<Subscriber<Odometry>> odom_sub_; std::shared_ptr<Synchronizer<MySyncPolicy>> synchronizer_; }; int main(int argc, char **argv) { rclcpp::init(argc, argv); auto node std::make_shared<TimeSyncTestNode>(); rclcpp::spin(node); rclcpp::shutdown(); return 0; } ```"},"/note/嵌入式/ROS/ROS2/2026-1-16-11-DDS通信QoS.html":{"title":"DDS机器人神经网络","content":"# DDS机器人神经网络 话题、服务、动作，他们底层通信的具体实现过程，都是靠DDS来完成的，它相当于是**ROS机器人系统中的神经网络** DDS的核心是通信，能够实现通信的模型和软件框架非常多，这里我们列出常用的四种模型 ![image 20260116160042569](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601161600695.png) 第一种，**点对点模型**，许多客户端连接到一个服务端，每次通信时，通信双方必须建立一条连接。当通信节点增多时，连接数也会增多。而且每个客户端都需要知道服务器的具体地址和所提供的服务，一旦服务器地址发生变化，所有客户端都会受到影响。 第二种，**Broker模型**，针对点对点模型进行了优化，由Broker集中处理所有人的请求，并进一步找到真正能响应该服务的角色。这样客户端就不用关心服务器的具体地址了。不过问题也很明显，Broker作为核心，它的处理速度会影响所有节点的效率，当系统规模增长到一定程度，Broker就会成为整个系统的性能瓶颈。更麻烦是，如果Broker发生异常，可能导致整个系统都无法正常运转。之前的ROS1系统，使用的就是类似这样的架构。 第三种，**广播模型**，所有节点都可以在通道上广播消息，并且节点都可以收到消息。这个模型解决了服务器地址的问题，而且通信双方也不用单独建立连接，但是广播通道上的消息太多了，所有节点都必须关心每条消息，其实很多是和自己没有关系的。 第四种，就是**以数据为中心的DDS模型**了，这种模型与广播模型有些类似，所有节点都可以在DataBus上发布和订阅消息。但它的先进之处在于，通信中包含了很多并行的通路，每个节点可以只关心自己感兴趣的消息，忽略不感兴趣的消息，有点像是一个旋转火锅，各种好吃的都在这个DataBus传送，我们只需要拿自己想吃的就行，其他的和我们没有关系。 DDS的全称是**Data Distribution Service**，也就是**数据分发服务**，2004年由**对象管理组织OMG**发布和维护，是一套专门为**实时系统**设计的**数据分发/订阅标准**, 强调**以数据为中心**，可以提供丰富的**服务质量策略**，以保障数据进行实时、高效、灵活地分发，可满足各种分布式实时通信应用需求。 > DDS在ROS2系统中的位置至关重要，所有上层建设都建立在DDS之上。在这个ROS2的架构图中，蓝色和红色部分就是DDS > > ![image 20260116160436332](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601161604381.png) > > DDS是一种通信的标准，就像4G、5G一样，既然是标准，那大家都可以按照这个标准来实现对应的功能，所以华为、高通都有很多5G的技术专利，DDS也是一样，**能够按照DDS标准实现的通信系统很多**，这里每一个红色模块，就是某一企业或组织实现的一种DDS系统 ![image 20260116160541078](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601161605135.png) DDS中另外一个重要特性就是**质量服务策略，QoS**。 QoS是一种网络传输策略，应用程序指定所需要的网络传输质量行为，QoS服务实现这种行为要求，尽可能地满足客户对通信质量的需求，可以理解为**数据提供者和接收者之间的合约**。 ![image 20260116160631302](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601161606370.png) **DEADLINE**策略，表示通信数据必须要在每次截止时间内完成一次通信, 否则可能丢弃 **HISTORY**策略，表示针对历史数据的一个缓存大小；`Keep last`, `Depth`, `Keep all` **RELIABILITY**策略，表示数据通信的模式，配置成`BEST_EFFORT`，就是尽力传输模式，网络情况不好的时候，也要保证数据流畅，此时可能会导致数据丢失，配置成`RELIABLE`，就是可信赖模式，可以在通信中尽量保证图像的完整性，我们可以根据应用功能场景选择合适的通信模式； **DURABILITY**策略，可以配置针对晚加入的节点，也保证有一定的历史数据发送过去，可以让新节点快速适应系统。`Transient local`为后面加入的节点保留信息, `Volatile`易失性, 不保留 **LIFESPAN**: 消息可以存在的时间长度 **LIVELINESS**: 活跃, 一个话题是不是活跃是rmw自动检测报告的, 每次报告在下一个持续时间以内都视为活跃, 也可以发布的时候手动的声明, 如果发布者无法按照约定的规则发出“我还活着”的信号，ROS 2会认为它“死亡”，并自动通知其所有订阅者，从而触发相应的故障处理逻辑 租约持续时间: 活跃的持续时间 > 可以使用false绕过ROS特定的命名规定, 和一个使用相同的DDS通信的时候才会使用 <img src \"https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601271329188.png\" alt \"image 20260127132907117\" style \"zoom:150%;\" /> ![image 20260127133043160](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601271330216.png) ## 命令行控制 ```bash # 尽力传输数据, 数据可能丢失 $ ros2 topic pub /chatter std_msgs/msg/Int32 \"data: 42\" qos reliability best_effort # 订阅消息, 使用另一个模式, 如果不一样会报错 $ ros2 topic echo /chatter qos reliability reliable $ ros2 topic echo /chatter qos reliability best_effort # 查看一个话题的具体信息 $ ros2 topic info /chatter verbose ``` ## 代码控制 ### 发布者 ```python import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from std_msgs.msg import String # 字符串消息类型 from rclpy.qos import QoSProfile, QoSReliabilityPolicy, QoSHistoryPolicy # ROS2 QoS类 \"\"\" 创建一个发布者节点 \"\"\" class PublisherNode(Node): def __init__(self, name): super().__init__(name) # 创建一个QoS原则 qos_profile QoSProfile( # reliability QoSReliabilityPolicy.BEST_EFFORT, reliability QoSReliabilityPolicy.RELIABLE, history QoSHistoryPolicy.KEEP_LAST, depth 1 ) # 创建发布者对象（消息类型、话题名、QoS原则） self.pub self.create_publisher(String, \"chatter\", qos_profile) self.timer self.create_timer(0.5, self.timer_callback) def timer_callback(self): msg String() msg.data 'Hello World' self.pub.publish(msg) self.get_logger().info('Publishing: \"%s\"' % msg.data) def main(args None): rclpy.init(args args) node PublisherNode(\"qos_helloworld_pub\") rclpy.spin(node) node.destroy_node( rclpy.shutdown() # 关闭ROS2 Python接口 ``` ### 接收者 ```python import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from std_msgs.msg import String # ROS2标准定义的String消息 from rclpy.qos import QoSProfile, QoSReliabilityPolicy, QoSHistoryPolicy \"\"\" 创建一个订阅者节点 \"\"\" class SubscriberNode(Node): def __init__(self, name): super().__init__(name) # 创建一个QoS原则 qos_profile QoSProfile( # reliability QoSReliabilityPolicy.BEST_EFFORT, reliability QoSReliabilityPolicy.RELIABLE, history QoSHistoryPolicy.KEEP_LAST, depth 1 ) # 创建订阅者对象（消息类型、话题名、订阅者回调函数、QoS原则） self.sub self.create_subscription(\\ String, \"chatter\", self.listener_callback, qos_profile) def listener_callback(self, msg): self.get_logger().info('I heard: \"%s\"' % msg.data) def main(args None): rclpy.init(args args) node SubscriberNode(\"qos_helloworld_sub\") rclpy.spin(node) node.destroy_node() rclpy.shutdown() ```"},"/note/嵌入式/ROS/ROS2/2026-1-15-09-参数.html":{"title":"参数","content":"# 参数 在ROS系统中，参数是以**全局字典**的形态存在的, 参数的特性非常丰富，比如某一个节点共享了一个参数，其他节点都可以访问，如果某一个节点对参数进行了修改，其他节点也有办法立刻知道，从而获取最新的数值。 参数是基于服务通信实现的, 但是直接使用服务的形式进行控制比较复杂 ```bash (base) jiao@jiao virtual machine:~$ ros2 service list t grep parameter /turtlesim/describe_parameters [rcl_interfaces/srv/DescribeParameters] /turtlesim/get_parameter_types [rcl_interfaces/srv/GetParameterTypes] /turtlesim/get_parameters [rcl_interfaces/srv/GetParameters] /turtlesim/list_parameters [rcl_interfaces/srv/ListParameters] /turtlesim/set_parameters [rcl_interfaces/srv/SetParameters] /turtlesim/set_parameters_atomically [rcl_interfaces/srv/SetParametersAtomically] ``` ### 命令行 ```bash (base) jiao@jiao virtual machine:~/ros$ ros2 param list /turtlesim: background_b background_g background_r qos_overrides./parameter_events.publisher.depth qos_overrides./parameter_events.publisher.durability qos_overrides./parameter_events.publisher.history qos_overrides./parameter_events.publisher.reliability use_sim_time (base) jiao@jiao virtual machine:~/ros$ ros2 param describe /turtlesim background_b Parameter name: background_b Type: integer Description: Blue channel of the background color Constraints: Min value: 0 Max value: 255 Step: 1 (base) jiao@jiao virtual machine:~/ros$ ros2 param get turtlesim background_b Integer value is: 255 (base) jiao@jiao virtual machine:~/ros$ ros2 param set turtlesim background_b 200 Set parameter successful (base) jiao@jiao virtual machine:~/ros$ ros2 param dump /turtlesim /turtlesim: ros__parameters: background_b: 200 background_g: 86 background_r: 69 qos_overrides: /parameter_events: publisher: depth: 1000 durability: volatile history: keep_last reliability: reliable use_sim_time: false (base) jiao@jiao virtual machine:~/ros$ ros2 param dump /turtlesim >> turtlesim.yaml (base) jiao@jiao virtual machine:~/ros$ ros2 param load /turtlesim turtlesim.yaml # 使用配置文件 (base) jiao@jiao virtual machine:~/ros$ ros2 run turtlesim turtlesim_node ros args params file turtlesim.yaml # 直接输入 (base) jiao@jiao virtual machine:~/ros$ ros2 run turtlesim turtlesim_node ros args p model: cnn ``` ## 代码 ### 参数设置 ```python import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 class ParameterNode(Node): def __init__(self, name): super().__init__(name) self.timer self.create_timer(2, self.timer_callback) # 创建一个参数，并设置参数的默认值 self.declare_parameter('robot_name', 'mbot') def timer_callback(self): # 从ROS2系统中读取参数的值 robot_name_param self.get_parameter('robot_name').get_parameter_value().string_value # 输出日志信息，打印读取到的参数值 self.get_logger().info('Hello %s!' % robot_name_param) # 重新将参数值设置为指定值 new_name_param rclpy.parameter.Parameter('robot_name', rclpy.Parameter.Type.STRING, 'mbot') all_new_parameters [new_name_param] # 将重新创建的参数列表发送给ROS2系统 self.set_parameters(all_new_parameters) def main(args None): rclpy.init(args args) node ParameterNode(\"param_declare\") rclpy.spin(node) node.destroy_node() rclpy.shutdown() ``` ```python import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from sensor_msgs.msg import Image # 图像消息类型 from cv_bridge import CvBridge # ROS与OpenCV图像转换类 import cv2 # Opencv图像处理库 import numpy as np # Python数值计算库 lower_red np.array([0, 90, 128]) # 红色的HSV阈值下限 upper_red np.array([180, 255, 255]) # 红色的HSV阈值上限 \"\"\" 创建一个订阅者节点 \"\"\" class ImageSubscriber(Node): def __init__(self, name): super().__init__(name) self.sub self.create_subscription(Image, 'image_raw', self.listener_callback, 10) # 创建一个图像转换对象，用于OpenCV图像与ROS的图像消息的互相转换 self.cv_bridge CvBridge() # 创建一个参数，表示阈值上限 self.declare_parameter('red_h_upper', 0) # 创建一个参数，表示阈值下限 self.declare_parameter('red_h_lower', 0) def object_detect(self, image): # 读取阈值上限的参数值 upper_red[0] self.get_parameter('red_h_upper').get_parameter_value().integer_value # 读取阈值下限的参数值 lower_red[0] self.get_parameter('red_h_lower').get_parameter_value().integer_value # 通过日志打印读取到的参数值 self.get_logger().info('Get Red H Upper: %d, Lower: %d' % (upper_red[0], lower_red[0])) # 图像从BGR颜色模型转换为HSV模型 hsv_img cv2.cvtColor(image, cv2.COLOR_BGR2HSV) # 图像二值化 mask_red cv2.inRange(hsv_img, lower_red, upper_red) # 图像中轮廓检测 contours, hierarchy cv2.findContours(mask_red, cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE) for cnt in contours:# 去除一些轮廓面积太小的噪声 if cnt.shape[0] < 150: continue # 得到苹果所在轮廓的左上角xy像素坐标及轮廓范围的宽和高 (x, y, w, h) cv2.boundingRect(cnt) # 将苹果的轮廓勾勒出来 cv2.drawContours(image, [cnt], 1, (0, 255, 0), 2) # 将苹果的图像中心点画出来 cv2.circle(image, (int(x+w/2), int(y+h/2)), 5, (0, 255, 0), 1) # 使用OpenCV显示处理后的图像效果 cv2.imshow(\"object\", image) cv2.waitKey(50) def listener_callback(self, data): self.get_logger().info('Receiving video frame') image self.cv_bridge.imgmsg_to_cv2(data, \"bgr8\") self.object_detect(image) def main(args None): rclpy.init(args args) node ImageSubscriber(\"param_object_detect\") rclpy.spin(node) node.destroy_node() rclpy.shutdown() ``` 可以使用回调函数检测参数变化 ```python self.add_on_set_parameters_callback(call_back) def call_back(paragrams): for paragram in paragrams: paragram.name paragram.value \treturn SetParametersResult(successful True) ``` ### 跨节点设置参数 ```python import rclpy from rclpy.node import Node from rcl_interfaces.srv import SetParameters, GetParameters from rcl_interfaces.msg import Parameter, ParameterType, ParameterValue class CrossParamNode(Node): def __init__(self): super().__init__(\"cross_param_node\") # 1. 创建参数客户端，指定目标节点名（即要修改参数的节点） self.param_client self.create_client(SetParameters, \"/turtlesim/set_parameters\") while not self.param_client.wait_for_service(timeout_sec 1.0): self.get_logger().info(\"/turtlesim/set_parameters服务未就绪，正在等待...\") self.get_logger().info(\"/turtlesim/set_parameters服务已连接\") # 2. 准备要设置的目标节点参数 request SetParameters.Request() target_param Parameter() target_param.name \"background_b\" param_value ParameterValue() param_value.type ParameterType.PARAMETER_INTEGER param_value.integer_value 200 # 设置蓝色背景值为200 target_param.value param_value request.parameters [target_param] # 3. 异步设置其他节点的参数 future self.param_client.call_async(request) rclpy.spin_until_future_complete(self, future) # 4. 验证设置结果 if future.result() is not None: self.get_logger().info(f\"跨节点设置参数成功: {future.result()}\") # 获取目标节点的参数值 get_param_client self.create_client(GetParameters, \"/turtlesim/get_parameters\") while not get_param_client.wait_for_service(timeout_sec 1.0): self.get_logger().info(\"/turtlesim/get_parameters服务未就绪，正在等待...\") get_request GetParameters.Request() get_request.names [\"background_b\"] get_future get_param_client.call_async(get_request) rclpy.spin_until_future_complete(self, get_future) if get_future.result() is not None: self.get_logger().info(f\"目标节点参数background_b的新值为: {get_future.result().values[0].integer_value}\") else: self.get_logger().error(\"跨节点设置参数失败\") def main(args None): rclpy.init(args args) # 注意：需先启动/turtlesim节点，再运行本节点 node CrossParamNode() node.destroy_node() rclpy.shutdown() if __name__ \"__main__\": main() ```"},"/note/嵌入式/ROS/ROS2/2026-1-27-39-执行器组织多个节点.html":{"title":"执行器组织多个节点","content":"# 执行器组织多个节点 ## 静态组合 可以把多个节点放在同一个进程里面, 从而实现更加方便的信息传输 ### 官方示例 ```bash (base) jiao@jiao virtual machine:~$ ros2 run intra_process_demo two_node_pipeline Published message with value: 0, and address: 0x5BA9FEAFC9C0 Received message with value: 0, and address: 0x5BA9FEAFC9C0 Published message with value: 1, and address: 0x5BA9FEAFC9C0 Received message with value: 1, and address: 0x5BA9FEAFC9C0 ``` 可以看到内存是没有变化的, 所以传输的效率更高 ### 代码实现 #### 类实现 ```cpp #ifndef LEARN_COMPOSE__TALKER_COMPONENT_HPP_ #define LEARN_COMPOSE__TALKER_COMPONENT_HPP_ #include \"rclcpp/rclcpp.hpp\" #include \"std_msgs/msg/int32.hpp\" namespace learn_compose { class Talker : public rclcpp::Node { public: explicit Talker(const rclcpp::NodeOptions &options); private: int32_t count_; rclcpp::Publisher<std_msgs::msg::Int32>::SharedPtr pub_; rclcpp::TimerBase::SharedPtr timer_; }; } // namespace learn_compose #endif // LEARN_COMPOSE__TALKER_COMPONENT_HPP_ ``` ```cpp #ifndef LEARN_COMPOSE__LISTENER_COMPONENT_HPP_ #define LEARN_COMPOSE__LISTENER_COMPONENT_HPP_ #include \"rclcpp/rclcpp.hpp\" #include \"std_msgs/msg/int32.hpp\" namespace learn_compose { class Listener : public rclcpp::Node { public: explicit Listener(const rclcpp::NodeOptions &options); private: rclcpp::Subscription<std_msgs::msg::Int32>::SharedPtr sub_; }; } // namespace learn_compose #endif // LEARN_COMPOSE__LISTENER_COMPONENT_HPP_ ``` ```cpp #include <chrono> #include \"learn_compose/talker.hpp\" namespace learn_compose { using namespace std::chrono_literals; Talker::Talker(const rclcpp::NodeOptions &options) : Node(\"talker\", options) { pub_ this >create_publisher<std_msgs::msg::Int32>(\"count\", 10); auto callback [&]() > void { // unique_ptr 代表独占式所有权：一个 unique_ptr 实例独占它所指向的对象， // 同一时间只有一个 unique_ptr 能指向该对象，不允许拷贝（拷贝构造 / 赋值会编译报错）， // 只能通过移动（move） 转移所有权。 std_msgs::msg::Int32::UniquePtr msg(new std_msgs::msg::Int32()); msg >data count_++; RCLCPP_INFO(this >get_logger(), \"发布数据:%d(0x%lX)\", msg >data, reinterpret_cast<std::uintptr_t>(msg.get())); pub_ >publish(std::move(msg)); }; timer_ this >create_wall_timer(1s, callback); } } // namespace learn_compose ``` ```cpp #include \"learn_compose/listener.hpp\" #include <chrono> namespace learn_compose { using namespace std::chrono_literals; Listener::Listener(const rclcpp::NodeOptions &options) : Node(\"listener\", options) { sub_ this >create_subscription<std_msgs::msg::Int32>( \"count\", 10, [&](const std_msgs::msg::Int32::UniquePtr msg) { RCLCPP_INFO(this >get_logger(), \"收到数据:%d(0x%lX)\", msg >data, reinterpret_cast<std::uintptr_t>(msg.get())); }); } } // namespace learn_compose ``` **普通对象发布的问题**：如果直接创建普通消息对象（`std_msgs::msg::Int32 msg;`），调用`pub_ >publish(msg)`时，ROS 2 会**拷贝整个消息对象**到发布队列中（相当于复制一份数据）。对于`Int32`这种小消息，拷贝开销可以忽略，但如果是大消息（比如图像`sensor_msgs::msg::Image`、激光雷达点云`sensor_msgs::msg::PointCloud2`），拷贝会消耗大量 CPU 和内存，严重影响性能。 **UniquePtr 发布的优势**：通过`std::move`转移`UniquePtr`的所有权，发布器直接使用你创建的消息内存，**无需任何拷贝**（零拷贝），发布效率大幅提升 —— 这也是 ROS 2 为所有消息类型内置`UniquePtr`别名（如`Int32::UniquePtr`）的核心目的。 ```cpp #include \"learn_compose/listener.hpp\" #include <chrono> namespace learn_compose { using namespace std::chrono_literals; Listener::Listener(const rclcpp::NodeOptions &options) : Node(\"listener\", options) { sub_ this >create_subscription<std_msgs::msg::Int32>( \"count\", 10, [&](const std_msgs::msg::Int32::UniquePtr msg) { RCLCPP_INFO(this >get_logger(), \"收到数据:%d(0x%lX)\", msg >data, reinterpret_cast<std::uintptr_t>(msg.get())); }); } } // namespace learn_compose #include \"rclcpp_components/register_node_macro.hpp\" RCLCPP_COMPONENTS_REGISTER_NODE(learn_compose::Listener) ``` #### 实际使用 ```cpp #include \"learn_compose/listener.hpp\" #include \"learn_compose/talker.hpp\" #include \"rclcpp/rclcpp.hpp\" int main(int argc, char *argv[]) { rclcpp::init(argc, argv); rclcpp::executors::SingleThreadedExecutor executor; rclcpp::NodeOptions options; // 创建节点选项 options.use_intra_process_comms(true); // 使用进程内通信 auto talker std::make_shared<learn_compose::Talker>(options); auto listener std::make_shared<learn_compose::Listener>(options); executor.add_node(talker); executor.add_node(listener); executor.spin(); rclcpp::shutdown(); return 0; } ``` ## 组件动态加载 使用命令查看当前加载的组件 ```bash (base) jiao@jiao virtual machine:~$ ros2 component types quality_of_service_demo_cpp quality_of_service_demo::MessageLostListener quality_of_service_demo::MessageLostTalker quality_of_service_demo::QosOverridesListener quality_of_service_demo::QosOverridesTalker composition # 这是一个提供的示例组件 composition::Talker composition::Listener composition::NodeLikeListener composition::Server composition::Client ... # 创建容器 (base) jiao@jiao virtual machine:~$ ros2 run rclcpp_components component_container ros args r __node: compent_test # 加载节点 (base) jiao@jiao virtual machine:~$ ros2 component load /compent_test composition composition::Talker Loaded component 1 into '/compent_test' container node as '/talker' # 指定配置 (base) jiao@jiao virtual machine:~$ ros2 component load /compent_test composition composition::Talker node name talker2 node namespace /ns Loaded component 2 into '/compent_test' container node as '/ns/talker2' # 出现两个topic (base) jiao@jiao virtual machine:~$ ros2 topic list /chatter /ns/chatter (base) jiao@jiao virtual machine:~$ ros2 component load /compent_test composition composition::Listener Loaded component 3 into '/compent_test' container node as '/listener' # 查看当前的node (base) jiao@jiao virtual machine:~$ ros2 component list /compent_test 1 /talker 2 /ns/talker2 3 /listener # 卸载 (base) jiao@jiao virtual machine:~$ ros2 component unload /compent_test 1 2 3 Unloaded component 1 from '/compent_test' container node Unloaded component 2 from '/compent_test' container node Unloaded component 3 from '/compent_test' container node ``` ### 代码实现 使用一个宏进行注册 ```cpp #include \"rclcpp_components/register_node_macro.hpp\" RCLCPP_COMPONENTS_REGISTER_NODE(learn_compose::Listener) ``` 在cmake里面引用对应的库, 编译为库 ```cmake find_package(rclcpp_components REQUIRED) include_directories(include) add_executable(intra_process_pubsub src/intra_process_pubsub.cpp src/talker.cpp src/listener.cpp ) ament_target_dependencies(intra_process_pubsub std_msgs rclcpp rclcpp_components) add_library(talker_component SHARED src/talker.cpp) ament_target_dependencies(talker_component \"std_msgs\" \"rclcpp\" \"rclcpp_components\") rclcpp_components_register_nodes(talker_component \"learn_compose::Talker\") add_library(listener_component SHARED src/listener.cpp) ament_target_dependencies(listener_component \"std_msgs\" \"rclcpp\" \"rclcpp_components\") rclcpp_components_register_nodes(listener_component \"learn_compose::Listener\") install(TARGETS talker_component listener_component ARCHIVE DESTINATION lib LIBRARY DESTINATION lib RUNTIME DESTINATION bin ) ``` 在运行的时候如果使用进程间通信的话, 需要在加载节点的时候加上参数` e use_intra_process_comms: true`"},"/note/嵌入式/ROS/ROS2/2026-1-17-16-环境变量.html":{"title":"环境变量","content":"# 环境变量 + `ROS_VERSION`: ROS的版本 + `ROS_DISTRO`: 发行版的版本 + `AMENT_PREFIX_PATH`: ROS安装的位置, `ros2 run`会在这个文件夹下的`/lib/package_name`里面查找可执行文件, 一般是在`/opt/ros/humble` + `RCUTILS_CONCOLE_OUTPUT_FORMAT`: 输出日志的格式, 可以设置为`[{function_name}:{line_number}]:{message}` ### 分组 默认所有的设备都可以通信, 但是可以使用分组的方式进行区分 ```bash export ROS_DOMAIN_ID 数字 ``` 还可以配置 ```bash export ROS_LOCALHOST_ONLY 1 ``` 只在本地主机"},"/note/嵌入式/ROS/ROS2/2026-1-15-01-ROS2.html":{"title":"ROS2","content":"# ROS2 ROS1基于PR2一个工作站级别的机器人, 以及有线连接的方式, 成本高 ROS2需要在嵌入式系统里面, 同时可以可以在连接不稳定的地方使用 + 构建多机器人系统 + 跨平台, RTOS/Windows + 实时性 + 网络连接 + 产品化 + 项目管理 ROS2是一个全新的系统, 不再使用Master进行管理, 使用分布式管理, 软件的API重新设计, 更加通用, 使用新的编译系统 ![image 20260115111150382](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601151111476.png) ROS通过自发现的方式查找其他的节点, 使用DDS通信协议 ## 安装 ```bash sudo apt update && sudo apt install curl gnupg lsb release sudo curl sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key o /usr/share/keyrings/ros archive keyring.gpg echo \"deb [arch $(dpkg print architecture) signed by /usr/share/keyrings/ros archive keyring.gpg] http://packages.ros.org/ros2/ubuntu $(source /etc/os release && echo $UBUNTU_CODENAME) main\" sudo tee /etc/apt/sources.list.d/ros2.list > /dev/null sudo apt update sudo apt upgrade sudo apt install ros humble desktop # sudo apt install ros humble ros base source /opt/ros/humble/setup.bash echo \" source /opt/ros/humble/setup.bash\" >> ~/.bashrc ``` 鲁班猫安装 ```bash wget http://fishros.com/install O fishros && . fishros # 失败 ``` ### 测试 ```bash ros2 run demo_nodes_cpp talker ros2 run demo_nodes_py listener ros2 run turtlesim turtlesim_node ros2 run turtlesim turtle_teleop_key ```"},"/note/嵌入式/ROS/ROS2/2026-1-22--23-ros2_control驱动.html":{"title":"ros2_control驱动","content":"# ros2_control驱动 `os2_control` 是 ROS 2 官方推出的硬件控制中间件，核心目标是**解耦机器人的「高层控制逻辑」和「底层硬件驱动」**： 对开发者：不用关心硬件的具体通信协议（比如串口、CAN、以太网），只需调用标准化接口就能控制电机 / 传感器； 对硬件：不同厂商的硬件（比如不同品牌的舵机、机械臂）只需适配 `ros2_control` 接口，就能无缝接入 ROS 2 生态； 对仿真：`ros2_control` 能让**仿真硬件（Gazebo 中的关节）** 和**真实硬件**使用完全相同的高层控制代码，实现「仿真与实机一键切换」。 简单说：`ros2_control` 是 ROS 2 中连接「算法（比如运动控制、路径规划）」和「硬件（或仿真硬件）」的 “翻译官”。 > **ROS2 Control 的核心价值：硬件抽象** > > 不管你是控制「Gazebo 仿真关节」还是「真实机器人的电机驱动板」，ROS2 Control 都把它们的接口标准化为： > > `command_interface`（命令接口：如 effort/velocity）：接收控制指令； > > `state_interface`（状态接口：如 position/velocity/effort）：反馈状态数据； > > 你不用关心 “Gazebo 怎么接收力矩指令” 或 “真实驱动板的通信协议”，只需要给控制器发标准化的 Topic 指令即可。 之前使用的插件进行设备的控制, 但是实际的使用时候没有真是的插件, 如果需要重新编写代码, 这个是重复造轮子 ![image 20260122163045674](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601221630732.png) 需要统一的是通信的数据输入 ![image 20260122163119290](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601221631343.png) ros2_control把硬件分为三类 + 传感器: 比如编码器、IMU、激光雷达 + 系统: 另外两种的集合,比如整个机械臂、移动底盘，包含多个执行器 / 传感器 + 执行器: 比如单个电机、舵机 ```bash sudo apt get install ros $ROS_DISTRO ros2 control ``` 1. 硬件组件层（Hardware Components） 这是直接对接硬件 / 仿真硬件的最底层，核心是实现 `read()` 和 `write()` 两个方法： `read()`：从硬件 / 仿真中读取状态（比如关节位置、速度、传感器数据）； `write()`：将控制指令（比如关节目标位置、力矩）发送到硬件 / 仿真。 2. 接口层（Standard Interfaces） `ros2_control` 定义了**标准化的硬件接口**，让控制器和硬件组件之间能 “无缝通信”，常用的接口 ![image 20260122181600640](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601221816705.png) 3. 控制器层（Controllers） 这是实现控制逻辑的核心层，`ros2_control` 提供了大量开箱即用的控制器（无需自己写），新手高频使用的： `joint_state_broadcaster`：广播关节状态（最基础，必须加载）； `joint_trajectory_controller`：关节轨迹控制器（控制多关节按预定轨迹运动）； `joint_position_controller`：单关节位置控制器； `joint_velocity_controller`：单关节速度控制器； `effort_controller`：单关节力矩控制器。 控制器支持**动态加载 / 卸载 / 切换**，比如可以先加载位置控制器，运行中切换为速度控制器。 4. 控制器管理器（Controller Manager） 相当于 `ros2_control` 的 “大脑”，负责： 加载 / 卸载控制器； 启动 / 停止控制器； 切换控制器的状态（活跃 / 非活跃）； 提供 ROS 2 服务 / 话题接口，让你能通过命令行或节点控制控制器。 ## 使用 ```bash (base) jiao@jiao virtual machine:~$ ros2 control help usage: ros2 control [ h] Call `ros2 control <command> h` for more detailed usage. ... Various control related sub commands options: h, help show this help message and exit Commands: list_controller_types Output the available controller types and their base classes list_controllers Output the list of loaded controllers, their type and status list_hardware_components Output the list of available hardware components list_hardware_interfaces Output the list of available command and state interfaces load_controller Load a controller in a controller manager reload_controller_libraries Reload controller libraries set_controller_state Adjust the state of the controller set_hardware_component_state Adjust the state of the hardware component switch_controllers Switch controllers in a controller manager unload_controller Unload a controller in a controller manager view_controller_chains Generates a diagram of the loaded chained controllers into /tmp/controller_diagram.gv.pdf Call `ros2 control <command> h` for more detailed usage. ``` 实际就是一些列的控制器接口的操作 ![image 20260122163818951](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601221638030.png) 可以在depends里面查看提供的控制器 ```bash sudo apt install ros $ROS_DISTRO ros2 controllers ``` ![image 20260122170304556](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601221703615.png) 安装插件 ```bash sudo apt install ros $ROS_DISTRO gazebo ros2 control ``` ### 配置gazebo的插件 ```xml <?xml version \"1.0\"?> <robot xmlns:xacro \"http://www.ros.org/wiki/xacro\"> <xacro:macro name \"fishbot_ros2_control\"> <! ROS2 Control 插件配置 > <ros2_control name \"FishBotGazeboSystem\" type \"system\"> <! 设置一个硬件, 设置一个驱动库的名字 > <hardware> <plugin>gazebo_ros2_control/GazeboSystem</plugin> </hardware> <! 定义机器人的关节和它们的接口 > <joint name \"left_wheel_joint\"> <! 配置一个关节的速度 > <command_interface name \"velocity\"> <param name \"min\"> 1</param> <param name \"max\">1</param> </command_interface> <! 配置一个关节的力矩 > <command_interface name \"effort\"> <param name \"min\"> 0.1</param> <param name \"max\">0.1</param> </command_interface> <! 配置一个关节的位置状态 > <state_interface name \"position\" /> <! 配置一个关节的速度状态 > <state_interface name \"velocity\" /> <! 配置一个关节的力矩状态 > <state_interface name \"effort\" /> </joint> <joint name \"right_wheel_joint\"> <command_interface name \"velocity\"> <param name \"min\"> 1</param> <param name \"max\">1</param> </command_interface> <command_interface name \"effort\"> <param name \"min\"> 0.1</param> <param name \"max\">0.1</param> </command_interface> <state_interface name \"position\" /> <state_interface name \"velocity\" /> <state_interface name \"effort\" /> </joint> </ros2_control> <gazebo> <plugin filename \"libgazebo_ros2_control.so\" name \"gazebo_ros2_control\"> <! 参数配置文件 > <parameters>$(find bot_3D_desc)/config/fishbot_ros2_controller.yaml</parameters> </plugin> </gazebo> </xacro:macro> </robot> ``` 和之前的 ` <xacro:gazebo_control_plugin/>`这个控制标签的冲突的, 需要注释一下 加载一个yaml的配置文件 ```yaml controller_manager: ros__parameters: update_rate: 100 # Hz use_sim_time: true ``` ### 控制 `ros2 control`实际是使用一系列的server进行控制 ```bash (base) jiao@jiao virtual machine:~$ ros2 service list grep controller /controller_manager/configure_controller /controller_manager/describe_parameters /controller_manager/get_parameter_types /controller_manager/get_parameters /controller_manager/list_controller_types /controller_manager/list_controllers /controller_manager/list_hardware_components /controller_manager/list_hardware_interfaces /controller_manager/list_parameters /controller_manager/load_controller /controller_manager/reload_controller_libraries /controller_manager/set_hardware_component_state /controller_manager/set_parameters /controller_manager/set_parameters_atomically /controller_manager/switch_controller /controller_manager/unload_controller # 可以直接拿来用的所有「控制器类型」 (base) jiao@jiao virtual machine:~/ros/dev_ws$ ros2 control list_controller_types [INFO] [1769078338.267571743] [_ros2cli_18134]: waiting for service /controller_manager/list_controller_types to become available... controller_manager/test_controller controller_interface::ControllerInterface controller_manager/test_controller_failed_activate controller_interface::ControllerInterface controller_manager/test_controller_failed_init ... # 查看当前的硬件接口 (base) jiao@jiao virtual machine:~/ros/dev_ws$ ros2 control list_hardware_interfaces command interfaces \t\t# unclaimed未被占用 left_wheel_joint/effort [available] [unclaimed] left_wheel_joint/velocity [available] [unclaimed] right_wheel_joint/effort [available] [unclaimed] right_wheel_joint/velocity [available] [unclaimed] state interfaces left_wheel_joint/effort left_wheel_joint/position left_wheel_joint/velocity right_wheel_joint/effort right_wheel_joint/position right_wheel_joint/velocity # 所有的硬件的组件 (base) jiao@jiao virtual machine:~/ros/dev_ws$ ros2 control list_hardware_components [INFO] [1769078781.066807208] [_ros2cli_18607]: waiting for service /controller_manager/list_hardware_components to become available... Hardware Component 1 name: FishBotGazeboSystem type: plugin name: state: id 3 label active command interfaces left_wheel_joint/velocity [available] [unclaimed] left_wheel_joint/effort [available] [unclaimed] right_wheel_joint/velocity [available] [unclaimed] right_wheel_joint/effort [available] [unclaimed] ``` ### 关节状态发布控制器 这个时候由于没有发布两个轮子的位置的节点, 所以轮子的位置是不对的, 可以使用一个controller进行发布 在配置文件里面添加一个controller配置 ```yaml controller_manager: ros__parameters: update_rate: 100 # Hz use_sim_time: true # 扫描所有的状态控制接口, 发布关节状态 fishbot_joint_state_broadcaster: type: joint_state_broadcaster/JointStateBroadcaster publish_rate: 50 # Hz ``` 这里只是配置, 还没有启动 > 广播器会连接到你 xacro 中定义的`left_wheel_joint`和`right_wheel_joint`硬件接口； > > 以 50Hz 的频率读取这两个关节的`position`（位置，车轮转动弧度）、`velocity`（速度，弧度 / 秒）、`effort`（力矩，牛米）； > > 将这些数据打包发布到`/joint_states`话题。 ```bash ros2 control load_controller fishbot_joint_state_broadcaster set state active ``` ![image 20260122190423729](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601221904957.png) 可以使用launch文件一次性加载 ```python # 自动加载关节状态控制器, 用于发布关节状态信息 action_load_joint_state_controller launch.actions.ExecuteProcess( cmd ['ros2', 'control', 'load_controller', ' set state', 'active', 'fishbot_joint_state_broadcaster'], output 'screen' ) # 加载的时候是有时间的, 需要额外的配置 launch.actions.RegisterEventHandler( event_handler launch.event_handlers.OnProcessExit( target_action action_spawn_entity, on_exit [action_load_joint_state_controller], ) ), # 在spawn_entity节点退出后加载控制 ``` ### 力度控制器 ```yaml controller_manager: ros__parameters: update_rate: 100 # Hz use_sim_time: true fishbot_joint_state_broadcaster: type: joint_state_broadcaster/JointStateBroadcaster publish_rate: 50 # Hz # 有这个controller fishbot_effort_controllers: type: effort_controllers/JointGroupEffortController # 配制实际的参数 fishbot_effort_controllers: ros__parameters: # 可以控制的关节列表 joints: left_wheel_joint right_wheel_joint # 控制接口类型 command_interfaces: effort # 状态接口类型 state_interfaces: position velocity effort ``` 在配置文件的添加和上面类似 ```bash jiao@jiao virtual machine:~$ ros2 topic list t grep effort /fishbot_effort_controllers/commands [std_msgs/msg/Float64MultiArray] /fishbot_effort_controllers/transition_event [lifecycle_msgs/msg/TransitionEvent] # 可以发布命令控制 jiao@jiao virtual machine:~$ ros2 topic pub /fishbot_effort_controllers/commands std_msgs/msg/Float64MultiArray \"{data: [0.0001, 0.0001]}\" ``` 使用数组控制力 ![image 20260123182219870](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601231822998.png) ### 两轮差速控制器 ```yaml controller_manager: ros__parameters: update_rate: 100 # Hz use_sim_time: true fishbot_joint_state_broadcaster: type: joint_state_broadcaster/JointStateBroadcaster publish_rate: 50 # Hz fishbot_effort_controllers: type: effort_controllers/JointGroupEffortController # 添加节点 fishbot_diff_drive_controller: type: diff_drive_controller/DiffDriveController # 使用的参数 fishbot_diff_drive_controller: ros__parameters: \t# 关节的名字 left_wheel_names: [\"left_wheel_joint\"] right_wheel_names: [\"right_wheel_joint\"] \t# 距离 wheel_separation: 0.20 # 同侧车轮数量 #wheels_per_side: 1 # actually 2, but both are controlled by 1 signal # 半径, 用于转换 “车轮转速 ↔ 底盘线速度” wheel_radius: 0.032 \t# 间距的倍数, 半径的倍数, 动态控制 \t# 用于微调轮距 / 轮径（比如仿真 / 实际硬件的尺寸和理论值有偏差） wheel_separation_multiplier: 1.0 left_wheel_radius_multiplier: 1.0 right_wheel_radius_multiplier: 1.0 \t# 里程计（Odom）发布配置（控制定位数据输出） publish_rate: 50.0 odom_frame_id: odom # 里程计参考坐标系名 base_frame_id: base_footprint # 机器人底盘坐标系名 # 位置的噪声 pose_covariance_diagonal : [0.001, 0.001, 0.0, 0.0, 0.0, 0.01] twist_covariance_diagonal: [0.001, 0.0, 0.0, 0.0, 0.0, 0.01] \t# 开环控制 \t# true（开环）：控制器直接根据/cmd_vel计算车轮目标值 \t# 不反馈实际车轮转速（仿真优先用，因为仿真无打滑 / 电机误差）； \t#false（闭环）：控制器读取车轮实际转速，和目标值对比做 PID 调节 \t#（真实机器人优先用，补偿打滑 / 电机误差）。 open_loop: true enable_odom_tf: true # 是否发布odom→base_footprint的TF变换 \t# 如果控制器在 0.5 秒内没收到新的/cmd_vel指令，自动停止车轮运动 cmd_vel_timeout: 0.5 # 是否发布限速后的实际速度 #publish_limited_velocity: true # 作用：是否使用带时间戳的速度指令 use_stamped_vel: false # 速度平滑窗口大小, 取最近 10 次速度的平均值 #velocity_rolling_window_size: 10 ``` ```python (base) jiao@jiao virtual machine:~/ros/dev_ws$ ros2 topic list grep diff /fishbot_diff_drive_controller/cmd_vel_unstamped /fishbot_diff_drive_controller/odom /fishbot_diff_drive_controller/transition_event ``` **`/odom` 话题** 是机器人**里程计（Odometry）** 数据的主要发布通道。里面记录的信息如下 + **`stamp`**: 数据发布时间，用于同步和滤波 + **`frame_id`**：该位姿数据所在的坐标系名称 + **`child_frame_id`**: 机器人底座坐标系 + **`position`**: 位置, x, y, z + **`orientation`**: 朝向 (orientation), **四元数表示**：`(x, y, z, w)`，避免万向锁问题 + **`Pose Covariance`**: 位姿协方差, **协方差矩阵是6×6的对称矩阵**，按行优先展开为36个元素的数组 索引 对应关系 含义 当前值 : : : : 0 pose.position.x 的方差 X位置不确定性 0.001 7 pose.position.y 的方差 Y位置不确定性 0.001 14 pose.position.z 的方差 Z位置不确定性 0.0 21 orientation.x (roll) 的方差 横滚角不确定性 0.0 28 orientation.y (pitch) 的方差 俯仰角不确定性 0.0 35 orientation.z (yaw) 的方差 偏航角不确定性 0.01 + **`twist`**: 线速度以及角速度 + **`Twist Covariance`**: 速度协方差 **`cmd_vel_unstamped`**是一个标准的速度控制的接口 可以重映射一下 ```bash <plugin filename \"libgazebo_ros2_control.so\" name \"gazebo_ros2_control\"> <! 参数配置文件 > <parameters>$(find bot_3D_desc)/config/fishbot_ros2_controller.yaml</parameters> <ros> <remapping>/fishbot_diff_drive_controller/odom: /odom</remapping> <remapping>/fishbot_diff_drive_controller/cmd_vel_unstamped: /cmd_vel</remapping> </ros> </plugin> ``` 之后可以使用之前的命令行控制工具了 ```bash ros2 run teleop_twist_keyboard teleop_twist_keyboard ```"},"/note/嵌入式/ROS/ROS2/2026-1-26-34-运动学正逆解.html":{"title":"运动学正逆解","content":"# 运动学正逆解 目标的线速度角速度 >两个轮子的速度 >运动学逆解 两个轮子的速度 >目标的线速度角速度 >运动学正解 <img src \"https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601261905696.png\" alt \"image 20260126190500650\" style \"zoom:150%;\" /> 使用这两个公式即可实现两者的转换 ## 实现 ```cpp #ifndef __KINEMATICS_H__ #define __KINEMATICS_H__ #include \"Arduino.h\" typedef struct { float per_pulse_distance; // 每个脉冲的前进的距离 int16_t motor_speed; // 单位用mm/s int64_t last_encoder_ticks; // 上一次电机的编码器读数 } motor_param_t; typedef struct { float x; float y; float angle; float linear_speed; float angular_speed; }odom_t; /** * 1. 运动学正逆解（两个轮子的实时速度 >当前实时的角速度和线速度 / 当前目标的角速度和线速度 >两个轮子的目标速度） * */ class Kinematics { private: /* data */ motor_param_t motor_param[2]; int16_t delta_ticks[2] {0, 0}; // 用于存储上一次读取的编码器数值 uint64_t last_update_time 0; // 用于存储上一次更新电机速度的时间,计算速度的时候使用 float wheel_distance 0.0; // 两个轮子之间的距离 odom_t odom; // 用于存储里程计信息 public: Kinematics(/* args */) default; ~Kinematics() default; odom_t& get_odom(); void update_odom(uint16_t dt); void TransAngleInPI(float angle,float& out_angle); void set_wheel_distance(float distance); // 设置轮子的间距 \t// 设置电机的速度 void set_motor_param(uint8_t id,float per_pluse_distance); // 运动学正解,将左右轮的速度转换成线速度和角速度 void kinematics_forward(float left_speed,float right_speed,float* out_linear_speed,float* out_angular_speed); // 运动学逆解，将线速度和角速度转换成左右轮的速度 void kinematics_inverse(float linear_speed,float angular_speed,float* out_left_speed,float* out_right_speed); // 更新电机速度和编码器数据 void update_motor_speed(uint64_t current_time,int32_t left_tick,int32_t right_tick); // 获取电机速度,返回值是速度 int16_t get_motor_speed(uint8_t id); }; #endif // __KINEMATICS_H__ ``` + 实现 计量器数据 >实时车轮速度(获取的速度使用PID转换为下一个的输出值) + 运动学正逆解 ```cpp #include \"Kinematics.h\" // 设置轮子的间距 void Kinematics::set_wheel_distance(float distance) { wheel_distance distance; } void Kinematics::set_motor_param(uint8_t id, float per_pluse_distance) { motor_param[id].per_pulse_distance per_pluse_distance; } // 运动学正解,将左右轮的速度转换成线速度和角速度 void Kinematics::kinematics_forward(float left_speed, float right_speed, float *out_linear_speed, float *out_angular_speed) { *out_linear_speed (left_speed + right_speed) / 2; *out_angular_speed (right_speed left_speed) / wheel_distance; } // 运动学逆解，将线速度和角速度转换成左右轮的速度 void Kinematics::kinematics_inverse(float linear_speed, float angular_speed, float *out_left_speed, float *out_right_speed) { *out_left_speed linear_speed angular_speed * wheel_distance / 2; *out_right_speed linear_speed + angular_speed * wheel_distance / 2; } // 输入：左右轮脉冲数，当前时间，输出更新电机速度和编码器数据 void Kinematics::update_motor_speed(uint64_t current_time, int32_t left_tick, int32_t right_tick) { int16_t dt current_time last_update_time; // ms delta_ticks[0] left_tick motor_param[0].last_encoder_ticks; delta_ticks[1] right_tick motor_param[1].last_encoder_ticks; \t// 使用获取的计量器数据计算实际的轮速 motor_param[0].motor_speed (delta_ticks[0] * 105.805) / dt; motor_param[1].motor_speed (delta_ticks[1] * 105.805) / dt; // 为了下次还可以正常的计算速度 motor_param[0].last_encoder_ticks left_tick; motor_param[1].last_encoder_ticks right_tick; last_update_time current_time; update_odom(dt); } // 获取电机速度,返回值是速度 int16_t Kinematics::get_motor_speed(uint8_t id) { if (id < 0 id > 1) { return 1; } return motor_param[id].motor_speed; } odom_t& Kinematics::get_odom() { return odom; } void Kinematics::TransAngleInPI(float angle,float& out_angle) { if(angle>PI) { out_angle 2*PI; }else if (angle< PI) { out_angle + 2*PI; } } void Kinematics::update_odom(uint16_t dt) { float dt_s float(dt)/1000.0; // ms > s // 获取实时的角速度和线速度呢？我们拿左右轮实时的速度，进行运动学正解 this >kinematics_forward(motor_param[0].motor_speed,motor_param[1].motor_speed,&odom.linear_speed,&odom.angular_speed); // 计算里程计信息 odom.linear_speed odom.linear_speed/1000.0; // 转换成米每秒 // 角度积分 odom.angle + odom.angular_speed*dt_s; TransAngleInPI(odom.angle,odom.angle); // 计算机器人行走的距离（沿自身前进方向的） float delta_distance odom.linear_speed * dt_s; // 分解到X轴和Y轴 odom.x + delta_distance * std::cos(odom.angle); odom.y + delta_distance * std::sin(odom.angle); } ```"},"/note/嵌入式/ROS/ROS2/2026-1-23-24-自主导航.html":{"title":"自主导航","content":"# 自主导航 1. 确定目标位置以及自己的位置, 在实际的场景里面一般是使用传感器获取 2. 一个标有环境的地图 ![image 20260124135917691](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601241359949.png) 由于扫描的时候会有延迟, 所以实际获取的环境是有偏差的 **SLAM** (`simultaneous localization and mapping),也称为CML (Concurrent Mapping and Localization`), 即时定位与地图构建，或并发建图与定位。通过里程计以及雷达, 计算实际的地图 一般来说有激光SLAM以及视觉SLAM, 一般来说激光SLAM比较成熟 获取地图以后之后需要的就是路径规划, 避免障碍物以及获取最短的路径, 首先规划全局的路线之后还需要处理动态突发的事件, 使用恢复行为脱困"},"/note/嵌入式/ROS/ROS2/2026-1-25-29-自定义路径规划.html":{"title":"自定义路径规划器","content":"# 自定义路径规划器 基于机器人的起始位姿, 目标位姿以及地图计算出来一个可以使用的路径 + 位置 ```bash (base) jiao@jiao virtual machine:~/ros/learn_pluginlib$ ros2 interface show geometry_msgs/msg/PoseStamped # A Pose with reference coordinate frame and timestamp std_msgs/Header header builtin_interfaces/Time stamp int32 sec uint32 nanosec string frame_id Pose pose Point position float64 x float64 y float64 z Quaternion orientation float64 x 0 float64 y 0 float64 z 0 float64 w 1 ``` + 地图, 这个数据是从左上角开始计算的 ```bash (base) jiao@jiao virtual machine:~/ros/learn_pluginlib$ ros2 interface show nav_msgs/msg/OccupancyGrid # This represents a 2 D grid map std_msgs/Header header builtin_interfaces/Time stamp int32 sec uint32 nanosec string frame_id # MetaData for the map MapMetaData info builtin_interfaces/Time map_load_time int32 sec uint32 nanosec float32 resolution # 分辨率, 一个像素代表的距离 uint32 width # 宽高 uint32 height geometry_msgs/Pose origin # 原点坐标 Point position float64 x float64 y float64 z Quaternion orientation float64 x 0 float64 y 0 float64 z 0 float64 w 1 # The map data, in row major order, starting with (0,0). # Cell (1, 0) will be listed second, representing the next cell in the x direction. # Cell (0, 1) will be at the index equal to info.width, followed by (1, 1). # The values inside are application dependent, but frequently, # 0 represents unoccupied, 1 represents definitely occupied, and # 1 represents unknown. int8[] data ``` 在实际使用的时候需要和ros里面的地图进行转换, 这里的origin是地图的起始位置的偏移 ```python row_index (y info.origin.y) / info.resolution row_index (x info.origin.x) / info.resolution occupied_state data[row_index * map_width + col_index] ``` + 路径:是一系列的点 ```bash (base) jiao@jiao virtual machine:~/ros/learn_pluginlib$ ros2 interface show nav_msgs/msg/Path # An array of poses that represents a Path for a robot to follow. # Indicates the frame_id of the path. std_msgs/Header header builtin_interfaces/Time stamp int32 sec uint32 nanosec string frame_id # Array of poses to follow. geometry_msgs/PoseStamped[] poses std_msgs/Header header builtin_interfaces/Time stamp int32 sec uint32 nanosec string frame_id Pose pose Point position float64 x float64 y float64 z Quaternion orientation float64 x 0 float64 y 0 float64 z 0 float64 w 1 ``` ## 创建自定义规划器 + 创建目录以及功能包 + 定义插件类, 插件继承于navigation2里面的一个基类nav2_core::GlobalPlanner + + 重写五个纯虚函数 + + configure: 插件配置 + cleanup: 插件清理 + activate: 插件激活 + deactivate: 插件停用 + createPlan: 创建路径 + 实现插件的逻辑 + + 在configure方法里面初始化代价地图, 全局坐标等 + 创建插件的描述文件 ```cpp #ifndef NAV2_CUSTOM_PLANNER__NAV2_CUSTOM_PLANNER_HPP_ #define NAV2_CUSTOM_PLANNER__NAV2_CUSTOM_PLANNER_HPP_ #include <memory> #include <string> // 消息接口头文件 #include \"geometry_msgs/msg/point.hpp\" #include \"geometry_msgs/msg/pose_stamped.hpp\" #include \"nav_msgs/msg/path.hpp\" #include \"nav2_costmap_2d/costmap_2d_ros.hpp\" #include \"rclcpp/rclcpp.hpp\" // 基类头文件 #include \"nav2_core/global_planner.hpp\" // rclcpp的生命周期节点头文件 #include \"nav2_util/lifecycle_node.hpp\" // 常用工具头文件 #include \"nav2_util/robot_utils.hpp\" namespace nav2_custom_planner { // 自定义导航规划器类 class CustomPlanner : public nav2_core::GlobalPlanner { public: CustomPlanner() default; ~CustomPlanner() default; // 插件配置方法 void configure( const rclcpp_lifecycle::LifecycleNode::WeakPtr &parent, std::string name, std::shared_ptr<tf2_ros::Buffer> tf, std::shared_ptr<nav2_costmap_2d::Costmap2DROS> costmap_ros) override; // 插件清理方法 void cleanup() override; // 插件激活方法 void activate() override; // 插件停用方法 void deactivate() override; // 为给定的起始和目标位姿创建路径的方法 nav_msgs::msg::Path createPlan(const geometry_msgs::msg::PoseStamped &start, const geometry_msgs::msg::PoseStamped &goal) override; private: // 坐标变换缓存指针，可用于查询坐标关系 std::shared_ptr<tf2_ros::Buffer> tf_; // 节点指针, 传过来的参数 nav2_util::LifecycleNode::SharedPtr node_; // 全局代价地图 nav2_costmap_2d::Costmap2D *costmap_; // 全局代价地图的坐标系, 插件的名字 std::string global_frame_, name_; // 插值分辨率 double interpolation_resolution_; }; } // namespace nav2_custom_planner #endif // NAV2_CUSTOM_PLANNER__NAV2_CUSTOM_PLANNER_HPP_ ``` 基础的C文件实现 ```cpp #include \"nav2_util/node_utils.hpp\" #include <cmath> #include <memory> #include <string> #include \"nav2_core/exceptions.hpp\" #include \"nav2_custom_planner/nav2_custom_planner.hpp\" namespace nav2_custom_planner { void CustomPlanner::configure( const rclcpp_lifecycle::LifecycleNode::WeakPtr &parent, std::string name, std::shared_ptr<tf2_ros::Buffer> tf, std::shared_ptr<nav2_costmap_2d::Costmap2DROS> costmap_ros) { tf_ tf; node_ parent.lock(); name_ name; costmap_ costmap_ros >getCostmap(); global_frame_ costmap_ros >getGlobalFrameID(); // 参数初始化 nav2_util::declare_parameter_if_not_declared( node_, name_ + \".interpolation_resolution\", rclcpp::ParameterValue(0.1)); node_ >get_parameter(name_ + \".interpolation_resolution\", interpolation_resolution_); } void CustomPlanner::cleanup() { RCLCPP_INFO(node_ >get_logger(), \"正在清理类型为 CustomPlanner 的插件 %s\", name_.c_str()); } void CustomPlanner::activate() { RCLCPP_INFO(node_ >get_logger(), \"正在激活类型为 CustomPlanner 的插件 %s\", name_.c_str()); } void CustomPlanner::deactivate() { RCLCPP_INFO(node_ >get_logger(), \"正在停用类型为 CustomPlanner 的插件 %s\", name_.c_str()); } nav_msgs::msg::Path CustomPlanner::createPlan(const geometry_msgs::msg::PoseStamped &start, const geometry_msgs::msg::PoseStamped &goal) { // 1.声明并初始化 global_path nav_msgs::msg::Path global_path; return global_path; } } // namespace nav2_custom_planner #include \"pluginlib/class_list_macros.hpp\" PLUGINLIB_EXPORT_CLASS(nav2_custom_planner::CustomPlanner, nav2_core::GlobalPlanner) ``` 对应一个xml文件 ```xml <library path \"nav2_custom_planner_plugin\"> \t<class name \"nav2_custom_planner/CustomPlanner\" type \"nav2_custom_planner::CustomPlanner\" base_class_type \"nav2_core::GlobalPlanner\"> \t <description>是一个自定义示例插件，用于生成自定义路径。</description> \t</class> </library> ``` 添加Cmake文件的配置 ```cmake # 包含头文件目录 include_directories(include) # 定义库名称 set(library_name ${PROJECT_NAME}_plugin) # 创建共享库 add_library(${library_name} SHARED src/nav2_custom_planner.cpp) # 指定库的依赖关系 ament_target_dependencies(${library_name} nav2_core pluginlib) # 安装库文件到指定目录 install(TARGETS ${library_name} ARCHIVE DESTINATION lib LIBRARY DESTINATION lib RUNTIME DESTINATION lib/${PROJECT_NAME} ) # 安装头文件到指定目录 install(DIRECTORY include/ DESTINATION include/ ) # 导出插件描述文件 pluginlib_export_plugin_description_file(nav2_core custom_planner_plugin.xml) ``` 对应的插件的描述需要放在配置文件的xml里面 ```xml <export> <build_type>ament_cmake</build_type> <nav2_core plugin \"${prefix}/custom_planner_plugin.xml\" /> </export> </package> ``` ### 直线算法 ```cpp nav_msgs::msg::Path CustomPlanner::createPlan(const geometry_msgs::msg::PoseStamped &start, const geometry_msgs::msg::PoseStamped &goal) { // 1.声明并初始化 global_path nav_msgs::msg::Path global_path; global_path.poses.clear(); global_path.header.stamp node_ >now(); global_path.header.frame_id global_frame_; // 2.检查目标和起始状态是否在全局坐标系中 if (start.header.frame_id ! global_frame_) { RCLCPP_ERROR(node_ >get_logger(), \"规划器仅接受来自 %s 坐标系的起始位置\", global_frame_.c_str()); return global_path; } if (goal.header.frame_id ! global_frame_) { RCLCPP_INFO(node_ >get_logger(), \"规划器仅接受来自 %s 坐标系的目标位置\", global_frame_.c_str()); return global_path; } // 3.计算当前插值分辨率 interpolation_resolution_ 下的循环次数和步进值 // 使用欧几里得距离计算起点到终点的距离，并据此计算需要多少个插值点 int total_number_of_loop std::hypot(goal.pose.position.x start.pose.position.x, goal.pose.position.y start.pose.position.y) / interpolation_resolution_; // 计算每一步的增量 double x_increment (goal.pose.position.x start.pose.position.x) / total_number_of_loop; double y_increment (goal.pose.position.y start.pose.position.y) / total_number_of_loop; // 4. 生成路径 for (int i 0; i < total_number_of_loop; ++i) { geometry_msgs::msg::PoseStamped pose; // 生成一个点 pose.pose.position.x start.pose.position.x + x_increment * i; pose.pose.position.y start.pose.position.y + y_increment * i; pose.pose.position.z 0.0; pose.header.stamp node_ >now(); pose.header.frame_id global_frame_; // 将该点放到路径中 global_path.poses.push_back(pose); } // 5.使用 costmap 检查该条路径是否经过障碍物 for (geometry_msgs::msg::PoseStamped pose : global_path.poses) { unsigned int mx, my; // 将点的坐标转换为栅格坐标 if (costmap_ >worldToMap(pose.pose.position.x, pose.pose.position.y, mx, my)) { unsigned char cost costmap_ >getCost(mx, my); // 获取对应栅格的代价值 // 如果存在致命障碍物则抛出异常 if (cost nav2_costmap_2d::LETHAL_OBSTACLE) { RCLCPP_WARN(node_ >get_logger(),\"在(%f,%f)检测到致命障碍物，规划失败。\", pose.pose.position.x, pose.pose.position.y); throw nav2_core::PlannerException( \"无法创建目标规划: \" + std::to_string(goal.pose.position.x) + \",\" + std::to_string(goal.pose.position.y)); } } } // 6.收尾，将目标点作为路径的最后一个点并返回路径 geometry_msgs::msg::PoseStamped goal_pose goal; goal_pose.header.stamp node_ >now(); goal_pose.header.frame_id global_frame_; global_path.poses.push_back(goal_pose); return global_path; } ``` ## 使用插件 插件的使用是在planner_server里面的, 所以需要更改对应的配置 ```yaml planner_server: ros__parameters: expected_planner_frequency: 20.0 use_sim_time: True planner_plugins: [\"GridBased\"] GridBased: plugin: \"nav2_custom_planner/CustomPlanner\" interpolation_resolution: 0.1 ```"},"/note/嵌入式/ROS/ROS2/2026-1-27-37-执行器回调组.html":{"title":"执行器/回调组","content":"# 执行器/回调组 ROS2里面的执行管理是使用执行器进行管理的, 执行器底层是一个或者多个线程来调用订阅、定时器、服务的回调函数, 以及响应收到的消息和事件 ![image 20260127134805264](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601271348305.png) ![image 20260127134837579](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601271348612.png) 单线程的处理是依次判断执行的, 多线程的时候会自动开新的线程, 运行回调组织为一个组, 配合一个执行器进行使用 使用多线程的处理器, 但是使用的回调组是同一个, 并且不是可重入的, 实际使用的时候还是同一个线程里面进行处理, 多线程实际是一个线程池, 可以在初始化的时候配置线程池里面的线程数量 + MutuallyExclusiveCallbackGroup（互斥回调组）同一回调组内的所有回调函数，同一时间只能有一个在运行，其他回调必须等待当前回调执行完毕后才能触发。无并发风险：因为串行执行，组内回调访问共享资源（如全局变量、硬件接口）时，无需额外加锁，天然保证线程安全。 + ReentrantCallbackGroup（可重入回调组）同一回调组内的回调函数可以被多个线程同时执行，甚至同一个回调函数也能被 “重入” 调用（比如高频定时器回调还没执行完，下一次触发又到了） ## 回调组使用 ### python ```python import rclpy from rclpy.node import Node from rclpy.executors import MultiThreadedExecutor, SingleThreadedExecutor from rclpy.callback_groups import MutuallyExclusiveCallbackGroup, ReentrantCallbackGroup from std_msgs.msg import String from example_interfaces.srv import AddTwoInts import threading import time class LearnExecutorNode(Node): def __init__(self): super().__init__('learn_executor') self.publisher self.create_publisher(String, 'string_topic', 10) # 创建一个时钟, 使用默认的回调组 self.timer self.create_timer(1.0, self.timer_callback) # 创建一个自己的回调组 my_callback_group ReentrantCallbackGroup() # 把一个server的回调函数放进去 self.service self.create_service( AddTwoInts, 'add_two_ints', self.add_two_ints_callback, callback_group my_callback_group) # self.service self.create_service( # AddTwoInts, 'add_two_ints', self.add_two_ints_callback) def timer_callback(self): msg String() msg.data f'话题发布，线程ID:{threading.get_ident()} 线程总数:{threading.active_count()}' self.get_logger().info(msg.data) self.publisher.publish(msg) def add_two_ints_callback(self, request: AddTwoInts.Request, response: AddTwoInts.Response): self.get_logger().info(f'处理服务，线程ID:{threading.get_ident()}') time.sleep(10) # 模拟处理延时 response.sum request.a + request.b self.get_logger().info(f'处理完成，线程ID:{threading.get_ident()}') return response def main(args None): rclpy.init(args args) node LearnExecutorNode() # executor SingleThreadedExecutor() # 单线程的执行器 executor MultiThreadedExecutor(num_threads 4) # 多线程的执行器 executor.add_node(node) executor.spin() rclpy.shutdown() ``` ### cpp ```cpp #include \"example_interfaces/srv/add_two_ints.hpp\" #include \"rclcpp/rclcpp.hpp\" #include \"std_msgs/msg/string.hpp\" #include <sstream> class LearnExecutorNode : public rclcpp::Node { public: LearnExecutorNode() : Node(\"learn_executor\") { // 发布者 publisher_ this >create_publisher<std_msgs::msg::String>(\"string_topic\", 10); // 一个时钟 timer_ this >create_wall_timer( std::chrono::seconds(1), std::bind(&LearnExecutorNode::timer_callback, this)); // 自定义一个回调组 service_callback_group_ this >create_callback_group( rclcpp::CallbackGroupType::MutuallyExclusive); // 互斥回调组 service_ this >create_service<example_interfaces::srv::AddTwoInts>( \"add_two_ints\", std::bind(&LearnExecutorNode::add_two_ints_callback, this, std::placeholders::_1, std::placeholders::_2), rmw_qos_profile_services_default, service_callback_group_); } private: void timer_callback() { auto msg std_msgs::msg::String(); msg.data \"话题发布：\" + thread_info(); RCLCPP_INFO(this >get_logger(), msg.data.c_str()); publisher_ >publish(msg); } std::string thread_info() { std::ostringstream thread_str; thread_str << \"线程ID：\" << std::this_thread::get_id(); return thread_str.str(); } void add_two_ints_callback( const std::shared_ptr<example_interfaces::srv::AddTwoInts::Request> request, std::shared_ptr<example_interfaces::srv::AddTwoInts::Response> response) { RCLCPP_INFO(this >get_logger(), \"服务开始处理：%s\", thread_info().c_str()); // 模拟一个长时间的处理 std::this_thread::sleep_for(std::chrono::seconds(10)); response >sum request >a + request >b; RCLCPP_INFO(this >get_logger(), \"服务处理完成：%s\", thread_info().c_str()); } rclcpp::Publisher<std_msgs::msg::String>::SharedPtr publisher_; rclcpp::TimerBase::SharedPtr timer_; rclcpp::Service<example_interfaces::srv::AddTwoInts>::SharedPtr service_; rclcpp::CallbackGroup::SharedPtr service_callback_group_; }; int main(int argc, char *argv[]) { rclcpp::init(argc, argv); auto node std::make_shared<LearnExecutorNode>(); // 两种执行器 // auto executor rclcpp::executors::SingleThreadedExecutor(); auto executor rclcpp::executors::MultiThreadedExecutor(); executor.add_node(node); executor.spin(); rclcpp::shutdown(); return 0; } ```"},"/note/嵌入式/ROS/ROS2/2026-1-15-08-动作.html":{"title":"动作","content":"# 动作 实现一个完整的动作流程管理, 在运动过程中可以把控运动的进度以及随时取消 需要有一个反馈, 随时告知实际的运动状态 动作和服务类似，使用的也是客户端和服务器模型，客户端发送动作的目标，想让机器人干什么，服务器端执行动作过程， 控制机器人达到运动的目标，同时周期反馈动作执行过程中的状态 客户端发送一个运动的目标，想让机器人动起来，服务器端收到之后，就开始控制机器人运动，一边运动，一边反馈当前的状态，如果是一个导航动作，这个反馈可能是当前所处的坐标，如果是机械臂抓取，这个反馈可能又是机械臂的实时姿态。当运动执行结束后，服务器再反馈一个动作结束的信息。整个通信过程就此结束。 和服务一样，动作通信中的客户端可以有多个，大家都可以发送运动命令，但是服务器端只能有一个, 先执行完成一个动作，才能执行下一个动作。 ![image8](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601151945488.gif) 使用两个服务以及一个Topic, 发送一个服务, 开启运动, 之后发送接受结束状态的服务, 同时订阅Topic, 动作完成之后获取到结束的服务返回 ## 命令行 ```bash (base) jiao@jiao virtual machine:~/ros$ ros2 action list /turtle1/rotate_absolute (base) jiao@jiao virtual machine:~/ros$ ros2 action info /turtle1/rotate_absolute Action: /turtle1/rotate_absolute Action clients: 0 Action servers: 1 /turtlesim (base) jiao@jiao virtual machine:~/ros$ ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute \"{theta: 3.14}\" Waiting for an action server to become available... Sending goal: theta: 3.14 Goal accepted with ID: 2415d93453014a59be77201b67aaea82 [INFO] [1768478139.297624195] [turtlesim]: Rotation goal completed successfully Result: delta: 3.135999917984009 Goal finished with status: SUCCEEDED (base) jiao@jiao virtual machine:~/ros$ ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute \"{theta: 0}\" feedback Waiting for an action server to become available... Sending goal: theta: 0.0 Feedback: remaining: 3.135999917984009 Goal accepted with ID: b9796b29259c4c199f7e83a285fa0c0e Feedback: remaining: 3.119999885559082 Feedback: remaining: 3.1040000915527344 ... [INFO] [1768478203.632885310] [turtlesim]: Rotation goal completed successfully Feedback: remaining: 0.01600000075995922 Result: delta: 3.119999885559082 Goal finished with status: SUCCEEDED ``` ## 代码实现 ![image 20220528010217043](https://book.guyuehome.com/ROS2/2.%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/image/2.7_%E5%8A%A8%E4%BD%9C/image 20220528010217043.png) ### action数据 ```yaml bool enable # 定义动作的目标，表示动作开始的指令 bool finish # 定义动作的结果，表示是否成功执行 int32 state # 定义动作的反馈，表示当前执行到的位置 ``` ### Client ```python import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from rclpy.action import ActionClient # ROS2 动作客户端类 from learning_interface.action import MoveCircle # 自定义的圆周运动接口 class MoveCircleActionClient(Node): def __init__(self, name): super().__init__(name) # 创建动作客户端（接口类型、动作名） self._action_client ActionClient( self, MoveCircle, 'move_circle') def send_goal(self, enable): # 创建一个动作目标的消息 goal_msg MoveCircle.Goal() goal_msg.enable enable \t\t# 等待动作的服务器端启动 self._action_client.wait_for_server() # 异步方式发送动作的目标 self._send_goal_future self._action_client.send_goal_async( goal_msg, feedback_callback self.feedback_callback) self._send_goal_future.add_done_callback(self.goal_response_callback) # 设置一个服务器收到目标之后反馈时的回调函数 \t# 创建一个服务器收到目标之后反馈时的回调函数 def goal_response_callback(self, future): # 接收动作的结果 goal_handle future.result() # 如果动作被拒绝执行 if not goal_handle.accepted: self.get_logger().info('Goal rejected :(') return \t\t# 动作被顺利执行 self.get_logger().info('Goal accepted :)') # 异步获取动作最终执行的结果反馈 self._get_result_future goal_handle.get_result_async() # 设置一个收到最终结果的回调函数 self._get_result_future.add_done_callback( self.get_result_callback) def get_result_callback(self, future): # 读取动作执行的结果 result future.result().result self.get_logger().info('Result: {%d}' % result.finish) def feedback_callback(self, feedback_msg): # 读取反馈的数据 feedback feedback_msg.feedback self.get_logger().info('Received feedback: {%d}' % feedback.state) def main(args None): rclpy.init(args args) # 创建ROS2节点对象并进行初始化 node MoveCircleActionClient(\"action_move_client\") # 发送动作目标 node.send_goal(True) rclpy.spin(node) node.destroy_node() rclpy.shutdown() ``` ### Server ```python import time import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from rclpy.action import ActionServer # ROS2 动作服务器类 from learning_interface.action import MoveCircle # 自定义的圆周运动接口 class MoveCircleActionServer(Node): def __init__(self, name): super().__init__(name) # 创建动作服务器（接口类型、动作名、回调函数） self._action_server ActionServer( self, MoveCircle, 'move_circle', self.execute_callback) \t# 执行收到动作目标之后的处理函数 def execute_callback(self, goal_handle): self.get_logger().info('Moving circle...') # 创建一个动作反馈信息的消息 feedback_msg MoveCircle.Feedback() # 从0到360度，执行圆周运动，并周期反馈信息 for i in range(0, 360, 30): # 创建反馈信息，表示当前执行到的角度 feedback_msg.state i self.get_logger().info('Publishing feedback: %d' % feedback_msg.state) goal_handle.publish_feedback(feedback_msg) # 发布反馈信息 time.sleep(0.5) # 动作执行成功 goal_handle.succeed() # 创建结果消息 result MoveCircle.Result() result.finish True return result def main(args None): rclpy.init(args args) node MoveCircleActionServer(\"action_move_server\") rclpy.spin(node) node.destroy_node() rclpy.shutdown() ```"},"/note/嵌入式/ROS/ROS2/2026-1-15-05-话题topic.html":{"title":"话题","content":"# 话题 实现节点之间的数据传输, 实现异步通信 ## 实现 ### 发布者 ```python import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from std_msgs.msg import String # 字符串消息类型 \"\"\" 创建一个发布者节点 \"\"\" class PublisherNode(Node): def __init__(self, name): # ROS2节点父类初始化 super().__init__(name) # 创建发布者对象（消息类型、话题名、队列长度） self.pub self.create_publisher(String, \"chatter\", 10) # 创建一个定时器（单位为秒的周期，定时执行的回调函数） self.timer self.create_timer(0.5, self.timer_callback) # 创建定时器周期执行的回调函数 def timer_callback(self): # 创建一个String类型的消息对象 msg String() # 填充消息对象中的消息数据 msg.data 'Hello World' # 发布话题消息 self.pub.publish(msg) # 输出日志信息，提示已经完成话题发布 self.get_logger().info('Publishing: \"%s\"' % msg.data) # ROS2节点主入口main函数 def main(args None): # ROS2 Python接口初始化 rclpy.init(args args) # 创建ROS2节点对象并进行初始化 node PublisherNode(\"topic_helloworld_pub\") rclpy.spin(node) # 循环等待ROS2退出 node.destroy_node() # 销毁节点对象 rclpy.shutdown() # 关闭ROS2 Python接口 ``` ### 接受者 ```python import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from std_msgs.msg import String # ROS2标准定义的String消息 \"\"\" 创建一个订阅者节点 \"\"\" class SubscriberNode(Node): def __init__(self, name): super().__init__(name) # 创建订阅者对象（消息类型、话题名、订阅者回调函数、队列长度） self.sub self.create_subscription(\\ String, \"chatter\", self.listener_callback, 10) \t# 创建回调函数，执行收到话题消息后对数据的处理 def listener_callback(self, msg): # 输出日志信息，提示订阅收到的话题消息 self.get_logger().info('I heard: \"%s\"' % msg.data) # ROS2节点主入口main函数 def main(args None): # ROS2 Python接口初始化 rclpy.init(args args) # 创建ROS2节点对象并进行初始化 node SubscriberNode(\"topic_helloworld_sub\") rclpy.spin(node) # 循环等待ROS2退出 node.destroy_node() # 销毁节点对象 rclpy.shutdown() # 关闭ROS2 Python接口 ``` ### 传输图像示例 ```python import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from sensor_msgs.msg import Image # 图像消息类型 from cv_bridge import CvBridge # ROS与OpenCV图像转换类 import cv2 # Opencv图像处理库 \"\"\" 创建一个发布者节点 \"\"\" class ImagePublisher(Node): def __init__(self, name): super().__init__(name) # 创建发布者对象（消息类型、话题名、队列长度） self.publisher_ self.create_publisher(Image, 'image_raw', 10) self.timer self.create_timer(0.1, self.timer_callback) # 创建一个视频采集对象，驱动相机采集图像（相机设备号） self.cap cv2.VideoCapture(0) # 创建一个图像转换对象，用于稍后将OpenCV的图像转换成ROS的图像消息 self.cv_bridge CvBridge() def timer_callback(self): ret, frame self.cap.read() if ret True: # 发布图像消息 self.publisher_.publish( self.cv_bridge.cv2_to_imgmsg(frame, 'bgr8')) # 输出日志信息，提示已经完成图像话题发布 self.get_logger().info('Publishing video frame') def main(args None): rclpy.init(args args) node ImagePublisher(\"topic_webcam_pub\") rclpy.spin(node) node.destroy_node() rclpy.shutdown() ``` ```python import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from sensor_msgs.msg import Image # 图像消息类型 from cv_bridge import CvBridge # ROS与OpenCV图像转换类 import cv2 # Opencv图像处理库 import numpy as np # Python数值计算库 lower_red np.array([0, 90, 128]) # 红色的HSV阈值下限 upper_red np.array([180, 255, 255]) # 红色的HSV阈值上限 \"\"\" 创建一个订阅者节点 \"\"\" class ImageSubscriber(Node): def __init__(self, name): # ROS2节点父类初始化 super().__init__(name) # 创建订阅者对象（消息类型、话题名、订阅者回调函数、队列长度） self.sub self.create_subscription( Image, 'image_raw', self.listener_callback, 10) # 创建一个图像转换对象，用于OpenCV图像与ROS的图像消息的互相转换 self.cv_bridge CvBridge() def object_detect(self, image): # 图像从BGR颜色模型转换为HSV模型 hsv_img cv2.cvtColor(image, cv2.COLOR_BGR2HSV) # 图像二值化 mask_red cv2.inRange(hsv_img, lower_red, upper_red) # 图像中轮廓检测 contours, hierarchy cv2.findContours( mask_red, cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE) \t\t# 去除一些轮廓面积太小的噪声 for cnt in contours: if cnt.shape[0] < 150: continue \t\t\t# 得到苹果所在轮廓的左上角xy像素坐标及轮廓范围的宽和高 (x, y, w, h) cv2.boundingRect(cnt) # 将苹果的轮廓勾勒出来 cv2.drawContours(image, [cnt], 1, (0, 255, 0), 2) # 将苹果的图像中心点画出来 cv2.circle(image, (int(x+w/2), int(y+h/2)), 5, (0, 255, 0), 1) \t\t# 使用OpenCV显示处理后的图像效果 cv2.imshow(\"object\", image) cv2.waitKey(10) def listener_callback(self, data): # 输出日志信息，提示已进入回调函数 self.get_logger().info('Receiving video frame') # 将ROS的图像消息转化成OpenCV图像 image self.cv_bridge.imgmsg_to_cv2(data, 'bgr8') # 苹果检测 self.object_detect(image) def main(args None): rclpy.init(args args) node ImageSubscriber(\"topic_webcam_sub\") rclpy.spin(node) node.destroy_node() rclpy.shutdown() ``` ### 通用USB相机驱动 ```bash # 通用的相机驱动 $ sudo apt install ros humble usb cam # 发布摄像头在image_raw节点 $ ros2 run usb_cam usb_cam_node_exe ``` ### cpp ```cpp #include <chrono> #include <functional> #include <memory> #include <string> #include \"rclcpp/rclcpp.hpp\" // ROS2 C++接口库 #include \"std_msgs/msg/string.hpp\" // 字符串消息类型 using namespace std::chrono_literals; class PublisherNode : public rclcpp::Node { public: PublisherNode() : Node(\"topic_helloworld_pub\") // ROS2节点父类初始化 { // 创建发布者对象（消息类型、话题名、队列长度） publisher_ this >create_publisher<std_msgs::msg::String>(\"chatter\", 10); // 创建一个定时器,定时执行回调函数 timer_ this >create_wall_timer( 500ms, std::bind(&PublisherNode::timer_callback, this)); } private: // 创建定时器周期执行的回调函数 void timer_callback() { // 创建一个String类型的消息对象 auto msg std_msgs::msg::String(); // 填充消息对象中的消息数据 msg.data \"Hello World\"; // 发布话题消息 RCLCPP_INFO(this >get_logger(), \"Publishing: '%s'\", msg.data.c_str()); // 输出日志信息，提示已经完成话题发布 publisher_ >publish(msg); } // 定时器指针 rclcpp::TimerBase::SharedPtr timer_; \t// 发布者指针 \trclcpp::Publisher<std_msgs::msg::String>::SharedPtr publisher_; }; // ROS2节点主入口main函数 int main(int argc, char * argv[]) { // ROS2 C++接口初始化 rclcpp::init(argc, argv); // 创建ROS2节点对象并进行初始化 rclcpp::spin(std::make_shared<PublisherNode>()); // 关闭ROS2 C++接口 rclcpp::shutdown(); return 0; } ```"},"/note/嵌入式/ROS/ROS2/2026-1-17-14-机器人建模.html":{"title":"机器人建模","content":"# 机器人建模 描述一个机器人的外观性能等属性, 机器人一般是由**硬件结构、驱动系统、传感器系统、控制系统**四大部分组成 硬件结构就是底盘、外壳、电机等实打实可以看到的设备； 驱动系统就是可以驱使这些设备正常使用的装置，比如电机的驱动器，电源管理系统等； 传感系统包括电机上的编码器、板载的IMU、安装的摄像头、雷达等等，便于机器人感知自己的状态和外部的环境； 控制系统就是我们开发过程的主要载体了，一般是树莓派、电脑等计算平台，以及里边的操作系统和应用软件。 机器人建模的过程，其实就是按照类似的思路，通过建模语言，把机器人每一个部分都描述清楚，再组合起来的过程 ## URDF ROS中的建模方法叫做**URDF**，全称是**统一机器人描述格式**，不仅可以清晰描述机器人自身的模型，还可以描述机器人的外部环境，比如桌子，也可以算作一个模型 ![image 20260117154356642](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601171543699.png) URDF模型文件使用的是**XML格式**, 都是由一系列尖括号包围的标签和其中的属性组合而成。 ```xml <?xml version \"1.0\"?> <robot name \"first_robot\"> <! XML 注释 > <link name \"base_link\"></link> </robot> ``` 在建模中，大臂和小臂就类似机器人的这些独立的刚体部分，称为**连杆Link**，手肘就类似于机器人电机驱动部分，称为**关节joint**。 所以在URDF建模过程中，关键任务就是通过`<link>`和`<joint>`，理清楚每一个连杆和关节的描述信息。 ![image 20220528144424329](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601171550527.png) ### **连杆**link `<link>`标签用来描述机器人某个刚体部分的**外观和物理属性**，外观包括尺寸、颜色、形状，物理属性包括质量、惯性矩阵、碰撞参数等 ![image 20260117154604123](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601171546169.png) ![image 20220528144549092](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601171550503.png) + visual: 描述的是机器人的外观, 使用一个3D模型的文件建模 + + <geometry>表示**几何形状**，里边使用<mesh>调用了一个在三维软件中提前设计好的蓝色外观，就是这个stl文件，看上去和真实机器人是一致的 + <origin>表示**坐标系相对初始位置的偏移**，分别是x、y、z方向上的平移，和roll、pitch、raw旋转，不需要偏移的话，就全为0。 + collision: 描述的是机器人的物理属性, 描述**碰撞参数**, 可以和visual一样, 看起来和碰撞是一样的 + + <visual>部分重在描述机器人碰撞体积的描述, 这里简化为一个长方体 + <collision>部分则是描述机器人运动过程中的状态，比如机器人与外界如何接触算作碰撞 ### Joint关节 机器人模型中的刚体最终要通过关节joint连接之后，才能产生相对运动, URDF中的关节有六种运动类型 ![image 20220528144655899](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601171550490.png) 1. continuous，描述旋转运动，可以围绕某一个轴无限旋转，比如小车的轮子，就属于这种类型。 2. revolute，也是旋转关节，和continuous类型的区别在于不能无限旋转，而是带有角度限制，比如机械臂的两个连杆，就属于这种运动。 3. prismatic，是滑动关节，可以沿某一个轴平移，也带有位置的极限，一般直线电机就是这种运动方式。 4. fixed，固定关节，是唯一一种不允许运动的关节，不过使用还是比较频繁的，比如相机这个连杆，安装在机器人上，相对位置是不会变化的，此时使用的连接方式就是Fixed。 5. Floating是浮动关节，第六种planar是平面关节，这两种使用相对较少。 在URDF模型中，每一个link都使用这样一段xml内容描述，比如关节的名字叫什么，运动类型是哪一种 ![image 20220528144729633](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601171550837.png) parent标签：描述父连杆； child标签：描述子连杆，子连杆会相对父连杆发生运动； origin：表示两个连杆坐标系之间的关系，也就是图中红色的向量，可以理解为这两个连杆该如何安装到一起； axis表示关节运动轴的单位向量，比如z等于1，就表示这个旋转运动是围绕z轴的正方向进行的； limit就表示运动的一些限制了，比如最小位置，最大位置，和最大速度等。 ### robot 最终所有的link和joint标签完成了对机器人每个部分的描述和组合，全都放在一个robot标签中，就形成了完整的机器人模型 ## 示例 ```bash ros2 launch learning_urdf display.launch.py ``` ![image 20260117155544819](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601171555919.png) ### 启动文件 ```python from ament_index_python.packages import get_package_share_path from launch import LaunchDescription from launch.actions import DeclareLaunchArgument from launch.conditions import IfCondition, UnlessCondition from launch.substitutions import Command, LaunchConfiguration from launch_ros.actions import Node from launch_ros.parameter_descriptions import ParameterValue def generate_launch_description(): urdf_tutorial_path get_package_share_path('learning_urdf') default_model_path urdf_tutorial_path / 'urdf/mbot_base.urdf' default_rviz_config_path urdf_tutorial_path / 'rviz/urdf.rviz' gui_arg DeclareLaunchArgument(name 'gui', default_value 'false', choices ['true', 'false'], description 'Flag to enable joint_state_publisher_gui') model_arg DeclareLaunchArgument(name 'model', default_value str(default_model_path), description 'Absolute path to robot urdf file') rviz_arg DeclareLaunchArgument(name 'rvizconfig', default_value str(default_rviz_config_path), description 'Absolute path to rviz config file') robot_description ParameterValue(Command(['xacro ', LaunchConfiguration('model')]), value_type str) robot_state_publisher_node Node( package 'robot_state_publisher', executable 'robot_state_publisher', parameters [{'robot_description': robot_description}] ) # Depending on gui parameter, either launch joint_state_publisher or joint_state_publisher_gui joint_state_publisher_node Node( package 'joint_state_publisher', executable 'joint_state_publisher', condition UnlessCondition(LaunchConfiguration('gui')) ) joint_state_publisher_gui_node Node( package 'joint_state_publisher_gui', executable 'joint_state_publisher_gui', condition IfCondition(LaunchConfiguration('gui')) ) rviz_node Node( package 'rviz2', executable 'rviz2', name 'rviz2', output 'screen', arguments [' d', LaunchConfiguration('rvizconfig')], ) return LaunchDescription([ gui_arg, model_arg, rviz_arg, joint_state_publisher_node, joint_state_publisher_gui_node, robot_state_publisher_node, rviz_node ]) ``` ### 模型描述 ```xml <?xml version \"1.0\" ?> <robot name \"mbot\"> <link name \"base_link\"> <visual> <origin xyz \" 0 0 0\" rpy \"0 0 0\" /> <geometry> <cylinder length \"0.16\" radius \"0.20\"/> </geometry> <material name \"yellow\"> <color rgba \"1 0.4 0 1\"/> </material> </visual> </link> <joint name \"left_wheel_joint\" type \"continuous\"> <origin xyz \"0 0.19 0.05\" rpy \"0 0 0\"/> <parent link \"base_link\"/> <child link \"left_wheel_link\"/> <axis xyz \"0 1 0\"/> </joint> <link name \"left_wheel_link\"> <visual> <origin xyz \"0 0 0\" rpy \"1.5707 0 0\" /> <geometry> <cylinder radius \"0.06\" length \"0.025\"/> </geometry> <material name \"white\"> <color rgba \"1 1 1 0.9\"/> </material> </visual> </link> <joint name \"right_wheel_joint\" type \"continuous\"> <origin xyz \"0 0.19 0.05\" rpy \"0 0 0\"/> <parent link \"base_link\"/> <child link \"right_wheel_link\"/> <axis xyz \"0 1 0\"/> </joint> <link name \"right_wheel_link\"> <visual> <origin xyz \"0 0 0\" rpy \"1.5707 0 0\" /> <geometry> <cylinder radius \"0.06\" length \"0.025\"/> </geometry> <material name \"white\"> <color rgba \"1 1 1 0.9\"/> </material> </visual> </link> <joint name \"front_caster_joint\" type \"continuous\"> <origin xyz \"0.18 0 0.095\" rpy \"0 0 0\"/> <parent link \"base_link\"/> <child link \"front_caster_link\"/> <axis xyz \"0 1 0\"/> </joint> <link name \"front_caster_link\"> <visual> <origin xyz \"0 0 0\" rpy \"0 0 0\"/> <geometry> <sphere radius \"0.015\" /> </geometry> <material name \"black\"> <color rgba \"0 0 0 0.95\"/> </material> </visual> </link> <joint name \"back_caster_joint\" type \"continuous\"> <origin xyz \" 0.18 0 0.095\" rpy \"0 0 0\"/> <parent link \"base_link\"/> <child link \"back_caster_link\"/> <axis xyz \"0 1 0\"/> </joint> <link name \"back_caster_link\"> <visual> <origin xyz \"0 0 0\" rpy \"0 0 0\"/> <geometry> <sphere radius \"0.015\" /> </geometry> <material name \"black\"> <color rgba \"0 0 0 0.95\"/> </material> </visual> </link> </robot> ``` 这一使用工具辅助查看 ```bash urdf_to_graphiz mbot_base.urdf ``` ![image 20260117160938759](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601171609836.png) ## 自定义bot ```bash ros2 pkg create bot_3D_desc build type ament_cmake ``` ![image 20260121114509772](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601211145859.png) ```cmake install(DIRECTORY launch urdf config DESTINATION share/${PROJECT_NAME} ) ``` ### 机器人描述 ```xml <?xml version \"1.0\"?> <robot name \"first_robot\"> <! 身体部分 > <link name \"base_link\"> <! 外观描述 > <visual> <! 描述沿着自己几何中心的位移以及旋转 > <origin xyz \"0.0 0.0 0.0\" rpy \"0.0 0.0 0.0\"/> <! 形状描述, 单位 米 > <geometry> <cylinder radius \"0.10\" length \"0.12\"/> </geometry> <! 颜色描述 > <material name \"white\"> <color rgba \"1.0 1.0 1.0 0.5\"/> </material> </visual> </link> <! 机器人的IMU, 惯性测量传感器 > <link name \"imu_link\"> <! 外观描述 > <visual> <! 描述沿着自己几何中心的位移以及旋转 > <origin xyz \"0.0 0.0 0.0\" rpy \"0.0 0.0 0.0\"/> <! 形状描述, 单位 米 正方体 > <geometry> <box size \"0.02 0.02 0.02\"/> </geometry> <! 颜色描述 > <material name \"black\"> <color rgba \"0.0 0.0 0.0 0.5\"/> </material> </visual> </link> <! 连接身体和IMU的关节, 把IMU固定在身体上 > <joint name \"imu_joint\" type \"fixed\"> <origin xyz \"0.0 0.0 0.3\" rpy \"0.0 0.0 0.0\"/> <parent link \"base_link\"/> <child link \"imu_link\"/> </joint> </robot> ``` ### 生成 ```bash # 结构可视化pdf urdf_to_graphviz bot_3D_desc/urdf/first_robot.urdf ``` ![image 20260121114900192](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601211149274.png) ![image 20260121115218556](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601211152725.png) ![image 20260121115348640](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601211153699.png) ![image 20260121115509513](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601211155657.png) ### 添加位置描述 默认这个程序不解析配置文件里面的位置信息, 可以使用两个节点进行发布 ```bash sudo apt get install ros $ROS_DISTRO joint state publisher sudo apt get install ros $ROS_DISTRO robot state publisher ``` ```bash import launch import launch_ros from ament_index_python.packages import get_package_share_directory import os def generate_launch_description(): pkg_share get_package_share_directory('bot_3D_desc') default_urdf_file_path os.path.join(pkg_share, 'urdf', 'first_robot.urdf') default_rviz_config_path os.path.join(pkg_share, 'config', 'display_robot.rviz') # 构建一个参数可以供外部传入URDF文件路径 action_declear_arg_mode_path launch.actions.DeclareLaunchArgument( name \"model\", default_value default_urdf_file_path, description \"Absolute path to robot urdf file\" ) # 读取文件的内容作为参数值 command_result launch.substitutions.Command( ['cat ', launch.substitutions.LaunchConfiguration('model')] ) robot_desc_value launch_ros.parameter_descriptions.ParameterValue( command_result, value_type str ) # 节点：用于发布机器人状态信息 action_robot_state_publisher launch_ros.actions.Node( package 'robot_state_publisher', executable 'robot_state_publisher', name 'robot_state_publisher', parameters [{'robot_description': robot_desc_value}] ) action_joint_state_publisher launch_ros.actions.Node( package 'joint_state_publisher', executable 'joint_state_publisher', name 'joint_state_publisher', ) action_rviz_node launch_ros.actions.Node( package 'rviz2', executable 'rviz2', name 'rviz2', arguments [' d', default_rviz_config_path], ) return launch.LaunchDescription([ action_declear_arg_mode_path, action_robot_state_publisher, action_joint_state_publisher, action_rviz_node ]) ``` ```bash ros2 launch bot_3D_desc display_robot.launch.py ``` ![image 20260121122828182](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601211228316.png) 可以保存一下配置在config文件夹里面, 在参数里面设置加载"},"/note/嵌入式/ROS/ROS2/2026-1-15-06-服务Server.html":{"title":"Server","content":"# Server 节点之间的双向交流, 实现同步的通信C/S通信格式 ## 实际实现 ### 客户端 ```python import sys import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from learning_interface.srv import AddTwoInts # 自定义的服务接口 class adderClient(Node): def __init__(self, name): super().__init__(name) # 创建服务客户端对象（服务接口类型，服务名） self.client self.create_client(AddTwoInts, 'add_two_ints') # 循环等待服务器端成功启动 while not self.client.wait_for_service(timeout_sec 1.0): self.get_logger().info('service not available, waiting again...') # 创建服务请求的数据对象 self.request AddTwoInts.Request() def send_request(self): # 创建一个发送服务请求的函数 self.request.a int(sys.argv[1]) self.request.b int(sys.argv[2]) # 异步方式发送服务请求 self.future self.client.call_async(self.request) def main(args None): rclpy.init(args args) node adderClient(\"service_adder_client\") node.send_request() # 发送服务请求 while rclpy.ok(): # 循环执行一次节点 rclpy.spin_once(node) # 数据是否处理完成 if node.future.done(): try: # 接收服务器端的反馈数据 response node.future.result() except Exception as e: node.get_logger().info('Service call failed %r' % (e,)) else: node.get_logger().info( 'Result of add_two_ints: for %d + %d %d' % (node.request.a, node.request.b, response.sum)) break # 销毁节点对象 node.destroy_node() rclpy.shutdown() ``` ```python # 异步方式发送服务请求 self.future self.client.call_async(self.request) rclpy.spin_until_future_complete(self, future) ``` ```python def result_callback(result_future): \tpass future.add_done_callback(result_callback) ``` ### 服务器 ```python import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from learning_interface.srv import AddTwoInts # 自定义的服务接口 class adderServer(Node): def __init__(self, name): super().__init__(name) # 创建服务器对象（接口类型、服务名、服务器回调函数） self.srv self.create_service(AddTwoInts, 'add_two_ints', self.adder_callback) def adder_callback(self, request, response): response.sum request.a + request.b self.get_logger().info('Incoming request\\na: %d b: %d' % (request.a, request.b)) # 输出日志信息，提示已经完成加法求和计算 return response def main(args None): rclpy.init(args args) node adderServer(\"service_adder_server\") rclpy.spin(node) node.destroy_node() rclpy.shutdown() ``` ### cpp ```cpp #include \"rclcpp/rclcpp.hpp\" // ROS2 C++接口库 #include \"learning_interface/srv/add_two_ints.hpp\" // 自定义的服务接口 #include <chrono> #include <cstdlib> #include <memory> using namespace std::chrono_literals; int main(int argc, char **argv) { // ROS2 C++接口初始化 rclcpp::init(argc, argv); if (argc ! 3) { RCLCPP_INFO(rclcpp::get_logger(\"rclcpp\"), \"usage: service_adder_client X Y\"); return 1; } // 创建ROS2节点对象并进行初始化 std::shared_ptr<rclcpp::Node> node rclcpp::Node::make_shared(\"service_adder_client\"); // 创建服务客户端对象（服务接口类型，服务名） rclcpp::Client<learning_interface::srv::AddTwoInts>::SharedPtr client node >create_client<learning_interface::srv::AddTwoInts>(\"add_two_ints\"); // 创建服务接口数据 auto request std::make_shared<learning_interface::srv::AddTwoInts::Request>(); request >a atoll(argv[1]); request >b atoll(argv[2]); // 循环等待服务器端成功启动 while (!client >wait_for_service(1s)) { if (!rclcpp::ok()) { RCLCPP_ERROR(rclcpp::get_logger(\"rclcpp\"), \"Interrupted while waiting for the service. Exiting.\"); return 0; } RCLCPP_INFO(rclcpp::get_logger(\"rclcpp\"), \"service not available, waiting again...\"); } // 异步方式发送服务请求 auto result client >async_send_request(request); // 接收服务器端的反馈数据 if (rclcpp::spin_until_future_complete(node, result) rclcpp::FutureReturnCode::SUCCESS) { // 将收到的反馈信息打印输出 RCLCPP_INFO(rclcpp::get_logger(\"rclcpp\"), \"Sum: %ld\", result.get() >sum); } else { RCLCPP_ERROR(rclcpp::get_logger(\"rclcpp\"), \"Failed to call service add_two_ints\"); } // 关闭ROS2 C++接口 rclcpp::shutdown(); return 0; } ``` ```cpp #include \"rclcpp/rclcpp.hpp\" // ROS2 C++接口库 #include \"learning_interface/srv/add_two_ints.hpp\" // 自定义的服务接口 #include <memory> // 创建回调函数，执行收到请求后对数据的处理 void adderServer(const std::shared_ptr<learning_interface::srv::AddTwoInts::Request> request, std::shared_ptr<learning_interface::srv::AddTwoInts::Response> response) { // 完成加法求和计算，将结果放到反馈的数据中 response >sum request >a + request >b; // 输出日志信息，提示已经完成加法求和计算 RCLCPP_INFO(rclcpp::get_logger(\"rclcpp\"), \"Incoming request\\na: %ld\" \" b: %ld\", request >a, request >b); RCLCPP_INFO(rclcpp::get_logger(\"rclcpp\"), \"sending back response: [%ld]\", (long int)response >sum); } // ROS2节点主入口main函数 int main(int argc, char **argv) { // ROS2 C++接口初始化 rclcpp::init(argc, argv); // 创建ROS2节点对象并进行初始化 std::shared_ptr<rclcpp::Node> node rclcpp::Node::make_shared(\"service_adder_server\"); // 创建服务器对象（接口类型、服务名、服务器回调函数） rclcpp::Service<learning_interface::srv::AddTwoInts>::SharedPtr service node >create_service<learning_interface::srv::AddTwoInts>(\"add_two_ints\", &adderServer); RCLCPP_INFO(rclcpp::get_logger(\"rclcpp\"), \"Ready to add two ints.\"); rclcpp::spin(node); rclcpp::shutdown(); } ```"},"/note/嵌入式/ROS/ROS2/2026-1-27-36-坐标系建图.html":{"title":"坐标系","content":"# 坐标系 开发板上面的雷达通过串口以及转接板连接到WIFI转接板, 在电脑模拟出串口, 发送给雷达驱动, 发布/scan话题 <img src \"https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601271222243.png\" alt \"image 20260127122231167\" style \"zoom:150%;\" /> URDF文件用于描述机器人的模型, 通过和URDF文件+robot_state_publisher节点就可以发布基坐标系以及各个组件之间的变化 odom和base_link之间的变化需要自己去发布 在建图的时候使用slam_toolbox进行发布map到odom之间的关系, 实际使用的时候使用nav2功能包进行 ## 建图 建图的时候需要使用的节点有 + cmd_vel: 小车的控制 + odom: 里程计 + robot_description: 外形描述 + scan: 激光扫描器 + tf: 坐标系 之后启动slam_toolbox建图即可"},"/note/嵌入式/ROS/ROS2/2026-1-21-20-rviz.html":{"title":"rviz","content":"# rviz ```bash rviz2 ``` ![image 20260121105746440](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601211057575.png) 可以使用` d`参数添加配置文件"},"/note/嵌入式/ROS/ROS2/2026-1-27-38-生命周期节点.html":{"title":"生命周期节点","content":"# 生命周期节点 普通 ROS 2 节点启动后会直接进入 “运行” 状态，只有 “启动” 和 “终止” 两种状态，缺少标准化的 “初始化→配置→运行→清理” 流程（比如机器人节点需要先加载参数、初始化硬件，再真正运行；出错后也没法优雅重置，只能重启整个节点）。 而**生命周期节点**的核心价值，就是给节点引入了**标准化的状态机管理机制**，把节点的运行过程拆分为多个可管控、可切换的状态，实现对节点行为的精细化控制。 ![image 20260127155132120](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601271559045.png) 有一个示例程序 ```bash ros2 run lifecycle lifecycle_talker ``` 相比于普通的节点多出来话题以及service ```bash (base) jiao@jiao virtual machine:~$ ros2 service list /lc_talker/change_state # /lc_talker/describe_parameters /lc_talker/get_available_states # /lc_talker/get_available_transitions /lc_talker/get_parameter_types /lc_talker/get_parameters /lc_talker/get_state # /lc_talker/get_transition_graph /lc_talker/list_parameters /lc_talker/set_parameters /lc_talker/set_parameters_atomically # 获取一下当前的状态 (base) jiao@jiao virtual machine:~$ ros2 service call /lc_talker/get_state lifecycle_msgs/srv/GetState waiting for service to become available... requester: making request: lifecycle_msgs.srv.GetState_Request() response: lifecycle_msgs.srv.GetState_Response(current_state lifecycle_msgs.msg.State(id 1, label 'unconfigured')) ``` 这个节点目前是未配置状态 可以配置的状态有 ```bash (base) jiao@jiao virtual machine:~$ ros2 lifecycle list /lc_talker configure [1] # 进入配置激活 \tStart: unconfigured \tGoal: configuring shutdown [5] # 关闭 \tStart: unconfigured \tGoal: shuttingdown (base) jiao@jiao virtual machine:~$ ros2 lifecycle set /lc_talker configure Transitioning successful # 进入配置状态 (base) jiao@jiao virtual machine:~$ ros2 lifecycle set /lc_talker configure Transitioning successful (base) jiao@jiao virtual machine:~$ ros2 service call /lc_talker/get_state lifecycle_msgs/srv/GetState waiting for service to become available... requester: making request: lifecycle_msgs.srv.GetState_Request() response: lifecycle_msgs.srv.GetState_Response(current_state lifecycle_msgs.msg.State(id 2, label 'inactive')) ``` 这时候可以看到一个新的话题`/lifecycle_chatter`, 但是没有发布的消息 ```bash (base) jiao@jiao virtual machine:~$ ros2 lifecycle set /lc_talker activate # 配置为激活 (base) jiao@jiao virtual machine:~$ ros2 topic echo /lifecycle_chatter data: 'Lifecycle HelloWorld #212' data: 'Lifecycle HelloWorld #213' ``` ```bash ros2(base) jiao@jiao virtual machine:~$ ros2 topic list /cmd_vel /lc_talker/transition_event /odom /parameter_events /rosout (base) jiao@jiao virtual machine:~$ ros2 topic echo /lc_talker/transition_event # 查看日志 ``` ## 代码实现 ### python 实际是一系列的函数, 在外部的状态变化的时候, 调用对应的函数 ```python import rclpy from rclpy.lifecycle import LifecycleNode, TransitionCallbackReturn class LearnLifeCycleNode(LifecycleNode): def __init__(self): super().__init__('lifecyclenode') self.timer_period 0 self.timer_ None self.get_logger().info(f'{self.get_name()}:已创建') def timer_callback(self): self.get_logger().info('定时器打印进行中...') def on_configure(self, state): self.timer_period 1.0 # 设置定时器周期 self.get_logger().info('on_configure():配置周期 timer_period') return TransitionCallbackReturn.SUCCESS def on_activate(self, state): self.timer_ self.create_timer(self.timer_period, self.timer_callback) self.get_logger().info('on_activate():处理激活指令，创建定时器') return TransitionCallbackReturn.SUCCESS def on_deactivate(self, state): self.destroy_timer(self.timer_) # 销毁定时器 self.get_logger().info('on_deactivate():处理失活指令停止定时器') return TransitionCallbackReturn.SUCCESS def on_cleanup(self, state): self.timer_ None self.timer_period 0 self.get_logger().info('on_cleanup():处理清理指令') return TransitionCallbackReturn.SUCCESS def on_shutdown(self, state): # 定时器未销毁则销毁 if self.timer_: self.destroy_timer(self.timer_) self.get_logger().info('on_shutdown():处理关闭指令') return TransitionCallbackReturn.SUCCESS def on_error(self, state): # 直接调用父类处理 return super().on_error(state) def main(): rclpy.init() node LearnLifeCycleNode() rclpy.spin(node) rclpy.shutdown() ``` ### cpp ```cpp #include \"rclcpp/rclcpp.hpp\" #include \"rclcpp_lifecycle/lifecycle_node.hpp\" using CallbackReturn rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn; class LearnLifeCycleNode : public rclcpp_lifecycle::LifecycleNode { public: LearnLifeCycleNode() : rclcpp_lifecycle::LifecycleNode(\"lifecyclenode\") { timer_period_ 1.0; timer_ nullptr; RCLCPP_INFO(get_logger(), \"%s: 已创建\", get_name()); } CallbackReturn on_configure(const rclcpp_lifecycle::State &state) override { (void)state; timer_period_ 1.0; RCLCPP_INFO(get_logger(), \"on_configure():配置周期 timer_period\"); return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface:: CallbackReturn::SUCCESS; } CallbackReturn on_activate(const rclcpp_lifecycle::State &state) override { (void)state; timer_ create_wall_timer( std::chrono::seconds(static_cast<int>(timer_period_)), [this]() { RCLCPP_INFO(get_logger(), \"定时器打印进行中...\"); }); RCLCPP_INFO(get_logger(), \"on_activate():处理激活指令，创建定时器\"); return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface:: CallbackReturn::SUCCESS; } CallbackReturn on_deactivate(const rclcpp_lifecycle::State &state) override { (void)state; timer_.reset(); RCLCPP_INFO(get_logger(), \"on_deactivate():处理失活指令，停止定时器\"); return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface:: CallbackReturn::SUCCESS; } CallbackReturn on_shutdown(const rclcpp_lifecycle::State &state) override { (void)state; timer_.reset(); RCLCPP_INFO(get_logger(), \"on_shutdown():处理关闭指令\"); return rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface:: CallbackReturn::SUCCESS; } private: rclcpp::TimerBase::SharedPtr timer_; double timer_period_; }; int main(int argc, char **argv) { rclcpp::init(argc, argv); auto node std::make_shared<LearnLifeCycleNode>(); rclcpp::spin(node >get_node_base_interface()); rclcpp::shutdown(); return 0; } ```"},"/note/嵌入式/ROS/ROS2/2026-1-25-30-自定义导航控制器.html":{"title":"自定义导航控制器","content":"# 自定义导航控制器 进行路径的跟踪, 把路径转换为控制机器的命令 <img src \"https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601251809392.png\" alt \"image 20260125180623125\" style \"zoom:150%;\" /> ## 创建插件 ```bash ros2 pkg create nav2_custom_controller dependencies pluginlib nav2_core ``` ```xml <class_libraries> <library path \"nav2_custom_controller_plugin\"> <class type \"nav2_custom_controller::CustomController\" base_class_type \"nav2_core::Controller\"> <description> 自定义导航控制器 </description> </class> </library> </class_libraries> ``` 这里可以不给名字, 之后直接使用类名进行引用 实际使用的时候配置的类是`controller_server >FollowPath` ```yaml FollowPath: plugin: \"nav2_custom_controller::CustomController\" max_linear_speed: 0.1 max_angular_speed: 1.0 ``` 之前使用的是`dwb_core::DWBLocalPlanner` 这个插件实现了局部的跟踪以及规划 ## 实际实现 ```cpp #ifndef NAV2_CUSTOM_CONTROLLER__NAV2_CUSTOM_CONTROLLER_HPP_ #define NAV2_CUSTOM_CONTROLLER__NAV2_CUSTOM_CONTROLLER_HPP_ #include <memory> #include <string> #include <vector> #include \"nav2_core/controller.hpp\" #include \"rclcpp/rclcpp.hpp\" #include \"nav2_util/robot_utils.hpp\" namespace nav2_custom_controller { class CustomController : public nav2_core::Controller { public: CustomController() default; ~CustomController() override default; void configure( const rclcpp_lifecycle::LifecycleNode::WeakPtr &parent, std::string name, std::shared_ptr<tf2_ros::Buffer> tf, std::shared_ptr<nav2_costmap_2d::Costmap2DROS> costmap_ros) override; void cleanup() override; void activate() override; void deactivate() override; geometry_msgs::msg::TwistStamped computeVelocityCommands(const geometry_msgs::msg::PoseStamped &pose, const geometry_msgs::msg::Twist &velocity, nav2_core::GoalChecker * goal_checker) override; void setPlan(const nav_msgs::msg::Path &path) override; void setSpeedLimit(const double &speed_limit, const bool &percentage) override; protected: // 存储插件名称 std::string plugin_name_; // 存储坐标变换缓存指针，可用于查询坐标关系 std::shared_ptr<tf2_ros::Buffer> tf_; // 存储代价地图 std::shared_ptr<nav2_costmap_2d::Costmap2DROS> costmap_ros_; // 存储节点指针 nav2_util::LifecycleNode::SharedPtr node_; // 存储全局代价地图 nav2_costmap_2d::Costmap2D *costmap_; // 存储 setPlan 提供的全局路径 nav_msgs::msg::Path global_plan_; // 参数：最大线速度角速度 double max_angular_speed_; double max_linear_speed_; // 获取路径中距离当前点最近的点 geometry_msgs::msg::PoseStamped getNearestTargetPose(const geometry_msgs::msg::PoseStamped &current_pose); // 计算目标点方向和当前朝向的角度差 double calculateAngleDifference(const geometry_msgs::msg::PoseStamped &current_pose, const geometry_msgs::msg::PoseStamped &target_pose); }; } // namespace nav2_custom_controller #endif // NAV2_CUSTOM_CONTROLLER__NAV2_CUSTOM_CONTROLLER_HPP_ ``` 使用以下的执行策略 1. 目标的位置和车的位置比较大的时候 > 旋转 2. 擦除全局路径里面从开始到最近的点的数据 3. 选取离当前位置最近的点的下一个点为目标点 ```cpp #include \"nav2_custom_controller/custom_controller.hpp\" #include \"nav2_core/exceptions.hpp\" #include \"nav2_util/geometry_utils.hpp\" #include \"nav2_util/node_utils.hpp\" #include <algorithm> #include <chrono> #include <iostream> #include <memory> #include <string> #include <thread> namespace nav2_custom_controller { void CustomController::configure( const rclcpp_lifecycle::LifecycleNode::WeakPtr &parent, std::string name, std::shared_ptr<tf2_ros::Buffer> tf, std::shared_ptr<nav2_costmap_2d::Costmap2DROS> costmap_ros) { node_ parent.lock(); costmap_ros_ costmap_ros; tf_ tf; plugin_name_ name; // 声明并获取参数，设置最大线速度和最大角速度 nav2_util::declare_parameter_if_not_declared( node_, plugin_name_ + \".max_linear_speed\", rclcpp::ParameterValue(0.1)); node_ >get_parameter(plugin_name_ + \".max_linear_speed\", max_linear_speed_); nav2_util::declare_parameter_if_not_declared( node_, plugin_name_ + \".max_angular_speed\", rclcpp::ParameterValue(1.0)); node_ >get_parameter(plugin_name_ + \".max_angular_speed\", max_angular_speed_); } void CustomController::cleanup() { RCLCPP_INFO(node_ >get_logger(), \"清理控制器：%s 类型为 nav2_custom_controller::CustomController\", plugin_name_.c_str()); } void CustomController::activate() { RCLCPP_INFO(node_ >get_logger(), \"激活控制器：%s 类型为 nav2_custom_controller::CustomController\", plugin_name_.c_str()); } void CustomController::deactivate() { RCLCPP_INFO(node_ >get_logger(), \"停用控制器：%s 类型为 nav2_custom_controller::CustomController\", plugin_name_.c_str()); } // 计算最佳的命令速度 geometry_msgs::msg::TwistStamped CustomController::computeVelocityCommands( const geometry_msgs::msg::PoseStamped &pose, const geometry_msgs::msg::Twist &, nav2_core::GoalChecker *) { // 1. 检查路径是否为空 if (global_plan_.poses.empty()) { throw nav2_core::PlannerException(\"收到长度为零的路径\"); } // 2.将机器人当前姿态转换到全局计划坐标系中 geometry_msgs::msg::PoseStamped pose_in_globalframe; if (!nav2_util::transformPoseInTargetFrame( pose, pose_in_globalframe, *tf_, global_plan_.header.frame_id, 0.1)) { throw nav2_core::PlannerException(\"无法将机器人姿态转换为全局计划的坐标系\"); } // 3.获取最近的目标点和计算角度差 auto target_pose getNearestTargetPose(pose_in_globalframe); auto angle_diff calculateAngleDifference(pose_in_globalframe, target_pose); // 4.根据角度差计算线速度和角速度 geometry_msgs::msg::TwistStamped cmd_vel; cmd_vel.header.frame_id pose_in_globalframe.header.frame_id; cmd_vel.header.stamp node_ >get_clock() >now(); // 根据角度差计算速度，角度差大于 0.3 则原地旋转，否则直行 if (fabs(angle_diff) > M_PI/10.0) { cmd_vel.twist.linear.x .0; cmd_vel.twist.angular.z fabs(angle_diff) / angle_diff * max_angular_speed_; } else { cmd_vel.twist.linear.x max_linear_speed_; cmd_vel.twist.angular.z .0; } RCLCPP_INFO(node_ >get_logger(), \"控制器：%s 发送速度(%f,%f)\", plugin_name_.c_str(), cmd_vel.twist.linear.x, cmd_vel.twist.angular.z); return cmd_vel; } void CustomController::setSpeedLimit(const double &speed_limit, const bool &percentage) { (void)percentage; (void)speed_limit; } void CustomController::setPlan(const nav_msgs::msg::Path &path) { global_plan_ path; } geometry_msgs::msg::PoseStamped CustomController::getNearestTargetPose( const geometry_msgs::msg::PoseStamped &current_pose) { // 1.遍历路径获取路径中距离当前点最近的索引，存储到 nearest_pose_index using nav2_util::geometry_utils::euclidean_distance; int nearest_pose_index 0; double min_dist euclidean_distance(current_pose, global_plan_.poses.at(0)); for (unsigned int i 1; i < global_plan_.poses.size(); i++) { double dist euclidean_distance(current_pose, global_plan_.poses.at(i)); if (dist < min_dist) { nearest_pose_index i; min_dist dist; } } // 2.从路径中擦除头部到最近点的路径 global_plan_.poses.erase(std::begin(global_plan_.poses), std::begin(global_plan_.poses) + nearest_pose_index); // 3.如果只有一个点则直接，否则返回最近点的下一个点 if (global_plan_.poses.size() 1) { return global_plan_.poses.at(0); } return global_plan_.poses.at(1); } double CustomController::calculateAngleDifference( const geometry_msgs::msg::PoseStamped &current_pose, const geometry_msgs::msg::PoseStamped &target_pose) { // 计算当前姿态与目标姿态之间的角度差 // 1. 获取当前角度 float current_robot_yaw tf2::getYaw(current_pose.pose.orientation); // 2.获取目标点朝向 float target_angle std::atan2(target_pose.pose.position.y current_pose.pose.position.y, target_pose.pose.position.x current_pose.pose.position.x); // 3.计算角度差，并转换到 M_PI 到 M_PI 之间 double angle_diff target_angle current_robot_yaw; if (angle_diff < M_PI) { angle_diff + 2.0 * M_PI; } else if (angle_diff > M_PI) { angle_diff 2.0 * M_PI; } return angle_diff; } } // namespace nav2_custom_controller #include \"pluginlib/class_list_macros.hpp\" PLUGINLIB_EXPORT_CLASS(nav2_custom_controller::CustomController,nav2_core::Controller) ```"},"/note/嵌入式/ROS/ROS2/2026-1-24-26-Navigation2自主导航.html":{"title":"Navigation","content":"# Navigation 自主导航框架 ![image 20260124151703012](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601241517097.png) ```bash sudo apt get install ros $ROS_DISTRO navigation2 sudo apt get install ros $ROS_DISTRO nav2 bringup ``` 复制一份默认的配置文件`/opt/ros/humble/share/nav2_bringup/params/nav2_params.yaml` 默认只需要配置一下`robot_radius: 0.12` 为了方便使用可以launch文件引用navigation2里面的默认启动文件 ```python import os import launch import launch_ros from ament_index_python.packages import get_package_share_directory from launch.launch_description_sources import PythonLaunchDescriptionSource def generate_launch_description(): # 获取与拼接默认路径 fishbot_navigation2_dir get_package_share_directory( 'fishbot_navigation2') # 找到这个库的默认的配置文件 nav2_bringup_dir get_package_share_directory('nav2_bringup') rviz_config_dir os.path.join( nav2_bringup_dir, 'rviz', 'nav2_default_view.rviz') # 创建 Launch 配置 use_sim_time launch.substitutions.LaunchConfiguration( 'use_sim_time', default 'true') # 使用仿真时间 map_yaml_path launch.substitutions.LaunchConfiguration( 'map', default os.path.join(fishbot_navigation2_dir, 'maps', 'room.yaml')) # 地图文件路径 nav2_param_path launch.substitutions.LaunchConfiguration( 'params_file', default os.path.join(fishbot_navigation2_dir, 'config', 'nav2_params.yaml')) # 导航参数文件路径 return launch.LaunchDescription([ # 声明新的 Launch 参数 launch.actions.DeclareLaunchArgument('use_sim_time', default_value use_sim_time, description 'Use simulation (Gazebo) clock if true'), launch.actions.DeclareLaunchArgument('map', default_value map_yaml_path, description 'Full path to map file to load'), launch.actions.DeclareLaunchArgument('params_file', default_value nav2_param_path, description 'Full path to param file to load'), # 使用navagation2的launch文件, 传递参数 launch.actions.IncludeLaunchDescription( PythonLaunchDescriptionSource( [nav2_bringup_dir, '/launch', '/bringup_launch.py']), # 使用 Launch 参数替换原有参数 launch_arguments { 'map': map_yaml_path, 'use_sim_time': use_sim_time, 'params_file': nav2_param_path}.items(), ), launch_ros.actions.Node( package 'rviz2', executable 'rviz2', name 'rviz2', arguments [' d', rviz_config_dir], parameters [{'use_sim_time': use_sim_time}], output 'screen'), ]) ``` ```cmake install(DIRECTORY launch maps config DESTINATION share/${PROJECT_NAME} ) ``` ```bash ros2 launch fishbot_navigation2 navigation2.launch.py ``` ![image 20260124153623570](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601241536699.png) ![image 20260124153658842](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601241536935.png) ![image 20260124153854515](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601241538616.png) ## 优化 ###优化导航的速度/膨胀半径 控制器服务器根据全局的路径输出机器人的控制命令, 所以这里需要改变的是控制器服务器的参数 位于`controller_server`节点下面的`controller_server`可以控制最小最大的速度等 这个地图里面在门的位置有一个膨胀半径, 这里面的默认膨胀是比较大的, 可以改为比较小的膨胀半径, 一般是机器人的半径`local_costmap >inflation_radius`以及`global_costmap >inflation_radius` ### 优化到点精度 之前配置的时候机器人并未完全到达目标点, 可以配置精度 `controller_server >general_goal_checker`"},"/note/嵌入式/ROS/ROS2/2026-1-15-04-节点node.html":{"title":"节点","content":"# 节点 每一个节点是一个可执行文件, 实现一个功能, 可能位于不同的设备上面 ## 基础使用 + 初始化编程接口 + 初始化节点, 创建节点 + 实现节点功能 + 销毁节点 ### 数据类型 使用的数据叫interface, 可以使用命令 ```bash ros2 interface list # 查看 # 具体的实现 ros2 interface show example_interfaces/msg/String ``` ### python #### 基础使用 ```python import rclpy from rclpy.node import Node import time # ROS2节点主入口main函数 def main(args None): # ROS2 Python接口初始化 rclpy.init(args args) # 创建ROS2节点对象并进行初始化 node Node(\"node_helloworld\") while rclpy.ok(): # ROS2日志输出 node.get_logger().info(\"Hello World\") # 休眠控制循环时间 time.sleep(0.5) node.destroy_node() rclpy.shutdown() ``` 使用python文件的时候需要配置一下入口函数 ```python entry_points { 'console_scripts': [ 'node_helloworld learning_node.node_helloworld:main', ], }, ``` 文件编译的时候会被复制到install目录里面 ![image 20260115141954508](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601151419572.png) #### 面向对象 ```python import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 import time \"\"\" 创建一个HelloWorld节点, 初始化时输出“hello world”日志 \"\"\" class HelloWorldNode(Node): def __init__(self, name): super().__init__(name) # ROS2节点父类初始化 while rclpy.ok(): # ROS2系统是否正常运行 self.get_logger().info(\"Hello World\") # ROS2日志输出 time.sleep(0.5) # 休眠控制循环时间 def main(args None): # ROS2节点主入口main函数 rclpy.init(args args) # ROS2 Python接口初始化 node HelloWorldNode(\"node_helloworld_class\") # 创建ROS2节点对象并进行初始化 node.destroy_node() # 销毁节点对象 rclpy.shutdown() # 关闭ROS2 Python接口 ``` 可以在节点里面实现实际的功能 ```python import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 import cv2 # OpenCV图像处理库 import numpy as np # Python数值计算库 lower_red np.array([0, 90, 128]) # 红色的HSV阈值下限 upper_red np.array([180, 255, 255]) # 红色的HSV阈值上限 def object_detect(image): hsv_img cv2.cvtColor(image, cv2.COLOR_BGR2HSV) # 图像从BGR颜色模型转换为HSV模型 mask_red cv2.inRange(hsv_img, lower_red, upper_red) # 图像二值化 contours, hierarchy cv2.findContours(mask_red, cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE) # 图像中轮廓检测 for cnt in contours: # 去除一些轮廓面积太小的噪声 if cnt.shape[0] < 150: continue (x, y, w, h) cv2.boundingRect(cnt) # 得到苹果所在轮廓的左上角xy像素坐标及轮廓范围的宽和高 cv2.drawContours(image, [cnt], 1, (0, 255, 0), 2) # 将苹果的轮廓勾勒出来 cv2.circle(image, (int(x+w/2), int(y+h/2)), 5, (0, 255, 0), 1) # 将苹果的图像中心点画出来 \t cv2.imshow(\"object\", image) # 使用OpenCV显示处理后的图像效果 cv2.waitKey(0) cv2.destroyAllWindows() def main(args None): rclpy.init(args args) node Node(\"node_object\") node.get_logger().info(\"ROS2节点示例：检测图片中的苹果\") image cv2.imread('/home/gyh/dev_ws/src/ros2_21_tutorials/learning_node/learning_node/apple.jpg') # 读取图像 object_detect(image) # 在这个里面处理话题回调函数等 rclpy.spin(node) node.destroy_node() rclpy.shutdown() ``` ### cpp ```cpp #include <unistd.h> #include \"rclcpp/rclcpp.hpp\" class HelloWorldNode : public rclcpp::Node {\t // ROS2节点初始化以及父类初始化 public: HelloWorldNode() : Node(\"node_helloworld_class\") { // ROS2系统是否正常运行 while(rclcpp::ok()) { // ROS2日志输出 RCLCPP_INFO(this >get_logger(), \"Hello World\"); // 休眠控制循环时间 sleep(1); } } }; // ROS2节点主入口main函数 int main(int argc, char * argv[]) { // ROS2 C++接口初始化 rclcpp::init(argc, argv); // 创建ROS2节点对象并进行初始化 rclcpp::spin(std::make_shared<HelloWorldNode>()); // 关闭ROS2 C++接口 rclcpp::shutdown(); return 0; } ``` #### cmake 可以自己编写文件进行链接 ```bash cmake_minimum_required(VERSION 3.8) project(ros2_cpp) add_executable(node_helloworld node_helloworld_class.cpp) find_package(rclcpp REQUIRED) target_include_directories(node_helloworld PUBLIC ${rclcpp_INCLUDE_DIRS}) target_link_libraries(node_helloworld ${rclcpp_LIBRARIES}) ``` ## 日志 日志可以使用环境变量进行配置输出格式 `RCUTILS_CONCOLE_OUTPUT_FORMAT`: 输出日志的格式, 可以设置为`[{function_name}:{line_number}]:{message}` ```bash node.get_logger().info(\"ROS2节点示例：检测图片中的苹果\") ```"},"/note/嵌入式/ROS/ROS2/2026-1-15-07-通信接口.html":{"title":"通用接口","content":"# 通用接口 几个模块之间的通信交流使用传输的数据, ROS有三种常用的通信机制，分别是**话题、服务、动作**，通过每一种通信种定义的接口，各种节点才能有机的联系到一起 为了保证每一个节点可以使用不同语言编程，ROS将这些接口的设计做成了和**语言无关**的，比如这里看到的int32表示32位的整型数，int64表示64位的整型数，bool表示布尔值，还可以定义数组、结构体，这些定义在编译过程中，会自动生成对应到C++、Python等语言里的数据结构 ![image 20260115165105822](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601151651897.png) 话题通信接口的定义使用的是.msg文件，由于是单向传输，只需要描述传输的每一帧数据是什么就行，比如在这个定义里，会传输两个32位的整型数，x、y，我们可以用来传输二维坐标的数值。 服务通信接口的定义使用的是.srv文件，包含请求和应答两部分定义，通过中间的“ ”区分，比如之前我们学习的加法求和功能，请求数据是两个64位整型数a和b，应答是求和的结果sum。 动作是另外一种通信机制，用来描述机器人的一个运动过程，使用.action文件定义，比如我们让小海龟转90度，一边转一边**周期反馈**当前的状态，此时接口的定义分成了三个部分，分别是动作的目标，比如是开始运动，运动的结果，**最终旋转的90度是否完成**，还有一个周期反馈，比如每隔1s反馈一下当前转到第10度、20度还是30度了，让我们知道运动的进度。 ## 常用的通信接口 ### Topic的msg ```bash jiao@jiao virtual machine:~/ros/dev_ws$ ls /opt/ros/humble/share/ grep msg actionlib_msgs action_msgs diagnostic_msgs geometry_msgs lifecycle_msgs map_msgs nav_msgs pcl_msgs pendulum_msgs rosgraph_msgs rqt_msg sensor_msgs sensor_msgs_py shape_msgs statistics_msgs std_msgs stereo_msgs tf2_geometry_msgs tf2_msgs tf2_sensor_msgs trajectory_msgs unique_identifier_msgs visualization_msgs # 传感器的数据类型 jiao@jiao virtual machine:~/ros/dev_ws$ ls /opt/ros/humble/share/sensor_msgs/msg/ BatteryState.idl FluidPressure.msg JoyFeedbackArray.idl LaserScan.msg NavSatStatus.idl Range.msg BatteryState.msg Illuminance.idl JoyFeedbackArray.msg MagneticField.idl NavSatStatus.msg RegionOfInterest.idl CameraInfo.idl Illuminance.msg JoyFeedback.idl MagneticField.msg PointCloud2.idl RegionOfInterest.msg CameraInfo.msg Image.idl JoyFeedback.msg MultiDOFJointState.idl PointCloud2.msg RelativeHumidity.idl ChannelFloat32.idl Image.msg Joy.idl MultiDOFJointState.msg PointCloud.idl RelativeHumidity.msg ChannelFloat32.msg Imu.idl Joy.msg MultiEchoLaserScan.idl PointCloud.msg Temperature.idl CompressedImage.idl Imu.msg LaserEcho.idl MultiEchoLaserScan.msg PointField.idl Temperature.msg CompressedImage.msg JointState.idl LaserEcho.msg NavSatFix.idl PointField.msg TimeReference.idl FluidPressure.idl JointState.msg LaserScan.idl NavSatFix.msg Range.idl TimeReference.msg ``` ### Srv类型 ```bash jiao@jiao virtual machine:~/ros/dev_ws$ ls /opt/ros/humble/share/ grep srv rqt_srv std_srvs # 标准的服务 jiao@jiao virtual machine:~/ros/dev_ws$ ls /opt/ros/humble/share/std_srvs/srv/ Empty.idl Empty_Response.msg SetBool.idl SetBool_Response.msg Trigger.idl Trigger_Response.msg Empty_Request.msg Empty.srv SetBool_Request.msg SetBool.srv Trigger_Request.msg Trigger.srv ``` ### 查询命令 ```bash jiao@jiao virtual machine:~/ros/dev_ws$ ros2 interface list jiao@jiao virtual machine:~/ros/dev_ws$ ros2 interface show sensor_msgs/msg/Joy # Reports the state of a joystick's axes and buttons. # The timestamp is the time at which data is received from the joystick. std_msgs/Header header builtin_interfaces/Time stamp int32 sec uint32 nanosec string frame_id # The axes measurements from a joystick. float32[] axes # The buttons measurements from a joystick. int32[] buttons # 查看一个工具包里面的具体情况 jiao@jiao virtual machine:~/ros/dev_ws$ ros2 interface package learning_interface learning_interface/msg/ObjectPosition learning_interface/action/MoveCircle learning_interface/srv/AddTwoInts learning_interface/srv/GetObjectPosition ``` ## 自定义 ### cmake ```cmake cmake_minimum_required(VERSION 3.5) project(learning_interface) # Default to C99 if(NOT CMAKE_C_STANDARD) set(CMAKE_C_STANDARD 99) endif() # Default to C++14 if(NOT CMAKE_CXX_STANDARD) set(CMAKE_CXX_STANDARD 14) endif() if(CMAKE_COMPILER_IS_GNUCXX OR CMAKE_CXX_COMPILER_ID MATCHES \"Clang\") add_compile_options( Wall Wextra Wpedantic) endif() # find dependencies find_package(ament_cmake REQUIRED) # uncomment the following section in order to fill in # further dependencies manually. # find_package(<dependency> REQUIRED) find_package(rosidl_default_generators REQUIRED) # 实际的配置文件 rosidl_generate_interfaces(${PROJECT_NAME} \"msg/ObjectPosition.msg\" \"srv/AddTwoInts.srv\" \"srv/GetObjectPosition.srv\" \"action/MoveCircle.action\" ) if(BUILD_TESTING) find_package(ament_lint_auto REQUIRED) # the following line skips the linter which checks for copyrights # uncomment the line when a copyright and license is not present in all source files #set(ament_cmake_copyright_FOUND TRUE) # the following line skips cpplint (only works in a git repo) # uncomment the line when this package is not in a git repo #set(ament_cmake_cpplint_FOUND TRUE) ament_lint_auto_find_test_dependencies() endif() ament_package() ``` ### 数据示例 #### msg ```xml # 使用功能包里面的数据类型 builtin_interfaces/Time stamp # 时间戳 # 自带的数据类型 string host_name float32 cpu_percent float32 memory_percent # 内存 float32 memory_total float32 memory_available float64 net_sent # 网络 float32 net_recv ``` #### server ```xml sensor_msgs/Image image int16 number float32 use_time int32[] top int32[] left int32[] bottom int32[] right ``` 可以定义常量 ```xml int8 SUCESS 1 int8 FAIL 0 ``` 使用的时候直接引用 ```cpp Partol::Response::SUCESS ```"},"/note/嵌入式/ROS/ROS2/2026-1-26-35-里程计计算.html":{"title":"里程计计算","content":"# 里程计计算 通过运动学的正解, 可以计算出机器人的实时速度, 通过线速度以及角速度的积分, 可以计算出来机器人的实时位置 <img src \"https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601261949047.png\" alt \"image 20260126194906989\" style \"zoom:150%;\" /> ```cpp void Kinematics::update_odom(uint16_t dt) { float dt_s float(dt)/1000.0; // ms > s // 获取实时的角速度和线速度呢？我们拿左右轮实时的速度，进行运动学正解 this >kinematics_forward(motor_param[0].motor_speed,motor_param[1].motor_speed,&odom.linear_speed,&odom.angular_speed); // 计算里程计信息 odom.linear_speed odom.linear_speed/1000.0; // 转换成米每秒 // 角度积分 odom.angle + odom.angular_speed*dt_s; TransAngleInPI(odom.angle,odom.angle); // 计算机器人行走的距离（沿自身前进方向的） float delta_distance odom.linear_speed * dt_s; // 分解到X轴和Y轴 odom.x + delta_distance * std::cos(odom.angle); odom.y + delta_distance * std::sin(odom.angle); } ```"},"/note/嵌入式/ROS/ROS2/2026-1-16-12-launch启动脚本.html":{"title":"launch脚本","content":"# launch脚本 ROS2里面的脚本使用python进行描述, 所有的命令可以使用python命令进行描述 ## 实现 ### 构建运行 #### python项目 ```bash $ ros2 launch learning_launch simple.launch.py ``` 这个文件放在launch文件夹下面, 名字就是simple.launch.py 在setup.py文件里面有如下的描述 ```python data_files [ ('share/ament_index/resource_index/packages', ['resource/' + package_name]), ('share/' + package_name, ['package.xml']), # 这个匹配launch文件 (os.path.join('share', package_name, 'launch'), glob(os.path.join('launch', '*.launch.py'))), (os.path.join('share', package_name, 'config'), glob(os.path.join('config', '*.*'))), (os.path.join('share', package_name, 'rviz'), glob(os.path.join('rviz', '*.*'))), ], ``` #### cpp 脚本文件的构建是一样的, cmake添加一个拷贝配置 ```cmake install(DIRECTORY launch DESTINATION share/${PROJECT_NAME}/ ) ``` ## 实际实现 python的实现需要使用generate_launch_description这个函数名字, 返回一个`LaunchDescription`数组, 里面是一系列的动作 ### 节点启动描述 ```python # launch文件的描述类 from launch import LaunchDescription from launch_ros.actions import Node # 自动生成launch文件的函数 def generate_launch_description(): # 返回launch文件的描述信息 # 配置一个节点的启动 return LaunchDescription([ Node( # 节点所在的功能包 package 'learning_topic', # 节点的可执行文件 executable 'topic_helloworld_pub', ), # 配置一个节点的启动 Node( # 节点所在的功能包 package 'learning_topic', # 节点的可执行文件名 executable 'topic_helloworld_sub', ), ]) ``` 可以使用`output`指定实际输出的位置 + screen: 终端 + log: 日志文件 + both: 上面两个 ### 参数文件加载 ```python import os from ament_index_python.packages import get_package_share_directory from launch import LaunchDescription类 from launch_ros.actions import Node def generate_launch_description(): \t# 找到配置文件的完整路径 rviz_config os.path.join( get_package_share_directory('learning_launch'), 'rviz', 'turtle_rviz.rviz' ) \t# 返回launch文件的描述信息 return LaunchDescription([ # 配置一个节点的启动, 对节点重新命名 Node( package 'rviz2', executable 'rviz2', name 'rviz2', # 加载命令行参数 arguments [' d', rviz_config] ) ]) ``` ### 资源重映射 当我们使用别人代码的时候，经常会发现通信的话题名称不太符合我们的要求, 为了提高软件的复用性，ROS提供了资源重映射的机制，可以帮助我们解决类似的问题 ```python from launch import LaunchDescription # launch文件的描述类 from launch_ros.actions import Node # 节点启动的描述类 def generate_launch_description(): return LaunchDescription([ Node( package 'turtlesim', # 使用命名空间的名字 namespace 'turtlesim1', executable 'turtlesim_node', name 'sim' ), Node( package 'turtlesim', namespace 'turtlesim2', executable 'turtlesim_node', name 'sim' ), # 启动 turtlesim 功能包中的 mimic 节点，并通过话题重映射， # 让 turtlesim2 命名空间下的海龟 “模仿” turtlesim1 # 命名空间下的海龟运动 # mimic 节点本身只认 /input/pose 和 /output/cmd_vel 这两个话题， # 若不做重映射，它无法关联到你创建的 turtlesim1/turtlesim2 海龟， # 因此需要通过 remappings 调整话题指向 Node( package 'turtlesim', executable 'mimic', name 'mimic', # 资源重映射列表 remappings [ # 将/input/pose话题名修改为/turtlesim1/turtle1/pose ('/input/pose', '/turtlesim1/turtle1/pose'), # 将/output/cmd_vel话题名修改为/turtlesim2/turtle1/cmd_vel ('/output/cmd_vel', '/turtlesim2/turtle1/cmd_vel'), ] ) ]) ``` **结合命名空间形成唯一标识**：节点的完整名称 `namespace + name`，因此两个 turtlesim 节点的完整名称分别是： `/turtlesim1/sim`（原本默认是 `/turtlesim1/turtlesim_node`） `/turtlesim2/sim`（原本默认是 `/turtlesim2/turtlesim_node`）； ### 初始化参数 ```python from launch import LaunchDescription from launch.actions import DeclareLaunchArgument from launch.substitutions import LaunchConfiguration, TextSubstitution from launch_ros.actions import Node def generate_launch_description(): # 声明launch文件里面使用的参数, 可以在加载的时候复用 background_r_launch_arg DeclareLaunchArgument( 'background_r', default_value TextSubstitution(text '0') ) background_g_launch_arg DeclareLaunchArgument( 'background_g', default_value TextSubstitution(text '84') ) background_b_launch_arg DeclareLaunchArgument( 'background_b', default_value TextSubstitution(text '122') ) return LaunchDescription([ # 加载并启用以上创建的参数（arg） background_r_launch_arg, background_g_launch_arg, background_b_launch_arg, Node( package 'turtlesim', executable 'turtlesim_node', name 'sim', parameters [{ # 将外部 Launch 参数的值传递给 turtlesim_node 内部 'background_r': LaunchConfiguration('background_r'), 'background_g': LaunchConfiguration('background_g'), 'background_b': LaunchConfiguration('background_b'), }] ), ]) ``` launch文件中出现的argument和parameter，虽都译为“参数”，但含义不同： argument：仅限launch文件内部使用，方便在launch中调用某些数值； parameter：ROS系统的参数，方便在节点见使用某些数值 可以在使用launch的时候再次设置 ```bash ros2 launch demo demo.launch.py background_r: 0 ``` 也可以从文件里面直接读取 ```python import os from ament_index_python.packages import get_package_share_directory # 查询功能包路径的方法 from launch import LaunchDescription # launch文件的描述类 from launch_ros.actions import Node # 节点启动的描述类 def generate_launch_description(): config os.path.join( # 找到参数文件的完整路径 get_package_share_directory('learning_launch'), 'config', 'turtlesim.yaml' ) return LaunchDescription([ Node( package 'turtlesim', executable 'turtlesim_node', namespace 'turtlesim2', name 'sim', parameters [config]# 加载参数文件 ) ]) ``` ## 进阶使用 Launch文件有三个组成部分, 动作, 条件, 替换 + 动作: 可以是一个节点的启动, 打印信息, 终端指令, 另一个launch文件 + 替换: 使用launch文件的参数替换节点的参数 + 条件: 使用条件可以决定实际启动的动作 ### 模块的包含 ```python import os from ament_index_python.packages import get_package_share_directory from launch import LaunchDescription from launch.actions import IncludeLaunchDescription from launch.launch_description_sources import PythonLaunchDescriptionSource from launch.actions import GroupAction from launch_ros.actions import PushRosNamespace def generate_launch_description(): # 包含指定路径下的另外一个launch文件, 使用功能包名字查找路径 parameter_yaml IncludeLaunchDescription( PythonLaunchDescriptionSource([os.path.join( get_package_share_directory('learning_launch'), 'launch'), '/parameters_nonamespace.launch.py']) ) # 对指定launch文件中启动的功能加上命名空间, 按顺序执行 parameter_yaml_with_namespace GroupAction( actions [ PushRosNamespace('turtlesim2'), parameter_yaml] ) return LaunchDescription([# 返回launch文件的描述信息 parameter_yaml_with_namespace ]) ``` ### 执行命令 ```pthon action_topic_list launch.actions.ExecuteProcess( \tcmd [\"ros2\", \"topic\", list] ) ``` ### 顺序执行 ```python parameter_yaml_with_namespace launch.actions.GroupAction( actions [ launch.actions.TimerAction(period 2.0, actions [action_include_launch]), launch.actions.TimerAction(period 4.0, actions [action_topic_list]) ] ) ``` ### 打印信息 ```python action_log_info launch.action.LogInfo(msg str(path)) ``` ### 调教执行 ```python # 初始化一个launch参数 action_declare_startup_rqt launch.action.DeclareLaunchArgument('startup_rqt', default_value \"False\") startup_rqt launch.substitutions.LaunchConfiguration('startup_rqt', default \"False\") # 使用这个参数进行判断执行 action_topic_list launch.actions.ExecuteProcess( \tcondition launch.conditions.IfCondition(startup_rqt) cmd [\"rqt\"] ) ```"},"/note/嵌入式/ROS/ROS2/2026-1-19-17-电脑信息示例.html":{"title":"电脑信息实例","content":"# 电脑信息实例 ## 创建工作区 ### 数据类型 ```bash ros2 pkg create status_interface dependencies builtin_interfaces rosidl_default_generators ``` ![image 20260119120229846](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601191202047.png) ### 发布文件 ```bash ros2 pkg create status_publisher dependencies status_interface rclpy build type ament_python ``` ### Qt界面 ```bash ros2 pkg create status_display dependencies rclcpp status_interface ``` ## 数据类型 ### 数据文件 ```bash # 使用功能包里面的数据类型 builtin_interfaces/Time stamp # 时间戳 # 自带的数据类型 string host_name float32 cpu_percent float32 memory_percent # 内存 float32 memory_total float32 memory_available float64 net_sent # 网络 float32 net_recv ``` ```cmake # 使用find_package里面的rosidl_generators_interfaces rosidl_generate_interfaces ( ${PROJECT_NAME} \"msg/SystemStatus.msg\" DEPENDENCIES builtin_interfaces ) ``` 配置文件里面添加 ```xml <member_of_group> rosidl_interface_packages </member_of_group> ``` 查看添加 ```bash cat@lubancat:~/ros$ ros2 interface show status_interface/msg/SystemStatus # 使用功能包里面的数据类型 builtin_interfaces/Time stamp # 时间戳 # 自带的数据类型 string host_name float32 cpu_percent float32 memory_percent # 内存 float32 memory_total float32 memory_available float64 net_sent # 网络 float32 net_recv ``` ### 发布类型 ```python import rclpy from rclpy.node import Node from status_interface.msg import SystemStatus import psutil import platform class SysStatusPub(Node): def __init__(self, node_name): super().__init__(node_name) self.publisher_ self.create_publisher(SystemStatus, 'sys_status', 10) timer_period 1.0 # seconds self.timer self.create_timer(timer_period, self.timer_callback) def timer_callback(self): \"\"\" # 使用功能包里面的数据类型 builtin_interfaces/Time stamp # 时间戳 # 自带的数据类型 string host_name float32 cpu_percent float32 memory_percent # 内存 float32 memory_total float32 memory_available float64 net_sent # 网络 float32 net_recv \"\"\" msg SystemStatus() msg.stamp self.get_clock().now().to_msg() msg.host_name platform.node() msg.cpu_percent psutil.cpu_percent() msg.memory_percent psutil.virtual_memory().percent msg.memory_total float(psutil.virtual_memory().total) / (1024 * 1024) msg.memory_available float(psutil.virtual_memory().available) / (1024 * 1024) net_io psutil.net_io_counters() msg.net_sent float(net_io.bytes_sent) / (1024 * 1024) msg.net_recv float(net_io.bytes_recv) / (1024 * 1024) self.get_logger().info(f'Publishing SystemStatus: CPU {msg.cpu_percent}%, Memory {msg.memory_percent}%, Platform {msg.host_name}') self.publisher_.publish(msg) def main(args None): rclpy.init(args args) sys_status_pub SysStatusPub('sys_status_publisher') rclpy.spin(sys_status_pub) sys_status_pub.destroy_node() rclpy.shutdown() ``` ### Qt #### 基础界面 ```cpp #include <QApplication> #include <QLabel> #include <QString> int main(int argc, char *argv[]) { QApplication app(argc, argv); QLabel label(\"Hello, HalloQt!\"); label.resize(200, 100); label.show(); return app.exec(); } ``` ```cmake find_package(Qt5 REQUIRED COMPONENTS Widgets) add_executable(hello_qt src/hello_qt.cpp) target_link_libraries(hello_qt Qt5::Widgets) install( TARGETS hello_qt DESTINATION lib/${PROJECT_NAME} ) ```"},"/note/嵌入式/ROS/ROS2/2026-1-24-27-导航应用开发.html":{"title":"导航应用开发","content":"# 导航应用开发 ## 初始化位姿 在navigation2里面机器人的位姿是/amcl节点根据地图以及传感器数据实时计算出来的, 在最开始的时候, 需要告诉他机器人的大致位置 ```bash (base) jiao@jiao virtual machine:~/ros/dev_ws$ ros2 node info /amcl /amcl Subscribers: /bond: bond/msg/Status /clock: rosgraph_msgs/msg/Clock /initialpose: geometry_msgs/msg/PoseWithCovarianceStamped /map: nav_msgs/msg/OccupancyGrid /parameter_events: rcl_interfaces/msg/ParameterEvent /scan: sensor_msgs/msg/LaserScan Publishers: /amcl/transition_event: lifecycle_msgs/msg/TransitionEvent /amcl_pose: geometry_msgs/msg/PoseWithCovarianceStamped /bond: bond/msg/Status /parameter_events: rcl_interfaces/msg/ParameterEvent /particle_cloud: nav2_msgs/msg/ParticleCloud /rosout: rcl_interfaces/msg/Log /tf: tf2_msgs/msg/TFMessage Service Servers: /amcl/change_state: lifecycle_msgs/srv/ChangeState /amcl/describe_parameters: rcl_interfaces/srv/DescribeParameters /amcl/get_available_states: lifecycle_msgs/srv/GetAvailableStates /amcl/get_available_transitions: lifecycle_msgs/srv/GetAvailableTransitions /amcl/get_parameter_types: rcl_interfaces/srv/GetParameterTypes /amcl/get_parameters: rcl_interfaces/srv/GetParameters /amcl/get_state: lifecycle_msgs/srv/GetState /amcl/get_transition_graph: lifecycle_msgs/srv/GetAvailableTransitions /amcl/list_parameters: rcl_interfaces/srv/ListParameters /amcl/set_parameters: rcl_interfaces/srv/SetParameters /amcl/set_parameters_atomically: rcl_interfaces/srv/SetParametersAtomically /reinitialize_global_localization: std_srvs/srv/Empty /request_nomotion_update: std_srvs/srv/Empty /set_initial_pose: nav2_msgs/srv/SetInitialPose Service Clients: Action Servers: Action Clients: ``` 有一个`/initialpose`接受初始化的位姿 ```bash (base) jiao@jiao virtual machine:~/ros/dev_ws$ ros2 topic pub /initialpose geometry_msgs/msg/PoseWithCovarianceStamped \"{header: {frame_id: map}, pose: {pose: {position:{x: 0.0, y: 0.0, z: 0.0}}}}\" once ``` 在关机的时候记录一下, 下一次启动可以直接初始化 可以使用python封装的包进行快速使用 ```python from geometry_msgs.msg import PoseStamped from nav2_simple_commander.robot_navigator import BasicNavigator import rclpy def main(): rclpy.init() nav BasicNavigator() # 这是一个节点 initial_pose PoseStamped() # 这个类型会自动转换 initial_pose.header.frame_id 'map' initial_pose.header.stamp nav.get_clock().now().to_msg() initial_pose.pose.position.x 0.0 initial_pose.pose.position.y 0.0 initial_pose.pose.position.z 0.0 initial_pose.pose.orientation.x 0.0 initial_pose.pose.orientation.y 0.0 initial_pose.pose.orientation.z 0.0 initial_pose.pose.orientation.w 1.0 nav.setInitialPose(initial_pose) nav.waitUntilNav2Active() rclpy.spin(nav) nav.destroy_node() rclpy.shutdown() ``` ## 获取实时位置 在amcl节点里面运行以后, 会计算机器人的位置, 结合里程计, 发布实际的坐标变换 ```yaml amcl: ros__parameters: use_sim_time: True alpha1: 0.2 alpha2: 0.2 alpha3: 0.2 alpha4: 0.2 alpha5: 0.2 base_frame_id: \"base_footprint\" beam_skip_distance: 0.5 beam_skip_error_threshold: 0.9 beam_skip_threshold: 0.3 do_beamskip: false global_frame_id: \"map\" lambda_short: 0.1 laser_likelihood_max_dist: 2.0 laser_max_range: 100.0 laser_min_range: 1.0 laser_model_type: \"likelihood_field\" max_beams: 60 max_particles: 2000 min_particles: 500 odom_frame_id: \"odom\" pf_err: 0.05 pf_z: 0.99 recovery_alpha_fast: 0.0 recovery_alpha_slow: 0.0 resample_interval: 1 robot_model_type: \"nav2_amcl::DifferentialMotionModel\" save_pose_rate: 0.5 sigma_hit: 0.2 tf_broadcast: true # 发布实时位置 transform_tolerance: 1.0 update_min_a: 0.2 update_min_d: 0.25 z_hit: 0.5 z_max: 0.05 z_rand: 0.5 z_short: 0.05 scan_topic: scan ``` 获取的方法和之前差不多 ```python import rclpy from rclpy.node import Node from tf2_ros import TransformListener, Buffer from tf_transformations import euler_from_quaternion class TFListener(Node): def __init__(self): super().__init__('tf2_listener') self.buffer Buffer() self.listener TransformListener(self.buffer, self) self.timer self.create_timer(1, self.get_transform) def get_transform(self): try: tf self.buffer.lookup_transform( 'map', 'base_footprint', rclpy.time.Time(seconds 0), rclpy.time.Duration(seconds 1)) transform tf.transform rotation_euler euler_from_quaternion([ transform.rotation.x, transform.rotation.y, transform.rotation.z, transform.rotation.w ]) self.get_logger().info( f'平移:{transform.translation},旋转四元数:{transform.rotation}:旋转欧拉角:{rotation_euler}') except Exception as e: self.get_logger().warn(f'不能够获取坐标变换，原因: {str(e)}') def main(): rclpy.init() node TFListener() rclpy.spin(node) rclpy.shutdown() if __name__ '__main__': main() ``` ### 单点导航动作 导出的导航接口是一个action ```bash (base) jiao@jiao virtual machine:~/ros/dev_ws$ ros2 action list t /assisted_teleop [nav2_msgs/action/AssistedTeleop] /backup [nav2_msgs/action/BackUp] /compute_path_through_poses [nav2_msgs/action/ComputePathThroughPoses] /compute_path_to_pose [nav2_msgs/action/ComputePathToPose] /drive_on_heading [nav2_msgs/action/DriveOnHeading] /follow_path [nav2_msgs/action/FollowPath] /follow_waypoints [nav2_msgs/action/FollowWaypoints] /navigate_through_poses [nav2_msgs/action/NavigateThroughPoses] /navigate_to_pose [nav2_msgs/action/NavigateToPose] # 这个 /smooth_path [nav2_msgs/action/SmoothPath] /spin [nav2_msgs/action/Spin] /wait [nav2_msgs/action/Wait] ``` 实际使用的数据如下 ```bash (base) jiao@jiao virtual machine:~/ros/dev_ws$ ros2 interface show nav2_msgs/action/NavigateToPose #goal definition geometry_msgs/PoseStamped pose std_msgs/Header header builtin_interfaces/Time stamp int32 sec uint32 nanosec string frame_id Pose pose Point position float64 x float64 y float64 z Quaternion orientation float64 x 0 float64 y 0 float64 z 0 float64 w 1 string behavior_tree #result definition std_msgs/Empty result #feedback definition geometry_msgs/PoseStamped current_pose std_msgs/Header header builtin_interfaces/Time stamp int32 sec uint32 nanosec string frame_id Pose pose Point position float64 x float64 y float64 z Quaternion orientation float64 x 0 float64 y 0 float64 z 0 float64 w 1 builtin_interfaces/Duration navigation_time # 导航时间 int32 sec uint32 nanosec builtin_interfaces/Duration estimated_time_remaining # 预计剩余时间 int32 sec uint32 nanosec int16 number_of_recoveries # 脱困次数 float32 distance_remaining ``` 可以使用action进行发送`ros2 action send_goal /navigate_to_pose nav2_msgs/action/NavigateToPose \"{pose: {header: {frame_id: map}, pose: {position: { x: 2.0, y: 1.0, z: 0.0}}}}\" feedback` #### python代码 ```python import rclpy from rclpy.node import Node from tf2_ros import TransformListener, Buffer from tf_transformations import euler_from_quaternion class TFListener(Node): def __init__(self): super().__init__('tf2_listener') self.buffer Buffer() self.listener TransformListener(self.buffer, self) self.timer self.create_timer(1, self.get_transform) def get_transform(self): try: tf self.buffer.lookup_transform( 'map', 'base_footprint', rclpy.time.Time(seconds 0), rclpy.time.Duration(seconds 1)) transform tf.transform rotation_euler euler_from_quaternion([ transform.rotation.x, transform.rotation.y, transform.rotation.z, transform.rotation.w ]) self.get_logger().info( f'平移:{transform.translation},旋转四元数:{transform.rotation}:旋转欧拉角:{rotation_euler}') except Exception as e: self.get_logger().warn(f'不能够获取坐标变换，原因: {str(e)}') def main(): rclpy.init() node TFListener() rclpy.spin(node) rclpy.shutdown() if __name__ '__main__': main() ``` ### 多点导航 ```bash (base) jiao@jiao virtual machine:~/ros/dev_ws$ ros2 interface show nav2_msgs/action/FollowWaypoints #goal definition geometry_msgs/PoseStamped[] poses std_msgs/Header header builtin_interfaces/Time stamp int32 sec uint32 nanosec string frame_id Pose pose Point position float64 x float64 y float64 z Quaternion orientation float64 x 0 float64 y 0 float64 z 0 float64 w 1 #result definition 错过的点 int32[] missed_waypoints #feedback definition uint32 current_waypoint # 当前的点 ``` #### python ```python from geometry_msgs.msg import PoseStamped from nav2_simple_commander.robot_navigator import BasicNavigator, TaskResult import rclpy from rclpy.duration import Duration def main(): rclpy.init() navigator BasicNavigator() navigator.waitUntilNav2Active() # 创建点集 goal_poses [] goal_pose1 PoseStamped() goal_pose1.header.frame_id 'map' goal_pose1.header.stamp navigator.get_clock().now().to_msg() goal_pose1.pose.position.x 0.0 goal_pose1.pose.position.y 0.0 goal_pose1.pose.orientation.w 1.0 goal_poses.append(goal_pose1) goal_pose2 PoseStamped() goal_pose2.header.frame_id 'map' goal_pose2.header.stamp navigator.get_clock().now().to_msg() goal_pose2.pose.position.x 2.0 goal_pose2.pose.position.y 0.0 goal_pose2.pose.orientation.w 1.0 goal_poses.append(goal_pose2) goal_pose3 PoseStamped() goal_pose3.header.frame_id 'map' goal_pose3.header.stamp navigator.get_clock().now().to_msg() goal_pose3.pose.position.x 2.0 goal_pose3.pose.position.y 2.0 goal_pose3.pose.orientation.w 1.0 goal_poses.append(goal_pose3) # 调用路点导航服务 navigator.followWaypoints(goal_poses) # 判断结束及获取反馈 while not navigator.isTaskComplete(): feedback navigator.getFeedback() navigator.get_logger().info( f'当前目标编号：{feedback.current_waypoint}') # 最终结果判断 result navigator.getResult() if result TaskResult.SUCCEEDED: navigator.get_logger().info('导航结果：成功') elif result TaskResult.CANCELED: navigator.get_logger().warn('导航结果：被取消') elif result TaskResult.FAILED: navigator.get_logger().error('导航结果：失败') else: navigator.get_logger().error('导航结果：返回状态无效') if __name__ '__main__': main() ```"},"/note/嵌入式/ROS/ROS2/2026-1-15-02-命令行使用.html":{"title":"命令行使用","content":"# 命令行使用 ### ROS2命令 ROS2和ROS1的操作类似, 但是所有的命令集成在ros2的总命令里面 ### run ```bash $ ros2 run turtlesim turtlesim_node $ ros2 run turtlesim turtle_teleop_key ``` ### node 所有节点的控制命令 ```bash $ ros2 node list $ ros2 node info /turtlesim ``` ### 话题topic ```bash $ ros2 topic list $ ros2 topic echo /turtle1/pose # 查看具体的topic $ ros2 topic pub rate 1 /turtle1/cmd_vel geometry_msgs/msg/Twist \"{linear: {x: 2.0, y: 0.0, z: 0.0}, angular: {x: 0.0, y: 0.0, z: 1.8}}\" ``` ### server服务 ```bash $ ros2 service call /spawn turtlesim/srv/Spawn \"{x: 2, y: 2, theta: 0.2, name: ''}\" ``` ### 动作目标 ```bash $ ros2 action send_goal /turtle1/rotate_absolute turtlesim/action/RotateAbsolute \"theta: 3\" ``` ### 录制播放 ```bash $ ros2 bag record /turtle1/cmd_vel $ ros2 bag play rosbag2_2022_04_11 17_35_40/rosbag2_2022_04_11 17_35_40_0.db3 ```"},"/note/嵌入式/ROS/ROS2/2026-1-21-22-Gozebo仿真.html":{"title":"Gozebo仿真","content":"# Gozebo仿真 下载一下默认的模型 ```bash sudo apt install gazebo mkdir p ~/.gazebo/ git clone https://gitee.com/fishros/gazebo_models.git mv gazebo_models/ models rm rf models/.git gazebo ``` ![image 20260122100643617](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601221006724.png) ![image 20260122100801249](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601221008378.png) ![image 20260122101127760](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601221011913.png) 这里使用的文件也是xml文件, 里面继承拓展urdf文件, 实际使用的是sdf格式的, 可以使用工具进行转化 ```bash sudo apt get install ros $ROS_DISTRO gazebo ros pkgs ``` ## 添加模型 在虚拟机里面运行的时候使用软件渲染 ```bash source /usr/share/gazebo 11/setup.bash export GAZEBO_RESOURCE_PATH /usr/share/gazebo 11:$GAZEBO_RESOURCE_PATH # 强制使用软件渲染（虚拟机核心配置） export LIBGL_ALWAYS_SOFTWARE 1 export GAZEBO_RENDERING_API ogre ``` ### launch文件 ````python import launch import launch_ros from ament_index_python.packages import get_package_share_directory import os def generate_launch_description(): pkg_share get_package_share_directory('bot_3D_desc') default_xacro_file_path os.path.join(pkg_share, 'urdf', 'filshbot.urdf.xacro') default_gazebo_world_config_path os.path.join(pkg_share, 'world', 'custom_room.world') # 构建一个参数可以供外部传入URDF文件路径 action_declear_arg_mode_path launch.actions.DeclareLaunchArgument( name \"model\", default_value default_xacro_file_path, description \"Absolute path to robot urdf file\" ) # 读取文件的内容作为参数值 command_result launch.substitutions.Command( ['xacro ', launch.substitutions.LaunchConfiguration('model')] ) robot_desc_value launch_ros.parameter_descriptions.ParameterValue( command_result, value_type str ) # 节点：用于发布机器人状态信息 action_robot_state_publisher launch_ros.actions.Node( package 'robot_state_publisher', executable 'robot_state_publisher', name 'robot_state_publisher', parameters [{'robot_description': robot_desc_value}] ) # action_joint_state_publisher launch_ros.actions.Node( # package 'joint_state_publisher', # executable 'joint_state_publisher', # name 'joint_state_publisher', # ) # action_rviz_node launch_ros.actions.Node( # package 'rviz2', # executable 'rviz2', # name 'rviz2', # arguments [' d', default_rviz_config_path], # ) # ros2 launch gazebo_ros gazebo.launch.py world: xxx action_launch_gazebo launch.actions.IncludeLaunchDescription( launch.launch_description_sources.PythonLaunchDescriptionSource( os.path.join( get_package_share_directory('gazebo_ros'), 'launch', 'gazebo.launch.py' ) ), launch_arguments { 'world': default_gazebo_world_config_path, 'verbose': 'true' }.items() ) # 节点：用于将机器人模型生成到gazebo环境中 action_spawn_entity launch_ros.actions.Node( package 'gazebo_ros', executable 'spawn_entity.py', arguments [ ' topic', '/robot_description', ' entity', 'filshbot' ] ) return launch.LaunchDescription([ action_declear_arg_mode_path, action_robot_state_publisher, # action_joint_state_publisher, # action_rviz_node, action_launch_gazebo, action_spawn_entity ]) ```` > 运行的时候需要退出conda环境 ![image 20260122111737649](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601221117907.png) 默认的这个模型没有颜色, 需要添加新的标签 ### gazebo标签 #### 颜色 描述的是仿真的配置, 需要添加gazebo专用的标签 ```xml <gazebo reference \"laser_cylinder_link\"> <material>Gazebo/Black</material> </gazebo> <gazebo reference \"laser_link\"> <material>Gazebo/Black</material> </gazebo> ``` #### 物理属性 可以设置轮子的摩擦系数 ```xml <gazebo reference \"${wheel_name}_link\"> <material>Gazebo/Yellow</material> <! mu1:切向摩擦系数 > <! mu2:次切向摩擦系数 > <! kp:弹簧刚度 > <! kd:阻尼系数 > <mu1 value \"20.0\"/> <mu2 value \"20.0\"/> <kp value \"1000000000.0\"/> <kd value \"1.0\"/> </gazebo> ``` `mu2`是**次切向方向**的摩擦系数：针对轮子**次要运动方向**（比如机器人转弯时轮子的横向侧滑方向）。 通俗例子：轮子前进 / 后退是 mu1 方向，轮子左右侧滑（比如转弯时）是 mu2 方向。 + 太小（<5）机器人转弯时侧滑严重，比如想转 90° 却滑出半米远汽车高速转弯时的侧滑 + 适中（和 mu1 接近）转弯时侧滑轻微，机器人轨迹精准正常地面的转弯行为 + 太大（>mu1）机器人转弯不灵活，甚至 “拐不过弯”，运动僵硬履带车的转弯特性（几乎无侧滑） `kp`是接触点的弹簧刚度，意思是 “让接触点产生 1 米形变需要的力”—— 值越大，弹簧越 “硬”，形变越小。 通俗例子：钢弹簧的 kp≈1e9 N/m（硬，几乎不变形），海绵的 kp≈1e3 N/m（软，易变形） + 太小（<1e8）轮子 “陷进” 地面：视觉上机器人轮子一半埋在地面下，运动发飘，甚至无法前进轮子压在海绵 / 软泥地上 + 适中（1e8~1e9）接触点几乎无形变，机器人平稳站在地面，符合 “刚体” 仿真需求（ROS 机器人默认都是刚体）轮子压在水泥 / 柏油地面 + 太大（>1e10）Gazebo 物理计算不稳定：仿真卡顿、报错，甚至机器人 “弹飞”（数值计算爆炸）无对应真实场景（超出刚体合理范围） 阻尼系数（d）：阻尼力与运动速度成正比（Fd −d×v），单位是 N・s/m（牛・秒 / 米）；阻尼的作用是**消耗运动能量**，模拟接触时的缓冲、减震、能量损耗（比如轮子碰到地面的 “减震” 效果）。 通俗例子：汽车减震器的 kd 大（平稳），没减震的玩具车 kd 小（颠簸）。 + 太小（<0.1）轮子 “弹跳”：机器人启动 / 停止时轮子跳起来，甚至翻倒，仿真抖动严重无减震的小车在硬地面行驶 + 适中（0.1~10）接触平稳，机器人启动 / 停止无弹跳，运动顺滑带减震的机器人轮子接触地面 + 太大（>20）轮子 “发粘”：机器人启动缓慢，像在粘滞的地面（比如蜂蜜）上行驶，响应迟钝轮子粘在粘稠地面上 #### 插件 ##### 运动控制插件 可以使用插件实现机器人的控制, 两轮差速控制插件可以实现小车的控制 ```xml <?xml version \"1.0\"?> <robot xmlns:xacro \"http://www.ros.org/wiki/xacro\"> <xacro:macro name \"gazebo_control_plugin\"> <gazebo> <! 插件的名字以及使用的库 > <plugin name 'diff_drive' filename 'libgazebo_ros_diff_drive.so'> <ros> <! 命名空间, 重映射话题的名字, 这个插件会订阅cmd_vel话题并发布odom话题 这两个话题分别用于控制机器人运动和获取机器人位置信息 > <namespace>/</namespace> <remapping>cmd_vel: cmd_vel</remapping> <remapping>odom: odom</remapping> </ros> <! 信息的更新频率 > <update_rate>30</update_rate> <! wheels 轮子的关节名字 > <left_joint>left_wheel_joint</left_joint> <right_joint>right_wheel_joint</right_joint> <! kinematics 轮子的间距和直径 > <wheel_separation>0.2</wheel_separation> <wheel_diameter>0.064</wheel_diameter> <! limits 设置轮子的最大扭矩和最大加速度 > <max_wheel_torque>20</max_wheel_torque> <max_wheel_acceleration>1.0</max_wheel_acceleration> <! output 是否发布里程计和相关TF的topic > <publish_odom>true</publish_odom> <publish_odom_tf>true</publish_odom_tf> <publish_wheel_tf>true</publish_wheel_tf> <! 配置里程计和机器人基座框架的参数设置 odometry_frame: 设置里程计参考坐标系为 \"odom\"，用于发布机器人的速度和位置信息 robot_base_frame: 设置机器人基座坐标系为 \"base_footprint\"，作为机器人的中心参考点 这些配置用于Gazebo仿真中的控制插件，以正确跟踪机器人在虚拟环境中的运动状态 > <odometry_frame>odom</odometry_frame> <robot_base_frame>base_footprint</robot_base_frame> </plugin> </gazebo> </xacro:macro> </robot> ``` ```xml <xacro:include filename \"$(find bot_3D_desc)/urdf/fishbot/plugins/gazebo_control_plugin.xacro\"/> <xacro:gazebo_control_plugin/> ``` ![image 20260122115305748](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601221153827.png) 控制 ```bash ros2 run teleop_twist_keyboard teleop_twist_keyboard ``` 可以使用rqt进行查看坐标系之间的管子, 由于插件配置的基准坐标系是base_footprint, 这里导致两个轮子的坐标系不是在base_link下面的 ![image 20260122121525444](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601221215551.png) 可以同时试一下Rviz查看小车的状态 ![image 20260122122023195](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601221220332.png) ![image 20260122122158161](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601221221282.png) ![image 20260122122300844](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601221223937.png) 可以记录100组的运动数据 ##### 激光雷达插件 实现对附近环境的探测 ```xml <?xml version \"1.0\"?> <robot xmlns:xacro \"http://www.ros.org/wiki/xacro\"> <xacro:macro name \"gazebo_sensor_plugin\"> <gazebo reference \"laser_link\"> <sensor name \"laserscan\" type \"ray\"> <plugin name \"laserscan\" filename \"libgazebo_ros_ray_sensor.so\"> <ros> <namespace>/</namespace> <remapping>~/out: scan</remapping> </ros> <output_type>sensor_msgs/LaserScan</output_type> <frame_name>laser_link</frame_name> </plugin> <always_on>true</always_on> <visualize>true</visualize> <update_rate>5</update_rate> <pose>0 0 0 0 0 0</pose> <! 激光传感器配置 > <ray> <! 设置扫描范围 > <scan> <horizontal> <samples>360</samples> <resolution>1.000000</resolution> <min_angle>0.000000</min_angle> <max_angle>6.280000</max_angle> </horizontal> </scan> <! 设置扫描距离 > <range> <min>0.120000</min> <max>8.0</max> <resolution>0.015000</resolution> </range> <! 设置噪声 > <noise> <type>gaussian</type> <mean>0.0</mean> <stddev>0.01</stddev> </noise> </ray> </sensor> </gazebo> </xacro:macro> </robot> ``` 可以在rviz2里面查看可以激光雷达的范围 ![image 20260122141823223](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601221418408.png) ##### imu 获取机器的三轴角速度以及加速度 ```xml <gazebo reference \"imu_link\"> <sensor name \"imu_sensor\" type \"imu\"> <plugin name \"imu_plugin\" filename \"libgazebo_ros_imu_sensor.so\"> <ros> <namespace>/</namespace> <remapping>~/out: imu</remapping> </ros> <! 不使用初始化方向作为参考系 > <initial_orientation_as_reference>false</initial_orientation_as_reference> </plugin> <update_rate>100</update_rate> <always_on>true</always_on> <! 六轴噪声设置 > <imu> <! 角速度 > <angular_velocity> <x> <noise type \"gaussian\"> <mean>0.0</mean> <stddev>2e 4</stddev> <bias_mean>0.0000075</bias_mean> <bias_stddev>0.0000008</bias_stddev> </noise> </x> <y> <noise type \"gaussian\"> <mean>0.0</mean> <stddev>2e 4</stddev> <bias_mean>0.0000075</bias_mean> <bias_stddev>0.0000008</bias_stddev> </noise> </y> <z> <noise type \"gaussian\"> <mean>0.0</mean> <stddev>2e 4</stddev> <bias_mean>0.0000075</bias_mean> <bias_stddev>0.0000008</bias_stddev> </noise> </z> </angular_velocity> <! 线加速度 > <linear_acceleration> <x> <noise type \"gaussian\"> <mean>0.0</mean> <stddev>1.7e 2</stddev> <bias_mean>0.1</bias_mean> <bias_stddev>0.001</bias_stddev> </noise> </x> <y> <noise type \"gaussian\"> <mean>0.0</mean> <stddev>1.7e 2</stddev> <bias_mean>0.1</bias_mean> <bias_stddev>0.001</bias_stddev> </noise> </y> <z> <noise type \"gaussian\"> <mean>0.0</mean> <stddev>1.7e 2</stddev> <bias_mean>0.1</bias_mean> <bias_stddev>0.001</bias_stddev> </noise> </z> </linear_acceleration> </imu> </sensor> </gazebo> ``` 机器人打滑的时候, 里程计不准, 可以使用imu辅助进行判断 #### 深度相机 一种专门用于识别深度的相机, 一般和彩色相机一起使用, 默认前方是z轴 ```xml <link name \"camera_optical_link\"> </link> <joint name \"camera_optical_joint\" type \"fixed\"> <! 虚拟深度相机, 需要旋转, 把z轴指向前方 > <origin xyz \"0 0 0\" rpy \"${ pi/2} 0.0 ${ pi/2}\"/> <parent link \"camera_link\"/> <child link \"camera_optical_link\"/> </joint> ``` ```xml <! 使用的相机, 参考camera_link坐标系, 但是绑定在camera_optical_link > <gazebo reference \"camera_link\"> <sensor type \"depth\" name \"camera_sensor\"> <plugin name \"depth_camera\" filename \"libgazebo_ros_camera.so\"> <frame_name>camera_optical_link</frame_name> </plugin> <always_on>true</always_on> <update_rate>10</update_rate> <camera name \"camera\"> <! 视角是90° > <horizontal_fov>1.5009831567</horizontal_fov> <image> <width>800</width> <height>600</height> <format>R8G8B8</format> </image> <! 图像的畸变, 中心坐标 > <distortion> <k1>0.0</k1> <k2>0.0</k2> <k3>0.0</k3> <p1>0.0</p1> <p2>0.0</p2> <center>0.5 0.5</center> </distortion> </camera> </sensor> </gazebo> ``` ```bash (base) jiao@jiao virtual machine:~$ ros2 topic list grep camera /camera_sensor/camera_info # 信息 /camera_sensor/depth/camera_info # 深度相机 /camera_sensor/depth/image_raw # 原始深度 /camera_sensor/image_raw # 彩色相机 /camera_sensor/points ``` **机器人本体坐标系（FLU 约定）**：`camera_link` 遵循机器人行业标准 ——**前 (Forward) X、左 (Left) Y、上 (Up) Z**。这个 link 描述的是相机**物理硬件**在机器人上的安装位置，所以你能看到它有`visual`（外观）、`collision`（碰撞）、`inertia`（惯性）属性，对应真实的硬件物理特征。 **相机光学坐标系（FRD 约定）**：`camera_optical_link` 遵循计算机视觉 / ROS 视觉标准 ——**前 (Forward) Z、右 (Right) X、下 (Down) Y**。这个 link 是**虚拟坐标系**（所以没有`visual`/`collision`），唯一作用是把机器人坐标系转换为视觉算法能识别的坐标系。 ![image 20260122161346985](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601221613190.png) ![image 20260122161418018](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601221614193.png) 可以直接查看图片的效果 ![image 20260122161639910](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601221616012.png) ![image 20260122161728533](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601221617689.png)"},"/note/嵌入式/ROS/ROS2/2026-1-25-28-navigation2插件机制.html":{"title":"插件","content":"# 插件 在navigation2里面自定义插件实现路径的规划以及控制导航, 需要使用pluginlib, 这是一个用于在ros功能包里面动态加载卸载插件的c++库, 使用ClassLoader加载不同的动态链接库 所有的插件都是一个插件抽象类的子类 ## 创建 ```bash ros2 pkg create motion_control_system_ dependencies plunginlib ``` ```bash (base) jiao@jiao virtual machine:~/ros/learn_pluginlib/src$ tree . └── motion_control_system ├── CMakeLists.txt ├── include │ └── motion_control_system │ ├── motion_control_interface.hpp │ └── spin_motion_controller.hpp ├── package.xml ├── spin_motion_plugins.xml └── src └── spin_motion_controller.cpp 4 directories, 6 files ``` + motion_control_interface.cpp 创建一个纯虚函数的基类 ```cpp #ifndef MOTION_CONTROL_INTERFACE_HPP #define MOTION_CONTROL_INTERFACE_HPP namespace motion_control_system { // 创建一个抽象类 MotionController，包含纯虚函数 start 和 stop class MotionController { public: virtual void start() 0; virtual void stop() 0; }; } #endif ``` + spin_motion_controller.hpp 基于这个基类创建实际的类实现 ```cpp #ifndef SPIN_MOTION_CONTROLLER_HPP #define SPIN_MOTION_CONTROLLER_HPP #include \"motion_control_system/motion_control_interface.hpp\" namespace motion_control_system { // 创建一个抽象类 MotionController，包含纯虚函数 start 和 stop class SpinMotionController: public MotionController { public: void start() override; void stop() override; }; } #endif ``` + spin_motion_controller.cpp ```cpp #include \"iostream\" #include \"motion_control_system/spin_motion_controller.hpp\" namespace motion_control_system { void SpinMotionController::start() { // 实现旋转运动控制逻辑 std::cout << \"SpinMotionController::start\" << std::endl; } void SpinMotionController::stop() { // 停止运动控制 std::cout << \"SpinMotionController::stop\" << std::endl; } } // namespace motion_control_system #include \"pluginlib/class_list_macros.hpp\" PLUGINLIB_EXPORT_CLASS(motion_control_system::SpinMotionController, motion_control_system::MotionController) ``` + spin_motion_plugin.xml 描述文件, 描述使用的类以及基类 ```xml <library path \"spin_motion_controller\"> \t<class name \"motion_control_system/SpinMotionController\" type \"motion_control_system::SpinMotionController\" base_class_type \"motion_control_system::MotionController\"> \t <description>Spin Motion Controller</description> \t</class> </library> ``` + CMake文件 ```cmake include_directories(include) # 创建编译的库 add_library(spin_motion_controller SHARED src/spin_motion_controller.cpp) ament_target_dependencies(spin_motion_controller pluginlib ) install(TARGETS spin_motion_controller ARCHIVE DESTINATION lib LIBRARY DESTINATION lib RUNTIME DESTINATION bin ) install(DIRECTORY include/ DESTINATION include/ ) # 导出插件描述文件, 功能包的名字以及描述文件的名字 pluginlib_export_plugin_description_file(motion_control_system spin_motion_plugins.xml) ``` ## 测试插件 ```cpp #include \"motion_control_system/motion_control_interface.hpp\" #include <pluginlib/class_loader.hpp> int main(int argc, char **argv) { // 判断参数数量是否合法 if (argc ! 2) return 0; // 通过命令行参数，选择要加载的插件,argv[0]是可执行文件名，argv[1]表示参数名 std::string controller_name argv[1]; // 1.通过功能包名称和基类名称创建控制器加载器 pluginlib::ClassLoader<motion_control_system::MotionController> controller_loader(\"motion_control_system\", \"motion_control_system::MotionController\"); // 2.使用加载器加载指定名称的插件，返回的是指定插件类的对象的指针 auto controller controller_loader.createSharedInstance(controller_name); // 3.调用插件的方法 controller >start(); controller >stop(); return 0; } ``` 在链接的时候不需要显式的链接某一个库 ```cmake add_executable(test_plugin src/test_plugin.cpp) ament_target_dependencies(test_plugin pluginlib) install(TARGETS test_plugin DESTINATION lib/${PROJECT_NAME} ) ``` 运行时候指定使用的类的名字 ```bash (base) jiao@jiao virtual machine:~/ros/learn_pluginlib$ ros2 run motion_control_system test_plugin motion_control_system/SpinMotionController SpinMotionController::start SpinMotionController::stop ```"},"/note/嵌入式/ROS/ROS2/2026-1-21-21-bag记录工具.html":{"title":"bag","content":"# bag 记录一系列的控制记录 ```bash ros2 bag record /turtle1/cmd_val # 生成记录的文件夹 ros2 bag play rosbag2_xxxx_xx_xx xx_xx_xx ```"},"/note/嵌入式/ROS/ROS2/2026-1-21-19-rqt工具.html":{"title":"rqt工具","content":"# rqt工具 是一个工具框架 ![image 20260121104455161](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601211044272.png) 可以使用原有的插件以及安装新的插件 ```bash sudo apt get install ros humble rqt tf tree y rm rf ~/.config/ros.org/rqt_gui.ini ``` 默认在启动的时候会使用配置文件启动, 安装新的插件以后需要删除一下之前的插件 ![image 20260121104932191](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601211049233.png) ![image 20260121105029158](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601211050225.png)"},"/note/嵌入式/ROS/ROS2/2026-1-19-18-人脸识别.html":{"title":"人脸识别","content":"# 人脸识别 ## 工作空间 ### 参数 ```bash ros2 pkg create face_recognize_interface dependencies sensor_msgs rosidl_default_generators ``` ```xml <member_of_group>rosidl_interface_packages</member_of_group> ``` ![image 20260119172711211](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601191727314.png) ```cmake rosidl_generate_interfaces(${PROJECT_NAME} \"srv/FaceDetector.srv\" DEPENDENCIES sensor_msgs ) ``` ```xml sensor_msgs/Image image int16 number float32 use_time int32[] top int32[] left int32[] bottom int32[] right ``` ### server ```bash ros2 pkg create face_recognize_interface dependencies senser_msgs rosidl_default_generators ``` ```python data_files [ ('share/ament_index/resource_index/packages', ['resource/' + package_name]), ('share/' + package_name, ['package.xml']), ('share/' + package_name + '/resource', ['resource/default.jpg']), ], ``` ## 代码实现 ### 创建参数 ### 人脸检测 可以使用python里面的库进行人脸的检测 ```bash pip install face_recognition ``` ```python import rclpy from rclpy.node import Node import face_recognition import cv2 from ament_index_python.packages import get_package_share_directory # 用于获取包路径 def main(): # Get the path to the default image in the package resources default_image_path get_package_share_directory('face_recognize_server') + '/resource/default.jpg' print(f\"Default image path: {default_image_path}\") # 加载默认图像并进行人脸编码 image cv2.imread(default_image_path) face_locations face_recognition.face_locations(image, number_of_times_to_upsample 1, model \"cnn\") # 绘制人脸位置框 for (top, right, bottom, left) in face_locations: cv2.rectangle(image, (left, top), (right, bottom), (0, 255, 0), 2) cv2.imshow(\"Default Image with Face Locations\", image) cv2.waitKey(0) ```"},"/note/嵌入式/ROS/ROS2/2026-1-15-03-工作空间功能包.html":{"title":"工作空间功能包","content":"# 工作空间功能包 ## 工作空间 一个项目 + src: 代码空间 + install: 安装空间 + build: 编译空间 + log: 日志空间 ### 创建空间 我们从社区中下载的各种代码，多少都会有一些依赖，我们可以手动一个一个安装，也可以使用rosdep工具自动安装 ```bash mkdir p ros/src cd ros/src git clone https://gitee.com/guyuehome/ros2_21_tutorials.git ``` 创建文件夹以及下载代码文件 ### 安装依赖 ```bash $ sudo pip install rosdepc $ sudo rosdepc init $ rosdepc update $ cd .. # 自动查找src文件夹下面的所有文件, 安装依赖 $ rosdepc install i from path src rosdistro humble y ``` ### 编译 ```bash sudo apt install python3 colcon ros colcon build # 单个功能包构建 colcon build packages select demo_cpp_pkg ``` ### 工作区激活 ```bash source install/local_setup.sh # 仅在当前终端生效 ``` ## 功能包 一个机器人里面的不同功能的源码 ### 创建 ```bash ros2 pkg create build type <build type> <package_name> licence Apache 2.0 dependencies rclcpp ``` **build type**：表示新创建的功能包是C++还是Python的，如果使用C++或者C，那这里就跟ament_cmake，如果使用Python，就跟ament_python； **package_name**：新建功能包的名字。 **dependencies**: 依赖的功能包 ```bash ros2 pkg create build type ament_cmake learing_packagec ros2 pkg create build type ament_python learing_packagepython ``` ![image 20260115134654797](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601151346870.png) 在Cmake文件里面配置C语言的编译, 在setup文件里面配置实际执行的脚本, xml是文件的依赖以及基础信息, 会依照这个文件进行安装zij ![image 20260118120400504](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601181204572.png) ### xml文件 这个文件是参考, 可以添加依赖vcpb ```xml <?xml version \"1.0\"?> <?xml model href \"http://download.ros.org/schema/package_format3.xsd\" schematypens \"http://www.w3.org/2001/XMLSchema\"?> <package format \"3\"> <name>learning_node</name> <version>0.0.0</version> <description>TODO: Package description</description> <maintainer email \"hcx@todo.todo\">hcx</maintainer> <license>TODO: License declaration</license> <depend> rclpy </depend> <test_depend>ament_copyright</test_depend> <test_depend>ament_flake8</test_depend> <test_depend>ament_pep257</test_depend> <test_depend>python3 pytest</test_depend> <export> <build_type>ament_python</build_type> </export> </package> ``` 可以通过标签控制功能包的依赖, 在一个包里面加上另一个包的`<depend>`可以控制自己写的包的编译顺序 #### cmake文件 ```cmake find_package(rclcpp REQUIRED) add_executable(node_helloworld_class src/node_helloworld_class.cpp) ament_target_dependencies(node_helloworld_class rclcpp) # 文件拷贝, 指定需要复制的文件以及目标文件 install(TARGETS node_helloworld_class DESTINATION lib/${PROJECT_NAME}) # 这一段代码需要放在ament_package()之前执行, 因为使用了ament工具 ``` ![image 20260118125428536](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601181254597.png) 复制以后得文件在install目录的这个位置"},"/note/嵌入式/ROS/ROS2/2026-1-15-10-分布式系统.html":{"title":"分布式系统","content":"# 分布式系统 在ROS系统中，机器人功能是由各种节点组成的，这些节点可能位于不同的计算机中，这种结构可以将原本资源消耗较多的任务，分配到不同的平台上，减轻计算压力，这就是分布式通信框架的典型应用之一 两个电脑之间的通信，看上去还有点复杂，毕竟相互传输的数据还挺多的，不过ROS系统都已经为我们设计好了，我们只需要在每一个电脑上配置好ROS环境，功能开发上完全不需要做任何变化，实现非常方便 两个设备处于一个网络里面 ## 连接 只要处于一个网段里面就可以进行ROS2通信 ### 分组 默认所有的设备都可以通信, 但是可以使用分组的方式进行区分 ```bash export ROS_DOMAIN_ID 数字 ``` 还可以配置 ```bash export ROS_LOCALHOST_ONLY 1 ``` 只在本地主机"},"/note/嵌入式/ROS/ROS2/2026-1-26-33-PID.html":{"title":"PID算法","content":"# PID算法 计算期望输出以及反馈信号之间的误差, 根据一定数学模型计算出控制信号, 使得目标系统可以稳定的到达期望的输出 ![Screenshot_20260126_182543](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601261826059.jpg) 对误差以及累计的误差计算获取到实际的输出值, Error是当前的误差值, 在比较简单的系统里面可以不计算第三项, 实际的电机在比较小的数值的时候是不动的, 误差小于一定值的时候需要使用累计误差进行调整 > 只有第一项, 在到达对应位置的时候会直接关闭, 只有前两个的话会抖动的比较厉害, 没有对当前速度的考虑 在实际计算的时候, PID一般积分有一个上限, 避免见减去的时候花的时间太长, 输出的值也有限制的最大最小值 ## 代码实现 ```cpp #ifndef __PID_CONTROLLER_H__ #define __PID_CONTROLLER_H__ class PidController { public: PidController() default; PidController(float kp, float ki, float kd); private: // PID 参数，可以调节的 float target_; float out_min_; float out_max_; float kp_; float ki_; float kd_; float intergral_up_ 2500; // 积分上限 // pid 中间过程值 float error_; float error_sum_; float derror_; float prev_error_; public: float update(float current); // 提供当前值，返回下次输出值，也就是PID的结果 void update_target(float target); // 更新目标值 void update_pid(float kp, float ki, float kd); // 更新PID参数 void reset(); // 重置PID void out_limit(float min, float max); // 设置输出限制 }; #endif // __PID_CONTROLLER_H__ ``` ```cpp #include \"Arduino.h\" #include \"PidController.h\" // 构造函数，传入三个PID参数 PidController::PidController(float kp, float ki, float kd) { kp_ kp; ki_ ki; kd_ kd; } float PidController::update(float current) { error_ target_ current; // 计算error error_sum_ + error_; // 计算error_sum,同时限制积分上下限 if (error_sum_ > intergral_up_) error_sum_ intergral_up_; if (error_sum_ < 1 * intergral_up_) error_sum_ 1 * intergral_up_; derror_ prev_error_ error_; // 计算误差变化率 prev_error_ error_; // 方便下次计算使用 float output kp_ * error_ + ki_ * error_sum_ + kd_ * derror_; if (output > out_max_) output out_max_; if (output < out_min_) output out_min_; return output; } void PidController::update_target(float target) { target_ target; } void PidController::update_pid(float kp, float ki, float kd) { kp_ kp; ki_ ki; kd_ kd; } void PidController::reset() { error_sum_ 0; prev_error_ 0; error_ 0; derror_ 0; kp_ 0; ki_ 0; kd_ 0; intergral_up_ 2500; out_min_ 0; out_max_ 0; } void PidController::out_limit(float min, float max) { out_min_ min; out_max_ max; } ```"},"/note/嵌入式/ROS/ROS2/2026-1-17-15-三维仿真.html":{"title":"三维仿真","content":"# 三维仿真 机器人三维物理仿真平台**Gazebo**是ROS系统中最为常用的**三维物理仿真平台**，支持动力学引擎，可以实现高质量的图形渲染，不仅可以模拟机器人及周边环境，还可以加入摩擦力、弹性系数等物理属性 ```bash sudo apt install ros humble gazebo * ``` 可以帮助我们验证机器人算法、优化机器人设计、测试机器人场景应用，为机器人开发提供更多可能。 ```bash export SVGA_VGPU 0 # 使用CPU export LIBGL_ALWAYS_SOFTWARE 1 ros2 launch gazebo_ros gazebo.launch.py ``` ## 模型 ### XACRO 可以使用DRDF模型优化以后, 使用XACRO文件描述, XACRO文件加入了更多编程化的实现方法，可以让模型创建更友好。 **宏定义**，一个小车有4个轮子，每个轮子都一样，我们就没必要创建4个一样的link，像函数定义一样，做一个可重复使用的模块就可以了。 **文件包含**，复杂机器人的模型文件可能会很长，为了切分不同的模块，比如底盘、传感器，我们还可以把不同模块的模型放置在不同的文件中，然后再用一个总体文件做包含调用。 **可编程接口**，比如在XACRO模型文件中，定义一些常量，描述机器人的尺寸，定义一些变量，在调用宏定义的时候传递数据，还可以在模型中做数据计算，甚至加入条件语句，比如你的机器人叫A，就有摄像头，如果叫B，就没有摄像头。 ```bash $ sudo apt install ros humble xacro ``` #### 常量 ![image 20220528150321426](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601171633332.png) `<xacro:property>`标签用来定义一些常量，比如这样定义一个PI的常量名为“M_PI”，值为“3.14159”，在调用的时候，通过$加大括号，里边就可以使用定义好的常量了 针对原本移动机器人的URDF文件，我们就可以把底盘的质量、尺寸，轮子的质量、尺寸、安装位置，这些不会变化的数据，都通过常量定义 ![image 20220528150338969](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601171634534.png) #### 数学计算 ![image 20220528150430205](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601171634432.png) 如果需要做数学计算，同样是在“${}”中进行，比如某一个位置，我们可以通过这两个常量做运算得到，就加入了加法和除法运算 > 所有数学运算都会转换成浮点数进行，以保证运算精度 #### 宏定义 ![image 20220528150542643](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601171635886.png) 定义方式是通过这个<xacro:macro>标签描述的，还可以像函数一样，设置里边会用到的一些参数，比如这里的A、B、C #### 引用文件 ![image 20220528150712684](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601171635325.png) ### 仿真配置参数 确保每一个link都有惯性参数和碰撞属性，因为Gazebo是物理仿真平台，必要的物理参数是一定需要的 + 完善物理参数![image 20220528150842585](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601171638577.png) + 添加Gazebo标签渲染每一个link的颜色![image 20220528150931153](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601171640434.png) + 给运动的joint设置传动装置, 可以理解为仿真了一个电机![image 20220528150958309](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601171640206.png) + 添加控制器插件小车是差速控制的，那就添加差速控制器插件，这样在不同角度下两个电机的速度分配，就可以交给控制器插件来完成了![image 20220528151019063](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601171640100.png) ## 实战 ### xacro文件 ```xml <?xml version \"1.0\"?> <! 只有主文件里面使用name这个参数 > <robot xmlns:xacro \"http://www.ros.org/wiki/xacro\" name \"first_robot\"> <xacro:macro name \"base_link\" params \"length radius\"> <! 身体部分 > <link name \"base_link\"> <! 外观描述 > <visual> <! 描述沿着自己几何中心的位移以及旋转 > <origin xyz \"0.0 0.0 0.0\" rpy \"0.0 0.0 0.0\"/> <! 形状描述, 单位 米 > <geometry> <cylinder radius \"${radius}\" length \"${length}\"/> </geometry> <! 颜色描述 > <material name \"white\"> <color rgba \"1.0 1.0 1.0 0.5\"/> </material> </visual> </link> </xacro:macro> <xacro:macro name \"imu_link\" params \"name xyz\"> <! 机器人的IMU, 惯性测量传感器 > <link name \"${name}\"> <! 外观描述 > <visual> <! 描述沿着自己几何中心的位移以及旋转 > <origin xyz \"0.0 0.0 0.0\" rpy \"0.0 0.0 0.0\"/> <! 形状描述, 单位 米 正方体 > <geometry> <box size \"0.02 0.02 0.02\"/> </geometry> <! 颜色描述 > <material name \"black\"> <color rgba \"0.0 0.0 0.0 0.5\"/> </material> </visual> </link> <! 连接身体和IMU的关节, 把IMU固定在身体上 > <joint name \"${name}_joint\" type \"fixed\"> <origin xyz \"${xyz}\" rpy \"0.0 0.0 0.0\"/> <parent link \"base_link\"/> <child link \"${name}\"/> </joint> </xacro:macro> <xacro:base_link length \"0.12\" radius \"0.10\"> <xacro:imu_link name \"imu_link\" xyz \"0.0 0.0 0.03\"> <xacro:imu_link name \"imu_link_2\" xyz \"0.0 0.0 0.03\"> </robot> ``` ### 预处理 需要把这个文件转为urdf文件 ```bash sudo apt get install ros $ROS_DISTRO xacro xacro first_robot.xacro # 直接输出转换后的文件 ``` 之后可以直接使用这个命令输入给描述生成launch ```python import launch import launch_ros from ament_index_python.packages import get_package_share_directory import os def generate_launch_description(): pkg_share get_package_share_directory('bot_3D_desc') default_urdf_file_path os.path.join(pkg_share, 'urdf', 'first_robot.xacro') default_rviz_config_path os.path.join(pkg_share, 'config', 'display_robot.rviz') # 构建一个参数可以供外部传入URDF文件路径 action_declear_arg_mode_path launch.actions.DeclareLaunchArgument( name \"model\", default_value default_urdf_file_path, description \"Absolute path to robot urdf file\" ) # 读取文件的内容作为参数值 command_result launch.substitutions.Command( ['xacro ', launch.substitutions.LaunchConfiguration('model')] ) robot_desc_value launch_ros.parameter_descriptions.ParameterValue( command_result, value_type str ) # 节点：用于发布机器人状态信息 action_robot_state_publisher launch_ros.actions.Node( package 'robot_state_publisher', executable 'robot_state_publisher', name 'robot_state_publisher', parameters [{'robot_description': robot_desc_value}] ) action_joint_state_publisher launch_ros.actions.Node( package 'joint_state_publisher', executable 'joint_state_publisher', name 'joint_state_publisher', ) action_rviz_node launch_ros.actions.Node( package 'rviz2', executable 'rviz2', name 'rviz2', arguments [' d', default_rviz_config_path], ) return launch.LaunchDescription([ action_declear_arg_mode_path, action_robot_state_publisher, action_joint_state_publisher, action_rviz_node ]) ``` ### 实际实现 #### 基座 ```xml <?xml version \"1.0\"?> <robot xmlns:xacro \"http://www.ros.org/wiki/xacro\"> <xacro:macro name \"base_xacro\" params \"length radius\"> <! 地面投影, 无实际的显示 > <link name \"base_footprint\"/> <! 身体部分 > <link name \"base_link\"> <! 外观描述 > <visual> <! 描述沿着自己几何中心的位移以及旋转 > <origin xyz \"0.0 0.0 0.0\" rpy \"0.0 0.0 0.0\"/> <! 形状描述, 单位 米 > <geometry> <cylinder radius \"${radius}\" length \"${length}\"/> </geometry> <! 颜色描述 > <material name \"white\"> <color rgba \"1.0 1.0 1.0 0.5\"/> </material> </visual> <collision> <! 描述沿着自己几何中心的位移以及旋转 > <origin xyz \"0.0 0.0 0.0\" rpy \"0.0 0.0 0.0\"/> <! 形状描述, 单位 米 > <geometry> <cylinder radius \"${radius}\" length \"${length}\"/> </geometry> <! 颜色描述 > <material name \"white\"> <color rgba \"1.0 1.0 1.0 0.5\"/> </material> </collision> </link> <! 绑定一个虚拟地面 > <joint name \"joint_name\" type \"fixed\"> <origin xyz \"0.0 0.0 ${length/2 + 0.032 0.001}\" rpy \"0.0 0.0 0.0\"/> <parent link \"base_footprint\"/> <child link \"base_link\"/> </joint> </xacro:macro> </robot> ``` #### 传感器 雷达 ```xml <?xml version \"1.0\"?> <robot xmlns:xacro \"http://www.ros.org/wiki/xacro\"> <xacro:macro name \"laser_xacro\" params \"xyz\"> <! 雷达支撑杆 > <link name \"laser_cylinder_link\"> <! 外观描述 > <visual> <! 描述沿着自己几何中心的位移以及旋转 > <origin xyz \"0.0 0.0 0.0\" rpy \"0.0 0.0 0.0\"/> <! 形状描述, 单位 米 圆柱体 > <geometry> <cylinder radius \"0.01\" length \"0.1\"/> </geometry> <! 颜色描述 > <material name \"black\"> <color rgba \"0.0 0.0 0.0 1.5\"/> </material> </visual> <collision> <! 描述沿着自己几何中心的位移以及旋转 > <origin xyz \"0.0 0.0 0.0\" rpy \"0.0 0.0 0.0\"/> <! 形状描述, 单位 米 圆柱体 > <geometry> <cylinder radius \"0.01\" length \"0.1\"/> </geometry> <! 颜色描述 > <material name \"black\"> <color rgba \"0.0 0.0 0.0 1.5\"/> </material> </collision> </link> <! 雷达传感器 > <link name \"laser_link\"> <! 外观描述 > <visual> <! 描述沿着自己几何中心的位移以及旋转 > <origin xyz \"0.0 0.0 0.0\" rpy \"0.0 0.0 0.0\"/> <! 形状描述, 单位 米 圆柱体 > <geometry> <cylinder radius \"0.02\" length \"0.02\"/> </geometry> <! 颜色描述 > <material name \"black\"> <color rgba \"0.0 0.0 0.0 1.0\"/> </material> </visual> </link> <! 连接身体和激光传感器的关节, 把激光传感器固定在身体上 > <joint name \"laser_cylinder_joint\" type \"fixed\"> <origin xyz \"0.0 0.0 0.05\" rpy \"0.0 0.0 0.0\"/> <parent link \"laser_cylinder_link\"/> <child link \"laser_link\"/> </joint> <joint name \"laser_joint\" type \"fixed\"> <origin xyz \"${xyz}\" rpy \"0.0 0.0 0.0\"/> <parent link \"base_link\"/> <child link \"laser_cylinder_link\"/> </joint> </xacro:macro> </robot> ``` #### 执行器件 轮子 ```xml <?xml version \"1.0\"?> <robot xmlns:xacro \"http://www.ros.org/wiki/xacro\"> <xacro:macro name \"wheel_xacro\" params \"wheel_name xyz\"> <! 机器人的驱动轮胎 > <link name \"${wheel_name}_link\"> <! 外观描述 > <visual> <! 描述沿着自己几何中心的位移以及旋转 > <origin xyz \"0.0 0.0 0.0\" rpy \"1.57079 0.0 0.0\"/> <! 形状描述, 单位 米 圆柱体 > <geometry> <cylinder radius \"0.032\" length \"0.04\"/> </geometry> <! 颜色描述 > <material name \"yellow\"> <color rgba \"1.0 1.0 0.0 0.8\"/> </material> </visual> <collision> <! 描述沿着自己几何中心的位移以及旋转 > <origin xyz \"0.0 0.0 0.0\" rpy \"1.57079 0.0 0.0\"/> <! 形状描述, 单位 米 圆柱体 > <geometry> <cylinder radius \"0.032\" length \"0.04\"/> </geometry> <! 颜色描述 > <material name \"yellow\"> <color rgba \"1.0 1.0 0.0 0.8\"/> </material> </collision> </link> <! 连接身体和IMU的关节, 把IMU固定在身体上 > <joint name \"${wheel_name}_joint\" type \"continuous\"> <origin xyz \"${xyz}\" rpy \"0.0 0.0 0.0\"/> <parent link \"base_link\"/> <child link \"${wheel_name}_link\"/> <! 绕 Y 轴旋转 > <axis xyz \"0.0 1.0 0.0\"/> </joint> </xacro:macro> </robot> ``` #### 合并 ```xml <?xml version \"1.0\"?> <robot xmlns:xacro \"http://www.ros.org/wiki/xacro\" name \"fishbot\"> <xacro:include filename \"$(find bot_3D_desc)/urdf/fishbot/base.urdf.xacro\"/> <xacro:include filename \"$(find bot_3D_desc)/urdf/fishbot/sensor/imu.urdf.xacro\"/> <xacro:include filename \"$(find bot_3D_desc)/urdf/fishbot/sensor/camera.urdf.xacro\"/> <xacro:include filename \"$(find bot_3D_desc)/urdf/fishbot/sensor/laser.urdf.xacro\"/> <xacro:include filename \"$(find bot_3D_desc)/urdf/fishbot/actuator/wheel.urdf.xacro\"/> <xacro:include filename \"$(find bot_3D_desc)/urdf/fishbot/actuator/caster.urdf.xacro\"/> <xacro:base_xacro length \"0.12\" radius \"0.10\"/> <xacro:imu_xacro xyz \"0.0 0.0 0.02\"/> <xacro:camera_xacro xyz \"0.10 0.0 0.075\"/> <xacro:laser_xacro xyz \"0.0 0.0 0.10\"/> <xacro:wheel_xacro wheel_name \"left_wheel\" xyz \"0.0 0.10 0.06\"/> <xacro:wheel_xacro wheel_name \"right_wheel\" xyz \"0.0 0.10 0.06\"/> <xacro:caster_xacro caster_name \"front_wheel\" xyz \"0.08 0.0 0.076\"/> <xacro:caster_xacro caster_name \"back_wheel\" xyz \" 0.08 0.0 0.076\"/> </robot> ``` ![image 20260121155149069](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601211551237.png) ### 添加物理属性 机器人是有质量以及惯性的, 曹亮可以使用一个数字千克表示, 旋转惯性需要使用一个3x3的矩阵表示 ![image 20260121185203662](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601211852795.png) 这里面有一部分的数字是重复的, 可以使用六个数字表示, 一般可以从建模软件里面获取, ![image 20260121190617562](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601211906642.png) 可以直接使用下面的这几个公式进行计算 ```xml <?xml version \"1.0\"?> <robot xmlns:xacro \"http://ros.org/wiki/xacro\"> <xacro:macro name \"box_inertia\" params \"m w h d\"> <inertial> <mass value \"${m}\" /> <inertia ixx \"${(m/12) * (h*h + d*d)}\" ixy \"0.0\" ixz \"0.0\" iyy \"${(m/12) * (w*w + d*d)}\" iyz \"0.0\" izz \"${(m/12) * (w*w + h*h)}\" /> </inertial> </xacro:macro> <xacro:macro name \"cylinder_inertia\" params \"m r h\"> <inertial> <mass value \"${m}\" /> <inertia ixx \"${(m/12) * (3*r*r + h*h)}\" ixy \"0\" ixz \"0\" iyy \"${(m/12) * (3*r*r + h*h)}\" iyz \"0\" izz \"${(m/2) * (r*r)}\" /> </inertial> </xacro:macro> <xacro:macro name \"sphere_inertia\" params \"m r\"> <inertial> <mass value \"${m}\" /> <inertia ixx \"${(2/5) * m * (r*r)}\" ixy \"0.0\" ixz \"0.0\" iyy \"${(2/5) * m * (r*r)}\" iyz \"0.0\" izz \"${(2/5) * m * (r*r)}\" /> </inertial> </xacro:macro> </robot> ``` ![image 20260121192133618](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601211921725.png) ![image 20260121193439175](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601211934306.png)"},"/note/嵌入式/ROS/ROS2/2026-1-26-32-机器人搭建.html":{"title":"机器人搭建","content":"# 机器人搭建 ## 硬件 ### 传感器 + 编码器: 获取轮子的姿态, 计算小车的位置 + 激光雷达: 获取距离信息 + 超声波: + IMU ### 执行器 电机 ### 决策 负责依据传感器的内容控制机器人的运动, 需要的算力比较大 ### 其他 电池等 ## 软件 安装platform IO 使用Vscode插件进行安装, 安装以后的插件在用户目录里面创建`.platformio`文件夹, 可以在`penv`子目录里面`. bin/activate`进行激活, `pip install platformio` `pio project init`: 创建项目"},"/note/嵌入式/ROS/ROS2/2026-1-27-41-不同DDS.html":{"title":"DDS","content":"# DDS 在实际使用的时候选择DDS不能一刀切, 需要考虑许可证资源消耗等多种因素, ROS2在设计时候通过定义抽象的中间件(ROS Middleware 简称rmw)接口适配不同的DDS 可以在电脑安装不同的DDS, 使用的时候通过配置环境变量进行 ```bash sudo spt search ros humble rmw * ``` ## 配置文件 不同的配置文DDS可以通过配置文件来进行配置 ```xml <?xml version \"1.0\" encoding \"UTF 8\" ?> <profiles xmlns \"http://www.eprosima.com/XMLSchemas/fastRTPS_Profiles\"> <! 默认发布者配置 > <publisher profile_name \"default_publisher\" is_default_profile \"true\"> <historyMemoryPolicy>DYNAMIC</historyMemoryPolicy> </publisher> <! 默认订阅者配置 > <subscriber profile_name \"default_subscriber\" is_default_profile \"true\"> <historyMemoryPolicy>DYNAMIC</historyMemoryPolicy> </subscriber> <! 话题 chatter 的发布者配置 > <publisher profile_name \"/chatter\"> <historyMemoryPolicy>DYNAMIC</historyMemoryPolicy> <matchedSubscribersAllocation> <initial>0</initial> <maximum>1</maximum> <increment>1</increment> </matchedSubscribersAllocation> </publisher> </profiles> ``` 限制`/chatter`的最大的订阅者数量是1 ```bash export RMW_IMPLEMENTATION rmw_fastrtps_cpp # 使用的DDS export RMW_FASTRTPS_USE_QOS_FROM_XML 1 export FASTRTPS_DEFAULT_PROFILES_FILE ./topic_sub_limit.xml ros2 run demo_nodes_cpp talker ``` ## 共享内存 对于不在同一个节点, 但是在同一个主机的节点, 可以使用共享内存的通信, 需要对DDS额外配置, 实际使用的时候, 发布数据需要从中间件里面租借存放消息的数据块, 存入消息, 之后把数据描述发布出去, 接受者获取以后, 从提供的内存里面读取数据 ```cpp #include \"rclcpp/loaned_message.hpp\" #include \"rclcpp/rclcpp.hpp\" #include \"std_msgs/msg/int32.hpp\" class LoanedMessagePublisher : public rclcpp::Node { public: LoanedMessagePublisher() : Node(\"loaned_message_publisher\") { publisher_ this >create_publisher<std_msgs::msg::Int32>(\"loaned_int_topic\", 10); timer_ this >create_wall_timer(std::chrono::seconds(1), [&]() { auto message publisher_ >borrow_loaned_message(); // 1.租借消息 message.get().data count_++; // 2.放入数据 RCLCPP_INFO(this >get_logger(), \"发布数据:%d\", message.get().data); publisher_ >publish(std::move(message)); // 3.发布数据 }); } private: rclcpp::Publisher<std_msgs::msg::Int32>::SharedPtr publisher_; rclcpp::TimerBase::SharedPtr timer_; int32_t count_{0}; }; int main(int argc, char **argv) { rclcpp::init(argc, argv); auto node std::make_shared<LoanedMessagePublisher>(); rclcpp::spin(node); rclcpp::shutdown(); return 0; } ``` 使用的配置文件 ```xml <?xml version \"1.0\" encoding \"UTF 8\" ?> <profiles xmlns \"http://www.eprosima.com/XMLSchemas/fastRTPS_Profiles\"> <data_writer profile_name \"default publisher profile\" is_default_profile \"true\"> <qos> <publishMode> <kind>SYNCHRONOUS</kind> </publishMode> <data_sharing> <kind>AUTOMATIC</kind> </data_sharing> </qos> <historyMemoryPolicy>DYNAMIC</historyMemoryPolicy> </data_writer> <data_reader profile_name \"default subscription profile\" is_default_profile \"true\"> <qos> <data_sharing> <kind>AUTOMATIC</kind> </data_sharing> </qos> <historyMemoryPolicy>DYNAMIC</historyMemoryPolicy> </data_reader> </profiles> ```"},"/note/嵌入式/ROS/ROS2/2026-1-16-13-TF坐标系.html":{"title":"TF坐标系","content":"# TF坐标系 ## 示例 ```bash sudo apt install ros humble turtle tf2 py ros humble tf2 tools sudo pip3 install transforms3d ros2 launch turtle_tf2_py turtle_tf2_demo.launch.py ros2 run turtlesim turtle_teleop_key # 查看坐标系结构 ros2 run tf2_tools view_frames # 查看坐标之间的关系 ros2 run tf2_ros tf2_echo turtle2 turtle1 # 可视化界面 ros2 run rviz2 rviz2 d $(ros2 pkg prefix share turtle_tf2_py)/rviz/turtle_rviz.rviz ``` ![image 20260116212533125](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601162125208.png) ```bash # 创建两个坐标系, 基础坐标以及雷达的坐标(静态) ros2 run tf2_ros static_transform_publisher x 0.1 y 0.0 z 0.2 roll 0.0 pitch 0.0 yaw 0.0 frame id base_link child frame id base_laser # 创建墙的坐标基于雷达坐标 ros2 run tf2_ros static_transform_publisher x 0.3 y 0.0 z 0.0 roll 0.0 pitch 0.0 yaw 0.0 frame id base_laser child frame id wall_point # 获取相对坐标 (base) jiao@jiao virtual machine:~/ros/ros2_21_tutorials$ ros2 run tf2_ros tf2_echo base_link wall_point [INFO] [1768898775.078954176] [tf2_echo]: Waiting for transform base_link > wall_point: Invalid frame ID \"base_link\" passed to canTransform argument target_frame frame does not exist At time 0.0 Translation: [0.400, 0.000, 0.200] # 位移 Rotation: in Quaternion (xyzw) [0.000, 0.000, 0.000, 1.000] # 旋转 Rotation: in RPY (radian) [0.000, 0.000, 0.000] Rotation: in RPY (degree) [0.000, 0.000, 0.000] Matrix: # 旋转矩阵 1.000 0.000 0.000 0.400 0.000 1.000 0.000 0.000 0.000 0.000 1.000 0.200 0.000 0.000 0.000 1.000 # 查看坐标系结构框图 ros2 run tf2_tools view_frames ``` 可视化展示几种旋转的关系 ```bash sudo apt get install mrpt apps y 3d rotation converter ``` ![image 20260120165803321](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601201658588.png) ![image 20260120170003402](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601201700554.png) 实际的原理使用的是topic在发布消息 ```bash # 所有的节点 (base) jiao@jiao virtual machine:~$ ros2 topic list /parameter_events /rosout /tf_static # 发布节点的信息 (base) jiao@jiao virtual machine:~$ ros2 topic info /tf_static Type: tf2_msgs/msg/TFMessage Publisher count: 2 Subscription count: 0 # 使用的数据类型, 实际是两个坐标系的相对位置发布 (base) jiao@jiao virtual machine:~$ ros2 interface show tf2_msgs/msg/TFMessage geometry_msgs/TransformStamped[] transforms \t# \t# \tstd_msgs/Header header \t\tbuiltin_interfaces/Time stamp \t\t\tint32 sec \t\t\tuint32 nanosec \t\tstring frame_id \tstring child_frame_id \tTransform transform \t\tVector3 translation \t\t\tfloat64 x \t\t\tfloat64 y \t\t\tfloat64 z \t\tQuaternion rotation \t\t\tfloat64 x 0 \t\t\tfloat64 y 0 \t\t\tfloat64 z 0 \t\t\tfloat64 w 1 ``` ### 坐标广播 #### 静态坐标变化 坐标系的位置是不变的 ```python import rclpy from rclpy.node import Node from geometry_msgs.msg import TransformStamped import tf_transformations from tf2_ros.static_transform_broadcaster import StaticTransformBroadcaster class StaticTFBroadcaster(Node): def __init__(self, name): super().__init__(name) # 创建一个TF广播器对象 self.tf_broadcaster StaticTransformBroadcaster(self) # 创建一个坐标变换的消息对象 static_transformStamped TransformStamped() # 设置坐标变换消息的时间戳 static_transformStamped.header.stamp self.get_clock().now().to_msg() # 设置一个坐标变换的源坐标系 static_transformStamped.header.frame_id 'world' # 设置一个坐标变换的目标坐标系 static_transformStamped.child_frame_id 'house' # 设置坐标变换中的X、Y、Z向的平移 static_transformStamped.transform.translation.x 10.0 static_transformStamped.transform.translation.y 5.0 static_transformStamped.transform.translation.z 0.0 # 将欧拉角转换为四元数（roll, pitch, yaw） quat tf_transformations.quaternion_from_euler(0.0, 0.0, 0.0) # 设置坐标变换中的X、Y、Z向的旋转（四元数） static_transformStamped.transform.rotation.x quat[0] static_transformStamped.transform.rotation.y quat[1] static_transformStamped.transform.rotation.z quat[2] static_transformStamped.transform.rotation.w quat[3] # 广播静态坐标变换，广播后两个坐标系的位置关系保持不变 self.tf_broadcaster.sendTransform(static_transformStamped) def main(args None): rclpy.init(args args) node StaticTFBroadcaster(\"static_tf_broadcaster\") rclpy.spin(node) node.destroy_node() ``` 可以使用math进行弧度以及角度的变化 ```python math.radians(180) ``` #### 运动广播 ```python import rclpy # ROS2 Python接口库 from rclpy.node import Node # ROS2 节点类 from geometry_msgs.msg import TransformStamped # 坐标变换消息 import tf_transformations # TF坐标变换库 from tf2_ros import TransformBroadcaster # TF坐标变换广播器 from turtlesim.msg import Pose # turtlesim小海龟位置消息 class TurtleTFBroadcaster(Node): def __init__(self, name): super().__init__(name) \t\t# 创建一个海龟名称的参数 self.declare_parameter('turtlename', 'turtle') # 优先使用外部设置的参数值，否则用默认值 self.turtlename self.get_parameter( 'turtlename').get_parameter_value().string_value \t\t# 创建一个TF坐标变换的广播对象并初始化 self.tf_broadcaster TransformBroadcaster(self) \t\t# 创建一个订阅者，订阅海龟的位置消息, 使用参数中获取到的海龟名称 self.subscription self.create_subscription( Pose, f'/{self.turtlename}/pose', self.turtle_pose_callback, 1) def turtle_pose_callback(self, msg): # 创建一个坐标变换的消息对象 transform TransformStamped() # 设置坐标变换消息的时间戳 transform.header.stamp self.get_clock().now().to_msg() # 设置一个坐标变换的源坐标系 transform.header.frame_id 'world' # 设置一个坐标变换的目标坐标系, 设置坐标变换中的X、Y、Z向的平移 transform.child_frame_id self.turtlename transform.transform.translation.x msg.x transform.transform.translation.y msg.y transform.transform.translation.z 0.0 # 将欧拉角转换为四元数（roll, pitch, yaw） q tf_transformations.quaternion_from_euler(0, 0, msg.theta) # 设置坐标变换中的X、Y、Z向的旋转（四元数） transform.transform.rotation.x q[0] transform.transform.rotation.y q[1] transform.transform.rotation.z q[2] transform.transform.rotation.w q[3] # Send the transformation self.tf_broadcaster.sendTransform(transform) def main(args None): rclpy.init(args args) node TurtleTFBroadcaster(\"turtle_tf_broadcaster\") rclpy.spin(node) node.destroy_node() rclpy.shutdown() ``` ### 监听 ```python import rclpy from rclpy.node import Node import tf_transformations from tf2_ros import TransformException from tf2_ros.buffer import Buffer from tf2_ros.transform_listener import TransformListener class TFListener(Node): def __init__(self, name): super().__init__(name) # 创建一个源坐标系名的参数, 如果外部（启动文件、命令行参数、参数服务器）已经为该参数设置了值 → 声明操作仅确认参数存在，不会覆盖外部值； self.declare_parameter('source_frame', 'world') # 优先使用外部设置的参数值，否则用默认值 self.source_frame self.get_parameter( 'source_frame').get_parameter_value().string_value \t\t# 创建一个目标坐标系名的参数 self.declare_parameter('target_frame', 'house') self.target_frame self.get_parameter( 'target_frame').get_parameter_value().string_value \t\t# 创建保存坐标变换信息的缓冲区 self.tf_buffer Buffer() # 创建坐标变换的监听器 self.tf_listener TransformListener(self.tf_buffer, self) self.timer self.create_timer(1.0, self.on_timer) def on_timer(self): try: # 获取ROS系统的当前时间 now rclpy.time.Time() # 监听当前时刻源坐标系到目标坐标系的坐标变换, 获取标准数据 # 可以输入两个时间, 查询的时间以及超时时间 trans self.tf_buffer.lookup_transform( self.target_frame, self.source_frame, now) # 如果坐标变换获取失败，进入异常报告 except TransformException as ex: self.get_logger().info( f'Could not transform {self.target_frame} to {self.source_frame}: {ex}') return # 获取位置信息 pos trans.transform.translation # 获取姿态信息（四元数） quat trans.transform.rotation euler tf_transformations.euler_from_quaternion([quat.x, quat.y, quat.z, quat.w]) self.get_logger().info('Get %s > %s transform: [%f, %f, %f] [%f, %f, %f]' % (self.source_frame, self.target_frame, pos.x, pos.y, pos.z, euler[0], euler[1], euler[2])) def main(args None): rclpy.init(args args) node TFListener(\"tf_listener\") rclpy.spin(node) node.destroy_node() rclpy.shutdown() ``` ### 海龟跟踪示例 ```python import math import rclpy from rclpy.node import Node import tf_transformations from tf2_ros import TransformException from tf2_ros.buffer import Buffer from tf2_ros.transform_listener import TransformListener from geometry_msgs.msg import Twist from turtlesim.srv import Spawn class TurtleFollowing(Node): def __init__(self, name): super().__init__(name) self.declare_parameter('source_frame', 'turtle1') self.source_frame self.get_parameter( 'source_frame').get_parameter_value().string_value self.tf_buffer Buffer() self.tf_listener TransformListener(self.tf_buffer, self) \t\t# 创建一个请求产生海龟的客户端 self.spawner self.create_client(Spawn, 'spawn') # 是否已经请求海龟生成服务的标志位 self.turtle_spawning_service_ready False # 海龟是否产生成功的标志位 self.turtle_spawned False \t\t# 创建跟随运动海龟的速度话题 self.publisher self.create_publisher(Twist, 'turtle2/cmd_vel', 1) self.timer self.create_timer(1.0, self.on_timer) def on_timer(self): from_frame_rel self.source_frame # 目标坐标系 to_frame_rel 'turtle2' \t\t# 如果已经请求海龟生成服务 if self.turtle_spawning_service_ready: # 如果跟随海龟已经生成 if self.turtle_spawned: try: # 获取ROS系统的当前时间 now rclpy.time.Time() # 监听当前时刻源坐标系到目标坐标系的坐标变换 trans self.tf_buffer.lookup_transform( to_frame_rel, from_frame_rel, now) except TransformException as ex: self.get_logger().info( f'Could not transform {to_frame_rel} to {from_frame_rel}: {ex}') return \t\t\t # 创建速度控制消息 msg Twist() # 根据海龟角度，计算角速度 scale_rotation_rate 1.0 msg.angular.z scale_rotation_rate * math.atan2( trans.transform.translation.y, trans.transform.translation.x) \t\t\t # 根据海龟距离，计算线速度 scale_forward_speed 0.5 msg.linear.x scale_forward_speed * math.sqrt( trans.transform.translation.x ** 2 + trans.transform.translation.y ** 2) # 发布速度指令，海龟跟随运动 self.publisher.publish(msg) else: # 如果跟随海龟没有生成 if self.result.done(): self.get_logger().info( f'Successfully spawned {self.result.result().name}') self.turtle_spawned True # 依然没有生成跟随海龟 else: self.get_logger().info('Spawn is not finished') else: # 如果没有请求海龟生成服务, 如果海龟生成服务器已经准备就绪 if self.spawner.service_is_ready(): # 创建一个请求的数据 request Spawn.Request() # 设置请求数据的内容，包括海龟名、xy位置、姿态 request.name 'turtle2' request.x float(4) request.y float(2) request.theta float(0) \t\t\t # 发送服务请求 self.result self.spawner.call_async(request) # 设置标志位，表示已经发送请求 self.turtle_spawning_service_ready True else: # 海龟生成服务器还没准备就绪的提示 self.get_logger().info('Service is not ready') def main(args None): rclpy.init(args args) node TurtleFollowing(\"turtle_following\") rclpy.spin(node) node.destroy_node() rclpy.shutdown() ``` ### 启动脚本 ```python from launch import LaunchDescription from launch.actions import DeclareLaunchArgument from launch.substitutions import LaunchConfiguration from launch_ros.actions import Node def generate_launch_description(): return LaunchDescription([ Node( package 'turtlesim', executable 'turtlesim_node', name 'sim' ), Node( package 'learning_tf', executable 'turtle_tf_broadcaster', name 'broadcaster1', parameters [ {'turtlename': 'turtle1'} ] ), DeclareLaunchArgument( 'target_frame', default_value 'turtle1', description 'Target frame name.' ), Node( package 'learning_tf', executable 'turtle_tf_broadcaster', name 'broadcaster2', parameters [ {'turtlename': 'turtle2'} ] ), Node( package 'learning_tf', executable 'turtle_following', name 'listener', parameters [ {'target_frame': LaunchConfiguration('target_frame')} ] ), ]) ``` ### cpp #### 静态 ```cpp #include \"rclcpp/rclcpp.hpp\" #include \"tf2/LinearMath/Quaternion.h\" #include \"tf2_ros/static_transform_broadcaster.h\" #include \"geometry_msgs/msg/transform_stamped.hpp\" class StaticTFBroadcaster : public rclcpp::Node { public: explicit StaticTFBroadcaster() : Node(\"static_tf_broadcaster\") // ROS2节点父类初始化 { // 创建一个TF广播器对象 tf_static_broadcaster_ std::make_shared<tf2_ros::StaticTransformBroadcaster>(this); // 广播静态坐标变换，广播后两个坐标系的位置关系保持不变 this >make_transforms(); } private: void make_transforms() { // 创建一个坐标变换的消息对象 geometry_msgs::msg::TransformStamped t; // 设置坐标变换消息的时间戳 t.header.stamp this >get_clock() >now(); // 设置一个坐标变换的源坐标系 t.header.frame_id \"world\"; // 设置一个坐标变换的目标坐标系 t.child_frame_id \"house\"; // 设置坐标变换中的X、Y、Z向的平移 t.transform.translation.x 10.0; t.transform.translation.y 5.0; t.transform.translation.z 0.0; // 将欧拉角转换为四元数（roll, pitch, yaw） tf2::Quaternion q; q.setRPY(0.0, 0.0, 0.0); // 设置坐标变换中的X、Y、Z向的旋转（四元数） t.transform.rotation.x q.x(); t.transform.rotation.y q.y(); t.transform.rotation.z q.z(); t.transform.rotation.w q.w(); // 可以使用这个替代 // t.transform.rotation tf2::toMsg(q); // 广播静态坐标变换 tf_static_broadcaster_ >sendTransform(t); } std::shared_ptr<tf2_ros::StaticTransformBroadcaster> tf_static_broadcaster_; }; int main(int argc, char * argv[]) { // ROS2 C++接口初始化 rclcpp::init(argc, argv); // 创建ROS2节点对象并进行初始化,循环等待ROS2退出 rclcpp::spin(std::make_shared<StaticTFBroadcaster>()); // 关闭ROS2 C++接口 rclcpp::shutdown(); return 0; } ``` ```cmake # find dependencies find_package(ament_cmake REQUIRED) find_package(geometry_msgs REQUIRED) find_package(rclcpp REQUIRED) find_package(tf2 REQUIRED) find_package(tf2_ros REQUIRED) find_package(turtlesim REQUIRED) add_executable(static_tf_broadcaster src/static_tf_broadcaster.cpp) ament_target_dependencies( static_tf_broadcaster geometry_msgs rclcpp tf2 tf2_ros ) ``` #### 动态 ```cpp #include \"rclcpp/rclcpp.hpp\" #include \"tf2/LinearMath/Quaternion.h\" #include \"tf2_ros/transform_broadcaster.h\" #include \"geometry_msgs/msg/transform_stamped.hpp\" #include \"chrono\" using namespace std::chrono_literals; // 可以直接使用100ms等表示 class TFBroadcaster : public rclcpp::Node { public: explicit StaticTFBroadcaster() : Node(\"static_tf_broadcaster\") // ROS2节点父类初始化 { // 创建一个TF广播器对象 tf_broadcaster_ std::make_shared<tf2_ros::TransformBroadcaster>(this); timer_ this >create_wall_timer(100ms, std::bind(&TFBroadcaster::publish_tf, this)); } private: void make_transforms() { // 创建一个坐标变换的消息对象 geometry_msgs::msg::TransformStamped t; // 设置坐标变换消息的时间戳 t.header.stamp this >get_clock() >now(); // 设置一个坐标变换的源坐标系 t.header.frame_id \"world\"; // 设置一个坐标变换的目标坐标系 t.child_frame_id \"house\"; // 设置坐标变换中的X、Y、Z向的平移 t.transform.translation.x 10.0; t.transform.translation.y 5.0; t.transform.translation.z 0.0; // 将欧拉角转换为四元数（roll, pitch, yaw） tf2::Quaternion q; q.setRPY(0.0, 0.0, 0.0); // 设置坐标变换中的X、Y、Z向的旋转（四元数） t.transform.rotation.x q.x(); t.transform.rotation.y q.y(); t.transform.rotation.z q.z(); t.transform.rotation.w q.w(); // 可以使用这个替代 // t.transform.rotation tf2::toMsg(q); // 广播坐标变换 tf_broadcaster_ >sendTransform(t); } \t\trclcpp::TimerBase::SharedPtr timer_; std::shared_ptr<tf2_ros::TransformBroadcaster> tf_broadcaster_; }; int main(int argc, char * argv[]) { // ROS2 C++接口初始化 rclcpp::init(argc, argv); // 创建ROS2节点对象并进行初始化,循环等待ROS2退出 rclcpp::spin(std::make_shared<StaticTFBroadcaster>()); // 关闭ROS2 C++接口 rclcpp::shutdown(); return 0; } ``` #### 查询动态关系 ```cpp #include <chrono> #include <functional> #include <memory> #include <string> #include \"rclcpp/rclcpp.hpp\" #include \"tf2/exceptions.h\" #include \"tf2_ros/transform_listener.h\" #include \"tf2_ros/buffer.h\" using namespace std::chrono_literals; class TFListener : public rclcpp::Node { public: TFListener() : Node(\"tf_listener\") //ROS2节点父类初始化 { // 创建一个目标坐标系名的参数,优先使用外部设置的参数值，否则用默认值 target_frame_ this >declare_parameter<std::string>(\"target_frame\", \"house\"); // 创建保存坐标变换信息的缓冲区 tf_buffer_ std::make_unique<tf2_ros::Buffer>(this >get_clock()); // 创建坐标变换的监听器 tf_listener_ std::make_shared<tf2_ros::TransformListener>(*tf_buffer_); // 创建一个固定周期的定时器，处理坐标信息 timer_ this >create_wall_timer(1s, std::bind(&TFListener::on_timer, this)); } private: void on_timer() { // 设置源坐标系和目标坐标系的名称 std::string target_frame target_frame_.c_str(); std::string source_frame \"world\"; geometry_msgs::msg::TransformStamped trans; // 监听当前时刻源坐标系到目标坐标系的坐标变换 try { trans tf_buffer_ >lookupTransform( target_frame, source_frame, tf2::TimePointZero); } catch (const tf2::TransformException & ex) { // 如果坐标变换获取失败，进入异常报告 RCLCPP_INFO( this >get_logger(), \"Could not transform %s to %s: %s\", target_frame.c_str(), source_frame.c_str(), ex.what()); return; } // 四元数转换为欧拉角 tf2::Quaternion q( trans.transform.rotation.x, trans.transform.rotation.y, trans.transform.rotation.z, trans.transform.rotation.w); tf2::Matrix3x3 m(q); double roll, pitch, yaw; m.getRPY(roll, pitch, yaw); // 打印查询到的坐标信息 RCLCPP_INFO( this >get_logger(), \"Get %s > %s transform: [%f, %f, %f] [%f, %f, %f]\", source_frame.c_str(), target_frame.c_str(), trans.transform.translation.x, trans.transform.translation.y, trans.transform.translation.z, roll, pitch, yaw); } rclcpp::TimerBase::SharedPtr timer_{nullptr}; std::shared_ptr<tf2_ros::TransformListener> tf_listener_{nullptr}; std::unique_ptr<tf2_ros::Buffer> tf_buffer_; std::string target_frame_; }; int main(int argc, char * argv[]) { // ROS2 C++接口初始化 rclcpp::init(argc, argv); // 创建ROS2节点对象并进行初始化,循环等待ROS2退出 rclcpp::spin(std::make_shared<TFListener>()); // 关闭ROS2 C++接口 rclcpp::shutdown(); return 0; } ``` ## 手眼坐标变换 通过机械臂以及摄像头的关系, 计算物品和机械臂的关系 ```bash sudo apt get install ros $ROS_DISTRO tf transformations pip install transforms3d ros2 pkg create demo_tf build type ament_python dependencies rclpy geometry_msgs tf_ros tf_transformations ```"},"/note/嵌入式/ROS/ROS2/2026-1-26-31-MicroROS.html":{"title":"MicroROS","content":"# MicroROS ## 部署 ### 电脑 需要运行一个docker的镜像监听端口连接开发板, 开启一个代理, 之后使用串口/蓝牙/以太网等形式连接开发板 <img src \"https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601262034678.png\" alt \"image 20260126203437623\" style \"zoom:150%;\" /> 在ros的src目录里面添加两个组件 ```bash git clone https://github.com/micro ROS/micro ROS Agent.git b $ROS_DISTRO git clone https://github.com/micro ROS/micro_ros_msgs.git b $ROS_DISTRO cd .. colcon build source install/setup.bash ros2 run micro_ros_agent micro_ros_agent udp4 port 8888 ``` ### 控制 #### imu 查看imu的演示 ```bash sudo apt get install ros humble rviz imu plugin ```"},"/note/嵌入式/ROS/ROS1/2026-1-13-04-Publisher编程实现.html":{"title":"Publisher","content":"# Publisher ![image 20260113131637769](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601131316893.png) ## 实现 ###创建功能包 ```bash catkin_create_pkg learning_topic roscpp rospy std_msgs geometry_msgs turtlesim ``` ### cpp代码 + 初始化ROS节点 + 向ROS Master里面注册节点, 包括发布的话题以及消息的类型 + 创建消息 + 按照频率发送 ```cpp #include <ros/ros.h> #include <geometry_msgs/Twist.h> int main(int argc, char ** argv){ // 初始化ROS节点 ros::init(argc, argv, \"velocity_publish\"); // 创建节点句柄 ros::NodeHandle n; // 创建一个publisher 发布/turtle1/cmd_vel的topic, 消息类型是geometry_msgs::Twist, 长度为10(缓冲大小) // 缓冲区满了的时候默认去除最老的信息 ros::Publisher turtle_val_pub n.advertise<geometry_msgs::Twist>(\"/turtle1/cmd_vel\", 10); ros::Rate loop_rate(10); // 循环的频率 int count 0; while(ros::ok()){ //初始化Twist类型的消息 geometry_msgs::Twist vel_msg; vel_msg.linear.x 0.5; vel_msg.angular.z 0.2; // 发布消息 turtle_val_pub.publish(vel_msg); ROS_INFO(\"Publish command[%0.2f m/s, %0.2f rad/s]\", vel_msg.linear.x, vel_msg.angular.z); loop_rate.sleep(); } return 0; } ``` > 1. 单独看`vel_msg.linear.x 0.5` > > 机器人会**以 0.5 米 / 秒的速度沿自身正前方直线前进**（无转向），对应你的玩具机器人：两个驱动电机以相同速度正转，机器人直走，每秒前进 50 厘米。 > > 2. 单独看`vel_msg.angular.z 0.2` > > 机器人会**原地顺时针旋转**（无前进 / 后退），旋转速度是 0.2 弧度 / 秒。 > > 换算成直观的角度：1 弧度≈57.3°，所以 0.2rad/s ≈ 11.46°/ 秒（每秒转约 11.5 度）； > > 旋转方向规则（ROS 右手定则）：右手竖起大拇指指向 Z 轴正方向（垂直地面向上），四指弯曲的方向就是旋转方向 —— > > ``` > angular.z > ``` > > 为正数是顺时针转，负数是逆时针转。 > > 对应你的玩具机器人：左侧电机正转、右侧电机反转（或左侧转速快于右侧），机器人在原地慢慢顺时针转，每秒转约 11.5 度。 > > 3. 两者结合（核心）：`linear.x 0.5 + angular.z 0.2` > > 机器人会做 **“前进 + 顺时针转向” 的圆弧运动 **（不是直走，也不是原地转）： > > 整体趋势：一边以 0.5m/s 向前走，一边以 11.5°/ 秒顺时针转向（也就是机器人向前的同时向右拐）； > > 可计算转弯半径（量化理解）： > > 转弯半径 线速度角速度米意味着机器人会沿着半径 2.5 米的圆形轨迹，向前 + 顺时针移动（类似汽车打右方向慢速前进的效果）。 > > 转弯半径 线速度 / 角速度 > > 玩具机器人的实际表现 > > 你的 3V 13 转的微型电机驱动轮式机器人，收到这个指令后： > > 前进速度：0.5m/s（50cm / 秒），如果电机转速不够，ROS 会按比例调节电机占空比，尽量接近这个速度； > 转向效果：每秒向右转约 11.5 度，前进 50 厘米的同时，转向约 11.5 度，整体走一个平缓的右转弯圆弧。 > > 只发一次指令无法实现持续的前进 + 右转效果，因为 ROS 速度指令是 “瞬时指令”，硬件需要持续信号才能维持运动； > > 循环以 10Hz 发布指令，本质是持续 “刷新” 运动指令，告诉机器人 “继续保持当前速度运动”； > > 对你的玩具机器人来说，只发一次指令电机只会抖一下，只有循环发布才能看到明显的前进 + 转弯效果。 添加CMake配置 ```cmake add_executable(velocity_publish src/velocity_publisher.cpp) target_link_libraries(velocity_publish ${catkin_LIBRARIES}) ``` 编译使用 ```bash catkin_make source devel/setup.bash roscore rosrun turtlesim turtlesim_node rosrun learning_topic velocity_publish ``` ### python ```python #!/usr/bin/env python # * coding: utf 8 * ######################################################################## #### Copyright 2020 GuYueHome (www.guyuehome.com). ### ######################################################################## # 该例程将发布turtle1/cmd_vel话题，消息类型geometry_msgs::Twist import rospy from geometry_msgs.msg import Twist def velocity_publisher(): \t# ROS节点初始化 rospy.init_node('velocity_publisher', anonymous True) \t# 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10 turtle_vel_pub rospy.Publisher('/turtle1/cmd_vel', Twist, queue_size 10) \t#设置循环的频率 rate rospy.Rate(10) while not rospy.is_shutdown(): \t\t# 初始化geometry_msgs::Twist类型的消息 vel_msg Twist() vel_msg.linear.x 0.5 vel_msg.angular.z 0.2 \t\t# 发布消息 turtle_vel_pub.publish(vel_msg) \trospy.loginfo(\"Publsh turtle velocity command[%0.2f m/s, %0.2f rad/s]\", \t\t\t\tvel_msg.linear.x, vel_msg.angular.z) \t\t# 按照循环频率延时 rate.sleep() if __name__ '__main__': try: velocity_publisher() except rospy.ROSInterruptException: pass ```"},"/note/嵌入式/ROS/ROS1/2026-1-13-03-工作空间功能包.html":{"title":"工作空间/功能包","content":"# 工作空间/功能包 ## 工作空间 存放一个工程开发相关文件的文件夹 + src: 代码空间, 所有的功能包 + build: 编译空间 + devel: 开发空间, 开发时候的可执行文件, 以及库文件(开发中的执行文件) + install: 安装空间, 最终的可执行文件(开发后的执行文件) ![image 20260113121250585](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601131212642.png) ## 创建 ```bash # 创建工作空间, 文件的命令需要是src (base) jiao@jiao:~/JHY/ros$ mkdir p catkin_ws/src (base) jiao@jiao:~/JHY/ros$ cd catkin_ws/src/ (base) jiao@jiao:~/JHY/ros/catkin_ws/src$ catkin_init_workspace # 初始化文件夹 Creating symlink \"/home/jiao/JHY/ros/catkin_ws/src/CMakeLists.txt\" pointing to \"/opt/ros/noetic/share/catkin/cmake/toplevel.cmake\" # 编译, 在根目录进行 cd ../ catkin_make # 安装 catkin_make install (base) jiao@jiao:~/JHY/ros/catkin_ws$ ls build devel install src ``` ### 创建功能包 所有的代码都是在一个功能包里面, 所以需要创建一个功能包, 同一个工作空间里面不可以有名字一样的功能包 ```bash cd src # catkin_create_pkg <package_name> [depend1] [depend2] ... # 使用ros的标志数据结构, cpp以及py接口 catkin_create_pkg test_pkg std_msgs roscpp rospy (base) jiao@jiao:~/JHY/ros/catkin_ws/src$ tree . ├── CMakeLists.txt > /opt/ros/noetic/share/catkin/cmake/toplevel.cmake └── test_pkg ├── CMakeLists.txt ├── include # 头文件 │ └── test_pkg ├── package.xml └── src # 源码文件 4 directories, 3 files ``` 编译 ```bash # 在根目录里面 catkin_make # 设置公共空间变量 source devel/setup.bash # 实际是获取到变量 (base) jiao@jiao:~/JHY/ros/catkin_ws$ echo $ROS_PACKAGE_PATH /home/jiao/JHY/ros/catkin_ws/src:/opt/ros/noetic/share ``` ### 功能包基本文件 #### CMake 编译基本规则 #### package.xml + 名字, 版本信息, 维护email, 开源许可证 + 依赖信息"},"/note/嵌入式/ROS/ROS1/2026-1-13-07-同步Client实现.html":{"title":"Client实现","content":"# Client实现 ![image 20260113182603842](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601131826904.png) ## 代码 ### cpp ```cpp /*********************************************************************** Copyright 2020 GuYueHome (www.guyuehome.com). ***********************************************************************/ /** * 该例程将请求/spawn服务，服务数据类型turtlesim::Spawn */ #include <ros/ros.h> #include <turtlesim/Spawn.h> // 使用的数据类型 int main(int argc, char** argv) { // 初始化ROS节点 \tros::init(argc, argv, \"turtle_spawn\"); // 创建节点句柄 \tros::NodeHandle node; // 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service \t// 阻塞等待这个服务的创建 \tros::service::waitForService(\"/spawn\"); \t// 创建这个客户端, 用于发送数据 \tros::ServiceClient add_turtle node.serviceClient<turtlesim::Spawn>(\"/spawn\"); // 初始化turtlesim::Spawn的请求数据, 填入数据 \tturtlesim::Spawn srv; \tsrv.request.x 2.0; \tsrv.request.y 2.0; \tsrv.request.name \"turtle2\"; // 请求服务调用 \tROS_INFO(\"Call service to spwan turtle[x:%0.6f, y:%0.6f, name:%s]\", \t\t\t srv.request.x, srv.request.y, srv.request.name.c_str()); \tadd_turtle.call(srv); \t// 显示服务调用结果 \tROS_INFO(\"Spwan turtle successfully [name:%s]\", srv.response.name.c_str()); \treturn 0; }; ``` ### python ```python #!/usr/bin/env python # * coding: utf 8 * ######################################################################## #### Copyright 2020 GuYueHome (www.guyuehome.com). ### ######################################################################## # 该例程将请求/spawn服务，服务数据类型turtlesim::Spawn import sys import rospy from turtlesim.srv import Spawn def turtle_spawn(): \t# ROS节点初始化 rospy.init_node('turtle_spawn') \t# 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service rospy.wait_for_service('/spawn') try: add_turtle rospy.ServiceProxy('/spawn', Spawn) \t\t# 请求服务调用，输入请求数据 response add_turtle(5.0, 3.0, 0.0, \"turtle3\") return response.name except rospy.ServiceException as e: print(f\"Service call failed: {e}\") if __name__ \"__main__\": \t#服务调用并显示调用结果 print(\"Spwan turtle successfully [name:%s]\" %(turtle_spawn())) ```"},"/note/嵌入式/ROS/ROS1/2026-1-12-01-基础介绍.html":{"title":"ROS","content":"# ROS Robot Operating System机器人领域的一个标准 + 通信机制 + 开发工具 + 应用功能 + 生态系统 ## 安装 ```bash sudo sh c '. /etc/lsb release && echo \"deb http://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ `lsb_release cs` main\" > /etc/apt/sources.list.d/ros latest.list' sudo apt key adv keyserver 'hkp://keyserver.ubuntu.com:80' recv key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 sudo apt update sudo apt install ros melodic desktop full sudo apt install python rosdep2 conda create n ros python 3.10 conda activate ros sudo rosdep init sudo pip3 install rosdep2 upgrade sudo rosdep init sudo rosdep update echo \"source /opt/ros/melodic/setup.bash\" >> ~/.bashrc ``` 默认安装在opt/ros里面, 现在安装的是melodic版本 ```bash #测试 # roscore # 仿真器 rosrun turtlesim turtlesim_node # 控制节点 rosrun turtlesim turtle_teleop_key ``` ## 概念 ### 通信机制 是一个松耦合的分布式通信机制 ![image 20260112212600094](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601122126158.png) 不同的功能之间连接, 抽象成为一个计算图 ### 开发工具 ![image 20260112213102381](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601122131549.png) ### 应用功能 ![image 20260112213208816](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601122132960.png) 实现不同机器人的功能包![](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601122132960.png)![](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601122132960.png) ### 生态系统 1.发行版（Distribution）：ROS发行版包括一系列带有版本号、可以直接安装的功能包。 2.软件源（Repository）：ROS依赖于共享网络上的开源代码，不同的组织机构可以开发或者共享自己的机器人软件。 3.ROSwiki：记录ROS信息文档的主要论坛。 4.邮件列表（Mailinglist)：交流ROS更新的主要渠道，同时也可以交流ROS开发的各种疑问。 5.ROSAnswers：咨询ROS相关问题的网站。 6.博客（Blog）：发布ROS社区中的新闻、图片、视频(http://www.ros.org/news) ![image 20260112214824198](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601122148261.png) ### 通信机制 #### 节点node ![image 20260113101839324](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601131018453.png) + 节点: 以及具体的**执行单元**, 可以独立运行的文件, 可以使用不同的语言, 名称必须是唯一的 + 节点管理器(ROS Master): 为节点提供命名以及注册服务, 跟踪以及记录话题/服务通信, 辅助节点互相查找, 建立连接, 提供参数服务器, 节点使用服务器存储以及检索运行时候的参数 ![image 20260113102140091](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601131021156.png) #### 异步topic + 话题: **异步**通信机制, 节点之间使用发布以及订阅的形式 + 消息: 话题里面数据, 有一定的类型以及数据结构, 可以自定义, 通过.msg文件配置, 编译的过程中生成对应的文件 ![image 20260113105003595](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601131050644.png) #### 同步Server + 服务(Server): **同步**数据传输机制, 使用客户端服务器的形式, 客户端发送请求, 服务器完成请求处理以后应答, 使用编程语言无关的.srv文件定义请求和应答数据结构, 编译的过程生成对应的代码(一般是单词请求单次配置) ![image 20260113105610354](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601131056410.png) ![image 20260113105703656](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601131057725.png) #### 区分 ![image 20260113110513032](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601131105123.png) #### 参数 全局共享的字典, 通过网络进行共享, 可以使用这个服务器存储以及检索运行时候的参数, 适合存储静态, 非二进制的配置参数, 不适合存储动态的配置参数 ![image 20260113111108418](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601131111479.png) #### 文件系统 + 功能包: ROS功能的基本单元, 包含源码, 配置文件, 数据定义 + 功能包清单: 记录包的基本功能, 包含作者信息, 许可证, 依赖配置, 编译标志 + 元功能包: 组织多个用于同一个目的的功能包 ![image 20260113111703523](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601131117614.png)"},"/note/嵌入式/ROS/ROS1/2026-1-14-11-坐标系管理系统.html":{"title":"坐标系管理系统","content":"# 坐标系管理系统 ## 坐标系转换 有两个坐标系, 希望知道一个坐标系里面的点另一个坐标系的表示 ![image 20260114135749115](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601141357221.png) ![image 20260114140926375](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601141409444.png) 在实际的变化的时候, 首先转轴, 之后进行移轴, 在三维的时候, 旋转的时候是围绕其中一个轴进行旋转, 固定一个轴, 这个时候可以简化为一个二维的坐标轴旋转, 旋转变化实际就是一个旋转矩阵, 二维的旋转矩阵到三维的变化是使三维向量的对应不变的轴只有一个1 公式：![image 20260114141208261](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601141412295.png) 推导背景：笛卡尔坐标的 3 维矢量需要 “旋转矩阵 × 矢量 + 平移矢量” 两步计算，不便工程应用（比如多坐标系串联变换），因此引入**齐次坐标**（将 3 维矢量扩展为 4 维），用一个 4×4 矩阵整合旋转和平移 > 旋转的时候按照逆时针的角是正的 ## TF工具包 用于方便计算坐标系相对于全局坐标的位置 <img src \"https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601141459859.png\" alt \"image 20260114145918792\" style \"zoom:50%;\" /> 记录十秒钟之内的所有坐标系的关系, 一个点对于不同的坐标系的位置 > 是一个广播监听的机制, 在启动ROS Master+ TF之后, 维护一个TF树, 所有的节点可以查询这个树获取 ![image 20260114150236042](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601141502128.png) ### 效果演示 ```bash sudo apt get install ros noetic turtle tf # 启动示例脚本 roslaunch turtle_tf turtle_tf_demo.launch # 控制 rosrun turtlesim turtle_teleop_key # 查看所有的坐标系关系, 生成一个pdf文件 (base) jiao@jiao:~/JHY/ros/catkin_ws$ rosrun tf view_frames WARNING: tf view_frames is deprecated. Use tf2_tools view_frames.py instead. Listening to /tf for 5.0 seconds Done Listening frames.pdf generated ``` 实际的效果是一个海龟跟随另一个在移动 ![image 20260114151445204](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601141514246.png) ```bash # 使用命令查看位置变化 (base) jiao@jiao:~/JHY/ros/catkin_ws$ rosrun tf tf_echo turtle1 turtle2 At time 1768375788.341 Translation: [0.000, 0.000, 0.000] Rotation: in Quaternion [0.000, 0.000, 0.885, 0.465] in RPY (radian) [0.000, 0.000, 2.173] in RPY (degree) [0.000, 0.000, 124.516] At time 1768375788.996 Translation: [0.000, 0.000, 0.000] Rotation: in Quaternion [0.000, 0.000, 0.885, 0.465] in RPY (radian) [0.000, 0.000, 2.173] in RPY (degree) [0.000, 0.000, 124.516] At time 1768375790.005 Translation: [0.000, 0.000, 0.000] Rotation: in Quaternion [0.000, 0.000, 0.885, 0.465] in RPY (radian) [0.000, 0.000, 2.173] in RPY (degree) [0.000, 0.000, 124.516] ``` + Translation: 平移 + Rotation: 角度 + + Quaternion: 四元数, 3D 旋转的数值稳定表示 + RPY: 弧度以及角度的显示 > 你之前看到的`RPY (degree) [0.000, 0.000, 124.516]`就是欧拉角（横滚 Roll、俯仰 Pitch、偏航 Yaw），它把 3D 旋转拆成 “绕 x 轴转、绕 y 轴转、绕 z 轴转” 三步，虽然直观，但有致命缺陷： > > **万向锁（Gimbal Lock）**：当俯仰角（Pitch）转到 90° 时，横滚（Roll）和偏航（Yaw）的旋转轴会重合，丢失一个旋转自由度（比如无人机俯仰 90° 后，无法区分横滚和偏航）。 > 旋转顺序敏感：欧拉角的结果和 “先绕哪个轴转” 强相关（比如先绕 x 再绕 y，和先绕 y 再绕 x 结果不同），容易出错。 > > 四元数的数学形式是：q w+xi+yj+zk > > 也常写成向量形式（工程中更常用）：q [w,x,y,z]（注意：不同库可能顺序不同，你看到的`[0.000, 0.000, 0.885, 0.465]`是`[x, y, z, w]`顺序） > > 四元数表示的旋转本质是 “**绕x, y, z 3D 轴旋转 w 角度**”（轴 角表示法） 可视化 ```bash export LIBGL_ALWAYS_SOFTWARE 1 rosrun rviz rviz d `rospack fimd turtle_tf` / rviz/turtle_rviz.rviz ``` ![image 20260114155621506](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601141556575.png) ![image 20260114155722866](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601141557963.png) ## 代码使用 ### 广播位置 ```cpp #include <ros/ros.h> #include <tf/transform_broadcaster.h> #include <turtlesim/Pose.h> std::string turtle_name; void poseCallback(const turtlesim::PoseConstPtr& msg) { \t// 创建tf的广播器 \tstatic tf::TransformBroadcaster br; \t// 初始化tf数据, 创建一个广播器 \ttf::Transform transform; \ttransform.setOrigin( tf::Vector3(msg >x, msg >y, 0.0) ); // 位移 \ttf::Quaternion q; // 旋转, 这里三个参数是横滚, 俯仰, 偏航, 只设置一下偏航即可 // 这一步把海龟的 2D 偏航角转换成了 TF 能识别的四元数旋转。 \tq.setRPY(0, 0, msg >theta); \ttransform.setRotation(q); \t// 广播world与海龟坐标系之间的tf数据, 设置相对于world, 以及节点的名字 \tbr.sendTransform(tf::StampedTransform(transform, ros::Time::now(), \"world\", turtle_name)); } int main(int argc, char** argv) { // 初始化ROS节点 \tros::init(argc, argv, \"my_tf_broadcaster\"); \t// 输入参数作为海龟的名字 \tif (argc ! 2) \t{ \t\tROS_ERROR(\"need turtle name as argument\"); \t\treturn 1; \t} \tturtle_name argv[1]; \t// 订阅海龟的位姿话题 \tros::NodeHandle node; \tros::Subscriber sub node.subscribe(turtle_name+\"/pose\", 10, &poseCallback); // 循环等待回调函数 \tros::spin(); \treturn 0; }; ``` ### 获取相对关系 ```cpp #include <ros/ros.h> #include <tf/transform_listener.h> #include <geometry_msgs/Twist.h> #include <turtlesim/Spawn.h> int main(int argc, char** argv) { \t// 初始化ROS节点 \tros::init(argc, argv, \"my_tf_listener\"); // 创建节点句柄 \tros::NodeHandle node; \t// 请求产生turtle2 \tros::service::waitForService(\"/spawn\"); \tros::ServiceClient add_turtle node.serviceClient<turtlesim::Spawn>(\"/spawn\"); \tturtlesim::Spawn srv; \tadd_turtle.call(srv); \t// 创建发布turtle2速度控制指令的发布者 \tros::Publisher turtle_vel node.advertise<geometry_msgs::Twist>(\"/turtle2/cmd_vel\", 10); \t// 创建tf的监听器, 用于监听任意坐标系之间的tf数据 \ttf::TransformListener listener; \tros::Rate rate(10.0); \twhile (node.ok()) \t{ \t\t// 获取turtle1与turtle2坐标系之间的tf数据 \t\ttf::StampedTransform transform; \t\ttry \t\t{ \t\t\t// 等待有两个坐标系, 超时3秒 \t\t\tlistener.waitForTransform(\"/turtle2\", \"/turtle1\", ros::Time(0), ros::Duration(3.0)); \t\t\t// 获取两个坐标系之间的相对变换关系 \t\t\tlistener.lookupTransform(\"/turtle2\", \"/turtle1\", ros::Time(0), transform); \t\t} \t\tcatch (tf::TransformException &ex) \t\t{ \t\t\tROS_ERROR(\"%s\",ex.what()); \t\t\tros::Duration(1.0).sleep(); \t\t\tcontinue; \t\t} \t\t// 根据turtle1与turtle2坐标系之间的位置关系，发布turtle2的速度控制指令 \t\t// \t\tgeometry_msgs::Twist vel_msg; // ROS定义的速度消息类型 \t\t// 角速度设置为与目标点的夹角的4倍 \t\t// 线速度设置为与目标点距离的0.5倍 \t\t// 这样可以让turtle2快速地转向turtle1，并且接近turtle1 \t\t// atan2(y, x)：数学中的反正切函数，作用是计算 “从 x 轴正方向到点 (x,y) \t\t// 的夹角”（单位：弧度），这个夹角就是turtle2需要旋转的角度 \t\tvel_msg.angular.z 4.0 * atan2(transform.getOrigin().y(), \t\t\t\t transform.getOrigin().x()); \t\tvel_msg.linear.x 0.5 * sqrt(pow(transform.getOrigin().x(), 2) + \t\t\t\t pow(transform.getOrigin().y(), 2)); \t\tturtle_vel.publish(vel_msg); \t\trate.sleep(); \t} \treturn 0; }; ``` 测试命令 ```bash # 启动两个汇报, 为避免名字一样, 需要单独设置一下 rosrun learning_tf turtle_tf_broadcaster __name: turtle1_tf_broadcaster /turtle1 & rosrun learning_tf turtle_tf_broadcaster __name: turtle2_tf_broadcaster /turtle2 & # 启动一个监听 rosrun learning_tf turtle_tf_listener & rosrun turtlesim turtle_teleop_key ``` ### python版本 ```python import roslib roslib.load_manifest('learning_tf') import rospy import tf import turtlesim.msg def handle_turtle_pose(msg, turtlename): br tf.TransformBroadcaster() br.sendTransform((msg.x, msg.y, 0), tf.transformations.quaternion_from_euler(0, 0, msg.theta), rospy.Time.now(), turtlename, \"world\") if __name__ '__main__': rospy.init_node('turtle_tf_broadcaster') # 获取一个局部的变量, 名字是turtle, 在命令行里面设置 turtlename rospy.get_param('~turtle') rospy.Subscriber('/%s/pose' % turtlename, turtlesim.msg.Pose, handle_turtle_pose, turtlename) rospy.spin() ``` ```python import roslib roslib.load_manifest('learning_tf') import rospy import math import tf import geometry_msgs.msg import turtlesim.srv if __name__ '__main__': rospy.init_node('turtle_tf_listener') listener tf.TransformListener() \t# 监听一下创建海龟的server rospy.wait_for_service('spawn') spawner rospy.ServiceProxy('spawn', turtlesim.srv.Spawn) spawner(4, 2, 0, 'turtle2') \t# 创建一个发布位置信息的 turtle_vel rospy.Publisher('turtle2/cmd_vel', geometry_msgs.msg.Twist,queue_size 1) rate rospy.Rate(10.0) while not rospy.is_shutdown(): try: # 查询当前的坐标位置关系 (trans,rot) listener.lookupTransform('/turtle2', '/turtle1', rospy.Time(0)) except (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException): continue \t\t# 计算一下实际的速去 angular 4 * math.atan2(trans[1], trans[0]) linear 0.5 * math.sqrt(trans[0] ** 2 + trans[1] ** 2) cmd geometry_msgs.msg.Twist() cmd.linear.x linear cmd.angular.z angular turtle_vel.publish(cmd) rate.sleep() ``` 运行 ```bash python src/learning_tf/scripts/turtle_tf_broadcaster.py __name: turtle_follower_2 _turtle: turtle2 & python src/learning_tf/scripts/turtle_tf_broadcaster.py __name: turtle_follower_1 _turtle: turtle1 & python src/learning_tf/scripts/turtle_tf_listener.py rosrun turtlesim turtlesim_node & python src/learning_tf/scripts/turtle_tf_listener.py ``` ### launch文件 ```xml <launch> <! Turtlesim Node > <node pkg \"turtlesim\" type \"turtlesim_node\" name \"sim\"/> <node pkg \"turtlesim\" type \"turtle_teleop_key\" name \"teleop\" output \"screen\"/> <node pkg \"learning_tf\" type \"turtle_tf_broadcaster\" args \"/turtle1\" name \"turtle1_tf_broadcaster\" /> <node pkg \"learning_tf\" type \"turtle_tf_broadcaster\" args \"/turtle2\" name \"turtle2_tf_broadcaster\" /> <node pkg \"learning_tf\" type \"turtle_tf_listener\" name \"listener\" /> </launch> ```"},"/note/嵌入式/ROS/ROS1/2026-1-13-08-Server实现.html":{"title":"Server实现","content":"# Server实现 ![image 20260113230431629](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601132304674.png) ## 实际实现 + 初始化ROS节点 + 创建Server示例 + 回调函数处理实际的信息 ### cpp ```cpp /** * 该例程将执行/turtle_command服务，服务数据类型std_srvs/Trigger */ #include <ros/ros.h> #include <geometry_msgs/Twist.h> #include <std_srvs/Trigger.h> ros::Publisher turtle_vel_pub; bool pubCommand false; // service回调函数，输入参数req，输出参数res bool commandCallback(std_srvs::Trigger::Request &req, \t\t\tstd_srvs::Trigger::Response &res) { \tpubCommand !pubCommand; // 显示请求数据 ROS_INFO(\"Publish turtle velocity command [%s]\", pubCommand true?\"Yes\":\"No\"); \t// 设置反馈数据 \tres.success true; \tres.message \"Change turtle command state!\"; return true; } int main(int argc, char **argv) { // ROS节点初始化 ros::init(argc, argv, \"turtle_command_server\"); // 创建节点句柄 ros::NodeHandle n; // 创建一个名为/turtle_command的server，注册回调函数 commandCallback ros::ServiceServer command_service n.advertiseService(\"/turtle_command\", commandCallback); \t// 创建一个Publisher，发布名为/turtle1/cmd_vel的topic，消息类型为geometry_msgs::Twist，队列长度10 \t// 这一个是用于显示现象使用的命令发送器 \tturtle_vel_pub n.advertise<geometry_msgs::Twist>(\"/turtle1/cmd_vel\", 10); // 循环等待回调函数 ROS_INFO(\"Ready to receive turtle command.\"); \t// 设置循环的频率 \tros::Rate loop_rate(10); \twhile(ros::ok()) \t{ \t\t// 查看一次回调函数队列 \tros::spinOnce(); \t\t \t\t// 如果标志为true，则发布速度指令 \t\tif(pubCommand) \t\t{ \t\t\tgeometry_msgs::Twist vel_msg; \t\t\tvel_msg.linear.x 0.5; \t\t\tvel_msg.angular.z 0.2; \t\t\tturtle_vel_pub.publish(vel_msg); \t\t} \t\t//按照循环频率延时 \t loop_rate.sleep(); \t} return 0; } ``` 这里使用的是一个标准的数据类型`Trigger`, 可以使用命令查看这个数据类型实际是什么样的 ```bash (base) jiao@jiao:~/JHY/ros/catkin_ws$ rossrv show std_srvs/Trigger bool success string message ``` > 上面的数据是发送的数据, 下面的是返回的数据类型, 这个发送的信息是一个空的信息 测试可以使用下面的命令 ```bash roscore & rosrun turtlesim turtlesim_node & rosrun learning_service turtle_command_server # 启动一下我们的server rosservice call /turtle_command \"{}\" # 测试发送一个请求 ``` ## python实现 ```python # 该例程将执行/turtle_command服务，服务数据类型std_srvs/Trigger import rospy import thread,time from geometry_msgs.msg import Twist from std_srvs.srv import Trigger, TriggerResponse pubCommand False # 状态标志位 turtle_vel_pub rospy.Publisher('/turtle1/cmd_vel', Twist, queue_size 10) def command_thread():\t \twhile True: \t\tif pubCommand: \t\t\tvel_msg Twist() \t\t\tvel_msg.linear.x 0.5 \t\t\tvel_msg.angular.z 0.2 \t\t\tturtle_vel_pub.publish(vel_msg) \t\t\t \t\ttime.sleep(0.1) def commandCallback(req): \tglobal pubCommand \tpubCommand bool(1 pubCommand) \t# 显示请求数据 \trospy.loginfo(\"Publish turtle velocity command![%d]\", pubCommand) \t# 反馈数据 \treturn TriggerResponse(1, \"Change turtle command state!\") def turtle_command_server(): \t# ROS节点初始化 rospy.init_node('turtle_command_server') \t# 创建一个名为/turtle_command的server，注册回调函数commandCallback s rospy.Service('/turtle_command', Trigger, commandCallback) \t# 循环等待回调函数 print \"Ready to receive turtle command.\" thread.start_new_thread(command_thread, ()) rospy.spin() if __name__ \"__main__\": turtle_command_server() ```"},"/note/嵌入式/ROS/ROS1/2026-1-14-10-参数的使用.html":{"title":"参数的使用","content":"# 参数的使用 在ROS Master里面有一个参数的服务器, 里面记录配置参数, 所有的节点都可以获取到里面的参数 ![image 20260114113149147](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601141131192.png) ## 使用 在控制参数的时候, 如果参数的数量比较多, 可以使用yaml文件进行配置 ### 参数文件 ```yaml A: 123 B: \"hello\" group: C: 456 D: \"hello\" ``` group是一个命名空间, 这个命名空间在实际使用的时候是参数的一层`/group/C` ### cpp 这个使用对应命令行工具里面的操作 ```cpp /** * 该例程设置/读取海龟例程中的参数 */ #include <string> #include <ros/ros.h> #include <std_srvs/Empty.h> int main(int argc, char **argv) { \tint red, green, blue; // ROS节点初始化 ros::init(argc, argv, \"parameter_config\"); // 创建节点句柄 ros::NodeHandle node; // 读取背景颜色参数 \tros::param::get(\"/background_r\", red); \tros::param::get(\"/background_g\", green); \tros::param::get(\"/background_b\", blue); \tROS_INFO(\"Get Backgroud Color[%d, %d, %d]\", red, green, blue); \t// 设置背景颜色参数 \tros::param::set(\"/background_r\", 255); \tros::param::set(\"/background_g\", 255); \tros::param::set(\"/background_b\", 255); \tROS_INFO(\"Set Backgroud Color[255, 255, 255]\"); // 读取背景颜色参数 \tros::param::get(\"/background_r\", red); \tros::param::get(\"/background_g\", green); \tros::param::get(\"/background_b\", blue); \tROS_INFO(\"Re get Backgroud Color[%d, %d, %d]\", red, green, blue); \t// 调用服务，刷新背景颜色 \tros::service::waitForService(\"/clear\"); \tros::ServiceClient clear_background node.serviceClient<std_srvs::Empty>(\"/clear\"); \tstd_srvs::Empty srv; \tclear_background.call(srv); \t \tsleep(1); return 0; } ``` 在代码里面使用yaml文件加载配置的时候, 需要自己解析yaml文件 ### python ```python #!/usr/bin/env python # * coding: utf 8 * ######################################################################## #### Copyright 2020 GuYueHome (www.guyuehome.com). ### ######################################################################## # 该例程设置/读取海龟例程中的参数 import sys import rospy from std_srvs.srv import Empty def parameter_config(): \t# ROS节点初始化 rospy.init_node('parameter_config', anonymous True) \t# 读取背景颜色参数 red rospy.get_param('/background_r') green rospy.get_param('/background_g') blue rospy.get_param('/background_b') rospy.loginfo(\"Get Backgroud Color[%d, %d, %d]\", red, green, blue) \t# 设置背景颜色参数 rospy.set_param(\"/background_r\", 255); rospy.set_param(\"/background_g\", 255); rospy.set_param(\"/background_b\", 255); rospy.loginfo(\"Set Backgroud Color[255, 255, 255]\"); \t# 读取背景颜色参数 red rospy.get_param('/background_r') green rospy.get_param('/background_g') blue rospy.get_param('/background_b') rospy.loginfo(\"Get Backgroud Color[%d, %d, %d]\", red, green, blue) \t# 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service rospy.wait_for_service('/clear') try: clear_background rospy.ServiceProxy('/clear', Empty) \t\t# 请求服务调用，输入请求数据 response clear_background() return response except rospy.ServiceException as e: print(\"Service call failed: %s\" % e) if __name__ \"__main__\": parameter_config() ```"},"/note/嵌入式/ROS/ROS1/2026-1-14-12-可视化工具.html":{"title":"可视化工具","content":"# 可视化工具 ROS里面基于Qt开发了一系列的工具, 可供使用 ## rqt相关 ###日志信息rqt_console ![image 20260114205009961](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601142050001.png) 可以对日志进行筛选 ### 绘制数据曲线qrt_plot ![image 20260114205204454](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601142052491.png) ### 显示摄像头图像rqt_image_view ![image 20260114205304170](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601142053212.png) ### 工具集合rqt 可以在这个界面打开之前的工具 ![image 20260114205422894](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601142054945.png) ![image 20260114205503659](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601142055739.png) ## Rviz数据显示 机器人模型, 坐标, 地图等显示平台, 是一个三维的可视化工具, 使用xml对机器人, 周围物体的尺寸, 质量, 位置, 材质等进行描述, 在界面里面显示出来 还可以通过图形化的方式, 实时显示机器人的位置, 运动状态, 周围的环境 开发者可以通过界面里面的按钮对机器人进行行为控制 ![image 20260114210211786](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601142102929.png) ```bash export LIBGL_ALWAYS_SOFTWARE 1 rosrun rviz rviz ``` 实际显示的时候会订阅一个topic, 从里面获取信息 ## Gazebo仿真平台 三维显示平台, 高质量的图形渲染, 方便的图形化接口 可以用测试机器人的算法, 机器人的设计, 真实情况下面的回溯测试 可以使用`roslaunch gazebo_ros willowgarage_world.launch`进行加载"},"/note/嵌入式/ROS/ROS1/2026-1-13-02-命令行工具.html":{"title":"命令行工具","content":"# 命令行工具 ![image 20260113112526792](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601131125919.png) ## 小海龟 ```bash #测试 # 基础服务 roscore # 仿真器, rosrun用于运行一个包, 一个包名, 以及里面的节点 rosrun turtlesim turtlesim_node # 控制节点 rosrun turtlesim turtle_teleop_key ``` ### 信息获取 #### 图形架构 可以通过rqt_graph获取整个系统的架构 ![image 20260113112918288](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601131129326.png) 两个节点, 中间使用一个话题进行通信 #### 命令行节点信息 也可以使用命令行工具进行查看节点的信息, 使用命令`rosnode` ```bash (base) jiao@jiao:~$ rosnode list /rosout # 默认启动的时候自动创建的一个 /teleop_turtle /turtlesim (base) jiao@jiao:~$ rosnode info /turtlesim Node [/turtlesim] Publications: # 发布的话题 * /rosout [rosgraph_msgs/Log] * /turtle1/color_sensor [turtlesim/Color] * /turtle1/pose [turtlesim/Pose] # 位置 Subscriptions: # 订阅的话题 * /turtle1/cmd_vel [geometry_msgs/Twist] Services: # 提供的服务可以用于配置 * /clear * /kill * /reset * /spawn * /turtle1/set_pen * /turtle1/teleport_absolute * /turtle1/teleport_relative * /turtlesim/get_loggers * /turtlesim/set_logger_level contacting node http://jiao:44890/ ... Pid: 120888 Connections: * topic: /rosout * to: /rosout * direction: outbound (44774 127.0.0.1:48359) [15] * transport: TCPROS * topic: /turtle1/cmd_vel * to: /teleop_turtle (http://jiao:44828/) * direction: inbound (48579 jiao:45572) [23] * transport: TCPROS ``` #### topic相关 使用命令`rostopic` ```bash (base) jiao@jiao:~$ rostopic list /rosout /rosout_agg /turtle1/cmd_vel # 运动控制的节点 /turtle1/color_sensor /turtle1/pose # 发布信息, /turtle1/cmd_vel是节点, geometry_msgs/Twist是数据类型 (base) jiao@jiao:~$ rostopic pub /turtle1/cmd_vel geometry_msgs/Twist \"linear: x: 1.0 y: 0.0 z: 0.0 angular: x: 0.0 y: 0.0 z: 0.0\" publishing and latching message. Press ctrl C to terminate (base) jiao@jiao:~$ rostopic pub r 10 /turtle1/cmd_vel geometry_msgs/Twist \"linear: x: 1.0 y: 0.0 z: 0.0 angular: x: 0.0 y: 0.0 z: 0.0\" ``` > ```bash > (base) jiao@jiao:~$ rostopic pub h > Usage: rostopic pub /topic type [args...] > > Options: > h, help show this help message and exit > v print verbose output > r RATE, rate RATE publishing rate (hz). For f and stdin input, this > defaults to 10. Otherwise it is not set. > 1, once publish one message and exit > f FILE, file FILE read args from YAML file (Bagy) > l, latch enable latching for f, r and piped input. This > latches the first message. > s, substitute keywords > When publishing with a rate, performs keyword ('now' > or 'auto') substitution for each message > use rostime use rostime for time stamps, else walltime is used > ``` #### 查看数据格式 ```bash (base) jiao@jiao:~$ rosmsg show geometry_msgs/Twist geometry_msgs/Vector3 linear float64 x float64 y float64 z geometry_msgs/Vector3 angular float64 x float64 y float64 z ``` > 默认距离单位是m, 角度单位是弧度 #### 服务server ```bash (base) jiao@jiao:~$ rosservice list /clear /kill /reset /rosout/get_loggers /rosout/set_logger_level /spawn # 产生新的海龟 /teleop_turtle/get_loggers /teleop_turtle/set_logger_level /turtle1/set_pen /turtle1/teleport_absolute /turtle1/teleport_relative /turtlesim/get_loggers /turtlesim/set_logger_level (base) jiao@jiao:~$ rosservice call /spawn \"x: 2.0 y: 0.0 theta: 0.0 name: 'jiao'\" name: \"jiao\" # 反馈数据 ``` ![image 20260113114910586](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601131149639.png) > 默认的坐标在左下角 创建的海龟自动订阅了一些topic ```bash (base) jiao@jiao:~$ rostopic list /jiao/cmd_vel /jiao/color_sensor /jiao/pose /rosout /rosout_agg /turtle1/cmd_vel /turtle1/color_sensor /turtle1/pose ``` #### 话题复现 可以使用rosbag记录一次数据, 用于之后的复现 ```bash (base) jiao@jiao:~$ rosbag record a O cmd_record [INFO] [1768276539.364019106]: Recording to 'cmd_record.bag'. [INFO] [1768276539.365862266]: Subscribing to /rosout_agg [INFO] [1768276539.368921951]: Subscribing to /rosout [INFO] [1768276539.371992650]: Subscribing to /turtle1/cmd_vel [INFO] [1768276539.375071107]: Subscribing to /turtle1/pose [INFO] [1768276539.377982403]: Subscribing to /turtle1/color_sensor ^C(base) jiao@jiao:~$ ls JHY cmd_record.bag maix miniconda3 rknn toolkit2 1.6.0 (base) jiao@jiao:~$ rosbag play cmd_record.bag # 复现之前的工作, 使用有时间的复现 [INFO] [1768276676.710743428]: Opening cmd_record.bag Waiting 0.2 seconds after advertising topics... done. Hit space to toggle paused, or 's' to step. [RUNNING] Bag Time: 1768276573.531749 Duration: 34.150425 / 49.574965 ``` 显示一些自动订阅的主题 ### 参数 查看以及控制ROS Master里面的的参数服务器 ````bash (base) jiao@jiao:~/JHY/ros/catkin_ws$ rosparam list /rosdistro /roslaunch/uris/host_jiao__46634 /rosversion /run_id /turtlesim/background_b /turtlesim/background_g /turtlesim/background_r (base) jiao@jiao:~/JHY/ros/catkin_ws$ rosparam get /turtlesim/background_r 69 (base) jiao@jiao:~/JHY/ros/catkin_ws$ rosparam set /turtlesim/background_r 255 (base) jiao@jiao:~/JHY/ros/catkin_ws$ rosparam get /turtlesim/background_r 255 # 需要使用命令进行更新 (base) jiao@jiao:~/JHY/ros/catkin_ws$ rosservice call /clear \"{}\" [INFO] [1768362643.776969794]: Clearing turtlesim. # 记录信息在文件里面 (base) jiao@jiao:~/JHY/ros/catkin_ws$ rosparam dump param.yaml # 加载文件 (base) jiao@jiao:~/JHY/ros/catkin_ws$ rosparam load param.yaml (base) jiao@jiao:~/JHY/ros/catkin_ws$ rosparam get /turtlesim/background_r 128 ```` > ```bash > rosparam is a command line tool for getting, setting, and deleting parameters from the ROS Parameter Server. > > Commands: > rosparam set set parameter > rosparam get get parameter > rosparam load load parameters from file > rosparam dump dump parameters to file > rosparam delete delete parameter > rosparam list list parameter names > ``` ### 执行脚本 用于一次性启动很多个服务 `roslaunch turtle_tf turtle_tf_demo.launch` 可以使用launch文件进行配置启动, 实际就是一个xml文件, 一般放在launch文件夹下面 #### 基础语法 [文档](https://wiki.ros.org/roslunch/XML) ![image 20260114195132939](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601141951003.png) > + output: 输出的位置 > + respawn: 启动失败是不是重试 > + required: 是不是必须得 > + ns: 命名空间 > + args: 使用的参数 ![image 20260114195219124](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601141952187.png) > 参数服务器以及launch文件里面的参数设置 ![image 20260114195623904](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601141956968.png) ![image 20260114200448269](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601142004333.png)"},"/note/嵌入式/ROS/ROS1/2026-1-13-06-话题消息发布.html":{"title":"话题消息发布","content":"# 话题消息发布 ![image 20260113155611430](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601131556477.png) ## 消息定义 ROS master在创建连接的时候需要使用, 创建连接以后可以关闭 + 定义msg文件, 创建一个msg文件夹, 里面创建一个Person.msg文件 ```msg string name uint8 age uint8 sex uint8 unknown 0 uint8 male 1 uint8 female 2 ``` + 在package.xml文件里面添加功能包的依赖 ```xml <build_depend> message_generation </build_depend> <exec_depend>message_runtime</exec_depend> ``` + 在Cmake文件里面添加编译选项 ```cmake find_package(catkin REQUIRED COMPONENTS geometry_msgs roscpp rospy std_msgs turtlesim message_generation ) add_message_files( FILES Person.msg ) generate_messages( DEPENDENCIES std_msgs ) catkin_package( # INCLUDE_DIRS include # LIBRARIES learning_topic CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs turtlesim # DEPENDS system_lib ) add_executable(person_publisher src/person_publisher.cpp) target_link_libraries(person_publisher ${catkin_LIBRARIES}) add_dependencies(person_publisher ${PROJECT_NAME}_generate_messages_cpp) # 动态生成的文件 add_executable(person_subscriber src/person_subscriber.cpp) target_link_libraries(person_subscriber ${catkin_LIBRARIES}) add_dependencies(person_subscriber ${PROJECT_NAME}_generate_messages_cpp) ``` > ```bash > (base) jiao@jiao:~/JHY/ros/catkin_ws/src/learning_topic$ tree > . > ├── CMakeLists.txt > ├── include > │ └── learning_topic > ├── msg > │ └── Person.msg > ├── package.xml > ├── scripts > │ ├── pose_subscriber.py > │ └── velocity_publisher.py > └── src > ├── person_publisher.cpp > ├── person_subscriber.cpp > ├── pose_subscriber.cpp > └── velocity_publisher.cpp > > 5 directories, 9 files > ``` > > 在devel/include/learning_topic/Person.h是一个生成的文件 ### 代码实现 publisher ```cpp /*********************************************************************** Copyright 2020 GuYueHome (www.guyuehome.com). ***********************************************************************/ /** * 该例程将发布/person_info话题，自定义消息类型learning_topic::Person */ #include <ros/ros.h> #include \"learning_topic/Person.h\" int main(int argc, char **argv) { // ROS节点初始化 ros::init(argc, argv, \"person_publisher\"); // 创建节点句柄 ros::NodeHandle n; // 创建一个Publisher，发布名为/person_info的topic，消息类型为learning_topic::Person，队列长度10 ros::Publisher person_info_pub n.advertise<learning_topic::Person>(\"/person_info\", 10); // 设置循环的频率 ros::Rate loop_rate(1); int count 0; while (ros::ok()) { // 初始化learning_topic::Person类型的消息 \tlearning_topic::Person person_msg; \t\tperson_msg.name \"Tom\"; \t\tperson_msg.age 18; \t\tperson_msg.sex learning_topic::Person::male; // 发布消息 \t\tperson_info_pub.publish(person_msg); \tROS_INFO(\"Publish Person Info: name:%s age:%d sex:%d\", \t\t\t\t person_msg.name.c_str(), person_msg.age, person_msg.sex); // 按照循环频率延时 loop_rate.sleep(); } return 0; } ``` Subscriber ```cpp /*********************************************************************** Copyright 2020 GuYueHome (www.guyuehome.com). ***********************************************************************/ /** * 该例程将订阅/person_info话题，自定义消息类型learning_topic::Person */ #include <ros/ros.h> #include \"learning_topic/Person.h\" // 接收到订阅的消息后，会进入消息回调函数 void personInfoCallback(const learning_topic::Person::ConstPtr& msg) { // 将接收到的消息打印出来 ROS_INFO(\"Subcribe Person Info: name:%s age:%d sex:%d\", \t\t\t msg >name.c_str(), msg >age, msg >sex); } int main(int argc, char **argv) { // 初始化ROS节点 ros::init(argc, argv, \"person_subscriber\"); // 创建节点句柄 ros::NodeHandle n; // 创建一个Subscriber，订阅名为/person_info的topic，注册回调函数personInfoCallback ros::Subscriber person_info_sub n.subscribe(\"/person_info\", 10, personInfoCallback); // 循环等待回调函数 ros::spin(); return 0; } ``` ### python实现 ![image 20260113164534357](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601131645414.png) Cmake文件里面的配置会生成python里面的库文件 ```python #!/usr/bin/env python # * coding: utf 8 * ######################################################################## #### Copyright 2020 GuYueHome (www.guyuehome.com). ### ######################################################################## # 该例程将发布/person_info话题，自定义消息类型learning_topic::Person import rospy from learning_topic.msg import Person def velocity_publisher(): \t# ROS节点初始化 \trospy.init_node('person_publisher', anonymous True) \t# 创建一个Publisher，发布名为/person_info的topic，消息类型为learning_topic::Person，队列长度10 \tperson_info_pub rospy.Publisher('/person_info', Person, queue_size 10) \t#设置循环的频率 \trate rospy.Rate(10) \twhile not rospy.is_shutdown(): \t\t# 初始化learning_topic::Person类型的消息 \t\tperson_msg Person() \t\tperson_msg.name \"Tom\" \t\tperson_msg.age 18 \t\tperson_msg.sex Person.male \t\t# 发布消息 \t\tperson_info_pub.publish(person_msg) \t\trospy.loginfo(\"Publsh person message[%s, %d, %d]\", \t\t\t\tperson_msg.name, person_msg.age, person_msg.sex) \t\t# 按照循环频率延时 \t\trate.sleep() if __name__ '__main__': \ttry: \t\tvelocity_publisher() \texcept rospy.ROSInterruptException: \t\tpass ``` ```python #!/usr/bin/env python # * coding: utf 8 * ######################################################################## #### Copyright 2020 GuYueHome (www.guyuehome.com). ### ######################################################################## # 该例程将订阅/person_info话题，自定义消息类型learning_topic::Person import rospy from learning_topic.msg import Person def personInfoCallback(msg): rospy.loginfo(\"Subcribe Person Info: name:%s age:%d sex:%d\", \t\t\t msg.name, msg.age, msg.sex) def person_subscriber(): \t# ROS节点初始化 rospy.init_node('person_subscriber', anonymous True) \t# 创建一个Subscriber，订阅名为/person_info的topic，注册回调函数personInfoCallback rospy.Subscriber(\"/person_info\", Person, personInfoCallback) \t# 循环等待回调函数 rospy.spin() if __name__ '__main__': person_subscriber() ```"},"/note/嵌入式/ROS/ROS1/2026-1-14-09-自定义服务数据类型.html":{"title":"自定义服务数据","content":"# 自定义服务数据 和之前的定义形式类似, 但是实际定义的时候需要同时定义发送以及回复的数据, 使用` `进行分割 + 定义srv文件夹, 里面存放的数据的后缀是.srv的 ```txt string name uint8 age uint8 sex uint8 unknown 0 uint8 male 1 uint8 famale 2 string result ``` + 在package.xml文件里面添加功能包的依赖 ```xml <build_depend>message_generation</build_depend> <exec_depend>message_runtime</exec_depend> ``` + 在CMakeList.txt文件里面添加编译选项 ```cmake find_package(catkin REQUIRED COMPONENTS geometry_msgs roscpp rospy std_msgs turtlesim message_generation ) add_service_files( FILES Person.srv ) generate_messages( DEPENDENCIES std_msgs ) catkin_package( # INCLUDE_DIRS include # LIBRARIES learning_service CATKIN_DEPENDS geometry_msgs roscpp rospy std_msgs turtlesim message_runtime # DEPENDS system_lib ) ``` + 使用生成的相关文件编程 ![image 20260114110054514](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601141100564.png) ## 使用 ### cpp client使用 ```cpp #include <ros/ros.h> #include \"learning_service/Person.h\" int main(int argc, char** argv) { // 初始化ROS节点 \tros::init(argc, argv, \"person_client\"); // 创建节点句柄 \tros::NodeHandle node; // 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service \tros::service::waitForService(\"/show_person\"); \tros::ServiceClient person_client node.serviceClient<learning_service::Person>(\"/show_person\"); // 初始化learning_service::Person的请求数据 \tlearning_service::Person srv; \tsrv.request.name \"Tom\"; \tsrv.request.age 20; \tsrv.request.sex learning_service::Person::Request::male; // 请求服务调用 \tROS_INFO(\"Call service to show person[name:%s, age:%d, sex:%d]\", \t\t\t srv.request.name.c_str(), srv.request.age, srv.request.sex); \tperson_client.call(srv); \t// 显示服务调用结果 \tROS_INFO(\"Show person result : %s\", srv.response.result.c_str()); \treturn 0; }; ``` #### server ```cpp #include <ros/ros.h> #include \"learning_service/Person.h\" // service回调函数，输入参数req，输出参数res bool personCallback(learning_service::Person::Request &req, \t\t\tlearning_service::Person::Response &res) { // 显示请求数据 ROS_INFO(\"Person: name:%s age:%d sex:%d\", req.name.c_str(), req.age, req.sex); \t// 设置反馈数据 \tres.result \"OK\"; return true; } int main(int argc, char **argv) { // ROS节点初始化 ros::init(argc, argv, \"person_server\"); // 创建节点句柄 ros::NodeHandle n; // 创建一个名为/show_person的server，注册回调函数personCallback ros::ServiceServer person_service n.advertiseService(\"/show_person\", personCallback); // 循环等待回调函数 ROS_INFO(\"Ready to show person informtion.\"); ros::spin(); return 0; } ``` ### python client ```python import sys import rospy from learning_service.srv import Person, PersonRequest def person_client(): \t# ROS节点初始化 rospy.init_node('person_client') \t# 发现/spawn服务后，创建一个服务客户端，连接名为/spawn的service rospy.wait_for_service('/show_person') try: person_client rospy.ServiceProxy('/show_person', Person) \t\t# 请求服务调用，输入请求数据 response person_client(\"Tom\", 20, PersonRequest.male) return response.result except rospy.ServiceException, e: print \"Service call failed: %s\"%e if __name__ \"__main__\": \t#服务调用并显示调用结果 print \"Show person result : %s\" %(person_client()) ``` Server ```python import rospy from learning_service.srv import Person, PersonResponse def personCallback(req): \t# 显示请求数据 rospy.loginfo(\"Person: name:%s age:%d sex:%d\", req.name, req.age, req.sex) \t# 反馈数据 return PersonResponse(\"OK\") def person_server(): \t# ROS节点初始化 rospy.init_node('person_server') \t# 创建一个名为/show_person的server，注册回调函数personCallback s rospy.Service('/show_person', Person, personCallback) \t# 循环等待回调函数 print \"Ready to show person informtion.\" rospy.spin() if __name__ \"__main__\": person_server() ```"},"/note/嵌入式/ROS/ROS1/2026-1-13-05-Subscriber实现.html":{"title":"Subscriber实现","content":"# Subscriber实现 ![image 20260113152502331](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601131525394.png) ## 实现 ### cpp ```cpp /*********************************************************************** Copyright 2020 GuYueHome (www.guyuehome.com). ***********************************************************************/ /** * 该例程将订阅/turtle1/pose话题，消息类型turtlesim::Pose */ #include <ros/ros.h> #include \"turtlesim/Pose.h\" // 接收到订阅的消息后，会进入消息回调函数 void poseCallback(const turtlesim::Pose::ConstPtr& msg) { // 将接收到的消息打印出来 ROS_INFO(\"Turtle pose: x:%0.6f, y:%0.6f\", msg >x, msg >y); } int main(int argc, char **argv) { // 初始化ROS节点 ros::init(argc, argv, \"pose_subscriber\"); // 创建节点句柄 ros::NodeHandle n; // 创建一个Subscriber，订阅名为/turtle1/pose的topic，注册回调函数poseCallback ros::Subscriber pose_sub n.subscribe(\"/turtle1/pose\", 10, poseCallback); // 循环等待回调函数 ros::spin(); return 0; } ``` ### python ```python #!/usr/bin/env python # * coding: utf 8 * ######################################################################## #### Copyright 2020 GuYueHome (www.guyuehome.com). ### ######################################################################## # 该例程将订阅/turtle1/pose话题，消息类型turtlesim::Pose import rospy from turtlesim.msg import Pose def poseCallback(msg): rospy.loginfo(\"Turtle pose: x:%0.6f, y:%0.6f\", msg.x, msg.y) def pose_subscriber(): \t# ROS节点初始化 rospy.init_node('pose_subscriber', anonymous True) \t# 创建一个Subscriber，订阅名为/turtle1/pose的topic，注册回调函数poseCallback rospy.Subscriber(\"/turtle1/pose\", Pose, poseCallback) \t# 循环等待回调函数 rospy.spin() if __name__ '__main__': pose_subscriber() ```"},"/note/嵌入式/模拟器/RISC-V模拟器/2024-8-29-GDB调试.html":{"title":"GDB调试","content":" layout: post title: \"GDB调试\" date: 2024 8 5 15:39:08 +0800 tags: RISC V # GDB调试 实现使用MounRiver的程序加载以及调试 实际实现的时候是需要一个可以处理服务器发来的命令的端口, 这个协议使用TCP进行发送 一次典型的调试会话可能包括启动GDB、加载程序、设置断点、运行程序并在断点处停下，检查和修改程序状态，继续或单步执行，以及退出调试会话。 我们也可以将其与一些工具，如VSCode结合，使得其支持图形化界面中的程序调试 使用GDB调试的主要功能特点有： 1. **源代码调试**：GDB允许开发者查看程序执行时的源代码，这是通过编译时加入调试信息来实现的。开发者可以单步执行程序，检查当前执行点的源代码。 2. **断点设置**：可以在特定的源代码行或函数上设置断点，使得程序执行到这些点时自动停下来，便于查看此时程序的状态，如变量值、堆栈调用路径等。 3. **变量检查和修改**：在调试过程中，GDB允许查看和修改变量的值。这对于测试不同的执行路径和问题诊断非常有用。 4. **多线程调试**：GDB支持多线程程序的调试，可以检查各个线程的状态，切换当前调试的线程，设置线程特定的断点等。 5. **远程调试**：GDB支持通过网络对远程机器上的程序进行调试。这对于嵌入式开发和远程测试尤为重要。 6. **条件断点和观察点**：可以设置条件断点（只有当满足某条件时才触发断点）和观察点（当变量值改变时停止执行），以更细致地控制调试过程。 7. **后端支持**：GDB的架构允许它使用不同的后端。例如，它可以使用原生的操作系统功能来控制程序，或者使用其他工具如QEMU或Valgrind来作为其后端。 ## VSCode调试配置文件 [VS Code 的 launch.json 进行高效代码调试：配置和原理解析_麦田的守望者_InfoQ写作社区](https://xie.infoq.cn/article/183b37b4d36785b3f18f7e5c1) 在 **`launch.json`** 配置文件中，常见的字段和其含义如下： **`\"version\"`**：指定 **`launch.json`** 文件的格式版本。通常使用 **`\"0.2.0\"`**。 **`\"configurations\"`**：一个包含多个调试配置的数组。每个配置是一个 JSON 对象，包含以下字段： **`\"name\"`**：调试配置的名称，用于在 VS Code 菜单中显示。 **`\"type\"`**：指定调试器的类型，如 **`\"node\"`**、**`\"python\"`** 等。 **`\"request\"`**：指定调试请求类型，通常为 **`\"launch\"`**（启动调试）或 **`\"attach\"`**（附加到已运行的进程）。 **`\"program\"`**：指定要调试的程序或脚本的路径。 **`\"cwd\"`**：指定工作目录，即调试会话开始时的当前工作目录。 其他可选字段：不同的调试器可能支持不同的字段，用于配置更详细的调试行为。 ```json { // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid 830387 \"version\": \"0.2.0\", \"configurations\": [ { \"name\": \"(gdb) Launch\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"${workspaceFolder}/build/riscv_sim\", \"args\": [\" u\"], \"stopAtEntry\": false, \"cwd\": \"${workspaceFolder}/../../test\", \"environment\": [], \"externalConsole\": false, \"MIMode\": \"gdb\", \"setupCommands\": [ { \"description\": \"Enable pretty printing for gdb\", \"text\": \" enable pretty printing\", \"ignoreFailures\": true }, { \"description\": \"Set Disassembly Flavor to Intel\", \"text\": \" gdb set disassembly flavor intel\", \"ignoreFailures\": true } ] }, { \"name\": \"(Windows) Launch\", \"type\": \"cppvsdbg\", \"request\": \"launch\", \"program\": \"${workspaceFolder}/build/Debug/riscv_sim.exe\", \"args\": [\" u\"], \"stopAtEntry\": false, \"cwd\": \"${workspaceFolder}/../../test\", \"environment\": [], \"console\": \"integratedTerminal\" } ] } ``` ![image 20240830095348822](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408300953900.png) > 可以使用args选择调试的时候的参数 可以使用添加配置来实现不同的配置 ![image 20240830095554433](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408300955488.png) ## MounRiver的设置 ![image 20240830144321647](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408301443715.png) ![image 20240830144701365](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408301447443.png) 第一个取消选择即可 ## 数据包 在数拒手册的763页 ### 要实现的内容 能够接收GDB的程序下载请求，将程序下载到Flash中 芯片复位 寄存器读写 内存读写 单步、全速运行控制 断点的设置和取消、程序运行断点时能够自动停下来 ### 命令示例 GDB Remote Serial Protocol 是一个用于 GDB与远程调试目标之间通信的协议。该协议允许 GDB 在一台机器上运行，而程序则在另一台机器上或者在一个特定的环境中如模拟器或特定的硬件上执行。这种机制使得开发者能够调试跨平台应用、嵌入式系统、或者在特殊环境中运行的应用。 该协议是一种基于简单的文本命令和响应。以下是一些基本的命令和响应示例： 设置断点： 命令：Z0,addr,kind （设置断点，其中 addr 是地址，kind 表示断点类型） 响应：OK（成功）或E NN（错误，NN 为错误代码） 读取寄存器： 命令：p n（读取编号为 n 的寄存器） 响应：寄存器的值或错误代码 继续执行： 命令：c（从当前位置继续执行） 响应：当程序停止时，返回停止原因 ### 数据格式 GDB包的格式遵循一个相对简单的结构，确保数据的完整性和解析的一致性。下面是GDB远程协议包的基本构成： 开始字符：每个数据包以一个美元符号 ($) 开头。 数据字段：紧跟在开始字符后面的是数据部分，这部分包含实际的命令或响应信息，如 g (读取所有寄存器的值) 或 mADDR,LEN (读取内存)。 校验和分隔符：数据部分后是一个井号 (#)，它标记着校验和的开始。 校验和：校验和是一个两位十六进制数，计算的是数据字段的模 256 的和。这用于检查数据在传输过程中是否发生了变化或错误数据包示例 > 例如，当需要读取内存时，可能会有如下的交互过程： > > GDB发送请求包：`$m200,4#ca // $m200,#4#ca > # > } #^0x20 > } ?` > > $ 开始 > m200,4 请求读取从地址 0x200 开始的 4 字节 > \\#ca 校验和 > > GDB Server给出读内存响应：$xxxyyyzz#ff > > $ 开始 > xxxyyyzz 为读取的内存内容 > \\#ff 校验和 ### 转义字符 在数据字段中，某些特殊字符需要进行转义处理，确保它们不会被解释为包的控制字符（如开始字符 $ 和分隔符 #）。GDB使用一种简单的转义机制来处理这些情况： } 转义字符，后跟原字符的异或 0x20 的结果。 例如，若数据中需要包含 #（十六进制值为 0x23），则会被转义为 } 后跟 0x03（即 0x23 XOR 0x20）。 ![image 20240830164815318](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408301648435.png) ### 减少使用空间 Response data can be run length encoded to save space. Run length encoding replaces runs of identical characters with one instance of the repeated character, followed by a ‘\\*’ and a repeat count. The repeat count is itself sent encoded, to avoid binary characters in data: a value of n is sent as n+29. For a repeat count greater or equal to 3, this produces a printable ascii character, e.g. a space (ascii code 32) for a repeat count of 3. (This is because run length encoding starts to win for counts 3 or more.) Thus, for example, ‘0\\* ’ is a run length encoding of “0000”: the space character after ‘\\*’ means repeat the leading 0 32 29 3 more times. The printable characters ‘#’ and > 在实际使用的时候, 可以把一个数据使用`*`进行重复的操作, 在使用这一个方式的时候, 需要把重复的次数加29 > > 实际使用的时候由于6和7是\"#\"和\"*\"所以在实际使用的时候不可以使用, 发送的时候也不可以发送大于126次的重复数据 ### 回复数据 在处理数据的时候, 客户端需要发送一个'+'表示这一个数据的接收是成功的, 如果是一个' '表示这一个数据是需要重需发送 如果这一个数据的传输是通过TCP或者UDP这种可靠的传输方式的时候, 可以不使用这一个 > In cases where the transport mechanism is itself reliable (such as a pipe or TCP connection), the ‘+’/‘ ’ acknowledgments are redundant. It may be desirable to disable them in that case to reduce communication overhead, or for other reasons. This can be accomplished by means of the ‘QStartNoAckMode’ packet; see [QStartNoAckMode], page 790 不支持的命令发送一个空数据包 > For any command not supported by the stub, an empty response (‘$#00’) should be returned. That way it is possible to extend the protocol. A newer gdb can tell if a packet is supported based on that response. ### 部分命令 'q' 查询命令 (gdb_handle_query)：处理各种查询请求，例如获取目标信息、支持的特性等。 's' 单步执行 (gdb_handle_step)：执行目标程序的单步执行，通常执行下一条指令并在执行后立即停止。 'c' 继续执行 (gdb_handle_continue)：使目标程序继续执行，直到遇到下一个断点或程序结束。 'g' 读取所有寄存器 (gdb_handle_read_regs)：请求从目标读取所有寄存器的值。 'm' 读取内存 (gdb_handle_read_mem)：根据提供的地址和长度，从目标内存中读取数据。 'M' 写入内存 (gdb_handle_write_mem)：将数据写入目标内存的指定位置。 'p' 读取单个寄存器 (gdb_handle_read_reg)：请求读取指定寄存器的值。 'z' 删除断点 (gdb_handl_remove_breakpoint)：删除在目标程序中设定的断点。 'Z' 设置断点 (gdb_handle_set_breakpoint)：在目标程序中设置断点。 '?' 查询停止原因 (gdb_handle_query_stop)：查询目标为什么停止，通常用于获取异常或中断的详细信息。 'v' 处理v命令 (gdb_handle_vcmd)：处理以\"v\"开头的一组扩展命令，例如vCont用于继续控制。 'k' 终止目标程序 (gdb_handle_kill)：请求终止目标程序的执行。 'D' 断开调试会话 (gdb_handle_disconnect)：GDB客户端与远程目标断开连接 #### q命令 用于告诉对方支持的属性, 以及询问对方是否支持某一个属性, 如果有不支持的属性可以直接忽略, 有的属性只有在回复的时候告诉对方也支持这一个属性, 才会进行支持 ##### qSupported 发送qSupported的GDB都支持不限长度的数据 在实际发送的时候, 各个参数之间使用`;`进行分割, 发送的数据有几种格式 + `name value`: 远端支持这一个属性, 同时这一个属性有一个特定的值 + `name+`: 远端支持这一个属性, 这一个属性不需要特定的值 + `name `: 不支持这一个属性 + `name?`: 这一个属性可能支持, 需要使用其他的方式进行测试, 不会在通知的时候使用 属性 + multiprocess: 多线程调试的支持, 在使用这一个参数的时候如果返回值也有回复, 才可以进行多线程的调试 + swbreak: 支持软件断断点 + hwbreak: 硬件断点 + qRelocInsn: 支持追踪点 + fork event: gdb的fork event是指在调试过程中，当子进程被创建（通过fork系统调用）时，gdb会生成一个fork事件。这个事件可以帮助调试人员跟踪并监视子进程的执行。通过在特定的事件上设置触发器（trigger），可以使调试器在fork事件发生时自动进行某些操作，如设置断点、改变程序状态等。这样可以方便地调试多进程程序或者具有父子进程关系的程序。 + vfork event: 在GDB中，vfork事件是一个用于跟踪vfork系统调用的事件。当程序执行vfork系统调用时，会进入vfork事件，可以在这个事件中查看vfork系统调用的相关信息，例如调用参数、返回值等。通过跟踪vfork事件，可以更好地理解程序的执行过程，并调试可能存在的问题。 > fork和vfork都是用于创建新进程的系统调用，它们之间的主要区别在于： > > 1. fork： > > fork会创建一个新的进程，并且新进程会复制父进程的所有资源，包括内存空间、文件描述符等。 > 在fork创建新进程时，父进程和子进程之间会存在独立的内存空间，任何一个进程对内存的改动都不会影响到另一个进程。 > 在fork后，父进程和子进程会并发执行，并且各自独立运行，互不干扰。 > > 1. vfork： > > vfork也会创建一个新的进程，但是子进程会共享父进程的内存空间，即子进程在执行期间与父进程共享内存，不会做完全的内存空间拷贝。 > vfork通常用于子进程需要立即执行一个新程序的情况，子进程会在调用exec或者exit之后才会释放父进程的内存空间。 > 使用vfork创建的子进程必须要在执行exec或exit之后，否则就会出现内存泄露或者数据破坏等问题。 > > 总的来说，fork创建的进程是完全独立的，而vfork创建的子进程与父进程共享内存空间，需要注意在使用vfork时避免出现潜在的问题。 + evec event: 是不是支持exec创建一个新的进 + vContSupported: 对方是否支持action, 是的话返回一个`vCont?`的包 > 在gdb中，vCont命令用于控制程序的执行，可以继续执行程序、单步执行程序、以及在特定条件下执行程序。 > > vCont命令的格式为vCont[actions]，其中actions是一个字符串，用来指示要执行的动作。常见的actions包括： > > c：继续执行程序 > s：单步执行程序 > t<thread_id>：暂停指定线程 > continue：继续执行程序 > step：单步执行程序 > > 使用vCont命令可以更灵活地控制程序的执行，特别适用于多线程程序调试。 回复属性 PacketSize bytes: 支持的最大数据包的大小 ‘vContSupported: 回复vCout? ##### qTStatus 查询这一个是不是有在运行的跟踪实验 ##### qAttached 这一个程序是不是以一个附加程序的方式启动的(实际启动的时候是开启一个新的程序还是连接一个已有的程序), 这一个使用多线程的时候返回0, 这里返回一个1 ##### qRcmd 发送一个命令 qRcmd,68616c74 #### v开头 这是一个有多个字母的名字 ##### vMustReplyEmpty 测试对方是不是可以处理未知命令, 这一个需要返回一个空字符串 #### ? 用于询问这一个程序停止的原因[P 775] 返回S05表示这一个是因为一个trap指令停止的 #### H op thread id 设置线程为随后的操作 Hg0表示跳转到起始的线程, #### g查询寄存器 返回数据的时候使用两位16进制的数字表示一个byte的数据, 也可以使用x表示这一个寄存器不可以读取 由于编译器默认使用的小端模式, 所以数据需要进行转化为小端模式 #### p命令 用于读取指定的寄存器, p20 >读取PC寄存器 #### m指令 + m addr,length 用于读取内存的数据, 编辑器会使用读取的数据进行反汇编, 这一个在实际读取的时候有可能不会进行对齐 + M addr,length:XX... 对内存进行写入 #### s命令 s [addr]: 在addr处进行单步调试, 如果没有addr, 在当前位置继续 #### c命令继续执行 c [addr]: continue命令, 从addr开始执行 #### z实现断点 + 软件断点 指令ebreak, 在使用的时候可以把一个指令进行替换, 执行到这里以后再恢复这一个指令 + 硬件断点 使用一个寄存器进行保存一个地址, 运行到这一个地址的时候, 可以停下来, 使用这一种的时候数量是有限的, ARM一般是4个 `Z type,addr,kind` Insert (‘Z’) or remove (‘z’) a type breakpoint or watchpoint starting at address address of kind kind. + type 0: 硬件断点 1: 软件断点 #### 3停止运行 发送这一个命令的时候如果这一个程序在continue命令里面, 需要停止 #### k关闭进程 对于一个裸机进程, 会直接把这一个进程杀死, 对于一个多线程, 会关闭收到这一个信号的进程"},"/note/嵌入式/模拟器/RISC-V模拟器/2024-8-5-00基础知识.html":{"title":"基础知识","content":" layout: post title: \"基础知识\" date: 2024 8 5 15:39:08 +0800 tags: RISC V # 基础知识 ## SDL SDL是一个跨平台的多媒体库，它通过OpenGL和2D视频帧缓冲，提供了针对音频、视频、键盘、鼠标、控制杆及3D硬件的低级别的访问接口。它在MPEG播放软件、模拟器以及许多游戏中得到广泛的应用 基本的SDL的使用思路，基本分为三部分：初始化 > 循环渲染 > 销毁释放资源。 ### 使用 ```c #include \"SDL/SDL.h\" int main( int argc, char* args[] ) { //启动SDL SDL_Init( SDL_INIT_EVERYTHING ); //退出SDL SDL_Quit(); return 0; } ``` > 在 Visual Studio里面使用的头文件是`#include <SDL.h>` ### 基础概念 1、Window 窗口 SDL_Window这个结构体存放了所有与Window有关的信息，比如长宽、位置、边界等等。 2、Renderer 渲染器(实际的数据) SDL_Renderer这个结构体存放了与所有渲染有关的信息，它被绑定到了SDL_Window，刷新Renderer可以刷新与其绑定的Window。 3、Texture 纹理 和 Surface 表面 SDL_Renderer会渲染SDL_Texture，SDL_Texture与SDL_Surface很像，不同是SDL_Surface仅仅是一个包含像素信息的结构体，而SDL_Texture是一个高效的特定驱动的像素数据集；还有一点不同的是SDL_Surface使用软件渲染（CPU）而SDL_Texture使用硬件渲染（GPU）。 ### API函数 #### 初始化SDL_Init ```c int SDLCALL SDL_Init(Uint32 flags) ``` SDL_INIT_TIMER：定时器 SDL_INIT_AUDIO：音频 SDL_INIT_VIDEO：视频 SDL_INIT_JOYSTICK：摇杆 SDL_INIT_HAPTIC：触摸屏 SDL_INIT_GAMECONTROLLER：游戏控制器 SDL_INIT_EVENTS：事件 SDL_INIT_NOPARACHUTE：不捕获关键信号（这个不理解） SDL_INIT_EVERYTHING：包含上述所有选项 > 初始化不同的子系统 #### 创建一个窗口 ```c SDL_Window * SDLCALL SDL_CreateWindow(const char *title, int x, int y, int w, int h, Uint32 flags); ``` title ：窗口标题 x ：窗口位置x坐标。也可以设置为SDL_WINDOWPOS_CENTERED或SDL_WINDOWPOS_UNDEFINED。 y ：窗口位置y坐标。同上。 w ：窗口的宽 h ：窗口的高 flags ：支持窗口的状态属性的标识。包括了窗口的是否最大化、最小化，能否调整边界等等属性。可以把这一个参数设置为SDL_WINDOW_SHOWN 返回创建完成的窗口的ID。如果创建失败则返回0。 #### 创建一个渲染器 ```c SDL_Renderer * SDLCALL SDL_CreateRenderer(SDL_Window * window, int index, Uint32 flags); ``` window ： 渲染的目标窗口。 index ：打算初始化的渲染设备的索引。设置“ 1”则初始化默认的渲染设备。 flags ：支持以下值（位于SDL_RendererFlags定义中）SDL_RENDERER_SOFTWARE > 使用软件渲染；SDL_RENDERER_ACCELERATED > 使用硬件加速；SDL_RENDERER_PRESENTVSYNC > 和显示器的刷新率同步 返回创建完成的渲染器的ID。如果创建失败则返回NULL。 渲染的目标窗口是第二节我们创建的窗口，索引值为默认的渲染设备，设置的渲染属性为 “使用硬件加速 + 和选时期的刷新率同步” #### 创建纹理 ```c SDL_Texture * SDLCALL SDL_CreateTexture(SDL_Renderer * renderer, Uint32 format, int access, int w, int h); ``` renderer：目标渲染器。 format ：纹理的格式。后面会详述。 access ：可以取以下值（定义位于SDL_TextureAccess中） SDL_TEXTUREACCESS_STATIC > 变化极少 ; SDL_TEXTUREACCESS_STREAMING ：变化频繁； w ：纹理的宽 h ：纹理的高 #### 更新纹理 ```c int SDLCALL SDL_UpdateTexture(SDL_Texture * texture, const SDL_Rect * rect, const void *pixels, int pitch); ``` texture：目标纹理。 rect：更新像素的矩形区域。设置为NULL的时候更新整个区域。 pixels：像素数据。 pitch：一行像素数据的字节数。 #### 复制纹理到渲染目标 ```c int SDLCALL SDL_RenderCopy(SDL_Renderer * renderer, SDL_Texture * texture, const SDL_Rect * srcrect, const SDL_Rect * dstrect); ``` renderer：渲染目标。 texture：输入纹理。 srcrect：选择输入纹理的一块矩形区域作为输入。设置为NULL的时候整个纹理作为输入。 dstrect：选择渲染目标的一块矩形区域作为输出。设置为NULL的时候整个渲染目标作为输出。 #### 显示画面 ```c void SDLCALL SDL_RenderPresent(SDL_Renderer * renderer); ``` 其中参数 renderer 用于指定渲染器。 ### 核心流程 1. 初始化：SDL_Init() 2. 创建SDL_Window：SDL_CreateWindow() 3. 创建SDL_Render：SDL_CreateRenderer() 4. 创建SDL_Texture：SDL_CreateTexture() 5. 更新SDL_Texture：SDL_UpdateTexture() 6. 渲染SDL_Texture：SDL_RenderCopy() 7. 显示：SDL_RenderPresent() 8. 返回4继续执行 ### 绘制基本图形 SDL中绘制基本图形的 API并不多，主要是 点、线、矩形、填充矩形。其它图形都可以通过 点、线、矩形组合出来。 #### 设置画笔的颜色 ```c int SDL_SetRenderDrawColor(SDL_Renderer* renderer, // 渲染器 Uint8 r, // 红 Uint8 g, // 绿 Uint8 b, // 蓝 Uint8 a) // 透明值 ``` #### 绘制一个点 ```c int SDL_RenderDrawPoint(SDL_Renderer* renderer, int x, int y) ``` #### 绘制多个点 ```c int SDL_RenderDrawPoints(SDL_Renderer* renderer, const SDL_Point* points, int count) ``` 其中points为绘制的点的数组，count为要绘制的点的个数。 #### 绘制直线 ```c int SDL_RenderDrawLine(SDL_Renderer* renderer, // 渲染器 int x1, // 端点1的x坐标 int y1, // 端点1的y坐标 int x2, // 段点2的x坐标 int y2) // 端点2的y坐标 ``` #### 绘制多条直线 ```c int SDL_RenderDrawLines(SDL_Renderer* renderer, const SDL_Point* points, int count) ``` 使用两个相邻的点之间进行连线。最终画出你想画的图形。如画三角形，多边形或圆形。 #### 绘制矩形 ```c int SDL_RenderDrawRect(SDL_Renderer* renderer, const SDL_Rect* rect) ``` rect: 是要绘制的一块区域。它包括x,y,w,h这些元素。 #### 填充矩形 ```c int SDL_RenderFillRect(SDL_Renderer* renderer, const SDL_Rect* rect) int SDL_RenderDrawRects(SDL_Renderer* renderer, const SDL_Rect* rects, int count) ``` 填充一个以及一系列矩形 #### 示例代码 ```c #include <stdio.h> #include <SDL.h> #define POINTS_COUNT 4 static SDL_Point points[POINTS_COUNT] { {320, 200}, {300, 240}, {340, 240}, {320, 200} }; static SDL_Rect bigrect { 0,0,540, 380 }; static void test_thread_entry (void * param) { //启动SDL SDL_Init( SDL_INIT_EVERYTHING ); SDL_Window* window SDL_CreateWindow(\"My SDL Window\", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, 640, 480, SDL_WINDOW_SHOWN); if (window NULL) { printf(\"Could not create window: %s\\n\", SDL_GetError()); return; } /* We must call SDL_CreateRenderer in order for draw calls to affect this window. */ SDL_Renderer * renderer SDL_CreateRenderer(window, 1, 0); if(renderer NULL){ printf(\"Could not get a renderer\\n\"); return; } //设置一下颜色 SDL_SetRenderDrawColor(renderer, 255, 0, 255, 255); //清屏, 会清屏到这里设置的颜色 SDL_RenderClear(renderer); SDL_SetRenderDrawColor(renderer, 255, 0, 0, SDL_ALPHA_OPAQUE); //绘制线条 SDL_RenderDrawLines(renderer, points, POINTS_COUNT); SDL_Rect rect { 200, 300, 100, 100 }; SDL_RenderDrawRect(renderer, &rect); SDL_SetRenderDrawColor(renderer, 0, 255, 255, 255); SDL_RenderFillRect(renderer, &rect); SDL_SetRenderDrawColor(renderer, 0, 0, 255, 255); SDL_RenderFillRect(renderer, &bigrect); //实际的显示函数 SDL_RenderPresent(renderer); SDL_Delay(5000); //释放资源 //destory renderer if (renderer) { SDL_DestroyRenderer(renderer); } // Close and destroy the window SDL_DestroyWindow(window); //退出SDL SDL_Quit(); } ``` ![image 20240823082550730](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408230825348.png) ### 事件处理 SDL事件就是键盘事件，鼠标事件，窗口事件等。SDL将所有事件都存放在一个队列中。所有对事件的操作，其实就是对队列的操作。 ### API函数 处理事件队列的API函数 SDL_PollEvent: 将队列头中的事件抛出来。这一个也会进行阻塞, 但是使用这一个函数的时候会导致CPU一直在处理这一个任务 SDL_WaitEvent: 当队列中有事件时，抛出事件。否则处于阻塞状态，释放 CPU。 SDL_WaitEventTimeout: 与SDL_WaitEvent的区别时，当到达超时时间后，退出阻塞状态。 SDL_PeekEvent: 从队列中取出事件，但该事件不从队列中删除。 SDL_PushEvent: 向队列中插入事件。 处理事件的API函数 SDL_WindowEvent : Window窗口相关的事件。 SDL_KeyboardEvent : 键盘相关的事件。 SDL_MouseMotionEvent : 鼠标移动相关的事件。 SDL_QuitEvent : 退出事件。 SDL_UserEvent : 用户自定义事件。 #### 处理一下退出 ```c int quit 1; do { SDL_Event event; SDL_WaitEvent(&event); switch (event.type) { case SDL_QUIT: SDL_Log(\"Event type is %d\", event.type); quit 0; default: SDL_Log(\"Event type is %d\", event.type); break; } } while (quit); ``` ### SDL纹理渲染 SDL 视频渲染主要涉及到四个对象：SDL_Window、SDL_Render、SDL_Texture和SDL_Surface。 SDL_Window代表的是窗口的逻辑概念，它是存放在主内存中的一个对象。当我们调用SDL API 创建窗口后，它并不会被显示出来。 SDL_Render 是渲染器，它也是主存中的一个对象。对Render操作时实际上分为两个阶段： 渲染阶段。在该阶段，用户可以画各种图形渲染到SDL_Surface或SDL_Texture 中; 显示阶段。参SDL_Texture为数据，通过OpenGL操作GPU，最终将 SDL_Surfce 或SDL_Texture中的数据输出到显示器上。 SDL_Render对象中有一个视频缓冲区，该缓冲区我们称之为SDL_Surface，它是按照像素存放图像的。我们一般把真彩色的像素称为RGB24数据。也就是说，每一个像素由24位组成，每8位代表一种颜色，像素的最终颜色是由RGB三种颜色混合而成的。 SDL_Texture 与SDL_Surface 相似，也是一种缓冲区。只不过它存放的不是真正的像素数据，而是存放的图像的描述信息。这些描述信息通过OpenGL、D3D 或 Metal等技术操作GPU，从而绘制出与SDL_Surface一样的图形，且效率更高。 > 在SDL中，可以通过其他方式来实现图像的显示，不一定非要使用Texture对象。例如，可以使用SDL的Surface对象来加载和处理图像数据，然后直接将Surface对象渲染到屏幕上。然而，使用Texture对象可以提供更高性能和更有效的图像渲染，因为Texture对象通常存储在显存中，能够直接与图形硬件进行交互，提高渲染效率。 > > 虽然不使用Texture对象也可以正常显示图像，但是在需要高效处理图像数据、实现复杂的图形效果、或者进行游戏开发等场景下，推荐使用Texture对象来实现图像渲染，以获得更好的性能和效果。Texture对象是SDL提供的一种高效的图像处理方式，可以帮助开发者更轻松地实现图像渲染和处理。 #### 创建一个SDL_Texture ```c SDL_Texture* SDL_CreateTexture(SDL_Renderer* renderer, // 渲染器 Uint32 format, // 渲染数据的格式，如YUV、RGB int access, // Texture 类型，target、stream int w, int h) ``` format: 指明像素格式，可以是YUV，也可以是RGB access: 指明Texture的类型。可以是 Stream(视频)，也可以是Target一般的类型。 #### 渲染 ```c int SDL_RenderCopy(SDL_Renderer* renderer, SDL_Texture* texture, const SDL_Rect* srcrect, const SDL_Rect* dstrect) ``` srcrect: 指定 Texture 中要渲染的一部分。如果将 Texture全部输出，可以设置它为 NULL。 dstrect: 指定输出的空间大小。 #### 销毁 ```c void SDL_DestroyTexture(SDL_Texture* texture) ``` #### 示例 ```c static void test_thread_entry (void * param) { SDL_Window *window; SDL_Renderer *renderer; SDL_Texture *texture; SDL_Event event; SDL_Rect r; if (SDL_Init(SDL_INIT_VIDEO) < 0) { SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, \"Couldn't initialize SDL: %s\", SDL_GetError()); return; } window SDL_CreateWindow(\"SDL_CreateTexture\", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, 1024, 768, SDL_WINDOW_RESIZABLE); r.w 100; r.h 50; renderer SDL_CreateRenderer(window, 1, 0); texture SDL_CreateTexture(renderer, SDL_PIXELFORMAT_RGBA8888, SDL_TEXTUREACCESS_TARGET, 1024, 768); // 跳来跳去的方块 while (1) { SDL_PollEvent(&event); if (event.type SDL_QUIT) break; r.x rand() % 500; r.y rand() % 500; SDL_SetRenderTarget(renderer, texture); SDL_SetRenderDrawColor(renderer, 0x00, 0x00, 0x00, 0x00); SDL_RenderClear(renderer); SDL_RenderDrawRect(renderer, &r); SDL_SetRenderDrawColor(renderer, 0xFF, 0x00, 0x00, 0x00); SDL_RenderFillRect(renderer, &r); SDL_SetRenderTarget(renderer, NULL); SDL_RenderCopy(renderer, texture, NULL, NULL); SDL_RenderPresent(renderer); } SDL_DestroyRenderer(renderer); SDL_Quit(); return; } ``` ### 一个YUM显示器 [【音视频 YUV格式】深入理解 YUV 数据格式，一文弄懂 CSDN博客](https://blog.csdn.net/wkd_007/article/details/141218195) [YUV Sequences (asu.edu)获取一个yuv格式的视频](http://trace.eas.asu.edu/yuv/index.html) ```c // SDL.cpp : 此文件包含 \"main\" 函数。程序执行将在此处开始并结束。 // #include \"stdlib.h\" #include \"stdio.h\" #include \"SDL.h\" //Bit per Pixel #define bpp 12 int screen_w 500, screen_h 500; // 根据不同的YUV视频，来设置不同的 宽 * 高 数据 #define pixel_w 352 #define pixel_h 288 unsigned char buffer[pixel_w*pixel_h*bpp / 8]; //Refresh Event #define REFRESH_EVENT (SDL_USEREVENT + 1) int thread_exit 0; int refresh_video(void *opaque) { while (thread_exit 0) { SDL_Event event; event.type REFRESH_EVENT; SDL_PushEvent(&event); SDL_Delay(40); } return 0; } int main(int argc, char* argv[]) { if (SDL_Init(SDL_INIT_VIDEO)) { printf(\"Could not initialize SDL %s\\n\", SDL_GetError()); return 1; } SDL_Window *window; // 创建SDL窗口 window SDL_CreateWindow(\"Simplest Video Play SDL2\", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, screen_w, screen_h, SDL_WINDOW_OPENGL SDL_WINDOW_RESIZABLE); // 判断是否创建窗口成功 if (!window) { printf(\"SDL: could not create window exiting:%s\\n\", SDL_GetError()); return 1; } // 创建SDL渲染器 SDL_Renderer* sdlRenderer SDL_CreateRenderer(window, 1, 0); // 声明像素格式 Uint32 pixformat 0; // IYUV: Y + U + V (3 planes) // YV12: Y + V + U (3 planes) // I420也叫IYUV, 也叫YUV420 pixformat SDL_PIXELFORMAT_IYUV; // 按照YUV视频的宽高创建SDL纹理对象 SDL_Texture* sdlTexture SDL_CreateTexture(sdlRenderer, pixformat, SDL_TEXTUREACCESS_STREAMING, pixel_w, pixel_h); FILE *fp NULL; fp fopen(\"222.yuv\", \"rb+\"); if (fp NULL) { printf(\"cannot open this file\\n\"); return 1; } SDL_Rect sdlRect; SDL_Thread *refresh_thread SDL_CreateThread(refresh_video, NULL, NULL); SDL_Event event; while (1) { //Wait SDL_WaitEvent(&event); if (event.type REFRESH_EVENT) { // 读取一帧数数据到缓冲区 if (fread(buffer, 1, pixel_w*pixel_h*bpp / 8, fp) ! pixel_w * pixel_h*bpp / 8) { // Loop fseek(fp, 0, SEEK_SET); fread(buffer, 1, pixel_w*pixel_h*bpp / 8, fp); } // 将数据更新到纹理 SDL_UpdateTexture(sdlTexture, NULL, buffer, pixel_w); //FIX: If window is resize sdlRect.x 0; sdlRect.y 0; sdlRect.w screen_w; sdlRect.h screen_h; SDL_RenderClear(sdlRenderer); // 将更新后的纹理拷贝到渲染器 SDL_RenderCopy(sdlRenderer, sdlTexture, NULL, &sdlRect); // 渲染器显示画面 SDL_RenderPresent(sdlRenderer); //Delay 40ms Dealy时常根据帧率进行调整 SDL_Delay(40); } else if (event.type SDL_WINDOWEVENT) { //If Resize SDL_GetWindowSize(window, &screen_w, &screen_h); } else if (event.type SDL_QUIT) { break; } } return 0; } ``` ### PCM音频播放 [音频处理——详解PCM数据格式_pcm格式 CSDN博客](https://blog.csdn.net/qq_28258885/article/details/120197122) #### 音频播放的API ```c void SDLCALL SDL_PauseAudio(int pause_on) ``` 当pause_on设置为0的时候即可开始播放音频数据。设置为1的时候，将会播放静音的值。 #### 实际示例 ```c // SDL.cpp : 此文件包含 \"main\" 函数。程序执行将在此处开始并结束。 // #include \"stdio.h\" #include \"SDL.h\" /** * * 使用SDL2播放PCM音频采样数据。SDL实际上是对底层绘图API（Direct3D，OpenGL）的封装，使用起来明显简单于直接调用底层API。 * * 函数调用步骤如下: * * [初始化] * SDL_Init(): 初始化SDL。 * SDL_OpenAudio(): 根据参数（存储于SDL_AudioSpec）打开音频设备。 * SDL_PauseAudio(): 播放音频数据。 * * [循环播放数据] * SDL_Delay(): 延时等待播放完成。 * * [播放音频的基本原则] * 声卡向你要数据而不是你主动推给声卡 * 数据的多少是由音频参数决定的 */ //Buffer: // //chunk pos len static Uint8 *audio_chunk; static Uint32 audio_len; static Uint8 *audio_pos; void fill_audio(void *udata, Uint8 *stream, int len) { //SDL 2.0 SDL_memset(stream, 0, len); if (audio_len 0) return; len (len > audio_len ? audio_len : len); SDL_MixAudio(stream, audio_pos, len, SDL_MIX_MAXVOLUME); audio_pos + len; audio_len len; } int main(int argc, char* argv[]) { //Init if (SDL_Init(SDL_INIT_AUDIO SDL_INIT_TIMER)) { printf(\"Could not initialize SDL %s\\n\", SDL_GetError()); return 1; } //SDL_AudioSpec SDL_AudioSpec wanted_spec; wanted_spec.freq 16000; //采样频率 wanted_spec.format AUDIO_S16SYS;// wanted_spec.channels 1; //声道的数量 wanted_spec.silence 0; wanted_spec.samples 1024; wanted_spec.callback fill_audio; if (SDL_OpenAudio(&wanted_spec, NULL) < 0) { printf(\"can't open audio.\\n\"); return 1; } FILE *fp fopen(\"333.pcm\", \"rb+\"); if (fp NULL) { printf(\"cannot open this file\\n\"); return 1; } int pcm_buffer_size 4096; char *pcm_buffer (char *)malloc(pcm_buffer_size); int data_count 0; //Play SDL_PauseAudio(0); while (1) { if (fread(pcm_buffer, 1, pcm_buffer_size, fp) ! pcm_buffer_size) { // Loop fseek(fp, 0, SEEK_SET); fread(pcm_buffer, 1, pcm_buffer_size, fp); data_count 0; } printf(\"Now Playing %10d Bytes data.\\n\", data_count); data_count + pcm_buffer_size; //Set audio buffer (PCM data) audio_chunk (Uint8 *)pcm_buffer; //Audio buffer length audio_len pcm_buffer_size; audio_pos audio_chunk; while (audio_len > 0)//Wait until finish SDL_Delay(1); } free(pcm_buffer); SDL_Quit(); return 0; } ``` > 可以使用[这一个网页](https://www.yayapeiyin.com/mp3 to pcm/)对数据格式进行转换"},"/note/嵌入式/模拟器/RISC-V模拟器/2024-9-3-04外设.html":{"title":"外设","content":" layout: post title: \"外设\" date: 2024 9 3 15:39:08 +0800 tags: RISC V # 外设 ## USART 在实际实现的时候不需要关心波特率之类的功能, 只需要实现打印即可"},"/note/嵌入式/模拟器/RISC-V模拟器/2024-8-19-02指令实现.html":{"title":"指令实现","content":" layout: post title: \"指令实现\" date: 2024 8 5 15:39:08 +0800 tags: RISC V # 指令实现 ## 实现思路 ![image 20240823225502441](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408232255495.png) + 首先，要创建模拟器对像riscv，后续模拟器的任何组件都要添加到其中 + 接下来，创建用于存储程序的Flash，并将二进制文件加载到Flash中 + 其次，在执行程序前，先复位整个riscv，让整个模拟器处于初始运行状态 + 最后，控制模拟器执行Flash中的程序 模拟器需要实现对指令的解析, ebreak是中断的断点指令, CPU遇到以后会在这里停顿 这一个指令通常的用途是用于调试, 在这里，之所以选用ebreak指令的运行作为第一项工作，是因为该指令的执行不需要访问任务的寄存器、存储器，但是仍然需要实现程序的加载、取指、运行工作。通过实现ebreak指令，我们可以将risc v模拟器的基本运行流程跑通。 ## 设备初始化 初始化一个设备, 在里面开辟一块空间, 这一块空间会作为之后的Flash, 同时还有初始化出来的寄存器 之后把加载的程序复制到这个开辟出来的flash里面 ### 实际的指令实现 读取一条指令, 之后根据这一条指令的含义, 对对应的寄存器进行操作"},"/note/嵌入式/模拟器/RISC-V模拟器/2024-8-5-01模拟器.html":{"title":"模拟器","content":" layout: post title: \"模拟器\" date: 2024 8 5 15:39:08 +0800 tags: RISC V # 模拟器 实现支持RV32IM指令集的运行 自带的GDB Server可以使用IDE进行调试 模拟Systick定时器, FPIC中断控制器, 串口等 支持RTOS 配置一个LCD界面 ![image 20240818201018011](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408182010078.png) ![image 20240818231242275](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408182312350.png) 暂时不使用拓展的指令集 ![image 20240818231320256](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408182313312.png) ### 基本代码 ```c static void plat_init(void) { \tWORD sockVersion MAKEWORD(2, 2); \tWSADATA wsaData; \tint rc WSAStartup(sockVersion, &wsaData); \tassert(rc 0); } ``` > 初始化一下Windows下面的Socket环境"},"/note/嵌入式/基础知识/Cotex-M3权威指南/2024-1-18-10系统异常.html":{"title":"系统异常","content":" layout: post title: \"系统异常\" date: 2024 1 17 15:39:08 +0800 tags: Cotex M3 # 系统异常 ## 使用中断 + 建立堆栈 + 建立向量表 + 分配各中断的优先级 + 使能中断 ### 建立堆栈 当开发的程序比较简单时，可以从头到尾都只使用MSP。这时，只需要保证开出一个容量够大的堆栈，再把MSP初始化到其顶即可 事实上，准确计算主堆栈需求往往是不可能的任务，也容易过于保守而浪费宝贵的血液资源。在调试阶段时，最好先选用内存更大点的器件，然后开出足够大的内存给主堆栈。然后在调试程序时，允许随时把主堆栈曾经的最大用量输出（通过调试串口或仿真器等），这样时间长了就能估算对主堆栈的需求 ### 建立向量表 如果在程序执行的从头到尾，都只给每个中断提供固定的中断服务例程（这也是目前单片机开发的绝大多数情况），则可以把向量表放到ROM中 ### 建立新的优先级 ```assembly ; 把IRQ #4的优先级设为0xC0 LDR R0, 0xE000E400 ; 加载外部空优先级寄存器阵列的起始地址 LDR R1, 0xC0 ; 优先级 STRB R1, [R0, #4] ; 为IRQ #4设置优先级（按字节写） ``` 在CM3中，允许使用3个位到8个位来表达优先级。为了确定具体的位数，可以先往一个优先级寄存器中写0xFF，再读回来，读出多少个1，就表示使用多少个位来表达优先级 ```assembly ; 检测系统使用多少个位来表达优先级 LDR R0, 0xE000E400 ; 加载IRQ #0的优先级配置寄存器 LDR R1, 0xFF STRB R1, [R0] ; 按字节写，写入0xFF LDRB R1, [R0] ; 读回（如果是3位，则应读取回0xE0） RBIT R2, R1 ; 反转，使之以LSB对齐 CLZ R1, R2 ; 计算前导零个数（例如，如果是3个1则返回5） MOV R2, #8 SUB R2, R2, R1 ; 得到表达优先级的位数 MOV R1, #0x0 STRB R1, [R0] ; 存储结果 ``` ### 使能中断 有两条注意事项 > 如果把向量表重定位到了RAM中，且这块RAM所在的存储器区域是写缓冲的，向量更新就可能被延迟。为了以防万一，必须在建立完所有向量后追加一条“数据同步隔离(DSB)”指令（见第4章），以等待缓冲写入后再继续，从而确保所有数据都已落实。 > > 开中断前可能已经有中断悬起，或者请求信号有效了，这往往是不可预料的。比如，在上电期间，信号线上有发生过毛刺，就可能会被意外地判定成一次中断请求脉冲。另外，在某些外设，如UART，在串口连接瞬间的一些噪音也可以被误判为接收到的数据，从而使中断被悬起。 在NVIC中进行中断的使能与除能时，都是使用各自的寄存器阵列(SETENA/CLRENA)来完成的：通过往适当的位写1来发出命令，而写0则不会有任何效果。这就让每个中断都可以自顾地使能和除能，而不必担心会破坏其它中断的设置。 ```assembly ; 根据IRQ号来使能中断的子程序 EnableIRQ \t; 入口条件：R0 中断号 \tPUSH {R0 R2, LR} \tAND.W R1, R0, #0x1F ; 为该IRQ产生移位量 \tMOV R2, #1 \tLSL R2, R2, R1 ; 位旗标 (0x1 << (N & 0x1F)) \tAND.W R1, R0, #0xE0 ; 若IRQ编号>31则为它生成下标偏移量 \tLSR R1, R1, #3 ; 地址偏移量 (N/32)*4（每个IRQ一个位） \tLDR R0, 0xE000E100 ; 加载SETENA寄存器阵列的首地址 \tSTR R2, [R0, R1] ; 写入该中断的位旗标，从而使能该中断 \tPOP {R0 R2, PC} ; 子程返回 ``` ## 异常中断服务函数 ```assembly irq1_handler \t; 处理中断请求 \t... ; 消除在设备中的IRQ请求信号 ... ; 中断返回 BX LR ``` 些外设的中断请求信号需要ISR手工清除，如：外设的中断请求是持续的电平信号——显然，对于稍纵即逝的脉冲型的请求，是无需手工清除的。若电平型中断请求没有清除，则中断返回后将再次触发已经服务过的中断。 ## 软件触发中断 + 外部中断输入 + 设置NVIC的悬起寄存器中设置相关的位（第8章） + 使用NVIC的软件触发中断寄存器（STIR）（ 第8章） 系统中总是会有一些中断没有用到，此时就可以当作软件中断来使用。软件中断的功用与SVC类似，两者都能用于让任务进入特权级下，以获取系统服务。不过，若要使用软件中断，必须在初始化时把NVIC配置与控制寄存器的USERSETMPEND位置位，否则是不允许用户级下访问STIR的 但是软件中断没有SVC专业：比如，它们是不精确的，也就是说，抢占行为不一定会立即发生，即使当时它没有被掩蔽，也没有被其它ISR阻塞，也不能保证马上响应。这也是写缓冲造成的，会影响到与操作NVIC STIR相临的后一条指令 为解决这个问题，必须使用一条DSB指令 ```assembly MOV R0, #SOFTWARE_INTERRUPT_NUMBER LDR R1, 0xE000EF00 ; 加载NVIC软件触发中断寄存器的地址 STR R0, [R1] ; 触发软件中断 DSB ; 执行数据同步隔离指令 ``` 如果欲触发的软件中断被除能了，或者执行软件中断的程序自己也是个异常服务程序，软件中断就有可能无法响应。因此，必须在使用前检查这个中断已经在响应中了。为达到此目的，可以让软件中断服务程序在入口处设置一个标志。 如果系统中包含了不受信任的用户程序，就必须全体接种疫苗——每个异常服务例程都必须检查该异常是否允许。 ## 使用SVC SVC是用于呼叫OS所提供API的正道。用户程序只需知道传递给OS的参数，而不必知道各API函数的地址 SVC指令带一个8位的立即数，可以视为是它的参数，被封装在指令本身中 ```assembly SVC 3 ;呼叫3号系统服务 ``` ![image 20240118154444062](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401181544110.png) ```assembly svc_handlerTST LR, #0x4 ; 测试EXC_RETURN的比特2 ITE EQ ; 如果为0, MRSEQ R0, MSP ; 则使用的是主堆栈，故把MSP的值取出 MRSNE R0, PSP ; 否则, 使用的是进程堆栈，故把PSP的值取出 LDR R1, [R0,#24] ; 从栈中读取PC的值 LDRB R0, [R1,# 2] ; 从SVC指令中读取立即数放到R0 ; 准备调用系统服务函数。这需要适当调整入栈的PC的值以及LR(EXC_RETURN)，来进入OS内部 BX LR ; 借异常返回的形式，进入OS内部，最终调用系统服务函数 ``` > 使用则一种传递参数的方式而不是直接使用寄存器的原因是当SVC作为咬尾函数被调用的时候不会发生错误 ## 在C中使用SVC ```c // 汇编封皮，用于提出堆栈帧的起始位置，并放到R0中，然后跳转至实际的SVC服务例程中 __asm void svc_handler_wrapper(void) { \tIMPORT svc_handlerTST LR, #4 ITE EQ MRSEQ R0, MSP MRSNE R0, PSP B svc_handler } ``` ```c // 使用C写成的SVC服务例程，接受一个指针参数（pwdSF）：堆栈栈的起始地址。 // pwdSF[0] R0 , pwdSF[1] R1 // pwdSF[2] R2 , pwdSF[3] R3 // pwdSF[4] R12, pwdSF[5] LR // pwdSF[6] 返回地址（入栈的PC） // pwdSF[7] xPSR unsigned longsvc_handler(unsigned int* pwdSF) { unsigned int svc_number; unsigned int svc_r0; unsigned int svc_r1; unsigned int svc_r2; unsigned int svc_r3; int retVal; //用于存储返回值 svc_number ((char *) pwdSF[6])[ 2]; // 没想到吧，C的数组能用得这么绝！ svc_r0 ((unsigned long) pwdSF[0]); svc_r1 ((unsigned long) pwdSF[1]); svc_r2 ((unsigned long) pwdSF[2]); svc_r3 ((unsigned long) pwdSF[3]); printf (“SVC number %xn”, svc_number); printf (“SVC parameter 0 %x\\n”, svc_r0); printf (“SVC parameter 1 %x\\n”, svc_r1); printf (“SVC parameter 2 %x\\n”, svc_r2); printf (“SVC parameter 3 %x\\n”, svc_r3); //做一些工作，并且把返回值存储到retVal中 pwdSF[0] retVal; return 0; } ``` 这个函数返回的其实不是0！返回的是retVal 这个函数可是异常服务例程，它的返回可是享受“异常返回”的待遇的——伴随着一个硬件控制的自动出栈行为，这会从堆栈中重建R0的值，从而覆盖“return”指定的值。因此，它必须把返回值写到堆栈中R0的位置，才能借自动出栈之机返回自己的值（pwdSF[0] retVal） ### 编译器简化 + Keil RVDS和Keil RVMDK中，为了方便我们放参数，提供了“__svc”编译器指示字。举例来说，如果需要在3号服务请求中传递4个参数，则可以类似下例写： ```c unsigned long__svc(0x03)CallSvc3(unsigned long svc_r0, unsigned long svc_r1, unsigned long svc_r2, unsigned long svc_r3); ``` 当C程序调用这种函数时，则编译器会自动生成SVC指令 ```c svcRet CallSvc3(p0, p1, p2, p3); // 呼叫3号系统服务，并且传递4个参数，依次为：p1,p2,p3,p4，再接收返回值到svcRet中（别忘了，这个返回值的来历不寻常） ``` + GNU 如果使用的是GNU的工具链，里面没有__svc关键字。但是GCC支持内联汇编，可以实现此功能。 ```c int MyDataIn ＝ 0x123; __asm __volatile (”mov R0, %0\\n” ”svc 3 \\n” : ”” : ”r” (MyDataIn) ); ```"},"/note/嵌入式/基础知识/Cotex-M3权威指南/2024-1-16-03指令集.html":{"title":"指令集","content":" layout: post title: \"指令集\" date: 2024 1 16 15:39:08 +0800 tags: Cotex M3 # 指令集 ## 基础语法 ```assembly 标号 \t操作码操作数1, 操作数2, ... ;注释 ``` > 标号是可选的，如果有，它必须顶格写。标号的作用是让汇编器来计算程序转移的地址。 > > 操作码是指令的助记符，它的前面必须有至少一个空白符，通常使用一至二个“Tab”键来产生。操作码后面往往跟随若干个操作数，而第1个操作数，通常都给出本指令的执行结果存储处。不同指令需要不同数目的操作数 > 立即数必须以“#”开头 ```assembly MOV R0, #0x12 ; R0 < 0x12 MOV R1, #’A’ ; R1 < 字母A的ASCII码 ``` 还可以使用EQU指示字来定义常数 ```assembly NVIC_IRQ_SETEN0 EQU 0xE000E100 ;注意：常数定义必须顶格写 ``` > 宏定义 ```assembly MOV R1, #NVIC_IRQ0_ENABLE ; 把立即数传送到R1中 ``` 如果汇编器不能识别某些特殊指令的助记符，你就要“手工汇编”——查出该指令的确切二进制机器码，然后使用DCI编译器指示字。例如，BKPT指令的机器码是0xBE00，即可以按如下格式书写： ```assembly DCI 0xBE00 ; 断点(BKPT)，这是一个16位指令 ``` 可以使用DCB来定义一串字节常数，字节常数还允许以字符串的形式来表达；还可以使用DCD来定义一串32位整数 ![image 20240116203814554](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162038590.png) ## 后缀 ![image 20240116203922652](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162039688.png) > ![image 20240116204425447](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162044475.png) Cortex M3中，对条件后缀的使用有很大的限制：只有转移指令（B指令）才可随意使用。 S后缀可以和条件后缀在一起使用 ## 指令 ### 16位数据操作 ![image 20240116204617818](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162046886.png) ### 16位转移指令 ![image 20240116204703960](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162047992.png) ![image 20240116204715593](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162047612.png) ### 16位存储器数据传送 ![image 20240116204826031](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162048073.png) ### 16位其他指令 ![image 20240116204915325](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162049365.png) ### 32位数据操作 ![image 20240116205054520](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162050556.png) ![image 20240116205156012](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162051104.png) ![image 20240116205210942](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162052964.png) ### 32位存储器数据传送 ![image 20240116205250930](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162052972.png) ### 32位跳转 ![image 20240116205318700](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162053731.png) ### 32位其他指令 ![image 20240116205426173](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162054220.png) ![image 20240116205510253](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162055285.png) ## 实际使用 ### 数据的传送 #### 寄存器之间的传送 ```assembly MOV R8, R3 ``` #### 访问存储器 ![image 20240116205806998](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162058031.png) ![image 20240116205840223](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162058252.png) ![image 20240116205952196](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162059242.png) ![image 20240116210022858](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162100877.png) > 使用!表示自增或者自减, 如果不加!的话寄存器里面的值不会变 > > 还可以用于更新寄存器的标志, `LDR.W R0, [R1, #20]!`, 先执行R1 R1 + 20, 之后把R1位置的值放到R0(预索引) > > ![image 20240116210636136](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162106179.png) > 后索引 > > 先把寄存器地址里面的值取出来以后再进行更新寄存器 > > ```assembly > STR.W R0, [R1], # 12 ;后索引 > ``` > > ![image 20240116210812534](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162108574.png) > **注: **使用寄存器作为偏移的时候不能使用前后索引 ##### 立即数 16位指令MOV支持8位立即数加载 ```assembly MOV R0, #0x12 ``` 32位指令MOVW和MOVT可以支持16位立即数加载。 要加载32位立即数怎么办呢？如果要直来直去，当前是要用两条指令来完成了。通过组合使用MOVW和MOVT就能产生32位立即数, 必须先使用MOVW，再使用MOVT。这种顺序是不能颠倒的，因为MOVW会清零高16位 更流行的是另一种方法：使用汇编器提供的”LDR Rd, imm32”伪指令 #### LDR 和 ADR伪指令 > 如果加载的是程序地址, 会把最低位设置为1, 加载的是数据不会设置为1 > > ![image 20240116211925600](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162119633.png) > > ![image 20240116211933933](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162119958.png) > > ADR指令不会设置为1 > > ![image 20240116212013911](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162120938.png) ### 数据处理 ![image 20240116212208406](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162122430.png) #### 常见的四则运算 ![image 20240116212254043](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162122103.png) ![image 20240116212426200](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162124235.png) #### 常用逻辑运算 ![image 20240116212516599](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162125659.png) ![image 20240116212702910](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162127956.png) #### 位移和循环 ![image 20240116212812315](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162128366.png) ![image 20240116213237068](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162132111.png) #### 带符号位扩展 ![image 20240116213452204](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162134232.png) #### 数据顺序翻转 ![image 20240116213533972](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162135003.png) ![image 20240116213550461](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162135497.png) #### 位段处理 ![image 20240116213654266](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162136301.png) ### 程序呼叫与跳转 + 无条件跳转 ```assembly B Label ;跳转到Label处对应的地址 BX reg ;跳转到由寄存器reg给出的地址 ``` > reg的最低位指示出在转移后将进入的状态：是ARM(LSB 0)，还是Thumb(LSB 1)。CM3只在Thumb中运行，就必须保证reg的LSB 1 + 保存返回地址 ```assembly BL Label ;跳转到Label对应的地址，并且把跳转前的 下条指令地址保存到LR BLX reg ;跳转到由寄存器reg给出的地址，并根据REG的LSB切换处理器状态， ;还要把转移前的下条指令地址保存到LR ``` > 只能保存一级, 所以在进行多层调用的时候需要对LR寄存器的值进行并保存 + 条件转移 ![image 20240116221802654](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162218701.png) > 主要用于跳转指令条件以及IF Then指令的依据 ![image 20240116221927840](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162219886.png) ![image 20240116222002050](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162220076.png) ![image 20240116222309321](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162223352.png) > CMP指令。CMP指令在内部做两个数的减法，并根据差来设置标志位，但是不把差写回 > > ```assembly > CMP R0, R1 ; 计算R0 R1的差，并且根据结果更新标志位 > CMP R0, 0x12 ; 计算R0 0x12的差，并且根据结果更新标志位 > ``` > > CMN是CMP的一个孪生姊妹，只是它在内部做两个数的加法（相当于减去减数的相反数） > > ```assembly > CMN R0, R1 ; 计算R0+R1的和，并根据结果更新标志位 > CMN R0, 0x12 ; 计算R0+0x12的和，并根据结果更新标志位 > ``` > > TST指令的内部其实就是AND指令，只是不写回运算结果，它也无条件更新标志位。 > > ```assembly > TST R0, R1 ; 计算R0 & R1，并根据结果更新标志位 > TST R0, 0x12 ; 计算R0 & 0x12，并根据结果更新标志位 > ``` > > TEQ指令的内部其实就是EOR指令，只是不写回运算结果，它也无条件更新标志位。 > > ```assembly > TEQ R0, R1 ; 计算R0 ^ R1，并根据结果更新标志位 > TEQ R0, 0x12 ; 计算R0 ^ 0x12，并根据结果更新标志位 > ``` ### 隔离指令(存储器相关) 在进行存储器映射关系改变或者保护区的改变以后, 需要一个数据同步指令DSB ![image 20240117125124501](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171251634.png) > 一般情况下主要使用前两条 > > 第三条可以在更新代码以后使用用来清空流水线 ### 饱和运算 主要用于进行削顶失真, 原因是数字溢出以后, 会从最大变成最小, 最小变为最大 使用饱和运算以后会在到达极值以后保持极值 ![image 20240117130211481](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171302536.png) ![image 20240117130245029](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171302064.png) 举例来说，如果要把一个32位（带符号）整数饱和到12位带符号整数（ 2048至2047），则可以如下使用SSAT指令 ```assembly SSAT{.W} R1, #12, ``` ![image 20240117130332381](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171303416.png) 如果需要把32位整数饱和到无符号的12位整数（0 4095），则可以如下使用USAT指令 ```assembly USAT{.W} R1, #12, R0 ``` ![image 20240117130500683](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171305731.png) ![image 20240117130522975](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171305006.png) ![image 20240117130531350](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171305376.png) ### 其他指令 #### MSR/MRS特殊寄存器操控 访问特殊功能寄存器的“专用通道”, 必须在特权级下使用，除了APSR可以在用户级下访问外。 ![image 20240117130726748](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171307803.png) ![image 20240117130811156](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171308185.png) #### IF THEN 围起一个块，里面最多有4条指令，它里面的指令可以条件执行 IT指令已经带了一个“T”，因此还可以最多再带3个“T”或者“E”。 并 且对T和E的顺序没有要求。其中T对应条件成立时执行的语句，E对应条件不成立时执行的语句。在If Then块中的指令必须加上条件后缀，且T对应的指令必须使用和IT指令中相同的条件，E对应的指令必须使用和IT指令中相反的条件。 ```assembly IT的使用形式总结如下：IT <cond> ;围起1条指令的IF THEN块 IT<x> <cond> ;围起2条指令的IF THEN块 IT<x><y> <cond> ;围起3条指令的IF THEN块 IT<x><y><z> <cond> ;围起4条指令的IF THEN块 ``` ![image 20240117131134348](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171311388.png) #### CBZ/CBNZ比较跳转 比较并条件跳转指令专为循环结构的优化而设，它只能做前向跳转 ```assembly BZ <Rn>, <label> CBNZ <Rn>, <label> ``` ```c while (R0! 0) { Function1(); } 变成 Loop CBZ R0, LoopExit BL Function1 B Loop LoopExit: ... ``` > CBZ/CBNZ不会更新标志位 #### REV, REVH,REV16以及REVSH大小端处理 REV反转32位整数中的字节序，REVH则以半字为单位反转，且只反转低半字。语法格式为 ```assembly REV Rd, Rm REVH Rd, Rm REV16 Rd, Rm REVSH Rd, ``` 记R0 0x12345678 ```assembly REV R1, R0 REVH \tR2, R0 REV16 \tR3, R0 ``` > 执行后R1 0x78563412，R2 0x12347856，R3 0x34127856 专门服务于小端模式和大端模式的转换 REVSH在REVH的基础上，还把转换后的半字做带符号扩展 #### RBIT翻转 比前面的REV之流更精细，它是按位反转的，相当于把32位整数的二进制表示法水平旋转180度。其格式为：`RBIT.W Rd, Rn` 例如，记R1 0xB4E10C23（二进制数值为 1011,0100,1110,0001,0000,1100,0010,0011），``RBIT.W R0, R1` R0 0xC430872D（二进制数值为1100,0100,0011,0000,1000,0111,0010,1101） #### SXTB, SXTH, UXTB, UXTH数据扩展 为了体贴C语言的强制数据类型转换而设的，把数据宽度转换成处理器喜欢的32位长度 对于SXTB/SXTH，数据带符号位扩展成32位整数。对于UXTB/UXTH，高位清零 ```assembly SXTB R1, R0 ; R1 0x00000065 SXTH R1, R0 ; R1 0xffff8765 UXTB R1, R0 ; R1 0x00000065 UXTH R1, R0 ; R1 0x00008765 ``` #### BFC/BFI，UBFX/SBFX寄存器中部分数据转移 BFC（位段清零）指令把32位整数中任意一段连续的2进制位s清0，语法格式为 ```assembly BFC.W Rd, #lsb, #width ``` ```assembly LDR R0, 0x1234FFFF BFC R0, #4, #10\t\tR0 0x1234C00F\t ``` > 位段不支持首尾拼接。例如， BFC R0, #27, #9将产生不可预料的结果 BFI（位段插入指令），把某个寄存器按LSB对齐的数值，拷贝到另一个寄存器的某个位段中， ```assembly BFI .W Rd, Rn, #lsb, #width LDR R0, 0x12345678 LDR R1, 0xAABBCCDD BFI.W \tR1, R0, #8, ``` UBFX/SBFX都是位段提取指令 ```assembly UBFX.W Rd, Rn, #lsb, #width SBFX.W Rd, Rn, #lsb, #width ``` UBFX从Rn中取出任一个位段，执行零扩展后放到Rd中 ![image 20240117133157776](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171331805.png) SBFX也抽取任意的位段，但是以带符号的方式进行扩展。 ![image 20240117133221456](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171332482.png) #### LDRD/STRD 64位数据操作 ![image 20240117133512561](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171335596.png) ![image 20240117133549476](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171335506.png) #### TBB,TBH TBB（查表跳转字节范围的偏移量）指令和TBH（查表跳转半字范围的偏移量）指令，分别用于从一个字节数组表中查找转移地址，和从半字数组表中查找转移地址。TBH的转移范围已经足以应付任何臭长的switch结构。如果写出的switch连TBH都搞不定，只能说那人有严重自虐倾向。 因为CM3的指令至少是按半字对齐的，表中的数值都是在左移一位后才作为前向跳转的偏移量的。又因为PC的值为当前地址+4，故TBB的跳转范围可达255*2+4 514 TBH的跳转范围更可高达65535*2+4 128KB+2 > 只能作前向跳转，也就是说偏移量是一个无符号整数。 ```assembly TBB.W [Rn,Rm]; PC+ Rn[Rm]*2 ``` ![image 20240117134552746](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171345789.png) ![image 20240117134656818](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171346861.png) TBH的操作原理与TBB相同，只不过跳转表中的每个元素都是16位的。故而下标为Rm的元素要从Rn+2*Rm处去找。 ![image 20240117134717986](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171347024.png) ![image 20240117135004962](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171350009.png)"},"/note/嵌入式/基础知识/Cotex-M3权威指南/2024-1-18-09Cotex-M3低层编程.html":{"title":"Cotex-M3低层编程","content":" layout: post title: \"Cotex M3低层编程\" date: 2024 1 17 15:39:08 +0800 tags: Cotex M3 # Cotex M3低层编程 ## 使用汇编 + 无法用C写成的函数，如操作特殊功能寄存器，以及实施互斥访问。 + 在危急关头执行处理的子程（如，NMI服务例程）。 + 存储器极度受限，只有使用汇编才可能把程序或数据挤进去。 + 执行频率非常高的子程，如操作系统的调度程序。 + 与处理器体系结构相关的子程，如上下文切换。 + 对性能要求极高的应用，如防空炮的火控系统。 ## 使用C ![image 20240118125607269](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401181256301.png) 当使用C开发程序时，推荐开启CM3的双字对齐管理机制（在NVIC配置与控制寄存器中，把STKALIGN置位），代码形如： ```c #define NVIC_CCR ((volatile unsigned long *)(0xE000ED14)) *NVIC_CCR ＝ *NVIC_CCR 0x200; //设置STKALIGN位 ``` ## 汇编和C接口 + 在C代码中使用了嵌入式汇编（或者是在GNU工具下，使用了内联汇编） + C程序呼叫了汇编程序，这些汇编程序是在独立的汇编源文件中实现的 + 汇编程序调用了C程序 在大多数场合下的情况都比较简单：当主调函数需要传递参数（实参）时，它们使用R0 R3。其中R0传递第一个，R1传递第2个......在返回时，把返回值写到R0中。 但若使用R4 R11，则必须在使用之前先PUSH它们，使用后POP回来。 汇编要呼叫C函数，则考虑问题的方式就有所不同：必须意识到子程序可以随心所欲地改写R0 R3, R12，却决不会改变R4 R11。因此，如果在调用后还需要使用R0 R3,R12，则在调用之前，必须先PUSH，从C函数返回后再POP它们, 对R4 R11则不用操心。 ![image 20240118131557025](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401181315070.png) ## 示例 ```assembly STACK_TOP EQU 0x20002000 ; SP初始值，常数 \tAREA Header Code, CODE \tDCD STACK_TOP ; 栈顶（MSP的） \tDCD Start ; 复位向量 \tENTRY ; 指示程序从这里开始执行 Start ; 主程序开始; 初始化寄存器 \tMOV r0, #10 ; 加载循环变量的初值 \tMOV r1, #0 ; 初始化运算结果的值 \t; 计算 10+9+8+...+1 loop \tADD r1, r0 ; R1 + R0 \tSUBS r0, #1 ; R0自减，并且根据结果更新标志（有”S”后缀） \tBNE loop ; if (R0! 0) goto loop; \t; 现在，运算结果在R1中 deadloop \tB deadloop ; 工作完成后，进入无穷循环 \tEND ; 标记文件结束\t ``` > ```bash > $> armasm cpu cortex m3 o test1.o test1.s > $> armlink rw_base 0x20000000 ro_base 0x0 map o test1.elf test1.o > ``` > > “ ro_base 0x0”的意思是说，把只读区（也就是程序ROM）的起始地址设为0；而“ rw_base 0x20000000”则指定读写区（数据存储器）从0x20000000开始（在本例中，我们没有定义任何RAM数据）。“ map”选项则要求连接器给出存储器分配映射表，通过它，可以查看编译后的映像中内存的布局。 > > ```bash > $> fromelf bin output test1.bin test1.e > $> fromelf c output test1.list test1.elf # 一般不会执行这一步 > ``` ## 和外界互动 在CM3中有很多调试组件，它们提供了一系列输出调试消息的方法： + 半主机（Semihosting）：取决于调试器与代码库的支持，可以通过NVIC的调试寄存器来做S emihosting（通过调试探测设备，以printf的形式输出消息），第15章还要深入讨论这个主题。使用时，你要在C程序中使用printf函数，然后其输出就会显示在终端，或者显示在调试软件标准输出（STDOUT）上，具体细节还是请参阅第15章。 + 硬件水平上支持的跟踪：如果使用的CM3单片机提供了一个跟踪接口，并且有一台外部的跟踪接口分析仪（TPA）的话，则可以解放出UART，而使用ITM来做形如printf的调试。跟踪端口就是为了这种调试而生的，它可比UART专业多了——速度快而且能提供多条信道。 + 硬件水平上支持的跟踪——通过串行线查看器：作为后备方案，CM3的TPIU还提供了“串行线查看器（SWV）”操作模式。有了它，就可以使用远比TPA便宜的硬件来捕获从ITM发来的消息。不过，在SWV模式下，带宽并不富余，因此在需要输出大量数据时，本法就显得有些力不从心。 ### 显示的示例 ```assembly UART0_BASE EQU 0x4000C000 UART0_FLAG EQU UART0_BASE+0x018 UART0_DATA EQU UART0_BASE+0x000 Putc ; 该子程使用UART来发一个字符 ; 入口条件： R0 需要发的字符 \tPUSH {R1,R2, LR} ; 保存寄存器 \tLDR R1, UART0_FLAG PutcWaitLoop \tLDR R2, [R1] ; 读取状态标志 \tTST R2, #0x20 ; 检查“发送缓冲满”标志 \tBNE PutcWaitLoop ; 若已满则重试（若UART当掉了，则可能死循环） \tLDR R1, UART0_DATA ; 有空位时，就把UART发送站寄存器地址加载 \tSTRB R0, [R1] ; 然后通过它把字符送给输出缓冲区 \tPOP {R1,R2, PC} ; 子程返回 ``` > putc函数 ```assembly Puts ; 该子程往UART送一个字符串 ; 入口条件：R0 待输出字符串的起始地址 ; 这个字符串必须以零结尾（C语言格式） PUSH {R0 ,R1, LR} ; 先保存寄存器 MOV R1, R0 ; 把地址拷贝到R1，因为待会儿调用Putc时还要用 \t\t\t\t\t\t\t\t\t; R0来传参数 PutsLoop \tLDRB R0, [R1], #1 ; 读取一个字符，再自增地址 \tCBZ R0, PutsLoopExit ; 若已到达零字符，则执行完毕，退出 \tBL Putc ; 把这个字符送往UART \tB PutsLoop ; 循环，以输出下一个字符 PutsLoopExit \tPOP {R0, R1, PC} ; 子程序返回 ``` > puts函数 ```assembly STACK_TOP EQU 0x20002000 ; SP初始值 UART0_BASE EQU 0x4000C000 UART0_FLAG EQU UART0_BASE+0x018 UART0_DATA EQU UART0_BASE+0x000 \tAREA Header Code, CODE \tDCD STACK_TOP ; MSP初始值 \tDCD Start ; 复位向量 \tENTRY Start ; 主程序入口点 \tMOV r0, #0 ; 初始化各寄存器 \tMOV r1, #0 \tMOV r2, #0 \tMOV r3, #0 \tMOV r4, #0 \tBL Uart0Initialize ; 初始化 \tUART0 LDR r0, HELLO_TXT ; 让R0指向客串的起始地址 \tBL Puts deadend \tB deadend ; 做完了工作，在这里原地打转 \t HELLO_TXTDCB “Hello world\\n”,0 ; 定义零结尾的“Hello world”END ; 本文件结束\t ``` > 主函数 ```assembly PutHex ; 以16进制输出寄存器的值 \t; 入口条件：R0 要显示的值 \tPUSH {R0 R3,LR} MOV R3, R0 ; 把R0的值拷贝到R3，以便待会使用R0传递参数给 Putc MOV R0, #’0’ ; 先显示“0x”前缀 BL Putc MOV R0, #’x’ BL Putc MOV R1, #8 ; 初始化循环变量 MOV R2, #28 ; 圆圈移位偏移量 PutHexLoop \tROR R3, R2 ; 圆圈右移28格——相当于圆圈左移4格 \tAND R0, R3, #0xF ; 此时最高4位移至最低4位，提取它们 \tCMP R0, #0xA ; 转换成ASCII码 \tITE \tGE ADDGE \tR0, #55 ; 若大于等于10,则使用字母A F表示 ORRLT \tR0, #0x30 ; 否则转换到0 9（原文使用ADDLT，效果相同） BL Putc ; 输出一个hex字符 SUBS R1, #1 ; 循环变量自减 BNE PutHexLoop ; 检查循环变量是否已减到0，从而循环8次 POP {R0 R3,PC} ; 显示完毕，子程返回 ``` > 显示一个16进制数 ```assembly PutDec ; 以10进制输出寄存器的值 \t; 入口条件：R0 要显示的值 \t; 因为是32位宽，最大值（0xffff_ffff）需要10个10进制位表示，再加上零结尾，共需11字节 \tPUSH {R0 R5, LR} ; 保存寄存器的值 \tMOV R3, SP ; 把当前堆栈指针拷贝到R3 \tSUB SP, SP, #12 ; 为文本缓冲区保留出11个字节（因为是满栈） \tMOV R1, #0 ; NULL字符 \tSTRB \tR1, [R3, # 1]! ; 先把NULL字符写到字符串的结尾（把各字符逆序输出 \t\t\t\t\t\t\t\t\t; 好“负负得正”）。这里使用了更新基址的预索引 \tMOV R5, #10 ; R5保存除数 PutDecLoop \tUDIV R4, R0, R5 ; R4 R0 / 10 \tMUL R1, R4, R5 ; R1 R4 * 10 \tSUB R2, R0, R1 ; R2 （ R0 (R0/10)*10），即个位 \tADD R2, 0x30 ; 转换成ASCII（因为R2只能是0 9），亦可使用ORR STRB R2, [R3, # 1]! ; 把ascii字符送进缓冲区 MOVS R0, R4 ; R0 商，并且根更新标志位以检查商是否为零 BNE PutDecLoop ; 若商为零，则已经把所有10进制位都求出 MOV R0, R3 ; R0指向文本缓冲区的起始地址 BL Puts ; 使用Puts显示结果 ADD SP, SP, #12 ; 恢复SP指针 POP {R0 R5, PC} ; 子程返回 ``` ## 使用数据存储区 在汇编源文件中定义一个相应的数据区。让连接器把数据区中的内容分派到我们指定的位置——从0x2000_0000(SRAM区的起始) ```bash $> armlink rw_base 0x20000000 ro_base 0x0 map o test1.elf test1.o ``` ```assembly STACK_TOP EQU 0x20002000 ; SP初始值，常数 \tAREA Header Code, CODE \tDCD STACK_TOP ; 栈顶（MSP的） \tDCD Start ; 复位向量 \tENTRY ; 指示程序从这里开始执行 Start ; 主程序开始 \t; 初始化寄存器 \tMOV r0, #10 ; 加载循环变量的初值 \tMOV r1, #0 ; 初始化运算结果的值 \t; 计算 10+9+8+...+1 loop ADD r1, r0 ; R1 + R0 SUBS r0, #1 ; R0自减，并且根据结果更新标志（有”S”后缀） BNE loop ; if (R0! 0) goto loop; ; 现在，运算结果在R1中 LDR r0, MyData1 STR r1, [r0] ;把结果存入MyData1 deadloop B deadloop ; 工作完成后，进入无穷循环 ;定义数据区 AREA Header Data, DATA ALIGN 4 MyData1 \tDCD 0 ; Destination of calculation result MyData2 \tDCD 0 \tEND ; 文件结束标记 ``` 在连接阶段，连接器要把DATA区放入读/写存储器中，因此MyData1的地址就将是我们指定的0x2000_0000。 ## 使用互斥访问实现信号量 ![image 20240118144925604](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401181449671.png) ## 使用位带实现互斥 ![image 20240118145243797](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401181452859.png) ## 使用位段提取与查表跳转 ![image 20240118145854101](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401181458154.png) ```assembly DecodeA \tLDR R0, A ; 从内存中读取A的值 \tLDR R0, [R0] \tUBFX R1, R0, #6, #2 ; R1 R0[7:6] \tTBB [PC, R1] BrTable1 \tDCB ((P0 BrTable1)/2) ; 如果 A[7:6] 00则跳至P0 \tDCB ((DecodeA1 BrTable1)/2) ; 如果 A[7:6] 01 则跳至DecodeA1，继续解码 \tDCB ((P1 BrTable1)/2) ; 如果 A[7:6] 10 则跳至P1 \tDCB ((DecodeA2 BrTable1)/2) ; 如果 A[7:6] 10 则跳至DecodeA2 DecodeA1 \tUBFX R1, R0, #3, #2 ; R1 R0[4:3]，准备二级解码 \tTBB [PC, R1] BrTable2 \tDCB ((P2 BrTable2)/2) ; 如果 A[4:3] 00 则跳至P2 \tDCB ((P3 BrTable2)/2) ; 如果 A[4:3] 01 则跳至P3 \tDCB ((P4 BrTable2)/2) ; 如果 A[4:3] 10 则跳至P4 \tDCB ((P4 BrTable2)/2) ; 如果 A[4:3] 11 则也跳至P4 DecodeA2 \tTST R0, #4 ; 只需检测一个位，因此无需UBFX \tBEQ P5 B P6 P0 ... ; P0 P1 ... ; P1 P2 ... ; P2 P3 ... ; P3 P4 ... ; P4 P5 ... ; P5 P6 ... ; P6 ```"},"/note/嵌入式/基础知识/Cotex-M3权威指南/2024-1-17-04存储器.html":{"title":"存储器","content":" layout: post title: \"存储器\" date: 2024 1 16 15:39:08 +0800 tags: Cotex M3 # 存储器 ## 映射 CM3的存储器只有一个单一的映射, 比如说NVIC和MPU都只有特定的位置, 方便移植 CM3有4GB的地址映射, 应用可以在内部SRAM, 外部SRAM以及代码区执行 ![image 20240117144307309](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171443384.png) + 系统控制空间 ![image 20240117144711075](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171447106.png) + AHB私有外设总线，只用于CM3内部的AHB外设，它们是：NVIC, FPB, DWT和ITM。 + APB私有外设总线，既用于CM3内部的APB设备，也用于外部设备（这里的“外部”是对内核而言）。CM3允许器件制造商再添加一些片上APB外设到APB私有总线上，它们通过APB接口来访问 ## 各内存属性 + 可否缓冲 + 可否缓存 + 可否执行 + 可否共享 > 使用MPU的时候可以分开配置不同位置的属性 1. 代码区（0x0000_0000 0x1FFF_FFFF）。该区是可以执行指令的，缓存属性为WT（“写通”，Write Through），即不可以缓存。此区亦允许布设数据存储器。在此区上的数据操作是通过数据总线接口的（估计读数据使用D Code，写数据使用System），且在此区上的写操作是缓冲的 2. SRAM区（0x2000_0000 – 0x3FFF_FFFF）。此区用于片内SRAM，写操作是缓冲的，并且可以选择WB WA(Write Back, Write Allocated)缓存属性。此区亦可以执行指令，以允许把代码拷贝到内存中执行——常用于固件升级等维护工作。 3. 片上外设区(0x4000_0000 – 0x5FFF_FFFF)。该区用于片上外设，因此是不可缓存的，也不可以在此区执行指令（这也称为eXecute Never, XN。ARM的参考手册大量使用此术语）。 4. 外部RAM区的前半段（0x6000_0000 0x7FFF_FFFF）。该区可用于布设片上RAM或片外RAM，可缓存（缓存属性为WB WA），并且可以执行指令。 5. 外部RAM区的后半段（0x8000_0000 – 0x9FFF_FFFF）。除了不可缓存(WT)外，同前半段。 6. 外部外设区的前半段(0xA000_0000 – 0xBFFF_FFFF)。用于片外外设的寄存器，也用于多核系统中的共享内存（需要严格按顺序操作，即不可缓冲）。该区也是个不可执行区。 7. 外部外设区的后半段(0xC000_0000 – 0xDFFF_FFFF)。目前与前半段的功能完全一致。 8. 系统区(0xE000_0000 – 0xFFFF_FFFF)。此区是私有外设和供应商指定功能区。此区不可执行代码。系统区涉及到很多关键部位，因此访问都是严格序列化的（不可缓存，不可缓冲）。而供应商指定功能区则是可以缓存和缓冲的。 ![image 20240117145656757](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171456798.png) > 1. 内存缓冲： 内存缓冲是指计算机中的一块高速内存，用于临时存储从较慢的存储设备（如硬盘或网络）读取的数据，以便提高数据访问的速度。它通常用在输入/输出操作中，可以减少对慢速设备的频繁访问。 > 2. 缓存： 缓存是指存储在计算机内存或者其他高速存储设备中的数据副本，以便快速访问和提高数据访问的性能。缓存可以用来存储经常访问或计算得到的数据，避免重复计算或频繁访问慢速存储设备。 ## 默认许可 ![image 20240117150032336](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171500386.png) ![image 20240117150050974](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171500012.png) ## 位带操作 ### 实际映射 可以使用普通的加载/存储指令来对单一的比特进行读写 其中一个是SRAM区的最低1MB范围，第二个则是片内外设区的最低1MB范围。 ![image 20240117150334038](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171503073.png) ![image 20240117150349646](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171503692.png) ![image 20240117150450654](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171504684.png) ![image 20240117151031728](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171510754.png) ### 使用优势 对于硬件I/O密集型的底层程序最有用 还可以简化比较某一位的跳转指令 在多任务的情况下, 实现访问任务的原子性(读 改 写 >写) ![image 20240117151610290](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171516336.png) > 位带操作并不只限于以字为单位的传送。亦可以按半字和字节为单位传送, 但是不管用哪一个对子，都必须保证目标地址对齐到字的边界上 ```c #define BITBAND(addr, bitnum) ((addr & 0xF0000000)+0x2000000+((addr & 0xFFFFF)<<5)+(bitnum<<2)) //把该地址转换成一个指针 #define MEM_ADDR(addr) *((volatile unsigned long *) (adr)) ``` > 当使用位带功能时，要访问的变量必须用volatile来定义。因为C编译器并不知道同一个比特可以有两个地址。所以就要通过volatile，使得编译器每次都如实地把新数值写入存储器，而不再会出于优化的考虑，在中途使用寄存器来操作数据的复本，直到最后才把复本写回——这会导致按不同的方式访问同一个位会得到不一致的结果 ```c volatile unsigned long bbVarAry[7] __attribute__(( at(0x20003014) )); volatile unsigned long* const pbbaVar (void*)(0x22000000+0x3014*8*4); pbbaVar[136] 1; //置位第136号比特 ``` > 不直接定义pbbaVer为一个大数组是应为这样这个数组会被记录到应用的大小里面 ## 非对齐数据传送 CM3支持在单一的访问中使用非（地址）对齐的传送，数据存储器的访问无需对齐。 非对齐的数据传送只发生在常规的数据传送指令中，如LDR/LDRH/LDRSH。其它指令则不支持 > 不支持的指令类型: > > 多个数据的加载/存储(LDM/STM) > > 堆栈操作PUSH/POP > > 互斥访问(LDREX/STREX)。如果非对齐会导致一个用法fault > > 位带操作。因为只有LSB有效，非对齐的访问会导致不可预料的结果。 ## 互斥访问 在互斥访问操作下，允许互斥体所在的地址被其它总线master访问，也允许被其它运行在本机上的任务访问，但是CM3能够“驳回”有可能导致竞态条件的互斥写操作 互斥访问分为加载和存储，相应的指令对子为LDREX/STREX, LDREXH/STREXH, LDREXB/STREXB，分别对应于字/半字/字节。 ```assembly LDREX Rxf, [Rn, #offset] STREX Rd, Rxf, [Rn, #offset] ``` > LDREX的语法同LDR相同，这里不再赘述。而STREX则不同。STREX指令的执行是可以被“驳回”的。当处理器同意执行STREX时，Rxf的值被存储到(Rn+offset)处，并且把Rd的值更新为0。但若处理器驳回了STREX的执行，则不会发生存储动作，并且把Rd的值更新为1。 当遇到STREX指令时，仅当在它之前执行过LDREX指令，且在最近的一条LDREX指令执行后，没有执行过其它的STR/STREX指令，才允许执行本条STREX指令——也就是说只有在LDREX执行后，从时间上与之距离最近的一条STREX才能成功执行。 其它情况下，驳回此STREX。包括：中途有其它的STR指令执行 中途有其它的STREX指令执行。 ![image 20240117154520703](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171545753.png) ![image 20240117154947763](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171549792.png) > LDREX/STREX的工作原理其实很简单。仍然以上一段程序为例：当执行了LDREX后，处理器会在内部标记出一段地址。原则上，这段地址从R0开始，范围由芯片制造商定义。技术手册推荐的范围是在4字节至4KB之间，但是很多粗线条的实现会标记整个4GB的地址。在标记以后， 对于第一个执行到的STR/STREX指令，只要其存储的地址落在标记范围内，就会清除此标记（对于整个4GB地址都被标记的情况，则任何存储指令都会清除此标记）。如果先后执行了两次LDREX，则以后一个LDREX标记的地址为准。 > 当使用互斥访问时，在CM3总线接口上的内部写缓冲会被旁路，即使是MPU规定此区是可以缓冲的也不行。这保证了互斥体的更新总能在第一时间内完成，从而保证数据在各个总线主机(master)之间是一致的 ## 端模式 一般的单片机使用的都是小段模式, 但是也支持大端模式"},"/note/嵌入式/基础知识/Cotex-M3权威指南/2024-1-16-02基础(寄存器-栈-中断向量表).html":{"title":"基础(寄存器-栈-中断向量表)","content":" layout: post title: \"基础(寄存器 栈 中断向量表)\" date: 2024 1 16 15:39:08 +0800 tags: Cotex M3 # 基础(寄存器 栈 中断向量表) ## 寄存器 ### 普通寄存器 R0 R7也被称为低组寄存器。所有指令都能访问它们。它们的字长全是32位，复位后的初始值是不可预料的 R8 R12也被称为高组寄存器。这是因为只有很少的16位Thumb指令能访问它们，32位的thumb 2指令则不受限制。它们也是32位字长，且复位后的初始值是不可预料的。 ![image 20240116174117645](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401161741689.png) > 当引用R13（或写作SP）时，引用到的是当前正在使用的那一个，另一个必须用特殊的指令来访问（MRS,MSR指令） > > ![image 20240116174403368](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401161744385.png) > R14是连接寄存器（LR）。在一个汇编程序中，你可以把它写作both LR和R14。LR用于在调用子程序时存储返回地址。例如，当你在使用BL(分支并连接，Branch and Link)指令时，就自动填充LR的值。 > > ![image 20240116174539633](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401161745663.png) > > LR的LSB却是可读可写的。这是历史遗留的产物。在以前，由位0来指示ARM/Thumb状态。因为其它有些ARM处理器支持ARM和Thumb状态并存，为了方便汇编程序移植，CM3需要允许LSB可读可写 > R15是程序计数器，在汇编代码中一般我们都都叫它的外号“PC”。 因为CM3内部使用了指令流水线，读PC时返回的值是当前指令的地址+4 > > CM3中的指令至少是半字对齐的，所以PC的LSB总是读回0。然而，在分支时，无论是直接写PC的值还是使用分支指令，都必须保证加载到PC的数值是奇数（即LSB 1），用以表明这是在Thumb状态下执行。倘若写了0，则视为企图转入ARM模式，CM3将产生一个fault异常 ### 特殊寄存器 #### 状态寄存器 ![image 20240116174132828](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401161741852.png) 它们只能被专用的MSR/MRS指令访问，而且它们也没有与之相关联的访问地址 ``` MRE \t<gp_reg>, <special_reg> \t\t; 读取寄存器到通用寄存器 MSR <special_reg>, <gp_reg> ;写通用寄存器的值到特殊功能寄存器 ``` ![image 20240116175115570](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401161751607.png) ![image 20240116183647749](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401161836785.png) > + PSR位的类型： > > 预留位：为将来的扩展预留 > 用户可写位：在任意模式下都可写，N，Z，C，V，Q，和GE[3:0]以及E位都是用户可写的。 > 特权模式位：在特权模式下可写，用户模式下写特权位没有效果，A，I，F，T和M[4:0]都是特权位。 > 执行状态位：在特权模式下可写，用户模式下写执行状态位没有效果，J和T位都是执行状态位，在ARM状态下一直为0 > > + 应用程序: PSR(APSR) > > ```c > N: 负数 ? 1 : 0 > Z: 运算结果为0 ? 1 : 0 > C: 进位标志.(4中情况) > 1. 加法指令(包括CMN): 当结果产生了进位,则为1,表示无符号数运算发生溢出; > 2. 减法指令(包括CMP): 当运算中发生了错位,为1, 表示运算发生下溢出; > 3. 对已在操作数中包含移位操作的运算指令,C被置为被移位寄存器最后移出去的位; > 4. 对于其他非加/减的运算指令,c一般不收影响; > V: 溢出标志位: 对于加减法,当操作数和运算结果都是以二进制的补码表示的带符号的数,切运算结果超出了有符号运算的范围溢出,V 1. > ``` > > + 中断号: PSR(IPSR) > + 执行: PSR(EPSR) > > ![image 20240116184216325](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401161842371.png) > > 通过MRS/MSR指令，这3个PSRs即可以单独访问，也可以组合访问（2个组合，3个组合都可以）。当使用三合一的方式访问时，应使用名字“xPSR”或者“PSR”。 #### 中断屏蔽寄存器 ![image 20240116175335023](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401161753060.png) > 要访问PRIMASK, FAULTMASK以及BASEPRI，同样要使用MRS/MSR指令 ![image 20240116175557291](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401161755318.png) #### 控制寄存器 ![image 20240116175712965](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401161757007.png) > 在Cortex M3的handler模式中，CONTROL[1]总是0。在线程模式中则可以为0或1。因此，仅当处于特权级的线程模式下，此位才可写，其它场合下禁止写此位。改变处理器的模式也有其它的方式：在异常返回时，通过修改LR的位2，也能实现模式切换。这是LR在异常返回时的特殊用法，颠覆了对LR的传统使用方式 > > **FreeRTOS里面使用到了** > > 仅当在特权级下操作时才允许写该位。一旦进入了用户级，唯一返回特权级的途径，就是触发一个（软）中断，再由服务例程改写该位 > 在线程模式＋用户级下，对系统控制空间（SCS）的访问将被阻止——该空间包含了配置寄存器组以及调试组件的寄存器组。除此之外，还禁止使用MRS/MSR访问刚才讲到的，除了APSR之外的特殊功能寄存器。如果以身试法，则对于访问特殊功能寄存器的，访问操作被忽略；而对于访问SCS空间的，将fault伺候。 ## 异常和中断 NVIC还有一条NMI输入信号线。NMI究竟被拿去做什么，还要视处理器的设计而定。在多数情况下，NMI会被连接到一个看门狗定时器，有时也会是电压监视功能块，以便在电压掉至危险级别后警告处理器。NMI可以在任何时间被激活，甚至是在处理器刚刚复位之后 > STM32连接的是CSSI中断, 当外部时钟异常的时候触发中断 ## 栈操作 支持一次多个寄存器 ``` PUSH {R0 R2} ;压入R0 R2 PUSH {R3 R5,R8, R12} ;压入R3 R5,R8，以及R12 POP {R3 R5,R8, R12} ;弹出R3 R5，R8，以及R12 POP {R0 R2} ;弹出R0 R2 ``` > 在使用的时候汇编器会把寄存器进行升序排列 ``` PUSH {R0 R3, LR} POP {R0 R3, PC} ``` ### 双栈 在使用OS的环境下，只要OS内核仅在handler模式下执行，用户应用程序仅在用户模式下执行，这种双堆栈机制派上了用场——防止用户程序的堆栈错误破坏OS使用的堆栈。 在特权级的时候使用MRS和MSR进行设置两个堆栈指针 ![image 20240116202209214](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401162022244.png) ## 复位(中断向量表) 从0地址的位置获取到复位函数和栈指针的值 因为CM3使用的是向下生长的满栈，所以MSP的初始值必须是堆栈内存的末地址加1 > 由于存储的是PC的值, 又是在Thumb模式下面进行的, 所以地址最低位设置为1"},"/note/嵌入式/基础知识/Cotex-M3权威指南/2024-1-20-20Cotex-M3开发.html":{"title":"Cotex-M开发","content":" layout: post title: \"Cotex M开发\" date: 2024 1 18 15:39:08 +0800 tags: Cotex M3 # Cotex M3开发 ## 选择产品 CM3有一些配置是可选的 + 外中断的数目 + 表达优先级的位数（优先级寄存器的有效宽度） + 是否配备了MPU + 是否配备了ETM + 对调试接口的选择（SW, JTAG或两者兼有） 主要需要关心的内容 + 外设 + 存储器 + 时钟速度 + 脚印 ## 编译器 ![image 20240120112709313](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401201127808.png) ## 使用GNU编译器 ### 汇编 #### 伪指令 [ARM架构下常用GNU汇编程序伪指令介绍（Assembler Directive）_.pushsection CSDN博客](https://blog.csdn.net/Roland_Sun/article/details/107705952) [GNU ARM 汇编基础笔记 CSDN博客](https://blog.csdn.net/Naisu_kun/article/details/116979178) ![image 20240120132748934](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401201327000.png) #### 链接 ![image 20240120120541401](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401201205452.png) ```assembly /* 定义常数 */ .equ STACK_TOP, 0x20000800 .text .global _start .code 16 .syntax unified /* .thumbfunc */ / * .thumbfunc仅仅在2006Q3 26之前的CodeSourcery工具中需要*/ _start: \t.word STACK_TOP, start \t.type start, function \t/* 主程序入口点 */ start: \tmovs r0, #10 \tmovs r1, #0 \t/* 计算 10+9+8...+1 */ loop: \tadds r1, r0 \tsubs r0, #1 \tbne loop \t/* Result is now in R1 */ deadloop: \tb deadloop \t.end ``` + .word指示字定义MSP起始值为0x2000_0800，并且把”start”作为复位向量。 + .text也是一个预定义的指示字，表示从这以后是一个代码区，需要予以汇编。 + .global使\\_start标号可以由其它目标文件使用。 + \\_.code 16指示程序代码使用thumb写成。 + .syntax unified指示使用了统一汇编语言语法。 + _start是一个标号，指示出程序区的入口点 + start是另一个标号，它指示复位向量。 + .type start, function宣告了start是一个函数。对于所有处于向量表中的异常向量，这种宣告都是必要的，否则汇编器会把向量的LSB清零——这在thumb中是不允许的。 + .end指示程序文件的结束。 ```bash $> arm none eabi as mcpu cortex m3 mthumb example1.s o example1.o # 命令行中的 mcpu和 mthumb决定使用的指令集。 $> arm none eabi ld Ttext 0x0 o example1.out example1.o $> arm none eabi objcopy Obinary example1.out example1.bin # 目标拷贝命令（objcopy）来产生二进制文件 $> arm none eabi objdump S example1.out > example1.list #使用目标倾倒(dump)命令（objdump）来创建一个反汇编代码来检查生成的目标文件 ``` ```assembly hello: \t.ascii \"Hello\\n\" \t.byte 0 \t.align ``` > 定义一个字符串(只读变量), .align表示这一个字符串之后的代码进行对齐 ```assembly \tldr r0, result \tstr r1, [r /* 数据区 */ \t.data result: \t.word 0 \t.end ``` > 这是定义的可读可写变量, .data指示字。使用它创建一个数据区。在该区中，使用一个.word指示字来保留一个4字节的空间，并且取名为Result > > 欲连接本程序，需要告诉连接器RAM在何处，这可以使用 Tdata选项来实现 ```bash $> arm none eabi as mcpu_cortex m3 mthumb example4.s o example4.o $> arm none eabi ld Ttext 0x0 Tdata 0x20000000 o example4.outexample4.o $> arm none eabi objcopy Obinary –R .dataexample4.out example4.bin $> arm none eabi objdump S example4.out > example4.list ``` > 在objcopy中对 R .data选项的使用。它避免在二进制输出文件中把数据存储区也包含进去。 ## C语言 ### 自己写启动代码 ```c #define STACK_TOP 0x20000800 #define NVIC_CCR ((volatile unsigned long *)(0xE000ED14)) // 声明函数原型 void myputs(char *string1); void myputc(char mychar); int main(void);void nmi_handler(void); void hardfault_handler(void); // 定义向量表 __attribute__ (( section(“vectors”) )) void (* const VectorArray[])(void) { STACK_TOP, main, nmi_handler, hardfault_handler }; // 主程序入口点 int main(void) { const char *helloworld[] \"Hello world\\n\"; *NVIC_CCR *NVIC_CCR 0x200; /* 设置NVIC的STKALIGN */ myputs(*helloworld); while(1); return(0); } // 函数 void myputs(char *string1) { char mychar; int j; j 0; do { mychar string1[j]; if (mychar! 0) { myputc(mychar); j++; } } while (mychar ! 0); return; } void myputc(char mychar) { #define UART0_DATA ((volatile unsigned long *)(0x4000C000)) #define UART0_FLAG ((volatile unsigned long *)(0x4000C018)) // Wait until busy fl ag is clear while ((*UART0_FLAG & 0x20) ! 0); // Output character to UART *UART0_DATA mychar; return; } //空的服务例程 void nmi_handler(void) { return; } void hardfault_handler(void) { return; } ``` 它使用__attribute(( ))（注意，是双小括号）来指定特殊的属性。在这里则指出那个函数指针数组是放到vectors段中的。 ```ld /* MEMORY命令：定义允许的存储器区域 */ /* 本部分定义了连接器允许放入数据的各存储器区域，这是 */ /* 一个可选的功能，但是对于开发很有益，它使连接器在在 */ /* 程序太大时能给你警告 */ MEMORY { \t/* ROM是可读的(r)和可执行的(x) */ rom (rx) : ORIGIN 0, LENGTH 2M /* RAM是可读的(r)，可写的(w)，可执行的(x) */ ram (rwx) : ORIGIN 0x20000000, LENGTH 4M } /* SECTIONS 命令 : 定义各输入段到输出段的映射 */ SECTIONS{ \t. 0x0; /* 从0x00000000开始*/ .text : { \t*(vectors) /* 向量表 */ *(.text) /* 程序代码 */ *(.rodata) /* 只读数据 */ } . 0x20000000; /* 从0x20000000开始*/ .data : { \t*(.data) /* 数据存储器 */ } .bss : { \t*(.bss) /* 预留的数据存储器，必须初始化为零 */ \t} } ``` ```bash arm none eabi gcc mcpu_cortex m3 mthumb example5.c nostartfiles T simple.ld o example5.o ``` > 在编译阶段把simple.ld传给编译器 ```bash $> arm none eabi ld T simple.ld o example5.out example5.o ``` > 在连接时，需要再次使用simple.ld。 ```bash $> arm none eabi objcopy Obinary example5.out example5.bin $> arm none eabi objdump S example5.out > example5.list ``` > 使用了另一个称为 nostartfiles的编译器开关。使用它，就可以让编译器不再往可执行映像中插入启动代码(crt)，这样做的目的之一就是减少程序映像的尺寸。不过，使用该选项的主要原因，其实是在于GNU工具链的启动代码是与发布包的提供者相关的，而有些人提供的启动代码不适合CM3 ### 使用自带的启动代码 标准C运行时库的启动代码由GNU工具链提供，但是不同提供者提供的工具链可能有不同的启动代码。下例是基于CodeSourcery GNU ARM工具链2006q3 26版本的。因此，最好检查一下从工具链中的启动代码，或者从供应者处获取最新的启动代码。对于这个版本的CodeSourcery提供的工具链，其启动代码目标文件为armv7m crt0.o。但是这个版本提供的启动代码是错误的——使用了ARM代码来编写。到了2006q3 27及更晚的版本中才修正了这个bug。 CodeSourcery提供的工具链，其启动代码目标文件为armv7m crt0.o。但是这个版本提供的启动代码是错误的——使用了ARM代码来编写。到了2006q3 27及更晚的版本中才修正了这个bug。不同提供者的GNU工具链会有不同的启动代码，而且文件名也常常不同。此时，就需要检查你所使用的GNU工具链之帮助文档来获取准确信息了 缺省情况下，armv7m crt0已经包含了一张向量表，并且在它里面，NMI服务例程和硬fault服务例程分别取名为\\_nmi\\_isr和\\_fault\\_isr。 安装了CodeSourcery后，已经包含了一系列的连接脚本，可以从codesourcery/sourceryg++/arm none eabi/lib目录下找到。在下例中，我们就使用了lm3s8xx rom.ld文件。 所需的目标文件armvrm crt0.o以及连接器脚本都被拷贝到这个“lib”目录下 ```bash $> arm none eabi gcc –mcpu cortex m3 mthumb example6.c L lib–T lm3s8xx rom.ld o example6.out ``` #### 访问特殊的寄存器 可以直接使用小写的名字来访问特殊功能寄存器, 必须是小写 ```assembly msr control, r1 mrs r1, control msr apsr, r1 mrs r0, ``` #### 支持未使用的指令 使用.word来插入不支持指令的二进制机器码 ```assembly .equ DW_MSR_CONTROL_R0, 0x8814F380 ... MOV R0, #0x1 .word DW_MSR_CONTROL_R0 /* 相当于执行 MSR CONTROL, R0指令 */ ... ``` #### 内敛汇编 [GCC Inline Assembly HOWTO (ibiblio.org)](https://www.ibiblio.org/gferg/ldp/GCC Inline Assembly HOWTO.html) ```assembly __asm (\" inst1 op1, op2... \\n\" \" inst2 op1, op2... \\n\" ... \" inst op1, op2... \\n\" : 输出操作数s /* 可选 */ : 输入操作数s /* 可选 */ ``` 如果汇编代码需要一个输入变量和一个输出变量，例如，把一个变量除以5 ```c _asm ( \"mov r0, %0\\n\" \"mov r3, #5\\n\" \"udiv r0, r0, r3\\n\" \"mov %1, r0\\n\" : \" r\" (DataOut) : \"r\" (DataIn) : \"cc\", \"r3\" ); ``` 在这个代码中，输输入参数是一个C变量，名为DataIn（%0代表第一个参数），该代码把结果返回到另外一个C变量DataOut中（%1表示第2个参数）。内联汇编的代码还手工修改了寄存器r3，并且修改了条件标志cc，因此它们被列在被破坏的（clobbered）寄存器列表中"},"/note/嵌入式/基础知识/Cotex-M3权威指南/2024-1-16-01概览.html":{"title":"概览","content":" layout: post title: \"概览\" date: 2024 1 16 15:39:08 +0800 tags: Cotex M3 # 概览 ![image 20240116162640097](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401161626141.png) ## 寄存器 拥有R0 R15, R13为SP指针(两个) ![image 20240116162740180](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401161627215.png) + R0 R12通用寄存器 + R13:两个堆栈指针, 任一时刻只能使用一个, 主堆栈指针用于操作系统以及异常处理, 这个指针最低两位永远是0(4字节对齐) + R14: 储存返回地址(减少访问内存, 加速) + R15: 程序计数器 ![image 20240116163214802](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401161632839.png) ![image 20240116163257738](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401161632771.png) ## 特权模式 在CM3运行主应用程序时（线程模式），既可以使用特权级，也可以使用用户级；但是异常服务例程必须在特权级下执行。 用户级的程序不能简简单单地试图改写CONTROL寄存器就回到特权级，它必须先“申诉”：执行一条系统调用指令(SVC)。这会触发SVC异常，然后由异常服务例程（通常是操作系统的一部分）接管，如果批准了进入，则异常服务例程修改CONTROL寄存器，才能在用户级的线程模式下重新进入特权级。 ![image 20240116163635677](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401161636707.png) ## 优先级嵌套 在状态寄存器里面保存有当前的中断优先级, 当有优先级更高的中断来的时候会直接进行跳转 使用中断向量表进行跳转 中断调整自己的优先级不会使自己被重入 ## 存储器 ![image 20240116164735968](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401161647015.png) ![image 20240116165126115](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401161651218.png) ## 总线 有若干个总线接口, 用于加速 指令存储区总线(两个), 系统总线, 私有外设总线 > 代码存储区总线负责对代码存储区的访问，分别是I Code总线和D Code总线。前者用于取指，后者用于查表等操作 > > 系统总线用于访问内存和外设，覆盖的区域包括SRAM，片上外设，片外RAM，片外扩展设备，以及系统级存储区的部分空间 > > 私有外设总线负责一部分私有外设的访问，主要就是访问调试组件。它们也在系统级存储区 ## 存储器保护单元MCU 对特权级访问和用户级访问分别施加不同的访问限制。当检测到犯规（violated）时，MPU就会产生一个fault异常，可以由fa ult异常的服务例程来分析该错误 ## 指令集 Thumb 2指令集 32位和16位指令共存 ## 中断和异常 支持16 4 1 11种系统异常（保留了4+1个档位），外加240个外部中断输入。 虽然CM3是支持240个外中断的，但具体使用了多少个是由芯片生产商决定。CM3还有一个NMI（不可屏蔽中断）输入脚。当它被置为有效（assert）时，NMI服务例程会无条件地执行。 ## 调试 在内核水平上搭载了若干种调试相关的特性。最主要的就是程序执行控制，包括停机(halting)、单步执行(stepping)、指令断点、数据观察点、寄存器和存储器访问、性能速写（profiling）以及各种跟踪机制 本身不再含有JTAG接口。取而代之的，是CPU提供称为 “调试访问接口(DAP)”的总线接口 是由一个调试端口(DP)设备完成的。DPs不属于CM3内核，但它们是在芯片的内部实现的。 目前可用的DPs包括SWJ DP(既支持传统的JTAG调试，也支持新的串行线调试协议)，另一个SW DP则去掉了对JTAG的支持。另外，也可以使用ARM CoreSignt产品家族的JTAG DP模块。这下就有3个DPs可以选了，芯片制造商可以从中选择一个，以提供具体的调试接口（通常都是选SWJ DP）。"},"/note/嵌入式/基础知识/Cotex-M3权威指南/2024-1-17-08中断的具体行为.html":{"title":"中断的具体行为","content":" layout: post title: \"中断的具体行为\" date: 2024 1 17 15:39:08 +0800 tags: Cotex M3 # 中断的具体行为 + 入栈：把8个寄存器的值压入栈 + 取向量：从向量表中找出对应的服务程序入口地址 + 选择堆栈指针MSP/PSP，更新堆栈指针SP，更新连接寄存器LR，更新程序计数器PC ## 入栈 自动保存现场的必要部分：依次把xPSR, PC, LR, R12以及R3 R0由硬件自动压入适当的堆栈中 如果当响应异常时，当前的代码正在使用PSP，则压入PSP，也就是使用进程堆栈；否则就压入MSP，使用主堆栈。一旦进入了服务例程，就将一直使用主堆栈。 ![image 20240117212158170](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401172121203.png) ![image 20240117212241495](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401172122523.png) ![image 20240117212951143](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401172129204.png) 先把PC与xPSR的值保存，就可以更早地启动服务例程指令的预取——因为这需要修改PC；同时，也做到了在早期就可以更新xPSR中IPSR位段的值 优先入栈这几个寄存器的原因是使得中断控制函数可以使用C语言进行编写, 编译器优先使用入栈了的寄存器来保存中间结果当然，如果程序过大也可能要用到R4 R11，此时编译器负责生成代码来push它们。 ## 取向量 数据总线在忙的时候指令总线会获取到程序的入口 ## 更新寄存器 + SP：在入栈 后会把堆栈指针（PSP或MSP）更新 到新的位置。在执行服务例程时，将由MSP负责对堆栈的访问。 + PSR：更新IPSR位段（地处PSR的最低部分）的值为新响应的异常编号。 + PC：在取向量完成后，PC将指向服务例程的入口地址， + LR：在出入ISR的时候，LR的值将得到重新的诠释，这种特殊的值称为“EXC_RETURN”，在异常进入时由系统计算并赋给LR，并在异常返回时使用它。EXC_RETURN的二进制值除了最低4位外全为1，而其最低4位则有另外的含义（后面讲到，见表9.3和表9.4）。 ## 异常返回 ![image 20240117213747958](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401172137995.png) 在CM3中，是通过把EXC_RETURN往PC里写来识别返回动作的。 1. 出栈：先前压入栈中的寄存器在这里恢复。内部的出栈顺序与入栈时的相对应，堆栈指针的值也改回先前的值。 2. 更新NVIC寄存器：伴随着异常的返回，它的活动位也被硬件清除。对于外部中断，倘若中断输入再次被置为有效，悬起位也将再次置位，新一次的中断响应序列也可随之再次开始。 > 以上的行为是自动的 ## 中断的嵌套 NVIC和CM3处理器会根据优先级的设置来控制抢占与嵌套行为。因此，在某个异常正在响应时，所有优先级不高于它的异常都不能抢占之，而且它自己也不能抢占自己。 有了自动入栈和出栈，就不用担心在中断发生嵌套时，会使寄存器的数据损毁，从而可以放心地执行服务例程。 有一件事情却必须更加一丝不苟地处理了，否则有功能紊乱甚至死机的危险。这就是计算主堆栈容量的最小安全值。 相同的异常是不允许重入的。因为每个异常都有自己的优先级，并且在异常处理期间，同级或低优先级的异常是要阻塞的。因此对于同一个异常，只有在上次实例的服务例程执行完毕后，方可继续响应新的请求。由此可知，在SVC服务例程中，就不得再使用SVC指令，否则将fault伺候。 ## 咬尾中断 当处理器在响应某异常时，如果又发生其它异常，但它们优先级不够高，则被阻塞 在中断退出又进入的过程中, 不需要在进行一次出站入栈的过程 ![image 20240117215424935](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401172154985.png) ## 晚到（的高优先级）异常 如果是在低优先级中断入栈的时候产生的高优先级中断, 会在入栈结束之后进入高优先级的处理函数, 之后使用咬尾中断处理 ## 异常返回值 在进入异常处理函数的时候, LR寄存器保存的值是EXC_RETURN 高28位全为1的值，只有[3:0]的值有特殊含义 ![image 20240118121857774](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401181218925.png) ![image 20240118121915548](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401181219577.png) > 进入之前的LR会被自动入栈 ![image 20240118122032765](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401181220815.png) EXC_RETURN的格式可见，我们不能把0xFFFF_FFF0 0xFFFF_FFFF中的地址作为任何返回地址。其实也并不用担心会弄错，因为CM3已经把这个范围标记成“取指不可区” ## 中断延迟 中断延迟的定义是：从检测到某中断请求，到执行了其服务例程的第一条指令时，已经流逝了的时间。 在CM3中，若存储器系统够快，且总线系统允许入栈与取指同时进行，同时该中断可以立即响应，则中断延迟是雷打不动的12周期（满足硬实时所要求的确定性）。 进行了入栈、取向量、更新寄存器以及服务例程取指的一系列操作。 处理咬尾中断时，省去了堆栈操作，因此切入新异常服务例程的耗时可以短至6周期。 ## 异常响应期间的Fault ### 入栈期间 入栈期间引起了总线fault，则本次入栈操作将被强行中止，并且把总线异常悬起或者在允许时立即响应。若除能了总线fault，则此次故障将成为“硬伤”——上访至硬fault。在总线fault被使能的情况下，如果它的优先级比正在响应的异常高，则抢占之，否则将悬起直到引起fault的异常执行完毕。 入栈操作引起MPU访问违例，则产生存储管理fault，并且必须能立即执行MemFault服务例程，否则将无条件上访成硬fault。 ### 出栈期间 中断返回时的出栈期间引起了总线fault，则本次出栈操作将被强行中止，并且把总线异常悬起或立即响应。若除能了总线fault，则此次故障将成为“硬伤”——上访至硬fault。其它情况下，只要总线fault的优先级比当前的高（也包括比当前最深嵌套的优先级高），则可以立即响应。这种情况称为“出栈错误” ### 取向量期间 直接上硬fault, MPU的限制则管不着取向量操作 ### 无效返回 LR中的EXC_RETURN不是合法的值（合法值见表9.4，包括企图返回ARM状态），则引起用法fault。如果用法fault被除能，也上访成硬fault。"},"/note/嵌入式/基础知识/Cotex-M3权威指南/2024-1-17-06异常.html":{"title":"异常","content":" layout: post title: \"异常\" date: 2024 1 16 15:39:08 +0800 tags: Cotex M3 # 异常 编号为1－15的对应系统异常，大于等于16的则全是外部中断。除了个别异常的优先级被定死外，其它异常的优先级都是可编程的。 所有能打断正常执行流的事件都称为异常。 ![image 20240117164219976](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171642018.png) ![image 20240117164230620](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171642650.png) 在NVIC的中断控制及状态寄存器中，有一个VECTACTIVE位段；另外，还有一个特殊功能寄存器IPSR。在它们二者的里面，都记录了当前正服务的异常，给出了它的编号。 如果一个发生的异常不能被即刻响应，就称它被“悬起”(pending)。CM3则由NVIC的悬起状态寄存器来解决这个问题。于是，哪怕设备在后来已经释放了请求信号，曾经的中断请求也不会错失。 ## 优先级定义 优先级的数值越小，则优先级越高。CM3支持中断嵌套，使得高优先级异常会抢占(preempt)低优先级异常 原则上，CM3支持3个固定的高优先级和多达256级的可编程优先级，并且支持128级抢 占（128的来历请见下文分解——译注）。但是，绝大多数CM3芯片都会精简设计，以致实际上支持的优先级数会更少，如8级，16级，32级等。 ![image 20240117164725195](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171647217.png) + 使用MSB的原因 通过让优先级以MSB对齐，可以简化程序的跨器件移植。比如，如果一个程序早先在支持4位优先级的器件上运行，在移植到只支持3位优先级的器件后，其功能不受影响。但若是对齐到LSB，则会使MSB丢失，导致数值大于7的低优先级一下子升高了，甚至会发生“优先级反转”：使它高于小于等于7的优先级。如，8号优先级因为损失了MSB，现在反而变成0号了；而15号优先级则变成7号优先级，它则不会影响0 6号优先级，使得这个问题更隐蔽。 ## 子优先级和抢占优先级 MSB所在的位段（左边的）对应抢占优先级，而LSB所在的位段（右边的）对应子优先级 NVIC中有一个寄存器是“应用程序中断及复位控制寄存器” 0xE000_ED0C ![image 20240117165110755](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171651794.png) ![image 20240117170030444](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171700473.png) ![image 20240117165137025](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171651056.png) 子优先级至少是1个位。因此抢占优先级最多是7个位，这就造成了最多只有128级抢占的现象 CM3允许从比特7处分组，此时所有的位都表达子优先级，没有任何位表达抢占优先级，因而所有优先级可编程的异常之间就不会发生抢占——相当于在它们之中除能了CM3的中断嵌套机制。当然还有凌驾于法律之上的三位老大：复位，NMI和硬fault。它们无论何时出现，都立即无条件抢占所有优先级可编程的“平民异常”。 虽然[4:0]未使用，却允许从它们中分组。例如，如果优先级组为1，则所有可用的8个优先级都是抢占优先级 ### 向量表 CM3需要定位其服务例程的入口地址。这些入口地址存储在所谓的“（异常）向量表”中。缺省情况下，CM3认为该表位于零地址处，且各向量占用4字节。 NVIC中有一个寄存器，称为“向量表偏移量寄存器”（在地址0xE000_ED08处），通过修改它的值就能重定位向量表。 向量表的起始地址是有要求的：必须先求出系统中共有多少个向量，再把这个数字向上“圆整”到2的整次幂，而起始地址必须对齐到后者的边界上。 ## 中断悬起 ![image 20240117171931155](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171719181.png) > 当中断输入脚被置为有效（asser）t后，该中断就被悬起。即使后来中断源撤消了中断请求，已经被标记成悬起的中断也被记录下来。到了系统中它的优先级最高的时候，就会得到响应。 但是，如果在某个中断得到响应之前，其悬起状态被清除了（例如，在PRIMASK或FAULTMASK置位的时候软件清除了悬起状态标志），则中断被取消 ![image 20240117172104460](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171721488.png) 在一个中断活跃后，直到其服务例程执行完毕，并且返回（亦称为中断退出）后，才能对该中断的新请求予以响应（单实例）。 新请求在得到响应时，亦是由硬件自动清零其悬起标志位。 ![image 20240117172332981](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171723018.png) ![image 20240117172358558](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171723597.png) ![image 20240117172436715](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171724751.png) ![image 20240117172502709](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171725749.png) ## Fault类型的异常 + 总线Fault + 存储器Fault + 用法Fault + 硬Fault ### 总线Fault AHB接口传输数据的时候如果回复了一个错误信号, 会产生一个Fault ![image 20240117172946576](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171729608.png) ![image 20240117173019568](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171730606.png) 欲使能总线fault服务例程，需要在NVIC的“系统Handler控制及状态寄存器”中置位BUSFAULTENA位。要注意的是：在使能之前，总线fault服务例程的入口地址必须已经在向量表中配置好，否则就成了作法自毙——程序可能跑飞。 如果总线fault被除能，或者总线fault是被某同级或更高优先级异常的服务例程引发的，则总线fault被迫成为“硬伤”——上访成硬fault，使得最后执行的是硬fault的服务例程 对于精确的总线fault（见下框说明），肇事指令的地址被压在堆栈中。如果BFSR中的BFARVALID位为1，还可以找出是在访问哪块存储器时产生该总线fault的——该存储器的地址被放到“总线fault地址寄存器（BFAR）”中 > 在不精确的总线faults中，导致此fault的指令早已完成了。例如，缓冲区写入。启动缓冲区写入的指令不知何时已经执行了，但是写到中途时触发了总线fault。此时，肇事指令早已“逃逸”——在若干个时钟周期就执行过了，而且不能确定是具体几个周期之前，CM3也不会记录这期间的程序跳转动作。因此无法确认“肇事者”，故而该fault是不精确的。精确的总线fault则不同，它是被最后一个完成的操作触发的。例如，一个存储器读取导致的fault总是精确的，因为该指令必须等全部读完时才算执行完成。这样，任何在读取过程中发生的fault总能落在该指令的头上。 BFSR寄存器的程序员模型如下所示：它是一个8位的寄存器，并且可以使用字传送和字节传送来读取它。如果以字方式访问，地址是0xE000_ED28，并且第2个字节有效；如果以字节方式访问，则地址直接就是0xE000_ED29， ![image 20240117173831147](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171738183.png) ### 存储器管理Fault 其诱因常常是某次访问触犯了MPU设置的保护规范。在不可执行的存储器区域试图取指，也会触发一个MemManage fault ![image 20240117173919150](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171739175.png) 如果MemMange fault是被同级或高优先级异常的服务例程引发的，或者MemManage fault被除能，则和总线fault一样：上访成硬fault，最终执行的是硬fault的服务例程 如果硬fault服务例程或NMI服务例程的执行也导致了MemManage fault，那就不可救要了——内核将被锁定。 在NVIC“系统handler控制及状态寄存器”中的使能位是MEMFAULTENA ![image 20240117174132803](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171741837.png) ### 用法Fault ![image 20240117174234128](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171742164.png) ![image 20240117174527364](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171745398.png) > 如果需要严格要求程序的质量，还可以让CM3在遇到除数为零的时候，以及遇到未对齐访问的时候也产生用法fault。在NVIC中有两个控制位分别与它们对应。通过设置这两个控制位，就可以激活它们。 没有使能的时候会导致结果和上面一样 在NVIC“系统handler控制及状态寄存器”中的使能位是USGFAULTENA。 NVIC中有一个“用法fault状态寄存器（UFSR） ![image 20240117174545365](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171745409.png) ### 硬Fault 是上文讨论的总线fault、存储器管理fault以及用法fault上访的结果 另外，在取向量（异常处理时对异常向量表的读取）时产生的总线fault也按硬fault处理。 fault状态寄存器（HFSR），它指出产生硬fault的原因。 ![image 20240117175328205](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171753243.png) ### 应对Fault 复位。这也是最后一招。通过设置NVIC“应用程序中断及复位控制寄存器”中的VECTRESET位，将只复位处理器内核而不复位其它片上设施。取决于芯片的复位设计，有些CM3芯片可以使用该寄存器的SYSRESETREQ位来复位。这种只限于内核中的复位不会殃及其它的系统部件。 恢复：在一些场合下，还是有希望解决产生fault的问题的。例如，如果程序尝试访问了协处理器，可以通过一个协处理器的软件模拟器来解决此问题——当然是以牺牲性能为代价的，要不然还要硬件加速干啥。 中止相关任务：如果系统运行了一个RTOS，则相关的任务可以被终结或者重新开始。 各个fault状态寄存器(FSRs)都保持住它们的状态，直到手工清除。Fault服务例程在处理了相应的fault后不要忘记清除这些状态，否则如果下次又有新的fault发生，服务例程在检视fault源时，又将看到早先已经处理的fault遗留下来的状态标志。此时，将无法判断哪个fault是新发生的。FSRs采用一个写时清除机制（写1时清除）。芯片厂商也可以再添加自己的FSR，以表示其它fault情况。 ## SVC和PendSV SVC: 系统服务中断 PendSV: 可悬起系统调用 ### SVC函数 SVC用于产生系统函数的调用请求。例如，操作系统通常不让用户程序直接访问硬件，而是通过提供一些系统服务函数，让用户程序使用SVC发出对系统服务函数的呼叫请求，以这种方法调用它们来间接访问硬件。 > 使用户程序从控制硬件的繁文缛节中解脱出来，而是由OS负责控制具体的硬件 > > OS的代码可以经过充分的测试，从而能使系统更加健壮和可靠 > > 它使用户程序无需在特权级下执行，用户程序无需承担因误操作而瘫痪整个系统的风险 > > 通过SVC的机制，还让用户程序变得与硬件无关，因此在开发应用程序时无需了解硬件的操作细节，从而简化了开发的难度和繁琐度，并且使应用程序跨硬件平台移植成为可能 SVC异常通过执行”SVC ”指令来产生。该指令需要一个立即数，充当系统调用代号。SVC异常服务例程稍后会提取出此代号，从而获知本次调用的具体要求，再调用相应的服务函数 ```assembly SVC 0x3 ; 调用3号系统服务 ``` 上次执行的SVC指令地址可以根据自动入栈的返回地址计算出。找到了SVC指令后，就可以读取该SVC指令的机器码，从机器码中萃取出立即数，就获知了请求执行的功能代号。 如果用户程序使用的是PSP，服务例程还需要先执行MRS Rn, PSP指令来获取应用程序的堆栈指针。通过分析LR的值，可以获知在SVC指令执行时，正在使用哪个堆栈 ![image 20240117182058286](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171820325.png) 我们不能在SVC服务例程中嵌套使用SVC指令, 这种作法会产生一个用法fault。同理，在NMI服务例程中也不得使用SVC，否则将触发硬fault。 对于SVC异常来说，若因优先级不比当前正处理的高，或是其它原因使之无法立即响应，将上访成硬fault ![image 20240117183411519](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171834554.png) ### PendSV函数 PendSV则不同，它是可以像普通的中断一样被悬起的（不像SVC那样会上访）。 OS可以利用它“缓期执行”一个异常——直到其它重要的任务完成后才执行动作。悬起PendSV 的方法是：手工往NVIC的PendSV悬起寄存器中写1。悬起后，如果优先级不够高，则将缓期等待执行。 如果OS在某中断活跃时尝试切入线程模式，将触犯用法fault异常。 ![image 20240117183919986](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171839028.png) 期的OS大多会检测当前是否有中断在活跃中，只有在无任何中断需要响应时，才执行上下文切换（切换期间无法响应中断）。然而，这种方法的弊端在于，它可以把任务切换动作拖延很久（因为如果抢占了IRQ，则本次SysTick在执行后不得作上下文切换，只能等待下一次SysTick异常），尤其是当某中断源的频率和SysTick异常的频率比较接近时，会发生“共振”，使上下文切换迟迟不能进行 PendSV异常会自动延迟上下文切换的请求，直到其它的ISR都完成了处理后才放行。为实现这个机制，需要把PendSV编程为最低优先级的异常。 ![image 20240117184147611](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171841657.png)"},"/note/嵌入式/基础知识/Cotex-M3权威指南/2024-1-17-05全景概况.html":{"title":"全景概况","content":" layout: post title: \"全景概况\" date: 2024 1 16 15:39:08 +0800 tags: Cotex M3 # 全景概况 ## 流水线 三级指的是取址, 解码, 执行 ![image 20240117160704552](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171607584.png) 当执行到跳转指令时，需要清洗流水线，处理器会不得不从跳转目的地重新取指 由于流水线的存在，以及出于对Thumb代码兼容的考虑，读取PC时，会返回当前指令地址+4的值。这个偏移量总是4，不管是执行16位指令还是32位指令 在处理器内核的预取单元中也有一个指令缓冲区，它允许后续的指令在执行前先在里面排队，也能在执行未对齐的32位指令时，避免流水线“断流” ## 框图 ![image 20240117161218683](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171612738.png) ![image 20240117161410458](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171614504.png) ![image 20240117161422846](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171614869.png) ## 总线接口 ### I Code I Code总线是一条基于AHB Lite总线协议的32位总线，负责在0x0000_0000 – 0x1FFF_FFFF之间的取指操作。取指以字的长度执行，即使是对于16位指令也如此。因此CPU内核可以一次取出两条16位Thumb指令。 ### D Code 负责在0x0000_0000 – 0x1FFF_FFFF之间的数据访问操作。尽管CM3支持非对齐访问，但你绝不会在该总线上看到任何非对齐的地址，这是因为处理器的总线接口会把非对齐的数据传送都转换成对齐的数据传送。因此，连接到D Code总线上的任何设备都只需支持AHB Lite的对齐访问，不需要支持非对齐访问。 ### 系统总线 负责在0x2000_0000 – 0xDFFF_FFFF和0xE010_0000 – 0xFFFF_FFFF之间的所有数据传送，取指和数据访问都算上。和D Code总线一样，所有的数据传送都是对齐的。 ### 外部私有外设 基于APB总线协议的32位总线。此总线来负责0xE004_0000 – 0xE00F_FFFF之间的私有外设访问。但是，由于此APB存储空间的一部分已经被TPIU、ETM以及ROM表用掉了，就只留下了0xE004_2000 E00F_F000这个区间用于配接附加的（私有）外设。 ### 调试访问总线 它专用于挂接调试接口，例如SWJ DP和SW DP ### 连接方式 ![image 20240117162748625](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171627676.png) ## 复位信号 ![image 20240117163903999](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171639036.png) ![image 20240117163943914](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171639948.png)"},"/note/嵌入式/基础知识/Cotex-M3权威指南/2024-1-18-12其它特性.html":{"title":"其它特性","content":" layout: post title: \"其它特性\" date: 2024 1 18 15:39:08 +0800 tags: Cotex M3 # 其它特性 ## Systick定时器 SysTick是一个24位的倒计数定时器，当计到0时，将从RELOAD寄存器中自动重装载定时初值。只要不把它在SysTick控制及状态寄存器中的使能位清除，就永不停息 ![image 20240118180555518](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401181805557.png) CM3允许为SysTick提供两个时钟源以供选择 第一个是内核的“自由运行时钟”FCLK。“自由”表现在它不来自系统时钟HCLK，因此在系统时钟停止时FCLK也继续运行。第二个是一个外部的参考时钟。但是使用外部时钟时，因为它在内部是通过FCLK来采样的，因此其周期必须至少是FCLK的两倍（采样定理）。 通过检查校准寄存器的位31，可以判定是否有可用的外部时钟源 ![image 20240118181005216](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401181810238.png) 当SysTick定时器从1计到0时，它将把COUNTFLAG位置位；清零方式 + 读取SysTick控制及状态寄存器（STCSR） + 往SysTick当前值寄存器（STCVR）中写任何数据 如欲使能SysTick异常，则把STCSR.TICKINT置位。另外，如果把向量表重定位到了SRAM中，还需要为SysTick异常建立向量 ```assembly ; 建立SysTick异常服务例程 \tMOV R0, #0xF ; 异常号：15 \tLDR R1, systick_handler ; 加载服务例程的入口地址 \tLDR R2, 0xE000ED08 ; 加载向量表偏移量寄存器的地址 \tLDR R2, [R2] ; 读取向量表的首地址 \tSTR R1, [R2, R0, LSL #2] ; 写入向量 下面的代码演示启用SysTick的基本程序 ; 使能SysTick定时器，并且使能SysTick异常 \tLDR R0, 0xE000E010 ; 加载STCSR的地址 \tMOV R1, #0 \tSTR R1, [R0] ; 先停止SysTick，以防意外产生异常请求 \tLDR R1, 0x3FF ; 让SysTick每1024周期计完一次。因为是从1023数到 \t\t\t\t\t\t\t\t ; 0，总共数了1024个周期，所以加载值为0x3FF STR R1, [R0,#4] ; 写入重装载的值 STR R1, [R0,#8] ; 往STCVR中写任意的数，以确保清除COUNTFLAG标志 MOV R1, #0x7 ; 选择FCLK作为时钟源，并使能SysTick及其异常请求 STR R1, [R0] ; 写入数值，开启定时器 ``` SysTick定时器还提供了走完10ms所需要的格数(TENMS位段)，作为时间校准的参考信息。在CM3处理器的顶层有一个24位的输入，芯片厂商可以写入一个10ms的加载值，写程序时就可以读取STCR寄存器中的TENMS位段来获取此信息 > STM32实现的是1ms的值 ![image 20240118181736332](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401181817366.png) ## 电源管理 在睡眠时，可以停止系统时钟，但可以让FCLK继续走，以允许处理器能被SysTick异常唤醒。 + 睡眠：由CM3处理器的SLEEPING信号指示 + 深度睡眠：由CM3处理器的SLEEPDEEP信号指示 0xE000_ED10 ![image 20240118183937672](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401181839724.png) 通过执行WFI/WFE指令，请求CM3进入睡眠模式，它们在CM3中的地位就类似于某些处理器的” sleep/slp”指令。WFI表示Wait For Interrupt，而WFE表示Wait For Event。那么什么可以算是event呢？新来的中断、早先被悬起的中断，或者是通过RXEV信号表示的一个外部事件信号脉冲，都属于event。在处理内部，对事件有一个锁存器，因此过去发生的事件可以用来唤醒将来才执行到的WFE。 ![image 20240118184126106](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401181841141.png) 当从WFI唤醒时，要根据异常系统的游戏规则来决定是否唤醒。只有当该中断的优先级比当前优先级要高（如果是在服务例程中使用WFI），并且比BASEPRI掩蔽的高时，才唤醒处理器并执行ISR。但如果PRIMASK置位，则依然唤醒处理器，然而ISR却不执行了。 WFE则有点区别，不管优先级和掩蔽情况如何，只要SETONPEND置位，它就会不错过任何一个事件，在发生事件时一定把处理器唤醒。至于是否执行ISR，则与WFI的规则相同。 ![image 20240118184522978](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401181845007.png) ![image 20240118184757210](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401181847267.png) > PRTMASK是总的中断开关, SEVONPEND设置为1的时候任意事件都会唤醒 > > 1. 只有PRIMASK 0时，才执行ISR > 2. 对于WFE，只要SEVONPEND 1，则不管何时发生了什么中断，都一定会唤醒处理器 > 3. 不管PRIMASK为何值，只要优先级高到BASEPRI不能掩蔽，就将唤醒处理器 > 4. 当PRIMASK 0时，它不会对唤醒产生影响 ### 自动睡眠 从中断服务例程返回后立即睡眠。 需要把系统控制寄存器中的SLEEPONEXIT位置位。 ![image 20240118185158663](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401181851698.png) ## 多处理机通信 CM3竟然还支持简单的多核功能 处理机有一个名为TXEV（Transmit Event）的输出信号，用于发送信号给其它处理机；还有一个名为RXEV（Receive Event）的输入信号 ![image 20240118185317944](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401181853970.png) 如上一小节所述，当处理机因为WFE而睡眠时，可以由外部事件——即RXEV唤醒。CM3提供了SEV指令（Send EVent）。当执行该指令时，当事处理机就会在TXEV上发送一个脉冲，从而可以唤醒另外的睡眠中的处理机，从而实现同步 ![image 20240118185357420](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401181853464.png) ## 自复位控制 CM3允许由软件触发复位序列，用于特殊的调试或维护目的 第一种方法，是通过置位NVIC中应用程序中断与复位控制寄存器(AIRCR)的VECTRESET位（位偏移：0） 这种复位的作用范围覆盖了整个CM3处理器中，除了调试逻辑之外的所有角落，但是它不会影响到CM3处理器外部的任何电路，所以单片机上的各片上外设和其它电路都不受影响。 > STM32不可用, 只用于Debug 复位的第二种方法，是置位同一个寄存器中的SYSRESETREQ位。这种复位则会波及整个芯片上的电路：它会使CM3处理器把送往系统复位发生器的请求线置为有效。但是系统复位发生器不是CM3的一部分，而是由芯片厂商实现，因此不同的芯片对此复位的响应也不同。"},"/note/嵌入式/基础知识/Cotex-M3权威指南/2024-1-18-11系统行为.html":{"title":"系统行为","content":" layout: post title: \"系统行为\" date: 2024 1 18 15:39:08 +0800 tags: Cotex M3 # 系统行为 ## 在系统中使用双堆栈 + 服务例程使用MSP（在“非基级线程模式”中会讲到例外情况） + 尽管异常服务例程使用MSP，但是它们在形式上返回后，内容上却可以依然继续——而且此时还能使用PSP，从而实现“可抢占的系统调用”，大幅提高实时性能 + 通过SysTick，实时内核的代码每隔固定时间都被调用一次，运行在特权级水平上，负责任务的调度、任务时间管理以及其它系统例行维护 + 用户应用程序以线程的形式运行，使用PSP，并且在用户级下运行 + 内核在执行关键部位的代码时，使用MSP，并且在辅以MPU时，MSP对应的堆栈只允许特权级访问 ![image 20240118161636667](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401181616706.png) 使用形如SVC的ISR来调用内核，然后通过修改EXC_RETURN的值来切换堆栈指针。图12.2简单OS中的堆栈初始化 ![image 20240118162611868](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401181626909.png) ![image 20240118162723361](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401181627403.png) ## 双字的对堆栈齐方式 在符合AAPCS的应用程序中，对于响应异常时的堆栈操作，是有必要对齐到原始（primitive）的数据尺寸的（1,2,4或8字节） 需要把NVIC配置控制寄存器的STKALIGN置位 如果在入栈时STKALIGN位为1，则xPSR的位9功能启用，指示在入栈时SP的值是否为了对齐而作出了调整。在出栈时，会检查入栈的xPSR.9，再根据它的值把SP的值调整回去。 > 注意：切勿在异常服务例程中改动STKALIGN位的值，否则会使出栈时数据发生错位，彻底破坏各个寄存器的值，这常常是致命错误 此外，当程序的一部分是使用C开发，且程序中包含了对双字数据的处理时，也推荐启用此功能 在最新的修订版2中，该特性不需手动使能，而是在缺省时已使能。在使用C开发时，如果程序包含了需要双字尺寸的数据类型（double, long long / INT64）时，推荐使能此特性。 ## 非基级的线程模式 在CM3中，原则上异常服务程序要在handler模式下执行，但是也允许在服务例程中切换到线程模式。通过设置NVIC配置与控制寄存器的“非基级线程模式允许”位（NONBASETHRDENA，位偏移：0），可以在服务例程中把处理器切换入线程模式。 中断服务例程是用户程序的一部分，可能需要让它在线程模式下执行，以限制它访问特权级下的资源，此时可以让此功能派上用场 ![image 20240118165952238](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401181659280.png) ```assembly redirect_handler \tPUSH {LR} \tSVC #0 ; 呼叫系统服务，用于把特权级别改为用户级 \tBL User_IRQ_Handler \tSVC #1 ; 执行完中断处理后，回到特权级 \tPOP {PC} ; 启动本次中断的返回序列 ``` 使用SVC #0，它先使能非基级线程模式，再拷贝主堆栈中被压入的8个寄存器到进程堆栈并更新PSP的值，最后修改EXC_RETURN，以使返回后进入“线程模式.用户级+PSP堆栈” 使用SVC #1来使一切归位，它除能非基级模式，恢复PSP先前的位置，并且修改EXC_RETURN以返回到特权级，继续使用主堆栈。 ![image 20240118170429413](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401181704475.png) ```assembly svc_handler \t; 小测试：请读者为本段代码加注释 \tTST LR, #0x4 ; 测试EXC_RETURN.2 \tITE EQ ; 如果为零则 \tMRSEQ R0, MSP ; 先前使用的是主堆栈，把MSP的值加载到R0 \tMRSNE R0, PSP ; 否则，先前使用的是进程堆栈，把PSP的值加载到R0 \tLDR R1, [R0, #24] ; 读取入栈的返回值 \tLDRB R0, [R1, # 2] ; 提出8位立即数调用代号 \tCBZ r0, svc_service_0 \tCMP r0, #1 \tBEQ svc_service_1 \tB.W Unknown_SVC_Request svc_service_0 \t; 0号服务：切换到“线程模式+PSP” \tMRS R0, PSP ; 读取PSP \tSUB R0, R0, #0x20 ; 开出32字节的空间存储8个寄存器 \tMSR PSP, R0 ; 更新PSP的值 \tMOV R1, #8*4 ; R1作为拷贝堆栈帧（8个寄存器）的循环变量 svc_service_0_copy_loop \tSUBS R1, R1, #1*4 \tLDR R2, [SP, R1] \tSTR R2, [R0, R1] \tCMP R1, #0 \tBNE svc_service_0_copy_loop \t \tSTRB R1, [R0, #0x1C] ; 在进程堆栈中清零IPSR LDR R0, 0xE000ED14 ; 加载NVIC中CCR（配置与控制寄存器）的地址 LDR r1, [r0] ORR r1, #1 STR r1, [r0] ; 使能非基级线程模式（这里的地址不在位带操作区） ORR LR, #0xC ;修改EXC_RETURN，以使得返回后进入线程模式+PSP BX LR ; 启动异常返回序列，执行动作 svc_service_1 ; 1号服务：从线程模式+PSP返回到handler模式 \tMRS R0, PSP ; 读取PSP到R0，以便于后续的一系列归位处理 \tLDR R1, [R0, #0x18] ; 读取压入PSP中的返回地址（即svc #1后面的 \t\t\t\t\t\t\t\t\t ; POP {PC}） \tSTR R1, [SP, #0x18] ; 因为将要返回到handler模式，所以把它转移到MSP ADD R0, R0, #0x20 ; 把PSP的值归位——刚响应外部中断时的值 MSR PSP, R0 ; 用归位后的值更新PSP \tLDR R0, 0xE000ED14 ; NVIC中配置与控制寄存器（CCR）的地址 \tLDR r1, [r0] ; 再次读取NVIC中的CCR \tBIC r1, #1 \tSTR r1, [r0] ; 清除NONBASETHRDENA位， \tBIC LR, #0xC ; 修改EXC_RETURN以返回handler模式，MSP亦归位 \tBX LR\t\t ``` > 手工调整PSP也是必须的。如果没有第一次调整，则在借SVC0返回的形式进入用户IRQ服务例程后，会使PSP回到进入中断前的状态。然后在执行“svc #1”时，将重新把寄存器压入栈——但此时的寄存器已经是被用户IRQ服务例程用过的了！结果，虽然PSP的值与两次调整后的还相同，但是PSP中寄存器内容已经被破坏了！ > > 这一个例程的SVC 1返回的是SVC0进去之前的状态 ## 性能评估 + 要消灭存储器等待周期。在MCU/SoC的设计期间，就应该优化存储器系统，最起码的要求，也要允许取指和数据访问能并行不悖，这才对得起“哈佛结构”的称号。应尽可地使用32位的存储器。对于软件开发人员，还应该划清代码与数据的界线，使得程序代码从代码区执行（使用I Code总线），而绝大部分数据都从数据区访问（使用System总线，而不要使用D Code总线），哪怕是多浪费点内存。只有这样，才能使取指与访问数据同时进行。 + 如果没有必要，中断向量表也放到代码区中。只有这样，才能使取向量(I Code总线)与入栈(System总线)同时进行, 如果向量表在RAM中，就会出现取向量与入栈抢总线的情况，必然导致额外的中断延迟被引入 + 限制使用非对齐访问。前面讲到，CM3总线内部其实只接受对齐访问，而由总线接口来堵窟窿：把一个非对齐的访问拆成若干个对齐的访问，来实现这种透明性。 1. 使用带偏移量寻址的LDR/STR指令，进一步地，还可以对偏移量作侈位预处理（LSL用得最多）。使用这种强大的寻址方式，常常能省去分立的地址增减/乘除计算操作。重温一下上一章中使能中断和使能异常子程的不同，相信会有切身的体会 2. 把上下文相关的变量放到一起——也就是说使它的地址是连续的。这样就可以创造使用LDM/STM指令的机会。只要遇到连续地址的数据传送，就使用LDM/STM。一条传送14个字的LDM指令，可远比14个LDR要快多了，而且代码也巨幅精简 3. 当遇到很小的“if then”块时，如果使用条件跳转指令，则会使流水线被清洗，花不少时间。这时，应使用IF THEN指令（ITxxx）。IT指令在张开双臂时，最多能保护4个孩子。 4. 如果旧时需要两条Thumb指令才能完成的操作，现在可以由一条Thumb 2指令完成，则应使用Thumb 2指令。 5. 为使自己成长为大虾，要学会使用CM3的新好指令。尤其是在ARMv6后才新出来的，都是无数前人经验的结晶，常常能有戏剧般地优化（回顾RBIT与CLZ的梦幻组合） ## 处理器被锁定 硬件Fault也触发错误会导致进入锁定 具体地说，下列场合会导致锁定 + 在硬fault服务例程中产生faults（双重fault） + 在NMI服务例程中产生faults + 在复位序列（初始的MSP与PC读取）中产生总线fault 在双重fault下，NMI还能响应（再次证明了它的第一优先地位）。然而在NMI服务例程退出后，又回到锁定状态。此时，当前优先级为 1，因此可以响应NMI——NMI的优先级是 2，比当前的高。 ## 避免被锁定 对于硬fault来说先花点工夫去查一查SP的值，看它是否在可接受的范围，然后再做后续工作。避免是因为SP异常引起的硬件Fault 对于NMI服务例程来说，它做的通常是应急工作，设计系统时就应该让这种应急工作极简单（比如，只改变一个I/O脚的电平，最多也就是修改若干寄存器的值，就可以开启相关的应急硬件——译者注），因此常常可以只使用R0 R3以及R12就完全够用，无需堆栈操作。 简化硬fault和NMI的服务例程确实是个好主意：它们只做必需的，然后悬起PendSV，让诸如错误报告等其它工作在PendSV中处理 必须杜绝在硬NMI/fault例程中使用SVC指令, 如果NMI/硬fault服务例程中调用了其它目标文件中的函数，就不能保证这些函数中没有使用过SVC。因此，在开发软件时，必须仔细地计划如何实现SVC。"},"/note/嵌入式/基础知识/Cotex-M3权威指南/2024-1-17-07NVIC与中断控制.html":{"title":"NVIC与中断控制","content":" layout: post title: \"NVIC与中断控制\" date: 2024 1 16 15:39:08 +0800 tags: Cotex M3 # NVIC与中断控制 向量中断控制器，简称NVIC NVIC的寄存器以存储器映射的方式来访问，除了包含控制寄存器和中断处理的控制逻辑之外，NVIC还包含了MPU、SysTick定时器以及调试控制相关的寄存器。 NVIC的中断控制/状态寄存器都只能在特权级下访问。不过有一个例外——软件触发中断寄存器可以在用户级下访问以产生软件中断。所有的中断控制／状态寄存器均可按字／半字／字节的方式访问。此外，还有几个中断掩蔽寄存器也与中断控制密切相关，它们是第三章中讲到的“特殊功能寄存器”，只能通过MRS/MSR及CPS来访问。 ## 中端配置基础 ![image 20240117184654419](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171846442.png) ![image 20240117184802164](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171848189.png) ## 中断的使能与失能 CM3中可以有240对使能位／除能位(SETENA位/CLRENA位)，每个中断拥有一对。这240个对子分布在8对32位寄存器中（最后一对没有用完）。 欲使能一个中断，我们需要写1到对应SETENA的位中；欲除能一个中断，你需要写1到对应的CLRENA位中 > 写0无效, 不需要读改写的步骤 因为前16个异常已经分配给系统异常，故而中断0的异常号是16 > SETENAs: xE000_E100 – 0xE000_E11C > > CLRENAs:0xE000E180 0xE000_E19C ![image 20240117185534067](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171855119.png) ## 中断的悬起与解悬 如果中断发生时，正在处理同级或高优先级异常，或者被掩蔽，则中断不能立即得到响应。此时中断被悬起。中断的悬起状态可以通过“中断设置悬起寄存器(SETPEND)”和“中断悬起清除寄存器(CLRPEND)”来读取，还可以写它们来手工悬起中断。 ![image 20240117191208184](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171912235.png) ## 优先级 每个外部中断都有一个对应的优先级寄存器，每个寄存器占用8位，但是CM3允许在最“粗线条”的情况下，只使用最高3位。4个相临的优先级寄存器拼成一个32位寄存器。 中断优先级寄存器阵列0xE000_E400 – 0xE000_E4EF ![image 20240117191325771](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171913801.png) 系统异常优先级寄存器阵列0xE000_ED18 －0xE000_ED23 ![image 20240117191358948](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171913989.png) ## 活动状态 每个外部中断都有一个活动状态位。在处理器执行了其ISR的第一条指令后，它的活动位就被置1，并且直到ISR返回时才硬件清零。由于支持嵌套，允许高优先级异常抢占某个ISR。然而，哪怕中断被抢占，其活动状态也依然为1 它们也能按字／半字／字节访问，但他们是只读的 ACTIVE寄存器族 0xE000_E300_0xE000_E31C ![image 20240117191612563](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171916603.png) ![image 20240117191629429](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171916451.png) ## 特殊功能寄存器PRIMASK与FAULTMASK PRIMASK用于除能在NMI和硬fault之外的所有异常，它有效地把当前优先级改为0（可编程优先级中的最高优先级）。该寄存器可以通过MRS和MSR以下例方式访问 ```assembly 1. 关中断 MOV R0, #1 MSR PRIMASK, R0 2. 开中断 MOV R0, #0 MSR PRIMASK, R0 CPSID i ;关中断 CPSIE i ;开中断 ``` FAULTMASK更绝，它把当前优先级改为 1,连硬fault都被掩蔽了,使用方案与PRIMASK的相似。但要注意的是，FAULTMASK会在异常退出时自动清零 ## BASEPRI寄存器 需要对中断掩蔽进行更细腻的控制——只掩蔽优先级低于某一阈值的中断——它们的优先级在数字上大于等于某个数。 如果往BASEPRI中写0，则另当别论——BASEPRI将停止掩蔽任何中断。 ```assembly 有优先级不高于0x60的中断，则可以如下编程： MOV R0, #0x60 MSR BASEPRI, R0 如果需要取消BASEPRI对中断的掩蔽，则示例代码如下： MOV R0, #0 MSR BASEPRI, R0 ``` 我们还可以使用BASEPRI_MAX这个名字来访问BASEPRI寄存器, 是当我们使用这个名字时，会使用一个条件写操作 使用BASEPRI时，可以任意设置新的优先级阈值；但是使用BASEPRI_MAX时则“许进不许出”——只允许新的优先级阈值比原来的那个在数值上更小，也就是说，只能一次次地扩大掩蔽范围，反之则不行。 为了把掩蔽阈值降低，或者解除掩蔽，需要使用“BASEPRI”这个名字。 ## 其他异常的配置寄存器 用法fault，总线fault以及存储器管理fault都是特殊的异常，因此给它们开了小灶 它们的使能控制是通过“系统Handler控制及状态寄存器(SHCSR)”（地址：0xE000_ED24）来实现的。各种faults的悬起状态和大多数系统异常的活动状态也都在该寄存器中 ![image 20240117193634683](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401171936745.png) > 写这些寄存器时要小心，必须确保对活动位的修改是经过深思熟虑的，决不能粗心修改。否则，如果某个异常的活动位被意外地清零了，其服务例程却不知晓，仍然执行异常返回指令，那么CM3将视之为无理取闹——在异常服务例程以外做异常返回，从而产生一个fault。 中断控制及状态寄存器ICSR（地址：0xE000_ED04） ![image 20240117204417764](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401172044833.png) ## 实际的实现 ```assembly LDR R0, 0xE000ED0C ; 应用程序中断及复位控制寄存器 LDR R1, 0x05FA0500 ; 使用优先级组5 (2/6) STR R1, [R0] ; 设置优先级组 ... MOV R4, #8 ; ROM中的向量表 LDR R5, (NEW_VECT_TABLE+8) LDMIA R4!, {R0 R1} ; 读取NMI和硬fault的向量 STMIA R5!, {R0 R1} ; 拷贝它们的向量到新表中 ... LDR R0, 0xE000ED08 ; 向量表偏移量寄存器的地址 LDR R1, NEW_VECT_TABLE STR R1, [R0] ; 把向量表重定位 ... LDR R0, IRQ7_Handler ; 取得IRQ #7服务例程的入口地址 LDR R1, 0xE000ED08 ; 向量表偏移量寄存器的地址 LDR R1, [R1] ADD R1, R1,#(4*(7+16)); 计算IRQ #7服务例程的入口地址 STR R0, [R1] ; 在向量表中写入IRQ #7服务例程的入口地址 ... LDR R0, 0xE000E400 ; 外部中断优先级寄存器阵列的基地址 MOV R1, #0xC0 STRB R1, [R0,#7] ; 把IRQ #7的优先级设置为0xC0 ... LDR R0, 0xE000E100 ; SETEN寄存器的地址 MOV R1, #(1<<7) ; 置位IRQ #7的使能位 STR R1, [R0] ; 使能IRQ #7 ``` > 1. 当系统启动后，先设置优先级组寄存器。缺省情况下使用组0（7位抢占优先级，1位亚优先级）。 > 2. 如果需要重定位向量表，先把硬fault和NMI服务例程的入口地址写到新表项所在的地址中。 > 3. 配置向量表偏移量寄存器，使之指向新的向量表（如果有重定位的话） > 4. 为该中断建立中断向量。因为向量表可能已经重定位了，保险起见需要先读取向量表偏移量寄存器的值，再根据该中断在表中的位置，计算出对应的表项，再把服务例程的入口地址填写进去。如果一直使用ROM中的向量表，则无需此步骤。 > 5. 为该中断设置优先级。 > 6. 使能该中断 CM3的NVIC中，有一个名为“中断控制器类型寄存器”，它提供了该芯片中支持的中断数目，粒度是32的整数倍 ![image 20240117210704458](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401172107495.png) 也可以通过对每个SETENA位进行先写后读的测试，来获取支持的中断的精确数目（往各SETENA中写1，不支持的中断将永远读回0，求出第1个0的位置即可），亦可使用SETPEND等其它位来做此测试。 ## 软件中断 包括手工产生的普通中断，能以多种方式产生。最简单的就是使用相应的SETPEND寄存器；而更专业更快捷的作法，则是通过使用软件触发中断寄存器STIR 0xE000_EF00 ![image 20240117210906839](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401172109876.png) ## SysTick Cortex M3处理器内部包含了一个简单的定时器。 SysTick控制及状态寄存器（地址：0xE000_E010） ![image 20240117211200496](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401172112536.png) SysTick重装载数值寄存器（地址：0xE000_E014） ![image 20240117211231039](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401172112064.png) SysTick当前数值寄存器（地址：0xE000_E018） ![image 20240117211303648](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401172113673.png) SysTick校准数值寄存器（地址：0xE000_E01C） ![image 20240117211348076](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401172113112.png) 校准值寄存器提供了这样一个解决方案：它使系统即使在不同的CM3产品上运行，也能产生恒定的SysTick中断频率。最简单的作法就是：直接把TENMS的值写入重装载寄存器，这样一来，只要没突破系统的“弹性极限”，就能做到每10ms来一次 SysTick异常。 少数情况下，CM3芯片可能无法准确地提供TENMS的值（如，CM3的校准输入信号被拉低），所以为保险起见，最好在使用TENMS前检查器件的参考手册 当处理器在调试期间被喊停（halt）时，则SysTick定时器亦将暂停运作。"},"/note/嵌入式/基础知识/Cotex-M3权威指南/2024-1-19调试.html":{"title":"调试","content":" layout: post title: \"调试\" date: 2024 1 18 15:39:08 +0800 tags: Cotex M3 # 调试 ## 简介 ### 侵入式调试 1. 停机以及单步执行程序 2. 硬件断点 3. 断点指令（BKPT） 4. 数据观察点，作用于单一地址、一个范围的地址，以及数据的值。 5. 访问寄存器的值（既包括读，也包括写） 6. 调试监视器异常 7. 基于ROM的调试（闪存地址重载(flash patching) ） ### 非侵入式调试 1. 在内核运行的时候访问存储器 2. 指令跟踪，需要通过可选的嵌入式跟踪宏单元（ETM） 3. 数据跟踪 4. 软件跟踪（通过ITM（指令跟踪单元）） 5. 性能速写（profiling）（通过数据观察点以及跟踪模块） CM3的调试系统基于ARM亲手打造且吐血推荐的“CoreSight（内核景象）”调试架构 ## CoreSight技术概览 ### 处理器调试接口 以前的ARM处理器都提供JTAG接口，通过它来控制对寄存器和存储器的访问。在CM3中全变了——对处理器上总线逻辑的控制使用另外的总线接口，即通过所谓的“调试访问端口(DAP)”。 把JTAG或串行线协议都转换成DAP总线接口协议，再控制DAP来执行调试动作。 CM3支持两种调试主机接口（debug host interface）:第一个是广为使用的JTAG接口，另一个则是新的“串行线(Serial Wire, SW)调试接口”。 CM3主要针对低成本的单片机市场。单片机往往没有很富裕的管脚资源。而JTAG协议需要使用4根脚，而SW则只需要两根。 ### DP模块, AP模块和DAP模块 ![image 20240119200941923](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401192009188.png) 通过DP接口模块（通常是SWJ DP或SW DP），先把外部信号转换成一个通用的32位调试总线信号（图表中的DAP总线） SWJ DP支持SW与JTAG两种协议，而SW DP则只支持SW。 CoreSight产品中还可以使用一种JTAG DP，它只支持JTAG协议。 DAP总线上的地址是32位的，其中高8位用于选择访问哪一个设备，由此可见，最多可以在DAP总线上面挂256个设备。 在CM3处理器的内部，只用掉了一个设备的地址，还剩下的255个都可以用于连接访问端口（AP）到DAP总线上 在把数据从DAP接口传递给CM3处理器后，下一步就连接到了一个称为“AHB AP”的AP设备上，它相当于一个总线桥，用于把DAP总线的命令转换为AHB总线上的数据传送，再插入到CM3内部的总线网络中。这么一来，CM3的整个寻址空间就都在覆盖范围之内了，连NVIC中的调试控制寄存器组也包括在内。 在CoreSight系列产品中，AP设备可以有好几种类型，包括APB AP和JTAG AP。APB AP顾名思义，是用于产生APB总线数据传送动作的，而JTAG AP则用于控制传统的、基于JTAG的测试接口，例如ARM7上的调试接口 ### 跟踪接口 1. 指令跟踪：由ETM（嵌入式跟踪宏单元）产生 2. 数据跟踪：由DWT产生 3. 调试消息：由ITM产生，提供形如printf的消息输入，送到调试器的GU I中 尽管在CM3中拥有多个跟踪源，但CM3内建了一个归并硬件, 跟踪输出接口可以直接连接到专为CM3设计的TPIU上，然后就可以供PC控制的外部硬件捕捉仪来跟踪数据。 ### 性质 CoreSight的调试设计有很多优势： + 即使在处理器运行时，也可以查看存储器和外设的寄存器的内容 + 使用单一调试器，就可以控制多核系统的调试接口。例如，如果使用JTAG，则只需要一个TAP控制器，不管芯片中有几个处理机都一样。 + 内部的调试接口是基于单总线的方式设计的，因此非常有弹性，也简化了为芯片的其它部分设计附加的测试逻辑。 + 它使得多条“跟踪数据流”可以由单一的“跟踪捕获设备”来收集，送到PC机上之后再还原出先前的各条数据流。 CM3中的调试系统是基于CoreSight的，但是又有一些“变异”： + CM3的跟踪组件是重新设计的，有些在CM3中的ATB接口是8位的，而纯种的CoreSight的都是32位的。 + CM3的调试系统没有实现TrustZone——ARM提供的一种技术，用于在嵌入式产品中提供安全特性。 + 调试组件所需的空间挤到了系统的存储器映射中。而在标准的CoreSight系统中，是为调试总线另开了一个地址空间的。 ![image 20240119202324513](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401192023572.png) ![image 20240119202345402](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401192023446.png) ## 调试模式 CM3中的调试操作模式分为两种。第一种称为“halt”（停机模式），在进入此模式时，处理器完全停止程序的执行。第二种则称为“debug monitor exception”（调试监视器模式），此时处理器执行相应的调试监视器异常服务例程，由它来执行调试任务，并且依然允许更高优先级的异常抢占它。调试监视器的异常号为12，优先级可编程。除了调试事件可以触发异常外，手工设置其悬起位也可以触发本异常 ![image 20240119202745381](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401192027424.png) 需要把NVIC调试停机控制及状态寄存器（DHCSR）的C_DEBUGEN位置位。这个位只能由调试器来设置，没有调试器是不能把CM3停机的。在C_DEBUGEN置位后，就可以设置DHCSR.C_HALT位来喊停处理器。此C_HALT位可以由软件置位。 试停机控制及状态寄存器DHCSR（地址：0xE０00_EDF0） ![image 20240119202924707](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401192029761.png) DHCSR中的控制位是在上电复位时得到复位的。系统复位（例如，往NVIC应用程序中断及复位寄存器中写命令）不会影响到它们 正常情况下，只有调试器会操作DHCSR，应用程序不要乱动它，以免使调试工具出现问题。 调试及监视器控制寄存器DEMCR（地址：0xE０00_EDFC） ![image 20240119203100136](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401192031192.png)"},"/note/嵌入式/基础知识/Cotex-M3权威指南/2024-1-16-00快查.html":{"title":"快查","content":" layout: post title: \"快查\" date: 2024 1 16 15:39:08 +0800 tags: Cotex M3 # 快查 ![image 20240116162421441](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401161624577.png) ![image 20240116162435898](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401161624923.png)"},"/note/嵌入式/基础知识/Cotex-M3权威指南/2024-1-18-13MPU.html":{"title":"MPU","content":" layout: post title: \"MPU\" date: 2024 1 18 15:39:08 +0800 tags: Cotex M3 # MPU 在Cortex M3处理器中可以选配一个存储器保护单元（MPU），它可以实施对存储器（主要是内存和外设寄存器）的保护 如果没有启用MPU，则等同于系统中没有配MPU + 阻止用户应用程序破坏操作系统使用的数据 + 阻止一个任务访问其它任务的数据区，从而把任务隔开。 + 可以把关键数据区设置为只读，从根本上消除了被破坏的可能。 + 检测意外的存储访问，如，堆栈溢出，数组越界。 + 此外，还可以通过MPU设置存储器regions的其它访问属性，比如，是否缓区，是否缓冲等。 MPU在执行其功能时，是以所谓的“region”为单位的。一个region其实就是一段连续的地址，只是它们的位置和范围都要满足一些限制（对齐方式，最小容量等）。CM3的MPU共支持8个regions。 允许把每个region进一步划分成更小的“子region”。此外，还允许启用一个“背景region”（即没有MPU时的全部地址空间），不过它是只能由特权级享用。在启用MPU后，就不得再访问定义之外的地址区间，也不得访问未经授权的region。否则，将以“访问违例”处理，触发MemManage fault。 MPU定义的regions可以相互交迭。如果某块内存落在多个region中，则访问属性和权限将由编号最大的region来决定 ## 寄存器组 ![image 20240118192756845](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401181927903.png) + MPU类型寄存器MPUTR（地址：0xE000_ED90） ![image 20240118193303399](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401181933429.png) > 通过读取DREGION的值，能够判断芯片中是否配了MPU + MPU控制寄存器MPUCR（地址：0xE000_ED94） ![image 20240118193551302](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401181935325.png) ![image 20240118193530847](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401181935883.png) > 通过把PRIVDEFENA置位，可以在没有建立任何region就使能MPU的情况下，依然允许特权级程序访问所有地址，而只有用户级程序被拒之门外。然而，如果设置了其它的region并且使能了MPU，则背景region与这些region重合的部分，就要受各region的限制。 ![image 20240118193707868](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401181937921.png) 不管MPU如何限制，响应异常时的取向量操作，以及对系统分区(system partition)的访问总是不受影响的。 配置任何一个region之前，都需要在MPU内选中这个region，这可以通过把region号写入MPU region号寄存器(MPURNR)来完成 + MPU region号寄存器MPURNR（地址：0xE000_ED98） ![image 20240118193906918](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401181939943.png) 选好了region后，就可以在另外两个寄存器中配置该region的所有属性了。为了能快速地配置多个regions，还有另一种快捷方式。在MPU region基地址寄存器(MPURBAR)中有两个位段：VALID和REGION，它们配合使用可以绕过MPURNR。 + MPU region基址寄存器MPURBAR（地址：0xE000_ED9C） ![image 20240118194023980](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401181940014.png) 基址必须对齐到region容量的边界。举例来说，如果你定义的region容量是64KB，那么它的基址就必须能被64KB整除 如果读取REGION位段，返回的总是当前的region号，并且VALID总返回0。通过设置VALID 1和REGION n，也可以改变一个region的编号。相比于先设置MPU region号寄存器再设置本寄存器的正统做法而言，这是一个快捷方式 必须以字的方式来访问本寄存器，否则结果不可预知 + MPU region属性及容量寄存器MPURASR（地址：0xE000_EDA0） ![image 20240118194541003](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401181945086.png) > 8个region的定义过于粗枝大叶，因而允许再精雕细琢，把每个region的内部进一步划分成更小的块，这就是子region。但是子region的使用有限制：每个region必须8等分，每份是一个子region，而且所有子region的属性都与“父region”的是相同的。每个子region可以独立地使能或除能（相当于可以部分地使能一个region）：SRD中的8个位，每个位控制一个子region是否被除能 > 楷体的TEX, S, B和C（整体位于[21:16]），对应着存储系统中比较高级的概念。CM3中没有缓存(cache)，但是CM3是以v7 M的架构设计的，而v7 M支持外部缓存（差不多是L2缓存的地位）以及更先进的存储器系统。按v7 M的规格说明，可以通过对这些位段的编程，来支持多样的内存管理模型。从v6开始，ARM架构支持两级缓存（与x86的缓存系统是异曲同工的），分别是：内部缓存和外部缓存，它们可以有不同的缓存方针(policy)，这些位组合的详细功能如下表所示 > > ![image 20240118200632270](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401182006319.png) > > 表中最后一项越发离奇，它是TEX的MSB 1时的情况。此时，如果该region是片内存储器，则由C和B决定其缓存属性（AA）；如果是片外存储器，则由TEX的[1:0]决定其缓存属性（BB）。不管是AA还是BB，每个数值的含义都是相同的，如下表所示 > > ![image 20240118200905547](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401182009574.png) ## 启用MPU + 特权级的程序代码（如OS内核和异常服务例程） + 用户级的程序代码 + 特权级程序的数据存储器，位于代码区中（data_stack） + 用户级程序的数据存储器，位于代码区中（data_stack） + 通用的数据存储器，位于其它存储器区域中（如，SRAM） + 系统设备区，只允许特权级访问，如NVIC和MPU的寄存器所有的地址区间 + 常规外设区，如UART，ADC等。 对于CM3来说，绝大多数region中，都有TEX 0，C 1，B 1。系统设备（如NVIC）必须“严格顺序”（strongly ordered）访问；另一方面，外设regions则可以共享（TEX 0, C 0, B 1）。如果想要在某个region中，确保所有的总线fault都是精确的，就必须把该region严格顺序化（TEX 0, C 0, B 0）。这样一来写缓冲被除能，但也因此产生性能损失的代价。 ![image 20240118201538390](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401182015442.png) ## MPU的典型设置 ![image 20240118205714540](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401182057572.png) 在只有部分外设可以给用户使用的时候, 可以设置背景为特权级, 上面一个用户级, 部分子regin使能"},"/note/嵌入式/基础知识/RISC-V体系/2024-8-1-04汇编.html":{"title":"汇编","content":" layout: post title: \"汇编\" date: 2024 6 26 15:39:08 +0800 tags: RISC V # 汇编 ![image 20240801155619811](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408011556839.png) ## 基本语法 ## 指令集及其编码 ![image 20240731231949594](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407312319732.png) + R Type 指令用于涉及两个源寄存器和一个目标寄存器的操作。它们通常包括算术和逻辑操作，如加法、减法、位运算和比较，比如后面课程要介绍的add x3, x1, x2把x1+x2写入x3, 使用funct7和opcode确定操作的方式, 两个源寄存器是rs1, rs2目标是rd + I Type 指令用于涉及立即值（常数）和一个源寄存器的操作。常见的 I Type 指令包括加载操作，以及使用立即值进行算术运算（例如，用于“加立即数”的 addi x3, x1, 0x10）。 + S Type 指令是 I Type 指令的子集，专门用于将数据存储到内存中。它们涉及一个源寄存器、一个立即偏移和一个基地址寄存器，用于指定要存储数据的内存位置 sb x0, 0(x1)。 + B Type 指令用于条件分支操作。它们比较两个寄存器，并根据结果确定是否采取分支指令。常见的 B Type 指令包括 beq（相等时分支）和 bne（不相等时分支）。 + U Type 指令用于将寄存器的高位设置为一个常数值，通常用于初始化指针或地址。U Type 指令包括 lui（加载高位立即数）和 auipc（将高位立即数添加到 PC）。 + J Type 指令用于无条件跳转操作。跳转指令将控制转移到指定的目标地址，例如 jal（跳转并链接）指令用于子程序调用。 ![image 20240731232621529](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407312326615.png) > 基础指令集 ![image 20240731232641231](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407312326271.png) ![image 20240731232654089](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407312326143.png) ![image 20240731232713781](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407312327827.png) ![image 20240731232803052](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407312328195.png) ### 标签 用于记录一个位置, 可以使用标签进行跳转 数字标签用于本地引用。对本地标签的引用包括 后缀为“f”表示正向引用，后缀为“b”表示后向引用。 ```assembly 1: \tjmp 1b ``` ### 操作数顺序 在 RISC V 汇编语言中，指令的操作数顺序通常遵循“目标寄存器，源寄存器1，源寄存器2”的模式，用于三操作数指令。例如，在指令“xor x1, x5, x10”中，目标寄存器是 x1，第一个源寄存器是 x5，第二个源寄存器是 x10。该指令将取出 x5 和 x10 的内容，对它们执行按位异或操作，并将结果存储在 x1 中。 ### 立即数 如果你观察RISC V指令编码，会发现：RV32I指令通常使用12位大小的立即数，其大小被符号扩展到目标寄存器的宽度。因此，很多指令在使用时，不能使用太大的立即数。如需要更大的数值，则需要利用组合lui和addi指令将数值加载到寄存器中。 ```assembly lui t0, 0x1235 adddi t0, t0, 0.678 ``` ### 伪指令 仅仅使用RISC V提供的指令在很多时候并不方便进行程序的编程，所以汇编器会额外引入伪指令。 伪指令（Pseudoinstruction）是汇编语言中用于控制汇编程序的行为或提供其他辅助功能的指令，但它们并不对应实际的机器指令。伪指令在汇编过程中被解释执行，而不会被翻译成机器码。例如： + 定义数据：伪指令可以用于定义常量、变量、数组等数据结构。 + 分配内存：伪指令可以用于分配内存空间，例如栈空间、数据段等。 + 控制流程：伪指令可以用于控制程序的流程，例如条件跳转、循环等。 + 引入外部代码：伪指令可以用于引入其他源文件中的代码或数据。 + 其他辅助功能：伪指令还可以用于其他辅助功能，例如设置程序的入口点、声明程序的中断处理程序等。 ![image 20240801162731499](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408011627599.png) ![image 20240801162807692](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408011628754.png) ### 汇编指令符 在汇编语言中，有一些指示符，主要用于告知汇编器如何对汇编程序进行处理。例如，可使用指示符划分代码或数据块、为不同数据大小分配数据区域、控制程序如何处理（宏） ![image 20240801162607770](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408011626852.png) ## 基础使用 ![image 20240731224252939](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407312242994.png) ### 立即数加载 ![image 20240801164917970](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408011649003.png) 不过这两条指令有缺陷，只能加载一个数值的高20位，低12位保持为0。例如：指令lui rd, imm将寄存器rd的值设置为左移12位的立即值。指令auipc rd, imm将寄存器rd的值设置为PC与左移12位的立即值之和。在下面的例子中，可以看到其具体计算过程。 > ![image 20240801170127399](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408011701430.png) ![image 20240801165019527](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408011650557.png) 可以看到，这两条指令都是有一定缺省的，因此在实际使用过程中，往往需要配合addi rd, rs, imm来进一步将低12位的imm累加到寄存器，从而将完整的32位立即数加载到寄存器。这个过程，可以使用以下伪指令完成。 ![image 20240801165106451](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408011651480.png) ![image 20240801165227730](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408011652758.png) + 示例 ![image 20240801170549600](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408011705637.png) ### 内存操作 进行读取的时候可以使用load指令, 加载的数据必须是对齐的 + LB（Load Byte）：加载一个8位值，并进行符号扩展为32位，存储在目标寄存器。 例如：`lb rb, offset(rs1)` + LH（Load Half）：加载一个16位值，并进行符号扩展为32位，存储在目标寄存器，例如：`lh rb, offset(rs1)` + LW（Load Word）：加载一个32位值到目标寄存器，例如：`lw rh, offset(rs1)` + LBU（Load Byte Unsigned）：加载一个8位值，并进行零扩展为32位，存储在目标寄存器中，例如：`lbu rb, offset(rs1)` + LHU（Load Half Unsigned）：加载一个16位值，并进行零扩展为32位，存储在目标寄存器中，例如: `lhu rb, offset(rs1)` 写入的时候可以使用指令store + SW（Store Word）：将寄存器中的32位值存储到内存中，例如：`sw sr2, offset(rs1)` + SH（Store Half）：将寄存器中的16位值存储到内存中，例如：`sh sr2, offset(rs1)` + SB（Store Byte）：将寄存器中的8位值存储到内存中，例如：`sb sr2, offset(rs1)` 可以使用伪指令的方式进行使用 ![image 20240801172239584](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408011722620.png) ![image 20240801172913659](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408011729712.png) ![image 20240801173653528](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408011736576.png) ### 算数运算 ![image 20240801180654518](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408011806583.png) ![image 20240801181652483](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408011816516.png) 实际使用的时候用的是: `操作 目标地址, 源地址1, 源地址2或立即数` + 伪指令 ![image 20240801180817194](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408011808245.png) > 最后这几个使用x0永远为0的特性 ### 无条件跳转 除了条件分支之外，还有无条件跳转指令jalr和jal。这些指令允许跳转到特定地址，并修改程序计数器，但将（可能的）返回地址写入寄存器。返回地址是跳转指令后地址的指令。返回地址允许从跳转的代码段跳回（返回)。通过这种方式实现程序的模块化。这些指令使用不同的格式： ![image 20240801194703567](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408011947633.png) > 这一个offset可以使用一个标签 伪指令 ![image 20240803152844213](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408031528344.png) > 通常使用x1寄存器记录返回的地址 ### 条件跳转 ![image 20240803153948324](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408031539376.png) 伪指令 ![image 20240803154318891](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408031543934.png) ### CSR控制指令 ![image 20240803155941938](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408031559001.png) ![image 20240803160142865](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408031601917.png) 伪指令 ![image 20240803160701102](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408031607149.png) ### 其他指令 ![image 20240803160826614](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408031608652.png) > 系统调用以及设置断点 ## 和C语言的配合 ### 汇编使用C语言变量 可以使用lw进行读取 ```assembly \t.text \t.global test_asm \t.extern counter test_asm: \tlw to, counter ``` 在使用的时候不能标注这一个数据的类型, 这是一个32位的数据, 所以使用lw, 可以使用la加载变量的地址, 然后使用sw进行写入 ```assembly \tlw t0, count \tla t1, count \tsw t0, (t1) ``` ### C语言使用汇编中的变量 ```assembly \t.global data0, data1 \t.data data0: .byte 0x12 \t.align 4 data1: .short 0x1234 ``` > 汇编里面进行声明 ```c extern unsigned char data0; extern unsigned short data1; ``` ### 返回值 x1寄存器(ra)记录函数的返回地址 返回的数据会放在x10 x11(a0 a1)寄存器里面, a0 a7寄存器可以作为函数的参数数据存放的位置 数据的长度不到32位的时候, 会把这一个数据进行扩展 > 不超过32位的时候使用寄存器进行传递, [riscv elf psabi doc/riscv cc.adoc at master · riscv non isa/riscv elf psabi doc · GitHub](https://github.com/riscv non isa/riscv elf psabi doc/blob/master/riscv cc.adoc)其余的情况使用这一种方式进行处理 ### 函数调用 + 在C语言里面调用汇编函数 汇编代码里面使用global声明一下一个代码段里面的标签, 最后使用ret进行返回 在C语言里面声明一下这一个函数 ```assembly \t.text \t.global test_asm \t.extern counter test_asm: \tlw t0, counter \tret ``` + 汇编里面调C函数 在汇编里面, 函数实际就是一段程序的入口 ```c \t.text \t.global test_asm \t.extern printf test_asm: \t//压栈 \taddi sp, sp, 4 \tsw ra, 0(sp) \t//传参 \tla a0, hello_msg \tli a1, 100 \t//调用函数 \tcall printf \t//出栈 \tlw ra, (sp) \taddi sp, sp, 4 \tret \t.global data0, data1 \t.data hello_msg: .asciz \"Hello asm %d\\n\" ``` ![image 20240804164146874](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408041641945.png) > 这一个函数不会正常返回, 因为ra这一个寄存器被改变了, 一般可以使用栈进行保存, 在寄存器表里面记录了需要调用者以及背调函数保存的寄存器 > > 调用者: > > + t0 t6: 临时寄存器 > + a0 a7: 参数/返回值寄存器 > + ra: 返回地址寄存器 > > 被调函数: > > + s0 s11: 保存寄存器, 记录保存函数调用过程中需要保存的寄存器状态 > + sp: 栈指针寄存器 > ### 乘法拓展 ![image 20240829162725597](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408291627717.png) 如果不实现这一个部分的话, 会使用C库里面的实现 #### MUL MUL（Multiply）指令是RISC V指令集中用于执行两个寄存器中值的乘法操作。它计算两个数的乘积，并将结果的低32位（对于32位RISC V）或低64位（对于64位RISC V）存入目标寄存器，即rd (rs1 * rs2) & 0xFFFFFFFF。 ```assembly mul rd, rs1, rs2 ``` 使用这一个命令的时候, 只保存结果的低位 #### MULH MULH（Multiply High）指令执行两个寄存器中值的有符号乘法，并将乘积的高位部分存入目标寄存器。这对于需要乘积完整范围的操作特别有用，尤其是在处理大数乘法时，即rd (rs1 * rs2) >> 32 #### MULHSU 令执行一个有符号数（rs1）与一个无符号数（rs2）的乘法操作，并将乘积的高位部分存入目标寄存器rd，即rd (rs1 * rs2) >> 32。这允许在同一个操作中混合有符号和无符号数的乘法，扩展了乘法指令的应用范围。 #### MULHU 进行两个无符号数的乘法运算, 把高位记录在寄存器里面 #### DIV ```assembly div rd, rs1, rs2 ``` rd rs1/rs2 除数为0的时候结果未定义 #### DIVU 用于计算无符号的数的操作, 吧目标记录在目标寄存器里面 #### REM 有符号数的取余操作 #### REMU 无符号数的取余操作 ```assembly remu rd, rs1, rs2 ``` rd rs1 % rs2"},"/note/嵌入式/基础知识/RISC-V体系/2024-6-26-问题处理.html":{"title":"问题处理","content":" layout: post title: \"问题处理\" date: 2024 6 26 15:39:08 +0800 tags: RISC V # 问题处理 ## WCH Link无法连接 使用WCH LinkUtility ![image 20240803164424196](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408031644238.png)"},"/note/嵌入式/基础知识/RISC-V体系/2024-8-5-06中断处理.html":{"title":"异常处理机制","content":" layout: post title: \"异常处理机制\" date: 2024 8 5 15:39:08 +0800 tags: RISC V # 异常处理 ![image 20240805133417978](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408051334047.png) 可以设置中断的使能, 挂起, 优先级以及激活和控制 CH32V20x、CH32V30x 和 CH32V31x 系列内置可编程快速中断控制器（PFIC–Programmable Fast Interrupt Controller），最多支持 255 个中断向量。当前系统管理了 88 个外设中断通道和 8 个内 核中断通道，其他保留。 ## 实际操控 中断管理的相关的函数可以在riscv_croe.h文件里面找到 在启动文件里已经把mstatus寄存器的对应的位设置为1![image 20240805140628745](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408051406768.png) ![image 20240805140601182](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408051406218.png) ![image 20240805140805000](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408051408029.png) 可以设置中断使能以后, 把中断挂起从而实现手动激活中断的作用 ```c void SysTick_Handler(void) __attribute__((interrupt())); void SysTick_Handler(void){ printf(\"Hello Systick\\n\"); } int main(void) { \tNVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); \tSystemCoreClockUpdate(); \tDelay_Init(); \tUSART_Printf_Init(115200); \tNVIC_SetPendingIRQ(SysTicK_IRQn); \tNVIC_EnableIRQ(SysTicK_IRQn); \twhile(1) { \t} } ``` ### 优先级控制寄存器 ![image 20240805142545939](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408051425979.png) ![image 20240805142757197](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408051427261.png) > 使用寄存器INTSYSCR寄存器控制实际的抢占优先级的位数 > > ![image 20240805143653228](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408051436263.png) > > ![image 20240805143748934](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408051437970.png) > > ![image 20240805143847621](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408051438647.png) > > ![image 20240805143902986](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408051439014.png) 设置优先级可以使用`NVIC_SetPriority(IRQn, priority)`函数, 或者使用函数`NVIC_Init(NVIC_InitStruct);` > ```c > /* NVIC Init Structure definition > * interrupt nesting disable(CSR 0x804 bit1 0) > * NVIC_IRQChannelPreemptionPriority range is 0. > * NVIC_IRQChannelSubPriority range from 0 to 7. > * > * interrupt nesting enable 2 Level(CSR 0x804 bit1 1 bit[3:2] 1) > * NVIC_IRQChannelPreemptionPriority range from 0 to 1. > * NVIC_IRQChannelSubPriority range from 0 to 3. > * > * interrupt nesting enable 4 Level(CSR 0x804 bit1 1 bit[3:2] 2) > * NVIC_IRQChannelPreemptionPriority range from 0 to 3. > * NVIC_IRQChannelSubPriority range from 0 to 1. > * > * interrupt nesting enable 8 Level(CSR 0x804 bit1 1 bit[3:2] 3) > * NVIC_IRQChannelPreemptionPriority range from 0 to 7. > * NVIC_IRQChannelSubPriority range range is 0. > */ > typedef struct > { > uint8_t NVIC_IRQChannel; > uint8_t NVIC_IRQChannelPreemptionPriority; > uint8_t NVIC_IRQChannelSubPriority; > FunctionalState NVIC_IRQChannelCmd; //设置为ENABLE即可开启中断 > } NVIC_InitTypeDef; > ``` > >"},"/note/嵌入式/基础知识/RISC-V体系/2024-8-4-05异常处理机制.html":{"title":"异常处理机制","content":" layout: post title: \"异常处理机制\" date: 2024 8 4 15:39:08 +0800 tags: RISC V # 异常处理机制 ![image 20240804172035813](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408041720858.png) 分析该表可知：每种异常有一个唯一的编号，编号从0开始，interrupt字段表明该类型的异常是否是外设中断。另外，同步/异常指明： + 同步”是指可以准确地定位到某一条执行的指令，例如一条 ebreak 或 ecall 指令，每次执行到该指令均会触发进入异常。 + 异步”是指不能准确定位于某条指令，每次异常发生时的指令PC 值有可能不同。 + “精确异步”是指异常发生后可以精确地定位到某一条指令的边界，即某条指令执行之后的状态，例如外部的中断。 + 而“非精确异步”是指无法精确定位到某一条指令的边界，有可能是某条指令执行了一半被打断后的状态，例如访存错误。访问存储器需要时间，微处理器访存时一般不会一直等待访存结束，而是继续执行指令，此时再出现访存错误异常时，微处理器已经执行了后续的指令，无法精确定位。 ## 处理流程 青稞处理器中，异常处理流程如下所示，可以看到分三步：进入异常、执行异常处理程序、退出异常。 ![image 20240804172243067](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408041722098.png) > 在发生异常的时候会通过中断向量表进入处理程序, 使用CSR寄存器记录信息, 同时进入机器模式 ### 相关寄存器 在实际处理的时候, 会使用mtvec寄存器里面记录的向量表的位置 ![image 20240804174120153](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408041741196.png) > 统一的入口地址的时候, 所有的函数使用同一个函数进行处理 ![image 20240804174511414](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408041745448.png) ![image 20240804174432941](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408041744967.png) 当进入异常或中断时，微处理器会自动更新相关的 CSR 寄存器，包括机器模式异常原因寄存器 mcause、机器模式异常指针寄存器 mepc、机器模式异常值寄存器 mtval、机器模式状态寄存器 mstatus + 更新 mcause 当进入异常或中断时，微处理器会自动更新相关的 CSR 寄存器，包括机器模式异常原因寄存器 mcause、机器模式异常指针寄存器 mepc、机器模式异常值寄存器 mtval、机器模式状态寄存器 mstatus。 ![image 20240804175342469](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408041753500.png) > 低位为异常编码，用于指示具体的原因。 + 更新 mepc 标准定义退出异常或中断后微处理器的返回地址保存在 mepc 中。所以当发生异常或中断后，硬 件自动更新 mepc 值为当前遇到异常时的指令 PC 值，或中断前下一条预执行的指令 PC 值。异常或中 断处理结束后，微处理器使用其保存的值作为返回地址，回到中断的位置继续执行。 ![image 20240804175428671](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408041754705.png) > .mepc 是一个可读可写的寄存器，软件也可以修改该值，达到修改返回后运行的 PC 指针位置的 目的。 > > 当发生中断时，即异常原因寄存器 mcause[31] 1 时，mepc 的值更新为中断时下一条未执行的 指令 PC 值。 > > 而发生异常时，异常原因寄存器 mcause[31] 0 时，mepc 的值更新为当前异常的指令 PC 值。因 此这时异常返回时，如果直接使用 mepc 的值返回，还是继续执行之前产生异常的指令，此时还会继 续进异常。通常我们处理好异常后，可以修改 mepc 的值为下一条未执行指令的值后再返回。例如我 们因 ecall/ebreak 引起异常，处理异常后，由于 ecall/ebreak（c.ebreak 为 2 字节）为 4 字节指令， 此时只需要软件修改 mepc 的值为 mepc+4(c.ebreak 为 mepc+2)后返回即可。 + 更新 mtval ![image 20240804175514294](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408041755322.png) 进入异常和中断时，硬件将自动更新 mtval 的值，该值即为引起异常的值。该值一般是： 1. 如果存储器访问引起的异常，硬件会将异常时存储器访问的地址存入 mtval。 2. 如果是非法指令引起的异常，硬件会将该指令的指令编码存入 mtval。 3. 如果是硬件断点引起的异常，硬件会将断点处 PC 值存入 mtval。 4. 对于其他的异常，硬件将 mtval 的值设为 0，例如 ebreak，ecall 指令引起的异常。 5. 进入中断时，硬件将 mtval 的值设为 0。 + 更新 mstatus ![image 20240804175559244](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408041755283.png) > FS 域用于描述和维护浮点单元状态，所以该域只有在含有硬件浮点功能的青稞 V4F 微处理器上 才有意义。当其值为 0 时，表示浮点单元为关闭状态，且如果此时使用浮点指令，将触发异常；若其 值为 1 或 2，当执行了浮点指令后，该域会被更新为 3。若用户在使用 V4F 微处理器时，不期望使用 硬件浮点功能，可在机器模式下，手动清除该两位，以关闭硬件浮点并降低功耗。 MPP 域用于保存进入异常或中断前的特权模式，用于退出异常或中断后的特权模式恢复，MIE 为 全局中断使能位，当进入异常或中断时，MPIE 的值被更新为 MIE 值，需要注意的是青稞 V4 系列微处 理器中，在最后一级嵌套中断前 MIE 不会被更新为 0，以保证机器模式下的中断嵌套继续执行。当退 出异常或中断后，微处理器恢复为 MPP 保存的机器模式，并且 MIE 恢复为 MPIE 的值。 青稞 V4 微处理器支持机器模式和用户模式，若需要使微处理器仅工作在机器模式，可在启动文 件的初始化中把 MPP 设置为 0x3，即返回后，始终保持在机器模式。 进入异常和中断时，硬件会更新 mstatus 中的某些位： 1. MPIE 更新为进入异常和中断前的 MIE 值，异常和中断结束后，MPIE 用于恢复 MIE。 2. .MPP 更新为进入异常和中断前的特权模式，异常和中断结束后，MPP 用于恢复之前的特权模式。 3. 青稞 V4 微处理器支持机器模式下的中断嵌套，进入异常和中断后，MIE 不会被清零。 ### 实际获取 可以使用封装好了的函数 ```c void HardFault_Handler(void) { uint32_t mcause __get_MCAUSE(); printf(\"mcause %d\\r\\n\", mcause); while (1) { } } ``` 在处理的最后使用mret进行返回, 这一个会使用mepc更新PC寄存器, 更新一下CS寄存器以及工作模式 在写这一个中断处理函数的时候如果使用的是C语言, 需要使用 使用硬件压栈的中断函数需要使用 MRS 或者其提供的工具链进行编译且中断函数需要采用 `__attribute__((interrupt(\"WCH Interrupt fast\")))`声明。 .使用软件压栈的中断函数采用`__attribute__((interrupt()))`声明。 ![image 20240804182522941](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408041825971.png) ![image 20240804182757318](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408041827358.png) > 使用\"WCH Interrupt fast\"的时候会改变这一个函数的返回指令, 使用interrupt()为空的时候会加上一系列的压栈以及出栈指令, 青稞v4可以使用硬件实现这一个功能 > > 硬件压栈支持嵌套，嵌套深度最大为 3 级。硬件压栈溢出后，若仍然允许更高优先级 的中断执行，则“现场”被保存至用户堆栈区。 > > 使用INTSYSCR寄存器进行控制 > > ![image 20240804183317394](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408041833448.png)"},"/note/嵌入式/基础知识/RISC-V体系/2024-6-30-02开发环境.html":{"title":"开发环境","content":" layout: post title: \"开发环境\" date: 2024 6 26 15:39:08 +0800 tags: RISC V # 开发环境 需要使用MounRiver Studio这一个集成开发环境 是一个基于Eclipse的集成开发环境 ![image 20240630153726318](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301537389.png) > MounRiver Studio(MRS)是一款面向嵌入式MCU的免费集成开发环境，提供了包括C编译器、宏汇编、链接器、库管理、仿真调试器和下载器等在内的完整开发方案。MRS同时支持RISC V和ARM内核开发,内置沁恒微、兆易创新等厂家MCU工程模板;界面上兼顾工程师的开发习惯并进行整体优化，工具链方面进行了定制开发，支持部分MCU厂家的扩展、自研指令。在兼容通用RISC V项目开发功能的基础上，MRS还集成了跨内核单片机工程转换接口，实现ARM内核项目到RISC V开发环境的一键迁移。 + 支持ARM和RISC V + 支持根据工程自动切换对应的芯片以及工具链 + 引用外部自定义的工具链 + 使用轻量级的C库以及printf函数 + 支持32, 64位的RISC V ISA, I/M/A/C/F指令集支持 + 跨单片机的工程迁移 + 项目文件一键打开, 导入 + 多线程编译 + 支持ISP + 支持汇编, C语言, c++ + 支持中英文 ## 创建项目 ![image 20240630155431526](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301554578.png) ![image 20240630155933070](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301559103.png) ![image 20240630160238701](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301602728.png) > 使用这一个进行编译,可以右键点击项目进行清理, ### 配置参数 Help > language 配置语言 ![image 20240630160556589](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301605626.png) ![image 20240630160821738](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301608806.png) ![image 20240630160911391](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301609455.png) ![image 20240630161009817](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301610878.png) ![image 20240630161129895](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301611948.png) > 可以在这里获取对应的数据 ## 运行调试 第一次调试的时候可以在这一个项目右键, 调试方式进行调试 之后可以直接使用![image 20240731193306305](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407311933353.png)进行调试 ![image 20240731223414618](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407312234662.png) 在这一模式的时候是按照汇编的单步进行调试的"},"/note/嵌入式/基础知识/RISC-V体系/2024-6-26-01RISC-V体系.html":{"title":"RISC-V体系","content":" layout: post title: \"RISC V体系\" date: 2024 6 26 15:39:08 +0800 tags: RISC V # RISC V体系 这是一个精简指令集计算机的架构, 这是一个开放的体系, 有可扩展性, 简洁高效, 广大运营商都有参与 ## 简介 ### CISC 复杂计算机指令集, 一条指令可以完成多个工作 里面有多种不同的寻址模式, 直接的, 间接的, 寄存器间接寻址 指令的长度是不同的, 使得解码变得复杂 内存频繁访问, 通常这一个需要频繁访问内存, 从而达到一个执行的效率比较低 使用更多的逻辑单元, 实现的成本和难度比较大 ### RISC 精简指令集, 非常简洁, 指令的长度一般都是一样的, 使得硬件的设计比较简单, 在执行的时候周期数比较固定 使用专门的指令访问内存, 提高执行的效率 寄存器优先, 推荐使用寄存器实现 在实际实现的时候使用模块化的思想, 可以根据需要进行添加指令集 编码的复杂度比较高 ## RISC V架构 通用开放的指令集架构, 这一个是第五代, 是一个免费的内核 指令的架构使用的是一个模块化的思想, 定义了一种所有的RISC V架构都需要使用的基础指令集, 包括基础的数据处理, 控制流程, 内存访问等, 同时可以进行拓展 基础指令集 + V: 首先，RISC V定义了一组基础指令，称为基础指令集（Base ISA），这是RISC V的核心部分，所有RISC V处理器都必须支持基础指令集。基础指令集包括执行基本的数据处理、控制流程和内存访问等操作所需的指令，提供了处理器的基本功能。 例如，针对32位处理器，该最小指令集为RV32I，针地64位处理器，其为RV64I 向量扩展, 支持定长向量 + M: 乘法拓展 + A: 原子操作, 支持原子访问内存和操作 + F: 浮点数拓展, 单浮点数运算 + C: 压缩指令拓展, 紧凑的指令编码格式 > 青稞处理器是[南京沁恒微电子股份有限公司](https://baike.baidu.com/item/南京沁恒微电子股份有限公司/24550581?fromModule lemma_inlink)基于开源RISC V指令集规范自研的32位处理器。 > > 青稞v4使用的是RV32IMACF, 支持RV32I, M, A, C, F ### 基金会以及厂商 [RISC V International – RISC V: The Open Standard RISC Instruction Set Architecture (riscv.org)](https://riscv.org/) 他的基金会的主要的作用是维护相关的标准 ![image 20240630101858095](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301018170.png) ![image 20240630102306930](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301023972.png) ![image 20240630102255397](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301022447.png) [riscv manual1.pdf · 语雀 (yuque.com)](https://www.yuque.com/office/yuque/0/2024/pdf/12764787/1708133080351 812da4ef faae 4d5b 88be 99bcec9e965c.pdf?from https%3A%2F%2Fwww.yuque.com%2Flishutong docs%2Frtos_riscv%2Fvdfrzlnfcc45wvpa) ![image 20240630102435332](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301024376.png) [riscv manual2.pdf · 语雀 (yuque.com)](https://www.yuque.com/office/yuque/0/2024/pdf/12764787/1708133080351 1da9a56a 9693 4d7c acc2 b6e0415a6fef.pdf?from https%3A%2F%2Fwww.yuque.com%2Flishutong docs%2Frtos_riscv%2Fvdfrzlnfcc45wvpa) ![image 20240630102511472](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301025504.png) [[SiFive Leading the RISC V Revolution](https://www.sifive.com/)](https://www.yuque.com/office/yuque/0/2024/pdf/12764787/1708133080351 1da9a56a 9693 4d7c acc2 b6e0415a6fef.pdf?from https%3A%2F%2Fwww.yuque.com%2Flishutong docs%2Frtos_riscv%2Fvdfrzlnfcc45wvpa) 一个厂商提供处理器的设计方案以及一些相关的工具 [Homepage Andes Technology](http://www.andestech.com/en/) 一个提供RISC V处理器IP的公司, 提供一系列低功耗嵌入式芯片, 有一些类似STM32的芯片GD32Vf103之类的 [专业RISC V处理器IP及解决方案公司 (nucleisys.com)](https://www.nucleisys.com/) [首页 南京沁恒微电子股份有限公司 (wch.cn)](https://www.wch.cn/) 主要使用的, 里面有青稞v4的内核, 是一个国内厂商, 之后主要是使用CH32V这一个进行学习 ## 青稞v4 青稞处理器是沁恒微电子自研的32位微处理器，遵循和兼容开源的RISC V指令集架构规范，并提供可选的功能扩展。支持IMAFC指令集和自定义压缩指令，并提供硬件压栈（HPE）、免表中断（VTF）、精简的两线和单线调试接口、“WFE”指令、物理内存保护（PMP）等特色功能，详细说明可参考[青稞微处理器手册](https://www.wch.cn/downloads/QingKeV4_Processor_Manual_PDF.html)。 ### 指令集 ![image 20240630104223962](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301042026.png) ![image 20240630104711986](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301047046.png) [QingKeV4处理器手册.PDF · 语雀 (yuque.com)](https://www.yuque.com/office/yuque/0/2024/pdf/12764787/1708133080361 c4c87a64 33bb 41a9 8dfc e5866ddd8744.pdf?from https%3A%2F%2Fwww.yuque.com%2Flishutong docs%2Frtos_riscv%2Fvdfrzlnfcc45wvpa) ![image 20240630104841061](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301048104.png) ![image 20240630105006593](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301050629.png) ![image 20240630105113584](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301051646.png) ### 特权模式 ![image 20240630105327321](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301053376.png) ### 控制寄存器 ![image 20240630105656611](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301056655.png) ### 中断和异常 ![image 20240630105722546](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301057606.png) > 同步指的是执行一条指令以后进入异常的情况, 异步是事件触发, 精确的可以获取实际发生的位置, 非精确可能会打断一条指令 ![image 20240630110002338](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301100386.png) ![image 20240630110113473](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301101624.png) 中断支持嵌套, 实际看起来和stm32差距不大 ### 内存保护 ![image 20240630143235797](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301432841.png) ![image 20240630142945273](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301429327.png) > 通股票`pmp<i>cfg`这一个寄存器设置某一块地址的权限以及模式和进不进行锁定, 通过`pmpaddr<i>`寄存器控制对应的位置, 和配置寄存器里面的某一位共同配置区域的大小 ### 系统时钟 ![image 20240630144042148](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301440194.png) > 可以使用这一个作为RTOS的系统时钟, 测量时间, 以及定时之类的功能 ### 睡眠模式 ![image 20240630144238440](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202406301442484.png) ## 开发板 [互联型青稞RISC V MCU CH32V307 南京沁恒微电子股份有限公司 (wch.cn)](https://www.wch.cn/products/CH32V307.html?) 实验室的名额 外校的研究所名额, 研究生办, 使用外校的名额 尝试一下芯片原厂, 挑战杯 + ODM公司, 技术处比较广, 实力强做Linux开发 + 芯片原厂"},"/note/嵌入式/基础知识/RISC-V体系/2024-8-5-07-其他组件.html":{"title":"其他组件","content":" layout: post title: \"其他组件\" date: 2024 8 5 15:39:08 +0800 tags: RISC V # 其他组件 ## Systick系统定时器 ![image 20240805151322504](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408051513534.png) ![image 20240805151344986](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408051513030.png) ![image 20240805151952443](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408051519490.png) > 在ch32v30x_rcc.h文件里面有相关的操控函数 > > 使用函数`RCC_GetClocksFreq`可以获取实际的时钟的频率 ### 中断 在Systick寄存器设置使能中断, 以及打开重装载, 同时使能NVIC的中断 在中断处理函数里面, 需要清除中断的标志位 ## 内存保护 最多支持4个物理区域的内存保护 权限包括读（R）、 写(W)、执行(X)属性，保护区域的长度最小可设置为 4 字节。PMP 模块在用户模式下一直生效，而在 机器模式下可通过锁定（L）属性，可选生效。 如果访问违反当前权限限制，将会触发产生异常中断。PMP 模块包括 4 组 8bit 的配置寄存器（一 组 32bit）和 4 组地址寄存器，所有的寄存器需要使用 CSR 指令在机器模式下访问。 ![image 20240812160919517](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408121609566.png) + pmp\\*cfg\\* ![image 20240812160945149](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408121609185.png) ![image 20240812161020669](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408121610694.png) + pmpaddr\\<i> ![image 20240812161123057](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408121611090.png) > 这里的y是实际写入的地址, 比如保护4字节的时候, 需要把这一个地址进行右移 ```assembly li t0, (0x20004000 >> 2) csrw 0x3b0, t0 li t0, (1<<0) (2<<3) (1<<7) csrw 0x3a0, t0 ``` ## 低功耗 青稞 V4 系列微处理器支持通过 WFI(Wait For Interrupt)指令进入睡眠状态，实现较低的静态 功耗。配合 PFIC 的系统控制寄存器（PFIC_SCTLR），能实现多种睡眠模式和 WFE 指令。 青稞 V4 系列微处理器可以通过两种方式进入睡眠，即等待中断（Wait for Interrupt，WFI）和 等待事件（Wait For Event，WFE）。WFI 方式是指微处理器进入睡眠后，等待中断来唤醒，醒来后 进入相应的中断中去执行。WFE 方式是指微处理器进入睡眠后，等待事件来唤醒，醒来后继续执行之 前停止的程序流。 标准的 RISC V 支持 WFI 指令，直接执行 WFI 命令，即可通过 WFI 方式进入睡眠。而对于 WFE 方 式，系统控制寄存器 PFIC_SCTLR 中 WFITOWFE 位用于控制将之后的 WFI 指令当做 WFE 处理，实现 WFE 方式进入睡眠。 ### 唤醒 + WFI方式进入睡眠后，可由以下方式唤醒： 微处理器可被中断控制器响应的中断源唤醒，唤醒后，微处理器先执行中断函数。 进入睡眠模式，调试请求可以使微处理器唤醒，进入深度睡眠，调试请求无法唤醒处理器。 + WFE方式进入睡眠后，微处理器可被下面的方式唤醒： 内部或外部的事件，此时无需配置中断控制器，唤醒后继续执行程序。 若使能某中断源，产生中断时微处理器被唤醒，唤醒后，微处理器先执行中断函数 若配置PFIC_SCTLR中的SEVONPEND位，中断控制器不使能中断下，但产生新的中断挂起 信号时（之前产生的挂起信号不生效）也可以使微处理器唤醒，唤醒后需要手动清除相应的 中断挂起标志。 进入睡眠模式调试请求可以使微处理器唤醒，进入深度睡眠，调试请求无法唤醒微处 理器。 ### 深度睡眠 根据 PFIC_SCTLR 中 SLEEPDEEP 位控制睡眠的深度： + 若PFIC_SCTLR寄存器中的SLEEPDEEP清零，微处理器进入睡眠模式，除SysTick及部分唤醒逻 辑外的内部单元时钟允许被关闭。 + 若PFIC_SCTLR寄存器中的SLEEPDEEP置位，微处理器进入深度睡眠模式，所有单元时钟均允 许被关闭。"},"/note/嵌入式/基础知识/RISC-V体系/2024-7-31-03内核.html":{"title":"内核","content":" layout: post title: \"内核\" date: 2024 6 26 15:39:08 +0800 tags: RISC V # 内核 ## 寄存器 ### 通用寄存器 有32个寄存器, 每一个是32位, x0 x31进行表示, x0是不可写的, 总是为0, 其余的寄存器是可写的 ![image 20240731224252939](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407312242994.png) > 浮点寄存器的个数也是32个, ABI指的是Application binary Interface, 这个名字是可以在汇编里面使用的名字 ### CSR寄存器 用于控制以及记录运行的状态 ![image 20240731224943541](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407312249611.png) > 带有M的寄存器只有在机器模式下面才可以进行访问 > > D是在调试的时候才可以访问 ![image 20240731225146332](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407312251365.png) ### 程序计数器 Program Counter(PC)记录当前程序的位置, 这一个寄存器不可以直接进行读写, 需要通过其他的指令间接的操作 ### 栈 从高地址向地地址进行增长, 没有特定的压栈以及出栈的指令, 使用SP加减之后写入内存的方式, 每一个单元是4字节 ![image 20240731225517238](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407312255275.png) > SP也就是x2寄存器 ## 大小端 青稞使用的是小端的处理方式, 低有效位的字节优先存储比如0x12345678在内存里面是78 56 34 12 ## 指令集 使用的额指令集是RV32IMAC ![image 20240731225855896](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407312258996.png) 支持RV32I, 支持乘除法M,原子运算A, 压缩C ## 启动方式 ![image 20240801152536592](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408011525623.png) 启动模式不同，程序闪存存储器、系统存储器和内部 SRAM 有着不同的访问方式： + 从程序闪存存储器启动时，程序闪存存储器地址被映射到 0x00000000 地址区域，同时也能够在 原地址区域 0x08000000 访问。 + 从系统存储器启动时，系统存储器地址被映射到 0x00000000 地址区域，同时也能够在原地址区 域 0x1FFF8000 访问。 + 从内部 SRAM 启动，只能够从 0x20000000 地址区域访问。 对于 CH32F20x 系列产品，在此区域启 动时，需要通过 NVIC 控制器设置向量表偏移寄存器，重映射向量表到 SRAM 中。对于 CH32V20x、 CH32V30x 和 CH32V31x 系列产品无需此动作。 ![image 20240801153555061](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408011535098.png) ![image 20240801153625437](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408011536474.png) ## 存储器 ![image 20240801152855829](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408011528906.png) 内置最大 128K 字节的 SRAM，起始地址 0x20000000，支持字节、半字（2 字节）、全字（4 字节） 访问。 内置最大 480K 字节的程序闪存存储区（CodeFlash），用于存储用户应用程序。 内置 28K 字节的系统存储器（bootloader），用于存储系统引导程序（厂家固化自举加载程序）。 内置 128 字节空间用于厂商配置字存储，出厂前固化，用户不可修改。 内置 128 字节空间用于用户选择字存储。 ![image 20240801154441639](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408011544666.png)"},"/note/嵌入式/外设/2024-1-10-15音频编解码VS1053等.html":{"title":"音频编解码VS1053/ES8388/VS1053","content":" layout: post title: \"音频编解码VS1053/ES8388/VS1053\" date: 2024 1 10 15:39:08 +0800 tags: stm32 # 音频编解码VS1053/ES8388/VS1053 ![image 20240110174954722](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401101749784.png) ## VS1053 ![image 20240110175509788](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401101755849.png) ### 引脚 ![image 20240110175902323](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401101759381.png) ![image 20240110180227180](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401101802239.png) ### 命令时序 ![image 20240110180647640](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401101806705.png) ![image 20240110180735938](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401101807998.png) ### 寄存器 ![image 20240110180814133](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401101808192.png) ![image 20240110180953464](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401101809541.png) ![image 20240110181221293](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401101812349.png) ![image 20240110181500862](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401101815924.png) ![image 20240110181543538](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401101815591.png) ![image 20240110181659304](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401101816345.png) ![image 20240110181940299](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401101819359.png) ### 原理图 ![image 20240110184728844](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401101847938.png) ![image 20240110184811368](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401101848430.png)"},"/note/嵌入式/外设/2024-1-1-Flash-W25Q64.html":{"title":"Flash W25Q64","content":" layout: post title: \"Flash W25Q64\" date: 2024 1 1 15:39:08 +0800 tags: stm32 # Flash W25Q64 ## Flash 常用的存储器件, 有一个物理特性就是只能写0, 不能写1, 可以进行擦除 主要有两种, NOR Flash 和NAND Flash ![image 20240101105457598](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401011054629.png) ## FLashW25Q64 8M字节, nor flash, 支持双线和四线SPI, 标准模式104Mbit/s ![image 20230705113847085](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401011052826.png) DO: MISO DI: MDIO /CS: 片选 /WP: 写保护 /HOLD: 暂停通讯 CLK: 时钟 Standard SPI instructions use the unidirectional DI (input) pin to serially write instructions, addresses or data to the device on the rising edge of the Serial Clock (CLK) input pin. Standard SPI also uses the unidirectional DO (output) to read data or status from the device on the falling edge CLK. (可以使用模式0或者模式3) ![image 20230705120249483](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401011052864.png) > W25Q64分为128个块, 每个块64kb, 块又分为16个扇区, 每一个4kb, 在写入的数据之前需要进行擦除, 只能把为1的数据位改为0, 擦除的时候只能按照最小的单元进行, 在写入的时候没有限制, 为nor Flash, nand Flash需要以扇区进行写入 ![image 20240101105932922](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401011059979.png) > 擦除的时候单位可以是扇区, 块, 或者整个片 > > 写的时候是页写 有一个状态寄存器, BUSY位为忙状态 ![image 20230705123108519](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401011052764.png) + 实际读写 ![image 20240101110313682](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401011103721.png) ![image 20230705123255295](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401011052887.png) ![image 20230705173533798](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401011052870.png) > 带括号的为返回值 擦除, 0x20之后发送三字节的地址 写入, 0x02 ![image 20230705124123214](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401011052766.png) > 几个id可以读取, 用来验证是否连接成功 ![image 20230705124036127](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401011052401.png) ![image 20240101110736419](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401011107475.png) ![image 20240101110813146](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401011108201.png) ![image 20240101110850188](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401011108250.png) ![image 20240101111620730](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401011116799.png) ![image 20240101111936481](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401011119540.png) ![image 20240101112057605](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401011120659.png) ### 开发板情况 ![image 20230705135254082](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401011052615.png) > 指南者CS连接PC0 ![image 20240101105812580](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401011058618.png) ## QSPI模式 ![image 20240103150256723](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401031502793.png) ![image 20240103201116549](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401032015933.png) > QE位就是控制是不是使用的QSPI模式 > > 四字节地址使用的是W25Q256, 使用32位的地址 ![image 20240103201454566](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401032014666.png) ![image 20240103201808617](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401032018719.png) ![image 20240103202001887](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401032020997.png) ![image 20240103202145861](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401032021931.png) ![image 20240103202256014](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401032022110.png) ![image 20240103202443193](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401032024269.png)"},"/note/嵌入式/外设/2024-1-6-11-2.4G通信nrf24l01.html":{"title":"温湿度传感器DHT11","content":" layout: post title: \"温湿度传感器DHT11\" date: 2024 1 5 15:39:08 +0800 tags: stm32 # 2.4G通信nrf24l01 低功耗芯片, 使用SPI进行通信 ![image 20240106123415250](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061234340.png) > https://gitee.com/alicedodo/nRF24L01P_internals/wikis/ ## 引脚 ![image 20240106123913552](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061239675.png) ## 时序 ![image 20240106124141785](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061241847.png) ![image 20240106124302771](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061243837.png) ![image 20240106124420968](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061244039.png) ![image 20240106124441711](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061244767.png) ## 命令 ![image 20240106124741829](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061247889.png) ## 工作模式 ![image 20240106125132236](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061251298.png) ![image 20240106125359483](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061253560.png) ![image 20240106134836268](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061348342.png) ## 寄存器 ![image 20240106140539647](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061405712.png) ![image 20240106141035217](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061410277.png) > MASK_RX_DR: 接收中断 > > MASK_TX_DS: 发送中断, 发送完并且接收到回应 > > MASK_MAX_RT: 最大重发次数中断 ![image 20240106151840840](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061518899.png) ![image 20240106151902910](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061519959.png) ![image 20240106151931140](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061519179.png) ![image 20240106152038757](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061520816.png) ![image 20240106152109264](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061521310.png) ![image 20240106152227088](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061522148.png) ![image 20240106152336751](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061524808.png) ![image 20240106152633706](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061526766.png) ## 实际使用 ![image 20240106134943496](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061349572.png) ![image 20240106135330011](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061353080.png) ```c //初始化 void nrf24l01_tx_mode( void ) {\t \tNRF24L01_CE ( 0 ); \t \t/* 发去哪里？ */\t \tnrf24l01_write_buf ( NRF_WRITE_REG + TX_ADDR, (uint8_t *)TX_ADDRESS, TX_ADR_WIDTH ); \t/* 哪里接收应答信号？ */ \tnrf24l01_write_reg ( NRF_WRITE_REG + RX_ADDR_P0, (uint8_t *)TX_ADDRESS, TX_ADR_WIDTH ); \tnrf24l01_write_reg ( NRF_WRITE_REG + EN_AA, 0x01);\t\t/* 使能通道0的自动应答 */ \tnrf24l01_write_reg ( NRF_WRITE_REG + EN_RXADDR, 0x01);\t/* 使能通道0的接收地址 */ \t/* 发送失败如何处理？ */ \tnrf24l01_write_reg ( NRF_WRITE_REG + SETUP_RETR, 0x1a);\t/* 设置自动重发间隔时间 */ \t/* 无线条件怎么样？*/ \tnrf24l01_write_reg ( NRF_WRITE_REG + RF_CH, 0x01); \t\t/* 设置RF通信频率 */ \tnrf24l01_write_reg ( NRF_WRITE_REG + RF_SETUP, 0x01); \t/* 设置TX发射参数 */ \t/* 如何配置身份？*/ \tnrf24l01_write_reg ( NRF_WRITE_REG + CONFIG, 0x0e);\t\t/* 配置基本工作模式参数 */ NRF24L01_CE ( 1 );\t\t\t } ``` ```c //发送数据 uint8_t nrf24l01_tx_packet(uint8_t *ptxbuf) {\t \tuint8_t sta, rval 0xff; \tNRF24L01_CE ( 0 );\t\t\t nrf24l01_write_buf ( WR_TX_PLOAD, ptxbuf, TX_PLOAD_WIDTH );\t/* 写数据到TX_FIFO */ NRF24L01_CE ( 1 );\t\t\t/* 启动传输 */ \twhile (NRF24L01_IRQ ! 0); \tsta nrf24l01_read_reg(STATUS);\t\t\t\t\t /* 读取状态寄存器的值 */ \tnrf24l01_write_reg(NRF_WRITE_REG + STATUS, sta);\t /* 清除TX_DS或MAX_RT中断标记 */ \tif ( sta & MAX_TX) { \t /* 达到最大重发次数 */ \t\tnrf24l01_write_reg(FLUSH_TX, 0xff);\t//清除FIFO \t\trval 1;\t \t}\t \tif ( sta & TX_OK)\t\trval 0;\t/* 发送完成 */ \treturn rval;\t\t/* 返回结果*/ } ``` ![image 20240106140119182](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061401245.png) ![image 20240106140204830](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061402899.png) ```c //配置接收模式 void nrf24l01_rx_mode( void ) {\t \tNRF24L01_CE ( 0 ); \t \t/* 接收谁的数据 */\t nrf24l01_write_buf ( NRF_WRITE_REG + RX_ADDR_P0, (uint8_t *)RX_ADDRESS, RX_ADR_WIDTH ); nrf24l01_write_reg ( NRF_WRITE_REG + EN_RX_ADDR, 0x01); \t/* 使能通道0的接收地址 */ \tnrf24l01_write_reg ( NRF_WRITE_REG + RX_PW_P0, RX_PLOAD_WIDTH); \t/* 选择通道0的有效数据宽度 */ \t/* 如何发送应答信号？ */ \tnrf24l01_write_reg ( NRF_WRITE_REG + EN_AA, 0x01);\t\t/* 使能通道0的自动应答 */ \t/* 无线条件怎么样？*/ \tnrf24l01_write_reg ( NRF_WRITE_REG + RF_CH, 0x01); \t\t/* 设置RF通信频率 */ \tnrf24l01_write_reg ( NRF_WRITE_REG + RF_SETUP, 0x01);\t/* 设置TX发射参数 */ \t/* 如何配置身份？*/ \tnrf24l01_write_reg ( NRF_WRITE_REG + CONFIG, 0x0f); \t\t/* 配置基本工作模式参数 */ \tNRF24L01_CE ( 1 );\t\t\t } ``` ```c //接收数据 uint8_t nrf24l01_rx_packet(uint8_t *prxbuf)\t\t /* return 0:succeed\t1:fail */ {\t \tuint8_t sta, rval 1; \tsta nrf24l01_read_reg(STATUS);\t\t\t\t\t /* 读取状态寄存器的值 */ \tnrf24l01_write_reg(NRF_WRITE_REG + STATUS, sta);\t /* 清除RX_DS标记 */ \tif ( sta & RX_OK)\t \t/* 接收到数据 */ \t{ \t \t\t \t\tnrf24l01_read_buf(RD_RX_PLOAD, prxbuf, RX_PLOAD_WIDTH); \t/* 读取数据 */ \t\tnrf24l01_write_reg(FLUSH_RX, 0xff);\t /* 清除RX_FIFO */ \t\trval 0;\t \t}\t \treturn rval;\t\t/* 返回结果*/ } ```"},"/note/嵌入式/外设/2023-12-31-02磁力计ST480MC.html":{"title":"磁力计ST480MC","content":" layout: post title: \"磁力计ST480MC\" date: 2023 6 20 15:39:08 +0800 tags: stm32 # 磁力计ST480MC ![image 20231231164233962](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312311642108.png) ![image 20231231164929637](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312311649713.png) ![image 20231231165246779](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312311652831.png) ![image 20231231165349064](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312311654842.png) > 由于这一种封装没有中断引脚, 所以可以通过计算转换一次需要的时间, 然后进行获取 ![image 20231231170029576](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312311700647.png) ![image 20231231170623613](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312311706675.png) ![image 20231231170829528](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312311708589.png) ![image 20231231170927200](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312311709245.png) ![image 20231231173450479](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312311734542.png) > 实际RM返回的字节数是2*D[1:0] + 2 ![image 20231231174000473](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312311740530.png) ![image 20231231174202178](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312311742235.png) ![image 20231231174910891](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312311749990.png) ## 磁场检测 用于检测偏航角, 但是会受到外部的磁场的干扰"},"/note/嵌入式/外设/2024-1-7-14SD卡.html":{"title":"SD卡","content":" layout: post title: \"SD卡\" date: 2024 1 6 15:39:08 +0800 tags: stm32 # SD卡 ## 简介 SD卡的名字是Secure Digital Card 安全数字卡, 实际上就是nand flash加上控制芯片 只要有三种full size sd卡, Micro SD卡, 还有MiniSD卡 最常用的就是Micro SD卡 是在MMC卡的基础上面发展来的, 遵守的是SD协议, 下面使用的2.0版本的协议, 支持32G容量 容量大, 高安全性, 体积小, 传输速度快, 接口简单 ![image 20240107220417205](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401072204265.png) ![image 20240107220507955](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401072205023.png) ![image 20240107220917154](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401072209230.png) ![image 20240107221021830](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401072210915.png) ![image 20240107222241497](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401072222583.png) ## 寄存器 ![image 20240107222709694](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401072227774.png) ![image 20240107222818446](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401072228516.png) ![image 20240107223229648](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401072232726.png) ## SDIO模式 ### 常用的命令 ![image 20240107223901006](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401072239082.png) ![image 20240107224049323](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401072240406.png) ![image 20240107224309812](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401072243882.png) ![image 20240107225131594](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401072251681.png) > RCA就是相对地址 ### 响应 ![image 20240107225301911](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401072253984.png) ![image 20240107225453227](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401072254300.png) ![image 20240107225544390](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401072255463.png) ![image 20240107225633702](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401072256767.png) ### 操作模式 ![image 20240108110949895](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081109010.png) ![image 20240108111542740](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081115810.png) ![image 20240108112235995](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081122061.png) ![image 20240108112633096](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081126166.png) ![image 20240108112751691](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081127745.png) ![image 20240108112809095](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081128151.png) ![image 20240108112913176](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081129215.png) ![image 20240108113121040](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081131097.png) ## SPI模式 ### 命令 ![image 20240108113633384](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081136446.png) ![image 20240108113856113](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081138179.png) ![image 20240108114058082](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081140143.png) ![image 20240108114709431](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081147503.png) > CMD9会在接收到respond之后返回16字节的CSD ### 相应 ![image 20240108114832934](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081148998.png) ![image 20240108115229476](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081152539.png) ![image 20240108115345960](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081153017.png) ### 数据Token ![image 20240108115637988](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081156058.png) > 主要通过返回的Token检查数据是否被正常接收 ![image 20240108115845745](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081158816.png) ### 实际通信 ![image 20240108120105929](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081201007.png) ### 各种模式 ![image 20240108121842550](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081218613.png) ![image 20240108125541746](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081255847.png) ![image 20240108125604050](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081256109.png) ![image 20240108125710814](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081257874.png) ![image 20240108125731821](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081257875.png) > 需要等待MISO的状态变化, 标志着数据已经写入了 ![image 20240108130025768](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081300830.png) ## 编程实战 ### SPI模式 ![image 20240108130358447](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081303501.png) ![image 20240108130438220](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081304318.png) #### 计算容量 获取csd寄存器值, 根据不同版本进行计算 ```c /** * @brief 获取SD卡的总扇区数(扇区数) * @note 每扇区的字节数必为512, 如果不是512, 则初始化不能通过 * @param 无 * @retval SD卡容量(扇区数), 换成字节数要 * 512 */ uint32_t sd_get_sector_count(void) { uint8_t csd[16]; uint32_t capacity; uint8_t n; uint16_t csize; if (sd_get_csd(csd) ! 0) /* 取CSD信息，如果期间出错，返回0 */ { return 0; /* 返回0表示获取容量失败 */ } /* 如果为SDHC卡，按照下面方式计算 */ if ((csd[0] & 0xC0) 0x40) /* V2.00的卡 */ { /* V2.0卡 计算容量的公式 * memory capacity (C_SIZE+1) * 512K byte 这个相当于2^19 扇区数：memory capacity / 512byte 即 / 2^9 */ /* C_SIZE低8位 C_SIZE中8位 C_SIZE高6位 */ csize csd[9] + ((uint16_t)csd[8] << 8) + ((uint32_t)(csd[7] & 63) << 16) + 1; capacity (uint32_t)csize << 10; /* 得到扇区数 */ } else /* V1.XX的卡 / MMC V3卡 */ { /* V1.0卡 计算容量的公式 * memory capacity BLOCKNR * BLOCK_LEN (C_SIZE+1)*MULT * (2^READ_BL_LEN) (C_SIZE+1)*(2^(C_SIZE_MULT+2)) (C_SIZE+1)*(2^(C_SIZE_MULT+2+READ_BL_LEN)) 扇区数：memory capacity / 512byte 即 / 2^9 */ /* READ_BL_LEN C_SIZE_MULT后1位 C_SIZE_MULT前2位 (移位操作是重新组合数据) */ n (csd[5] & 15) + ((csd[10] & 128) >> 7) + ((csd[9] & 3) << 1) + 2; /* C_SIZE低2位 C_SIZE中8位 C_SIZE高2位 (移位操作是重新组合数据) */ csize (csd[8] >> 6) + ((uint16_t)csd[7] << 2) + ((uint16_t)(csd[6] & 3) << 10) + 1; /* 公式中的（C_SIZE+1） */ capacity (uint32_t)csize << (n 9); /* 得到扇区数 */ } return capacity; /* 注意这里返回的是扇区数量, 不是实际容量的字节数, 换成字节数 得 * 512 */ } ``` ### SDIO模式 ![image 20240108174155984](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081741058.png) ![image 20240108174312666](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081743721.png) > 在初始化的时候设置的分频参数直接设置为正常情况下的参数就可以了, 因为在进行初始化的时候会调用函数HAL_SD_InitCard, 在这个函数里面会使用一个新的结构设置时钟为初始化的时钟, 使用默认的配置实现 > > 之后会在函数SD_PowerON函数里面进行初始化发送命令, 根据不同的版本进行不同的操作, 发送命令ACMD41获取电压信息是否匹配, 以及获取SD卡的大小 > > 然后调用SD_InitCard, 发送CMD2, CMD3, CMD9获取相对地址等信息 > > 最后按照我们的配置进行设置时钟速度等"},"/note/嵌入式/外设/2024-1-5-08游戏手柄.html":{"title":"游戏手柄","content":" layout: post title: \"游戏手柄\" date: 2024 1 5 15:39:08 +0800 tags: stm32 # FC游戏手柄 又称为红白机, 小霸王游戏机, 大致分为两种, 一种是11针, 还有一种是9针, 可以和DR9的串口头对插 ![image 20240105202446597](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401052024779.png) ![image 20240105202719601](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401052027670.png) ```c uint8_t joypad_read(void) { \tvolatile uint8_t temp 0; \t \tuint8_t t; \tJOYPAD_LAT(1);\t\t/* 锁存当前状态 */ \t joypad_delay(80); \tJOYPAD_LAT(0); \tfor (t 0; t < 8; t++) \t\t/* 移位输出数据*/ \t{ \t\ttemp >> 1; \t\tif (JOYPAD_DATA 0) \t\t{ \t\t\ttemp 0x80;\t /* LATCH之后，就得到第一个数据*/ \t\t} \t\tJOYPAD_CLK(1); \t\tjoypad_delay(80); \t\tJOYPAD_CLK(0); \t\tjoypad_delay(80); \t} \treturn temp; \t\t\t } ``` ![image 20240105203012778](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401052030807.png) ![image 20240105203339903](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401052033070.png)"},"/note/嵌入式/外设/2023-12-31-03六轴传感器SH3001.html":{"title":"六轴传感器SH3001","content":" layout: post title: \"六轴传感器SH3001\" date: 2023 6 20 15:39:08 +0800 tags: stm32 # 六轴传感器SH3001 使用的是MEMS(微机电系统)技术 3轴加速度传感器可以获取设备在X、Y和Z轴上的加速度数据，用于检测设备的运动状态和倾斜角度；而3轴陀螺仪传感器可以获取设备在X、Y和Z轴上的角速度数据，用于检测设备的旋转状态和角度变化。 ![image 20231231203001251](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312312030701.png) ![image 20231231203247913](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312312032972.png) ![image 20231231203743961](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312312037037.png) ![image 20231231203941258](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312312039323.png) ![image 20231231211619946](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312312116000.png) ![image 20231231211950107](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312312119178.png) > Temperature (oC) (TEMP DATA ROOM TEMP)/16 + 25 ![image 20231231213508410](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312312135468.png) ![image 20231231215155175](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312312151222.png) ![image 20231231215629827](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312312156889.png) ![image 20231231221301376](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312312213431.png) ## 姿态解算 ![image 20231231223428427](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312312234519.png) > 使用的坐标系主要有三种, 分别是地球坐标系(坐标轴位于地球的中心), 地理坐标系(坐标轴位于地球的表面), 载体坐标系(和载体重合) ![image 20231231223458563](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312312234634.png) ![image 20231231223708313](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312312237376.png) ![image 20231231223933056](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312312239118.png) ![image 20231231224132977](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312312241070.png) ![image 20231231224225777](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312312242845.png) ![image 20231231224323985](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312312243088.png) ![image 20231231224733754](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312312247816.png) ![image 20231231224833743](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312312248804.png) ![image 20231231224939477](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312312249540.png) ![image 20240101092641427](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401010926559.png) ![image 20240101092955578](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401010929648.png) ## 基础知识 [MPU6050姿态解算2 欧拉角&旋转矩阵 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/195683958) > [3维旋转矩阵推导与助记 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/183973440) > [欧拉角旋转 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/186299280) **绕X轴** ![img](https://pic1.zhimg.com/80/v2 0e0a8be32cb4cd9ccd8447127fc530e2_720w.webp) **绕Y轴** ![img](https://pic1.zhimg.com/80/v2 7110db8e23efd90395581335c40598e0_720w.webp) **[绕Z轴](https://zhida.zhihu.com/search?content_id 129016364&content_type Article&match_order 4&q 绕Z轴&zhida_source entity)** ![img](https://pic4.zhimg.com/80/v2 2a0bcfe94b75414c2c8729b2dc8d7b41_720w.webp) ![动图](https://pic2.zhimg.com/v2 7cae68055445721f53553800d9c42c7f_b.webp) 欧拉角是一种表示[三维旋转](https://zhida.zhihu.com/search?content_id 129532898&content_type Article&match_order 1&q 三维旋转&zhida_source entity)的描述方法，欧拉角的计算需要借助旋转矩阵，关于旋转矩阵的知识 实际上，对于夹角的顺序和标记，夹角的两个轴的指定，并没有明确的规定。因此当用到[欧拉角](https://zhida.zhihu.com/search?content_id 129532898&content_type Article&match_order 6&q 欧拉角&zhida_source entity)时，需要明确地表示出夹角的顺序，指定其参考轴。合法的欧拉角组中，唯一的限制是，任何两个连续的旋转，必须绕着不同的转动轴旋转。 对于在三维空间里的一个**参考系**，任何**坐标系**的取向，都可以用三个欧拉角来表现。 **参考系**又称为实验室参考系，是静止不动的，可以先简单的理解理解为**大地坐标系**，也称**[惯性坐标系](https://zhida.zhihu.com/search?content_id 129532898&content_type Article&match_order 1&q 惯性坐标系&zhida_source entity)**。 **坐标系**则固定于刚体，随著刚体的旋转而旋转，比如**飞行器自身的坐标系**，也称**[载体坐标系](https://zhida.zhihu.com/search?content_id 129532898&content_type Article&match_order 1&q 载体坐标系&zhida_source entity)**。 另外，**横滚roll，俯仰pitch，偏航yaw**的实际含义如下图： ![动图封面](https://pic3.zhimg.com/v2 69bc85754c2955ba92206fcba2d45cf2_b.jpg) ## 加速度计以及陀螺仪 在使用陀螺仪的时候静止状态会存在误差, 受到时间影响, 加速度计在运动的时候不会受到影响 可以使用算法调整不同状态下的数据占比 1. 加速度数据：反映设备在三个轴上的加速度大小和方向，可以用来判断设备的运动状态（如静止、运动加速、减速等）以及姿态角度。 2. 陀螺仪数据：反映设备在三个轴上的角速度大小和方向，可以用来判断设备的旋转状态以及角度变化。 ### 陀螺仪获取个方向速度 使用这一个可以利用重力进行测算, 但是无法获取偏航角, 无法区分重力以及外部加速度, 震动的情况下误差比较大 当加速度计水平放置，即Z轴竖直向上时，Z轴可以读到1g的数值（g为重力加速度），X轴和Y轴两个方向读到0，可以记作（0，0，g）。 当加速度计旋转一定的姿态时，重力加速度会在加速度的3个轴上产生相应的分量，其**本质是大地坐标系下的（0，0，g）在新的加速度计自身坐标系下的坐标**，加速度计读到的3个值就是（0，0，g）向量的新坐标。 姿态的旋转选用ZYX顺序的3次旋转方式，则上述描述可表示为： ![img](https://pic3.zhimg.com/80/v2 3dc75acdc5b5e64f2af9b3fb28b368de_720w.webp) 解这个方程，可以得到roll和pitch角（由于绕Z旋转时，感受到的重力加速度是不变的，因此加速度计无法计算yaw角） ![img](https://pic3.zhimg.com/80/v2 0c08fbd578d1aa64ea64c617c6eac39a_720w.webp) ### 加速度计算位置变化 陀螺仪测量的绕3个轴转动的角速度，因此，对角速度积分，可以得到角度。陀螺仪的英文简写为gyro，下面用**首字母g**代表陀螺仪数据。 如下图，IMU在第n个时刻的姿态角度为r、p、y，其含义为IMU坐标系从初始位置，经过绕Z旋转y角度，绕Y旋转p角度，绕X旋转r角度，得到了最终的姿态，此时需要计算下一个时刻(n+1)的姿态。设n+1时刻的姿态角为r+Δr、p+Δp、y+Δy，该姿态也是经历了3次旋转。要想计算n+1时刻的姿态，只要在n时刻姿态的基础上，加上对应的姿态角度变化量即可。姿态角度的变化量可以通过角速度与采用时间周期积分即可。 ![img](https://pic2.zhimg.com/80/v2 b8e2f588258c2297a06bb2dca7381e8f_720w.webp) 每一次的变化是在上一次变化的结果上进行的 ![img](https://pic4.zhimg.com/80/v2 8f9e706d1378f9aa57b57320c1d48c5d_720w.webp) 在使用加速度进行计算积分的时候会出现误差, 这个时候计算的时间越短获取的数据的误差越小(获取的加速度是一个瞬时量), 还有一个问题是本身的误差会进行积累(累积误差), 为了避免这一种误差, 可以引入监测倾角的传感器(水平仪), 可以使用一个检测横滚角以及俯仰角, 偏航角使用这一个无法检测 > 由上面的分析可知，**加速度计**在静止时刻，根据感受到的重力加速度，可以计算出roll和pitch角，并且角度计算只与当前姿态有关。而**陀螺仪**是对时间间隔内的角速度积分，得到每一次的角度变换量，累加到上一次的姿态角上，得到新的姿态角，陀螺仪可以计算roll、pitch、yaw三个角。 > > ![img](https://pic1.zhimg.com/80/v2 b2bb643d59b3f143b7555074e4d5b3b6_720w.webp)"},"/note/嵌入式/外设/2023-7-13-18触摸屏.html":{"title":"触摸屏","content":" layout: post title: \"触摸屏\" date: 2023 7 13 15:39:08 +0800 tags: stm32 # 触摸屏 电阻触摸屏只能一次一个点, 电容屏可以有多个 + 电阻屏: 有两层均匀的电阻叫做ITO层, 有间隔点隔开, 受到压力的时候会接触, 在接触点链接, 使得电阻变化, 一般会引出四根线, X+, X , Y+, Y , 分别检测电阻, x和y分开时间供电, 一侧供电, 另一侧检测电压, 使用ADC进行检测, 也可以使用专门的芯片进行检测 触摸校准: 由于硬件的信息不同, 需要校准, 有四线吗五线, 七线, 八线 ![image 20240104183720715](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041837773.png) + 电容屏: 直接可以得出触点的坐标, 也是用ITO层, X轴Y轴不导电, 之间产生电容, 平时对X轴产生一个波动信号, 当手放上的时候, 会对电路分流, 使得Y达到电压阈值的时间变大, 轮流通电, 同时检测, 可以得到实际的位置 会在交叉的位置形成电容, 电容的位置就是他的坐标 1. 表面电容型, 利用电场感应触摸, 只能识别一次 ![image 20230713181001349](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281048085.png) 2. 投射式, 利用触摸屏电极发射出静电场线, 有两种电容 自我电容: 扫描电极与地构成的电容 交互电容: 玻璃表面横向纵向的ITO电极交叉处形成的电容 ![image 20240104180825757](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041808828.png) ![image 20240104184036221](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041840353.png) + 红外线式 + 表面声波 ## 实现 ![image 20240104184224558](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041842606.png) ![image 20230713181852133](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281048086.png) 一边链接电阻屏, 另一边链接stm32, PENDIRQ, 有信号之后产生信号, AUX电压辅助通道不使用，PENIRQ 变低并作为处理器的中断信号 ![image 20240104184658876](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041846924.png) ### 控制原理 4线触摸屏控制器, 使用SPi接口, 内部有一个12位分辨率的ADC, 125KHz, 是一个逐步逼近性的AD转换器 实际上是一个十二位的ADC, 最大为4096, 通过比例获得位置, 使用内部电压源, 通过发送命令获得数据 ![image 20230713182801896](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281048087.png) 7: 准备开始检测 6 4: ![image 20230713191549154](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281048089.png) 3: 检测的模式 2: 设置为0, 1的时候使用AUX引脚 1 0: 节省电源, 设置为00的时候会在获取数据的时候再去产生电场 设置为0x90, 获取X通道数字, 0xD0获取Y的数字 ![image 20230713192050741](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281048090.png) > 使用软件SPI ![image 20231026185527854](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281048091.png) ![image 20240104184904794](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041849823.png) > 首先发送一个命令, 之后会获得对应的数据, 在实际接受的时候使用16位进行接收 ![image 20231026185602822](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281048092.png) ![image 20231026185823730](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281048093.png) > 首选的是差分工作模式, 这时候找到对应的A2 A0的表 ![image 20231026185835391](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281048094.png) > 选择00, 在两次测量之间会进行自动断电 ![image 20231026221557923](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281048095.png) > 实际使用的是001和101 ![image 20240104185503851](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041855878.png) > ```c > #define\t XPT2046_CHANNEL_X \t 0x90 \t //通道Y+的选择控制字 > #define\t XPT2046_CHANNEL_Y \t 0xd0\t //通道X+的选择控制字 > ``` > > 在读取X轴坐标的时候打开Y驱动, 把X轴的驱动关闭0x90 >10010000 > > 读取Y轴坐标的时候打开X轴的驱动, 0xd0 >11010000 > > ![image 20231026222352678](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310262324203.png) ```c //发送命令 void XPT2046_SendCMD(uint8_t cmd)\t { \tuint8_t i; \t \t/*设置引脚的初始状态*/ \tXPT2046_CS_ENABLE();//片选引脚设置为低电平 \tXPT2046_CLK_LOW();//时钟为低电平 \tXPT2046_MOSI_0(); \t \t/*片选选中*/ \tXPT2046_DelayUS(10); \tXPT2046_CS_DISABLE(); \t \t/*产生8个时钟，发送数据*/ \tfor(i 0;i<8;i++) \t{ \t\tif( (cmd & (0x80>>i)) 0 ) \t\t{ \t\t\tXPT2046_MOSI_0(); \t\t} \t\telse \t\t{ \t\t\tXPT2046_MOSI_1();\t\t \t\t}\t\t \t\t \t\tXPT2046_CLK_HIGH();\t\t \t\tXPT2046_DelayUS(5); \t\t\t \t\tXPT2046_CLK_LOW(); \t\tXPT2046_DelayUS(5);\t \t}\t \t //\t/*片选取消*/ //\tXPT2046_CS_ENABLE(); \t } ``` > 在上升沿的时候采样, 高数据位先行 ```c //读取数据 uint16_t XPT2046_ReceiveData(void)\t { \tuint8_t i; \t \tuint16_t receive_temp 0; \t //\t/*设置引脚的初始状态*/ //\tXPT2046_CS_ENABLE(); //\tXPT2046_CLK_LOW(); //\tXPT2046_MOSI_0(); //\t //\t/*片选选中*/ //\tXPT2046_DelayUS(10); //\tXPT2046_CS_DISABLE(); \t \t\tXPT2046_CLK_HIGH();\t\t \t\tXPT2046_DelayUS(5); \t\tXPT2046_CLK_LOW(); \t\tXPT2046_DelayUS(5);\t \t \t/*产生12个时钟，读取数据*/ \tfor(i 0;i < 12;i++) \t{\t\t \t\treceive_temp receive_temp << 1; \t\tXPT2046_CLK_HIGH();\t\t \t\tXPT2046_DelayUS(5); \t\t \t\t \t\tif( XPT2046_MISO() Bit_SET) \t\t{ \t\t\treceive_temp 0x01; \t\t} \t\telse \t\t{ \t\t\treceive_temp 0x00;\t\t \t\t}\t\t\t\t \t\t\t \t\tXPT2046_CLK_LOW(); \t\tXPT2046_DelayUS(5);\t \t}\t \t \t/*片选取消*/ \tXPT2046_CS_ENABLE(); \t \treturn receive_temp; \t } ``` > 高电平的时候数据是稳定的 > 在发送命令到接收时序直接片选不能中断, 且两个中间有一个时钟间隔, 可以使用一直片选 ## 使用状态机检测 检测输出按下释放两种状态 检测 ![image 20230713201105922](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281048096.png) ```c //触摸检测状态机 uint8_t touch_detect(void) { \tstatic Touch_State touch_state XPT2046_STATE_RELEASE; \tstatic uint8_t i; \tuint8_t result; \t \tswitch(touch_state) \t{ \t\tcase XPT2046_STATE_RELEASE: \t\t\t\t//之前没有按下,现在检测为低电平 \t\t\t\tif(XPT2046_PENIRQ_Read() XPT2046_PENIRQ_ActiveLevel) \t\t\t\t{ \t\t\t\t \t\t\t\t\ttouch_state XPT2046_STATE_WAITING; \t\t\t\t\tresult TOUCH_NOT_PRESSED; \t\t\t\t} \t\t\t\telse \t\t\t\t{\t\t\t\t\t\t\t \t\t\t\t\ttouch_state XPT2046_STATE_RELEASE; \t\t\t\t\tresult TOUCH_NOT_PRESSED; \t\t\t\t}\t\t\t\t\t\t \t\tbreak; \t\t \t\tcase XPT2046_STATE_WAITING: \t\t\t//在等待状态,再次检测 \t\t\tif(XPT2046_PENIRQ_Read() XPT2046_PENIRQ_ActiveLevel) \t\t\t\t{ \t\t\t\t\ti++; \t\t\t\t\t \t\t\t\t\tif(i>10) \t\t\t\t\t{ \t\t\t\t\t\t//进行延时后检测为按下 \t\t\t\t\t\ttouch_state XPT2046_STATE_PRESSED; \t\t\t\t\t\tresult TOUCH_PRESSED; \t\t\t\t\t}\t\t \t\t\t\t\telse \t\t\t\t\t{\t//等待没有结束 \t\t\t\t\t\ttouch_state XPT2046_STATE_WAITING; \t\t\t\t\t\tresult TOUCH_NOT_PRESSED;\t\t\t\t\t\t\t \t\t\t\t\t}\t\t\t\t\t\t\t\t\t\t \t\t\t\t\t\t \t\t\t\t} \t\t\t\telse \t\t\t\t{\t\t\t\t\t \t\t\t\t\t\ti 0; \t\t\t\t\t\ttouch_state XPT2046_STATE_RELEASE; \t\t\t\t\t\tresult TOUCH_NOT_PRESSED; \t\t\t\t}\t\t\t\t \t\t \t\t\tbreak; \t\t \t\tcase XPT2046_STATE_PRESSED:\t\t\t \t\t\t\t\t\tif(XPT2046_PENIRQ_Read() XPT2046_PENIRQ_ActiveLevel) \t\t\t\t\t\t{ \t\t\t\t\t\t\t\ttouch_state XPT2046_STATE_PRESSED; \t\t\t\t\t\t\t\tresult TOUCH_PRESSED; \t\t\t\t\t\t} \t\t\t\t\t\telse \t\t\t\t\t\t{\t\t\t\t\t\t\t \t\t\t\t\t\t\t\ttouch_state XPT2046_STATE_RELEASE; \t\t\t\t\t\t\t\tresult TOUCH_NOT_PRESSED; \t\t\t\t\t\t}\t \t\t\t \t\t\tbreak; \t \t} \t \treturn result; } ```"},"/note/嵌入式/外设/2024-1-6-12摄像头OV7725.html":{"title":"摄像头OV7725","content":" layout: post title: \"摄像头OV7725\" date: 2024 1 6 15:39:08 +0800 tags: stm32 # 摄像头OV7725 还有OV2640 200W像素, OV5640 500W像素 这一个是30W像素, 通过SCCB协议进行通信 ![image 20240106195109118](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061951246.png) ![image 20240106195253045](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061952123.png) > 窗口设置就是在整个比较大的图像里面选取其中一部分 ![image 20240106195559546](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061955648.png) > 是类似于IIC的通信 ## SCCB时序 ![image 20240106195816045](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061958120.png) ![image 20240106200108314](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401062001381.png) ![image 20240106200308977](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401062003034.png) ![image 20240106200459287](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401062004411.png) > 设置为8bit的时候是D[9:2]的数据是有效的 ![image 20240106200858038](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401062008092.png) ## FIFO芯片 ![image 20240106201236228](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401062012310.png) ## 输出时序图 ![image 20240106201828154](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401062018227.png) ![image 20240106201949734](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401062019814.png) ![image 20240106202547209](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401062025306.png) ![image 20240106202754310](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401062027379.png) ![image 20240106202825565](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401062028633.png) > RE直接连接的是地, 所以需要控制的是OE引脚 ## 实际的使用 ![image 20240106205622271](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401062056324.png) ![image 20240106210128347](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401062101420.png) ![image 20240106210348587](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401062103681.png) ![image 20240106210705442](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401062107521.png)"},"/note/嵌入式/外设/2024-1-4-05电阻触摸屏XPT2046.html":{"title":"电阻触摸屏XPT2046","content":" layout: post title: \"电阻触摸屏XPT2046\" date: 2024 1 4 15:39:08 +0800 tags: stm32 # 电阻触摸屏XPT2046 ## 实现 ![image 20240104184224558](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041901278.png) ![image 20230713181852133](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041901394.png) 一边链接电阻屏, 另一边链接stm32, PENDIRQ, 有信号之后产生信号, AUX电压辅助通道不使用，PENIRQ 变低并作为处理器的中断信号 ![image 20240104184658876](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041901598.png) ### 控制原理 4线触摸屏控制器, 使用SPi接口, 内部有一个12位分辨率的ADC, 125KHz, 是一个逐步逼近性的AD转换器 实际上是一个十二位的ADC, 最大为4096, 通过比例获得位置, 使用内部电压源, 通过发送命令获得数据 ![image 20230713182801896](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041901475.png) 7: 准备开始检测 6 4: ![image 20230713191549154](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041901387.png) 3: 检测的模式 2: 设置为0, 1的时候使用AUX引脚 1 0: 节省电源, 设置为00的时候会在获取数据的时候再去产生电场 设置为0x90, 获取X通道数字, 0xD0获取Y的数字 ![image 20230713192050741](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041901274.png) > 使用软件SPI ![image 20231026185527854](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041901786.png) ![image 20240104184904794](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041901766.png) > 首先发送一个命令, 之后会获得对应的数据, 在实际接受的时候使用16位进行接收 ![image 20231026185602822](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041901229.png) ![image 20231026185823730](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041901981.png) > 首选的是差分工作模式, 这时候找到对应的A2 A0的表 ![image 20231026185835391](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041901089.png) > 选择00, 在两次测量之间会进行自动断电 ![image 20231026221557923](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041901178.png) > 实际使用的是001和101 ![image 20240104185503851](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041901207.png) > ```c > #define\t XPT2046_CHANNEL_X \t 0x90 \t //通道Y+的选择控制字 > #define\t XPT2046_CHANNEL_Y \t 0xd0\t //通道X+的选择控制字 > ``` > > 在读取X轴坐标的时候打开Y驱动, 把X轴的驱动关闭0x90 >10010000 > > 读取Y轴坐标的时候打开X轴的驱动, 0xd0 >11010000 > > ![image 20231026222352678](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041901365.png) ```c //发送命令 void XPT2046_SendCMD(uint8_t cmd)\t { \tuint8_t i; \t \t/*设置引脚的初始状态*/ \tXPT2046_CS_ENABLE();//片选引脚设置为低电平 \tXPT2046_CLK_LOW();//时钟为低电平 \tXPT2046_MOSI_0(); \t \t/*片选选中*/ \tXPT2046_DelayUS(10); \tXPT2046_CS_DISABLE(); \t \t/*产生8个时钟，发送数据*/ \tfor(i 0;i<8;i++) \t{ \t\tif( (cmd & (0x80>>i)) 0 ) \t\t{ \t\t\tXPT2046_MOSI_0(); \t\t} \t\telse \t\t{ \t\t\tXPT2046_MOSI_1();\t\t \t\t}\t\t \t\t \t\tXPT2046_CLK_HIGH();\t\t \t\tXPT2046_DelayUS(5); \t\t\t \t\tXPT2046_CLK_LOW(); \t\tXPT2046_DelayUS(5);\t \t}\t \t //\t/*片选取消*/ //\tXPT2046_CS_ENABLE(); \t } ``` > 在上升沿的时候采样, 高数据位先行 ```c //读取数据 uint16_t XPT2046_ReceiveData(void)\t { \tuint8_t i; \t \tuint16_t receive_temp 0; \t //\t/*设置引脚的初始状态*/ //\tXPT2046_CS_ENABLE(); //\tXPT2046_CLK_LOW(); //\tXPT2046_MOSI_0(); //\t //\t/*片选选中*/ //\tXPT2046_DelayUS(10); //\tXPT2046_CS_DISABLE(); \t \t\tXPT2046_CLK_HIGH();\t\t \t\tXPT2046_DelayUS(5); \t\tXPT2046_CLK_LOW(); \t\tXPT2046_DelayUS(5);\t \t \t/*产生12个时钟，读取数据*/ \tfor(i 0;i < 12;i++) \t{\t\t \t\treceive_temp receive_temp << 1; \t\tXPT2046_CLK_HIGH();\t\t \t\tXPT2046_DelayUS(5); \t\t \t\t \t\tif( XPT2046_MISO() Bit_SET) \t\t{ \t\t\treceive_temp 0x01; \t\t} \t\telse \t\t{ \t\t\treceive_temp 0x00;\t\t \t\t}\t\t\t\t \t\t\t \t\tXPT2046_CLK_LOW(); \t\tXPT2046_DelayUS(5);\t \t}\t \t \t/*片选取消*/ \tXPT2046_CS_ENABLE(); \t \treturn receive_temp; \t } ``` > 高电平的时候数据是稳定的 > 在发送命令到接收时序直接片选不能中断, 且两个中间有一个时钟间隔, 可以使用一直片选 ## 触摸校准 出现误差的原因是由于两块屏幕并不是完全贴合的, 所以会导致出现误差, 校准就是将逻辑平面映射到物理平面 主要就是要算出来比例缩放系数 y kx+b 主要就是通过获取5个点的ADC的值, 之后使用这几个值进行计算"},"/note/嵌入式/外设/2023-12-5-模块OLED.html":{"title":"0.96寸OLED模块","content":" layout: post title: \"0.96寸OLED模块\" date: 2023 6 19 15:39:08 +0800 tags: stm32 # 0.96寸OLED模块 + CH1116芯片 128*64分为8个页, 每个页有128列 设备地址是0x7A 指令: 以0x00开头之后是一字节的指令 设置页地址: 设置为page0的指令是0xB0, 设置为page7的是0xB7 列地址: 设置为0x5A的时候指令需要两个0x0A 0x15 数据: 以0x40开头之后是若干个数据 ## 移植 直接把驱动代码移植到文件里面, 添加头文件路径, 这时候UTF 8的编码汉字会出问题 需要在C/C++里面添加一行参数` no multibyte chars` ![image 20231205092436115](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312050924219.png) + 使用GB2312格式的时候需要对文件的格式进行转换 ![image 20231205093134508](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312050931564.png) ![image 20231205093409447](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312050934495.png) ![image 20231205094022542](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312050940584.png) ![image 20231205094228701](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312050942740.png) ```c /** * OLED显存数组 * 所有的显示函数，都只是对此显存数组进行读写 * 随后调用OLED_Update函数或OLED_UpdateArea函数 * 才会将显存数组的数据发送到OLED硬件，进行显示 */ uint8_t OLED_DisplayBuf[8][128]; ``` ![image 20231205114809808](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312051148902.png) ![image 20231205114827541](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312051148609.png) 之后调整大小, 然后再次二值化"},"/note/嵌入式/外设/2023-12-31-01环境传感器AP3216.html":{"title":"环境传感器AP3216","content":" layout: post title: \"环境传感器AP3216\" date: 2023 6 20 15:39:08 +0800 tags: stm32 # 环境传感器AP3216 [AP3216C.pdf](file:///E:/a学习/1.stm/【正点原子】精英STM32F103开发板/2. 入门篇/34，IIC/3，光环境传感器实验/课件/器件手册/AP3216C.pdf) 三合一环境传感器, 支持环境光强度, 接近距离和红外光传感器, 后两个是搭配使用的, 检测红外线光源的距离 通过IIC进行连接, 支持INT输出 ![image 20231231105221685](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312311052927.png) ![image 20231231105542264](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312311055313.png) ![image 20231231105929384](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312311059448.png) > ALS: 光强 PS: 距离 IR: 红外线强度 > > 转换时间是可以设置的, 需要获得更高的性能具体看手册 ## 读写时序 The slave address of this device is 0x1E. ![image 20231231110554268](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312311105312.png) ![image 20231231110614435](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312311106458.png) ![image 20231231110635576](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312311106626.png) ![image 20231231111357653](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312311113704.png) ![image 20231231112106545](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312311121609.png) ![image 20231231112759279](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312311127308.png)"},"/note/嵌入式/外设/2024-1-5-07红外遥控.html":{"title":"红外遥控","content":" layout: post title: \"红外遥控\" date: 2024 1 1 15:39:08 +0800 tags: stm32 # 红外遥控 无线非接触式技术, 抗干扰能力强, 信息传输可靠, 功耗低, 成本低, 容易实现, 但是不能穿过障碍物 ![image 20240105175212828](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401051752931.png) ![image 20240105175359412](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401051753509.png) ![image 20240105175535358](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401051755424.png) ![image 20240105175630365](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401051756417.png) ![image 20240105175754823](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401051757888.png) ![image 20240105180243884](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401051802961.png) > 连发码就是一个9ms的低电平, 加上2.25ms的高电平, 0.56ms的低电平以及97.94ms的高电平(按照例程,这个会进入溢出中断) ![image 20240105181002660](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401051810729.png)"},"/note/嵌入式/外设/2024-1-5-09温度传感器DS18B20.html":{"title":"温度传感器DS18B20","content":" layout: post title: \"温度传感器DS18B20\" date: 2024 1 5 15:39:08 +0800 tags: stm32 # 温度传感器DS18B20 ![image 20240105214453290](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061054417.png) ![image 20240105214542198](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061054286.png) > 电压是3.0 5.5V ![image 20240105214943165](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061054303.png) ## 时序 ![image 20240105215020340](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061054277.png) ![image 20240105215136843](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061054396.png) ![image 20240105215158583](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061054336.png) ![image 20240105215325107](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061054886.png) ![image 20240105215454427](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061054996.png) ![image 20240105215525092](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061054218.png) ![image 20240105215751654](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061054134.png) ![image 20240105215840391](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061054085.png) ## 使用 ![image 20240105215907601](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061054119.png) ![image 20240105230146359](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061054646.png) ![image 20240105230414342](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061054627.png) ![image 20240105230429654](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061054732.png) ![image 20240105230844021](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061054035.png) ![image 20240105230954067](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061054049.png)"},"/note/嵌入式/外设/2024-1-6-10温湿度传感器DHT11.html":{"title":"温湿度传感器DHT11","content":" layout: post title: \"温湿度传感器DHT11\" date: 2024 1 5 15:39:08 +0800 tags: stm32 # 温湿度传感器DHT11 类似的还有DHT22, SHT30/31 ![image 20240106105842645](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061058814.png) ![image 20240106110011149](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061100191.png) ![image 20240106110315857](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061103903.png) ![image 20240106110442650](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061104706.png) ![image 20240106110848070](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061108172.png) ![image 20240106110927795](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061109854.png) ![image 20240106111026286](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061110373.png) ![image 20240106111345290](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061113344.png) ![image 20240106111554911](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061115962.png) > 获取数据的间隔要大于两秒"},"/note/嵌入式/外设/2024-1-6-13摄像头OV2640OV5640.html":{"title":"摄像头OV2640/OV5640","content":" layout: post title: \"摄像头OV2640/OV5640\" date: 2024 1 6 15:39:08 +0800 tags: stm32 # 摄像头OV2640/OV5640 ![image 20240106224527428](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401062245565.png) ![image 20240106224715471](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401062247527.png) ## 框图 ![image 20240106230134829](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401062301902.png) ![image 20240106230253480](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401062302554.png) ## 原理图 ![image 20240106230542779](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401062305857.png) ![image 20240106230652353](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401062306424.png) ![image 20240107113715570](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401071137726.png) ## 时序 参考上一篇 ## 寄存器 ![image 20240107120044494](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401071200562.png) ![image 20240107120147708](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401071201762.png) ![image 20240107121057379](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401071210444.png) ![image 20240107121152391](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401071211441.png) ## 实际使用 ![image 20240107131526603](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401071315667.png) ![image 20240107131945737](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401071319786.png) ![image 20240107132841579](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401071328645.png) ![image 20240107133448959](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401071334068.png) ### 例程思路 + RGB565模式 这个时候使能DCMI信号以后会直接把数据通过DMA传递给LCD屏幕, 在每一次一帧结束的时候设置指针回到屏幕的开始, 同时输入开始数据传输的命令, 这个时候没有使用DMA的发送结束的中断 + jpeg模式 这个时候会使用DMA接收结束的中断, 每一接受一行的数据, 在每一行结束的中断里面把接收到的数据搬运到缓存的数组里面, 之后在每一帧结束的中断里面对数据进行处理, 首先就是关闭DMA, 之后搬运剩下的数据到数组里面 在主函数里面对数据进行处理, 会找到有效数据的起始位置和结束, 之后把这一部分的数据通过串口发送到电脑"},"/note/嵌入式/外设/2024-9-11-4G DTU.html":{"title":"温湿度传感器DHT11","content":" layout: post title: \"温湿度传感器DHT11\" date: 2024 9 11 15:39:08 +0800 tags: stm32 # 4G DTU 4G数据透传模块, 使用物联网卡即可 数据传输模块, 可实实现串口数据转4G信号, 收到数据以后会把数据发送到配置好的位置去 AKT M750具体使用"},"/note/嵌入式/外设/2024-1-4-06电容触摸屏GT9147.html":{"title":"电容触摸屏GT9147","content":" layout: post title: \"电容触摸屏GT9147\" date: 2024 1 1 15:39:08 +0800 tags: stm32 # 电容触摸屏GT9147 使用IIC接口, 支持5点触摸 ![image 20240104190355356](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041903411.png) ![image 20240104190507174](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041905225.png) ![image 20240104190608895](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041906995.png) ## 相关寄存器 ![image 20240104190844653](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041908704.png) ![image 20240104191057177](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041910234.png) ![image 20240104191136980](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041911038.png) ![image 20240104191231103](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041912163.png)"},"/note/嵌入式/PCB/立创eda/2024-7-23-触摸墨水屏时钟.html":{"title":"esp32设计","content":" layout: post title: \"esp32设计\" date: 2024 7 23 15:39:08 +0800 tags: Linux 网络 # 触摸墨水屏时钟 ## 相关信息网站 [硬创社 好玩的硬件模块设计交流社区 (jlc.com)](https://x.jlc.com/) [与非网 国内领先的电子工程师设计技术门户网站 (eefocus.com)](https://www.eefocus.com/?_ga 2.170943017.886200440.1721703273 633646473.1721703272) [拆解 我爱音频网 (52audio.com)](https://www.52audio.com/archives/category/teardowns) ## 电路设计 ### 充电电路 #### 常见的电池 14500: 直径14, 长50, 圆柱形 18650: 直径18, 长65, 圆柱形 聚合物锂电池: 可以设计的比较小 603040: 厚度6mm, 宽30mm, 长40mm 电池有容量性和动力型, 容量型的驱动能力比较差, 使用放电倍率描述, 单位是C 如果一个2000毫安容量的电池, 持续放电的电流是5C, 实际可以持续的电流是2000*5/1000 10A INR: 三元材料锂电池, NCR: 钴酸锂材料锂电池, 一般INR的放电能力比较强, 放电为4.1 3.4V, NCR的放电能力比较低4.2V 2.7V平滑分布 一般可以理解为INR为动力型, NCR为容量型 > 串联电压相加容量不变, 并联电压不变容量相加 #### 充电芯片 TP4056: 一个为一节锂电池充电的芯片, 充电的电流可以有外部的电阻进行设定最大可以达到1000mA, 还有电池的温度检查功能, 精度达到1%的4.2V充电电压, 故障状态以及无电池显示等 ![image 20240723135611002](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407231356230.png) ![image 20240723140130068](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407231401107.png) ![image 20240723140517435](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407231405481.png) 当输入电压大于UVLO检测阈值和芯片使能输入端CE接高电平时，TP4056开始对电池充电。 ①如果电池电压低于2.9V，充电器用小电流对电池进行预充电。 ②当电池电压超过2.9V时，充电器采用恒流模式对电池充电，充电电流由PROG端和 GND端之间的电阻决定。 ③当电池电压接近4.2V时，充电电流逐渐减小，TP4056进入恒压充电模式。 ④当充电电流减小到充 电结束阈值时，充电周期结束。 ![image 20240723140832303](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407231408330.png) ![image 20240723141026952](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407231410994.png) > USB3：为Type C接口的母座 > > R69、R68：为下拉电阻，为了兼容PB快充协议 > > F2：为热自动恢复保险丝，防止充电电流过大，1.1A 6V规格 > > C48、C49：电容滤波与储能 > > > > R62：PROG端口电阻，对应充电电流，I 1200/1500（A） 0.8A，即800mA > > LED6：正在充电中指示灯 > > LED7：充电完成指示灯 > > R65、R66：电池电压分压电阻，接到单片机ADC上 > > CN3：电池接插件母座 ![image 20240723141157727](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407231411761.png) ①当没有插入USB口的时，由电池对系统供电，即电池输出到Vout； ②当有USB孔插入时，由USB对系统供电，即USB电压输出到Vout，但是此时的供电会有0.3V左右的压降。 这里利用的是PMOS管与二极管组成，此时电池电压被阻断输出。 > 这是一个PMOS管, 电压比较小的时候会导通 > > ![image 20240723151242668](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407231512699.png) > > 电源正极VCC经过后级负载电路接到体二极管，那么体二极管就会导通，于是此时S极的电压就约为0.7V左右（体二极管导通电压）。 > > 同时栅极G极接的是VCC，所以Vgs Vcc 0.7V>Vgsth，NMOS管会导通。NMOS管导通之后，导通压降基本为0，那么Vgs Vcc，MOS管维持导通状态。 > > 这样整体电源通路就是通的，电源给后级负载供上了电，后级电路正常工作。 > > 这里有一点需要特别注意，就是此时MOS管的电流是S到D的，与往常我们经常见的D到S是反的。 > > ![image 20240723143325153](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407231433183.png) #### 串口防倒灌 ![image 20240724104818483](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407241048555.png) 使用NMOS管可以完全隔离RXD对外的上拉电流，其工作原理为：RXD连接NMOS的D极，VCC连接NMOS的G极，TXD连接NMOS的S极。 当TXD侧器件无电，NMOS不导通，RXD和TXD之间未导通； 当TXD侧器件通电，驱动TXD为高电平时，NMOS不导通，RXD保持默认高电平；TXD为低电平时，NMOS导通，RXD和TXD直连被下拉为低电平； ![image 20240724105246780](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407241052817.png) > 主要是用于防止串口芯片直接对esp32进行供电 > > [墨水屏手册](https://www.e paper display.com/GDEW0154Z04 T V1.0 Specificationb8a3.pdf?method picker&flag all&id 4c61aaf7 8c8e 4a0b 8271 e7e5e51f5ffd&fileId 789&v 2.zip) > > ![image 20240724121713459](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407241217512.png) > > [GDEW0154Z04 T V1.0 Specification (e paper display.com)](https://www.e paper display.com/GDEW0154Z04 T V1.0 Specificationb8a3.pdf?method picker&flag all&id 4c61aaf7 8c8e 4a0b 8271 e7e5e51f5ffd&fileId 789&v 2.zip) ### 墨水屏 [墨水屏（电子纸）的介绍与使用（附STM32程序~~~）_嵌入式 墨水屏 CSDN博客](https://blog.csdn.net/sandwich_iot/article/details/121136582) ![image 20240724113935908](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407241139960.png) ![image 20240724111038650](C:\\Users\\jinhua\\AppData\\Roaming\\Typora\\typora user images\\image 20240724111038650.png) 如原理图所示，3.3V输入源，电感L1，MOS管Q1，电容C1，二极管D3，电阻R2构成了一个最基本的boost升压电路，MOS管Q1的导通或截止状态，由E_GDR控制。 当MOS管Q1导通时，输入电压经过电感L1后直接通过限流电阻R2返回到GND，这导致通过电感L1的电流线性的增大，此时输出滤波电容C1向负载放电。 当MOS管Q1截止时，由于电感L1的电流不能在瞬间发生突变，因此在电感L1上产生反向电动势Vs以维持通过电流不变。此时二极管D3导通，3.3V和Vs两电压串联后，以超过3.3V大小的电压向负载供电，并对输出滤波电容C1充电，如此循环，由此实现对E_PREVGH引脚的升压操作。 同样的，对于E_PREVGL引脚， 当MOS管Q1截止时，电容C2充电，二极管D1导通，D2截止，电流经过D1流向GND，理想情况下电容C2两端的电压差为3.3V+Vs。 当MOS管Q1导通时，Q1的漏极接近0V，由于电容C2电压不能突变，可认为二极管D2的K极电势为 (3.3V+Vs)，电容C2放电，二极管D1截止，D2导通，电流经过D2流向C2，由此实现对E_PREVGL引脚负电压“升压”操作。 #### boost升压电路 [Boost电路原理分析及其元件参数设计 CSDN博客](https://blog.csdn.net/qq_23174771/article/details/117594998) ![image 20240724111858033](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407241118064.png) 当控制端的输入信号为高电平时，此时开关管VQ导通，相当于短路，其等效电路如图2所示。通过电路可以看出，此时输入电压VS给电感L充电，需要注意这时电感两端电压的极性为左正右负，并且随着时间的增加，电感上的电流（即输入电流）不断增大。此时二极管VD反向截止，相当于断路。而此时的电容C向负载R放电，随着时间的增加，电容C两端的电压（即输出电压）在不断减小。 ![image 20240724112036955](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407241120992.png) 当控制端的输入信号为低电平时，此时开关管VQ截止，相当于断路，其等效电路如图3所示。此时电感L两端电压的极性变为右正左负，使得VD导通，电感放电，且随着时间的增加，电感上的电流（即输入电流）不断减小。这时输入电压和电感L上的电压叠加起来，一起给电容C充电，同时给负载R供电。随着时间的增加，电容C两端的电压（即输出电压）在不断增加。 ![image 20240724112133839](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407241121871.png) ![image 20240724112750389](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407241127429.png) ## ubuntu配置环境 ```bash 在ubuntu终端中执行： sudo apt get install openssh server sudo /etc/init.d/ssh start ps egrep ssh sudo passwd root 若未设置过root密码，可自行选择设置 查看ubuntu ip确定和windows一样 ifconfig ``` ```c sudo apt get update sudo apt get install samba sudo gedit /etc/samba/smb.conf 末尾添加以下 [share] comment samba home directory path /home/xxxx/esp 你本机路径 public yes browseable yes public yes read only no writable yes create mask 0777 directory mask 0777 available yes security share 重启 sudo service smbd restart sudo ufw allow samba ``` 在 Windows 系统上右击 此电脑 >**映射网络驱动器** ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407241539795.png) > 这一个文件夹直接给一个`sudo chmod 777 文件夹` 打开VSCode安装C/C++、SSH客户端插件 ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407241542481.png)![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407241542076.png) 配置连接Ubuntu ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407241542707.png) 添加配置信息 ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407241542436.png) 登录，如果网络配置没问题，你可以在新窗看到需要输入密码，输入ubuntu密码后可登录成功。 > 这一个需要刷新一下 ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407241542674.png) [Ubuntu设置静态IP地址的几种方法_ubuntu配置静态ip地址 CSDN博客](https://blog.csdn.net/fun_tion/article/details/126750615) ![image 20240724155842111](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407241558148.png) 把这一个文件改为 ![image 20240724155912946](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407241559982.png) 输入命令netplan apply使改动生效，然后reboot重启系统，就配置好了。 + 安装esp idf 下载文件解压, 之后使用install.sh进行安装 + pip换源 [pypi 镜像站使用帮助 清华大学开源软件镜像站 Tsinghua Open Source Mirror](https://mirrors.tuna.tsinghua.edu.cn/help/pypi/) ## 导出3D模型 使用导出SD的选项导出step文件, 之后用Solidworks打开, 另存为prt格式(零件的格式即可)"},"/note/嵌入式/PCB/立创eda/2024-7-21-esp32设计.html":{"title":"esp32设计","content":" layout: post title: \"esp32设计\" date: 2024 7 14 15:39:08 +0800 tags: Linux 网络 # esp32设计 [esp32 wroom 32_datasheet_cn.pdf (espressif.com)](https://www.espressif.com/sites/default/files/documentation/esp32 wroom 32_datasheet_cn.pdf) [esp32_datasheet_cn.pdf (espressif.com)](https://www.espressif.com/sites/default/files/documentation/esp32_datasheet_cn.pdf) 这里使用的是esp32的一个模组 [模组概览｜乐鑫科技 (espressif.com)](https://www.espressif.com/zh hans/products/modules) esp32的技术规格书, 里面有GPIO的定义 [esp32_datasheet_cn.pdf (espressif.com)](https://www.espressif.com/sites/default/files/documentation/esp32_datasheet_cn.pdf) ## 出现的问题 1. 有的GPIO不可以进行输出 2. 串口接线需要交叉布线 3. 天线下面不能铺铜 4. 改完以后需要重新铺铜以及添加泪滴 5. 可以加一个下载使用的位置 ![image 20240724135718322](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407241357398.png) ## type c转串口 ![image 20240721150600613](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407211506679.png) ![Screenshot_20240721_143024](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407211503562.jpg) ![image 20240721150625798](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407211506863.png) ## LED [主要特点 (szlcsc.com)](https://atta.szlcsc.com/upload/public/pdf/source/20211224/E1D51490BF3990BC3747CA833459C67A.pdf) ![image 20240721161457746](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407211614797.png) ## IO分布 esp32的I2C和SPI可以连接任意的引脚, 所以可以随意地设计, 实际设计的时候需要注意, 有的GPIO是不可以输出的 [esp32_datasheet_cn.pdf (espressif.com)](https://www.espressif.com/sites/default/files/documentation/esp32_datasheet_cn.pdf)这一个手册里面记录有引脚的功能 0. 无 1. 无 2. **KEY** 3. 无 4. 无 5. **LCD** 6. 无 7. 无 8. 无 9. 无 10. 无 11. 无 12. **KEY** 13. **LCD** 14. **LCD** 15. 无 KEY 16. **LCD** 17. **LCD** 18. LCD 19. **KEY** 20. 无 21. **KEY** 22. I2C 23. I2C 24. 无 25. **KEY** >LED 26. **KEY** >LED 27. **KEY** 28. 无 29. 无 30. 无 31. 无 32. LED 33. 无 34. 无//LED >key// 35. 无//LED >key 36. 无 37. 无"},"/note/嵌入式/PCB/立创eda/2024-7-18-04设计.html":{"title":"设计流程","content":" layout: post title: \"设计流程\" date: 2024 7 14 15:39:08 +0800 tags: Linux 网络 # 设计 ## 设计流程 ![image 20240718184038322](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407181840378.png) 1、如果没有需要的库，则先画库：器件，符号，封装。器件需要绑定符号和封装。 2、新建工程，放置器件在原理图 3、原理图转PCB 4、导出BOM和Gerber下单。 > 修改注意: 添加泪滴, 测试点 ## 快捷键 ![image 20240720172803835](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201728883.png) 放大缩小: 滚轮 移动屏幕: 右键 ### 元件快捷键 旋转: 空格 选择线宽: Tab 切换长度单位: q ### PCB快捷键 单路布线: w 隐藏飞线: Ctrl+r 突出走线 Shift + S 放置过孔 v 顶层T, 底层D, 用于自动打孔 高亮网络 H 重新铺铜 Shift+ B ## 新的工程 ![image 20240718224726845](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407182247895.png) ![image 20240718224807645](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407182248670.png) ![image 20240718224841198](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407182248224.png) ![image 20240718224926907](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407182249954.png) > 可以在这设置默认初始化图纸右下角的信息, 也可以直接在右边的属性表里面更改 ### 图纸 在放置电压, 地和引脚的时候, 如果名字是一样的, 就会进行连接, 名字是不同的不会进行连接 连接器件的时候使用导线 实际绘制的时候需要首先从立创商城里面查找自己需要的那一个器件 ![image 20240720142654079](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201426128.png) ### 检测DRC ![image 20240719223742342](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407192237408.png) ![image 20240719224835651](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407192248687.png) > 可以在这里设置检查的规则 ### 元件 最重要的引脚的放置, 线条没有物理意义, 引脚的编号是和封装绑定的 ![image 20240718233141737](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407182331772.png) > 这些器件实际是不需要进行绘制的 ![image 20240718233354134](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407182333167.png) ![image 20240718233605152](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407182336181.png) 名字一样的端口实际是连接在一起的 ![image 20240718235056783](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407182350831.png) 也可以使用这一种方法进行查找 ![image 20240719105203485](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407191052523.png) #### 电阻 ![image 20240718225438810](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407182254845.png) ![image 20240718225541800](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407182255852.png) ![image 20240718225655778](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407182256812.png) ![image 20240718231331968](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407182313993.png) ![image 20240718225814926](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407182258981.png) > 这个位号里面的?会被替换为1, 2, 3, 电阻可以使用R? > > 如果有封装, 图片或者3D模型可以进行绑定 使用这一个进行绘画, 这时候发现网格比较大, 所以使用 ![image 20240718225903949](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407182259977.png) ![image 20240718225928930](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407182259960.png) 调小一点 ![image 20240718230130070](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407182301096.png) 添加引脚 ![image 20240718230416540](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407182304567.png) ![image 20240718231011076](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407182310107.png) > 电阻没有引脚名称可以去掉 ![image 20240718231727213](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407182317246.png) ![image 20240718233103060](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407182331110.png) #### LED ![image 20240718232501936](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407182325998.png) #### AMS1117 3.3 [【电源】【PCB】电源板(提供±2v5,3v3,5v,12v供电)的制作——电赛使用_pcb板上加多少电压 CSDN博客](https://blog.csdn.net/GalaxyerKw/article/details/125686221) [Microsoft Word DS1117 (szlcsc.com)](https://atta.szlcsc.com/upload/public/pdf/source/20180727/C6186_7A095716F0823C02F1997A905E26C086.pdf) AMS1117 3.3是一种输出电压为3.3V的正向低压降稳压器，适用于高效率线性稳压器发表开关电源稳压器电池充电器活跃的小型计算机系统接口终端笔记本电脑的电源管理电池供电的仪器。 AMS1117有两个版本：固定输出版本和可调版本，固定输出电压为1.5V、1.8V、2.5V、2.85V、3.0V、3.3V、5.0V，具有1％的精度；固定输出电压为１．２Ｖ的精度为２％。 AMS1117内部集成过热保护和限流电路，是电池供电和便携式计算机的最佳选择。 特性 固定输出电压为1.5V、1.8V、2.5V、2.85V、3.0V、3.3V、5.0V和可调版本，具有1％的精度 固定输出电压为1.2V的精度为2％ 低漏失电压：1A输出电流时仅为1.2V 限流功能 过热切断 温度范围： 40°C~125°C ![image 20240719100448389](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407191004444.png) ![image 20240719101633308](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407191016351.png) > 1、D1作用是防止电源反接。 > > 2、C01、C02是电源输入滤波。 > > 3、VDD3.3是3.3V电源，供数字电路使用， > > 4、L1、L2是隔离滤波电感。 > > 5、VCC3.3是3.3V电源，供模拟电路使用。 ![image 20240719100938040](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407191009082.png) ![image 20240719101148518](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407191011554.png) ![image 20240719101823704](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407191018744.png) > 第四个脚是散热pad，一般和封装的中间脚是通的（也有不通的，具体参见厂家的datasheet）手册里只有三个脚是因为2、4两个脚在电气功能上是一样的，没必要单独拿出来说而已 > > 第四脚对应的是封装的第四个焊盘，所以命名为TAB #### microusb ![image 20240719111546941](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407191115051.png) ![image 20240719111723194](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407191117240.png) ### 封装 [PCB封装尺寸 0402 0603 0805 CSDN博客](https://blog.csdn.net/li707414287/article/details/99239656) ![image 20240719224301637](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407192243674.png) #### C0603 首先需要获取封装的尺寸 ![image 20240719225443880](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407192254931.png) ![image 20240719225527242](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407192255283.png) ![image 20240719225615496](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407192256535.png) ![image 20240719225755507](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407192257567.png) ![image 20240719225850018](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407192258051.png) > 这一个焊盘的1对应元件引脚的编号 ![image 20240719230232235](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407192302272.png) > 设置焊盘的形状以及大小 ![image 20240719230456190](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407192304237.png) > 计算位置, 红色的是铜, 实际焊接的位置 ![image 20240719230655788](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407192306823.png) > 电阻使用的圆角, 电感使用的是方角 ![image 20240719230706480](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407192307517.png) ![image 20240719230717586](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407192307622.png) > 绘制丝印 ![image 20240719230859174](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407192308217.png) ![image 20240719231043762](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407192310815.png) > 紫色的部分是阻焊层, 可以在焊盘属性里面进行设置, 这一层的作用是阻止覆盖绿油的 > > ![image 20240719231111884](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407192311921.png) ![image 20240719231719248](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407192317319.png) > 选择器件以及封装进行更新 > > ![image 20240719231933970](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407192319012.png) #### C0402 ![image 20240719232348064](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407192323109.png) #### C0805 ![image 20240719232412914](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407192324958.png) #### F1201 ![image 20240720104739050](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201047105.png) ![image 20240720105107650](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201051690.png) #### 排针 ![image 20240720113928094](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201139171.png) ![image 20240720114023841](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201140886.png) > 可以使用这一个快速放置 ![image 20240720114323205](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201143248.png) ![image 20240720114337905](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201143954.png) #### USB ![image 20240720132918108](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201329160.png) ![image 20240720133147894](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201331937.png) 内直径是实际这一个孔的直径, 外直径是外面有一个铜皮的直径 固定脚使用的是多层的焊盘 ![image 20240720134516495](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201345535.png) ### PCB 原理图转PCB ![image 20240720143019863](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201430906.png) ![image 20240720143059875](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201430927.png) ![image 20240720143152871](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201431911.png) > 这一个蓝色的线是飞线层 **网络:** 相同网络的铜是需要连接在一起的 ![image 20240720143427140](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201434200.png) ![image 20240720143602486](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201436529.png) > 导出的数据实际是器件的json数据 #### 板框 ![image 20240720143729837](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201437878.png) ![image 20240720143941253](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201439298.png) ![image 20240720144012127](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201440168.png) ![image 20240720144033045](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201440106.png) #### 布局 在原理图部分选中的时候, PCB也会进行选中, 之后就可以把器件按照模块拖动出来 ![image 20240720144613551](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201446599.png) 丝印一般会把他放在器件的中间位置 ![image 20240720144828356](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201448398.png) ![image 20240720144858107](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201448160.png) 可以选择所有的丝印 ![image 20240720144955545](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201449589.png) ![image 20240720145012635](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201450682.png) 在布局的时候可以使用Ctrl+r隐藏飞线, 这个时候飞线只有在移动期间的时候才会显示 ![image 20240720165512087](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201655162.png) ![image 20240720165531389](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201655450.png) > 按照大概得走线进行布局 #### 设计规则 ![image 20240720165636556](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201656601.png) ![image 20240720170004812](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201700880.png) ![image 20240720170048334](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201700400.png) [PCB走线载流计算器 电子技术资料工具 电子发烧友 (elecfans.com)](https://www.elecfans.com/tools/108.html) ![image 20240720170434734](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201704783.png) ![image 20240720170537530](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201705594.png) ![image 20240720170617124](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201706192.png) ![image 20240720170728998](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201707045.png) ![image 20240720170947556](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201709619.png) ![image 20240720171016466](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201710535.png) + 差分信号 ![image 20240720171159217](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201711264.png) ![image 20240720171230660](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201712711.png) ![image 20240720171649512](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201716580.png) ![image 20240720223602225](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407202236295.png) > ![image 20240720223902398](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407202239451.png) > > 全填充的连接方式, 机器焊接的时候一般使用这一个 > > ![image 20240720224008436](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407202240486.png) > > 使用发散的模式, 手工焊接的时候一般使用这一个 #### 布线 快捷键w ![image 20240720172923171](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201729220.png) 可以使用shift+s突出走线 正面连线的时候不需要考虑GND, 反面会大面积铺地 ![image 20240720183232191](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201832243.png) ##### 底层布线 ![image 20240720182652594](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201826642.png) 这一个eda在切换层的时候会自动打孔, 设置一下切换的快捷键, 顶层T, 底层D ##### 特殊 + 晶振的外部需要包地处理 ![image 20240720174912323](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201749374.png) 之后需要进行打孔, 快捷键V ![image 20240720180018477](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407201800532.png) 在最后铺GND的时候这一个还需要禁止铺铜的操作 ##### 电源线 可以使用铺铜的方式 ![image 20240720223437220](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407202234299.png) ![image 20240720224056938](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407202240994.png) 改变规则以后可以使用这一个重新加载 ![image 20240720225329286](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407202253340.png) ![image 20240720225337804](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407202253864.png) > 填充和铺铜的区别的不会自动避让 ##### 差分线 使用差分线布线 ![image 20240720230446183](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407202304236.png) ##### GND ![image 20240721001635951](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407210016004.png) 只有这一个没有处理了 首先需要隔离晶振 ![image 20240721002430572](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407210024631.png) ![image 20240721002851301](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407210028367.png) 之后直接选中底层进行铺铜 ![image 20240721003026691](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407210030754.png) ![image 20240721003336889](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407210033955.png) ![image 20240721003431057](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407210034128.png) ![image 20240721003442275](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407210034340.png) 可以加强PCB的韧性 ##### 增加泪滴 ![image 20240721102224048](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407211022099.png) ![image 20240721102232896](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407211022960.png) ![image 20240721102341346](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407211023400.png) ##### 丝印图片 ![image 20240721111250495](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407211112554.png) #### 底层设计 在底层设计的时候, 需要把这一个板子进行翻转 ![image 20240724124434963](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407241244018.png) ### 3D模型 ![image 20240721111002698](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407211110780.png) ## 下单 ![image 20240721111952404](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407211119467.png) [嘉立创客户中心 (jlc.com)](https://member.jlc.com/integrated/content/couponList) 领取以后可以进行下单 ![image 20240722182120136](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407221821243.png) ![image 20240722182227858](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407221822913.png)"},"/note/嵌入式/PCB/立创eda/2024-7-18-03立创eda.html":{"title":"立创EDA","content":" layout: post title: \"立创EDA\" date: 2024 7 14 15:39:08 +0800 tags: PCB # 立创EDA ![image 20240718181538837](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407181815948.png) ![image 20240718181649716](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407181816748.png) ![image 20240718182030211](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407181820236.png) > 在半离线模式的时候可以用这一个打开在线系统库 ![image 20240718182137008](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407181821071.png) ![image 20240718182439320](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407181824364.png)"},"/note/嵌入式/PCB/立创eda/2024-7-16-01入门.html":{"title":"入门","content":" layout: post title: \"入门\" date: 2024 7 14 15:39:08 +0800 tags: Linux 网络 # 软件下载 使用立创EDA [软件下载 嘉立创EDA (lceda.cn)](https://lceda.cn/page/download?src index) ![image 20240716221008470](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407162210586.png) 下载激活即可 ## PCB定义 Printed Circuit Board 印刷电路板 作为元器件的制成, 实现电子元器件的连接 ### 层叠结构 在铜皮上面做减法, 去除不需要的部分, 铜皮容易被折断, 所以把铜皮放在一个基板上面,直接裸露的时候, 这一个铜皮容易被腐蚀, 覆盖一层绝缘的绿油(阻焊), 同时可以防止触电, 还可以防止焊锡乱走 在板子上面做一些标志, 标志的名字叫做丝印 元器件比较多的时候, 连接比较复杂, 这时候可以有多层的铜皮, 不同的层之间可以进行打孔进行连接 内部的线和外部的器件进行连接的时候, 需要根据不同的封装设计不同的接触面积, 体现在PCB就是裸露的焊盘, 使用阻焊开窗的方式实现 ![image 20240716223810604](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407162238643.png) ![image 20240716224214665](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407162242831.png) >   它可以在PCB工厂制造。一般情况下，四层板芯两侧压一铜箔，三层板芯一侧压一铜箔。就工艺流程而言，有必要进行冲压。 > >   两种工艺成本的差异在于，四层板材多了一层铜箔和粘合层，成本差异不大。板材厂报价时，一般以3 4层的报价为一个等级，报价以偶数定义（当然不止多层）。例如，如果你设计了五层板，对方会按照六层板的价格报价，即你设计了三层板的价格，价格与你设计的四层板的价格相同。 > >   在PCB工艺中，四层板比三层板更容易控制。主要在对称性方面，四层板的翘曲度可控制在0.7%以下（ipc600标准）。然而，当三层板的尺寸较大时，翘曲将超过该标准，这将影响SMT贴片和整个产品的可靠性。因此，普通设计师不设计奇数层板，即使奇数层实现了功能，也将设计为伪偶数层，即5层设计为6层，7层设计为8层。 > ### 通孔, 盲孔, 埋孔 通孔: 从顶层到底层, 这一个PCB板被打通了, 内部镀铜 盲孔: 没有打通, 连接其中几层, 但是外部可以看到, 所以起点是第一层 埋孔: 进行内层的切换, 也是没有打通的 ## 元器件符号和封装 元件在PCB上面的形式 ![image 20240717094247506](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407170942586.png) > 黄色的是丝印层, 灰色的是焊盘的范围, 红色的是实际的焊盘, 每一个引脚对应一个焊盘 ## 生产 + 开料, 圆角, 刨边 开料把原始的覆铜板割为可以制作板子的过程, 铺铜板是双层板, 其余的多层板是使用这一个板子粘合而来的 + 钻孔 这个时候孔里面是没有铜的, 根据实际有孔的层进行打孔 + 沉铜 PCB在沉铜缸里面通过氧化还原对孔进行金属化 + 压膜 铜箔板的两个面各贴一张蓝色的感光膜。 感光膜作用是在铜箔板上完成线路的印制，它只在铜箔板上保留一段时间，在后续的“图电”步骤完成后，铜箔板上的膜就消失了，它的使命就完成了。 + 曝光 线路菲林有线路的地方是黑色的，没有线路的地方是透明的，在曝光灯管的作用下，透明的地方就会充分曝光，也就是**没有线路的地方会充分曝光。** 经过曝光后，干膜上就有清晰的线路了 > 菲林就跟模具一样，而PCB就是材料。做PCB的时候，需要把没用的铜箔[蚀刻](https://zhidao.baidu.com/search?word 蚀刻&fr iknow_pc_qb_highlight)掉。菲林就是在这里起了作用，首先，把菲林晒到网板上。 + 显影 曝光其实就是为显影做准备。显影设备中的显影液会把没有曝光过的部分去掉，也就是说，它会把有线路的地方去掉，露出黄铜。 > 需要留下来的铜是在空气中的 + 电铜 曝光其实就是为显影做准备。显影设备中的显影液会把没有曝光过的部分去掉，也就是说，它会把有线路的地方去掉，露出黄铜。 + 电锡 电锡以后，有线路的地方，会再上一层锡，这里的锡，并不是我们最终拿到手电路板上的锡，这里的锡，是一种液态锡，它的作用是在下一个环节“退膜”的时候保护线路，它将会在图电工序的最后一个环节消失，完成它的使命。 + 退膜 把蓝色的膜去掉, 只对曝光过的干膜起反应，经过两次退膜水洗，退膜就彻底完成了。 + 蚀刻 干膜已经不见了，露出了铜，这些铜，都不是我们需要的，我们需要的铜，此时正在锡的下面。接下来板子进入蚀刻环节，目的就是把裸露的铜全部腐蚀掉。 经过蚀刻以后，刚才去掉干膜后露出的铜，就被腐蚀掉了。现在电路板上就只剩下真正需要的线路部分了。 锡没有和蚀刻药水发生反应，刚才的裸露铜部分，现在已经露出了基材。 + 退锡 锡没有和蚀刻药水发生反应，刚才的裸露铜部分，现在已经露出了基材。 + 光学AOI线路扫描 自动光学检测, 把待检测的电路板放到AOI仪器检测面板上，AOI仪器开始自动扫描电路板，并与MI文件中的相应文件进行对比，一旦有区别，就会停下来，把图像放大显示到显示器上。 如果是缺陷的话，看看是否能够补救，能补救的话就补救一下，不能补救的，就是生产缺陷了，然后标记一下出错地方。 AOI检测，只是针对电路板的外观进行检测，可以很好的检测出来开路、短路、断路的地方。 + 阻焊 阻焊的目的，就是给电路板表面涂一层油，保护铜。最常见的是绿油，此外，还有蓝、黑、白、红、黄、紫等颜色。目前，嘉立创针对不同颜色的阻焊工艺，全部免费。 + 曝光 在不需要绿油覆盖的地方，也有了绿油，比如焊盘等需要开窗的地方。为了去除这些地方的阻焊油，就需要经过曝光和显影。 曝光需要用到阻焊菲林，在菲林上，需要开窗的地方是黑色的，其它地方是透明的。经过曝光以后，透明的地方就进行了充分的曝光，黑色的地方没有被曝光，就是需要开窗的地方，没有被曝光。 + #### 显影 也是一个化学反应的过程，显影液只对未曝光的地方起反应，所以，需要开窗的地方，就裸露出了焊盘 + 字符 丝印, 标志打印上面 + 表面处理 字符工序完成后，就该喷锡或沉金了。我们在嘉立创下单PCB的时候，会在焊盘喷镀那一栏选择“喷锡”还是“沉金”。喷锡后的焊盘，被上了一层锡，是银色的；沉金后的焊盘，被镀了一层金，是金色的。 + 测试 板子进行了AOI光学检测，主要是从外观上，针对开路、短路、断路等情况对电路板的表面进行了检测，无法知道过孔的问题，比如孔内是否有铜、铜的质量如何、是否可以正常导通。 > **飞针测试:** 通过检测电容值来判断。在开始测试前，工作人员先把电路板固定到机器上，然后导入电路板的网络文件，机器电脑会计算好每个网络的电容标准值，当测试开始以后，如果容差超过了一定范围，就认为不合格。 > > 在开始测试前，工作人员先把电路板固定到机器上，然后导入电路板的网络文件，机器电脑会计算好每个网络的电容标准值，当测试开始以后，如果容差超过了一定范围，就认为不合格。 > > **复合模具测试: **飞针测试完成一张电路板，需要的时间并不短。为了很好的解决时间的问题，复合模具测试，就诞生了。 > > 复合模具测试虽然快，但是需要制作一个复合模具，复合模具是由一层一层的板子组成的，包括插针、打线、排线等。制作模具需要一定的成本，还有时间，所以，复合模具测试，更适合大批量的电路板测试，如果是样板，还是飞针测试比较适合。 > > 在复合模具中，会有很多的探针，一次性压到电路板上，完成测试，很明显，它比飞针测试中的4个探针逐点移动要快很多。 + 锣边成型和V CUT 把大板分成小板了，每一个小板，就是每一个客户设计的电路板，最终会把这些小板对应的发给不同的客户。 V割和锣边的区别就是，锣边会直接把两张电路板分开，而V割后的电路板，两张电路板之间没有被完全割开，还留有一部分，只需要稍微用力，就可以掰开。 + 质量检测 QC，即质量检测。在这个环节，主要通过人工进行检测，主要检测板子外观和板子数量是否达标。板子外观方面，主要看是否有明显的缺陷，比如划伤、字符模糊等，还需要检测需要V割的板子是否有V割过。 ## PCBA 印刷电路板+组装的缩写, 空的PCB经过SMT贴片加载以及DIP插件安装, 整个过程叫做PCBA ## 焊接 浸焊: 浸焊是大量应用在插件工艺及[SMT红胶](https://baike.baidu.com/item/SMT红胶/2694579?fromModule lemma_inlink)面，利用手工或机器，把大量的锡煮熔，把焊接面浸入，使焊点上锡的一种多点焊接方法。 > 用于直插件的焊接 回流焊: 使用钢网, 锡膏, 用于贴片 波峰焊: 也是用于插件 ## 多层PCB的经典方案 ### 四层板 多了两层可以操控的空间 最常使用的方案是顶层和底层放置元件, 另外的两层分别为GND和PWR 一般使用的时候会把GND层设置在主要的元件所在的层附近 如果元器件大多数是插件, 也可以考虑把GND为顶层, PWR为底层, 中间的是走线层 ### 六层板 + TOP GND S1 S2 PWR BOTTOM 电压阻抗比较小的时候可以使用这一个, 地平面比较少电磁的吸收能力比较少 并且PWR和GND耦合比较差 + TOP S1 GND PWR S2 BOTTOM 有比较好的电磁吸收能力, TOP和BOTTOM层的参考不是特别好 + TOP GND S1 PWR GND BOTTOM **最佳的方案**: 设计了多层参考地平面, 使得叠层有非常好的参考地平面 ### 八层板 + TOP GND1 S1 PWR1 GND2 S2 GND3 BOTTOM 最佳的方案, 有多个参考使用的地平面, 有比较好地磁吸收能力 > 关键的信号层要和地相邻, 信号层之间尽量不要相连 > > 相邻的层之间的布线尽量不要平行"},"/note/嵌入式/PCB/立创eda/2024-7-17-02硬件基础.html":{"title":"硬件基础","content":" layout: post title: \"硬件基础\" date: 2024 7 17 15:39:08 +0800 tags: Linux 网络 # 硬件基础 ## 电阻 ### 参数 TCR: 电阻温度系数, 电子温度改变1摄氏度的时候电阻的相对变化 ppm/℃, ppm(百万分之几) > α (R2 R1)/R1(t2 t1) R1 温度为t1时的电阻值，Ω; R2 温度为t2时的电阻值，Ω。单位是ppm的时候, 需要乘一个1,000,000 标准测量的温度是20℃, 正常的这一个参数是 200 ~ 500 ppm/℃, 应用在特殊温度的时候需要考虑 ### 选型 #### 安装方式 + 贴片 体积小, 容易焊接以及拆卸, 稳定性比较高, 可靠性高, 在数字电路里面的抗干扰能力比较强 可以使用SMP(贴片工艺进行大规模生产) + 插件 体积大, 可以承受大电流, 稳固不容易脱离, 便宜 > 选择的时候需要考虑功率, 成本, 焊接工艺 #### 阻值 电阻的阻值是离散的, 有一定的误差 ![image 20240717123357637](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407171233682.png) ![image 20240717123301726](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407171233801.png) 电阻的标准是IEC(国际电工委员会)制定的, 标准的文件是IEC60063和EN60115 2 标称阻值有六大类 E6(%20), E12(%10) E24(%5) E48(%2) E96(%1) E192(%0.5) > 一般使用的是E24, E96, E指的是指数间距 > > ![image 20240717123919233](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407171239296.png) ![image 20240717124035845](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407171240904.png) + 贴片电阻 三位数字代表的是5%的精度, 四位是1%的精度, 前面的几位是数值, 最后一位是10的x次方 如果里面有一个R, 阻值一般比较小, 精度为1%, R代表小数点, 前面的是有效值, 一般都是E96系列的电阻 > R100 > 0.1Ω E 96规定两个数字加一个字母为丝印的时候, 实际的阻值通过查表进行获取 ![image 20240717124711282](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407171247377.png) > 88A表示的是806, 前面的是行, 后面的是列 1. 实际使用的时候需要进行计算, 根据分压, 反馈, 取样获取 2. 通过手册获取 3. 通过经验, 上下拉以及部分的限流电阻 #### 精度 ![image 20240717125116301](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407171251340.png) > 一般使用的是1%, 5%, 在ADC等需要精度比较高的地方使用其他电阻 #### 封装 ![image 20240717125303195](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407171253282.png) 主要使用的是0402, 0603, 功率比较高的时候使用1206 > 0201 > 长为0.02, 宽是0.01单位是英寸 > > 换算1inch 1000 mil > > 1mil 0.0254mm > > 实际用的时候小数点直接进位 #### 功率 ![image 20240717125827492](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407171258567.png) 功率和封装, 工艺, 品牌相关, 实际的信息查看数据手册 #### 温度 ![image 20240717130034111](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407171300204.png) #### 额定电压 电阻的耐压值和电阻的材料以及封装大小有关 ![image 20240717130234699](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407171302766.png) ### 零欧姆 是一个特殊用途的电阻, 一般来说是50mΩ 1. 调试兼容 2. 作为跳线使用, 使用跳针的时候会有高频干扰 3. 实际是一个小电阻, 可以用于测量大电流(用的比较少) 4. 参数不确定的时候, 使用这一个进行调试 5. 高频的时候可以作为电感或者电容, 主要是解决EMC问题(电阻的实际模型) ![image 20240717131210283](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407171312315.png) 6. 布线的时候, 实在是不能绕过去的时候使用这一个作为导线 7. 单点接地, 保护接地, 使得设备相互分离 > 当系统中存在多个接地点时，可能会形成地环路，这些环路会引起干扰和噪声，从而影响系统的正常运行。单点接地通过消除多个接地点，从根本上杜绝了地环路的产生。 > > 多点接地容易导致各接地点之间出现电位差，这种电位差可能引起电流的非正常流动，影响设备的正常工作。单点接地确保所有设备共享一个接地点，从而避免了电位差的问题。 > > 现代电子设备对电气环境的要求非常高，单点接地可以提供一个稳定的电气参考点，保障设备的正常工作。 8. 电路保护, 做一个低成本额熔丝, 比如使用0603作为USB电路的过流保护, 但是不推荐 9. 数字模拟电路一起使用的时候一般需要把两个地进行分离, 单点连接, 可以使用一个0Ω电阻连接, 地分为两个网络, 实际铺铜的时候比较简单, 有的时候也会使用电感以及熔丝 10. 配置电路, 起到开关的作用 ## 电容 在两个导线之间, 会有一个寄生电容, 可以通过增加这一个寄生电容的方式减少原来电路里面的阻抗 ![image 20240717162150347](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407171621397.png) 在画PCB的时候, 有时候需要走线加粗, 根据电容的公式, 这时候寄生电容的相对面积加大, 容值加大(加大S) 在高速总线里面需要进行包地处理, 实际是通过加大电容减少阻抗(减小d) ![image 20240717172902628](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407171729667.png) ![image 20240717172915796](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407171729832.png) 其中为容抗，为感抗，为等效串联电阻。很容易看出，在频率比较低（比较小）的时候，容抗远大于感抗，电容主要成容性，在频率比较高的时候，电容主要呈感性。 而当，即谐振的时候，阻抗等于等效串联电阻，此时阻抗达到最小值，如果是用来滤波的话，此时效果最好。 ### 类型 ![image 20240717163527011](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407171635043.png) 滤波电容: 电源和芯片之间加一个接地的电容, 使用电容充放电平缓电源的波动 旁路电容: 用于导通或者吸收某元件或者一组元件中交流成分的一种电容。通常交直流中的交流部分被去除，而允许直流部分通过加有旁路电容的元件。 ![image 20240717164007973](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407171640019.png) 耦合电容: 将交流信号的能量从一个电路传递到另一个电路的电容。可以将我们需要的交流信号从前级电路近似无衰减地耦合到后级电路，将我们不需要的直流信号进行去耦（隔断） ![image 20240717164305406](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407171643456.png) 去耦电容: 去耦，在电子学中，表示不让能量通过一个电路传递到另一个电路。 自举电容 ### 选型 #### 安装类型 陶瓷电容, 铝电容, 钽电容一般使用贴片的方式 安规电容一般使用的是插件的形式 #### 电容值 1. 计算获取, 晶体振荡, LC滤波电容 2. 手册取值: 设计电路的时候 3. 经验: 滤波, 储能 > 供电电源上面一般会有一个0.1微法的电容, 几个芯片的供电一般使用一个10微法的电容 #### 电容的类型 一般小于10uF的使用陶瓷电容 小于几百的使用铝电解电容与钽电容, 更大的使用铝电解电容 高温的环境使用陶瓷电容或者钽电容, 低温的时候一般都可以使用 #### 耐压封装 陶瓷电容的耐压性能比较好, 一般来说封装比较大的耐压值也比较大 > 示例: 5V的电源滤波, 可以使用一个10uF/6.3V的陶瓷电容以及一个100uF/6.3V的铝电解电容, 或者一个47uF/10V的钽电容 > > 使用两个电容的原因是去除高频和低频信号 #### 滤波特性 ![image 20240717171008531](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407171710619.png) #### 等效串联电阻 ![image 20240717171221165](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407171712308.png) > 在谐振的时候的频率 #### 温度特性 ![image 20240717171755095](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407171717214.png) ### 陶瓷电容 [关于MLCC陶瓷电容，这篇总结得太全面了_陶瓷电容esr对照表 CSDN博客](https://blog.csdn.net/plane1plane/article/details/123522374) <img src \"https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407171720482.png\" alt \"image 20240717172013446\" style \"zoom:200%;\" /> MLCC(Multi layer Ceramic Capacitors)片式多层陶瓷电容, 是由印好电极（内电极）的陶瓷介质膜片以错位的方式叠合起来，经过一次性高温烧结形成陶瓷芯片，再在芯片的两端封上金属层（外电极），从而形成一个类似独石的结构体，故也叫独石电容器。 > 频率特性比较好, 不同的介质做成的电容器的特性不同，有容量大的，有温度特性好的，有频率特性好的等等，这也是为什么陶瓷电容有这么多种类的原因。 ![image 20240717172307692](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407171723739.png) 不同的封装可以达到的最大值不同 > 0402 4.7uF/6.3V > > 0603 22uF/6.3V > > 0805 47uF/6.3V 陶瓷电容常见的额定电压有：2.5V、4V、6.3V、10V、16V、25V、50V、63V、100V、200V、250V、450V、500V、630V、1KV、1.5KV、2KV、2.5KV、3KV等等。 > 实际选用的时候一般要有一个70%的余量 在实际读取大小的时候和电阻类似, 但是单位是pF, 还是使用R作为小数点 #### 类型 同介质种类由于它的主要极化类型不一样，其对电场变化的响应速度和极化率亦不一样。在相同的体积下的容量就不同，随之带来的电容器的介质损耗、容量稳定性等也就不同。介质材料划按容量的温度稳定性可以分为两类，即Ⅰ类陶瓷电容器和Ⅱ类陶瓷电容器， NPO属于Ⅰ类陶瓷，而其他的X7R、X5R、Y5V、Z5U等都属于Ⅱ类陶瓷。 MLCC陶瓷电容主要分为2大类：高节介电常数型和温度补偿型 ![image 20240717173146988](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407171731038.png) > I类一般用于振荡器电路, 谐振电路 > > II类一般用于旁路, 耦合以及其他要求不高的场合 ### 铝电解电容 [铝电解电容_铝电解电容器主要由什么构成 CSDN博客](https://blog.csdn.net/weixin_47911361/article/details/112983754) 电容的容量比较大, 耐压比较好, 价格便宜 但是ESR比较大, 耐温比较差 > ESR比较大的话可能会导致纹波增大 > > 耐低温能力差, 低温的时候ESR增大, 电容也下降(比较少) ![image 20240717184355766](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407171843812.png) 阳极: 铝板的氧化膜 中间通过电解液和阴极(铝板)进行分割 > 如果加正向电压会破坏氧化铝, 阴极上面只有少量的氧化膜, 电容可以承受的电压和氧化膜的厚度有关导致反向击穿 #### 损坏正切值 ![image 20240717191522979](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407171915021.png) 电解电容等效电路如上图（忽略了绝缘电阻），当频率为 120Hz（一般电容器标称的损耗角就是在此频率下测得的）时，频率相对等效串联电感 L 非常低，因此可以忽略 L，损耗角模型如下图： ![image 20240717191616226](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407171916270.png) 实际是有功功率和有功功率的比值 #### 漏电流 施加直流电的时候, 氧化铝允许电流通过, 这一个部分的电流是漏电流 当温度升高时，漏电流增加；温度降低，漏电流减少施加的电压降低，漏电流值也会减少。 漏电流会随时间而变化，如图所示、随时间而减小后会达到一个稳定值。因此，漏电流的规格值为 20℃下施加额定电压一段时间之后所测量的值。 ![image 20240717192159685](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407171921734.png) ### 钽电解电容 ![image 20240717194404848](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407171944914.png) ![image 20240717194415090](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407171944142.png) ![image 20240717194431173](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407171944232.png) 改善一些铝电解电容不好的性质, ERS比较小, 耐温比较好, 但是价格贵, 耐压不好 在实际读取的时候, 上面标注的字母是耐压的等级 E G J A C D E V T 2.5V 4V 6.3V 10V 16V 20V 25V 35V 50V ### 安规电容器 [差模干扰，共模干扰的原理，以及解决方案_差模电感原理图 CSDN博客](https://blog.csdn.net/qq_45675261/article/details/132620767) 电容器失效以后不会电击, 危机人身的安全电容器 X电容: 跨接在零线以及火线之间的电容, 用于差模滤波 Y电容: 零线和地线之间, 火线和地线之间, 用于共模滤波 ![image 20240717220129282](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407172201374.png) ![image 20240717220143371](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407172201424.png) ![image 20240717223016867](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407172230920.png) ![image 20240717224222664](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407172242708.png) > 这一个信号同时把火线和零线加了一个电源, 这里把这一个电源导向地面 ![image 20240717223037253](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407172230308.png) > 有一个高频的差模信号的时候, 电容的阻抗很小, 这一个信号是两个线之间的, 之间通过这一个线导出去 > > ![image 20240717224237063](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407172242111.png) > > ![image 20240717223150486](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407172231598.png) ## 电感 ![image 20240717230850214](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407172308292.png) > 空气和铜的磁导率接近, 铁的磁导率要大得多 在设计电路的时候要注意要给电感一个可靠的回路, 以及注意继电器等器件里面有线圈(续流二极管) ![image 20240718112043710](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407181120771.png) ![image 20240718112113205](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407181121246.png) ![image 20240718112145365](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407181121419.png) 低频的时候和理想电感十分的相似, 一般是小于十分之一的自谐频率, 使用电感进行滤波的时候, 工作频率需要低于谐振频率 ![image 20240718122616132](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407181226356.png) 在频率非常小的时候等效为电阻 ### 选型 #### 电流 + 饱和电流 lsat 电感值衰减30%的时候的偏置电路 > 电感的值在电流增大的时候会减少, 电感的磁芯是有一定限制的, 达到饱和以后阻碍作用不再变化 > > 在实际选型的时候瞬间值是不可以超过这一个饱和电流的 + 温升电流 lrms 实际的电感在使用的时候会发热, 这一个电流指的是电感的自我升温不超过40℃的时候的电流 + 额定电流 lrat 这一个是前两个电流里面的最小值, 在实际使用的时候一般需要最少有20%的余量 > 在手册里面有时候会有一个最大值和一个典型值, 一般典型值是厂家实际测试出来的值, 最大值是用户推荐使用的值, 所以最大值比典型值要小 #### 直流电阻DCR 导线一般是由导线烧制的, 是有一个直流电阻的 一般来说, 电感量比较大, 导线比较长, DCR大, 相同的电感量, 额定电流比较大, 导线比较粗, DCR小 #### 种类 依据铁芯的不同类型, 主要有环形, E型, 工字型 依据铁芯的材质来说, 主要有陶瓷芯, 铁氧体, 粉末铁芯 封装有绕线式, 多层式, 绕线又有非遮蔽式, 加磁胶之半遮蔽式以及遮蔽式 > 在其他器件不容易被影响的时候, 可以选用非隐蔽式 + 工艺 1. 绕线电感 2. 叠层电感, 丝网印刷, 贴片式 3. 薄膜电感 4. 一体成型 ### 功率电感 体积比较大, 但是可以承受比较大的功率 ### 贴片电感 体积比较小, 主要用在高频电路, 电感量比较小, DCR比较大, 温升电流比较小, 自谐频率高 手册里面一般会有一个Q值, 无功功率比上有功功率 ### 共模差模电感 ![image 20240718125904738](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407181259815.png) > 差模电感可以用于单一线路上的突变 > > 共模电感, 两条线同时产生电流突变的时候会有一个大的磁场, 抑制突变 ## 磁珠 单位是欧姆, 消耗高频的能量, 电感使用的时候希望的是消耗比较小, 磁珠是利用他的损耗 它等效于电阻和电感串联，但电阻值和电感值都随频率变化。它比普通的电感有更好的高频滤波特性，在高频时呈现阻性，所以能在相当宽的频率范围内保持较高的阻抗，从而提高调频滤波效果。 主要的损耗是磁损耗以及涡流损耗, 和磁芯材料有关 使用的时候一般需要是在谐振频率附近 > 它等效于电阻和电感串联，但电阻值和电感值都随频率变化。它比普通的电感有更好的高频滤波特性，在高频时呈现阻性，所以能在相当宽的频率范围内保持较高的阻抗，从而提高调频滤波效果。 ## 半导体 1. 热敏性, 温度升高的时候导电能力加强 2. 光敏性 3. 参杂性, 加入一部分杂质以后导电的能力会发生变化 本征半导体: 没有杂质以及晶格缺陷的半导体, 结构稳定 ### 二极管 [【硬件基础4】二极管（原理、特性、类型、电路分析）_双稳压管2dw232数据手册 CSDN博客](https://blog.csdn.net/ARM_qiao/article/details/125868788) ![image 20240718160002491](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407181600559.png) ![image 20240718155945395](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407181559464.png) + PN结不加外部电源时：内部处于动态平衡，此时电流I 0 + 外加正向电压：u<Uon时，正向电流几乎为0，PN结未导通；u>Uon时，正向电流 I 随电压增大而指数增加。 + 外加反向电压：u<Ubr时，反向电流 i Is，Is很小，通常忽略不计；u>Ubr时，反向电流 I 急剧增加，称之为反向击穿。 + Uon为正向导通电压 Ubr为反向击穿电压 最大整流电流 ：管子长期运行时，允许通过最大正向平均电流，电流太大会发热烧坏。 反向击穿电压：反向击穿电压值 反向电流：未击穿时，其值越小，管子的单向导电性越好，反向电流会随温度增加而增加。 极间电容：，扩散电容＋势垒电容，高频或开关状态运用时。 反向恢复时间：二极管在极性变化时不能瞬时完全变化（极间电容）。 ### 稳压二极管 利用二极管的反向击穿以后电流特性, 电流变化电压基本不变的特性 ### PMOS和NMOS ![image 20240723142304298](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407231423361.png) NMOS是栅极高电平（VGS > Vt）导通,低电平断开,可用来控制与地之间的导通。 PMOS是栅极低电平（VGS > Vt）导通,高电平断开,可用来控制与电源之间的导通。 **NMOS的特性，Vgs大于一定的值就会导通，适合用于源极接地时的情况（低端驱动）**，只要栅极电压达到4V或10V就可以了。 **PMOS的特性，Vgs小于一定的值就会导通，适合用于源极接VCC时的情况（高端驱动）**。但是，虽然PMOS可以很方便地用作高端驱动，但由于导通电阻大，价格贵，替换种类少等原因，在高端驱动中，通常还是使用NMOS。 > NMOS管实际的原理是使用栅极连接一个比较高的电压, 这时候他会吸收电子, 电子和两个N极构成一个N沟道, 可以进行导电 > > ![image 20240723144053606](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407231440702.png) > > 图形里面的N代表的是电子的流动方向 #### 寄生二极管 很多时候电路图中MOS管旁边会带有一个二极管符号，这个不是人工加了一个二极管，而是MOS管自身的寄生二极管。对于NMOS，由于衬底（和S极相连）是P极，D极是N极，所以S到D相当于存在了一个二极管；对于PMOS，由于衬底（和S极相连）是N极，D极是P极，所以D到S相当于存在了一个二极管。在上文电流方向章节中有描述，对于NMOS，只要G大于S，MOS管就可以导通，并没有提到D，D是不是可以随便设置电压呢？ 从这个寄生二极管可以看出，要想MOS管作为开关作用，D不可以随便设置。NMOS的D电压一般不能比S电压低，因为会导致这个寄生二极管导通，G极不管怎么样，MOS管都看起来像是直接导通了，失去了MOS开关功能。PMOS则是D电压一般不能比S电压高。 > 而实际应用电路，NMOS会有电流从S到D的情况，比如下面这个NMOS管防电源反接电路（仅仅是个示意图，实际电路需要多考虑一些因素）。 > > ![image 20240723151348572](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407231513622.png) > > 电源正极VCC经过后级负载电路接到体二极管，那么体二极管就会导通，于是此时S极的电压就约为0.7V左右（体二极管导通电压）。 > > 同时栅极G极接的是VCC，所以Vgs Vcc 0.7V>Vgsth，NMOS管会导通。NMOS管导通之后，导通压降基本为0，那么Vgs Vcc，MOS管维持导通状态。 > > 这样整体电源通路就是通的，电源给后级负载供上了电，后级电路正常工作。 > > 这里有一点需要特别注意，就是此时MOS管的电流是S到D的，与往常我们经常见的D到S是反的。 > > #### 参数 Vgsth临界电压值, 使用的时候断开和连接的变化的时候的电压 Rdson: 实际导通的时候电阻值 Cgs: G和S之间的寄生电容, 实际使用的时候由于这一个电容的充电需要时间, 所以不是立即进行导通的, 一般这一个参数和Rdson的值是反比的关系 ## 晶振 石英晶体有一种特性，如果在晶片某轴向上施加压力时，相应施力的方向会产生一定的电位, 相反的，在晶体的某些轴向施加电场时，会使晶体产生机械变形； 如果在石英晶片上加上交变电压，晶体就会产生机械振动，机械形变振动又会产生交变电场，尽管这种交变电场的电压极其微弱，但其振动频率是十分稳定的。当外加交变电压的频率与晶片的固有频率（与切割后的晶片尺寸有关，晶体愈薄，切割难度越大，谐振频率越高）相等时，机械振动的幅度将急剧增加，这种现象称为“压电谐振”。 ![image 20240719171951524](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407191719602.png) ![image 20240719172211061](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407191722136.png) 串联谐振的时候这一个电路的阻抗最小, 之后并联谐振的时候理论这一个电路的阻抗无限大 ![image 20240719182124181](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407191821243.png) CL (C1*C2)/(C1+C2)+Cs ![image 20240719185028272](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407191850351.png) > 负载电容是晶振两个段子之间的有效电容, 实际作用是反向位 > > [晶振旁边的两个电容起什么作用？_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV17C4y117PW/?spm_id_from 333.337.search card.all.click&vd_source 3771cc8df803eed7244034a762706c24) > > 这一个电容如果比较大会导致起振时间变长, 有可能导致单片机的启动出现问题"},"/note/嵌入式/index.html":{"title":"","content":"# 嵌入式"},"/note/嵌入式/补充知识/2024-1-10-04视频解码.html":{"title":"视频解码","content":" layout: post title: \"视频解码\" date: 2024 1 10 15:39:08 +0800 tags: stm32 # 视频解码 主要针对的是AVI格式的视频"},"/note/嵌入式/补充知识/2024-1-11-07IAP原子.html":{"title":"IAP技术","content":" layout: post title: \"IAP技术\" date: 2024 1 11 15:39:08 +0800 tags: stm32 # IAP ## stm32的三种烧录方式 ![image 20240111130718538](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111307598.png) ![image 20240111131054035](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111310098.png) ## 程序运行过程 ![image 20240111131318617](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111313687.png) ![image 20240111131711265](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111317349.png) ## 实际实现过程 ![image 20240111131908877](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111319919.png) ### 设置APP的起始位置以及存储空间的大小 起始位置的大小需要根据bootloader文件的大小 ![image 20240111132136687](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111321719.png) ![image 20240111132228831](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111322921.png) ![image 20240111133157369](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111331434.png) > 左侧是程序存放的内存, 右侧是程序的运行内存 ![image 20240111133356832](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111333864.png) ### 生成APP ![image 20240111133521988](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111335047.png)"},"/note/嵌入式/补充知识/2024-1-11-06T9拼音输入法.html":{"title":"T9拼音输入法","content":" layout: post title: \"T9拼音输入法\" date: 2024 1 10 15:39:08 +0800 tags: stm32 # T9拼音输入法 手机输入的标准之一, 就是九键输入法, 主要是为了解决在小型掌机上面的输入问题 ![image 20240111114829666](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111148224.png) ## 实现的原理 ![image 20240111115057007](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111150066.png) ![image 20240111115133566](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111151596.png) ## 实际使用 调用函数t9.getpymb()参数是当前输入的数字, 之后会返回是否完全匹配, 是的话返回匹配的个数, 不是的话会在最高位设置为1, 并且返回匹配的字符的个数, 这时候根据匹配的字符的个数进行调整输入的字符串 上面的函数最终调用的函数是get_matched_pymb 这个函数在返回是否匹配的同时在一个全局变量t9的变量pymb里面记录匹配到的数据, 之后可以直接通过返回的匹配个数与这一个全局变量进行配合获取实际获得的数据"},"/note/嵌入式/补充知识/2024-1-9-02图片显示.html":{"title":"图片显示","content":" layout: post title: \"图片显示\" date: 2024 1 9 15:39:08 +0800 tags: stm32 # 图片显示 常见的图片格式有BMP, JPEG(JPG), GIF ![image 20240109180120807](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091801876.png) ## BMP ![image 20240109180526796](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091805851.png) ## JPEG ![image 20240109180620210](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091806262.png) ## GIF ![image 20240109180916702](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091809764.png) ## 实际解码 ![image 20240109181122576](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091811633.png) > 用户主要调用的函数在piclib.c文件里面 ![image 20240109181258151](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091812204.png) ![image 20240109181355389](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091813446.png) ![image 20240109181443917](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091814976.png)"},"/note/嵌入式/补充知识/2024-1-10-05手写识别.html":{"title":"手写识别","content":" layout: post title: \"手写识别\" date: 2024 1 10 15:39:08 +0800 tags: stm32 # 手写识别 ![image 20240110204755842](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401102047924.png) ![image 20240110204812214](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401102048271.png) ![image 20240110205146248](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401102051310.png)"},"/note/嵌入式/补充知识/2024-9-14-08USB.html":{"title":"USB","content":" layout: post title: \"USB\" date: 2024 1 11 15:39:08 +0800 tags: stm32 # USB ## 基础知识 USB Host : 只有一个, 比如说电脑 USB Device: 可以有多个, 这些设备可以是一个集线器也可以是一个节点设备Node USB 2.0: 有三种全速FS(12Mbps)/高速HS(480Mbps)/低速(1.5Mbps) 所有的数据都是由主机发起的, 输入输出都是相对于主机的, 有四种传输类型: > 控制: 初始化的时候设置设备以及获取信息 > > 中断: 主机每一段时间询问一下从机是不是有数据 > > 批量: 硬盘跑大量数据的时候 > > 同步: 数据传输的时候有时间限制 > > [USB：USB通信中的端点(endpoint)和四种传输模式 夜行过客 博客园 (cnblogs.com)](https://www.cnblogs.com/yongdaimi/p/11981553.html) + STM 32 USB IP: 可以作为全速的设备, stm32f103, stm32f102 USB + IP: 全速的USB设备stm32f0x2 FS OTG IP: 全速以及低速主机, 全速stm32设备 stm32f105/stm32f107 stm32f2/4 HS OTG IP: 全速高速低速USB主机, 高速全速USB设备 STM32f2/f4 ## USB2.0协议 [USB 基本概念(2.0 为主) — CherryUSB 1.4.0 文档](https://cherryusb.readthedocs.io/zh cn/latest/usb/usb2.0_basic.html) 一个易用的可以满足高速传输的, 比较灵活的协议, 向下兼容 最大支持127个设备, 有多种错误校验以及恢复机制, USB接口一般是4根线，VCC GND DM(D ) DP(D+), 在OTG模式的时候有一根ID线用于切换这一个机器的主从模式, D+/ 是一个差分线 主机端将DM DP接入下拉电阻(15K)；设备端根据不同速度，将DM DP的某一根接上拉电阻(1.5K)，插入时通过压差即可判定是否插入 低速设备：在DM线上接入上拉 全速设备：在DP线上接入上拉 高速设备：在DP线上接入上拉，在主机对设备进行复位后进一步的确认，详情 > 在断电的时候就是两个引脚都为低电平 ![../_images/overview1.png](https://cherryusb.readthedocs.io/zh cn/latest/_images/overview1.png) USB设备的各个线之间会进行限制引脚的电压 ![../_images/overview2.png](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409141928750.png) ### 数据线状态 这两根线可以表示不同的状态 **差分 0 和差分 1**： 这两个状态用于通过 USB 进行的通用数据通信。当 D+线为高电平、 D 线为低电平时，该状态为差分 1。当 D+线为低电平、 D 线为高电平时，该状态为差分 0。 **J 状态和 K 状态**： 除了差分信号外， USB 规范还定义了其他两个差分状态： J 状态和 K 状态。它们的定义由设备速度决定。在全速和高速设备上， J 状态为差分 1 而 K 状态是差分 0。在低速设备上，该情况则相反。 **单端 0（ SE0）**： 在 D+和 D 均为低电平时所发生的状态。该状态表示一个复位、断连或数据包的结束。 **单端 1（ SE1）**： 在 D+和 D 均为高电平时发生的状态。不会故意生成该状态，并且不能在 USB 设计中出现。 **闲置**： 必须在发送一个数据包的前后发生的状态。如果一个数据线为低电平，而另一个数据线为高电平，则表示闲置状态。高电平和低电平的定义由设备的速度决定。在全速设备上，闲置状态是指 D+为高电平、 D 为低电平。在低速设备上，该情况则相反。 **恢复**： 用于使设备从挂起状态唤醒。通过发送一个 K 状态实现该操作。 **数据包的开始（ SOP）**： 当 D+和 D 线从闲置状态转换到 K 状态时，将在开始低速或全速数据包前发生。 **数据包的结束（ EOP）**： 在低速或全速数据包结束时发生。当 SE0 状态持续两位时间（后面的内容将介绍位时间）以及 J 状态持续 1 位时间时，将发生 EOP。 **复位**： 在 SE0 状态持续 10 ms 时发生。在 SE0 至少持续 2.5 ms 后，该设备会复位，并开始进入复位状态。 **保持活动（ Keep Alive）**： 在低速设备中使用的信号。低速设备缺少了一个帧起始数据包（用于防止挂起状态）。每次经过 1 ms，它们都会使用一个 EOP 来防止设备进入挂起状态。 > 实际的状态: 空闲 >K状态 >数据 >SEO >SEO >J状态 ### 供电 总线供电是 USB 设计的一个优势。由于设备通过总线供电，因此不需要使用笨重的内部或外部电源，它仍能够维持自身操作。总线可由主机或集线器供电。使用某个总线供电的设备时，用户将设备配置为某种状态前必须考虑其功耗。这一个供电有一个上限是500ma, 在实际使用这一个方式的时候需要设置一个SET_CONFIGURATION标志位, 在设置之前, 最大电流不超过100ma 自供电设备通过使用外部电源（如直流电源适配器或电池）为自己供电。自供电设备在进行设计的过程中需要考虑到一些注意事项。 USB 规范要求自供电设备一直监控自己的 VBUS 线。 VBUS 不存在的时间内，设备必须断开提供给 D+/D 线上的上拉电阻的电源，从而防止向主机或集线器供电。 否则，会导致 USB 合规性测试发生失败。但是自供电集线器能够从总线获得最多 100 mA 的电流。 也可以使用两种模式的配合, 实现使用USB进行充电 ### 连接状态 连接状态： 当将某个设备插入到主机/集线器，但主机/集线器不给 VBUS 线供电时，会出现这种状态。它通常在集线器检测到一个过流事件时出现。虽然仍连接着设备，但主机移除了供给它的电源。 供电： 某个设备被连接到 USB 上并得到供电，但仍未接收到一个复位请求。 默认： 某个设备被连接到 USB 上、得到供电，并且由主机进行了复位。这时，设备没有任何设备地址。 设备会响应地址 0。 地址： 某个设备被连接到 USB、得到供电、被复位，并且有一个唯一的地址。但是设备仍未得到配置。 配置： 设备已经连接到 USB、得到供电、被复位、具有唯一的地址、得到配置，但尚未进入挂起状态。此时，总线供电设备能够消耗超过 100 mA 的电流。 挂起： 如上面所述，设备已经建立好了连接，并且得到配置，但在 3 ms 时间内不会进行任意总线操作。 ![image 20240915095537562](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409150955632.png) ### 编码 USB在实际传输的时候没有使用有时钟线的传输, 为了使得传输的信息可以进行同步, 所以采用 RZ 编码 > RZ 编码（Return to zero Code），也叫做归零编码。在 RZ 编码中，正电平代表逻辑 1，负电平代表逻辑 0，并且，每传输完一位数据，信号返回到零电平，也就是说，信号线上会出现 3 种电平：正电平、负电平、零电平。 > > ![image 20240915095944790](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409150959822.png) > > 大部分的数据带宽，都用来传输“归零”而浪费掉了。 > > NRZ编码, 去掉归零的这一步 > > NRZI: NRZI 编码（Non Return to Zero Inverted Code）和 NRZ 的区别就是 NRZI 用信号的翻转代表一个逻辑，信号保持不变代表另外一个逻辑。 > > ![image 20240915100735270](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409151007306.png) > > 遇到 0 的边沿电平就翻转，遇到 1 的边沿则不变。这里的变化实际是K状态和J状态的变化, 在对数据进行着一个编码之前, 会对数据每6位连续的1插入一个0信号用于同步 ### 字段 USB 字段构成了 USB 通信中最基本也是最小的单元，后面的包、事务，最根本都是由字段构成，而字段又是由比特构成。字段部分见手册 8.1。使用LSB的发送顺序 + 同步字段SYNC 主机和设备不是共享一个时钟，这使得接收方没办法准确知道发送方什么时候发送数据，尽管能检测到SOP，但是远远不够，所有这个时候就需要同步字段，使得接收方和发送方收发过程中保持同步，所以任何一个包都要以同步字段开始。同步字段0x01，经过编码以后就是01010100B。 + 包标识符字段PID PID 由一个四位数据包类型字段和一个四位校验字段组成，占用 8 个bit，如图所示。 PID指示数据包的类型，并通过推断，数据包的格式和应用于数据包的错误检测类型包。 PID的四位校验字段是通过执行分组类型字段的一个补码来生成，从而确保PID的可靠解码，以便正确解释分组的其余部分，如果四个PID校验位不是它们各自的分组标识符位的补码，则存在PID错误。 ![image 20240915104251188](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409151042242.png) 既然是 4个比特，说明了 PID 类型可以分为16种，从16种中，又细分成4类：令牌 PID,数据 PID，握手 PID 和特殊 PID。 <img src \"https://cherryusb.readthedocs.io/zh cn/latest/_images/20.png\" alt \"../_images/20.png\" style \"zoom:150%;\" /> PID 含义 说明 : : : : : : 0001 令牌OUT 主机发送数据包USB设备 1001 临牌IN 主机接收USB设备发送的数据 0101 立牌SOF 一个帧或小帧的开始 1101 令牌SETUP 主机向从机发送配置信息 0010 握手ACK 数据正确接收 1010 握手NAK 数据没有正确接收 1110 握手STALL 使用的端点被挂起 0110 握手NYET 接收方没有响应 0011 数据DATA0 数据包偶数 1011 数据包DATA1 数据包奇数 0111 数据包DATA2 高速同步事务专用 1111 MDATA SPLIT事务专用 + 地址字段 地址字段又分为设备地址字段和端点地址字段，其中设备地址字段占用 7 个bit，除去0 地址，主机可以分配的地址有 127个。 端点地址字段占用 4个 bit，总共可以提供 16 个端点。LS设备最多3个 + 帧号域 11位, 主机每发出一个帧，帧号都会加1，如图所示。而高速设备中，帧中又包含微帧，1帧 8微帧，微帧则是加0.1。 ![image 20240915105551264](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409151055327.png) + 数据段 根据传输类型不同，数据字段中的数据长度也是不定的，从 0 1024不等。 + CRC校验 ### 包 令牌包、数据包、握手包、特殊包 ![image 20240915110458965](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409151104007.png) #### 令牌包 令牌包分为：SETUP、IN、OUT、SOF，其中 SETUP、IN、OUT的字段组成一样，如图： ![../_images/27.png](https://cherryusb.readthedocs.io/zh cn/latest/_images/27.png) PID 字段：定义了数据传输方向为USB主机到USB设备。 ADDR 字段：指明了USB设备地址。 ENDP 字段：指明了接收数据的端点号。 CRC 字段：用于ADDR字段和ENDP字段进行循环冗余校验。 SOF 包的字段组成，如图： ![../_images/28.png](https://cherryusb.readthedocs.io/zh cn/latest/_images/28.png) PID 字段：定义了数据传输方向为USB主机到USB设备。 帧号 字段：指明了USB传输的帧号，其11位。 CRC 字段：用于ADDR字段和ENDP字段进行循环冗余校验。 #### 数据包 ![../_images/29.png](https://cherryusb.readthedocs.io/zh cn/latest/_images/29.png) PID 字段：用于指明不同的数据包类型。支持 4 种数据包，分别为： DATAO 、 DATA1 、DATA2 和MDATA。 数据 字段：其中包含了传输的数据。其数据的大小根据数据传输类吧和用户需要而定。根据 USB 协议的规定，对于低速 USB 数据传输， 最大长度为8字节对于全速USB 数据传输，其最大长度为 1023 字节；对于高速 USB 数据传输，数据最大长度为 1024 。 CRC 字段：这里使用 16 位的循环冗余校验来对数据字段进行保护。 #### 握手包 握手包由8位的PID构成，用于数据传输的末位报告本次数据传输的状成。握手包之后使是整个事务处理的结束信号EOP. ![../_images/30.png](https://cherryusb.readthedocs.io/zh cn/latest/_images/30.png) #### 特殊包 ### 设备 在USB设备的逻辑组织中，包含设备、配置、接口和端点4个层次。 每个USB**设备**都提供了不同级别的**配置信息**，可以包含一个或多个配置，不同的配置使设备表现出不同的功能组合（在探测/连接期间需从其中选定一个），配置由多个接口组成。 在USB协议中，**接口**由多个端点组成，代表一个基本的功能，是USB设备驱动程序控制的对象，一个功能复杂的USB设备可以具有多个接口。每个配置中可以有多个接口，而设备接口是端点的汇集（collection）。例如USB扬声器可以包含一个音频接口以及对旋钮和按钮的接口。一个配置中的所有接口可以同时有效，并可被不同的驱动程序连接。每个接口可以有备用接口，以提供不同质量的服务参数。 **端点**是USB通信的最基本形式，每一个USB设备接口在主机看来就是一个端点的集合。主机只能通过端点与设备进行通信，以使用设备的功能。在USB系统中每一个端点都有惟一的地址，这是由设备地址和端点号给出的。每个端点都有一定的属性，其中包括传输方式、总线访问频率、带宽、端点号和数据包的最大容量等。一个USB端点只能在一个方向承载数据，或者从主机到设备（称为输出端点），或者从设备到主机（称为输入端点），因此端点可看作一个单向的管道。端点0通常为控制端点，用于设备初始化参数等。只要设备连接到USB上并且上电端点0就可以被访问。端点1、2等一般用作数据端点，存放主机与设备间往来的数据。 ![image 20240917193043826](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409171930901.png) ### 配置 **配置** (Configuration)：一个USB设备可以有多种配置。比如4G上网卡就有2种配置：U盘、上网卡。第1次把4G上网卡插入电脑时，它是一个U盘，可以安装里面的程序。装好程序后，把它再次插入电脑，它就是一个上网卡。[驱动程序](https://zhida.zhihu.com/search?q 驱动程序&zhida_source entity&is_preview 1)可以选择让它工作于哪种配置，同一时间只能有一种配置有效。大多数的USB设备只有一种配置。 ### EndPinot USB的Endpoint是USB设备与主机之间进行数据传输的通道。每个USB设备都包含一个或多个Endpoint，分为两种类型：IN Endpoint用于从设备向主机传输数据，OUT Endpoint用于从主机向设备传输数据。Endpoints根据其方向和类型，可以支持不同的数据传输速度和协议。通过Endpoint，USB设备可以与主机进行数据交换，实现数据的传输和通信功能。 端点位于USB 外设内部，所有通信数据的来源或目的都基于这些端点，是一个可寻址的FIFO。 每个USB 外设有一个唯一的地址，可能包含最多十六个端点。主机通过发出器件地址和每次数据传输的端点号，向一个具体端点(FIFO)发送数据。 每个端点的地址为0 到15，一个端点地址对应一个方向。所以，端点2 IN 与端点2 OUT 完全不同。 每个器件有一个默认的双向控制端点0，因此不存在端点0 IN 和端点0 OUT。 除了端点0，其余的端点在设备配置前，不能与主机通讯，只有向主机报告这些端点的特性并被激活后才能被激活。 ### USB请求 ![image 20240916105550147](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409161055239.png) 建立连接的时候发送过来的数据 #### 标准的请求 ![image 20240916110647008](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409161106071.png) > 在实际使用的时候电脑发来一个0x80 0x06 0x00 0x01 0x00 0x00 0x40 0x00 > > 这一个是向设备请求描述符, 获取描述符的时候, wValue表示的是描述符的种类以及序号, wIndex 0或者语言ID, wLength是描述符的长度, Data是数据 ##### 设置地址 ![image 20240917112342813](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409171123865.png) wValue的低字节是索引值。取0的索引值表示请求语言ID(LANGID)，其他索引值表示请求字符串。 ##### 获取描述符 + SRING_DESCRIPTOR wValue的低字节是索引值。取0的索引值表示请求语言ID(LANGID)，其他索引值表示请求字符串。 + DEVICE_DESCRIPTOR 获取设备描述符 + CONFIGURATION_DESCRIPTOR 获取配置描述符等一系列描述符 ##### 设置配置 ![image 20240918181245975](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409181812072.png) wValue字段的低字节指定所需的配置。该配置值应为零或与配置描述符(configuration descriptor)中的配置值(bConfigurationValue字段)匹配。如果该配置值与设备支持的配置相匹配，设备就会执行请求的配置。如果配置值为零，则设备将处于地址状态(Address state)，等待新的Set Configuration请求进行配置。wValue字段的高位节是保留的。 如果 wIndex，wLength，或者wValue 的高字节的值为非零值(non zero)，或者wValue 的低字节的值是设备所不支持的配置，那么设备将以请求错误来响应，返回STALL。 完成Set Configuration请求后，设备将进入配置状态(Configured state)。许多标准请求都需要设备进入配置状态才有效。 ## 描述符 [彻底搞懂USB描述符 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/656339393) ![image 20240916232311485](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409162323578.png) #### 设备描述符 + DEVICE_DESCRIPTOR \t\t\t\t0X01设备描述符 + CONFIGURATION_DESCRIPTOR\t 0X02配置描述符 + SRING_DESCRIPTOR\t\t\t 0X03字符串描述符, 用于显示的信息比如名字 + INTERFACE_DESCRIPTOR\t\t\t 0X04接口描述符 + ENDPOINT_DESCRIPTOR\t\t\t 0X05端点描述符 > 描述符的个数可能有多个 ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409162325808.webp) ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409162326692.webp) **bLength** 长度1字节，表示设备描述符的总长度，设备描述符的长度是18字节，写成[十六进制](https://zhida.zhihu.com/search?q 十六进制&zhida_source entity&is_preview 1)就是 0x12。 **bDescriptor** 长度1字节，表示描述符的类型。设备描述符的类型为0x01。 ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409162329333.webp) **bcdUSB** 长度为2字节，表示该设备支持的 USB 版本。它是使用 BCD 编码来实现的，采用 0xAABC 的形式，其中 A 是主版本号， B 是次版本号， C 是子次版本号。例如， USB 2.0 为 0x0200 ， USB 1.1 为 0x0110 。 **bDeviceClass** 长度1字节，设备的类代码，设备的类代码由USB协会规定，具体的类代码在官网[http://usb.org](https://link.zhihu.com/?target http%3A//usb.org)上搜索defined class codes就可以看到，对于大多数标准的USB设备，通常设置为0，而在接口描述符中的 bInterfaceClass 中指定接口所实现的功能。如果bDeviceClass为0xFF(Vendor Specific)，表示是厂商自定义的设备类。 [Defined Class Codes USB IF](https://usb.org/defined class codes) ![image 20240916232916373](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409162329414.png) **bDeviceSubClass** 长度1字节，设备所使用的子类代码，由USB协会规定，当bDeviceClass为0时，bDeviceSubClass也必须为0。 **bDeviceProtocol** 长度1字节，设备所使用的协议，协议代码由USB协会规定。bDeviceProtocol必须要结合设备类和设备子类联合使用才有意义，因此当类代码为0时，bDeviceProtocol也必须为0。 **bMaxPacketSize** 长度1字节，表示端点 0 支持的数据包的最大字节数量。数据包的大小可以为 8 个字节、 16 个字节、 32 个字节或 64 个字节。 ![image 20240917102957281](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409171029369.png) **idVender** 长度2字节，厂家ID号，由USB协会分配。 **idProduct** 长度2字节，产品ID号，由厂家自己决定，比较自由。 **bcdDevice** 长度2字节。 **iManufacturer、 iProduct 和 iSerialNumber** 长度均为1字节，都是字符串描述符索引。 字符串描述符包括有关制造商、产品和序列号等信息。如果存在字符串描述符，这些变量应该指向其索引位置。如果没有任何字符串，那么应该将零值填充到各个字段内。 **bNumConfigurations** 长度1字节，定义了设备可支持的配置总数。每种配置都会有一个配置描述符，大部分的USB设备只有一个配置。 #### 配置描述符 ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409171211409.jpeg) ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409171213934.webp) **bLength** 1字节，表示配置描述符的长度，配置描述符的长度是9字节。 **bDescriptor** 1字节，表示描述符的类型，配置描述符的类型编码为 0x02。 **wTotalLength** 2字节，是整个配置描述符集合的总长度。包括配置描述符，接口描述符，端点描述符和类特殊描述符（如果有）。 **bNumInterfaces** 1字节，则定义了在该指定配置中接口总数。最小为 1 个接口，通常功能单一的设备只有一个接口（如鼠标），而复合设备具有多个接口（如音频设备）。 **bConfigurationValue** 1字节，表示该配置的值，设置配置请求时会发送一个配置值，如果某个配置的bConfigurationValue和它相匹配，就表示该配置被激活。用于区分不同的配置, 这一个在实际设置的的时候需要是一个大于零的数字, 因为设置配置的时候0有特殊的用处 > 所谓配置请求是USB标准请求中的一种，后面会介绍。 **iConfiguration** 1字节，描述该配置的字符串的索引，如果该值为0，表示没有字符串来描述它。 **bmAttributes** 1字节，定义了 USB 设备的一些特性。 位7保留，必须设置为1，位6表示供电方式，设置为 0表示设备由总线供电，设置为 1 表示设备自供电。位5表示是否支持远程唤醒，设置为 1表示支持远程唤醒，设置为 0 表示不支持远程唤醒。位4~位0设置为0。 **bMaxPower** 1字节，表示设备需要从总线获取的最大电流量，以 2 mA 为单位。如需要200mA的最大电流，则该字段的值为100。 #### 接口描述符 ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409171220361.webp) ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409171220165.webp) **bLength** 1字节，表示接口描述符的长度，标准的接口描述符的长度为9字节。 **bDescriptorType** 1字节，表示描述符的类型，接口描述符的类型编码为 0x04。 **bInterfaceNumber** 1字节，表示该接口的编号，如果一个配置具有多个接口，每个接口的编号都不相同，从0开始依次递增对一个配置的接口进行编号。 **bAlternateSetting** 1字节，接口的备用编号，很少用到，设置为0。 **bNumEndpoints** 1字节，表示该接口的端点数（不包括0端点）。 **bInterfaceClass、bInterfaceSubClass、bInterfaceProtocol** 均为1字节，分别表示接口所使用的类，子类以及协议，由USB协会规定。如果使用的是HID协议, 这里bInterfaceClass是3 ![image 20240917191814948](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409171918033.png) bInterfaceSubClass, 由于HID数量以及种类比较多, 所以这一个现在仅用于设备是否支持启动接口 > 一般对PC机而言才有意义，意思是BIOS启动时能识别并使用您的[HID](https://www.usbzh.com/article/detail 76.html)设备，且只有标准鼠标或键盘类设备才能成为Boot Device，进入bios时不会枚举[报告描述符](https://www.usbzh.com/article/detail 48.html)，主机会采用一个默认的标准描述符，所以此时发送的报告要符合这个描述符，这是关键，标准描述符请查询[HID](https://www.usbzh.com/article/detail 76.html)协议。 ![image 20240917191852915](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409171918969.png) ![image 20240917191907506](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409171919564.png) **iInterface** 1字节，描述该接口的字符串的索引值，如果为0，表示没有字符串。 #### 端点描述符 ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409171933695.webp) ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409171934701.webp) **bLength** 1字节，表示端点描述符的长度，标准的端点描述符的长度为7字节。 **bDescriptorType** 1字节，表示描述符的类型，端点描述符的类型编码为 0x05。 **bEndpointAddress** 1字节，表示该端点的地址和方向。 **bmAttributes** 1字节，表示该端点的属性，详细看上表。 **wMaxPacketSize** 2字节，表示该端点的数据包最大长度。 **bInterval** 1字节 #### 语言ID描述符 ![image 20240917230932191](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409172309268.png) 这一个语言ID是USB里面有一个表, 可以填0x0409是English(United States) **语言ID描述符：**给大家明确一点，其实语言ID描述符也是字符串描述符，它比较特殊，是用来告诉主机**其他字符串描述符**里面的字符串都支持哪国家语言，因为USB标准全球都在用，字符串的显示形式也是各种各样。 #### 字符串描述符 1. bLength描述符长度，这里的长度不确定，因为字符串多长不定； 2. bDescriptorType描述符类型，字符串描述符类型为0x03； 3. bStringUNICODE编码的字符串。 ### HID设备 [Microsoft Word HID1_11.doc (usb.org)](https://www.usb.org/sites/default/files/documents/hid1_11.pdf) USB HID类是USB设备的一个标准设备类，包括的设备非常多。HID类设备定义它属于人机交互操作的设备，用于控制计算机操作的一些方面，如USB鼠标、USB键盘、USB游戏操纵杆等。但HID设备类不一定要有人机接口，只要符合HID类别规范的设备都是HID设备。 USB HID设备的一个好处就是操作系统自带了HID类的驱动程序，而用户无需去开发驱动程序，只要使用API系统调用即可完成通信。 所有的HID设备通过USB的控制管道（默认管道，即端点0）和中断管道（端点1或端点2）与主机进行通信。 在USB协议中，HID设备的类型定义放置在接口描述符中，USB的设备描述符和配置描述符中不包含HID设备的信息。因此，对于某些特定的HID设备，可以定义多个接口，一个接口为HID设备类即可。当USB一个设备为HID设备时，其设备描述符里面的bDeviceClass、bDeviceSubClass、bDeviceProtocol应为0，具体的定义在接口描述符中，接口描述符bInterfaceClass、bInterfaceSubClass、bInterfaceProtocol三个值 ![图片](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409180900732.png) 1. bLength 描述符长度。HID描述符长度不是固定的，长度多少与描述符中包含的下级描述符个数相关。如果只有一个下级描述符，也就是不包括可选的部分，一共有9字节的长度，如果有多个下级描述符，按照长度往上加。 2. bDescriptorType 描述符类型，设置为0x21。 3. bcdHID HID设备所遵循的HID版本号，为4位16进制的BCD码。1.0即0x0100，1.1即0x0110，2.0即0x0200。 4. bCountryCodeHID 设备国家/地区代码，如下表格自行查询。 ![图片](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409180904144.png) 5. bNumDescriptor HID设备支持的下级描述符的数量。在这里大家一定要注意，下一级描述符的类型有两种，报告描述符和物理描述符，对于HID设备报告描述符和物理描述符可以有多个，但是至少有一个报告描述符，物理描述符是可选的，bNumDescriptor表示报告描述符和物理描述符的个数总和。由于HID设备至少需要包括一个报告描述符，故其值至小为0x01，一般的HID设备也为1，也就是有一个报告描述符，物理描述符很少用到。 6. bDescriptorType 下级描述符的类型，下级描述符第1个必须是报告描述符，所以这里存放报告描述符类型，如下表格，报告描述符的类型为0x22，其他描述符的类型可速查。 ![image 20240918091146073](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409180911149.png) 7. wDescriptorLength 下级描述符的长度，下级描述符第1个必须是报告描述符，所以这里存放报告描述符的长度，每种HID设备的报告描述符长度是不一样的，比如STM32某HID设备的报告描述符长度为43字节 #### 报表描述符 + 报表描述符定义了执行设备功能的数据格式和使用方法。 + 报表描述符和 USB 的其他描述符是不一样的，它不是一个简单的表格，报表描述符是 USB 所有描述符中最复杂的。报 + 表描述符非常复杂而有弹性，因为它需要处理各种用途的设备报表的数据必须以简洁的格式来储存，这样才不会浪费 + 设备内的储存空间以及数据传输时的总线时间。实际上可以这样理解，报表内容的简洁，是通过报表描述符全面的、复杂的数据描述实现的。 + 报表描述符必须先描述数据的大小与内容。报表描述符的内容与大小因设备的不同而不同，在进行报表传输之前，主机必须先请求设备的报表描述符，只有得到了报表描述符才可正确解析报表的数据。 + 报表描述符是报表描述项目（Item）的集合，每一个描述项目都有相对统一的数据结构，项目很多，通过编码实现。 HID协议中规定了两种条目：短条目和长条目。长条目很少使用 **短条目由1字节前缀后面跟上可选的数据字节组成**。可选的数据字节可以为0字节，1字节，2字节或者4字节。实际所使用的条目，**大部分只有1字节的可选数据**。 ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409182218403.png) ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409182218084.png) ##### 短条目 ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409182222561.png) bTag ：代表在对应的 Item 下的更加细的分类，也可以称之为标签。 —— Main 分为：Input、Output、Feature、Collection、End Collection。 —— Global 分为：Usage Page、 Logical Minimum、Logical Maximum、Physical Minimum、Physical Maximum、Report Size、Report ID等等。 —— Local 分为 ：Usage 、Usage Minimum、Usage Maximum、String 等等。 ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409182228787.png) ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409182337115.png) 在实际使用的使用化会使用Usage Page 用来指定设备的功能，而 Usage 项目用来指定个别报表的功能。Usage Page 项目相当于是 HID 的子集合，Usage 相当于是 Usage Page 的子集合。 ##### 四种类型 [HID Usages and Descriptions (usb.org)](https://www.usb.org/sites/default/files/hut1_22.pdf) **Main类型的Tag** + Input: 设备向主机上报数据，bTag 0x8 + Output:主机向设备发送数据， bTag 0x9 + Feature：返回配置信息， bTag 0xB + Collection：数据分组开始， bTag 0xA + End Collection：:数据分组结束，, bTag 0xC 在这一个里面的input, output, Feature之后的32位数据里面定义了9个位 bit0~8 的定义中只有位 7 不能应用于 Input 项目，除此之外其他的位定义都适应于 Input、Output、Feature 项目。可以使用这几个位进行上传这一个数据的一些属性 ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409192242549.webp) > 之后主要使用的是INPUT > > Data/Constant: 这一个数值是不是一个可以变化的值 > > Array/Variable: Array每一个字段可是表示几个不同的操作的其中一个被触发, Variable表示一个操作 > > Absolute/Relative 这一个数值是一个相对值监还是绝对值 > > No Wrap/Wrap 是不是循环数 > > Linear/NoLinear 主项目数据与操作刻度是不是一个线性的 > > Preferred Stated/No Preferred 主项目的操作不再触发的时候会不会回复初始的值 > > No Null Positation/ Null State 主项目对应操作和有一个状态, 会不会发送一个无意义的数字(超出设定的范围) > > Non Volatile/Volatile 这一个数据可不可以被主机改变 > > Bit Field/Buffered Bytes数据以字节为单位, 不足的自动补全 collection 这一个属性的data主要有四个取值 Physical：物理层次描述，定义了设备的物理结构和连接方式，关注的是设备的物理特性和交互方式。例如，鼠标的按钮和滚轮。 Application：应用层次描述，定义了设备的输入和输出行为，以及设备与操作系统或应用程序之间的交互方式。例如，游戏手柄的按键和摇杆、音频设备的音量控制。 Logical：逻辑层次作为 Physical 和 Application 之间的桥梁，定义了[输入设备](https://zhida.zhihu.com/search?q 输入设备&zhida_source entity&is_preview 1)的逻辑结构和映射关系。例如，将鼠标的滚轮映射为音量控制功能。 Vendoer Defined ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409192245722.webp) **Global Item** 这一个主要适用于定义一个用途页, 数据域的长度, 数量, 报告的ID Global Item 对后续的所有 Item 有效，当遇到新的 Global Item 时才会变为新的定义数据。 Usage Page：用途页，bTag 0x0 Logical Minimum：逻辑最小值，bTag 0x1 Logical Maxinum：逻辑最大值，bTag 0x2 Physical Minimum：物理最小值， bTag 0x3, 设置一下 Physical Maximum：物理最大值，bTag 0x4 Report Size：数据域大小，表示每个数据域有多少位， bTag 0x7 Report Count: 有多少个数据域，bTag 0x9 ReportId:报告 ID, bTag 0x8 ![img](https://pic3.zhimg.com/80/v2 33b971ae0acb079a3054b4be8cd622b8_720w.webp) **Local Item** 定义数据的控制特性，如该数据域的用途，用途的最大值，用途的最小值等。 常用的有： + Usage :一个用途 + bTag 0x0 Usage Minmum:用途的最小值，bTag 0x1 + Usage Maxmum:用途的最大值，bTag 0x2 > 其中 Usage 描述用途的内容根据 Usage Page 的不同而不同，在确定 Usage Page 后可以从 **hut[8]** 中查询对应的 Usage 的含义， 例如当 Usage Page 是 Generic Desktop Ctrls 时，就需要从 **hut Table 4.1: Generic Desktop Page[9]** 中查找 Usage 的含义。 > > ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409192252753.webp) ##### 示例 > 这里主要的项目是INPUT, 其他的各个项适用于描述主要项目的 ```c Usage Page (Generic Desktop), Usage (Mouse), Collection (Application), Usage (Pointer), Collection (Physical), Report Count (3), Report Size (1), Usage Page (Buttons), Usage Minimum (1), Usage Maximum (3), Logical Minimum (0), Logical Maximum (1), Input (Data, Variable, Absolute), Report Count (1), Report Size (5), Input (Constant), Report Size (8), Report Count (2), Usage Page (Generic Desktop), Usage (X), Usage (Y), Logical Minimum ( 127), Logical Maximum (127), Input (Data, Variable, Relative), End Collection, End Collection ``` > 1. Usage Page (Generic Desktop): 指定了设备使用的通用桌面控制器页面，表示设备用于一般桌面控制的类型。 > 2. Usage (Mouse): 指定了设备的主要功能为鼠标，表示设备是一个鼠标设备。 > 3. Collection (Application): 表示这是一个应用程序集合，用于定义鼠标功能的应用程序。 > 4. Usage (Pointer): 指定了设备用于控制指针的功能。 > 5. Collection (Physical): 表示这是一个物理设备集合，在此情况下用于定义物理设备的属性。 > 6. Report Count (3): 定义了输入报告中的数据字段数量为3个。 > 7. Report Size (1): 定义了每个数据字段的大小为1字节。 > 8. Usage Page (Buttons): 指定了数据字段用于定义按键的页面。 > 9. Usage Minimum (1): 指定了按键的最小数量为1。 > 10. Usage Maximum (3): 指定了按键的最大数量为3。 > 11. Logical Minimum (0): 指定了逻辑上按键值的最小值为0。 > 12. Logical Maximum (1): 指定了逻辑上按键值的最大值为1。 > 13. Input (Data, Variable, Absolute): 定义了按键数据字段为可变且绝对值。 > 14. Report Count (1): 定义了输入报告中的数据字段数量为1个。 > 15. Report Size (5): 定义了每个数据字段的大小为5位。 > 16. Input (Constant): 定义了数据字段为常量。 > 17. Report Size (8): 定义了数据字段的大小为8位。 > 18. Report Count (2): 定义了输入报告中的数据字段数量为2个。 > 19. Usage Page (Generic Desktop): 重新指定了通用桌面控制器页面。 > 20. Usage (X), Usage (Y): 指定了设备的X轴和Y轴功能，用于控制鼠标光标的移动。 > 21. Logical Minimum ( 127): 指定了X和Y轴的最小逻辑值为 127。 > 22. Logical Maximum (127): 指定了X和Y轴的最大逻辑值为127。 > 23. Input (Data, Variable, Relative): 定义了X和Y轴数据字段为可变相对值。 > 24. End Collection: 结束物理设备集合。 > 25. End Collection: 结束应用程序集合。 + 这里的Usage (Mouse)去掉会导致什么 如果去掉Usage(Mouse)这一项，可能会导致操作系统无法正确识别这个USB设备作为鼠标设备。由于Usage项用于描述设备的主要功能类型，去掉了Usage(Mouse)可能会导致系统无法正确识别设备为鼠标，并可能导致设备无法正常工作或无法被操作系统正确配置。 + 这里两个Collection的作用 在USB设备描述符中，Collection用于定义继续的功能集合或者实体。在你给出的描述符中，有两个Collection，分别是Collection (Application) 和 Collection (Physical)。 1. Collection (Application): 这个Collection表示设备功能的应用程序集合，定义了设备用于鼠标控制功能的应用程序。它可以包含一组相关的功能或者数据字段，用于描述设备在应用程序级别上的功能。 2. Collection (Physical): 这个Collection表示设备的物理属性集合，用于定义物理设备的属性，如按键、轴等特性。它描述了设备的物理特性和与之相关的功能，用于帮助操作系统正确识别和处理设备的物理属性。 这两个Collection的作用是将USB设备的功能分组并进行描述，以便操作系统能够正确地解析设备的功能和属性，并相应地进行配置和处理数据。这些集合在USB描述符中提供了有组织的结构，帮助操作系统准确地理解USB设备的功能和特性。 ### CDC Class Definitions for Communication Device USB 通信设备类（或USB CDC类）是一个复合通用串行总线 设备类。 通信设备类用于类似于网卡的计算机网络设备，提供用于将以太网或ATM帧传输到某些物理介质的接口。它还用于调制解调器、ISDN、传真机和电话应用程序以执行常规语音呼叫。 #### USB描述符配置 [Microsoft Word usbcdc11 jh.doc (cscott.net)](https://cscott.net/usb_dev/data/devclass/usbcdc11.pdf) 这不是一个HID设备了, 而是一个CDC(Class Definitions for Communication Device) 需要使用两个接口以及端点, 分别是控制类的以及数据类的 ![image 20240929225448696](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409292254784.png) 以下是这一个实现虚拟串口使用的类(第一个接口 Communication Class Endpoint Requirement) ![image 20240929225429355](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409292254445.png) ![image 20240929225258387](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409292252669.png) ![image 20240929225329948](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409292253050.png) ![image 20240929225744382](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409292257477.png) 第二个接口 ![image 20240929230039989](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409292300093.png) #### 功能描述符 Descriptors 这一章里面是各种描述符, 需要关注一下Function Descriptor这一个描述符 需要实现的是Header Functional Descriptor, Call Management Function Descriptor, Abstract Control Management Functional Descriptor, Union Functional Descriptor 下面是通用的格式 ![image 20240929230634852](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409292306942.png) ![image 20240929230645973](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409292306073.png) > bDescriptor以及bDescriptorSubtype的值是用于区分不同的描述符种类 > > ![image 20240929231431312](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409292314403.png) > > ![image 20240929231446723](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409292314840.png) > > ![image 20240929231457302](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409292314441.png) ## 实际使用 ## USB枚举 当 USB设备与USB主机连接以后主机就会对 USB设备进行枚举，通过枚举来获取设备的描述符信息，主机得到这些信息以后就知道该加载什么样的驱动、如何进行通信等。USB枚举过程如下： 1. 第一回合，当 USB 主机检测到 USB 设备插入以后主机会发出总线复位信号来复位设备。USB设备复位完成以后地址为 0，主机向地址 0的端点 0发送数据，请求设备的描述符。设备得到请求以后就会按照主机的要求将设备描述符发送给主机，主机得到设备发送过来的设备描述符以后，如果确认无误就会向设备返回一个确认数据包(ACK)。 2. 第二回合，主机再次复位设备，进入地址设置阶段。主机向地址 0的端点0发送设置地址请求数据包，新的设备地址就包含在这个数据包中，因此没有数据过程。设备进入状态过程，等待主机请求状态返回，收到以后设备就会向主机发送一个 0字节状态数据包，表明设备已经设置好地址了，主机收到这个 0 字节状态数据包以后会返回一个确认包(ACK)。设备收到主机发送的ACK包以后就会使用这个新的设备地址，至此设备就得到了一个唯一的地址。 3. 第三回合，主机向新的设备地址端点 0发送请求设备描述符数据包，这一次主机要获取整个设备描述符，一共是 18个字节 4. 接下来依次获取配置描述符、配置集合、字符串描述符等等 可以使用PDIUSBD11（I2C 接口）、PDIUSBP11A、PDIUSBD12（并行接口）等芯片进行实现 ![](https://img blog.csdn.net/20130829155301890?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbmV2ZXJfbmV2ZXJfZ2l2ZV91cA /font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA /dissolve/70/gravity/Center) 初始化以后检测中断, 中断发生以后获取一下中断的状态Read interrupt registe 同时可以获取实际发生的中断的位置 ![image 20240917111041019](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409171110087.png) 这一个状态需要进行进行清除 Read Last Transaction Status, 这一个命令可以同时获取中断的状态, 以及是不是一个SETUP包, 在获取这些信息以后可以进行读取 ![image 20240917111006634](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409171110711.png) ### 设备描述符 在电脑进行连接的时候使用的是Endpoint0, 发过来的数据是0x80 0x06 0x00 0x01 0x00 0x00 0x40 0x00, 实际获取数据的时候需要先选择一下使用的端口`Select Endpoint`, 之后Read buffer, 这一个发送的数据第一个是没有用的, 第二个数据是数据的长度, 在读取结束以后这一个buf需要被清除, 使用命令Clear buffer > 在这里获取的数据是一个描述符, 需0要根据USB请求进行分析处理, 获取请求的方向以及请求的数据, 看一下是不是一个标准请求 > > 如果是一个标准请求需要进一步处理看看请求的数据是哪一个 如果获取的是一个SETUP数据包的, 需要使用Acknowledge setup命令来重新使能一下buffer, 否则不能获取新的数据, 在使用Acknowledge setup命令的时候, 输入和输出两个通道都需要发送这个命令 获取的数据需要进行解析, 判断一下这一个描述符的种类以及编号, 之后初始化一下设备描述符 **bcdUSB:** USB版本号, 0x0110 **bDeviceClass bDeviceSubClass bDeviceProtocol** 设置为0, 在之后配置 **bMaxPacketSize0:** 设置包的大小, 16 **idVendor:** 厂商编号 **idProder:** 产品编号 **bcdDevice** 出厂编号 **iManufacturer、 iProduct 和 iSerialNumber** 长度均为1字节，都是字符串描述符索引。 字符串描述符包括有关制造商、产品和序列号等信息。如果存在字符串描述符，这些变量应该指向其索引位置。如果没有任何字符串，那么应该将零值填充到各个字段内。这里设置为 1 2 3 **bNumConfigurations** 配置的数量 > 发送数据的时候由于设备不可以发起发送, 所以是在IN中断里面进行发送的, 获取到的中断状态是获取描述符, 每一次中断只能写一次数据没有结束都再有一次中断, 在发起中断的时候会传过来对方可以接受的字节个数, 需要进行比较 ### 设置地址 获取的第二个请求是一个设置地址的USB请求, 主机会发送多次不同的地址, 使用命令Set Address ![image 20240917113607633](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409171136691.png) 发送结束以后在发送一个数据长度为0的数据包, 回复以后会使用新设置的设备号获取一下设备描述符 ### 获取描述符 在获取成功以后会进行请求配置描述符, 这一个配置描述符在发送的时候需要把接口描述符, 端点描述符和HID描述符一次性发出去 首先是一个配置描述符, 之后是接口, HID描述符和端点描述符 + 配置描述符 bLength: 描述符大小 bDescriptorType: 0x02 配置描述符的种类 wTotallLength: 这一个是所有的结构体的大小之和 bNumInterfaces: 接口的数量, 这里是一个 bConfigurationValue 这一个配置的编号 1 iConfigurationValue: 配置描述符的描述字符串的值 0 iConfiguration: 这一个值是一个用于 bmAttributes: 参数, 供电模式 0x80 总线供电 bMaxPower: 200 > 400mA + 接口描述符 bDescriptorType: 接口描述符的种类, 0x04 bInterfaceNumber, bAlternateSetting: 两个接口描述符的编号 0 , 0 bNumEndpoints: 端点的数量, 1 bInterfaceClass、bInterfaceSubClass、bInterfaceProtocol 均为1字节，分别表示接口所使用的类，子类以及协议, 这里使用HID鼠标, 3, 1, 2 iInterface: 描述字符串 0 + HID描述符 bDescriptorType: 0x21 描述符的类型 bcdHID : HID版本号0x0101 bCountryCodeHID: 硬件国家, 0x33 美国 bNumDescriptor: 几个描述符 1 bDescriptorType: 0x22 报表描述符 wDescriptorLength: 长度, + 端点描述符 bLength 1字节，表示端点描述符的长度，标准的端点描述符的长度为7字节。 bDescriptorType 1字节，表示描述符的类型，端点描述符的类型编码为 0x05。 bEndpointAddress 1字节，表示该端点的地址和方向。0x81, 一号端点是一个IN bmAttributes 1字节，表示该端点的属性 3 一个中断端点 wMaxPacketSize 2字节，表示该端点的数据包最大长度。 16 bInterval 1字节, 轮询时间 #### 设置配置 这里主机设置配置为1, 启用端点1, Set Endpoint Enable , 之后写一个0x01就可以启用 ![image 20240918185512690](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202409181855884.png) #### 获取HID描述符 这一个描述符是使用的获取描述符格式里面的但是不是默认的五个里面的, 这一个请求的Type是在HID描述符里面的bDescriptorType这一个值里面进行设置的值, 之前设置的是0x22 这一个描述符按照一个标准的鼠标描述符设置 #### 返回数据 之前设置的是3个字节的数据, 第一个字节是三个按键, 后面的两个字节是指针的位移 这时候返回使用的是端点一, 发送的时候使用命令选择一下对应的endpoint, 之后是一个endpoint的写命令, 数据写一个0, 一个数据的大小, 数据, Validate_buffer命令 > When the microprocessor has written data into an IN buffer, it should set the buffer full flag by the Validate Buffer command. This indicates that the data in the buffer are valid and can be sent to the host when the next IN token is received ### 键盘 使用另一个厂商编号, 需要使用输入输出, 所以再加一个端点, 加一个端点描述符, 只改变一下方向, 配置描述符里面长度改一下, 在接口描述符里面加一个端点的数量, HID子协议使用键盘 [USB协议中HID设备描述符以及键盘按键值对应编码表_usb hid键盘码表的完整列表。 CSDN博客](https://blog.csdn.net/u012388993/article/details/116395497#:~:text USB HID设备描) ```c ; ;HID Reports Descriptor 报表描述符 ; DB 0x05, 1 ; Usage Page (1: Generic Desktop) DB 0x09, 6 ; Usage (6: Keyboard) 表示报表定义的是HID键盘 DB 0xA1, 1 ; Collection (1: Application) 集合开始 ; ; 以下定义了键盘的修饰键输入报表，共有8个键，组成一个字节 ; 用法见HID Usage Table中的第10节中的键盘用法定义 DB 0x05, 7 ; Usage page (7: Key Codes) DB 0x19, 224 ; Usage Minimum (224) DB 0x29, 231 ; Usage Maximum (231) DB 0x15, 0 ; Logical Minimum (0) DB 0x25, 1 ; Logical Maximum (1) DB 0x75, 1 ; Report Size (1) DB 0x95, 8 ; Report Count (8) DB 0x81, 2 ; Input (Data,Variable,Absolute) ; ; 以下定义了一个保留字节的输入报表 DB 0x95, 1 ; Report Count (1) DB 0x75, 8 ; Report Size (8), DB 0x81, 1 ; Input (Constant) Reserved Byte ; ; 以下定义了键盘的LED指示灯输出报表项目，共有5个指示灯 ; 用法见HID Usage Table中的第11节中的LED用法定义 DB 0x95, 5 ; Report Count (5) ``` ```bash USAGE_PAGE(Generic Desktop) USAGE(Keyboard) COLLECTION(Application) \tUSAGE_PAGE(Keyboard) \tUSAGE_MINIMUM(Keyboard a and A) \tUSAGE_MAXIMUM(Keyboard f and F) \tLOGICAL_MINIMUM(0) \tLOGICAL_MAXIMUM(1) \tREPORT_SIZE(1) \tREPORT_COUNT(6) \tINPUT(Data, Ary, Abs) \tUSAGE_PAGE(LEDs) \tUSAGE_MINIMUM(Num Lock) \tUSAGE_MAXIMUM(Scroll Lock) \tLOGICAL_MINIMUM(0) \tLOGICAL_MAXIMUM(1) \tREPORT_SIZE(1) \tREPORT_COUNT(3) \tOUTPUT(Data, Ary, Abs) \tREPORT_SIZE(5) \tREPORT_COUNT(1) \tOUTPUT(Cnst, Ary, Abs) END_COLLECTION ``` 之后可以使用端点2中断进行获取灯的信息 ### 串口"},"/note/嵌入式/补充知识/2023-11-7-IAP技术.html":{"title":"IAP技术","content":" layout: post title: \"IAP技术\" date: 2023 11 7 15:39:08 +0800 tags: stm32 **这个是B站\"不烧板子\"的视频学习记录,大部分笔记也是直接复制的** # IAP技术 ## **ICP**: In Circuit Programming 在电路中编程。使用厂家配套的软件或仿真器进行程序烧录，目前主流的有JTAG接口和SWD接口，常用的烧录工具为J Link、ST Link等。 ## ISP: In System Programing 在系统编程的时候, 以STM32为例, 内置了一个bootloader, 可以通过BOOT引脚电平来运行这一段程序, 再通过ISP编程工具下载进去, 下载之后更正BOOT到正常的状态使得MCU运行下载的程序 ## IAP: In Application Programming 在应用中编程。IAP可以使用微控制器支持的任一种通信接口（如I/O端口、USB、CAN、UART、I2C、SPI等）下载程序或数据到FLASH中。IAP允许用户在程序运行时重新烧写FLASH中的内容。但需要注意，IAP要求至少有一部分程序（Bootloader）已经使用ICP或ISP烧到FLASH中。 ![image 20231107121723850](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311071217913.png) 无论是ICP技术还是ISP技术，都需要连接下载线，设置跳线帽等操作。一般来说，产品的电路板都会密封在外壳中，在这时若要使用ICP或ISP的方式对程序进行更新，则必然要拆装外壳，如果产品的数量比较多，将花费很多不必要的时间。 采用IAP编程技术，可以在一定程度上避免上述的情况。一般情况下，产品的外壳都会留有通信接口，若能通过这种通信方式对程序进行升级，则可以省去拆装的麻烦。在此基础上，若引入远距离或无线数据传输方案，更可以实现远程编程或无线编程。 ## 2 IAP方案设计 ### 2.1 IAP简介 IAP技术的核心在于BootLoader程序的设计，这段程序预先烧录在单片机中，正常的APP程序可以使用BootLoader程序中的IAP功能写入，也可以两部分代码一起写入，以后需要程序更新时通过IAP进行代码更新。每次板卡上电都会首先执行BootLoader程序，在程序内判断进行固件升级还是跳转到正常的APP程序。 ![202311071223689.png](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311071223689.png) 是否进行固件升级的判断可以从硬件和软件两个方面进行考虑。 1. 硬件实现：通过拨码开关、跳线帽等方式设定单片机某一引脚电平状态，程序通过读取引脚电平判断是否需要升级。此种方式需要接触板卡进行操作，当板卡被封闭在外壳中或安装于不便于操作位置时很难实现。 2. 软件实现 1：软件内设定一标志位（变量），通过判断标志位状态判断是否需要升级。该标志位状态掉电不能改变，故需要存储在外部EEPROM或单片机内部FLASH中。若存储在外部EEPROM，则需要增加额外的电路；若存储在单片机内部FLASH，由于FLASH每次写入都需要擦除一整页，会造成资源浪费。 3. 软件实现 2：单片机每次上电首先进入BootLoader程序，在BootLoader中等待一定时间，若上位机软件在该时间段内发起通讯，则停留在BootLoader程序中等待固件升级；若该时间段内无通讯，则跳转到正常的APP程序。该方式每次上电都要等待一定时间，需要考虑是否可以接受。 4. …… 在IAP过程中，单片机通过特定的通讯方式从上位机软件接收程序数据，并执行FLASH擦写操作对APP部分的程序进行更新。 IAP过程中传输的数据文件一般为后缀名为bin的文件，该文件内容与正常烧录进FLASH中的数据内容一致，便于程序升级。但是MDK软件并不能直接生成bin文件，需要进行一些配置。 ![image 20231107122511789](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311071225851.png) ```bash fromelf.exe bin o ..\\OBJ\\TIMER.bin ..\\OBJ\\TIMER.axf //“TIMER”需要改成自己程序的名字 ``` 由于我把fromelf.exe所在目录添加到了环境变量，所以可以直接这样写。如未添加环境变量，则需要写清楚详细路径，该文件一般在MDK软件的安装目录下。 ![image 20231107122932799](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311071229840.png) ### 2.2 FLASH空间划分 BootLoader程序和APP 程序存放在 STM32 FLASH 的不同地址范围，一般从最低地址区开始存放 BootLoader，紧跟其后的就是 APP 程序。在FLASH足够大的情况下，还可以分配多个APP程序区域，便于恢复默认程序或者执行多段功能不同的程序。"},"/note/嵌入式/补充知识/2023-7-13-17液晶屏显示字符.html":{"title":"液晶屏显示字符","content":" layout: post title: \"液晶屏显示字符\" date: 2023 7 13 15:39:08 +0800 tags: stm32 # 液晶屏显示字符 ASCII只有255个字符 GB2312: 兼容ASCII前127位, 两个大于127的数字连用表示一个汉字, 一共有八千多个符号, 包含6763个汉字, ASCII之中的的有的也是用两个字节进行编码, 叫做全角, 一般使用半角, 一般使用0xa1开始表示 区位码: 每一个区对应94个字符, 一共有94个区, 可以表示8836个码位, 每个字符有两个字节表示, 第一个字节表示区位码, 第二个字节表示的是位, 范围是0101 9494, 再加上0xa0就可以表示 GBK: 在GB2312的基础上增加了14240个新的汉字, 由于原来的格式原来的格式已经存放不下, 所以要求第一个编码大于127就可以了 GB18030: 在GBK上面进一步扩展, 第二个字节未使用的0x30 0x39编码表示扩充为四个字节, 兼容前几个, 只要增加了中日韩统一汉字编码扩充 Unicode: 各个国家制作的统一的字符集, 兼容ASCII, 还有一些表情emoji, 只是进行编号, 没有进行编码, 就是只是用一个数字代表一个字符, 但是没有使用具体的电脑解析的规范 utf 32: 编码和编号一样, 每一个字符使用4个字节进行表示, 前面的0不能省略, 会导致ASCII等编码变长 utf 16: 使用两个或者四个字节进行编写, 由于发现Unicode没有使用0xD800到0xDBFF所以利用这片空间表示映射 , 使用这一空间达到变长的目的 utf 8: 网页上使用的比较多, 也是一种变长的编码格式, 第一位设置为0, 就可以兼容ASCII的0 127, 其他的字符, 两个字节的时候第一个字节使用110开头, 第二个字节使用10开头, 三个字节的时候会使用1110开头, 之后是使用10开头, 以此类推, 将Unicode编码填入空位, 从最后一个字节开始填写, 不够的在前面加0 BOM: UTF16, UTF32使用的大小端各式需要标记, Linux默认没有这个BOM ![image 20230713150336782](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281044813.png) ## 字模 实际上字符就是一个图形 ![image 20230713154917469](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281044814.png) 使用这个软件进行生成, ### GB2312 实际使用的编码位是0xA1A1 FEFE, 汉字的区域是B0A1 F7FE, 原因是为了兼容ASCII, 最高位为1, 并且预留0x20个控制位 GB2312编码对收录的字符进行分区, 分为94个区, 每一个区有94个位, 一共有8836个码位 第16个区开始是汉字, 0 9是682个汉字以外的字符 10 15是空白区域没有使用 16 55是一级汉字, 按照拼音进行排序 56 87区收录3008个二级汉字, 按照部首进行排序 88 94是空白区没有使用 实际使用的时候就是: 区码加位码+A0A0, 比如''啊''是16区第一个, 就是0x1001+0xA0A0 实际在使用字模库的时候由于没有进行兼容偏移, 所以使用的是字符的在总个数的排序 Addr (((ColdH 0xA0 1)* 94) + (CodeL 0xA0 1))\\*32\\*32/8 > 在这里面会除去前面为了兼容ASCII不使用的字节, 以及空白字符和每一个区里面的空位 ## GBK ![image 20240109151502178](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091515285.png) ![image 20240109153557444](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091535533.png)"},"/note/嵌入式/补充知识/2024-1-10-03图片存储.html":{"title":"摄像头输出图片","content":" layout: post title: \"摄像头输出图片\" date: 2024 1 10 15:39:08 +0800 tags: stm32 # 摄像头输出图片 图片的格式要看摄像头有没有输出对应图片的数据流 OV7725 >bmp OV2640,OV5640 > bmp jpg 主要就是通过文件的编码把文件通过文件系统存放在SD卡里面 ## BMP编码 BMP全程Bitmap, 是Windows里面的标准图像文件格式, 采用位映射存储方式, 不压缩, 图像深度有1, 4, 8, 16, 24, 32bit 存储的时候扫描方向是从左到右, 从下到上 优点: 不失真, 画质好 缺点: 占用空间比较大 主要有四部分组成, 文件头, 位图信息头, 颜色表, 位图数据 ![image 20240110114549481](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401101145622.png) ![image 20240110114652572](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401101146649.png) ![image 20240110114743999](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401101147047.png) > 小端存储, 大小是BB842, 偏移是42 ![image 20240110115846954](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401101158055.png) ![image 20240110115958538](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401101159622.png) ![image 20240110120250997](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401101202061.png) > RGB掩码：RGB掩码用于指定每个颜色通道的位数和位偏移。通常情况下，颜色通道的顺序是蓝色、绿色和红色。比如，对于32位的BMP文件，RGB掩码为(0x00FF0000, 0x0000FF00, 0x000000FF)，分别表示红色、绿色和蓝色的掩码。 > > ![image 20240110120927530](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401101209551.png) > > ![image 20240110120920095](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401101209115.png) > > ![image 20240110120912126](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401101209144.png) ![image 20240110165409122](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401101654239.png) ![image 20240110165713733](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401101657790.png) ![image 20240110165840295](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401101658373.png) ![image 20240110170058635](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401101700694.png) ## JPEG编码 ![image 20240110170211565](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401101702618.png) > 由于摄像头输出的格式直接就是这一个的格式, 所以只要捕捉到文件的头和尾就可以了 头: 0xff 0xD8 尾: 0xff 0xD9 ![image 20240110170553394](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401101705458.png)"},"/note/嵌入式/嵌入式Linux编程入门与实例开发/2022-8-24-嵌入式系统基础.html":{"title":"嵌入式系统基础","content":" layout: post title: \"嵌入式系统基础\" date: 2022 8 23 15:39:08 +0800 tags: 嵌入式 《嵌入式Linux编程入门与实例开发》 # 嵌入式系统基础 ### 概述 专用性强, 实时性好, 可裁剪性, 可靠性高, 功耗低, 系统内核小, 有专门的开发工具, 开发环境, 多技术的融合 ### 嵌入式操作系统 嵌入式操作系统是一种支持嵌入式系统应用的操作系统软件, 能够有效管理复杂的系统资源，并且把硬件虚拟化 有两种类型 + 商用型实时操作系统, 稳定可靠, 有完善的技术支持, 售后服务 + 免费嵌入式实时操作系统, 价格方面优势, 但是稳定性服务型存在挑战 ## Linux操作系统 linux分为两个版本, 内核版本和发行版本 内核版本是指Linus领导的开发小组所开发的操作系统内核的版本号, 有时会附加第几次修改, 由3个部分组成，即主版本号、次版本号和次次版本号, 次版本号为奇数，表示该版本为测试版；次版本号为偶数，表示是个稳定版本，可以放心使用, 内核只是操作系统的核心, 负责控制硬件, 管理文件系统, 程序进程等, 不负责提供应用程序 以Linux Kernel为核心再集成搭配各式各样的系统程序或应用工具程序组成一套完整的操作系统。经过如此组合的Linux套件称为Linux发行版。 ### 特点 开源, 多用户多任务, 良好的用户界面, 独立的设备, 丰富的网络, 出色的速度, 良好的移植姓, 只有%10以下的使用汇编 ## ARM微处理器平台 ### 处理器的体系结构 #### 工作状态 有两种 + ARM状态, 处理32位字节对齐ARM指令 + Thumb状态, 处理16位半字节对齐Thumb指令 可以随时在两种工作状态之间切换，并且，微处理器工作状态的转变并不影响处理器的工作模式和相应寄存器中的内容, 使用BX指令, 操作数寄存器bit0为1的时候ARM #### 存储格式 + 大端模式, 数据的高字节存储在低字节 + 小端模式, 和大端模式相反 #### 处理器的模式 + 用户模式（usr）：ARM处理器正常的程序执行状态。 + 快速中断模式（fiq）：用于高速数据传输或通道处理。 + 外部中断模式（irq）：用于通用的中断处理。 + 管理模式（svc）：操作系统使用的保护模式。 + 数据访问终止模式（abt）：当数据或指令预取终止时进入该模式，可用于虚拟存储及存储保护。 + 系统模式（sys）：运行具有特权的操作系统任务。 + 定义指令中止模式（und）：当未定义的指令执行时进入该模式，可用于支持硬件协处理器的软件仿真. 通过软件改变，也可以通过外部中断或异常处理改变 ### 指令集 ARM指令集是以32位二进制编码的方式给出的, ARM指令根据CPSR中的条件位自动判断是否执行指令 可以分为6大类，分别为数据处理指令、Load/Store指令、跳转指令、程序状态寄存器处理指令、协处理器指令和异常产生指令。 ``` opcode>{<cond>}{S}<Rd>，<Rn>{，<operand2>} ``` + opcode：指令助记符，如LDR、STR等。 + cond：可选的条件码，如EQ、NE等。 + S：可选后缀，若指定“S”，则根据指令执行结果更新CPSR中的条件码。 + Rd：目标寄存器。 + Rn：存放第1操作数的寄存器。 + operand2：第2个操作数。 ### 处理器的系列 #### ARM7 低功耗, 对于价格功耗要求较高, ARM7TDMI是目前使用最广泛的32位嵌入式RISC处理器，属低端ARM处理器核。ARM7系列处理器没有内存管理单元（MMU） ### ARM9 高性能, 低功耗 #### ARM9E 使用单一的处理器内核提供了微控制器、DSP、Java应用系统的解决方案, 增强的DSP(数字信号处理)处理能力，很适合于那些需要同时使用DSP和微控制器 #### ARM10E 在同样的时钟频率下，性能提高了近50% #### ARM 11 ARM11的媒体处理能力和低功耗特点特别适用于无线和消费类电子产品 #### SecurCore微处理器系列 专为安全需要而设计，提供了完善的32位RISC技术的安全解决方案 #### XScale处理器 基于ARMv5TE体系结构的解决方案，是一款全性能、高性价比、低功耗的处理器 #### StrongARM微处理器系列 它融合了Intel公司的设计和处理技术以及ARM体系结构的电源效率, 便携式通信产品和消费类电子产品的理想选择 #### Cortex微处理器 ### 特点 低功耗, 低成本, 高性能, 双指令集可优化程序, 大量寄存器加快运行速度, 寻址灵活, 指令固定长度 ### 结构 传统的计算机对于不通指令均匀分配, 不合理, ARM采用RISC RISC并非只是简单地去减少指令，而是把着眼点放在了如何使计算机的结构更加简单合理地提高运算速度上。RISC结构优先选取使用 频率最高的简单指令，避免复杂指令，将指令长度固定，指令格式和寻址方式种类减少， 以控制逻辑为主，不用或少用微码控制等措施来达到上述 ARM还采用了一系列的优化处理 不能认为RISC架构就可以取代CISC架构。 事实上，RISC和CISC各有优势，而且界限并不那么明显。现代的CPU往往采用CISC的外围，内部加入了RISC的特性 #### 寄存器结构 共有37个寄存器 + 31个通用寄存器，包括程序计数器（PC指针），均为32位的寄存器。 + 6个状态寄存器，用以标识CPU的工作状态及程序的运行状态，均为32位，目前只使用了其中的一部分 在每一种处理器模式下均有一组相应的寄存器与之对应，即在任意一种处理器模式下，可访问的寄存器包括15个通用寄存器（R0～R14）、1～2个状态寄存器和程序计数器 #### 指令结构 ARM指令的长度为32位，Thumb指令的长度为16位。Thumb指令集为ARM指令集的功能子集"},"/note/嵌入式/stm32/蓝桥杯备赛/2024-3-10-01.html":{"title":"01","content":" layout: post title: \"01\" date: 2024 3 10 15:39:08 +0800 tags: stm32 蓝桥杯 # 01 ## 芯片基础知识(比赛的话不需要太了解) ![image 20240310185552935](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403101855203.png) ## 外设(需要重点关注) ### GPIO #### 输入输出模式 ![image 20240310192643548](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403101926611.png) #### 复用 ![image 20240310191433902](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403101914987.png) 这一个表是数据手册里面的4.11 > 引脚的复用, 比如使用PA9作为USART_TX的时候, 把他配置为AF7 > > ![image 20240310191637675](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403101916724.png) > > 这一个是参考手册里面的9.4 > > > 使用这一个寄存器配置实际的复用功能 > > > > ![image 20240310191823289](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403101918337.png) ### 通用定时器 G4的通用定时器有好几种模式, 主要的区别是可以使用的通道的数量 ![image 20240311165053944](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403111650030.png) ![image 20240311165022510](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403111650590.png) ![image 20240311164957100](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403111649224.png) #### 定时功能 使用定时器的时候使用HAL_TIM_Base_Start();HAL_TIM_Base_Start_IT();HAL_TIM_Base_Start_DMA();进行开启 可以使用函数HAL_TIM_Base_GetState();获取时钟的状态 使用`__HAL_TIM_GET_COUNTER()`获取计数器的值, `__HAL_TIM_SET_COUNTER()`进行设置 使用`__HAL_TIM_GET_AUTORELOAD()`获取这一个时钟的自动重装载值, 使用这一个时候最好打开影子寄存器 ![image 20240312230937476](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403122309575.png) `__HAL_TIM_SET_PRESCALER()`处理预分频值 #### PWM 使用这一个模式的时候, 先在对应的引脚选择一个定时器的通道 ![image 20240311173239988](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403111732054.png) ![image 20240311173308458](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403111733522.png) ![image 20240311174210763](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403111742839.png) 代码使用的时候需要打开PWM, 使用函数HAL_TIM_PWM_Start(); #### 输入捕获 ![image 20240311194546528](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403111945586.png) ![image 20240311194442648](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403111944730.png) > 实际捕获的时候使用HAL_TIM_IC_Start_IT()开启这一个捕获 ```c void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim){ \tif(htim >Instance TIM17){ \t\tcurr_val HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1); \t\t__HAL_TIM_SET_COUNTER(htim, 0); \t\tfrq (80000000 / 80) / curr_val; \t\tHAL_TIM_IC_Start_IT(htim, TIM_CHANNEL_1); \t} } ``` > 使用这一个计算PWM的频率 如果要捕获占空比, 可以使用一个定时器的两个通道, 这两个通道捕获不同的边沿, 之后通过捕获时间的比例获取这一个PWM的占空比 ![image 20240311202141971](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403112021058.png) ```c void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim){ \tif(htim >Instance TIM17){ \t\tcurr_val HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1); \t\t__HAL_TIM_SET_COUNTER(htim, 0); \t\tfrq (80000000 / 80) / curr_val; \t\tHAL_TIM_IC_Start_IT(htim, TIM_CHANNEL_1); \t} \tif(htim >Instance TIM8){ \t\tif(htim >Channel HAL_TIM_ACTIVE_CHANNEL_1){ \t\t\trise HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1); \t\t\tfall HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_2); \t\t\t__HAL_TIM_SET_COUNTER(htim, 0); \t\t\tduty 100 * fall / rise; \t\t\tHAL_TIM_IC_Start_IT(htim, TIM_CHANNEL_1); \t\t\tHAL_TIM_IC_Start_IT(htim, TIM_CHANNEL_2); \t\t} \t} } ``` ### ADC + 扫描模式： 使用STM32CUBEMX配置了多通道后，这一项默认开启且无法设置成关闭。这个模式就是自动扫描你开启的所有通道进行转换，直至转换完。例如你开启了CH0、CH1、CH2、CH3这四个通道，启动转换后ADC会自动将这4个通道全部转换完，但是这种连续性是可以被打断的，所以就引出了间断模式。 + 连续模式： 在CUBE中选中ENABLE就是连续模式，DISABLE就是单次模式。开启连续模式后，ADC的转换不由其他控制。例如将ADC设置为了定时器的TGRO触发采样，如果开启连续模式，ADC将忽略定时器的触发采样。（连续转换模式开启后其实就是满频率的采样）。 + 间断模式： 可以将多个通道进行分组采集，例如你开启了CH0~3这4个通道，假如你设置了间断次数为4，就相当于将4个通道分成了4组，每组1个通道，那么要想采集完这4个通道就需要手动触发4次ADC采集；如果设置了间断次数为2，那么采集完4个通道就需要手动触发2次ADC采集。 #### 单通道 ![image 20240311212818189](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403112128276.png) ```c double get_adc(void){ \tuint32_t adc; \tHAL_ADC_Start(&hadc2); \tadc HAL_ADC_GetValue(&hadc2); \treturn adc * 3.3 / 4096; } ``` #### 多通道 ![image 20240314123429962](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403141234073.png) ```c void read_adc(void){ \t//依次获取两个通道的数据 HAL_ADC_Start(&hadc2); \tHAL_ADC_PollForConversion(&hadc2, 50); \tadcs[0].adc_original HAL_ADC_GetValue(&hadc2); \tHAL_ADC_Start(&hadc2); \tHAL_ADC_PollForConversion(&hadc2, 50); \tadcs[1].adc_original HAL_ADC_GetValue(&hadc2); \t \t//计算实际的电压 \tadcs[0].adc_voltage adcs[0].adc_original * 3.3 /4096; \tadcs[1].adc_voltage adcs[1].adc_original * 3.3 /4096; } ``` ### 串口 这一个使用的时候需要注意, usb转串口使用的引脚不是默认的引脚, 需要自己调整一下, 使用PA10, PA9 ### RTC HAL_RTC_GetData()获取日期 HAL_RTC_SetData()设置日期 HAL_RTC_GetTime()获取当前时间 IS_RTC_HOUR_FORMAT(FROMAT)看一看这一个时间是24小时的还是12小时的 ![image 20240317104250750](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403171042825.png) ![image 20240317101614571](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403171016743.png) ![image 20240317104333386](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403171043482.png) ![image 20240317104902730](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403171049804.png) > 这一个时钟不需要特意开启, 只需要直接获取时间以及回调就可以了 ### I2C 使用官方的I2C示例 这一个直接使用开漏输出就可以了 ```c uint8_t eeprom_read(uint8_t addr){ \tuint8_t data; \tI2CStart(); \tI2CSendByte(EEPROM_ADDRESS_WRITE); \tI2CWaitAck(); \tI2CSendByte(addr); \tI2CWaitAck(); \t \tI2CStart(); \tI2CSendByte(EEPROM_ADDRESS_READ); \tI2CWaitAck(); \tdata I2CReceiveByte(); \tI2CSendNotAck(); \tI2CStop(); \treturn data; } void eeprom_write(uint8_t addr, uint8_t data){ \tI2CStart(); \tI2CSendByte(EEPROM_ADDRESS_WRITE); \tI2CWaitAck(); \tI2CSendByte(addr); \tI2CWaitAck(); \tI2CSendByte(data); \tI2CWaitAck();\t \tI2CStop(); } ``` ## 原理图 ![image 20240310095731925](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403100957995.png) ![image 20240310100012205](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403101000254.png) > 使用R39和R40两滑动变阻器进行调节, 使用J9J10进行连接引脚 ![image 20240310100415304](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403101004334.png) > 下边的两个 ![image 20240310100538745](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403101005781.png) > LED使用的是低电平点亮 ![image 20240310100619729](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403101006762.png) ![image 20240310100730807](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403101007847.png) ![image 20240310100745415](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403101007451.png) ![image 20240310101025084](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403101010127.png) > MCP4017是一个可变电阻 > > 其内置了7位寄存器，共计127个档位的分辨率。 ### EEPROM M24C02 ![image 20240310111745699](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403101117747.png) > 这是一个2Kbit的芯片 #### 通信 ![image 20240310112858203](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403101128248.png) > 实际的地址1010000R/W ![image 20240310113324349](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403101133414.png) > 写的时候 > > 1. 发送一个起始信号 > 2. 发送一个写入的地址 > 3. 等待一个ASK信号 > 4. 发送数据以及等待响应的循环 ![image 20240310113924984](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403101139063.png) > 写的时候 > > 1. 发送一个起始信号 > 2. 发送一个写入的地址 > 3. 等待一个ASK信号 > 4. 发送起始信号以及读取的地址 > 5. 读取数据以及发送响应的循环 ### 可变电阻MCP4017 [【蓝桥杯】【嵌入式组别】第九节：MCP4017编程设计 CSDN博客](https://blog.csdn.net/Gorege__Hu/article/details/129913505) ![image 20240310101522872](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403101015899.png) ![image 20240310101514378](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403101015402.png) > 这一个原理图里面的A引脚没有使用, 实际可以控制的是Rbw里面的电阻值 > > 如果使用PB14进行电压的测量, 实际的结果是VDD*Rwb/(Rwb + R17) ![image 20240310102410374](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403101024419.png) ![image 20240310101919163](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403101019197.png) > 内部的原理图 ![image 20240310103037720](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403101030755.png) > 可以通过控制寄存器控制这一个W的位置 ![image 20240310110353522](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403101103552.png) > 这一个N是实际的可以写入的值 ![image 20240310110455988](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403101104019.png) > 开发板使用的这一块的典型电阻是100K欧姆的电阻 #### 通信协议 ![image 20240310102018565](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403101020658.png) > 这一个的地址是固定的 ![image 20240310104052761](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403101040791.png) > 这个玩意只支持两个命令 ![image 20240310103540741](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403101035798.png) 实际使用的时候写入以及读取只有低7位是有效的, 因为这一个芯片支持的只有127个分辨率 ### 锁存器SN74HC(LED) ![image 20240310202118817](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403102021863.png) > 这一个芯片使用的时候使能使能这一个芯片的时候, Q和D的电平是一样的, 不然的话Q是使能结束的时候D的状态 ![image 20240310202345193](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403102023234.png) > LE是高电平的时候这一个芯片是使能的 ### LCD ![image 20240310212415740](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403102124809.png) ![image 20240310213014309](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403102130343.png) > 这里从官方的文件里面获取这三个文件, 之后添加文件就可以了 > > 使用的时候初始化GPIO为output然后使用LED_Init()函数就可以了 ### 按键 按键有一个上拉电阻, 没有按下的时候这一个按键默认是高电平 使用的时候可以使用一个时钟进行轮询 ![image 20240310214449383](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403102144444.png) ![image 20240310214506324](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202403102145364.png) ```c ##### TIM Callbacks functions ##### [..] This section provides TIM callback functions: (+) TIM Period elapsed callback (+) TIM Output Compare callback (+) TIM Input capture callback (+) TIM Trigger callback (+) TIM Error callback (+) TIM Index callback (+) TIM Direction change callback (+) TIM Index error callback (+) TIM Transition error callback ``` > 这里使用的是溢出中断回调函数HAL_TIM_PeriodElapsedCallback > 使用时钟之前需要使用\tHAL_TIM_Base_Start_IT(&htim6);开启这一个时钟 #### 实际实现 这里使用一个状态机进行实现 ```c #ifndef KEY_H #define KEY_H #include \"main.h\" #define KEY1_Press\t\t\t(1<<0) #define KEY2_Press\t\t\t(1<<1) #define KEY3_Press\t\t\t(1<<2) #define KEY4_Press\t\t\t(1<<3) #define KEY1_LONG_Press\t\t\t(1<<4) #define KEY2_LONG_Press\t\t\t(1<<5) #define KEY3_LONG_Press\t\t\t(1<<6) #define KEY4_LONG_Press\t\t\t(1<<7) typedef struct _key_t{ \tGPIO_TypeDef *GPIOx; \tuint16_t GPIO_Pinx; \tenum{ \t\tKEY_NO_PRESS, \t\tKEY_PRESS_UNAFFIRM, \t\tKEY_PRESS_AFFIRM, \t}state;//这是一个状态机用于按键的消抖 \tGPIO_PinState input;//记录当前的按键状态 \tint time;//一个按下的时间, 用于处理长按 \tunsigned char long_press;//长按的标志 }key_t; void KEY_Init(void); uint8_t key_get_state(void); #endif /*KEY_H*/ ``` ```c #include \"key/key.h\" #include \"gpio.h\" key_t keys[4]; //按键的初始化, 这一个需要在时钟开启之前执行 void KEY_Init(void){ \tkeys[0].GPIOx GPIOB; \tkeys[0].GPIO_Pinx GPIO_PIN_0; \tkeys[1].GPIOx GPIOB; \tkeys[1].GPIO_Pinx GPIO_PIN_1; \tkeys[2].GPIOx GPIOB; \tkeys[2].GPIO_Pinx GPIO_PIN_2; \tkeys[3].GPIOx GPIOA; \tkeys[3].GPIO_Pinx GPIO_PIN_0; \tfor(int i 0;i < 4; i++){ \t\t \t} } //使用一个时钟进行轮询 void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim){ \tif(htim >Instance TIM6) \t{ \t\tfor(int i 0;i < 4; i++){ \t\t\tkeys[i].input HAL_GPIO_ReadPin(keys[i].GPIOx, keys[i].GPIO_Pinx); \t\t\tif(keys[i].input GPIO_PIN_RESET){ \t\t\t\tswitch(keys[i].state){ \t\t\t\t\tcase KEY_NO_PRESS: //这一个按键第一次按下, 这时候需要进行消抖 \t\t\t\t\t\tkeys[i].state KEY_PRESS_UNAFFIRM; \t\t\t\t\t\tkeys[i].time++; \t\t\t\t\t\tbreak; \t\t\t\t\tcase KEY_PRESS_UNAFFIRM: //消抖结束, 确定这一个按键是按下的 \t\t\t\t\t\tkeys[i].state KEY_PRESS_AFFIRM; \t\t\t\t\t\tkeys[i].time++; \t\t\t\t\t\tbreak; \t\t\t\t\tcase KEY_PRESS_AFFIRM: //这时候处理一下这一个按键是不是长按 \t\t\t\t\t\tif(keys[i].time++ > 10){ \t\t\t\t\t\t\tkeys[i].long_press 1; \t\t\t\t\t\t} \t\t\t\t\t\tbreak; \t\t\t\t} \t\t\t}else{ \t\t\t\tkeys[i].state KEY_NO_PRESS; \t\t\t\tkeys[i].time 0; \t\t\t\tkeys[i].long_press 0; \t\t\t} \t\t\t \t\t} \t} } //获取当前的按键状态 //这里使用返回的值和宏定义&可以获取按键的状态 uint8_t key_get_state(void){ \tuint8_t key_state 0; \tfor(int i 0;i < 4; i++){ \t\tif(keys[i].state KEY_PRESS_AFFIRM) \t\t{ \t\t\tkey_state 1 << i; \t\t} \t\tif(keys[i].long_press) \t\t{ \t\t\tkey_state 1 << i + 4; \t\t} \t} \treturn key_state; } ``` ```c key_state key_get_state(); if(key_state & KEY1_Press){ LCD_DisplayStringLine(Line0, \"press\"); }else{ LCD_DisplayStringLine(Line0, \"no press\"); } ``` > main函数里面可以轮询获取这一个按键的状态"},"/note/嵌入式/stm32/蓝桥杯备赛/2024-3-11-02理论题.html":{"title":"02理论题","content":" layout: post title: \"02理论题\" date: 2024 3 11 15:39:08 +0800 tags: stm32 蓝桥杯 # 理论题"},"/note/嵌入式/stm32/无人机/2025-2-1-01-基础知识.html":{"title":"基础知识","content":"# 基础知识 四旋翼飞行器（quadrotor aircraft）又称四轴直升机（quadcopter）或简称四转子（quad），是用大小相同、两侧对称分布的四个旋翼产生升力的多轴飞行器，属于直升机的一种。 ## 结构 常见的无人机有十字形和X型两种, 十字形的控制前后飞行的时候, 左右的机翼不参与控制, X型的结构简单容易控制 ### 基础动力学 电机 1和电机 3逆时针旋转的同时，电机 2和电机 4顺时针旋转，因此当飞行器平衡飞行时，**陀螺效应**和**空气动力扭矩效应**均被抵消 ![image 20260201154035475](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202602011540565.png) ![image 20260201154053217](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202602011540252.png) ![image 20260201154341499](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202602011543546.png) #### 偏航运动 在我们的四轴无人机中，ω4 和ω2 的转向与ω1 和ω3 的转向相反，这是因为螺旋桨旋转会产生水平扭矩。于是当ω4+ω2≠ω1+ω3 就会产生水平旋转，这就是偏航原理。至于是顺旋还是逆旋，要根据实物电机正反转搭配正反桨来决定。 #### 横滚角 当 F4+F3＞F1+F2 向右飞行 当 F4+F3＜F1+F2 向左飞行 #### 俯仰运动 当 F1+F4＜F2+F3 向前飞行 当 F1+F4＞F2+F3 向后飞行 ## 需求 + 姿态稳定 + 移动控制 + 定高 经常使用的电机有两种, 无刷电机以及有刷电机, 无人机便宜的使用空心杯有刷电机, 中间的转子减重适配无人机, 转速大, 扭矩小"},"/note/嵌入式/stm32/固件库/2024-1-8-39SDMMC.html":{"title":"SDMMC","content":" layout: post title: \"SDMMC\" date: 2024 1 7 15:39:08 +0800 tags: stm32 # SDMMC ![image 20240108222127314](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401082221398.png) ![image 20240108222710300](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401082227374.png) ![image 20240108224644914](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401082246992.png) ![image 20240108224846451](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401082248530.png)"},"/note/嵌入式/stm32/固件库/2023-6-20-4GPIO.html":{"title":"GPIO","content":" layout: post title: \"GPIO\" date: 2023 6 20 15:39:08 +0800 tags: stm32 # GPIO ## 电气特性 stm32支持的范围的2V VDD 3.6V 识别电压的范围 COMS端口(只支持3,3V的端口), 0.3 1.164为逻辑0, 1.833 3.6为逻辑1, 最大的输出电压是25MA总的输出电流是150MA ## 寄存器 ### GPIO的寄存器 ![image 20231120173637862](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311201736923.png) + GPIOx_CRL: 控制输入输出以及模式, 输出速度可理解为: **输出驱动电路的带宽**：即一个驱动电路可以不失真地通过信号的最大频率。设置为上下拉的时候, 具体是哪一个是ODR寄存器控制的, 1为上拉, 0为下拉 ![image 20230620203643146](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281055355.png) + GPIOx_CRH: 同上 ![image 20230620203748093](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281055356.png) + GPIOx_IDR: 读出GPIO的状态 ![image 20230620203855978](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281055357.png) + GPIOx_ODR: 设置对应的位 ![image 20230620203943523](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281055358.png) + GPIOx_BSRR设置对应的位为0 ![image 20230621163952625](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281055359.png) + GPIOx_BRR: 清除 ![image 20230621164105476](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281055360.png) + GPIOx_LCKR: 锁, 主要控制的CR寄存器 ![image 20230620204220895](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281055361.png) > ODR和BSRR之间的区别, ODR寄存器控制输入输出如果在读和修改访问之间发生中断, 可能会发生风险, 使用BSRR不会有这个风险 > > GPIOB >ODR 1<<3, 使用这一个的时候首先需要去读ODR的值然后修改, 最后重新写入, 如果在读取修改以后进入中断, 中断里面对这寄存器进行了修改, 再返回以后写入的时候会覆盖中断里面的操作 > > 等同于GPIOB >BSRR 0x00000008使用这一个的时候只有一个写操作 ### RCC寄存器 + RCC_CR时钟控制寄存器 + 时钟配置寄存器(RCC_CFGR) + 时钟中断寄存器 (RCC_CIR) + APB2 外设复位寄存器 (RCC_APB2RSTR) + APB1 外设复位寄存器 (RCC_APB1RSTR) + AHB外设时钟使能寄存器 (RCC_AHBENR) + APB2 外设时钟使能寄存器(RCC_APB2ENR), RCC起始地址0x40021000, 偏移18 ![image 20230620210722552](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281055362.png) + APB1 外设时钟使能寄存器(RCC_APB1ENR) + 备份域控制寄存器 (RCC_BDCR) + 控制/状态寄存器 (RCC_CSR) ## 原理 ### GPIO简介 general purpose input output: 通用输入输出 通过软件控制引脚实现通讯控制, 信息采集 引脚的功能 > 数据手册 引脚的模式一共有六种 电源引脚, 晶振引脚, 复位引脚, 下载引脚, BOOT引脚, GPIO引脚 ## 基本结构 ![image 20230621161611717](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281055363.png) > 引脚不要连接电机, 存在过充电压损坏电路, 链接的话需要电路隔离 ![image 20231120163917242](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311201639420.png) > 如果想要接5V需要加一个限压电阻, 外界高电压的时候, 保护二极管有压降0.3V, 所以引脚处的电压会是3.6V这时候芯片也可以承受, 外接一个低电压的时候, 引脚处的电压是 0.3V这时候也是允许的 > > 上拉电阻和下拉电阻为30K 50KΩ, 是一个弱的上下拉, 原因是驱动能力非常弱, 在外接的电压与内部的电压不同的时候不至于产生一个很大的电流 > > 施密特触发器, 是一种整形电路, 把一个非标准的方波变为一个标准的方波, 有一个正向阈值电压, 负向阈值电压, 只有在变化的时候向上超过正向阈值电压, 或者向下超过负向阈值电压的时候输入的信号才会改变 > > ![image 20231120170735818](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311201707873.png) > > P MOS & N MOS管 > > ![image 20231120170847015](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311201708061.png) ![image 20231120163931020](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311201639061.png) > 主要的区别是上下拉电阻的位置 #### 引脚模式 ![image 20231120171049572](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311201710621.png) + 推挽输出 施密特触发器打开, 上下拉电阻关闭 不复用ODR写入0的时候N MOS导通, 1P MOS导通 ![image 20230621162132107](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281055364.png) > 左侧输入的是1, 反向之后是0, 上面的导通, 输出的是高电平, 下面截止, 对外输出的电流比较大25ma, 是用的最多, 驱动能力强 + 开漏输出(复用) 上下拉电阻关闭, 施密特触发打开, P MOS管始终不导通 不复用的时候向ODR寄存器写入0, N MOS管导通, 1的时候高阻态 ![image 20230621162458660](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281055365.png) > 只能输出低电平, 这个模式的时候上面的NMOS管不工作, 高电平外部提供, 可以输出高电压 > > F4往后的芯片可以使用内部上拉 + 上拉下拉输入 通过软件配置, 向VSRR寄存器写入数字控制, 可以从IDR寄存器进行读取 施密特触发器: 起到门禁的功能, 高于2.0为1, 低于1.2为0 由于CR寄存器没有办法控制是上拉还是下拉, 所以实际是通过ODR寄存器进行设置 ![image 20230623204914088](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281055366.png) + 浮空输入 上下拉电阻关闭, 施密特触发器打开, 双MOS管不导通, 空闲的时候是高阻态的, 默认的电压是随机的 > 高组态: 一个器件的输出端口被断开或关闭，在这种情况下，器件的输出电平不确定，其电阻值会变得无穷大，称为高阻态（也叫三态）。在高阻态时，器件对电路的负载几乎没有任何影响，因为电路中的其他器件看不到这个器件的输出部分 + 模拟功能 上下拉电阻关闭, 施密特触发器关闭, MOS管不导通 ## 实际实现 ### 四步模型 1. 初始化: 设置时钟, 设置参数(模式), IO设置, 中断设置(开中断, 设置NVIC) 2. 读函数: 从外设读取数据 3. 写函数: 向外设写入数据 4. 中断服务函数: 根据中断位处理各种中断 ### 第一种 ```c \t//打开时钟 \t*(unsigned int *)0x40021018 (1<<3); \t//控制CRL寄存器 \t*(unsigned int *)0x40010c00 (1<<(4*0)); \t//控制ODR寄存器 \t*(unsigned int *)0x40010c0c & ~(1<<0); ``` ### 第二种 ```c #ifndef __STM32F10x_H__ #define __STM32F10x_H__ #define PERIRHRAL_BASE \t\t\t\t\t((unsigned int)0x40000000) #define APB1_BASE\t \t\t\t\t\t(PERIRHRAL_BASE) #define APB2_BASE\t\t\t\t\t\t(APB1_BASE + 0x10000) #define AHB_BASE\t\t\t\t\t\t(APB1_BASE + 0x20000) #define RCC_BASE\t\t\t\t\t\t(AHB_BASE + 0x1000) #define GPIOB_BASE\t\t\t\t\t\t(APB2_BASE + 0x0c00) #define GCCAPB2_ENR\t\t\t\t\t\t*(unsigned int *)(RCC_BASE + 0x18) #define GPIOB_ODR\t\t\t\t\t\t*(unsigned int *)(GPIOB_BASE + 0xc) #define GPIOB_CRL\t\t\t\t\t\t*(unsigned int *)(GPIOB_BASE + 0x0) #endif ``` ### 第三种 ```c typedef struct { \tuint32_t\tGPIO_CRL; \tuint32_t\tGPIO_CRH; \tuint32_t\tGPIO_IDR; \tuint32_t\tGPIO_ODR; \tuint32_t\tGPIO_BSRR; \tuint32_t\tGPIO_BRR; \tuint32_t\tGPIO_LCKR; }GPIO_TypeDef; #define GPIOB \t\t\t\t\t\t\t((GPIO_TypeDef *)GPIOB_BASE) ``` ### 第四种 使用初始化函数, 构建一个结构体, 使用结构体的参数作为初始化的值, 之后通过运算使用函数进行初始化 ```c typedef enum { GPIO_Speed_10MHz 1, // 10MHZ (01)b GPIO_Speed_2MHz, // 2MHZ (10)b GPIO_Speed_50MHz // 50MHZ (11)b }GPIOSpeed_TypeDef; typedef enum { GPIO_Mode_AIN 0x0, // 模拟输入 (0000 0000)b GPIO_Mode_IN_FLOATING 0x04, // 浮空输入 (0000 0100)b GPIO_Mode_IPD 0x28, // 下拉输入 (0010 1000)b GPIO_Mode_IPU 0x48, // 上拉输入 (0100 1000)b GPIO_Mode_Out_OD 0x14, // 开漏输出 (0001 0100)b GPIO_Mode_Out_PP 0x10, // 推挽输出 (0001 0000)b GPIO_Mode_AF_OD 0x1C, // 复用开漏输出 (0001 1100)b GPIO_Mode_AF_PP 0x18 // 复用推挽输出 (0001 1000)b }GPIOMode_TypeDef; typedef struct { \tuint16_t GPIO_Pin; \tuint16_t GPIO_Speed; \tuint16_t GPIO_Mode; }GPIO_InitTypeDef; ``` ![image 20230621194544353](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281055367.png) ```c void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct) { uint32_t currentmode 0x00, currentpin 0x00, pinpos 0x00, pos 0x00; uint32_t tmpreg 0x00, pinmask 0x00; /* GPIO 模式配置 */ // 把输入参数GPIO_Mode的低四位暂存在currentmode currentmode ((uint32_t)GPIO_InitStruct >GPIO_Mode) & ((uint32_t)0x0F); \t // bit4是1表示输出，bit4是0则是输入 // 判断bit4是1还是0，即首选判断是输入还是输出模式 if ((((uint32_t)GPIO_InitStruct >GPIO_Mode) & ((uint32_t)0x10)) ! 0x00) { \t// 输出模式则要设置输出速度 currentmode (uint32_t)GPIO_InitStruct >GPIO_Speed; } /* GPIO CRL 寄存器配置 CRL寄存器控制着低8位IO */ // 配置端口低8位，即Pin0~Pin7 if (((uint32_t)GPIO_InitStruct >GPIO_Pin & ((uint32_t)0x00FF)) ! 0x00) { \t// 先备份CRL寄存器的值 tmpreg GPIOx >CRL; \t\t \t// 循环，从Pin0开始配对，找出具体的Pin for (pinpos 0x00; pinpos < 0x08; pinpos++) { \t // pos的值为1左移pinpos位 pos ((uint32_t)0x01) << pinpos; \t // 令pos与输入参数GPIO_PIN作位与运算，为下面的判断作准备 currentpin (GPIO_InitStruct >GPIO_Pin) & pos; \t\t\t \t //若currentpin pos,则找到使用的引脚 if (currentpin pos) { \t\t// pinpos的值左移两位（乘以4），因为寄存器中4个寄存器位配置一个引脚 pos pinpos << 2; //把控制这个引脚的4个寄存器位清零，其它寄存器位不变 pinmask ((uint32_t)0x0F) << pos; tmpreg & ~pinmask; \t\t\t\t // 向寄存器写入将要配置的引脚的模式 tmpreg (currentmode << pos); \t\t\t\t \t\t// 判断是否为下拉输入模式 if (GPIO_InitStruct >GPIO_Mode GPIO_Mode_IPD) { \t\t // 下拉输入模式，引脚默认置0，对BRR寄存器写1可对引脚置0 GPIOx >BRR (((uint32_t)0x01) << pinpos); }\t\t\t\t else { // 判断是否为上拉输入模式 if (GPIO_InitStruct >GPIO_Mode GPIO_Mode_IPU) { \t\t // 上拉输入模式，引脚默认值为1，对BSRR寄存器写1可对引脚置1 GPIOx >BSRR (((uint32_t)0x01) << pinpos); } } } } \t\t// 把前面处理后的暂存值写入到CRL寄存器之中 GPIOx >CRL tmpreg; } /* GPIO CRH 寄存器配置 CRH寄存器控制着高8位IO */ // 配置端口高8位，即Pin8~Pin15 if (GPIO_InitStruct >GPIO_Pin > 0x00FF) { \t\t// // 先备份CRH寄存器的值 tmpreg GPIOx >CRH; \t\t \t// 循环，从Pin8开始配对，找出具体的Pin for (pinpos 0x00; pinpos < 0x08; pinpos++) { pos (((uint32_t)0x01) << (pinpos + 0x08)); \t\t\t // pos与输入参数GPIO_PIN作位与运算 currentpin ((GPIO_InitStruct >GPIO_Pin) & pos); \t\t\t \t //若currentpin pos,则找到使用的引脚 if (currentpin pos) { \t\t//pinpos的值左移两位（乘以4），因为寄存器中4个寄存器位配置一个引脚 pos pinpos << 2; \t //把控制这个引脚的4个寄存器位清零，其它寄存器位不变 pinmask ((uint32_t)0x0F) << pos; tmpreg & ~pinmask; \t\t\t\t // 向寄存器写入将要配置的引脚的模式 tmpreg (currentmode << pos); \t\t// 判断是否为下拉输入模式 if (GPIO_InitStruct >GPIO_Mode GPIO_Mode_IPD) { \t\t // 下拉输入模式，引脚默认置0，对BRR寄存器写1可对引脚置0 GPIOx >BRR (((uint32_t)0x01) << (pinpos + 0x08)); } // 判断是否为上拉输入模式 if (GPIO_InitStruct >GPIO_Mode GPIO_Mode_IPU) { \t\t // 上拉输入模式，引脚默认值为1，对BSRR寄存器写1可对引脚置1 GPIOx >BSRR (((uint32_t)0x01) << (pinpos + 0x08)); } } } \t// 把前面处理后的暂存值写入到CRH寄存器之中 GPIOx >CRH tmpreg; } } ``` ### 第五步 增加移植性, 使用宏定义 ## 使用固件库 ![image 20230623200235770](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281055368.png) ```c void LED_GPIO_Config() { \t//开启时钟 \tRCC_APB2PeriphClockCmd(LED_G_GPIO_CLOCK, ENABLE); \t//初始化引脚 \tGPIO_InitTypeDef GPIO_InitStructure; \tGPIO_InitStructure.GPIO_Pin LED_G_GPIO_PIN; \tGPIO_InitStructure.GPIO_Mode GPIO_Mode_Out_PP; \tGPIO_InitStructure.GPIO_Speed GPIO_Speed_10MHz; \t \tGPIO_Init(LED_G_GPIO_PORT, &GPIO_InitStructure); } ``` ### 读取 ![image 20230623230112181](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281055369.png) > 电阻是为了限流, 保护GPIO, 电容硬件消抖 PA0有唤醒功能, 上升沿唤醒 外部下拉设置为浮空 ```c #define LED_G_TOGGLE\t\t\t{LED_GPIO_PORT >ODR^ LED_G_GPIO_PIN;}\t\t\t\t ``` 与1异或变号, 与0不变 ```c uint8_t Key_Scaan(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin) { \tif(GPIO_ReadInputDataBit(GPIOx,GPIO_Pin) KEY_ON) \t{ \t\t//松手检测 \t\twhile(GPIO_ReadInputDataBit(GPIOx,GPIO_Pin) KEY_ON); \t\t\treturn KEY_ON; \t} \telse \t{ \t\treturn KEY_OFF; \t} } ``` ## 位带操作 CM3权威指南 >5.4 寄存器里面的每一个位都重新找一个地址, 每个位膨胀为4个字节(32位), 最低位有效, 只有最前面的1MB会被映射 ![image 20230624204543382](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281055370.png) ![image 20230624204753256](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281055371.png) 外设的AliasAddr 0x42000000 + (A 0x40000000)\\*8\\*4 + n*4 SARM的AliasAddr 0x22000000 + (A 0x20000000)\\*8\\*4 + n*4 > A是寄存器的偏移值, n是寄存器的第几位 统一公式: ![image 20230625180034775](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281055372.png) ```c #define GPIOB_ODR_ADDR \t\t\t(GPIOB_BASE+0x0c) #define GPIOA_IDR_ADDR \t\t\t(GPIOA_BASE+0x08) #define GPIOC_IDR_ADDR \t\t\t(GPIOC_BASE+0x08) #define PBout(n) \t\t\t*(unsigned int*)((GPIOB_ODR_ADDR & 0xF0000000) + 0x02000000 + ((GPIOB_ODR_ADDR & 0x00FFFFFF)<<5)+ (n<<2)) #define PBIn(n) \t\t\t*(unsigned int*)((GPIOA_IDR_ADDR & 0xF0000000) + 0x02000000 + ((GPIOA_IDR_ADDR & 0x00FFFFFF)<<5)+ (n<<2)) #define PCIn(n) \t\t\t*(unsigned int*)((GPIOC_IDR_ADDR & 0xF0000000) + 0x02000000 + ((GPIOC_IDR_ADDR & 0x00FFFFFF)<<5)+ (n<<2)) while(1){ if(PCIn(13) KEY_ON) { while(PCIn(13) KEY_ON); LED_G_TOGGLE; } } ``` ## 复用 通用: IO端口输入或者输出是由GPIO外设控制的, 我们称之为通用 复用: 输入输出是由其他的外设进行控制的 某一个IO只能用于一种复用功能, 否则会出现错误 当IO复用出现冲突的时候, 可以考虑重映射 + F4F7H7 为了解决F1里面存在的IO复用功能冲突, F4以后的系列加入了复用器, 在设置的时候只能设置为一种功能 每一个IO都有一个复用器, 采用16路复用功能输入AF0 AF15 复用器一次只允许一个外设复用功能AF连接到IO引脚 通过GPIOx_AFRL和GPIOx_AFRH进行控制 > 复位以后所有的IO都会连接到AF0 ![image 20231128225253299](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311282252391.png) ![image 20231128225531991](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311282255034.png) > 例: PA8的AF7对应的USART1_TX > > 手册中有一个表进行对应 ## 重映射 使用AFIO AFIO_MAPR寄存器里面设置重映射的设备, 比如如果是重映射时钟的引脚 ![image 20231202214615190](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312022146231.png) ## I/O扩展 使用PCF8574T芯片使用IIC协议进行扩展 有一个IIC总线接口, 8个准双向口, 1个中断线, 3个地址线 ![image 20231230205336369](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312302053469.png) > 准双向口内部有一个弱上拉电阻，上拉电阻不可避免地会影响到引脚的电路行为特性，而且在原始的8051MCU中这个上拉电阻是不能人为控制或断开的。双向口的开漏结构意味着使用者可以通过自己配置外部电路完全控制端口的电路行为特性，不用担心并联的内部上拉的影响。 > > ![image 20231230205603463](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312302056513.png) ![image 20231230205709939](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312302057984.png) ![image 20231230212040819](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312302120876.png) ![image 20231230212628347](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312302126420.png) ![image 20231230212708947](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312302127019.png) ![image 20231230212821293](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312302128356.png)"},"/note/嵌入式/stm32/固件库/2023-6-30-9SysTick.html":{"title":"SysTick","content":" layout: post title: \"SysTick\" date: 2023 6 30 15:39:08 +0800 tags: stm32 # SysTick 系统定时器, 24位只能递减计时, 位于内核, 嵌套在NVIC中, 所有的Cortex M内核 ![image 20230630162556741](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281051104.png) 手册中描述很少, 在内核手册中有描述4.5.1 ![image 20230630162941501](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281051105.png) ![image 20230630162951596](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281051106.png) ![image 20230630170520541](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281051107.png) + STK_CTRL + STK_LOAD + STK_VAL + STK_CALIB 还有一个校准寄存器, 固定值为9000 ## 函数 在文件core_cm3.h文件中 ```c typedef struct { __IO uint32_t CTRL; /*!< Offset: 0x00 SysTick Control and Status Register */ __IO uint32_t LOAD; /*!< Offset: 0x04 SysTick Reload Value Register */ __IO uint32_t VAL; /*!< Offset: 0x08 SysTick Current Value Register */ __I uint32_t CALIB; /*!< Offset: 0x0C SysTick Calibration Register */ } SysTick_Type; ``` ```c static __INLINE uint32_t SysTick_Config(uint32_t ticks) { if (ticks > SysTick_LOAD_RELOAD_Msk) return (1); /* Reload value impossible 传入的数字过大*/ SysTick >LOAD (ticks & SysTick_LOAD_RELOAD_Msk) 1; /* set reload register初始化reload寄存器的值 */ NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) 1); /* set Priority for Cortex M3 System Interrupts 配置中断优先级, 默认为最低的优先级*/ SysTick >VAL 0; /* Load the SysTick Counter Value 初始化计数器为0*/ SysTick >CTRL SysTick_CTRL_CLKSOURCE_Msk SysTick_CTRL_TICKINT_Msk SysTick_CTRL_ENABLE_Msk; /* Enable SysTick IRQ and SysTick Timer MSK为1设置时钟为72MHz, 产生中断, 使能*/ return (0); /* Function successful */ } ``` > 配置函数 ```c static __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority) { if(IRQn < 0) { //内部中断配置的是这个寄存器, 这里使用数组的位数来代表指针进行控制对应的寄存器 SCB >SHP[((uint32_t)(IRQn) & 0xF) 4] ((priority << (8 __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex M3 System Interrupts */ else { //外设控制的是NVIC NVIC >IP[(uint32_t)(IRQn)] ((priority << (8 __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for device specific Interrupts */ } ``` ![image 20230630174108808](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281051108.png) > 使用四个位控制优先级SCB_SHPR3 > > ![image 20230630174211636](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281051109.png) + 中断优先级对内核和外设的中断优先级同样适用 ## 实际实现 ```c void Systick_Delay_us(uint32_t us) { \tuint32_t i; \tSysTick_Config(72); \t \tfor(i 0;i<us;i++) \t{ \t\twhile(!(SysTick >CTRL & (1<<16))); \t} \tSysTick >CTRL & ~SysTick_CTRL_ENABLE_Msk; } void Systick_Delay_ms(uint32_t ms) { \tuint32_t i; \tSysTick_Config(72000); \t \tfor(i 0;i<ms;i++) \t{ \t\twhile(!(SysTick >CTRL & (1<<16))); \t} \tSysTick >CTRL & ~SysTick_CTRL_ENABLE_Msk; } ``` > 没有使用中断函数, 也可以使用中断函数来进行SysTick_Handler"},"/note/嵌入式/stm32/固件库/2023-9-14-26摄像头.html":{"title":"摄像头","content":" layout: post title: \"摄像头\" date: 2023 9 14 15:39:08 +0800 tags: stm32 # 摄像头 摄像头使用的VOFF25摄像头图像采集芯片 和AL422B的FIFO 摄像头的作用就是输出一个图像, 按照输出的模式分为数字摄像头和模拟摄像头, 按照传感构成分为CCD和CMOS, 绝大部分的都是CMOS 数字摄像头可以使用常见的接口进行传输, 模拟摄像头多使用AV视频端子之类线传输 模拟摄像头一般直接把信号输入到显示器 + CCD和CMOS区别 主要是使用的材料有区别, CCD使用的是MOS管构成像素, 需要比较大的电压, 一般有多个电源, 消耗的能量比较小, 但是起步早, 噪声低, 成像质量好, 但是如今的CMOS经过不断发展解决了大部分的问题, 占据了大部分市场 摄像头包括一个镜头座, 一个可以旋转调节的凸透镜, 通过旋转可以调节焦距, 正常使用的时候光线只能通过镜头传输到传感器, 他采集光线信号之后储存到后面的FIFO里面, 使用VGA时序输出图像, 可以输出YUV(422/420), YCbCr422以及RGB565 ![image 20230914120258792](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046487.png) ![image 20230914120315929](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046488.png) + 通过HREF, VSYNC, PCLK组成一个VGA时序, 再加上D0 9进行数据的输出 + PCLK: 时序时钟用于传输信号 + XCLK: 是一个外界时钟的输入, 用于内部的时序, 摄像头自带有一个晶振 + SCL: SCCB总线的时钟线 + SDA: SCCB总线的数据线, 主要用来修改内部的寄存器 ![image 20230914120741160](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046489.png) 1. 控制模块, 使用SCCB时序, 实际上可以使用I2C进行控制 2. 通讯, 控制信号以及时钟, PCLK, HREF, VSYNC是像素同步时钟, 行同步信号以及帧同步信号, 还有复位引脚, 外部时钟等 3. 感光矩阵, 模块的核心, 首先产生模拟信号, 之后通过A/D转换器转换为数字信号 4. 数字输出信号, 根据寄存器配置, 处理之后转换为其他的信号, 从数据线进行输出 ## SCCB时序 和I2C时序非常相似, 区别在于SCCB每一次只能读取或者写入一个字节数据, 但是测试之后发现还是支持的 这一个摄像头的硬件文档不完整, 直接使用提供的软件配置就行了 ## 像素输出时序 使用VGA时序或者是QVGA, 区别主要是分别率区别, VGA输出的是480\\*640, QVGA输出的是320\\*240 可以设置为输出RGB565, 每一次输出完一行的时候会产生一个HREF的信号, 结束一幅画之后HREF会产生VSYNC信号 ![image 20230914122808760](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046490.png) > HREF在高位的时候传输的数据是有效的, 这个是在每一行进行一次跳变, 在时钟每一次高电平的时候进行数据的采样, 低电平的时候会进行改变 ![image 20230914123046234](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046491.png) > HSYNC和HREF都用于输出信号, HREF产生之后马上输出, HSYNC则是在一段时间后再进行输出, ，当 VSYNC 为低电平时，各行的像素数据依次传输，每传输完一帧图像时，VSYNC 会 输出一个电平跳变信号。 ## FIFO 实际上就是一个缓冲, 一个RAM芯片, 为的是适应这一个性能比较差的芯片, 如果使用的是F4系列的芯片, 一般会外部扩展SRAM, SDRAM等存储器, 并且有DCMI外设, 可以直接处理VGA时序, 存储数据 一帧图像的大小是150kb大于内部的SRAM, 需要一个外部SRAM来存储图像, 扩展使用的FIFO可以缓存两帧的图像 ![image 20230914192931248](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046492.png) ![image 20230914192943344](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046493.png) ![image 20230914194003346](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046494.png) ## 驱动原理 需要协调好FIFO和OV7725之间的关系, 首先存储数据, 之后进行读取 实际控制, stm32在接受到第一个VSYNC信号时候使能写入, 写入一帧之后控制不再使能, 之后进行读取, 读取之后再重复之前的过程, 在使用480*640模式的时候由于FIFO的内存不够需要确保在覆盖数据之前把数据读出来 ![image 20230914195042494](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046495.png) ![image 20230914195107623](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046496.png) > WEN是一个普通的GPIO进行控制的引脚, 只有在数据有效以及WEN使能的时候才会使能FIFO的写入功能 ![image 20230914195356040](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046498.png) ## 实际上的软件实现 在这里使用的GPIO视同一组的GPIO, 所以可以直接读取GPIO_IDR寄存器进行获取读取到的状态 ![image 20230914225329956](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046499.png) PA8由于摄像头使用的是自己的晶振, 所以没有使用 > 编程要点 > > + 初始化SCCB通讯使用的引脚 > + 初始化OV7725和VGA和FIFO的控制相关的引脚以及时钟 > + 使用SCCB协议向其写入初始化配置 > + 编写测试程序 + 使用SCCB的时候的程序基本和I2C相同 ```c /** ****************************************************************************** * @file bsp_sccb.c * @version V1.0 * @date 2013 xx xx * @brief 模拟I2C SCCB协议驱动 ****************************************************************************** * @attention * * 实验平台:野火 F103 指南者 STM32 开发板 * 论坛 :http://www.firebbs.cn * 淘宝 :https://fire stm32.taobao.com * ****************************************************************************** */ #include \"./sccb/bsp_sccb.h\" #define DEV_ADR ADDR_OV7725 \t\t\t /*设备地址定义*/ /******************************************************************** * 函数名：SCCB_Configuration * 描述 ：SCCB管脚配置 * 输入 ：无 * 输出 ：无 * 注意 ：无 ********************************************************************/ void SCCB_GPIO_Config(void) { GPIO_InitTypeDef GPIO_InitStructure; \t \t /* SCL(PC6)、SDA(PC7)管脚配置 */ \tOV7725_SIO_C_SCK_APBxClock_FUN ( OV7725_SIO_C_GPIO_CLK, ENABLE ); GPIO_InitStructure.GPIO_Pin OV7725_SIO_C_GPIO_PIN ; GPIO_InitStructure.GPIO_Speed GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode GPIO_Mode_Out_OD; GPIO_Init(OV7725_SIO_C_GPIO_PORT, &GPIO_InitStructure); \t \tOV7725_SIO_D_SCK_APBxClock_FUN ( OV7725_SIO_D_GPIO_CLK, ENABLE ); GPIO_InitStructure.GPIO_Pin OV7725_SIO_D_GPIO_PIN ; GPIO_Init(OV7725_SIO_D_GPIO_PORT, &GPIO_InitStructure); \t } /******************************************************************** * 函数名：SCCB_delay * 描述 ：延迟时间 * 输入 ：无 * 输出 ：无 * 注意 ：内部调用 ********************************************************************/ static void SCCB_delay(void) {\t uint16_t i 400; while(i) { i ; } } /******************************************************************** * 函数名：SCCB_Start * 描述 ：SCCB起始信号 * 输入 ：无 * 输出 ：无 * 注意 ：内部调用 ********************************************************************/ static int SCCB_Start(void) { \tSDA_H; \tSCL_H; \tSCCB_delay(); \tif(!SDA_read) \treturn DISABLE;\t/* SDA线为低电平则总线忙,退出 */ \tSDA_L; \tSCCB_delay(); \tif(SDA_read) \treturn DISABLE;\t/* SDA线为高电平则总线出错,退出 */ \tSDA_L; \tSCCB_delay(); \treturn ENABLE; } /******************************************************************** * 函数名：SCCB_Stop * 描述 ：SCCB停止信号 * 输入 ：无 * 输出 ：无 * 注意 ：内部调用 ********************************************************************/ static void SCCB_Stop(void) { \tSCL_L; \tSCCB_delay(); \tSDA_L; \tSCCB_delay(); \tSCL_H; \tSCCB_delay(); \tSDA_H; \tSCCB_delay(); } /******************************************************************** * 函数名：SCCB_Ack * 描述 ：SCCB应答方式 * 输入 ：无 * 输出 ：无 * 注意 ：内部调用 ********************************************************************/ static void SCCB_Ack(void) {\t \tSCL_L; \tSCCB_delay(); \tSDA_L; \tSCCB_delay(); \tSCL_H; \tSCCB_delay(); \tSCL_L; \tSCCB_delay(); } /******************************************************************** * 函数名：SCCB_NoAck * 描述 ：SCCB 无应答方式 * 输入 ：无 * 输出 ：无 * 注意 ：内部调用 ********************************************************************/ static void SCCB_NoAck(void) {\t \tSCL_L; \tSCCB_delay(); \tSDA_H; \tSCCB_delay(); \tSCL_H; \tSCCB_delay(); \tSCL_L; \tSCCB_delay(); } /******************************************************************** * 函数名：SCCB_WaitAck * 描述 ：SCCB 等待应答 * 输入 ：无 * 输出 ：返回为: 1有ACK, 0无ACK * 注意 ：内部调用 ********************************************************************/ static int SCCB_WaitAck(void) \t { \tSCL_L; \tSCCB_delay(); \tSDA_H;\t\t\t \tSCCB_delay(); \tSCL_H; \tSCCB_delay(); \tif(SDA_read) \t{ \t //没有获取到读信号 SCL_L; return DISABLE; \t} \tSCL_L; \treturn ENABLE; } /******************************************************************* * 函数名：SCCB_SendByte * 描述 ：数据从高位到低位 * 输入 ：SendByte: 发送的数据 * 输出 ：无 * 注意 ：内部调用 *********************************************************************/ static void SCCB_SendByte(uint8_t SendByte) { uint8_t i 8; while(i ) { \t\t//在时钟信号为低电平的时候进行信号线的选择 SCL_L; SCCB_delay(); if(SendByte&0x80) SDA_H; else SDA_L; SendByte<< 1; SCCB_delay(); \t\tSCL_H; SCCB_delay(); } SCL_L; } /****************************************************************** * 函数名：SCCB_ReceiveByte * 描述 ：数据从高位到低位 * 输入 ：无 * 输出 ：SCCB总线返回的数据 * 注意 ：内部调用 *******************************************************************/ static int SCCB_ReceiveByte(void) { uint8_t i 8; uint8_t ReceiveByte 0; \t//释放数据线 SDA_H;\t\t\t\t while(i ) { ReceiveByte<< 1; SCL_L; SCCB_delay(); \t SCL_H; SCCB_delay();\t if(SDA_read) { ReceiveByte 0x01; } } SCL_L; return ReceiveByte; } /***************************************************************************************** * 函数名：SCCB_WriteByte * 描述 ：写一字节数据 * 输入 ： WriteAddress: 待写入地址 \t SendByte: 待写入数据\t DeviceAddress: 器件类型 * 输出 ：返回为: 1成功写入, 0失败 * 注意 ：无 *****************************************************************************************/ int SCCB_WriteByte( uint16_t WriteAddress , uint8_t SendByte ) {\t\t if(!SCCB_Start()) \t{ \t return DISABLE; \t} SCCB_SendByte( DEV_ADR ); /* 器件地址 */ if( !SCCB_WaitAck() ) \t{ \t\tSCCB_Stop(); \t\treturn DISABLE; \t} SCCB_SendByte((uint8_t)(WriteAddress & 0x00FF)); /* 设置低起始地址 */ SCCB_WaitAck();\t SCCB_SendByte(SendByte); SCCB_WaitAck(); SCCB_Stop(); return ENABLE; } /****************************************************************************************************************** * 函数名：SCCB_ReadByte * 描述 ：读取一串数据 * 输入 ： pBuffer: 存放读出数据 \t length: 待读出长度\t ReadAddress: 待读出地址\t\t DeviceAddress: 器件类型 * 输出 ：返回为: 1成功读入, 0失败 * 注意 ：无 **********************************************************************************************************************/ int SCCB_ReadByte(uint8_t* pBuffer, uint16_t length, uint8_t ReadAddress) {\t if(!SCCB_Start()) \t{ \t return DISABLE; \t} SCCB_SendByte( DEV_ADR ); /* 器件地址 */ if( !SCCB_WaitAck() ) \t{ \t\tSCCB_Stop(); \t\treturn DISABLE; \t} SCCB_SendByte( ReadAddress ); /* 设置低起始地址 */ SCCB_WaitAck();\t SCCB_Stop(); \t if(!SCCB_Start()) \t{ \t\treturn DISABLE; \t} SCCB_SendByte( DEV_ADR + 1 ); /* 器件地址 */ if(!SCCB_WaitAck()) \t{ \t\tSCCB_Stop(); \t\treturn DISABLE; \t} while(length) { *pBuffer SCCB_ReceiveByte(); if(length 1) \t { \t\t SCCB_NoAck(); \t } else \t { \t\tSCCB_Ack(); \t } pBuffer++; length ; } SCCB_Stop(); return ENABLE; } /*********************************************END OF FILE**********************/ ``` + 初始化各种引脚 在初始FIFO的时候使得允许读但是允许写, 这里的WE不是FIFO芯片的WE在之前还有一个与非门 在初始化VSYNC的时候设置一个VSYNC信号的时候会产生一个中断, 也就是每一幅画结束的时候会产生一个中断 使用的是EXTI_LINE3 + 初始化OV7725 ```c /************************************************ * 函数名：Sensor_Init * 描述 ：Sensor初始化, 写入寄存机, 重复五次 * 输入 ：无 * 输出 ：返回1成功，返回0失败 * 注意 ：无 ************************************************/ ErrorStatus OV7725_Init(void) { \tuint16_t i 0; \tuint8_t Sensor_IDCode 0;\t \t \t//DEBUG(\"ov7725 Register Config Start......\"); \t \tif( 0 SCCB_WriteByte ( 0x12, 0x80 ) ) /*复位sensor */ \t{ \t\t//DEBUG(\"sccb write data error\");\t\t \t\treturn ERROR ; \t}\t \tif( 0 SCCB_ReadByte( &Sensor_IDCode, 1, 0x0b ) )\t /* 读取sensor ID号*/ \t{ \t\t//DEBUG(\"read id faild\");\t\t \t\treturn ERROR; \t} \t//DEBUG(\"Sensor ID is 0x%x\", Sensor_IDCode);\t \t \tif(Sensor_IDCode OV7725_ID) \t{ \t\tfor( i 0 ; i < OV7725_REG_NUM ; i++ ) \t\t{ //这一个结构体数组, 里面的每一项保存有地址和数据两个数据 \t\t\tif( 0 SCCB_WriteByte(Sensor_Config[i].Address, Sensor_Config[i].Value) ) \t\t\t{ \t\t\t\t//DEBUG(\"write reg faild\", Sensor_Config[i].Address); \t\t\t\treturn ERROR; \t\t\t} \t\t} \t} \telse \t{ \t\treturn ERROR; \t} \t//DEBUG(\"ov7725 Register Config Success\"); \t \treturn SUCCESS; } ``` ```c typedef struct Reg { \tuint8_t Address;\t\t\t /*寄存器地址*/ \tuint8_t Value;\t\t /*寄存器值*/ }Reg_Info; ``` > 存放寄存器数据的寄存器 + 实现中断函数 ```c /* ov7725 场中断 服务程序 */ void OV7725_VSYNC_EXTI_INT_FUNCTION ( void ) { if ( EXTI_GetITStatus(OV7725_VSYNC_EXTI_LINE) ! RESET ) \t//检查EXTI_Line0线路上的中断请求是否发送到了NVIC { //判断进来多少次了 if( Ov7725_vsync 0 ) { FIFO_WRST_L(); \t //拉低使FIFO写(数据from摄像头)指针复位 FIFO_WE_H();\t //拉高使FIFO写允许 Ov7725_vsync 1;\t \t FIFO_WE_H(); //使FIFO写允许 FIFO_WRST_H(); //允许使FIFO写(数据from摄像头)指针运动 } else if( Ov7725_vsync 1 ) { //写入一次以后,这时候已经记录完成一次图像了 FIFO_WE_L(); //拉低使FIFO写暂停 Ov7725_vsync 2; } EXTI_ClearITPendingBit(OV7725_VSYNC_EXTI_LINE);\t\t //清除EXTI_Line0线路挂起标志位 } } ``` ```c while(1) \t{ \t\t/*接收到新图像进行显示, 在中断里面获取到的*/ \t\tif( Ov7725_vsync 2 ) \t\t{ \t\t\tframe_count++;\t//记录每一秒钟采样的数量, 使用系统时钟完成 \t\t\tFIFO_PREPARE; \t\t\t/*FIFO准备*/\t\t\t\t\t \t\t\tImagDisp(cam_mode.lcd_sx, \t\t\t\t\t\t\t\tcam_mode.lcd_sy, \t\t\t\t\t\t\t\tcam_mode.cam_width, \t\t\t\t\t\t\t\tcam_mode.cam_height);\t\t\t/*采集并显示*/ \t\t\t \t\t\tOv7725_vsync 0;\t\t\t \t\t\tLED1_TOGGLE; \t\t} \t\t \t\t/*检测按键*/ \t\tif( Key_Scan(KEY1_GPIO_PORT,KEY1_GPIO_PIN) KEY_ON ) \t\t{ \t\t\t/*LED反转*/ \t\t\tLED2_TOGGLE; \t\t} \t\t/*检测按键*/ \t\tif( Key_Scan(KEY2_GPIO_PORT,KEY2_GPIO_PIN) KEY_ON ) \t\t{ \t\t\t/*LED反转*/ \t\t\tLED3_TOGGLE;\t\t\t \t\t\t \t\t\t\t/*动态配置摄像头的模式， \t\t\t 有需要可以添加使用串口、用户界面下拉选择框等方式修改这些变量， \t\t\t 达到程序运行时更改摄像头模式的目的*/ \t\t\t \t\t\t\tcam_mode.QVGA_VGA 0,\t//QVGA模式 \t\t\t\tcam_mode.cam_sx 0, \t\t\t\tcam_mode.cam_sy 0,\t \t\t\t\tcam_mode.cam_width 320, \t\t\t\tcam_mode.cam_height 240, \t\t\t\tcam_mode.lcd_sx 0, \t\t\t\tcam_mode.lcd_sy 0, \t\t\t\tcam_mode.lcd_scan 3, //LCD扫描模式，本横屏配置可用1、3、5、7模式 \t\t\t\t//以下可根据自己的需要调整，参数范围见结构体类型定义\t \t\t\t\tcam_mode.light_mode 0,//自动光照模式 \t\t\t\tcam_mode.saturation 0,\t \t\t\t\tcam_mode.brightness 0, \t\t\t\tcam_mode.contrast 0, \t\t\t\tcam_mode.effect 1,\t\t//黑白模式 \t\t\t \t\t\t/*根据摄像头参数写入配置*/ \t\t\tOV7725_Special_Effect(cam_mode.effect); \t\t\t/*光照模式*/ \t\t\tOV7725_Light_Mode(cam_mode.light_mode); \t\t\t/*饱和度*/ \t\t\tOV7725_Color_Saturation(cam_mode.saturation); \t\t\t/*光照度*/ \t\t\tOV7725_Brightness(cam_mode.brightness); \t\t\t/*对比度*/ \t\t\tOV7725_Contrast(cam_mode.contrast); \t\t\t/*特殊效果*/ \t\t\tOV7725_Special_Effect(cam_mode.effect); \t\t\t \t\t\t/*设置图像采样及模式大小*/ \t\t\tOV7725_Window_Set(cam_mode.cam_sx, \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcam_mode.cam_sy, \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcam_mode.cam_width, \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcam_mode.cam_height, \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcam_mode.QVGA_VGA); \t\t\t/* 设置液晶扫描模式 */ \t\t\tILI9341_GramScan( cam_mode.lcd_scan ); \t\t} \t\t \t\t/*每隔一段时间计算一次帧率*/ \t\tif(Task_Delay[0] 0) \t\t{\t\t\t \t\t\tprintf(\"\\r\\nframe_ate %.2f fps\\r\\n\",frame_count/10); \t\t\tframe_count 0; \t\t\tTask_Delay[0] 10000; \t\t} \t\t \t} ``` ```c #define FIFO_PREPARE do{\\ \t FIFO_RRST_L();\\ \t FIFO_RCLK_L();\\ \t FIFO_RCLK_H();\\ \t FIFO_RRST_H();\\ \t FIFO_RCLK_L();\\ \t FIFO_RCLK_H();\\ }while(0) ``` > 进行读指针复位, 经历两个时钟, 之后才可以进行读取 ```c \t/*根据摄像头参数组配置模式*/ \tOV7725_Special_Effect(cam_mode.effect); \t/*光照模式*/ \tOV7725_Light_Mode(cam_mode.light_mode); \t/*饱和度*/ \tOV7725_Color_Saturation(cam_mode.saturation); \t/*光照度*/ \tOV7725_Brightness(cam_mode.brightness); \t/*对比度*/ \tOV7725_Contrast(cam_mode.contrast); \t/*特殊效果*/ \tOV7725_Special_Effect(cam_mode.effect); \t \t/*设置图像采样及模式大小,设置显示的位置, 需要在设置的模式范围*/ \tOV7725_Window_Set(cam_mode.cam_sx, \t\t\t\t\t\t\t\t\t\t\t\t\t\tcam_mode.cam_sy, \t\t\t\t\t\t\t\t\t\t\t\t\t\tcam_mode.cam_width, \t\t\t\t\t\t\t\t\t\t\t\t\t\tcam_mode.cam_height, \t\t\t\t\t\t\t\t\t\t\t\t\t\tcam_mode.QVGA_VGA); ```"},"/note/嵌入式/stm32/固件库/2023-7-27-23MDK编译过程.html":{"title":"MDK编译过程","content":" layout: post title: \"MDK编译过程\" date: 2023 7 27 15:39:08 +0800 tags: stm32 # MDK编译过程 理解芯片的原理, 制作IAP等 ![image 20230727130401312](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046628.png) 编译: 得到.o文件, 只要内容是源文件编译得到的机器码, 数据以及调试信息 链接: 把.o文件链接成为.axf或.elf文件 格式转换: 一般来说Windows以及Linux使用链接器直接生成可执行映像文件elf之后内核根据该文件信息进行加载就可以了, 在单片机需要转化为.bin或者.hex文件, 交给下载器下载到flash或者ROM中 ![image 20230727133044085](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046629.png) > 调用的编译器以及所在的文件夹 ![image 20230727133417692](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046630.png) > armar: .o文件打包成lib文件 > > armasm: 编译汇编文件 > > armcc: 编译C文件以及C++文件, 每一个源文件都会有一个独立的.o文件 > > armlink: 链接对象文件, 附带各个域的大小说明 > > fromelf: 生成hex文件, 在选项中选择是否生成 ![image 20230727134003561](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046631.png) > 编译过程中出现的错误以及警告, 构建消耗的时间 ## 程序的存储 ``` Program Size: Code 3404 RO data 336 RW data 40 ZI data 1024 ``` > 说明了各个域的大小 Code: 生成的代码, 会下载到flash中 ROdata: 只读数据, 程序用到这些数据这些数据是不能修改的, const变量, 存储在flash中 RW data: 初始值不是0的可读写的数据, 运行的时候常驻于RAM, 比如初始化的全局变量 ZI data: 初始值为0的值, 可以读写, 不需要在flash中储存 栈空间以及堆空间: 在函数内部定义的变量属于栈空间, 使用malloc分配的变量属于堆空间, 都是属于ZI data, 空间初始化为0, 没有使用malloc的话会进行优化, 在.s文件中初始化有最大值 ![image 20230727143535304](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046632.png) > RO不需要加载到SRAM, 运行的时候加载到内存, 直接从Flash加载之后运行, 但是由于没有MMC所以不能跑Linux > > 在执行主体代码前，会先执行一段加载代码，它把 RW 节数据从 ROM 复制到 RAM，并且在 RAM 加入 ZI 节，ZI 节的数据都被初始化为 0。 > 当程序存储到 STM32 芯片的内部 FLASH 时 (即 ROM 区)，它占用的空间是 Code、RO data 及 RW data 的总和 ![image 20230727145319016](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046633.png) stm32的RAM大小是64K ![image 20230727145817288](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046634.png) ## 编译过程 在文件的输出的文件夹里面 ![image 20230727155424096](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046635.png) > 编译器优化水平, 一般使用优化1, 优化水平过高会导致程序出错 > > 调节的时候会使用下面的指令进行控制armcc ```bash c cpu Cortex M3 D__MICROLIB g O1 apcs interwork I ../../Libraries/CMSIS I ../../User I ../../Libraries/FWlib/inc ``` ![image 20230727155859305](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046636.png) > c: 只编译不链接 > > cpu: 选择CPU > > D: 进入点 + armasm ![image 20230727160154457](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046637.png) > 这里设置的是汇编的编译器, armasm.exe + armlink ![image 20230727160249013](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046638.png) > 这里是armlink的操作, 这里使用默认的配置进行链接, 会被记录在sct文件, 它把各个 O 文件链接组合在一起生成 ELF 格式的 AXF 文件 ```sct ; ************************************************************* ; *** Scatter Loading Description File generated by uVision *** ; ************************************************************* LR_IROM1 0x08000000 0x00080000 { ; load region size_region ER_IROM1 0x08000000 0x00080000 { ; load address execution address *.o (RESET, +First) *(InRoot$$Sections) .ANY (+RO) } RW_IRAM1 0x20000000 0x00010000 { ; RW data .ANY (+RW +ZI) } } ``` > 生成的sct文件 + armar ![image 20230727161018282](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046640.png) > 是否生成lib文件, 看不见源代码 + fromelf ![image 20230727161226119](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046641.png) 生成hex文件 ![image 20230727161310594](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046642.png) 添加一些自己的指令, 在各个步骤之前执行的指令, 可以在这里添加文件生成bin文件, 这里需要axf文件 ![image 20230727162256617](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046643.png) MDK的执行路径值在项目存放的的位置 ![image 20230727163057196](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046644.png) ## 杂项文件 ![image 20230727163303711](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046645.png) > uvprojx: 整个工程的结构，如芯片类型、工程包 含了哪些源文件等内容 > > uvoptx 文件记录了工程的配置选项，如下载器的类型、变量跟踪配置、断点位置以及当前已打开 的文件等等 > > uvguix 文件记录了 MDK 软件的 GUI 布局，如代码编辑区窗口的大小、编译输出提示窗口的位置 等等。在窗口关闭的时候会进行刚更新 ![image 20230727163836013](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046646.png) > dep, 包含的文件信息的记录的时候, 比如说包含的头文件 > > .d, 某一个文件包含的头文件等信息 > > crf, MDK跳转的时候需要的文件 > > axf, 编译之后生成的文件, 再下载的时候需要这一个文件 > > hex, bin是axf的简化版 ## 具体文件解析 ### ELF文件 可执行链接格式, 用于记录目标文件内容, linux下可以直接运行 主要是有三种类型 + 可重定位文件 包含基础代码以及文件, 但是没有包含绝对地址, 适合和其他文件链接创建可执行文件或共享目标文件, 一般是.o文件或者.obj文件 + 可执行文件 适合执行文件 包含的代码和数据都有固定的地址, 可以由系统加载到内存执行, 文件一般由链接器根据重定位文件链接而成, 主要是组织各个可重定位文件, 给代码以及数据打上地址标签, 固定在程序内部, 链接之后代码数据不能再次链接 MDK生成的.elf文件.axf文件, + 共享目标文件 .lib文件, 可以继续参与链接, 加入到可执行文件中, linux下面的.so文件 ![image 20230727192803059](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046647.png) 中间代表的是 armlink 链接器，在它的右侧是输入链接器的 *.o 文件，左侧是它输出的 *axf 文件。 于都使用 ELF 文件格式，.o 与.axf 文件的结构是类似的，它们包含 ELF 文件头、程 序头、节区 (section) 以及节区头部表。 + ELF 文件头用来描述整个文件的组织，例如数据的大小端格式，程序头、节区头在文件中 的位置等。 + 程序头告诉系统如何加载程序，例如程序主体存储在本文件的哪个位置，程序的大小，程 序要加载到内存什么地址等等。MDK 的可重定位文件 *.o 不包含这部分内容 + 节区是 *.o 文件的独立数据区域，它包含提供给链接视图使用的大量信息，如指令 (Code)、 数据 (RO、RW、ZI data)、符号表 (函数、变量名等)、重定位信息等，例如每个由 C 语言定 义的函数在 *.o 文件中都会有一个独立的节区 + 存储在最后的节区头则包含了本文件节区的信息，如节区名称、大小等等。 ![image 20230727195513356](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046648.png) > 选了以后就会每一个函数都生成一个节区 > > ```bash > Other Output Formats: > elf ELF > text Text Information > > Flags for Text Information > v verbose > a print data addresses (For images built with debug) > c disassemble code > d print contents of data section > e print exception tables > g print debug tables > r print relocation information > s print symbol table > t print string table > y print dynamic segment contents > z print code and data size information > ``` > > ![image 20230727203334919](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046649.png) > 检查.o文件的内容可以使用fromlef text v 文件名.o > 输入的文件名 > > ```bash > PS E:\\a学习\\1.stm\\A盘（资料盘）\\1 程序源码_教程文档\\1 [野火]《STM32库开发实战指南》(标准库源码)【优先学习】\\0.书籍源码\\41 PWR—电源管理\\PWR—PVD监控\\Output> fromelf.exe v text .\\stm32f10x_gpio.o > text.txt > ``` > > ```bash > > //节区头 > ** ELF Header Information > \t# 文件名 > File Name: .\\stm32f10x_gpio.o > \t# 机器的类型, 大小端, 版本号, 操作系统, , 文件类型 > Machine class: ELFCLASS32 (32 bit) > Data encoding: ELFDATA2LSB (Little endian) > Header version: EV_CURRENT (Current version) > Operating System ABI: none > ABI Version: 0 > File Type: ET_REL (Relocatable object) (1) > Machine: EM_ARM (ARM) > > Entry offset (in SHF_ENTRYSECT section): 0x00000000 > Flags: None (0x05000000) > > ARM ELF revision: 5 (ABI version 2) > > Header size: 52 bytes (0x34) > # 程序头的大小, 节区头部表的大小 > Program header entry size: 0 bytes (0x0) > Section header entry size: 40 bytes (0x28) > \t# 进入的地址 > Program header entries: 0 > Section header entries: 344 > \t# 在程序中的位置 > Program header offset: 0 (0x00000000) > Section header offset: 400496 (0x00061c70) > > Section header string table index: 341 > > > ``` > > ```bash > > > ** Section #1 > \t# 节区名字 > Name : i.GPIO_AFIODeInit > # 程序的定义信息, 格式含义都是程序解释 > Type : SHT_PROGBITS (0x00000001) > # 节区在执行过程中占用内存, 有可以执行的机器指令 > Flags : SHF_ALLOC + SHF_EXECINSTR (0x00000006) > # 地址, 设置为0表示没有分配 > Addr : 0x00000000 > # 文件中的偏移(这时候的存储位置) > File Offset : 52 (0x34) > # 大小 > Size : 22 bytes (0x16) > Link : SHN_UNDEF > Info : 0 > # 字节对齐 > Alignment : 2 > Entry Size : 0 > > > > ``` ```bash PS E:\\a学习\\1.stm\\A盘（资料盘）\\1 程序源码_教程文档\\1 [野火]《STM32库开发实战指南》(标准库源码)【优先学习】\\0.书籍源码\\41 PWR—电源管理\\PWR—PVD监控\\Output> fromelf.exe v text .\\Template.axf > text1.txt ``` ```bash ** Program header #0 Type : PT_LOAD (1) File Offset : 52 (0x34) # 物理地址以及虚拟地址 Virtual Addr : 0x08000000 Physical Addr : 0x08000000 # 在flash中的大小, 这个是Code + RO data + R data, 实际上会小, 因为编译器会优化 Size in file : 1516 bytes (0x5ec) # 加载到内存中的大小 Size in memory: 2540 bytes (0x9ec) Flags : PF_X + PF_W + PF_R + PF_ARM_ENTRY (0x80000007) Alignment : 8 # ROM的大小 ** Section #1 Name : ER_IROM1 Type : SHT_PROGBITS (0x00000001) Flags : SHF_ALLOC + SHF_EXECINSTR (0x00000006) # 这就是flash的地址 Addr : 0x08000000 File Offset : 52 (0x34) Size : 1516 bytes (0x5ec) Link : SHN_UNDEF Info : 0 Alignment : 4 Entry Size : 0 # 这个是栈和堆的空间 ** Section #2 Name : RW_IRAM1 Type : SHT_NOBITS (0x00000008) Flags : SHF_ALLOC + SHF_WRITE (0x00000003) Addr : 0x20000000 File Offset : 1568 (0x620) Size : 1024 bytes (0x400) Link : SHN_UNDEF Info : 0 Alignment : 8 Entry Size : 0 ``` ## 分散加载代码 \\_\\_scatterload函数把文件copy到RAM中对应的位置, 是链接器自动生成的, 会被_\\_\\_main函数调用, \\_\\_main函数会被Reset_Handler调用 想要使用外部SRAM需要在__main之前初始化 ## HEX和bin文件 代码数据的文件, CooCex可以使用bin文件, 这个是DAP仿真器的配套软件 + HEX 是Intel公司制定的一种ASCII文本记录器或常量数据文件格式, 实际上就是一些数字 把这些数据存储到ROM里面, 大多数下载器都支持这种格式, 格式是`:llaaaatt[dd...]cc` ![image 20230728105626279](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046650.png) > + : 一条记录的开头 > + ll: 记录之后主体记录的长度 > + aaaa: 要保存的地址 > + tt: 数据的类型 > > ![image 20230728105909767](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046651.png) > > > `:020000040800F2` > > > > 02, 两个字节, 0000是地址, 04表示扩展地址, 0800表示扩展的线性地址位置, 第一行代表的就是地址0x0800 0000, 之后的地址会在这一条的地址上面 > > + dd: 表示一个字节的数据, 一条记录有多个数据 > + cc: 校验, 对前面所有的数取和, 对256取模结果的补码 + bin文件 最直接的代码映像, 记录的内容直接下载到flash, 根据芯片的类型进行选择下载的位置, 实际上就是hex文件的存储的数据 ![image 20230728105626279](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046650.png) ![image 20230728113645226](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046652.png) ![image 20230728113754483](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046653.png) > 先设置堆栈的指针, 之后设置sp指针运行开始的位置, 中断向量表 ## htm文件 这里面有各个函数的调用 ![image 20230728114728974](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046654.png) 最深一层的栈调用, 这个是静态调用, 但是如果有递归函数的时候就不能确定了, 定义的栈空间最好要大一倍, 使用指针调用的话也不能使用 ## Listing目录下的文件 + .map文件 ![image 20230728134135540](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046655.png) > 选择包含的内容 链接器生成的文件, 主要是交叉编译的信息, 查看该文件可以了解工程文件各个符号之间的引用以及工程的Code, RO data, RW data以及ZI data的详细信息, 主要包含节区的跨文件引用, 删除无用节区, 符号映像表, 存储器映像索引以及映像组件大小 这里记录了没有使用的函数以及使用的函数, 没有的函数会进行删除 ![image 20230728134511670](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046656.png) > 记录文件调用 ![image 20230728130136781](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046657.png) > 没有使用的堆区也进行了删除 ![image 20230728141029329](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046658.png) > 变量的位置以及大小 ![image 20230728131226697](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046659.png) > 文件各个分段的大小 ## sct文件 ![image 20230728141341900](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046660.png) > 选择sct文件, 这里是不使用外部的 在构建工程的时候MDK根据芯片的信息以及FLASH和SRAM的概况生成sct文件, 分散加载文件, 在这里可以控制文件在RAM里面的加载的位置 > 之前可以使用\\_\\_attribute\\_\\_来指定把文件储存到外部SRAM, 使用分散加载文件就不需要了 > **注: **stm32使用的是NOR Flash, 可以随意访问, 所以代码段直接存放在NOR Flash, 在其他的使用NAND Flash的代码里面, 分散文件会把加载区设置为NAND FLASH文件程序的位置, 程序实际运行的位置在SRAM中, 链接器就会生成配套的分散加载代码, 把它加载到外部的SRAM中, 内核从SRAM运行 ``` ; ************************************************************* ; *** Scatter Loading Description File generated by uVision *** ; ************************************************************* LR_IROM1 0x08000000 0x00080000 { ; load region size_region加载域,文件保存的地方 ER_IROM1 0x08000000 0x00080000 { ; load address execution address执行域,执行的区域 *.o (RESET, +First) *(InRoot$$Sections) .ANY (+RO) } RW_IRAM1 0x20000000 0x00010000 { ; RW data这里是RW以及ZI .ANY (+RW +ZI) } } ``` > 分配了Code, RO data, RW data, ZI data > > 主要包含加载域以及执行域 > > 最外层的是加载域, 第二层的是执行域 ![image 20230728144036373](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046661.png) ![image 20230728144816525](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046662.png) ![image 20230728160758667](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046663.png) + 模块选择样式 可以用于选择.o或者是.lib文件作为输入节区, 直接使用文件名或者使用通配符\"\\*\", 比如\\*.o, 也可以使用.ANY或单独的\"\\*\"选择所有的.o和.lib文件, .ANY的优先级最低, 选择剩下的文件 + 输入节区样式 ![image 20230728161519261](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046664.png) 在启动文件设置的节区的名字, + 输入节区属性 选择样式中的不同内容, 描述符之前有一个+, 使用空格或者逗号隔开 ![image 20230728162041527](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046665.png) + 输入节区特性 使用+FIRST或+LAST选择储存的位置, 一般重要的节区在头部, 校验之类的在尾部 + 特殊符号 \\*(lnRoot$$Section)是链接器支持的特殊符号, 选择所有的标准库里面的要求存储到root区域的节区, 比喻\\_\\_main.o、\\_\\_scatter\\*.o等内容 ### 修改 ![image 20230728163438360](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046666.png) ![image 20230728163553131](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046667.png) ``` ; ************************************************************* ; *** Scatter Loading Description File generated by uVision *** ; ************************************************************* LR_IROM1 0x08000000 0x00080000 { ; load region size_region ER_IROM1 0x08000000 0x00080000 { ; load address execution address *.o (RESET, +First) *(InRoot$$Sections) .ANY (+RO) } RW_IRAM1 0x20000000 0x00008000 { ; RW data .ANY (+RW +ZI) } RW_IRAM2 0x20008000 0x00008000 { .ANY (+RW +ZI) } } ``` ![image 20230728163831741](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046668.png) ![image 20230728163849266](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046669.png) 选择文件的位置 ![image 20230728164001377](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046670.png) ``` ; ************************************************************* ; *** Scatter Loading Description File generated by uVision *** ; ************************************************************* LR_IROM1 0x08000000 0x00080000 { ; load region size_region ER_IROM1 0x08000000 0x00080000 { ; load address execution address *.o (RESET, +First) *(InRoot$$Sections) .ANY (+RO) } RW_IRAM1 0x20000000 0x00008000 { ; RW data .ANY (+RW +ZI) } RW_IRAM2 0x20008000 0x00008000 { bsp_led.o (+RW) .ANY (+RW +ZI) } } ``` ### 实际应用 + 自动分配变量到指定的空间 ![image 20230728174329071](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046671.png) DAK会自动选择比较大的RAM先进行使用 由于速度的原因, 一般优先使用内部的SRAM ``` LR_IROM1 0x08000000 0x00080000 { ; load region size_region ER_IROM1 0x08000000 0x00080000 { ; load address execution address *.o (RESET, +First) *(InRoot$$Sections) .ANY (+RO) } RW_IRAM1 0x20000000 0x00005000 { ; RW data \t*.o(STACK) .ANY (+RW +ZI) } RW_ERAM1 0x20005000 0x00007000 { *.o(HEAP) } } ``` + 在外部空间存放大的数据 ```c uint8_t test5[1024] __attribute__((section(\"EXRAM\"))) {1, 2, 3}; ``` ```c LR_IROM1 0x08000000 0x00080000 { ; load region size_region ER_IROM1 0x08000000 0x00080000 { ; load address execution address *.o (RESET, +First) *(InRoot$$Sections) .ANY (+RO) } RW_IRAM1 0x20000000 0x00005000 { ; RW data \t*.o(STACK) .ANY (+RW +ZI) } RW_ERAM1 0x20005000 0x00007000 { *.o(EXRAM) *.o(HEAP) } } ``` ``` Execution Region RW_IRAM1 (Exec base: 0x20000000, Load base: 0x080005e0, Size: 0x00000410, Max: 0x00005000, ABSOLUTE) Exec Addr Load Addr Size Type Attr Idx E Section Name Object 0x20000000 0x080005e0 0x00000006 Data RW 3110 .data main.o 0x20000006 0x080005e6 0x00000002 PAD 0x20000008 0x080005e8 0x00000004 Data RW 3260 .data mc_w.l(mvars.o) 0x2000000c 0x080005ec 0x00000004 Data RW 3261 .data mc_w.l(mvars.o) 0x20000010 0x00000400 Zero RW 1 STACK startup_stm32f10x_hd.o Execution Region RW_ERAM1 (Exec base: 0x20005000, Load base: 0x080005f0, Size: 0x00000600, Max: 0x00007000, ABSOLUTE, COMPRESSED[0x0000000c]) Exec Addr Load Addr Size Type Attr Idx E Section Name Object 0x20005000 COMPRESSED 0x00000400 Data RW 3111 EXRAM main.o 0x20005400 0x00000200 Zero RW 2 HEAP startup_stm32f10x_hd.o ``` ### 使用外部SRAM 1. 在启动文件之中初始化SRAM放在__main之前 2. 更改sct文件 stack一定要在内部SRAM, 因为在调用SystemInit的时候还没有初始化外部SRAM空间, 固件库也有提供不使用变量的函数, 需要定义宏"},"/note/嵌入式/stm32/固件库/2023-11-30-28WWDG.html":{"title":"WWDG","content":" layout: post title: \"WWDG\" date: 2023 11 29 15:39:08 +0800 tags: stm32 # WWDG Window watchdog窗口看门狗 本质: 计数器, 可以产生系统复位和唤醒信号 特性: 递减计数器, 递减计数器从0x40减到0x3f的时候会复位(T6跳变为0), 计数器的值大于W[6:0]的时候喂狗会进行复位, 提前唤醒中断EWI(当计数值等于0x40的时候可以产生一个提前唤醒中断) 喂狗: 在窗口期里面重装载, 防止复位 ## 作用 用于监测单片机程序运行时效是否精准，主要检测软件异常 用于监测单片机程序运行时效是否精准，主要检测软件异常 ![image 20231130205815481](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311302058556.png) ![image 20231130210602940](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311302106002.png) ## 寄存器 + WWDG_CR控制寄存器 ![image 20231130210654925](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311302106966.png) > 没有重装载寄存器, 直接对这几个位进行操作 + WWDG_CFR配置寄存器 ![image 20231130210927467](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311302109515.png) + WWDG_SR状态寄存器 ![image 20231130211040319](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311302110354.png) ## 超时时间计算 ![image 20231130211517491](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311302115542.png) ![image 20231130224750805](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311302247850.png) 对于一般的看门狗，程序可以在它产生复位前的任意时刻刷新看门狗，但是这样有一个隐患，有可能程序跑乱了又跑回正常的地方，或者跑乱的程序正好执行了刷新看门狗操作，这样的情况下一按的看门狗就检测不出来故障了；但是如果使用窗口看门狗，程序员可以根据程序正常执行的时间设置刷新看门狗的一个时间窗口，保证不会提前刷新看门狗，也不会滞后刷新看门狗，这样可以检测出程序没有按照正常的路径运行，非正常地跳过了某些程序段的情况。 WWDG与IWDG的主要区别是有一个窗口控制，WWDG的中断不是用于日常喂狗的，如果用于日常喂狗动作，那WWDG的相对于IWDG，功能也就没什么特别了。WWDG的中断是给程序员最后一次喂狗的机会，一般进入这个中断时，表示你在其他地方安排的喂狗操不能凑效了，而发生这种现象时，肯定是系统有问题了，或者程序有Bug或者干扰，在这种情况下，这个中断时为了让你的程序在发生真正的看门狗复位前，有一个紧急处理的机会，如保存重要数据，或者系统刹车，说白了，就是让CPU写“遗嘱”；"},"/note/嵌入式/stm32/固件库/2023-7-16-20定时器.html":{"title":"定时器","content":" layout: post title: \"定时器\" date: 2023 7 16 15:39:08 +0800 tags: stm32 # 定时器 ## 定时器概述 ### 软件定时原理 使用纯软件(CPU死等)的方式实现定时器(延时)功能 这一个是不精准的, 因为函数调用是有一定时间及, 并且stm32有流水线, 语句执行的时间是不精确的 ### 定时器定时原理 使用精准的时基, 通过硬件的方式, 实现定时功能 ![image 20231201090147291](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312010901375.png) ### stm32定时器分类 + 常规定时器 有三种功能, 定时, 输出比较, 输出捕获, 互补输出 有三种: 基本定时器: 定时 通用定时器: 没有互补 高级定时器: 都有 ![image 20230717150629149](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281047859.png) ![image 20231201090840167](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312010908214.png) > H7 ![image 20231201091021022](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312010910078.png) + 专用定时器 独立看门狗 窗口看门狗 实时时钟 低功耗定时器 + 内核定时器 SysTick定时器 ### 溢出时间 ![image 20231201194745187](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312011947235.png) ## 基本定时器 ### 特点 16bit, 只能向上计数, 只有TIM6, TIM7 没有GPIO, 是内部资源, 时钟来自PCLK1, 72M时钟16位分频可以实现1 65535分频, ![image 20230717151044639](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281047860.png) > 控制器: 复位, 使能, 计数, 触发DAC, 涉及的寄存器是CR1/2, DIER, SR > > 在计数器(ANT)的值等于重装载寄存器(ARR(影子))的时候会发生溢出 > > U >Update更新事件, 除了溢出更新还可以通过UG位进行软件更新, 会把预装载的值加载到影子寄存器 > > ![image 20231201192844792](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312011928858.png) > 时基单元: 包括预分频器, 计数器, 自动重装载寄存器, 计数时钟CK_CNT CK_PSC/(PSC+1) > 影子寄存器: 起到缓冲寄存器, 有一个缓冲的功能, 用户值 >寄存器 >影子寄存器 >起作用, 不使用的话用户的值写到之后起作用, 使用的话这一周期计数之后起作用, TIMx_CR1:APRE控制 > > 影子寄存器是实际上起作用的寄存器, 并且是不可直接访问的 > > 一般是一个事件以后才会进行写入 ### 计数模式 ![image 20231201193335520](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312011933590.png) ![image 20231201193615116](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312011936179.png) > 递增计数模式 ![image 20231201193726151](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312011937205.png) > 递减计数模式 ![image 20231201193802947](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312011938003.png) > 中心对齐模式 ## 通用定时器 ### 特点 F1: TIM2, 3, 4, 5 16位递增, 递减, 中心对齐计数器 16位预分频器 可以用于触发DAC, ADC 在更新事件, 触发事件, 捕获输入, 输出比较的时候会产生DMA请求 四个独立通道, 可以用于输入捕获, 输出比较, 输出PWM和单脉冲模式 可实现外部信号控制定时器以及多个定时器相互连接的同步电路(级联) ### 时钟 ![image 20231202115920002](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312021159099.png) > 4+5模式: 信号通过外部的引脚输入, 经过滤波以后捕获边沿, 之后通过某一个通道分频以后会产生一个捕获信号, 这一个信号会把CNT计数器的值保存在捕获寄存器里面 > > 5+6模式: 向比较寄存器里面写入比较值, 之后计数器正常的计数, 当两个的值相等的时候(影子寄存器), 之后会产生一个输出参考OC1REF信号到通道, OC1信号会受到输出模式和ETRF(控制输出参考信号)的控制 > > 两个模式是分时复用的关系, 不能同时使用 ### 时钟源 1. 内部时钟CK_INT, 来自APB总线提供的时钟 2. 外部时钟模式1, 来自外部的TI1F ED会检测上升沿和下降沿, 产生两个脉冲, 或者是TI1FP1, TI2PF2为单边沿捕获 3. 外部时钟模式2, 外引脚触发ETR, 来自可以复用为TIMx_ETR的引脚 4. 内部触发输入(ITRx), 来自其他定时器的TRGO信号 ![image 20231202193149278](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312021931352.png) > + 外部时钟 > > TIMx_SMCR寄存器, 使用内部时钟的时候ECE也要设置为0 > > ![image 20231202194333358](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312021943421.png) > > + 外部时钟模式1 > > 当TIMx_SMCR寄存器的SMS 111时，此模式被选中。计数器可以在选定输入端的每个上升沿 或下降沿计数。 > > ![image 20231202194603955](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312021946022.png) > > > 设置SMCR寄存器的TS位为100, 101, 110的时候选择不同的通道 > > > > 使用滤波器以后只有在采样的时候连续N次采样的结果是相同的时候才会产生跳变, 否则的话不会发生变化 > > ![image 20231202195346212](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312021953255.png) > > + 外部时钟模式2 > > 选定此模式的方法为：令TIMx_SMCR寄存器中的ECE 1 计数器能够在外部触发ETR的每一个上升沿或下降沿计数。 > > 还有一种是把SMS设置为111, TS也是111的时候效果是相同的 > > <img src \"https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312021954293.png\" alt \"image 20231202195425243\" style \"zoom:150%;\" /> > > > ETRP的频率最高是CK_INT频率的四分之一, 外部时钟的输入比较快的时候需要使用预分频 > > + 一个时钟为另一个时钟时钟源 > > ![image 20231202201742996](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312022017052.png) > > MMS会设置产生一个TRGO信号 > > TS设置为0xx可以选择时钟的来源 > > ![image 20231202202010978](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312022020018.png) ### 输出PWM(输出比较) ![image 20231202204229664](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312022042727.png) ![image 20231202204909891](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312022049956.png) ![image 20231202205029034](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312022050092.png) > ETRF信号是外部引脚的输入信号经过滤波器以后的一个分支 ![image 20231202205722129](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312022057197.png) #### 模式 + PWM模式1 TIMx_CCMRx寄存器的COMx位进行控制,有三位 ![image 20231202210338177](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312022103216.png) ![image 20231202210632464](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312022106548.png) ### 输入捕获 ![image 20231202220143648](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312022201716.png) ![image 20231202220834030](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312022208092.png) ![image 20231202220904796](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312022209866.png) > 在读操作完成以后会把捕获的值存放到可以读取的寄存器里面 ### 脉冲计数 定时器有四种输入模式, 这一个需要使用的是外部输入模式1和2 ![image 20231203185735621](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312031857711.png) ![image 20231203185817677](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312031858746.png) ## 高级定时器 多了重复计数器, 死区时间, 可以编程的互补输出 断路输入, 用于将计时器的输出信号置于用户可选择的安全配置 ### 时钟 ![image 20231203194526203](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312031945296.png) ![image 20231203194843573](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312031948662.png) ### 重复计数器 ![image 20231203194955190](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312031949273.png) ### 输出指定数量的PWM ![image 20231203195825105](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312031958183.png) ### 输出比较 ![image 20231203210048759](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312032100832.png) > 占空比是百分之五十 ### 互补输出带死区控制 ![image 20231203221140348](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312032211204.png) > 互补输出, 两条路的电平相反, 死区时间, 输出之间有一个延迟 + 应用: H桥 ![image 20231203221355271](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312032213360.png) > 四个都是高电平的时候会导通, 如果输出通道和互补输出通道同时设置为1的时候电源会直接接地 > > 实际的使用的时候不会是这么简单的, 元器件之间的电气特性是有一定的延时的, 所以需要死区时间 ![image 20231203223514040](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312032235116.png) ![image 20231204145141334](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312041451467.png) ### 刹车短路 ![image 20231204145334416](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312041453496.png) ![image 20231204150110016](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312041501063.png) ![image 20231204151019659](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312041510768.png) ![image 20231204152428700](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312041524769.png) ![image 20231204152447404](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312041524465.png) ![image 20231204152355340](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312041523383.png) ![](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312041615846.png) ### PWM输入模式 + 原理 ![image 20231204165858442](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312041658528.png) ![image 20231204170032988](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312041700048.png) ## 寄存器 + TIMx_CR1: 控制寄存器 ![image 20230717153402120](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281047861.png) ![image 20230717154321210](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281047862.png) + TIMx_CR2 + TIMx_SMCR: 从模式控制寄存器 + TIMx_DIER: DMA/中断使能寄存器 ![image 20231201194349232](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312011943275.png) + TIMx_SR: 状态寄存器 ![image 20231201194421395](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312011944439.png) + TIMx_EGR: 事件产生寄存器 + TIMx_CCMR1: 捕获/比较模式寄存器 ![image 20230717172716414](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281047863.png) ![image 20230717172857298](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281047864.png) + TIMx_CCMR2 + TIMx_CCER: 捕获/比较使能寄存器 ![image 20230717173212170](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281047865.png) + TIMx_CNT: 计数器 ![image 20230717154825674](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281047866.png) + TIMx_PSC: 预分频器 ![image 20230717154814765](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281047867.png) + TIMx_ARR: 自动重装载寄存器 ![image 20230717154804279](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281047868.png) + TIMx_RCR ![image 20230717155356355](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281047869.png) > 计数器的值到达之后不发生中断, 到达这个值的时候才产生 + TIMx_CCR1: 捕获/比较寄存器 + TIMx_CCR2 + TIMx_CCR3 + TIMx_CCR4 + TIMx_BDTR: TIM1 和TIM8 刹车和死区寄存器 ![image 20230719100615309](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281047870.png) + TIMx_DCR: DMA控制寄存器 + TIMx_DMAR: 连续模式的DMA地址 ## 固件库 ```c typedef struct { uint16_t TIM_Prescaler; /*!< Specifies the prescaler value used to divide the TIM clock. This parameter can be a number between 0x0000 and 0xFFFF 分频因子*/ uint16_t TIM_CounterMode; /*!< Specifies the counter mode. This parameter can be a value of @ref TIM_Counter_Mode 计数模式, 基础寄存器只能向下计数*/ uint16_t TIM_Period; /*!< Specifies the period value to be loaded into the active Auto Reload Register at the next update event. This parameter must be a number between 0x0000 and 0xFFFF. 自动重装载*/ uint16_t TIM_ClockDivision; /*!< Specifies the clock division. This parameter can be a value of @ref TIM_Clock_Division_CKD 外部输入时钟分频因子, 基础定时器没有*/ uint8_t TIM_RepetitionCounter; /*!< Specifies the repetition counter value. Each time the RCR downcounter reaches zero, an update event is generated and counting restarts from the RCR value (N). This means in PWM mode that (N+1) corresponds to: the number of PWM periods in edge aligned mode the number of half PWM period in center aligned mode This parameter must be a number between 0x00 and 0xFF. @note This parameter is valid only for TIM1 and TIM8. 重复计数器, 高级计数器的*/ } TIM_TimeBaseInitTypeDef; ``` ## 实际使用 ```c void BASIC_TIM_Config(void) { \tTIM_TimeBaseInitTypeDef TIM_BaseStructure; \tBASIC_TIM_APBxClock_FUN(BASIC_TIM_CLK, ENABLE); \t \t \tTIM_BaseStructure.TIM_Period BASIC_TIM_Period; \t \tTIM_BaseStructure.TIM_Prescaler BASIC_TIM_Prescaler; \t/****基础定时器没有****/ \tTIM_BaseStructure.TIM_ClockDivision TIM_CKD_DIV1; \tTIM_BaseStructure.TIM_CounterMode TIM_CounterMode_Up; \tTIM_BaseStructure.TIM_RepetitionCounter 0; \t/********************/ \t \tTIM_TimeBaseInit(BASIC_TIM, &TIM_BaseStructure); //清除中断标志位 \tTIM_ClearFlag(BASIC_TIM, TIM_FLAG_Update); \tTIM_ITConfig(BASIC_TIM, TIM_FLAG_Update, ENABLE); \tTIM_Cmd(BASIC_TIM, ENABLE); \t } ``` ## 高级定时器 定时, 输出比较, 输出捕获, 输入捕获, 互补输出, 断路输出 16bit, 上/下/两边计数, 重复计数器, 四个GPIO, 通道1 3还有互补输出GPIO, 时钟使用PCLK2, 72M ![image 20230717171657107](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281047871.png) ![image 20230717171928852](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281047872.png) ![image 20230717171950102](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281047873.png) > 时钟源: CK_INT(TIMx_CLK在PSC分频之后), 内部时钟, 72MHz, > > ![image 20230717172438019](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281047874.png) > > 来自外部GPIO, 对应TIMx_CH1/2/3/4, TIM_CCMRx的CCxS位控制, 经过滤波(TIMx_CCMR:ICxF)之后, 之后进行边沿检测, 控制有效的边沿, TIM_CCER:CCxP和CCxNP, 最后进行触发选择, 很少使用 > > ![image 20230717194237657](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281047875.png) > > f~DTS~, TIMx_CR1:CKD决定, > 内部触发输入 > > 使用一个定时器作为另一个定时器的预分频器, 实现级联, TIMx_SMCR:TS > **总结: **有四种输入源, 内部时钟CK_INT, 外部时钟1引脚TIx, 外部触发输入ETR, 内部触发输入 + 时基同普通 ![image 20230717200012120](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281047876.png) + 输入捕获 ![image 20230717200024126](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281047877.png) > 对信号的上升下降或者双边捕获, 大概的原理就是跳变的时候把CNT计数器的值捕获到CCR寄存器 ① 输入通道, 输入的信号从定时器外部引脚TIMx_CH1/2/3/4进入, 通常叫TI1/2/3/4 ② 输入滤波以及边沿检测, 存在高频干扰的信号进行滤波 ③ 捕获通道, 捕获的时候CNTx计入CCRx, 一个输入通道可以进入两个捕获通道(PWM捕获, 只能使用IC1, IC2) ![image 20230717201101387](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281047878.png) ④ 预分频器 ⑤ 捕获寄存器, 会产生 CCxI 中断，相应的中断位 CCxIF（在 SR 寄存器中）会 被置位，通过软件或者读取 CCR 中的值可以将 CCxIF 清 0。如果发生第二次捕获（即重复捕获： CCR 寄存器中已捕获到计数器值且 CCxIF 标志已置 1），则捕获溢出标志位 CCxOF（在 SR 寄存 器中）会被置位，CCxOF 只能通过软件清零。 + 输出比较 ![image 20230717201347531](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281047879.png) > 计数到CCR的时候发生电平跳变, 计数到ARR的时候重装载切跳变 > DTG: 死区寄存器, 一般输出的PWM不可以直接驱动电机, 需要一个半桥驱动电路, 需要互补的PWM信号, 加入PWM的时候由于MOS管打开关闭需要一定时间, 所以需要预留一定的时间, 这就是死区 > 输出控制, 不需要了解 > > ![image 20230717202403178](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281047880.png) ### 实际使用 + 测量脉宽和频率 当测试到跳变的时候会发生中断, 测量脉宽的时候需要不断地改变触发的边沿 + PWM输入模式 通道一通道二, IC1是周期, IC2是占空比, 也可以反过来叫做非直连 在第一个上升沿发生跳变, IC2在第一个下降沿发生捕获, IC1在下一个上升沿发生捕获 ![image 20230718183208629](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281047881.png) 计数的值是从零开始, 计算的时候需要加一 + 输出比较 一共有八种, )CCMRx的OCxM配置 一般使用为PWM模式, 频率是ARR控制, 占空比CRR ![image 20230718183715608](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281047882.png) > 中心对齐模式, 计数器达到重装载的值之后向下计数, 重新回到0之后开始递增 ## PWM ![image 20230718184739691](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281047883.png) > 原理, 输出的信号主要控制CCR以及ARR, 以及PSC进行分频 ```c typedef struct { uint16_t TIM_OCMode; /*!< Specifies the TIM mode. This parameter can be a value of @ref TIM_Output_Compare_and_PWM_modes 使用的PWM模式*/ uint16_t TIM_OutputState; /*!< Specifies the TIM Output Compare state. This parameter can be a value of @ref TIM_Output_Compare_state 设置的是正通道*/ uint16_t TIM_OutputNState; /*!< Specifies the TIM complementary Output Compare state. This parameter can be a value of @ref TIM_Output_Compare_N_state @note This parameter is valid only for TIM1 and TIM8. 设置的是互补通道*/ uint16_t TIM_Pulse; /*!< Specifies the pulse value to be loaded into the Capture Compare Register. This parameter can be a number between 0x0000 and 0xFFFF 设置的是比较寄存器的值*/ uint16_t TIM_OCPolarity; /*!< Specifies the output polarity. This parameter can be a value of @ref TIM_Output_Compare_Polarity 设置的是极性, 设置是高电平有效还是低电平有效*/ uint16_t TIM_OCNPolarity; /*!< Specifies the complementary output polarity. This parameter can be a value of @ref TIM_Output_Compare_N_Polarity @note This parameter is valid only for TIM1 and TIM8. */ uint16_t TIM_OCIdleState; /*!< Specifies the TIM Output Compare pin state during Idle state. This parameter can be a value of @ref TIM_Output_Compare_Idle_State @note This parameter is valid only for TIM1 and TIM8. 输出的时候空闲电平极性设置, 用到断路功能的时候使用*/ uint16_t TIM_OCNIdleState; /*!< Specifies the TIM Output Compare pin state during Idle state. This parameter can be a value of @ref TIM_Output_Compare_N_Idle_State @note This parameter is valid only for TIM1 and TIM8. */ } TIM_OCInitTypeDef; ``` > 输出比较控制结构体 ```c typedef struct { uint16_t TIM_Channel; /*!< Specifies the TIM channel. This parameter can be a value of @ref TIM_Channel */ uint16_t TIM_ICPolarity; /*!< Specifies the active edge of the input signal. This parameter can be a value of @ref TIM_Input_Capture_Polarity */ uint16_t TIM_ICSelection; /*!< Specifies the input. This parameter can be a value of @ref TIM_Input_Capture_Selection */ uint16_t TIM_ICPrescaler; /*!< Specifies the Input Capture Prescaler. This parameter can be a value of @ref TIM_Input_Capture_Prescaler */ uint16_t TIM_ICFilter; /*!< Specifies the input capture filter. This parameter can be a number between 0x0 and 0xF */ } TIM_ICInitTypeDef; ``` > 输入 ```c typedef struct { uint16_t TIM_OSSRState; /*!< Specifies the Off State selection used in Run mode. This parameter can be a value of @ref OSSR_Off_State_Selection_for_Run_mode_state 运行模式下关闭状态的选择 0：当定时器不工作时，禁止OC/OCN输出(OC/OCN使能输出信号 0)； \t\t\t\t\t\t\t\t 1：当定时器不工作时，一旦CCxE 1或CCxNE 1，首先开启OC/OCN并输出无效电平，然后 \t\t\t\t\t\t\t\t 置OC/OCN使能输出信号 1。*/ uint16_t TIM_OSSIState; /*!< Specifies the Off State used in Idle state. This parameter can be a value of @ref OSSI_Off_State_Selection_for_Idle_mode_state 空闲模式下关闭状态的选择*/ uint16_t TIM_LOCKLevel; /*!< Specifies the LOCK level parameters. This parameter can be a value of @ref Lock_level 写保护寄存器*/ uint16_t TIM_DeadTime; /*!< Specifies the delay time between the switching off and the switching on of the outputs. This parameter can be a number between 0x00 and 0xFF 死区时间*/ uint16_t TIM_Break; /*!< Specifies whether the TIM Break input is enabled or not. This parameter can be a value of @ref Break_Input_enable_disable 刹车是否使能*/ uint16_t TIM_BreakPolarity; /*!< Specifies the TIM Break Input pin polarity. This parameter can be a value of @ref Break_Polarity 引脚为什么电平的时候进行刹车*/ uint16_t TIM_AutomaticOutput; /*!< Specifies whether the TIM Automatic Output feature is enabled or not. This parameter can be a value of @ref TIM_AOE_Bit_Set_Reset 自动使能输出*/ } TIM_BDTRInitTypeDef; ``` > 刹车死区控制 ### 实际PWM ```c #include \"bsp_pwm.h\" static void ADVANCE_TIM_GPIO_Config(void) { \tGPIO_InitTypeDef GPIO_InitStructure; \t// 输出比较通道 GPIO 初始化 \tRCC_APB2PeriphClockCmd(ADVANCE_TIM_CH1_GPIO_CLK, ENABLE); \tGPIO_InitStructure.GPIO_Pin ADVANCE_TIM_CH1_PIN; \tGPIO_InitStructure.GPIO_Mode GPIO_Mode_AF_PP; \tGPIO_InitStructure.GPIO_Speed GPIO_Speed_50MHz; \tGPIO_Init(ADVANCE_TIM_CH1_PORT, &GPIO_InitStructure); \t// 输出比较通道互补通道 GPIO 初始化 \tRCC_APB2PeriphClockCmd(ADVANCE_TIM_CH1N_GPIO_CLK, ENABLE); \tGPIO_InitStructure.GPIO_Pin ADVANCE_TIM_CH1N_PIN; \tGPIO_InitStructure.GPIO_Mode GPIO_Mode_AF_PP; \tGPIO_InitStructure.GPIO_Speed GPIO_Speed_50MHz; \tGPIO_Init(ADVANCE_TIM_CH1N_PORT, &GPIO_InitStructure); \t// 输出比较通道刹车通道 GPIO 初始化 \tRCC_APB2PeriphClockCmd(ADVANCE_TIM_BKIN_GPIO_CLK, ENABLE); \tGPIO_InitStructure.GPIO_Pin ADVANCE_TIM_BKIN_PIN; \tGPIO_InitStructure.GPIO_Mode GPIO_Mode_AF_PP; \tGPIO_InitStructure.GPIO_Speed GPIO_Speed_50MHz; \tGPIO_Init(ADVANCE_TIM_BKIN_PORT, &GPIO_InitStructure); \t// BKIN引脚默认先输出低电平 \tGPIO_ResetBits(ADVANCE_TIM_BKIN_PORT,ADVANCE_TIM_BKIN_PIN);\t } static void ADVANCE_TIM_MODE_Config(void) { \t // 开启定时器时钟,即内部时钟CK_INT 72M \tADVANCE_TIM_APBxClock_FUN(ADVANCE_TIM_CLK,ENABLE); /* 时基结构体初始化 */ \tTIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; \t// 自动重装载寄存器的值，累计TIM_Period+1个频率后产生一个更新或者中断 \tTIM_TimeBaseStructure.TIM_Period ADVANCE_TIM_PERIOD;\t \t// 驱动CNT计数器的时钟频率 Fck_int/(psc+1) \tTIM_TimeBaseStructure.TIM_Prescaler ADVANCE_TIM_PSC;\t \t// 时钟分频因子 ，配置死区时间时需要用到,配置的是CK_INT,死区时间采用的分频 \tTIM_TimeBaseStructure.TIM_ClockDivision TIM_CKD_DIV1;\t\t \t// 计数器计数模式，设置为向上计数 \tTIM_TimeBaseStructure.TIM_CounterMode TIM_CounterMode_Up;\t\t \t// 重复计数器的值，没用到不用管 \tTIM_TimeBaseStructure.TIM_RepetitionCounter 0;\t \t// 初始化定时器 \tTIM_TimeBaseInit(ADVANCE_TIM, &TIM_TimeBaseStructure); \t/* 输出比较结构体初始化 */\t\t \tTIM_OCInitTypeDef TIM_OCInitStructure; \t// 配置为PWM模式1 \tTIM_OCInitStructure.TIM_OCMode TIM_OCMode_PWM1; \t// 输出使能 \tTIM_OCInitStructure.TIM_OutputState TIM_OutputState_Enable; \t// 互补输出使能 \tTIM_OCInitStructure.TIM_OutputNState TIM_OutputNState_Enable; \t// 设置占空比大小 \tTIM_OCInitStructure.TIM_Pulse ADVANCE_TIM_PULSE; \t// 输出通道电平极性配置 \tTIM_OCInitStructure.TIM_OCPolarity TIM_OCPolarity_High; \t// 互补输出通道电平极性配置 \tTIM_OCInitStructure.TIM_OCNPolarity TIM_OCNPolarity_High; \t// 输出通道空闲电平极性配置 \tTIM_OCInitStructure.TIM_OCIdleState TIM_OCIdleState_Set; \t// 互补输出通道空闲电平极性配置 \tTIM_OCInitStructure.TIM_OCNIdleState TIM_OCNIdleState_Reset; \tTIM_OC1Init(ADVANCE_TIM, &TIM_OCInitStructure); \tTIM_OC1PreloadConfig(ADVANCE_TIM, TIM_OCPreload_Enable); \t/* 刹车和死区结构体初始化 */ \t// 有关刹车和死区结构体的成员具体可参考BDTR寄存器的描述 \tTIM_BDTRInitTypeDef TIM_BDTRInitStructure; TIM_BDTRInitStructure.TIM_OSSRState TIM_OSSRState_Enable; TIM_BDTRInitStructure.TIM_OSSIState TIM_OSSIState_Enable; TIM_BDTRInitStructure.TIM_LOCKLevel TIM_LOCKLevel_1; \t// 输出比较信号死区时间配置，具体如何计算可参考 BDTR:UTG[7:0]的描述 \t// 这里配置的死区时间为152ns TIM_BDTRInitStructure.TIM_DeadTime 11; TIM_BDTRInitStructure.TIM_Break TIM_Break_Enable; \t// 当BKIN引脚检测到高电平的时候，输出比较信号被禁止，就好像是刹车一样 TIM_BDTRInitStructure.TIM_BreakPolarity TIM_BreakPolarity_High; TIM_BDTRInitStructure.TIM_AutomaticOutput TIM_AutomaticOutput_Enable; TIM_BDTRConfig(ADVANCE_TIM, &TIM_BDTRInitStructure); \t \t// 使能计数器 \tTIM_Cmd(ADVANCE_TIM, ENABLE);\t \t// 主输出使能，当使用的是通用定时器时，这句不需要 \tTIM_CtrlPWMOutputs(ADVANCE_TIM, ENABLE); \t } void ADVANCE_TIM_Init(void) { \tADVANCE_TIM_GPIO_Config(); \tADVANCE_TIM_MODE_Config(); \t } ```"},"/note/嵌入式/stm32/固件库/2023-7-5-14文件系统.html":{"title":"文件系统","content":" layout: post title: \"文件系统\" date: 2023 7 5 15:39:08 +0800 tags: stm32 # 文件系统 实际上就是建立了一些组织结构, 包括系统引导区, 目录和文件 在使用之前需要进行格式, 格式化会建立文件按分配表等 磁盘分区表: 把一块磁盘划分多个分区 在存储文件的时候会创建文件索引, 指明文件存放的物理地址, 之后把文件存储 实际结构: 1. 文件分配表 在文件不是连续的时候只有目录不够用, 记录了文件的位置, 以及下一个扇区的位置 2. 目录 记录文件的开始簇, 大小, 日期, 属性等 3. 应用 ## Fatfs 使用C语言的文件操作函数 ![image 20230706134022729](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050193.png) fatfs是一个面向嵌入式的小型文件系统, 完全使用C语言, 独立于底层的I/O介质 支持Fat12, Fat16, Fat32 [FatFs Generic FAT Filesystem Module (elm chan.org)](http://elm chan.org/fsw/ff/00index_e.html) > 不能开代理 + doc: 帮助文档 + src: 源码 ![image 20230706140507706](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050194.png) > history: 文件版本信息 > > readme: 帮助信息 > > integer.h 变量的定义 > > diskio.c: 底层操作函数, 需要自己实现 > > ff.c核心文件, 实现管理方法, 文件系统和底层的转换, 根据配置实现函数 > > ![image 20230706155439129](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050195.png) > > ffconfig.h, 配置文件, 包含了各种宏定义, 用于裁剪, 支持的语言 > > option: 支持的语言编码 ## 实际实现 首先添加所有src文件 之后包含头文件路径 由于这是一个示例文件, 所以有的头文件不存在 ![image 20230706144834420](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050196.png) > diskio.h ```c DWORD get_fattime(void) { \treturn 0; } ``` > 缺少函数, 手动添加 ### 实际实现函数 + disk_initialize初始化函数 ![image 20230706151023766](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050197.png) 初始化函数, 使得存储器可读可写, 返回值把STA_NOINIT清零, 参数是初始化的内存编号 在使用的时候用上层函数, f_mount ```c DSTATUS disk_initialize ( \tBYTE pdrv\t\t\t\t/* Physical drive nmuber to identify the drive */ ) { \tDSTATUS stat; \tswitch (pdrv) { \tcase SD_CARD : \t\treturn stat; \tcase SPI_FLASH : \t\tSPI_FLASH_Init();//初始化 \t\tSPI_Flash_WAKEUP();//唤醒 \t\t//直接调用状态函数 \t\treturn disk_status(pdrv); \t} \treturn STA_NOINIT; } ``` + disk_status ![image 20230706151303481](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050198.png) > 初始化正常返回0, 否则返回上面的值 ```c DSTATUS disk_status ( \tBYTE pdrv\t\t/* Physical drive nmuber to identify the drive */ ) { \tDSTATUS stat; \t//int result; \tswitch (pdrv) { \tcase SD_CARD : \t\treturn stat; \tcase SPI_FLASH : \t\t \t\tif(SPI_FLASH_ReadID() sFLASH_ID) \t\t{ \t\t\t//正常 \t\t\tstat 0; \t\t}else \t\t{ \t\t\t//不正常 \t\t\tstat STA_NOINIT; \t\t} \t\treturn stat; \t} \treturn STA_NOINIT; } ``` + disk_read ![image 20230706153118670](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050199.png) > 返回值是一个枚举类型 ```c DRESULT disk_read ( \tBYTE pdrv,\t\t/* Physical drive nmuber to identify the drive */ \tBYTE *buff,\t\t/* Data buffer to store read data */ \tDWORD sector,\t/* Sector address in LBA */ \tUINT count\t\t/* Number of sectors to read */ ) { \tDRESULT res; \t//int result; \tswitch (pdrv) { \tcase SD_CARD : \t\treturn res; \tcase SPI_FLASH : \t\t//使用扇区作为单位, 所以进行地址转换 \t\tSPI_FLASH_BufferRead(buff, (sector * 4096), (count * 4096)); \t\tres RES_OK; \t\treturn res;\t \t} \treturn RES_PARERR; } ``` + disk_ write ![image 20230706154352294](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050200.png) ```c DRESULT disk_write ( \tBYTE pdrv,\t\t\t/* Physical drive nmuber to identify the drive */ \tconst BYTE *buff,\t/* Data to be written */ \tDWORD sector,\t\t/* Sector address in LBA */ \tUINT count\t\t\t/* Number of sectors to write */ ) { \tDRESULT res; \t//int result; \tswitch (pdrv) { \tcase SD_CARD : \t\treturn res; \tcase SPI_FLASH : \t\t//写入 \t\tSPI_FLASH_SectorErase(sector * 4096); \t\tSPI_FLASH_BufferWrite((BYTE *)buff,(sector * 4096), (count * 4096) ); \t\treturn res; \t} \treturn RES_PARERR; } ``` + disk_ioctl ![image 20230706155144274](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050201.png) > 通过命令获取信息, 实现杂项, 用来格式化 > + 写入 > > CTRL_SYNC: 用来确保信息已经写入(又换成的设备需要实现) > > + 格式化 > > GET_SECTOR_COUNT: 获取扇区的多少 > > GET_BLOCK_SIZE: 每次擦除的块的大小 > > + 扇区大小不一样 > > GET_SECTOR_SIZE: 扇区的多少 ```c DRESULT disk_ioctl ( \tBYTE pdrv,\t\t/* Physical drive nmuber (0..) */ \tBYTE cmd,\t\t/* Control code */ \tvoid *buff\t\t/* Buffer to send/receive control data */ ) { \tDRESULT res; \t//int result; \tswitch (pdrv) { \tcase SD_CARD : //预留SD卡 \t\treturn res; \tcase SPI_FLASH : \t\t//实现命令 \t\tswitch(cmd) \t\t{ \t\t\tcase GET_SECTOR_COUNT: \t\t\t\t//拥有的空间, 扇区个数 \t\t\t\t*(DWORD *)buff 2048; \t\t\t\tbreak; \t\t\tcase GET_SECTOR_SIZE: \t\t\t\t//返回扇区的大小 \t\t\t\t*(WORD *)buff 4096; \t\t\t\tbreak; \t\t\tcase GET_BLOCK_SIZE: \t\t\t\t//返回擦除扇区的最小个数 \t\t\t\t*(WORD *)buff 1; \t\t\t\tbreak;\t\t \t\t} \t\t//默认返回值是成功 \t\tres RES_OK; \t\treturn res; \t} \treturn RES_PARERR; } ``` ## 实际使用 + 添加头文件ff.h + 挂载文件系统, f_mount函数 ![image 20230706165257522](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050202.png) 初始化一个FATFS结构体, 占用内存比较大, 定义为全局变量 挂载 ```c #include \"stm32f10x.h\" #include \"bsp_led.h\" #include \"bsp_usart.h\" #include \"bsp_spi.h\" #include \"ff.h\" FATFS fsObject; int main() { \t//返回值 \tFRESULT res; \t \t//读取数据缓冲区 \tUSART_Config(); \tprintf(\"串口初始化完成\\n\"); \t//挂载文件系统,初始化Flash, 立即挂载 \tres f_mount(&fsObject, \"1:\", 1); \tprintf(\"res %d\", res); \t \t \twhile(1){ } } ``` > 这时候返回值为11, 原因是因为默认的设备数是1个 > > ```c > #define _VOLUMES\t1 > /* Number of volumes (logical drives) to be used. */ > ``` > 改过之后卡死了, 原因是溢出, 具体是扇区返回值和初始化的值不一样 > > ```c > #define\t_MIN_SS\t\t512 > #define\t_MAX_SS\t\t512 > /* These options configure the range of sector size to be supported. (512, 1024, > / 2048 or 4096) Always set both 512 for most systems, all type of memory cards and > / harddisk. But a larger value may be required for on board flash memory and some > / type of optical media. When _MAX_SS is larger than _MIN_SS, FatFs is configured > / to variable sector size and GET_SECTOR_SIZE command must be implemented to the > / disk_ioctl() function. */ > > ``` > > 最大值改为4096 > 之后返回13, 原因是没有文件系统 > > 使用函数f_mkfs > > ```c > #define\t_USE_MKFS\t\t0 > /* This option switches f_mkfs() function. (0:Disable or 1:Enable) */ > ``` > > 配置为1, 使能格式化 > 格式化之后需要重新挂载 > > ```c > \tif(res 13) > \t{ > \t\tf_mkfs(\"1:\", 0, 0); > \t\tres f_mount(NULL, \"1:\", 1); > \t\tres f_mount(&fsObject, \"1:\", 1); > \t} > ``` > > ```c #include \"stm32f10x.h\" #include \"bsp_led.h\" #include \"bsp_usart.h\" #include \"bsp_spi.h\" #include \"ff.h\" FATFS fsObject; FIL fp; UINT bw; unsigned char writeData[] \"焦浩洋测试文件\\n\"; unsigned char readData[1024]; int main() { \t//返回值 \tFRESULT res; \t \t//读取数据缓冲区 \tUSART_Config(); \tprintf(\"串口初始化完成\\n\"); \t//挂载文件系统,初始化Flash, 立即挂载 \tres f_mount(&fsObject, \"1:\", 1); \tprintf(\"res %d\\n\", res);\\ \t//没有操作系统进行创建 \tif(res 13) \t{ \t\tf_mkfs(\"1:\", 0, 0); \t\tres f_mount(NULL, \"1:\", 1); \t\tres f_mount(&fsObject, \"1:\", 1); \t\tprintf(\"格式化文件系统\\n\"); \t} \t \t//打开文件, 设置打开文件的模式 \tres f_open(&fp, \"1:jiao.txt\", FA_OPEN_ALWAYS FA_WRITE FA_READ); \tprintf(\"打开文件res %d\\n\", res); \tif(res FR_OK) \t{ \t\tres f_write(&fp, writeData, sizeof(writeData), &bw); \t\tprintf(\"写文件res %d, %d\\n\", res, bw); \t\tif(res FR_OK) \t\t{ //更改文件指针位置为开头 \t\t\tf_lseek(&fp, 0); \t\t\tres f_read(&fp, readData, f_size(&fp), &bw); \t\t\tif(res FR_OK) \t\t\t\tprintf(\"文件: %s\", readData); \t\t} \t\t \t} //关闭文件 \tf_close(&fp); \twhile(1){ \t}\t } ``` + 支持中文文件名 ```c #define _CODE_PAGE\t932 /* This option specifies the OEM code page to be used on the target system. / Incorrect setting of the code page can cause a file open failure. / ``` > 改为936 ```c #define\t_USE_LFN\t0 #define\t_MAX_LFN\t255 ``` > 第一个改成大于0的数字 > > 1: 文件名存储在全局变量 > > 2: 局部变量 > > 3: 堆区 ## 错误 在返回值的时候一定要返回规定值 ## 文件系统实际操作 f_getfree: 获取文件系统的剩余空间 f_read: 如果读取的数据少于要求的数字 > 文件比较小, 已经到了结尾 f_unlink: 删除文件 f_stat: 文件信息读取, 会储存长文件名 f_readdir: 获取目录文件信息, 再次调用获取下一个文件"},"/note/嵌入式/stm32/固件库/2024-1-11-42USB.html":{"title":"USB","content":" layout: post title: \"USB\" date: 2024 1 9 15:39:08 +0800 tags: stm32 # USB ## 简介 USB: Universal Serial Bus通用串行总线 提供适用于各种应用的传输协议, 向下兼容 ![image 20240111145643353](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111456450.png) > [Front Page USB IF](https://www.usb.org/) > > USB 3.2 Gen 1 USB3.0 > > USB 3.2 Gen 2 USB3.1 > > USB 3.2 Gen 2x2 USB3.2 ![image 20240111150041316](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111500383.png) ### 设备结构 ![image 20240111150716572](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111507643.png) ![](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111510058.png) ### 物理结构 ![image 20240111153012212](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111530291.png) ![image 20240111153215659](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111532735.png) > 由于驱动的开发很麻烦, 所以直接使用ST官方开发板的例程进行移植 ## STM32的USB特性 ![image 20240111153642549](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111536613.png) ![image 20240111153848312](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111538381.png) ![image 20240111154021524](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111540604.png) ![image 20240111154057883](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111540967.png) ### 开发板原理图 ![image 20240111154538884](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111545002.png) ![image 20240111154605105](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111546217.png) ![image 20240111154627476](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111546629.png) ![image 20240111154934187](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111549319.png) ### 驱动库 ![image 20240111155220314](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111552389.png) ![image 20240111155521008](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111555071.png) ### USB读卡器 ![image 20240111155640573](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111556679.png) ![image 20240111155757419](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111557506.png) > 主要就是官方开发板例程里面的这六个文件, 以及按照要使用的文件从USB驱动里面获取到要使用的模块的驱动和Croe的代码 ![image 20240111160457622](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111604707.png) ![image 20240111160604837](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111606908.png) ![image 20240111161619709](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111616784.png) ![image 20240111162131148](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111621208.png) ![image 20240111162142381](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401111621433.png)"},"/note/嵌入式/stm32/固件库/2023-6-19-1安装软件.html":{"title":"安装软件, 下载","content":" layout: post title: \"安装软件, 下载\" date: 2023 6 19 15:39:08 +0800 tags: stm32 # 安装软件, 下载 常用的开发软件有Keil和EWARM两个 使用的软件是keil5 MDK,必须使用**英文路径** 安装之后需要添加芯片包 在keil官网可以进行下载 [下载地址](https://www.keil.arm.com/packs/) 下载好之后直接双击进行安装 ![image 20230619183554558](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059343.png) 破解使用注册机 ## 下载器 仿真器, 下载之后进行硬件仿真 使用的规格是CMSIS DAP, 支持Cortex M内核单片机 支持WIN xp/WIN7/WIN10 支持SW在线调试 ![image 20230619195734029](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059344.png) 1和5不是必须的 ### 软件配置 ![image 20230619200241421](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059346.png) ![image 20230619200313991](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059347.png) ![image 20230619200350672](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059348.png) ![image 20230619200524024](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059349.png) ![image 20230619200614392](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059350.png) > HEX文件就是烧录文件, 传递给别人 ![image 20230619200709393](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059351.png) ## 串口下载 + 安装USB转串口下载 ISP: 在系统可编程, 电路板上可以编程写入程序, 不需要取下来, 编程的器件可以使用ISP方式擦除再编写, 通过Bootloader(自举程序)进行, 由厂家烧写, 程序选择串行外设, 对芯片进行编写, 最常用的是串口下载, 最主要的优点是成本低, 缺点是只能用于下载程序 普通ISP: 下载的时候手动设置BOOT启动方式 一键ISP: 下载的时候硬件上位机配合使用 ![image 20230619201953643](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059352.png) 第一种是仿真器, 第二种是串口, 默认是接GND, 但是可以达到一键ISP ![image 20230619202117656](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059353.png) 两边的电平不同, 需要芯片转换, 只有USART1才可以下载 ![image 20230619211505381](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059354.png) 在下载的时候只链接串口 > 上位机引脚配置和下面的分析相反, 原因是TTL电平和232电平, 1是低电平 ### 原理 + 电路图 ![image 20230619211748095](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059355.png) > 串口是PA9, PA10, 上位机控制DTR和RTS电位 ![image 20230619211918926](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059356.png) > 最重要的是BOOT的启动方式, 电路右侧是模拟开关, 在刚上电的时候电压不稳定, EN为使能引脚, 让不稳定的时候使能引脚为0 ![image 20230619212041075](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059357.png) > 正常情况通过两个10K电阻接地, 在拉高的时候连接一个1K电阻 ![image 20230619212331910](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059358.png) ![image 20230619212620098](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059359.png) 只需要改变BOOT1就可以了, RTS为低电位的时候下面的二极管导通, 之后应该进行复位(NRST设置为低电平), 默认复位引脚是高电位, 连接到RTS是低电位就可以进行复位, DTR高电位, 下载完成之后上位机控制RTS和DTR进行执行(编程后执行选项)"},"/note/嵌入式/stm32/固件库/2023-7-15-19ADC.html":{"title":"ADC","content":" layout: post title: \"ADC\" date: 2023 7 15 15:39:08 +0800 tags: stm32 # ADC ## 简介 Analog to Digital Converter模拟/数字转换器 ![image 20231228200121471](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312282001522.png) ![image 20231228200230557](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312282002598.png) ![image 20231228200313930](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312282003997.png) ![image 20231228201812373](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312282018436.png) > D/A会把数码寄存器里面的数字转换为对应的电压, 之后进行比较, 比较结果进行调整, 这个是STM32使用的模式 ### 参数 ![image 20231228202226037](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312282022091.png) ## STM32的ADC ![image 20231228202536592](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312282025640.png) > VREF+的电压要小于3.6V ### 工作原理F1 ![image 20230715103243971](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059569.png) ![image 20231228203339871](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312282033946.png) stm32f有三个ADC, 分辨率为12位, 每一个ADC有18个通道, 外部通道16个 ![image 20230715103708556](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059570.png) 1. 输入电压VREF < VIM< VREF+, 设置电压的引脚, 还有VDDA, 模拟电压的电源, VSSA模拟的地, 这里链接的是3.3V和地 ![image 20230715104441085](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059571.png) > 超出电压: 使用分压电路 > > ![image 20230715104658332](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059572.png) > > ![image 20230715104803913](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059573.png) 2. 确定输入通道 ![image 20230715105150119](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059574.png) > 使用的引脚有重复 ![image 20230715132058177](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059575.png) 3. 规则通道有16个, 注入通道只有4个 规则通道(常规转换组): 很规矩, 一般使用的 注入通道(注入转换组), 可以理解为插入, 是一种不安分的通道, 在规则通道转换的时候强行插入, 类似于中断, 有规则通道的时候才可以使用, 它是一种在规则通道转换的时候强 行插入要转换的一种通道。 > 如果在规则通道转换过程中，有注入通道插队，那么就要先转换完注 入通道，等注入通道转换完成后，再回到规则通道的转换流程。 ![image 20231228212152876](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312282121936.png) 3. 转换的顺序, 有专门的寄存器, SQR123, 四个位一个通道的转换顺序, 从SQR3优先级最高 ![image 20230715133122240](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059576.png) ![image 20231228212434770](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312282124838.png) 注入序列寄存器 ![image 20230715133429284](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059577.png) > 有1个的时候使用JSQ4, 两个的时候使用JSQ3, 4以此类推 4. 触发源, 开始转换的信号 有两种, 第一种外部事件触发, 触发又分为规则组和注入组 第二种ADON位触发转换(仅限于F1系列) ![image 20231228213001759](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312282130814.png) 软件触发ADC_CR2: ADON/SWST/ART/JSWSTART ![image 20230715134212636](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059578.png) > 开始的信号 ![image 20230715134226763](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059579.png) > 打开电源 + 外部事件触发 定时器ADC_CR2: EXTSEL[2:0] ![image 20230715134526971](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059580.png) ![image 20230715134634866](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059581.png) ![image 20230715134727079](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059582.png) 外部GPIO ![image 20230715143148416](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059583.png) ADC3控制的有一些不一样 5. 转换时间, 等于采样时间加上12.5个时钟, 时钟的频率最大是14M, PCLK2提供, 可以设置分频, RCC_CFGR的ADCCPRE位 采样时间, 需要一定的周期进行采样最小是1.5个周期, 通过设置SMPx[2:0]位进行设置 ![image 20231228213954949](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312282139007.png) 6. 数据寄存器 ![image 20231228215007690](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312282150747.png) ADC_DR: ![image 20230715144036095](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059584.png) 16位有效, 独立模式(只使用一个ADC)有效, ADR_CR2控制, 双ADC模式下使用上面的寄存器, 多通道的时候最好使用DMA, 只能使用DMA1, 2, DMA2没有DMA ![image 20230715144235478](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059585.png) ![image 20230715150256227](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059586.png) > 模式选择, 一般使用第一种 > > ![image 20230715150806464](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059587.png) ADC_JDRx, 有四个, 存放注入通道的数据 ![image 20230715144757588](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059588.png) 7. 中断 ![image 20231228215302606](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312282153664.png) EOC: 转换完成, 规则通道 JEOC: 注入通道转换结束 AWD: 模拟看门狗, 模拟量超过一个阈值, ADC_HTR, ADC_LTR 溢出中断, 在CPU读取的时候还没有转换完成或者丢失了的时候会进入溢出中断 ### 转换 输出的数据是12位 ![image 20231228215753401](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312282157476.png) > 在规则组使用连续转换的时候使用使用注入组需要把JAUTO > > ![image 20231228220159741](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312282201778.png) ![image 20231228220240713](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312282202772.png) ![image 20231228220407855](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312282204916.png) > 间断模式: 在转换的时候规则组不会一次性转换完 > > ![image 20231228220812457](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312282208493.png) ### 校准 在刚上电的时候需要进行一次校准ADC_CR2寄存器 ![image 20231228225135530](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312282251588.png) > 首先位0上电, 之后设置为3为1, 然后设置位2为1, 之后查询这一个位是否清零 ### 单通道过采样 有时候ADC的分辨率不够高 1. 提高芯片的等级, 使用H7 2. 购买专门的ADC芯片 3. 单通道过采样和求均值 ![image 20231229170938962](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312291709056.png) > 实际上还是在求平均值 + H7 内部集成了过采样器, 采样率在2x到1024x之间进行调整, 可以控制左移右移, 在初始化的时候结构体里面有一个专门设置过采样的部分 ## 内部温度传感器 ![image 20231229193811104](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312291938157.png) > 默认的时候适不使用的 > > 1. 上电 > 2. 进行采集电压, 通过数字量进行计算电压然后计算温度 ![image 20231229194023295](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312291940344.png) ![image 20231229195243316](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312291952361.png) ## 固件库使用 ```c typedef struct { uint32_t ADC_Mode; /*!< Configures the ADC to operate in independent or dual mode. This parameter can be a value of @ref ADC_mode 工作的模式*/ FunctionalState ADC_ScanConvMode; /*!< Specifies whether the conversion is performed in Scan (multichannels) or Single (one channel) mode. This parameter can be set to ENABLE or DISABLE 扫描模式, 多通道或者单通道*/ FunctionalState ADC_ContinuousConvMode; /*!< Specifies whether the conversion is performed in Continuous or Single mode. This parameter can be set to ENABLE or DISABLE. 单次转换或者多次转换*/ uint32_t ADC_ExternalTrigConv; /*!< Defines the external trigger used to start the analog to digital conversion of regular channels. This parameter can be a value of @ref ADC_external_trigger_sources_for_regular_channels_conversion 触发信号的选择*/ uint32_t ADC_DataAlign; /*!< Specifies whether the ADC data alignment is left or right. This parameter can be a value of @ref ADC_data_align 数据寄存器对齐方式的选择*/ uint8_t ADC_NbrOfChannel; /*!< Specifies the number of ADC channels that will be converted using the sequencer for regular channel group. This parameter must range from 1 to 16. 采集的通道数*/ }ADC_InitTypeDef; ``` ### 常用函数 ADC_Init(); RCC_ADCCLKConifg();控制时钟分频 ADC_RegularChannelConfig();选择通道时钟的时间, 优先级 ADC_Cmd(); ADC_SoftwareStartConvCmd();软件触发是否使能 ADC_ExternalTrigConcCmd();外部触发是否使能 ADC_DMACmd(); ## 实际使用 ![image 20230715160544028](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059589.png) + 初始化引脚 ```c static void ADCx_GPIO_Config(void) { \tGPIO_InitTypeDef GPIO_InitStructure; \t \t// 打开 ADC IO端口时钟 \tADC_GPIO_APBxClock_FUN ( ADC_GPIO_CLK, ENABLE ); \t \t// 配置 ADC IO 引脚模式 \t// 必须为模拟输入 \tGPIO_InitStructure.GPIO_Pin ADC_PIN; \tGPIO_InitStructure.GPIO_Mode GPIO_Mode_AIN; \t \t// 初始化 ADC IO \tGPIO_Init(ADC_PORT, &GPIO_InitStructure);\t\t\t\t } ``` + 初始化时钟以及结构体 + 配置时钟分频 + 配置通道 + 使能中断 + 使能ADC + 校准 ```c static void ADCx_Mode_Config(void) { \tADC_InitTypeDef ADC_InitStructure;\t \t// 打开ADC时钟 \tADC_APBxClock_FUN ( ADC_CLK, ENABLE ); \t \t// ADC 模式配置 \t// 只使用一个ADC，属于独立模式 \tADC_InitStructure.ADC_Mode ADC_Mode_Independent; \t \t// 禁止扫描模式，多通道才要，单通道不需要 \tADC_InitStructure.ADC_ScanConvMode DISABLE ; \t// 连续转换模式 \tADC_InitStructure.ADC_ContinuousConvMode ENABLE; \t// 不用外部触发转换，软件开启即可 \tADC_InitStructure.ADC_ExternalTrigConv ADC_ExternalTrigConv_None; \t// 转换结果右对齐 \tADC_InitStructure.ADC_DataAlign ADC_DataAlign_Right; \t \t// 转换通道1个 \tADC_InitStructure.ADC_NbrOfChannel 1;\t \t\t \t// 初始化ADC \tADC_Init(ADCx, &ADC_InitStructure); \t \t// 配置ADC时钟为PCLK2的8分频，即9MHz \tRCC_ADCCLKConfig(RCC_PCLK2_Div8); \t \t// 配置 ADC 通道转换顺序和采样时间 \tADC_RegularChannelConfig(ADCx, ADC_CHANNEL, 1, \t ADC_SampleTime_55Cycles5); \t \t// ADC 转换结束产生中断，在中断服务程序中读取转换值 \tADC_ITConfig(ADCx, ADC_IT_EOC, ENABLE); \t \t// 开启ADC ，并开始转换 \tADC_Cmd(ADCx, ENABLE); \t \t// 初始化ADC 校准寄存器 \tADC_ResetCalibration(ADCx); \t// 等待校准寄存器初始化完成 \twhile(ADC_GetResetCalibrationStatus(ADCx)); \t \t// ADC开始校准 \tADC_StartCalibration(ADCx); \t// 等待校准完成 \twhile(ADC_GetCalibrationStatus(ADCx)); \t \t// 由于没有采用外部触发，所以使用软件触发ADC转换 \tADC_SoftwareStartConvCmd(ADCx, ENABLE); } ``` ```c static void ADC_NVIC_Config(void) { NVIC_InitTypeDef NVIC_InitStructure; \t// 优先级分组 \tNVIC_PriorityGroupConfig(NVIC_PriorityGroup_1); // 配置中断优先级 NVIC_InitStructure.NVIC_IRQChannel ADC_IRQ; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority 1; NVIC_InitStructure.NVIC_IRQChannelSubPriority 1; NVIC_InitStructure.NVIC_IRQChannelCmd ENABLE; NVIC_Init(&NVIC_InitStructure); } ``` + 初始化中断函数 void ADC_IRQHandler() { \tif(ADC_GetITStatus(ADC_x, ADC_IT_EOC) SET) \t{ \t\tADC_ClearFlag(ADC_x, ADC_FLAG_EOC); \t\tADC_ConvertedValue ADC_GetConversionValue(ADC_x); \t\t \t} } ### DMA读取 ```c #if ADC_DMA_Enable static void ADCx_DMA_Config(void) { \tRCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE); \tDMA_InitTypeDef DMA_InitStructure; \tDMA_DeInit(ADC_DMA_CHANNEL); \t \tDMA_InitStructure.DMA_PeripheralBaseAddr ( uint32_t ) ( & ( ADC_x >DR ) ); \tDMA_InitStructure.DMA_MemoryBaseAddr (uint32_t)&ADC_ConvertedValue; \tDMA_InitStructure.DMA_DIR DMA_DIR_PeripheralSRC; \tDMA_InitStructure.DMA_BufferSize 1; \tDMA_InitStructure.DMA_PeripheralInc DMA_PeripheralInc_Disable; \tDMA_InitStructure.DMA_MemoryInc DMA_MemoryInc_Disable; \tDMA_InitStructure.DMA_PeripheralDataSize DMA_PeripheralDataSize_HalfWord; \tDMA_InitStructure.DMA_MemoryDataSize DMA_MemoryDataSize_HalfWord; \tDMA_InitStructure.DMA_Mode DMA_Mode_Circular;\t \tDMA_InitStructure.DMA_Priority DMA_Priority_High; \tDMA_InitStructure.DMA_M2M DMA_M2M_Disable; \tDMA_Init(ADC_DMA_CHANNEL, &DMA_InitStructure); \t \t// 使能 DMA 通道 \tDMA_Cmd(ADC_DMA_CHANNEL , ENABLE); } #endif ``` ```c void ADCx_Mode_Conifg() { \tADC_InitTypeDef ADC_InitStructure;\t \tADC_APBxClock_FUN(ADC_CLK, ENABLE); \t \tADC_InitStructure.ADC_Mode ADC_Mode_Independent; \tADC_InitStructure.ADC_ScanConvMode DISABLE;\t//使用一个通道 \tADC_InitStructure.ADC_NbrOfChannel 1; \tADC_InitStructure.ADC_ContinuousConvMode ENABLE; \tADC_InitStructure.ADC_ExternalTrigConv ADC_ExternalTrigConv_None; \tADC_InitStructure.ADC_DataAlign ADC_DataAlign_Right; \t \tADC_Init( ADC_x, &ADC_InitStructure); \t//配置时钟 \tRCC_ADCCLKConfig(RCC_PCLK2_Div8); \t \tADC_RegularChannelConfig(ADC_x, ADC_CHANNEL, 1, ADC_SampleTime_55Cycles5); #if ADC_DMA_Enable \tADC_DMACmd(ADC_x, ENABLE); #endif \t #if ITConfig_Enable\t \t//使能中断 \tADC_ITConfig(ADC_x ,ADC_IT_EOC, ENABLE); #endif \tADC_Cmd(ADC_x, ENABLE); \t//校准 \tADC_ResetCalibration(ADC_x); \t \twhile(ADC_GetCalibrationStatus(ADC_x)); \t// ADC开始校准 \tADC_StartCalibration(ADC_x); \t// 等待校准完成 \twhile(ADC_GetCalibrationStatus(ADC_x)); \t//使用软件触发 \tADC_SoftwareStartConvCmd(ADC_x, ENABLE); } #if ITConfig_Enable\t static void ADC_NVIC_Config(void) { NVIC_InitTypeDef NVIC_InitStructure; \t// 优先级分组 \tNVIC_PriorityGroupConfig(NVIC_PriorityGroup_1); // 配置中断优先级 NVIC_InitStructure.NVIC_IRQChannel ADC_IRQ; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority 1; NVIC_InitStructure.NVIC_IRQChannelSubPriority 1; NVIC_InitStructure.NVIC_IRQChannelCmd ENABLE; NVIC_Init(&NVIC_InitStructure); } #endif ``` ### 多通道 ![image 20230717102211056](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059590.png) ```c static void ADCx_DMA_Config(void) { \tRCC_AHBPeriphClockCmd(ADC_DMA_CLK, ENABLE); \tDMA_InitTypeDef DMA_InitStructure; \tDMA_DeInit(ADC_DMA_CHANNEL); #if\tMULTIPLE_CHANNEL \t//多通道 \tDMA_InitStructure.DMA_MemoryBaseAddr (uint32_t)ADC_ConvertedValue; \tDMA_InitStructure.DMA_BufferSize 6; \tDMA_InitStructure.DMA_MemoryInc DMA_MemoryInc_Enable; #else \t//普通 \tDMA_InitStructure.DMA_MemoryBaseAddr (uint32_t)&ADC_ConvertedValue; \tDMA_InitStructure.DMA_BufferSize 1; \tDMA_InitStructure.DMA_MemoryInc DMA_MemoryInc_Disable; #endif \t \t \tDMA_InitStructure.DMA_PeripheralBaseAddr ( uint32_t ) ( & ( ADC_x >DR ) ); \tDMA_InitStructure.DMA_DIR DMA_DIR_PeripheralSRC; \tDMA_InitStructure.DMA_PeripheralInc DMA_PeripheralInc_Disable; \tDMA_InitStructure.DMA_PeripheralDataSize DMA_PeripheralDataSize_HalfWord; \tDMA_InitStructure.DMA_MemoryDataSize DMA_MemoryDataSize_HalfWord; \tDMA_InitStructure.DMA_Mode DMA_Mode_Circular;\t \tDMA_InitStructure.DMA_Priority DMA_Priority_High; \tDMA_InitStructure.DMA_M2M DMA_M2M_Disable; \t\t \tDMA_Init(ADC_DMA_CHANNEL, &DMA_InitStructure); \t \t// 使能 DMA 通道 \tDMA_Cmd(ADC_DMA_CHANNEL , ENABLE); } void ADCx_Mode_Conifg() { \tADC_InitTypeDef ADC_InitStructure;\t \tADC_APBxClock_FUN(ADC_CLK, ENABLE); #if\tMULTIPLE_CHANNEL \tADC_InitStructure.ADC_ScanConvMode ENABLE;\t//使用多个个通道 \tADC_InitStructure.ADC_NbrOfChannel NOFCHANEL; #else \tADC_InitStructure.ADC_ScanConvMode DISABLE;\t//使用一个通道 \tADC_InitStructure.ADC_NbrOfChannel 1; #endif \t \tADC_InitStructure.ADC_Mode ADC_Mode_Independent; \tADC_InitStructure.ADC_ContinuousConvMode ENABLE; \tADC_InitStructure.ADC_ExternalTrigConv ADC_ExternalTrigConv_None; \tADC_InitStructure.ADC_DataAlign ADC_DataAlign_Right; \t \tADC_Init( ADC_x, &ADC_InitStructure); \t//配置时钟 \tRCC_ADCCLKConfig(RCC_PCLK2_Div8);\t \t #if\tMULTIPLE_CHANNEL \t// 配置ADC 通道的转换顺序和采样时间 \tADC_RegularChannelConfig(ADC_x, ADC_CHANNEL1, 1, ADC_SampleTime_55Cycles5); \tADC_RegularChannelConfig(ADC_x, ADC_CHANNEL2, 2, ADC_SampleTime_55Cycles5); \tADC_RegularChannelConfig(ADC_x, ADC_CHANNEL3, 3, ADC_SampleTime_55Cycles5); \tADC_RegularChannelConfig(ADC_x, ADC_CHANNEL4, 4, ADC_SampleTime_55Cycles5); \tADC_RegularChannelConfig(ADC_x, ADC_CHANNEL5, 5, ADC_SampleTime_55Cycles5); \tADC_RegularChannelConfig(ADC_x, ADC_CHANNEL6, 6, ADC_SampleTime_55Cycles5); #else \tADC_RegularChannelConfig(ADC_x, ADC_CHANNEL, 1, ADC_SampleTime_55Cycles5); #endif\t\t \t #if ADC_DMA_Enable \tADC_DMACmd(ADC_x, ENABLE); #endif \t #if ITConfig_Enable\t \t//使能中断 \tADC_ITConfig(ADC_x ,ADC_IT_EOC, ENABLE); #endif \tADC_Cmd(ADC_x, ENABLE); \t//校准 \tADC_ResetCalibration(ADC_x); \t \twhile(ADC_GetCalibrationStatus(ADC_x)); \t// ADC开始校准 \tADC_StartCalibration(ADC_x); \t// 等待校准完成 \twhile(ADC_GetCalibrationStatus(ADC_x)); \t//使用软件触发 \tADC_SoftwareStartConvCmd(ADC_x, ENABLE); } ``` ### 双重模式 由于ADC2, 没有DMA, 所以使用ADC1的DMA ```c #include \"bsp_adc.h\" //存放原始变量的地方 #if\tMULTIPLE_CHANNEL extern __IO uint16_t ADC_ConvertedValue[NOFCHANEL]; #elif DOUBLE_PATTERN extern __IO uint32_t ADC_ConvertedValue[NOFCHANEL]; #else extern __IO uint16_t ADC_ConvertedValue; #endif #if (ADC_DMA_EnableMULTIPLE_CHANNELDOUBLE_PATTERN) static void ADCx_DMA_Config(void) { \tRCC_AHBPeriphClockCmd(ADC_DMA_CLK, ENABLE); \tDMA_InitTypeDef DMA_InitStructure; \tDMA_DeInit(ADC_DMA_CHANNEL); #if\tMULTIPLE_CHANNEL \t//多通道 \tDMA_InitStructure.DMA_PeripheralBaseAddr ( uint32_t ) ( & ( ADC_x >DR ) ); \tDMA_InitStructure.DMA_MemoryBaseAddr (uint32_t)ADC_ConvertedValue; \tDMA_InitStructure.DMA_BufferSize NOFCHANEL; \tDMA_InitStructure.DMA_MemoryInc DMA_MemoryInc_Enable; \tDMA_InitStructure.DMA_MemoryDataSize DMA_MemoryDataSize_HalfWord; \tDMA_InitStructure.DMA_PeripheralDataSize DMA_PeripheralDataSize_HalfWord; #elif DOUBLE_PATTERN \tDMA_InitStructure.DMA_PeripheralBaseAddr ( uint32_t ) ( & ( ADCx_1 >DR ) ); \tDMA_InitStructure.DMA_MemoryBaseAddr (uint32_t)ADC_ConvertedValue; \tDMA_InitStructure.DMA_BufferSize NOFCHANEL; \tDMA_InitStructure.DMA_MemoryInc DMA_MemoryInc_Enable; \tDMA_InitStructure.DMA_MemoryDataSize DMA_MemoryDataSize_Word; \tDMA_InitStructure.DMA_PeripheralDataSize DMA_PeripheralDataSize_Word; #else \t//普通 \tDMA_InitStructure.DMA_PeripheralBaseAddr ( uint32_t ) ( & ( ADC_x >DR ) ); \tDMA_InitStructure.DMA_MemoryBaseAddr (uint32_t)&ADC_ConvertedValue; \tDMA_InitStructure.DMA_BufferSize 1; \tDMA_InitStructure.DMA_MemoryInc DMA_MemoryInc_Disable; \tDMA_InitStructure.DMA_MemoryDataSize DMA_MemoryDataSize_HalfWord; \tDMA_InitStructure.DMA_PeripheralDataSize DMA_PeripheralDataSize_HalfWord; #endif \t \tDMA_InitStructure.DMA_DIR DMA_DIR_PeripheralSRC; \tDMA_InitStructure.DMA_PeripheralInc DMA_PeripheralInc_Disable; \tDMA_InitStructure.DMA_Mode DMA_Mode_Circular;\t \tDMA_InitStructure.DMA_Priority DMA_Priority_High; \tDMA_InitStructure.DMA_M2M DMA_M2M_Disable; \t \t \tDMA_Init(ADC_DMA_CHANNEL, &DMA_InitStructure); \t \t// 使能 DMA 通道 \tDMA_Cmd(ADC_DMA_CHANNEL , ENABLE); } #endif static void ADCx_GPIO_Config(void) { \tGPIO_InitTypeDef GPIO_InitStructure; \t \t// 打开 ADC IO端口时钟 \tADC_GPIO_APBxClock_FUN ( ADC_GPIO_CLK, ENABLE ); \t \t// 配置 ADC IO 引脚模式 \t// 必须为模拟输入 #if MULTIPLE_CHANNEL\t \t\t// 配置 ADC IO 引脚模式 \tGPIO_InitStructure.GPIO_Pin \tADC_PIN1 \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tADC_PIN2 \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tADC_PIN3 \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tADC_PIN4 \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tADC_PIN5 \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tADC_PIN6; #elif DOUBLE_PATTERN \tGPIO_InitStructure.GPIO_Pin ADCx_2_PIN ADCx_1_PIN;\t #else \tGPIO_InitStructure.GPIO_Pin ADC_PIN; #endif\t \tGPIO_InitStructure.GPIO_Mode GPIO_Mode_AIN;\t \t// 初始化 ADC IO \tGPIO_Init(ADC_PORT, &GPIO_InitStructure); \t } void ADCx_Mode_Conifg() { \tADC_InitTypeDef ADC_InitStructure;\t /*****ADC时钟*****/ \tADC_APBxClock_FUN(ADC_CLK, ENABLE); #if DOUBLE_PATTERN \t//使用DMA2 \tADCx_2_APBxClock_FUN(ADCx_2_CLK, ENABLE); #endif\t #if\tMULTIPLE_CHANNEL \tADC_InitStructure.ADC_Mode ADC_Mode_Independent; \tADC_InitStructure.ADC_ScanConvMode ENABLE;\t//使用多个个通道 \tADC_InitStructure.ADC_NbrOfChannel NOFCHANEL; #elif DOUBLE_PATTERN \tADC_InitStructure.ADC_Mode ADC_Mode_RegSimult; \tADC_InitStructure.ADC_ScanConvMode ENABLE;\t//使用一个通道 \tADC_InitStructure.ADC_NbrOfChannel NOFCHANEL;\t #else \tADC_InitStructure.ADC_Mode ADC_Mode_Independent; \tADC_InitStructure.ADC_ScanConvMode DISABLE;\t//使用一个通道 \tADC_InitStructure.ADC_NbrOfChannel 1; #endif \t \tADC_InitStructure.ADC_ContinuousConvMode ENABLE; \tADC_InitStructure.ADC_ExternalTrigConv ADC_ExternalTrigConv_None; \tADC_InitStructure.ADC_DataAlign ADC_DataAlign_Right; \t \tADC_Init( ADC_x, &ADC_InitStructure); \t \t//配置时钟 \tRCC_ADCCLKConfig(RCC_PCLK2_Div8); #if DOUBLE_PATTERN \t//使用DMA2 \tADC_Init( ADCx_2, &ADC_InitStructure); \tRCC_ADCCLKConfig(RCC_PCLK2_Div8); #endif #if\tMULTIPLE_CHANNEL \t// 配置ADC 通道的转换顺序和采样时间 \tADC_RegularChannelConfig(ADC_x, ADC_CHANNEL1, 1, ADC_SampleTime_55Cycles5); \tADC_RegularChannelConfig(ADC_x, ADC_CHANNEL2, 2, ADC_SampleTime_55Cycles5); \tADC_RegularChannelConfig(ADC_x, ADC_CHANNEL3, 3, ADC_SampleTime_55Cycles5); \tADC_RegularChannelConfig(ADC_x, ADC_CHANNEL4, 4, ADC_SampleTime_55Cycles5); \tADC_RegularChannelConfig(ADC_x, ADC_CHANNEL5, 5, ADC_SampleTime_55Cycles5); \tADC_RegularChannelConfig(ADC_x, ADC_CHANNEL6, 6, ADC_SampleTime_55Cycles5); #elif DOUBLE_PATTERN \tADC_RegularChannelConfig(ADCx_1, ADCx_1_CHANNEL, 1, ADC_SampleTime_239Cycles5); \tADC_RegularChannelConfig(ADCx_2, ADCx_2_CHANNEL, 1, ADC_SampleTime_239Cycles5); #else \tADC_RegularChannelConfig(ADC_x, ADC_CHANNEL, 1, ADC_SampleTime_55Cycles5); #endif \t #if (ADC_DMA_Enable DOUBLE_PATTERN MULTIPLE_CHANNEL) \tADC_DMACmd(ADC_x, ENABLE); #endif \t #if ITConfig_Enable\t \t//使能中断 \tADC_ITConfig(ADC_x ,ADC_IT_EOC, ENABLE); #endif \tADC_Cmd(ADC_x, ENABLE); \t//校准 \tADC_ResetCalibration(ADC_x); \t \twhile(ADC_GetCalibrationStatus(ADC_x)); \t// ADC开始校准 \tADC_StartCalibration(ADC_x); \t// 等待校准完成 \twhile(ADC_GetCalibrationStatus(ADC_x)); \t//使用软件触发 #if DOUBLE_PATTERN \tADC_Cmd(ADCx_2, ENABLE); \t//校准 \tADC_ResetCalibration(ADCx_2); \t \twhile(ADC_GetCalibrationStatus(ADCx_2)); \t// ADC开始校准 \tADC_StartCalibration(ADCx_2); \t// 等待校准完成 \twhile(ADC_GetCalibrationStatus(ADCx_2)); \t/************* \t这里的信号顺序不能变 \t************/ //使能DMA2的外部触发 \tADC_ExternalTrigConvCmd(ADCx_2, ENABLE); #endif ADC_SoftwareStartConvCmd(ADC_x, ENABLE); } ``` ```c void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_ADC_ALL_PERIPH(ADCx)); assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState ! DISABLE) { /* Enable the selected ADC conversion on external event and start the selected ADC conversion */ ADCx >CR2 CR2_EXTTRIG_SWSTART_Set; } else { /* Disable the selected ADC conversion on external event and stop the selected ADC conversion */ ADCx >CR2 & CR2_EXTTRIG_SWSTART_Reset; } } ``` ```c void ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState) { /* Check the parameters */ assert_param(IS_ADC_ALL_PERIPH(ADCx)); assert_param(IS_FUNCTIONAL_STATE(NewState)); if (NewState ! DISABLE) { /* Enable the selected ADC conversion on external event */ ADCx >CR2 CR2_EXTTRIG_Set; } else { /* Disable the selected ADC conversion on external event */ ADCx >CR2 & CR2_EXTTRIG_Reset; } } ``` ### 问题 ```c \t/************* \t这里的信号顺序不能变 \t************/ //使能DMA2的外部触发 \tADC_ExternalTrigConvCmd(ADCx_2, ENABLE); #endif ADC_SoftwareStartConvCmd(ADC_x, ENABLE); ``` ## F4/F7/H7 ![image 20231228203527250](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312282035329.png) ![image 20231228203544981](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312282035063.png) ![image 20231228203735984](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312282037074.png) + 触发源 ![image 20231228213232118](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312282132176.png) ![image 20231228213437897](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312282134961.png) + 时钟 ![image 20231228214052630](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312282140695.png) ![image 20231228214124343](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312282141404.png) ![image 20231228214552775](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312282145835.png) ![image 20231228214612213](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312282146269.png) ![image 20231228214751466](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312282147541.png) + 中断 ![image 20231228215632159](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312282156221.png) ## 光敏二极管 ![image 20231229202609329](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312292026395.png) ![image 20231229202627592](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312292026638.png)"},"/note/嵌入式/stm32/固件库/2024-1-1-36QSPI.html":{"title":"QSPI","content":" layout: post title: \"QSPI\" date: 2023 12 29 15:39:08 +0800 tags: HAL库 stm32 # QSPI SPI: 标准SPI Dual SPi: 双线SPI Qual SPI: 四线SPI ![image 20240101171723383](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401011717466.png) ![image 20240101171848711](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401011718778.png) ![image 20240101172006463](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401011720519.png) > 间接模式: 就是之前使用的模式 > > 状态轮训模式: 读取状态, 在编程结束以后可以使用这一个 > > 内存映射: 直接使用指针进行操作 > > 优化操作: 加快速递, 单倍数据是单边沿检测, 双倍数据模式是双边沿检测 ![image 20240101175551216](C:/Users/jinhua/AppData/Roaming/Typora/typora user images/image 20240101175551216.png) ![image 20240103140812123](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401031408645.png) ## 模式 + 间接模式 相当于之前使用的普通模式 ![image 20240103141222725](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401031412800.png) + 内存映射 ![image 20240103141254519](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401031412581.png) > 在进行写入或者命令操作的时候需要退出这一个模式, 读取的时候可以直接读取内存 ```c static void norflash_ex_enter_mmap(void) { uint32_t tempreg 0; /* BY/W25QXX 写使能（0X06指令） */ while (QUADSPI >SR & (1 << 5)); /* 等待BUSY位清零 */ QUADSPI >CCR 0X00000106; /* 发送0X06指令，BY/W25QXX写使能 */ while ((QUADSPI >SR & (1 << 1)) 0); /* 等待指令发送完成 */ QUADSPI >FCR 1 << 1; if (qspi_wait_flag(1 << 5, 0, 0XFFFF) 0) /* 等待BUSY空闲 */ { tempreg 0XEB; /* INSTRUCTION[7:0] 0XEB,发送0XEB指令（Fast Read QUAD I/O） */ tempreg 1 << 8; /* IMODE[1:0] 1,单线传输指令 */ tempreg 3 << 10; /* ADDRESS[1:0] 3,四线传输地址 */ tempreg (uint32_t)g_norflash_addrw << 12; /* ADSIZE[1:0] 2,24/32位地址长度 */ tempreg 3 << 14; /* ABMODE[1:0] 3,四线传输交替字节 */ tempreg 0 << 16; /* ABSIZE[1:0] 0,8位交替字节(M0~M7) */ tempreg 4 << 18; /* DCYC[4:0] 4,4个dummy周期 */ tempreg 3 << 24; /* DMODE[1:0] 3,四线传输数据 */ tempreg 3 << 26; /* FMODE[1:0] 3,内存映射模式 */ QUADSPI >CCR tempreg; /* 设置CCR寄存器 */ } sys_intx_enable(); /* 开启中断 */ } ``` > 使能的方式 + 命令序列 ![image 20240103141601809](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401031416969.png) ![image 20240103141731802](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401031417885.png) ![image 20240103142028363](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401031420438.png) ![image 20240103142220120](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401031422189.png) ![image 20240103142402850](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401031424923.png) ## 寄存器 ![image 20240103142743819](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401031427894.png) ![image 20240103143127466](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401031431558.png) ![image 20240103143153137](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401031431216.png) ![image 20240103144517076](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401031445167.png) ![image 20240103144752028](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401031447104.png) ![image 20240103144911005](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401031449099.png) ![image 20240103144957975](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401031449049.png) ![image 20240103145111275](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401031451352.png) ![image 20240103145950945](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401031459054.png) ![image 20240103150045343](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401031500428.png)"},"/note/嵌入式/stm32/固件库/2023-6-30-10串口通讯.html":{"title":"串口通讯","content":" layout: post title: \"串口通讯\" date: 2023 6 30 15:39:08 +0800 tags: stm32 # 串口通讯 ## 通讯原理 + 传送方式: 并行串行 ![image 20230630185444953](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281051243.png) 串行: USART, I2C, SPI只有一两根数据线 并行: SDIO, FSMC ![image 20230630190029879](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281051244.png) + 通信的方向 全双工: 同时收发数据USART, SPI 半双工: 不可同时收发数据, 分时收发数据SPI 单工: 任何时候都是固定一个方向传输 + 同步方式 同步: 有时钟信号, 效率比较高, 对时钟允许误差比较小 异步: 没有时钟信号, 加上辅助标志符 + 速率 比特率bit/s, 每秒二进制数的位数 波特率: 每秒传输的码元个数 0V 3.3V一个二进制位为一个码元 用多种不同的电压代表不同的信息, 码元和位数就不同了 比特率 波特率*log<sub>2</sub> M, M表示每一个码元常在的信息量 ![image 20231128092521226](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311280925294.png) ## 串口 串行通信接口, 指的是按照位进行发送和接收的接口, 比如RS 232/422/485等, 232是标准的接口 RS 232接口(DB9): 简化以后的接口 ![image 20231128093037099](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311280930204.png) > 异步通讯的话只需要上面标红的三个引脚 ### 通信协议 #### 物理层 使用的RS232电平, 逻辑1 15V ~ 3V 逻辑0: +3V ~ +15V COMS电平: 逻辑1: 3.3V, 逻辑0: 0V TTL电平: 逻辑1: 5V, 逻辑0: 0V ![image 20230630195705940](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281051245.png) 3.3V的时候可以使用 MAX3232, 或者SP3232 5V的时候可以使用的转换芯片 MAX232 ![image 20230630200043103](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281051246.png) + TTL 芯片里面出来的都是TTL电平 + USB转串口 主要芯片有CH340, PL2303, CP2102, FT232 ![image 20231128093750475](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311280937556.png) #### 协议层 ![image 20230630200659430](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281051247.png) ![image 20231128093853663](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311280938711.png) > 起始位是一个逻辑0 > > 结束位是0.5、1、1.5或2个逻辑1表示 > > 有效数据: 经常被约定为5, 6, 7, 8, 9位长度, LSP在前面(低位在前), MSP在后 > > 校验位: > > + 奇校验, 加上校验位之后1的个数为奇数 > + 偶校验, 加上校验位之后1的个数为偶数 > + 无校验 > + 零校验 > + 一校验 ## STM的实现 USART: Universal syschronous asynchronous receive transmitter 通用数据同步异步收发器 UART: Universal asynchronous receive transmitter 通用数据异步收发器 这两种模式都可以与外部设备进行全双工异步通讯 可以配置使用DMA多缓冲器通信 有多个标志位的中断源 ![image 20230630201454008](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281051248.png) + H7 ![image 20231128100606231](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311281006292.png) > 主要是时钟, 有两个时钟域, 一个用于控制, 另一个用于实际的工作, 还多了一个FIFO ![image 20231128100904897](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311281009954.png) ### 实际使用 + 发送 UE, TE打开发送时钟和通道 数据放到TDR, 之后传到发送移位寄存器, 最后发送到TX 之后TXE位为1表示发送数据寄存器数据空了, 这时候不能写 之后TC寄存器表示发送移位寄存器空了 + 接收 首先使能寄存器, UE,RE 之后数据进来, 进入移位寄存器, 设置RXNE寄存器为1 可以从RDR读取 ![image 20230630201541935](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281051249.png) > 是使用有5根线 > > + TX: 数据发送 > + RX: 数据接收 > + SCLK: 时钟, 可选 > + nRTX: 请求发送, 可选, n >低电平有效, 硬件控制 > + nCTX: 允许发送 > + 其他引脚: 红外编码模块 ![image 20230701135847759](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281051250.png) > 注: 实际在使用的时候注意时钟 ### 寄存器 + USART_SR: 状态寄存器 ![image 20230701142540187](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281051251.png) ![image 20230701143758579](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281051252.png) > 主要使用到的是位5, 6 + USART_BRR: 波特比率寄存器, 设置分频因子 ![image 20230701151341333](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281051253.png) ![image 20230701151356780](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281051254.png) > fck是串口的时钟, 根据总线的不同变化, 串口1是PCLK2对应72MHz, 其他的对应的是32MHz > > 算出来的这一个值分为整数和小数部分, 分别保存在不同的位置 > > ![image 20231128101459759](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311281014787.png) > > ![image 20231128101611218](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311281016247.png) ![image 20230701151822599](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281051255.png) ![image 20231128102014721](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311281020753.png) > 加0.5是为了四舍五入 **统一的公式** 由于左移四位相当于乘了一个16, 所以可以和小数部分合起来 ![image 20231128193528619](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311281935684.png) + 其他的F4F7H7系列 ![image 20231128194031886](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311281940951.png) > OVER8这个位可以设置为1或者0, F1只有16位 > > ![image 20231128194424041](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311281944085.png) > > > 过采样是一种信号处理技术，其目的是提高采样率以增加信号分辨率并提高信噪比。在过采样的过程中，信号被多次采样，每次采样之间的间隔非常小。这样做是因为在采样率低的情况下，信号中的某些细节会被忽略，从而降低信号的精度。通过过采样，可以增加采样点的数量，使信号的细节更加清晰。同时，过采样还可以减少噪声对信号的影响，提高信号质量。 > > ![image 20231128194636264](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311281946311.png) > > > 使用16倍的时候没有区别, 使用8位的时候有一位不被使用 ![image 20231128194818412](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311281948479.png) > ![image 20231128195019450](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311281950494.png) > > 使用USART_CR1寄存器的位15设置使用几位过采样 ![image 20231128195131851](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311281951896.png) > ![image 20231128195223838](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311281952891.png) + USART_DR: 数据寄存器 包含了发送或接收的数据。由于它是由两个寄存器组成的，一个给发送用(TDR)，一个给接收 用(RDR)，该寄存器兼具读和写的功能。TDR寄存器提供了内部总线和输出移位寄存器之间的 并行接口(参见图248)。RDR寄存器提供了输入移位寄存器和内部总线之间的并行接口。 当使能校验位(USART_CR1中PCE位被置位)进行发送时，写到MSB的值(根据数据的长度不 同，MSB是第7位或者第8位)会被后来的校验位该取代。 当使能校验位进行接收时，读到的MSB位是接收到的校验位。 一个地址对应两个实际的物理地址,九位有效 + USART_CR1: 控制寄存器 ![image 20231128195848700](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311281958733.png) > M位(12): 控制数据的长度, 1: 一个起始位, 9个数据位, n个停止位, 0: 八个数据位 ![image 20230701142324741](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281051256.png) > 一般会禁止校验位 ![image 20230701142340297](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281051257.png) ![image 20230701142434024](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281051258.png) > 可以通过读取状态寄存器知道实际的问题 ![image 20230701142643055](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281051259.png) > 打开串口, 实际控制的是时钟 ![image 20230701142757448](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281051260.png) > 控制发送接收使能需要设置为1 ![image 20230701143557806](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281051261.png) > 其他各种中断, 一般会使能位5的中断(接收中断) + USART_CR2: 控制寄存器 ![image 20230701142246978](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281051262.png) + USART_CR3: 控制硬件 ![image 20231128200951893](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311282009923.png) + USART_GTPR: 保护时间, 预分频寄存器 ## 固件库实现 ```c typedef struct { uint32_t USART_BaudRate; /*!< This member configures the USART communication baud rate. 设置波特率 */ uint16_t USART_WordLength; /*!< Specifies the number of data bits transmitted or received in a frame. This parameter can be a value of @ref USART_Word_Length设置数据长度 */ uint16_t USART_StopBits; /*!< Specifies the number of stop bits transmitted. This parameter can be a value of @ref USART_Stop_Bits 设置停止位长度*/ uint16_t USART_Parity; /*!< Specifies the parity mode. This parameter can be a value of @ref USART_Parity @note When parity is enabled, the computed parity is inserted at the MSB position of the transmitted data (9th bit when the word length is set to 9 data bits; 8th bit when the word length is set to 8 data bits). 设置校验, 奇校验, 偶校验*/ uint16_t USART_Mode; /*!< Specifies wether the Receive or Transmit mode is enabled or disabled. This parameter can be a value of @ref USART_Mode 设置模式, 接收还是发送*/ uint16_t USART_HardwareFlowControl; /*!< Specifies wether the hardware flow control mode is enabled or disabled. This parameter can be a value of @ref USART_Hardware_Flow_Control 硬件流控制器, 是否使用后面的两根线 */ } USART_InitTypeDef; ``` ```c typedef struct { //设置时钟 uint16_t USART_Clock; /*!< Specifies whether the USART clock is enabled or disabled. This parameter can be a value of @ref USART_Clock 设置使能不使能*/ uint16_t USART_CPOL; /*!< Specifies the steady state value of the serial clock. This parameter can be a value of @ref USART_Clock_Polarity 极性, 空闲时候电平*/ uint16_t USART_CPHA; /*!< Specifies the clock transition on which the bit capture is made. This parameter can be a value of @ref USART_Clock_Phase 相位, 读取的边沿*/ \t\t\t\t\t\t//上面的两种相互组合有四种不同的效果 uint16_t USART_LastBit; /*!< Specifies whether the clock pulse corresponding to the last transmitted data bit (MSB) has to be output on the SCLK pin in synchronous mode. This parameter can be a value of @ref USART_Last_Bit 最后一位的时钟是否输出*/ } USART_ClockInitTypeDef; ``` ## 实际实现 ![image 20230701154521695](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281051263.png) 1. 初始化GPIO引脚, RX设置为浮空输入, TX设置为复用推挽输出 2. 之后初始化串口, 初始化之后使能 3. 初始化NVIC 4. 初始化中断, 如果读取寄存器不为空的时候就产生中断 5. 在传递的时候判断标志位, TXE是数据移入移位寄存器, TC是移位寄存器为空的时候 ```c void USART_Config(void) { \tGPIO_InitTypeDef GPIO_InitStructure; \tUSART_InitTypeDef USART_InitStructure; \t//初始化时钟 \tDEBUG_USART_GPIO_APBxClkCmd(DEBUG_USART_GPIO_CLK, ENABLE); \tDEBUG_USART_APBxClkCmd(DEBUG_USART_CLK, ENABLE); \t \t \t//设置GPIO \tGPIO_InitStructure.GPIO_Pin DEBUG_USART_TX_GPIO_PIN; \tGPIO_InitStructure.GPIO_Mode GPIO_Mode_AF_PP; \tGPIO_InitStructure.GPIO_Speed GPIO_Speed_10MHz; \t \tGPIO_Init(DEBUG_USART_TX_GPIO_PORT, &GPIO_InitStructure); \t \tGPIO_InitStructure.GPIO_Pin DEBUG_USART_RX_GPIO_PIN; \tGPIO_InitStructure.GPIO_Mode GPIO_Mode_IN_FLOATING; \tGPIO_Init(DEBUG_USART_RX_GPIO_PORT, &GPIO_InitStructure); \t \t//配置波特率 \tUSART_InitStructure.USART_BaudRate DEBUG_USART_BAUDRATE; \t//数据长度 \tUSART_InitStructure.USART_WordLength USART_WordLength_8b; \t//停止位 \tUSART_InitStructure.USART_StopBits USART_StopBits_1; \t//校验位 \tUSART_InitStructure.USART_Parity USART_Parity_No; \tUSART_InitStructure.USART_Mode USART_Mode_Rx USART_Mode_Tx; \tUSART_InitStructure.USART_HardwareFlowControl USART_HardwareFlowControl_None; \t//初始化串口 \tUSART_Init(DEBUG_USARTx, &USART_InitStructure); \t//初始化NVIC \tNVIC_Configuration(); \t//初始化中断,在接受的时候产生中断 \tUSART_ITConfig(DEBUG_USARTx, USART_IT_RXNE, ENABLE); \t//使能串口 \tUSART_Cmd(DEBUG_USARTx, ENABLE); \t } void Usart_SendByte(USART_TypeDef* pUSARTx, uint8_t data) { \t \tUSART_SendData(pUSARTx, data); \twhile(USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) RESET); } void Usart_sendHalfWord(USART_TypeDef* pUSARTx, uint16_t data) { \tuint8_t temp_h, temp_l; \ttemp_h (data & 0xff00)>>8; \ttemp_l data & 0xff; \tUSART_SendData(pUSARTx, temp_h); \twhile(USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) RESET); \tUSART_SendData(pUSARTx, temp_l); \twhile(USART_GetFlagStatus(pUSARTx, USART_FLAG_TXE) RESET); } void Usart_sendString(USART_TypeDef* pUSARTx, uint8_t* data, uint8_t num) { \tint i; \tfor(i 0 ; i<num ; i++) \t{ \t\tUsart_SendByte(pUSARTx, data[i]); \t} //这里设置为TC为发送完成的时候循环结束 while(USART_GetFlagStatus(pUSARTx, USART_FLAG_TC) RESET); } ``` > **注**: 不能在循环过程中判断USART_FLOG_TC, 因为在初始化的时候TC为1, 所以这时候不会进入循环, 直接发送第二字节的内容, 会覆盖第一字节导致出错 ### 初始化printf函数 重写fputc函数 ```c //重定义C库函数 int fputc(int ch, FILE *f) { \tUSART_SendData(DEBUG_USARTx, (uint8_t)ch); \twhile(USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_TXE) RESET); \treturn ch; } int fgetc(FILE *f) { \twhile (USART_GetFlagStatus(DEBUG_USARTx, USART_FLAG_RXNE) RESET); \treturn (int)USART_ReceiveData(DEBUG_USARTx); } ``` > 在使用后一个函数的时候最好不初始化中断, 或者重写中断函数, 否则会卡住 ## RS485 ![image 20240103214008958](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401032140073.png) ![image 20240103214408382](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401032144473.png) ![image 20240103214619337](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401032146425.png) ![image 20240103215319958](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401032153065.png) ![image 20240103215414833](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401032154928.png) > 在连接的时候A和A连接, B和B连接"},"/note/嵌入式/stm32/固件库/2023-12-18-31LTDC.html":{"title":"LTDC","content":" layout: post title: \"LTDC\" date: 2023 7 13 15:39:08 +0800 tags: stm32 # LTDC ## RGBLCD 用于控制RGB LCD + 一般的嵌入式图形系统包括(MCU屏) 微处理器: 根据程序输出需要显示的图形到帧缓冲器 帧缓冲器: 本质上是一个内存, 存储需要显示的图形数据, GRAM 显示控制器: 图形解析, 进行控制显示屏 显示屏: 进行图形的显示 > ILI9341包括的是帧缓冲器和显示控制器 + RGB屏幕 通过并行RGB信号加上控制信号直接控制屏幕 需要用到LTDC外设进行控制, 使用内存进行存储图形的数据 RGBLCD也就是TFTLCD, 引出来的接口是RGB接口 ![image 20231219200254828](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312192002880.png) ![image 20231219200440875](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312192004923.png) ![image 20231219201125092](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312192011159.png) ![image 20231219201228574](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312192012641.png) ![image 20231219201421984](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312192014059.png) ![image 20231219202109878](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312192021939.png) ### 正点原子的RGB屏幕模块 ![image 20231219202451974](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312192024115.png) ![image 20231219202503401](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312192025441.png) ## LTDC外设 F429/F750/F767/H643/H750里面都有LTDC外设 在F4中文手册的扩展章节的PDF里面 成本比较低, 可以驱动16位, 18位以及24位的显示模块, 分辨率是可以编程的, 宽度是4096, 高度是2048, 时钟最大是83MHz, 支持很多种颜色的格式, 支持的是RGB888, RGB565, ARGB8888, ARGB1555 不需要额外的应用层, 一个外设就可以实现数据的读取, RGB的输出和信号控制 还支持两层数据的数据混合, 混合以后输出的只有一层 ![image 20231219203412271](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312192034335.png) ![image 20231219203513633](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312192035691.png) > LTDC有两层, 每一层都可以启用以及禁止或者配置, 涂层的显示是固定的, 由下到上 AHB接口 >图形数据 >层FIFO >像素格式转换 >ARGB8888个数 >混合 >抖动(转换为要输出的颜色色深度) >LCD ![image 20231219204102035](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312192041076.png) ![image 20231219204303521](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312192043594.png) ![image 20231219204515920](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312192045976.png) ![image 20231219204730269](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312192047332.png) ### 寄存器 ![image 20231219205022395](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312192050460.png) #### 控制寄存器 ![image 20231219205108381](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312192051439.png) #### 时序 ![image 20231219205222892](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312192052949.png) ![image 20231219205242513](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312192052560.png) ![image 20231219205406130](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312192054181.png) ![image 20231219205441205](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312192054261.png) ![image 20231219205511363](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312192055417.png) #### 图层相关的寄存器 ![image 20231219205933611](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312192059672.png) ![image 20231219210126910](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312192101955.png) > 这个是不需要显示空间的 ![image 20231219210156504](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312192101559.png) ![image 20231219210227430](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312192102496.png) ![image 20231219210243322](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312192102385.png) ![image 20231219210448836](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312192104889.png) > 有两个 ![image 20231219210505119](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312192105180.png) ![image 20231219223915074](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312192239128.png) ![image 20231219224010301](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312192240348.png) > 使用恒定的Alpha的时候会使用这一个寄存器 ![image 20231219224242356](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312192242426.png) #### 时钟频率 ![image 20231219225155280](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312192251348.png) ![image 20231219225410928](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312192254988.png) ![image 20231219204730269](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312192254070.png)"},"/note/嵌入式/stm32/固件库/2023-6-22-5使用固件库.html":{"title":"使用固件库","content":" layout: post title: \"使用固件库\" date: 2023 6 22 15:39:08 +0800 tags: stm32 # 使用固件库 ## 相关文件 1. 初始化汇编文件, startup_stm32f10x_hg.h ![image 20230623143340685](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052977.png) 设置堆栈指针, 设置PC指针, 初始化中断向量表, 配置系统时钟, 调用C库函数_main最后进入C语言环境 2. 时钟配置文件 stm32f10x.c: 把外部时钟HSE经过PLL倍频设置为72MHz 3. 外射相关 stm32f10x.h实现了外射寄存器映射 stm32f10x_xx.c:外设的驱动库函数 stm32f10x_xx.h:外设的初始化结构体, 初始化结构体的成员参数列表, 驱动外设库函数声明 4. 内核相关 CMSIS Cortex 微控制器接口标准 core_cm3.h实现内核寄存器映射 core_cm3.c 控制NVIC(嵌套向量中断控制器), SysTick(系统滴答定时器) misc.h misc.c 5. 头文件配置文件 stm32f10x_config.h头文件的头文件 一般包含在stm32f10x.h的最后面 ![image 20230623171232169](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052978.png) 在编译器的宏里面进行定义 6. 存放中断服务的文件 stm32f10x_it.h stm32f10x_it.c 中断服务函数可以放在其他地方, 不一定放在这个文件 ## 文件夹分析 ![image 20230623163949164](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052979.png) 第一个是logo project是工程文件 第四个是评估板例程 + Project + + Template工程模板 + Example使用例程 + Libraries库文件 + + CMSIS: Cortex M处理器使用的硬件抽象层，它不依赖于任何特定的厂商。它提供了一个标准化的接口，用于访问Cortex M微控制器上的硬件外设和功能。 + + CM3 + + CoreSupport: 实现内核外设寄存器 + DeviceSupport/ST/STM32F10x: 实现相关寄存器映射 + + startup: 初始化文件 + Documentation: 相关的文档 + STM32F10x_StdPeriph_Driver标准库函数 + + inc外设相关的头文件 + src对应的c文件 ![image 20230623175852701](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052980.png) ## 移植 ![image 20230623180942600](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052981.png) ![image 20230623181644670](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052982.png) 创建文件夹, 之后在Project文件夹下面添加项目 ![image 20230623181746511](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052983.png) ![image 20230623181817522](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052984.png) 添加下面几个组 + 开始复制库文件 ![image 20230623184014166](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052985.png) 多余文件删除 ![image 20230623184248107](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052986.png) 剪切到根目录 ![image 20230623184325545](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052987.png) ![image 20230623184444662](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052988.png) 之后删除原来的文件夹, 核心文件相同 ![image 20230623184555310](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052989.png) 删除CM3, 把startup中不需要的文件删除, 其他复制到根目录下面 在User目录下面创建mian.c 这时候没有存放中断的文件stm32f10x_it.h以及stm32f10x_config.h 从例程中复制过来\\Project\\STM32F10x_StdPeriph_Template ![image 20230623185202171](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052990.png) + 回到工程目录 ![image 20230623190307667](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052991.png) 添加c文件 + 添加头文件 ![image 20230623190624143](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052992.png) ![image 20230623190813175](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052993.png) 启用头文件中宏定义 ![image 20230623191229622](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052994.png) ![image 20230623191253830](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052995.png) ![image 20230623191403670](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052996.png) ![image 20230623191455785](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052997.png) ![image 20230623192001833](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052998.png) 使用C语言的库"},"/note/嵌入式/stm32/固件库/2023-12-20-32DMA2D.html":{"title":"DMA2D","content":" layout: post title: \"DMA2D\" date: 2023 7 13 15:39:08 +0800 tags: stm32 # DMA2D 是一个专门用于图像处理的DMA外设 主要适用于数据的传输以及2D图形的加速 + DMA数据传输 从寄存器到存储器或者存储器到存储器 进行图像的填充(摄像头), 或者图像的复制 + 2D图形加速 支持硬件颜色格式转化和Alpha 转换支持YcbCr转RGB或RGB888转RGB565), 透明度混合 + 工作模式 寄存器到存储器: 可以实现快速的单色填充(清屏) 存储器到存储器: 快速地图形填充 存储器到存储器并进行像素格式的转换 存储器到存储器并支持颜色格式的转化以及透明度的混合 ![image 20231220224357184](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312202243259.png) ![image 20231220224412636](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312202244700.png) > 使用的时候不使用DMA2D, 因为进行的嵌套太多了, 而且有很多的检测, 使用寄存器的话比较快 ## 寄存器 ![image 20231220225148281](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312202251345.png) > 偏移就是在输出完一行以后需要跳过的像素的个数 ![image 20231220230300720](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312202303786.png) ![image 20231221194214610](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312211942708.png) ![image 20231221194331909](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312211943471.png) ![image 20231221194459125](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312211944185.png) ![image 20231221194603177](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312211946228.png) ![image 20231221194633928](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312211946980.png) ![image 20231221194751282](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312211947335.png) ![image 20231221194922591](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312211949647.png) ![image 20231221195226349](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312211952409.png) > 设置的是源数据的数据格式 ![image 20231221195309149](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312211953211.png)"},"/note/嵌入式/stm32/固件库/2024-1-10-41FPU.html":{"title":"FPU","content":" layout: post title: \"FPU\" date: 2024 1 9 15:39:08 +0800 tags: stm32 # FPU 浮点运算单元, 主要用于浮点数的运算 ![image 20240110201247077](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401102012153.png) ![image 20240110201307350](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401102013382.png) > M3内核, M4内核和M7内核 ![image 20240110201626161](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401102016357.png) ![image 20240110201718389](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401102017452.png) ![image 20240110201732043](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401102017091.png) ![image 20240110201826692](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401102018743.png) > 第一个宏会在硬件支持的时候HAL库设置为1, 第二个会在编辑器选项选择以后设置为1"},"/note/嵌入式/stm32/固件库/2024-1-7-38DCMI.html":{"title":"DCMI","content":" layout: post title: \"DCMI\" date: 2024 1 7 15:39:08 +0800 tags: stm32 # DCMI 用于摄像头的操控, 在F4/F7/H7里面才有 ![image 20240107121630909](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401071216975.png) ![image 20240107121804939](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401071218997.png) ![image 20240107122147245](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401071221320.png) ![image 20240107122403065](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401071224123.png) ## 寄存器 ![image 20240107123311754](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401071233802.png) ![image 20240107123440355](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401071234418.png)"},"/note/嵌入式/stm32/固件库/2023-7-3-12存储器(I2C).html":{"title":"存储器(I2C)","content":" layout: post title: \"存储器(I2C)\" date: 2023 7 3 15:39:08 +0800 tags: stm32 # 存储器 ## 常用的存储器 ![image 20230703121029277](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050603.png) 一般来说易失性存储器存储的速度比较快 ### RAM随机存储器 随机读取任意地址, 现在一般专用于半导体种类的易失存储器 + DRAM动态随机存储器 >硬盘, 动态的, stm32f10x不能使用, 因为没有刷新用的电路 ![image 20230703130722571](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050604.png) > 使用电容的电荷表示, 会有放电, 写入之后会掉电, 导致出错, 需要有一段时间就进行充电或者放电 > > 存储速度慢, 集成度高, 生产成本低, 需要刷新 由于通讯方式不同有进行分类 在时钟线上升沿或者下降沿判断数据有效, SDRAM上升沿的时候判断数据有效, DDRII上升沿下降沿都有效800MHz, DDRIII上升沿下降沿有效时钟频率1600MHz + SRAM静态随机存储器 >静态的 ![image 20230703130909927](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050605.png) > 实际上是一个锁存器, 会保持稳态 > > 存储速度块, 集成度较低, 生产成本较高, 不需要刷新 ### ROM MASK ROM: 只读, 不能写, 出厂的时候固化 OTPROM: 可以写一次, 写入之后不能修改 EPROM: 高电压擦除, 可以重复擦写, 需要专门装备 EEPROM: 低电压可以擦除, 方便实用, 一般来说储存的比较小, 成本比较高 ### FLASH NOR FLASH: 写入的速度比较低, 一般存储程序, 比较贵, 结构复杂, 随机储存, 但是支持XIP且坏块比较少, 地址线数据线分开, 支持代码的运行 NAND FLASH: **容量较大，改写速度快**等优点，适用于大量数据的存储，因而在业界得到了越来越广泛的应用，如嵌入式产品中包括数码相机、MP3随身听记忆卡、体积小巧的U盘等, 用来存储数据, 必须以块进行读写, 地址线数据线不分开 NOR Flash使用并行架构，允许在任意地址上进行随机访问，而NAND Flash使用串行架构，只能按页进行顺序访问。 可以使用FLASH制造SSD硬盘 FLASH在写入之前只能先进行擦除 ## I2C协议 同步串行半双工总线 ### 硬件 只需要两根线就可以实现, 在集成电路中广泛使用 ![image 20230703144229817](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050606.png) 支持多个设备连接, 多个设备公用的信号线 SCL: 串行时钟线 SDA: 串行数据线 寻址机制: 通过一个地址, 在设计硬件的时候就已经设置好了, 通过SDA线进行发送, 有七位或者是十位 有一个上拉电阻, 一般是4.7K 连接的数量受到最大电容400pF限制 当空闲的时候设备输出高阻态, GPIO的开漏模式, 总线不会受到影响, 多个主机使用的时候为防止冲突, 会使用仲裁大方式进行选择, 有三种传输模式, 标准模式100Kbit/s, 400kbit/s, 3.4Mbit/s ![image 20231230183211123](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312301832169.png) ### 软件 ![image 20230703151853082](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050607.png) > 首先传输起始信号 > 之后是从机地址 > R/W选择是读还是写 > 等待一个应答信号 > 传输数据 ![image 20230703152937099](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050608.png) 时钟信号和起始信号都是主机产生的 ![image 20230703153400857](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050609.png) 一般都是先写之后再进行读 ![image 20230703154942975](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050610.png) SCL高电平的时候SDA向低电平切换, 表示起始 ![image 20230703155359377](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050611.png) 实际的数据 > 一般在传输的时候把七位的传输地址加上一位的读或者写叫做读地址或者叫做写地址 ![image 20230703160005966](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050612.png) ## STM32实现I2C stm32硬件I2C在某些情况下会出现问题 支持主机和从机 ![image 20230703160704172](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050613.png) > ①通讯引脚, 还有一个引脚是为了兼容SMBus协议 > > ②时钟控制逻辑, SCL线的时钟信号, 根据寄存器CCR控制, 在快速模式下可以选择时钟的占空比, 外设时钟源为PCLK1 > > ③数据控制逻辑, 比较器用来比较自身的地址, PEC寄存器拿来数据校验, 很少使用 > > ④整体控制逻辑, ### 寄存器 + I2C_CR1: 控制寄存器1 ![image 20230703164137890](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050614.png) ![image 20230703164204590](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050615.png) ![image 20230703164250641](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050616.png) + I2C_CR2: 控制寄存器2 + I2C_OAR1: 自身地址寄存器 + ![image 20230703163805304](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050617.png) + ![image 20230703163820680](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050618.png) + I2C_OAR2: 自身地址寄存器2 + ![image 20230703163844358](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050619.png) + I2C_DR: 数据寄存器 ![image 20230703163630671](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050620.png) + I2C_SR1: 状态寄存器 ![image 20230703164349494](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050621.png) ![image 20230703164418079](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050622.png) ![image 20230703164437087](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050623.png) ![image 20230703170150275](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050625.png) ![image 20230703165943268](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050626.png) ![image 20230703165853464](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050627.png) + I2C_SR2: 状态寄存器2 ![image 20230703164527968](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050628.png) + I2C_CCR: 时钟控制寄存器 ![image 20230703162327864](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050629.png) ![image 20230703162340309](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050630.png) T~pclk~ 1/36M, 可以计算出实际的数值 ![image 20230703163436601](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050631.png) + I2C_TRISE: TRISE寄存器, TRISE代表“Timer Input Rise Time”。它是用于定时器输入信号上升时间的配置位或参数。 ### 手册中的过程 ![image 20230703165619192](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050632.png) > + EVx实际上是对应的状态寄存器变化 > > SB: 起始位发送完成 > > ADDR: 地址位发送完成 > > TxE: 数据寄存器为空 > > BTF: 数据字节发送完成(移位寄存器为空) ![image 20230703170605089](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050633.png) > RxNE: 接收的时候数据寄存器为非空 > 状态位需要清除 > **使用函数I2C_CheckEvent可以直接检查对应的事件, 这个函数自动清除事件** ### 库实现 ```c typedef struct { uint32_t I2C_ClockSpeed; /*!< Specifies the clock frequency. This parameter must be set to a value lower than 400kHz时钟频率 */ uint16_t I2C_Mode; /*!< Specifies the I2C mode. This parameter can be a value of @ref I2C_mode 设置使用I2C或者SMBus*/ uint16_t I2C_DutyCycle; /*!< Specifies the I2C fast mode duty cycle. This parameter can be a value of @ref I2C_duty_cycle_in_fast_mode 高速模式下时钟的比例*/ uint16_t I2C_OwnAddress1; /*!< Specifies the first device own address. This parameter can be a 7 bit or 10 bit address.自己的地址设置地址1 使用函数可以设置另一个地址*/ uint16_t I2C_Ack; /*!< Enables or disables the acknowledgement. This parameter can be a value of @ref I2C_acknowledgement是否使能应答 */ uint16_t I2C_AcknowledgedAddress; /*!< Specifies if 7 bit or 10 bit address is acknowledged. This parameter can be a value of @ref I2C_acknowledged_address 设置使用的地址*/ }I2C_InitTypeDef; ``` ## EEPROM(AT24C02) ![image 20231230193310425](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312301933471.png) > 32个页, 每一页8字节 ![image 20230703195745740](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050634.png) > 链接I2C的两个引脚, 256字节 > > WP: 写保护, 这里直接接地不使能 > > A0, A1, A2: 控制地址 > > ![image 20230703203428188](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050635.png) > > 在实际发送的时候输入的是八位写地址 ![image 20231230193407316](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312301934381.png) ![image 20231230194010095](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312301940130.png) 在实际使用的时候首先选定地址, 之后发送要保存的地址, 然后输入多个要保存的数据, 最多可以写入八个字节(一页) ![image 20230703205254462](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050636.png) 直接读取的时候返回当前地址 ![image 20230703205336481](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050637.png) 读的时候没有限制, 读到最后以后会返回开头 > 在写之后需要检测写完成 ```c #include \"bsp_i2c.h\" void I2C_Config(void) { \t \tGPIO_InitTypeDef GPIO_InitStructure; \t//初始化时钟 \tEEPROM_I2C_GPIO_APBxClkCmd(EEPROM_I2C_GPIO_CLK, ENABLE); \tEEPROM_I2Cx_APBxClkCmd(EEPROM_I2Cx_CLK, ENABLE); \t \t//设置GPIO, 均为推挽输出 \tGPIO_InitStructure.GPIO_Pin EEPROM_I2C_SCL_GPIO_PIN; \tGPIO_InitStructure.GPIO_Mode GPIO_Mode_AF_OD; \tGPIO_InitStructure.GPIO_Speed GPIO_Speed_10MHz; \tGPIO_Init(EEPROM_I2C_SCL_GPIO_PORT, &GPIO_InitStructure); \t \tGPIO_InitStructure.GPIO_Pin EEPROM_I2C_SDA_GPIO_PIN; \tGPIO_Init(EEPROM_I2C_SDA_PORT, &GPIO_InitStructure); \t\t \t \t//初始化I2C \tI2C_InitTypeDef I2C_InitStructure; \tI2C_InitStructure.I2C_ClockSpeed EEPROM_I2Cx_BAUDRATE;//时钟速率 \tI2C_InitStructure.I2C_Mode I2C_Mode_I2C;//使用的模式 \tI2C_InitStructure.I2C_DutyCycle I2C_DutyCycle_2;//时钟时间比率 \tI2C_InitStructure.I2C_OwnAddress1 EEPROM_I2Cx_ADDRESS;//自己的地址 \tI2C_InitStructure.I2C_Ack I2C_Ack_Enable;//使能应答 \tI2C_InitStructure.I2C_AcknowledgedAddress I2C_AcknowledgedAddress_7bit;//七位地址 \tI2C_Init(EEPROM_I2Cx, &I2C_InitStructure); \tI2C_Cmd(EEPROM_I2Cx, ENABLE); } void EEPROM_Byte_Write(uint8_t addr, uint8_t data) { \t//发送成功的函数 \tI2C_GenerateSTART(EEPROM_I2Cx, ENABLE); \twhile(I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_MODE_SELECT) ERROR); \t//发送成功 \t//发送地址 \tI2C_Send7bitAddress(EEPROM_I2Cx, EEPROM_ADDRESS_PERI, I2C_Direction_Transmitter); \twhile(I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) ERROR); \t//发送一个数据, 要操作的地址 \tI2C_SendData(EEPROM_I2Cx, addr); \twhile(I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTING) ERROR); \t//写入数据 \tI2C_SendData(EEPROM_I2Cx, data); \twhile(I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED) ERROR); \tI2C_GenerateSTOP(EEPROM_I2Cx, ENABLE); } void EEPROM_Write(uint8_t addr, uint8_t *data, uint8_t num) { \t//发送成功的函数 \tI2C_GenerateSTART(EEPROM_I2Cx, ENABLE); \twhile(I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_MODE_SELECT) ERROR); \t//发送成功 \t//发送地址 \tI2C_Send7bitAddress(EEPROM_I2Cx, EEPROM_ADDRESS_PERI, I2C_Direction_Transmitter); \twhile(I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) ERROR); \t//发送一个数据, 要操作的地址 \tI2C_SendData(EEPROM_I2Cx, addr); \twhile(I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTING) ERROR); \t//发送一个数据, 要操作的地址 \twhile(num) \t{ \t\t//写入数据 \t\tI2C_SendData(EEPROM_I2Cx, *data); \t\twhile(I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTED) ERROR); \t\tdata++; \t\tnum ;\t \t} \tI2C_GenerateSTOP(EEPROM_I2Cx, ENABLE); } //进行读取 void EEPROM_Read(uint8_t addr, uint8_t *data, uint8_t num) { \t//发送成功的函数 \tI2C_GenerateSTART(EEPROM_I2Cx, ENABLE); \twhile(I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_MODE_SELECT) ERROR); \t//发送成功 \t//发送地址, 这时候为读, 如果间隔较小会在这一步没有应答 \tI2C_Send7bitAddress(EEPROM_I2Cx, EEPROM_ADDRESS_PERI, I2C_Direction_Transmitter); \twhile(I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED) ERROR); \t//发送一个数据, 要操作的地址 \tI2C_SendData(EEPROM_I2Cx, addr); \twhile(I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_TRANSMITTING) ERROR); \t//第二次信号 \tI2C_GenerateSTART(EEPROM_I2Cx, ENABLE); \twhile(I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_MODE_SELECT) ERROR); \t//发送地址 \tI2C_Send7bitAddress(EEPROM_I2Cx, EEPROM_ADDRESS_PERI, I2C_Direction_Receiver); \twhile(I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED) ERROR); \t//开始接受, EV7被检查到, 有新的信息 \twhile(num) \t{ \t\tif(num 1) \t\t{ \t\t\t//最后一次时候设置为不响应 \t\t\tI2C_AcknowledgeConfig(EEPROM_I2Cx, DISABLE);\t \t\t} \t\t//检查接收到数据时候的信号 \t\twhile(I2C_CheckEvent(EEPROM_I2Cx, I2C_EVENT_MASTER_BYTE_RECEIVED) ERROR); \t\t*data I2C_ReceiveData(EEPROM_I2Cx); \t\tdata++; \t\tnum ; \t} \tI2C_GenerateSTOP(EEPROM_I2Cx, ENABLE); \t//恢复自动响应 \tI2C_AcknowledgeConfig(EEPROM_I2Cx, ENABLE);\t \t } void EEPROM_WaitForWrite(void) { \tdo{ \t\t//发送成功的函数 \t\tI2C_GenerateSTART(EEPROM_I2Cx, ENABLE); \t\twhile(I2C_GetFlagStatus(EEPROM_I2Cx, I2C_FLAG_SB) RESET); \t\tI2C_ClearFlag(EEPROM_I2Cx, I2C_FLAG_SB); \t\t//发送成功 \t\t//发送地址, 这时候为读, 如果间隔较小会在这一步没有应答 \t\tI2C_Send7bitAddress(EEPROM_I2Cx, EEPROM_ADDRESS_PERI, I2C_Direction_Transmitter); \t} \twhile(I2C_GetFlagStatus(EEPROM_I2Cx, I2C_FLAG_ADDR) RESET); \t//实现之后直接结束这一次 测试没有也行 \t//I2C_GenerateSTOP(EEPROM_I2Cx, ENABLE); } ``` ## 问题 首先是由于stm32硬件问题, 会导致数据线不释放, 所以下载其他程序之后重新上电可以解决 在进行页写入的时候最大值为8, 并且首地址为可以被8整除的数字 在写之后不能立刻进行读取 还可以在进去之前检测BUSY标志 ## 软件实现 ```c #ifndef _BSP_I2C_GPIO_H #define _BSP_I2C_GPIO_H #include <inttypes.h> #define EEPROM_I2C_WR\t0\t\t/* 写控制bit */ #define EEPROM_I2C_RD\t1\t\t/* 读控制bit */ /* 定义I2C总线连接的GPIO端口, 用户只需要修改下面4行代码即可任意改变SCL和SDA的引脚 */ #define EEPROM_GPIO_PORT_I2C\tGPIOB\t\t\t/* GPIO端口 */ #define EEPROM_RCC_I2C_PORT \tRCC_APB2Periph_GPIOB\t\t/* GPIO端口时钟 */ #define EEPROM_I2C_SCL_PIN\t\tGPIO_Pin_6\t\t\t/* 连接到SCL时钟线的GPIO */ #define EEPROM_I2C_SDA_PIN\t\tGPIO_Pin_7\t\t\t/* 连接到SDA数据线的GPIO */ /* 定义读写SCL和SDA的宏，已增加代码的可移植性和可阅读性 */ #if 0\t/* 条件编译： 1 选择GPIO的库函数实现IO读写 */ \t#define EEPROM_I2C_SCL_1() GPIO_SetBits(EEPROM_GPIO_PORT_I2C, EEPROM_I2C_SCL_PIN)\t\t/* SCL 1 */ \t#define EEPROM_I2C_SCL_0() GPIO_ResetBits(EEPROM_GPIO_PORT_I2C, EEPROM_I2C_SCL_PIN)\t\t/* SCL 0 */ \t \t#define EEPROM_I2C_SDA_1() GPIO_SetBits(EEPROM_GPIO_PORT_I2C, EEPROM_I2C_SDA_PIN)\t\t/* SDA 1 */ \t#define EEPROM_I2C_SDA_0() GPIO_ResetBits(EEPROM_GPIO_PORT_I2C, EEPROM_I2C_SDA_PIN)\t\t/* SDA 0 */ \t \t#define EEPROM_I2C_SDA_READ() GPIO_ReadInputDataBit(EEPROM_GPIO_PORT_I2C, EEPROM_I2C_SDA_PIN)\t/* 读SDA口线状态 */ #else\t/* 这个分支选择直接寄存器操作实现IO读写 */ /*　注意：如下写法，在IAR最高级别优化时，会被编译器错误优化 */ \t#define EEPROM_I2C_SCL_1() EEPROM_GPIO_PORT_I2C >BSRR EEPROM_I2C_SCL_PIN\t\t\t\t/* SCL 1 */ \t#define EEPROM_I2C_SCL_0() EEPROM_GPIO_PORT_I2C >BRR EEPROM_I2C_SCL_PIN\t\t\t\t/* SCL 0 */ \t \t#define EEPROM_I2C_SDA_1() EEPROM_GPIO_PORT_I2C >BSRR EEPROM_I2C_SDA_PIN\t\t\t\t/* SDA 1 */ \t#define EEPROM_I2C_SDA_0() EEPROM_GPIO_PORT_I2C >BRR EEPROM_I2C_SDA_PIN\t\t\t\t/* SDA 0 */ \t \t#define EEPROM_I2C_SDA_READ() ((EEPROM_GPIO_PORT_I2C >IDR & EEPROM_I2C_SDA_PIN) ! 0)\t/* 读SDA口线状态 */ #endif void i2c_Start(void); void i2c_Stop(void); void i2c_SendByte(uint8_t _ucByte); uint8_t i2c_ReadByte(void); uint8_t i2c_WaitAck(void); void i2c_Ack(void); void i2c_NAck(void); uint8_t i2c_CheckDevice(uint8_t _Address); #endif ``` ```c #include \"bsp_i2c_gpio.h\" #include \"stm32f10x.h\" static void i2c_CfgGpio(void); /* ********************************************************************************************************* *\t函 数 名: i2c_Delay *\t功能说明: I2C总线位延迟，最快400KHz *\t形 参：无 *\t返 回 值: 无 ********************************************************************************************************* */ static void i2c_Delay(void) { \tuint8_t i; \t/*　 \t \t下面的时间是通过逻辑分析仪测试得到的。 工作条件：CPU主频72MHz ，MDK编译环境，1级优化 \t\t循环次数为10时，SCL频率 205KHz \t\t循环次数为7时，SCL频率 347KHz， SCL高电平时间1.5us，SCL低电平时间2.87us \t \t循环次数为5时，SCL频率 421KHz， SCL高电平时间1.25us，SCL低电平时间2.375us \t*/ \tfor (i 0; i < 10; i++); } /* ********************************************************************************************************* *\t函 数 名: i2c_Start *\t功能说明: CPU发起I2C总线启动信号 *\t形 参：无 *\t返 回 值: 无 ********************************************************************************************************* */ void i2c_Start(void) { \t/* 当SCL高电平时，SDA出现一个下跳沿表示I2C总线启动信号 */ \tEEPROM_I2C_SDA_1(); \tEEPROM_I2C_SCL_1(); \ti2c_Delay(); \tEEPROM_I2C_SDA_0(); \ti2c_Delay(); \tEEPROM_I2C_SCL_0(); \ti2c_Delay(); } /* ********************************************************************************************************* *\t函 数 名: i2c_Stop *\t功能说明: CPU发起I2C总线停止信号 *\t形 参：无 *\t返 回 值: 无 ********************************************************************************************************* */ void i2c_Stop(void) { \t/* 当SCL高电平时，SDA出现一个上跳沿表示I2C总线停止信号 */ \tEEPROM_I2C_SDA_0(); \tEEPROM_I2C_SCL_1(); \ti2c_Delay(); \tEEPROM_I2C_SDA_1(); } /* ********************************************************************************************************* *\t函 数 名: i2c_SendByte *\t功能说明: CPU向I2C总线设备发送8bit数据 *\t形 参：_ucByte ： 等待发送的字节 *\t返 回 值: 无 ********************************************************************************************************* */ void i2c_SendByte(uint8_t _ucByte) { \tuint8_t i; \t/* 先发送字节的高位bit7 */ \tfor (i 0; i < 8; i++) \t{\t\t \t\tif (_ucByte & 0x80) \t\t{ \t\t\tEEPROM_I2C_SDA_1(); \t\t} \t\telse \t\t{ \t\t\tEEPROM_I2C_SDA_0(); \t\t} \t\ti2c_Delay(); \t\tEEPROM_I2C_SCL_1(); \t\ti2c_Delay();\t \t\tEEPROM_I2C_SCL_0(); \t\tif (i 7) \t\t{ \t\t\t EEPROM_I2C_SDA_1(); // 释放总线 \t\t} \t\t_ucByte << 1;\t/* 左移一个bit */ \t\ti2c_Delay(); \t} } /* ********************************************************************************************************* *\t函 数 名: i2c_ReadByte *\t功能说明: CPU从I2C总线设备读取8bit数据 *\t形 参：无 *\t返 回 值: 读到的数据 ********************************************************************************************************* */ uint8_t i2c_ReadByte(void) { \tuint8_t i; \tuint8_t value; \t/* 读到第1个bit为数据的bit7 */ \tvalue 0; \tfor (i 0; i < 8; i++) \t{ \t\tvalue << 1; \t\tEEPROM_I2C_SCL_1(); \t\ti2c_Delay(); \t\tif (EEPROM_I2C_SDA_READ()) \t\t{ \t\t\tvalue++; \t\t} \t\tEEPROM_I2C_SCL_0(); \t\ti2c_Delay(); \t} \treturn value; } /* ********************************************************************************************************* *\t函 数 名: i2c_WaitAck *\t功能说明: CPU产生一个时钟，并读取器件的ACK应答信号 *\t形 参：无 *\t返 回 值: 返回0表示正确应答，1表示无器件响应 ********************************************************************************************************* */ uint8_t i2c_WaitAck(void) { \tuint8_t re; \tEEPROM_I2C_SDA_1();\t/* CPU释放SDA总线 */ \ti2c_Delay(); \tEEPROM_I2C_SCL_1();\t/* CPU驱动SCL 1, 此时器件会返回ACK应答 */ \ti2c_Delay(); \tif (EEPROM_I2C_SDA_READ())\t/* CPU读取SDA口线状态 */ \t{ \t\tre 1; \t} \telse \t{ \t\tre 0; \t} \tEEPROM_I2C_SCL_0(); \ti2c_Delay(); \treturn re; } /* ********************************************************************************************************* *\t函 数 名: i2c_Ack *\t功能说明: CPU产生一个ACK信号 *\t形 参：无 *\t返 回 值: 无 ********************************************************************************************************* */ void i2c_Ack(void) { \tEEPROM_I2C_SDA_0();\t/* CPU驱动SDA 0 */ \ti2c_Delay(); \tEEPROM_I2C_SCL_1();\t/* CPU产生1个时钟 */ \ti2c_Delay(); \tEEPROM_I2C_SCL_0(); \ti2c_Delay(); \tEEPROM_I2C_SDA_1();\t/* CPU释放SDA总线 */ } /* ********************************************************************************************************* *\t函 数 名: i2c_NAck *\t功能说明: CPU产生1个NACK信号 *\t形 参：无 *\t返 回 值: 无 ********************************************************************************************************* */ void i2c_NAck(void) { \tEEPROM_I2C_SDA_1();\t/* CPU驱动SDA 1 */ \ti2c_Delay(); \tEEPROM_I2C_SCL_1();\t/* CPU产生1个时钟 */ \ti2c_Delay(); \tEEPROM_I2C_SCL_0(); \ti2c_Delay();\t } /* ********************************************************************************************************* *\t函 数 名: i2c_CfgGpio *\t功能说明: 配置I2C总线的GPIO，采用模拟IO的方式实现 *\t形 参：无 *\t返 回 值: 无 ********************************************************************************************************* */ static void i2c_CfgGpio(void) { \tGPIO_InitTypeDef GPIO_InitStructure; \tRCC_APB2PeriphClockCmd(EEPROM_RCC_I2C_PORT, ENABLE);\t/* 打开GPIO时钟 */ \tGPIO_InitStructure.GPIO_Pin EEPROM_I2C_SCL_PIN EEPROM_I2C_SDA_PIN; \tGPIO_InitStructure.GPIO_Speed GPIO_Speed_50MHz; \tGPIO_InitStructure.GPIO_Mode GPIO_Mode_Out_OD; \t/* 开漏输出 */ \tGPIO_Init(EEPROM_GPIO_PORT_I2C, &GPIO_InitStructure); \t/* 给一个停止信号, 复位I2C总线上的所有设备到待机模式 */ \ti2c_Stop(); } /* ********************************************************************************************************* *\t函 数 名: i2c_CheckDevice *\t功能说明: 检测I2C总线设备，CPU向发送设备地址，然后读取设备应答来判断该设备是否存在 *\t形 参：_Address：设备的I2C总线地址 *\t返 回 值: 返回值 0 表示正确， 返回1表示未探测到 ********************************************************************************************************* */ uint8_t i2c_CheckDevice(uint8_t _Address) { \tuint8_t ucAck; \ti2c_CfgGpio();\t\t/* 配置GPIO */ \t \ti2c_Start();\t\t/* 发送启动信号 */ \t/* 发送设备地址+读写控制bit（0 w， 1 r) bit7 先传 */ \ti2c_SendByte(_Address EEPROM_I2C_WR); \tucAck i2c_WaitAck();\t/* 检测设备的ACK应答 */ \ti2c_Stop();\t\t\t/* 发送停止信号 */ \treturn ucAck; } ```"},"/note/嵌入式/stm32/固件库/2023-7-9-16FSMC液晶屏8080时序.html":{"title":"液晶显示器(8080时序)","content":" layout: post title: \"液晶显示器(8080时序)\" date: 2023 7 9 15:39:08 +0800 tags: stm32 # 液晶显示器 LCD液晶显示器: 功耗比较小, 比较薄, 承载的信息比较多, 液晶是一种有机化合物, 液态, 但是分子排列非常的规律, 加电流会使电子偏移, 配合偏振片, 有控制光线透过率的功能, 配合彩色滤光片和电压可以改变每一颜色的光的透光量 ![image 20230709190937950](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049029.png) 缺点, 本身不发光, 光源经过一系列过滤之后损失比较高, 且显示的方向比较窄, 彩色转换得时候变化速率比较低, 分子转动需要一定时间 LED显示器: 单个像素点是三色LED组成, 灯的大小比较大, 像素的密度比较低, 显示的角度比较多, 单色的应用也比较广泛 OLED显示器: 不需要背光, 有机发光二极管, 像素的密度比较高, 有机二极管制成的显示屏, 对比度高, 可以显示黑色, 缺点是会烧屏以及价格昂贵, 还会有低频频闪, 比较贵寿命比较低 点阵显示屏: 大型广告牌, LED显示屏, 但是耗电比较高, 很贵体积大 断码屏: 数码管, 计算器, 遥控器, 成本低, 驱动简单, 稳定 ## 接口分类 MCU接口≤800*480, 有SRAM, 不需要频繁刷新 RGB接口≤1280*800, 不带SRAM需要实时刷新, 需要大内存, 驱动比较复杂 MIPI, 4K, 不带SRAM, 支持高分辨率, 省电大部分手机使用的接口 ## 参数 像素: 组成的最基本的单元 分辨率: 行像素x列像素 颜色深度: 每一个像素点可以显示的颜色的种类, 一般使用位作为单位, 255为24bit 显示器的尺寸 点距: 两个像素点之间的距离 电脑使用32位ARGB, A是透明度 ## 野火产品 由于stm32f1性能不足需要专门的控制芯片, 240x320 ### 没有控制芯片操控 ![image 20230709200748031](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049030.png) 表示一个二十四位的数据线, CLK是时钟线, HSYNC, VSYNC跳变表达传输完一行一列, DE有效的时候RDB数据有效 ![image 20230709201451303](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049031.png) ![image 20230709201654053](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049032.png) ### 操控芯片ILI9341 使用8080接口, 支持多种接口, 左上角的框, 现在提供的是MCU接口, 还可以使用SPI或者RGB接口,要看厂家的设计 ![image 20230710170810501](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049033.png) > 主要使用的是黄色区域的实际上使用的16位, 还有WDX, RDX读写使能引脚, D/CX引脚对应RS引脚, 还支持SPI通讯, 使用IM引脚进行控制, 但是在生产的时候已经固化 > > 红色的区域控制的是背光 ![image 20230710171350054](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049034.png) ![image 20230710171700805](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049035.png) ![image 20230710171740641](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049036.png) 红色的是数据线, 蓝色的是控制线 ![image 20230710171818940](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049037.png) > 采用的是异步通讯 > > 读数据的时候是为了获取屏幕的数据, 进行截屏等 ![image 20230710172630819](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049038.png) > 写的时序 ![image 20230710172938021](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049039.png) > 读 有设置位置的命令, 写数据的命令以及读取的命令 ![image 20230710182600064](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049040.png) ## FSMC Flexible Static Memory Controller 灵活的静态存储控制器 用于驱动SRAM, NOR FLASH, NAND FLASH以及PC卡之类的存储器 定义好FSMC以后直接访问一个地址就可以实现对于存储器的使用, 不需要操控时序 F1, F4大容量100引脚以上的才有这一个外设 F4/F7/H7系列的是FMC接口, 可以操控sdram ![image 20231212201646032](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312122016113.png) ![image 20231212201728207](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312122017276.png) ![image 20231212202146241](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312122021285.png) ![image 20231212202719121](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312122027185.png) ![image 20231212202847385](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312122028465.png) ![image 20231212203331373](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312122033461.png) ### 地址映射 ![image 20231212203735044](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312122037119.png) ![image 20231212204149249](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312122041316.png) ![image 20231213222117457](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312132221570.png) ### 寄存器 ![image 20231213222139140](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312132221190.png) ![image 20231213222322162](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312132223228.png) ![image 20231213222452217](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312132224288.png) ![image 20231213222540893](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312132225957.png) ![image 20231213223325165](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312132233220.png) ## FMC F4F7H7 简介: 灵活的存储控制器 用于驱动NOR/PSRAM, NAND/PC卡, 以及同步的DRAM(SDRAM/Mobile LPSDR SDRAM)等 之后亦就可以当做普通的内存进行使用了, 也可以用于模拟8080时序 ![image 20231214202038696](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312142020847.png) ![image 20231214202714360](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312142027429.png) ![image 20231214202752883](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312142027958.png) ![image 20231214203611448](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312142036520.png) ## 寄存器 ![image 20231214204141808](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312142041872.png) ![image 20231214204154996](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312142041068.png) ![image 20231214204211318](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312142042391.png) ## 实际操控 使用FSMC 这里使用的是模式B ![image 20230710194944584](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049041.png) CLK, NWAIT, NADV都不需要 ![image 20230710195244255](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049042.png) ![image 20230710195401204](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049043.png) ![image 20230710195544195](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049044.png) ![image 20230710200000856](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049045.png) 还需要考虑地址对其问题 由于NOR FLASH内部实际上是16位, 所以一个地址对应的是两个字节, 所以stm32进行了移位处理, 相当于addr<<1 ![image 20230710200857245](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049046.png) ## 实际使用 FSMC_NORSRAMTimingInitTypeDef: 使用的变量, FSMC_AddressSetupTime, FSMC_DataSetupTime, FSMC_AccessMode FSMC_NORSRAMTiniTypeDefe:FSMC_Bank,FSMC_MemoryType, FSMC_MemoryDataWidth, FSMC_WriteOperation, FSMC_ExtendedMode 这里使用的FOR FLASH的时序 ![image 20230710202255921](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049047.png) > 左侧是stm32引脚, 右侧是液晶屏, 使用A16控制是命令还是数据 > > PE1控制复位 > > BL: 背光引脚, 普通推挽输出, 通过三级管控制, 使用NE1进行片选 > > TP: 触摸屏相关引脚 ## 使用 初始化引脚, 初始化时序 使用命令0ch, 读取出像素点的状态, [0:2]为101为16bit, 为110是18bit, 没有初始化是18bit 2Ah: 有四个参数, 设置开始的列和结束的列, 设置x坐标 2bh: 设置他的纵坐标 ![image 20230712184233155](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049048.png) 2ch: 然后发送n个字节设置每一个像素的颜色 36h: 控制屏幕坐标的显示模式 ![image 20231211230222943](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312112302004.png) > 根据读取到的不同的ID进行不同的初始化 ![image 20231212191820453](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312121918794.png) ![image 20231212192120140](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312121921191.png) ![image 20231212192139990](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312121921053.png) ![image 20231212192844895](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312121928948.png) > 设置横坐标 ![image 20231212192909252](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312121929309.png) ![image 20231212192944263](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312121929324.png) ![image 20231212193246249](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312121932315.png) > r的左移右移为的是清空无关的位 ## 正点原子的OLED 0.96英寸, 高亮, 有升压电路, 分辨率是128*64, 使用SSD1306驱动IC(内部集成升压) 这个驱动芯片里面有多种的通信接口, 有8080, 4线SPI和IIC, 8位6800等接口, 通过BS1和BS2引脚进行选择 ![image 20231206085632845](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312060856928.png) ![image 20231206085901779](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312060859852.png) ![image 20231206090233702](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312060902770.png) ![image 20231206090337077](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312060903141.png) ![image 20231206090412327](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312060904391.png) ![image 20231206090545424](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312060905495.png) ### 驱动芯片 ![image 20231206090932378](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312060909445.png) ![image 20231206093124276](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312060931308.png) ![image 20231206093239558](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312060932622.png) ![image 20231206093407838](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312060934884.png)"},"/note/嵌入式/stm32/固件库/2023-12-5-29电容按键.html":{"title":"电容按键","content":" layout: post title: \"电容按键\" date: 2023 7 16 15:39:08 +0800 tags: stm32 # 电容按键 电容:容纳电荷的电容, 两个金属块之间有一层绝缘体就可以构成一个简单的电容 优势: 没有机械装置, 寿命比较长, 非接触感应, 面板不需要开孔, 简介美观, 防水性比较好 电容储能就是充放电 ![image 20231205192011322](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312051920521.png) 没有手指触摸的时候: 上电的时候, 电阻作用下, 电容进行充电, 直到电容充满电, 这时候有一个充电时间Tcs 当手指按下的时候, 电容会变大, 充电时间变长 实验的重点就是充电时间的变化, 也就是电平变化的时间, 可以使用时钟进行计算 ![image 20231205192459364](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312051924560.png) ![image 20231205192619613](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312051926691.png) ![image 20231205192630270](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312051926343.png) 时间和电容C之间的关系成正比, 电容越大, 充电的临界时间更长 ![image 20231205192908850](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312051929025.png) > 开机的时候测得的TCS值作为基准值 ## 检测 使用定时器的输入捕获功能 首先把TPAD引脚设置为低电平, 电容进行放电 之后吧TPAD设置为浮空输入, 电容开始充电 同时开启TPAD的输入捕获功能, 开始捕获高电平"},"/note/嵌入式/stm32/固件库/2023-6-20-3寄存器.html":{"title":"寄存器","content":" layout: post title: \"寄存器\" date: 2023 6 20 15:39:08 +0800 tags: stm32 # 寄存器 封装: 比较小的小圆圈 >正方向起始位置逆时针旋转, 没有的话正看丝印, 左上角开始 ![image 20230620172553098](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281058658.png) > 三条总线 ![image 20230620172926258](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281058659.png) ! > 黄色的是驱动单元, 右边的是ST公司设计的外设 ![image 20230620173058460](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281058660.png) > 程序在Flash, ICode总线进行取址, , DCode用来取变量存在SRAM中, 常量储存在FLASH中(const关键字), 数据可以被DMA和DCode访问, 需要总线矩阵进行仲裁 > > System总线主要用来读取寄存器 > > APB2是高速总线, APB1是低速总线 ## 内存 ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281058661.png) 32位可以访问4G的内存 分为8块 + 第0块存放Flash, 只用了512KB + 第1块存放SRAM, 只用了64KB + 第2块存放外设 + 第3, 4块存放FSMC + 第5块是FSMC的寄存器 + 第6块没用 + 第7块是内核使用的 ![image 20230620183927699](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281058662.png) 分配的过程叫做存储器映射 在编程的时候可以使用 ```c #define GPIO_ODR *(unsigned int*)(0x40010c0c) ``` > 给有特定功能的寄存器单元取一个别名, 别名就是寄存器单元 ## 实际的使用 ![image 20230620190102866](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281058663.png) ![image 20230620190431611](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281058664.png) ![image 20230620190545756](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281058665.png) ![image 20230620203524186](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281058666.png) ## 新建工程 ![image 20230620192318031](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281058667.png) ![image 20230620192607267](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281058668.png) ``` E:\\a学习\\1.stm\\A盘（资料盘）\\1 程序源码_教程文档\\1 [野火]《STM32库开发实战指南》(标准库源码)【优先学习】\\0.书籍源码\\0【固件库】STM32F10x_StdPeriph_Lib_V3.5.0\\【固件库】STM32F10x_StdPeriph_Lib_V3.5.0\\Libraries\\CMSIS\\CM3\\DeviceSupport\\ST\\STM32F10x\\startup\\arm\\startup_stm32f10x_hd.s ``` > 启动文件 ![image 20230620193536776](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281058669.png) > 设置字体 ![image 20230620195140805](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281058670.png) axf通过编译器下载 hex通过串口下载"},"/note/嵌入式/stm32/固件库/2023-7-3-13Flash(SPI).html":{"title":"Flash(SPI)","content":" layout: post title: \"Flash(SPI)\" date: 2023 7 3 15:39:08 +0800 tags: stm32 # Flash(SPI) Serial Peripheral Interface串行外设设备接口 是一种全双工的协议, 传输的速率比较较高 ![image 20230705092142745](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050224.png) SS(CS): 设备选择线, 片选信号, 每一个从机都有一根SS线, 低电平表示选中 SCK: 时钟, 用于信号的同步, STM32支持的最大频率为F~pclk~/2 MOSI: 主机输入, 从机发送 MISO: 主机发送, 从机接收 SPI1在APB2上面, SPI2/3在APB1上面 ![image 20230705092906490](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050225.png) > 高位字节先行 ![image 20230705093308220](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050226.png) > 时钟相位: 设备处于空闲状态的时候, SCK时钟线的电平状态, CPHA指数据采样的时刻, CPHA 0的时候会在奇数边沿采样, CPHA 1的时候会在偶数边沿采样 ![image 20230705094033124](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050227.png) > 常用的是模式0和3 > > ![image 20240101100448303](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401011004394.png) ## STM32的实现 SPI1最高36MHz, SPI2/3最高18MHz, 支持上面的四种模式, 数据可以是8位或16位, 也可以控制高位先行还是低位先行 还可以两根线传输同方向 SPI2/3可以作为I2S通讯, SPI3的引脚和下载器共用引脚 ![image 20230705094536352](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050228.png) ![image 20240101095846457](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401010958511.png) ![image 20240101095903088](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401010959135.png) ![image 20230705094925096](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050229.png) ![image 20240101100040941](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401011000997.png) ![image 20230705102243699](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050230.png) > TXE表示发送缓冲区为空, 可以写入 > > RXNE表示受到一个数据, 可以读取 > > 在接收的时候需要写入从而产生时钟 ### 寄存器 ![image 20240101100559293](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401011005354.png) + SPI_CR1: 控制寄存器 ![image 20230705101748310](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050231.png) ![image 20230705101843244](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050232.png) ![image 20240101101413740](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401011014775.png) ![image 20230705102036757](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050233.png) ![image 20230705101616487](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050234.png) + SPI_CR2: 控制寄存器 ![image 20230705100758700](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050235.png) + SPI_SR: 状态寄存器 ![image 20240101101615769](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401011016806.png) + SPI_DR: 数据寄存器 ![image 20230705100548326](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050236.png) + SPI_CRCPR: 包含CRC计算数值 + SPI_RXCRCR: SPI Rx CRC寄存器 CRC校验用于保证全双工通信的可靠性。数据发送和数据接收分别使用单独的CRC计算器。通 过对每一个接收位进行可编程的多项式运算来计算CRC。CRC的计算是在由SPI_CR1寄存器中 CPHA和CPOL位定义的采样时钟边沿进行的。 注意： 该SPI接口提供了两种CRC计算方法，取决于所选的发送和/或接收的数据帧格式：8位数据帧采 用CR8；16位数据帧采用CRC16 ### 标准库 ```c typedef struct { uint16_t SPI_Direction; /*!< Specifies the SPI unidirectional or bidirectional data mode. This parameter can be a value of @ref SPI_data_direction 控制使用的模式, 几根线以及传输方向*/ uint16_t SPI_Mode; /*!< Specifies the SPI operating mode. This parameter can be a value of @ref SPI_mode控制主机还是从机 */ uint16_t SPI_DataSize; /*!< Specifies the SPI data size. This parameter can be a value of @ref SPI_data_size 控制数据的位数*/ uint16_t SPI_CPOL; /*!< Specifies the serial clock steady state. This parameter can be a value of @ref SPI_Clock_Polarity 不用的时候时钟线的电平*/ uint16_t SPI_CPHA; /*!< Specifies the clock active edge for the bit capture. This parameter can be a value of @ref SPI_Clock_Phase 在第几个边沿进行采集*/ uint16_t SPI_NSS; /*!< Specifies whether the NSS signal is managed by hardware (NSS pin) or by software using the SSI bit. This parameter can be a value of @ref SPI_Slave_Select_management 软件还是硬件控制片选*/ uint16_t SPI_BaudRatePrescaler; /*!< Specifies the Baud Rate prescaler value which will be used to configure the transmit and receive SCK clock. This parameter can be a value of @ref SPI_BaudRate_Prescaler. @note The communication clock is derived from the master clock. The slave clock does not need to be set. 时钟 分频因子*/ uint16_t SPI_FirstBit; /*!< Specifies whether data transfers start from MSB or LSB bit. This parameter can be a value of @ref SPI_MSB_LSB_transmission MSB还是LSB先行*/ uint16_t SPI_CRCPolynomial; /*!< Specifies the polynomial used for the CRC calculation.CRC校验 */ }SPI_InitTypeDef; ``` ## FLashW25Q64 8M字节, nor flash ![image 20230705113847085](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050237.png) DO: MISO DI: MDIO /CS: 片选 /WP: 写保护 /HOLD: 暂停通讯 CLK: 时钟 Standard SPI instructions use the unidirectional DI (input) pin to serially write instructions, addresses or data to the device on the rising edge of the Serial Clock (CLK) input pin. Standard SPI also uses the unidirectional DO (output) to read data or status from the device on the falling edge CLK. (可以使用模式0或者模式3) ![image 20230705120249483](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050238.png) 分为127个块, 每个块64kb, 块又分为16个扇区, 每一个4kb, 在写入的数据之前需要进行擦除, 只能把为1的数据位改为0, 擦除的时候只能按照最小的单元进行, 在写入的时候没有限制, 为nor Flash, nand Flash需要以扇区进行写入 有一个状态寄存器, BUSY位为忙状态 ![image 20230705123108519](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050239.png) + 实际读写 ![image 20230705123255295](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050240.png) ![image 20230705173533798](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050241.png) > 带括号的为返回值 擦除, 0x20之后发送三字节的地址 写入, 0x02 ![image 20230705124123214](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050242.png) > 几个id可以读取, 用来验证是否连接成功 ![image 20230705124036127](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050243.png) ### 开发板情况 ![image 20230705135254082](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050244.png) > 指南者CS连接PC0 ## 实际实现 \\_\\_I, \\_\\_O, \\__IO: 控制编译器不会进行优化, 每次读取的时候都会从内存中获取数据 > 在写\\擦除之前需要进行写使能 ```c #ifndef __BSP_SPI_H__ #define __BSP_SPI_H__ #include \"stm32f10x.h\" #include <stdio.h> #define FLASH_SPIx SPI1 #define FLASH_SPIx_CLK RCC_APB2Periph_SPI1 #define FLASH_SPIx_APBxClkCmd RCC_APB2PeriphClockCmd #define FLASH_SPIx_BAUDRATE 400000 #define SPIT_PLAG_TIMEOUT\t\t\t\t((uint32_t)0x1000) // USART GPIO 引脚宏定义 #define FLASH_SPIx_GPIO_CLK (RCC_APB2Periph_GPIOC RCC_APB2Periph_GPIOA) #define FLASH_SPIx_GPIO_APBxClkCmd RCC_APB2PeriphClockCmd #define FLASH_SPIx_MISO_GPIO_PORT \tGPIOA #define FLASH_SPIx_MISO_GPIO_PIN \tGPIO_Pin_6 #define FLASH_SPIx_MOSI_GPIO_PORT \tGPIOA #define FLASH_SPIx_MOSI_GPIO_PIN \tGPIO_Pin_7 #define FLASH_SPIx_CLK_GPIO_PORT \tGPIOA #define FLASH_SPIx_CLK_GPIO_PIN \tGPIO_Pin_5 #define FLASH_SPIx_CS_GPIO_PORT \tGPIOC #define FLASH_SPIx_CS_GPIO_PIN \tGPIO_Pin_0 //控制CS引脚 #define FLASH_SPI_CS_HIGH\t\t\tGPIO_SetBits(FLASH_SPIx_CS_GPIO_PORT, FLASH_SPIx_CS_GPIO_PIN); #define FLASH_SPI_CS_LOW\t\t\tGPIO_ResetBits(FLASH_SPIx_CS_GPIO_PORT, FLASH_SPIx_CS_GPIO_PIN); /*信息输出*/ #define FLASH_DEBUG_ON 1 #define FLASH_INFO(fmt,arg...) printf(\"<< FLASH INFO >> \"fmt\"\\n\",##arg) #define FLASH_ERROR(fmt,arg...) printf(\"<< FLASH ERROR >> \"fmt\"\\n\",##arg) #define FLASH_DEBUG(fmt,arg...) do{\\ if(FLASH_DEBUG_ON)\\ printf(\"<< FLASH DEBUG >> [%d]\"fmt\"\\n\",__LINE__, ##arg);\\ }while(0) //无意义产生时钟数据 #define DUMMY\t\t\t\t\t\t\t\t0x00 \t\t\t\t\t\t\t\t\t\t //命令 #define READ_IEDEC_ID\t\t\t\t\t\t0x9f\t\t\t\t\t\t\t\t\t\t\t\t #define ERASE_SECTOR\t\t\t\t\t\t0x20\t\t\t\t\t\t\t\t\t\t\t\t #define READ_STATUS\t\t\t\t\t\t\t0x05\t\t\t\t\t\t\t\t\t\t #define READ_DATA\t\t\t\t\t\t\t0x03\t\t\t\t\t\t\t\t\t\t #define WRITE_ENABLE\t\t\t\t\t\t0x06 \t\t\t\t\t\t\t\t\t\t void Flash_SPI_Config(void); uint8_t Flash_SPI_Send_Receive_Byte(uint8_t data); uint8_t SPI_FLASH_Read_Byte(void); uint32_t SPI_Read_ID(void); void Flash_SPI_WatiFanish(void); void Flash_ERASE_SECTOR(uint32_t addr); void Flash_READ_SECTOR(uint32_t addr, uint8_t *buff, uint32_t numByteToRead); void SPI_Write_Enable(void); #endif ``` ```c #include \"bsp_spi.h\" static __IO uint32_t SPITimeOut SPIT_PLAG_TIMEOUT; static uint16_t SPI_TIMEOUT_UserCallback(uint8_t errorCode); //初始化SPI1的引脚 static void Flash_GPIO_Config(void) { \tGPIO_InitTypeDef GPIO_InitStructure; \t//初始化时钟 \tFLASH_SPIx_GPIO_APBxClkCmd(FLASH_SPIx_GPIO_CLK, ENABLE); \t \t//设置GPIO, CLK \tGPIO_InitStructure.GPIO_Pin FLASH_SPIx_CLK_GPIO_PIN; \tGPIO_InitStructure.GPIO_Mode GPIO_Mode_AF_PP; \tGPIO_InitStructure.GPIO_Speed GPIO_Speed_50MHz; \tGPIO_Init(FLASH_SPIx_CLK_GPIO_PORT, &GPIO_InitStructure); \t//MOSI \tGPIO_InitStructure.GPIO_Pin FLASH_SPIx_MOSI_GPIO_PIN; \tGPIO_Init(FLASH_SPIx_MOSI_GPIO_PORT, &GPIO_InitStructure); \t//MISO \tGPIO_InitStructure.GPIO_Mode GPIO_Mode_IN_FLOATING; \tGPIO_InitStructure.GPIO_Pin FLASH_SPIx_MISO_GPIO_PIN; \tGPIO_Init(FLASH_SPIx_MISO_GPIO_PORT, &GPIO_InitStructure); \t \t//CS \tGPIO_InitStructure.GPIO_Mode GPIO_Mode_Out_PP; \tGPIO_InitStructure.GPIO_Pin FLASH_SPIx_CS_GPIO_PIN; \tGPIO_Init(FLASH_SPIx_CS_GPIO_PORT, &GPIO_InitStructure); \tFLASH_SPI_CS_HIGH; } //初始化FLASH的SPI void Flash_SPI_Config(void) { \t//初始化引脚 \tFlash_GPIO_Config(); \t//初始化时钟 \tFLASH_SPIx_APBxClkCmd(FLASH_SPIx_CLK, ENABLE); \t//初始化结构体 \tSPI_InitTypeDef SPI_InitStructure; \tSPI_InitStructure.SPI_BaudRatePrescaler SPI_BaudRatePrescaler_2; \tSPI_InitStructure.SPI_CPHA SPI_CPHA_2Edge; \tSPI_InitStructure.SPI_CPOL SPI_CPOL_High;\t//使用模式3 \tSPI_InitStructure.SPI_CRCPolynomial 0;//不使用CRC校验 \tSPI_InitStructure.SPI_DataSize SPI_DataSize_8b; \tSPI_InitStructure.SPI_Direction SPI_Direction_2Lines_FullDuplex; \tSPI_InitStructure.SPI_FirstBit SPI_FirstBit_MSB;//大端先行 \tSPI_InitStructure.SPI_Mode SPI_Mode_Master; \tSPI_InitStructure.SPI_NSS SPI_NSS_Soft; \tSPI_Init(FLASH_SPIx, &SPI_InitStructure); \t//使能 \tSPI_Cmd(FLASH_SPIx, ENABLE); } //发送接收, 一个字节, 接收为返回值 uint8_t Flash_SPI_Send_Receive_Byte(uint8_t data) { \tSPITimeOut SPIT_PLAG_TIMEOUT; \t \t//读取寄存器是否为空 \twhile(SPI_I2S_GetFlagStatus(FLASH_SPIx, SPI_I2S_FLAG_TXE) RESET) \t{ \t\tif((SPITimeOut ) 0) \t\t\treturn SPI_TIMEOUT_UserCallback(0); \t} \t//缓冲区为空, 开始发送 \tSPI_I2S_SendData(FLASH_SPIx,data); \t//确认发送完成 \twhile(SPI_I2S_GetFlagStatus(FLASH_SPIx, SPI_I2S_FLAG_RXNE) RESET) \t{ \t\tif((SPITimeOut ) 0) \t\t\treturn SPI_TIMEOUT_UserCallback(1); \t} \treturn SPI_I2S_ReceiveData(FLASH_SPIx); } //读取一个字节, 作为返回值 uint8_t SPI_FLASH_Read_Byte() { \treturn Flash_SPI_Send_Receive_Byte(DUMMY); } void SPI_Write_Enable(void) { \tFLASH_SPI_CS_LOW \t \tFlash_SPI_Send_Receive_Byte(WRITE_ENABLE); \t \tFLASH_SPI_CS_HIGH } //读取ID uint32_t SPI_Read_ID(void) { \tuint32_t flash_id; \t//片选 \tFLASH_SPI_CS_LOW \tFlash_SPI_Send_Receive_Byte(READ_IEDEC_ID); \tflash_id SPI_FLASH_Read_Byte(); \tflash_id << 8; \tflash_id SPI_FLASH_Read_Byte(); \tflash_id << 8; \tflash_id SPI_FLASH_Read_Byte(); \t \tFLASH_SPI_CS_HIGH \treturn flash_id; } //等待操作完成, 通过判断Flash状态寄存器的状态完成 void Flash_SPI_WatiFanish(void) { \tSPITimeOut SPIT_PLAG_TIMEOUT; \tFLASH_SPI_CS_LOW \tuint8_t status 0; \tdo{ \t\tFlash_SPI_Send_Receive_Byte(READ_STATUS); \t\tstatus Flash_SPI_Send_Receive_Byte(DUMMY); \t\tSPITimeOut ; \t}while((status & 0x01 1) && SPITimeOut); \tif(SPITimeOut 0) \t{ \t\tSPI_TIMEOUT_UserCallback(2); \t} \t//取消片选 \tFLASH_SPI_CS_HIGH } //进行擦除4k void Flash_ERASE_SECTOR(uint32_t addr) { \tSPI_Write_Enable(); \tFlash_SPI_WatiFanish(); \t//片选 \tFLASH_SPI_CS_LOW \t//发送命令 \tFlash_SPI_Send_Receive_Byte(ERASE_SECTOR); \tFlash_SPI_Send_Receive_Byte((addr>>16)&0xff); \tFlash_SPI_Send_Receive_Byte((addr>>8)&0xff); \tFlash_SPI_Send_Receive_Byte((addr>>0)&0xff); \tFLASH_SPI_CS_HIGH } //读取的函数 void Flash_READ_SECTOR(uint32_t addr, uint8_t *buff, uint32_t numByteToRead) { \t//片选 \tFLASH_SPI_CS_LOW \t//发送命令 \tFlash_SPI_Send_Receive_Byte(READ_DATA); \t//发送地址 \tFlash_SPI_Send_Receive_Byte((addr>>16)&0xff); \tFlash_SPI_Send_Receive_Byte((addr>>8)&0xff); \tFlash_SPI_Send_Receive_Byte(addr&0xff); \t//进行读取 \t \twhile(numByteToRead ) \t{ \t\t*buff SPI_FLASH_Read_Byte(); \t\tbuff++; \t} \tFLASH_SPI_CS_HIGH } //写入的时候最大为256, 且需要对齐 void Flash_Write_Sector(uint32_t addr, uint8_t *buff, uint32_t numByteToWrite){ \t//写使能 \tSPI_Write_Enable(); \t//片选 \tFLASH_SPI_CS_LOW \t//发送命令 \tFlash_SPI_Send_Receive_Byte(WRITE_DATA); \t//发送地址 \tFlash_SPI_Send_Receive_Byte((addr>>16)&0xff); \tFlash_SPI_Send_Receive_Byte((addr>>8)&0xff); \tFlash_SPI_Send_Receive_Byte(addr&0xff); \t//进行读取 \twhile(numByteToWrite ) \t{ \t\tFlash_SPI_Send_Receive_Byte(*buff); \t\tbuff++; \t} \tFLASH_SPI_CS_HIGH \t \tFlash_SPI_WatiFanish(); } /** * @brief 等待超时回调函数 * @param None. * @retval None. */ static uint16_t SPI_TIMEOUT_UserCallback(uint8_t errorCode) { /* 等待超时后的处理,输出错误信息 */ FLASH_ERROR(\"SPI 等待超时!errorCode %d\",errorCode); return 0; } ``` ## 地址规划 ![image 20230705184906454](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281050245.png) ## NAND FLASH 使用FMC NAND FLASH接口进行驱动 是一种非易失性的存储器, 内部使用非线性宏单元模式, 为固态大容量内存提供了解决方案 存储的密度高, 速度快, 功耗低, 寿命长, 价格比较低 ### MT29F4G08/H27U4G8 板载的是512M的 SD卡, U盘, 固态硬盘使用的都是这一种, 但是坏块的问题, 还有EMMC这个有一个控制芯片解决坏块 #### 存储 ![image 20231216150602797](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312161506928.png) ![image 20231216151703437](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312161517544.png) ![image 20231216152140631](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312161521739.png) 他的地址分为三类, 块地址, 页地址, 和列地址 这三个地址通过5个周期进行发送, 首先发送列地址, 之后是页地址和块地址 ![image 20231216152516784](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312161525887.png) > 通常情况下会把块和页地址看为同一个地址, 理解为page的地址 ![image 20231216155152552](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312161551647.png) #### 命令 ![image 20231216155850179](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312161558290.png) > 最后一个只能在同一个plane里面操作 ![image 20231216160138490](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312161601593.png) > 出了查手册看时间,也可以通过检查忙引脚的状态 ![image 20231216160625888](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312161606000.png) ![image 20231216160902490](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312161609589.png) ![image 20231216161757651](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312161617768.png) ![image 20231216161929595](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312161619705.png) #### 管理的难点 + 坏块的解决 ![image 20231216162536458](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312161625568.png) ![image 20231216162851414](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312161628519.png) ![image 20231216163433357](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312161634469.png) ![image 20231216163454565](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312161634670.png) ![image 20231216163914441](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312161639543.png) ![image 20231216164152745](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312161641854.png) ![image 20231216165323211](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312161653309.png) ![image 20231216165509060](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312161655171.png) ### 接口(FMC) FMC主要就是把读写的操作变成满足外部存储器的时序 ![image 20231218194616930](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312181946000.png) 主要就是配置FMC的时序寄存器 ![image 20231218195053449](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312181950508.png) ![image 20231218195154665](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312181951732.png) ![image 20231218200002649](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312182000709.png) ![image 20231218200019289](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312182000349.png) ![image 20231218200309317](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312182003383.png) #### 寄存器 ![image 20231218200556781](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312182005824.png) ![image 20231218200925469](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312182009540.png) ![image 20231218201018549](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312182010609.png) ![image 20231218201042524](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312182010581.png) ![image 20231218201057704](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312182010748.png)"},"/note/嵌入式/stm32/固件库/2023-7-25-22电源管理.html":{"title":"电源管理","content":" layout: post title: \"电源管理\" date: 2023 7 25 15:39:08 +0800 tags: stm32 # 电源管理 ![image 20231225230337003](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312252303072.png) ![image 20231225230519884](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312252305950.png) ## 电源监控器 stm32主要是从VDD获取电压, 电压监控器会对他进行监控, 电压低的时候会进行处理, 保证系统正常的运行 主要是VDD: 芯片供电引脚, VDDA: 模拟电源, VBAT: 电池电压 进行检测 POR/PDR监控器, PVD监控器, BOR监控器, AVD监控器, VBAT阈值, 温度阈值 + POR/PDR监控器: 上电复位以及掉电复位 检测到电压低于阈值VPOR以及VPDR的时候, stm32会自动复位, 防止由于电压不足导致严重的后果, 在电压开始低于VPOR的时候(1.92V)stm32会进入上电复位, 当VDD电压持续上升至大于VPOR的时候, 芯片开始运行, 当电压低于VPDR的时候(1.88V)进入掉电 ![image 20231227204310355](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312272043417.png) + 可编程电压监测器PVD 也是一直在检测VDD, 可以自己设置两个电压阈值, 在低于阈值的时候发生一个中断, 之后进入复位状态, 进行紧急处理, 发生的中断时EXTI16中断 ![image 20231227204505648](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312272045712.png) ![image 20231227204539444](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312272045497.png) ### 寄存器 ![image 20231227210015946](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312272100995.png) ![image 20231227210031133](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312272100186.png) ![image 20231227210129499](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312272101551.png) > 通过这一个位查询判断电压的情况 + BOR 欠压复位 + AVD: 监控VDDA + VBAT阈值: 检测VBAT电池电压 + 温度阈值: 检测结温 + stm32电源系统 V~REF~提供的是A/D转换器的电压, 这里可以提供一个比较稳定的电压 V~DD~, 除了后备之外的供电, 供电电压是1.8V, 内部会进行降压 V~BAT~, 电路板上面的电池, 可以由V~DD~选择是否供电, V~DD~断电之后会使用V~BAT~供电给实时时钟 ## stm32的功耗模式 低功耗为的是降低集成电路的功能消耗, 对于电池供电的产品更加重要, 降低电池的体积, 延长电池的寿命, 更小的电磁干扰, 设计更简单(散热) ![image 20231225230835944](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312252308986.png) stm32具有运行,睡眠,停止,待机四种状态, 上电复位之后会进入运行状态, 内核不需要运行的时候可以选择使用后面的状态 ![image 20231225231538271](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312252315328.png) ![image 20231225231600649](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312252316696.png) ![image 20230725184046023](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046671.png) > 在停止之后需要重新设置时钟, 应为会默认使用HSI作为时钟 > > 待机模式相当于重启, 所以不需要 > > + 睡眠: 关闭内核时钟, 内核停止运行, 其他外设正常运行, CM3的核心外设正常运行, 进入有两种模式, WFI(wait for interrupt), WFE(wait for event) > > ![image 20231225230935432](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312252309505.png) > > ![image 20230725201944602](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046672.png) > > > 所有的事件都可以引起中断, 也可以设置为不引起中断 > > 可以设置直接进入中断或者是退出时进入中断, 设置的是SLEEPONEXIT 0就是立即睡眠, 在中断中需要退出时进入中断 > > + 停止模式 > > 外设停止工作, 但是1.8V工作区电源没有关闭, 保留内核的寄存器信息, 停止模式唤醒需要重新开启时钟, 从断电的地方开始执行函数, 进入停止之后所有的I/O处于停止前的状态 > > ![image 20231225231043807](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312252310881.png) > > ![image 20230726211026038](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046673.png) > > + 待机模式 > > 关闭所有的时钟, 不保存代码之前运行的信息, 有四种唤醒的方式, 唤醒可以通过KEY1唤醒, 所有的GPIO都处于高阻态 > > ![image 20231225231131814](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312252311883.png) > > ![image 20230726212205693](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046674.png) ### 寄存器 ![image 20231226203850631](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312262038691.png) ![image 20231226204022008](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312262040085.png) ![image 20231226204138873](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312262041941.png) ![image 20231226204313371](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312262043439.png) ![image 20231226204333687](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312262043789.png) ## 库函数 ```c void PWR_BackupAccessCmd(FunctionalState NewState); ``` > 有的RTC的寄存器需要先使能才可以访问 ```c void PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry); ``` > 停止 ```c void PWR_EnterSTANDBYMode(void); ``` > 待机 ```c void PWR_PVDLevelConfig(uint32_t PWR_PVDLevel); ``` > 设置可编程电源控制器 ```c void PWR_WakeUpPinCmd(FunctionalState NewState); ``` > 使能WAKEUP引脚 ```c #define __NOP __nop #define __WFI __wfi #define __WFE __wfe ``` > 这里是编译器指令 ```c void PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry) { uint32_t tmpreg 0; /* Check the parameters */ assert_param(IS_PWR_REGULATOR(PWR_Regulator)); assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry)); //设置寄存器的模式 /* Select the regulator state in STOP mode */ tmpreg PWR >CR; /* Clear PDDS and LPDS bits */ tmpreg & CR_DS_MASK; /* Set LPDS bit according to PWR_Regulator value */ tmpreg PWR_Regulator; /* Store the new value */ PWR >CR tmpreg; /* Set SLEEPDEEP bit of Cortex System Control Register */ SCB >SCR SCB_SCR_SLEEPDEEP; //设置唤醒的模式 /* Select STOP mode entry */ if(PWR_STOPEntry PWR_STOPEntry_WFI) { /* Request Wait For Interrupt */ __WFI(); } else { /* Request Wait For Event */ __WFE(); } //复位寄存器, 防止进入睡眠的时候进入待机 /* Reset SLEEPDEEP bit of Cortex System Control Register */ SCB >SCR & (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP); } ``` ```c void PWR_EnterSTANDBYMode(void) { /* Clear Wake up flag */ PWR >CR PWR_CR_CWUF; /* Select STANDBY mode */ PWR >CR PWR_CR_PDDS; /* Set SLEEPDEEP bit of Cortex System Control Register */ SCB >SCR SCB_SCR_SLEEPDEEP; /* This option is used to ensure that store operations are completed */ //等待所有的存储操作结束之后继续进行 #if defined ( __CC_ARM ) __force_stores(); #endif /* Request Wait For Interrupt */ __WFI(); } ``` > 调用之前需要调用函数 > > ```c > void PWR_WakeUpPinCmd(FunctionalState NewState) > { > /* Check the parameters */ > assert_param(IS_FUNCTIONAL_STATE(NewState)); > //设置这个引脚 > *(__IO uint32_t *) CSR_EWUP_BB (uint32_t)NewState; > } > ``` ## 实际使用 + 睡眠模式: 直接调动__WFI 在睡眠的时候不能进行下载以及调试 + 待机模式 调用`void PWR_EnterSTANDBYMode(void)` + 停止模式 `void PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)` ## 注意 待机模式必须开启PWR时钟 ## PVD ![image 20230727123248915](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046675.png) 输入的5V转换为3.3V, PVD实际上监控的是VDD引脚 ```c void PVD_Config(void) { NVIC_InitTypeDef NVIC_InitStructure; EXTI_InitTypeDef EXTI_InitStructure; /*使能 PWR 时钟 */ RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE); NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1); /* 使能 PVD 中断 */ NVIC_InitStructure.NVIC_IRQChannel PVD_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority 0; NVIC_InitStructure.NVIC_IRQChannelSubPriority 0; NVIC_InitStructure.NVIC_IRQChannelCmd ENABLE; NVIC_Init(&NVIC_InitStructure); /* 配置 EXTI16线(PVD 输出) 来产生上升下降沿中断*/ EXTI_ClearITPendingBit(EXTI_Line16); EXTI_InitStructure.EXTI_Line EXTI_Line16; EXTI_InitStructure.EXTI_Mode EXTI_Mode_Interrupt; EXTI_InitStructure.EXTI_Trigger EXTI_Trigger_Rising_Falling; EXTI_InitStructure.EXTI_LineCmd ENABLE; EXTI_Init(&EXTI_InitStructure); /* 配置PVD级别PWR_PVDLevel_2V6 (PVD检测电压的阈值为2.6V，VDD电压低于2.6V时产生PVD中断) */ \t/*具体级别根据自己的实际应用要求配置*/ PWR_PVDLevelConfig(PWR_PVDLevel_2V6); /* 使能PVD输出 */ PWR_PVDCmd(ENABLE); } ``` ```c void PVD_IRQHandler(void) { \t\t/*检测是否产生了PVD警告信号*/ \t\tif(PWR_GetFlagStatus (PWR_FLAG_PVDO) SET)\t\t\t \t\t{ \t\t\t/* 亮红灯，实际应用中应进入紧急状态处理 */ \t\t\tLED_RED; \t\t\t \t\t} /* 清除中断信号*/ EXTI_ClearITPendingBit(EXTI_Line16); } ``` ## H7 ![image 20231226214223358](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312262142446.png) ![image 20231227193039788](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312271930959.png) ![image 20231227193217348](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312271932425.png) ![image 20231227193424450](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312271934518.png) ![image 20231227193544240](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312271935304.png) ![image 20231227193705806](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312271937873.png) ![image 20231227193733880](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312271937943.png) ![image 20231227193837017](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312271938076.png) > 想要使用最大的主频需要进行切换电压等级 ![image 20231227193926249](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312271939327.png) ### 相关寄存器 ![image 20231227194034918](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312271940978.png) ![image 20231227194123386](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312271941438.png) ![image 20231227194209184](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312271942247.png) ![image 20231227194243601](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312271942671.png) ![image 20231227194328373](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312271943457.png) ![image 20231227194400514](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312271944581.png) ![image 20231227194433249](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312271944312.png) ![image 20231227194644794](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312271946872.png) > 首先在这个寄存器设置为VOS1 ![image 20231227194730360](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312271947431.png) > 在这里激活为VOS0 ![image 20231227194843450](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312271948498.png)"},"/note/嵌入式/stm32/固件库/2023-7-28-24读写内部Flash.html":{"title":"读写内部Flash","content":" layout: post title: \"读写内部Flash\" date: 2023 7 28 15:39:08 +0800 tags: stm32 # 读写内部Flash ![image 20240106155515167](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061555228.png) ![image 20240106160003826](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061600895.png) ## 内部Flash的结构 实际上就是一个内部存储器, 用于储存代码, 掉电不会丢失 下载过程: 读写内部flash的程序放在内存, 之后把程序写入flash Cortex M3使用ICode与Flash连接, 有三十二跟数据线与地址线, 所以读取比外部SPI FLASH速度快 同时可以进行上锁, 防止程序被抄袭 ![image 20230728223227078](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059548.png) > 系统存储区, 用户不可以访问, ISP支持, 以及芯片保护 > > 选项字节, 存储的是芯片保护以及电压操作, 待机/停机复位, 软件/硬件看门狗功能, 共16字节, 可以修改 + 主存储器 一般说的Flash实际上就是这一个位置, 一共有256页, 在写入之前按照页进行擦除, 设置擦除用到的位置 ![image 20230728223845130](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059549.png) ![image 20230728224013755](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059550.png) > 参考文件: STM32F10xxx闪存编程手册 ### 实际操作过程 ![image 20240106160244789](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061602839.png) + 写入 ![image 20240106161454026](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061614093.png) ![image 20240106161606246](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061616290.png) 1. 解锁, 为了防止误操作, 芯片复位之后会自动上锁, 这时候不允许设置FLASH的控制寄存器以及修改内容 解锁步骤: 向秘钥寄存器FLASH_KEYR写入KEY1 0x45670123 再向里面写入KEY2 0xCDEF89AB ![image 20230729113032490](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059551.png) ![image 20240106161145385](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061611408.png) > 通过CR寄存器的这一个位可以检查现在的状态 2. 擦除扇区, ![image 20240106161514924](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061615966.png) 检查FLSH_SR寄存器中的忙标志 ![image 20230729113621736](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059552.png) FLASH_CR寄存器的PER位置1 ![image 20230729113410995](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059553.png) 使用FLASH_AR寄存器选择要擦除的页 ![image 20230729113521923](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059554.png) FLASR_CR的STRT设置为1 ![image 20230729113658672](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059555.png) 等待BUSY位清零 3. 写入扇区 检查FLSH_SR寄存器中的忙标志 ![image 20230729113621736](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059552.png) FLASH_CR寄存器的PG位置1 ![image 20230729114330237](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059556.png) 向指定的位置写入数据, 每一次16位 等待操作完成 + 读取 ![image 20240106160627357](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061606420.png) > 设置等待周期是通过寄存器进行的, 设置好以后就可以直接使用指针进行读取 > > ![image 20240106160841661](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061608717.png) 没有读保护可以直接进行读取 > 由于FLASH本身存储有程序数据, 若不是有意的删除某段程序代码, 一般不修改程序的空间内容, 所以使用之前了解一下哪些空间被写入程序, 通过查询.map文件获取信息, 在Map of the image ![image 20230729132537851](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059557.png) > Load Regina LR ROM1以及Execution Region ER_IROM1分别是程序加载以及执行的空间 ### 实践 ```c \tuint32_t *p; \t//解锁 \tFLASH_Unlock(); \t//擦除第五页 \tFLASH_ErasePage(0x08000000 + 2*1024*5); \t//写入 \tFLASH_ProgramWord(0x08000000 + 2*1024*5, 0x12345678); \tprintf(\"已经写入完成\\r\\n\"); \tFLASH_Lock(); \t \tp (uint32_t*)(0x08000000 + 2*1024*5); \tprintf(\"读取的值是0x%x\\r\\n\", *p); ``` ## 设置读写保护以及解除 实际发布的产品芯片中包含了程序, 但是J Link等下载器可以获取, 所以有一个读写保护, 这样就会让程序非法读取 ### 选项字节以及读写保护 需要更改Flash的选项字节, stm32会根据他的内容进行写保护配置 ![image 20230729154939142](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059558.png) n > 取反, 就是前一列的取反 + RDP读保护 设置为0xA5的时候是没有写保护的, 不是这个的时候就会处于保护的状态 ![image 20230729155340372](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059559.png) + USER: 设置看门狗 + Datax: 这个地址留给用户使用 ![image 20230729155614243](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059560.png) + WRPx, 用于用于进行写保护 ![image 20230729155647635](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059561.png) > 这里的写保护是针对下载器以及仿真器, 或者是内部SRAM自举都不能对FLASH进行读写, 但是如果是从内部FLASH自举的时候就可以对Flash进行读 > > 设置成读保护之后前4K字节会加上写保护, 也就是说Flash内部也不能进行读写, 利用这个特性可以编写IAP代码, 更新FLASH中的程序, 原理是通过通讯接口接收将要更新的程序内容, 然后利用内部的FLASH擦写操作把内容烧写到内部的FLASH中, 实现程序的更新, 类似于ISP程序下载 > 写保护会导致所有的方式都无法对代码进行更改, 解除之后不会丢失 ### 解除保护 需要把RDP位重新设置为0xA5, 在解除保护之前芯片会擦除FLASH的所有的内容, 所有的代码丢失 ![image 20230729161117176](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059562.png) 解除写保护, 把对应的WRP设置为1 ### 选项字节修改 复位之后的状态是可读但是进行写保护的, 因此FLASH_CR寄存器访问限制, 想要修改需要对FLASH_OPTKEYR寄存器写入解锁编码, 由于需要访问FLASH_CR, 所以要先解锁 + 解除FLASH_CR寄存器 + 解除选项字节的访问权限, 向FLASH_OPTKEYR写入KEY1 0x45670123, 以及KEY2 0xCDEF89AB + 配置FLASH_CR的OPTPG位, 准备修改选项字节 + 使用指针修改 + 解除读保护之后确认FLASH的擦除操作完成 + 设置读保护以及解除需要给芯片重新上电, 配置选项字节生效, 写保护配置以及解除需要进行系统复位, 有专门的函数 ```c typedef struct { __IO uint16_t RDP; __IO uint16_t USER; __IO uint16_t Data0; __IO uint16_t Data1; __IO uint16_t WRP0; __IO uint16_t WRP1; __IO uint16_t WRP2; __IO uint16_t WRP3; } OB_TypeDef; #define OB ((OB_TypeDef *) OB_BASE) #define OB_BASE ((uint32_t)0x1FFFF800) /*!< Flash Option Bytes base address */ ``` > 在写入低字节高位设置为0的时候, stm32会自动进行设置高字节为补码 ```c FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState) { FLASH_Status status FLASH_COMPLETE; /* Check the parameters */ assert_param(IS_FUNCTIONAL_STATE(NewState)); status FLASH_WaitForLastOperation(EraseTimeout); if(status FLASH_COMPLETE) { /* Authorizes the small information block programming */ FLASH >OPTKEYR FLASH_KEY1; FLASH >OPTKEYR FLASH_KEY2; //恢复选项字节为出厂设置 FLASH >CR CR_OPTER_Set; FLASH >CR CR_STRT_Set; /* Wait for last operation to be completed */ status FLASH_WaitForLastOperation(EraseTimeout); if(status FLASH_COMPLETE) { /* if the erase operation is completed, disable the OPTER Bit */ FLASH >CR & CR_OPTER_Reset; /* Enable the Option Bytes Programming operation */ FLASH >CR CR_OPTPG_Set; if(NewState ! DISABLE) { //写入非0xA5的值设置为读保护 OB >RDP 0x00; } else { OB >RDP RDP_Key; } /* Wait for last operation to be completed 等待擦除完成*/ status FLASH_WaitForLastOperation(EraseTimeout); if(status ! FLASH_TIMEOUT) { /* if the program operation is completed, disable the OPTPG Bit */ FLASH >CR & CR_OPTPG_Reset; } } else { if(status ! FLASH_TIMEOUT) { /* Disable the OPTER Bit */ FLASH >CR & CR_OPTER_Reset; } } } /* Return the protection operation Status */ return status; } ``` > 在使用库函数去除读保护的时候, 会擦除之前设置的选项字节, 包括写保护 ![image 20230731135507154](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281059563.png) > 这里在使用RAM调试的时选择不进行擦除, 因为Flash被写保护了, 擦除不了 ```c void Write_Protect(void) { \tFLASH_Unlock(); \t//擦除之前的选项, 这是由于flash的特性, 写入之前需要进行擦除 \tFLASH_EraseOptionBytes(); \t \tFLASH_EnableWriteProtection (FLASH_WRProt_AllPages ); \t \tNVIC_SystemReset(); } void Write_Protect_Disable(void) { \tFLASH_Unlock(); \t \tFLASH_EraseOptionBytes(); \t \tFLASH_EnableWriteProtection (0x00000000 ); \t//进行一个系统的复位请求 \tNVIC_SystemReset(); } void Read_Protect(void) { \tFLASH_Unlock(); \t \tFLASH_EraseOptionBytes(); \t \tFLASH_ReadOutProtection (ENABLE ); \t //\tNVIC_SystemReset(); } void Read_Protect_Disable(void) { \tFLASH_Unlock(); \t \tFLASH_EraseOptionBytes(); \t \tFLASH_ReadOutProtection (DISABLE ); \t //\tNVIC_SystemReset(); } ``` ## F4/F7/H7 ![image 20240106162004955](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061620024.png) ![image 20240106162110887](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061621966.png) ![image 20240106162230905](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061622992.png) ![image 20240106162304719](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061623798.png) ![image 20240106162445472](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061624546.png) ![image 20240106162501675](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061625748.png) ![image 20240106162539957](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061625028.png) ![image 20240106162558399](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061625480.png) ![image 20240106162617920](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061626982.png) ![image 20240106162852298](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061628370.png) ## 实际操控 ![image 20240106162921111](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061629177.png) ![image 20240106162957212](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061629278.png)"},"/note/嵌入式/stm32/固件库/2023-6-26-6启动文件.html":{"title":"启动文件","content":" layout: post title: \"启动文件\" date: 2023 6 26 15:39:08 +0800 tags: stm32 # 启动文件 + 初始化堆栈指针SP ```assembly Stack_Size EQU 0x00000400\t; 宏定义设置大小为1KB \t\t\t AREA STACK, NOINIT, READWRITE, ALIGN 3 ;分配一个数据段, 名字叫STACK, 不初始化, 可读可写, 8字节对齐 Stack_Mem SPACE Stack_Size ; 分配内存空间 __initial_sp ; 紧挨着SPACE语句, 表示栈的结束, 由低向高生长 ``` ![image 20230626174327612](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281043634.png) + 初始化堆 用于动态内存的分配(malloc的使用) ```assembly Heap_Size EQU 0x00000200 AREA HEAP, NOINIT, READWRITE, ALIGN 3 __heap_base Heap_Mem SPACE Heap_Size __heap_limit ``` __heap_base 表示对的起始地址，__heap_limit 表示堆的结束地址。堆是由低向高生长 的，跟栈的生长方向相反。 ```assembly PRESERVE8\t\t文件堆栈8字节对齐 THUMB\t\t\t兼容这个指令集 ``` + 初始化中断向量表 内核响应中断之后中断函数执行, 内核使用中断向量表 ```assembly AREA RESET, DATA, READONLY EXPORT __Vectors EXPORT __Vectors_End EXPORT __Vectors_Size __Vectors DCD __initial_sp ; Top of Stack DCD Reset_Handler ; Reset Handler DCD NMI_Handler ; NMI Handler ...... DCD DMA2_Channel4_5_IRQHandler ; DMA2 Channel4 & Channel5 __Vectors_End __Vectors_Size EQU __Vectors_End __Vectors\t; 计算出向量表的大小 ``` > EXPORT表示可以被其他文件调用, 有全局性, 分配以字为单位的内存, 初始化内存 > > 使用DCD初始化一个字节的位置, 这里记录的是中断函数的名字, 中断函数在中断向量表中有顺序 + 初始化PC指针为复位程序, 初始化系统时钟, 和挂载的SARM(可选), 跳转到C库函数 ```assembly AREA .text, CODE, READONLY ``` > 设置这里为代码段开始执行, 第一个函数为复位函数 ```assembly ; Reset handler Reset_Handler PROC\t; 程序开始 EXPORT Reset_Handler [WEAK];弱定义, 可以由其他文件实现 IMPORT __main\t\t; 相当于extern, C库函数 IMPORT SystemInit\t; 系统时钟配置函数 LDR R0, SystemInit\t;执行函数 BLX R0 ;跳转, 执行完返回 LDR R0, __main BX R0\t\t\t\t;跳转, 执行完不返回 ENDP\t; 程序结束 ``` + 中断服务函数 ```assembly ; Dummy Exception Handlers (infinite loops which can be modified) NMI_Handler PROC EXPORT NMI_Handler [WEAK]\t; 有全局属性, 弱定义 B . ENDP ``` + 堆栈初始化, 由C库函数实现 ```assembly IF :DEF:__MICROLIB\t\t;宏定义, 在IDE里面定义 EXPORT __initial_sp EXPORT __heap_base EXPORT __heap_limit ELSE IMPORT __use_two_region_memory\t\t; 用户自己实现 EXPORT __user_initial_stackheap __user_initial_stackheap LDR R0, Heap_Mem LDR R1, (Stack_Mem + Stack_Size) LDR R2, (Heap_Mem + Heap_Size) LDR R3, Stack_Mem BX LR ALIGN ENDIF END ```"},"/note/嵌入式/stm32/固件库/2023-6-26-7时钟.html":{"title":"时钟","content":" layout: post title: \"时钟\" date: 2023 6 26 15:39:08 +0800 tags: stm32 # 时钟 ![](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311161144072.png) ![image 20230626230608247](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052925.png) 来源HSE(High Speed External Clock signal)外部高速时钟, 通过OSC_OUT和OSC_IN两个引脚 还有一个内部的HSI, 精度比较小, 受温度影响, 被RCC_CR寄存器控制 ![image 20230626203350095](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052926.png) ![image 20230626203435493](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052927.png) 故障的时候自动使用HSI, 直到HSE启动成功 也是由寄存器控制 ![image 20230626230424785](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052928.png) ## 寄存器 ### RCC_CR: HSE, HSI, PLL的使能, HSI的频率安全时钟使能 ![image 20230626231131332](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052929.png)![image 20230626231203030](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052930.png) ### RCC_CFGR:时钟的选择以及分频 ![image 20230626231350652](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052931.png) ![image 20230626231403968](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052932.png) ![image 20230626231501659](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052933.png) ### RCC_CLR: 时钟中断 ![image 20230626231539440](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052934.png) ![image 20230626231557502](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052935.png) ![image 20230626231623387](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052936.png) ### RCC_APB2RSTR: APB2复位寄存器 ### RCC_APB1RSTR: APB1复位寄存器 ### RCC_AHBENR:AHB时钟使能 ### RCC_APB2ENR:APB2时钟使能 ### RCC_APB1ENR:APB1时钟使能 ### RCC_BDCR: 备份域控制寄存器,设置LSE使能, RTC的时钟源选择 的LSEON、LSEBYP、RTCSEL和RTCEN位处于备份域。因 此，这些位在复位后处于写保护状态，只有在电源控制寄存器(PWR_CR)中的DBP位置’1’后才 能对这些位进行改动。 ### RCC_CSR:状态寄存器 ## 配置 PLL: 锁相环时钟, 是一种用于生成稳定时钟信号的时钟, 可以通过比较输入信号和输出信号的相位差来调整输出信号的频率和相位，从而使输出信号与输入信号同步。 使用外部时钟, PLLXTPRE不分频, PLLSRC选择, 之后的PLLMUL九倍频, 锁相环时钟PLLCLK为72MHz 如果使用内部时钟会进行一次分频, 最高频率为64MHz SYSCLK: 系统时钟, 有三种来源, 一般设置为锁相环时钟, 由RCC_CFGR前两位控制第三位检测是否切换完成 之后有AHB分频器, 再通过APB1, APB2预分频器再次分频, PCLK1为APB1最高36MHz, 之后可以倍频为定时器配置时钟, PCLK2为APB2可以为72MHz AHB还为内核等提供时钟 RTC试试时钟, HSE分频, LSE(外部32.768k), 或LSI(40K受温度影响)提供, 看门狗由LSI提供 还可以从MCO输出 CSS: 时钟安全系统, 外部的HSE故障的时候会发生时钟安全中断(CSSI后连接到不可屏蔽中断), 还会被发送到TIM1和TIM8的刹车输入端 HSE有毛病之后系统时钟自动切换为HSI为8MHz ```c static void SetSysClockTo72(void) { __IO uint32_t StartUpCounter 0, HSEStatus 0; /* SYSCLK, HCLK, PCLK2 and PCLK1 定义 */ /* 使能 HSE */ RCC >CR ((uint32_t)RCC_CR_HSEON); /* 等待 HSE is ready and if 超时 is reached exit */ do { HSEStatus RCC >CR & RCC_CR_HSERDY; StartUpCounter++; } while((HSEStatus 0) && (StartUpCounter ! HSE_STARTUP_TIMEOUT)); \t//判断成功或者失败 if ((RCC >CR & RCC_CR_HSERDY) ! RESET) { HSEStatus (uint32_t)0x01; } else { HSEStatus (uint32_t)0x00; } if (HSEStatus (uint32_t)0x01) { /* 成功初始化 使能预取址*/ FLASH >ACR FLASH_ACR_PRFTBE; /* Flash 2 wait state 设置等待时间在闪存编程手册中有描述配置系统时钟周期和闪存访问周期之间的关系 */ FLASH >ACR & (uint32_t)((uint32_t)~FLASH_ACR_LATENCY); FLASH >ACR (uint32_t)FLASH_ACR_LATENCY_2; /* HCLK SYSCLK 设置为72M*/ RCC >CFGR (uint32_t)RCC_CFGR_HPRE_DIV1; /* PCLK2 HCLK 一分频72M*/ RCC >CFGR (uint32_t)RCC_CFGR_PPRE2_DIV1; /* PCLK1 HCLK 二分频36MHz*/ RCC >CFGR (uint32_t)RCC_CFGR_PPRE1_DIV2; /* 配置锁相环设置PLL configuration: PLLCLK HSE * 9 72 MHz */ RCC >CFGR & (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC RCC_CFGR_PLLXTPRE RCC_CFGR_PLLMULL)); RCC >CFGR (uint32_t)(RCC_CFGR_PLLSRC_HSE RCC_CFGR_PLLMULL9); /* Enable PLL */ RCC >CR RCC_CR_PLLON; /* Wait till PLL is ready */ while((RCC >CR & RCC_CR_PLLRDY) 0) { } /* Select PLL as system clock source */ RCC >CFGR & (uint32_t)((uint32_t)~(RCC_CFGR_SW)); RCC >CFGR (uint32_t)RCC_CFGR_SW_PLL; /* Wait till PLL is used as system clock source */ while ((RCC >CFGR & (uint32_t)RCC_CFGR_SWS) ! (uint32_t)0x08) { } } else { //启动失败由用户添加代码 /* If HSE fails to start up, the application will have wrong clock configuration. User can add here some code to deal with this error */ } } ``` ```c void HSE_SetSysClk(uint32_t RCC_PLLMul_x) { \t//复位 \tRCC_DeInit(); \tErrorStatus HSEStatus; \t//使能HSE \tRCC_HSEConfig(RCC_HSE_ON); \tHSEStatus RCC_WaitForHSEStartUp(); \tif(HSEStatus SUCCESS) \t{ \t\t//启动成功 \t\t//根据库文件使能预取址, 设置为两个等待 \t\tFLASH_PrefetchBufferCmd(FLASH_PrefetchBuffer_Enable); \t\tFLASH_SetLatency(FLASH_Latency_2); \t\t//设置分频 \t\tRCC_HCLKConfig(RCC_SYSCLK_Div1); \t\tRCC_PCLK1Config(RCC_HCLK_Div2); \t\tRCC_PCLK2Config(RCC_HCLK_Div1); \t\t \t\tRCC_PLLConfig(RCC_PLLSource_HSE_Div1, RCC_PLLMul_x); \t\tRCC_PLLCmd(ENABLE); \t\t \t\twhile(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) RESET); \t\t//设置系统时钟为PLL \t\tRCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK); \t\twhile(RCC_GetSYSCLKSource() ! 0x08); \t\t \t\t \t\t \t}else \t{ \t\t//启动失败 \t} } ```"},"/note/嵌入式/stm32/固件库/2024-1-9-40硬件JGEG.html":{"title":"硬件JPEG","content":" layout: post title: \"硬件JPEG\" date: 2024 1 9 15:39:08 +0800 tags: stm32 # 硬件JPEG 在F7/H7芯片上面才有 ## 简介 ![image 20240109183930574](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091839641.png) ![image 20240109184105315](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091841401.png) ## 处理流程 ![image 20240109184241592](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091842655.png) ![image 20240109184428967](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091844052.png) ![image 20240109184816569](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091848643.png) ## YUV转RGB ![image 20240109184941441](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091849507.png) ![image 20240109185006494](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091850559.png) > YUV444没有进行压缩 > > ![image 20240109185421845](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091854925.png) > > YUV422压缩的方式就是通过相邻的色素共用一个色度, 单独存储他们的亮度 > > ![image 20240109185435930](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091854991.png) > > YUV420采用的是一行存储YU, 第二行存储YV, 还是相邻的像素共用 > > ![image 20240109185451125](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091854180.png) ### 硬件转换DMA2D ![image 20240109185929321](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091859395.png) ## 寄存器 ![image 20240109190144016](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091901065.png) ![image 20240109190249753](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091902826.png) ![image 20240109190327386](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091903449.png) ![image 20240109190702105](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091907188.png) ![image 20240109190815986](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091908053.png) ![image 20240109190833480](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401091908557.png)"},"/note/嵌入式/stm32/固件库/2023-12-29-35DAC.html":{"title":"DAC","content":" layout: post title: \"DAC\" date: 2023 12 29 15:39:08 +0800 tags: HAL库 stm32 # DAC Degital to Analog Converter 数字/模拟转换器 ![image 20231229215140931](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312292151963.png) ADC和DAC是用来连接数字电路和模拟电路之间的桥梁 ![image 20231229215249898](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312292152938.png) > 比例误差: 随着数字量增加变化的电压值斜率k发生变化 > > 失调误差: 斜率正确但是起点出现问题, 数字量为0的时候出现正电压或者是负电压 > > 非线性误差: 增加的线条不是直线 ![image 20231229215558434](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312292155485.png) > 挂载在APB1上面 ## 工作原理 ![image 20231229225404527](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312292254596.png) ![image 20231229225957133](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312292259201.png) ![image 20231229230045545](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312292300590.png) ![image 20231229230240470](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312292302523.png) ![image 20231229230724647](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312292307694.png) ![image 20231229230831390](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312292308437.png) ![image 20231229230924061](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312292309095.png) ![image 20231229230940457](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312292309490.png) ## 寄存器 ![image 20231230105422087](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312301054142.png) ![image 20231230105530139](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312301055196.png) ![image 20231230105555284](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312301055333.png) ![image 20231230105951904](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312301059958.png) ![image 20231230110008937](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312301100969.png) ## PWM DAC stm32一般有两路输出, 有一些应用可能需要多路DAC, 外扩DAC成本会提升 在精度要求不高的时候, 可以使用一种廉价的DAC输出, 主要就是PWM加RC滤波器 ![image 20231230164153953](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312301641016.png) ![image 20231230164414407](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312301644455.png) > ![image 20231230165223661](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312301652710.png) ![image 20231230165444147](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312301654203.png) ![image 20231230165531286](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312301655336.png) ![image 20231230170451342](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312301704392.png) ![image 20231230170632474](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312301706539.png)"},"/note/嵌入式/stm32/固件库/2023-12-25-34RNG.html":{"title":"RNG","content":" layout: post title: \"RNG\" date: 2023 6 26 15:39:08 +0800 tags: stm32 # RNG 硬件随机数 随机数发生器用于生成随机数的程序或者硬件, STM32的RNG处理器是一个以连续噪声为基础的随机数发生器, 提供一个32位的随机数 有的型号使用的是真随机数发生器, 而伪随机数使用确定的算法计算出来随机数, 不是真的随机数 应用场景, 验证码, 密码学, 概率学, 统计学, 游戏 ![image 20231225221641243](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312252216464.png) ## 寄存器 ![image 20231225221724098](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312252217128.png) ![image 20231225221801528](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312252218572.png) ![image 20231225221829952](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312252218006.png) ![image 20231225221846349](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312252218398.png)"},"/note/嵌入式/stm32/固件库/2024-1-4-37CAN.html":{"title":"CAN协议","content":" layout: post title: \"CAN协议\" date: 2024 1 4 15:39:08 +0800 tags: stm32 # CAN协议 ## 基础知识 ![image 20240104113305644](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041133771.png) ![image 20240104113442141](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041134197.png) ![image 20240104113627098](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041136148.png) ![image 20240104113924992](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041139053.png) ![image 20240104114105260](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041141317.png) ## 协议层 ![image 20240104114433587](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041144637.png) ![image 20240104115144730](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041151803.png) > CRC界定符是表示CRC校验场的结束，是一个1位的常态隐性位。但是，在CAN FD中，考虑到节点之间的位的距离，在接收端允许最大2位时间。CAN FD帧的数据场（可变速段）是CRC界定符的第一位采样点。 > > 在ACK之后，发送ACK界定符。这是一个表示ACK结束的分隔符，为是1位隐性位。 ![image 20240104120336220](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041203277.png) ![image 20240104120604005](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041206074.png) ![image 20240104120752538](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041207605.png) ![image 20240104120858249](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041208301.png) > 报文越小竞争力越强 ## STM32 STM32的控制器叫做bxCAN, 支持CAN2.0A和CAN 2.0B Active ![image 20240104131206704](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041312755.png) > F103只有14个过滤器组, 对报文进行过滤 ### 工作模式 ![image 20240104131540575](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041315629.png) ![image 20240104131740322](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041317380.png) ### 框图 ![image 20240104132041470](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041320548.png) ![image 20240104132324255](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041323322.png) ![image 20240104132455448](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041324503.png) ![image 20240104132854276](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041328347.png) ![image 20240104133129967](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041331033.png) ### 位时序 ![image 20240104133330900](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041333956.png) ![image 20240104133350287](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041333320.png) ### 寄存器 ![image 20240104150618929](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041506985.png) ![image 20240104150715930](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041507985.png) ![image 20240104150803002](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041508058.png) ![image 20240104150929569](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041509627.png) ![image 20240104151012886](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041510936.png) ![image 20240104151028614](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041510659.png) ![image 20240104151105664](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041511717.png) ![image 20240104151234525](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041512591.png) ![image 20240104151304233](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041513296.png) ![image 20240104151323411](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041513472.png)"},"/note/嵌入式/stm32/固件库/2023-7-8-15FSMC(SRAM).html":{"title":"FSMC(SRAM)","content":" layout: post title: \"FSMC(SRAM)\" date: 2023 7 8 15:39:08 +0800 tags: stm32 # FSMC(SRAM) ## SRAM ![image 20231216105906682](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312161059807.png) 芯片里面有SRAM相当于内存条, 可以使用用来扩展 ### IS62WV51216ALL ![image 20230708101959682](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049265.png) > ①用来存储数据 > > ②地址数据转换电路 > > ③控制电路 > > ![image 20230708102207094](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049266.png) > > 在寻址的时候每个地址有16位数字, 想要输出其中第一字节或者第二字节字节, 使用UB或者LB为低电平控制数据有效 > > OE: 读使能 > > CS: 片选 > > WE: 写使能 ![image 20230708102423476](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049267.png) 2^18^个数据位, 就是512K个数据位, 每个数据为是16位, 所以一共是1M字节 ![image 20230708110922906](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049268.png) > 读 > > 通过时间协调进行通讯 > > 片选,同时输入地址, 控制掩码, 传入地址, 读使能, 一段时间后返还数据, 保持一段时间 > > 没有时钟同步, 所以需要时间数据 > > 主要是TRC, TAA, TDOE > > ![image 20230708181344856](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049269.png) ![image 20230708181254706](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049270.png) > 写 > > ![image 20230708181400581](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049271.png) ### XM8A51216 最高访问速度是15ns, 功耗比较低, TTL电平兼容, 全静态操作, 不需要刷新电路以及时钟电路 三态输出, 支持高低字节 ![image 20231216110455517](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312161104581.png) ![image 20231216110644626](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312161106690.png) ![image 20231216111014544](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312161110608.png) ![image 20231216111111943](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312161111994.png) ![image 20231216111300536](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312161114488.png) > NE: 片选信号, NBL: 掩码信号, NOE, NWE: 选择读或者写 ![image 20231216113949581](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312161139635.png) ![image 20231216115116666](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312161151738.png) ![image 20231216115500349](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312161155420.png) ![image 20231216115641247](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312161156313.png) ![image 20231216115822038](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312161158097.png) ## stm32的实现 FSMC: 灵活的静态存储器 ![image 20230708181957308](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049272.png) > 用来控制SRAM, ROM > > **引脚** > > ![image 20230708205910810](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049273.png) > > FSMC_NB: 控制数据的高位低位 > > FSMC_A: 地址线, 这里只使用了一部分 > > FSMC_D: 数据线 > > FSMC_NWE: 写入时能 > > FSMC_NOE: 输出使能 > > FSMSC_NE: 片选引脚, 控制不同的内部地址, stm32会把这片区域映射到自己的内存地址, 直接读写就可以了, 且可以挂载多个, 访问不同的空间的时候使能不同的引脚 ### 存储器控制器 上面不同的引脚连接到FSMC内部对应的存储器中, NOR/PSRAM/SRAM设备使用相同的控制器, NAND/PC卡使用相同的控制器, 不同的控制器有不同的寄存器控制 SRAM的寄存器有 FSMC_BCRx: 控制寄存器, 控制存储器类型, 数据宽度, 信号有效极性 ![image 20230709135258986](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049274.png) ![image 20230709135326765](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049275.png) FSMC_BTRx: 片选时序寄存器, 控制延迟, 比如数据保持时间 ![image 20230709135354908](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049276.png) > 不同的存储器使用不同的模式 > > ① SRAM/CRAM > > A: SRAM/PSRAM(CRAM)OE反转 > > ②NOR闪存 > > C:NOR闪存OE反转 > > D: 带地址扩展异步操作 > > 复用模式: 地址数据复用模式 ![image 20230709135505825](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049277.png) ![image 20230709135559076](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049278.png) ![image 20230709135611842](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049279.png) FSMC_BWTRx: 写时序寄存器, 和上面基本一样, 主要用来扩展模式的时候读时序, 写时序使用不同的参数 ### 时钟配置逻辑 直接连接在HCLK72MHz, 分频之后CLK引脚的频率会有变化, 这里没有使用, 为异步通讯 ### 地址映射 直接映射到stm32自己的内存之中, 直接访问内存, stm32就会自动进行访问外部外设 stm预留了1G ![image 20230709140746247](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049280.png) > 每一个区域都有对应的存储器 > > ![image 20230709160412697](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049281.png) > > 为了连接不同的芯片, 每个信号线对应不同的引脚 ### 模式A ![image 20230709161136313](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049282.png) > ADDSET小于TAA > > DATAST+ADDSET时间大约就是tRC, 大于给出使能之后数据稳定的时间tDOE > > 所有的时间大于TRC 55ns > > 读使能到采样的时间大于TDOE, 最大是25ns > > ADDSET没有限制 > > ![image 20230709161957252](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049283.png) > > ![image 20230709162016568](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049284.png) ![image 20230709162123479](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281049285.png) > 通过配置FSMC_BCR的EXTMOD位的时候可以控制读写时序是否一样 > > 总时间小于tWC > > 采样是在写使能之后一段时间tPWE > > 写的总时间大于55ns: ADDSET+DARAST+2> 55ns > > 写使能到采样时间DATAST+1>40ns > > 地址配置之后可以立刻写使能 > 模式一和模式A的区别, 是否使用不同的时序 ## 库函数 ```c typedef struct { uint32_t FSMC_AddressSetupTime; /*!< Defines the number of HCLK cycles to configure the duration of the address setup time. This parameter can be a value between 0 and 0xF. 地址建立时间, 设置ADDSET, 设置之后会加一, 使能信号跳变的时刻*/ uint32_t FSMC_AddressHoldTime; /*!< Defines the number of HCLK cycles to configure the duration of the address hold time. This parameter can be a value between 0 and 0xF. @note: It is not used with synchronous NOR Flash memories. 地址保持时间, ADDHALD模式, 是复用模式, 不关注*/ uint32_t FSMC_DataSetupTime; /*!< Defines the number of HCLK cycles to configure the duration of the data setup time. This parameter can be a value between 0 and 0xFF. @note: It is used for SRAMs, ROMs and asynchronous multiplexed NOR \t\t\t\t\t\t\t\t\t\t Flash memories. 控制DATAST的时间, 设置0保留, 设置为1为两个时钟周期*/ uint32_t FSMC_BusTurnAroundDuration; /*!< Defines the number of HCLK cycles to configure the duration of the bus turnaround. This parameter can be a value between 0 and 0xF. @note: It is only used for multiplexed NOR Flash memories. 总线转换周期,这个模式不使用*/ uint32_t FSMC_CLKDivision; /*!< Defines the period of CLK clock output signal, expressed in number of \t\t\t\t\t\t\t\t\t\t\tHCLK cycles. This parameter can be a value between 1 and 0xF. @note: This parameter is not used for asynchronous NOR Flash, SRAM or \t\t\t\t\t\t\t\t\t\t\tROM accesses. 时钟分频因子, 输出时钟的时候使用,这里没有使用*/ uint32_t FSMC_DataLatency; /*!< Defines the number of memory clock cycles to issue to the memory before getting the first data. The value of this parameter depends on the memory type as shown below: It must be set to 0 in case of a CRAM It is don't care in asynchronous NOR, SRAM or ROM accesses It may assume a value between 0 and 0xF in NOR Flash memories with synchronous burst mode enable 数据的保持时间, 这里也没有使用*/ uint32_t FSMC_AccessMode; /*!< Specifies the asynchronous access mode. This parameter can be a value of @ref FSMC_Access_Mode 选择访问模式 这里使用模式A*/ }FSMC_NORSRAMTimingInitTypeDef; ``` > 配置时钟的结构体 ```c typedef struct { uint32_t FSMC_Bank; /*!< Specifies the NOR/SRAM memory bank that will be used. This parameter can be a value of @ref FSMC_NORSRAM_Bank 实际上控制的存储区, 实际选择是不同的寄存器组##使用##*/ uint32_t FSMC_DataAddressMux; /*!< Specifies whether the address and data values are multiplexed on the databus or not. This parameter can be a value of @ref FSMC_Data_Address_Bus_Multiplexing 地址线数据线是否复用*/ uint32_t FSMC_MemoryType; /*!< Specifies the type of external memory attached to the corresponding memory bank. This parameter can be a value of @ref FSMC_Memory_Type 控制的是存储器的类型##使用##*/ uint32_t FSMC_MemoryDataWidth; /*!< Specifies the external memory device width. This parameter can be a value of @ref FSMC_Data_Width 配置数据位的大小##使用##*/ uint32_t FSMC_BurstAccessMode; /*!< Enables or disables the burst access mode for Flash memory, valid only with synchronous burst Flash memories. This parameter can be a value of @ref FSMC_Burst_Access_Mode 配置是否使用突发模式, 给出起始地址,输入多个数据,地址会自动加一*/ uint32_t FSMC_AsynchronousWait; /*!< Enables or disables wait signal during asynchronous transfers, valid only with asynchronous Flash memories. This parameter can be a value of @ref FSMC_AsynchronousWait 是否使能同步传输的时候的等待信号*/ uint32_t FSMC_WaitSignalPolarity; /*!< Specifies the wait signal polarity, valid only when accessing the Flash memory in burst mode. This parameter can be a value of @ref FSMC_Wait_Signal_Polarity 设置等待信号的极性*/ uint32_t FSMC_WrapMode; /*!< Enables or disables the Wrapped burst access mode for Flash memory, valid only when accessing Flash memories in burst mode. This parameter can be a value of @ref FSMC_Wrap_Mode 设置是否支持对齐的突发模式*/ uint32_t FSMC_WaitSignalActive; /*!< Specifies if the wait signal is asserted by the memory one clock cycle before the wait state or during the wait state, valid only when accessing memories in burst mode. This parameter can be a value of @ref FSMC_Wait_Timing 设置的那个带信号在等待前还是等待期间有效*/ uint32_t FSMC_WriteOperation; /*!< Enables or disables the write operation in the selected bank by the FSMC. This parameter can be a value of @ref FSMC_Write_Operation 是否写使能##使用##*/ uint32_t FSMC_WaitSignal; /*!< Enables or disables the wait state insertion via wait signal, valid for Flash memory access in burst mode. This parameter can be a value of @ref FSMC_Wait_Signal 是否能使能等待状态插入*/ uint32_t FSMC_ExtendedMode; /*!< Enables or disables the extended mode. This parameter can be a value of @ref FSMC_Extended_Mode 是否使能扩展模式(使用两个时序)##使用##*/ uint32_t FSMC_WriteBurst; /*!< Enables or disables the write burst operation. This parameter can be a value of @ref FSMC_Write_Burst 是否使能写的突发操作*/ FSMC_NORSRAMTimingInitTypeDef* FSMC_ReadWriteTimingStruct; /*!< Timing Parameters for write and read access if the ExtendedMode is not used, 读寄存器的时序, 或者在没有分开使用的时候使用的时序##使用##*/ FSMC_NORSRAMTimingInitTypeDef* FSMC_WriteTimingStruct; /*!< Timing Parameters for write access if the ExtendedMode is used 写寄存器的时序*/ }FSMC_NORSRAMInitTypeDef; ``` ### 使用 ```c uint8_t testValue __attribute__ ((at (SRAM_BASE_ADDR + 40))); //在创建变量的同时指定创建的地址 ``` ## SDRAM 同步: 内部的工作需要同步时钟 动态: 需要不断刷新来保存数据不会丢失 随机: 数据不是线性依次存储的, 可以自由的进行数据的读写 优点, 容量比较大, 读写的速度快, 但是控制逻辑复杂 ![image 20231214212850329](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312142128410.png) ![image 20231214213009705](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312142131401.png) ![image 20231214213055998](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312142131408.png) ![image 20231214213230408](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312142138863.png) ![image 20231214213753444](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312142137500.png) ![image 20231214214046944](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312142140008.png) ![image 20231214214309856](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312142143923.png) ![image 20231214220112343](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312142201413.png) ![image 20231214220445603](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312142204675.png) ![image 20231214221030739](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312142210823.png) ![image 20231214221517362](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312142215442.png) ![image 20231214222016118](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312142220204.png) ![image 20231214222123205](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312142221283.png) ## FMC 灵活的存储控制器, 可以驱动SRAM/NOR/NAND Flash以及SDRAM等存储器 特点: 有两个存储区域, 可以独立配置, 支持8/16/32位数据总宽度, 支持13位行地址, 11位列地址, 4个内部存储区域, 支持字,半字,字节访问, 自动进行存储区域边界管理, 多存储区域乒乓访问, 支持自动刷新, 可以编程刷新变成速度, 读FIFO可以进行缓存 ![image 20231215090428889](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312150904007.png) ![image 20231215090631676](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312150906758.png) ![image 20231215090832988](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312150908064.png) 需要进行对应的配置, 从而获取到具体访问的数据 ![image 20231215090949325](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312150909386.png) ### 寄存器 ![image 20231215091123718](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312150911765.png) ![image 20231215091526093](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312150915179.png) ![image 20231215091608096](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312150916165.png) ![image 20231215091938228](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312150919302.png) ![image 20231215092245179](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312150922247.png) > 相当于一个递减的计数器,计数到0的时候会进行刷机新"},"/note/嵌入式/stm32/固件库/2023-7-2-11DMA.html":{"title":"DMA","content":" layout: post title: \"DMA\" date: 2023 7 2 15:39:08 +0800 tags: stm32 # DMA Direct Memory Access直接存储器访问, 主要的功能是数据的搬运, 不占用CPU, 通过硬件为RAM和IO开辟一条通道 DMA1: 有七个通道, 可以实现P >M, M >P, M >M(M是内存, P是外设) DMA2: 五个通道, 只存在于大容量或者互联型 ## STM实现 ![image 20230702193710282](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281051559.png) > 通过总线矩阵访问外设或者SRAM, 不通过CPU > > 不同的外设都有自己对应的特殊的外设 > > 仲裁器可以控制有多个响应的时候优先处理哪一个 + 实现过程 ![image 20231228165050829](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312281650947.png) ![image 20230702194001379](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281051560.png) ![image 20230702194013891](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281051561.png) > 每个通道用来管理来自于一个或多个外设对存储器访问的请求。且都有一个仲裁器，用于处理DMA请求间的优先级。 ![image 20231228165254334](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312281652418.png) 在使用M >M的时候所有的通道都可以使用 在实际使用的时候涉及优先级, 可以使用软件控制DMA_CCRx的PL, 之后还有硬件优先级, DMA1优先级高于DMA2 ### 寄存器 ![image 20231228165424692](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312281654766.png) + DMA_ISR: 中断状态寄存器 ![image 20231228171040527](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312281710595.png) + DMA_IFCR: 中断标志位清除寄存器 ![image 20231228171120097](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312281711147.png) + DMA_CCRx: 通道x配置寄存器 ![image 20230702195605618](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281051562.png) ![image 20231228170632277](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312281706312.png) ![image 20230702200241096](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281051563.png) ![image 20230702200148107](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281051564.png) ![image 20230702200131250](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281051565.png) ![image 20230702200659287](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281051566.png) ![image 20230702195311117](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281051567.png) ![image 20230702200943603](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281051568.png) + DMA_CNDTRx: 传输数量寄存器, 在DMA关闭的时候可以写入 数据传输结束后，寄存器的内容或者变为0；或者当该通道配置为自动重加载模式时，寄存 器的内容将被自动重新加载为之前配置时的数值, 寄存器的数字为0的时候停止传输 ![image 20230702195918363](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281051569.png) + DMA_CPARx: DMA通道x外设地址寄存器, 数据的来源 + DMA_CMARx: DMA通道x存储器地址寄存器, 数据的目标 ### 固件库 ```c typedef struct { uint32_t DMA_PeripheralBaseAddr; /*!< Specifies the peripheral base address for DMAy Channelx. 外设的地址*/ uint32_t DMA_MemoryBaseAddr; /*!< Specifies the memory base address for DMAy Channelx. 目标的地址*/ uint32_t DMA_DIR; /*!< Specifies if the peripheral is the source or destination. This parameter can be a value of @ref DMA_data_transfer_direction传输的方向 实际的参数 #define DMA_DIR_PeripheralDST ((uint32_t)0x00000010), Periphra作为目的地 #define DMA_DIR_PeripheralSRC ((uint32_t)0x00000000), Periphra作为初始地址*/ uint32_t DMA_BufferSize; /*!< Specifies the buffer size, in data unit, of the specified Channel. The data unit is equal to the configuration set in DMA_PeripheralDataSize or DMA_MemoryDataSize members depending in the transfer direction. 数据处传\t\t\t\t\t\t\t\t\t\t输的位数*/ uint32_t DMA_PeripheralInc; /*!< Specifies whether the Peripheral address register is incremented or not. This parameter can be a value of @ref DMA_peripheral_incremented_mode 传输的时候外设地址是否增量*/ uint32_t DMA_MemoryInc; /*!< Specifies whether the memory address register is incremented or not. This parameter can be a value of @ref DMA_memory_incremented_mode 传输的时候存储器的地址是否增加*/ uint32_t DMA_PeripheralDataSize; /*!< Specifies the Peripheral data width. This parameter can be a value of @ref DMA_peripheral_data_size 外设的数据宽度*/ uint32_t DMA_MemoryDataSize; /*!< Specifies the Memory data width. This parameter can be a value of @ref DMA_memory_data_size 目的地的传输的宽度*/ uint32_t DMA_Mode; /*!< Specifies the operation mode of the DMAy Channelx. This parameter can be a value of @ref DMA_circular_normal_mode. @note: The circular buffer mode cannot be used if the memory to memory data transfer is configured on the selected Channel 传输的时候什么时候结束, 是否为循环操作*/ uint32_t DMA_Priority; /*!< Specifies the software priority for the DMAy Channelx. This parameter can be a value of @ref DMA_priority_level 设置优先级*/ uint32_t DMA_M2M; /*!< Specifies if the DMAy Channelx will be used in memory to memory transfer. This parameter can be a value of @ref DMA_memory_to_memory 设置是否为内存之间转移*/ }DMA_InitTypeDef; ``` > 数据的宽度不相同的时候, 源比较大, 其他的直接丢弃, 源比较小, 剩余的位置设置为空 ## 实际使用 ### 实现地址之间的传输 ```c #include \"bsp_dma.h\" //原始数据 const uint32_t aSRC_Const_Buffer[BUFFER_SIZE] { 0x01020304,0x05060708,0x090A0B0C,0x0D0E0F10, 0x11121314,0x15161718,0x191A1B1C,0x1D1E1F20, 0x21222324,0x25262728,0x292A2B2C,0x2D2E2F30, 0x31323334,0x35363738,0x393A3B3C,0x3D3E3F40, 0x41424344,0x45464748,0x494A4B4C,0x4D4E4F50, 0x51525354,0x55565758,0x595A5B5C,0x5D5E5F60, 0x61626364,0x65666768,0x696A6B6C,0x6D6E6F70, 0x71727374,0x75767778,0x797A7B7C,0x7D7E7F80}; //目标 uint32_t aDST_Buffer[BUFFER_SIZE]; void DMA_MtoM_Config(void) { \t//初始化时钟 \tRCC_AHBPeriphClockCmd(MTM_DMA_CLK, ENABLE); \t \tDMA_InitTypeDef DMA_InitStructure; \tDMA_InitStructure.DMA_PeripheralBaseAddr (uint32_t)aSRC_Const_Buffer;\t//源地址 \tDMA_InitStructure.DMA_MemoryBaseAddr (uint32_t)aDST_Buffer;\t\t\t\t//目标地址 \tDMA_InitStructure.DMA_DIR DMA_DIR_PeripheralSRC; \tDMA_InitStructure.DMA_BufferSize BUFFER_SIZE; \t \tDMA_InitStructure.DMA_PeripheralInc DMA_PeripheralInc_Enable;\t\t\t//递增 \tDMA_InitStructure.DMA_PeripheralDataSize DMA_PeripheralDataSize_Word; \tDMA_InitStructure.DMA_MemoryInc DMA_MemoryInc_Enable;\t\t\t\t//设置为递增 \tDMA_InitStructure.DMA_MemoryDataSize DMA_MemoryDataSize_Word;\t//设置长度 \tDMA_InitStructure.DMA_Mode DMA_Mode_Normal;\t\t\t\t\t//设置不循环 \t \tDMA_InitStructure.DMA_Priority DMA_Priority_High;\t\t\t\t//设置优先级 \tDMA_InitStructure.DMA_M2M DMA_M2M_Enable; \t \tDMA_Init(MTM_DMA_CHANNEL, &DMA_InitStructure); //清除标志位 \tDMA_ClearFlag(DMA1_FLAG_TC6); \t//使能 \tDMA_Cmd(MTM_DMA_CHANNEL, ENABLE); } uint8_t Buffercmp(const uint32_t* pBuffer, uint32_t* pBuffer1, uint16_t BufferLength) { /* 数据长度递减 */ while(BufferLength ) { /* 判断两个数据源是否对应相等 */ if(*pBuffer ! *pBuffer1) { /* 对应数据源不相等马上退出函数，并返回0 */ return 0; } /* 递增两个数据源的地址指针 */ pBuffer++; pBuffer1++; } /* 完成判断并且对应数据相对 */ return 1; } ``` ```c \tLED_GPIO_Config(); \tLED_R(OFF) \tLED_B(OFF) \tLED_G(OFF) \tuint8_t status 0; \tDMA_MtoM_Config(); \t//检测是否完成 \twhile(DMA_GetFlagStatus(DMA1_FLAG_TC6) RESET); \tstatus Buffercmp(aSRC_Const_Buffer, aDST_Buffer, BUFFER_SIZE); \tif(status 0) \t{ \t\tLED_R(ON) \t}else \tLED_G(ON) ``` ### 实现串口的传输 1. 实现初始化 2. 串口发出请求 ```c LED_GPIO_Config(); LED_R(OFF) LED_B(OFF) LED_G(OFF) LED_B(ON) USART_Config(); //初始化数组 for(uint16_t i 0; i<SENDBUFF_SIZE;i++) { SendBuff[i] 'a'; } DMA_USART_Config(); //发送信号 USART_DMACmd(DEBUG_USARTx, USART_DMAReq_Tx, ENABLE); while(1){ LED_G_TOGGLE for(uint16_t i 0; i< 0xfff;i++) for(uint16_t b 0; b< 0xff;b++); }; ``` ```c void DMA_USART_Config(void) { \t//初始化时钟 \tRCC_AHBPeriphClockCmd(USART_TX_DMA_CLK, ENABLE); \t \tDMA_InitTypeDef DMA_InitStructure; \tDMA_InitStructure.DMA_PeripheralBaseAddr USART_DR_ADDRESS;\t\t//外设地址 \tDMA_InitStructure.DMA_MemoryBaseAddr (uint32_t)SendBuff;\t\t\t\t//内存地址 \tDMA_InitStructure.DMA_DIR DMA_DIR_PeripheralDST; \tDMA_InitStructure.DMA_BufferSize SENDBUFF_SIZE; \t \tDMA_InitStructure.DMA_PeripheralInc DMA_PeripheralInc_Disable;\t\t\t//不增 \tDMA_InitStructure.DMA_PeripheralDataSize DMA_PeripheralDataSize_Byte; \tDMA_InitStructure.DMA_MemoryInc DMA_MemoryInc_Enable; \tDMA_InitStructure.DMA_MemoryDataSize DMA_PeripheralDataSize_Byte; \tDMA_InitStructure.DMA_Mode DMA_Mode_Normal; \t \tDMA_InitStructure.DMA_Priority DMA_Priority_High; \tDMA_InitStructure.DMA_M2M DMA_M2M_Disable; \t \tDMA_Init(USART_TX_DMA_CHANNEL, &DMA_InitStructure); \tDMA_ClearFlag(USART_TX_DMA_FLAG_TCL); \t//使能 \tDMA_Cmd(USART_TX_DMA_CHANNEL, ENABLE); } ``` ## F4/F7/H7 ![image 20231228184523179](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312281845271.png) ![image 20231228184257596](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312281845489.png) ![image 20231228184702856](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312281847920.png) ![image 20231228184946978](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312281849058.png) ![image 20231228185241603](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312281852687.png) ![image 20231228185321689](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312281853773.png) ![image 20231228185548617](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312281855688.png) ## 寄存器 ![image 20231228190031861](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312281900920.png) ![image 20231228190554873](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312281905953.png) ![image 20231228190626449](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312281906522.png) ![image 20231228190640701](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312281906773.png) ![image 20231228190733400](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312281907466.png) ![image 20231228190930429](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312281909501.png) ![image 20231228191152517](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312281911570.png)"},"/note/嵌入式/stm32/固件库/2023-6-19-2初识stm32.html":{"title":"初识stm32","content":" layout: post title: \"初识stm32\" date: 2023 6 19 15:39:08 +0800 tags: stm32 # 初识stm32 ST是一个SOC厂商, ARM是IP厂商 [意法半导体STM32/STM8技术社区 提供最新的ST资讯和技术交流 (stmcu.org.cn)](https://www.stmcu.org.cn/) [产品 STM32/STM8 MCU单片机 意法半导体STM STMCU中文官网](https://www.stmcu.com.cn/product) [st.com/content/st_com/en.html官网](https://www.st.com/content/st_com/en.html) ![image 20231105091427637](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311050914776.png) [Selection_Guide.pdf (stmcu.com.cn)](https://static.stmcu.com.cn/upload/Selection_Guide.pdf), 点击上面的选项可以获取某一个系列的选型手册 ![image 20231105091718052](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311050917114.png) M: 微控制器, 一般不跑系统 **微处理器**: 区别是有没有MMU, 内存管理单元 ![image 20230620162642957](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281058187.png) ![image 20230620165455787](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281058188.png) ![image 20230620165814921](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281058190.png) ![image 20230728224159164](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281058191.png) > BGA封装 >引脚在芯片下面 ![image 20230620170646202](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281058192.png) ![image 20230620171012650](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281058193.png) > 在数据手册有具体每个引脚的说明, 引脚定义篇 ![image 20230620171545967](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281058194.png)"},"/note/嵌入式/stm32/固件库/2023-7-19-21SDIO.html":{"title":"SDIO","content":" layout: post title: \"SDIO\" date: 2023 7 19 15:39:08 +0800 tags: stm32 # SDIO ## 协议简介 常见的SD卡可以使用两种模式的通讯, SPI或者SDIO模式 SD卡: 安全数字存储卡, 内存< 2GB叫做SD, 2GB< 内存< 32GB叫做SDHC, 32< 内存叫做SDXC, stm32最大支持32GB SDIO: 安全数字输入输出接口, 可以驱动MMC卡, SD卡, SD I/O卡(接在一些设备上用于通讯, 不是存储器), CE ATA设备是一种硬盘使用的, 是一种总线 ### 物理结构 ![image 20230719112332523](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046532.png) 实际上是NOR Flash, 以块进行读写, 根据命令进行读写 ![image 20230719112749337](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046533.png) > SD卡内部的寄存器 > > CID: 每个厂商申请, 可以用于区分不同的SD卡 > > RCA: 实际上也可以用于区分设备 > > CSR: 判断卡的状态 > > SSR: 保存卡的信息 ![image 20230719113154012](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046534.png) > 协议可以连接多个, stm32只能连接一个 > SD卡一共有9 pin, 三根电源线, 一根时钟线, 一根命令线, 四根数据线 > > CLK: 时钟线, 主机产生, 上升的时候有效 > > CMD: 命令控制线, SDIO发送命令控制SD卡, 命令应答的时候也是通过这条线 > > D0 3: 数据线, 传输读写数据, 可以吧D0拉低表示忙状态 > > V~DD~, V~SS1~, V~SS2~: 电源以及地 ![image 20240107222154762](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401072221883.png) > SD卡使用两种频率通讯, 一个是识别时候的频率FOD, 最高400KHz, 另一个是数据传输模式下的FPP默认25MHz, 最高50MHz > 传输协议: 基于命令的, 先发送一个0, 结束的时候发送一个1, 有响应的命令返回数值 > 读写操作: 数据块一般为512字节, 需要CRC位保证数据传输成功, 硬件产生 > > ![image 20230719115905304](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046535.png) > > 在读之前需要检测忙标志 > > ![image 20230719120254087](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046536.png) > > ![image 20230719120356780](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046537.png) > > 用于SSR寄存器 ### 命令 广播命令: 对连接的所有的卡发出的信号 寻址命令: 包含卡的地址 + 命令格式 ![image 20230719123550551](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046538.png) > 固定48位, 传输标志是确定传输方向的 > > CRC算法计算进行校验 > > 基本命令64个 ![image 20230719124517148](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046539.png) 有一些扩展的命令, 特定应用命令, ACMD, 需要在发送之前发送CMD55, 之后发送ACMD命令, 如果发现不是ACMD, 执行标准命令 #### 实际的命令 <img src \"https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046540.png\" alt \"image 20230719125621779\" style \"zoom: 200%;\" /> > SDIO 总共有 7 个响应类型 (代号：R1~R7)，其中 SD 卡没有 R4、R5 类型响应。特定的命令对应 有特定的响应类型，比如当主机发送 CMD3 命令时，可以得到响应 R6。与命令一样，SD 卡的 响应也是通过 CMD 线连续传输的。根据响应内容大小可以分为短响应和长响应。短响应是 48bit 长度，只有 R2 类型是长响应，其长度为 136bit。各个类型响应具体情况如表 SD 卡响应类型 。 ![image 20230719130207910](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046541.png) > 读取sdsc地址以直接为单位, sdhc卡是块为地址 > 通过CMD7进行选定一张卡 > > 擦除命令需要使用三个命令 ### 操作模式 在初始化的时候有一个初始化模式, 叫做卡识别模式, 之后使用数据传输模式 stm32支持的模式是2.0, 使用的时候需要区分卡使用的模式且卡的容量需要区分 系统复位以后主机处于卡识别模式, 寻找可用的SDIO同时SD卡也处于卡识别模式, 直到被识别到, SD卡接收到SEND_RCA(CMD3)之后进入传输模式 ![image 20230721152719980](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046542.png) > 无效模式, 使用CMD15进入 > > 空闲状态, CMD1 > > 准备状态, 环境正常之后进入 > > 识别状态, 可以接受命令 > > 待机状态, 低功耗 > > 传输状态, 读写之前 > > 发送数据状态, 传输的时候 > > 接收数据状态, > > 编程状态, 这个是写入的时候, 传输的数据不一定立刻写入 > > 断开连接状态, 换卡, 断开连接 ![image 20230721161545433](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046543.png) > CMD8确认卡的状态 > CMD41询问卡的信息 ![image 20230721162125582](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046544.png) ## stm32的实现 ![image 20240108153630938](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081536090.png) SDIOCLK 72MHz ![image 20230721183344035](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046546.png) ![image 20240108153856782](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081538898.png) 使用两个时钟, 一个是SDIO适配时钟, 另一个是AHB总线时钟二分频, SDIO适配器时钟(SDIOCLK)提供SDIO主机功能, 提供SD时钟, 发送命令进行数据交换, APB2接口用于访问器访问SDIO适配器并且可以产生中断和DMA > SDIOCLK HCLK > > ![image 20240108155202587](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081552708.png) ![image 20230721183807207](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046547.png) ![image 20240108155633828](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081556939.png) ![image 20240108155829162](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081558286.png) ![image 20240108160541244](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081605377.png) > 输出的时钟可以使用两种, FIFO是一个32个字的存储单元, 使用DMA进行传输 ![image 20230721184139651](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046548.png) > 命令通道 ![image 20230721192352934](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046549.png) > 数据通道 ![image 20240108161638925](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081616052.png) ### 命令格式 ![image 20240108162018331](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081620450.png) ![image 20240108162128452](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081621574.png) ![image 20240108162219022](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081622133.png) ### 寄存器 ![image 20240108162249773](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081622892.png) + SDIO_POWER: 电源控制寄存器 ![image 20230721190317841](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046550.png) + SDIO_CLKCR: 时钟控制寄存器 ![image 20230721190414369](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046551.png) > 默认的时候使用的是1根总线, 初始化结束以后可以使用4位的模式 ![image 20240108170517958](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081705051.png) > 开始初始化的时候设置小于400KHz, 之后时钟频率小于25MHz + SDIO_ARG: 参数寄存器 ![image 20230721190452248](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046552.png) + SDIO_CMD: 命令寄存器 ![image 20230721190107858](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046553.png) > 一般位10设置为1, 使用状态机 > > 位6 7根据命令进行设置 > > 0 5代表要发送的命令 + SDIO_RESPCMD: 命令响应寄存器 ![image 20230721190552042](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046554.png) + SDIO_RESPx: 响应寄存器 ![image 20230721190709273](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046555.png) + SDIO_DTIMER: 数据定时器寄存器 ![image 20230721190745284](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046556.png) > 在写入数据控制器进行数据传输之前必须先写入数据定时器寄存器和数据长度寄存器 + SDIO_DLEN: 数据长度寄存器 ![image 20230721190820520](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046557.png) > 这个的数值必须是块数据长度的倍数 + SDIO_DCTRL: 数据控制寄存器 ![image 20230721190903000](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046558.png) > 块的长度设置为512字节 ![image 20240108171442596](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081714694.png) > 传输的时候使用的是块模式进行传输的 + SDIO_DCOUNT: 数据计数器寄存器 ![image 20230721190946068](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046559.png) + SDIO_STA: 状态寄存器 ![image 20240108171550273](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081715399.png) + SDIO_ICR: 清除中断寄存器 + SDIO_MASK: 中断屏蔽寄存器 + SDIO_FIFOCNT: 计数器寄存器 + SDIO_FIFO: FIFO寄存器, 数据缓冲 接收和发送FIFO是32位宽度读或写一组寄存器，它在连续的32个地址上包含32个寄存器，CPU可以使用FIFO读写多个操作数。 ![image 20240108171652567](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081716652.png) > 操作的时候需要以4字节对齐的内存进行操作 ## 使用 ```c typedef struct { uint32_t SDIO_ClockEdge; /*!< Specifies the clock transition on which the bit capture is made. This parameter can be a value of @ref SDIO_Clock_Edge 设置时钟的有效边沿*/ uint32_t SDIO_ClockBypass; /*!< Specifies whether the SDIO Clock divider bypass is enabled or disabled. This parameter can be a value of @ref SDIO_Clock_Bypass 时钟分频设置, 使能这直接SDIOCLK驱动CLK线, 禁用的话分品之后使用*/ uint32_t SDIO_ClockPowerSave; /*!< Specifies whether SDIO Clock output is enabled or disabled when the bus is idle. This parameter can be a value of @ref SDIO_Clock_Power_Save 是否使用节能模式*/ uint32_t SDIO_BusWide; /*!< Specifies the SDIO bus width. This parameter can be a value of @ref SDIO_Bus_Wide 数据的宽度, 一般设置为8位*/ uint32_t SDIO_HardwareFlowControl; /*!< Specifies whether the SDIO hardware flow control is enabled or disabled. This parameter can be a value of @ref SDIO_Hardware_Flow_Control 是否使能硬件控制FIFO*/ uint8_t SDIO_ClockDiv; /*!< Specifies the clock frequency of the SDIO controller. This parameter can be a value between 0x00 and 0xFF. 时钟分频, CLK时钟线的值 SDIOCLK/(CLKDIV+2)*/ } SDIO_InitTypeDef;//初始化 typedef struct { uint32_t SDIO_Argument; /*!< Specifies the SDIO command argument which is sent to a card as part of a command message. If a command contains an argument, it must be loaded into this register before writing the command to the command register 命令参数*/ uint32_t SDIO_CmdIndex; /*!< Specifies the SDIO command index. It must be lower than 0x40. 命令号*/ uint32_t SDIO_Response; /*!< Specifies the SDIO response type. This parameter can be a value of @ref SDIO_Response_Type 响应的类型*/ uint32_t SDIO_Wait; /*!< Specifies whether SDIO wait for interrupt request is enabled or disabled. This parameter can be a value of @ref SDIO_Wait_Interrupt_State 等待使能, 是否等待响应*/ uint32_t SDIO_CPSM; /*!< Specifies whether SDIO Command path state machine (CPSM) is enabled or disabled. This parameter can be a value of @ref SDIO_CPSM_State 命令路径状态机*/ } SDIO_CmdInitTypeDef;//发送命令 typedef struct { uint32_t SDIO_DataTimeOut; /*!< Specifies the data timeout period in card bus clock periods. \t\t\t\t\t\t\t 数据时钟超时, 多少时钟之后进入超时*/ uint32_t SDIO_DataLength; /*!< Specifies the number of data bytes to be transferred. 数据长度*/ uint32_t SDIO_DataBlockSize; /*!< Specifies the data block size for block transfer. This parameter can be a value of @ref SDIO_Data_Block_Size 数据块的大小*/ uint32_t SDIO_TransferDir; /*!< Specifies the data transfer direction, whether the transfer is a read or write. This parameter can be a value of @ref SDIO_Transfer_Direction 数据传输的方向*/ uint32_t SDIO_TransferMode; /*!< Specifies whether data transfer is in stream or block mode. This parameter can be a value of @ref SDIO_Transfer_Type 数据传输的模式, 数据块和数据流, 流是MMC卡*/ uint32_t SDIO_DPSM; /*!< Specifies whether SDIO Data path state machine (DPSM) is enabled or disabled. This parameter can be a value of @ref SDIO_DPSM_State 数据路径状态机*/ } SDIO_DataInitTypeDef;//用于数据发送接收 ``` ## 实际使用 ![image 20230724200731339](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046560.png) ![image 20230724201533241](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046561.png) 实际上程序是移植过来的 > 【固件库】STM32F10x_StdPeriph_Lib_V3.5.0\\STM32F10x_StdPeriph_Lib_V3.5.0\\Project\\STM32F10x_StdPeriph_Examples \\SDIO\\uSDCard下面的所有文件 > > 以及 > > 【固件库】STM32F10x_StdPeriph_Lib_V3.5.0\\【固件库】STM32F10x_StdPeriph_Lib_V3.5.0\\Utilities\\STM32_EVAL\\Common下面的 > > ![image 20230725140935063](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046562.png) > > 还有【固件库】STM32F10x_StdPeriph_Lib_V3.5.0\\【固件库】STM32F10x_StdPeriph_Lib_V3.5.0\\Utilities\\STM32_EVAL\\STM3210E_EVAL的 > > ![image 20230725141119995](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281046563.png) > > > eval是评估板的名字 ## 使用 + 初始化中断优先级 ```c static void NVIC_Configuration(void) { NVIC_InitTypeDef NVIC_InitStructure; /* Configure the NVIC Preemption Priority Bits */ NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1); NVIC_InitStructure.NVIC_IRQChannel SDIO_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority 0; NVIC_InitStructure.NVIC_IRQChannelSubPriority 0; NVIC_InitStructure.NVIC_IRQChannelCmd ENABLE; NVIC_Init(&NVIC_InitStructure); } ``` + 初始化引脚, 以及DMA ```c static void GPIO_Configuration(void) { GPIO_InitTypeDef GPIO_InitStructure; /*!< GPIOC and GPIOD Periph clock enable */ RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC RCC_APB2Periph_GPIOD , ENABLE); /*!< Configure PC.08, PC.09, PC.10, PC.11, PC.12 pin: D0, D1, D2, D3, CLK pin */ GPIO_InitStructure.GPIO_Pin GPIO_Pin_8 GPIO_Pin_9 GPIO_Pin_10 GPIO_Pin_11 GPIO_Pin_12; GPIO_InitStructure.GPIO_Speed GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode GPIO_Mode_AF_PP; GPIO_Init(GPIOC, &GPIO_InitStructure); /*!< Configure PD.02 CMD line */ GPIO_InitStructure.GPIO_Pin GPIO_Pin_2; GPIO_Init(GPIOD, &GPIO_InitStructure); /*!< Enable the SDIO AHB Clock 初始化时钟*/ RCC_AHBPeriphClockCmd(RCC_AHBPeriph_SDIO, ENABLE); /*!< Enable the DMA2 Clock 使能DMA的时钟*/ RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA2, ENABLE); } ``` + SDIO恢复初始化(之前初始化的是引脚) ```c void SDIO_DeInit(void) { SDIO >POWER 0x00000000; SDIO >CLKCR 0x00000000; SDIO >ARG 0x00000000; SDIO >CMD 0x00000000; SDIO >DTIMER 0x00000000; SDIO >DLEN 0x00000000; SDIO >DCTRL 0x00000000; SDIO >ICR 0x00C007FF; SDIO >MASK 0x00000000; } ``` + 上电初始化 ```c /* * 函数名：SD_PowerON * 描述 ：确保SD卡的工作电压和配置控制时钟 * 输入 ：无 * 输出 ： SD_Error SD卡错误代码 * 成功时则为 SD_OK * 调用 ：在 SD_Init() 调用 */ SD_Error SD_PowerON(void) { SD_Error errorstatus SD_OK; uint32_t response 0, count 0, validvoltage 0; uint32_t SDType SD_STD_CAPACITY; \t /********************************************************************************************************/ /* 上电初始化 * 配置SDIO的外设 * SDIOCLK HCLK, SDIO_CK HCLK/(2 + SDIO_INIT_CLK_DIV) * 初始化时的时钟不能大于400KHz */ \t/* HCLK 72MHz, SDIOCLK 72MHz, SDIO_CK HCLK/(178 + 2) 400 KHz */ SDIO_InitStructure.SDIO_ClockDiv SDIO_INIT_CLK_DIV;\t\t \t//时钟的有效边沿 SDIO_InitStructure.SDIO_ClockEdge SDIO_ClockEdge_Rising; \t \t/* 不使用bypass模式，直接用HCLK进行分频得到SDIO_CK, 这时候输出的时钟是根据分频因子配置的, 使能的话不进行分频*/ SDIO_InitStructure.SDIO_ClockBypass SDIO_ClockBypass_Disable; \t/* 空闲时不关闭时钟电源 */ SDIO_InitStructure.SDIO_ClockPowerSave SDIO_ClockPowerSave_Disable; \t \t/* 初始化的时候暂时先把数据线配置成1根 */ SDIO_InitStructure.SDIO_BusWide SDIO_BusWide_1b; \t \t/* 失能硬件流控制 MMC卡的*/ SDIO_InitStructure.SDIO_HardwareFlowControl SDIO_HardwareFlowControl_Disable; \t SDIO_Init(&SDIO_InitStructure); /* 开启SDIO外设的电源 */ SDIO_SetPowerState(SDIO_PowerState_ON); /* 使能 SDIO 时钟 */ SDIO_ClockCmd(ENABLE); /********************************************************************************************************/ /* 下面发送一系列命令,开始卡识别流程 * CMD0: GO_IDLE_STATE(复位所以SD卡进入空闲状态) * 没有响应 \t */ SDIO_CmdInitStructure.SDIO_Argument 0x0; SDIO_CmdInitStructure.SDIO_CmdIndex SD_CMD_GO_IDLE_STATE; \t \t/* 没有响应 */ SDIO_CmdInitStructure.SDIO_Response SDIO_Response_No; \t \t/* 关闭等待中断 */ SDIO_CmdInitStructure.SDIO_Wait SDIO_Wait_No; \t \t/* 则CPSM在开始发送命令之前等待数据传输结束 */ SDIO_CmdInitStructure.SDIO_CPSM SDIO_CPSM_Enable; SDIO_SendCommand(&SDIO_CmdInitStructure);\t \t\t \t \t/* 检测是否正确接收到cmd0 */ errorstatus CmdError(); \t \t/* 命令发送出错，返回 */ if (errorstatus ! SD_OK)\t { /* CMD Response TimeOut (wait for CMDSENT flag) */ return(errorstatus); } /********************************************************************************************************/ /* CMD8: SEND_IF_COND * Send CMD8 to verify SD card interface operating condition \t * * Argument: [31:12]: Reserved (shall be set to '0') * [11:8] : Supply Voltage (VHS) 0x1 (Range: 2.7 3.6 V) * [7:0] : Check Pattern (recommended 0xAA) * CMD Response: R7 \t */ \t /* 接收到命令sd会返回这个参数 */ SDIO_CmdInitStructure.SDIO_Argument SD_CHECK_PATTERN; \t//命令8, 测试卡的类型 SDIO_CmdInitStructure.SDIO_CmdIndex SDIO_SEND_IF_COND;\t SDIO_CmdInitStructure.SDIO_Response SDIO_Response_Short;\t SDIO_CmdInitStructure.SDIO_Wait SDIO_Wait_No;\t\t\t \t\t\t\t SDIO_CmdInitStructure.SDIO_CPSM SDIO_CPSM_Enable; SDIO_SendCommand(&SDIO_CmdInitStructure); /*检查是否接收到命令*/ errorstatus CmdResp7Error(); \t \t/* 有响应则card遵循sd协议2.0版本 */ if (errorstatus SD_OK)\t \t { \t\t/* SD Card 2.0 ，先把它定义会sdsc类型的卡 */ CardType SDIO_STD_CAPACITY_SD_CARD_V2_0; \t\t \t\t/* 这个变量用作ACMD41的参数，用来询问是sdsc卡还是sdhc卡 */ SDType SD_HIGH_CAPACITY;\t } else\t/* 无响应，说明是1.x的或mmc的卡 */ { /* 发命令 CMD55 */\t SDIO_CmdInitStructure.SDIO_Argument 0x00; SDIO_CmdInitStructure.SDIO_CmdIndex SD_CMD_APP_CMD; SDIO_CmdInitStructure.SDIO_Response SDIO_Response_Short; SDIO_CmdInitStructure.SDIO_Wait SDIO_Wait_No; SDIO_CmdInitStructure.SDIO_CPSM SDIO_CPSM_Enable; SDIO_SendCommand(&SDIO_CmdInitStructure); errorstatus CmdResp1Error(SD_CMD_APP_CMD); } \t /* CMD55 \t\t * 发送cmd55，用于检测是sd卡还是mmc卡，或是不支持的卡 \t * CMD 响应: R1 */ SDIO_CmdInitStructure.SDIO_Argument 0x00; SDIO_CmdInitStructure.SDIO_CmdIndex SD_CMD_APP_CMD; SDIO_CmdInitStructure.SDIO_Response SDIO_Response_Short; SDIO_CmdInitStructure.SDIO_Wait SDIO_Wait_No; SDIO_CmdInitStructure.SDIO_CPSM SDIO_CPSM_Enable; SDIO_SendCommand(&SDIO_CmdInitStructure); \t \t/* 是否响应，没响应的是mmc或不支持的卡 */ errorstatus CmdResp1Error(SD_CMD_APP_CMD);\t /********************************************************************************************************/ /* If errorstatus is Command TimeOut, it is a MMC card * If errorstatus is SD_OK it is a SD card: SD card 2.0 (voltage range mismatch) * or SD card 1.x \t */ if (errorstatus SD_OK)\t//响应了cmd55，是sd卡，可能为1.x,可能为2.0 { \t/*下面开始循环地发送sdio支持的电压范围，循环一定次数*/ /* SD CARD * Send ACMD41 SD_APP_OP_COND with Argument 0x80100000 \t\t */ while ((!validvoltage) && (count < SD_MAX_VOLT_TRIAL)) {\t \t\t\t/* 在发送ACMD命令前都要先向卡发送CMD55 * SEND CMD55 APP_CMD with RCA as 0 \t\t\t */ SDIO_CmdInitStructure.SDIO_Argument 0x00; SDIO_CmdInitStructure.SDIO_CmdIndex SD_CMD_APP_CMD;\t SDIO_CmdInitStructure.SDIO_Response SDIO_Response_Short; SDIO_CmdInitStructure.SDIO_Wait SDIO_Wait_No; SDIO_CmdInitStructure.SDIO_CPSM SDIO_CPSM_Enable; SDIO_SendCommand(&SDIO_CmdInitStructure); errorstatus CmdResp1Error(SD_CMD_APP_CMD); \t\t\t if (errorstatus ! SD_OK) { return(errorstatus); } \t\t\t \t\t\t/* ACMD41 \t\t\t * 命令参数由支持的电压范围及HCS位组成，HCS位置一来区分卡是SDSC还是SDHC \t\t\t * 0:SDSC \t\t\t * 1:SDHC * 响应：R3,对应的是OCR寄存器\t\t\t \t\t\t */\t\t\t SDIO_CmdInitStructure.SDIO_Argument SD_VOLTAGE_WINDOW_SD SDType;\t SDIO_CmdInitStructure.SDIO_CmdIndex SD_CMD_SD_APP_OP_COND; SDIO_CmdInitStructure.SDIO_Response SDIO_Response_Short; SDIO_CmdInitStructure.SDIO_Wait SDIO_Wait_No; SDIO_CmdInitStructure.SDIO_CPSM SDIO_CPSM_Enable; SDIO_SendCommand(&SDIO_CmdInitStructure); errorstatus CmdResp3Error(); \t\t\t if (errorstatus ! SD_OK) { return(errorstatus); } \t\t\t \t\t\t/* 若卡需求电压在SDIO的供电电压范围内，会自动上电并标志pwr_up位 \t\t\t * 读取卡寄存器，卡状态 \t\t\t */ response SDIO_GetResponse(SDIO_RESP1); \t\t\t \t\t\t/* 读取卡的ocr寄存器的pwr_up位，看是否已工作在正常电压 */ validvoltage (((response >> 31) 1) ? 1 : 0);\t count++;\t\t\t /* 计算循环次数 */ } \t\t if (count > SD_MAX_VOLT_TRIAL)\t\t\t\t\t /* 循环检测超过一定次数还没上电 */ { errorstatus SD_INVALID_VOLTRANGE;\t /* SDIO不支持card的供电电压 */ return(errorstatus); } \t\t \t\t/*检查卡返回信息中的HCS位*/ \t\t/* 判断ocr中的ccs位 ，如果是sdsc卡则不执行下面的语句 */ if (response & SD_HIGH_CAPACITY) { CardType SDIO_HIGH_CAPACITY_SD_CARD; /* 把卡类型从初始化的sdsc型改为sdhc型 */ } }/* else MMC Card */ return(errorstatus);\t\t } ``` ```c /* * 函数名：SD_InitializeCards * 描述 ：初始化所有的卡或者单个卡进入就绪状态 * 输入 ：无 * 输出 ： SD_Error SD卡错误代码 * 成功时则为 SD_OK * 调用 ：在 SD_Init() 调用，在调用power_on（）上电卡识别完毕后，调用此函数进行卡初始化 */ SD_Error SD_InitializeCards(void) { SD_Error errorstatus SD_OK; uint16_t rca 0x01; \t//检测是不是处于掉电状态 if (SDIO_GetPowerState() SDIO_PowerState_OFF) { errorstatus SD_REQUEST_NOT_APPLICABLE; return(errorstatus); } \t \t/* 判断卡的类型,不是数字类卡(是储存卡) */ if (SDIO_SECURE_DIGITAL_IO_CARD ! CardType) { /* Send CMD2 ALL_SEND_CID \t\t * 响应：R2，对应CID寄存器 \t\t */ SDIO_CmdInitStructure.SDIO_Argument 0x0; SDIO_CmdInitStructure.SDIO_CmdIndex SD_CMD_ALL_SEND_CID; SDIO_CmdInitStructure.SDIO_Response SDIO_Response_Long; SDIO_CmdInitStructure.SDIO_Wait SDIO_Wait_No; SDIO_CmdInitStructure.SDIO_CPSM SDIO_CPSM_Enable; SDIO_SendCommand(&SDIO_CmdInitStructure); errorstatus CmdResp2Error(); if (SD_OK ! errorstatus) { return(errorstatus); } \t\t \t\t/* 将返回的CID信息存储起来 */ CID_Tab[0] SDIO_GetResponse(SDIO_RESP1); CID_Tab[1] SDIO_GetResponse(SDIO_RESP2); CID_Tab[2] SDIO_GetResponse(SDIO_RESP3); CID_Tab[3] SDIO_GetResponse(SDIO_RESP4); } /********************************************************************************************************/ if ( (SDIO_STD_CAPACITY_SD_CARD_V1_1 CardType) \t\t (SDIO_STD_CAPACITY_SD_CARD_V2_0 CardType) \t (SDIO_SECURE_DIGITAL_IO_COMBO_CARD CardType) (SDIO_HIGH_CAPACITY_SD_CARD CardType) )\t /* 使用的是2.0的卡 */ { /* Send CMD3 SET_REL_ADDR with argument 0 * SD Card publishes its RCA. * 响应：R6，对应RCA寄存器\t\t \t\t */ SDIO_CmdInitStructure.SDIO_Argument 0x00; SDIO_CmdInitStructure.SDIO_CmdIndex SD_CMD_SET_REL_ADDR;\t\t SDIO_CmdInitStructure.SDIO_Response SDIO_Response_Short;\t\t SDIO_CmdInitStructure.SDIO_Wait SDIO_Wait_No; SDIO_CmdInitStructure.SDIO_CPSM SDIO_CPSM_Enable; SDIO_SendCommand(&SDIO_CmdInitStructure); \t\t \t\t/* 把接收到的卡相对地址存起来 */ errorstatus CmdResp6Error(SD_CMD_SET_REL_ADDR, &rca);\t if (SD_OK ! errorstatus) { return(errorstatus); } } /********************************************************************************************************/ if (SDIO_SECURE_DIGITAL_IO_CARD ! CardType) { RCA rca; /* Send CMD9 SEND_CSD with argument as card's RCA \t\t * 响应:R2 对应寄存器CSD(Card Specific Data) \t\t */ SDIO_CmdInitStructure.SDIO_Argument (uint32_t)(rca << 16); SDIO_CmdInitStructure.SDIO_CmdIndex SD_CMD_SEND_CSD; SDIO_CmdInitStructure.SDIO_Response SDIO_Response_Long; SDIO_CmdInitStructure.SDIO_Wait SDIO_Wait_No; SDIO_CmdInitStructure.SDIO_CPSM SDIO_CPSM_Enable; SDIO_SendCommand(&SDIO_CmdInitStructure); errorstatus CmdResp2Error(); if (SD_OK ! errorstatus) { return(errorstatus); } CSD_Tab[0] SDIO_GetResponse(SDIO_RESP1); CSD_Tab[1] SDIO_GetResponse(SDIO_RESP2); CSD_Tab[2] SDIO_GetResponse(SDIO_RESP3); CSD_Tab[3] SDIO_GetResponse(SDIO_RESP4); } /********************************************************************************************************/\t \t/*全部卡初始化成功 */ errorstatus SD_OK; return(errorstatus); } ``` ## 移植 + 初始化diskio.c文件"},"/note/嵌入式/stm32/固件库/2023-12-6-30MPU.html":{"title":"MPU","content":" layout: post title: \"MPU\" date: 2023 7 13 15:39:08 +0800 tags: stm32 # MPU 内存保护单元 1. 设置不同存储区域的访问权限(特权级以及用户级) 2. 设置存储器(内存, 外存)的属性(可以缓存, 可缓冲, 可共享) 好处 1. 可以阻止用户的应用程序破坏操作系统的数据 2. 阻止一个任务访问其他的任务 3. 把关键位置的数据设置为只读, 根本上解决被破坏 4. 防止意外的地址访问, 比如说堆栈溢出, 数组越界等 5. 把SRAM和RAM空间定义为不可执行, 防止注入代码的攻击 > 提高兼容性 ![image 20231206100420079](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312061004150.png) > 背景区就是一个默认的设置 ![image 20231206100540414](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312061005468.png) ![image 20231206100711701](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312061007756.png) + 可缓冲, 可缓存 ![image 20231206100835405](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312061008456.png) > 可以减少数据的读写次数，如果每次数据只传输一点数据，就需要传送很多次，这样会浪费很多时间，因为开始读写与终止读写所需要的时间很长，如果将数据送往缓冲区，待缓冲区满后再进行传送会大大减少读写次数，这样就可以节省很多时间。 **缓存（cache）与缓冲(buffer)的主要区别** Buffer的核心作用是用来缓冲，缓和冲击。比如你每秒要写100次硬盘，对系统冲击很大，浪费了大量时间在忙着处理开始写和结束写这两件事嘛。用个buffer暂存起来，变成每10秒写一次硬盘，对系统的冲击就很小，写入效率高了，日子过得爽了。极大缓和了冲击。 Cache的核心作用是加快取用的速度。比如你一个很复杂的计算做完了，下次还要用结果，就把结果放手边一个好拿的地方存着，下次不用再算了。加快了数据取用的速度。 简单来说就是buffer偏重于写，而cache偏重于读。 + 可共享 ![image 20231206101050327](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312061010409.png) ![image 20231206101418935](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312061014002.png) ![image 20231206101720901](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312061017967.png) ![image 20231206101844426](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312061018484.png) ![image 20231206101909166](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312061019220.png) ![image 20231206101952790](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312061019851.png) ![image 20231206103453447](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312061034507.png) ## 寄存器 ![image 20231206103701911](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312061037959.png) > MPU在执行其功能时，是以所谓的“region”为单位的。一个region其实就是一段连续 的地址，只是它们的位置和范围都要满足一些限制（对齐方式，最小容量等）。CM3的MPU 共支持8个regions。怎么，嫌少？是少了点，不过，还允许把每个region进一步划分成更小 的“子region”。此外，还允许启用一个“背景region”（即没有MPU时的全部地址空间）， 不过它是只能由特权级享用。在启用MPU后，就不得再访问定义之外的地址区间，也不得访 问未经授权的region。否则，将以“访问违例”处理，触发MemManage fault。 MPU定义的regions可以相互交迭。如果某块内存落在多个region中，则访问属性和权限 将由编号最大的region来决定。比如，若1号region与4号region交迭，则交迭的部分受4号region 控制。 ![image 20231206103907960](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312061039020.png) > + M3 > > ![image 20231206104033355](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312061040389.png) ![image 20231206104100470](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312061041533.png) > 通过把PRIVDEFENA置位，可以在没有建立任何region就使能MPU的情况下，依然允许特 权级程序访问所有地址，而只有用户级程序被卡死。然而，如果设置了其它的region并且使 能了MPU，则背景region与这些region重合的部分，就要受各region的限制。 ![image 20231206104438293](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312061044354.png) > 要注意，只要没有极另类的考虑，就要要到万事就绪后，最后一步才置位ENABLE位。 否则，就有可能因region没有配置好而意外地产生MemManage fault。很多条件下，为安全 起见，最好在执行配置MPU的子程前先除能MPU，待执行后再重新使能MPU。 ![image 20231206104614459](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312061046494.png) ![image 20231206104637960](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312061046004.png) ![image 20231206104743665](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312061047732.png) ![image 20231206110859952](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312061109024.png) ![image 20231206110940256](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312061109323.png) ![image 20231206111411592](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312061114654.png) > 这几个策略对应上面的命中没有命中的时候的处理方式"},"/note/嵌入式/stm32/固件库/2023-6-26-8中断.html":{"title":"中断","content":" layout: post title: \"中断\" date: 2023 6 26 15:39:08 +0800 tags: stm32 # 中断 ![image 20231121195841744](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311211958814.png) 中断有优先级, 数字越小优先级越高 + 系统异常: 内核水平 + 外部中断: 外设水平 有10个系统异常, 60个外设中断, 对应一个中断向量表, 保存在启动文件里面 ![image 20230628180451294](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052469.png) ![image 20230628180512907](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052470.png) ## 控制NVIC NVIC: 嵌套向量中断控制器, 属于内核外设, 支持256个中断(16个内核中断, 240个外部中断), 最多支持256个优先级(可以剪裁), ST只使用了16个 ![image 20231121200314188](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311212003230.png) ![image 20231121201014795](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311212010837.png) > 还有一些中断挂起, 解挂, 激活标志位等不常用的功能寄存器 ### 工作原理 ![image 20231121201124666](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311212011712.png) > 首先判断中断是否开启, 之后根据AIRCR寄存器里面的分组方式进行控制进一步操作, 判断运行的顺序 > > 内核中断不通过外部寄存器的开关判断, 但是经过相同的评级 在文件STM32F10xxxx Cortex M3编程手册中 内核的寄存器定义在core_cm3.h文件 ```c typedef struct { __IO uint32_t ISER[8]; /*!< Offset: 0x000 Interrupt 使能寄存器 */ uint32_t RESERVED0[24]; __IO uint32_t ICER[8]; /*!< Offset: 0x080 Interrupt 清除 */ uint32_t RSERVED1[24]; __IO uint32_t ISPR[8]; /*!< Offset: 0x100 Interrupt 使能悬起 */ uint32_t RESERVED2[24]; __IO uint32_t ICPR[8]; /*!< Offset: 0x180 Interrupt 清除悬起 */ uint32_t RESERVED3[24]; __IO uint32_t IABR[8]; /*!< Offset: 0x200 Interrupt 有效位寄存器 */ uint32_t RESERVED4[56]; __IO uint8_t IP[240]; /*!< Offset: 0x300 Interrupt 中断优先级寄存器,8位有效 */ uint32_t RESERVED5[644]; __O uint32_t STIR; /*!< Offset: 0xE00 软件触发中断寄存器 */ } NVIC_Type; ``` > 经过裁剪之后STM公司把它放在misc.h文件中 ### 优先级设定 实际操作的是NVIC >IPRx寄存器, 一个寄存器8位 使用STM只使用高四位共64种, 又将它分为主优先级, 子优先级, 数字越小优先级越高, 都相等比较硬件中断编号 优先级分为抢占优先级以及响应优先级 > 抢占优先级可以对低优先级的中断函数进行打断 > > 响应优先级不能进行打断, 抢占优先级相同的时候响应优先级比较高的先执行 > > 优先级相同的时候通过自然优先级进行排序 优先级还会进行分组, 设置为五个组, 控制寄存器表示的方法(主优先级和子优先级分别由几位进行控制) ![image 20230628183435658](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052471.png) ## 编程顺序 + 请求使能中断 外设使能, 控制外设相关寄存器 + 总开关NVIC中断使能寄存器 + 配置优先级分组 有专门的函数进行配置 + 配置NVIC寄存器 ```c typedef struct { uint8_t NVIC_IRQChannel; /*!< Specifies the IRQ channel to be enabled or disabled. This parameter can be a value of @ref IRQn_Type (For the complete STM32 Devices IRQ Channels list, please refer to stm32f10x.h file) 配置要使能的中断*/ uint8_t NVIC_IRQChannelPreemptionPriority; /*!< Specifies the pre emption priority for the IRQ channel specified in NVIC_IRQChannel. This parameter can be a value between 0 and 15 as described in the table @ref 抢占优先级\t\t\t\t\t\t\t\t\t\t\t\t NVIC_Priority_Table 主优先级*/ uint8_t NVIC_IRQChannelSubPriority; /*!< Specifies the subpriority level for the IRQ channel specified in NVIC_IRQChannel. This parameter can be a value between 0 and 15 as described in the table @ref \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t NVIC_Priority_Table 次优先级*/ FunctionalState NVIC_IRQChannelCmd; /*!< Specifies whether the IRQ channel defined in NVIC_IRQChannel will be enabled or disabled. This parameter can be set either to ENABLE or DISABLE 内核控制器\t\t\t\t\t\t\t\t\t\t\t\t 是否同意产生中断*/ } NVIC_InitTypeDef; ``` + 编写中断服务函数 在中断向量表里面找到对应的函数名称 中断函数写错了会执行启动文件中的, 陷入循环, 函数全部在说stm32F10x_it.h文件中重新定义为空函数 ### 实际使用 使用寄存器SCB >AIRCR:PRIGROUP[10:8]\\(系统控制块(System Control Block))控制分组的模式 ## 实现GPIO中断(外部中断) ### EXTI EXTI(External interupt/event Controller外部中断/事件控制器)控制, 对应的是上面的中断函数中的EXTI触发的中断 在H7里面为Extended interupt/event Controller扩展中断事件控制器 有二十个产生事件.中断请求的边沿检测器, 即有二十个EXTI线(F1) > 中断和事件的理解: > > 中断: 进入NVIC, 有相应的中断处理函数, 需要CPU进行处理 > > 事件: 不进入NVIC, 只用于内部硬件的自动控制, 比如TIM, DMA, ADC ![image 20231121204307002](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311212043051.png) > H7里面有89条, 主要是各种的唤醒事件, 为的是降低功耗 #### 主要特性 + F1/F4/F7 每一条线都可以单独的进行配置, 选择触发的是事件还是中断, 触发的方式(上升沿, 下降沿, 双边沿触发), 支持软件触发, 开启/屏蔽, 有挂起状态位(中断) + H7系列 对EXTI产生的事件分为可配置事件以及直接事件 可配置事件跟上面的类似(来自产生脉冲的I/O或者外设的信号) 直接事件(来自其他的外设中断唤醒源, 需要再外设的中断进行清除): 固定上升沿触发, 不支持软件触发, 无挂起状态位(由其他的外设提供) #### 工作原理 + F1/F4/F7 ![image 20231123214517394](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311232145476.png) ![image 20230628193616469](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311251946266.png) > 中断为上面的一路, 最终的信号通入NVIC控制器 > > 事件为下面的一路 > > ①是输入线, EXTI有十九个中断/事件输入线, 输入线通过寄存器设置为任意一个GPIO, 也可以是一些外设的时间, 一般是存在电平变化的信号 > > ②是一个检测电路, 根据上升沿或下降沿选择寄存器, 对应的位设置控制信号触发, 测到有边沿跳变就左侧输出有效信号 1 给编号 3 电路，否则输出无效信号 0。 > > ③软件中断事件控制器EXTI_SWIER, 设置为1则与门设置为1, 之后会控制EXTI_PR寄存器对应的位为1设置为挂起, 之后会输出1 > > ④EXIT_IMR中断屏蔽寄存器控制位, 设置为1的时候开放请求 > > ⑤发送到内核产生中断 > > ⑥EXTI_EMR事件屏蔽寄存器控制, 写1使能, 来到脉冲发生器, 产生脉冲, 之后会触发ADC产生信号, 或触发定时器等 ![image 20231123214653457](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311232146526.png) > 下降沿触发选择寄存器(EXTI_FTSR)和上面的类似 ![image 20231123214757504](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311232147561.png) ![image 20231123214919899](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311232149953.png) + H7 ![image 20231123215123970](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311232151019.png) > PWR: 电源管理模块 ![image 20231123215640457](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311232156533.png) ### EXTI和实际的GPIO的对应(AFIO F1, SYSCFG F4/F7/H7) AFIO: 复用功能I/O和调试配置, 主要是用来进行重映射和外部中断的配置 1. 调试IO的配置: AFIO_MAPR[26:24], 配置JTAG和SWD的开关状态 2. 重映射配置: AFIO_MAPR, 部分外设IO的重映射配置 3. 外部中断配置: AFIO_EXTICR1 4, EXTI的每根线具体对应的IO > 配置之前需要使能时钟 SYSCFG: 系统时钟配置控制器, 用于外部中断的配置 使用的是SYSCFG_EXTICR1 4配置实际对应的具体IO > 配置之前也需要使能时钟 EXTI可以控制20根外部的终端线, 每个 GPIO 都可以被设置为输入线，占用 EXTI0 至 EXTI15，还有另 外七根用于特定的外设事件，见表 EXTI 中断 _ 事件线 。有十六根外部中断线连接到EXTI的一根线上 ![image 20230628200901595](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052474.png) ![image 20231125195051787](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311251950826.png) ### 固件库 使用EXIT_InitTypeDef函数进行实现 ```c typedef struct { uint32_t EXTI_Line; /*!< Specifies the EXTI lines to be enabled or disabled. This parameter can be any combination of @ref EXTI_Lines 设置产生中断的线实\t\t\t\t\t\t\t\t\t\t际上设置的是中断屏蔽寄存器*/ EXTIMode_TypeDef EXTI_Mode; /*!< Specifies the mode for the EXTI lines. This parameter can be a value of @ref EXTIMode_TypeDef设置为事件还是中断 */ EXTITrigger_TypeDef EXTI_Trigger; /*!< Specifies the trigger signal active edge for the EXTI lines. This parameter can be a value of @ref EXTIMode_TypeDef 设置出发的条件*/ FunctionalState EXTI_LineCmd; /*!< Specifies the new state of the selected EXTI lines. This parameter can be set either to ENABLE or DISABLE */ }EXTI_InitTypeDef; ``` > 这里控制的是上面的框图里面的寄存器 之后使用void GPIO_EXTILineConfig(uint8_t GPIO_PortSource, uint8_t GPIO_PinSource);函数进行设置实际使用的引脚 ### 思路总理 首先设置GPIO的触发中断的引脚使用函数GPIO_EXTILineConfig, 之后产生的信号会进入EXTI, 由EXTI初始化函数确定中断的进一步选择是触发中断还是产生事件, 最后进入NVIC在配置优先级之后会触发中断 1. 初始化引脚为输入, 打开时钟 2. 选择引脚复用, 由于属于引脚复用打开AFIO时钟(对寄存器AFIO_EVCR，AFIO_MAPR和AFIO_EXTICRX进行读写操作前，应当首先打开AFIO 的时钟。参考第6.3.7节APB2外设时钟使能寄存器(RCC_APB2ENR)。) 3. 初始化EXTI 4. 初始化NVIC ```c void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup) { //配置优先级分组 /* Check the parameters */ assert_param(IS_NVIC_PRIORITY_GROUP(NVIC_PriorityGroup)); /* Set the PRIGROUP[10:8] bits according to NVIC_PriorityGroup value */ SCB >AIRCR AIRCR_VECTKEY_MASK NVIC_PriorityGroup; } ``` 在初始化NVIC的通道的时候前四个EXTI有单独的通道, 后面的会使用这种定义 ![image 20230630154013370](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281052479.png) 区分不同的中断源需要进行相应的判断，通过取读EXTI >PR寄存器来判 5. 中断服务函数 首先检查中断标志位, 之后处理, 最后清除标志位 ```c //声明为静态函数, 只能在本文件中使用, 其他文件可以有同名字的函数, 如果声明的是变量之后不可以使用extern在其他文件调用 static void EXTI_NVIC_Config(void) { \tNVIC_PriorityGroupConfig(NVIC_PriorityGroup_1); \t \tNVIC_InitTypeDef NVIC_InitStructure; \tNVIC_InitStructure.NVIC_IRQChannel EXTI0_IRQn; \tNVIC_InitStructure.NVIC_IRQChannelPreemptionPriority 1; \tNVIC_InitStructure.NVIC_IRQChannelSubPriority 1; \tNVIC_InitStructure.NVIC_IRQChannelCmd ENABLE; \tNVIC_Init(&NVIC_InitStructure); } void EXTI_Key_config(void) { \t//开启时钟 \tRCC_APB2PeriphClockCmd(KEY1_GPIO_CLOCK, ENABLE); \t//初始化引脚 \tGPIO_InitTypeDef GPIO_InitStructure; \t//初始化NVIC \tEXTI_NVIC_Config(); \t \t \tGPIO_InitStructure.GPIO_Pin KEY1_GPIO_PIN; \tGPIO_InitStructure.GPIO_Mode GPIO_Mode_IN_FLOATING; \tGPIO_InitStructure.GPIO_Speed GPIO_Speed_10MHz; \t\t \tGPIO_Init(KEY1_GPIO_PORT, &GPIO_InitStructure); \t//复用引脚,选择输入线 \tRCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO, ENABLE); \tGPIO_EXTILineConfig(GPIO_PortSourceGPIOA, GPIO_PinSource0); \t//初始化引脚 \tEXTI_InitTypeDef EXTI_InitStruct; \tEXTI_InitStruct.EXTI_Line EXTI_Line0;\t//设置为EXTI0 \tEXTI_InitStruct.EXTI_LineCmd ENABLE;\t//使能 \tEXTI_InitStruct.EXTI_Mode EXTI_Mode_Interrupt;\t//设置为中断 \tEXTI_InitStruct.EXTI_Trigger EXTI_Trigger_Rising;//上升沿触发 \tEXTI_Init(&EXTI_InitStruct); } ``` > 连接多个引脚相同的时候可以检测IDR寄存器"},"/note/嵌入式/stm32/固件库/2023-7-29-25SRAM.html":{"title":"SRAM","content":" layout: post title: \"SRAM\" date: 2023 7 29 15:39:08 +0800 tags: stm32 # SRAM ## 内存管理 软件运行的时候对于MCU内存资源的分配使用 高效快速的分配, 在适当的时候释放回收内存资源, 尽量避免内存泄漏以及内存碎片 主要就是实现malloc和free 使用标准库的时候这两个函数会占用大量的代码空间, 不适合嵌入式, 并且没有线程安全的相关机制, 运行的时候有不确定性, 还会导致内存的碎片化 ### 分块内存管理 ![image 20240107201358723](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401072013836.png) ![image 20240107201513452](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401072015547.png) ![image 20240107201612660](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401072016744.png) ![image 20240107202156756](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401072021848.png) ## SRAM调试代码 + 优点 下载的速度比较快, 频繁改动的程序可以节省很多时间 stm32的擦写次数为1万次 不改写内部FLASH的原有程序 内部FLASH被锁定的芯片可以下载到RAM上, 进行解锁 对Flash解锁 + 使用外部SRAM 空间会增大,但是读取的速度会比内部Flash速度慢, 运行总时间增加, 并且无法从外部Flash启动, 并且复制的过程比较复杂 ## STM32的启动方式 首先从0地址去除栈指针的初始值, 就是栈顶指针的地址, 之后从0x00000004获取PC指针的初始值, 指向复位之后的第一条数据 这两个的值地址是可以映射的, 是通过引脚的电平进行设置的 ![image 20230730173646676](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281047228.png) > BOOT0是一个单独的引脚 > > BOOT1就是PB2 实际上就是内核在离开复位状态之后从映射的地址取得栈指针以及程序指针 > 系统存储器, 是一段特殊的程序, 用户不能访问, ST公司固化的代码, 在设置启动方式的时候会执行, 会检测USAT1/3, CAN2以及USB传过来的文件, 达到更新程序的目的, 在使用串口下载器的时候会使用USB进行设置引脚 ### 内部Flash的启动过程 在连接的时候会直接把文件定位在对应的位置 ## 使用SRAM调试 程序调试的时候是使用Debug, 复位需要重新加载Debug, 使用软件复位的话会加载flash里面的程序 + 设置一个SRAM调试的工程 + 修改sct文件 + 修改下载的配置, 程序下载到SRAM + 修改调试器配置, 初始化SP以及PC指针 ![image 20230731100107919](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281047229.png) > 新建一个工程 ![image 20230731100621342](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281047230.png) 共用文件使用单独的配置 ![image 20230731100822299](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281047231.png) ![image 20230731105112340](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281047232.png)** ![image 20230731110449806](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281047233.png) ![image 20230731110626691](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281047234.png) > 下载算法位置 修改中断向量表的位置 ![image 20230731111109013](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281047235.png) > 定义这个宏 ![image 20230731111958471](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281047236.png) ![image 20230731112149449](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281047237.png) 创建文件 ![image 20230731112303055](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202310281047238.png) > 添加文件, 强制配置Debug 这个文件是MDK的芯片包里面复制来的 ```c /* * Name: Dbg_RAM.ini * Purpose: RAM Debug Initialization File * Note(s): * * This file is part of the uVision/ARM development tools. * This software may only be used under the terms of a valid, current, * end user licence from KEIL for a compatible version of KEIL software * development tools. Nothing else gives you the right to use this software. * * This software is supplied \"AS IS\" without warranties of any kind. * * Copyright (c) 2008 2011 Keil An ARM Company. All rights reserved. * */ /* Setup() configure PC & SP for RAM Debug * */ FUNC void Setup (void) { //强制设置指针 SP _RDWORD(0x20000000); // Setup Stack Pointer PC _RDWORD(0x20000004); // Setup Program Counter //设置中断向量表 _WDWORD(0xE000ED08, 0x20000000); // Setup Vector Table Offset Register } FUNC void OnResetExec (void) { // executes upon software RESET Setup(); // Setup for Running } // 把axf文件加载到RAM load %L incremental Setup(); // Setup for Running调用上面的setup函数设置环境 //g, main\t不需要再跳转到 ```"},"/note/嵌入式/stm32/固件库/2023-11-29-27IWDG.html":{"title":"IWDG","content":" layout: post title: \"IWDG\" date: 2023 11 29 15:39:08 +0800 tags: stm32 # IWDG独立看门狗 Independent watchdog 本质实际上就是一个可以产生系统复位信号的计数器 IWDG是一个递减的计数器, 他的时钟是独立RC振荡器提供, 可以在待机或者停止的情况下运行, 看门狗被激活以后, 递减计数器计数到0的时候会产生复位 在计数器计数到0之前需要进行喂狗, 重装载计数器的值, 防止复位 ![image 20231129215628692](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311292156770.png) ## 作用 1. 异常, 外界的电磁干扰或者自身系统的硬件或者软件异常, 导致不正常的死循环, 打断程序正常运行 2. 作用, 用于检测外界电磁干扰, 或硬件异常导致的软件跑飞 3. 应用, 在一些需要高稳定性的产品, 对时间精度要求比较低的场景里面 > 异常处理的最后手段, 不可以依赖 ## 工作原理 ![image 20231129220230452](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311292202494.png) CPU必须及时喂狗 ![image 20231129220501933](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311292205013.png) ## 寄存器 + IWDG_KR密钥寄存器 ![image 20231129220634249](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311292206282.png) > 用于喂狗, 关闭写保护, 以及开启看门狗, 硬件看门狗介绍在用户闪存手册里面 ![image 20231129221328944](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311292213002.png) > 硬件看门狗 >硬件复位以后会由硬件自己启动看门狗, 不能关闭 > > 软件看门狗 >不会自己启动, 软件写入以后才会启动 ```c #define OB ((OB_TypeDef *)OB_BASE) ``` > 对应这一个寄存器 + IWDG_PR预分频器寄存器 ![image 20231130103146966](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311301031049.png) + IDWG_RLR重装载寄存器 ![image 20231130103323621](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311301033666.png) + IWDG_SR状态寄存器 ![image 20231130103416575](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311301034613.png) + IWDG_WINR(F1没有)窗口寄存器 十二位有效, 递减计数器低于设个寄存器的值的时候并且大于0的时候必须喂狗, 受到写保护, 实际上是缩短了喂狗的时间, 只有在这一个区间范围里面的时候才可以喂狗 ### 寄存器配置步骤 1. 通过在键寄存器 (IWDG_KR) 中写入 0xCCCC 来使能 IWDG。 2. 通过在键寄存器 (IWDG_KR) 中写入 0x5555 来使能寄存器访问。 3. 通过将预分频器寄存器 (IWDG_PR) 编程为 0~7 中的数值来配置预分频器。 4. 对重载寄存器 (IWDG_RLR) 进行写操作。 5. 等待寄存器更新 (IWDG_SR 0x0000 0000)。 6. 刷新计数器值为 IWDG_RLR 的值 (IWDG_KR 0xAAAA)。 ### 溢出计算 ![image 20231130104022547](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311301040609.png) + F1 ![image 20231130104108360](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311301041394.png) + F4F7H7 ![image 20231130104927619](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311301049662.png) ## 判断实际发生的复位类型 在RCC寄存器里面有一个RCC_CSR寄存器 ![image 20231130223152997](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311302231127.png)"},"/note/嵌入式/stm32/固件库/2023-12-22-33-RTC.html":{"title":"RTC","content":" layout: post title: \"RTC\" date: 2023 6 26 15:39:08 +0800 tags: stm32 # RTC 是一个实时时钟, 本质是一个计数器, 计数的频率是秒, 专门用于记录时间 ![image 20231222203329848](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312222033934.png) > 普通的定时器在掉电以后没有办法运行, RTC功耗比较低, 可以掉电运行 ![image 20231222203455625](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312222034680.png) > F1只能提供亚秒的信号 > > BCD码（Binary Coded Decimal‎），用4位二进制数来表示1位十进制数中的0~9这10个数码，是一种二进制的数字编码形式，用二进制编码的十进制代码。BCD码这种编码形式利用了四个位元来储存一个十进制的数码，使二进制和十进制之间的转换得以快捷的进行。 ![image 20231222204400889](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312222044980.png) ## 寄存器 + 后备寄存器和RTC寄存器的特性 ![image 20231222204609127](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312222046176.png) > 部分寄存器有写保护, 不会因为复位而被改变, 待机状态恢复的时候也不会被复位 ![image 20231222205000361](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312222050422.png) ![image 20231222205020081](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312222050142.png) ![image 20231222205035098](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312222050144.png) ![image 20231222205049979](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312222050032.png) ![image 20231222210124714](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312222101784.png) ![image 20231222210225012](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312222102143.png) ![image 20231222210247953](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312222102002.png) > 在计算出来当前的时间以后放到这个寄存器里面 ## F4/F7/H7RTC ![image 20231225201413631](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312252014700.png) ![image 20231225201841482](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312252018569.png) ![image 20231225202132761](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312252021820.png) ![image 20231225202441035](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312252024098.png) ![image 20231225202625646](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312252026711.png) ![image 20231225202900711](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312252029783.png) ![image 20231225203044858](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312252030915.png) ![image 20231225203159859](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312252031915.png) ![image 20231225203454582](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312252034642.png) ![image 20231225203513561](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312252035621.png) ![image 20231225203729276](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312252037339.png)"},"/note/嵌入式/stm32/HAL原子/2023-12-25-23RNG.html":{"title":"RNG","content":" layout: post title: \"RNG\" date: 2023 12 1 15:39:08 +0800 tags: HAL库 stm32 # RNG ![image 20231225222011781](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312252220843.png) ![image 20231225222329024](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312252223079.png)"},"/note/嵌入式/stm32/HAL原子/2023-11-12-07新建HAL库版本的工程.html":{"title":"新建HAL库版本的MDK工程","content":" layout: post title: \"新建HAL库版本的MDK工程\" date: 2023 11 11 15:39:08 +0800 tags: HAL库 stm32 # 新建HAL库版本的MDK工程 在官网搜索STM32Cube就可以找到了 + 新建文件夹 + 新建工程框架 + 添加文件 + 魔术棒设置 + 添加main.c ![image 20231112091435554](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311120914607.png) ![image 20231112091457649](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311120914702.png) ![image 20231112091724854](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311120917906.png) ![image 20231112093343853](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311120933906.png)"},"/note/嵌入式/stm32/HAL原子/2023-11-20-11GPIO.html":{"title":"GPIO","content":" layout: post title: \"GPIO\" date: 2023 20 18 15:39:08 +0800 tags: HAL库 stm32 # GPIO 基础知识看固件库相关的笔记 ## 四步模型 1. 初始化: 设置时钟, 设置参数(模式), IO设置, 中断设置(开中断, 设置NVIC) 2. 读函数: 从外设读取数据 3. 写函数: 向外设写入数据 4. 中断服务函数: 根据中断位处理各种中断 ## 配置步骤 1. 使能时钟\\_\\_HAL\\_RCC\\_GPIOx\\_CLK\\_ENABLE() 2. 设置工作模式 HAL_GPIO_Init() 3. 设置输出状态 HAL_GPIO_WritePin(), HAL_GPIO_TogglePin() 4. 读取状态HAL_GPIO_ReadPin() ![image 20231120181407191](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311201814268.png) ![image 20231120181518748](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311201815792.png) ```c #define __HAL_RCC_GPIOB_CLK_ENABLE() do { \\ __IO uint32_t tmpreg; \\ SET_BIT(RCC >APB2ENR, RCC_APB2ENR_IOPBEN);\\ /* Delay after an RCC peripheral clock enabling */\\ tmpreg READ_BIT(RCC >APB2ENR, RCC_APB2ENR_IOPBEN);\\ UNUSED(tmpreg); \\ } while(0U) ``` ## 点亮LED ![image 20231121095535691](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311210955733.png) > GPIO可以使用的模式, 推挽输出的时候可以实现, 使用推挽输出的由于没有办法输出高电平, 但是有高组态, 所以也可以使用 > > 如果使用共阴极的时候使用的是推挽才可以正常使用 ![image 20231121095638149](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311210956331.png) > 电流可以比较低只是亮度比较低 ## 重映射 以时钟作为例子 \\_\\_HAL_AFIO\\_REMAP\\_TIM3\\_PARTIAL()"},"/note/嵌入式/stm32/HAL原子/2023-12-21-20USMART.html":{"title":"USMART","content":" layout: post title: \"USMART\" date: 2023 12 1 15:39:08 +0800 tags: HAL库 stm32 # USMART 一个串口的调试组件, 可以用来提高代码的调试效率 可以调用大部分用户直接编写的函数, 按照格式放在注册表里面, 并且占用的资源比较少, 需要4KB的FLASH以及72B的SRAM 支持的参数种类比较多, 整形, 字符串, 函数指针 支持函数返回值的显示以及对格式进行显示 还可以计算函数执行的时间 通过用户输入的字符串和本地函数名, 通过函数指针调用不同的函数 ![image 20231221222152431](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312212221482.png) ![image 20231221222310192](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312212223233.png)"},"/note/嵌入式/stm32/HAL原子/2023-12-19-18LTDC.html":{"title":"LTDC","content":" layout: post title: \"LTDC\" date: 2023 12 1 15:39:08 +0800 tags: HAL库 stm32 # LTDC ![image 20231219225701692](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312192257755.png) ![image 20231220201229461](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312202012637.png) ![image 20231220201306434](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312202013525.png) ![image 20231220201325956](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312202013048.png) ![image 20231220202543106](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312202025183.png) ![image 20231220202816673](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312202028769.png) ![image 20231220203557475](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312202035535.png) ![image 20231220203858749](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312202038809.png) ![image 20231220215837944](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312202158058.png) ![image 20231220220003035](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312202200110.png) ![image 20231220220144191](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312202201276.png)"},"/note/嵌入式/stm32/HAL原子/2024-1-6-31内部Flash.html":{"title":"内部Flash","content":" layout: post title: \"内部Flash\" date: 2024 1 6 15:39:08 +0800 tags: HAL库 stm32 # 内部Flash ![image 20240106165340560](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401061655085.png)"},"/note/嵌入式/stm32/HAL原子/2023-12-22-21RTC.html":{"title":"RTC","content":" layout: post title: \"RTC\" date: 2023 12 1 15:39:08 +0800 tags: HAL库 stm32 # RTC ![image 20231222210634834](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312222106915.png) ## 实际使用F1 ![image 20231222211504564](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312222115640.png) ![image 20231222215514369](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312222155449.png) ## F4/F7/H7RTC ![image 20231225205141786](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312252051876.png) ![image 20231225205343346](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312252053430.png) ![image 20231225205522545](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312252055643.png) ![image 20231225205608674](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312252056772.png) ![image 20231225205700679](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312252057768.png) ![image 20231225205809135](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312252058199.png)"},"/note/嵌入式/stm32/HAL原子/2023-12-26-24电源管理.html":{"title":"电源管理","content":" layout: post title: \"电源管理\" date: 2023 12 26 15:39:08 +0800 tags: HAL库 stm32 # 电源管理 ![image 20231226204527267](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312262045344.png) ![image 20231226205333226](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312262053283.png) ![image 20231226205550995](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312262055061.png) ![image 20231226205732715](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312262057782.png) ![image 20231226205823753](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312262058800.png) ![image 20231226210004343](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312262100403.png) ![image 20231226210017612](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312262100665.png) ## PVD电源监控 ![image 20231227210225166](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312272103410.png) ![image 20231227210349205](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312272103275.png) ![image 20231227210450533](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312272104608.png)"},"/note/嵌入式/stm32/HAL原子/2023-12-28-25DMA.html":{"title":"DMA","content":" layout: post title: \"DMA\" date: 2023 12 28 15:39:08 +0800 tags: HAL库 stm32 # DMA ![image 20231228171432689](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312281714780.png) ![image 20231228171837378](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312281718451.png) ![image 20231228172111388](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312281721469.png) ## F4/F7/H7 ![image 20231228191303801](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312281913887.png) ![image 20231228191711202](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312281917268.png) ![image 20231228191744434](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312281917488.png)"},"/note/嵌入式/stm32/HAL原子/2024-1-1-28SPI.html":{"title":"SPI","content":" layout: post title: \"SPI\" date: 2024 1 1 15:39:08 +0800 tags: HAL库 stm32 # SPI ![image 20240101101731976](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401011017060.png) ![image 20240101102032778](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401011020867.png)"},"/note/嵌入式/stm32/HAL原子/2024-1-7-32DCMI.html":{"title":"DCMI","content":" layout: post title: \"DCMI\" date: 2024 1 7 15:39:08 +0800 tags: HAL库 stm32 # DCMI ![image 20240107130614564](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401071306634.png) ![image 20240107130818521](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401071308582.png) ![image 20240107131139229](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401071311290.png)"},"/note/嵌入式/stm32/HAL原子/2023-12-21-19DMA2D.html":{"title":"DMA2D","content":" layout: post title: \"DMA2D\" date: 2023 12 1 15:39:08 +0800 tags: HAL库 stm32 # DMA2D ![](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312211956324.png) ![image 20231221200844074](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312212008130.png)"},"/note/嵌入式/stm32/HAL原子/2023-12-1-16定时器.html":{"title":"WWDG","content":" layout: post title: \"WWDG\" date: 2023 12 1 15:39:08 +0800 tags: HAL库 stm32 # 定时器 ## 基本定时器 ![image 20231201195117247](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312011951303.png) ![image 20231201195219189](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312011952236.png) ![image 20231201195239509](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312011952554.png) > 基本定时器的计数模式和时钟分频因子是没有用的, 也没有重复计数器 ## 生成PWM ### 配置 ![image 20231202210853799](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312022148934.png) ![image 20231202211037959](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312022148041.png) ![image 20231202211147643](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312022148070.png) > PWM模式只需要设置前面三个 #### 实际的使用 ![image 20231202213837866](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312022148867.png) ## 测量脉冲长度 ![image 20231202221230514](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312031852724.png) ![image 20231202223150133](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312031852773.png) ![image 20231202223222103](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312031852872.png) ![image 20231202223417148](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312031852662.png) ## 捕获脉冲 ![image 20231203190002368](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312031900414.png) ![image 20231203190705953](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312031907034.png) ![image 20231203190746699](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312031907739.png) ## 高级定时器输出指定数量的PWM ![image 20231203195856354](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312031958413.png) ### 输出比较 ![image 20231203210128991](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312032101042.png) ![image 20231203210149474](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312032101521.png) ## 带死区的PWM输出 ![image 20231204154458900](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312041544963.png) ![image 20231204154539724](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312041545768.png) ![image 20231204154557967](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312041545020.png) > 比较极性就是有效电平, 空闲状态下的电平就是刹车以后得电平 ![image 20231204154619245](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312041546296.png) > 关闭状态就是定时器不工作时候的输出信号设置 > > 锁寄存器也不使用 > > 自动恢复会在下一个时钟更新事件以后恢复输出 > > ![image 20231204161502074](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312041615105.png) ## 捕获PWM ![image 20231204170107764](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312041701827.png) ![image 20231204170243714](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312041702761.png) ![image 20231204170300039](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312041703093.png) ![image 20231219193602286](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312191936380.png) ```c \tHAL_TIM_IC_Start_IT(&htim3, TIM_CHANNEL_1); \tHAL_TIM_IC_Start_IT(&htim2, TIM_CHANNEL_1); ``` > 开启的时候只打开了通道一的中断 ```c uint32_t ccrl_val1a 0, ccrl_val1b 0, frq1 0, ccrl_val2a 0, ccrl_val2b 0, frq2 0; float duty1 0, duty2 0; void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim){ \tif(htim >Instance TIM2) \t{ \t\tccrl_val1a HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);//获取捕获到的值 \t\tccrl_val1b HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_2); \t\t__HAL_TIM_SetCounter(htim, 0); \t\tfrq1 (80000000/80)/ccrl_val1a;//计算周期 \t\tduty1 (ccrl_val1b*1.0/ccrl_val1a)*100;//计算占空比 \t\tHAL_TIM_IC_Start(htim, TIM_CHANNEL_1);//重新使能通道 \t\tHAL_TIM_IC_Start(htim, TIM_CHANNEL_2); \t} \tif(htim >Instance TIM3) \t{ \t\tccrl_val2a HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1); \t\tccrl_val2b HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_2); \t\t__HAL_TIM_SetCounter(htim, 0); \t\tfrq2 (80000000/80)/ccrl_val2a; \t\tduty2 (ccrl_val2b*1.0/ccrl_val2a)*100; \t\tHAL_TIM_IC_Start(htim, TIM_CHANNEL_1); \t\tHAL_TIM_IC_Start(htim, TIM_CHANNEL_2); \t} } ``` ## 电容按键 ![image 20231205194310309](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312051943446.png) ![image 20231205195147621](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312051951772.png)"},"/note/嵌入式/stm32/HAL原子/2023-12-28-26ADC.html":{"title":"ADC","content":" layout: post title: \"ADC\" date: 2023 12 28 15:39:08 +0800 tags: HAL库 stm32 # ADC ## 单通道 ![image 20231229093138503](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312290931643.png) ![image 20231229093318645](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312290933697.png) ![image 20231229093347242](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312290933295.png) ![image 20231229093927466](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312290939494.png) ## 单通道使用DMA ![image 20231229101040567](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312291010618.png) ![image 20231229101125339](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312291011390.png) ![image 20231229101442416](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312291014463.png) ![image 20231229101536868](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312291015908.png) ## 温度传感器 在使用的时候在init函数里面会帮我们进行上电处理 ```c /* If ADC1 Channel_16 or Channel_17 is selected, enable Temperature sensor */ /* and VREFINT measurement path. */ if ((sConfig >Channel ADC_CHANNEL_TEMPSENSOR) (sConfig >Channel ADC_CHANNEL_VREFINT) ) { /* For STM32F1 devices with several ADC: Only ADC1 can access internal */ /* measurement channels (VrefInt/TempSensor). If these channels are */ /* intended to be set on other ADC instances, an error is reported. */ if (hadc >Instance ADC1) { //在这里设置使能位 if (READ_BIT(hadc >Instance >CR2, ADC_CR2_TSVREFE) RESET) { SET_BIT(hadc >Instance >CR2, ADC_CR2_TSVREFE); if ((sConfig >Channel ADC_CHANNEL_TEMPSENSOR)) { /* Delay for temperature sensor stabilization time */ /* Compute number of CPU cycles to wait for */ wait_loop_index (ADC_TEMPSENSOR_DELAY_US * (SystemCoreClock / 1000000U)); while(wait_loop_index ! 0U) { wait_loop_index ; } } } } else { /* Update ADC state machine to error */ SET_BIT(hadc >State, HAL_ADC_STATE_ERROR_CONFIG); tmp_hal_status HAL_ERROR; } } ```"},"/note/嵌入式/stm32/HAL原子/2023-11-30-14IWDG.html":{"title":"IWDG","content":" layout: post title: \"IWDG\" date: 2023 11 30 15:39:08 +0800 tags: HAL库 stm32 # IWDG ## 实际使用 1. 取消PR/RLR寄存器写保护，设置IWDG预分频系数和重装载值，启动IWDG, HAL_IWDG_Init() 2. 及时喂狗，即写入0xAAAA 到IWDG_KR, HAL_IWDG_Refresh() ![image 20231130105435284](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311301054355.png) ## 编程 ![image 20231130110501294](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311301105330.png) ## 问题 DAP调试器不拔掉的时候复位会出问题 ![image 20231130204635044](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311302046118.png) ![image 20231130204705403](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311302047430.png)"},"/note/嵌入式/stm32/HAL原子/2024-1-8-33SDIO.html":{"title":"SDIO","content":" layout: post title: \"SDIO\" date: 2024 1 8 15:39:08 +0800 tags: HAL库 stm32 # SDIO ![image 20240108172551183](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081725294.png) ![image 20240108172815508](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081728622.png) ![image 20240108173528534](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081735633.png) ![image 20240108173708163](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081737251.png) ![image 20240108173735251](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081737318.png) ![image 20240108173919853](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081739948.png) ![image 20240108174058731](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401081740823.png)"},"/note/嵌入式/stm32/HAL原子/2023-11-5-原理图设计.html":{"title":"原理图设计","content":" layout: post title: \"原理图设计\" date: 2023 11 5 15:39:08 +0800 tags: HAL库 stm32 # 原理图设计 ## 获取资料 [st.com/content/st_com/en.html](https://www.st.com/content/st_com/en.html) ![image 20231106164249579](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311061642608.png) ![image 20231106164225445](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311061642677.png) [意法半导体STM32/STM8技术社区 提供最新的ST资讯和技术交流 (stmcu.org.cn)](https://www.stmcu.org.cn/) 在资料下载里面进行下载 ![image 20231106164659623](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311061646763.png) ![image 20231106164721407](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311061647479.png) ## 引脚分类 STM32引脚类型： + 电源引脚: V开头 + 晶振引脚: OSC引脚, 有高速和低速的引脚 + 复位引脚: RST引脚 + 下载引脚: 有三种, JTAG, SW, 串口 + BOOT引脚: F1里面有两个 + GPIO引脚 ![image 20231106165448200](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311061654263.png) > 从正面的小圆圈开始逆时针进行排序 ![image 20231106165829059](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311061658114.png) ![image 20231106164811546](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311061648595.png) > JTAG和SWD可以进行调试以及下载, 串口只能进行下载 ![image 20231106164830961](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311061648015.png) ![image 20231106170234724](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311061702768.png) > 使用的引脚的控制, 有一个寄存器进行控制 ![image 20231106165229460](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311061652589.png) > 这一种封装的引脚从正面开始右下角的小圆圈对应的是A1, 顺时针1234, 逆时针ABCD > > 背面的小三角对应的就是正面的圆圈, 逆时针1234, 顺时针ABCD ## 电气特性 ![image 20231106170830469](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311061708522.png) ![image 20231106170840998](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311061708047.png) ## 最小系统 ![image 20231106171011983](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311061710028.png) ![image 20231106171111473](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311061711555.png) ![image 20231106171634552](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311061716637.png) ![image 20231106171651614](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311061716663.png) > 在上电的时候由于电容充电需要时间, 所以上电的时候也会进行复位 ![image 20231106171829087](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311061718134.png) ![image 20231106171923916](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311061719991.png) > 右侧使用的是一个贴片晶振 ![image 20231106172130146](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311061721216.png) ![image 20231106172330054](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311061723132.png) 一键下载电路, 在进行设置为DTR低电平, RTS高电平的时候会使得RESET引脚为低电平, 进行自动复位 ## I/O分配 优先分配特殊的IO, 之后分配通用IO, 最后进行微调, 为了方便不布线等"},"/note/嵌入式/stm32/HAL原子/2023-11-11-05创建工程.html":{"title":"创建工程","content":" layout: post title: \"创建工程\" date: 2023 11 11 15:39:08 +0800 tags: HAL库 stm32 # 创建工程 + Driver: 硬件相关的驱动 + + BSP: 存放开发板的板级支持包, 比如外设驱动 + CMSIS, 存放内核底层代码, 启动文件等 + SYSTEM: 存放正点原子系统级核心驱动代码 + Middlewares: 中间层文件 + Output: 工程输出文件 + Project: 存放MDK工程文件 + + DebugConfig: 调试文件 + 编译过程中的链接链表(可删除) + 调试信息(可删除) + User: 存放HAL库用户文件, main.c, 中断处理, 分散加载文件 编译器选择 ![image 20231111095152836](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311110951973.png) ![image 20231111095218863](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311110952913.png)"},"/note/嵌入式/stm32/HAL原子/2024-1-3-29QSPI.html":{"title":"QSPI","content":" layout: post title: \"QSPI\" date: 2024 1 3 15:39:08 +0800 tags: HAL库 stm32 # QSPI ![image 20240103145321978](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401031455414.png) ![image 20240103145438541](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401031454065.png)"},"/note/嵌入式/stm32/HAL原子/2023-12-13-17-FSMC.html":{"title":"FSMC","content":" layout: post title: \"FSMC\" date: 2023 12 13 15:39:08 +0800 tags: HAL库 stm32 # FSMC ```c HAL_StatusTypeDef HAL_SRAM_Init ( SRAM_HandleTypeDef *hsram, FSMC_NORSRAM_TimingTypeDef *Timing, FSMC_NORSRAM_TimingTypeDef *ExtTiming) ``` ![image 20231213224306990](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312132243053.png) ![image 20231213224410641](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312132244746.png) ![image 20231213224503140](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312132245238.png) ![image 20231213224728937](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312132247013.png) ![image 20231213224859098](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312132248181.png) ![image 20231213230238083](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312132302144.png) # FMC ## SDRAM ![image 20231215193708086](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312151938907.png) ![image 20231215193901158](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312151939235.png) ![image 20231215193922060](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312151939145.png) ![image 20231215193958148](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312151939237.png) ![image 20231215194440733](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312151944801.png) ![image 20231215194453895](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312151944944.png) ![image 20231215195355622](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312151953681.png) ![image 20231215195726103](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312151957162.png) ### 驱动步骤 首先需要配置FMC, 使能对应的时钟, 配置对应的I/O口 之后设置相关的参数, 控制参数以及时序参数, 调用HAL_SDRAM_Init实现 之后发送初始化序列, 时钟配置使能, 所有区域进行预充电, 设置自刷新次数, 配置模式寄存器 配置刷新的频率, HAL_SDRAM_ProgramRefresh函数 ## SRAM ![image 20231216120044081](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312161200150.png) ![image 20231216120111721](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312161201749.png) ![image 20231216120220578](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312161202675.png) ![image 20231216120244729](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312161202786.png) ![image 20231216143723995](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312161437065.png) ![image 20231216143800078](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312161438122.png) ### FLASH ![image 20231218201221161](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312182012224.png) ![image 20231218201315416](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312182013472.png) ![image 20231218201442438](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312182014498.png) ![image 20231218201501127](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312182015195.png) ![image 20231218201544914](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312182015970.png) ![image 20231218201612529](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312182016588.png)"},"/note/嵌入式/stm32/HAL原子/2024-1-4-30CAN.html":{"title":"CAN","content":" layout: post title: \"CAN\" date: 2024 1 3 15:39:08 +0800 tags: HAL库 stm32 # CAN ![image 20240104152508209](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041525308.png) ![image 20240104152750862](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041527939.png) ![image 20240104153437314](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041534402.png) ![image 20240104153638062](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041536122.png) ## 实际使用 ![image 20240104153729650](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401041537724.png)"},"/note/嵌入式/stm32/HAL原子/2024-1-8-34SDMMC.html":{"title":"SDMMC","content":" layout: post title: \"SDMMC\" date: 2024 1 8 15:39:08 +0800 tags: HAL库 stm32 # SDMMC ![image 20240108225109919](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401082251028.png) ![image 20240108225146350](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401082251435.png) ![image 20240108225304159](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202401082253253.png)"},"/note/嵌入式/stm32/HAL原子/2023-11-28-13USART.html":{"title":"USART","content":" layout: post title: \"USART\" date: 2023 11 28 15:39:08 +0800 tags: HAL库 stm32 # USART 设置为启动位一个, 必须为0, 8位有效数据, 没有校验位, 1位字长, 一个停止位 ## HAL库外设初始化MSP回调机制 在HAL库里面有很多的HAL_PPP_Init()的初始化函数, 用户需要使用这一个函数进行初始化, 之后这个函数会调用一个HAL_PPP_MspInit()函数, 一般是被\\_\\_weak进行修饰, 里面实际上什么都没有干, 需要用户自己实现 这个函数需要用户自己进行配置使用到的硬件, 比如说GPIO, NVIC, CLOCK等 当多个PPP外设同时使用MSP函数的时候, 比如说串口1和串口3都使用者一个函数的时候, 需要通过判断外设寄存器的基地址进行区分实际上初始化的是哪一个外设的硬件 当多个外设都是用到这一个函数的时候, 文件不好管理, 会使得代码比较乱 ![image 20231128202820168](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311282028224.png) 官方把所有的msp回调函数放在stm32f1xx_hal_msp.c文件里面, 但是不方便管理 ## 回调函数 ![image 20231128203359561](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311282033620.png) ![image 20231128203417044](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311282034097.png) ![image 20231128212511376](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311282125432.png) ## 实际使用 配置串口的工作参数, HAL_UART_Init() 串口底层的初始化HAL_UART_MspInit() 开启串口的异步接收中断HAL_UART_Receive_IT() 设置优先级以及使能中断HAL_NVIC_SetPriority(), HAL_NVIC_EnableIRQ() 编写中断服务函数 USARTx_IRQHandler() UARTx_IRQHandler() 串口数据发送: UART_DR寄存器, HAL_UART_Transmit() ### 函数介绍 ![image 20231128214358535](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311282143581.png) ```c HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size) ``` ```c void MX_USART1_UART_Init(void) { /* USER CODE BEGIN USART1_Init 0 */ /* USER CODE END USART1_Init 0 */ /* USER CODE BEGIN USART1_Init 1 */ /* USER CODE END USART1_Init 1 */ huart1.Instance USART1;//设置句柄 huart1.Init.BaudRate 115200; huart1.Init.WordLength UART_WORDLENGTH_8B; huart1.Init.StopBits UART_STOPBITS_1; huart1.Init.Parity UART_PARITY_NONE; huart1.Init.Mode UART_MODE_TX_RX; huart1.Init.HwFlowCtl UART_HWCONTROL_NONE; huart1.Init.OverSampling UART_OVERSAMPLING_16; if (HAL_UART_Init(&huart1) ! HAL_OK) { Error_Handler(); } /* USER CODE BEGIN USART1_Init 2 */ /* USER CODE END USART1_Init 2 */ } ``` ```c HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size) HAL_StatusTypeDef HAL_UART_Receive_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size) { /* Check that a Rx process is not already ongoing */ if (huart >RxState HAL_UART_STATE_READY) { if ((pData NULL) (Size 0U)) { return HAL_ERROR;//判断参数是否正确 } /* Process Locked */ __HAL_LOCK(huart); huart >pRxBuffPtr pData;\t//设置几个参数, 会在中断的处理函数里面用到 huart >RxXferSize Size; huart >RxXferCount Size; huart >ErrorCode HAL_UART_ERROR_NONE; huart >RxState HAL_UART_STATE_BUSY_RX; /* Process Unlocked */ __HAL_UNLOCK(huart); /* Enable the UART Parity Error Interrupt */ __HAL_UART_ENABLE_IT(huart, UART_IT_PE); /* Enable the UART Error Interrupt: (Frame error, noise error, overrun error) */ __HAL_UART_ENABLE_IT(huart, UART_IT_ERR); /* Enable the UART Data Register not empty Interrupt */ __HAL_UART_ENABLE_IT(huart, UART_IT_RXNE);\t//初始化接受非空中断 return HAL_OK; } else { return HAL_BUSY; } } ``` > 使用中断的方式接受指定字节的数据 > > ```c > /* Check that a Rx process is ongoing */ > if (huart >RxState HAL_UART_STATE_BUSY_RX) > { > if ((huart >Init.WordLength UART_WORDLENGTH_9B) && (huart >Init.Parity UART_PARITY_NONE)) > { > /*使用9bit模式的处理*/ > } > else > { > pdata8bits (uint8_t *) huart >pRxBuffPtr;//获取数据存储区 > pdata16bits NULL; > > if ((huart >Init.WordLength UART_WORDLENGTH_9B) ((huart >Init.WordLength UART_WORDLENGTH_8B) && (huart >Init.Parity UART_PARITY_NONE))) > { > *pdata8bits (uint8_t)(huart >Instance >DR & (uint8_t)0x00FF); > } > else > { > *pdata8bits (uint8_t)(huart >Instance >DR & (uint8_t)0x007F); > } > huart >pRxBuffPtr + 1U;//存储区移位 > } > > if ( huart >RxXferCount 0U) > {//没有数据了关闭中断 > /* Disable the UART Data Register not empty Interrupt */ > __HAL_UART_DISABLE_IT(huart, UART_IT_RXNE); > > /* Disable the UART Parity Error Interrupt */ > __HAL_UART_DISABLE_IT(huart, UART_IT_PE); > > /* Disable the UART Error Interrupt: (Frame error, noise error, overrun error) */ > __HAL_UART_DISABLE_IT(huart, UART_IT_ERR); > > /* Rx process is completed, restore huart >RxState to Ready */ > huart >RxState HAL_UART_STATE_READY; > > #if (USE_HAL_UART_REGISTER_CALLBACKS 1) > /*Call registered Rx complete callback*/ > huart >RxCpltCallback(huart); > #else > /*Call legacy weak Rx complete callback*/ > HAL_UART_RxCpltCallback(huart); > #endif /* USE_HAL_UART_REGISTER_CALLBACKS */ > > return HAL_OK; > } > return HAL_OK; > } > else > { > return HAL_BUSY; > } > ``` ```c HAL_StatusTypeDef HAL_UART_Receive(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout) ``` > 接收数据用一个死等的方式 ```c HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size, uint32_t Timeout) ``` > 发送数据 ```c HAL_StatusTypeDef HAL_UART_Transmit_IT(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size) ``` ```c HAL_StatusTypeDef HAL_UART_Transmit_DMA(UART_HandleTypeDef *huart, uint8_t *pData, uint16_t Size) ``` ## 原理图 ![image 20231129084955262](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311290849381.png) ![image 20231129085250966](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311290852030.png) ```c uint8_t g_rx_buffer[1]; /* HAL库使用的串口接收数据缓冲区 */ uint8_t g_usart1_rx_flag 0; /* 串口接收到数据标志 */ UART_HandleTypeDef g_uart1_handle; /* UART句柄 */ /* 串口1初始化函数 */ void usart_init(uint32_t baudrate) { g_uart1_handle.Instance USART1; g_uart1_handle.Init.BaudRate baudrate; g_uart1_handle.Init.WordLength UART_WORDLENGTH_8B; g_uart1_handle.Init.StopBits UART_STOPBITS_1; g_uart1_handle.Init.Parity UART_PARITY_NONE; g_uart1_handle.Init.HwFlowCtl UART_HWCONTROL_NONE; g_uart1_handle.Init.Mode UART_MODE_TX_RX; HAL_UART_Init(&g_uart1_handle); HAL_UART_Receive_IT(&g_uart1_handle, (uint8_t*)g_rx_buffer, 1);\t//在这里直接使用中断去收数据 } /* 串口MSP回调函数 */ void HAL_UART_MspInit(UART_HandleTypeDef *huart) { GPIO_InitTypeDef gpio_init_struct; if(huart >Instance USART1) /* 如果是串口1，进行串口1 MSP初始化 */ { __HAL_RCC_USART1_CLK_ENABLE(); __HAL_RCC_GPIOA_CLK_ENABLE(); gpio_init_struct.Pin GPIO_PIN_9; gpio_init_struct.Mode GPIO_MODE_AF_PP; /* 推挽式复用输出 */ gpio_init_struct.Speed GPIO_SPEED_FREQ_HIGH; /* 高速 */ HAL_GPIO_Init(GPIOA, &gpio_init_struct); /* 初始化串口1的TX引脚 */ gpio_init_struct.Pin GPIO_PIN_10; gpio_init_struct.Mode GPIO_MODE_AF_INPUT; /* 输入 */ gpio_init_struct.Pull GPIO_PULLUP; /* 上拉 */ HAL_GPIO_Init(GPIOA, &gpio_init_struct); /* 初始化串口1的RX引脚 */ HAL_NVIC_SetPriority(USART1_IRQn, 3, 3); HAL_NVIC_EnableIRQ(USART1_IRQn); } } /* 串口1中断服务函数 */ void USART1_IRQHandler(void) { HAL_UART_IRQHandler(&g_uart1_handle); HAL_UART_Receive_IT(&g_uart1_handle, (uint8_t*)g_rx_buffer, 1); } /* 串口数据接收完成回调函数 */ void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) { if(huart >Instance USART1) { g_usart1_rx_flag 1; } } ``` ```c int main(void) { HAL_Init(); /* 初始化HAL库 */ sys_stm32_clock_init(RCC_PLL_MUL9); /* 设置时钟,72M */ delay_init(72); /* 初始化延时函数 */ led_init(); /* 初始化LED */ usart_init(115200); /* 波特率设为115200 */ printf(\"请输入一个英文字符：\\r\\n\\r\\n\"); while(1) { if(g_usart1_rx_flag 1) { printf(\"您输入的字符为：\\r\\n\"); HAL_UART_Transmit(&g_uart1_handle, (uint8_t*)g_rx_buffer, 1, 1000); while(__HAL_UART_GET_FLAG(&g_uart1_handle, UART_FLAG_TC) ! 1); printf(\"\\r\\n\"); g_usart1_rx_flag 0; } else { delay_ms(10); } } } ``` ## 使用printf的原因 当波特率是115200的时候, 一秒钟发送的数据的115200/10bit的数据(有起始位结束位), 每一秒钟发送的数据的大概是11.25K数据, 发送一个数据大约需要89us, 发送11个数据就是接近1ms了 在实际的产品里面尽量不要使用这个函数"},"/note/嵌入式/stm32/HAL原子/2023-11-6-常用的开发工具.html":{"title":"常用的开发工具","content":" layout: post title: \"常用的开发工具\" date: 2023 11 6 15:39:08 +0800 tags: HAL库 stm32 # 常用的开发工具 ![image 20231106180608502](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311061806556.png) ![image 20231106180745537](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311061807596.png) 安装分为软件安装以及器件支持包的安装 [Keil Product Downloads](https://www.keil.com/download/product/) [Arm Keil Devices](https://www.keil.arm.com/devices/) 有的扩展Flash以后需要再下载一个扩展的算法放在MDK5.xx\\ARM\\Flash里面 ## 编译 ![image 20231107084820618](C:/Users/jinhua/AppData/Roaming/Typora/typora user images/image 20231107084820618.png) Code: Flash里面存放的是代码 RO Data: Flash只读数据, 一般是指const修饰的数据 RW Data: Flash和RAM初始值为非0的可读可写数据 ZI Data: SRAM初始值为0的可读可写数据 ## 串口下载 ![image 20231107092423821](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311070924909.png) 在不同的芯片里面通过设置BOOT引脚的状态可以开启bootloader进行串口下载, 不同芯片的串口支持的波特率不同, 下载的时候使用的是HEX文件 ![image 20231108090630878](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311080906940.png) > 模式0: 0x08000000 > > 模式1: ISP下载, 这里面有一个bootloader程序, 可以进行ISP下载一般使用的是串口1 > > 模式2: 内部的SRM一般是用来进行调试的 ![image 20231108090909230](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311080909258.png) 之后的芯片里面还支持其他的下载模式 ![image 20231108091144783](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311080911839.png) ![image 20231108091157908](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311080911940.png) ![image 20231108091329951](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311080913990.png) ![image 20231108091823635](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311080918659.png) > 一般情况下两个引脚都是直接接得地, 会直接进入正常的模式, 在使用一键下载的时候设置为DTR低电平进行复位, RTS高电平进Bootloader ![image 20231108092017985](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311080920018.png) > 不使用的时候的原理图 ## DAP下载 ![image 20231108092047241](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311080920332.png) > 支持JTAG和SWD模式 ![image 20231108093517259](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311080935308.png) ## 调试程序 Cortex M内核含有硬件调试模块，该模块可在取指(指令断点)或访问数据(数据断点)时停止。内核停止时，可以查询内核的内部状态和系统的外部状态。完成查询后，可恢复程序执行。 ![image 20231108094308690](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311080943736.png) ![image 20231108094424475](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311080944515.png) > 这几个引脚的使用以及释放的几种状态 > > F1系列可以通过AFIO_MAPR寄存器的SWJ_CFG[2:0]位来释放部分或者全部SWJ DP引脚 > > F4/F7/H7系列默认全部SWJ DP引脚为复用功能并映射到复用功能0（AF0） ![image 20231108094745368](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311080947414.png) ![image 20231108095410934](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311080954974.png) > 黄色的箭头会使得指向下一行要执行的程序 ![image 20231108100952746](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311081009786.png) ![image 20231108180756920](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311081807065.png) 在这里可以看到运行的时间 > 在结束仿真以后由于对中文的支持不友好, 路径里面存在中文的时候, 有断点的时候没有办法直接退出, 退出的时候需要把所有的断点删去或者换一个路径 ![image 20231108181301648](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311081813682.png) > ![image 20231108213918787](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311082139831.png) ![image 20231108213957860](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311082139888.png) 函数调用关系 ![image 20231108214122644](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311082141690.png) ![image 20231108214159140](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311082141197.png) ![image 20231108214709205](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311082147253.png) ![image 20231108215150944](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311082151993.png) > 调试断点的时候只是内核停止了, 外设会继续进行 > > 断点设置的时候考虑是否会打断正常的通讯 ## 代码美化 ![image 20231109110600610](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311091106691.png) > 添加自己的关键字 ![image 20231109110912514](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311091109556.png) > 设置保存在这里"},"/note/嵌入式/stm32/HAL原子/2023-11-12-09STM32CubeMX.html":{"title":"stm32CubeMX","content":" layout: post title: \"stm32CubeMX\" date: 2023 11 12 15:39:08 +0800 tags: HAL库 stm32 # stm32CubeMX 由于不同的芯片支持的固件包是不同的, 使用这一个工具可以快捷的进行配置 内部有一些示例, 中间层以及HAL库的文件 ![image 20231112195536292](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311121955317.png) > 管理固件包 ![image 20231112195519535](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311121955594.png) ## 用户使用手册 [STM32CubeMX STM32Cube初始化代码生成器 意法半导体STMicroelectronics](https://www.st.com/zh/development tools/stm32cubemx.html#documentation) 1. 创建工程, 选择芯片型号 2. 设置时钟模块HSE, LSE, MCO 3. 时钟系统配置PLL, SYSCLK, AHB, APB1, APB2 4. 外设配置 5. Cortex内核配置, DEBUG, NVIC 6. 生成源码 7. 编写用户程序 ![image 20231113160139739](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311131601926.png) ![image 20231113161329687](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311131613729.png) > 生成文件的时候选择不同的生成模式"},"/note/嵌入式/stm32/HAL原子/2023-11-9-03C语言知识.html":{"title":"C语言知识","content":" layout: post title: \"C语言知识\" date: 2023 11 9 15:39:08 +0800 tags: HAL库 stm32 # C语言知识 ## 使用stdint.h 里面定义了uint8_t等变量, 这是C99标准的一个文件 ^: 异或 0^0 0, 0^1 1, 1^0 1, 1^1 0 可以用来对某一个位进行翻转temp ^ 1<<6"},"/note/嵌入式/stm32/HAL原子/2023-11-18-10SYSTEN文件介绍.html":{"title":"SYSTEM文件介绍","content":" layout: post title: \"SYSTEM文件介绍\" date: 2023 11 18 15:39:08 +0800 tags: HAL库 stm32 # SYSTEM文件介绍 这个是正点原子用来快速构建文件的文件夹 + sys文件夹 + delay文件夹 + usart文件夹 ## sys文件 ![image 20231118215057588](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311182150666.png) ## delay文件 ![image 20231118215816142](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311182158181.png) 使用的SysTick定时器, 是一个包含在内核里面的计时器, 是一个24位的递减计数器 ![image 20231118223806792](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311182238846.png) > 第二个位段被stm32修改了, 变为分频器控制 ![image 20231118224359453](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311182243507.png) ```c //初始化延迟函数 //当使用ucos的时候,此函数会初始化ucos的时钟节拍 //SYSTICK的时钟固定为AHB时钟 //SYSCLK:系统时钟频率,单位是M(直接传入32就可以了) void delay_init(u8 SYSCLK) { #if SYSTEM_SUPPORT_OS \t\t\t\t\t\t//如果需要支持OS. \tu32 reload; #endif HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);//SysTick频率为HCLK \tfac_us SYSCLK;\t\t\t\t\t\t//不论是否使用OS,fac_us都需要使用 #if SYSTEM_SUPPORT_OS \t\t\t\t\t\t//如果需要支持OS. \treload SYSCLK;\t\t\t\t\t //每秒钟的计数次数 单位为K\t \treload* 1000000/delay_ostickspersec;\t//根据delay_ostickspersec设定溢出时间 \t\t\t\t\t\t\t\t\t\t\t//reload为24位寄存器,最大值:16777216,在72M下,约合0.233s左右\t \tfac_ms 1000/delay_ostickspersec;\t\t//代表OS可以延时的最少单位\t \tSysTick >CTRL SysTick_CTRL_TICKINT_Msk;//开启SYSTICK中断 \tSysTick >LOAD reload; \t\t\t\t\t//每1/OS_TICKS_PER_SEC秒中断一次\t \tSysTick >CTRL SysTick_CTRL_ENABLE_Msk; //开启SYSTICK #else #endif } ``` ![image 20231118224851848](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311182248876.png) > 第一行是为了清空设置 > > 第二行设置时钟源 > > 第三行设置一秒需要计数多少次的计算参数, 这时候的时钟频率是9MHz, 数9次就是1us ![image 20231118225416945](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311182254995.png) ![image 20231118230732411](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311182307443.png) ![image 20231118230910502](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311182309556.png) ```c //延时nus //nus为要延时的us数.\t //nus:0~190887435(最大值即2^32/fac_us@fac_us 22.5)\t void delay_us(u32 nus) {\t\t \tu32 ticks; \tu32 told,tnow,tcnt 0; \tu32 reload SysTick >LOAD;\t\t\t\t//LOAD的值\t \t \tticks nus*fac_us; \t\t\t\t\t\t//需要的节拍数 \ttold SysTick >VAL; \t\t\t\t//刚进入时的计数器值 \twhile(1) \t{ \t\ttnow SysTick >VAL;\t \t\tif(tnow! told) \t\t{\t \t\t\tif(tnow<told)tcnt+ told tnow;\t//这里注意一下SYSTICK是一个递减的计数器就可以了. \t\t\telse tcnt+ reload tnow+told;\t \t\t\ttold tnow; \t\t\tif(tcnt> ticks)break;\t\t\t//时间超过/等于要延迟的时间,则退出. \t\t} \t}; } ``` ```c //延时nms //nms:要延时的ms数 void delay_ms(u16 nms) { \tu32 i; \tfor(i 0;i<nms;i++) delay_us(1000); } ``` ## uart文件 + 避免使用半主机模式 简单说就是通过仿真器实现开发板在电脑上的输入输出 半主机模式（semi hosting mode）是一种调试方法，在这种模式下，单片机和主机之间可以实现双向通信，以便进行调试。半主机模式通过一组定义好的软件指令（如 SVC）来实现，这些指令通过程序控制生成异常。应用程序调用相应的半主机调用，然后调试代理处理该异常，最终将信息传输到主机，以便进行调试和分析。半主机模式通常用于调试程序或者进行单片机的初始启动和调试。但是使用半主机模式会增加程序开销和调试代理的复杂性，并且可能会影响程序的执行效率和稳定性。因此，在单片机设计中应尽量避免使用半主机模式，而应该选择更加稳定、高效的调试方法。 + 微库法 直接使用移植好的微库 + 代码法 一个预处理, 两个定义, 三个函数 1. 预处理是#pragma import(\\_\\_use\\_no_semihosting), 保证C库不使用半主机模式 2. 定义\\_\\_FILE\\_\\_结构体, 避免HAL库报错 3. 定义FILE_\\_stdio, 避免报错 4. 实现\\_\\_ttywrch, \\_sys\\_exit和\\_sys\\_command\\_string三个函数 ![image 20231119224207590](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311192242625.png) ```c ////////////////////////////////////////////////////////////////// //加入以下代码,支持printf函数,而不需要选择use MicroLIB\t #if 1 #pragma import(__use_no_semihosting) //标准库需要的支持函数 struct __FILE { \tint handle; }; FILE __stdout; //定义_sys_exit()以避免使用半主机模式 void _sys_exit(int x) { \tx x; } //重定义fputc函数 int fputc(int ch, FILE *f) { \twhile((USART1 >SR&0X40) 0);//循环发送,直到发送完毕 USART1 >DR (u8) ch; \treturn ch; } #endif ```"},"/note/嵌入式/stm32/HAL原子/2023-11-11-06初识HAL库.html":{"title":"初识HAL库","content":" layout: post title: \"初识HAL库\" date: 2023 11 11 15:39:08 +0800 tags: HAL库 stm32 # 初识HAL库 ## CMSIS微控制器软件接口标准 Crotex Microcontroller Software Interface Standard ARM和与其合作的芯片厂商共同制作的标准 到了用户手上就是一个CMSIS的包 ![image 20231111113342702](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311111133749.png) ST为了方便开发提供了三种库 1. 标准库 2. HAL库(硬件抽象层) 3. LL库(底层库) ![image 20231111113447528](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311111134563.png) ## STM32Cube固件包 ST公司针对上面的协议做出来的属于自己的固件包 ### 获取 [stm32Cube 工具与软件 Search STMicrocontrollers](https://www.st.com/content/st_com/zh/search.html#q stm32Cube t tools page 1) ![image 20231111113930381](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311111139404.png) ![image 20231111114208542](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311111142584.png) > 主要使用的是驱动源码, 中间文件, 以及开发板示例 ![image 20231111200242740](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311112002825.png) ![image 20231111200615647](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311112006686.png) ![image 20231111200707579](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311112007630.png) ![image 20231111200851786](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311112008839.png) > Device: 使用的是arm文件夹下面的文件, 前两个文件在include文件夹里面, 第三个文件在source文件夹里面, 而启动文件在source里面的arm下面 > > Include: 对应的是AC5编译器, AC6编译器, 两个版本共用, 编译器版本, 对应内核的, 以及内存保护的头文件 ## HAL库框架结构 ### 文件夹结构 ![image 20231111203240975](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311112032017.png) > inc和src里面的Legacy文件夹里面的文件是补充的文件 ![image 20231111203427945](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311112034999.png) > ex文件一般是用来区别不同芯片的同一个驱动的不同单独设置的 ![image 20231111204132237](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311112041287.png) ![image 20231111204815060](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311112048113.png) ![image 20231111204839618](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311112048667.png) ## 怎么使用HAL库 ### 基于CMSIS应用程序文件描述 ![image 20231111210007472](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311112100627.png) > 用户文件是参考了官方的例程 > > 官方会把所有的MSP_Init函数放到同一个文件里面 ![image 20231111211011559](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311112110719.png) ### 修改config文件 ![image 20231111211211304](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311112112339.png) > 1. 选择使用到的驱动, 不需要的注释掉 > 2. 对不使用的文件不进行移植 ![image 20231111213939532](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311112139559.png) > 定义晶振的频率 ### stm32f1xx_hal.c文件 ```c HAL_StatusTypeDef HAL_Init(void) { /* Configure Flash prefetch */ #if (PREFETCH_ENABLE ! 0) #if defined(STM32F101x6) defined(STM32F101xB) defined(STM32F101xE) defined(STM32F101xG) \\ defined(STM32F102x6) defined(STM32F102xB) \\ defined(STM32F103x6) defined(STM32F103xB) defined(STM32F103xE) defined(STM32F103xG) \\ defined(STM32F105xC) defined(STM32F107xC) /* Prefetch buffer is not available on value line devices */ __HAL_FLASH_PREFETCH_BUFFER_ENABLE(); #endif #endif /* PREFETCH_ENABLE */ /* Set Interrupt Group Priority */ HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_2); //设置优先级分组2 /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */ HAL_InitTick(TICK_INT_PRIORITY); /* Init the low level hardware */ HAL_MspInit(); /* Return function status */ return HAL_OK; } ``` > f1里面有一个预取缓冲区, 有两个64位组成的, 在复位以后会打开, 加快程序的运行 > > 之后设置中断优先级的分组 > > 使能系统的滴答定时器, 设置为1Ms, 作为系统的时钟源 ### 使用注意 出现问题的时候需要去检查寄存器的操作 尽量不要通过修改库的源码实现功能 HAL库有可能出现错误 有的API函数效率过低, 可以通过直接操作寄存器进行操作"}}