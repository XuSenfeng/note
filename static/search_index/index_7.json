{"/note/网络/协议/2025-3-13-websocket.html":{"title":"WebSocket","content":"# WebSocket 传统的HTTP协议是一个单向的通信, 用于实时协议, 开始的时候使用HTTP, 但是后续保持TCP连接, 请求的时候使用的是ws或者wss(对应http/https) ``` GET / HTTP/1.1 Host: localhost:8080 Origin: http://127.0.0.1:3000 Connection: Upgrade Upgrade: websocket Sec WebSocket Version: 13 Sec WebSocket Key: w4v7O6xFTi36lq3RNcgctw ``` 只可以使用GET请求 `Connection: Upgrade`：表示要升级协议 `Upgrade: websocket`：表示要升级到websocket协议。 `Sec WebSocket Version: 13`：表示websocket的版本。如果服务端不支持该版本，需要返回一个`Sec WebSocket Version`header，里面包含服务端支持的版本号。 `Sec WebSocket Key`：与后面服务端响应首部的`Sec WebSocket Accept`是配套的，提供基本的防护，比如恶意的连接，或者无意的连接。 服务端响应 ``` HTTP/1.1 101 Switching Protocols Connection:Upgrade Upgrade: websocket Sec WebSocket Accept: Oy4NRAQ13jhfONC7bP8dTKb4PTU ``` 101是切换协议 > 备注：每个header都以`\\r\\n`结尾，并且最后一行加上一个额外的空行`\\r\\n`。此外，服务端回应的HTTP状态码只能在握手阶段使用。过了握手阶段后，就只能采用特定的错误码。 `Sec WebSocket Accept`根据客户端请求首部的`Sec WebSocket Key`计算出来。 计算公式为： 1. 将`Sec WebSocket Key`跟`258EAFA5 E914 47DA 95CA C5AB0DC85B11`拼接。 2. 通过SHA1计算出摘要，并转成base64字符串。 ## 数据帧格式 1. 从左到右，单位是比特。比如`FIN`、`RSV1`各占据1比特，`opcode`占据4比特。 2. 内容包括了标识、操作代码、掩码、数据、数据长度等。（下一小节会展开） ``` 0 1 2 3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 + + + + + + + + + FRRR opcodeM Payload len Extended payload length ISSS (4) A (7) (16/64) NVVV S (if payload len 126/127) 123 K + + + + + + + + + Extended payload length continued, if payload len 127 + + + Masking key, if MASK set to 1 + + + Masking key (continued) Payload Data + + : Payload Data continued ... : + + Payload Data continued ... + + ``` **FIN**：1个比特。 如果是1，表示这是消息（message）的最后一个分片（fragment），如果是0，表示不是是消息（message）的最后一个分片（fragment）。 **RSV1, RSV2, RSV3**：各占1个比特。 一般情况下全为0。当客户端、服务端协商采用WebSocket扩展时，这三个标志位可以非0，且值的含义由扩展进行定义。如果出现非零的值，且并没有采用WebSocket扩展，连接出错。 **Opcode**: 4个比特。 操作代码，Opcode的值决定了应该如何解析后续的数据载荷（data payload）。如果操作代码是不认识的，那么接收端应该断开连接（fail the connection）。可选的操作代码如下： %x0：表示一个延续帧。当Opcode为0时，表示本次数据传输采用了数据分片，当前收到的数据帧为其中一个数据分片。 %x1：表示这是一个文本帧（frame） %x2：表示这是一个二进制帧（frame） %x3 7：保留的操作代码，用于后续定义的非控制帧。 %x8：表示连接断开。 %x9：表示这是一个ping操作。 %xA：表示这是一个pong操作。 %xB F：保留的操作代码，用于后续定义的控制帧。 **Mask**: 1个比特。 表示是否要对数据载荷进行掩码操作。从客户端向服务端发送数据时，需要对数据进行掩码操作；从服务端向客户端发送数据时，不需要对数据进行掩码操作。 如果服务端接收到的数据没有进行过掩码操作，服务端需要断开连接。 如果Mask是1，那么在Masking key中会定义一个掩码键（masking key），并用这个掩码键来对数据载荷进行反掩码。所有客户端发送到服务端的数据帧，Mask都是1。 **Payload length**：数据载荷的长度，单位是字节。为7位，或7+16位，或1+64位。 假设数Payload length x，如果 x为0~126：数据的长度为x字节。 x为126：后续2个字节代表一个16位的无符号整数，该无符号整数的值为数据的长度。 x为127：后续8个字节代表一个64位的无符号整数（最高位为0），该无符号整数的值为数据的长度。 此外，如果payload length占用了多个字节的话，payload length的二进制表达采用网络序（big endian，重要的位在前）。 **Masking key**：0或4字节（32位） 所有从客户端传送到服务端的数据帧，数据载荷都进行了掩码操作，Mask为1，且携带了4字节的Masking key。如果Mask为0，则没有Masking key。 备注：载荷数据的长度，不包括mask key的长度。 **Payload data**：(x+y) 字节 载荷数据：包括了扩展数据、应用数据。其中，扩展数据x字节，应用数据y字节。 扩展数据：如果没有协商使用扩展的话，扩展数据数据为0字节。所有的扩展都必须声明扩展数据的长度，或者可以如何计算出扩展数据的长度。此外，扩展如何使用必须在握手阶段就协商好。如果扩展数据存在，那么载荷数据长度必须将扩展数据的长度包含在内。 应用数据：任意的应用数据，在扩展数据之后（如果存在扩展数据），占据了数据帧剩余的位置。载荷数据长度 减去 扩展数据长度，就得到应用数据的长度。 ## 掩码计算 掩码键（Masking key）是由客户端挑选出来的32位的随机数。掩码操作不会影响数据载荷的长度。掩码、反掩码操作都采用如下算法： 首先，假设： original octet i：为原始数据的第i字节。 transformed octet i：为转换后的数据的第i字节。 j：为`i mod 4`的结果。 masking key octet j：为mask key第j字节。 算法描述为： original octet i 与 masking key octet j 异或后，得到 transformed octet i。 ## 数据传递 一旦WebSocket客户端、服务端建立连接后，后续的操作都是基于数据帧的传递。 WebSocket根据`opcode`来区分操作的类型。比如`0x8`表示断开连接，`0x0` `0x2`表示数据交互。 1. 数据分片 WebSocket的每条消息可能被切分成多个数据帧。当WebSocket的接收方收到一个数据帧时，会根据`FIN`的值来判断，是否已经收到消息的最后一个数据帧。 FIN 1表示当前数据帧为消息的最后一个数据帧，此时接收方已经收到完整的消息，可以对消息进行处理。FIN 0，则接收方还需要继续监听接收其余的数据帧。 此外，`opcode`在数据交换的场景下，表示的是数据的类型。`0x01`表示文本，`0x02`表示二进制。而`0x00`比较特殊，表示延续帧（continuation frame），顾名思义，就是完整消息对应的数据帧还没接收完。 2. 数据分片例子 直接看例子更形象些。下面例子来自[MDN](https://developer.mozilla.org/en US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers)，可以很好地演示数据的分片。客户端向服务端两次发送消息，服务端收到消息后回应客户端，这里主要看客户端往服务端发送的消息。 **第一条消息** FIN 1, 表示是当前消息的最后一个数据帧。服务端收到当前数据帧后，可以处理消息。opcode 0x1，表示客户端发送的是文本类型。 **第二条消息** 1. FIN 0，opcode 0x1，表示发送的是文本类型，且消息还没发送完成，还有后续的数据帧。 2. FIN 0，opcode 0x0，表示消息还没发送完成，还有后续的数据帧，当前的数据帧需要接在上一条数据帧之后。 3. FIN 1，opcode 0x0，表示消息已经发送完成，没有后续的数据帧，当前的数据帧需要接在上一条数据帧之后。服务端可以将关联的数据帧组装成完整的消息。 ```vbnet Client: FIN 1, opcode 0x1, msg \"hello\" Server: (process complete message immediately) Hi. Client: FIN 0, opcode 0x1, msg \"and a\" Server: (listening, new message containing text started) Client: FIN 0, opcode 0x0, msg \"happy new\" Server: (listening, payload concatenated to previous message) Client: FIN 1, opcode 0x0, msg \"year!\" Server: (process complete message) Happy new year to you too! ``` ## 心跳 WebSocket为了保持客户端、服务端的实时双向通信，需要确保客户端、服务端之间的TCP通道保持连接没有断开。然而，对于长时间没有数据往来的连接，如果依旧长时间保持着，可能会浪费包括的连接资源。 但不排除有些场景，客户端、服务端虽然长时间没有数据往来，但仍需要保持连接。这个时候，可以采用心跳来实现。 发送方 >接收方：ping 接收方 >发送方：pong ping、pong的操作，对应的是WebSocket的两个控制帧，`opcode`分别是`0x9`、`0xA`。"},"/note/网络/index.html":{"title":"","content":"# 网络"},"/note/网络/爬虫/2022-10-2-环境搭建.html":{"title":"环境搭建","content":" layout: post title: \"环境搭建\" date: 2023 6 15 15:39:08 +0800 tags: 爬虫 # 环境搭建 ## python3 ```bash (base) jiao@ubuntu:~/Downloads$ sudo apt get install y python3 dev build essential libssl dev libffi dev libxml2 dev libxslt1 dev zlib1g dev libcurl4 openssl dev (base) jiao@ubuntu:~/Downloads$ sudo apt get install y python3 (base) jiao@ubuntu:~/Downloads$ sudo apt get install y python3 pip ``` ## 下载Anaconde 里面有多个常用的python库 [anaconda 镜像站使用帮助 清华大学开源软件镜像站 Tsinghua Open Source Mirror](https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/) 下载最新的 之后 ````bash (base) jiao@ubuntu:~/Downloads$ cd Downloads/ (base) jiao@ubuntu:~/Downloads$ chmod +x Anaconda3 2022.10 Linux x86_64.sh (base) jiao@ubuntu:~/Downloads$ ./Anaconda3 2022.10 Linux x86_64.sh ```` ## 下载相关的库 ``` pip install requests pip install selenium ``` > 后面的那个里面可以使用浏览器进行抓取, 比如点击下拉等 ## 下载浏览器 + 使用的是Chrome + 需要下载相应的驱动Chromedriver 这个相当于是个入口，启动还是本地事先安装好的Chrome浏览器，而且ChromeDriver只兼容相应的浏览器版本，因此，在下载前需要确定好自己得下哪个版本。 [CNPM Binaries Mirror (npmmirror.com)](https://registry.npmmirror.com/binary.html?path chromedriver/) ``` 配置环境变量或者把可执行文件移动到/usr/bin ``` ```python >>> from selenium import webdriver >>> browser webdriver.Chrome() ``` + 下载地址：https://github.com/mozilla/geckodriver/releases 火绒相关的 + phantomJS, 没有界面可以使用脚本编程的浏览器 下载的软件会在bin文件夹当中 > 在使用的时候不能使用高版本的 > > ``` > pip uninstall selenium > 2.安装selenium 2.48.0版本的，代码如下： > pip install selenium 2.48.0 > ``` + aiohttp requests是一个阻塞式的请求库, 发送一个请求之后会一直等待服务器的响应, 得到响应之后才会进行下一步的操作, 需要等待的时间比较长 aiohttp是一个异步的服务库 直接使用pip进行安装 ## 相关的解析库 + lxml相关的HTML和XML解析, 支持XPATH + Beautiful Soup同上, 依赖于上面的库 + 安装pyquery + 安装tesserocr, 用于识别图片二维码, 实际上是对tesseract的封装`(base) jiao@ubuntu:~$ sudo apt get install y tesseract ocr libtesseract dev libleptonica dev` ```bash //查看可以支持的语言 (base) jiao@ubuntu:~$ tesseract list langs List of available languages (2): osd eng ``` 之后$ git clone https://github.com/tesseract ocr/tessdata.git 下载文件全部复制到/usr/share/tesseract ocr/4.0/tessdata文件夹中进行语言的添加 + 使用 ```bash (base) jiao@ubuntu:~/Desktop$ tesseract R C.png result l eng && cat result.txt Tesseract Open Source OCR Engine v4.0.0 beta.1 with Leptonica Warning. Invalid resolution 0 dpi. Using 70 instead. Estimating resolution as 1385 C TESSERACLT ``` 第二个参数是文件名, 第三个参数是保存结果的文件名, l指定要使用的语言库, 最后打开文件 ```python >>> import tesserocr >>> from PIL import Image >>> image Image.open('R C.png') >>> print(tesserocr.image_to_text(image)) C TESSERACLT ``` 也可以直接 ```python >>> print(tesserocr.file_to_text('R C.png')) C TESSERACLT ``` ## 安装数据库 ```bash (base) jiao@ubuntu:~/Desktop$ sudo apt get install y mysql server mysql client ``` 使用 ```bash (base) jiao@ubuntu:~/Desktop$ sudo service mysql start (base) jiao@ubuntu:~/Desktop$ sudo service mysql stop (base) jiao@ubuntu:~/Desktop$ sudo service mysql restart ```"},"/note/网络/爬虫/2022-9-20-python相关知识.html":{"title":"相关库版本处理","content":" layout: post title: \"相关库版本处理\" date: 2023 6 15 15:39:08 +0800 tags: 爬虫 # 相关的库版本处理 1.先把selenium卸载，代码如下: pip uninstall selenium 2.安装selenium 2.48.0版本的，代码如下： pip install selenium 2.48.0"}}