{"/note/编程基础/前端/2024-8-6-03CSS.html":{"title":"CSS","content":" layout: post title: \"CSS\" date: 2024 8 5 15:39:08 +0800 tags: RISC V # CSS CSS是层叠样式表( Cascading Style Sheets ) 的简称.有时我们也会称之为CSS 样式表或级联样式表。 CSS 是也是一种标记语言CSS 主要用于设置HTML 页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及版面的布局和外观显示样式。 CSS 让我们的网页更加丰富多彩，布局更加灵活自如。 简单理解：CSS 可以美化HTML , 让HTML 更漂亮，让页面布局更简单。 ## 语法规范 CSS 规则由两个主要的部分构成：选择器以及一条或多条声明。 ![image 20240806195926265](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408061959326.png) 选择器是用于指定CSS样式的HTML标签，花括号内是对该对象设置的具体样式 属性和属性值以“键值对”的形式出现 属性和属性值之间用英文“:”分开 多个“键值对”之间用英文“;”进行区分 实际写的时候不区分大小写, 但是一般使用小写 > 这一个的位置可以在head标签里面, 使用`<style>`标签进行包裹 > > ![image 20240806200211191](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408062002223.png) ## 基础选择器 用于选取页面的某一部分 选择器分为基础选择器和复合选择器两个大类 基础选择器是由单个选择器组成的 基础选择器又包括：标签选择器、类选择器、id 选择器和通配符选择器 ### 标签选择器 标签选择器（元素选择器）是指用HTML标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的CSS 样式。 ```html 标签名 { \t属性1:属性值1; \t属性2:属性值2; \t属性3:属性值3; ... } ``` ### 类选择器 如果想要差异化选择不同的标签，单独选一个或者某几个标签，可以使用类选择器。 ```html <div class 'red'>变红色</div> ``` > 使用class属性 类选择器在HTML 中以class属性表示，在CSS 中，类选择器以一个点“.”号显示。 1. 类选择器使用“.”（英文点号）进行标识，后面紧跟类名（自定义，我们自己命名的）。 2. 可以理解为给这个标签起了一个名字，来表示。 3. 长名称或词组可以使用中横线来为选择器命名。 4. 不要使用纯数字、中文等命名，尽量使用英文字母来表示。 5. 命名要有意义，尽量使别人一眼就知道这个类名的目的 ```html .类名{ \t属性1:属性值1; \t... } ``` > 同一个标签可以有多个类名, 之间使用空格进行分割 > > `<div class \"red font20\">阿巴阿巴</div>` ### id选择器 HTML 元素以id 属性来设置id 选择器，CSS 中id 选择器以“#\" 来定义。 ```css #id名 \t{ \t属性1: 属性值1; \t... } ``` + id选择器和类选择器的区别 类选择器（class）好比人的名字，一个人可以有多个名字，同时一个名字也可以被多个人使用。 id选择器好比人的身份证号码，全中国是唯一的，不得重复。 id 选择器和类选择器最大的不同在于使用次数上。 类选择器在修改样式中用的最多，id 选择器一般用于页面唯一性的元素上，经常和JavaScript 搭配使用。 ## 通配符选择器 ### *全选 使用这一个可以选中所有的属性 ### 总结 ![image 20240808222621906](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408082226339.png) ## 字体属性 ### 字体系列`font family` ```html p {font family:\"微软雅黑\";} div {font family:Arial,\"Microsoft Yahei\", \"微软雅黑\";} ``` > 一般情况下,如果有空格隔开的多个单词组成的字体,加引号. > > 各种字体之间必须使用英文状态下的逗号隔开 > > 量使用系统默认自带字体，保证在任何用户的浏览器中都能正确显示 > > 最常见的几个字体：body {font family: 'Microsoft YaHei',tahoma,arial,'Hiragino Sans GB'; } > > 在实际使用时，浏览器会按照您指定的顺序依次尝试加载这些字体。如果用户计算机上安装了这些字体中的任何一个，浏览器将使用第一个找到的可用字体。 在实际使用的时候, 可以直接设置body标签进行设置 ### 字体大小`font size` ```css p { \tfont size:20px; } ``` > 直接使用body标签进行设置字体大小的时候, 会不影响标题的字体大小, 需要单独指定 ### 字体粗细`font weight` ![image 20240809104409350](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408091044466.png) > 实际使用的时候大多数使用数字的方式进行加粗, 400是普通情况, 700是默认的加粗 ### 字体属性`font style` ```css p { \tfont style: normal; } ``` ![image 20240809105359651](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408091053813.png) ### 复合属性 ```css body { \tfont: font style font weight font size/line height font family; } ``` > 使用font 属性时，必须按上面语法格式中的顺序书写，不能更换顺序，并且各个属性间以空格隔开 > > 不需要设置的属性可以省略（取默认值），但必须保留font size 和font family 属性，否则font 属性将不起作用 ```css div { font: italic 700 16px 'Microsoft Yahei'; } ``` ## 文本属性 CSS Text（文本）属性可定义文本的外观，比如文本的颜色、对齐文本、装饰文本、文本缩进、行间距等。 ### 文本颜色`color` ```css div { \tcolor: red; } ``` ![image 20240809110738508](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408091107551.png) ### 对齐`text align ` ![image 20240809112042837](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408091120877.png) 默认是左对齐 > 在图片进行居中对齐的时候, 需要把这一个图片放在一个段落标签里面, 之后对这一个段落设置一个对齐 ### 装饰文本`text decoration` ![image 20240809112147958](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408091121000.png) ### 文本缩进`text indent` ```css div { \ttext indent: 10px; } ``` > 通过设置该属性，所有元素的第一行都可以缩进一个给定的长度，甚至该长度可以是负值。 ```css p { \ttext indent: 2em; } ``` > em是一个相对单位，就是当前元素（font size) 1 个文字的大小, 如果当前元素没有设置大小，则会按照父元素的1 个文字大小。 ### 行间距 ```css p { \tline height: 26px; } ``` ![image 20240809113826200](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408091138252.png) ## 引用方式 1. 行内样式表（行内式） 2. 内部样式表（嵌入式） 3. 外部样式表（链接式） ### 内部样式表 ```css <style> div{ color: red; font size: 12px; } </style> ``` `<style>` 标签理论上可以放在HTML文档的任何地方，但一般会放在文档的`<head>`标签中 通过此种方式，可以方便控制当前整个页面中的元素样式设置 ### 行内样式引用 ```css <div style \"color: red; font size: 12px;\">青春不常在，抓紧谈恋爱</div> ``` 在双引号中间，写法要符合CSS 规范 不推荐大量使用，只有对当前元素添加简单样式的时候，可以考虑使用 ### 外部样式表 ```html <link rel \"stylesheet\" href \"css文件路径\"> ``` ![image 20240809120508848](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408091205899.png) ## 调试工具 ![image 20240809125215725](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408091252789.png) 左边是元素, 右边是css样式 右边的CSS是可以改变样式的, 点击一个元素, 右侧的样式没有改变, 可能是类名或者样式名出错"},"/note/编程基础/前端/2024-8-5-02HTML.html":{"title":"html","content":" layout: post title: \"html\" date: 2024 8 5 15:39:08 +0800 tags: RISC V # HTML ## 注释 注释的格式和C语言是一样的 ## 框架代码 ```html <!DOCTYPE html> <html lang \"en\"> <head> <meta charset \"UTF 8\"> <meta name \"viewport\" content \"width device width, initial scale 1.0\"> <title>Document</title> </head> <body> <div>nihao</div> </body> </html> ``` > `<!DOCTYPE>`文档类型的声明, 用于告诉浏览器使用那一个HTML的版本来显示这一个网页, `<!DOCTYPE html>`这一个代表是使用HTML5这一个版本 > > 这一个不是一个HTML标签是一个声明标签 > > `<html lang \"en\">`这一个文档的显示语言, 如果是`zh CN`这一个表示的是中文的网页, 翻译插件会使用这一个进行翻译 > > ` <meta charset \"UTF 8\">`实际使用的编码, 尽量使用这一个编码 > > `<meta name \"viewport\" content \"width device width, initial scale 1.0\">`告诉浏览器，网页的宽度应该等于设备的宽度，并且初始缩放比例为1.0，这样可以确保网页在移动设备上以合适的大小显示。 ## 常用的标签 ### 标题标签`<h1> <h6>` 有六个等级的标签, 结束的时候需要使用`</h1>`进行结束, 字体变粗变大, 独占一行 ### 段落标签`<p>` ```html <p>段落<\\p> ``` > paragraph 在文本里面的换行实际不会进行换行, 多个空格只显示一个, 会在浏览器里面进行自动换行 ### 换行标签`<br/>` 只需要这一个标签, 即可进行换行, 是一个单标签 换行和段落的区别在于这一个符号的间隔比较小 ### 加粗`<strong>或<b>` ### 斜体`<em>或<i>` ### 删除线`<del>或<s>` ### 下划线`<ins>或<u>` 这几组都是成对存在的 ### 常用标签`<div>和<span>` 一个盒子, 用于装东西, 没有实际的语义 div标签用于布局的时候, 一行只能有一个div标签, 这一个标签后面的内容会放在下一行里面 span的每一行里面可以放置多个 ### 图像`<img/>` `<img src \"图像url\" />`这是一个单标签, 这一个属性是必须写的 其他属性: ![image 20240806101608622](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408061016679.png) > 参数在使用的时候都是使用字符串的形式, 写的时候必须在标签名的后面, 属性之间使用空格进行分割 ### 超链接`<a>` `<a href \"跳转目标\" target \"目标窗口出现方式\">文本图像</a>` ![image 20240806122430327](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408061224375.png) target可以使用的属性有`\"_self\"`或者\"`_blank\"` + 内部链接 在网页内部进行连接的适合可以直接使用网页的名字, 直接输入网页的文件名即可 + 空链接 这一个网页还没有做好的时候可以使用一个`#`代替 + 下载链接 实际链接的是一个文件 > 这一个超链接的里面可以放置其他的各种元素, 比如文本, 表格, 音频, 视频, 图片 + 锚点链接 快速的去往这一个链接的某一个位置 在链接的属性里面设置属性为`#名字的格式`, 在实际要跳转的位置加一个属性`id \"名字\"` ### 注释`<! 注释 >` ### 特殊字符 ![image 20240806124738965](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408061247048.png) ### 表格 <img src \"https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408061302137.png\" alt \"image 20240806130221094\" style \"zoom:150%;\" /> ```html <table> <tr> <td>姓名</td> <td>性别</td> <td>年龄</td> </tr> <tr> <td>焦浩洋</td> <td>男</td> <td>21</td> </tr> </table> ``` ![image 20240806130709201](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408061307237.png) + 特殊标签 表头单元格的元素可以使用`<th>`标签 ```html <table> <tr> <th>姓名</th> <th>性别</th> <th>年龄</th> </tr> <tr> <td>焦浩洋</td> <td>男</td> <td>21</td> </tr> </table> ``` ![image 20240806130908431](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408061309466.png) ![image 20240806131028167](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408061310231.png) > 属性写在table这一个标签里面 > > 对齐指的是这一个表格整体的对齐, 不是里面元素的对齐 > > cellpadding: 文字和单元格之间的距离 + 表格分段 表格比较长的时候可以使用标签对着一个表格进行不同段落的区分 `<thead>`标签表格的头部区域、`<tbody>`标签表格的主体区域. 一般第一行使用thead进行包含, 其他的使用tbody进行包含, 使用这一个可以使结构更加清晰 + 合并单元格 方式1: 跨行合并单元格, `rowspan \"合并单元格的个数\"` (竖着的) 方式1: 跨行合列单元格, `colspan \"合并单元格的个数\"` (横着的) > 目标单元格: 实际合并把代码写的位置 跨行: 最上边的那一个, 跨列: 最左边的 > > 之后被合并的单元格不需要写 ```html <table width \"500\" cellspacing \"0\" border \"1\" height \"250\"> <tr> <th></th> <th colspan \"2\"></th> </tr> <tr> <td rowspan \"2\"></td> <td></td> <td></td> </tr> <tr> <td></td> <td></td> </tr> </table> ``` ![image 20240806133606345](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408061336388.png) ### 列表 可以排列出来整齐, 有序的元素 有三类: 无序列表、有序列表和自定义列表。 ![image 20240806140928935](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408061409010.png) + 无序列表 `<ul>` 标签表示HTML 页面中项目的无序列表，一般会以项目符号呈现列表项，而列表项使用`<li>` 标签定义。 ```html <ul> <li>列表项1</li> <li>列表项2</li> </ul> ``` > ![image 20240806141132422](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408061411464.png) > > 在ul里面只能放li标签, li里面可以放任意标签, 这一个属性可以使用CSS进行修改 + 有序列表 使用`<ol>`里面的属性还是`<li>` + 自定义列表 经常用于对一个术语或者名词进行解释的时候 在HTML 标签中，`<dl> `标签用于定义描述列表（或定义列表），该标签会与`<dt>`（定义项目/名字）和`<dd>`（描述每一个项目/名字）一起使用。 ```html <dl> <dt>列表项1</dt> <dd>解释1</dd> <dd>解释2</dd> <dt>列表项2</dt> <dd>解释1</dd> <dd>解释2</dd> <dd>解释3</dd> <dd>解释4</dd> </dl> ``` > ![image 20240806142218834](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408061422880.png) > > <dt> 和<dd>个数没有限制，经常是一个<dt> 对应多个<dd>。 ### 表单标签 一个完整的表单通常由表单域、表单控件（也称为表单元素）和提示信息3个部分构成。 ![image 20240806143219996](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408061432075.png) 在HTML 标签中，`<form> `标签用于定义表单域，以实现用户信息的收集和传递。`<form>` 会把它范围内的表单元素信息提交给服务器. ```html <form action \"url地址\" method \"提交方式\" name \"表单域名称\"> 各种表单元素控件 </form> ``` ![image 20240806143432317](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408061434379.png) + 表单元素 1. input: 输入元素 这一个元素有一个type的属性, 这一个属性可以使得输入的字段有不同的形式 可以是文本字段、复选框、掩码后的文本控件、单选按钮、按钮等 `<input />` 标签为单标签, type属性设置不同的属性值用来指定不同的控件类型 ![image 20240806145404852](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408061454940.png) > 在使用submit的时候, 点击这一个按钮会把数据进行提交 > > reset用于返回初始值 ![image 20240806153328949](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408061533024.png) > 可以使用name属性区别不同的输入框, 有同一个name的单选框只能选取其中一个 > > value: 默认里面的数据 > > name 和value 是每个表单元素都有的属性值,主要给后台人员使用. > > name 表单元素的名字, 要求单选按钮和复选框要有相同的name值. > > checked属性主要针对于单选按钮和复选框, 主要作用一打开页面,就要可以默认选中某个表单元素. > > maxlength是用户可以在表单元素输入的最大字符数, 一般较少使用. ```html <form> <! 输入框 > 用户名: <input type \"text\" name \"name\" value \"请输入姓名\" /> <br /> <! 密码框 > 密码: <input type \"password\" name \"password\" /> <br /> <! 单选按钮 > 性别: <input type \"radio\" name \"sex\" value \"男\">男<input type \"radio\" name \"sex\" value \"女\">女 <br /> <! 多选框 > 爱好: <input type \"checkbox\" name \"hobby\">吃饭<input type \"checkbox\" name \"hobby\">睡觉 <! 提交按钮 > <input type \"submit\"> </form> ``` ![image 20240806154130748](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408061541808.png) > 提交以后 + lable标签 `<label>`标签为input 元素定义标注（标签）。 `<label>`标签用于绑定一个表单元素, 当点击`<label> `标签内的文本时，浏览器就会自动将焦点(光标)转到或者选择对应的表单元素上,用来增加用户体验. ```html <label for \"sex\">男</label> <input type \"radio\" name \"sex\" id \"sex\"/> ``` > 核心：`<label>` 标签的for 属性应当与相关元素的id 属性相同。 2. select: 下拉表单 在页面中，如果有多个选项让用户选择，并且想要节约页面空间时，我们可以使用<select>标签控件定义下拉列表. ```html <select> <option>选项1</option> <option>选项2</option> <option>选项3</option> </select> ``` ![image 20240806172426063](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408061724117.png) > 一般使用的使用也是在form元素里面, 这个里面最少有一个选项 > > 选项可以有一个参数`selected \"selected\"`用于选择这一个选项 3. textarea: 文本域元素 输入大量数据的时候可以使用这一个标签 有参数cols可以设置每一行的指数, rows可以设置现实的行数 > 在实际使用的时候可以使用表格来进行对齐的操作"},"/note/编程基础/前端/2024-8-5-01基础知识.html":{"title":"基础知识","content":" layout: post title: \"基础知识\" date: 2024 8 5 15:39:08 +0800 tags: RISC V # 基础知识 ## 基础知识 ### 网页 网站是指在因特网上根据一定的规则，使用 HTML 等制作的用于展示特定内容相关的网页集合。 网页是网站中的一“页”，通常是 HTML 格式的文件，它要通过浏览器来阅读。 网页是构成网站的基本元素，它通常由图片、链接、文字、声音、视频等元素组成。通常我们看到的网页， 常见以 .htm 或 .html 后缀结尾的文件，因此将其俗称为 HTML 文件。 ### html简介 HTML 指的是超文本标记语言 (Hyper Text Markup Language) ，它是用来描述网页的一种语言。 HTML 不是一种编程语言，而是一种标记语言 (markup language)。 标记语言是一套标记标签 (markup tag)。 所谓超文本，有 2 层含义： 1. 它可以加入图片、声音、动画、多媒体等内容（超越了文本限制 ）。 2. 它还可以从一个文件跳转到另一个文件，与世界各地主机的文件连接（超级链接文本 ） ### Web标准 遵循 Web 标准除了可以让不同的开发人员写出的页面更标准、更统一外，还有以下优点： 1. 让 Web 的发展前景更广阔。 2. 内容能被更广泛的设备访问。 3. 更容易被搜寻引擎搜索。 4. 降低网站流量费用。 5. 使网站更易于维护。 6. 提高页面浏览速度。 主要包括结构（Structure） 、表现（Presentation）和行为（Behavior）三个方面。 ![image 20240805191855176](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408051918221.png) Web 标准提出的最佳体验方案：结构、样式、行为相分离。 简单理解： 结构写到 HTML 文件中， 表现写到 CSS 文件中， 行为写到 JavaScript 文件中。 ## HTML标签 ### 规范 所有的标签都是在<>里面, 一般都是成对出现的 标签有两种关系, 包含关系以及并列关系 ### 基本结构 每个网页都会有一个基本的结构标签（也称为骨架标签），页面内容也是在这些基本标签上书写。 ![image 20240805193042394](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408051930423.png) ![image 20240805193125833](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408051931868.png) ![image 20240805193713660](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408051937685.png) ![image 20240805193733641](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408051937679.png) ## 插件 [第一篇：前端VSCode常用插件 快捷键 以及常用技巧 pink老师 哔哩哔哩 (bilibili.com)](https://www.bilibili.com/read/cv9698270/) [第二篇：前端VSCode常用插件 快捷键 以及常用技巧 pink老师 哔哩哔哩 (bilibili.com)](https://www.bilibili.com/read/cv9699783/?spm_id_from 333.999.0.0)"},"/note/编程基础/前端/2024-8-12-04CSS2.html":{"title":"CSS2","content":" layout: post title: \"CSS2\" date: 2024 8 5 15:39:08 +0800 tags: RISC V # CSS2 ## Emmet语法 Emmet语法的前身是Zen coding,它使用缩写,来提高html/css的编写速度, Vscode内部已经集成该语法. 1. 快速生成HTML结构语法 2. 快速生成CSS样式语法 ### 生成HTML结构 1. 生成标签直接输入标签名按tab键即可比如 div然后tab 键，就可以生成`<div></div>` 2. 如果想要生成多个相同标签 加上* 就可以了比如`div*3`就可以快速生成3个div, 没有空格 3. 如果有父子级关系的标签，可以用>比如ul>li就可以了 4. 如果有兄弟关系的标签，用 + 就可以了比如div+p 5. 如果生成带有类名或者id名字的， 直接写 .demo 或者 #twotab 键就可以了, 默认的时候是div标签, 其他的标签需要在前面写明 6. 如果生成的div 类名是有顺序的，可以用自增符号 $, `.demo$*5` >五个div, 类名是demo1,到demo5, $被数字替代, 默认从1开始 7. 如果想要在生成的标签内部写内容可以用 { } 表示, `div{内容}` >`<div>内容</div>`, 这里面可以使用$"},"/note/编程基础/go/2022-8-26-函数.html":{"title":"Go","content":" layout: post title: \"Go\" date: 2023 6 17 15:39:08 +0800 tags: go # Go"},"/note/编程基础/C#/2023-6-24-1.C#.html":{"title":"C#","content":" layout: post title: \"C#\" date: 2022 8 23 15:39:08 +0800 tags: C# # C# java: 网站应用程序 C++: 不擅长网络编程 依附于.NET平台 编译器首先把C#转换为IL中间语言, 之后.NET中的CLR动态转换为机器指令 优点, 提升开发效率, 运行的时候才会转换为机器指令, 性能会降低 .NET平台降低不同语言开发程序沟通成本 最开始的叫做.NET Framework, 只能在Windows上面运行 之后实现MONO, 微软肉实现.NET CORE可以跨平台运行 ![image 20230624141952681](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242257084.png) 编译器 创建醒目选择控制台应用.NET Framework ![image 20230624143414523](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242257085.png) ![image 20230624143426074](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242257086.png) 项目名字: 文件夹名字 解决方案: 控制多个项目的时候 ![image 20230624143840334](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242257087.png) ![image 20230624144110812](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242257088.png) 这是项目文件夹, 控制文件.sln ![image 20230624144302265](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242257089.png) ![image 20230624144659781](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242257090.png) 实际运行的项目 ## 代码 ```c# using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace Hello { class Program { static void Main(string[] args) { Console.WriteLine(\"这是我的程序\"); Console.ReadKey(); } } } ``` 注释// ### 结构 ```c# //命名空间 namespace Hello { //类型 class Program { //函数方法 static void Main(string[] args) { Console.WriteLine(\"这是我的程序\"); Console.ReadKey(); } } } ``` ```c# //类型, 名字自定义, 不能是数字名字开头 class Program { //函数方法, 程序入口 static void Main() { } } ``` > 最基本的结构 ### 变量 变量的类型 变量的名称 初始值; ![image 20230624153724950](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242257091.png) ```c# var n 100; var m 200; var sum 0; sum n + m; System.Console.WriteLine(sum); System.Console.ReadKey(); ``` 使用`using System` ```c Console.WriteLine(sum); Console.ReadKey(); ``` #### 类型 var语法糖: 自动推测语法的类型 int整数 string字符串 ![image 20230624160101472](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242257092.png)"},"/note/编程基础/C和指针/2022-7-26-指针.html":{"title":"指针(《C和指针》)","content":" layout: post title: \"指针(《C和指针》)\" date: 2022 7 26 11:29:08 +0800 categories: C和指针 # 指针 一个内存存储的信息保存的是是什么内容取决于读取的方式，由编译器来确定你定义的数据类型，如果不正确则进行报错 ## 间接访问 一个指针访问他所指向的地址 > **注：**不要直接给一个没有初始化的地址赋值 > > + 访问非法地址：终止程序 > + 访问地址没有对齐：UNIX系统总线错误 > + 位于合法的内存：出现不可预知的错误 ## NULL指针 指向0，可以把它和0比较来判断是不是一个空指针，但是他的实际值可能不是0，这是一种源代码约定，对一个空指针进行求解是非法的。 **最好对没有初始值的指针初始化为NULL** ## 指针常量 直接使用*对一个整形去赋值是错误的，应该进行类型的转换 ```C * 100 25;//错误 * (int *)100 25;//正确 ``` > 这种方式通常用来访问某些固定的内存地址,比如硬件接口等 ## 指针的指针 ```C int a 12; int *b &a; int **c &b; ``` ## 指针的使用示例解析 ```*++cp```:表示的是cp原先指向的地址之后的一个地址的内容 ```*cp++```:执行顺序（1）返回现在的cp（2）cp加一（3）对原来的地址进行取值操作 ```++*cp```:两个符号的结合性质都是从右到左，所以先对cp取值，然后对取到的值进行左++操作 ```(*cp)++```:首先进行访问然后对结果进行++ ```++*++cp```:先对cp代表内存之后的那个内存内容进行获取，然后进行加一 > **注：**在使用指针操作时对会对原数据造成破坏的数据进行备份 ```C int find_char(char **strings,int value) { assert(strings ! NULL);//如果结果不正确就打印一条提示 while(*strings ! NULL) { while(**strings ! '\\0') { if(*(*strings)++ value)//对原来的数据进行了改变 return 1; } strings ++; \t} } ``` **正确的方式**： ```C int find_char(char **strings,int value) { char *string; while((string *strings) ! NULL)//进行备份 { while(*string ! '\\0') { if(*string++ value) return 1; } strings ++; \t} } ``` ## 指针运算 ### 算数运算 + 指针±整数 > 当一个指针和一个整数执行算数运算，整数会在加法运算前根据指针指向的数据类型进行调整,减法会在得到相应的值之后除以指针的类型大小 ### 关系运算 前提是必须是一个数组之内的两个值 > 协议允许一个指针和数组之后的那个地址进行比较，但是不允许和之前的那个地址进行比较 ```C 1 #include <stdio.h> 2 #define NUM 5 3 float values[NUM]; 4 float *vp; 5 6 int main() 7 { 8 for( vp &values[0]; vp <&values[NUM];) 9 *vp++ 0; 10 for( vp &values[NUM]; vp > &values[0];) 11 * vp 0; 12 for( vp &values[NUM 1]; vp > &values[0];vp )//这种在有的机器上的运行可能是错误的 13 *vp 0; 14 return 0; 15 16 17 } ```"},"/note/编程基础/C和指针/2022-7-25-字符串操作.html":{"title":"字符串操作","content":" layout: post title: \"字符串操作\" date: 2022 7 25 11:29:08 +0800 categories: C和指针 # 字符串操作 ### 字符串 C语言之中没有string，以NUL字节（全部为0 、\\0）结尾 使用gets获取到的字符串丢弃换行符加上一个NUL > scanf函数 > 实现按照指定的格式接收输入，返回值是成功传入的参数个数，形式和printf相似，但是接收使用指针，在读取数据时，只读取使用到的数据，剩余的数据保留 > getchar() >获取一个字符，如果不再存在任何字符返回EOF > > **注**：EOF为长度大于一个字节的数字，应该使用整形接收防止误判 > gets() >获取一个字符串存到传入的指针，但是没有溢出检测 > strcpy() >字符串复制， **char \\*strncpy(char \\*dest, const char \\*src, size_t n)** 把 **src** 所指向的字符串复制到 \t\t\t\t\t\t\t\t**dest**，最多复制 **n** 个字符。当 src 的长度小于 n 时，dest 的剩余部分将用空字节填充。 > strcpy() >和上面类似，但是没有限定字符的个数，进行全部复制 > strcat() >把第二个字符串加到第一个的末尾 > strchr() >查找一个字符，第一个参数是字符串，第二个参数是要查找的字符 > strstr() >查找一个字符串"},"/note/编程基础/C和指针/2022-7-26-表达式.html":{"title":"表达式","content":" layout: post title: \"表达式\" date: 2022 7 26 11:29:08 +0800 categories: C和指针 # 表达式 ## 隐式类型转化 C语言整形算术运算的时候至少是以缺省整形的精度来进行的，表达式中的字符型、短整型在使用前会被转换成整形 ```C char a, b, c; a ( a^b<<1)>>1; ``` ## 算数转化 某个操作符的操作数属于不同的类型 > **转换方式**:int > unsigned int > long int > unsigned long int > float > double > long double ## 操作符的属性 + 操作符的优先级 + 操作符的结合性：操作符的运算顺序从左到右还是从右到左 + 操作符是否控制程序的顺序 **优先级**：![QQ图片20220726104314](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242254824.png)\t ![QQ图片20220726104340](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242254825.png) ![QQ图片20220726104658](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311011800534.png) **注**：```a + b```这种由于“ ”符号不能确定是在之前之后进行，所以没有正确答案 <u>**注意溢出**</u> <u>**尽量编写结果取决于不确定的运算顺序的表达式**</u> > 如果操作对于顺序的要求很高的话，最好添加一个中间值然后分行进行 > > ```C > f() + g() + h() > temp f(); temp + g(); temp + h();"},"/note/编程基础/C和指针/2022-7-27-结构体和指针.html":{"title":"结构体和指针《C和指针》","content":" layout: post title: \"结构体和指针《C和指针》\" date: 2022 7 27 11:29:08 +0800 categories: C和指针 # 结构体和指针 ## 链表 包含数据的独立数据结构的集合，通过链表和指针连接在一起，节点通常是动态分配的，也有数组组成的，但是通过指针遍历 ## 单链表 每个节点包含有指向下一个节点的指针，最后一个指向NULL 只要找到了第一个节点就可以访问后面的节点，可以用一个指针保存第一个指针的地址 ```C typedef struct NODE{ struct NODE *link; int value; }Node; ``` ### 在单列表之中插入 遍历的时候保存上一个节点的地址 把之前的指针改为插入的值，把插入的指针改为下一个节点的地址 **问题**： + 注意末尾数据的判断 + 注意第一个数据的插入，要更改root指针，需要传入一个指向root的指针，实际上为结构体的二重指针 **改进**：只需要记录每次的节点指向下一节点的指针的地址就足够了 ```C 1 #include <stdio.h> 2 #include <stdlib.h> 3 typedef struct NODE{ 4 struct NODE *link; 5 int value; 6 }Node; 7 8 #define FALSE 0 9 #define TRUE 1 10 //参数：指向保存第一个结构体位置的指针的指针，要插入的值 11 int sile_insert(Node **linkp, int new_value) 12 { 13 Node *current;//用来保存现在的结构体的指针 14 Node *new;//用来保存下一个数组的位置 15 while((current *linkp) ! NULL && 16 current >value < new_value)//在要插入地址之后位置出来 17 linkp &current >link;//指向对应的指针的地址，这是插入前位置 18 19 new (Node *)malloc(sizeof(Node)); 20 if(new NULL) 21 return FALSE; 22 new >value new_value; 23 24 new >link current; 25 *link new; 26 return TRUE; 27 } ``` ## 双链表 每个节点包括两个指针，指向前一个字节，指向后一个字节的指针 ```C typedef struct NODE{ struct NODE *fwd; struct NODE *bwd; int value; }Node; ``` + 根节点：fwd指向以一个节点，bwd指向最后一个节点 + 第一个节点的bwd NULL + 最后一个节点的fwd NULL ### 在双链表中插入 有四种可能 + 起始位置 + 结束位置 + 中间位置 + 起始和结束 ```C #include <stdlib.h> #include <stdio.h> typedef struct NODE{ struct NODE *fwd; struct NODE *bwd; int value; }Node; int dll_insert(Node *rootp, int value) { Node *this; Node *next; Node *newnode; for(this rootp; (next this >fwd) ! NULL; this next){ if(next >value value) return 0;//这个值已经存在了 if(next >value > value) break; } newnode (Node *)malloc(sizeof(Node)); if(newnode NULL) return 1; newnode >value value; if(next ! NULL) { newnode >fwd next; if(this ! rootp){//位于中间位置 \tthis >fwd nownode; \tnewnode >bwd this; } else{//位于起始位置，并且不是结尾 \trootp >fwd nownode; \tnewnode >bwd NULL; } next >bwd newnode; } else { newnode >fwd NULL; if(this ! rootp){//位于末尾位置，不是起始 \tthis >fwd nownode; \tnewnode >bwd this; }else {//位于起始和末尾 \tthis >fwd nownode; \tnewnode >bwd NULL; } rootp >bwd newnode; } \treturn 1; } ``` **代码简化**： + 把if语句之中的重复代码提取出来 **注：**提取出的代码不会影响判断代码的进行 + 对现有的代码进行总结 ```C newnode >fwd next; if(this ! rootp) { \tthis >fwd newnode; newnode >bwd this; } else{ root >fwd newnode; newnode >bwd NULL; } if(next ! NALL) next >bwd newnode; else rootp >bwd newnode; ``` 写法化简 ```C newnode >fwd next; this >fwd newnode; newnode >bwd this ! rootp ? this :NULL; (next ! NULL ? next : rootp) >bwd newnode; ```"},"/note/编程基础/C和指针/2022-7-27-字符串字符字节.html":{"title":"字符串字符和字节《C和指针》","content":" layout: post title: \"字符串字符和字节《C和指针》\" date: 2022 7 27 11:29:08 +0800 categories: C和指针 # 字符串字符和字节 C语言没有专门的显式的字符串类型，常以字符串常量或者存储于字符数组，字符串常量适用于程序不会对他进行修改的情况，其他的字符串必须存储于字符数组或动态分配的内存之中 ## 基础 > 就是一串字符，以一个全为0的NUL字节结尾，因此字符串不能包含NUL字节，NUL字节的长度不包括在字符串的长度之中 ## 长度 库函数：```size_t strlrn(char const *string);``` size_t定义于stddef.h文件之中，代表无符号整形 > **注：**返回值为无符号数 > > ```C > if(strlen(x) strlen(y) &gt; 0);//错误，这个永远是大于零的结果 > ``` > > ```C > 1 #include <stdio.h> > 2 #include <string.h> > 3 int main(void) > 4 { > 5 char *a \"##########\"; > 6 char *b \"###############\"; > 7 if(strlen(a) strlen(b) > 0) > 8 printf(\"longer\\n\"); > 9 else > 10 printf(\"short\\n\"); > 11 return 0; > 12 } > > result: > \tlonger > ``` > > ## 不受限制的字符串函数 常用的字符串函数都是不受限制的，就是说通过寻找NUL字节来判断它的长度。 > ```char *strcpy(char *dst, char const *src);```字符串复制，把src字符串复制到dst字符串之中，目标参数的所有内容都会被覆盖或者丢失，因为复制的字符串最后是NUL字节 > > **注：**程序员必须保证第一个参数的大小可以保存整个字符串被储存 > ```char *strcat(char *dat,char const *src);```字符串链接。把第二个字符串添加到第一个字符串之后，要求dst原先已经有一个字符串 由于两个函数的返回值都是第一个字符串的地址 ```C strcat(strcpy(dat, a), b); ``` > ```int strcmp(char const *s1, char const *s2);```字符串比较，返回值是比较大小，相等的时候返回0 > > **注：**相等的时候返回的0代表错误 ## 长度受限制的字符串函数 ```C char *strncpy(char *dst, char const *src, size_t len); char *strncat(char *dat,char const *src, size_t len); int strncmp(char const *s1, char const *s2, size_t len); ``` > **注：**在进行复制的时候，如果长度<len会用NUL进行填充，反之着会就进行裁剪，*<u>不会以NUL结尾</u>*，必须人工添加NUL以免发生意外 > 追加函数会自动添加NUL，但是不检测溢出 ## 字符串查找 ### 查找一个字符 ```C char *strchr(char const *str,int ch);//从左向右，返回指针，没有找到返回NULL char *strrchr(char const *str,int ch);//从右向左，返回指针 ``` ### 查找几个字符 ```C char *strpbrk(char const *str, char const *group); ``` ### 查找子串 ```C char *strstr(char const *s1, char const *s2); ``` ```C 1 #include <stdio.h> 2 #include <string.h> 3 4 int main(void) 5 { 6 char *str1 \"hello world\\0\"; 7 char *str2 \"abcde\\0\"; 8 char *str3 \"wor\\0\"; 9 printf(\" strpbrk \\n\"); 10 printf(\"%d\\n\", strpbrk(str1,str2)); 11 printf(\"%d\\n\", strpbrk(str1,str3)); 12 printf(\" strstr \\n\"); 13 printf(\"%d\\n\", strstr(str1,str2)); 14 printf(\"%d\\n\", strstr(str1,str3)); 15 } result: strpbrk 2001022981 2001022984 strstr 0 2001022986 ``` > strpbrk查找不需要全部匹配，只要含有相同的内容就可以 > strstr查找要求全部一样 ## 高级字符串的查找 ### 查找一个字符串前缀 ```C size_t strspn(char const *str, char const *group);//返回字符串之开头和group中的字符匹配的字符个数 size_t strcspn(char const *str, char const *group);//返回字符串之开头和group中的字符不匹配的字符个数 ``` 使用： ```C int len1.len2; char buffer[] \"25,142,330,Smith,J,223 4123\" len1 strspn(buffer, \"0123456789\");//返回值为2 len2 strspn(buffer, \",1234567890\");//返回值为11 //查找空白字符的结束 ptr buffer + strspn(buffer, '\\n\\r\\f\\t\\v'); 1 #include <stdio.h> 2 #include <string.h> 3 4 int main(void) 5 { 6 int len1,len2; 7 char buffer[] \"25,142,330,Smith,J,223 4123\"; 8 9 len1 strspn(buffer, \"0123456789\");//返回值为2 10 len2 strspn(buffer, \",1234567890\");//返回值为11 11 printf(\"%d\\n\", len1); 12 printf(\"%d\\n\", len2); 13 return 0; 14 } result 2 11 ``` ### 查找标记 ```C char *strtok(char *str, char const *sep); ``` > sep是一个字符串，定义了作为分隔符的字符合集，第一个参数中包含零个或多个sep中的一个或多个分隔符的标记，strtok找到下一个标记，并将其用NUL结尾返回 > > **注：**strtok会修改字符串，请提前做好备份，改变后的字符串是第一段 如果在第一个参数传入NULL则继续对上一个字符串查找，直到返回值为NULL ```C 1 #include <stdio.h> 2 #include <string.h> 3 4 void print_tokens(char *line) 5 { 6 static char *whitespace \" \\t\\n\\f\\r\\v\"; 7 char *token; 8 // printf(\"%s\\n\", line); 9 for(token strtok(line, whitespace); 10 token ! NULL; 11 token strtok(NULL, whitespace)) 12 printf(\"Next token is %s\\n\",token); 13 14 } 15 16 int main(void) 17 { 18 char *token; 19 char line[60] \" wocao2 666 zhesha\\n gg\"; 20 print_tokens(line); 21 printf(\" \\n\"); 22 printf(\"%s\", line); 23 } result: Next token is wocao2 Next token is 666 Next token is zhesha Next token is gg \twocao2 ``` > **注：**不要使用```char *str \"abc\"```形式的字符串，这是一个常量，不可以更改 > > 不可以同时解析两个字符串 还可以在每次提取的时候采用不同的标记符 ## 打印错误信息 ```C char *strerror(int error_number);//返回当前的错误信息, open() write() creat() 函数就会把错误原因放入errno ``` > `error_number`的值通常为``errno`,`strerror`实在`string.h`这个头文件中的, 同样, `errno`也是存放在`errno.h`头文件中. ```C 1 #include <stdio.h> 2 #include <string.h> 3 #include <errno.h> 4 5 int main() 6 { 7 printf(\"%s\\n\", strerror(errno)); 8 9 return 0; 10 } ``` ## 字符操作 包含于`ctype.h`中 ### 字符分类 ![QQ图片20220727134007](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311011800068.png) 这些函数的可移植性比较好比如`if(ch > \"A\" && ch < \"Z\");`只能在使用ASCII码的机器上使用 ### 字符转换 ```C int tolower(int ch);//转为小写 int toupper(int ch);//转为大写 ``` ## 内存操作 字符串在遇到NUL字节就进行结尾，但是在内存操作中这样的数据并不少 > **注：**长度的单位是字节 ```C //复制 void *memcpy(void *dst,void const *str, size_t length); //复制但是原地址和目标可以重叠，会先进行备份然后复制 void *memmove(void *dst,void const *str, size_t length); //比较 void *memcmp(void const *a, void const *b, size_t length); //查找 void *memchr(void const *a, int ch, size_t length); //全部设置为ch void *memset(void *a,int ch, size_t length); ```"},"/note/编程基础/C和指针/2022-7-25-C语言环境.html":{"title":"C语言环境","content":" layout: post title: \"C语言环境\" date: 2022 7 25 11:29:08 +0800 categories: C和指针 # C语言环境 主要分为**编译环境**和**执行环境**，不一定要在一台机器上，比如交叉编译器 **独立环境**：没有操作系统的环境，通常出现在嵌入式 ### 翻译 ![QQ图片20220725143448](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311011759643.png) 预处理 > 解析 >优化器 >编译 >链接（详细见笔记本） ### 执行 详细见笔记本"},"/note/编程基础/C和指针/2022-7-25-操作符和表达式.html":{"title":"操作符","content":" layout: post title: \"操作符\" date: 2022 7 25 11:29:08 +0800 categories: C和指针 # 操作符 ### 操作符 + 算数操作符：+， ，*，/ + 移位操作符：<<，>> + 位操作符：，& + 赋值： + 复合运算符：+ ， +， + 单目操作符：只接受一个参数: *, ++, ! <u>sizeof :可以是函数，也可以是运算符</u> ```C 1 #include <stdio.h> 2 3 int main(){ 4 int a; 5 printf(\"%d\\n\", sizeof a); 6 return 0; 7 } ``` > **注**：因为sizeof不需要对内部的参数求值，所以sizeof(a a + 2)并没有改变a的值 > > ```C > 1 #include <stdio.h> > 2 > 3 int main(void) > 4 { > 5 int a 0; > 6 int b 2; > 7 printf(\"sizeof %d\\n\", sizeof(a a+b)); > 8 printf(\"a %d\\n\", a); > 9 return 0; > 10 } > result: > > sizeof 4 > a 0 > > ``` > 强制转换符 <u>优先级很高，如果对表达式使用，需要用括号括起来</u> > ++和 实质上是复制了一份操作的，所以不能使用 ```++a 10；``` 这样的代码 + 关系操作符：>, <, > , < 返回的是一个整形 > **注**：赋值操作符在相等测试的地方使用也是正确的```if(x 5){}``` 并不会报错，切运行时判断一直为正确 + 逻辑操作符： &&， 在进行比较的时候，如果&&左侧的值是错误就不会比较右边，是左侧为正确的时候不会比较右边 + 条件操作符：expression ? expression3 ! expression3; + 逗号操作符：将两个或者多个表达式使用逗号隔开，从左向右求值，最后一个表达式的值就是结果 + 下标引用，函数调用，结构体成员 ### 布尔值 0是假，别的都为真 ### 左值和右值 左值就是一个位置，右值意味着一个一个值"},"/note/编程基础/C和指针/2022-7-27-动态内存分配.html":{"title":"动态内存分配《C和指针》","content":" layout: post title: \"动态内存分配《C和指针》\" date: 2022 7 27 11:29:08 +0800 categories: C和指针 # 动态内存分配 在使用数组的时候我们有时候不知道需要多大的数组，于是提前申请一个大的数组用来存储数据，但是这回使得大块的内存被浪费 ## malloc和free ```C void *malloc(size_t size); void free(void *point); ``` malloc会申请一块内存，实际上有可能比你申请的大一点，如果申请失败。返回NULL，free的参数是NULL或者malloc的返回值 在对边界要求严格的机器上，返回的地址会满足要求最严格的数据的地址 ## calloc和realloc ```C void *calloc(size_t num_elements, size_t element_size); void *realloc(void *ptr, size_t new_size); ``` **calloc**:也是用来申请一段内存的，和malloc的区别是他会把申请到的内存初始化为0，但是如果你是想把数据存储到一块内存之中，这个行为就是浪费时间，请求的方式也不同，他的参数元素的数量以及元素的大小 **realloc：**修改已经有的一块内存的大小，可以把一块扩大或者缩小，在扩展时候如果需要更换内存，会把原来的数据复制 到新的内存，返回新的地址 ### 使用分配到的内存 先判断返回的是不是NULL 使用一个有类型的指针去接受返回的指针 > 得到一块数组 ### 常见的错误 + 对NULL进行解读 + 操作时候越界 + 释放不是分配的内存 + 释放一部分 + 释放之后继续使用 ```C 1 #include <stdlib.h> 2 3 #define malloc//禁止使用malloc 4 #define MALLOC(num,type) (type *)alloc((num) * sizeof(type))//对函数进行重定义 5 extern void *alloc(size_t size); 1 #include <stdio.h> 2 #include \"malloc.h\" 3 #undef malloc 4 5 void *alloc(size_t size) 6 { 7 void *new_mem; 8 new_mem malloc(size); 9 if(new_mem NULL)//进行检查 10 { 11 printf(\"Out of memory\"); 12 exit(1); 13 } 14 return new_mem; 15 } 1 #include \"malloc.h\" 2 3 int main(void) 4 { 5 int *new_memory; 6 new_memory MALLOC(25, int); 7 printf(\"%p\\n\", new_memory); 8 free(new_memory); 9 return 0; 10 } ``` > free在释放内存的时候必须全部释放，但是可以用realloc可以调整 ### 内存泄漏 申请的内存没有及时的释放 ```C 1 #include <stdio.h> 2 #include <stdlib.h> 3 4 int compare_integers(void const *a, void const *b) 5 { 6 register int const *pa a; 7 register int const *pb b; 8 return *pa > *pb ? 1: *pa < *pb ? 1 : 0; 9 } 10 11 int main(void) 12 { 13 int *array; 14 int n_value; 15 int i; 16 17 printf(\"How many values are there?\"); 18 if(scanf(\"%d\", &n_value) ! 1 n_value < 0 ) 19 { 20 printf(\"Illeage number of value \\n\"); 21 exit(EXIT_FAILURE); 22 } 23 24 array malloc(n_value * sizeof(int)); 25 if(array NULL){ 26 printf(\"Can't get memory for that many value.\\n\"); 27 exit(EXIT_FAILURE); 28 } 29 30 for(i 0;i < n_value; i++) 31 { 32 printf(\"? \"); 33 if(scanf(\"%d\", array + i) ! 1)//输入要保存的数据 34 { 35 printf(\"Error reading vlue #%d\\n\", i); 36 free(array); 37 exit(EXIT_FAILURE); 38 } 39 } 40 41 qsort(array, n_value, sizeof(int), compare_integers); //按照规定的顺序对数组进行排列 42 43 for(i 0;i<n_value; i++) 44 { 45 printf(\"%d\\n\", array[i]); 46 } 47 free(array); 48 return EXIT_SUCCESS; 49 50 } ``` 复制字符串，用于读取大文件的信息保存 ```C 1 #include <stuio.h> 2 #include <string.h> 3 4 char *strdup(char const *string) 5 { 6 char *new_string; 7 new_string malloc(strlen(string) + 1); 8 if(new_string ! NULL) 9 strcpy(new_string , string); 10 return new_string; 11 } ```"},"/note/编程基础/C和指针/2022-7-28-预处理器.html":{"title":"预处理器《C和指针》","content":" layout: post title: \"预处理器《C和指针》\" date: 2022 7 28 11:29:08 +0800 tags: C和指针 C语言 # 预处理器 ## 预定义的符号 ```C __FILE__ 进行编译的源文件名 __LINE__ 当前的行数 __DATE__ 编译时候的日期 __TIME__ 时间 __STDC__ 编译器是否遵循ANSI C ``` ```C 1 #include <stdio.h> 2 3 int main(void){ 4 printf(\"file %s\\n\", __FILE__); 5 printf(\"line %d\\n\", __LINE__); 6 printf(\"date %s\\n\", __DATE__); 7 printf(\"time %s\\n\", __TIME__); 8 printf(\"stdc %d\\n\", __STDC__); 9 10 11 return 0; 12 } result : file main.c line 5 date Jul 28 2022 time 18:08:31 stdc 1 ``` ## #define 使用define你可以把文本替换到程序之中 如果define很长可以用 \\ 来连接不同的行 ```C #define DEBUG_PRINT printf(\"File %s line: %d:\" \\ \t\t\t\t\t\t\" x %d, y %d, z %d\", \\ \t\t\t\t\t\t__FILE__, __LINE__, x, y, z) 6 int main(void) 7 { 8 int x 2; 9 int y 1; 10 int z 4; 11 DEBUG_PRINT; 12 return 0; 13 } ``` 在这个宏定义调用的时候加了一个分号，所以在定义的时候最好不要加分号,如果插入宏定义的地方只能插入一条语句就会出问题，最好定义为函数 ```C #define PROCESS_LOOP \\ \t\t\tfor(i 0; i < 10; i++) \\ \t\t\t{\t\t\t\t\t\t\\ \t\t\tsum + i;\t\t\t \\ \t\t\t\tif(i>0)\t\t\t\t\\ prod * i;\t\t \\ \t\t\t} ``` ### 宏 ```C #define name(parameter list) stuff ``` parameter list是一个用逗号分割的符号列表，括号左边必须和name紧邻 > 在使用的时候会原封不动的进行转换，所以要注意是不是会与周围的语句产生不同的含义 尽量少使用宏改变C语言的执行方式，让他看起来像别的语言的实现，会导致代码阅读不方便 ### define替换 在执行#define的替换的时候要涉及几个步骤 + 宏调用的时候检查是不是有地方包含#define定义的符号，有的话替换 + 替换的文本插入原来的位置 + 再次扫描 > 所以宏参数可以包含其他的宏符号，但是不能进行递归 > > 在检查的时候不会检查字符串内部 **插入到字符串的方法：** + 利用临近的字符串自动连接 ```C 1 #include <stdio.h> 2 3 #define PRINT(PORMAT, VALUE) \\ 4 printf(\"The value is \"PORMAT\"\\n\", VALUE) 5 6 int main(void) 7 { 8 PRINT(\"%d\", 23); 9 10 return 0; 11 } ``` + 适用预处理器把宏定义转换为字符串 #argument 被翻译成\"argument\" ```C 1 #include <stdio.h> 2 3 #define PRINT(FORMAT,VALUE) \\ 4 printf(\"The value of \"#VALUE\" is \"FORMAT\"\\n\", VALUE) 5 int main(void) 6 { 7 int x 1; 8 PRINT(\"%d\", x+3); 9 return 0; 10 } result: \tThe value of x+3 is 4 ``` + `##` 构建一种不同的任务，他把两个符号连接到一起，构成一个新的符号 ```C 1 #include <stdio.h> 2 3 #define ADD_TO_SUM(sum_number, value) \\ 4 sum ## sum_number + value 5 6 int main(void) 7 { 8 int sum2 1; 9 ADD_TO_SUM(2, 45); 10 printf(\"%d\\n\", sum2); 11 } ``` ### 宏与函数 宏频繁的使用于简单的运算，原因 + 从函数来回的时间可能比计算本身更长 + 函数必须声明为固定的类型，宏可以作用于不同的类型 **缺点** + 使用的宏最后都会插入到程序之中，大量使用会使得程序变长 有一些任务函数不能实现 ```C #define MALLOC(n, type) ((type *)malloc((n) * sizeof(type))) ``` ### 有副作用的宏参数 如果宏参数在宏定义中出现多次，就有可能会产生副作用 ```C #define MAX(a, b) ((a) > (b) ? (a) : b) x 5; y 8; z MAX(x++, y++);//这里较大的数进行了两次相加 //这个时候 x 6 y 10 z 9 ``` 类似的还有getchar函数 ### 命名约定 由于使用的规则不同，最好让程序员知道的使用的是宏还是函数，但是两者的使用方法相同 + 所有的字母大写 不同之处 属性 #define宏 函数 : : : : : : 代码长度 使用时会插入代码，程序大幅度增加 代码只出现在一个地方，每次都到同一个地方调用 执行速度 更快 存在函数的调用返回 操作符优先级 宏参数的求值是在周围的环境之中，会受到环境的影响，除非加上括号 函数的参数在函数调用的时候求值，求值的结果更容易预测 参数求值 参数每次使用于宏定义的时候都会重新求值，由于多次求值导致结果不可预测 在被调用之前只求值一次，多次调用不会多次求值 参数类型 宏与类型无关，只要参数合法就可以使用 函数的参数和类型有关，类型不同要用不同的参数 ### #undef 用于移除一个宏定义 ### 命令行定义 许多编译器允许在命令行之中定义符号 + 使用 D命令可以在编译的时候创建变量 ```C Dname Dname stuff ``` ```C //main5.c 1 #include <stdio.h> 2 3 int main(void) 4 { 5 int test[ARRAY_SIZE];//在之后才决定大小 6 printf(\"%d\\n\", sizeof(test)); 7 return 0; 8 } gcc DARRAY_SZIE 5 main5.c result : 20 ``` + 使用 U会使得对应的变量被忽略 ```C Uname//实测不好用，只有在传参数定义宏的时候才会起作用 ``` ## 条件编译 ```C #if constant expression \tstamtments #endif ``` constant expression由预处理器求值，如果求得的值是真的那就执行 ```C #if constant expression \tstamtments #elif constant expression \tstamtments #else stamtments #endif ``` **示例** ```C #define DEBUG 1 #if DEBUG printf(\"x %d\\n\", x); #endif ``` > 在早期的编译器中没有elif，但是可以使用if的嵌套来完成复杂的程序 ### 是否被定义 ```C #if define(symbol) #ifdef symbol #if !define(symbol) #ifndef symbol ``` ## 文件包含 预处理的时候删除这一条指令，并把文件中的内容取而代之 在这个时候整个头文件都会被编译一次，所以最好只放函数的声明，只存放必要的文件 使用#ifndef防止重复编译 ### 嵌套文件包含 标准要求编译器最少支持8层以上的头文件包含 + 会导致不能判断真正的依赖关系，在编译的时候造成困难 + 头文件多次包含 ```C #ifndef __AAAA #define __AAAA #endif ``` ## 其他指令 + #error ```C #error text of error message//在编译的时候发出一个错误信息 ``` 示例 ```C 1 #error \"111111\" 2 int main(void) 3 { 4 return 0; 5 } result: main7.c:1:2: error: #error \"111111\" 1 #error \"111111\" ^~~~~ ``` + #line ```C #line number \"string\" //line行号，string可选文件名更改 ``` 示例 ```C 1 #include <stdio.h> 2 3 #line 100 \"test110.c\" 4 5 int main(void){ 6 printf(\"file %s\\n\", __FILE__); 7 printf(\"line %d\\n\", __LINE__); 8 return 0; 9 } result: file test110.c line 103 ``` > 常用于把其他语言转换为C语言的代码之中，错误信息是源文件的行号和文件名 + #program 编译器处理一些设置，根据编译器的不同进行改变 + `#` 单独一行，不加任何东西，用来突出显示其他行，在编译的时候会直接被删除"},"/note/编程基础/C和指针/2022-7-30-经典抽象数据类型.html":{"title":"经典抽象数据类型《C和指针》","content":" layout: post title: \"经典抽象数据类型《C和指针》\" date: 2022 7 30 10:11:08 +0800 tags: C和指针 C语言 # 经典抽象数据类型 有些抽象数据类型(ADT)是不可或缺的工具,链表,堆栈, 队列, 树等 ## 内存分配 所有的ADT都必须确定一件事情,如何获取内存来存储值 + 静态数组: 固定的长度,编译的时候确定 + 动态分配数组: 运行时候决定 + 动态分配链式结构: 最灵活 ## 堆栈 ### 接口 传统的堆栈有三种接口, push, top, pop > top: 查看顶层 > > push: 入栈 > > pop: 移出但是不返回 还需要一个判断栈是不是为空的函数, 以及一个判断是不是满了的函数 ### 实现 + `stack.h` ```C 1 #define STACK_TYPE int 2 #include <stddef.h> 3 void push(STACK_TYPE value); 4 STACK_TYPE pop(void); 5 STACK_TYPE top(void); 6 int is_empty(void); 7 int is_full(void); 8 void create_stack(size_t size); 9 void destory_stack(void); ``` + `stack.c` ```C 1 #include \"stack.h\" 2 #include <stdlib.h> 3 #include <stdio.h> 4 #include <assert.h> 5 6 static size_t stack_size; 7 static STACK_TYPE *stack; 8 static int top_element 1; 9 10 void create_stack(size_t size) 11 { 12 assert(stack_size 0); 13 stack_size size; 14 stack malloc(stack_size * sizeof(STACK_TYPE)); 15 assert(stack ! NULL); 16 } 17 18 void destory_stack(void) 19 { 20 assert(stack_size > 0); 21 stack_size 0; 22 free(stack); 23 stack NULL; 24 } 25 26 void push(STACK_TYPE value) 27 { 28 assert(!is_full()); 29 top_element + 1; 30 stack[top_element] value; 31 } 32 33 STACK_TYPE pop(void) 34 { 35 STACK_TYPE temp; 36 assert(!is_empty()); 37 temp stack[top_element]; 38 top_element 1; 39 return temp; 40 } 41 42 STACK_TYPE top(void) 43 { 44 assert(!is_empty()); 45 return stack[top_element]; 46 } 47 int is_empty(void) 48 { 49 assert(stack_size > 0); 50 return top_element 1; 51 } 52 int is_full(void) 53 { 54 assert(stack_size > 0); 55 return top_element stack_size 1; 56 } ``` + 链表实现 ```C 1 #include <stdio.h> 2 #include <stdlib.h> 3 #include \"stack.h\" 4 #include <assert.h> 5 6 #define FALSE 0 7 8 typedef struct STACK_NODE{ 9 STACK_TYPE value; 10 struct STACK_NODE *next; 11 }StackNode; 12 13 static StackNode *stack NULL; 14 15 void create_stack(size_t size){ 16 } 17 18 void destory_stack(void) 19 { 20 while(!is_empty()) 21 pop(); 22 } 23 void push(STACK_TYPE value) 24 { 25 StackNode *new_node; 26 27 new_node malloc(sizeof(StackNode)); 28 assert(new_node ! NULL); 29 new_node >value value; 30 new_node >next stack; 31 stack new_node; 32 } 33 34 STACK_TYPE pop(void) 35 { 36 StackNode *first_node; 37 STACK_TYPE temp; 38 if(!is_empty()){ 39 first_node stack; 40 temp first_node >value; 41 stack first_node >next; 42 free(first_node); 43 44 return temp; 45 } 46 return 1; 47 } 48 49 STACK_TYPE top(void) 50 { 51 assert(!is_empty()); 52 return stack >value; 53 } 54 int is_empty(void){ 55 return stack NULL; 56 } 57 int is_full(void){ 58 return FALSE; 59 } ``` ## 队列FIFO + 循环数组 > 当用一个指针指向头部,一个指向尾部的时候, 在为空的时候,需要把尾部放在比头部小一个的位置,这时候和数组满了的时候的格式一样 > **解决方法:**重新定义数组满的概念, 数组中有一个元素一直不使用 > > **满:**`(rear + 2) % QUERE_SIZE front` > > **空:** `(rear + 1) % QUERE_SIZE front` ```C 1 #include \"queue.h\" 2 #include <stdio.h> 3 #include <assert.h> 4 #define QUEUE_SIZE 100 5 #define ARRAY_SIZE (QUEUE_SIZE + 1) 6 7 static QUEUE_TYPE queue[ARRAY_SIZE]; 8 static size_t front 1; 9 static size_t rear 0; 10 11 void insert(QUEUE_TYPE value){ 12 assert(!is_full()); 13 rear (rear+1) % ARRAY_SIZE; 14 queue[rear] value; 15 } 16 void delect(void) 17 { 18 assert(!is_empty()); 19 front (front + 1) % ARRAY_SIZE; 20 } 21 22 QUEUE_TYPE first(void) 23 { 24 assert(!is_empty()); 25 return queue[front]; 26 } 27 28 int is_empty(void) 29 { 30 return (rear + 1) % ARRAY_SIZE front; 31 } 32 int is_full(void) 33 { 34 return (rear + 2) % ARRAY_SIZE front; 35 } ``` ## 树 要么为空,要么具有零个或多个孩子, 每个孩子本身也是树, 递归的设置提示了树的高度没有内在的限制 ### 二叉搜索树 树的特殊形式 + 每个节点最多有两个孩子, 左孩子, 右孩子 + 每个节点比他所有的左子树的值要大, 但是比右子树的值要小 + 排除了相等的可能性 没有孩子的节点被称为叶节点 ### 在二叉树之中插入 ``` 树为空: \t新的值作为根节点插入 否则: \t小于当前: \t\t插入左侧 \t否则: \t\t右侧 ``` ### 在二叉树中删除 + 删除没有孩子的节点 + 删除有一个孩子 + 删除有两个: 删除左侧最的大一个值把他替换这个值 ### 在二叉树中查找 ``` 树为空: \t不存在 否则: \t和根节点相等: \t\t成功 \t否则: \t\t小于: \t\t\t左侧 \t\t否则: \t\t\t右侧 ``` ### 树的遍历 有几种不同的次序 + 前序: 检查节点然后递归的遍历左子树右子树 + 中序: 先遍历左侧然后检测当前节点, 最后右侧 + 后序: 首先遍历左右然后当前节点 + 层次遍历: 处理根节点, 然后他的儿子, 然后孙子 ### 实现 #### 数组类型 + 节点N的双亲节点是N/2 + 节点N左孩子是2N + 节点右孩子是2N+1 问题: 数组是从零开始的 1. 忽略第一个元素 2. 更改规则 + 节点N的双亲节点是(N+1)/2 1 + 节点N左孩子是2N+1 + 节点右孩子是2N+2 数组存在的问题: + 不能够随意插入, 会导致浪费, + 分配不同元素利用率不同 ```C 1 #include <stdio.h> 2 #include <assert.h> 3 #include \"tree.h\" 4 5 #define TREE_SIZE 100 6 #define ARRAY_SIZE (TREE_SIZE + 1) 7 8 static TREE_TYPE tree[ARRAY_SIZE]; 9 //查询分支的位置 10 static int left_child(int current) 11 { 12 return current * 2; 13 } 14 15 static int right_child(int current) 16 { 17 return current * 2 + 1; 18 } 19 //插入一个元素 20 void insert(TREE_TYPE value) 21 { 22 int current; 23 assert(value ! 0); 24 current 1; 25 while(tree[current] ! 0){//根据数值寻找位置所在 26 if(value < tree[current]) 27 current left_child(current); 28 else{ 29 assert(value ! tree[current]);//保证不会有重复的元素 30 current right_child(current); 31 } 32 assert(current<ARRAY_SIZE); 33 } 34 tree[current] value; 35 } 36 37 TREE_TYPE *find(TREE_TYPE value) 38 { 39 int current; 40 current 1; 41 while(current < ARRAY_SIZE && tree[current] ! value){ 42 if(value < tree[current]) 43 current left_child(current); 44 else 45 current right_child(current); 46 } 47 if(current < ARRAY_SIZE) 48 return tree + current; 49 else 50 return 0; 51 } 52 static void do_per_order_traverse(int current, void (*callback)(TREE_TYPE value)) 53 {//遍历到每一个元素并进行一定的处理 54 if(current < ARRAY_SIZE && tree[current] ! 0) 55 { 56 callback(tree[current]); 57 do_per_order_traverse(left_child(current), callback); 58 do_per_order_traverse(right_child(current), callback); 59 } 60 } 61 //外部可以使用的 62 void pre_order_traverse(void (*callback)(TREE_TYPE value)) 63 { 64 do_per_order_traverse(1, callback); 65 } ``` #### 链表类型 由于每一个节点必须有左右两个孩子, 所以用两个指针 ```C 1 #include \"tree.h\" 2 #include <assert.h> 3 #include <stdio.h> 4 #include <malloc.h> 5 6 typedef struct TREE_NODE{//用于存储数据的结构体 7 TREE_TYPE value; 8 struct TREE_NODE *left; 9 struct TREE_NODE *right; 10 }TreeNode; 11 12 static TreeNode *tree;//建立一个指向根部的指针 13 14 void insert(TREE_TYPE value) 15 { 16 TreeNode *current; 17 TreeNode **link;//用来指向上一级的指针的指针 18 19 link &tree;//初始化为根部 20 while((current *link) ! NULL) 21 { 22 if(value < current >value) 23 link &current >left; 24 else{ 25 assert(value ! current >value); 26 link &current >right; 27 } 28 } 29 30 current malloc(sizeof(TreeNode)); 31 assert(current ! NULL); 32 current >value value; 33 current >left NULL; 34 current >right NULL; 35 *link current;//创建与上一级的链接 36 } 37 38 TREE_TYPE *find(TREE_TYPE value) 39 { 40 TreeNode *current; 41 current tree;//指向根部 42 while(current ! NULL && current >value ! value) 43 { 44 if(value<current >value) 45 current current >left; 46 else 47 current current >right; 48 } 49 if(current ! NULL) 50 return &current >value;//返回一个指向数据的指针 51 else 52 return NULL; 53 } 54 55 static void do_pre_order_traverse(TreeNode *current, 56 void (*callback)(TREE_TYPE value)) 57 { 58 if(current ! NULL) 59 { 60 callback(current >value);//对每一个数据进行处理 61 do_pre_order_traverse(current >left, callback);//对左侧进行遍历 62 do_pre_order_traverse(current >right, callback);//右侧 63 } 64 } 65 66 void pre_order_traverse(void (*callback)(TREE_TYPE value)) 67 { 68 do_pre_order_traverse(tree, callback);//外部调用 69 } ``` ## 实现的改进 ### 拥有超过一个堆栈 由用户进行对堆栈的创建,再通过参数进行访问, 用户可以创建任意数量的堆栈, 然后进行访问 ### 拥有超过一种的类型 + 为每一种类型写代码 + 实现#define的宏 + 使用void *类型 ### 名字冲突 不同的结构之间可能有相同的函数名字 ### 标准库的ADT C语言暂时没有提供,但是可以用#define模拟 + `g_atck.h` ```C 1 #include <assert.h> 2 /*建立一个栈初始化的声明,数据类型,标记,大小*/ 3 #define GENERIC_STACK(STACK_TYPE, SUFFIX, STACK_SIZE) \\ 4 static STACK_TYPE stack##SUFFIX[STACK_SIZE]; \\ 5 static int top_element##SUFFIX 1; \\ 6 int is_empty##SUFFIX(void) \\ 7 { \\ 8 return top_element##SUFFIX 1; \\ 9 } \\ 10 int is_full##SUFFIX(void) \\ 11 { \\ 12 return top_element##SUFFIX STACK_SIZE 1; \\ 13 } \\ 14 void push##SUFFIX(STACK_TYPE value) \\ 15 { \\ 16 assert(!is_full##SUFFIX()); \\ 17 top_element##SUFFIX + 1; \\ 18 stack##SUFFIX[top_element##SUFFIX] value; \\ 19 } \\ 20 void pop##SUFFIX(void) \\ 21 { \\ 22 assert(!is_empty##SUFFIX()); \\ 23 top_element##SUFFIX 1; \\ 24 } \\ 25 STACK_TYPE top##SUFFIX(void) \\ 26 { \\ 27 assert(!is_empty##SUFFIX()); \\ 28 return stack##SUFFIX[top_element##SUFFIX]; \\ 29 } ``` + `g_atck.c` ```C 2 #include <stdio.h> 3 #include \"g_atck.h\" 4 5 GENERIC_STACK(int, _int, 10)//建立第一个栈 6 GENERIC_STACK(float, _float, 10) 7 int main(){ 8 push_int(5); 9 push_int(22); 10 push_int(15); 11 push_float(25.4); 12 push_float( 40.5); 13 14 while(!is_empty_int()){ 15 printf(\"*Popping %d\\n\", top_int()); 16 pop_int(); 17 } 18 while(!is_empty_float()){ 19 printf(\"*Popping %f\\n\", top_float()); 20 pop_float(); 21 } 22 return EXIT_SUCCESS; 23 } result: *Popping 15 *Popping 22 *Popping 5 *Popping 40.500000 *Popping 25.400000 ```"},"/note/编程基础/C和指针/2022-7-26-数组.html":{"title":"数组《C和指针》","content":" layout: post title: \"数组《C和指针》\" date: 2022 7 26 11:29:08 +0800 categories: C和指针 # 数组 ## 一维数组 ### 数组名 数组明用来记住这个数组的属性，当数组在表达式中使用的时候，编译器会为他产生一个指针常量(不能修改的值) 只有在两种情况下数组名不是被当成指针使用 + sizeof + &：产生一个指向数组的指针，而不是一个指向指针的指针,指针的类型是一个数组类型 ```C 1 #include <stdio.h> 2 3 int main(){ 4 int a[10]; 5 int b[10]; 6 int *p; 7 p a; 8 printf(\"p a %p\\n\", p); 9 p &a; 10 printf(\"p &a %p\\n\", p); 11 return 0; 12 13 } result: /* main.c: In function ‘main’: main.c:9:11: warning: assignment to ‘int *’ from incompatible pointer type ‘int (*)[10]’ [ Wincompatible pointer types] 9 p &a; ^ jiao@jiao virtual machine:~/桌面/point_and_c/8$ ./a.out */ p a 0x7ffd32d61a60 p &a 0x7ffd32d61a60 ``` > 非法使用 > > ```C > int a[10]; > int b[10]; > int *c; > b a; //非法 > a c; //非法 > a++;//非法，不能改变a的值 > c a; //合法 > > ``` ### 下标引用 array[subscript] < > *(array + (subscript)) 2[array] < > *(array + 2) < > array[2] ### 指针和下标 在可读性方面下标有优势，但是有可能会影响效率 ```C int array[10],a; for(a 0;a<10;a+ 1) array[a] 0;//每次循环的时候进行一次乘法 ``` ```C int array[10],*ap; for(ap array,ap<array+10;ap++)//由于每次进行的乘法相同弄，所以只在编译的时候进行一次 \t*ap 0; ``` ### 指针的效率 **<u>指针有着更高的效率，前提是被正确的使用，不要为了效率上的细微差距牺牲了可读性</u>** > 示例: 把y中的数据复制到x中 ```C #define SIZE 50 int x[SIZE]; int y[SIZE]; int i; int *p1,*p2; ``` 下标 ```C void try1(void) { for(i 0; i<SIZE; i++) x[i] y[i]; } ``` 指针 ```C void try2(void) { for(p1 x,p2 y;p1 x <size;)//两个指针相减的时候会进行除法 *p1++ *p2++; } ``` ```C void try3(void) { for(i 0,p1 x,p2 y;i<SIZE;i++)//在每次进行的时候需要把指针的值移到寄存器 *p1++ *p2++; } ``` ```C void try4(void) { register int *p1,*p2; register int i; for(i 0,p1 x,p2 y;i<SIZE;i++) \t\t*p1++ *p2++; } ``` ```C void try5(void) { register int *p1, *p2; for(p1 x,p2 y;p1<&x[SIZE];)//消除指针器 *p1++ *p2++; } ``` #### 总结 + 当根据某个固定的量在数组中移动的时候，使用指针比使用下标效率更高 + 声明为寄存器比静态内存和堆栈中的指针效率更高，但是当前的编译器会自动进行优化，并且做的比程序员更好 + 通过测试一些已经初始化并调整的内容判断循环的终止就不需要单独的计数器 + 在运算时候求值的表达式代价更高 ### 声明数组参数 数组再传递的时候传递的是一个指针,在传递的时候不传递数组的长度 ```C int strlen(char *string); < > int strlen(char string[]); ``` ### 初始化 + 在声明的时候初始化```int vector[5] {1, 2, 3, 4, 5};``` ### 静态和自动初始化 > 和变量的初始化方式相似 > 应该考虑在每次进入函数的时候初始化一个数组是不是值得 ### 不完整的初始化 + 超出指定的空间 > 非法 + 没有全部初始化 > 剩下的设置为0 ### 字符串初始化 ```C char message[] \"hello\"; char message[] {'h', 'e', 'l', 'l', 'o'};//初始化一个字符数组 char *message \"Hello\";//初始化一个数组 ``` ## 多维数组 ```C int a; int b[10]; int c[6][10];//c是一个六元素的数组，每个元素是一个十元素的数组 int d[3][6][10]; ``` 多维数组的存储是按照右边的下标先变化的顺序进行存储的，但是应该尽量避免使用指针进行行的变化 > 一个二维数组的数组名是指向一个一维数组的指针 示例 ```C int matrix[3][10]; matrix //指向第一个数组 matrix + 1 //指向第二个数组 *(matrix + 1) + 5//第二列的五个指针 *(*(matrix + 1) + 5)//第二列第五个的值 *(matrix[1] + 5) ``` ### 指向数组的指针 > 错误示范 ：```int matrix[3][10], *mp matrix;```，实际的指针应该是```int (*p)[10]```,p是一个指向整形数组的指针 > 如果要创建一个可以逐个访问的指针```int *pi &matrix[0][0];```或者```int *pi &matrix[0];``` **注：**不要使用```int (*p)[ ] matrix;```初始化一个指针，系统会认为这是长度为0，在进行运算时会和长度相乘造成错误 ### 作为函数参数的多维数组 多维数组的每个参数是一个数组，编译器要知道他的维数 ```C void func(int (*mat)[10]); void func(int mat[][10]); ``` ### 初始化 ```C int matrix[2][3] {1, 2, 3, 4, 5, 6}; int matrix[3][5] { {00, 01, 02, 03, 04}, {10, 11, 12, 13, 14}, {20, 21, 22, 23, 24} } ``` ![QQ图片20220726233158](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311011800079.png) > 加不加花括号对结果没有影响。但是可以帮助理解，并且可以省略尾部的几个初始值 ### 数组长度自动计算 只有第一维数组才可以省略，自动计算，后面的都需要添加 ## 指针数组 每一个参数都是一个指针，可以用来存放字符串的首地址"},"/note/编程基础/C和指针/2022-7-31-运行时环境.html":{"title":"运行时环境《C和指针》","content":" layout: post title: \"运行时环境《C和指针》\" date: 2022 7 30 10:11:08 +0800 tags: C和指针 C语言 # 运行时环境 <u>本书使用的是不常用的机型, 建议使用其他书进行细致了解</u> ## 判断运行时环境 ### 静态变量和初始化 进入数据区,为变量进行声明初始化 ### 堆栈帧 一个函数分为三部分 + 函数序: 执行启动函数的需要的操作, 例如为局部变量保留栈中的内存 + 函数体: 执行有用的工作 + 函数跋: 函数返回之前清理堆栈 声明函数,进入函数,把相关的值存入栈中 局部变量声明和函数原型不会产生任何代码, 但是局部变量声明的时候会产生 ### 寄存器变量 寄存器的是有限的, 超出的会被保存在栈, 不同的机器不同, 有的类型太长不能被存放在寄存器之中 ### 外部标识符的长度 外部名字的长短是由链接器确定的, 他有可能会接受所有长度, 但是忽略除了前几个以外的其他字符, 标准要求最少区分六个字符 ### 判断栈帧的分布 #### 传递函数参数 + 把参数压入栈 + 记录函数的返回地址 #### 函数序 + 对旧的寄存器的值进行保存 + 局部变量的保存 #### 函数跋 + 恢复寄存器的值 + 取出原来的地址, 进行返回 + 清理部分栈,参数并未清除 #### 返回值 根据不同的机器确定 ### 表达式副作用 函数应该返回一个值但是没有填写,有可能会返回一个错误的值, 这个值是计算的时候存储于用于返回的寄存器中 ## 运行时效率 当一个函数的容量超过了内存的数量, 就不能运行 现在的机器使用虚拟内存 现代的编译器在代码优化方面做的很好,因此把时间放在一些小的修改是不值得的 当一个程序运行的速度很慢的时候, 可以对程序使用性能评测 + 减少用时长的库函数的使用 + 对调用次数多的短小函数设置寄存器变量 + 对使用时间长的函数换新的算法 ## 警告 + 你不能链接不同编译器产生的程序 + 使用汇编会使得移植姓降低"},"/note/编程基础/C和指针/2022-7-27-结构和联合.html":{"title":"结构和联合《C和指针》","content":" layout: post title: \"结构和联合《C和指针》\" date: 2022 7 27 11:29:08 +0800 categories: C和指针 # 结构体和联合 聚合数据类型能同时存储超过一个的单独数据，C语言提供了两种，数组和结构。 元素数组可以通过下标访问，结构体不能。 结构体名不能当成指针来使用 结构体属于标量类型，可以作为函数参数，相互之间可以相互赋值 ## 结构体声明 ```C struct tag{number list}variable list; ``` > 必须列出所有的成员，就算两个结构体的成员完全一样，最后的结构体也是两种不同的结构体 ```C struct { int a; char b; float c; }x;//声明一个结构体 struct { int a; char b; float c; }y[20], *z;//声明一个结构体的数组以及一个指针 ``` #### 和typedef一块使用 ```C tyoedef struct{ int a; char b; float c; }Simple;//重命名为Simple ``` ### 结构体成员的直接访问 不同结构体可以拥有名字相同的结构体成员 + 通过( .)直接访问 > ((comp.sa)[4]).c < > comp.sa[4].c ### 间接访问 有一个结构体的指针cp，访问他的成员 + `(*cp).c` > ( .)的优先级要比*的优先级要高，所以要加括号 + cp >c ### 结构体的自引用 ```C struct SELF_REF1{ int a; struct SELF_REF1 b; int c; };//错误的引用，会生成无限多的结构体 struct SELF_REF2{ int a; struct SELF_REF1 *b; int c; };//正确的使用方法 typedef struct{ int a; SELF_REF3 *b; int c; }SELF_REF3;//错误，使用的结构体声明还没有定义 typedef struct SELF_REF3_TAG{ int a; SELF_REF3_TAG *b; int c; }SELF_REF3;//正确 ``` ### 不完整的声明 ```C struct B; struct A{ struct B *partner; ... }; struct B{ struct A *partner; ... }; ``` ### 初始化类 > 似于多维数组 ## 结构、指针和成员 ```C typedef struct { int a; short b[2]; }Ex2; typedef struct EX{ int a; char b[3]; Ex2 c; struct EX *d; }Ex; Ex x {10, \"Hi\",{5, { 1, 25}}, 0}; Ex *px &x; ``` ### 访问指针 `px+1`:不合法，会指向下一个相邻的结构体大小的内存 `*px >c.b`:直接访问数组的第一个变量 ## 结构体的存储分配 编译器禁止结构体的起始位置跳过几个字节，所以结构体的对齐是按照最严格的成员对齐的 每一个成员都必须对齐 + 在创建结构体的时候对齐要求严格的数据先出现 ```C 1 #include <stdio.h> 2 #include <stddef.h> 3 struct A{ 4 int a; 5 short b; 6 char c; 7 }a; 8 9 int main(void) 10 { 11 printf(\"%d\\n\", offsetof(struct A, a)); 12 printf(\"%d\\n\", offsetof(struct A, b)); 13 printf(\"%d\\n\", offsetof(struct A, c)); 14 } result: 0 4 6 ``` 可以使用stddef.h中的`offsetof(type, nember);`查看每一个元素的偏移 ### 作为函数参数的结构体 + 直接把结构体作为参数：占用的空间大，不适合多次调用，效率低 + 指针传递：必须用间接访问来访问参数 ## 位段 声明和结构体类似但是成员是一个或者多多个位的字段，不同长度的字段实际存储于一个或者多个整形之中 **注意** + 在意可移植性的程序少使用 + 是有符号数还是无符号数 + 位段的最大值 + 位段成员分配方向 ## 联合 存储在内存的相同位置 当一个数据有好几种可能性的时候就可以使用，可以和结构体联合使用，定义不同的成员 ```C struct A1{ ... }; struct A2{ ... }; struct B{ enmu {A1, A2} type; union{ struct A1; struct A2; }info; } ``` 联合体的长度是成员的最大值 ### 初始化 它的初始化必须初始化第一个成员，并且位于一个大括号之中 ```C union { int a; float b; char c[4]; }x {5}; ```"},"/note/编程基础/C和指针/2022-7-25-数据.html":{"title":"数据","content":" layout: post title: \"数据\" date: 2022 7 25 11:29:08 +0800 categories: C和指针 # 数据 C语言只有四种基本类型：整形、浮点型、指针、聚合类型 ### 整形 只规定有每个类型的最小值，短整型，整形，长整型没有规定必须不一样长，但是长整型> 整形> 短整型，长整型> 32位，短整型> 16位 规定位于limits.h char:如果声明signed和unsigned可以提高可移植性，但是有可能会降低处理速度，最好的办法是使用两者的交集，只有在进行显式声明的时候才可以进行算术运算。 ##### 常量(字面值) 在直接输入一个常量的时候，会给它分配一个最小的但是可以容纳类型 > 字符常量如'a', '\\n'等都是默认为int类型 ##### 浮点数 默认情况下是double型的变量 ### 指针 + 指针常量 + 字符常量 + ... **声明**： ```C int *a, b, c;//只有一个指针 int *a, *b, *c;//定义三个指针 ``` 注：在声明指针常量的时候要注意const位置不同带来的差异 ``` C int const *a;//指针的指向的对象的值不能改版 int * const a;//指针指向的地址不能改变 ``` ### 作用域 有四种 + 文件作用域 + 函数作用域 + 代码块作用域 + 原型作用域：在函数声明的括号之中声明的变量 函数的形参的作用域是在在外层的括号之中 ### 链接属性 + extern 定义的全局变量，用于一个标识符的第一次声明，在其他位置不生效 + internal 定义为static的变量，只能在文件内使用 + none 函数的声明以及函数内部定义的变量 ### 存储的类型 + 普通内存：static + 运行时候的堆栈：auto + 硬件寄存器 > 注：使用static修饰的变量，只能改变存在的时间，不能改变作用域"},"/note/编程基础/C和指针/2022-7-25-语句.html":{"title":"语句","content":" layout: post title: \"语句\" date: 2022 7 25 11:29:08 +0800 categories: C和指针 # 语句 C语言不存在专门的赋值语句，使用表达式语句代替 C语言没有Bool类型，使用整形来代替 ### 空语句 不需要执行任务但是必须存在 ### 表达式语句 赋值语句在表达式之中进行 在表达式之后加上分号就会变成表达式语句 ### 代码块 两个花括号之间的可选声明，语句列表，允许你在只可以使用一条语句的地方使用好几条语句 ### switch语句 和其他语言不同，只能使用整形 case是语句的进入地点，不是划分，可以利用这个特性在多个值都可以执行 ```C switch(expression) { case 1: case 2: case 3: statement list; break; case 4: case 5: ... } ``` 使用default进行最后的都不满足的处理，可以出现在任何位置，当都不匹配的时候进行 ```C 1 #include <stdio.h> 2 3 void test(int n) 4 { 5 switch(n) 6 { 7 case 1: 8 printf(\"1\\n\"); 9 break; 10 case 2: 11 printf(\"2\\n\"); 12 default: 13 printf(\"over\\n\"); 14 case 3: 15 printf(\"3\\n\"); 16 } 17 } 18 int main(void) 19 { 20 test(1); 21 printf(\"\\n\\n\\n\"); 22 test(2); 23 printf(\"\\n\\n\\n\"); 24 test(3); 25 printf(\"\\n\\n\\n\"); 26 test(4); 27 28 } result: 1 2 over 3 3 over 3 ```"},"/note/编程基础/C和指针/2022-7-30-标准库函数.html":{"title":"标准库函数《C和指针》","content":" layout: post title: \"标准库函数《C和指针》\" date: 2022 7 30 10:11:08 +0800 tags: C和指针 C语言 # 标准库函数 ## 整形函数 分为三类 + 算数 + 随机数 + 字符串转换 ### 算数`<stdlib.h>` ```C int abs(int value);//返回绝对值 long int labs(long int value);//返回绝对值 div_t div(int numerator, int denominator);//第二个参数除以第一个，返回商和余数 //返回值结构 int quot;//商，如果不能整除则是小于实际的结果的最大整数，为负数的时候不确定 int rem;//余数 ldiv_t div(long int number, long int deno) ``` ### 随机数`<stdlib.h>` ```C int rand(void); void srand(unsignde int seed); ``` `rand`返回一个范围在0到RAND_MAX的随机数，至少为32767 `srand`设置随机数`srand((unsigned int)time(0));`设置为时间 ### 字符串转换`<sdlib.h>` ```C int atoi(char const *string); long int atol(char const *string); long int strtol(char const *string, char **unused, int base); unsigned long int strtoul(char const *string, char **unused, int base); ``` > `atoi atol`:转换的值以10为基数 > `strtol strtoul`:转换的时候指定基数，在转换结束的时候把下一个字符的指针存放在unused之中，基数为0的时候任何用于书写整数的数字面值都会被书写,包括\"0x234\"这种,在基数为11 36的时候a z被翻译为10 35 ```C 1 #include <stdio.h> 2 #include <stdlib.h> 3 4 int main(void) 5 { 6 char *b; 7 long int a; 8 char **c &b; 9 a strtol(\"590bear\", c, 12);//e对于十二进制是非法的，返回的指针指向e 10 printf(\"%ld\\n\", a); 11 a strtol(\"0x123\", c, 0); 12 printf(\"%ld\\n\", a); 13 a strtol(\"00101\", c, 2); 14 printf(\"%ld\\n\", a); 15 return 0; 16 } resule: 9947 //11+12*12*9+12*12*12*5 291 5 ``` > 当返回值出错的时候会把错误传入`erno`,传入ERANGE，并返回错误标志 > > 函数 返回值 > > `strtol` 返回值太大为负数，LONG_MIN，太大为正数，LONG_MAX > `strtoul` 太大返回UNLONG_MAX ## 浮点型函数`<math.h>` 函数库中的返回值、参数大部分为double 定义域错误`errno`设置为EDOM 太大函数返回HUGE_VAL，太小返回0，有可能会把`errno`设置为ERANGE ### 三角函数 ```C double sin(double angle); double cos(double angle); double tan(double angle); double asin(double value); double acos(double value); double atan(double value); double atan2(double x, double y); ``` > `sin cos tan`的参数是一个用弧度表示得知，返回对应的值 > > `asin acos atan`返回的是反正弦函数，反余弦，反正切`asin atan`返回值是一个 π/2 π/2，`cos`的是0 π > > `atan2`使用y/x的值求反正切的值，通过两个数的符号决定象限，返回值为 π π ### 双曲函数 ```C double sinh(double angle); double cosh(double angle); double tanh(double angle); ``` ### 对数指数函数 ```C double exp(double x); double log(double x); double log10(double x); ``` > exp返回e的x次幂 > > log返回log以x的底数 > > log10以10为底数 ### 浮点数表示 根据编译器格式存储一个浮点数 ```C double frexp(double value, int *exponent); double ldexp(double fraction,int exponent); double modf(double value, double *ipart); ``` > `fraction X 2 ^ exponent value` > > `frexp`返回fraction > > `ldexp`返回value 用于在不能兼容浮点格式的机器之间传递信息 > `modf`把一个小数分解为两部分，整数部分存储以第二个参数，小数部分返回值 ### 幂 ```C double pcw(double x, double y); double sqrt(double x); ``` > `pcw`返回x的y次幂x^y，如果x是一个负数，y不是一个整数就会出现定义域错误 > > `sqrt`函数返回参数的平方根，为负数出现定义域错误 ### 底数、顶数、绝对值和余数 ```C double floor(double x); double cell(double x); double fabs(double x); double fmod(double x, double y); ``` > `floor`返回不大于这个数的最大整数 > > `cell`返回不小于的最小值 > `fabs`返回其参数的绝对值 > > `fmod`返回x除以y的余数 ### 字符转转换 ```C double atof(char const *string); double strtod(char const *string, char **unused); ``` 参数前有空白直接忽略，然后把合法的字符转换为一个double，忽略结尾的非法字符 `strtod`会返回一个指向下一个参数的指针 > 没有合法的参数返回0，如果过大存储不下`errno`存储ERANGE这个值函数返回HUGE_VAL ## 日期和时间函数 ### 处理时间`<time.h>` ```C clock_t clock(void); ``` 这个值可能是一个近似值，如果要更精确的值，可以再main函数最开始调用，然后用两个数相减，如果机器不能提供时间，或者时间太大返回 1,程序开始执行到调用这个函数的时间 > 返回的是一个数字，是处理器滴答的次数， 转换为秒应该除以常量CLOCK_PER_SEC ### 当天时间 `time_t time(time_t *retrun_value);` 返回的时间通过这个指针传递， 时间太大的话返回 1，标准没有定义具体的格式，最好不要直接使用 ### 时间日期的转换 ```C char *ctime(time_t const *time_value); double difftime(time_t time_t time2); ``` `ctime` 的参数是一个指向time_t的指针，返回的是一个字符串格式 ```C 1 #include <stdio.h> 2 #include <time.h> 3 #include <stdlib.h> 4 int main(void) 5 { 6 char *a, *b; 7 a (char *)malloc(30); 8 b a;//地址备份用于释放内存 9 time_t time_n; 10 time(&time_n); 11 a ctime(&time_n);//这个时a的值会发生改变 12 printf(\"%s\", a); 13 free(b); 14 return 0; 15 16 } result: Sat Jul 30 13:23:52 2022 ``` > `difftime`计算time1 time2的值，把结果转换为秒 ```C struct tm *gmtime(time_t const *time_value); struct tm *localtime(time_t const *time_value); ``` 用来把time_t的格式转换为一个结构体 > `gmtime`转为世界协调时间UTC > `localtime`转换为本地时间 tm结构体 类型 范围 含义 `int tm_sec` 0 61 分之后的秒数 `int tm_min` 0 59 小时之后的分钟数 `int tm_hour` 0 23 午夜之后的小时数 `int tm_mday` 1 31 当月的日期 `int tm_mon` 0 11 1月后的月份，从零开始 `int tm_year` 0 ?? 1900年之后的年数 `int tm_wday` 0 6 星期日后的天数 `int tm_yday` 0 365 一月一日之后的天数 `int tm_isdat` 夏令时标志 ```C 1 #include <stdio.h> 2 #include <time.h> 3 int main() 4 { 5 time_t time_n; 6 struct tm *tp; 7 time(&time_n);//获取时间 8 tp gmtime(&time_n);//时间转换为结构体 9 printf(\"time: %s\", ctime(&time_n));//转换为字符串 10 printf(\"hour:%d\\n\", tp >tm_hour); 11 printf(\"min:%d\\n\", tp >tm_min); 12 printf(\"mday:%d\\n\", tp >tm_mday); 13 } result: time: Sat Jul 30 15:26:22 2022 hour:15 min:26 mday:30 ``` + 结构体的操作 ```C char *asctime(struct tm const *tm_ptr); size_t strftime(char *string, size_t maxsize, char const *format, struct tm const *tm_ptr); ``` > `asctime`把结构体转换为一个字符串，和`ctime`的格式一样 > > `strftime`把字符串转换为一个，字符串的长度小于`maxsize`，被复制到第一个参数，返回值为字符串的长度，当字符串长度大于`maxsize`返回 1 代码 由……代替 : : : : %% 一个%字符 %a 星期的某一天，以当地星期几的格式简写 %A 星期的某一天，以当地星期几的格式全写 %b 月份，当地简写 %B 全写 %c 日期和时间使用%x和%X %d 一个月的第几天 0 31 %H 小时24小时制 0 23 %I 12小时制 0 12 %J 一年的第几天 001 365 %m 月份 01 12 %M 分钟 00 59 %P AM或者PM %S 秒 0 61 %U 第几个星期 周日为第一天 %w 星期的第几天 0 6 %W 第几个星期 周一为第一天 %x 日期 %X 时间 %y 当前世纪的年数 %Y 年份全写 %Z 时区简写 ```C 1 #include <stdio.h> 2 #include <stdlib.h> 3 #include <time.h> 4 int main(void) 5 { 6 time_t t; 7 char *c, *b; 8 struct tm *p; 9 c (char *)malloc(40); 10 b c; 11 time(&t); 12 p localtime(&t); 13 14 strftime(c, 40, \"a %a\\n\", p); 15 printf(\"%s\", c); 16 strftime(c, 40, \"A %A\\n\", p); 17 printf(\"%s\", c); 18 strftime(c, 40, \"b %b\\n\", p); 19 printf(\"%s\", c); 20 strftime(c, 40, \"B %B\\n\", p); 21 printf(\"%s\", c); 22 strftime(c, 40, \"c %c\\n\", p); 23 printf(\"%s\", c); 24 strftime(c, 40, \"d %d\\n\", p); 25 printf(\"%s\", c); 26 strftime(c, 40, \"H %H\\n\", p); 27 printf(\"%s\", c); 28 strftime(c, 40, \"I %I\\n\", p); 29 printf(\"%s\", c); 30 strftime(c, 40, \"J %J\\n\", p); 31 printf(\"%s\", c); 32 strftime(c, 40, \"m %m\\n\", p); 33 printf(\"%s\", c); 34 strftime(c, 40, \"M %M\\n\", p); 35 printf(\"%s\", c); 36 strftime(c, 40, \"P %P\\n\", p); 37 printf(\"%s\", c); 38 strftime(c, 40, \"S %S\\n\", p); 39 printf(\"%s\", c); 40 strftime(c, 40, \"U %U\\n\", p); 41 printf(\"%s\", c); 42 strftime(c, 40, \"w %w\\n\", p); 43 printf(\"%s\", c); 44 strftime(c, 40, \"W %W\\n\", p); 45 printf(\"%s\", c); 46 strftime(c, 40, \"x %x\\n\", p); 47 printf(\"%s\", c); 48 strftime(c, 40, \"X %X\\n\", p); 49 printf(\"%s\", c); 50 strftime(c, 40, \"y %y\\n\", p); 51 printf(\"%s\", c); 52 strftime(c, 40, \"Y %Y\\n\", p); 53 printf(\"%s\", c); 54 strftime(c, 40, \"Z %Z\\n\", p); 55 printf(\"%s\", c); 56 57 free(b); 58 59 60 } result a Sat A Saturday b Jul B July c Sat Jul 30 15:58:04 2022 d 30 H 15 I 03 J %J //出错没有这个参数 m 07 M 58 P pm S 04 U 30 w 6 W 30 x 07/30/22 X 15:58:04 y 22 Y 2022 Z CST ``` ```C time_t mktime(struct tm *tm_ptr); ``` > 把结构体转换为size_t格式 ## 非本地跳转`<setjmp.h>` 类似于`goto`但是范围不限于一个函数的作用域之内，常用于深层函数嵌套链 ```C int setjmp(jmp_buf state); void longjmp(jump_buf state, int value); ``` > 声明一个`jmp_buf`的变量，使用setjmp对他初始化，返回值为0，同时把程序的状态进行保存，调用时候的函数成为顶层函数，之后使用`longjmp`函数进行返回 > `longjmp`就是通过让执行流，通过再次从setjump返回，返回值是value，必须为一个非零的值 ```C 1 #include <stdio.h> 2 #include <stdlib.h> 3 #include <setjmp.h> 4 5 jmp_buf restart; 6 void func(void) 7 { 8 printf(\"func\\n\"); 9 longjmp(restart, 1); 10 printf(\"below\\n\"); 11 } 12 int main(void) 13 { 14 int value; 15 value setjmp(restart); 16 if(value 0) 17 { 18 printf(\"value 0\\n\"); 19 func(); 20 } 21 else if(value 1) 22 printf(\"value 1\\n\"); 23 return 0; 24 } result: value 0 func value 1 ``` 当顶层函数返回的时候，保存的状态就不再有效了 ## 信号 大多数的事件发生都是由程序引发的，例如执行各种语句请求输入，但是有些事件不是由程序本身引起的，常见的例子就是用户中断程序，必须对这种事件做出反应 信号是一种事件，可能是异步发生的，通常默认是终止程序，但是可以设置 ### 信号名`<signed.h>` 信号 含 义 : : : : SIGABRT 程序请求异常终止 SIGFPE 算数错误 SIGILL 检测到非法的指令 SIGSEGV 检查内存的非法访问 SIGINT 交互性注意信号 SIGTREM 终止程序的请求 >SIGABRT:`abort`函数引起 > >SIGFPE：上溢、下溢、除零 > >SIGILL：非法的CPU指令 > >SIGSEGV：访问不存在的地址，或者不属于程序的地址，以及地址没有对齐 > >SIGINT：用户中断程序，一般设置处理函数 > >SIGTREM：另一种用于处理中断的信号，一般不设置处理函数 ### 处理信号`<signed.h>` ```C int raise(int sig); ``` > 可以主动引发一个信号,和自助引发的作用一样 ```C void ( *signal(int sig, void(* hander)(int)))(int); ``` > 参数是一个信号名以及一个没有返回值, 接受一个整形函数的指针, 函数的返回参数是一个同样的指针 > > 返回的是之前的处理函数的指针, 失败返回SIG_ERR > > 参数中的是要设置的指针 > > 第二个参数SIG_DFL缺省处理,SIG_IGN忽略信号 ### 信号处理函数 一个已经设置处理函数的信号发生的时候,首先系统恢复信号的缺省行为, 防止处理函数内部也发生这个信号导致无限循环,然后信号调用函数触发,信号代码为参数传递给函数 信号函数处理的情况是有限的,信号如果是异步的, 也就是说不是`abrot`和`raise`引起的不要使用`signal.h`以外的库函数,而除了能给一个`volatile sig_atomic_t`的静态变量赋值以外无法访问其他静态变量 程序的其他地方检查变量的值,来确定是不是有信号产生 sig_atomic_t定义了一种CPU可以以原子的方式访问的数据类型, 也就是不可分割的访问单位, 因为访问不是这种数据的时候有中间步骤, 可能会产生新的信号 标准信号处理可以使用`exit() abort()`函数但是由于这两个是库函数, 所以当被异步处理的时候可能不能正常运行 #### `volatile`数据 信号的处理可能会发生在任何时候, 要处理的变量可能会在任何时候发生改变, 这个关键字告诉编译器防止他修改程序含义的方式优化程序 示例 ```C if(value){ printf(\"True\"); } else{ printf(\"False\"); } if(value){ printf(\"True\"); } else{ printf(\"False\"); } ``` 可能会被优化为 ```C if(value){ printf(\"True\"); printf(\"True\"); } else{ printf(\"False\"); printf(\"False\"); } ``` 但是由于信号可能在任何时候产生, 所以有可能导致结果的不同 #### 信号处理函数返回 从信号处理函数返回到信号发生的地方, 例外是SIGFPE(计算出错),由于计算不能完成, 结果未知 > 如果希望再次捕捉同样的信号, 要在返回之前用`signal`函数重新设置 > 由于不同的机器处理方式不同, 有可能不会定义所有的符号, 有的也不会回到缺省的状态, 所以移植姓会降低 ## 打印可变参数列表`<stdarg.h>` ```C int vprintf(char const *format, va_list arg); int vfprintf(FILE *stream, char const *format, va_list arg); int vfprintf(char *buffer, char const *format, va_list arg); ``` `va_list`必须用`va_start`初始化 ## 执行环境 ### 终止执行`<stdlib.h>` ```C void abort(void); void atexit(void (func)(void)); void exit(int status); ``` > `abort`不正常的终止一个正在运行的程序,引发信号 > `atexit`用来把一些函数注册为退出函数.当函数正常终止的时候用(`exit`或者`main`的`return`),退出函数被调用,有多个的时候按照注册的顺序依次执行 > exit调用之后注册的函数依次调用, 然后用于流的缓冲区刷新,所有打开的文件关闭,`tmpfile`创建的文件删除 > + **注:**在注册的函数之中调用exit有可能会导致无限循环 ## 断言`<assert.h>` 声明某种东西应该为真 ```C void assert(int expression); ``` 执行的时候对参数进行检测, 如果为假, 就向标准错误打印一条诊断信息然后终止程序 ```C 1 #include <stdio.h> 2 #include <assert.h> 3 4 int main(void) 5 { 6 assert(0); 7 printf(\"hi\\n\"); 8 return 0; 9 } a.out: main5.c:6: main: Assertion `0' failed. 已放弃 (核心已转储) ``` 可以通过这个来检查必须为正确的参数 > 如果要去除所有的 > > ```C > #define NDEBUG//必须在包含头文件之前 > ``` ## 环境`<stdlib.h>` 由编译器定义的一个列表 ```C char *getenv(char const *name); ``` 根据名字返回一个对应的字符串 ## 执行系统命令`<stdlib.h>` ```C void system(char const *command); ``` 实际的调用和编译器有关, 可以使用NULL来检测是否存在 ## 排序查找 在数组之中以升序对数据进行排列, 和类型无关,数组元素的长度固定 ```C void qsort(void *base, size_t n_elements, size_t el_size, int (*compare)(void const *, void const *)) ``` > `base`要排列的数组 > > `n_elements`元素的数量 > > `el_size`每个元素的大小 > > 第四个:函数的比较用的函数,返回一个整数, 大于零, 等于零, 小于零, 分别是第一个参数大于第二个, 等于, 小于 + 查找已经排序的数列 ```C void *bsearch(void const *key, void const *base, size_t n_elements, size_t el_size, int (*compare)(void const *, void const *)) ``` > `key`要查找的值 > > 函数: 一样的话返回0 > > 返回: 查找的指针 ## locale 为了让函数语言更加的通用,定义了一组特定的参数,每个国家的各不相同 ```C char *setlocale(int category, char const *locale); ``` > `category`要修改的部分 > > , 第二个为NULL的时候,返回一个指向对应的指针,可以在之后用来复原, 不是的时候指定新的locale, 成功的话返回的是新的值的指针 值 修改 LC_ALL 整个local LC_COLLATE 对照序列,影响`strcoll,strxfrm`函数 LC_CTYPE 定义于`ctype.h`中的函数使用的字符类型分类信息 LC_MONETARY 格式化货币使用的字符 LC_NUMERIC 格式化非货币使用的字符串, 修改格式化输入输出函数和字符串转换函数所使用的小数点符号 LC_TIME `strftime`函数的行为 ### 货币格式 ```C struct lconv *localeconv(void); ``` `locale`作用 + 字符集增加参数 + 打印方向 + 小数点符号 如果改变了字符集,比较字符串 ```C int strcoll(char const *s1, char const *s2);//进行比较,但需要更多计算 int strxfrm(char *s1, char const *s2, size_t);//简化计算,把字符串(参数2)转换,再用上面的函数比较 ```"},"/note/编程基础/C和指针/2022-7-26-函数.html":{"title":"函数《C和指针》","content":" layout: post title: \"函数《C和指针》\" date: 2022 7 26 11:29:08 +0800 categories: C和指针 # 函数 定义：类型 函数名（形式参数） ​\t\t 代码块 > 老式的代码格式在参数列表和函数体之间定义形式参数 > > ```C > int *fint_int(key, array, array_len) > int key; > \tint array[]; > \tint len; > \t{ > ``` > > ## 函数声明 当编译器遇到一个函数的时候，如果没有特定的信息，会假定参数的种类和数量是对的，并且返回一个整形 > 如果一个文件已经出现了一个函数的定义，编译器就会记住，在之后的调用中确保正确，但是老式的定义方法只会检查返回值的定义 > > 在函数的声明的时候，参数的名字不是必要的，但是格式是必要的 > 一个没有参数的函数```int *func(void);```,如果没有void会使得按照旧式声明 ## 函数的参数 C函数均采用传值调用，会对参数进行一次拷贝，数组除外 > 在调用旧式参数的时候会对参数进行提升 char、short > int , float > double，新式函数不会 ## ADT和黑盒 抽象数据类型(ADT)，实现方式：模块具有功能说明以及接口说明，用户并不需要知道细节，除了定义好的接口，用户不能以任何方式访问模块 ## 递归 ```C 1 #include <stdio.h> 2 //使用递归的方法打印一个数字 3 void binary_to_ascil(unsigned int value) 4 { 5 unsigned int quotient; 6 7 quotient value / 10; 8 if(quotient ! 0) 9 binary_to_ascil(quotient); 10 putchar(value % 10 + '0'); 11 } 12 int main(void) 13 { 14 binary_to_ascil(123321); 15 return 0; 16 } ``` ### 追踪递归函数 函数被调用的时候它的参数是保存在运行时候的堆栈上面，以前调用的函数的参数也保存在堆栈上面，但是被新的函数掩盖不能调用， ```C //计算阶乘 long factorial(int n) { if(n < 0) return 1; \telse return n * factoral(n 1); } ``` ```C //计算斐波那契数 long fibonacci(int n) { if(n < 2) \treturn 0; return fibonacci(n 1) + fibonacci(n 2); } // 由于在调用的时候会导致一个数被反复计算，所以会增加极多的计算量 ``` ## 可变参数列表 使用`stdarg.h` 定义了一个类型`va_list`,三个宏`va_start, va_arg, va_end`配合使用 `va_start`: 有两个参数，第一个参数是使用`va_list`初始化的列表，第二个参数是最后一个有名字的参数 `va_arg`: 访问参数，`va_list`的变量，以及变量的类型 `va_end`: 结束调用 ```C #include <stdarg.h> float average(int n_value, ...) { \tva_list var_arg; int count; float num 0; va_start(var_arg, n_value); for(count 0; count < n_value; count + 1){ sum + va_arg(var_arg, int); } va_end(var_arg); return sum / n_values; } ``` > **注：**不能判断实际的参数数量，不能判断参数的种类"},"/note/编程基础/C和指针/2022-7-29-输入输出函数.html":{"title":"输入输出函数《C和指针》","content":" layout: post title: \"输入输出函数《C和指针》\" date: 2022 7 29 10:11:08 +0800 tags: C和指针 C语言 # 输入输出函数 ANSI的标准要求编译器必须支持一组规定的函数，具有规范所要求的接口 ## 错误报告 ```C void perror(char const *message) #include <erno.h> > eron变量，在错误发生之后存储错误信息，库函数失败的时候被设置 ``` ```C 1 #include <stdio.h> 2 #include <stdlib.h> 3 FILE *input; 4 int main(void) 5 { 6 input fopen(\"data3\", \"r\"); 7 if(input NULL) 8 { 9 perror(\"data3\"); 10 exit(EXIT_FAILURE); 11 } 12 } result； data3: No such file or directory ``` ## 终止执行 ```C void exit(int status) ``` status的值返回给操作系统，用于提示程序是否完成，和main函数返回的整形值相同，定义了EXIT_SUCCESS，EXIT_FAILURE分别代表成功失败 经常与perror函数一同使用 ## 标准I/O函数库 旧版函数库实现了对函数的扩展，但是存在两个缺陷，首先是在特定的机器上实现，没有好的移植姓，移植的时候进行修改，会导致函数不再标准 ANSI的进步是对于可移植性和性能的改进，通过增加实现的方式，不影响可移植性 ## ANSI I/O 函数 包含在<stdio.h> ### 流 当前的计算机具有大量不同的设备，许多都和I/O操作有关，软盘硬盘驱动，网络连接，通信端口，每种设备具有不同的特性和操作协议，操作系统负责不同系统的通讯细节，对于C语言而言，所有的I/O操作都是简单的从程序移入移出字节，这种字节流被称为**流** + 流分为两种类型，二进制流、文本流 绝大多数的流是完全缓冲的，实际上意味着是从一块称为缓冲区的区域来回复制数据，只有写满的时候才会把他写入文件设备之中，当输入缓冲区为空的时候才会读取设备文件 使用标准输入输出的时候，缓冲可能会引起混淆，只有当操作系统判定他和交互设备没有联系的时候才会进行完全缓冲 > 最常用的策略是，提示用户吧输入输出联系在一起，当请求输入的同时刷新缓冲区，把之前输入的信息进行打印 > 常见的错误就是`printf`的输出被写入到缓冲区不立刻显示到显示器，程序失败的时候不会被实际写入 > > > 每次写入之后使用`fflush`刷新缓冲区 ```C printf(\"something or other\"); fflush(stdout); ``` #### 文本流 标准要求文本流最小不小于254字节，文本行的结束不同系统不同，MS DOS使用回车加换行，UNIX使用的是一个换行符 > 标准输出流把文本定义为零或多个字符，以一个换行符表示结束，对于那些文本在外的表现方式不同的操作系统库函数进行翻译，在MS DOS系统中换行符被转换为回车加换行，输入时候丢弃回车，增加可移植性 #### 二进制流 二进制流中的字节将会完全依照程序编写的顺序写入文件设备之中，并且完全根据文件设备的读取写入到程序之中，如果你不希望改变文件行末的字符，也可以用来处理文本文件 ### 文件 `stdio.h`声明的FILE结构是一个数据结构，用于访问一个流，如果你同时激活了多个流，每一个流都有和它对应的FILE，为了在流上操作，调用相关的函数，并且传递一个和流相关的FILE参数 每一个程序至少有三个流**标准输入`stdin`，标准输出`stdout`，标准错误`stuerr`**,都是指向FILE结构的指针，通常是缺省状态下的输入输出，为键盘和屏幕 > 操作系统通常支持重定向 > > ```C > $ program <data> answer > ``` > > 从文件<data>进行读取，写入到answer文件之中 ### 标准I/O常量 + EOF标志文件到达结尾，实际值比一个字节要大，避免二进制被错误的解释为EOF + FOPEN_MAX可以打开的文件的最大数量，最少为8 + FILENAME_MAX提示一个字符应该以多大以便容纳编译器支持的最长的合法名字 ## 流I/O总览 文件I/O总览 + 程序为每一个活动的文件声明一个指针变量，类型为FILE *，处于活动状态由流使用 + 流通过`fopen`打开你必须指定需要访问的文件或者设备，以及访问的方式 + 对文件读取写入 + `fclose`关闭文件，关闭一个流防止再次访问，保证缓冲区的数据正确写入，释放FILE 标准的I/O更简单，不需要打开关闭 **基本处理方式**：单个字符，文本文件，二进制文件 每种形式都有特定的处理函数 数据类型 输入 输出 描述 字符 `getchar` `putchar` 读取(写入)单个字符 文本行 `get scanf` `puts printf` 文本行未格式化的输入(输出)，格式化的输入输出 二进制数据 `fread` `fwrite` 读取(写入)二进制文件 1. 只用于`stdin、stdout` 2. 操作作为参数的流使用 3. 使用内存中的字符串 **输入输出函数家族** 家族名 目的 可用于所有值 只用于`stdin stdout` 内存中的字符串 : : : : : : : : : : `getchar` 字符输入 `fgetc gets` `getchar` ① `putchar` 字符输出 `fputc putc` `putchar` ① `gets` 文本行输入 `fgets` `gets` ② `puts` 文本行输出 `fputs` `puts` ② `scanf` 格式化输入 `fscanf` `scanf` `sscanf` `printf` 格式化输出 `fprintf` `printf` `sprintf` ① 对使用的下标引用或者间接访问内存 ②`strcpy`函数从内存中读取文本行 ## 打开流 `fopen`打开一个特定的文件，并把一个流和这个文件相关联 ```C FILE *fopen(char const *name, char const *mode) ``` 读取 写入 添加 : : : : : : : : 文本 \"r\" \"w\" \"a\" 二进制 \"rb\" \"wb\" \"ab\" > a+:即可以读也可以写，追加，如果已经读入一些数据要使用`fseek, fsetpos, rewind`等指令进行定位 > 如果打开成功，就会返回一个FILE指针，失败的话就会返回NULL ```C FILE *input; input fopen(\"data3\", \"r\"); if(input NULL) { perror(\"data3\"); exit(EXIT_FAILURE); } ``` + 打开或者重新打开一份文件流 ```C FILE *freopen(char const *filename, char const *mode ,FILE *stream) ``` > 成功返回一个函数的第三个参数 ## 关闭流 ```C int fclose(FILE *f) ``` + 对于输出流`fclose`关闭文件之前刷新缓冲区，执行成功返回0，否则返回EOF + 文件可能在关闭之前的操作中失败，使得input转换为NULL ```C 1 #include <stdio.h> 2 #include <stdlib.h> 3 4 int main(int ac, char **av) 5 { 6 int exit_status EXIT_SUCCESS; 7 FILE *input; 8 while(*++av ! NULL) 9 { 10 input fopen(*av, \"r\"); 11 if(input NULL) 12 { 13 perror(*av); 14 exit_status EXIT_FAILURE; 15 continue; 16 } 17 18 if(fclose(input) ! 0) 19 { 20 perror(\"fclose\"); 21 exit(EXIT_FAILURE); 22 } 23 } 24 return exit_status; 25 } ``` ## 字符I/O 一个流被打开之后，他可以用来输入输出，最简单的值字符的输入输出 ```C int fgetc(FILE* stream); int gets(FILE *stram);//这两个使用没啥区别 int getchar(void);//标准输入流 ``` > 返回值是一个int是为了返回错误EOF，它在任何可能出现的字符之外，为0xffffffff ```C int fputc(int character, FILE *stream); int putc(int character, FILE *stream); int putchar(int character, FILE *stream); ``` > 写入一个字符，失败EOF ## 字符I/O宏 `fgetc fputc`都是真正的函数 `getc putc getchar putchar`都是定义的宏 两者结果甚微 ## 撤销字符I/O 在实际读取之前不知道下一个字符，读取之后不希望丢弃这个字符 ```C int ungetc(int character, FILE *stream); ``` > 把前一个读取的字符返回流中，可以在之后重新读入。 ```C 1 #include <stdio.h> 2 #include <ctype.h> 3 4 int read_init(void){ 5 int value; 6 int ch; 7 value 0; 8 while((ch getchar()) ! EOF && isdigit(ch)){ 9 value * 10; 10 value + ch '0'; 11 } 12 ungetc(ch, stdin); 13 return value; 14 } 15 int main(void) 16 { 17 int value; 18 value read_init(); 19 printf(\" main \\n\"); 20 printf(\"value %d\", value); 21 printf(\"%c\\n\", getchar()); 22 return 0; 23 } result jiao@jiao virtual machine:~/桌面/point_and_c/15$ ./a.out 123321 main value 123321 jiao@jiao virtual machine:~/桌面/point_and_c/15$ vim main2.c ``` > 返回到接收区一个换行符 + 返回的位置和当前的位置有关，使用`fseek, fsetpos, rewind`改变位置退回的字符被丢弃 ## 未格式化的I/O 行I/O可以使用两种方式执行 未格式化的和格式化的，都用于操纵字符串 区别在于未格式化的简单的读取或写入字符串，格式化的执行数字和其他变量的内部外部表示形式的转换 ```C char *fgets(char *buffer, int buffer_size, FILE *stream); char *gets(char *buffer); int fputs(char const *buffer, FILE *stream); int puts(char const *buffer); ``` > `fgets`:读取到字符复制到buffer中，当读取到一个换行符，并存储到缓冲区之后就不再读取。 > > 读取到buffer_size 1的时候也停止读取,不会出现数据丢失，下一次调用的时候从下一字节开始 > > 如果读取到文件尾返回NULL，否则返回的第一个参数 > > **注：**不能使用小于2的缓冲区，会把最后一位转换为NUL字节，让他成为字符串 > `fputs`:传递给缓冲区一个字符串，预计以NUL字符结尾，如果不包含换行符不会写入，有多个全部写入 > > 出现错误返回EOF，否则返回一个非负值 `fgets`:一次读取一行 `fputs`：写入可以不是一行，写入几行，半行都是可以的 > gets和puts和上面几乎相同，但是他们允许向后兼容，gets读取一行不再缓冲区中存储结尾的换行符 > > puts写入的时候，写完再添加一个换行符 > > **注**：gets没有指定缓冲区长度的参数 ## 格式化的I/O ```C int fscanf(FILE *stream, char const *format, ...) int scanf(char const *formot, ...) int sscanf(char const *string, char const *formot, ...)//从字符串之中读取数据 ``` 从输入源读取数据，按照`formot` 格式对字符串进行转换 > 当格式字符串达到末尾或者读取的输入不再匹配格式字符串指定的类型的时候，输入停止。 > > 返回值是输入的得数目，在任何输入值转换之前文件到达末尾，函数返回常量EOF + 如果参数不是指定的格式，会导致结果是不能预测的 + 给他传递的参数指针，为了对对用的地址进行更改 ### scanf格式代码 format的参数 + 空白字符，和输入中的空白匹配 + 格式代吗，指定函数如何解释 + 其他 格式 1. 百分号 2. 可选的星号：转换后的值丢弃，不进行转换 3. 可选的宽度：非负整数，限制读取的字数，没有就直到下一个空白字符 4. 可选的限定符： 5. 格式代码 scanf的限定符 格式码 h l L : : : : : : : : `d, i, n` `short` `long` `o, u, x` `unsigned short` `unsigned long` `e, f, g` `double` `long double` 字符格式 `c` `char *` 读取存储单个字符，不跳过空白字符，如果给出宽度，就读取对应宽度的字符，最后不会添加NUL字节参数指向的数组要足够大 `i d` `int *` 一个可选的有符号的整形，d为十进制，i根据第一个字符决定值得基数 `u o x` `unsigned *` 一个可选的有符号的整形转换，按照无符号数存储，十进制u，八进制o， 十六进制x、X `e f g` `float *` 一个浮点型，小数点不是必须的 s `char *` 一串非空的字符串，必须指向足够大的数组，发现空白停止，自动添加NUL `[xxx]` `char *` 按照给定的组合进行读取，知道读取到第一个不在组合之众的字符，最后自动添加NUL，使用^补集`[^abc]`，[a z]范围 `p` `void *` 预期为字符串 `n` `int *` 到目前为止的读取的参数的数量返回 > scanf函数把换行当做空白字符跳过 可以使用sscanf对输入的参数进行格式的检测，通过返回值的个数是否正确来判断 ```C void function(char *buffer) { int a, b, c; if(sscanf(buffer, \"%d %d %d\", &a, &b, &c) ! 3){ a ...; if(sscanf(buffer, \"%d %d\", &b, &c) ! 2){ b ...; \t\t\tif(sscanf(buffer, \"%d\", &c) ! 1){ fprintf(stderr, \"Bad input %s\", buffer); exit(EXIT_FAILURE); } } } } ``` ### printf ```C int fprintf(FILE * stream, char const *format, ...); int printf(char const *format, ...); int sprintf(char *buffer, char const *format, ...); ``` > `sprintf`可以吧他输出到指定的buffer中，并添加一个NUL `c` `int` 参数被剪裁为`unsigned int`进行打印 `i d` `int` 十进制打印，指定位数不足用0填充 `u o x X` `unsigned int` 一个无符号的值，按照无符号数存储，十进制u，八进制o， 十六进制x打印出小写、X打印大写 `e E` `double` 参数按照指数的方式打印，参数决定小数点之后的位数 `f` `double` 浮点格式打印，精度决定小数点之后，缺省值为6 `g G` double 按照f或者e的格式打印，指数大于等于 4但是小于精度字段就使用f s `char *` 字符串 `p` `void *` 预期为字符串 `n` `int *` 到目前为止的读取的参数返回 格式标志 标志 含义 中左对齐，没有中右对齐 0 为右对齐的时候，缺省使用空格填充左侧未使用的值，这个标志用0来填充可用于d,i,u,o,x,X,e,E,f,g,G.其中d,i,u,o,x,X出现精度被忽略 + 显示符号 空格 转换有符号数，非负时候加一个空格到开头 # 选择某些代码的另一种形式 + 如果宽度用一个*代替，那么由下一个参数决定 + 参数在传递的时候短整型转化为整形 修改代码 修改符 用于...的时候 参数的表示 h `d, i, u, o, x, X` short整形 h `n` 指向short的指针 l d, i, u, o, x, X long整形 l `n` 指向long的指针 L `e, E, f, g, G` long double整形 printf其他格式(和#连用) 用于 #标志 o 保证产生的值以0开头 x, X 非零值前加0x 或0X e, E, f 结果有小数点 g, G 同上，尾部的0不去除 ![QQ图片20220729192437](https://xingqiu tuchuang 1256524210.cos.ap shanghai.myqcloud.com/1082/202301260020131.png) ## 二进制I/O 效率更高 ```C size_t fread(void *buffer, size_t size, size_t count, FILE *stream); size_t fwrite(void *buffer, size_t size, size_t count, FILE *stream); ``` buffer:保存数据的内存位置的指针 size：缓冲区每一个元素的字节数 count：读取写入的字节数 stream：流 实际读取的数量有可能会少于请求的元素 可以使用一个或者多个数组、数列组成的数列进行接收 ## 刷新定位函数 ```C int fflush(FILE *stream); ``` > 立刻迫使输出流缓冲区的数据进行物理写入，而不是直到以后才进行打印 正常情况下文件的写入是按照顺序来进行的，C语言支持随机访问，通过在访问之前定位实现 ```C long ftell(FILE *stream);//返回当前的位置,距离文件开头的偏移量 int fseek(FILE *stream, long offset, int from)//定位 ``` `ftell`:在二进制的时候表示的是距离开头得字节数，在文本流的时候不一定是字节数，根据不同的系统进行转换,但是可以作用于fseek之中 `fseek`:第一个参数 >流 第二个参数 >定位的字节 第三个参数 >定位的基地址 + 定位到起始位置之前是非法的，定位到文件尾写入扩展文件，读取获得到达文件尾 + 在二进制的时候文件尾定位是不可取的 + 文本流从SEEK_CUR或SEEK_END开始的offset必须是零，SEEK_SET开始的必须是`ftell`返回的值 如果是from... 你得到的定位 SEEK_SET 从流的起始位置的offest字节，非负数 SEEK_CUR 从当前位置开始的offset字节 SEEK_END 从流的末尾开始，可正可负 其他的函数 ```C void rewind(FILE *stream);//回到起始位置 int fgetpos(FILE *stream, fpos_t *position);//把文件当前位置存储到指定的位置 int fgetpos(FILE *stream, fpos_t const *position);//把文件指定为这的位置的地址 ``` ## 改变缓冲的格式 ```C void setbuf(FILE *stream, char *buf); int setvbuf(FILE *stream, char *buf, int mode, size_t size) ``` setbuf:设置一块新的缓冲区，大小BUFSIZ，防止分配动态的，NULL为第二个参数，关闭所有缓存 setvbuf：mode设置缓冲的模式， `_IOFBF`完全缓冲 `_IONBF`不缓冲 `_IOLBF`行缓冲，最好不要更改别的 ## 流错误函数 ```C int feof(FILE *stream);//是不是在文件未 int ferror(FILE *stream);//报告流错误状态，有的话为True void clearerr(FILE *stream);//错误标志重置 ``` ## 临时文件 使用文件保存数据，程序结束删除 ```C FILE *tmpfile(void); ``` 创建一个文件，程序结束的时候删除，以wb+的格式打开 如果文件要用其他方式打开或其他程序访问，就用fopen，最后remove函数 临时文件的文件名：`char *tmpnam(char *name);`，参数是NULL的时候返回一个指向静态数组的指针 ## 文件操纵函数 ```C int remove(char const *filename); int rename(char const *oldname, char const *newname); ``` 成功的话返回0"},"/note/编程基础/C和指针/2022-7-28-高级指针.html":{"title":"高级指针《C和指针》","content":" layout: post title: \"高级指针《C和指针》\" date: 2022 7 28 11:29:08 +0800 tags: C和指针 C语言 # 高级指针 并不是所有的都是有用的，部分是为了找乐子 ## 指向指针的指针 ```C int i; int *pi; int **ppi; ppi &pi; *ppi &i;//把三个变量联系起来 int ***pppi &ppi; ``` > 间接访问的层数越多，使用的越少 ## 高级声明 ```C int *f();//返回指针的函数 int (*f)();//函数指针 int *(*f)();//指向返回指针的函数的指针 ``` 加入数组 ```C int f[]; int *f[]; int (*f)();//函数指针 int f()[];//f是一个函数，返回一个数组，是违法的，函数只能返回标量 int f[]();//f是一个数组，成员是返回值为整形的函数，也是非法的，函数的长度不同 int (*f[])();//(*f[]) >f是参数为某种指针的函数，函数指针的数组，函数返回值为整形 int *(*f[])();//返回值为整形指针 int (*f)(int, float); int *(*g[])(int, float); ``` ## 函数指针 ```C int f(int); int (*pf)(int) &f;//&是可选的 ``` > 在函数指针赋值之前，必须要有函数的原型，用来检查类型是不是一致 函数名在使用之前总是被转化为函数指针，使用&只是声明了编译器隐式执行的任务 ```C //使用 int ans; ans f(25); ans (*pf)(25); ans pf(25); ``` ### 回调函数 ```C //在一个单列表之中寻找一个值 Node *search_list(Node *node, int const value) { while(node ! NULL) { if(node >value value) break; node node >link; } return node; } ``` 这个函数只能解决整形的列表传值 ```C #include <stdio.h> #include \"node.h\" Node *search_list(Node *node, void const *value, int (*compare)(void const *, void const *))//传入一个用于比较的函数指针 { while(node ! NULL) { if(compare(&node >value,value) 0) break; node node >link; } return node; } ``` 这里使用的是相等的时候返回0，为了和系统函数相互兼容，负值表示第一个参数小于第二个参数，正值表示第一个参数大于第二个参数 ```C int compare_ints(void const *a, void const *b)//声明为void*是为了匹配函数的原型 { if(*(int *)a *(void *)b) return 0; else return 1; } ``` > 比较字符串可以直接使用strcmp函数，但是有可能会报告函数的参数类型不匹配，它的参数是char * ## 转移表 把具体的操作封装成函数，与操作的选择分割开来 转移表是一个函数指针的列表，但是在创建列表之前要有每个函数的原型 ```C double add(double, double); double sub(double, double); double mul(double, double); double div(double, double); ... double (*oper_func[])(double, double) { add, sub, mul, div... } //使用 rseult oper_func[oper](op1, op2); ``` > **注：**数组的越界有可能会引起跳转进入其他函数，引起很难考察的错误 ## 命令行参数 用户在命令行之中编写参数 ### 传递命令行参数 main函数有两个参数，第一个argc，表示命令行参数的树木，第二个argv指向一组参数 ```C int main(int argv, char **argv) ``` > 第一个参数是程序的名字，当一个函数有不同的调用方式的时候就有用了 ```C 1 #include <stdio.h> 2 #include <stdlib.h> 3 4 int main(int argc, char **argv) 5 { 6 while(*++argv ! NULL)//跳过第一个程序名 7 printf(\"%s \\n\", *argv); 8 return EXIT_SUCCESS; 9 } ``` 处理文件传入的参数 ```C 1 #include <stdio.h> 2 #define TRUE 1 3 void process_standard_input(void) 4 {//处理用的函数 5 printf(\"over\"); 6 } 7 void process_file(char *file_name){ 8 printf(\"open : %s\\n\", file_name); 9 } 10 11 int option_a, option_b; 12 13 void main(int argc, int **argv){ 14 while(*++argv ! NULL && **argv ' '){ //处理参数, 访问第一个字符，从左到右进行，先判断非空 15 switch(*++*argv){ //运算方向从右向左，同一级符号 16 case 'a': 17 option_a TRUE; 18 printf(\"a\"); 19 break; 20 case 'b': 21 option_b TRUE; 22 printf(\"b\"); 23 break; 24 } 25 } 26 if(*argv NULL)//处理文件 27 process_standard_input(); 28 else{ 29 do{ 30 printf(\"laile\"); 31 process_file(*argv); 32 }while(*++argv ! NULL); 33 } 34 } ``` **每个‘ ’可以有多个参数** ```C while((opt *++*argv) ! '\\0'){ switch(*++*argv){ //运算方向从右向左，同一级符号 case 'a': option_a TRUE; printf(\"a\"); break; case 'b': option_b TRUE; printf(\"b\"); break; } ``` ## 字符串常量 当一个字符串常量出现在表达式中，他的值是一个指针常量，和数组名类似 ```C \"xyz\" + 1 *\"xyz\" \"xyz\"[2] *(\"xyz\" + 4) //出错 ``` 把十进制的数字转化为十六进制 ```C #include <stdio.h> void binary_to_ascii(unsigned int value) { unsigned int quotient; quotient value / 16; if(quotient ! 0) binary_to_ascii(quotient); putchar(\"0123456789abcdef\"[value %16]);//进行对应的转换 } ``` ```C void print_star(int n) {//根据传入的数字打印你对应数量的星星 n + 5; n / 10; printf(\"%s\\n\", \"**********\"+10 n); } ``` # 示例 ```C int **(*abc[6])(); ``` 返回值为int指针的指针的函数的指针组成的数组 ```C int **abc[6]; ``` int型指针的指针组成的数列 ```C int *(*abc)[6] ``` 指向int的指针组成的数组的指针 ```C int *(*abc())() ``` 返回值为int指针的函数的指针作为abc函数的返回值 ```C int (**(*abc)())() ``` 返回值为int型的的函数的指针的指针的函数指针 ```C int (*(*abc)())[6] ``` 返回值为指向int型数组指针的函数指针 ```C int *(*(*(*abc)())[6])() ``` 返回值为int型指针的函数指针的数组的指针的函数指针 `int *(*(*函数主体)[6])()`在外面的都是函数的返回值 第一个* 是最外层的返回值` int *()()` 第二个*是和最后面的括号组成函数指针`int *(*[6])()` 第三个*是对于数组求指针 ### 总结 + 确定函数的主体 + 函数的返回值的确定 > 从内向外单独的* 是对外面的结果求指针 > > 数组是对外层的结果进行求数组`int *(*[6])()` ​"},"/note/编程基础/C和指针/2022-7-25-词法规则.html":{"title":"词法规则","content":" layout: post title: \"词法规则\" date: 2022 7 25 11:29:08 +0800 categories: C和指针 # 词法规则 ### 字符 标准没有规定字符集，但是规定了必须有的字符 **三字母词**：用三个字母表示字符集中没有的的字符，常用于缺少必要字符分字符集 **常见的转化方式**：![QQ图片20220725145241](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242255424.png) **转义字符串**：![QQ图片20220725145658](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242255425.png) ​\t![QQ图片20220725151830](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202311011759868.png) ### 注释 注释最后会被转化为一个空格，所以可以出现在所有可以有空格的地方，出现在字符串内部不起作用 在逻辑上使用注释删除一段代码可以使用#if,#endif来避免逻辑错误 ### 标识符 就是变量，没有长度限制，到时允许编译器省略31个字符之后的 **关键字**：![QQ图片20220725150954](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242255426.png) ### 程序形式 可以包含多个函数但是每个函数必须是完整的"},"/note/编程基础/算法基础/2024-12-31-02哈希表.html":{"title":"哈希表","content":"# 哈希表 这里使用的是[uthash User Guide](https://troydhanson.github.io/uthash/userguide.html)这一个 在使用的时候需要包含一下`#include \"uthash.h\"` 在实际使用的时候自己的数据格式是按照以下的形式进行排布的, 在实际使用的时候这一个key是不可以重复的 ```c struct my_struct { int id; /* key 这一个是必须的*/ char name[21]; UT_hash_handle hh; /* makes this structure hashable 用于操控的, 必须*/ }; ``` 初始化的时候可抑制初始化一个指针, 之后使用分配的方式进行 ```c struct my_struct *users NULL; /* important! initialize to NULL */ ``` ### 实际使用 ```c HASH_FIND_INT( users, &user_id, s ); /* s: output pointer */ ``` > 第一个是哈希表的头指针, 之后是查找的数据的key(取指针), 最后一个是返回值 > > 其他的操作也是使用类似的宏定义进行实现的 ### 基础操作示例 ```c void add_user(int user_id, const char *name) { struct my_struct *s; HASH_FIND_INT(users, &user_id, s); /* id already in the hash? */ if (s NULL) { s (struct my_struct*)malloc(sizeof *s); s >id user_id; HASH_ADD_INT(users, id, s); /* id is the key field */ } strcpy(s >name, name); } struct my_struct *find_user(int user_id) { struct my_struct *s; HASH_FIND_INT(users, &user_id, s); /* s: output pointer */ return s; } void delete_user(struct my_struct *user) { HASH_DEL(users, user); /* user: pointer to deletee */ free(user); } void delete_all() { struct my_struct *current_user; struct my_struct *tmp; HASH_ITER(hh, users, current_user, tmp) { HASH_DEL(users, current_user); /* delete it (users advances to next) */ free(current_user); /* free it */ } } void print_users() { struct my_struct *s; for (s users; s ! NULL; s (struct my_struct*)(s >hh.next)) { printf(\"user id %d: name %s\\n\", s >id, s >name); } } int by_name(const struct my_struct *a, const struct my_struct *b) { return strcmp(a >name, b >name); } int by_id(const struct my_struct *a, const struct my_struct *b) { return (a >id b >id); } ```"},"/note/编程基础/算法基础/2024-12-31-03贪心算法.html":{"title":"贪心算法","content":"# 贪心算法 贪心算法（又称贪婪算法）是指，在对[问题求解](https://baike.baidu.com/item/问题求解/6693186)时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，[算法](https://baike.baidu.com/item/算法/209025)得到的是在某种意义上的局部最优解 。 [135. 分发糖果 力扣（LeetCode）](https://leetcode.cn/problems/candy/solutions/533150/fen fa tang guo by leetcode solution f01p/?envType study plan v2&envId top interview 150)"},"/note/编程基础/算法基础/2022-7-31-高级数据结构.html":{"title":"高级数据结构《算法基础-打开算法之门》","content":" layout: post title: \"高级数据结构《算法基础 打开算法之门》\" date: 2022 7 30 10:11:08 +0800 tags: 《算法基础 打开算法之门》 算法 # 高级数据结构 基础数据结构: 线性表(栈、队列、链表)，二叉树，图等 常见的数据结构, 堆排序是利用堆设计的选择排序 + 堆: 可以实现优先队列 + 树状结构: 区间和 Treap通过随机数优化二叉树, Splay树通过Splay操作维持平衡。左倾堆是一种可并堆,有左倾特性 ## 堆 常见的数据类型 二叉堆 ### 堆的定义 堆是一棵完全的二叉树, 最重要的就是, 儿子不一定小于或者大于父亲的值(小堆顶, 大堆顶) 应用: 堆排列, 优先队列 利用数组存储的时候, 两个子节点的标号是, 2x+1, 2x+2 ### 建堆 核心是调整堆, 满足没一个节点都不大于父节点的值, 从最后一个非叶子节点开始到根节点 ### 堆排序的算法 设堆有n个元素, 每一次调整堆顶得到最大值, 然后将顶元素和最后一个元素互换, 对前n 1个元素调整直到有序 ```C 1 #include <stdio.h> 2 void heap_adjust(int arr[], int father, int n)//数组, 起始位置, 数组的长度 3 { //传入一个堆栈, 从father位置开始,长度为n, 调整father位置的数值到正确的位置 4 int child father*2 + 1; 5 int temp arr[father]; 6 while(child < n){//当没有超出的时候 7 if(child+1<n && arr[child]<arr[child+1])child++; 8 if(arr[father]> arr[child])break;//位置正确,大于子类的最大值, 退出 9 arr[father] arr[child];//交换 10 father child;//重新定位 11 child father*2+1;//调整位置 12 arr[father] temp; 13 } 14 } 15 //数组,总共的元素 16 void build_heap(int arr[], int n) 17 {//建立堆区,把不是叶的节点全部调整一次 18 for(int i (n 1)/2;i> 0; i)//从不是叶的节点的位置从下到上开始遍历 19 heap_adjust(arr, i, n); 20 } 21 //数组,起始位置,结束位置 22 void heap_sort(int arr[], int beg, int end) 23 { 24 build_heap(arr+beg, end beg);//建立堆区 25 for(int tmp, i end 1; i>beg; i) 26 { 27 tmp arr[i]; 28 arr[i] arr[0]; 29 arr[0] tmp;//进行换位 30 heap_adjust(arr+beg, 0, i);//对换上来的进行调整 31 } 32 } 33 int main(void){ 34 int arr[100]; 35 int n; 36 scanf(\"%d\", &n); 37 for(int i 0; i<n;i++) 38 scanf(\"%d\", &arr[i]);//建立数组 39 heap_sort(arr, 0, n);//排序 40 for(int i 0; i<n;++i)printf(\"%d \", arr[i]); 41 return 0; 42 } ``` ## 树状数组 ### 定义 ![QQ图片20220801120149](https://blog 1308522872.cos.ap beijing.myqcloud.com/jhy/202212312355514.png) 给定一个数组, 更新某个点的值, 求某个区间的和, 对于普通的数组分别为O(1)和O(n), 对于树状数组,都为`O(nlog n)` 定义 $$ C[i] A[i 2^k +1] + ... + A[i] $$ k为用二进制表示的时候末尾的0的个数, 也就是i是2^k的倍数 C[i]为A[i]开始前2^k项的和 求2^k的快捷方法 ```C int lowbit(x){ return x&( x); } //再求负数的时候, 所有的末尾的0变为1再加一,使得原本第一位不是的变为1, 有且只有这一位是政府同时1的 ``` 修改某一点的值的时候要修改他所有的父节点,它的父节点是 $$ i+lowbit(i) $$ ```C //在posion处加value,数组的长度是len void change(int c[], int posion, int value, int len){ while(posion < len) { c[posion] + value; posion + lowbit(posion); } } ``` 前n项的和可以记为sum(n) $$ sum(n) C[n]+sum[n lowbit(n)]; $$ ```C int sun(int c[], int n) { int answer 0; while(n>0) { answer + c[n]; n lowbit(n); } return answer; } ``` 计算一个数列每次只能交换相邻的两个数据, 从小到大要使用的次数 建立一个树状数列, 在每添加一个数的时候, 在这个数列的对应位置置一, 然后对添加数的位置前面的数求和就是小于这个数的数字的数量, 所有的数字的逆序对相加就是结果 ```C 1 #include <stdio.h> 2 #include <string.h> 3 4 const int N 1000; 5 int lowbit(int x){ 6 return x&( x); 7 } 8 9 void change(int c[], int posion, int value, int len){ 10 while(posion < len) 11 { 12 c[posion] + value; 13 posion + lowbit(posion); 14 } 15 } 16 17 int sum(int c[], int n) 18 { 19 int answer 0; 20 while(n>0) 21 { 22 answer + c[n]; 23 n lowbit(n); 24 } 25 return answer; 26 } 27 28 int main(void){ 29 int n; 30 int c[N]; 31 while(~scanf(\"%d\", &n)) 32 { 33 memset(c, 0, sizeof(c)); 34 int x; 35 int answer 0; 36 for(int i 1;i< n;i++) 37 { 38 scanf(\"%d\", &x); 39 change(c, x, 1, n); 40 answer + i sum(c, x); 41 } 42 printf(\"%d\\n\", answer); 43 printf(\" \\n\"); 44 } 45 return 0; 46 } ``` ## 左倾堆 实现两个堆的合并 ### 相关的定义性质 > 零距离(NPL): 一个节点到一个最近的不满节点的路径 > > 不满节点: 该节点的左右节点最少有一个是空的 叶子节点的NPL为0, 空节点的NPL为 1 + 节点的键值小于等于子节点的键值 + 节点的左子节点NPL大于等于右子节点的NPL, 左倾性质 + 节点的NPL等于右节点NPL+1 + 左倾堆任意子树也是左倾堆"},"/note/编程基础/算法基础/2024-12-31-01快速排序.html":{"title":"快速排序","content":"# 快速排序 在使用这一个排序的时候, 需要选择一个基准, 之后把这一个数字移动到他应该所在的位置 ```c void swap(int *a, int * b){ int temp *a; *a *b; *b temp; } // 移动基准到对应的位置 int partition(int arr[], int low, int high){ int pivot arr[high]; // 最后一个作为基准 int i low; for(int j low; j < high; j++){ if(arr[j] > pivot){ swap(&arr[i], &arr[j]); i++; } } swap(&arr[i], &arr[high]); return i; } // 快速排序 void quickSort(int arr[], int low, int high){ if(low < high){ int pi partition(arr, low, high); quickSort(arr, low, pi 1); quickSort(arr, pi+1, high); } } ```"},"/note/编程基础/python/进阶使用/django/2025-8-2-10-模型扩展.html":{"title":"","content":"## 模型扩展 ### 模型管理器 > 模型类.objects.操作方法() # objects 就是模型管理器对象，它提供了所有关于数据库的操作以及获取数据库查询结果的属性方法。 objects是 模型管理器（Manager）的实例对象，而模型管理器（Manager）是`models.Model`提供给模型进行数据库操作的接口对象，因为数据库模型类都必须要继承`models.Model`，所以django中每个模型类都拥有至少一个模型管理器对象(objects)。 我们在通过模型类的**objects**属性提供的方法操作数据库时，即是在使用一个模型管理器的实例对象objects。当没有为模型类定义管理器时，Django会为每一个模型类生成一个名为objects的管理器对象，它是**models.Manager**类的实例对象。 在源代码中`models.Model`的元类ModelBase提供了一个`_prepare`方法，在`_prepare`方法中创建了objects对象并补充到Model类中。`django/db/models/base.py`，代码： ```python def _prepare(cls): \"\"\"Create some methods once self._meta has been populated.\"\"\" opts cls._meta opts._prepare(cls) if opts.order_with_respect_to: cls.get_next_in_order partialmethod( cls._get_next_or_previous_in_order, is_next True ) cls.get_previous_in_order partialmethod( cls._get_next_or_previous_in_order, is_next False ) # Defer creating accessors on the foreign class until it has been # created and registered. If remote_field is None, we're ordering # with respect to a GenericForeignKey and don't know what the # foreign class is we'll add those accessors later in # contribute_to_class(). if opts.order_with_respect_to.remote_field: wrt opts.order_with_respect_to remote wrt.remote_field.model lazy_related_operation(make_foreign_order_accessors, cls, remote) # Give the class a docstring its definition. if cls.__doc__ is None: cls.__doc__ \"%s(%s)\" % ( cls.__name__, \", \".join(f.name for f in opts.fields), ) get_absolute_url_override settings.ABSOLUTE_URL_OVERRIDES.get( opts.label_lower ) if get_absolute_url_override: setattr(cls, \"get_absolute_url\", get_absolute_url_override) \t\t# 添加一个object if not opts.managers: if any(f.name \"objects\" for f in opts.fields): raise ValueError( \"Model %s must specify a custom Manager, because it has a \" \"field named 'objects'.\" % cls.__name__ ) manager Manager() manager.auto_created True cls.add_to_class(\"objects\", manager) # Set the name of _meta.indexes. This can't be done in # Options.contribute_to_class() because fields haven't been added to # the model at that point. for index in cls._meta.indexes: if not index.name: index.set_name_with_model(cls) class_prepared.send(sender cls) ``` 同时，Manager模型管理器，实际上是继承了一个元类，这个元类就是QuerySet对象，从而提供了所有的数据库查询操作。 ```python class Manager(BaseManager.from_queryset(QuerySet)): pass ``` 查找from_queryset方法的源代码，可以发现，此处在构建元类(我们在python面向对象高级中曾经讲过这块) ```python @classmethod def from_queryset(cls, queryset_class, class_name None): if class_name is None: class_name \"%sFrom%s\" % (cls.__name__, queryset_class.__name__) return type( class_name, (cls,), { \"_queryset_class\": queryset_class, **cls._get_queryset_methods(queryset_class), }, ) ``` #### 自定义模型管理器 我们可以自定义模型管理器，并应用到我们的模型类上，以增加一些自定义数据库查询操作。但是**一旦为模型类指明自定义模型管理器以后，Django不再提供默认的模型管理器对象objects了**。 自定义管理器类主要用于两种情况，分别是重写objects的现有方法与新增数据库操作方法。 准备一个用户模型，代码： ```python class User(models.Model): \"\"\"用户信息表\"\"\" nickname models.CharField(max_length 50, verbose_name \"昵称\") username models.CharField(max_length 50, verbose_name \"用户名\") password models.CharField(max_length 255, verbose_name \"密码\") created_time models.DateTimeField(auto_now_add True, verbose_name \"注册时间\") updated_time models.DateTimeField(auto_now True, verbose_name \"更新时间\") deleted_time models.DateTimeField(null True, blank True, verbose_name \"删除时间\") class Meta: db_table \"orm_user\" verbose_name \"用户信息\" verbose_name_plural verbose_name def __str__(self): return str({\"name\": self.nickname, \"deleted_time\": self.deleted_time}) ``` 数据迁移 ```bash python manage.py makemigrations python manage.py migrate ``` #### 直接重写模型类 可以直接在模型里面写入自己的函数比如实现`get_user` ```python def get_user(self): return self.objects.filter(age__gte 18).all() ``` 但在这时候发现实际使用的时候`models.User().get_user()`里面的User()初始化的时候设置不了参数 ```python @classmethod def get_user(cls): return cls.objects.filter(age__gte 18).all() ``` 需要改为这种方式, 很不方便 #### 重写objects的现有方法 打开orm/models.py文件，定义类UserManager ```python from django.db.models import Manager \"\"\" 1. 自定义模型管理器 模型管理器，必须直接或间接继承于 Manager 注意：filter的返回值并非QuerySet，所以跟在filter后面的调用的方法无法重写。 \"\"\" class UserManager(Manager): def create(self, **kwargs): if \"password\" in kwargs: from hashlib import sha256 hash sha256() hash.update(kwargs[\"password\"].encode()) kwargs[\"password\"] str(hash.hexdigest()) return super().create(**kwargs) def all(self): return super().filter(deleted_time__isnull True).all() ``` 在模型类User中注册模型管理器 ```python class User(models.Model): \"\"\"用户信息表\"\"\" nickname models.CharField(max_length 50, verbose_name \"昵称\") username models.CharField(max_length 50, verbose_name \"用户名\") password models.CharField(max_length 255, verbose_name \"密码\") created_time models.DateTimeField(auto_now_add True, verbose_name \"注册时间\") updated_time models.DateTimeField(auto_now True, verbose_name \"更新时间\") deleted_time models.DateTimeField(null True, blank True, verbose_name \"删除时间\") \"\"\" 2. 作为类属性注册到模型类中 \"\"\" objects UserManager() class Meta: db_table \"orm_user\" verbose_name \"用户信息\" verbose_name_plural verbose_name def __str__(self): return str({\"name\": self.nickname, \"deleted_time\": self.deleted_time}) ``` 视图中调用模型管理器 ```python class Student6View(View): def get(self, request): \"\"\"修改objects原有方法\"\"\" # from hashlib import sha256 # hash sha256() # hash.update(\"123456\".encode()) # user User.objects.create(username \"root\", nickname \"超级管理员\", password str(hash.hexdigest())) # user User.objects.create(username \"root\", nickname \"超级管理员\", password \"123456\") user_list User.objects.all() print(user_list) return HttpResponse(\"ok\") ``` #### 在管理器类中补充定义新的查询方法 a）打开models.py文件，定义方法create。 ```python from django.db.models import Manager class UserManager(Manager): def create(self, **kwargs): if \"password\" in kwargs: from hashlib import sha256 hash sha256() hash.update(kwargs[\"password\"].encode()) kwargs[\"password\"] str(hash.hexdigest()) return super().create(**kwargs) def all(self): return super().filter(deleted_time__isnull True).all() def soft_delete(self, **kwargs): \"\"\"逻辑删除，并非真实删除数据，而是给数据设置了一个删除时间\"\"\" from datetime import datetime return self.filter(**kwargs).update(deleted_time datetime.now()) ``` 视图代码调用： ```python class Student6View(View): def get1(self, request): \"\"\"修改objects原有方法\"\"\" from hashlib import sha256 hash sha256() hash.update(\"123456\".encode()) user User.objects.create(username \"root\", nickname \"超级管理员\", password str(hash.hexdigest())) \t\t# 重写以后 user User.objects.create(username \"root\", nickname \"超级管理员\", password \"123456\") user_list User.objects.all() print(user_list) return HttpResponse(\"ok\") def get(self, request): \"\"\"新增objects没有的方法\"\"\" User.objects.soft_delete(username \"root\") return HttpResponse(\"ok\") ``` ### 代理模型(模型细分) Django提供的ORM模型声明中，一共有3种不同类型的模型。我们前面已经了解并使用了2种。使用代理模型的时候可以共享父类模型的数据 ```python from django.db import models from django.db.models.base import Manager class UserManager(Manager): def get_user_list(self): return self.filter(age__gte 18).all() # Create your models here. class User(models.Model): name models.CharField(max_length 20, db_index True, verbose_name \"姓名\") age models.IntegerField(verbose_name \"年龄\") sex models.BooleanField(null True, blank True, default None, verbose_name \"性别\") # 覆盖设置了django默认的模型管理器 objects2 UserManager() # 模型的对象管理器，是否叫objects都不影响django取消内部的objects，因为我们自定义了 class Meta: db_table 'tb_user' verbose_name \"用户信息\" verbose_name_plural verbose_name def __str__(self): return self.name @classmethod def get_user(cls): \"\"\"获取成年人列表\"\"\" return cls.objects.filter(age__gte 18).all() class Female(User): class Meta: proxy True # 设置当前模型为代理模型，共享父模型的数据和操作方法 @classmethod def all(cls): return cls.objects2.filter(sex False).all() class Male(User): class Meta: proxy True @classmethod def all(cls): return cls.objects2.filter(sex True).all() ```"},"/note/编程基础/python/进阶使用/django/2025-8-1-09-ORM优化.html":{"title":"ORM优化","content":"# ORM优化 ## 虚拟外键 在前面所有的关联查询操作中，我们使用的外联手段都是依靠数据库本身维护的物理外键(使用数据库里面的一个数据进行记录关系)，但是这在一定程度上会增加数据库的运行成本，消耗数据库性能，因为数据量大了之后DB在高并发情况会产生大量锁。所以在外界就存在了相当一部分公司(50%左右)为了追求性能，舍弃了物理外键（就是在数据库建表操作中不再创建外键索引），改用ORM提供的虚拟外键（逻辑外键，这种外键关系是由ORM代码来维护的）来进行关联查询操作。当然，如果没有数据库本身维护的物理外键，肯定也会存在对数据库一致性的风险。 ![image 20250801165746125](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202508011657219.png) > 在数据删除的时候由于数据库里面没有记录, 所以实际会导致数据库不会主动维护 要在Django中使用虚拟外键，只需要在模型声明外键字段中设置属性`db_constraint False`即可。 > 补充： > > db_constraint True 表示当前外键使用物理外键 > > db_constraint False 表示当前外键使用虚拟外键 代码举例： ```python # 一对一的逻辑外键 student models.OneToOneField(\"Student\", related_name \"profile\", on_delete models.CASCADE, db_constraint False, verbose_name \"学生\") # 一对多的逻辑外键 student models.ForeignKey(\"Student\", on_delete models.CASCADE, db_constraint False, verbose_name \"学生\") # 多对多的逻辑外键 teacher models.ManyToManyField(\"Teacher\", db_constraint False, related_name \"to_course\") ``` 当我们在模型声明时，使用虚拟外键，则将来生成的数据表中DDL（表定义语句）则不会出现外键的约束声明，只会出现普通索引的声明。 课堂代码： ```python from django.db import models \"\"\"1对1的虚拟外键设置\"\"\" class Student(models.Model): name models.CharField(max_length 20, verbose_name \"学生\") age models.SmallIntegerField(verbose_name \"年龄\") sex models.BooleanField(default True, verbose_name \"性别\") class Meta: db_table \"tb_student\" verbose_name \"学生信息表\" verbose_name_plural verbose_name class StudentProfile(models.Model): student models.OneToOneField(\"Student\", on_delete models.CASCADE, db_constraint False, verbose_name \"学生\") mobile models.CharField(max_length 15, verbose_name \"紧急电话\") address models.CharField(max_length 200, verbose_name \"联系地址\") class Meta: db_table \"tb_student_profile\" verbose_name \"学生详情表\" verbose_name_plural verbose_name \"\"\"1对多的虚拟外键设置\"\"\" class Author(models.Model): name models.CharField(max_length 20, db_index True, verbose_name \"姓名\") age models.IntegerField(verbose_name \"年龄\") sex models.BooleanField(null True, blank True, default None, verbose_name \"性别\") class Meta: db_table 'tb_author' verbose_name \"作者信息\" verbose_name_plural verbose_name class Article(models.Model): title models.CharField(max_length 50, verbose_name \"文章标题\") content models.TextField(null True, verbose_name \"文章内容\") pubdate models.DateTimeField(null True, verbose_name \"发布时间\") created_time models.DateTimeField(auto_now_add True, verbose_name \"创建时间\") updated_time models.DateTimeField(auto_now True, verbose_name \"创建时间\") author models.ForeignKey(\"Author\", on_delete models.DO_NOTHING, db_constraint False, verbose_name \"作者\") class Meta: db_table \"tb_article\" verbose_name \"文章信息\" verbose_name_plural verbose_name \"\"\"多对多的虚拟外键设置\"\"\" class Teacher(models.Model): name models.CharField(max_length 20, db_index True, verbose_name \"姓名\") age models.IntegerField(verbose_name \"年龄\") sex models.BooleanField(null True, blank True, default None, verbose_name \"性别\") # course models.ManyToManyField(\"Course\", related_name \"teacher\", db_constraint False) class Meta: db_table 'tb_teacher' verbose_name \"老师信息\" verbose_name_plural verbose_name class Course(models.Model): name models.CharField(max_length 20, db_index True, verbose_name \"课程名称\") teacher models.ManyToManyField(\"Teacher\", related_name \"course\", db_constraint False) class Meta: db_table 'tb_course' verbose_name \"课程信息\" verbose_name_plural verbose_name ``` ### 查询优化 django在关联查询中**为了减少SQL查询的数量**，提供了2个优化方法，prefetch_related()和select_related()。2个优化方法的功能作用类似，使用方式也一样，但是内部实现方式不同（也就是内部生成的SQL语句不同，使用场合不同）。 select_related() 是通过JOIN语句，在查询时减少SQL查询数量，一般适用于**一对一**的连表查询中，不适用在多对多。对于多对多关系使用SQL语句JOIN得到的SQL将会很长，会导致SQL语句运行时间和内存占用比例的增加。 prefetch_related()是通过 IN 语句分别查询关联的每个表的数据，然后在ORM中使用python处理他们之间的关联关系，通过这种方式来达到减少SQL连表查询数量。但是这样也有弊端，在QuerySet中的对象数量过多时，根据数据库特性的不同有可能造成性能额外损耗。 对于多对多字段（ManyToManyField）和一对多字段，可以使用`prefetch_related()`来进行优化。 对于一对一和多对一关系字段，可以使用`select_related()` 来进行优化。 2个优化函数是好的，但是使用不当会导致比原来还要糟心，那还不如别优化，所以最好慎用。 举例：实现用户的足迹功能，拿用户到过那些省份和城市以及他的家乡来举例，模型代码： ```python class Province(models.Model): name models.CharField(max_length 50, verbose_name \"省份\") class Meta: db_table \"tb_province\" verbose_name \"省份信息\" verbose_name_plural verbose_name def __str__(self): return self.name class City(models.Model): name models.CharField(max_length 50, verbose_name \"城市\") province models.ForeignKey(\"Province\", on_delete models.DO_NOTHING, verbose_name \"省份\") class Meta: db_table \"tb_city\" verbose_name \"城市信息\" verbose_name_plural verbose_name def __str__(self): return self.name class Person(models.Model): firstname models.CharField(max_length 10, verbose_name \"姓\") lastname models.CharField(max_length 10, verbose_name \"名\") hometown models.ForeignKey(\"City\", on_delete models.DO_NOTHING, related_name \"hometown_peoples\", verbose_name \"家乡\") living models.ForeignKey(\"City\", on_delete models.DO_NOTHING, related_name \"living_peoples\", verbose_name \"现居地\") visitation models.ManyToManyField(\"City\", related_name \"visit_peoples\", verbose_name \"旅游地\") class Meta: db_table \"tb_person\" verbose_name \"用户信息\" verbose_name_plural verbose_name def __str__(self): return self.firstname + self.lastname class PersonProfile(models.Model): mobile models.CharField(max_length 20, verbose_name \"联系电话\") wechat models.CharField(max_length 50, verbose_name \"微信号\") person models.OneToOneField(\"Person\", on_delete models.CASCADE, related_name \"profile\") class Meta: db_table \"tb_person_profile\" verbose_name \"用户详细信息\" verbose_name_plural verbose_name def __str__(self): return self.person.firstname + self.person.lastname ``` 数据迁移 ``` python manage.py makemigrations python manage.py migrate ``` 测试数据，代码： ```mysql INSERT INTO school.tb_province (name) VALUES (\"河南省\"); INSERT INTO school.tb_province (name) VALUES (\"广东省\"); INSERT INTO school.tb_city (name, province_id) VALUES ('开封市', 1); INSERT INTO school.tb_city (name, province_id) VALUES ('郑州市', 1); INSERT INTO school.tb_city (name, province_id) VALUES ('广州市', 2); INSERT INTO school.tb_city (name, province_id) VALUES ('深圳市', 2); INSERT INTO school.orm_person (firstname, lastname, hometown_id, living_id) VALUES ('张', '三丰', 1, 1); INSERT INTO school.orm_person (firstname, lastname, hometown_id, living_id) VALUES ('张', '雷锋', 1, 2); INSERT INTO school.orm_person (firstname, lastname, hometown_id, living_id) VALUES ('张', '翠山', 2, 3); INSERT INTO school.orm_person (firstname, lastname, hometown_id, living_id) VALUES ('张', '无忌', 3, 4); INSERT INTO school.orm_person (firstname, lastname, hometown_id, living_id) VALUES ('张', '老六', 3, 2); INSERT INTO school.orm_person_visitation (person_id, city_id) VALUES (1, 1); INSERT INTO school.orm_person_visitation (person_id, city_id) VALUES (1, 2); INSERT INTO school.orm_person_visitation (person_id, city_id) VALUES (1, 3); INSERT INTO school.orm_person_visitation (person_id, city_id) VALUES (2, 2); INSERT INTO school.orm_person_visitation (person_id, city_id) VALUES (2, 3); INSERT INTO school.orm_person_visitation (person_id, city_id) VALUES (2, 4); INSERT INTO school.orm_person_visitation (person_id, city_id) VALUES (3, 1); INSERT INTO school.orm_person_visitation (person_id, city_id) VALUES (3, 2); INSERT INTO school.orm_person_visitation (person_id, city_id) VALUES (3, 3); INSERT INTO school.orm_person_visitation (person_id, city_id) VALUES (3, 4); INSERT INTO school.orm_person_visitation (person_id, city_id) VALUES (4, 3); INSERT INTO school.orm_person_visitation (person_id, city_id) VALUES (4, 4); INSERT INTO school.orm_person_visitation (person_id, city_id) VALUES (5, 2); INSERT INTO school.orm_person_visitation (person_id, city_id) VALUES (5, 3); INSERT INTO school.orm_person_visitation (person_id, city_id) VALUES (5, 4); ``` #### select_related ```python # 获取主表信息的同时，也把外键表数据也获取到 模型.objects.all().select_related() # 默认主表数据时，获取全部的外键字段 模型.objects.all().select_related('外键字段') 模型.objects.all().select_related('外键字段1').select_related('外键字段2')....select_related('外键字段n') #一次查询，连表操作性能低 模型.objects.all().select_related('外键字段__外键字段')　　　　#一次查询，连表操作性能低 举例： # 获取张三丰到过的城市, 分别在查找而非和查找城市的时候查两次 person Person.objects.filter(firstname \"张\", lastname \"三丰\").first() # # print(person) print(person.living) # \"\"\" # SELECT `orm_person`.`id`, `orm_person`.`firstname`, `orm_person`.`lastname`, `orm_person`.`hometown_id`, `orm_person`.`living_id` FROM `orm_person` WHERE (`orm_person`.`firstname` '张' AND `orm_person`.`lastname` '三丰') ORDER BY `orm_person`.`id` ASC LIMIT 1 # SELECT `orm_city`.`id`, `orm_city`.`name`, `orm_city`.`province_id` FROM `orm_city` WHERE `orm_city`.`id` 1 LIMIT 21 # \"\"\" # # select_related 全外键关联优化, 只查找一次, 使用INNER JOIN连表, 默认查找所有的表 person Person.objects.filter(firstname \"张\", lastname \"三丰\").select_related().first() \"\"\" SELECT `orm_person`.`id`, `orm_person`.`firstname`, `orm_person`.`lastname`, `orm_person`.`hometown_id`, `orm_person`.`living_id`, `orm_city`.`id`, `orm_city`.`name`, `orm_city`.`province_id`, `orm_province`.`id`, `orm_province`.`name`, T4.`id`, T4.`name`, T4.`province_id`, T5.`id`, T5.`name` FROM `orm_person` INNER JOIN `orm_city` ON (`orm_person`.`hometown_id` `orm_city`.`id`) INNER JOIN `orm_province` ON (`orm_city`.`province_id` `orm_province`.`id`) INNER JOIN `orm_city` T4 ON (`orm_person`.`living_id` T4.`id`) INNER JOIN `orm_province` T5 ON (T4.`province_id` T5.`id`) WHERE (`orm_person`.`firstname` '张' AND `orm_person`.`lastname` '三丰') ORDER BY `orm_person`.`id` ASC LIMIT 1 \"\"\" print(person.living) # # 限定外键的优化查找, 指定连接的表 person Person.objects.filter(firstname \"张\", lastname \"三丰\").select_related(\"living\").first() print(person.living) print(person.living.province) \"\"\" SELECT `orm_person`.`id`, `orm_person`.`firstname`, `orm_person`.`lastname`, `orm_person`.`hometown_id`, `orm_person`.`living_id`, `orm_city`.`id`, `orm_city`.`name`, `orm_city`.`province_id` FROM `orm_person` INNER JOIN `orm_city` ON (`orm_person`.`living_id` `orm_city`.`id`) WHERE (`orm_person`.`firstname` '张' AND `orm_person`.`lastname` '三丰') ORDER BY `orm_person`.`id` ASC LIMIT 1 SELECT `orm_province`.`id`, `orm_province`.`name` FROM `orm_province` WHERE `orm_province`.`id` 1 LIMIT 21 \"\"\" # 限定外键的优化查找 person Person.objects.filter(firstname \"张\", lastname \"三丰\").select_related(\"hometown\").select_related(\"living__province\").first() print(person.living) print(person.living.province) print(person.living.hometown) \"\"\" SELECT `orm_person`.`id`, `orm_person`.`firstname`, `orm_person`.`lastname`, `orm_person`.`hometown_id`, `orm_person`.`living_id`, `orm_city`.`id`, `orm_city`.`name`, `orm_city`.`province_id`, `orm_province`.`id`, `orm_province`.`name` FROM `orm_person` INNER JOIN `orm_city` ON (`orm_person`.`living_id` `orm_city`.`id`) INNER JOIN `orm_province` ON (`orm_city`.`province_id` `orm_province`.`id`) WHERE (`orm_person`.`firstname` '张' AND `orm_person`.`lastname` '三丰') ORDER BY `orm_person`.`id` ASC LIMIT 1 \"\"\" ``` #### prefetch_related ```python 模型.objects.prefetch_related('外键字段') 　#不连表，一次性多次查询 模型.objects.all().select_related('外键字段__外键字段') 举例 \"\"\"[查询优化] prefetch_related\"\"\" # 查询所有人的足迹, 首先查询Person, 之后在查询visitation, 进行两次查询 person_list Person.objects.all() for person in person_list: print(person.visitation.all()) \"\"\" SELECT `orm_person`.`id`, `orm_person`.`firstname`, `orm_person`.`lastname`, `orm_person`.`hometown_id`, `orm_person`.`living_id` FROM `orm_person` SELECT `orm_city`.`id`, `orm_city`.`name`, `orm_city`.`province_id` FROM `orm_city` INNER JOIN `orm_person_visitation` ON (`orm_city`.`id` `orm_person_visitation`.`city_id`) WHERE `orm_person_visitation`.`person_id` 1 LIMIT 21 SELECT `orm_city`.`id`, `orm_city`.`name`, `orm_city`.`province_id` FROM `orm_city` INNER JOIN `orm_person_visitation` ON (`orm_city`.`id` `orm_person_visitation`.`city_id`) WHERE `orm_person_visitation`.`person_id` 2 LIMIT 21 SELECT `orm_city`.`id`, `orm_city`.`name`, `orm_city`.`province_id` FROM `orm_city` INNER JOIN `orm_person_visitation` ON (`orm_city`.`id` `orm_person_visitation`.`city_id`) WHERE `orm_person_visitation`.`person_id` 3 LIMIT 21 SELECT `orm_city`.`id`, `orm_city`.`name`, `orm_city`.`province_id` FROM `orm_city` INNER JOIN `orm_person_visitation` ON (`orm_city`.`id` `orm_person_visitation`.`city_id`) WHERE `orm_person_visitation`.`person_id` 4 LIMIT 21 SELECT `orm_city`.`id`, `orm_city`.`name`, `orm_city`.`province_id` FROM `orm_city` INNER JOIN `orm_person_visitation` ON (`orm_city`.`id` `orm_person_visitation`.`city_id`) WHERE `orm_person_visitation`.`person_id` 5 LIMIT 21 \"\"\" # 多对多中使用prefetch_related来减少SQL语句 person_list Person.objects.prefetch_related(\"visitation\").all() for person in person_list: print(person.visitation.all()) \"\"\" SELECT `orm_person`.`id`, `orm_person`.`firstname`, `orm_person`.`lastname`, `orm_person`.`hometown_id`, `orm_person`.`living_id` FROM `orm_person` WHERE (`orm_person`.`firstname` '张' AND `orm_person`.`lastname` '三丰') ORDER BY `orm_person`.`id` ASC LIMIT 1 SELECT (`orm_person_visitation`.`person_id`) AS `_prefetch_related_val_person_id`, `orm_city`.`id`, `orm_city`.`name`, `orm_city`.`province_id` FROM `orm_city` INNER JOIN `orm_person_visitation` ON (`orm_city`.`id` `orm_person_visitation`.`city_id`) WHERE `orm_person_visitation`.`person_id` IN (1, 2, 3, 4, 5) \"\"\" # prefetch_related也支持多级外键 person_list Person.objects.prefetch_related(\"visitation__province\").all() for person in person_list: print(person.visitation.all()) \"\"\" SELECT `orm_person`.`id`, `orm_person`.`firstname`, `orm_person`.`lastname`, `orm_person`.`hometown_id`, `orm_person`.`living_id` FROM `orm_person` SELECT (`orm_person_visitation`.`person_id`) AS `_prefetch_related_val_person_id`, `orm_city`.`id`, `orm_city`.`name`, `orm_city`.`province_id` FROM `orm_city` INNER JOIN `orm_person_visitation` ON (`orm_city`.`id` `orm_person_visitation`.`city_id`) WHERE `orm_person_visitation`.`person_id` IN (1, 2, 3, 4, 5) SELECT `orm_province`.`id`, `orm_province`.`name` FROM `orm_province` WHERE `orm_province`.`id` IN (1, 2) \"\"\" ```"},"/note/编程基础/python/进阶使用/django/2025-7-24-02-创建.html":{"title":"创建","content":"# 创建 可以使用命令`django admin startproject 名字` ![image 20250724174839544](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507241748592.png) 启动: `python manage.py runserver 8000` ![image 20250724175212776](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507241752847.png) 可以在`ElectronicPet/settings.py`文件里面的ALLOWED_HOSTS选择可以用于访问的IP地址 ## 目录架构 ``` djdemo/ # 项目根目录 │─ manage.py # 入口程序，终端脚本命令, 提供了一系列用于生成文件或者目录的命令,也叫脚手架 └─ djdemo/ # 主应用开发目录,保存了项目中的所有开发人员编写的代码, 目录是生成项目时指定的 │ asgi.py # django3.0以后新增的，用于让django运行在异步编程模式的一个web应用对象 │ settings.py # 默认开发配置文件，将来填写数据库账号，密码等相关配置 │ urls.py # 总路由文件,用于绑定django应用程序和url的映射关系, 不同的路径对应不同的功能 │ wsgi.py # wsgi就是项目运行在wsgi服务器时的入口文件, 本质上来说，manage.py runserver 内部调用的就是wsgi └ __init__.py # 包初始化文件 ``` > 默认运行的是这个同步阻塞的 可以在http://127.0.0.1:8000/admin这个页面进行登录 ## 快速使用 在django中要提供数据展示给用户,我们需要完成3个步骤. ``` 1. 创建子应用 2. 在子应用的视图文件views.py 中编写视图函数 3. 把视图函数和url进行绑定注册到django项目. 用户就可以通过url地址访问，用户访问的时候，django自动根据url地址执行对应的视图函数 ``` ### 1. 创建子应用 ``` python manage.py startapp 子应用名称（目录） django admin startapp 子应用名称 ``` 子应用的名称将来会作为目录名而存在，**务必按变量名的命名规则**来创建，不能出现特殊符号,也是不能出现中文等多字节的字符，更不能以数字开头！！！ ![image 20250724191058505](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507241910558.png) + migrations: 数据迁移文件, 同步数据到数据库的 + views: 视图函数 ### 2. 在子应用的视图文件中编写视图函数 `home/views.py`,代码: ```python from django.http.response import HttpResponse def index(request): # 业务代码 print(\"视图运行了\") return HttpResponse(\"hello world!\") # 可以使用这种方式解析html HttpResponse(\"<h1>ok!!!</h1>\") ``` ### 3. 绑定路由和视图的映射关系 `djdemo/urls.py`代码： ``` from django.contrib import admin from django.urls import path from home.views import index urlpatterns [ path('admin/', admin.site.urls), path(\"index/\", index), # 新加入的代码 ] ``` 因为上面我们绑定index视图函数的url地址是index,所以我们可以通过`http://127.0.0.1:8000/`拼接url地址`index`来访问视图函数 上面的过程,我们就可以展示数据给客户端浏览器了.但是这个过程发生了什么,怎么实现的?我们需要清晰几个相关概念：`网页类型`，`web服务器`和`MVT设计模式`，`路由`。 ## web服务 **web服务器**，全称也叫`http web server`，专门**用于提供网页文件浏览的一类服务器软件**，本质上就是一种收发http协议并解析http内容的服务器软件，可以通过各类语言使用代码开发实现。 前面的学习中，我们在编辑器中执行manage.py文件以后, 之所以用户能使用浏览器访问视图函数就是django内置的**测试**web服务器的功劳. 常见的web服务器软件: **nginx**，**uwsgi**，gunicorn，apache，toncat，uvicon。 其中, uwsgi和gunicorn, uvicon就是使用python开发的web服务器软件。 注意: 大部分的项目框架都有内置的测试web服务器。其中django框架就内置了python解析器提供的wsgiref模块，这个模块是python官方提供给开发者进行学习测试使用的，不能用于项目实际运营的线上环境中, 因为这个测试web服务器，性能不好，不支持多线程。 wsgi 就是python基于cgi标准实现的http通讯技术 asgi 就是wsgi的异步版本，async就是这个a，也就是python使用协程异步基于cgi标准实现的异步http通信技术。 ![image 20250725102911071](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507251029225.png) > **路由作用：将请求分发到正确的处理逻辑（视图）** > > 接收从 `Application` 传来的 `Request` 对象 > 根据请求的 URL 路径、请求方法（GET/POST 等）等信息 > 匹配到对应的处理函数（即视图） > 把请求交给对应视图函数去处理 > > **视图作用：负责处理业务逻辑并返回响应数据** > > 从请求对象中提取参数 > 调用数据库或业务逻辑 > 构建响应对象（Response），通常是 HTML、JSON、文件等 > 返回给路由或 Application 层处理 ``` 客户端浏览器 ↓ http 请求报文 ↓ http web服务器（监听端口、解析请求） ↓ Application（web应用处理程序，实例化Request对象） ↓ →【路由】⇒ 调用 View（Django 中的 View 处理逻辑） ↓ →【Template】模板渲染（生成 HTML 页面） ↓ 返回 http 响应报文 ``` #### MVT 设计模式 所谓的设计模式，就是前人针对解决常用业务场景所总结出来的一套解决方案【解决问题的流程】。 + Django主要采用MVT模式。 *M model\\*：模型，操作数据库功能部分。 *V View\\*：视图，处理业务逻辑的位置，提取数据、获取用户数据等等操作都在这里。 *T Template\\*：模版，用来展示视图操作后的数据，也可以在模版中为用户提供表单，让用户可以提交数据。 MVT MVC 描述 *M model**\\*** *M model\\* 数据模型 *V View\\* *C Controller\\* 业务逻辑 *T Template\\* *V view\\* 外观效果 ``` # MVT 的交互流程 前后端不分离开发， 后台工程师 会写前端代码（所有的， 只写模板部分） # MVC 前后端分离， 后台工程师 只写后台代码 json数据 1. 发请求 django框架 V 处理主业务逻辑（1.判断路由 2.解析参数 3.对接Model 4.返回数据） 2. V 获取数据 Model(交互数据库) 3. model >V 4. V >数据 Template 模板 5. Template 模板 数据渲染 V 展示 客户端 ``` ##### MVC设计模式 ***M model\\***：**数据模型**，和**MVT**的 m 是一样的，同样用来操作数据库 ***V view\\***：**视图**，和**MVT**的 T 是一样的，用来进行数据的可视化 ***C Controller\\***：**控制器**，相当于**MVT**中的 C，用来进行数据的逻辑操作 ``` # MVC 的交互流程 1. 前端 View视图里面页面 发送请求 给后台后端 2. 控制器来接收请求Controller > 处理主业务逻辑（1.判断路由 2.解析参数 3.对接Model 4.返回数据） 3. Model 交互数据库 返回数据给 C 4. C把数据 传给V 展示 ``` ## 会话控制技术 在web开发领域，网络中网页之间进行内容传输使用的协议是http/https协议。 http协议是一种无状态, 有所请求必有所回应的超文本传输协议，HTTP为了提升效率，一经完成请求和响应的过程以后，就会自动关闭连接。所谓无状态意指: 基于http协议提供服务的服务端,无法识别前后多次请求过程中,是不是同一个客户端发送的还是多个客户端发送的。 web开发的应用往往不仅仅只是一个网页或一个功能，那么怎么多个页面不同的请求，识别用户之前的状态和行为？ 为了能在多次请求过程中,识别客户端是否是同一个客户端,所以就出现了会话跟踪技术，就需要使用会话控制技术, 也叫会话保持或者会话跟踪技术. 会话控制技术，主要作用是**为了识别和记录用户在web应用中的身份行为和操作历史**。 ### 会话 会话的单词：session，所谓一次会话其实就是客户端和服务端之间进行通信的一次完整过程。 在web项目中： ​ 客户端和服务端之间产生的会话开始于: **在用户第一次通过url访问网站的时候** ​ 客户端和服务端之间的会话结束于**关闭浏览器** 注意: 如果在移动端下面，则必须是关闭当前app应用才算结束会话，如果只是后台运行，会话并没有结束的. 所以会话跟踪技术就是在一次完整的会话中,能让服务端识别客户端在整个过程中的身份行为和操作历史的一项技术. 实现会话控制的几种技术类型： 1. url地址栏记录用户身份的参数[少见，很古老的技术了，例如：QQ邮箱，QQ空间] 2. cookie: 在浏览器中由浏览器自动读写保存用户信息的一种小文件，能够存储的数据有限，30M左右，[过时了，谷歌在2021开始慢慢关闭这个cookie技术了] 3. session: 在服务端中保存用户信息的文件存储信息技术，能够存储的数据视存储设备而定，根据服务端配置而定。session默认是基于cookie的 4. token令牌: 就是一段可以记录和识别用户身份的字符串，通过客户端语言[js/安卓/ios]保存在客户端中一项技术，替代cookie或session. jwt就是token技术的其中一种。Oauth2.0也是属于token令牌技术的一种。 ### cookie cookie是保存在客户端浏览器中的小文本，由浏览器自动管理和收发, 所以cookie中不要保存用户的敏感信息，例如: 密码，身份证，手机号等等之类的。而且cookie在浏览器中用户是可以手动关闭或禁止cookie功能的.如果关闭了cookie功能,一般服务端能做的就只有2个事情了:1. 提示用户开启cookie功能, 2. 不要使用cookie进行会话控制了。 ![image 20250725154826345](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507251548433.png) #### 使用实例 ```python from django.http.response import HttpResponse ​ ​ def set_cookie(request): \"\"\"设置/保存/更新Cookie\"\"\" response HttpResponse() # 生成cookie \"\"\" 参数列表： key, # 键/变量 value '', # 值/内容 max_age None, # 设置cookie的有效时间，单位: 秒 expires None, # 设置cookie的过期时间戳[时间戳表示从1970 01 01 00:00:00至今的总秒数] # datetime.now().timestamp() 获取时间戳 # int( time.time() * 1000 ) 获取毫秒时间戳 # datetime.now().timestamp() 获取毫秒时间戳 ​ path None, # 当前cookie是否只能在指定公共路径下使用，None表示在同一个域名下，任意路径都可以使用 domain None, # 当前cookie是否只能在指定同一段域名下使用，None表示在当前服务器所在域名下使用 secure False, # 当前cookie是否只能在https协议下使用，False表示在http协议下也能使用 httponly False, # 当前cookie是否只能在http协议下使用,False表示在其他协议下也可以使用 \"\"\" response.set_cookie(\"uname\", \"xiaoming\", max_age 5) response.set_cookie(\"uid\", 100, max_age 180) # 设置cookie信息，可以不设置过期时间，默认cookie有效期的就是浏览器关闭时自动删除 # 会话结束时浏览器会自动删除没有设置有效的cookie，而设置了有效期的cookie则只会在到期时才删除 response.set_cookie(\"is_login\", True, ) return response def get_cookie(request): \"\"\"通过request.COOKIES可以获取客户端发送过来的cookie\"\"\" # 获取本次客户端发送过来的所有cookie print(request.COOKIES) # 获取指定名称cookie print(\"uid \", request.COOKIES.get(\"uid\")) # 不存在的或过期的cookie不会被浏览器通过http请求头携带到服务端 print(\"uname \", request.COOKIES.get(\"uname\")) # cookie的修改，与添加一致，cookie重复的变量名会覆盖 response HttpResponse(\"OK\") response.set_cookie(\"uname\", \"xiaohong\", max_age 15) return response def del_cookie(request): \"\"\"直接删除cookie在服务端是做不到的，因为cookie保存在客户端，所以我们需要通知客户端自己去删除\"\"\" # 告诉浏览器，cookie过期了 response HttpResponse(\"告诉客户端，删除cookie\") # 设置有效期为0秒，当浏览器接受响应内容时，0秒早就到了，所以会自动删除 response.set_cookie(\"uid\", \"\", max_age 0) return response ``` ### session 这里的session就是会话控制技术的一种, **session主要把用户状态信息保存在服务器的文件中**。 在没有进行特殊设置的情况下，session以文件格式保存状态数据, 一般保存的目录是系统的缓存文件存储目录. 例如: windows的C:/windows/temp目录 ,Linux/Mac OS的/tmp目录 > 因为session是在服务端中保存数据,相对而言比cookie要安全.但是因为用户的数据都保存到服务器中,当用户基数大了,则服务器的存储压力就来了.所以一般不会考虑把session数据保存在文件，而是采用的第三方设置存储session的方案，例如保存到redis或者mysql之类的数据库里面。 ![image 20250725164931095](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507251649183.png) #### 数据存储 用户的数据可以放在文件里面, 也可以放在数据库里面, 可以在setting里面配置 ```python # 配置项 # session核心类 SESSION_ENGINE \"django.contrib.sessions.backends.file\" # 保存到文件: django.contrib.sessions.backends.file # 保存到数据库: django.contrib.sessions.backends.db # 需要配置数据库连接 # 保存到缓存中: django.contrib.sessions.backends.cache # 需要配置缓存连接 # session存储目录[如果不设置,则默认是系统的缓存目录] # 3.0以前的django 通过以下代码配置 # SESSION_FILE_PATH os.path.join(BASE_DIR, \"session\") # 3.0以后通过以下配置 SESSION_FILE_PATH BASE_DIR / \"session_path\" # 路径拼接，如果当前目录不存在，必须手动创建，否则报错 ``` #### 读写 ```python def set_session(request): \"\"\"设置session\"\"\" # session保存在服务端，所以所有关于session的操作都是由request.session来完成的 # request.session[\"uname\"] \"root\" request.session[\"uid\"] 1 return HttpResponse(\"设置session数据\") def get_session(request): \"\"\"获取session \"\"\" print(f\"uname {request.session.get('uname')}\") # format string python3.6提供的 print(f\"uid {request.session.get('uid')}\") # 获取session所有的键值对 print(request.session.items()) # 获取session数据的有效，默认值是：2周 > 60 * 60 * 24 * 7 * 2 print(request.session.get_session_cookie_age() ) return HttpResponse(\"获取session数据\") def del_session(request): \"\"\"删除session数据\"\"\" # 删除单个指定名称的session if request.session.get(\"name\"): request.session.pop(\"name\") # 删除所有的session，慎用 request.session.clear() return HttpResponse(\"删除session数据\") ``` ![image 20250725174956854](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507251749993.png)"},"/note/编程基础/python/进阶使用/django/2025-8-3-12-异步.html":{"title":"WSGI和ASGI","content":"# WSGI和ASGI WSGI和ASGI，都是基于Python设计的网关接口（Gateway Interface，GI）。 WSGI是python语言基于http协议模式开发的，不支持websocket协议，而ASGI的诞生解决了python中的WSGI不支持当前的web开发中的一些新的协议标准，同时ASGI支持原有模式和Websocket的扩展，即ASGI是WSGI的扩展。 ## 基础定义 ### 网关接口 网关接口（Gateway Interface，GI）就是一种为了实现加载动态脚本而运行在Web服务器和Web应用程序中的通信接口，也可以理解为一份协议/规范。只有Web服务器和Web应用程序都实现了网关接口规范以后，双方的通信才能顺利完成。常见的网关接口协议：CGI，FastCGI，WSGI，ASGI。 ![image 20210608222947398](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202508031319966.png) ### CGI 公共网关接口（Common Gateway Interface，CGI）是最早的Web服务器主机提供信息服务的标准接口规范。只要实现了CGI协议，Web服务器就能够获取并了解客户端提交的信息，转交给服务器端的web应用程序进行处理，最后返回结果给客户端。 CGI程序是一种实现了CGI协议的程序。 快速通用网关接口（Fast Common Gateway Interface／FastCGI）是一种让web应用程序与Web服务器通信的协议。FastCGI是公共网关接口（CGI）的增强版本。 ### Web服务器 Web服务器（Web Server）是一种运行于网站后台（物理服务器）的软件。Web服务器主要用于提供网页浏览或文件下载服务，它可以向浏览器等Web客户端提供html网页文档，也可以提供其他类型的可展示文档，让客户端用户浏览；还可以提供数据文件下载等。目前世界上最主流的Web服务器有 Nginx 、Apache、IIS、tomcat。 ### Web应用程序 Web应用程序（Web Programming Application）是一种能完成web业务逻辑，能让用户基于web浏览器访问的应用程序，它可以是一个实现http请求和响应功能的函数或者类，也可以是Django、Flask、FastAPI等这样的web框架，当然也可以是其他语言的web程序或web框架。 > 问：Web服务器和Web应用程序的区别？ > 答：Web应用程序主要是完成web应用的业务逻辑的处理，Web服务器则主要是应对外部请求的接收、响应和转发。 > 需要使用web服务器启动运行，web应用程序才能被用户访问到。 > 而django框架中，我们之所以只有一个web应用程序就跑起来了，是因为我们在终端执行了一个命令，python manage.py runserver。 > 这个命令启动了django框架中内置提供的测试web服务器。 ## WSGI ![image 20210608223815714](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202508031329264.png) Web服务器网关接口（Web Server Gateway Interface，WSGI），是Python为了解决**Web服务器端与客户端之间的通信**基于CGI标准而设计的。实现了WSGI协议的web服务器有：uWSGI、[gunicorn](https://gunicorn.org/)、uvicorn、[Hypercorn](https://pgjones.gitlab.io/hypercorn/)。像django框架开发的项目一般在线上服务器运行就不会使用runserver来运行，而是采用上面实现了WSGI协议的web服务器来运行。 django中运行runserver命令时，其实内部就启动了wsgiref模块作为web服务器运行的。wsgiref是python内置的一个简单地遵循了wsgi接口规范的web服务器程序。 ### WSGI web服务器 ```python from wsgiref.simple_server import make_server # application 由wsgi服务器调用、函数对http请求与响应的封装、使得Python专注于HTML # environ http 请求 (是一个字典) # start_response 响应 (是一个函数) def application(environ, start_response): \"\"\"web应用程序\"\"\" # 判断请求 if environ['REQUEST_METHOD'] 'GET' and environ['PATH_INFO'] '/': # 响应 start_response('200 OK', [('Content Type', 'text/html')]) return [b'<h1>hi, python!</h1>'] # 判断请求 elif environ['REQUEST_METHOD'] 'GET' and environ['PATH_INFO'] '/python': # 响应 start_response('200 OK', [('Content Type', 'text/html')]) return [b\"<h1>it work!</h1>\"] if __name__ '__main__': # 启动服务器 这个服务器负责与 wsgi 接口的 application 函数对接数据 httpd make_server('127.0.0.1', 8888, application) # 监听请求 httpd.serve_forever() # 1. 监听8000端口, # 2. 把http请求根据WSGI协议将其转换到applcation中的environ参数, 然后调用application函数. # 3. wsgiref会把application函数提供的响应头设置转换为http协议的响应头, # 4. 把application的返回(return)作为响应体, 根据http协议,生成响应, 返回给浏览器. # http://127.0.0.1:8888/ # http://127.0.0.1:8888/python ``` 开发中，我们一般使用uWSGI或者Gunicorn作为web服务器运行django。 ### uWSGI [uWSGI](https://uwsgi docs.readthedocs.io/) 是一个快速的，自我驱动的，对开发者和系统管理员友好的应用容器服务器，完全由 C 编写，实现了WSGI协议,uwsgi,http等协议。注意：uwsgi 协议是一个 uWSGI服务器自有的协议,用于定义传输信息的类型，常用于uWSGI服务器与其他网络服务器的数据通信中。 文档：https://docs.djangoproject.com/zh hans/3.2/howto/deployment/wsgi/uwsgi/ 配置：https://uwsgi.readthedocs.io/en/latest/Configuration.html\t ``` conda config add channels conda forge conda install uWSGI ``` 项目根目录下创建uwsgi配置文件，uwsgi.ini(不是python文件)，代码样本： ``` [uwsgi] #使用nginx连接时使用，Django程序所在服务器地址 socket 0.0.0.0:8000 #直接做web服务器使用，Django程序所在服务器地址 # http 0.0.0.0:8000 #项目目录 chdir 项目根目录绝对路径 #项目中wsgi.py文件的目录，相对于项目目录 wsgi file 主应用目录/wsgi.py # 进程数 CPU * 2 1 processes 4 # 线程数 threads 2 # uwsgi服务器的角色 master True # 存放进程编号的文件 pidfile uwsgi.pid # 日志文件，因为uwsgi可以脱离终端在后台运行，日志看不见。我们以前的runserver是依赖终端的 daemonize uwsgi.log # 指定依赖的虚拟环境 virtualenv 虚拟环境的绝对路径 ``` uwsgi.ini，代码： ``` [uwsgi] # 使用nginx连接时使用，Django程序所在服务器地址 # socket 0.0.0.0:8000 # 直接做web服务器使用，Django程序所在服务器地址 http 0.0.0.0:8000 # 项目目录 # chdir 项目根目录，务必使用绝对路径 chdir /home/moluo/Desktop/djdemo # 项目中wsgi.py文件的目录，相对于项目根目录 wsgi file djdemo/wsgi.py # 进程数 CPU * 2 1 , 也可以不减1 processes 4 # 线程数 CPU数量 threads 2 # uwsgi服务器的角色 master True # 存放进程编号的文件 pidfile uwsgi.pid # 日志文件，因为uwsgi可以脱离终端在后台运行，日志看不见。我们以前的runserver是依赖终端的 daemonize uwsgi.log # 指定依赖的虚拟环境 # virtualenv /root/.virtualenvs/环境名称 virtualenv /home/moluo/anaconda3/envs/djdemo ``` 项目根目录下，启动uwsgi服务器 ```bash # 启动项目 uwsgi ini uwsgi.ini # 停止运行 uwsgi stop uwsgi.pid # 调用系统的 kill 9 uwsgi.pid中的进程号 # 查看当前系统中的指定名称的进程 ps aux grep uwsgi # 输出效果如下，则表示成功运行，接下来就可以根据配置中设置的地址访问项目了。 # (base) moluo@ubuntu:~$ ps aux grep uwsgi # moluo 12759 2.3 0.9 96944 37736 ? S 11:52 0:00 uwsgi ini uwsgi.ini # moluo 13167 0.0 0.7 170676 29468 ? Sl 11:52 0:00 uwsgi ini uwsgi.ini # moluo 13169 0.0 0.7 170676 29468 ? Sl 11:52 0:00 uwsgi ini uwsgi.ini # moluo 13171 0.0 0.7 170676 29468 ? Sl 11:52 0:00 uwsgi ini uwsgi.ini # moluo 13173 0.0 0.7 170676 29468 ? Sl 11:52 0:00 uwsgi ini uwsgi.ini # moluo 13176 0.0 0.8 105140 35416 ? S 11:52 0:00 uwsgi ini uwsgi.ini # moluo 18073 0.0 0.0 17688 740 pts/2 R+ 11:52 0:00 grep color auto uwsgi ``` ![image 20210609121333733](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202508031514654.png) ## ASGI ASGI，是构建于WSGI接口规范之上的**异步服务器网关接口**，是WSGI的延伸和扩展。 ``` A指的是Async，异步的意思。 ``` 协议，规范 支持的请求协议（常见，未列全） 同步/异步 支持的框架 CGI HTTP CGI程序 WSGI HTTP 同步 django3.0以前，Flask1.0 ASGI HTTP，HTTP2，WebSocket等 同步/异步 FastAPI，Tornado，django3.1以后，flask2.0 在 Python3.5 之后增加 async/await 特性之后简化了协程操作以后，异步编程变得异常火爆，越来越多开发者投入异步的怀抱。 3.0版本以前，django所提供的所有内部功能都是基于同步编程的。所以，在以往django开发中，针对网络请求，数据库读取等IO操作形成的阻塞，往往会导致项目运行性能的下降。虽然等待I/O操作数微秒时，但是随着流量的增加和操作的频率上升，这一点点的阻塞就会导致整个项目运作的缓慢。而如果换成异步就不会有任何阻塞，还可以同时处理其他任务，从而以较低的延迟处理更多的请求。所以在目前python开发中，越来越多的框架开始支持了异步编程。所以，3.0版本以后，django开始支持异步编程，可以让开发者在django中使用python第三方异步模块，推出了asgi异步web服务器。3.1版本推出了异步视图，当然，目前django的异步编程还不够完善，django中只有极少的功能是支持了异步操作。 ### Uvicorn > Django支持的另一个web服务器 ![image 20210608235013829](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202508031518244.png) Uvicorn 是一个快速的 ASGI 服务器，Uvicorn 是基于 uvloop 和 httptools 构建的，是 Python 异步生态中重要的一员。 Uvicorn 当前支持 HTTP / 1.1 和 WebSockets，将来计划支持HTTP/2.0。 文档：https://www.uvicorn.org/ 安装uvicorn ```python pip install uvicorn ``` 项目根目录下，运行django项目, 实际是运行asgi.py 的application函数 ```bash # uvicorn 主应用目录名.asgi:application reload uvicorn djdemo.asgi:application reload ``` 开发中一般使用gunicorn来管理uvicorn。所以可以一并安装(不支持Windows) > **Gunicorn**（Green Unicorn）是一个成熟的WSGI（Web Server Gateway Interface）服务器，广泛用于同步的Python Web应用的部署（例如Django、Flask）。其特点是： > > **以同步模式运行** > **多进程模型** > **丰富的插件和扩展支持** > > 随着异步Web框架变得流行，单纯的Gunicorn不支持异步功能，于是出现了一种常用的模式：**将Gunicorn作为管理器，使用Uvicorn作为工作类（worker）**。 > > ### 关系总结 > > **Uvicorn** 是一个纯粹的ASGI服务器，专为异步应用设计，性能极佳。 > **Gunicorn** 提供强大的多进程管理和部署能力，不直接支持ASGI标准，但可以通过插件（类似 `uvicorn.workers.UvicornWorker`）实现对ASGI应用的支持。 > **结合使用**：通常在生产环境中，将Gunicorn作为管理进程，使用`UvicornWorker`作为worker类，来部署异步应用。这样既能利用Gunicorn的管理与扩展能力，又能享受Uvicorn的高性能异步处理。 ``` pip install gunicorn ``` 运行 ``` # gunicorn w 4 主应用目录名.asgi:application k uvicorn.workers.UvicornWorker reload gunicorn w 4 djdemo.asgi:application k uvicorn.workers.UvicornWorker reload ``` ### Daphne [如何使用 Daphne 托管 Django Django documentation Django](https://docs.djangoproject.com/zh hans/4.2/howto/deployment/asgi/daphne/) 由Django团队开发，最初为支持Channels设计 未来发展紧密结合Django生态 ```bash python m pip install daphne daphne myproject.asgi:application ``` #### 与 `runserver` 集成 Daphne 提供了一个 [`runserver`](https://docs.djangoproject.com/zh hans/4.2/ref/django admin/#django admin runserver) 命令，用于在开发过程中使用 ASGI 来提供站点服务。 这可以通过将 `daphne` 添加到你的 [`INSTALLED_APPS`](https://docs.djangoproject.com/zh hans/4.2/ref/settings/#std setting INSTALLED_APPS) 的开头，并添加一个指向你的 ASGI 应用程序对象的 `ASGI_APPLICATION` 设置来启用： ``` INSTALLED_APPS [ \"daphne\", ..., ] ASGI_APPLICATION \"myproject.asgi.application\" ``` ## 异步视图 文档：https://docs.djangoproject.com/zh hans/4.2/topics/async/ ### 函数视图 在Django3.1后的版本中，我们可以通过`async def`语法，将任何函数视图定义为异步视图。 ```python \"\"\"同步视图\"\"\" import time def home1(request): time.sleep(5) return HttpResponse('Hello, sync view!') \"\"\"异步视图\"\"\" import asyncio async def home2(request): # asyncio.sleep(5) await asyncio.sleep(5) # 开发中，一般就是ORM操作，http请求，或者读取文件等IO操作，就需要在左边上加上 await return HttpResponse('Hello, async view!') ``` ### 类视图 类视图，django内部是将它的`__call__()`方法定义为`async def`，成为异步视图。 ```python class Home3View(View): async def __call__(self, *args, **kwargs): # 当把一个类当函数去调用，就会触发__call__方法 return super().__call__(*args, **kwargs) async def get(self, request): await asyncio.sleep(5) return HttpResponse(\"ok, get\") ``` ## 模型异步操作 django4.2版本的ORM对数据库的访问这块还没有全面实现异步处理，默认还是同步的。当我们需要在项目中调用模型进行异步操作时，django有提供了2个适配函数，可从`asgiref.sync`包中获取：`async_to_sync()`和 `sync_to_async()` 。它们用于同步和异步之间调用风格的转换，同时保持兼容性。适配函数既可以当包装函数使用，也可以作为装饰器使用。 async_to_sync()：异步转同步，参数就是同步函数 sync_to_async()：同步转异步，参数就是异步函数 ```python from asgiref.sync import async_to_sync # 用法1 sync_function async_to_sync(async_function) # 用法2 @async_to_sync async def async_function(...): pass ``` 代码： ```python from django.views import View from django.http.response import JsonResponse from component import models from asgiref.sync import sync_to_async # Create your views here. class User1View(View): async def __call__(self, *args, **kwargs): return super().__call__(*args, **kwargs) async def get(self, request): \"\"\"因为是异步视图，无法直接使用同步代码，所以报错：SynchronousOnlyOperation\"\"\" # student models.Student.objects.get(id 12) # print(student) \"\"\"在异步视图中，必须异步操作模型\"\"\" # sync_to_async(models.Student.objects.get, thread_sensitive True) # 上面就是把 models.Student.objects.get 进行异步转换，在线程安全模式运行 \"\"\"异步获取一条数据\"\"\" aget sync_to_async(models.Student.objects.get, thread_sensitive True) student await aget(id 12) # # aget就是get的异步方法，调用方法与原来的get一样 return JsonResponse({\"msg\": \"ok, get\", \"data\": { \"id\": student.id, \"name\": student.name, }}) \"\"\"异步获取多条数据\"\"\" # QuerySet 惰性查询，all执行的时候，根本没发生数据操作，自然也就没有IO student_objs models.Student.objects.all() student_list [] async for student in student_objs: student_list.append({ \"id\": student.id, \"name\": student.name, }) return JsonResponse({\"msg\": \"ok, get\", \"data\": student_list}) \"\"\"异步添加数据\"\"\" acreate sync_to_async(models.Student.objects.create, thread_sensitive False) student await acreate( name \"小柏\", age 13, sex True, mobile \"13956567878\", status 1, classmate \"307\", description \"话不多数，上就完事了！\") return JsonResponse({\"msg\": \"ok, get\", \"data\": { \"id\": student.id, \"name\": student.name, }}, status 201) ``` redis异步库：aioredis mysql异步库：aiomysql mongoDB异步库：motor http网络请求异步库：httpx ## 异步HTTP请求 views.py，代码： ```python import httpx from django.views import View from django.http.response import JsonResponse from component import models from asgiref.sync import sync_to_async # Create your views here. class User1View(View): async def __call__(self, *args, **kwargs): return super().__call__(*args, **kwargs) async def get(self, request): \"\"\"异步网络请求\"\"\" # 同步代码在遇到IO操作时就会出现阻塞，所以异步代码在IO时需要交出程序执行权 async with httpx.AsyncClient() as client: response await client.get(\"https://httpbin.org/get\") return JsonResponse(response.json()) ``` ## 异步中间件 3.1版本以后，django还提供了中间件的异步支持。 [中间件 Django documentation Django](https://docs.djangoproject.com/zh hans/4.2/topics/http/middleware/) 中间件支持同步和异步请求的任意组合。如果Django不能同时支持它们，它会调整请求来适应中间件的需求，但会有性能损失。 默认情况下，Django假设你的中间件只能处理同步请求。如果要改变这种模式，需要在你的中间件工厂函数或类中添加入如下属性： `sync_capable` 是一个布尔值，来表明中间件是否处理同步请求。默认为 `True`。 `async_capable` 是一个布尔值，来表明中间件是否处理异步请求。默认为 `False`。 如果你的中间件同时设置了 `sync_capable True` 和 `async_capable True`，那么Django将直接传递请求而不进行转换。在这种情况下，你可以通过检查传递给你的 `get_response` 对象是否是协程函数，使用 `asgiref.sync.iscoroutinefunction` 来确定你的中间件是否会接收到异步请求。 ```python \"\"\" wsgiref 是python内置模块，提供给开发者在开发时，用于创建同步web服务器 asgiref 是python内置模块，提供给开发者在开发时，用于创建异步web服务器 \"\"\" \"\"\"异步中间件\"\"\" \"\"\"异步函数中间件\"\"\" from asgiref.sync import iscoroutinefunction # iscoroutinefunction 是python内置 判断当前参数是否是协程函数，如果是协程函数，则返回值为True，否则False def simple_middleware(get_response): if iscoroutinefunction(get_response): async def middleware(request): response await get_response(request) return response else: def middleware(request): response get_response(request) return response return middleware \"\"\"异步类中间件\"\"\" from asgiref.sync import iscoroutinefunction, markcoroutinefunction # markcoroutinefunction 把当前参数标记为协程函数 class SimpleMiddleware2: \"\"\"异步中间件\"\"\" async_capable True sync_capable False def __init__(self, get_response): self.get_response get_response if iscoroutinefunction(self.get_response): markcoroutinefunction(self) async def __call__(self, request): response await self.get_response(request) return response async def process_request(self, request): print(\"视图执行之前!!\") async def process_response(self, request, response): print(\"视图执行以后！！\") return response ```"},"/note/编程基础/python/进阶使用/简单模块使用/2024-5-4-01logging日志模块.html":{"title":"logging日志模块","content":" layout: post title: \"logging日志模块\" date: 2024 4 27 15:39:08 +0800 tags: python基础 # logging模块 日志一般有5个等级 DEBUG >INFO >WARING >ERROR >CRITICAL + DEBUG: 调试信息 + INFO: 正常运行的时候的信息 + WRING: 一个意想不到的事情发生了, 但是这一个软件还可以运行 + ERROR: 严重的问题, 软件不能执行某一些功能 + CRITICAL: 严重的错误, 程序可能不能运行了 > 默认的时候EARING以上的信息可以被执行 ## 实际使用 ```python import logging # 基础配资 logging.basicConfig(level logging.WARNING, format \"%(asctime)s %(filename)s[line:%(lineno)d] %(levelname)s:%(message)s\") logging.debug('这是个一debug') logging.info(\"这是一个info\") logging.warning(\"这是一个warning\") logging.error(\"这是一个error\") logging.critical(\"这是一个critical\") ``` > ```bash > PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" > 2024 05 05 22:53:25,195 main.py[line:7] WARNING:这是一个warning > 2024 05 05 22:53:25,195 main.py[line:8] ERROR:这是一个error > 2024 05 05 22:53:25,195 main.py[line:9] CRITICAL:这是一个critical > ``` > > 这个basicConfig > > ![image 20240505225625562](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405052256646.png) > > ![image 20240505225641602](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405052256654.png) 同时到文件和终端 ```python import logging # 获取一个logger logger logging.getLogger() logger.setLevel(logging.INFO) # 这一个总开关, 这一个输出的最高级别 # 创建一个文件Handler logfile 'log.txt' fh logging.FileHandler(logfile, mode 'a') fh.setLevel(logging.WARNING) # 创建一个终端Handler ch logging.StreamHandler() ch.setLevel(logging.INFO) # 这里使用的级别大于总开关的时候不起作用 # 获取一个格式 formatter logging.Formatter('%(asctime)s %(name)s %(levelname)s %(message)s') # 设置不同Handler的输出格式 fh.setFormatter(formatter) ch.setFormatter(formatter) # 把输出添加到logger logger.addHandler(fh) logger.addHandler(ch) # 实际的信息打印 logger.info('This is an info message') logger.warning('This is a warning message') logger.error('This is an error message') logger.critical('This is a critical message') ```"},"/note/编程基础/python/进阶使用/简单模块使用/2025-3-15-02fastapi.html":{"title":"fastAPI","content":"# fastAPI [FastAPI](https://fastapi.tiangolo.com/zh/#typer fastapi) 一个用于快速搭建http服务器的模块 ```bash pip install fastapi pip install \"uvicorn[standard]\" ``` ## 示例 ```python from typing import Union from fastapi import FastAPI app FastAPI() @app.get(\"/\") def read_root(): return {\"Hello\": \"World\"} @app.get(\"/items/{item_id}\") def read_item(item_id: int, q: Union[str, None] None): return {\"item_id\": item_id, \"q\": q} ``` > 使用命令`uvicorn main:app reload`运行这个程序, 第一个main是文件名, 第二个app是文件里面定义的app参数 通过 *路径* `/` 和 `/items/{item_id}` 接受 HTTP 请求。 以上 *路径* 都接受 `GET` *操作*（也被称为 HTTP *方法*）。 `/items/{item_id}` *路径* 有一个 *路径参数* `item_id` 并且应该为 `int` 类型。 `/items/{item_id}` *路径* 有一个可选的 `str` 类型的 *查询参数* `q`。 ### 文档 http://127.0.0.1:8000/docs http://127.0.0.1:8000/redoc 以上两个地址二选一 ### 从 `PUT` 请求中接收请求体。 ```python from typing import Union from fastapi import FastAPI from pydantic import BaseModel app FastAPI() class Item(BaseModel): name: str price: float is_offer: Union[bool, None] None @app.get(\"/\") def read_root(): return {\"Hello\": \"World\"} @app.get(\"/items/{item_id}\") def read_item(item_id: int, q: Union[str, None] None): return {\"item_id\": item_id, \"q\": q} @app.put(\"/items/{item_id}\") def update_item(item_id: int, item: Item): return {\"item_name\": item.name, \"item_id\": item_id} ``` > 实际使用的时候需要在post的数据里面加入一个json字符串, 描述一个Item类型的数据"},"/note/编程基础/python/进阶使用/网络编程/2024-5-10-02Socket.html":{"title":"Socket","content":" layout: post title: \"Socket\" date: 2024 4 23 15:39:08 +0800 tags: python基础 # Socket ## UDP通信 可以使用python里面的socket模块进行创建一个socket ```python import socket socket.socket(AddressFamily, Type) ``` > AddressFamily: AF_INET用于Internet进程里面的通讯, AF_UNIX用于同一台机器的通信 > > Type: 实际使用的协议, SOCK_STREAM流式套接字, 一般使用的是TCP, SOCK_DGRAM, 数据套接字, 一般用UDP ```python import socket if __name__ \"__main__\": s socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((\"www.baidu.com\", 80)) s.send(b\"GET / HTTP/1.1\\r\\nHost: www.baidu.com\\r\\nConnection: close\\r\\n\\r\\n\") buffer [] while True: d s.recv(1024) if d: buffer.append(d) else: break data b\"\".join(buffer) s.close() # 分离header和html header, html data.split(b\"\\r\\n\\r\\n\", 1) print(header.decode(\"utf 8\")) with open(\"baidu.html\", \"wb\") as f: f.write(html) s.close() ``` ### 函数 #### sendto发送信息 ```python socket.sendto(bytes, address)¶ ``` ```python import socket if __name__ \"__main__\": s socket.socket(socket.AF_INET, socket.SOCK_DGRAM) dest_addr (\"192.168.65.1\", 8080) s.sendto(b\"GET / HTTP/1.1\\r\\nHost: www.baidu.com\\r\\nConnection: close\\r\\n\\r\\n\", dest_addr) s.close() ``` > 这一个直接发送的时候使用的是UDP, 在发送的时候这一个数据必须是bytes类型的, 发送的时候也可以使用一个字符串`.encode('utf 8')`进行编码, 获取的数据使用`.decode(\"utf 8\")`进行解码 ![image 20240510221308398](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405102213472.png) > 发送数据的时候会使用一个随机的端口, 每一次程序里面只会申请一次端口 #### recvfrom接收udp数据 ```python socket.recvfrom(bufsize[, flags]) ``` ```python import socket if __name__ \"__main__\": s socket.socket(socket.AF_INET, socket.SOCK_DGRAM) dest_addr (\"192.168.65.1\", 8080) s.sendto(b\"GET /v1/images/search HTTP/1.1\\r\\nHost: www.baidu.com\\r\\nConnection: close\\r\\n\\r\\n\", dest_addr) data, addr s.recvfrom(1024) print(data.decode()) print(addr) s.close() ``` > ```bash > PS E:\\JHY\\python\\2024 5 10 internet> python u \"e:\\JHY\\python\\2024 5 10 internet\\main.py\" > hello > ('192.168.65.1', 8080) > ``` > > 使用阻塞的方式进行获取数据, 接收的数据是一个元组, 里面分别的是获取的数据以及这一个数据的来源 See the Unix manual page *[recv(2)](https://manpages.debian.org/recv(2))* for the meaning of the optional argument *flags*; it defaults to zero. (The format of *address* depends on the address family — see above.) #### bind绑定端口 ```python socket.bind(address) ``` > 参数是一个元组, 第一个是元素ip字符串, 第二个元素是端口, 这一个ip可以为空, 会使用本机的ip ````python s.bind((\"\", 11451)) ```` > 这一个绑定的时候需要在发送信息前面, 否则有一个自动绑定的端口, 不能再进行绑定 #### 非阻塞 ```python # 设置套接字为阻塞或非阻塞模式：如果 flag 为 false，则将套接字设置为非阻塞，否则设置为阻塞。 # socket.setblocking(flag) # 如果value赋为 0，则套接字将处于非阻塞模式。如果指定为 None，则套接字将处于阻塞模式。 # socket.settimeout(value) # 阻塞 sock.setblocking(True) sock.settimeout(None) # 非阻塞 sock.setblocking(False) sock.settimeout(0.0) ``` ### UDP广播 发送给这一个局域网里面的每一个电脑的某一个端口发送一个数据 ````python if __name__ \"__main__\": s socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # 设置广播选项 s.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1) # 广播地址 dest_info ('<broadcast>', 11451) while True: data input(\"请输入要广播的内容：\") s.sendto(data.encode(), dest_info) ```` > 主机号是255的是广播地址 ## TCP通信 + 客户端 1. 建立套接字 2. 连接对方, connect 3. 发送数据, send 4. 接收数据, recv 5. 关闭套接字, close + 服务器 1. 建立TCP套接字 2. 绑定ip以及端口, bind 3. 等待连接, listen 4. 接收连接, accept 5. 发送接收数据, recv/send 6. 关闭连接close ```python import socket if __name__ \"__main__\": s socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 建立连接 s.connect((\"192.168.65.1\", 11451)) while True: data input(\"请输入要发送的数据:\") s.send(data.encode('gbk')) if data \"exit\": break s.close() print(\"连接已关闭\") ``` ### 函数 #### send发送 #### recv接收 ```python ret s.recv(1024) print(ret.decode('gbk')) ``` > 这时候获取的数据只有对方发送的数据 #### accept等待连接 ```python import socket if __name__ \"__main__\": s socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.bind((\"127.0.0.1\", 11451)) s.listen(5) print(\"服务器启动成功\") while True: client, addr s.accept() print(\"连接地址:\", addr) while True: data client.recv(1024) if data b\"exit\": break print(data.decode()) client.send(\"已收到\".encode()) client.close() print(\"连接已关闭\") ``` > 服务连接的时候需要等待客户端断开连接, 否则会出现错误, 四次挥手的TIME_WAIT阶段会由服务器进行, 这一个资源需要等待2msl > > 对方发送的数据是一个空字符串的时候, 这一个连接是中断了"},"/note/编程基础/python/进阶使用/网络编程/2024-8-20-04MQTT.html":{"title":"MQTT","content":" layout: post title: \"MQTT\" date: 2024 4 23 15:39:08 +0800 tags: python基础 # MQTT ## 安装 ```bash pip install paho mqtt ``` ```c import paho.mqtt.client as mqtt import time def on_connect(client, userdata, flag, rc): print(\"连接\") print(\"Connect result\" + str(rc)) def on_message(client, userdata, msg): print(\"消息内容\") print(msg.topic + \" \" + str(msg.payload)) def on_subscribe(client, userdata, mid, granted_qos): print(\"订阅\") print(\"On Subscribed: qos %d\" % granted_qos) # 取消订阅回调 def on_unsubscribe(client, userdata, mid, granted_qos): print(\"取消订阅\") print(\"On unSubscribed: qos %d\" % granted_qos) def on_publish(client, userdata, mid): print(\"发布消息\") print(\"On onPublish: qos %d\" % mid) def on_disconnect(client, userdata, rc): print(\"断开链接\") print(\"Unexpected disconnection rc \" + str(rc)) client mqtt.Client() client.on_connect on_connect client.on_message on_message client.on_publish on_publish client.on_disconnect on_disconnect client.on_unsubscribe on_unsubscribe client.on_subscribe on_subscribe client.connect('110.41.39.131', 1883, 600) # 600为keepalive的时间间隔 # client.subscribe('hello', qos 0) # client.loop_forever() # 保持连接 while True: client.publish(topic 'Z_topic', payload '{\"msg\": \"LED1open\"}', qos 0, retain False) time.sleep(20) ```"},"/note/编程基础/python/进阶使用/网络编程/2024-5-10-01网络编程.html":{"title":"网络编程","content":" layout: post title: \"网络编程\" date: 2024 4 23 15:39:08 +0800 tags: python基础 # 网络编程 ip地址: 逻辑上标记一台电脑, 这一个地址是不能重复的 在实际的使用传输数据的时候, 需要同时记录发送地址以及接收地址, 主要使用的是ipv4 ## ipv4 [关于ipv4和ipv6讲解最好的一篇文章 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/419689117) 因为网络规模有所不同，为了方便网络的管理，IP地址被分为 A,B,C,D,E，5类 ![image 20240510204357826](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405102043943.png) A、B、C 类地址称之为单点传送地址，只能分配给唯一的主机； E类地址则是在IP地址设计之初保留作为科学研究用的； ![image 20240510204631233](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405102046294.png) > 一般来说, 以192.168.14.60这一个ip为示例, 这是一个C类IP地址, 192.168.14是网络号, 60是主机号, 最多可以256个主机, 使用的时候使用掩码进行区分是哪一组 ### 私有ip 在网络里面国际规定有一部分的ip是用于局域网里面使用, 也就是说是私网ip, 不在公网里面使用 ``` 10.0.0.0 ~ 10.255.255.255 172.16.0.0 ~ 172.31.255.255 192.168.0.0 ~ 192.168.255.255 ``` ### 特殊的ip地址 `127.0.0.1 ~ 127.255.255.255`用于回路测试 `127.0.0.1`这一个ip地址代表本机的IP地址 ## 端口 标记一个进程 ### 知名端口 + 21: FTP端口 + 22: SSH端口 + 80: HTTP端口"},"/note/编程基础/python/进阶使用/网络编程/2024-5-12-03软件.html":{"title":"软件","content":" layout: post title: \"软件\" date: 2024 4 23 15:39:08 +0800 tags: python基础 # wrieshark抓包 可以使用这一个软件分析这一个电脑里面的所有的软件的网络信息 ## PacketTracer 可以用于模拟一个网络的全貌"},"/note/编程基础/python/进阶使用/C语言-Cpp接轨/2025-12-10-01-struct.html":{"title":"struct库","content":"# struct库 该模块作用是完成Python数值和C语言结构体的Python字符串形式间的转换。这可以用于处理存储在文件中或从网络连接中存储的二进制数据，以及其他数据源 `Struct`支持将数据packing(打包)成字符串，并能从字符串中逆向unpacking(解压)出数据。 格式字符 C 类型 Python 类型 字节数 `b` `signed char` `int` 1 `B` `unsigned char` `int` 1 `h` `short` `int` 2 `H` `unsigned short` `int` 2 `i` `int` `int` 4 `I` `unsigned int` `int` 4 `f` `float` `float` 4 `d` `double` `float` 8 字符 字节序 `@` 本机字节序（默认） ` ` 本机字节序，但强制使用标准大小 `<` 小端字节序 `>` 大端字节序 `!` 网络字节序（大端字节序） ## 打包 ```python import struct # 打包一个整数和一个浮点数 data struct.pack('>if', 123, 3.14) print(data) ``` ## 解包 ```python import struct data struct.pack('>if', 123, 3.14) num1, num2 struct.unpack('>if', data) print(num1, num2) ``` ## 其他 ```python # 计算结构体大小 struct.calcsize(format) ```"},"/note/编程基础/python/进阶使用/pyQT/2024-5-8-07线程.html":{"title":"线程","content":" layout: post title: \"线程\" date: 2023 9 23 15:39:08 +0800 tags: python基础 # 线程 如果某一个线程的后台操作代码需要大量的时间, 会使得这一个程序的执行的时候卡顿 这时候可以使用多线程使得界面的更新不会卡顿, 逻辑代码在另一个线程里面执行 ```python from PyQt5.QtCore import QThread class MyThread(QThread): def __init__(self): super().__init__() # 这一个函数是世纪汇执行的函数 def run(self): for i in range(10): print(\"登录中...\") time.sleep(1) # 调用这一个线程 # 创建的时候必须要有这一个self, 否则这一个函数执行结束的时候这一个线程会被销毁 # 这时候线程还没有结束, 会报错 self.my_thread MyThread() self.my_thread.start() ```"},"/note/编程基础/python/进阶使用/pyQT/2024-5-8-06QTDesigner.html":{"title":"QTDesigner","content":" layout: post title: \"QTDesigner\" date: 2023 9 23 15:39:08 +0800 tags: python基础 # QTDesigner 辅助的图形化界面 ![image 20240508183240778](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405081832937.png) 这一个界面的图形设置好以后进行保存 ![image 20240508183502338](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405081835383.png) ```python import sys from PyQt5.QtWidgets import * from PyQt5 import uic if __name__ '__main__': app QApplication(sys.argv) ui uic.loadUi(\"./2024 5 8 test.ui\") ui.show() app.exec() ``` > 使用这一个可以加载这一个ui"},"/note/编程基础/python/进阶使用/pyQT/2024-5-8-05信号与槽.html":{"title":"信号与槽","content":" layout: post title: \"信号与槽\" date: 2023 9 23 15:39:08 +0800 tags: python基础 # 信号与槽 信号是发生的事件, 槽是事件的处理, 使用槽进行捕获事件, 执行和槽绑定的函数 一般需要把信号和槽进行绑定 ```python 对象.信号.connect(槽函数) ``` 信号可以是Qt自带的, 也可以使我们发送的 ```python import sys from PyQt5.QtWidgets import * from PyQt5.QtCore import * class MyWindow(QMainWindow): def __init__(self): super().__init__() self.setupUI() def setupUI(self): self.setGeometry(800, 200, 300, 300) self.setWindowTitle(\"Signal and Slot\") btn QPushButton(\"Click me\", self) btn.move(10, 10) btn.clicked.connect(self.click_my_btn) def click_my_btn(self, arg): print(\"press btn\", arg) if __name__ '__main__': app QApplication(sys.argv) w MyWindow() w.show() app.exec() ``` ## 使用自己的信号 ```python import sys from PyQt5.QtWidgets import * from PyQt5.QtCore import * class MyWindow(QMainWindow): # 创建一个信号, 这一个信号只能 my_signal pyqtSignal(str) def __init__(self): super().__init__() self.init_ui() def init_ui(self): self.resize(300, 200) btn QPushButton(\"begin\", self) btn.setGeometry(10, 10, 100, 30) \t\t btn.clicked.connect(self.check) self.my_signal.connect(self.my_slot) def check(self): \"\"\" 发送一个信号 \"\"\" self.my_signal.emit(\"hello\") def my_slot(self, msg): \"\"\" 槽函数 \"\"\" print(msg) if __name__ '__main__': app QApplication(sys.argv) w MyWindow() w.show() app.exec() ```"},"/note/编程基础/python/进阶使用/pyQT/2024-5-6-02控件.html":{"title":"控件","content":" layout: post title: \"控件\" date: 2023 9 23 15:39:08 +0800 tags: python基础 # 控件 ## 控件 ### 按键 [PyQt5创建按钮和触发点击事件_pyqt5 clicked.connect csdn CSDN博客](https://blog.csdn.net/u011699626/article/details/113746434) [PyQt5 按钮控件使用 zyg_100 博客园 (cnblogs.com)](https://www.cnblogs.com/ygzhaof/p/10059540.html) ```python import sys from PyQt5.QtWidgets import QWidget, QApplication, QPushButton # 创建一个app对象, 参数是这一个程序运行的变量 app QApplication(sys.argv) btn QPushButton(\"按钮\") widget QWidget() widget.resize(640, 480) widget.setWindowTitle(\"Hello, PyQt5!\") # 把这一个按钮安装 btn.setParent(widget) widget.show() # 执行这一个app sys.exit(app.exec()) ``` ![image 20240506231508061](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405062315095.png) ### 文本Qlabel ```python label QLabel('你好', widget) # 设置位置x, y, w, h Geometry:几何图形 label.setGeometry(70, 70, 30, 30) ``` ![image 20240507085709229](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405070857262.png) ### 输入框QLineEdit ```python edit QLineEdit(widget) # 设置提示信息 edit.setPlaceholderText(\"请输入账号:\") edit.setGeometry(55, 20, 300, 20) ``` ![image 20240507090240476](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405070902507.png) ### 常用事件 ```python self.lineEdit.returnPressed.connect(self.send) ``` > 回车事件, 可以用于回车发送信息 ### 标题组框 [Qt之容器控件（QGroupBox） CSDN博客](https://blog.csdn.net/YinShiJiaW/article/details/104987842) QGroupBox小部件提供带有标题的组框[框架](https://so.csdn.net/so/search?q 框架&spm 1001.2101.3001.7020)。 一个组框提供一个框架，一个标题，一个快捷键，并在其内部显示其他各种小部件。键盘快捷键将键盘焦点移到组框的子窗口小部件之一。 A group box provides a frame, a title on top, a keyboard shortcut, and displays various other widgets inside itself. The keyboard shortcut moves keyboard focus to one of the group box's child widgets. QGroupBox doesn't automatically lay out the child widgets (which are often [QCheckBox](https://doc.qt.io/qt 6/qcheckbox.html)es or [QRadioButton](https://doc.qt.io/qt 6/qradiobutton.html)s but can be any widgets). 这一个不会自动有一个布局, 需要使用函数setLayout进行关联一个布局 ```python gender_box QGroupBox(\"性别\") h_layout QHBoxLayout() btn4 QRadioButton(\"男\") btn5 QRadioButton(\"女\") h_layout.addWidget(btn4) h_layout.addWidget(btn5) gender_box.setLayout(h_layout) ``` ## 常用控制函数 ### 设置位置 ```python # x, y, w, h edit.setGeometry(55, 20, 300, 20) ``` ### 设置标题 ```python widget.setWindowTitle(\"Hello, PyQt5!\") ``` ### 设置大小 ```python widget.resize(640, 480) ``` ### 设置窗口位置 ```python widget.move(640, 480) ``` ```python x center_point.x() y center_point.y() pos_x int(x widget.width()/2) pos_y int(y widget.height()/2) # print(x, y, pos_x, pos_y, widget.width()/2) widget.move(pos_x, pos_y) ``` > 获取中心点的位置 ### 获取窗口位置大小 ```python print(\"方法一\") print(\"widget.x() %d\" % widget.x()) # 250 （窗口横坐标） print(\"widget.y() %d\" % widget.y()) # 200 （窗口纵坐标） print(\"widget.width() %d\" % widget.width()) # 300（工作区宽度） print(\"widget.height() %d\" % widget.height()) # 240 （工作区高度） print(\"方法二\") # This property holds the geometry of the widget relative to its parent and excluding the window frame print(\"widget.geometry().x() %d\" % widget.geometry().x()) # 250 （工作区横坐标） print(\"widget.geometry().y() %d\" % widget.geometry().y()) # 222 （工作区纵坐标） print(\"widget.geometry().width() %d\" % widget.geometry().width() ) # 300（工作区宽度） print(\"widget.geometry().height() %d\" % widget.geometry().height()) # 240 （工作区高度） print(\"方法三\") # geometry of the widget relative to its parent including any window frame print(\"widget.frameGeometry().x() %d\" % widget.frameGeometry().x()) # 250 （窗口横坐标） print(\"widget.frameGeometry().y() %d\" % widget.frameGeometry().y()) # 200 （窗口纵坐标） print(\"widget.frameGeometry().width() %d\" % widget.frameGeometry().width() ) # 300（窗口宽度） print(\"widget.frameGeometry().height() %d\" % widget.frameGeometry().height()) # 262（窗口高度） print(\"widget.frameGeometry().getRect() %d\" % widget.frameGeometry().getRect()) # 获取一个元组 ``` > [【pyqt5】课时27.获取屏幕坐标系 获取窗口和工作区的尺寸（w,h）、坐标(x,y)_pyqt5获取窗口尺寸 CSDN博客](https://blog.csdn.net/zzx188891020/article/details/105940623) ### 设置图标 ```python widget.setWindowIcon(QIcon('favicon.png')) ``` ### 隐藏标题栏 ```python from PyQt5.QtCore import Qt widget.setWindowFlag(Qt.FramelessWindowHint) ```"},"/note/编程基础/python/进阶使用/pyQT/2024-5-7-04窗口.html":{"title":"窗口","content":" layout: post title: \"窗口\" date: 2023 9 23 15:39:08 +0800 tags: python基础 # 窗口 ## QWidget 控件和窗口的父类, 自由度高, 里面没有任何东西, 这一个是前面一直使用的那一个 ## QMainWindow QWidget的子类, 里面有状态栏, 菜单栏, 标题栏等 ```python import sys from PyQt5.QtWidgets import * from PyQt5.QtCore import * class MyWindow(QMainWindow): def __init__(self): super().__init__() self.setupUI() def setupUI(self): lable QLabel(\"Hello World\") # 标签文字居中 lable.setAlignment(Qt.AlignCenter) # 把这一个控件居中 self.setCentralWidget(lable) menu self.menuBar() menu_file menu.addMenu(\"File\") menu_edit menu.addMenu(\"Edit\") menu_view menu.addMenu(\"View\") # 添加菜单项 menu_file.addAction(\"New\") # 创建一个行为 save_action QAction(\"Save\", self) menu_file.addAction(save_action) # 添加分割线 menu_file.addSeparator() exit_action QAction(\"Exit\", self) exit_action.triggered.connect(qApp.quit) menu_file.addAction(exit_action) save_action.triggered.connect(self.save) def save(self): print(\"Save\") if __name__ '__main__': app QApplication(sys.argv) w MyWindow() w.show() app.exec() ``` ![image 20240507225620841](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405072256877.png) ## QDialog 对话框窗口 这一个一般使用弹窗的方式进行出现"},"/note/编程基础/python/进阶使用/pyQT/2024-5-11-08界面容器.html":{"title":"界面容器","content":" layout: post title: \"界面容器\" date: 2024 5 11 15:39:08 +0800 tags: python基础 # 界面容器 [Qt界面容器：Widget、 Frame、分组框、滚动区、工具箱、选项卡小部件、堆叠小部件控件精讲 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/688904469) ![image 20240511192203070](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405111922299.png) ## Frame边框容器 这一个是一个集成类QWidget类的类, 设置的时候可以有一个表框, 可以通过这一个设置 ![image 20240511192752567](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405111927594.png) ![](https://pic2.zhimg.com/v2 67ac72d8a03bf8434c4b0afefa3bea31_r.jpg) [QT QFrame控件使用详解 CSDN博客](https://blog.csdn.net/qq_37529913/article/details/132705090) ## GroupBox带标题 这一个带了一个标题, 可以选择是不是可选的 ![image 20240511194238500](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405111942534.png) ![image 20240511194245744](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405111942775.png) > 标题可以设置标题对齐模式, flat是边框的显示, checkable是这一个框是不是可选的 ### SrollArea滚轮区域 QScrollArea组件为一种控件容器，它的的作用是可以容纳更多的组件，如果组件过多会出现滚动条，滚动条会根据容器的大小与内部组件的大小变化。 ![image 20240511194952044](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405111949085.png) ```python import sys from PyQt5.QtWidgets import * from PyQt5.QtCore import * class MyWindow(QWidget): my_signal pyqtSignal(str) def __init__(self): super().__init__() self.setupUI() self.msg_history list() def setupUI(self): self.setGeometry(800, 200, 500, 200) self.setWindowTitle(\"Signal and Slot\") container QVBoxLayout() self.msg QLabel(\"\") self.msg.resize(400, 15) # 自动换行 self.msg.setWordWrap(True) # 设置对齐方式 self.msg.setAlignment(Qt.AlignTop) self.msg.setStyleSheet(\"border: 1px solid black;\") \t\t# 获取一个滚动条 scroll QScrollArea() scroll.setWidget(self.msg) # 设置滚动条的策略 scroll.setWidgetResizable(True) v_layout QVBoxLayout() v_layout.addWidget(scroll) h_layout QHBoxLayout() btn QPushButton(\"Click me\", self) btn.clicked.connect(self.click) h_layout.addStretch(1) h_layout.addWidget(btn) h_layout.addStretch(1) container.addLayout(v_layout) container.addLayout(h_layout) self.setLayout(container) self.my_signal.connect(self.my_slot) def click(self): self.my_signal.emit(\"Hello, World!\") def my_slot(self, msg): self.msg_history.append(msg) self.msg.setText(\"\\n\".join(self.msg_history)) if __name__ '__main__': app QApplication(sys.argv) w MyWindow() w.show() app.exec() ``` ## ToolBox 可以用于实现一种抽屉的感觉 ![image 20240511195427288](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405111954325.png) ![image 20240511195437143](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405111954181.png) ![image 20240511195718574](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405111957615.png) ## Tab Widget ![image 20240511195852863](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405111958900.png) ![image 20240511200222360](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405112002403.png) ![image 20240511200348990](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405112003024.png) ## Stacked Widget 可以有多个页 ![image 20240511223137451](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405112231505.png) ![image 20240511223207025](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405112232062.png) ![image 20240511223220286](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405112232324.png)"},"/note/编程基础/python/进阶使用/pyQT/2024-5-7-03布局.html":{"title":"布局","content":" layout: post title: \"布局\" date: 2023 9 23 15:39:08 +0800 tags: python基础 # 布局 主要有四类 + QBoxLayout + QGridLayout + QFromLayout + QStackedLayout ## QBoxLayout 盒子布局 一般使用的是他的两个子类QVBoxLayout(vertical垂直) QHBoxLayout(horizontal水平), 负责垂直以及水平布局 ```python from PyQt5.QtWidgets import QWidget, QApplication, QPushButton, QVBoxLayout import sys class MyWidget(QWidget): def __init__(self): super().__init__() self.resize(200, 300) self.setWindowTitle(\"hello world\") \t\t# 获取一个垂直布局器 layout QVBoxLayout() btn1 QPushButton('按钮1') layout.addWidget(btn1) btn2 QPushButton('按钮2') layout.addWidget(btn2) btn3 QPushButton('按钮3') layout.addWidget(btn3) \t\t# Strectch 伸展张开, 不加这个的话这三个按键平均分布 # 可以把这一个想象为一个弹簧, 这一个弹簧在最下面 # 这一个参数是比例关系 layout.addStretch(2) self.setLayout(layout) if __name__ '__main__': app QApplication(sys.argv) widget MyWidget() widget.show() app.exec() ``` ![image 20240507123204699](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405071232729.png) ```python from PyQt5.QtWidgets import * import sys class MyWidget(QWidget): def __init__(self): super().__init__() self.init_ui() def init_ui(self): container QVBoxLayout() # 第一个子框架 hobby_box QGroupBox(\"爱好\") v_layout QVBoxLayout() btn1 QRadioButton(\"抽烟\") btn2 QRadioButton(\"喝酒\") btn3 QRadioButton(\"打麻将\") v_layout.addWidget(btn1) v_layout.addWidget(btn2) v_layout.addWidget(btn3) \t\t# 给他设置一个布局 hobby_box.setLayout(v_layout) \t\t# 另一个框 gender_box QGroupBox(\"性别\") h_layout QHBoxLayout() btn4 QRadioButton(\"男\") btn5 QRadioButton(\"女\") h_layout.addWidget(btn4) h_layout.addWidget(btn5) gender_box.setLayout(h_layout) container.addWidget(hobby_box) container.addWidget(gender_box) self.setLayout(container) if __name__ '__main__': app QApplication(sys.argv) widget MyWidget() widget.show() app.exec() ``` ![image 20240507125821002](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405071258029.png) ### 函数 #### 添加组件 ```python layout.addWidget(btn3) ``` #### 添加弹簧 ```python # Strectch 伸展张开, 不加这个的话这三个按键平均分布 # 可以把这一个想象为一个弹簧, 这一个弹簧在最下面 # 这一个参数是比例关系 layout.addStretch(2) ``` ## QGridLayout [Qt学习之路14 布局管理器（QGridLayout）_qtwidgets.qgridlayout()setspacing(0) CSDN博客](https://blog.csdn.net/tqs_1220/article/details/81842878) 这一个是九宫格布局, 设置的时候需要给出行号以及列号 ```python from PyQt5.QtWidgets import * import sys class MyWidget(QWidget): def __init__(self): super().__init__() self.init_ui() def init_ui(self): self.setWindowTitle(\"计算器\") data { 0: [\"7\", \"8\", \"9\", \"+\", \"(\"], 1: [\"4\", \"5\", \"6\", \" \", \")\"], 2: [\"1\", \"2\", \"3\", \"*\", \"< \"], 3: [\"0\", \".\", \" \", \"/\", \"C\"] } \t\t# 总的布局 layout QVBoxLayout() \t\t# 文本框 edit QLineEdit() edit.setPlaceholderText(\"请输入\") layout.addWidget(edit) grid QGridLayout() for lint_number, line_data in data.items(): for col_number, number in enumerate(line_data): btn QPushButton(number) # 设置按键布局 grid.addWidget(btn, lint_number, col_number) layout.addLayout(grid) self.setLayout(layout) if __name__ '__main__': app QApplication(sys.argv) widget MyWidget() widget.show() app.exec() ``` ![image 20240507131700410](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405071317440.png) ## QFormLayout 适用于提交数据form表单, 比如登录, 注册之类的场景 QFormLayout是label field式的表单布局，其目标是提供表单方式的布局，主要由两列构成，第一列一般叫做label域，用于显示提示信息；第二列一般叫做field域，需要用户进行选择，输入，点击等交互操作。 QFormLayout常用方法： + addRow()： 添加一行，包括标签(label)和域(field) + insertRow()： 插入一行 + removeRow()： 移除一行 + setItem()： 在指定行，指定角色位置设置一个QLayoutItem项 + setWidget()： 在指定行，指定角色位置设置一个部件 + setLayout： 在指定行，指定角色位置设置一个布局 ```python import sys from PyQt5.QtWidgets import QLabel, QWidget, QApplication, QTextEdit, QLineEdit, QFormLayout \"\"\" 表单布局 QFormLayout \"\"\" class QFormLayoutDemo(QWidget): def __init__(self): super().__init__() self.setWindowTitle('表单布局') self.resize(600, 400) f_layout QFormLayout(self) title_label QLabel('标题') author_label QLabel('作者') content_label QLabel('内容') title_line QLineEdit() author_line QLineEdit() content_text QTextEdit() f_layout.addRow(title_label, title_line) # 添加行 f_layout.addRow(author_label, author_line) f_layout.addRow(content_label, content_text) if __name__ '__main__': app QApplication(sys.argv) w QFormLayoutDemo() w.show() app.exec() ``` ![image 20240507214102423](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405072141508.png) ## QStackedLayout 抽屉布局, 有不同的东西需要显示, 通过选择显示不同的页面, 在同一个位置进行显示"},"/note/编程基础/python/进阶使用/pyQT/2024-5-6-01介绍以及安装.html":{"title":"pyQt","content":" layout: post title: \"pyQt\" date: 2023 9 23 15:39:08 +0800 tags: python基础 # pyQt编译以及安装 Qt是一个C++的库, 这一个适用于开发GUI程序的, 由于开源社区的存在, 这一个可以使用python进行开发 这一个是一个跨平台的程序, 支持Windows, Linux, Unix, IOS, Android, 嵌入式等 pyQt是C++写的, 使用python进行调用的程序, 使用GPL协议 还有一个PySide2也是一个使用python进行图形化开发的库, 但是使用的数量不如pyQt ```bash pip install PyQt5 i https://pypi.tuna.tsinghua.edu.cn/simple pip install PyQt5 tools i https://pypi.tuna.tsinghua.edu.cn/simple ``` > 安装PyQt5 tools之后可以使用![image 20240506225939527](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405062259636.png) > > 这一个进行图形化开发 ```python from PyQt5 import QtWidgets from PyQt5.QtCore import * print(QT_VERSION_STR) ``` > 测试 ```python import sys from PyQt5.QtWidgets import QWidget, QApplication # 创建一个app对象, 参数是这一个程序运行的变量 app QApplication(sys.argv) widget QWidget() widget.resize(640, 480) widget.setWindowTitle(\"Hello, PyQt5!\") widget.show() # 执行这一个app sys.exit(app.exec()) ``` ## 基础模块 + QtCore: 核心的非GUI的功能, 主要是时间, 文件文件夹, 各种数据, 流, URLs, mine类文件, 进程和线程使用 + QtGui: 窗口系统, 事件处理, 2D图像, 基本绘图, 字体文字类 + QtWidget: 插件, 应用UI元素 ```python import sys from PyQt5.QtWidgets import * from PyQt5.QtCore import * class Window1(QWidget): def __init__(self): super().__init__() QLabel(\"抽屉1\", self) self.setStyleSheet(\"background color:red;\") class Window2(QWidget): def __init__(self): super().__init__() QLabel(\"抽屉2\", self) self.setStyleSheet(\"background color:green;\") class MyWindow(QWidget): def __init__(self): super().__init__() self.create_stacked_layout() self.init_ui() def create_stacked_layout(self): self.stacked_layout QStackedLayout() win1 Window1() win2 Window2() self.stacked_layout.addWidget(win1) self.stacked_layout.addWidget(win2) def init_ui(self): self.setFixedSize(300, 270) container QVBoxLayout() widget QWidget() # 添加一个抽屉布局器 widget.setLayout(self.stacked_layout) widget.setStyleSheet(\"background color:grey;\") # 这一个样式是CSS的样式 # 两个按钮 btn_press1 QPushButton(\"1\") btn_press2 QPushButton(\"2\") \t # 设置按键的功能 btn_press1.clicked.connect(self.btn_press1_clicked) btn_press2.clicked.connect(self.btn_press2_clicked) # 显示空间添加组件 container.addWidget(widget) container.addWidget(btn_press1) container.addWidget(btn_press2) self.setLayout(container) def btn_press1_clicked(self): self.stacked_layout.setCurrentIndex(0) def btn_press2_clicked(self): self.stacked_layout.setCurrentIndex(1) if __name__ '__main__': app QApplication(sys.argv) w MyWindow() w.show() app.exec() ``` ## Vscode设置 [在Visual Studio Code中使用PyQt5开发python GUI应用程序 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/679467681) ### ui文件转py ![image 20240508210545788](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405082105978.png) ```python # * coding: utf 8 * # Form implementation generated from reading ui file 'e:\\JHY\\python\\2024 5 6 pyQt\\2024 5 8 test2.ui' # # Created by: PyQt5 UI code generator 5.15.10 # # WARNING: Any manual changes made to this file will be lost when pyuic5 is # run again. Do not edit this file unless you know what you are doing. import sys from PyQt5 import QtCore, QtGui, QtWidgets from PyQt5.QtWidgets import * class Ui_Form(object): def setupUi(self, Form): Form.setObjectName(\"Form\") Form.resize(596, 198) self.formLayoutWidget QtWidgets.QWidget(Form) self.formLayoutWidget.setGeometry(QtCore.QRect(40, 30, 251, 61)) self.formLayoutWidget.setObjectName(\"formLayoutWidget\") self.formLayout QtWidgets.QFormLayout(self.formLayoutWidget) self.formLayout.setContentsMargins(0, 0, 0, 0) self.formLayout.setObjectName(\"formLayout\") self.label QtWidgets.QLabel(self.formLayoutWidget) self.label.setObjectName(\"label\") self.formLayout.setWidget(0, QtWidgets.QFormLayout.LabelRole, self.label) self.label_2 QtWidgets.QLabel(self.formLayoutWidget) self.label_2.setObjectName(\"label_2\") self.formLayout.setWidget(1, QtWidgets.QFormLayout.LabelRole, self.label_2) self.lineEdit QtWidgets.QLineEdit(self.formLayoutWidget) self.lineEdit.setObjectName(\"lineEdit\") self.formLayout.setWidget(0, QtWidgets.QFormLayout.FieldRole, self.lineEdit) self.lineEdit_2 QtWidgets.QLineEdit(self.formLayoutWidget) self.lineEdit_2.setObjectName(\"lineEdit_2\") self.formLayout.setWidget(1, QtWidgets.QFormLayout.FieldRole, self.lineEdit_2) self.textBrowser QtWidgets.QTextBrowser(Form) self.textBrowser.setGeometry(QtCore.QRect(320, 20, 256, 151)) self.textBrowser.setObjectName(\"textBrowser\") self.horizontalLayoutWidget QtWidgets.QWidget(Form) self.horizontalLayoutWidget.setGeometry(QtCore.QRect(90, 110, 201, 41)) self.horizontalLayoutWidget.setObjectName(\"horizontalLayoutWidget\") self.horizontalLayout QtWidgets.QHBoxLayout(self.horizontalLayoutWidget) self.horizontalLayout.setContentsMargins(0, 0, 0, 0) self.horizontalLayout.setObjectName(\"horizontalLayout\") self.pushButton_2 QtWidgets.QPushButton(self.horizontalLayoutWidget) self.pushButton_2.setObjectName(\"pushButton_2\") self.horizontalLayout.addWidget(self.pushButton_2) self.pushButton QtWidgets.QPushButton(self.horizontalLayoutWidget) self.pushButton.setObjectName(\"pushButton\") self.horizontalLayout.addWidget(self.pushButton) self.retranslateUi(Form) self.pushButton_2.clicked.connect(self.textBrowser.hide) # type: ignore QtCore.QMetaObject.connectSlotsByName(Form) def retranslateUi(self, Form): _translate QtCore.QCoreApplication.translate Form.setWindowTitle(_translate(\"Form\", \"Form\")) self.label.setText(_translate(\"Form\", \"用户名\")) self.label_2.setText(_translate(\"Form\", \"密码\")) self.pushButton_2.setText(_translate(\"Form\", \"登录\")) self.pushButton.setText(_translate(\"Form\", \"忘记密码\")) if __name__ '__main__': app QApplication(sys.argv) MainWindow QWidget() ui Ui_Form() # ui GUI的py文件名.类名 ui.setupUi(MainWindow)\t# 设置一个显示的窗口 MainWindow.show() sys.exit(app.exec_()) ``` ```python from PyQt5 import uic import UItest2 as UI class MyWindow(UI.Ui_Form, QMainWindow): def __init__(self): super().__init__() self.setupUi(self) self.retranslateUi(self) if __name__ '__main__': app QApplication(sys.argv) w MyWindow() w.show() app.exec() ```"},"/note/编程基础/python/进阶使用/线程/2025-2-20-async.html":{"title":"async","content":"# async 使用asyncio库实现, 通过协程函数, 这是一个可以停止运行以及恢复运行的函数, 使用`async def`进行定义 使用这个方式进行定义的函数执行返回的是一个coutine object协程对象, 实际运行的时候是执行这个对象, 这个函数在运行的而时候如果遇到一个await标志会进行暂停运行, 让出执行权限, 等待await之后完成以后继续执行 事件循环: 有实际控制权, 主要做三个事情 + 检查是不是有可以执行的任务 + 让出控制, 把控制权给可移执行的协程 + 等待 实际的协程被任务进行封装, 记录协程的各种状态 实际使用的时候有三个步骤 1. 定义协程函数 2. 包装为任务 3. 建立事件循环 > 在实际使用的时候把await后面的函数换为协程函数如`sleep` > `asyncio.sleep`, 他会把后面的协程包装为一个任务 ```python import asyncio import time async def fetch_url(url): print(f\"fetching {url}\") await asyncio.sleep(1) print(f\"fetched {url}\") return url async def read_file(file): print(f\"reading {file}\") await asyncio.sleep(1) print(f\"read {file}\") return file async def main(): url \"https://www.google.com\" file \"test.txt\" task1 asyncio.create_task(fetch_url(url)) task2 asyncio.create_task(read_file(file)) fetch_result await task1 read_result await task2 if __name__ \"__main__\": start_time time.time() asyncio.run( main() ) print(f\"Time taken: {time.time() start_time}\") ``` ## 自动控制 ```python async def main(): url \"https://www.google.com\" file \"test.txt\" result await asyncio.gather(fetch_url(url), read_file(file)) ``` > 实际的结果和传入的顺序是一样的, 列表的形式返回, 所有的结束以后返回 ```python async def main(): url \"https://www.google.com\" file \"test.txt\" result asyncio.as_completed([fetch_url(url), read_file(file)]) for coro in result: print(await coro) ``` > 返回一个迭代器, 按照返回的顺序进行处理 也可以使用task ## 实际应用 实际的应用需要配合基于asyncio的库, 比aiohttp, aiofiles 使用不是一个基于async的函数可以使用`asyncio.to_thread(函数名, 参数)`把他变为线程从而不阻塞, 这个返回可以当做协程使用"},"/note/编程基础/python/进阶使用/线程/2024-5-10-01多任务.html":{"title":"多任务","content":" layout: post title: \"多任务\" date: 2024 5 14 15:39:08 +0800 tags: python基础 # 多线程 多任务:同时可以运行多个任务 一个程序可以同时执行多个事件, 就是一个多任务的程序, 实际是程序之间的快速轮转 ````python from time import sleep import threading def sing(): for i in range(5): print(\"Singing...\") sleep(1) def dance(): for i in range(5): print(\"Dancing...\") sleep(1) if __name__ \"__main__\": t1 threading.Thread(target sing) t2 threading.Thread(target dance) t1.start() # start the thread t2.start() t1.join() # wait for the thread to finish t2.join() print(\"Main thread is over.\") ```` > 并发: 假的多任务, 快速切换实现 > > 并行: 真的多任务 python里面有一个thread模块, 但是比较底层, 建议使用threading的封装 ## threading使用 ### 基础使用 ```python t1 threading.Thread(target dance) # 获取一个线程, 这一个线程执行dance这一个函数 t1.start() # start the thread ``` > 可以使用Thread这一个类创建一个线程, 创建以后不会立即执行, 需要使用start进行启动, 这一个线程会使用创建的时候target参数指定的执行的代码 > > 主线程的代码结束以后不会立即结束, 而是会等待子线程的结束, 为了回收垃圾, 子线程执行完以后则会直接结束 ### 获取线程数量 ```python print(threading.enumerate()) ``` > ```bash > [<_MainThread(MainThread, started 16076)>, <Thread(Thread 1 (dance), started 104)>, <Thread(Thread 2 (dance), started > 35924)>, <Thread(Thread 3 (dance), started 5528)>, <Thread(Thread 4 (dance), started 11448)>, <Thread(Thread 5 (dance), started > 33788)>] > ``` > > 获取一个列表, 这一个列表里面有现在的线程 ### 传递参数 ```python t threading.Thread(target dance, args (\"John\", i + 18)) ``` > 这一个args是一个元组, 这一个元组会被拆包传递给这一个函数 还可以通过字典的方式进行传递参数 ```python t threading.Thread(target dance, kwargs {\"name\": \"Alice\", \"age\": i+18}) ``` ### 继承的方式创建 ```python from time import sleep import threading class MyThread(threading.Thread): def __init__(self, name): threading.Thread.__init__(self) self.name name def run(self): print(f\"Thread {self.name} started\") sleep(2) print(f\"Thread {self.name} finished\") if __name__ \"__main__\": threads [] for i in range(3): thread MyThread(name f\"Thread {i}\") threads.append(thread) thread.start() for thread in threads: thread.join() print(\"Main thread finished\") ``` > 在调用start函数以后会执行这一个类里面的run方法 > > 这一个类结束的时候会调用`__del__`可以在这一个类里面处理需要关闭的信息等 ## 互斥锁 使用全局变量的时候需要使用互斥锁进行保护 ```python mutex threading.Lock() mutex.acquire() mutex.release() ``` > 这一个是不可以重入的锁 > > ```python > acquire(blocking True, timeout 1) # 时间是按秒计算的 > ``` ```python mutex threading.RLock() ``` > 这一个锁是可以重入的 ## 栅栏对象 在所有的线程都调用with以后这一个线程才会被允许继续进行 ```python b Barrier(2, timeout 5) # 两个, 5秒以后超时 def server(): start_server() b.wait() while True: connection accept_connection() process_server_connection(connection) def client(): b.wait() while True: connection make_connection() process_client_connection(connection) ``` # 多进程 ```python import multiprocessing as mp import time def test(): \"\"\"This function will be run by a separate process\"\"\" while True: print(\"Hello from the child process\") time.sleep(1) if __name__ \"__main__\": # Create a new process p mp.Process(target test) # Start the process p.start() while True: print(\"Hello from the main process\") time.sleep(1) ``` ```python import multiprocessing as mp import time class MyProcess(mp.Process): def __init__(self, name): super().__init__() self.name name def run(self): while True: print(f\"Process {self.name} is running\") time.sleep(1) print(f\"Process {self.name} is done\") if __name__ \"__main__\": p1 MyProcess(\"p1\") p2 MyProcess(\"p2\") p1.start() p2.start() ``` > 可以使用以上的两种方法实现一个进程 ## 参数传递 ```python def test(name, age, m): pass mp.Process(target test, args (\"jiao\", 21), kwargs {\"m\", 20}) ``` ## 变量 进程里面的全局变量是不共享的 ## 进程间通信IPC 可以使用文件, 管道, 共享内存之类的方式实现 python里面可以使用队列进行通信 ### 基础使用 ```python import multiprocessing import time q multiprocessing.Queue(3) # 3 is the maximum number of items that can be stored in the queue q.put(1) q.put(2) print(q.full()) # False q.put(3) print(q.full()) # True try: q.put(4, timeout 1) # This will raise a Full exception except: print('The queue is full! now we have %d items in the queue' % q.qsize()) try: q.put_nowait(4) # This will raise a Full exception except: print('The queue is full! now we have %d items in the queue' % q.qsize()) try: q.put(4, block False) # This will raise a Full exception except: print('The queue is full! now we have %d items in the queue' % q.qsize()) if not q.empty(): for i in range(q.qsize()): print(q.get()) \t# 这一个函数也有timeout参数以及nowait函数 ``` > ```bash > PS E:\\JHY\\python\\2024 5 10 multithread> python u \"e:\\JHY\\python\\2024 5 10 multithread\\main.py\" > False > True > The queue is full! now we have 3 items in the queue > The queue is full! now we have 3 items in the queue > The queue is full! now we have 3 items in the queue > 1 > 2 > 3 > ``` ### 进程间通信 ```python from multiprocessing import Process, Queue import time import random def task1(q): for value in ['a', 'b', 'c', 'd', 'e']: print(\"Task1 is putting value: \", value) time.sleep(random.random()) q.put(value) def task2(q): while True: if not q.empty(): value q.get() print(\"task2 is get value: \", value) time.sleep(random.random()) if __name__ '__main__': q Queue() p1 Process(target task1, args (q,)) p2 Process(target task2, args (q,)) p1.start() p2.start() p1.join() p2.join() print(\"Done\") ``` ## 进程池 方式开启的进程的数量过多的时候会导致开启的进程的数量过多导致大量的资源浪费在切换任务 ```python from multiprocessing import Pool import time import os import random def worker(num): for i in range(5): print(f'pid %d, num %d' % (os.getpid(), num)) time.sleep(random.random()) if __name__ '__main__': p Pool(3) for i in range(10): p.apply_async(worker, args (i,)) # 添加任务 p.close()\t# 以后不会添加任务 p.join()\t# 所有的子进程结束以后开启主进程, 这一个前面必须close, 否则报错 print('All done') ``` > ```python > apply_async(func[, args[, kwds[, callback[, error_callback]]]]) > ``` > > 如果指定了 *callback* , 它必须是一个接受单个参数的可调用对象。当执行成功时， *callback* 会被用于处理执行后的返回结果，否则，调用 *error_callback* 。会将抛出的异常对象作为参数传递给 *error_callback* 执行。 ### 通信 在使用进程池的时候通信不能使用之前的那一队列了, 要使用multiprocessing模块里面的`Manager`创建一个对象, 使用这个对象的Queue方法创建一个新的队列 ```python from multiprocessing import Manager, Pool from time import sleep def reader(q): print('Reader waiting') for i in range(q.qsize()): print('Read from queue:', q.get()) def writer(q): print('Writer waiting') for i in \"Hello World\": q.put(i) if __name__ '__main__': q Manager().Queue() po Pool() po.apply_async(writer, (q,)) sleep(1) po.apply_async(reader, (q,)) po.close() po.join() print('Main process end') ``` ### 常用的函数 ### apply/apply_async 这两个函数的参数不同 ```pyhon apply(func[, args[, kwds]]) apply_async(func[, args[, kwds[, callback[, error_callback]]]]) ``` > 第一个函数会等待传入的函数的结束返回结果, 第二个不会, apply_async方法返回一个AsyncResult对象。可以通过AsyncResult对象的get()方法获取函数的返回值。 # 协程 另一个实现多任务的额方式, 使用的执行单元比线程还要小 可以理解为在一个线程里面开多任务, 线程里面的某一个函数在一个地方记录自己的信息, 之后切换到另一个函数里面执行, 切换的次数以及时间是开发者自己决定的 > 线程和协程都是处理并发的方法，但是它们之间有一些重要的区别： > > 1. 调度方式：线程是由操作系统进行调度，通过时间片轮转或者优先级调度来分配CPU资源。而协程是由代码自己进行调度，通过yield、await等关键字来主动释放CPU资源。 > > 2. 内存消耗：每个线程都需要独立的堆栈和上下文切换开销，因此创建大量线程会消耗大量内存。而协程在一个线程内执行，并且共享线程的堆栈，因此创建大量协程的内存消耗较小。 > > 3. 并发能力：线程能够利用多核处理器并行执行，因为每个线程都有自己的CPU核心。而协程在单个线程上执行，因此无法利用多核处理器进行并行操作。但是使用协程可以避免线程之间的上下文切换开销，从而提高并发性能。 > > 4. 错误处理：由于线程是由操作系统调度的，因此当一个线程出现异常时，整个进程可能会崩溃。而协程是由代码自己调度的，可以在代码中捕获和处理异常，从而提高程序的健壮性。 > > 综上所述，线程适合于CPU密集型任务，并且需要并行执行时，而协程适合于IO密集型任务，并且需要高并发能力时。因此在实际开发中，可以根据具体的需求选择合适的并发处理方式。 ```python import time def work1(): while True: print('work1') yield time.sleep(1) def work2(): while True: print('work2') yield time.sleep(1) def main(): w1 work1() w2 work2() while True: next(w1) next(w2) if __name__ '__main__': main() ``` > 可以使用这一个方式实现多任务类似的形式 ## 使用greenlet实现 ```python from greenlet import greenlet import time def test1(): while True: print(\" A \") gr2.switch() time.sleep(0.5) def test2(): while True: print(\" B \") gr1.switch() time.sleep(0.5) gr1 greenlet(test1) gr2 greenlet(test2) gr1.switch() ``` ## 使用gevent 在网络里面IO一般会使用比较长的时间, 可以使用gevent库实现自动切换 这一个库可以在遇到IO(文件, 网络)的时候自动进行切换其他的gevent ```python import gevent def f(n): for i in range(n): print(gevent.getcurrent(), i) gevent.sleep(0) g1 gevent.spawn(f, 5) g2 gevent.spawn(f, 5) g3 gevent.spawn(f, 5) g1.join() # 这是一个耗时操作, 所以会开始执行协程 g2.join() g3.join() ``` > ```bash > PS E:\\JHY\\python\\2024 5 10 multithread> python u \"e:\\JHY\\python\\2024 5 10 multithread\\main.py\" > <Greenlet at 0x1e10a9f4b80: f(5)> 0 > <Greenlet at 0x1e10c5944a0: f(5)> 0 > <Greenlet at 0x1e10c594540: f(5)> 0 > <Greenlet at 0x1e10a9f4b80: f(5)> 1 > <Greenlet at 0x1e10c5944a0: f(5)> 1 > <Greenlet at 0x1e10c594540: f(5)> 1 > <Greenlet at 0x1e10a9f4b80: f(5)> 2 > <Greenlet at 0x1e10c5944a0: f(5)> 2 > <Greenlet at 0x1e10c594540: f(5)> 2 > <Greenlet at 0x1e10a9f4b80: f(5)> 3 > <Greenlet at 0x1e10c5944a0: f(5)> 3 > <Greenlet at 0x1e10c594540: f(5)> 3 > <Greenlet at 0x1e10a9f4b80: f(5)> 4 > <Greenlet at 0x1e10c5944a0: f(5)> 4 > <Greenlet at 0x1e10c594540: f(5)> 4 > ``` > > 在使用这一个库的时候需要使用这一个库里面的函数才可以进行切换, 但是这样不方便 ### 修饰其他IO函数 ```python from gevent import monkey # 有耗时操作时需要打补丁 monkey.patch_all() ``` > Make the standard library cooperative. ### 回收 ```python import gevent import time from gevent import monkey # 有耗时操作时需要打补丁 monkey.patch_all() def f(n): for i in range(n): print(gevent.getcurrent(), i) time.sleep(1) gevent.joinall([ gevent.spawn(f, 5), gevent.spawn(f, 5), gevent.spawn(f, 5), ]) ``` # 选择 + 计算密集型 多进程: 使用多个核进行计算 + IO密集型 多线程或者协程"},"/note/编程基础/python/进阶使用/线程/2024-5-14-02队列.html":{"title":"队列","content":" layout: post title: \"队列\" date: 2024 5 14 15:39:08 +0800 tags: python基础 # 队列 有三种队列, FIFO, LIFO, 以及优先级队列 ## FIFO ```python import queue q queue.Queue() q.put(1) q.put(\"2\") q.put({'num': 3}) print(q.get()) print(q.get()) print(q.get()) ``` > ```bash > PS E:\\JHY\\python\\2024 5 10 multithread> python u \"e:\\JHY\\python\\2024 5 10 multithread\\main.py\" > 1 > 2 > {'num': 3} > ``` > > 在获取数据但是没有数据的时候会阻塞进行获取 ### 使用实例udp聊天室 ```python import threading import socket import queue def recv_data(udp_socket, q): while True: # 接收数据 recv_data udp_socket.recvfrom(1024) # 将接收到的数据放入队列中 q.put(recv_data) print(recv_data) def send_data(udp_socket, q): while True: # 发送数据 send_data input(\"请输入要发送的数据：\") # 获取接收方的ip和端口 ip input(\"请输入接收方的ip：\") port int(input(\"请输入接收方的端口：\")) udp_socket.sendto(send_data.encode(\"utf 8\"), (ip, port)) def save_data(q): while True: recv_data q.get() with open(\"recv_data.txt\", \"a\") as f: f.write(str(recv_data) + \"\\n\") def main(): # 获取一个udp的socket对象 udp_socket socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # 绑定端口 udp_socket.bind((\"\", 7788)) # 创建一个队列 q queue.Queue() # 创建一个线程 t1 threading.Thread(target recv_data, args (udp_socket, q)) t2 threading.Thread(target send_data, args (udp_socket, q)) t1.start() t2.start() t3 threading.Thread(target save_data, args (q,)) t3.start() if __name__ '__main__': main() ``` ## LIFO ```python import queue q queue.LifoQueue() q.put(1) q.put('2') q.put({'a': 1, 'b': 2}) print(q.get()) print(q.get()) print(q.get()) ``` > ```bash > PS E:\\JHY\\python\\2024 5 10 multithread> python u \"e:\\JHY\\python\\2024 5 10 multithread\\main.py\" > {'a': 1, 'b': 2} > 2 > 1 > ``` ## 优先级队列 ```python import queue q queue.PriorityQueue() q.put((2, 'code')) q.put((1, 'eat')) q.put((3, 'sleep')) while not q.empty(): next_item q.get() print(next_item) ``` > ```bash > PS E:\\JHY\\python\\2024 5 10 multithread> python u \"e:\\JHY\\python\\2024 5 10 multithread\\main.py\" > (1, 'eat') > (2, 'code') > (3, 'sleep') > ``` > > 传入的参数是一个元组, 第一个数字代表优先级, 数字越小优先级越高"},"/note/编程基础/cpp/2025-1-6-03模板和STL.html":{"title":"模板","content":"# 模板 泛型编程的编程思想, 主要使用的就是模板 模板的语法是建立一个通用的函数, 函数的参数以及返回值可以不具体定制, 使用一个虚拟的类表示 ```c++ template<typename T> 函数声明或定义 ``` template是声明建立模板, typename是一个数据类型可以使用class代替, T是通用的数据类型, 名字可以替换 ```c++ template <typename T> // T是一个模板参数 void swap(T &a, T &b){ T temp a; a b; b temp; } ``` > 在实际使用的时候可以自动的对数据类型进行推算, 也可以显式指定 > > ```c++ > int a 10; > int b 20; > Swap(a, b); > cout << \"a \" << a << \", b \" << b << endl; > Swap<int>(a, b); > cout << \"a \" << a << \", b \" << b << endl; > ``` **注: **在使用的时候模板是在推导出来一致的数据类型的时候才可以使用, T是确定的 普通的函数可以在使用的时候发生隐式的类型转换, 使用函数模板的时候不可以 ## 重载 这一个模板和普通的函数是可以发生重载的, 两个都可以调用的时候, 优先使用模板, 可以使用空的模板参数列表强制使用函数模板, 函数的模板可以重载, 模板更好匹配的时候使用模板 ```c++ void myPrint(int a, int b){ cout << \"function\" << endl; cout << a << \" \" << b << endl; } template <class T> void myPrint(T a, T b){ cout << \"template\" << endl; cout << a << \" \" << b << endl; } int main(void){ int a 10; int b 20; myPrint(a, b); //使用函数 myPrint<>(a, b); //使用模板 return 0; } ``` ## 局限 有的模板的操作不可以适配所有的类, 所以可以使用对具体的类使用具体化的模板, 比如一个自定义的Person类不可以使用` `进行比较 ```c++ template <class T> bool Compare(T a, T b){ if(a b){ return true; }else{ return false; } } class Person{ public: string name; int age; Person(string name, int age){ this >name name; this >age age; } }; template <>bool Compare(Person a, Person b){ if(a.name b.name && a.age b.age){ return true; }else{ return false; } } int main(void){ cout << Compare(1, 1) << endl; cout << Compare(Person(\"Tom\", 10), Person(\"Tom\", 10)) << endl; return 0; } ``` ## 类模版 ```c++ template<typename T> 类 ``` ```c++ template <typename NameType, typename AgeType int> class Person{ public: Person(NameType name, AgeType age): name(name), age(age){} bool operator (const Person &p) const{ return name p.name && age p.age; } private: NameType name; AgeType age; }; int main(void){ Person<string, int> p1(\"Tom\", 20); Person<string, int> p2(\"Tom\", 20); if(p1 p2){ cout << \"p1 p2\" << endl; return 0; } ``` > 核函数模板的区别, 类模板不会自动推测类型, 在类模板里面可以有默认参数 类模板的成员函数是在调用的时候创建的(在编译的时候不会检测这一个对象是不是可以使用对应的操作) ### 作为函数参数 使用一个类模板做函数的参数有三种方法 1. 指定传入的参数的类型 2. 参数模板化 3. 整个类模板化 ```c++ template <typename NameType, typename AgeType int> class Person{ public: Person(NameType name, AgeType age): name(name), age(age){} bool operator (const Person &p) const{ return name p.name && age p.age; } void show() const{//const成员函数不能修改成员变量 cout << \"Name: \" << name << \", Age: \" << age << endl; } private: NameType name; AgeType age; }; void printPerson1(const Person<string, int> &p){ p.show(); } template <typename NameType, typename AgeType int> void printPerson2(const Person<NameType, AgeType> &p){ p.show(); } template<class T> void printPerson3(const T &p){ p.show(); } int main(void){ Person<string> p1(\"Tom\", 20); printPerson1(p1); printPerson2(p1); printPerson3(p1); return 0; } ``` ### 继承 子类继承的父类是一个类模板的时候, 需要指出来父类的数据类型, 或者再使用模板, 但是在实际实现的时候还是需要指定使用的类型 ### 类外实现 ```c++ template<class T1, class T2> Person<T1, T2>::Person(T1 name, T2 name){ ... } ``` # STL标准模版库 使用容器, 算法以及迭代器, 容器以及算法之间通过迭代器进行连接 六大组件 1. 容器, 各种数据结构 2. 算法 3. 迭代器: 容器算法之间的融合 4. 仿函数: 行为类似的函数, 可以作为算法的某种策略 5. 适配器: 修饰容器或者仿函数或迭代器接口的东西 6. 空间适配器: 空间配置与管理 ![image 20250107223746766](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202501072237892.png) ## vector数组 容器`vector` 算法`for_each` 迭代器`vector<int>::iterator` > 在C++中，对于std::vector来说，插入和删除元素可能会导致迭代器失效，具体取决于操作的位置和方式。 > > 1. 如果在vector中插入或删除元素导致重新分配内存，即超出当前容量，迭代器就会失效。因为重新分配后，迭代器指向的位置可能已经不再是之前的位置了。 > 2. 如果在vector中插入或删除元素后，并且在进行其他操作之前没有重新分配内存，大部分迭代器仍然有效。但是，如果插入或删除的元素的位置在迭代器之前的话，迭代器可能会失效。 > > 因此，在进行插入和删除操作时，如果涉及到迭代器的使用，需要慎重考虑可能导致迭代器失效的情况，并在必要时更新迭代器。 是一个可以存放所有数据的一个数组, 会进行动态扩展 ```c++ int main(void){ vector<int> v; v.push_back(10); v.push_back(20); v.push_back(30); vector<int>::iterator itBegin v.begin(); vector<int>::iterator itEnd v.end(); for(vector<int>::iterator it itBegin; it ! itEnd; it++){ cout << *it << endl; } return 0; } ``` ```c++ void myPrint(int val){ cout << val << endl; } for_each(itBegin, itEnd, myPrint); ``` ### 构造 ```c++ vector<T> v; //采用模板实现类实现，默认构造函数 vector<int> v1; vector(v.begin(), v.end()); //将v[begin(), end())前闭后开区间中的元素拷贝给本身。vector<int> v2(v1.begin(), v1.end()); vector(n, elem); //构造函数将n个elem拷贝给本身。vector<int> v3(10, 100); vector(const vector &vec); //拷贝构造函数。vector<int> v4(v3); ``` ### 赋值 通过重载 或assign成员函数 ```c++ vector& operator (const vector &vec);//重载等号操作符 v2 v1; assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。v3.assign(v1.begin(), v1.end()); assign(n, elem); //将n个elem拷贝赋值给本身。v4.assign(10, 100); ``` ### 容量和大小 ```c++ empty(); //判断容器是否为空 v1.empty() capacity(); //容器的容量v1.capacity() size(); //返回容器中实际元素的个数 size一定<capacity resize(int num); //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。改变的是实际的元素的个数, 不是容量大小 resize(int num, elem); //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。 ``` resize函数中如果容器变短，则末尾超出容器长度的元素被删除 ### vector插入和删除 ```c++ push_back(ele); //尾部插入元素ele v1.push_back(1); pop_back(); //删除最后一个元素 v1.pop_back(); insert(const_iterator pos, ele); //迭代器指向位置pos插入元素ele v1.insert(v1.begin(), 100); insert(const_iterator pos, int count,ele);//迭代器指向位置pos插入count个元素elev1.insert(v1.begin(), 2, 1000); erase(const_iterator pos); //删除迭代器指向的元素v1.erase(v1.begin()); erase(const_iterator start, const_iterator end);//删除迭代器从start到end之间的元素v1.erase(v1.begin(), v1.end()); clear(); //删除容器中所有元素v1.clear(); ``` ### 数据存取 访问 除了迭代器可以访问所有元素外，还有一下几种访问元素的方式 ```c++ at(int idx); //返回索引idx所指的数据 v1.at(i) operator[]; //返回索引idx所指的数据 v1[i] front(); //返回容器中第一个数据元素 v1.front() back(); //返回容器中最后一个数据元素v1.back() ``` ### vector互换容器 ```c++ swap(vec);//成员函数实现两个容器内元素进行互换 v1.swap(v2); ``` 使用swap函数可以实现收缩函数的空间, 数据量比较大的时候这一个容器也会扩容的很厉害, 这时候使用resize进行改变的时候, 实际的容量大小不会改变, 可能会导致大量个内存浪费(size从10000 变为 2) 这时候可以使用swap进行一下收缩 `vector<int>(v).swap(v)`: 首先使用v进行一个匿名对象的初始化, 之后把他换到v里面 ### vector预留空间 `reserve(int len);`使容器预留len个元素长度，预留位置不初始化，元素不可访问（与resize不同）。 由于vector类中自动有算法根据size的内容算出capacity。一旦size要超过capacity，就重新分配新的空间，释放原有空间。10000个数需要转移30次。如果一开始就预留10000个空间，就不需要转移。可以减少vector在动态扩展容量时的扩展次数。 ## string 实际是一个对`char *`进行封装的类, 实现多种的成员方法 ### 构造函数 ```c++ string(); //默认的构造函数 string(const char *s); string(const string& str); string(int n, char c); // 建立一个n个字符c的字符串 ``` ### 赋值操作 ```c++ string &operator (const char*s); string &operator (const string& s); string &operator (const char c); string &assign(const const char *s); string &assign(const const char *s, int n); // 字符串的前n个字符 string &assign(const string& s); string &assign(int n,const char c); ``` ### 拼接 ```c++ string &operator+ (const char *str); string &operator+ (const char c); string &operator+ (const string &str); string &append(const char *str); string &append(const char *str, int n); string &append(const string &s); // 从pos开始的n个字符 string &append(const string &s, int pos, int n); ``` ### 查找替换 ```c++ int find(const string& str, int pos 0) const;\t//查找str第一次出现位置,从pos开始查找 int find(const char* s, int pos 0) const; \t//查找s第一次出现位置,从pos开始查找 int find(const char* s, int pos, int n) const; \t//从pos位置查找s的前n个字符第一次位置 int find(const char c, int pos 0) const; \t\t//查找字符c第一次出现位置 int rfind(const string& str, int pos npos) const;//查找str最后一次位置,从pos开始查找 int rfind(const char* s, int pos npos) const;\t//查找s最后一次出现位置,从pos开始查找 int rfind(const char* s, int pos, int n) const;\t//pos查找s的前n个字符最后一次位置 int rfind(const char c, int pos 0) const; \t//查找字符c最后一次出现位置 string& replace(int pos, int n, const string& str);//替换从pos开始n个字符为字符串str string& replace(int pos, int n,const char* s);\t//替换从pos开始的n个字符为字符串s ``` ### 比较 ```c++ int compare(const string &s) const; \t//与字符串s比较 int compare(const char *s) const;\t\t//与字符串s比较 ``` 进行ASCII的比较, 0是相等, 也可以使用` `, 相同返回1 ### 存取 ```c++ char& operator[](int n); \t //通过[]方式取字符 char& at(int n); \t\t\t//通过at方法获取字符 ``` ### 插入删除 ```c++ string& insert(int pos, const char* s); ————插入字符串 string& insert(int pos, const string& str); ——插入字符串 string& insert(int pos, int n, char c); ————指定位置插入n个字符c string& erase(int pos, int n npos); —————删除从Pos开始的n个字符 ``` ### 获取子串 ```c++ string substr(int pos 0, int n npos) const; //返回由pos开始的n个字符组成的字符串 ``` ### 属性 `.size()`: 获取字符串的长度 ## Deque双向链表 ![image 20250121172131575](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/picture/202501211721846.png) 实际的实现是有一个中控器, 控制多个缓冲区 是一个动态数组，通常是用多个连续的数组块组成的。它可以在两端高效地插入和删除元素（O(1) 时间复杂度），并且支持较快的随机访问（O(1) 时间复杂度）。 ```c++ deque<T> deqT; //默认构造形式 deque(beg, end);//构造函数将【beg，end】区间中的元素拷贝给本身 deque(n, elem);//构造函数将n个elem拷贝给本身 deque(const deque &deg);//拷贝构造函数 ``` ```c++ void test(const deque<int> &dq){ // 这里使用的是const_iterator for(deque<int>::const_iterator it dq.begin(); it ! dq.end(); it++){ cout << *it << \" \"; } cout << endl; } int main(void){ deque<int> dq; for(int i 0; i < 10; i++){ dq.push_back(i); } test(dq); cout << endl; } ``` ### deque赋值操作 功能描述： 给deque容器进行赋值 函数原型： ```cpp *deque& operator (const deque &deq); //重载等号操作符 assign(beg, endl); //将[beg，end]区间中的数据拷贝赋值给本身 assign(n, elem); //将n个elem拷贝赋值给本身 ``` ### deque大小操作 功能描述： 对deque容器的大小进行操作 函数原型： ```cpp deque.empty(); //判断容器是否为空 deque.size(); //返回容器中元素的个数 //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。 //如果容器变短，则末尾超出容器长度的元素被删除 deque.resize(num); //重新指定容器的长度，若容器变长，则以elem值填充新位置。 //如果容器变短，则末尾超出容器长度的元素被删除 deque.resize(num, elem); ``` ### deque插入和删除 功能描述： 向deque容器中插入和删除数据 函数原型： 两端插入操作： ```cpp push_back(elem); //在容器尾部添加一个数据 push_fromt(elem); //在容器头部插入一个数据 pop_back(); //删除容器最后一个数据 pop_front(); //删除容器第一个数据 ``` 指定位置操作：(pos之类为迭代器) ```cpp //在pos位置插入一个elem数据，无返回值。 insert(pos, elem); //在pos位置插入n个elem数据，无返回值 insert(pos, n, elem); //在pos位置插入[beg,end]区间的数据，无返回值 insert(pos, beg, end); clear(); //清空容器的所有数据 //删除[beg，end]区间的数据，返回下一个数据的位置 erase(beg, end); //删除pos位置的数据，返回下一个数据的位置上。 erase(pos); ``` ### deque数据存取 功能描述： 对deque中的数据存取操作 函数原型 ```cpp at(int idx); //返回索引idx所指的数据\t operator[]; //返回索引idx所指的数据 front(); //返回容器中的第一个数据元素 back(); //返回容器中最后一个数据元素 ``` ### deque排序 功能描述： 利用算法实现对deque容器进行排序 算法： ```cpp #include <algorithm> sort(iterator beg, iterator end); //对beg和end区间内元素进行排序 ``` > 默认是升序, 支持随机访问的都可以使用这一个 ## Stack栈 先进后出, 不可以进行遍历, 可以判断这一个容器是否为空以及元素个数 ### 基础使用 + 出舒畅 ```cpp stack<T> stk; //stack采用模板类实现， stack对象的默认构造形式 stack(const stack &stk); //拷贝构造函数 ``` + 赋值操作 ```cpp stack& operator (const stack &stk); //重载等号操作符 ``` + 数据存取： ```cpp push(elem); //向栈顶添加元素 pop(); //从栈顶移除第一个元素 top(); //返回栈顶元素 ``` + 大小操作： ```cpp empty(); //判断堆栈是否为空 size(); //返回栈的大小 ``` ## Queue队列 + 构造函数： ```cpp queue<T> que; //queue采用模板类实现，queue对象的默认构造形式 queue(const queue &que); //拷贝构造函数 ``` + 赋值操作： ```cpp queue& operator (const queue &que); //重载等号操作符 ``` + 数据存取： ```cpp push(elem); //往队尾添加元素 pop(); //从队头移除第一个元素 back(); //返回最后一个元素 front(); //返回第一个元素 ``` + 大小操作： ```cpp empty(); //判断堆栈是否为空 size(); //返回栈的大小 ``` ## list链表 插入 ```cpp list<T> lst; //list采用采用模板类实现,对象的默认构造形式： list(beg,end); //构造函数将[beg, end)区间中的元素拷贝给本身。 list(n,elem); //构造函数将n个elem拷贝给本身。 list(const list &lst); //拷贝构造函数。 ``` + 赋值交换 ```cpp list& operator (const list &lst); //重载等号操作符 assign(beg, end); //将[beg, end)区间中的数据拷贝赋值给本身。 assign(n, elem); //将n个elem拷贝赋值给本身。 swap(lst); //将lst与本身的元素互换。 ``` + 大小 ```cpp size(); //返回容器中元素的个数 empty(); //判断容器是否为空 resize(num); //重新指定容器的长度为num resize(num, elem); //重新指定容器的长度为num ``` + list 插入和删除 ```cpp push_back(elem);//在容器尾部加入一个元素 pop_back();//删除容器中最后一个元素 push_front(elem);//在容器开头插入一个元素 pop_front();//从容器开头移除第一个元素 insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。 insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。 insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。 clear();//移除容器的所有数据 erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。 erase(pos);//删除pos位置的数据，返回下一个数据的位置。 remove(elem);//删除容器中所有与elem值匹配的元素。 ``` + 数据存取 ```cpp front(); //返回第一个元素。 back(); //返回最后一个元素。 不能用[]和at，因为list不用连续的空间存储，不能随机访问 ``` + 翻转排序 ```cpp reverse(); //反转链表 sort(); //链表排序 ``` ## set/multiset容器 在插入的时候可以直接进行排序, 实际的实现是使用一个二叉树 set里面不可以有重复的元素, multiset里面可以有 + 构造 ```cpp set<T> st; //默认构造函数：set<int>s3; set(const set &st); //拷贝构造函数set<int>s2(s1); ``` + 赋值 ```cpp set& operator (const set &st); //重载等号操作符s3 s2; ``` + 插入数据： ```cpp s1.insert(10); ``` > set的这个函数的返回值是一个iterator和bool组合的pair, 可以使用`.second`查看是不是成功 > > multiset的返回只有一个iterator + 遍历： 使用迭代器 ```cpp for (set<int>::iterator it s.begin(); it ! s.end(); it++){ \t\tcout << *it << \" \"; } ``` + 大小交换 ```cpp size(); //返回容器中元素的数目 empty(); //判断容器是否为空 swap(st); //交换两个集合容器 ``` + 插入删除 ```cpp insert(elem); //在容器中插入元素。 clear(); //清除所有元素 erase(pos); //删除pos迭代器所指的元素，返回下一个元素的迭代器。 erase(beg, end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。 erase(elem); //删除容器中值为elem的元素。 ``` + 查找 ```cpp find(key); //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end(); count(key); //统计key的元素个数，set不允许重复，结果只能为0或1 ``` + 排序 set容器在插入时默认排序规则为从小到大，利用仿函数可改变排序规则。插入时就改变。 ```cpp class MyCompare { public: \tbool operator()(int v1, int v2) const { \t\treturn v1 > v2; \t} }; //定义时，第二个参数类型为仿函数类型。 set<int,MyCompare> s2; s2.insert(10); //在迭代的时候类型也需要变为 for (set<int>::iterator it s1.begin(); it ! s1.end(); it++) { } ``` ## pair对组 成对出现的一组数据, 可以使用这一个返回两个数据 ```cpp //默认构造 value1 value2赋初值 pair<type, type> p ( value1, value2 ); pair<type, type> p make_pair( value1, value2 ); ``` > 访问`p.first`和 `p.second` ## map 所有的元素都是一个pair, 第一个key为索引, 第二个value是实际的值, 会使用key进行排序 + 构造 ```cpp map<T1, T2> mp; //map默认构造函数: map(const map &mp); //拷贝构造函数 ``` + 赋值 ```cpp map& operator (const map &mp); //重载等号操作符 ``` + 大小交换 ```cpp size(); //返回容器中元素的数目 empty(); //判断容器是否为空 swap(st); //交换两个集合容器 ``` + 插入删除 ```cpp insert(elem); //在容器中插入'元素'。m.insert(pair<int, int>(1, 10)); clear(); //清除所有元素 erase(pos); //删除pos'迭代器'所指的元素，返回下一个元素的迭代器。 erase(beg, end); //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。 erase(key); //删除容器中键值为key的元素 ``` + 查找统计 ```cpp find(key); //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end(); count(key); //统计key的元素个数 ``` + 排序的实现和之前的set一样 ## 函数对象(仿函数) 重载函数调用操作符的类, 这一个对象称为函数对象, 使用重载的()的时候行为类似函数, 所以也叫仿函数 在使用的时候和普通的函数一样, 有参数和返回值, 但是这一个里面可以有自己的状态, 同时可以作为一个参数进行传递 ### 谓词 返回值是bool类型的仿函数, 接受一个参数是一元谓词, 两个参数是二元谓词, 一般作为STL的判断函数 ### 内建对象 以及实现了的仿函数, 可以直接使用, 使用`#include <functional>` + 算数仿函数 + 关系仿函数 + 逻辑仿函数 ```cpp //（1）算术仿函数，实现四则运算。其中negate是一元运算，其他都是二元运算。仿函数原型： template<class T> T plus<T> //加法仿函数，`plus<int> p; p(10,20); // p(10, 20) 30` template<class T> T minus<T> //减法仿函数； template<class T> T multiplies<T> //乘法仿函数； template<class T> T divides<T> //除法仿函数； template<class T> T modulus<T> //取模仿函数； template<class T> T negate<T> //取反仿函数，negate<int> neg; neg(10); // neg(10) 10` //（2）关系仿函数，实现关系对比。仿函数原型： template<class T> bool equal_to<T> 等于； template<class T> bool not_equal_to<T> 不等于； template<class T> bool greater<T> //大于，可以用于实现降序`sort(v.begin(), v.end(), greater<int>())`； template<class T> bool greater_equal<T> //大于等于； template<class T> bool less<T> //小于； template<class T> bool less_equal<T> //小于等于； //（3）逻辑仿函数，实现逻辑运算。仿函数原型： template<class T> bool logical_and<T> //逻辑与； template<class T> bool logical_or<T> //逻辑或； template<class T> bool logical_not<T> //逻辑非； ``` 实际使用 ```cpp int main(void){ negate<int> neg; cout << neg(10) << endl; plus<int> p;// 只可以同类操作, 所以使用一个参数 cout << p(10, 20) << endl; } ``` ## 常用算法 算法在使用的时候主要是有三个头文件 + algorithm: 最大的一个, 交换, 遍历, 查找, 复制, 修改 + numeric: 在几个序列进行简单数学运算的模板函数 + functional: 模板类, 用于声明函数对象 ### 遍历 `for_each`和`transform` ， 需包含 `<algorithm>`头文件 函数原型： `for_each(iterator beg, iterator end, _func);`，func是函数或函数对象都可以 **函数内部**是for循环，遍历从起始迭代器，到结束迭代器，执行传入的函数或仿函数操作 函数原型：` transform(iterator beg1, iterator end1, iterator beg2, _func);` beg1是源容器开始迭代器，end1是源容器结束迭代器，beg2是目标容器开始迭代器 _func 函数或者函数对象，在从源容器搬运到目标容器进行的操作 > 使用transform函数的时候目标容器需要提前开辟一下空间 ### 查找 `find` //查找元素 `find_if` //按条件查找元素 `adjacent_find` //查找相邻重复元素 `binary_search` //二分查找法 `count` //统计元素个数 `count_if` //按条件统计元素个数 函数原型：`find(iterator beg, iterator end, value);`,开始迭代器，结束迭代器和要查找的元素, 自定义的类型需要重载一下` ` 找到返回指定元素的迭代器，找不到返回结束迭代器end() 函数原型：`find_if(iterator beg, iterator end, _Pred);` 第三个参数是一个谓词，可以按照自己的条件找容器中是否有指定的数据。 有则返回当前迭代器，没有返回end() 函数原型： `adjacent_find(iterator beg, iterator end);`,开始迭代器，结束迭代器 找到返回第一个位置的迭代器，找不到返回结束迭代器end() **要求容器必须有序** 函数原型：`bool binary_search(iterator beg, iterator end, value);`， 查到 返回true 否则false 函数原型：`count(iterator beg, iterator end, value);` 返回值即为容器中value的个数，自定义数据类型需要重载 运算符(使用const)。 函数原型：`count_if(iterator beg, iterator end, _Pred);` `_Pred`谓词用来指定统计规则 自定义数据类型不需要重载，和正常的一样 ### 排序 ```cpp sort //对容器内元素进行排序 random_shuffle //洗牌 指定范围内的元素随机调整次序 merge // 容器元素合并，并存储到另一容器中 reverse // 反转指定范围的元素 ``` + 函数原型：sort(iterator beg, iterator end, Pred); + Pred谓词用来指定统计规则，默认为升序。 + 若要更改为降序，可以自己写函数或函数对象，也可以调用内建函数对象`greater<int>()`，需包含头文件`#include <functional>` 函数原型： `random_shuffle(iterator beg, iterator end);` 可以加随机种子`srand`，让他真实的打乱 函数原型：`merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);` dest是目标容器开始迭代器。 两个容器必须是**有序的** ，合并之后也是有序的。 目标容器需要**提前开辟空间** + 函数原型： `reverse(iterator beg, iterator end);` ### 拷贝替换 ```cpp copy // 容器内指定范围的元素拷贝到另一容器中 replace // 将容器内指定范围的旧元素修改为新元素 replace_if // 容器内指定范围满足条件的元素替换为新元素 swap // 互换两个容器的元素 ``` 函数原型：`copy(iterator beg, iterator end, iterator dest);` `dest);` 为目标容器的起始迭代器 目标容器需要提前分配空间 函数原型： `replace(iterator beg, iterator end, oldvalue, newvalue);` 使用：`replace(v.begin(), v.end(), 20,2000);` + 函数原型： `replace_if(iterator beg, iterator end, _pred, newvalue);` `_pred`谓词指定条件 函数原型：`swap(container c1, container c2);`，两种容器需要同种类型。 使用： `swap(v1, v2);` ### 计算 小型算法，需包含头文件`#include <numeric>` ```cpp accumulate // 计算容器元素累计总和 fill // 向容器中添加元素 ``` 函数原型 `accumulate(iterator beg, iterator end, value);` `value`指起始的累加值。 使用： `int total accumulate(v.begin(), v.end(), 0);` 函数原型： `fill(iterator beg, iterator end, value);` 使用： `fill(v.begin(), v.end(), 100);` ### 集合 `set_intersection` // 求两个容器的交集,需要是有序地 `set_union` // 求两个容器的并集 `set_difference` // 求两个容器的差集 + 函数原型: set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest); + dest为目标容器的起始迭代器，函数返回值为新容器的end()迭代器。 + 两个集合必须为有序序列 + 目标容器需提前分配空间。大小为容器可能性中最大的。eg取交集，容器最大为一个容器完全包含了另一个容器。即小的容器的大小。 + 由于我们分配的容器空间可能偏大，因此需要使用目标容器返回的结束的迭代器, 使用`.end()`会出现位置过大。"},"/note/编程基础/cpp/2025-1-22-其他扩展语法.html":{"title":"扩展语法","content":"# 扩展语法 ## lambda函数 [深入浅出 C++ Lambda表达式：语法、特点和应用_lamda CSDN博客](https://blog.csdn.net/m0_60134435/article/details/136151698) Lambda表达式是一种在被调用的位置或作为[参数传递](https://so.csdn.net/so/search?q 参数传递&spm 1001.2101.3001.7020)给函数的位置定义匿名函数对象（闭包）的简便方法。Lambda表达式的基本语法如下： ```cpp [capture list] (parameter list) > return type { function body } ``` + `capture list` 是捕获列表，用于指定 Lambda表达式可以访问的外部变量，以及是按值还是按引用的方式访问。捕获列表可以为空，表示不访问任何外部变量，也可以使用默认捕获模式 & 或 来表示按引用或按值捕获所有外部变量，还可以混合使用具体的变量名和默认捕获模式来指定不同的捕获方式。 + `parameter list `是参数列表，用于表示 Lambda表达式的参数，可以为空，表示没有参数，也可以和普通函数一样指定参数的类型和名称，还可以在 c++14 中使用 auto 关键字来实现泛型参数。 + `return type` 是返回值类型，用于指定 Lambda表达式的返回值类型，可以省略，表示由编译器根据函数体推导，也可以使用 > 符号显式指定，还可以在 c++14 中使用 auto 关键字来实现泛型返回值。 + `function body` 是函数体，用于表示 Lambda表达式的具体逻辑，可以是一条语句，也可以是多条语句，还可以在 c++14 中使用 constexpr 来实现编译期计算。 > Lambda表达式虽然是一种语法糖，但它本质上也是一种函数对象，也就是重载了 `operator()` 的类的对象。每一个 Lambda表达式都对应一个唯一的匿名类，这个类的名称由编译器自动生成，因此我们无法直接获取或使用。 > > ```cpp > int x 10; > class __lambda_1 > { > public: > __lambda_1(int x) : __x(x) {} // 构造函数，用于初始化捕获的变量 > int operator() (int y) const // 重载的 operator()，用于调用 Lambda表达式 > { > return __x + y; // 函数体，与 Lambda表达式的函数体相同 > } > private: > int __x; // 数据成员，用于存储捕获的变量 > }; > auto f __lambda_1(x); // 创建一个匿名类的对象，相当于 Lambda表达式 > > ``` ### 捕获值 + 值捕获（capture by value）：在捕获列表中使用变量名，表示将该变量的值拷贝到 Lambda 表达式中，作为一个数据成员。值捕获的变量在 Lambda 表达式定义时就已经确定，不会随着外部变量的变化而变化。值捕获的变量默认不能在 Lambda 表达式中修改，除非使用 mutable 关键字。例如： ```cpp int x 10; auto f [x] (int y) > int { return x + y; }; // 值捕获 x x 20; // 修改外部的 x cout << f(5) << endl; // 输出 15，不受外部 x 的影响 ``` + 引用捕获（capture by reference）：在捕获列表中使用 & 加变量名，表示将该变量的引用传递到 Lambda 表达式中，作为一个数据成员。引用捕获的变量在 Lambda 表达式调用时才确定，会随着外部变量的变化而变化。引用捕获的变量可以在 Lambda 表达式中修改，但要注意生命周期的问题，避免悬空引用的出现。例如： ```cpp int x 10; auto f [&x] (int y) > int { return x + y; }; // 引用捕获 x x 20; // 修改外部的 x cout << f(5) << endl; // 输出 25，受外部 x 的影响 ``` + 隐式捕获（implicit capture）：在捕获列表中使用 或 &，表示按值或按引用捕获 Lambda 表达式中使用的所有外部变量。这种方式可以简化捕获列表的书写，避免过长或遗漏。隐式捕获可以和显式捕获混合使用，但不能和同类型的显式捕获一起使用。例如： ```cpp int x 10; int y 20; auto f [ , &y] (int z) > int { return x + y + z; }; // 隐式按值捕获 x，显式按引用捕获 y x 30; // 修改外部的 x y 40; // 修改外部的 y cout << f(5) << endl; // 输出 55，不受外部 x 的影响，受外部 y 的影响 ``` + 初始化捕获（init capture）：C++14 引入的一种新的捕获方式，它允许在捕获列表中使用初始化表达式，从而在捕获列表中创建并初始化一个新的变量，而不是捕获一个已存在的变量。这种方式可以使用 auto 关键字来推导类型，也可以显式指定类型。这种方式可以用来捕获只移动的变量，或者捕获 this 指针的值。例如： ```cpp int x 10; auto f [z x + 5] (int y) > int { return z + y; }; // 初始化捕获 z，相当于值捕获 x + 5 x 20; // 修改外部的 x cout << f(5) << endl; // 输出 20，不受外部 x 的影响 ``` ### 拓展 C++14 允许在 Lambda表达式的参数列表和返回值类型中使用 `auto` 关键字，从而实现泛型 Lambda，即可以接受任意类型的参数和返回任意类型的值的 Lambda表达式。例如： ```cpp #include <iostream> using namespace std; int main() { // 定义一个泛型 Lambda，根据参数的类型返回不同的值 auto f [] (auto x) > auto { if (is_integral<decltype(x)>::value) // 如果 x 是整数类型 { return x * 2; // 返回 x 的两倍 } else if (is_floating_point<decltype(x)>::value) // 如果 x 是浮点类型 { return x / 2; // 返回 x 的一半 } else // 其他类型 { return x; // 返回 x 本身 } }; // 调用泛型 Lambda cout << f(10) << endl; // 输出 20 cout << f(3.14) << endl; // 输出 1.57 cout << f(\"hello\") << endl; // 输出 hello return 0; } ``` C++14 允许在 Lambda表达式的捕获列表中使用初始化表达式，从而实现初始化捕获，即可以在捕获列表中创建和初始化一个新的变量，而不是捕获一个已存在的变量。 ```cpp int main() { // 定义一个 Lambda表达式，使用初始化捕获，创建一个新的变量 z auto f [z 10] (int x, int y) > int { return x + y + z; }; // 调用 Lambda表达式 cout << f(3, 4) << endl; // 输出 17 return 0; } ``` C++17 允许在 Lambda表达式的捕获列表中使用 `*this`，从而实现捕获 this 指针，即可以在 Lambda表达式中访问当前对象的成员变量和成员函数。 ```cpp #include <iostream> using namespace std; // 定义一个类 class Test { public: Test(int n) : num(n) {} // 构造函数，初始化 num void show() // 成员函数，显示 num { cout << num << endl; } void add(int x) // 成员函数，增加 num { // 定义一个 Lambda表达式，捕获 this 指针 auto f [*this] () { return num + x; }; // 调用 Lambda表达式 cout << f() << endl; } private: int num; // 成员变量，存储一个整数 }; int main() { Test t(10); // 创建一个 Test 对象 t.show(); // 调用成员函数，输出 10 t.add(5); // 调用成员函数，输出 15 return 0; } ``` ## Auto auto不再是一个存储类型指示符，而是作为一个新的类型指示符来指示编译器，auto声明的变量必须由编译器在编译时期推导而得，`auto`关键字被引入以简化变量的类型声明。 可以作为一个赋值语句的左侧以及函数的返回值, 自动推导类型 > 不可以用于数组和函数的参数 还可以用于遍历 ```cpp #include <iostream> #include <vector> int main() { std::vector<int> vec {1, 2, 3, 4, 5}; // 使用 auto 关键字和范围for循环 for (auto& elem : vec) { // 自动推导 elem 的类型为 int& std::cout << elem << std::endl; } return 0; } ``` > 对于数组而言，就是数组中第一个元素和最后一个元素的范围；对于类而言，应该提供begin和end的方法，begin和end就是for循环迭代的范围。 > > 迭代的对象必须支持递增（`++`）和比较（` `）操作。这是因为范围for循环在内部使用这些操作来遍历容器。 也可以用lambda函数的推导 ```cpp int main() { auto add { return a + b; }; int result add(3, 4); // result 被推导为 int，值为 7 std::cout << \"3 + 4 \" << result << std::endl; return 0; } ``` ## 函数包装器 不同的函数包装为同一种类型, 这样在传递一个类里面函数作为回调函数的时候, 不用把类交给对方 ```cpp #include <iostream> #include <functional> void save_with_free_func(const std::string &data) { std::cout << \"Free function saving data: \" << data << std::endl; } class DataSaver { public: void save_with_member_func(const std::string &data) { std::cout << \"Member function saving data: \" << data << std::endl; } }; int main() { // 使用std::function绑定成员函数 DataSaver saver; // lambda表达式 auto lambda_func [](const std::string &data) { std::cout << \"Lambda saving data: \" << data << std::endl; }; // 使用std::function绑定普通函数 std::function<void(const std::string &)> func_std save_with_free_func; // 使用std::bind绑定成员函数, 参数为对象指针和占位符, 占位符表示后续传入的参数 std::function<void(const std::string &)> member_func_std std::bind(&DataSaver::save_with_member_func, &saver, std::placeholders::_1); std::function<void(const std::string &)> lambda_std lambda_func; func_std(\"Sample Data 1\"); member_func_std(\"Sample Data 2\"); lambda_std(\"Sample Data 3\"); return 0; } ```"},"/note/编程基础/cpp/2025-1-1-02内存.html":{"title":"内存","content":"# 内存 内存分区, 在c++里面一共有四个分区, 代码区, 全局区, 栈区以及堆区 >"},"/note/编程基础/cpp/2025-1-1-01C++.html":{"title":"C++","content":"# C++ 这是一个基于C语言的语言 ## 区别 ### 头文件 所有的C语言头文件都有一个C++的版本, 在使用的时候去掉`.h`在前面加`c`比如`<cstring>` stdio.h iostream : : : : math cmath string cstring stdlib cstdlib ### 命名空间 ### 标准输出/输入 ```c++ #include <iostream> int main(void){ std::cout << \"Hello World!\" << 24 << 3.14 << std::endl; return 0; } ``` ```c++ int num 1; char name[50]; std::cin >> num >> name; std::cout << \"You entered: \" << num << std::endl; std::cout << \"You entered: \" << name << std::endl; ``` > 这里的std可以在加一行`using namespace std;`以后进行省略 ### 命名空间 防止命名的变量是相同名字的可以把变量放在不同的作用域里面, 标准的命名空间是std ````c #include <iostream> namespace myNamespace{ int myVar 42; } int main(void){ int myVar 0; std::cout << myNamespace::myVar << std::endl; std::cout << myVar << std::endl; return 0; } ```` > 这是一个空间, 在使用的时候可以导入整个命名空间, 也可以导入单个变量 > > ```c++ > #include <iostream> > > namespace myNamespace{ > int myVar 42; > } > > int main(void){ > using namespace myNamespace; > std::cout << myVar << std::endl; > return 0; > } > ``` > > ```c++ > #include <iostream> > > namespace myNamespace{ > int myVar 42; > } > > int main(void){ > using myNamespace::myVar; > std::cout << myVar << std::endl; > return 0; > } > ``` ### 数据类型 #### bool 多了一个类型`bool`, 在C语言里面需要使用`stdbool.h`, 在c++里面可以直接使用`true`和`false` ```c++ std::cout << true << \" \" << false << std::endl; ``` 实际在使用的时候可以使用 ```c++ std::cout << std::boolalpha << true << \" \" << false << std::endl; ``` > `true false`输出的时候是使用这样的形式 #### string 1. 内存管理：在C语言中，字符数组需要手动分配内存和管理内存释放。而在C++中，string类会自动处理内存管理，避免了内存泄漏和越界访问的问题。 2. 功能性：C语言的字符数组只能存储字符序列，而C++的string类可以存储任意类型的字符串，并提供了丰富的字符串操作方法，如查找、替换、连接、分割等。 3. 便利性：使用C++的string类可以更方便地操作字符串，避免了在C语言中使用字符数组时需要手动处理的很多细节，使代码更简洁清晰。 4. 长度可变：C语言的字符数组长度是固定的，一旦分配了内存大小就不能再改变。而C++的string类可以动态增加或删除字符串内容，长度可变。 总的来说，C++的string类相比于C语言的字符数组更加安全、便捷、功能更强大，是更好的字符串处理工具。 ```c++ string s1; // 默认构造一个空字符串 string s2(\"hello\"); // 使用C风格字符串初始化 string s3(s2); // 拷贝构造 ``` + string类的容量操作 *string*类提供了一系列容量操作的方法，如*size()*和*length()*返回字符串的长度，*capacity()*返回分配的总空间，*empty()*检查字符串是否为空，*clear()*清空字符串内容，*reserve()*预留空间，以及*resize()*调整字符串大小。例如： ```c++ string str \"hello\"; cout << str.size() << endl; // 输出字符串长度 str.reserve(100); // 预留100个字符的空间 str.resize(50, 'x'); // 将字符串大小调整为50，多出的部分用'x'填充 ``` + string类的访问和遍历 *string*类支持通过下标访问单个字符，也支持使用迭代器进行遍历。C++11还引入了范围*for*循环，使得遍历*string*对象变得更加简单。例如： ```c++ string str \"hello\"; for (size_t i 0; i < str.size(); ++i) { \tcout << str[i]; // 通过下标访问 } for (auto c : str) { \tcout << c; // 使用范围for遍历 } ``` string类的修改操作 *string*类提供了丰富的修改操作，如*push_back()*在字符串末尾添加字符，*append()*追加字符串，*insert()*在指定位置插入字符串，*erase()*删除部分字符串，*replace()*替换字符串中的一部分，以及*operator+ *用于字符串连接等。例如： ```c++ string str \"hello\"; str.push_back('!'); // 在末尾添加字符 str.append(\" world\"); // 追加字符串 str.insert(5, \" dear\"); // 在指定位置插入字符串 str.erase(0, 5); // 删除前五个字符 str.replace(0, 5, \"Hi\"); // 替换字符串中的一部分 str + \"!!!\"; // 字符串连接 ``` string类的非成员函数 *string*类还提供了一些非成员函数，如*operator+*用于字符串连接，*operator>>*和*operator<<*用于输入输出流操作，以及*getline()*用于从输入流中读取一行字符串。例如： string str1 \"hello\"; string str2 \"world\"; string str3 str1 + \" \" + str2; // 字符串连接 cout << str3 << endl; // 输出字符串 getline(cin, str3); // 从标准输入读取一行字符串 **注意**：在使用*string*类时，应该包含头文件`<string>`并使用`std`命名空间。此外，`string`类的操作在底层可能涉及到内存的分配和释放，因此在性能敏感的场合需要谨慎使用。 可以直接使用` `对两个字符串进行比较 ### 强弱类型 在c++里面对于类型的检查比较严格, 强制转换需要显式的转换, 除了转换为`void *`类型的指针 ### 空指针 在c++里面使用`nullptr`替代`NULL`作为空指针, 在c++里面NULL被定义为0, C语言里面这一个`void *`类型的0 ### const 在C语言里面, 只是规定这一个变量为只读的 在C语言里面如果使用下面的代码 ```c const int num 18; int buf[num]; //这个时候有可能报错 printf(\"The size of the buffer is %d\\n\", sizeof(buf)); int *p &num; *p 22; // 可以使用这一种方法进行修改数据 printf(\"The value of num is %d\\n\", num); ``` 如果是在C++里面 ```c const int num 18; int buf[num]; // 可以直接使用 printf(\"The size of the buffer is %d\\n\", sizeof(buf)); int *p (int *)&num; // 地址不兼容, 必须强转 *p 22; printf(\"The value of num is %d\\n\", num); // 实际打印的是18, 没有改变但不报错 return 0; ``` 实际在C++进行赋值的时候把常量区的数据复制到了栈区, 最后改的是栈区里面的, 观看件地址的时候这两个地址实际还是一样的数字, 这是因为C++会把真实地址隐藏, 用于兼容C语言 并且在进行字符串定义的时候要加`const` >`const char* name \"jiao\";` ### 三目运算符 在C语言里面下面的使用方法是错误的 ```c++ (a > b ? a : b) 20; ``` 在C语言里面返回的这一个值是数值, c++里面可以, 它返回的是变量 如果在C语言里面使用类似的需要使用下面的 ```c *(a > b ? &a : &b) 20; ``` ### 引用 在C语言里面改变一个实参的值, 需要传递一个指针, 在c++里面则可以使用引用, 实际是给这一个变量一个别名 语法`数据类型 &别名 原名`, 在实际使用的时候必须初始化, 初始化以后不可以改变 ```c++ #include <iostream> void test(int& a){ a 10; } int main(void){ int a 5; test(a); std::cout << a << std::endl; return 0; } ``` 实际还是通过指针实现的, 两个变量指向的是同一个地址 在实际使用的时候这一个可以作为函数的返回值, 不要返回局部变量的引用, 可以使用static ```c++ int & test(){ static int a 10; return a; } int main(void){ int &p test(); std::cout << p << std::endl; test() 20; std::cout << p << std::endl; return 0; } ``` 实际实现的方法是使用一个const类型的地址, 在赋值的时候会自动进行添加`*` ```c++ int * const ref &b; ``` #### 常量引用 在实际使用的时候如果指向的数据不是在一个合法的内存里面, 可以在前面加一个`const` ```c++ const int & ref 10; // 等价于int temp 10; const int & ref temp; ``` 这给数据是只读的, 实际的使用场景是作为函数的参数 ### 堆区申请释放 ```c++ int *p new int(10); delete p; ``` > 建立一个变量, 这一个变量是10 ```c++ int *p new int[10]; delete[] p; ``` > 建立一个数组, 这一个数组里面有10个数据, 再释放的时候要告诉他 ### 函数 #### 默认参数 函数的参数在实际传递的时候可以给一个默认的数值， 函数赋值的时候只可以给最后面的参数赋值 实际使用的时候如果声明里面使用了默认参数, 实际实现的时候不可以在加一个默认参数(只能有一个里面有) #### 占位参数 在初始化函数的时候只有一个变量的类型, 没有变量名 ```c void test(int 10){ std::cout << \"test(int)\" << std::endl; } int main(void){ test(10); return 0; } ``` 这一个参数可以有默认的数值 #### 函数重载 在同一个作用域里面函数的名字不同但是函数的参数不同(函数的返回值不可以) ```c++ void test(int ){ std::cout << \"test(int)\" << std::endl; } void test(){ std::cout << \"test()\" << std::endl; } int main(void){ test(10); test(); return 0; } ``` 在实际使用的时候引用也可以作为重载的条件比如`const int &`和`int &` ```c++ void test(int & a){ std::cout << \"test(int & a)\" << std::endl; } void test(const int & a){ std::cout << \"test(const int & a)\" << std::endl; } int main(void){ int a 10; test(a); //test(int & a) test(10);//test(const int & a) return 0; } ``` 如果有默认参数使得在传递参数的时候出现异议是非法的 ```c++ void test(int a){ std::cout << \"test(int a)\" << std::endl; } void test(int a, int b 10){ std::cout << \"test(int a, int b 10)\" << std::endl; } ``` > 上面的情况再只有一个参数的时候是非法的 ## 类 ### 封装 把属性的属性和行为封装为一个类 ### 权限 有三种权限: public共有的, protected保护的, private私有的 public: 在类里面可以访问, 类外面可以访问 protected: 类里面可以访问, 外面不可以访问(继承的时候子类可以访问的内容) private: 类里面可以访问, 外面不可以访问(继承的时候不可以访问父类) > 默认的时候struct里面的都是公共的, Class里面的都是私有的 ### 构造函数以及析构函数 构造函数`类名(){}`, 析构函数`~类名(){}` > 没有返回值, 也不用写void, 构造函数有参数可以重载 > > 在C++中，构造函数后面的冒号（:）引入了一个非常重要的概念——初始化列表。初始化列表是在构造函数体执行之前初始化类成员的一种方式。它不仅用于提供给成员变量初始值，而且是某些特定情况下唯一可行的初始化方式。 > > 初始化列表不仅用于普通成员变量的初始化，还有几种特殊的用途： > > 1. **初始化const成员变量**：由于const成员变量一旦被初始化后就不能再被修改，因此它们必须在初始化列表中进行初始化。 > 2. **初始化引用类型成员变量**：引用成员也必须在初始化列表中进行初始化，因为引用一旦被绑定到一个对象上，就不能再绑定到另一个对象上。 > 3. **调用基类的构造函数**：当创建派生类对象时，可以在初始化列表中调用基类的构造函数来初始化基类部分。 > 4. **初始化成员类对象**：如果成员类对象没有默认构造函数，或者需要特定的初始化参数，也必须在初始化列表中进行初始化。 ```c++ class Circle{ // 公共权限 public: // 构造函数 Circle(int r):radius(r){ std::cout << \"Constructor called\" << std::endl; } int radius; double calculateArea(){ return 3.14159 * radius * radius; } }; int main(void){ Circle circle(10); circle.radius 10; std::cout << \"The area of the circle is: \" << circle.calculateArea() << std::endl; return 0; } ``` + 拷贝构造函数 ```c++ #include <iostream> #include <string> using namespace std; class Person{ // 公共权限 public: // 构造函数 Person(const Person &person){ // 拷贝构造函数, 作用是初始化一个对象, 该对象是用同类的另一个对象初始化的 std::cout << \"Copy constructor called\" << std::endl; name person.name; } Person(){ std::cout << \"Constructor called\" << std::endl; } ~Person(){ std::cout << \"Destructor called\" << std::endl; } string name; }; int main(void){ Person person1; // 调用构造函数 person1.name \"zhangsan\"; Person person2 person1; // 调用拷贝构造函数 std::cout << person2.name << std::endl; return 0; } ``` + 调用 ```c++ Person person; //没有参数的构造函数 Person person2(20); // 有参数的构造函数 Person person3(person2);// 拷贝构造函数 Person person4 person3; //拷贝构造函数 ``` > 在调用没有参数的构造函数的时候不要加括号, 否则会被以为是一个函数的声明 > > 在使用值传递的方式给一个函数传递参数的时候, 实际也是对一个对象实现一次拷贝, 使用值的方式返回局部变量的时候也是同样的 + 匿名对象 ```c++ Person(10); // 一个匿名对象, 这一行结束以后立即释放 ``` > 注意在使用这一个的时候不要使用拷贝构造函数 > > ```c++ > Person(p3); // Person(p3) 等价于 Person p3;会导致重复命名 > ``` + 隐式转换 ```c++ Person p4 10; // 相当于 Person p4 Person(10); ``` > 拷贝构造同理 #### 默认函数 C++的类默认的时候会初始化四个函数, 没有参数构造函数, 析构函数, 拷贝构造函数以及一个赋值运算符重载, 如果写了一个有参数的构造函数, 无参数的构造函数也会消失, 但是有拷贝构造函数 如果有一个拷贝构造函数, 其他的函数都会没有 #### 深浅拷贝 浅拷贝是简单的使用等号赋值, 深拷贝是重新开辟一次内存 如果使用指针指向一块堆区的内存, 会出现一种情况, 使用默认的复制会导致复制的函数操控的内存是同一块, 如果使用析构函进行释放, 会导致重复释放 ### 初始化列表 `构造函数():属性1(值1), 属性2(值2)...{}` 用于初始化类里面的值, 这里的值可以是写死的, 也可以是函数的参数 ```c++ class Person{ // 公共权限 public: // 构造函数 Person(int a, int b):a(a), b(b), c(30){ std::cout << \"构造函数\" << std::endl; } int a; int b; int c; }; int main(void){ Person person1(10, 20); // 调用构造函数 std::cout << person1.a << std::endl; std::cout << person1.b << std::endl; std::cout << person1.c << std::endl; return 0; } ``` ### 静态成员 使用static关键字 静态成员变量: 所有的类使用同一个数据, 在使用的时候类内声明, 类外初始化 静态成员函数: 所有的类使用同一个函数, 只可以访问静态的变量 ```c++ class Person{ // 公共权限 public: static int A; static void func(){ std::cout << \"static func\" << std::endl; } }; int Person::A 10; int main(void){ Person person1; // 调用构造函数 std::cout << person1.A << std::endl; std::cout << Person::A << std::endl; person1.func(); Person::func(); return 0; } ``` 在访问的时候可以通过对象以及类名进行访问 ### 对象模型以及this指针 在C++里面只有非静态的成员变量才在类的对象上面, 一个空的类对象占用的内存为一个字节, 为了区分空的对象占用的内存空间不同 如果里面有一个其他的非静态的变量, 按照变量的大小存储 `this`指针指向当前的调用成员函数的变量, 隐含在每一个非静态的成员函数, 实质是一个指针常量 > 可以用于区分形参和成员变量重名以及用于返回对象本身`return *this;` ```c++ class Person{ // 公共权限 public: int age; Person(int age):age(age){ cout << \"构造函数\" << endl; } void set_age(int age){ this >age age; } Person& add_age(Person &p){ // 引用传递 this >age + p.age; return *this; } }; int main(void){ Person person1(10); // 调用构造函数 std::cout << person1.age << std::endl; Person person2(20); // 调用构造函数 std::cout << person2.age << std::endl; person1.add_age(person2).add_age(person2).add_age(person2); std::cout << person1.age << std::endl; return 0; } ``` 在使用空指针调用成员函数的时候, 使用this的函数会失败 ```c++ class Person{ // 公共权限 public: void test(){ cout << \"test\" << endl; } int a; void test2(){ cout << \"test2\"<< this >a << endl; } }; int main(void){ Person *person NULL; person >test(); person >test2();\t// 失败 } ``` ### const修饰(常函数/对象) 这一个函数不可以修改成员的属性, 除非在属性声明的时候加一个mutable ![image 20250105140613173](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202501051406288.png) > 实质是给this指针变为一个常量指针常量 > > ```c++ > class Person{ > // 公共权限 > public: > void show_Person() const{ > cout << \"Person show()\" << endl; > age 10; > } > > mutable int age; > }; > ``` 在一个对象的前面加一个const, `const Person p;`, 这时候这一个对象只可以使用常函数, 修根常属性 ### 友元friend 有一部分的私有属性想要其他的类或者函数进行访问 这一个可以是全局的函数, 类以及成员函数 ```c++ class Person{ friend void good_friend(Person *person); // 公共权限 public: Person(string name, int age){ m_name name; m_age age; } private: // 私有权限 string m_name; int m_age; }; void good_friend(Person *person){ cout << \"好基友: \" << person >m_name << \" 年龄: \" << person >m_age << endl; } int main(void){ Person person(\"张三\", 20); good_friend(&person); return 0; } ``` 使用另一个类进行访问的时候可以加一个`friend class Goodfriend;`, 这时候这一个类里面的所有的函数都可以访问, 如果只希望一部分函数可以使用`friend void Goodfriend::visit(void);` > **注:**如果这一个函数在类内实现, 加一个friend, 这一个函数会成为全局函数 ### 类外实现 在类里面只有一个声明, 在类的外面使用类的名字以及::函数名进行实现 ### 运算符重载 实现自定义的类型运算 ```c++ // 公共权限 public: int a, b; Person(int a, int b){ this >a a; this >b b; } Person operator+(Person &person){ Person temp(0, 0); temp.a this >a + person.a; temp.b this >b + person.b; return temp; } }; int main(void){ Person person1(1, 2); Person person2(3, 4); Person person3 person1 + person2; cout << person3.a << \" \" << person3.b << endl; return 0; } ``` > 也可以使用`Person person3 operator+(p1 ,p2)` 还可以使用全局函数进行重载 ```c++ Person operator+(Person &person1, Person &person2){ Person temp(0, 0); temp.a person1.a + person2.a; temp.b person1.b + person2.b; return temp; } ``` > 这一个函数也可以函数重载 > > ```c > Person operator+(Person &person1, int a){ > Person temp(0, 0); > temp.a person1.a + a; > temp.b person1.b + a; > return temp; > } > ``` > > > 这样第二个参数不同的时候调用不同的函数 重载一下`<<`这一个符号, 可以用于输出, 一般不使用成员函数, 这样输出的时候变量可以在的`cout`的右侧 ```c++ ostream& operator<<(ostream &cout, Person &person){ cout << \"p.a\" << person.a << \" p.b\" << person.b << endl; return cout; } ``` 在重载递增的时候需要重载前置以及后置的重载 ```c++ class MyInteger{ int n; public: MyInteger(int n): n(n){} MyInteger operator+(int n){ return MyInteger(this >n + n); } friend ostream& operator<<(ostream& os, const MyInteger& myInteger); // 这是一个前置++运算符重载 MyInteger& operator++(){ n++; return *this; }; // 这是一个后置++运算符重载, int是一个占位符，用于区分前置和后置 MyInteger operator++(int){ MyInteger temp *this; n++; return temp; }; }; ostream& operator<<(ostream& os, const MyInteger& myInteger){ os << myInteger.n; return os; } int main(void){ MyInteger myInteger(10); cout << myInteger + 5 << endl; cout << myInteger++ << endl; cout << myInteger << endl; cout << ++myInteger << endl; return 0; } ``` > ```bash > PS E:\\JHY\\c++\\test> ./main.exe > 15 > 10 > 11 > 12 > ``` 在默认的时候赋值运算符的重载是已经实现了的, 对属性进行浅拷贝, 再重新实现的时候是一个`Person & operator (Person &p)` 重载关系运算符的时候返回的是一个bool类型的数据 #### 仿函数 实际是对`()`进行重载, 使用的方式类似一个函数 ```c++ class MyPrint{ public: void operator()(string str){ cout << str << endl; } }; int main(void){ MyPrint myPrint; myPrint(\"Hello World\"); return 0; } ``` > 在实际使用的时候可以使用匿名对象进行调用`MyPrint()(\"Hello World\")` ### 继承 为了避免重复的代码, 语法`class 类名:public 继承的类{}` 这里的额public是继承的方式, 实际继承的的时候也是三种方式 + public继承 这一个可以把父类的public和protected的属性继承下来, 同时有对应的属性, 没有变化 + protected继承 继承父类的public和protected, 继承的属性都是protected + private继承 继承父类的public和protected, 继承的属性都是private > 在继承的时候父类的所有的属性都会被继承, 但是私有的属性不可以访问, 实际的数据大小是所有的属性相加 子类在继承父类的时候也会调用父类的构造函数, 首先调用父类的构造函数, 最后调用父类的析构函数 #### 同名变量 访问子类的同名对象的时候可以直接进行访问, 在访问父类的同名对象的时候需要加一下作用域 ```c++ class Parent{ public: Parent(){ num 10; } int num; }; class Son: public Parent{ public: Son(){ num 20; } int num; }; int main(void){ Son son; cout << son.num << endl; cout << son.Parent::num << endl; //父类的作用域 return 0; } ``` > 如果子类里面出现和父类的名字一样的成员函数, 会隐藏掉父类里面的所有的同名函数(包括重载的函数), 想要使用的时候需要使用作用域 #### 多继承 `class 类名:继承方式 继承的类, 继承方式 继承的类3{}` 在实际继承的时候父类里面有同样的成员的时候需要使用作用域进行区分, 在C++里面不建议使用 #### 菱形继承 在继承的时候如果有一个相同的祖宗类, 会使得这一个部分的代码出现重复继承的情况, 实际使用的时候需要加上作用域进行区分, 但是这一部分的数据实际只需要一份, 如果这样使用会导致出现资源的浪费 解决这一个问题可以使用虚继承的方式在继承的时候继承的方式前面加一个`virtual` ```c++ class base { public: int A; }; class parent1 : public base{ public: parent1(){ A 5; } int B; }; class parent2 : public base{ public: parent2(){ A 10; } int C; }; class child : public parent1, public parent2{ public: int D; }; int main(void){ child obj; cout << \"Size of child: \" << sizeof(obj) << endl; cout << \"A: \" << obj.parent1::A << endl; cout << \"A: \" << obj.parent2::A << endl; return 0; } ``` ```c++ class parent1 :virtual public base{ public: parent1(){ A 5; } int B; }; class parent2 :virtual public base{ public: parent2(){ A 10; } int C; }; ``` > 这时候实际的数据只有一份, 使用这一个关键字的时候, 实际继承的是一个vbptr, virtual base pinter, 指向vbtable, 这一个指针是一个偏移量, 最后指向实际的数据 ### 多态 静态的多态实际就是函数的多态以及运算符的重装载, 动态的多态实际是在派生类以及虚函数运行的时候实现的多态 动态的多态在运行的时候函数的地址才会绑定 ```c class Animal{ public: string color; void speak(){ cout << \"Animal speaks\" << endl; } }; class Dog : public Animal{ public: string breed; void speak(){ cout << \"Dog barks\" << endl; } }; // 这一个函数不管传入的是什么类型的动物，都会调用动物的speak方法 void doSpeak(Animal &a){ a.speak(); } int main(void){ Dog d1; doSpeak(d1); return 0; } ``` ```c++ class Animal{ public: string color; virtual void speak(){ // virtual关键字，表示这个方法是虚方法，可以被子类重写 cout << \"Animal speaks\" << endl; } }; class Dog : public Animal{ public: string breed; void speak(){ cout << \"Dog barks\" << endl; } }; // 这时候使用的是Dog的函数 void doSpeak(Animal &a){ a.speak(); } int main(void){ Dog d1; doSpeak(d1); return 0; } ``` > 重写的时候函数的名字以及函数的参数是完全相同的, 实际是父类的指针在指向子类的函数, 所以使用这一个方法以后会使得没有参数的时候占位的一字节变成4个, 变为一个虚函数指针, 指向实际执行的虚函数表, 表里面记录的是虚函数的地址 #### 纯虚函数和抽象类 `virtual 返回值类型 函数名(参数列表) 0;`这一个函数不实现, 作为父类 有这一种函数的类是抽象类, 这一个类不能实例化对象, 子类必须重写纯虚函数, 否则也是纯虚函数 实际的使用是在函数的参数描写的时候写父类, 传递的参数是子类, 由于子类的实现不同, 函数实际执行的任务是不同的 #### 虚析构和纯虚析构 使用多态的时候如果子类里面有在堆区的数据, 使用父类的指针在释放的时候不可以调用到子类的析构函数, 这时候可以把父类的析构函数改为虚析构或纯虚析构, 如果使用的是纯虚的析构, 这一个类也是一个抽象的类 `virtual ~类名(){}`和`virtual ~类名() 0;` ```c++ class Base{ public: Base(){ cout << \"Base Constructor\" << endl; } ~Base(){ cout << \"Base Destructor\" << endl; } }; class Animal: public Base{ public: Animal(){ cout << \"Animal Constructor\" << endl; } ~Animal(){ cout << \"Animal Destructor\" << endl; } }; void test(Base *b){ delete b; } int main(void){ Animal *a new Animal(); test(a); return 0; } ``` > ```bash > PS E:\\JHY\\c++\\test> ./main.exe > Base Constructor > Animal Constructor > Base Destructor > ``` > > 使用 > > ```c++ > virtual ~Base(){ > cout << \"Base Destructor\" << endl; > } > ``` > > ```bash > PS E:\\JHY\\c++\\test> ./main.exe > Base Constructor > Animal Constructor > Animal Destructor > Base Destructor > ``` 使用纯虚析构的时候也需要实现这一个函数, 使用`类名::返回值 函数名(参数){}`进行实现 ## 文件操作 使用头文件`<fstream>`, 主要有三大类ofstream写, istream读, fstream读写 ### 写文件 + 头文件 + 创建对象`ofstream ofs;` + 打开文件`ofs.open(文件路径, 打开方式)` + `ofs << \"数据\"` + `ofs.close()` > 打开的方式 > > `ios::in`读, `ios::out`写, `ios::ate`文件末尾, `ios::app`追加, `ios::trunc`文件存在先删除,再建立, `ios::binary`二进制 > > 可以使用``进行拼接 ### 读文件 + 头文件 + 创建对象`ifstream ifs;` + 判断是不是打开了`ifs.is_open()` + 打开文件`ifs.open(文件路径, 打开方式)` + 读取数据 + `ofs.close()` 读取数据 1. 直接读取 ```c++ char buf[1024] {0}; while(cin >> buf){ cout << buf << endl; } ``` 2. ```c++ char buf[1024] {0}; while(ifs.getline(buf, sizeof(buf))){ cout << buf << endl; } ``` 3. ```c++ string buf; while(getline(ifs, buf)){ cout << buf << endl; } ``` 4. ```c++ char c; while((c ifs.get()) ! EOF){ cout << c; } ``` ### 二进制 打开的时候使用二进制的模式 `ostream& write(const char *buffer, int len)` `ostream& read(const char *buffer, int len)`"},"/note/编程基础/cpp/2025-1-26-多线程.html":{"title":"多线程","content":"# 多线程 ## 线程库 常用函数 函数 作用 : : : : void join() 等待线程结束并清理资源（会阻塞） bool joinable() 返回线程是否可以执行join函数 void detach() 将线程与调用其的线程分离，彼此独立执行（此函数必须在线程创建时立即调用，且调用此函数会使其不能被join） std::thread::id get_id() 获取线程id thread& operator (thread &&rhs) 见移动构造函数（如果对象是joinable的，那么会调用`std::terminate()`结果程序） ### 线程创建 ```cpp #include <thread> std::thread t(function_name, args...); ``` 实际使用 ```cpp #include <iostream> #include <thread> void printHello(){ std::cout << \"Hello from Worker Thread \" << std::this_thread::get_id() << std::endl; } int main(void){ std::thread t(printHello); std::cout << \"Hello from Main Thread \" << std::this_thread::get_id() << std::endl; t.join(); // 等待线程t结束 return 0; } ``` 线程后台运行, 之后不可以再使用join()进行捕获 ```cpp t.detach() ``` ### 传参 函数再传递变量的时候不要使用局部变量, 可以使用`std::ref`类型进行修饰, 使用`cref`进行修饰的时候这一个是const类型的 ```cpp void printHello(int a){ std::cout << \"Hello\" << a << \" from Worker Thread \" << std::this_thread::get_id() << std::endl; } int main(void){ int a 10; std::thread t(printHello, std::ref(a)); // 创建线程t t.join(); // 等待线程t结束 return 0; } ``` 在传参的时候如果使用的是一个指针或者引用的时候, 指向的是一个局部变量有可能会出错 使用的时候注意使用一个类作为函数的入口的时候, 这一个类不要被提前释放 ```cpp class MyThread{ public: void printHello(int a){ std::cout << \"Hello\" << a << \" from Worker Thread \" << std::this_thread::get_id() << std::endl; } }; int main(void){ int a 10; std::thread t(&MyThread::printHello, std::ref(a)); // 创建线程t return 0; } ``` 使用指针时候可以使用智能指针, 这一个会在所有的都不再使用时候才对对象进行释放 `std::shared_ptr<MyThread> t std::make_shared<MyThread>();` ### 互斥量 #### mutex ```cpp std::mutex mtx; mtx.lock(); n++; mtx.unlock(); ``` 可以使用`bool try_lock()`尝试进行上锁 #### 原子变量 也可以使用atomic变量, 自动进行变量的保护 ```cpp #include <iostream> #include <thread> // #include <mutex> //这个例子不需要mutex了 #include <atomic> using namespace std; atomic_int n 0; void count10000() { \tfor (int i 1; i < 10000; i++) { \t\tn++; \t} } int main() { \tthread th[100]; \tfor (thread &x : th) \t\tx thread(count10000); \tfor (thread &x : th) \t\tx.join(); \tcout << n << endl; \treturn 0; } ``` #### std::recursive_mutex std::recursive_mutex 允许同一个线程对互斥量多次上锁（即递归上锁） #### lock_guard 还可以使用变量lock_guard, 使用这个变量的时候可以自动避免死锁, 在创建的时候尝试获取资源, 超出作作用域的时候自动释放 ```cpp #include <thread> #include <mutex> #include <iostream> int g_i 0; std::mutex g_i_mutex; // 保护 g_i void safe_increment() { std::lock_guard<std::mutex> lock(g_i_mutex); ++g_i; std::cout << std::this_thread::get_id() << \": \" << g_i << '\\n'; // g_i_mutex 在 lock 离开作用域时自动释放 } int main() { std::cout << __func__ << \": \" << g_i << '\\n'; std::thread t1(safe_increment); std::thread t2(safe_increment); t1.join(); t2.join(); std::cout << __func__ << \": \" << g_i << '\\n'; } ``` #### std::time_mutex std::time_mutex 比 std::mutex 多了两个成员函数，try_lock_for()，try_lock_until()。 try_lock_for 函数接受一个时间范围，表示在这一段时间范围之内线程如果没有获得锁则被阻塞住（与 std::mutex 的 try_lock() 不同，try_lock 如果被调用时没有获得锁则直接返回 false），如果在此期间其他线程释放了锁，则该线程可以获得对互斥量的锁，如果超时（即在指定时间内还是没有获得锁），则返回 false。 #### std::unique_lock 提供比 std::lock_guard 更灵活的锁管理，可以手动释放和重新获得锁，还支持定时锁定。 ```cpp #include <mutex> #include <chrono> std::mutex mtx; void function() { std::unique_lock<std::mutex> lock(mtx); // 访问共享资源 // 可以手动释放锁 lock.unlock(); // 可以重新获得锁 lock.lock(); // 可以进行定时锁定 if (lock.try_lock_for(std::chrono::seconds(1))) { // 成功获得锁 } } ``` > 注: C++11以后得static变量是线程安全的 #### std::condition_variable 当 std::condition_variable 对象的某个 wait 函数被调用的时候，它使用 std::unique_lock(通过 std::mutex) 来锁住当前线程。当前线程会一直被阻塞，直到另外一个线程在相同的 std::condition_variable 对象上调用了 notification 函数来唤醒当前线程 ```cpp #include <iostream> // std::cout #include <thread> // std::thread #include <mutex> // std::mutex, std::unique_lock #include <condition_variable> // std::condition_variable std::mutex mtx; // 全局互斥锁. std::condition_variable cv; // 全局条件变量. bool ready false; // 全局标志位. void do_print_id(int id) { std::unique_lock <std::mutex> lck(mtx); while (!ready) // 如果标志位不为 true, 则等待... cv.wait(lck); // 当前线程被阻塞, 当全局标志位变为 true 之后, // 线程被唤醒, 继续往下执行打印线程编号id. std::cout << \"thread \" << id << '\\n'; } void go() { std::unique_lock <std::mutex> lck(mtx); ready true; // 设置全局标志位为 true. cv.notify_all(); // 唤醒所有线程. } int main() { std::thread threads[10]; // spawn 10 threads: for (int i 0; i < 10; ++i) threads[i] std::thread(do_print_id, i); std::cout << \"10 threads ready to race...\\n\"; go(); // go! for (auto & th:threads) th.join(); return 0; } ``` > *wait*函数还可以接受一个谓词（Predicate），这是一个返回布尔值的函数或Lambda表达式。只有当谓词返回*false*时，*wait*才会阻塞线程。当线程被唤醒并且谓词返回*true*时，阻塞才会解除。 使用`wait_for`可以指定等待的时间 ```cpp void worker() { std::unique_lock<std::mutex> lock(mtx); // 等待条件变量，最多等待500毫秒 if (cv.wait_for(lock, std::chrono::milliseconds(500), [] { return ready; })) { std::cout << \"Worker thread is running\" << std::endl; } else { std::cout << \"Timed out waiting\" << std::endl; } } ``` wait_until 可以指定一个时间点，在当前线程收到通知或者指定的时间点 abs_time 超时之前，该线程都会处于阻塞状态。而一旦超时或者收到了其他线程的通知，wait_until 返回，剩下的处理步骤和 wait_until() 类似。 #### std::condition_variable_any 与 std::condition_variable 类似，只不过std::condition_variable_any 的 wait 函数可以接受任何 lockable 参数，而 std::condition_variable 只能接受 `std::unique_lock<std::mutex> `类型的参数，除此以外，和 std::condition_variable 几乎完全一样。 ### 线程池 ```cpp #include <condition_variable> #include <functional> #include <queue> #include <thread> #include <iostream> class ThreadPool { public: ThreadPool(int numThreads) : stop(false) { for (int i 0; i < numThreads; ++i) { // 创建线程并将线程函数设置为从任务队列中取出任务并执行 threads.emplace_back([this] { while (true) { std::unique_lock<std::mutex> lock(mutex); // 等待任务队列不为空或者线程池停止 condition.wait(lock, [this] { return stop !tasks.empty(); }); if (stop && tasks.empty()) { return; } std::function<void()> task(std::move(tasks.front())); tasks.pop(); lock.unlock(); task(); // 执行任务 } }); } } ~ThreadPool() { { std::unique_lock<std::mutex> lock(mutex); stop true; } condition.notify_all(); for (std::thread& thread : threads) { thread.join(); } } template<typename F, typename... Args> void enqueue(F&& f, Args&&... args) { // 将任务包装成 std::function<void()> 类型并放入任务队列 std::function<void()> task(std::bind(std::forward<F>(f), std::forward<Args>(args)...)); { std::unique_lock<std::mutex> lock(mutex); tasks.emplace(std::move(task)); // 将任务放入队列 } condition.notify_one(); } private: std::vector<std::thread> threads; std::queue<std::function<void()>> tasks; std::mutex mutex; std::condition_variable condition; bool stop; }; int main() { ThreadPool pool(4); for (int i 0; i < 8; ++i) { pool.enqueue([i] { std::cout << \"Task \" << i << \" is running in thread \" << std::this_thread::get_id() << std::endl; std::this_thread::sleep_for(std::chrono::seconds(1)); std::cout << \"Task \" << i << \" is done\" << std::endl; }); } return 0; } ``` ## 单次调用 std::call_once的使用 **std::call_once** 接受三个参数：一个 **std::once_flag** 对象，一个可调用对象，以及传递给这个可调用对象的参数。它保证无论有多少线程尝试调用这个函数，可调用对象只会被执行一次。 ```cpp #include <mutex> #include <iostream> #include <thread> std::once_flag flag1; void simple_do_once() { std::call_once(flag1, [](){ std::cout << \"Simple example: called once\\n\"; }); } int main() { std::thread st1(simple_do_once); std::thread st2(simple_do_once); std::thread st3(simple_do_once); std::thread st4(simple_do_once); st1.join(); st2.join(); st3.join(); st4.join(); } ``` ## 多线程http ```bash git clone https://gitee.com/fishros/cpp httplib.git ``` 这个库只需要头文件即可 ```cmake include_directories(include) ``` ![image 20260118163429265](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601181634367.png) ### 使用 #### client ```cpp #include <iostream> #include <thread> #include <chrono> #include <functional> #include <cpp httplib/httplib.h> class Download{ private: public: void download(const std::string &host, const std::string &path, const std::function<void(const std::string &, const std::string &)> &callback_word_count) { httplib::Client cli(host.c_str()); auto res cli.Get(path.c_str()); if (res && res >status 200) { std::cout << \"Downloaded data from \" << host + path << \": \" << res >body.substr(0, 50) << \"...\" << std::endl; callback_word_count(host, res >body); } else { std::cout << \"Failed to download data from \" << host + path << std::endl; } } void start_download(const std::string &host, const std::string &path, const std::function<void(const std::string &, const std::string &)> &callback_word_count) { auto download_func std::bind(&Download::download, this, host, path, callback_word_count); std::thread download_thread(download_func, host, path, callback_word_count); download_thread.detach(); } }; int main() { Download downloader; auto word_count_callback [](const std::string &path, const std::string &result) { // 计算单词数 size_t word_count std::count_if(result.begin(), result.end(), [](char c) { return std::isspace(c); }) + 1; std::cout << \"Word count from \" << path << \": \" << word_count << std::endl; }; downloader.start_download(\"www.example.com\", \"/\", word_count_callback); downloader.start_download(\"www.iana.org\", \"/domains/reserved\", word_count_callback); // 主线程等待一段时间以确保下载线程完成 std::this_thread::sleep_for(std::chrono::seconds(5)); return 0; } ``` ## python合作 [python调用C++混合编程：VScode配置pybind11环境(windows)_vscode pybind11 CSDN博客](https://blog.csdn.net/qq_35863477/article/details/141507342)"},"/note/编程基础/c/2023-6-19-C语言程序设计.html":{"title":"C语言程序设计","content":" layout: post title: \"C语言程序设计\" date: 2023 6 18 15:39:08 +0800 tags: 操作系统 # C语言程序设计 ## 编译链接 ![image 20230619135439864](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242257428.png) > 指令只有一行, 无结尾 > > 语句可以有多行, 以;结尾"},"/note/编程基础/c/2023-6-16-c监控.html":{"title":"","content":"``` gcc mwindows gui.cpp o guinocmd.exe ``` > 编译之后不会显示窗口, 但是测试之后不行 ## 服务器Linux ```c //socket 套接字, 用来进行网络通讯 #include <string.h> #include <stdio.h> #include <sys/types.h> #include <sys/socket.h> #include <netinet/in.h> #include <unistd.h> #include <arpa/inet.h> #include <stdlib.h> int main() { //windows 网络套接字 进行版本匹配 一般使用2.2 //打电话 //1.安装电话机 //使用socket函数, 选择协议IPv4, 第二个是流式套接字TCP int sock socket(PF_INET, SOCK_STREAM, 0); \tint hServSock socket(PF_INET, SOCK_STREAM, 0); //2.电话卡分配号码 //ip地址 端口号 struct sockaddr_in servAddr; //使用ipa4 servAddr.sin_family AF_INET; //这里是ip地址,自动获取本地地址 servAddr.sin_addr.s_addr htonl(INADDR_ANY); servAddr.sin_port htons(6280); bind(hServSock, (struct sockaddr*)&servAddr, sizeof(servAddr));//绑定 //3.接入电话网络, 开始监听, 同一时间最多5个 listen(hServSock, 5); //4.接电话, 建立对方的 //int hClntSock;//对方和这个在进行交流 //保存对方的ip地址端口号 //struct sockaddr_in clntAddr; //int clntAddrSz sizeof(clntAddr); //hClntSock accept(hServSock, (struct sockaddr*)&clntAddr, &clntAddrSz); //5.说话 //printf(\"%s 链接成功\\n\", inet_ntoa(clntAddr.sin_addr)); \tint choice; \tchar buf[1024]; \tchar select; \tint hClntSock; \tstruct sockaddr_in clntAddr; \twhile(1) \t{ \t\tint clntAddrSz sizeof(clntAddr); \t\tprintf(\"是否等待下一次链接？\\n\"); \t\tscanf(\"%c\", &select); \t\tgetchar(); \t\tif(select! 'y') \t\t{ \t\t\tbreak; \t\t} \t\tprintf(\"等待链接。。。\\n\"); \t\thClntSock accept(hServSock, (struct sockaddr*)&clntAddr, &clntAddrSz); \t\tprintf(\"链接成功\\n\"); \t\tprintf(\"是否链接y/n\\n\"); \t\tscanf(\"%c\", &select); \t\tgetchar(); \t\t//printf(\"%c\\n\", select); \t\tif(select! 'y') \t\t{ \t\t\tsend(hClntSock, \"6\", 2, 0); \t\t\tbreak; \t\t} \t\twhile(1) \t\t{ \t\t\tsystem(\"clear\"); \t\t\tprintf(\"1.关机\\n\"); \t\t\tprintf(\"2.注销\\n\"); \t\t\tprintf(\"3.重启\\n\"); \t\t\tprintf(\"4.恶搞\\n\"); \t\t\tprintf(\"5.来\\n\"); \t\t\tprintf(\"6.关闭客户端\\n\"); \t\t\tscanf(\"%d\", &choice); \t\t\tgetchar(); \t\t\tif(choice< 0choice>6) \t\t\t{ \t\t\t\tcontinue; \t\t\t}//数字转化为字符串 \t\t\tsprintf(buf, \"%d\", choice); \t\t\t \t\t\tsend(hClntSock, buf, 1024, 0); \t \t\t\trecv(hClntSock, buf, 1024, 0); \t\t\tif(!strcmp(buf, \"Y\")) \t\t\t{ \t\t\t\tcontinue; \t\t\t} \t\t\tprintf(\"对方下线\\n\"); \t\t\tclose(hClntSock); \t\t\tselect 0; \t\t\tbreak; \t\t} \t} close(hServSock); return 0; } ``` ## 客户端 ```c //被监控的 //socket 套接字, 用来进行网络通讯 #include <stdio.h> #include <winsock2.h> //windows套接字头文件 #pragma comment(lib, \"ws2_32.lib\") //windows套接字库文件 #include<windows.h> void hindWindows(){ HWND hwnd; \thwnd FindWindow(\"ConsoleWindowClass\",NULL);\t \tif(hwnd) \t{ \t\tShowWindow(hwnd,SW_HIDE);//设置指定窗口的显示状态 \t} } int main() { hindWindows(); WSADATA wsadata; WSAStartup(MAKEWORD(2, 2), &wsadata); //准备电话机 SOCKET hClntSock socket(PF_INET, SOCK_STREAM, 0); int c; //知道对方的号码, 端口号, 服务端 //ip地址 端口号 SOCKADDR_IN servAddr; //使用ipa4 servAddr.sin_family AF_INET; //这里是ip地址,自动获取本地地址 servAddr.sin_addr.s_addr inet_addr(\"114.55.226.26\");//服务器的ip地址 //servAddr.sin_addr.s_addr inet_addr(\"192.168.31.168\");//服务器的ip地址 //servAddr.sin_addr.s_addr inet_addr(\"108.0.105.0\");//服务器的ip地址 servAddr.sin_port htons(6280); connect(hClntSock, (SOCKADDR*)&servAddr, sizeof(servAddr)); //拨打电话 char buf[1024]; while(1){ recv(hClntSock, buf, 1024, 0); printf(\"%s\\n\", buf); int ret atoi(buf); if(ret 1) { system(\"shutdown s t 180\"); MessageBox(NULL,\"快保存文件,三分钟后关机\",\"芜湖\",MB_OK); //printf(\"六十秒关机\\n\"); }else if(ret 2) { //system(\"shutdown l\"); //printf(\"六十秒注销\\n\"); }else if(ret 3) { system(\"shutdown r t 180\"); MessageBox(NULL,\"快保存文件,三分钟后重启\",\"芜湖\",MB_OK); //printf(\"六十秒重启\\n\"); }else if(ret 4) { //system(\"shutdown l\"); //printf(\"恶搞\\n\"); while(1){ c MessageBox(NULL,\"焦浩洋是你爸爸, 请确认\",\"芜湖\",MB_OKCANCEL); if(c 1) { //send(hClntSock, \"对方确认\", 2, 0); break; } } }else if(ret 5) { //system(\"shutdown l\"); //printf(\"来\\n\"); }else if(ret 6) { //system(\"shutdown l\"); //printf(\"退出\\n\"); send(hClntSock, \"N\", 2, 0); break; } send(hClntSock, \"Y\", 2, 0); } //system(\"pause\"); WSACleanup(); return 0; } ``` ## 遇到的问题 + 使用`getchar()`进行处理回车 + linux上面不能使用Windows上面定义的一些关键字 +"},"/note/编程基础/C陷阱与缺陷/2022-8-27-语义陷阱.html":{"title":"函数","content":" layout: post title: \"函数\" date: 2022 8 23 15:39:08 +0800 tags: C陷阱与缺陷 # 语义陷阱 ## 指针数组 C语言只有一维数组, 但是数组的元素可以为任意的类型, 因此可以创建多维数组"},"/note/编程基础/C陷阱与缺陷/2022-8-26-函数.html":{"title":"函数","content":" layout: post title: \"函数\" date: 2022 8 23 15:39:08 +0800 tags: C陷阱与缺陷 # 函数 ## 优先级 优先级最高的不是真正的运算符, 数组的下标, 函数的调用, 结构体操作符等 之后是单目运算符 然后是双目运算符, 算术运算符优先级最高, 之后是移位运算符, 然后是逻辑运算符, 三目运算符, 最后是赋值运算符 关系运算符的优先级并不一样, 和! 的优先级要低一点 位运算符也有优先级的顺序, &, ^, , &&, , ?:, 依次降低只要是为了对之前的语言的兼容 赋值运算符的运算顺序是从右到左 ## else 始终与同一对括号中最近的if进行结合 ```C if(x 0) if(y 0)error(); else{ \tz x+y; f(&z); } ``` ```c if(x 0) { if(y 0)error(); }else{ z x+y; f(&z); } ``` 第一个else会和最近的if进行结合"},"/note/编程基础/index.html":{"title":"","content":"# 编程基础"},"/note/编程基础/python/基础语法/2024-4-27-12迭代器.html":{"title":"迭代器","content":" layout: post title: \"迭代器\" date: 2024 4 27 15:39:08 +0800 tags: python基础 # 迭代器 使用for循环遍历一个class 在原来的数据基础上面取下一个 > 验证一个函数是不是可以迭代, 实际检测的是这一个类里面没有没有`__iter__`这一个方法 > > ```python > from collections.abc import Iterable > from collections.abc import Iterator > isinstance(测试的类型, Iterable) # 看是不是可迭代的 > isinstance(测试的类型, Iterator) # 看是不是一个迭代器 > ``` > > 可以使用`iter`获取一个对象的迭代器, 之后可以使用`next`依次获取下一个对象 ```python from collections.abc import Iterable nums [11, 22, 33, 44, 55] print(isinstance(nums, Iterable)) # Output: True iter_obj iter(nums) print(isinstance(iter_obj, Iterable)) # Output: True print(next(iter_obj)) # Output: 11 print(next(iter_obj)) # Output: 22 print(next(iter_obj)) # Output: 33 print(next(iter_obj)) # Output: 44 print(next(iter_obj)) # Output: 55 print(next(iter_obj)) # Output: StopIteration ``` > 取数据的时候超出长度的时候会出现一个错误, for循环里面有一个错误处理 ## 自己定义 使用两个方法`__iter__`和`__next__` ### `__iter__` 这一个会返回一个迭代器 ### `__next__` 可以返回下一个元素的位置 ```python class MyList(object): def __init__(self) > None: self.items [] def add(self, item): self.items.append(item) def __iter__(self): return MyIterator(self) class MyIterator(object): def __init__(self, my_list) > None: self.index 0 self.my_list my_list def __next__(self): if self.index < len(self.my_list.items): item self.my_list.items[self.index] self.index + 1 return item else: raise StopIteration def __iter__(self): return self my_list MyList() my_list.add(4) my_list.add(5) my_list.add(6) for i in my_list: print(i) # Output: # 4 # 5 # 6 ``` > 这里使用两个类的时候, 这一个类可以多次被for循环调用 ## 其他使用 不只是for循环可以使用迭代器, `list()`之类的函数也可以使用迭代器 ```python list2 list(my_list) print(list2) ``` > ```bash > PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" > [4, 5, 6] > ```"},"/note/编程基础/python/基础语法/2024-4-23-04常用函数.html":{"title":"常用函数","content":" layout: post title: \"常用函数\" date: 2024 4 23 15:39:08 +0800 tags: python基础 # 常用函数 ## 内建函数 在python里面可以直接使用的函数, 不需要使用import从其他文件里面导入 可以使用`dir(__builtin__)`进行查看 ## 输入输出 ### print打印信息 ```python print(*objects, sep ' ', end '\\n', file sys.stdout, flush False) ``` > objects 复数，表示可以一次输出多个对象。输出多个对象时，需要用 , 分隔。 > sep 用来间隔多个对象，默认值是一个空格。 > end 用来设定以什么结尾。默认值是换行符 \\n，我们可以换成其他字符串。 > file 要写入的文件对象。 > flush 输出是否被缓存通常决定于 file，但如果 flush 关键字参数为 True，流会被强制刷新。 #### 基本使用 可以把数据打印到终端里面 1. 可以直接打印一个变量, 里面没有数据的时候会打印一个换行 2. 里面是一个表达式的时候, 会打印这一个表达式的结果 3. 可以在里面使用逗号分割变量, 实际的打印信息会使用空格分割 #### 格式化字符串 使用双引号里面 格式符号 转换 : : `%c` 字符 `%s` 字符串, 实际使用的时候也可以打印整形浮点型之类的数据, 不确定这一个的类型的时候可以使用这一个 `%d` 有符号十进制整数 `%u` 无符号十进制整数 `%o` 八进制整数 `%x` 十六进制整数（小写字母`0x`） `%X` 十六进制整数（大写字母`0X`） `%f` 浮点数 `%e` 科学计数法（小写`'e'`） `%E` 科学计数法（大写`“E”`） `%g` `％f`和`％e `的简写 `%G` `％f`和`％E`的简写 ```c age 10 print(\"我今年%d岁\" % age) age + 1 print(\"我今年%d岁\" % age) age + 1 print(\"我今年%d岁\" % age) ``` > 传入多个数据的时候, 需要使用一个括号括起来 > > ```python > print(\"my name id %s, my age id %d id :%s\" % (\"jiao\", 21, \"1231002004\")) > ``` #### 占位符 在Python中，print函数用于将内容输出到控制台。当使用print函数时，用{}来表示占位符，可以在字符串中插入变量的值。例如： ```python name \"Alice\" age 30 print(\"My name is {} and I am {} years old.\".format(name, age)) ``` 在上面的例子中，{}会被name和age的值替换，输出结果为\"My name is Alice and I am 30 years old.\" ```python >>>\"{} {}\".format(\"hello\", \"world\") # 不设置指定位置，按默认顺序 'hello world' >>> \"{0} {1}\".format(\"hello\", \"world\") # 设置指定位置 'hello world' >>> \"{1} {0} {1}\".format(\"hello\", \"world\") # 设置指定位置 'world hello world' ``` ```python print(\"网站名：{name}, 地址 {url}\".format(name \"菜鸟教程\", url \"www.runoob.com\")) # 通过字典设置参数 site {\"name\": \"菜鸟教程\", \"url\": \"www.runoob.com\"} print(\"网站名：{name}, 地址 {url}\".format(**site)) # 通过列表索引设置参数 my_list ['菜鸟教程', 'www.runoob.com'] print(\"网站名：{0[0]}, 地址 {0[1]}\".format(my_list)) # \"0\" 是必须的 ``` ```python class AssignValue(object): def __init__(self, value): self.value value my_value AssignValue(6) print('value 为: {0.value}'.format(my_value)) # \"0\" 是可选的 ``` 数字 格式 输出 描述 : : : : 3.1415926 {:.2f} 3.14 保留小数点后两位 3.1415926 {:+.2f} +3.14 带符号保留小数点后两位 1 {: .2f} 1.00 带符号保留小数点后两位 2.71828 {:.0f} 3 不带小数 5 {:0>2d} 05 数字补零 (填充左边, 宽度为2) 5 {:x<4d} 5xxx 数字补x (填充右边, 宽度为4) 10 {:x<4d} 10xx 数字补x (填充右边, 宽度为4) 1000000 {:,} 1,000,000 以逗号分隔的数字格式 0.25 {:.2%} 25.00% 百分比格式 1000000000 {:.2e} 1.00e+09 指数记法 13 {:>10d} 13 右对齐 (默认, 宽度为10) 13 {:<10d} 13 左对齐 (宽度为10) 13 {:^10d} 13 中间对齐 (宽度为10) 11 `'{:b}'.format(11) '{:d}'.format(11) '{:o}'.format(11) '{:x}'.format(11) '{:#x}'.format(11) '{:#X}'.format(11)` `1011 11 13 b 0xb 0XB` 进制 **^**, **<**, **>** 分别是居中、左对齐、右对齐，后面带宽度， **:** 号后面带填充的字符，只能是一个字符，不指定则默认是用空格填充。 **+** 表示在正数前显示 **+**，负数前显示 ** **； （空格）表示在正数前加空格 b、d、o、x 分别是二进制、十进制、八进制、十六进制。 此外我们可以使用大括号 **{}** 来转义大括号，如下实例： ```python print (\"{} 对应的位置是 {{0}}\".format(\"runoob\")) runoob 对应的位置是 {0} ``` ### input输入 会让程序停止, 等待输入 ```python input(\"请输入数据\") ``` > 可以填一个输入的提示语, 返回值是输入的数据的字符串 ## 数据转换 ### int 把一个字符串转换为整数, 这一个里面必须都是数字 ### tuple, set, liset 列表, 元组, 集合的相互转换, 这几个转换的时候不是改变之前的数据, 是返回一个新的数据 可以使用set进行快速去重 ## random ### 随机数 ```python import random random.randint(start, stop) ``` > **start** 必需， 一个整数，指定开始值（包含在范围内），即生成的随机整数可以取到这个值。 > > **stop** 必需， 一个整数，指定结束值（包含在范围内），即生成的随机整数可以取到这个值。 ### 数组乱序 ```python import random nums [1, 2, 3, 4, 5, 6] randoms.shuffle(nums) # 洗牌 randoms.choice(nums) # 随机获取一个 ``` ## 迭代 ### range ```python range(start, stop[, step]) ``` > start: 计数从 start 开始。默认是从 0 开始。例如range（5）等价于range（0， 5）; > > stop: 计数到 stop 结束，**但不包括 stop**。例如：range（0， 5） 是[0, 1, 2, 3, 4]没有5 > > step：步长，默认为1。例如：range（0， 5） 等价于 range(0, 5, 1) ```python >>>x 'runoob' >>> for i in range(len(x)) : ... print(x[i]) ... r u n o o b ``` > 在python里面这一个函数返回一个数组, python3里面返回的是一个可迭代的对象 > > ```bash > In [2]: print(type(range(1, 10))) > <class 'range'> > ``` ## 可迭代对象处理 ### map映射处理 使用提供的函数对一个序列进行映射 ```python map(function, iterable, *iterables) ``` > 返回一个将 function 应用于 *iterable* 的每一项，并产生其结果的迭代器。 如果传入了额外的 iterables 参数，则 function 必须接受相同个数的参数并被用于到从所有可迭代对象中并行获取的项。 ```python a map(lambda x: x*x, [1, 2, 3]) print(a) for temp in a: print(temp) ``` > ```bash > PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" > <map object at 0x000001EFB54D76D0> > 1 > 4 > 9 > ``` ```python a map(lambda x, y: x+y , [1, 2, 3], [4, 5, 6]) for temp in a: print(temp) ``` > ```bash > PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" > 5 > 7 > 9 > ``` ```python def f1(x, y): return {x:y} l1 [0, 1, 2, 3, 4, 5, 6] l2 ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'] a map(f1, l1, l2) print(list(a)) ``` > ```bash > PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" > [{0: 'Sun'}, {1: 'Mon'}, {2: 'Tue'}, {3: 'Wed'}, {4: 'Thu'}, {5: 'Fri'}, {6: 'Sat'}] > ``` ### filter过滤 ```python filter(function, iterable) ``` > 使用 *iterable* 中 *function* 返回真值的元素构造一个迭代器。 *iterable* 可以是一个序列，一个支持迭代的容器或者一个迭代器。 如果 *function* 为 `None`，则会使用标识号函数，也就是说，*iterable* 中所有具有假值的元素都将被移除。 ### reduce遍历处理 python3 中，函数被移到了functools模块中 ```python functools.reduce(function, iterable[, initializer]) ``` > 将两个参数的 *function* 从左至右积累地应用到 *iterable* 的条目，以便将该可迭代对象缩减为单一的值。 例如，`reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])` 是计算 `((((1+2)+3)+4)+5)` 的值。 左边的参数 *x* 是积累值而右边的参数 *y* 则是来自 *iterable* 的更新值。 如果存在可选项 *initializer*，它会被放在参与计算的可迭代对象的条目之前(初始值)，并在可迭代对象为空时作为默认值。 如果没有给出 *initializer* 并且 *iterable* 仅包含一个条目，则将返回第一项。 ```python from functools import reduce a reduce(lambda x, y: x + y, [1, 2, 3, 4, 5]) print(a) ``` > ```bash > PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" > 15 > ``` 每一次的返回值会给x, 遍历获取下一个数值给y ```python from functools import reduce a reduce(lambda x, y: x + y, [1, 2, 3, 4, 5], 5) print(a) ``` > 5+1+2+3+4+5 20 ## 字符串操作 ### 获取字符串特征 ```python str1 'hello, world!' # 通过内置函数len计算字符串的长度 print(len(str1)) # 13 # 检查字符串是否以指定的字符串开头 print(str1.startswith('He')) # False print(str1.startswith('hel')) # True # 检查字符串是否以指定的字符串结尾 print(str1.endswith('!')) # True str2 'abc123456' # 检查字符串是否由数字构成 print(str2.isdigit()) # False # 检查字符串是否以字母构成 print(str2.isalpha()) # False # 检查字符串是否以数字和字母构成 print(str2.isalnum()) # True str3 ' jackfrued@126.com ' print(str3) ``` ### 格式化操作 ```python # 获得字符串首字母大写的拷贝 print(str1.capitalize()) # Hello, world! # 获得字符串每个单词首字母大写的拷贝 print(str1.title()) # Hello, World! # 获得字符串变大写后的拷贝 print(str1.upper()) # HELLO, WORLD! # 将字符串以指定的宽度居中并在两侧填充指定的字符 print(str1.center(50, '*')) # 将字符串以指定的宽度靠右放置左侧填充指定的字符 print(str1.rjust(50, ' ')) # 获得字符串修剪左右两侧空格之后的拷贝 print(str3.strip()) ``` ### 查找 ```python # 与find类似但找不到子串时会引发异常 # print(str1.index('or')) # print(str1.index('shit')) # 从字符串中查找子串所在位置 print(str1.find('or')) # 8 print(str1.find('shit')) # 1 # 从右侧开始找, 可以使用这一个获取后缀名 print(str1,rfind(\"0\")) # 查看里面有没有 print(if 'a' in str1) ``` ### 替换 ```python # 替换字符串里面的字符, 返回新的, 原来的不改变 # str.replace(old, new[, max]), 可选参数, 替换的次数 test_srt \"Hello, World!\" print(test_srt.replace(\"World\", \"Python\")) print(test_srt) ''' Hello, Python! Hello, World! ''' ``` ### 切片 ```python str.split(str \"\", num string.count(str)). ``` > str 分隔符，默认为所有的空字符，包括空格、换行(\\n)、制表符(\\t)等。 > > num 分割次数。默认为 1, 即分隔所有。 > > 这一个函数的返回值是一个字符串的数组 ```python str.partition(str) ``` > partition() 方法用来根据指定的分隔符将字符串进行分割，返回一个3元的元组，第一个为分隔符左边的子串，第二个为分隔符本身，第三个为分隔符右边的子串。 ```python str.splitlines(str) ``` > `splitlines()`是Python字符串对象的一个方法，用于按照字符串中的换行符将字符串拆分为多行。它会返回一个包含拆分后每行内容的列表。 ### 拼接 ```python str.join(sequence) symbol \" \"; seq (\"a\", \"b\", \"c\"); # 字符串序列 print symbol.join( seq ); # a b c ``` > join() 方法用于将序列中的元素以指定的字符连接生成一个新的字符串。join里放列表、字符串、字典也是可以的 ## 列表操作 ### 添加 ```python # 在后面插入, 追加(只添加一个元素) list.append(new) # 拼接链表, 把新的链表拼接在前面 list2.extend(list1) # 随机插入, 需要指定位置, 超出长度的时候相当于追加 list3.insert(index, object) ``` ### 删除 ```python # 根据一个下标对元素进行删除 del list[n] # pop删除最后一个元素 list.pop() # 根据一个值进行删除 list.remove(value) ``` ### 修改 ```python list[pos] new_value ``` ### 查 ```python # 查看里面有没有这一个数据 value in list value not in list # 查看某一个数据的个数 list.count(\"value\") ``` ### 排序 ```python # 排序, 默认为从小到大 list.sort() # 从大到小 list.sort(reverse True) # 倒序 list.reverse() ``` ### enumerate枚举化 ```python enumerate(sequence, [start 0]) ``` ```python >>> seasons ['Spring', 'Summer', 'Fall', 'Winter'] >>> list(enumerate(seasons)) [(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')] >>> list(enumerate(seasons, start 1)) # 下标从 1 开始 [(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')] ``` ## 字典 ### 查找 dict[key]如果这一个key不存在的话, 会导致报错 ```python # 安全的方法 dict.get(key) ``` > 使用这一个方法, 不存在的时候会返回一个NULL, 可以传入第二个参数, 会使用这一个参数作为没有时候的返回值 ### 添加数据 ```python dict.[newkey] value ``` > 如果这一个值不存在的话, 这一个键值对会进行增加 ### 删除 ```python # 删除其中一个键值对 del dict.[key] # 清空一个字典 dict.clear() # 删除这一个字典 del dict ``` ### 排序 使用sort的时候, 不能对一个字典里列表面的数据进行排序, 这时候可以设置sort函数的key参数 这一个key指向一个函数, 这一个函数会返回一个用于比较的值 ```python stus [ {\"name\": \"jiao\", \"age\":21}, {\"name\": \"shi\", \"age\":23}, {\"name\": \"dong\", \"age\":19}, ] # def sort_by_age(arg): # return arg[\"age\"] # print(stus) # stus.sort(key sort_by_age) print(stus) stus.sort(key lambda arg: arg[\"age\"]) ``` ```bash PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" [{'name': 'jiao', 'age': 21}, {'name': 'shi', 'age': 23}, {'name': 'dong', 'age': 19}] [{'name': 'dong', 'age': 19}, {'name': 'jiao', 'age': 21}, {'name': 'shi', 'age': 23}] ``` ## 其他函数 可以直接调用的函数 ### len, max, min, del 获取长度, 最大值, 最小值, 删除一个元素 ### isinstance比较类型 [python中isinstance()函数详解_python instance函数 CSDN博客](https://blog.csdn.net/u012813109/article/details/106008885) 判断一个对象是否是一个已知的类型 ```python isinstance(object, classinfo) isinstance(2,int) isinstance(12,(str,int,list)) ``` > classinfo – 可以是直接或间接类名、基本类型或者由它们组成的元组。 isinstance()函数和type()函数很类似。但是两者又有区别，type() 不会认为子类是一种父类类型，不考虑继承关系。isinstance() 会认为子类是一种父类类型，考虑继承关系。 ````python class A: pass class B(A): pass isinstance(A(), A) # returns True type(A()) A # returns True isinstance(B(), A) # returns True type(B()) A # returns False ```` ### hasattr查看参数 ```python hasattr(object, name) ``` > 查看一个对象里面有没有一个属性"},"/note/编程基础/python/基础语法/2023-9-23-01基础运算.html":{"title":"基础运算","content":" layout: post title: \"基础运算\" date: 2023 9 23 15:39:08 +0800 tags: python基础 # 基础运算 > 可以使用type获取一个变量的类型 常见的数据类型 + 整形, 可以存储任意大小的整数, 支持二进制（如`0b100`，换算成十进制是4）、八进制（如`0o100`，换算成十进制是64）、十进制（`100`）和十六进制（`0x100`，换算成十进制是256）的表示法。 + 浮点型：浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，浮点数除了数学写法（如`123.456`）之外还支持科学计数法（如`1.23456e2`） + 字符串型：字符串是以单引号或双引号括起来的任意文本，比如`'hello'`和`\"hello\"`,字符串还有原始字符串表示法、字节字符串表示法、Unicode字符串表示法，而且可以书写成多行的形式（用三个单引号或三个双引号开头，三个单引号或三个双引号结尾）。 + 布尔型：布尔值只有`True`、`False`两种值，要么是`True`，要么是`False`，在Python中，可以直接用`True`、`False`表示布尔值 + 复数型：形如`3+5j`，跟数学上的复数表示一样，唯一不同的是虚部的`i`换成了`j`。 **变量命令** 和C语言相似 常用的模式 + 小写字母下划线连接 + 受保护的属性使用下划线开头 + 是有的实例属性使用两个下划线 **实际的使用** 在Python中可以使用`type`函数对变量的类型进行检查 ```c a 100 b 12.345 c 1 + 5j d 'hello, world' e True print(type(a)) # <class 'int'> print(type(b)) # <class 'float'> print(type(c)) # <class 'complex'> print(type(d)) # <class 'str'> print(type(e)) # <class 'bool'> ``` 可以使用Python中内置的函数对变量类型进行转换。 `int()`：将一个数值或字符串转换成整数，可以指定进制。 `float()`：将一个字符串转换成浮点数。 `str()`：将指定的对象转换成字符串形式，可以指定编码。 `chr()`：将整数转换成该编码对应的字符串（一个字符）。 `ord()`：将字符串（一个字符）转换成对应的编码（整数）。 ```python a int(input('a ')) b int(input('b ')) print('%d + %d %d' % (a, b, a + b)) print('%d %d %d' % (a, b, a b)) print('%d * %d %d' % (a, b, a * b)) print('%d / %d %f' % (a, b, a / b)) print('%d // %d %d' % (a, b, a // b)) print('%d %% %d %d' % (a, b, a % b)) print('%d ** %d %d' % (a, b, a ** b)) ``` > 字符串之后的`%`后面跟的变量值会替换掉占位符然后输出到终端中 > > ```python > In [1]: import keyword > > In [2]: keyword.kwlist > Out[2]: > ['False', > 'None', > 'True', > 'and', > 'as', > 'assert', > 'async', > 'await', > 'break', > 'class', > 'continue', > 'def', > 'del', > 'elif', > 'else', > 'except', > 'finally', > 'for', > 'from', > 'global', > 'if', > 'import', > 'in', > 'is', > 'lambda', > 'nonlocal', > 'not', > 'or', > 'pass', > 'raise', > 'return', > 'try', > 'while', > 'with', > 'yield'] > ``` ### 关键字 ```python False, None, True, and, as, assert, async, await, break, class, continue, def, del elif, else, except, finally, for, from, global, if, import, in, is, lambda, nonlocalnot, or, pass, raise, return, try, while, with, yield ``` ## 运算符 运算符 描述 `[]` `[:]` 下标，切片 `**` 指数 `~` `+` ` ` 按位取反, 正负号 `*` `/` `%` `//` 乘，除，模，整除 `+` ` ` 加，减 `>>` `<<` 右移，左移 `&` 按位与 `^` `` 按位异或，按位或 `< ` `<` `>` `> ` 小于等于，小于，大于，大于等于 ` ` `! ` 等于，不等于 `is` `is not` 身份运算符 `in` `not in` 成员运算符 `not` `or` `and` 逻辑运算符 ` ` `+ ` ` ` `* ` `/ ` `% ` `// ` `** ` `& ` ` ` `^ ` `>> ` `<< ` ### 比较运算符 可以使用连等 ```python 60 < score ``` ### 赋值运算符 python里面可以使用 对多个数据进行赋值 ```python name, age, addr \"jiao\", 18, \"China\" ``` ### 乘号 一个乘号的一侧是一个字符串, 实际是对这一个字符串的重复 ### 除号 使用/进行计算得到的数据是一个浮点数, //得到的数据是一个整形 ### 逻辑运算符 一般情况下, 逻辑运算符里一般左右都是布尔类型 如果左右都是一个数字的时候, 会把一个非零的值作为一个True, 如果判断的结果是True, and返回右侧的数字(两个都是需要判断的), or返回非零的数字, 两个都是非零的数字的时候返回左侧的(先判断的) ```python In [1]: 100 and 200 Out[1]: 200 In [2]: 200 and 100 Out[2]: 100 In [3]: 0 and 200 Out[3]: 0 In [4]: 0 or 200 Out[4]: 200 In [5]: 200 or 0 Out[5]: 200 In [6]: 100 or 200 Out[6]: 100 In [7]: 200 or 100 Out[7]: 200 ``` ### is 和 的区别 Python 中，对于任意的变量都具有三个基本要素：分别是 id，type，value。其中 id 为身份标识，即唯一能识别变量的标志，type 为数据类型，value 为数据值。 ```c >>> a 1 >>> id(a) 140705782725696 >>> type(a) <class 'int'> >>> a 1 ``` “ ” 主要用于判断两个对象的 value 是否相等，属于 Python 标准操作符中的比较运算符。 “is” 主要用来判断两个对象的身份标识，即两者的基本要素 “id”，也叫做同一性运算符。 在 Python 中，整型对象和字符串对象是不可变对象，所以 Python 会很高效地对它们进行缓存。因此在程序上看应该创建新对象时，却并不会创建新对象，而是对它们进行缓存。 但 Python 仅缓存简单整型，因为 Python 认为在程序中这些小整型会经常被用到。而 Python 缓存的值也是有一定范围的，并且是可变的，使用时要注意。 ```python >>> a 1 >>> b 1 >>> a b True >>> a is b True >>> c 1.0 >>> d 1.0 >>> c d True >>> c is d False >>> e \"abc\" >>> f \"abc\" >>> e f True >>> e is f True >>> g [1,2,3] >>> h [1,2,3] >>> g h True >>> g is h False >>> i (1,2,3) >>> j (1,2,3) >>> i j True >>> i is j False ``` ## 条件语句 使用的关键字if , elif, else, 语句之后使用:进行分割 ```python a input(\"请用户输入用户名: \") b input(\"请输入密码: \") if a 'jiao' and b '1234': print(\"用户存在\") elif a 'jiao' b ! '1234': print(\"密码错了\") else: print(\"滚\") ``` ## 循环结构 ### for循环 用于循环遍历一个可迭代的变量 ```c sum 0 for x in range(101): sum + x print(sum) ``` > `range(1, 101)`可以用来构造一个从1到100的范围，当我们把这样一个范围放到`for in`循环中，就可以通过前面的循环变量`x`依次取出从1到100的整数。 `range(101)`：可以用来产生0到100范围的整数，需要注意的是取不到101。 `range(1, 101)`：可以用来产生1到100范围的整数，相当于前面是闭区间后面是开区间。 `range(1, 101, 2)`：可以用来产生1到100的奇数，其中2是步长，即每次数值递增的值。 `range(100, 0, 2)`：可以用来产生100到1的偶数，其中 2是步长，即每次数字递减的值。 ### while循环 `while True:` 可以使用break, continue ### 和else配合使用 ```python while xxx: ... else: ... ``` > 如果退出的时候是这一个判断条件不成立退出的, 会执行这一个else语句, 使用bread进行退出则不会执行 ## 实例 求最大公约数以及最小公倍数 ```python x int(input('x ')) y int(input('y ')) # 如果x大于y就交换x和y的值 if x > y: # 通过下面的操作将y的值赋给x, 将x的值赋给y x, y y, x # 从两个数中较小的数开始做递减的循环 for factor in range(x, 0, 1): if x % factor 0 and y % factor 0: print('%d和%d的最大公约数是%d' % (x, y, factor)) print('%d和%d的最小公倍数是%d' % (x, y, x * y // factor)) break ``` ## 变量 ### 作用域 Python 能够改变变量作用域的代码段是 def 、 class 、 lamda. if/elif/else、try/except/finally、for/while 并不能涉及变量作用域的更改，也就是在这些代码块中的变量，外部也是可以访问的 变量搜索路径是：局部变量 >全局变量 局部变量：在函数内部，类内部，lamda.的变量，它的作用域仅在函数、类、lamda 里面 全局变量：在当前 py 文件都生效的变量 > 可以使用global进行初始化一个变量, 这一个变量作用域为全局变量 ## 占位符 函数或者一个循环里面暂时不打算实现, 可以写一个`pass` ## 三目运算符 ```python 条件成立的时候返回值 if 条件 else 不成立的时候的返回值 ```"},"/note/编程基础/python/基础语法/2024-4-27-14生成器.html":{"title":"生成器","content":" layout: post title: \"生成器\" date: 2024 4 27 15:39:08 +0800 tags: python基础 # 生成器 获取系列有规律但是个数不确定的数据 使用迭代器的时候可以使用一个不会产生异常的迭代器, 实际记录的是生成的数据的方式, 不是实际的数据 使用迭代器的时候这一个规则的改变不方便, 需要加一个专门的方法 还有就是如果需要大量的数据, 而实际使用的时候只用其中一部分, 会浪费大量的空间 > 生成器是一个记录生成数据的方式, 而不是实际的数据的方式, 实际是一个特殊的迭代器 ## 实际定义 ### 方法一 只需要把一个列表的生成`[]`改为`()` ```python nums [x for x in range(5)] nums2 (x for x in range(5)) print(type(nums)) print(type(nums2)) print(nums) print(nums2) ``` > ```bash > PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" > <class 'list'> > <class 'generator'> > [0, 1, 2, 3, 4] > <generator object <genexpr> at 0x000002431C7B2110> > ``` ### 方法二 有时候这一个推导比较复杂, 不能使用for循环实现 这时候可以使用一个函数生成一个生成器 这一个函数返回的时候使用的不是return, 而是使用yeild, 下一次调用的时候会从yeild返回的位置 ```python def fib_generator(): num1 1 num2 1 while True: temp_num num1 num1, num2 num2, num1 + num2 yield temp_num ``` > 这个代码块的返回值是一个生成器, 这一个生成器第一次执行会从def开始直到yield, 调用next的时候会返回yield后面的数值 > > ```python > fib fib_generator() > > print(fib) > print(next(fib)) > print(next(fib)) > print(next(fib)) > print(next(fib)) > print(next(fib)) > ``` > > ```bash > <generator object fib_generator at 0x000002342F7D2110> > 1 > 1 > 2 > 3 > 5 > ``` > > 这一个迭代器执行结束的时候会产生一个异常StopIteration, 如果是使用一个return, 返回的值会成为这一个异常的参数, 可以使用try语句进行捕获 ```python def fib_generator(): num1 1 num2 2 temp_num num1 num1, num2 num2, num1 + num2 yield temp_num temp_num num1 num1, num2 num2, num1 + num2 yield temp_num temp_num num1 num1, num2 num2, num1 + num2 yield temp_num return \"结束了!!!\" fib fib_generator() print(next(fib)) print(next(fib)) print(next(fib)) try: print(next(fib)) except StopIteration as ret: print(ret.value) ``` > ```bash > PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" > 1 > 2 > 3 > 结束了!!! > ``` ### send唤醒 除了使用next还可以使用send发送一个数据给迭代器 ```python def fib_generator(): num1 1 num2 2 temp_num num1 num1, num2 num2, num1 + num2 num yield temp_num print(\"get \", num) temp_num num1 num1, num2 num2, num1 + num2 num yield temp_num print(\"get \", num) temp_num num1 num1, num2 num2, num1 + num2 num yield temp_num print(\"get \", num) return \"结束了!!!\" fib fib_generator() print(fib.send(None)) print(fib.send(2)) print(fib.send(3)) try: print(fib.send(4)) except StopIteration as ret: print(ret.value) ``` > ```bash > PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" > 1 > get 2 > 2 > get 3 > 3 > get 4 > 结束了!!! > ```"},"/note/编程基础/python/基础语法/2024-5-1-17With和上下文管理器.html":{"title":"With和上下文管理器","content":" layout: post title: \"With和上下文管理器\" date: 2023 9 23 15:39:08 +0800 tags: python基础 # With和上下文管理器 在使用系统资源比如说文件, socket, 数据库连接的时候, 打开这一些资源以后需要关闭, 不关闭的话, 文件的打开数量等资源的数量是有限的 如果一个为文件关闭的打开的过程中报错, 这一个文件的关闭可能出现问具体, 可以使用try进行异常捕获, 也可以使用with语句 ## 上下文 实际是代码的执行环境 ### 上下文管理器 任何一个实现了`__enter__()`和`__exit()__`两个方法的对象都可以使用with进行管理 ```python class File(object): def __init__(self, filename, mode) > None: self.filename filename self.mode mode def __enter__(self): print(\"Opening the file...\") self.file open(self.filename, self.mode) return self.file def __exit__(self, *args): # 这一个函数在调用的时候传入参数, 所以需要*args去获取这些参数 print(\"Closing the file...\") self.file.close() with File('test.txt', 'w') as f: print(\"Writing to the file...\") f.write(\"Hello, World!\") ``` > with开始的时候会调用`__enter__`, 离开的时候会使用`__exit__` > > ```bash > PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" > Opening the file... > Writing to the file... > Closing the file... > ``` ### 更简单的调用 ```python from contextlib import contextmanager @contextmanager def my_context_manager(): print('Enter') yield print('Exit') with my_context_manager(): print('Inside') ``` > ```bash > PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" > Enter > Inside > Exit > ``` ```python from contextlib import contextmanager @contextmanager def my_open(filename, mode): f open(filename, mode) yield f f.close() with my_open('test.txt', 'r') as f: print(f.readlines()) ``` > ```bash > PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" > ['1.Hello\\n', '2.World\\n'] > ``` 实际使用的时候可以直接`with oprn(filename, mode) as f:`这一个f里面已经实现了这两个规则 ## 总结 在开发里面使用系统资源一定需要关闭的时候, 为了避免资源在异常的时候没有正常的关闭, 所以使用这一个用于管理资源"},"/note/编程基础/python/基础语法/2023-9-24-02函数及变量.html":{"title":"函数及变量","content":" layout: post title: \"函数及变量\" date: 2024 4 23 15:39:08 +0800 tags: python基础 # 函数及变量 ## 函数 使用def关键字 在参数名前面的*表示args是一个可变参数 ```python def add(*args): total 0 for val in args: total + val return total # 在调用add函数时可以传入0个或多个参数 print(add()) print(add(1)) print(add(1, 2)) print(add(1, 2, 3)) print(add(1, 3, 5, 7, 9)) ``` 由于Python没有函数重载的概念，那么后面的定义会覆盖之前的定义，也就意味着两个函数同名函数实际上只有一个是存在的。 Python中每个文件就代表了一个模块（module），我们在不同的模块中可以有同名的函数，在使用函数的时候我们通过`import`关键字导入指定的模块就可以区分到底要使用的是哪个模块中的`foo`函数 在引用的时候如果引用两个相同名字的函数, 后面的会覆盖前面的函数 + 在定义函数模块的时候使用`\"if __name__ '__main__':\"`关键字会在只有运行着一个模块的时候运行这一个模块 ```python def is_prime(num): \"\"\"判断一个数是不是素数\"\"\" for factor in range(2, int(num ** 0.5) + 1): if num % factor 0: return False return True if num ! 1 else False ``` ### 参数的作用域 ```python def foo(): b 'hello' # Python中可以在函数内部再定义函数 def bar(): c True print(a) print(b) print(c) bar() # print(c) # NameError: name 'c' is not defined if __name__ '__main__': a 100 # print(b) # NameError: name 'b' is not defined foo() ``` > 这时候三个参数都可以打印出来 > > a >全局部变量 > > b >函数中的局部变量, 但是对于其内部的函数来说, b属于嵌套作用域 > > c >局部作用域 > > Python查找一个变量时会按照“局部作用域”、“嵌套作用域”、“全局作用域”和“内置作用域”的顺序进行搜索，前三者我们在上面的代码中已经看到了，所谓的“内置作用域”就是Python内置的那些标识符，我们之前用过的`input`、`print`、`int`等都属于内置作用域。 当函数中的参数和外部的全局变量同名的时候使用局部变量 ```python def foo(): a 200\t\t\t# 相当于一个新的变量 print(a) # 200 if __name__ '__main__': a 100 foo() print(a) # 100 ``` > 在函数里面使用` 全局变量 value`实际不是调用这一个全局变量, 是创建了一个新的一样名字的变量 > > 想要这时候调用全局变量可以使用关键字global ```python def foo(): global a a 200 print(a) # 200 if __name__ '__main__': a 100 foo() print(a) # 200 ``` > 如果全局里面没有a会在下一行定义全局的a变量 > > ```python > def foo(): > global a > a 200 > print(a) > > if __name__ \"__main__\": > foo() > print(a) > ``` > > > 这个里面的第二个a可以正常打印 > > 如果想要修改的是嵌套作用域里面的变量, 使用的是关键字`nonlocal` + 建议在操作的时候把所有的变量都在函数里面实现 ### 数据的传递 函数调用时的机制：有一实际参数a，在调用时产生一个新的变量x（形式参数），x和a指向相同的地址。如果对x赋值，意味着改变了x指向的内存块，而不改变a的值。如果x是列表，对x[0]赋值，则改变了x[0]指向的内存块，而又因为x[0]的地址是存放在列表中，a又指向了这个列表，因此a也被修改了。 > [Python函数中修改变量（值传递、引用传递、可变对象、不可变对象）的深入思考_python引用类型在函数内修改 CSDN博客](https://blog.csdn.net/qq_41987033/article/details/81675514) > > 这一点是引用部分的知识 **注意**: 如果函数的缺省参数是一个列表, 没有指定的时候这一个列表会一直是同一个列表, 可以使用append之类的方法进行改变 ### 返回值 使用return, 没有return的时候实际返回的是一个NULL 可以一次性返回多个数值 ```python def func(): return a, b, c num1, num2, num3 func() ``` > 这一个返回的是一个元组 可以在定义函数的时候使用` >类型`定义这一个函数的返回值 ```python def __init__(self) > None: pass ``` ### 函数的文档 ```python def func(): \"\"\" 这是一个说明 \"\"\" pass ``` > 在交互模式里面可以使用`help(print)`这样的方式获取文档 ### 重复定义 定义两个函数的名字一样的时候, 会执行后面的那一个 ### 缺省参数 也叫默认参数, 在定义参数的时候使用` `进行赋值, 这一个参数没有传入的时候会使用默认的那一个值 ```python def func(value1, value2 2): \tpass ``` ### 命名参数 在函数调用的时候可以指定这一个参数的名字, 直接把这一个值传递给这一个参数 ```python def func(a, b, c): pass func(b 3, b 1, a 3) ``` > 没有命名的参数需要在左边 ### 不定长参数 使用的时候有两种 + *args: 函数多余的参数会使用元组的形式在args里面, 这一个参数需要是未命名参数 ```python def func_test(a, b, c, *args): print(a, b, c, args) func_test(2, 1, 3, 3, 4, 5) ``` > ```bash > PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" > 2 1 3 (3, 4, 5) > ``` 使用的时候如果希望参数传递的使用优先给不定长参数, 而不是给命名参数, 需要把`*args`这一个参数放在命名参数前面 + **kwargs: 多余的参数会使用键值对的形式存在这一个参数里面, 这一个参数需要是命名参数 ```python def func_test(a, b, c, **kwargs): print(a, b, c, kwargs) func_test(2, 1, 3, d 3) ``` > ```bash > PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" > 2 1 3 {'d': 3} > ``` 这两个参数在传递的时候可以使用`*`和`**`进行拆包, 达到按照原来的样子传递的方式 ## 常用变量 ### 字符串 #### 定义 使用单引号或者双引号定义, 也可以使用三个引号定义有折行的字符串 ```python s1 'hello, world!' s2 \"hello, world!\" # 以三个双引号或单引号开头的字符串可以折行 s3 \"\"\" hello, world! \"\"\" print(s1, s2, s3, end '') ``` > ```bash > hello, world! hello, world! > hello, > world! > ``` > `\\`后面还可以跟一个八进制或者十六进制数来表示字符，例如`\\141`和`\\x61`都代表小写字母`a`，前者是八进制的表示法，后者是十六进制的表示法。也可以在`\\`后面跟Unicode字符编码来表示字符，例如`\\u9a86\\u660a`代表的是中文“骆昊”。 + **如果不希望字符串中的`\\`表示转义，我们可以通过在字符串的最前面加上字母`r`来加以说明** 可以使用`+`运算符来实现字符串的拼接，可以使用`*`运算符来重复一个字符串的内容，可以使用`in`和`not in`来判断一个字符串是否包含另外一个字符串（成员运算），我们也可以用`[]`和`[:]`运算符从字符串取出某个字符或某些字符（切片运算） #### 切片 ```python str2 'abc123456' # 从字符串中取出指定位置的字符(下标运算) print(str2[2]) # c # 字符串切片(从指定的开始索引到指定的结束索引) print(str2[2:5]) # c12 print(str2[2:]) # c123456 print(str2[2::2]) # c246 print(str2[::2]) # ac246 print(str2[:: 1]) # 654321cba print(str2[ 3: 1]) # 45 ``` > [起始位置:结束位置:每一次的步长] #### 切片赋值 ```python a [11, 22, 33, 44] a[1:3] [1, 2, 3, 4, 5, 6] print(a) ``` > ```bash > PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" > [11, 1, 2, 3, 4, 5, 6, 44] > ``` > > 会把这一个段进行替换 ### 特殊格式 [Python中字符串前“b”,“r”,“u”,“f”的作用_python b CSDN博客](https://blog.csdn.net/acktomas/article/details/119323913) + **u**: 这里面有中文 + **r**: 这里面`\\`不起作用 + **b**: 这一个字符串是一个byte类型(默认为unicode类) 在 Python3 中，bytes 和 str 的互相转换方式是 ```python str.encode('utf 8') bytes.decode('utf 8') ``` > 在Python中，普通字符串和字节字符串是两种不同的数据类型，它们的使用方式和特性有所不同。如果在处理二进制数据时使用普通字符串而不是字节字符串，可能会导致以下问题： > > 1. 编码问题：普通字符串是以Unicode编码方式存储的，如果将二进制数据（如图片、音频等）直接存储在普通字符串中，会导致数据被解析为Unicode字符而产生编码错误。这可能导致数据的损坏或无法正确解析。 > 2. 字符集问题：普通字符串在处理二进制数据时可能会出现字符集问题。由于普通字符串会自动进行编码和解码操作，可能会导致数据在不同字符集下发生变化，导致数据不完整或损坏。 > 3. 性能问题：普通字符串在处理大量的二进制数据时可能会导致性能问题，因为普通字符串需要进行Unicode编码和解码的操作，而字节字符串直接以字节形式存储，不需要进行编码和解码操作，更加高效。 > > 因此，如果需要处理二进制数据，最好使用字节字符串而不是普通字符串，以确保能够正确地处理二进制数据，避免数据损坏和编码问题。在处理二进制数据时，建议使用字节字符串，并在需要文本数据操作时再将其转换为普通字符串进行处理。 + **f**: 一个比formot更方便的格式化字符串的方式 ```python import time t0 time.time() time.sleep(1) name 'processing' print(f'{name} done in {time.time() t0:.2f} s') ``` ### 占位符 在Python中，print函数用于将内容输出到控制台。当使用print函数时，用{}来表示占位符，可以在字符串中插入变量的值。例如： ```python name \"Alice\" age 30 print(\"My name is {} and I am {} years old.\".format(name, age)) ``` 在上面的例子中，{}会被name和age的值替换，输出结果为\"My name is Alice and I am 30 years old.\" ##### 通过位置 ```python >>>\"{} {}\".format(\"hello\", \"world\") # 不设置指定位置，按默认顺序 'hello world' >>> \"{0} {1}\".format(\"hello\", \"world\") # 设置指定位置 'hello world' >>> \"{1} {0} {1}\".format(\"hello\", \"world\") # 设置指定位置 'world hello world' ``` ##### 通过关键字 ```python print(\"网站名：{name}, 地址 {url}\".format(name \"jiao\", url \"http://www.xvsenfeng.asia/\")) # 通过字典设置参数 site {\"name\": \"jiao\", \"url\": \"http://www.xvsenfeng.asia/\"} print(\"网站名：{name}, 地址 {url}\".format(**site)) # 通过列表索引设置参数 my_list ['jiao', 'http://www.xvsenfeng.asia/'] print(\"网站名：{0[0]}, 地址 {0[1]}\".format(my_list)) # \"0\" 是必须的 ``` ```python class Person: def __init__(self, name, age): self.name name self.age age def __str__(self): return 'name is {self.name}, age is {self.age}'.format(self self) ``` ### 通过映射 ```python class AssignValue(object): def __init__(self, value): self.value value my_value AssignValue(6) print('value 为: {0.value}'.format(my_value)) # \"0\" 是可选的 ``` ```python b_dict {'name': \"jiao\", 'age': 21} print('my name is {name}, age is {age}'.format(**b_dict)) print('my name is {info[name]}, age is {info[age]}'.format(info b_dict)) ``` > 在使使用一个字典的时候, 不能使用`\"key\"`的形式 数字 格式 输出 描述 : : : : 3.1415926 {:.2f} 3.14 保留小数点后两位 3.1415926 {:+.2f} +3.14 带符号保留小数点后两位 1 {: .2f} 1.00 带符号保留小数点后两位 2.71828 {:.0f} 3 不带小数 5 {:0>2d} 05 数字补零 (填充左边, 宽度为2) 5 {:x<4d} 5xxx 数字补x (填充右边, 宽度为4) 10 {:x<4d} 10xx 数字补x (填充右边, 宽度为4) 1000000 {:,} 1,000,000 以逗号分隔的数字格式 0.25 {:.2%} 25.00% 百分比格式 1000000000 {:.2e} 1.00e+09 指数记法 13 {:>10d} 13 右对齐 (默认, 宽度为10) 13 {:<10d} 13 左对齐 (宽度为10) 13 {:^10d} 13 中间对齐 (宽度为10) 11 `'{:b}'.format(11) '{:d}'.format(11) '{:o}'.format(11) '{:x}'.format(11) '{:#x}'.format(11) '{:#X}'.format(11)` `1011 11 13 b 0xb 0XB` 进制 **^**, **<**, **>** 分别是居中、左对齐、右对齐，后面带宽度， **:** 号后面带填充的字符，只能是一个字符，不指定则默认是用空格填充。 **+** 表示在正数前显示 **+**，负数前显示 ** **； （空格）表示在正数前加空格 b、d、o、x 分别是二进制、十进制、八进制、十六进制。 此外我们可以使用大括号 **{}** 来转义大括号，如下实例： ```python print (\"{} 对应的位置是 {{0}}\".format(\"runoob\")) runoob 对应的位置是 {0} ``` ### 列表list 使用`[]`, 用于存储多个数据 可以使用下标的方式进行访问, 也可以使用切片 使用len()可以获取这一个链表的长度 python里面的链表可以存储不同数据类型的数据 ### 元组tuple 这一个和列表很像, 但是里面的数据不能进行修改, 使用`()` > 这一个里面只有一个参数的时候, 需要加一个`,` ### 集合set 这一个里面不能有重复的数据, 使用`{}` 有重复的数据的时候会把里面的重复的数据只保存一次 这一个的顺序是随机的 ### 字典dict ```python {key : value, key2 : value...} ``` > 这一个里面的key这一个不能重复 > > 获取数据的时候需用使用key进行获取它对应的值 使用for对着一个进行遍历的时候, 实际获取到的时候这一个字典的key的信息(相当于dict.keys()) 也可以对dict.values()进行遍历, 这一个可以直接获取这一个字典里面的value 也可以使用dict.items(), 可以获取这一个字典的元素, 使用一个元组返回一个键值对"},"/note/编程基础/python/基础语法/2024-4-28-15闭包.html":{"title":"闭包","content":" layout: post title: \"闭包\" date: 2024 4 28 15:39:08 +0800 tags: python基础 # 闭包 **闭包函数：**声明在一个函数中的函数，叫做[闭包](https://so.csdn.net/so/search?q 闭包&spm 1001.2101.3001.7020)函数。 **闭包：**内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。 > 这一个和类比较类似, 属性加方法, 但是比较轻量 + 特点 让外部访问函数内部变量成为可能； 局部变量会常驻在内存中； 可以避免使用全局变量，防止全局变量污染； 会造成内存泄漏（有一块内存空间被长期占用，而不被释放） > 一个函数里面嵌套另一个函数, 里面的函数使用了外部函数的局部变量 ```python def who(name): def do(content): print(\"(%s):%s\" % (name, content)) return do zhangsan who(\"zhangsan\") lisi who(\"lisi\") zhangsan(\"hello\") lisi(\"world\") ``` > 实际就是使用使用一个函数生成另一个函数, 这一个函数实用了外部变量 可以使用dwl对这个闭包进行释放 ### 改变变量 在闭包里面如果没有使用特殊的关键字进行声明, 外部函数里面的变量不能直接修改, 加一个`nonlocal`之后就可以修改了 ```python def counter(start 0): def increment(): nonlocal start start + 1 return start return increment c counter() print(c()) print(c()) print(c()) c1 counter(10) print(c1()) print(c1()) ``` ## 示例 ```python def make_filter(keep): def the_filter(file_name): file open(file_name) lines file.readlines() file.close() filter_doc [i for i in lines if keep in i] return filter_doc return the_filter filter make_filter(\"python\") print(filter(\"main.py\")) ```"},"/note/编程基础/python/基础语法/2024-4-25-09面向对象.html":{"title":"面向对象","content":" layout: post title: \"面向对象\" date: 2023 6 15 15:39:08 +0800 tags: python基础 # 面向对象 可以把数据以及功能打包为一个整体 类: + 名称 + 属性(数据) + 方法 ```python class Person: def __init__(self, name, age): self.age age self.name name def print_info: print(self.name, self.age) ``` ## 定义 ```python #经典类 class Dog1: pass # 新式类 class Dog2(object): pass ``` > 在python3里面这都一样, 用于继承 ### self self指向当前的这一个对象自己, python会自动传递当前的对象 self的名字可以不叫self, 但是推荐使用self, 会使用类的方法的第一个参数 ### 属性 ```python class Dog1: def set_name(self, name): self.name name def print_name(self): print(self.name) class Dog2: pass dog1 Dog1() # dog1.set_name('dog1') dog1.print_name() ``` > 这一个属性会在调用`dog1.set_name('dog1')`的时候才会创建, 不调用的时候使用这一个变量会出问题 > > 也可以使用`dog1.name \"dog1\"`来进行指定, 但是一般不使用这一个方式 #### 私有属性 普通的属性可以在外部进行修改, 这种方式一般是不希望出现的 可以在变量名前面加两个`__`进行设置 ```python class Dog1: def __init__(self, name): self.__name name def print_name(self): print(self.__name) dog Dog1(\"dog1\") print(dog.__name) ``` > ```bash > PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" > Traceback (most recent call last): > File \"e:\\JHY\\python\\2024 4 22\\main.py\", line 9, in <module> > print(dog.__name) > AttributeError: 'Dog1' object has no attribute '__name' > ``` ```python dog Dog1(\"dog1\") dog.__name \"dog2\" dog.print_name() ``` > 这样实际也不能修改这一个变量, 打印的还是`dog1` 实际使用的时候可以通过\\_ClassName\\_\\_name进行调用, 但是不建议使用 ```python dog Dog1(\"dog1\") dog._Dog1__name \"dog2\" dog.print_name() ``` > python实际是对这一个变量进行了一个重命名 ### 私有方法 外部不能直接调用的方法 在函数名的前面加一个`__` ## 继承 一个新的类里面有之前的一个类里面的数据, 这时候可以使用继承的方式 ```python class NewClass(OldClass1, OldClass2, ...): pass ``` > 实际继承的时候可以有多个类 继承获取的方法可以重写进行覆盖(方法的名字需要一样) ```python class Parent(object): x 1 class son1(Parent): pass class son2(Parent): pass print(Parent.x, son1.x, son2.x) son1.x 2\t\t\t# 这一个实际是一个定义 print(Parent.x, son1.x, son2.x) Parent.x 3 print(Parent.x, son1.x, son2.x) ``` > ```bash > PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" > 1 1 1 > 1 2 1 > 3 2 3 > ``` > > 在类里面的变量是使用字典的方式进行记录的, 在当前的类里面没有找到的话会从祖先的类里面找, 子类里面重写会创建一个新的变量在他的里面记录这一个新的值, 不会影响父类里面的值 ### super 有可能存在父类的方法不可以满足子类的需求, 但是不是需要全部重写, 而是加了一部分新的数据, 全部重写会出现代码的冗余 可以重写的时候调用一下父类的方法 ```python class Chile(Father): def Father_func(): super.Father_func() 子类的新的处理 ``` > 也可以使用`Father.Father_func()`, 但是使用这一个方法的时候会导致多继承的时候可能有的函数会被多次调用, 如果没有相同的祖先, 这一个就不会出现问题 ```python class Father(object): def __init__(self, name): print(\"Father\") self.name name class Son1(Father): def __init__(self, name): print(\"Son1 Begin\") super().__init__(name) print(\"Son1 End\") class Son2(Father): def __init__(self, name): print(\"Son2 Begin\") super().__init__(name) print(\"Son2 End\") class GrandSon(Son1, Son2): def __init__(self, name): print(\"GrandSon\") super().__init__(name) print(\"GrandSon End\") grandson GrandSon(\"Shi\") ``` > ```bash > PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" > GrandSon > Son1 Begin > Son2 Begin > Father > Son2 End > Son1 End > GrandSon End > ``` > > 这一个调用的时候需要计算出来实际调用的是哪一个父类, python里面实际使用了一个C3算法 > > 可以使用`print(GrandSon.__mro__)`查看实际调用的顺序, 每一次遇到一个super会进入下一层的函数里 > > `(<class '__main__.GrandSon'>, <class '__main__.Son1'>, <class '__main__.Son2'>, <class '__main__.Father'>, <class 'object'>)` > > 使用这一个的时候会出现一个问题: 多进程的时候传入的参数的个数的问题, 这一个的顺序是不一定的, 所以传递的时候需要把所有的参数都传递 ## 多态 在python里面不是很明显 多态是指一类事物有多种形态，比如动物类，可以有猫，狗，猪等等。（一个抽象类有多个子类，因而多态的概念依赖于继承） 多态性是指具有不同功能的函数可以使用相同的函数名，这样就可以用一个函数名调用不同内容的函数。在面向对象方法中一般是这样表述多态性：向不同的对象发送同一条消息，不同的对象在接收时会产生不同的行为（即方法）。也就是说，每个对象可以用自己的方式去响应共同的消息。所谓消息，就是调用函数，不同的行为就是指不同的实现，即执行不同的函数。 > 实际使用的时候可以传递一系列类过去, 这些类里面有一个相同名字的函数, 但是这一个函数的实际执行的任务不同, 传不同的类会使用不同的行为, 但是实际调用的时候看起来调用的都一样 ## 特殊属性方法 ### 静态方法 在class里面有一个函数, 实际不需要class这一个参数, 这一个方法就是一个静态方法, 实际使用的时候需要使用参数`@staticmethod`进行修饰 ```python class Class(Object): @staticmethod def func(): pass ``` > 这一个静态方法可以直接使用类名进行调用 > > ```python > Class.func() > ``` ### 类属性 通过一个类创建的对象之间的数据是相互隔离的, 但是有的数据需要是共享的 在Class里面, 但是位于def外面的属性是一个类属性 ```python class Class(object): 类属性 value ``` > 实际调用的时候需要使用`类名.类属性`来调用这一个属性 ```python class Tools(object): num 0 def __init__(self): Tools.num + 1 ``` > 类里面的属性实际存储的时候使用的是字典里面的键值对, 所以实际去调用一个参数的时候传给属性拦截器的是一个字符串 ### 类方法 专门用于对类属性操作的方法, 使用`@classmethod`, 这个时候传递的参数是`cls` ```python class Tools(object): num 0 @classmethod def add_1(cls): cls.num + 1 def __init__(self): self.add1() ``` > 实际调用的时候可以使用`实例对象.类方法`或者`类名.类方法` > > 记录的时候实际也是一个属性, 指向一个代码段 可以直接使用`实例或者类.名字 方法`这种方式进行动态添加一个一个方法, 但是这一种方式不会自动传入self参数, 可以使用types进行动态添加方法 + 实例方法 ```python import types class Person (object): def __init__(self, name None, age None): self.name name self.age age p Person(\"jiao\", 21) def show_info(self): print(\" info \") p.show_info types.MethodType(show_info, p) # 自动把这一个参数传进去 p.show_info() ``` + 类方法/静态方法 这两个可以直接在加了修饰器以后添加 ### 类对象 在python里面定义class的时候这一个定义也是一个对象, 这一个对象里面有类属性等信息, 还有各种方法的代码 创建的实例里面有一个参数`__class__`, 这一个参数指向这个类对象 实例调用方法的时候会使用这一个类对象, 用于节省空间, 避免代码重复 > 可以使用`dir(实例对象)`查看有哪一些方法, 属性 > > **dir()** 函数不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表。如果参数包含方法\\_\\_dir\\_\\_()，该方法将被调用。如果参数不包含\\_\\_dir\\_\\_()，该方法将最大限度地收集参数信息。 ## 变量特殊命名方法 `xx`: 共有变量 `_xx`:私有化属性和方法, 使用`from module import *`禁止导入, 类对象和子类可以使用 `__xx`: 无法在外部直接访问, 私有属性 `__xx__`用户名名空间的魔法对象和属性 `xx_`: 用于避免和python关键字冲突 ## property动态数据 使用`实例对象.属性 xxx`的时候会自动调用一个方法, 一个属性使用的时候是动态生成的, 需要在使用的时候通过一个函数进行生成 在使用 进行赋值的时候也可以使用这一个函数进行数据的检查 ### 装饰器使用 ```python class Foo(object): def func(self): print(\"fun running...\") @property def prop(self): print(\"prop running...\") foo_boj Foo() foo_boj.func() foo_boj.prop\t\t\t#这一个调用的时候没有()但是会执行这一个函数 ``` 这一个函数的返回值会作为最后的结果, 可以使用这一个进行产生动态的数据 ### 新式类 ```python class Foo(object): def __init__(self) > None: self.aaa 1 @property def prop(self): print(\"prop running...\") @prop.setter def prop(self, value): print(\"prop setting...\") self._prop value @prop.getter def prop(self): print(\"prop getting...\") return self._prop @prop.deleter def prop(self): print(\"prop deleting...\") del self._prop foo_boj Foo() foo_boj.prop 2 print(foo_boj.prop) del foo_boj.prop ``` > ```python > PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" > prop setting... > prop getting... > 2 > prop deleting... > ``` > > `@prop.getter`没有定义的时候会使用`@property`的返回值, 后面两个必须在`@property`后面使用, 这一个属性是必须有的 ### 另一种调用方式 ```python class Foo(object): def __init__(self): self.bar \"jiao\" def get_bar(self): return self.bar def set_bar(self, value): self.bar value BAR property(get_bar, set_bar, None, \"This is a bar\") obj Foo() result obj.BAR print(result) obj.BAR \"haoyang\" print(obj.BAR) print(Foo.BAR.__doc__) ``` ![image 20240503112644197](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405031126476.png) 第四个参数是一个字符串, 使用`类名.属性.__doc__`可以获取 > ```bash > PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" > jiao > haoyang > This is a bar > ``` > > 这一个使用`+ `进行赋值的时候相当于`obj.BAR obj.BAR + value `, 所以实际调用的时候会使用一次获取以及一次写入 + 实际使用实例 Django框架里面的property里面属性使用的就是这一个 ### 不足 如果有多个属性需要设置的时候, 这里面需要实现很多的函数 ## 内建函数集合 ### `__init__`引入 创建的时候会调用的函数 ```python class Person: def __init__(self, name, age): self.age age self.name name def print_info: print(self.name, self.age) ``` ### `__str__`打印 这一个函数的返回值是使用print函数打印这一个类的时候结果 ### `__call__` 如果使用一个类创建了一个对象, 直接使用这一个对象当函数调用会执行这一个函数 ### `__slots__`静态 添加这一个属性可以使得这一个类不能在运行的时候进行添加属性, 只可以使用声明了的属性 ```python class Person(object): __slots__ (\"name\", \"age\") p Person() p.name \"John\" p.age 20 print(p.name, p.age) p.address \"henan\" print(p.address) ``` > ```bash > PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" > John 20 > Traceback (most recent call last): > File \"e:\\JHY\\python\\2024 4 22\\main.py\", line 8, in <module> > p.address \"henan\" > AttributeError: 'Person' object has no attribute 'address' > ``` > > 这一个效果只在定义他的类里面有效, 不会进行继承 ```python import math class Person: # 初始化 def __init__(self, name, age): self.age age self.name name def print_info(self): print(self.name, self.age) \t # print直接打印的时候 def __str__(self): return f'{self.name} is {self.age} years old' def __repr__(self): return f'Person({self.name}, {self.age})' def __eq__(self, other): return self.age other.age def __lt__(self, other): return self.age < other.age def __gt__(self, other): return self.age > other.age def __le__(self, other): return self.age < other.age def __ge__(self, other): return self.age > other.age def __ne__(self, other): return self.age ! other.age def __add__(self, other): return self.age + other.age def __sub__(self, other): return self.age other.age def __mul__(self, other): return self.age * other.age def __truediv__(self, other): return self.age / other.age def __floordiv__(self, other): return self.age // other.age def __mod__(self, other): return self.age % other.age def __pow__(self, other): return self.age ** other.age def __and__(self, other): return self.age & other.age def __or__(self, other): return self.age other.age def __xor__(self, other): return self.age ^ other.age def __lshift__(self, other): return self.age << other.age def __rshift__(self, other): return self.age >> other.age def __neg__(self): return self.age def __pos__(self): return +self.age def __abs__(self): return abs(self.age) def __invert__(self): return ~self.age def __round__(self, n 0): return round(self.age, n) def __floor__(self): return math.floor(self.age) def __ceil__(self): return math.ceil(self.age) def __trunc__(self): return math.trunc(self.age) def __index__(self): return self.age def __len__(self): return len(self.name) def __contains__(self, item): return item in self.name def __getitem__(self, key): return self.name[key] def __setitem__(self, key, value): self.name[key] value def __delitem__(self, key): del self.name[key] def __iter__(self): return iter(self.name) def __reversed__(self): return reversed(self.name) def __next__(self): return next(self.name) def __hash__(self): return hash(self.name) def __call__(self): return self.print_info() def __enter__(self): print('Entering') def __exit__(self, exc_type, exc_value, traceback): print('Exiting') def __del__(self): print('Deleting') p1 Person('John', 30) p2 Person('Jane', 25) p1.print_info() print(p1 p2) print(p1 < p2) print(p1 > p2) print(p1 < p2) print(p1 > p2) print(p1 ! p2) print(p1 + p2) print(p1 p2) print(p1 * p2) print(p1 / p2) print(p1 // p2) print(p1 % p2) print(p1 ** p2) print(p1 & p2) print(p1 p2) print(p1 ^ p2) print(p1 << p2) print(p1 >> p2) print( p1) print(+p1) print(abs(p1)) print(~p1) print(round(p1, 1)) print(math.floor(p1)) print(math.ceil(p1)) print(math.trunc(p1)) print(hash(p1)) p1() with p1: pass del p1 ``` ```bash John 30 False False True False True True 55 5 750 1.2 1 5 8472886094430000000000000000000000000 24 31 7 1006632960 0 30 30 30 31 30 30 30 30 2252686827583093840 John 30 Entering Exiting Deleting Deleting ``` 常用的属性 说明 触发 : : : : : : `__init__` 构建初始化的时候 初见实际赋值的时候调用, 初始化new创建的实例 `__new__` 生成的实例时候 创建实际时, 最先调用, 返回实例 `__class__` 实例所在的类 `实例.__class__` `__str__` 实例的字符串显示, 可读性 print打印的时候显示 `__repr__` 实例的字符串显示, 准确性 print(repr(实例类))或print直接调用, 优先级比较高 `__del__` 析构(删除的时候执行) del实例 `__dict__` 实例的自定义属性 `vars(实例.__dict__)`, `类.__dict__`的时候只打印实例属性 `__doc__` 类文档, 子类不会继承 help(类或实例), 函数会打印他的描述 `__getattribute__` 属性访问拦截器 访问实例属性的时候, 传入的参数是这一个参数的字符串 `__bases__` 类的所有的父类构成的元素 `print(类名.__bases__)` ### 常用属性 + `__module__`: 查看他所在的模块(文件) + `__class__`: 这一个实例使用的类 ### 类字典实现 + `__getitem__, __setitem__, __delitem__`: 使用`实例[索引]`和的时候会调用这三个 ```python class Foo(object): def __getitem__(self, key): print(\"__getitem__\", key) def __setitem__(self, key, value): print(\"__setitem__\", key, value) def __delitem__(self, key): print(\"__delitem__\", key) foo Foo() foo[\"bar\"] \"baz\" del foo[\"bar\"] foo[\"bar\"] ``` > ```bash > PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" > __setitem__ bar baz > __delitem__ bar > __getitem__ bar > ``` > > 传递的时候是一个字符串 + `__getslice__, __setslice__, __delslice__`: 在python2里面的实现切片 ## 元类 一个特殊的类, 用于定义其他的类 元类(type) >类(类对象) >实例对象 类的创建也可以使用类似于闭包的方式 ```python def choice_class(name): if name \"foo\": class Foo(object): pass return Foo else: class Bar(object): pass return Bar ``` ### 使用type创建类 type实际有两个功能, 一个是测试类型, 另一个是创建一个类 ```python type(类名, 父类的名称组成的元组(可以为空), 包含属性的字典(名称和值)) ``` ```python c_j type(\"JIAO\", (object,), {\"name\":\"jiao\", \"age\":18}) print(type(c_j)) obj_j c_j() print(obj_j.name) print(obj_j.age) ``` > ```bash > PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" > <class 'type'> > jiao > 18 > ``` ### 元类的定义 函数type实际上就是一个元类, 是python里面用于创建所有类的元类, Python里面的所有的类都是一个对象 ```python JIAO type(\"JIAO\", (), {}) print(dir(JIAO)) print(JIAO.__dict__) print(JIAO.__bases__) # 查看这一个对象继承的类 print(JIAO.__class__) # 查看它构建这一个实例使用的类 ``` > ```bash > PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" > ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', > '__weakref__'] > {'__module__': '__main__', '__dict__': <attribute '__dict__' of 'JIAO' objects>, '__weakref__': <attribute '__weakref__' of 'JIAO' objects>, '__doc__': None} > (<class 'object'>,) > <class 'type'> > ``` > > str, int这一些数据实际使用也是一个type类生成的对象, type这一个类的父类是object ### 自己创建元类 ```python class Foo(object, metaclass xxxxx): ``` > 在定义一个类的时候没有指定这一个metaclass, 会默认使用type进行创建, 否则使用这一个参数指定的那一个函数进行创建 ```python class UperAttrMetaClass(type): # def __new__(cls, clsname, bases, dct): new_attr {} for name, value in dct.items(): if not name.startswith('__'): new_attr[name.upper()] value else: new_attr[name] value return type(clsname, bases, new_attr) class Foo(metaclass UperAttrMetaClass): bar 'bip' print(hasattr(Foo, 'bar')) print(hasattr(Foo, 'BAR')) f Foo() print(f.BAR) ``` > ```bash > PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" > False > True > bip > ``` > > 创建这一个类里面的属性的时候都使用大写 ```python class UperAttrMetaClass(type): # 这一个函数会在类被创建的时候被调用 # clsname: 类的名字 # bases: 类的基类 # dct: 类的属性 # 默认的实现是返回一个新的类 # 这个新的类会将属性名转换为大写 def __new__(cls, clsname, bases, dct): new_attr {} for name, value in dct.items(): if not name.startswith('__'): new_attr[name.upper()] value else: new_attr[name] value return type(clsname, bases, new_attr) class Foo(metaclass UperAttrMetaClass): bar 'bip' print(hasattr(Foo, 'bar')) print(hasattr(Foo, 'BAR')) f Foo() print(f.BAR) ``` ## 类定义的过程 python解释器遇到一个类的时候实际会进行一次调用, 为了知道实际有的属性以及方法, 之后把这些方法属性传递到元类type里面, 创建一个对象, 这个就是类对象 如果类里面有放在外面代码的话, 这些代码会执行 ## 描述符对象 property的实现, `@classmethod`等的实现都可以使用描述符 在大型的项目里面对MySQL数据库的操作的传媒也可以使用这一个进行实现 ### `__getattr__` 这一个是在调用一个不存在的属性的时候调用, 访问的属性存在的时候不会调用这一个方法 ```python class A: def __init__(self, name): self.name name # def __getattribute__(self, item): # if item \"name\": # return \"haha\" # else: # return super().__getattribute__(item) def __getattr__(self, item): print(\"error item %s\" % item) a A(\"jiao\") print(a.age) # 默认访问这一个的时候会报错, 现在不会 ``` > ```bash > PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" > error item age > None > ``` > > 默认这一个会产生一个异常 ### `__getattribute__` 访问一个对象的时候会调用这一个函数, 实际使用的时候可以使用这一个函数进行拦截 ```python class A: def __init__(self, name): self.name name def __getattribute__(self, item): if item \"name\": return \"haha\" else: return super().__getattribute__(item) a A(\"jiao\") print(a.name) ``` > ```bash > PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" > haha > ``` > **注: **这两个同时出现的时候会调用`__getattribute__` ### 描述符 之前使用的`@property`这一个属性会使得一个函数的方法属于的类从`function`变为`property` 这个property实际就是一个描述符, 严格来说, 如果一个类里面有`__get__, __set__, __delete__`这三个属性里面的任意一个, 那么这一个类实际就是一个描述符对象 如果有一个类, 这一个类里面有类属性对应的是上面的描述符对象创建的实例对象, 这一个类属性就是一个描述符 ```python class A: def __get__(self, instance, owner): print(\" get \") def __set__(self, instance, value): print(\" set \") def __delete__(self, instance): print(\" delete \") class B: a A() # 这一个是一个描述符 b B() print(b.a) # 调用__get__方法, b为instance, B是owner b.a 100 # 调用__set__方法, b为instance, 100是value del b.a # 调用__delete__方法 ``` > ```bash > PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" > get > None > set > delete > ``` > > 实际property就是这一个方式实现的 > > 如果直接使用B.a进行调用的时候, instance这一个是None, owner还是B ### 使用描述符的原因 python里面没有属性, 所以可以使用这一个进行类型检测, 使用的时候比 ### 实际使用 #### 实现数据监测 ```python class NonNegative(object): def __init__(self, default): self.default default # 没有某一个参数的时候返回值 self.data dict() def __get__(self, instance, owner): return self.data.get(instance, self.default) def __set__(self, instance, value): if value < 0: raise ValueError('value must be non negative') self.data[instance] value class Order(object): price NonNegative(0) quantity NonNegative(1) def __init__(self, name, price, quantity): self.name name self.price price self.quantity quantity def total(self): return self.price * self.quantity order Order('apple', 1, 10) print(order.total()) order.price 10 print(order.total()) order.price 10 # ValueError: value must be non negative ``` #### 实现classmethed ```python class classmethed_new(object): def __init__(self, func): self.func func def __get__(self, instance, owner): def new_func(*args, **kwargs): return self.func(owner, *args, **kwargs) return new_func # 这是一个闭包, 返回实际调用的函数 class A(object): M 100 def a(self): print('A.a') @classmethed_new def b(cls):\t\t# 这里实际为b classmethed_new(b) print('A.b') print(cls.M) obj A() obj.a() print(' '*20) obj.b() # 从b获取一个函数, 之后执行这一个函数, 这时候的参数会给new_func, 之后new_func调用self.func ``` #### 实现惰性计算 惰性计算就是需要一个值, 这一个值不是提前准备的, 是啥时候需要啥时候计算的 ```python class LazyPropety(object): def __init__(self, fun) > None: self.fun fun def __get__(self, instance, owner): print(\"Calling __get__\") if instance is None: return self value self.fun(instance) # setattr(instance, area, value) 把这一个函数的名字指向的对象改为这一个计算值 setattr(instance, self.fun.__name__, value) return value class ReadOnlyNumber(object): def __init__(self, value) > None: self.value value def __get__(self, instance, owner): return self.value def __set__(self, instance, value): raise AttributeError(\"Can't set attribute\") class Circle(object): pi ReadOnlyNumber(3.14) def __init__(self, radius): self.radius radius # 初始的时候area这一个类保存的是一个描述符 @LazyPropety def area(self): print(\"Calculating area\") return self.pi * self.radius * self.radius print(\"1. \") a Circle(4) print(\"2. \") print(a.area) print(\"3. \") print(a.area) print(\"4. \") ``` ![image 20240504202648657](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202405042026731.png) ### `__dict__`作用 使用这一个可是查看一个类里面的已经定义的属性 在python里面所有的属性以及方式使用的都是字典的方式进行存储的, 实力对象里面只有这一个对象的私有属性, 方法以及类的文档在类属性里面 这一个实际调用`print(对象.__dict__)`, 也可以使用`vars(对象)`这一个函数进行替代 数据在调用的时候找到的是一个普通的属性的时候会直接调用, 如果这一个属性是一个描述符则会调用他的`__get__`方法 在获取数据的时候会首先从自己的字典里面获取数据, 没有这一个数据的话查找父类的字典 ```python class M: def __init__(self) > None: self.x 1 def __get__(self, instance, owner): print('get') return self.x def __set__(self, instance, value): print('set') self.x value class AA: m M() n 2 def __init__(self, score) > None: self.score score a AA(3) print(a.m) print(\" \" * 20) print(type(a).__dict__[\"m\"].__get__(a, AA)) # 这个和上面的那一个等价 ``` ### 数据描述符和非数据描述符 同时有`__get__`和`__set__`的时候这是一个数据描述符 只有一个`__get__`的时候是一个非数据的描述符 这两个区别是: 属性名和描述符的名字一样的时候, 访问这一个属性的时候, 如果这一个描述符是数据描述符, 就会优先访问这一个描述符, 不是的话访问这一个属性 ```python class M: def __init__(self) > None: self.x 1 def __get__(self, instance, owner): return self.x def __set__(self, instance, value): self.x value class N: def __init__(self) > None: self.x 1 def __get__(self, instance, owner): return self.x class AA(object): m M() # 资料描述符 n N() # 非资料描述符 def __init__(self, m, n) > None: self.m m # 属性m和描述符m同名, 调用的时候会发生冲突 # 数据描述符优先级高, 不会创建一个新的m, 会给m描述符赋值 self.n n # 属性n和描述符n同名, 这一个会创建一个新的属性 aa AA(2, 3) print(' '*20) print(aa.__dict__) print(AA.__dict__) print(' '*20) print(aa.n) # 这俩是不一样的, 这个调用属性 print(AA.n)\t # 描述符 print(' '*20) print(aa.m) # 这俩是一样的, 都是用的描述符 print(AA.m) ``` > ```python > PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" > > {'n': 3} > {'__module__': '__main__', 'm': <__main__.M object at 0x0000015CB8287FD0>, 'n': <__main__.N object at 0x0000015CB8287CD0>, '__init__': <function AA.__init__ at 0x0000015CB82AB0A0>, '__dict__': <attribute '__dict__' of 'AA' objects>, '__weakref__': <attribute '__weakref__' of 'AA' objects>, '__doc__': None} > > 3 > 1 > > 2 > 2 > ``` ### 只读描述符 同时定义两个属性, 但是在调用`__set__`的时候会触发一个AttributeError, 引发一个异常 ### 实际调用的细节 使用默认的`__getattribute__`的时候访问一个属性的时候会使用`hasattr`进行判断是不是有一个属性`__get__`如果有的话会使用这一个函数的返回值 如果重新这一个函数会使得描述符失效 没有这一个属性的时候调用`__getattr__` ### 注意 1. 使用描述符的时候这一个必须是一个类属性, 不能是实例属性, 否则的话这一个属性调用的时候不会调用这一个属性的方法 2. 由于使用的是类属性, 所以这一个描述符在实现的时候需要区分不同的实例, 这个时候可以使用instance做一个字典的key"},"/note/编程基础/python/基础语法/2025-12-19-打包whl文件.html":{"title":"打包whl文件","content":"# 打包whl文件 whl格式本质上是一个压缩包，里面包含了py文件，以及经过编译的pyd文件。 可以在不具备编译环境的情况下，选择合适自己的Python环境进行安装。 说白了，.whl就是python的压缩包。 目前wheel被认为是Python的二进制包的标准格式。 ## 安装 ```bash pip install xxxx.whl # 或者如果是升级 pip install U xxxx.whl # 或者如果是卸载 pip uninstall xxxx.whl ``` ## 生成 ```bash pip install setuptools wheel ``` ``` my_package/ │ ├── my_package/ │ ├── __init__.py │ └── my_module.py │ ├── setup.py └── README.md ``` `my_package/`: 包含你的源代码。 `setup.py`: 包含包的配置信息。 `README.md`: 包的描述文档（可选）。 ### setup.py ```python from setuptools import setup, find_packages setup( name 'my_package', # 包名 version '0.1.0', # 版本号 packages find_packages(), # 自动查找子包 install_requires [ # 依赖包 # 'numpy', # 示例依赖 ], description 'My sample Python package', # 包描述 long_description open('README.md').read(), # 长描述 long_description_content_type 'text/markdown', # 描述类型 url 'https://github.com/yourusername/my_package', # 项目地址 author 'Your Name', # 作者 author_email 'your.email@example.com', # 作者邮箱 classifiers [ # 分类信息 'Programming Language :: Python :: 3', 'License :: OSI Approved :: MIT License', 'Operating System :: OS Independent', ], python_requires '> 3.6', # Python 版本要求 ) ``` 使用命令`python setup.py bdist_wheel`即可进行打包 ## setup.py https://setuptools.pypa.io/en/latest/setuptools.html ![](https://pic3.zhimg.com/v2 4563e810d05ec25ce283c7f54a271e2e_r.jpg) 这个文件是为了打包存在的文件, 最初的时候使用的是工具`distutils`, `distutils` 的精髓在于编写 `setup.py`，它是模块分发与安装的指导文件 `setuptools` 是 distutils 增强版，不包括在标准库中。其扩展了很多功能，能够帮助开发者更好的创建和分发 Python 包。大部分 Python 用户都会使用更先进的 setuptools 模块 当你安装完 setuptools 后，就拥有了一个叫做 `easy_install` 的第三方管理工具，这也是它区分于 distutils 的一大改进 ### python的包形式 1、以源码包的方式发布 源码包安装的过程，是先解压，再编译，最后才安装，所以它是跨平台的，由于每次安装都要进行编译，相对二进包安装方式来说安装速度较慢。源码包的本质是一个压缩包 2、以二进制包形式发布 二进制包的安装过程省去了编译的过程，直接进行解压安装，所以安装速度较源码包来说更快。 由于不同平台的编译出来的包无法通用，所以在发布时，需事先编译好多个平台的包, 一般以`.egg`, `.whl`结尾 Egg 格式是由 setuptools 在 2004 年引入，而 Wheel 格式是由PEP427在2012 年定义。Wheel 的出现是为了替代 Egg，它的本质是一个zip包，其现在被认为是 Python 的二进制包的标准格式。 ### 文件编写 ```python from setuptools import setup, find_packages setup( name \"mytest\", version \"1.0\", author \"wangbm\", author_email \"wongbingming@163.com\", description \"Learn to Pack Python Module\", # 项目主页 url \"http://iswbm.com/\", # 你要安装的包，通过 setuptools.find_packages 找到当前目录下有哪些包 packages find_packages() ) ``` #### classifiers `classifiers` 参数说明包的分类信息, 实际是一个字符串的数组, 可以在https://pypi.org/pypi?%3Aaction list_classifiers这里查看所有可以使用的项 ```python setup( classifiers [ # 发展时期,常见的如下 # 3 Alpha # 4 Beta # 5 Production/Stable 'Development Status :: 3 Alpha', # 开发的目标用户 'Intended Audience :: Developers', # 属于什么类型 'Topic :: Software Development :: Build Tools', # 许可证信息 'License :: OSI Approved :: MIT License', # 目标 Python 版本 'Programming Language :: Python :: 2', 'Programming Language :: Python :: 2.7', 'Programming Language :: Python :: 3', 'Programming Language :: Python :: 3.3', 'Programming Language :: Python :: 3.4', 'Programming Language :: Python :: 3.5', ] ) ``` #### 添加文件 ```python from setuptools import setup, find_packages setup( name \"mytest\", version \"1.0\", author \"wangbm\", author_email \"wongbingming@163.com\", description \"Learn to Pack Python Module\", url \"http://iswbm.com/\", packages find_packages(), # 安装过程中，需要安装的静态文件，如配置文件、service文件、图片等 data_files [ ('', ['conf/*.conf']), ('/usr/lib/systemd/system/', \t\t['bin/*.service']), ], # 希望被打包的文件 package_data { '':['*.txt'], 'bandwidth_reporter':['*.txt'] }, # 不打包某些文件 exclude_package_data { 'bandwidth_reporter':['*.txt'] } ) ``` 除了以上的参数配置之外，还可以使用一个叫做 `MANIFEST.in` 的文件，来控制文件的分发 ```ini include *.txt recursive include examples *.txt *.py prune examples/sample?/build ``` 所有根目录下的以 txt 为后缀名的文件，都会分发 根目录下的 examples 目录 和 txt、py文件都会分发 路径匹配上 examples/sample?/build 不会分发 `MANIFEST.in` 需要放在和 setup.py 同级的顶级目录下，setuptools 会自动读取该文件 #### 依赖的包 ```python from setuptools import setup, find_packages setup( ... # 表明当前模块依赖哪些包，若环境中没有，则会从pypi中下载安装 install_requires ['docutils> 0.3'], # setup.py 本身要依赖的包，这通常是为一些setuptools的插件准备的配置 # 这里列出的包，不会自动安装。 setup_requires ['pbr'], # 仅在测试时需要使用的依赖，在正常发布的代码中是没有用的。 # 在执行python setup.py test时，可以自动安装这三个库，确保测试的正常运行。 tests_require [ 'pytest> 3.3.1', 'pytest cov> 2.5.1', ], # 用于安装setup_requires或tests_require里的软件包 # 这些信息会写入egg的 metadata 信息中 dependency_links [ \"http://example2.com/p/foobar 1.0.tar.gz\", ], # install_requires 在安装模块时会自动安装依赖包 # 而 extras_require 不会，这里仅表示该模块会依赖这些包 # 但是这些包通常不会使用到，只有当你深度使用模块时，才会用到，这里需要你手动安装 extras_require { 'PDF': [\"ReportLab> 1.2\", \"RXP\"], 'reST': [\"docutils> 0.3\"], } ) ``` 关于 `install_requires`， 有以下五种常用的表示方法： 1. `'argparse'`，只包含包名。 这种形式只检查包的存在性，不检查版本。 方便，但不利于控制风险。 2. `'setuptools 38.2.4'`，指定版本。 这种形式把风险降到了最低，确保了开发、测试与部署的版本一致，不会出现意外。 缺点是不利于更新，每次更新都需要改动代码。 3. `'docutils > 0.3'`，这是比较常用的形式。 当对某个库比较信任时，这种形式可以自动保持版本为最新。 4. `'Django > 1.11, ! 1.11.1, < 2'`，这是比较复杂的形式。 如这个例子，保证了Django的大版本在1.11和2之间，也即1.11.x；并且，排除了已知有问题的版本1.11.1（仅举例）。 对于一些大型、复杂的库，这种形式是最合适的。 5. `'requests[security, socks] > 2.18.4'`，这是包含了额外的可选依赖的形式。 正常安装requests会自动安装它的`install_requires`中指定的依赖，而不会安装`security`和`socks`这两组依赖。 这两组依赖是定义在它的`extras_require`中。 这种形式，用在深度使用某些库时。 #### python版本 `python_requires '> 2.7, < 3',`有些库并不是在所以的 Python 版本中都适用的，若一个库安装在一个未兼容的 Python 环境中，理论上不应该在使用时才报错 #### 生成可执行文件 ```python from setuptools import setup, find_packages setup( name \"mytest\", version \"1.0\", author \"wangbm\", author_email \"wongbingming@163.com\", description \"Learn to Pack Python Module\", url \"http://iswbm.com/\", packages find_packages(), # 用来支持自动生成脚本，安装后会自动生成 /usr/bin/foo 的可执行文件 # 该文件入口指向 foo/main.py 的main 函数 entry_points { 'console_scripts': [ 'foo foo.main:main' ] }, # 将 bin/foo.sh 和 bar.py 脚本，生成到系统 PATH中 # 执行 python setup.py install 后 # 会生成 如 /usr/bin/foo.sh 和 如 /usr/bin/bar.py scripts ['bin/foo.sh', 'bar.py'] ) ``` 上面的 scripts 里有的脚本中有 `sh` 和 `py` 后缀，那么安装后，setuptools 会原封不动的移动到 /usr/bin 中，并添加可执行权限, 可以使用脚本进行进一步的工作 ```python from setuptools.command.install_scripts import install_scripts # 定义一个脚本类 class InstallScripts(install_scripts): def run(self): setuptools.command.install_scripts.install_scripts.run(self) # Rename some script files for script in self.get_outputs(): if basename.endswith(\".py\") or basename.endswith(\".sh\"): dest script[: 3] else: continue print(\"moving %s to %s\" % (script, dest)) shutil.move(script, dest) setup( ... scripts ['bin/foo.sh', 'bar.py'], \t\t# 注册 cmdclass { \"install_scripts\": InstallScripts } ) ``` #### 编译C/C++ `ext_modules` 参数用于构建 C 和 C++ 扩展扩展包。其是 Extension 实例的列表，每一个 Extension 实例描述了一个独立的扩展模块，扩展模块可以设置扩展包名，头文件、源文件、链接库及其路径、宏定义和编辑参数等 ```python setup( # other arguments here... ext_modules [ Extension('foo', glob(path.join(here, 'src', '*.c')), libraries [ 'rt' ], include_dirs [numpy.get_include()]) ] ) ``` 第一个参数 `'foo'` 是**扩展模块的名称**： 编译完成后，会生成类似 `foo.so`（Linux/macOS）或 `foo.pyd`（Windows）的文件； 在 Python 中可直接 `import foo` 使用该模块 第二个参数，指定**要编译的 C 源文件列表**，拆解： `here`：通常是提前定义的变量，代表当前 `setup.py` 脚本所在的目录（如 `here os.path.abspath(os.path.dirname(__file__))`）； `path.join(here, 'src', '*.c')`：拼接路径，指向 `setup.py` 所在目录下的 `src` 子目录，匹配所有 `.c` 后缀的文件； `glob()`：将通配符路径（`*.c`）转换为具体的文件路径列表（比如 `src/a.c`、`src/b.c`），告诉编译器要编译这些源文件。 ✅ 替代方案：如果只想编译特定文件，可直接传列表（如 `['src/foo.c', 'src/utils.c']`），不用 `glob` #### `libraries ['rt']`指定编译时需要**链接的系统库**： `'rt'` 是 Linux 下的 `librt.so`（Real Time Library，实时库），提供 POSIX 实时扩展功能（如高精度时钟、定时器、共享内存）； 编译时，编译器会自动添加 ` lrt` 参数（链接库的标准写法）； #### `include_dirs [numpy.get_include()]`指定编译时的**头文件搜索目录** `numpy.get_include()`：返回 NumPy 的头文件目录路径（如 `/usr/lib/python3.x/site packages/numpy/core/include`）； 如果你的 C 代码中用到了 NumPy 的 C API（比如操作 NumPy 数组、使用 `numpy.ndarray` 的底层结构），编译器需要找到这些头文件才能编译通过； ✅ 扩展：可添加自定义头文件目录，比如 `include_dirs [numpy.get_include(), os.path.join(here, 'include')]`（`include` 是自定义头文件目录） ## setup.py文件使用 ### 打包文件 用于发布一个 Python 模块或项目，将源码打包成 tar.gz （用于 Linux 环境中）或者 zip 压缩包（用于 Windows 环境中） ```bash $ python setup.py sdist ``` 那这种包如何安装呢 答案是，使用下一节即将介绍的 `setuptools` 中提供的 `easy_install` 工具。 ```text $ easy_install xxx.tar.gz ``` 使用 sdist 将根据当前平台创建默认格式的存档。在类 Unix 平台上，将创建后缀后为 `.tar.gz` 的 gzip 压缩的tar文件分发包，而在Windows上为 ZIP 文件。 当然，你也可以通过指定你要的发布包格式来打破这个默认行为 ```bash $ python setup.py sdist formats gztar,zip ``` ![](https://pic4.zhimg.com/v2 7416d2c5ffd4fde928d7bd214ea59d39_1440w.jpg) 另外，如果您希望归档文件的所有文件归root拥有，可以这样指定 ```bash python setup.py sdist owner root group root ``` 在windows中我们习惯了双击 exe 进行软件的安装，Python 模块的安装也同样支持 打包成 exe 这样的二进制软件包。 ```bash $ python setup.py bdist_wininst ``` 而在 Linux 中，大家也习惯了使用 rpm 来安装包，对此你可以使用这条命令实现 rpm 包的构建 ```bash $ python setup.py bdist_rpm ``` 若你的项目，需要安装多个平台下，既有 Windows 也有 Linux，按照上面的方法，多种格式我们要执行多次命令，为了方便，你可以一步到位，执行如下这条命令，即可生成多个格式的进制 ```bash $ python setup.py bdist ``` ### 直接安装以及调试 正常情况下，我们都是通过以上构建的源码包或者二进制包进行模块的安装。 但在编写 setup.py 的过程中，可能不能一步到位，需要多次调试，这时候如何测试自己写的 setup.py 文件是可用的呢？ 这时候你可以使用这条命令，它会将你的模块安装至系统全局环境中 ```bash $ python setup.py install ``` 如若你的项目还处于开发阶段，频繁的安装模块，也是一个麻烦事。 这时候你可以使用这条命令安装，该方法不会真正的安装包，而是在系统环境中创建一个软链接指向包实际所在目录。这边在修改包之后不用再安装就能生效，便于调试。 ```bash $ python setup.py develop ```"},"/note/编程基础/python/基础语法/2024-4-26-10文件基本操作.html":{"title":"文件基本操作","content":" layout: post title: \"文件基本操作\" date: 2023 6 15 15:39:08 +0800 tags: python基础 # 文件基本操作 ## 基本函数 ### open打开文件 ```python open(name[, mode[, buffering]]) ``` > name : 一个包含了你要访问的文件名称的字符串值。 > > mode : mode 决定了打开文件的模式：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，默认文件访问模式为只读(r)。 > > buffering : 如果 buffering 的值被设为 0，就不会有寄存。如果 buffering 的值取 1，访问文件时会寄存行。如果将 buffering 的值设为大于 1 的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。 模式 描述 : : t 文本模式 (默认)。 x 写模式，新建一个文件，如果该文件已存在则会报错。 b 二进制模式。 + 打开一个文件进行更新(可读可写)。 U 通用换行模式（不推荐）。 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。 w 打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 w+ 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 > 这一个函数会返回一个文件的结构体 ### read/write读写 1. `write()`方法可以向文件中写入指定内容。 2. `writelines()`方法可以将多行内容写入文件。(使用一个列表) ```python f open(\"test.txt\", \"w\") f.write(\"Hello world\") ``` 1. read() 函数：逐个字节或者字符读取文件中的内容； 2. readline() 函数：逐行读取文件中的内容； 3. readlines() 函数：一次性读取文件中多行内容。把所有的行放在一个列表里面 4. 文件对象是可迭代的，因此我们可以使用`for`循环逐行读取文件内容。 5. 使用`with`语句打开文件，可以确保在文件使用完毕后自动关闭文件，避免资源泄漏。 ```python file.read([size]) ``` > size 作为一个可选参数，用于指定一次最多可读取的字符（字节）个数，如果省略，则默认一次性读取所有内容。 ```python with open('example.txt', 'r') as file: for line in file: print(line) ``` ```python with open('example.txt', 'r') as file: content file.read() print(content) # 文件自动关闭 ``` > [Python中with的用法_python中with用法 CSDN博客](https://blog.csdn.net/Ego_Bai/article/details/80873242) > > with 语句实现原理建立在上下文管理器之上。 > > 上下文管理器是一个实现 **\\_\\_enter\\_\\_** 和 **\\_\\_exit\\_\\_** 方法的类。 ### close关闭 ```python f.close() ``` ## 使用os.walk遍历文件 这一个可以遍历出来文件夹里面的所有文件以及文件夹 这一个函数的返回值是一个迭代器 > 这一个函数的walk参数是一个路径, 返回值是一个元组 ![image 20240427100835035](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202404271008074.png) ```python import os for temp in os.walk(\"./test\"): print(temp) ``` ```bash PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" ('./test', ['test1', 'test2'], ['test.md', 'test.txt']) ('./test\\\\test1', [], ['test1.txt']) ('./test\\\\test2', [], ['test2.txt']) ``` > 第一个参数是这一个文件夹的路径, 第二个参数是这一个文件夹里面的文件夹, 第三个数据是这一个文件夹里面的文件的名称 > > 实际使用深度遍历, 把一个文件夹里面所有的文件遍历完以后出来遍历和他同一级的其他文件 ### os.**listdir**(*path '.'*) 返回一个包含由 *path* 指定目录中条目名称组成的列表。 该列表按任意顺序排列，并且不包括特殊条目 `'.'` 和 `'..'`，即使它们存在于目录中。"},"/note/编程基础/python/基础语法/2024-4-27-11OS模块.html":{"title":"OS模块","content":" layout: post title: \"OS模块\" date: 2024 4 27 15:39:08 +0800 tags: python基础 # OS模块 > [Python os 模块详解 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/150835193) `os`模块提供的就是各种 Python 程序与操作系统进行交互的接口。通过使用`os`模块，一方面可以方便地与操作系统进行交互，另一方面页可以极大增强代码的可移植性。如果该模块中相关功能出错，会抛出`OSError`异常或其子类异常。 > 注意，如果是读写文件的话，建议使用内置函数`open()`；如果是路径相关的操作，建议使用`os`的子模块`os.path`；如果要逐行读取多个文件，建议使用`fileinput`模块；要创建临时文件或路径，建议使用`tempfile`模块；要进行更高级的文件和路径操作则应当使用`shutil`模块。 [10. Brief Tour of the Standard Library — Python 3.12.3 documentation](https://docs.python.org/3/tutorial/stdlib.html) [os — Miscellaneous operating system interfaces — Python 3.12.3 documentation](https://docs.python.org/3/library/os.html)"},"/note/编程基础/python/基础语法/2024-4-25-08匿名函数.html":{"title":"匿名函数","content":" layout: post title: \"匿名函数\" date: 2023 6 15 15:39:08 +0800 tags: python基础 # 匿名函数 使用def定义的函数是一个普通的函数, 适合用于功能完善的代码 匿名函数使用`lambda` ## 定义 ```python lambda value1, value2 ... : 表达式 ``` > ```python > lambda a, b : a + b > ``` ## 调用 这一个函数没有名字, 使用的时候一般使用一个变量指向这一个函数, 之后使用这一个变量进行调用 ```python my_test_func lambda a, b : a + b my_test_func(11, 22) ``` 还有一种使用方式是把这一个当做函数的参数进行传递, 之后使用这一个函数的参数调用这一个函数 ```python def func_test(func): \tprint(func(11, 22)) func_test(lambda a,b : a + b) ``` ## 实际的使用 使用sort的时候, 不能对一个字典里列表面的数据进行排序, 这时候可以设置sort函数的key参数 这一个key指向一个函数, 这一个函数会返回一个用于比较的值 ```python stus [ {\"name\": \"jiao\", \"age\":21}, {\"name\": \"shi\", \"age\":23}, {\"name\": \"dong\", \"age\":19}, ] # def sort_by_age(arg): # return arg[\"age\"] # print(stus) # stus.sort(key sort_by_age) print(stus) stus.sort(key lambda arg: arg[\"age\"]) ``` ```bash PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" [{'name': 'jiao', 'age': 21}, {'name': 'shi', 'age': 23}, {'name': 'dong', 'age': 19}] [{'name': 'dong', 'age': 19}, {'name': 'jiao', 'age': 21}, {'name': 'shi', 'age': 23}] ```"},"/note/编程基础/python/基础语法/2025-12-19-CPP交互使用.html":{"title":"调用CPP库","content":"# 调用CPP库 ## CPP使用python代码 ```python def add(a: int, b: int): res a + b return res def sub(a: int, b: int): return a b ``` ```cpp #include <Python.h> #include <cstdint> #include <iostream> int32_t add_from_python(int32_t a, int32_t b, int32_t& res) { // 获取使用的python文件 PyObject* pModuleName PyUnicode_FromString(\"py_math\"); if (!pModuleName) { PyErr_Print(); return 1; } // 导入模块 PyObject* pModule PyImport_Import(pModuleName); if (!pModule) { PyErr_Print(); Py_DECREF(pModuleName); return 1; } /* great_module.great_function */ PyObject* pFunc PyObject_GetAttrString(pModule, \"add\"); if (!pFunc !PyCallable_Check(pFunc)) { PyErr_Print(); Py_DECREF(pModule); Py_DECREF(pModuleName); return 1; } // 设置参数 PyObject* pArgs PyTuple_Pack( 2, PyLong_FromLong(a), PyLong_FromLong(b) ); if (!pArgs) { PyErr_Print(); Py_DECREF(pFunc); Py_DECREF(pModule); Py_DECREF(pModuleName); return 1; } // 调用函数 PyObject* pValue PyObject_CallObject(pFunc, pArgs); if (!pValue) { PyErr_Print(); Py_DECREF(pFunc); Py_DECREF(pModule); Py_DECREF(pModuleName); return 1; } // 获取结果 res PyLong_AsLong(pValue); Py_DECREF(pValue); Py_DECREF(pFunc); Py_DECREF(pModule); Py_DECREF(pModuleName); return 0; } int main() { // 1. 初始化 Python 解释器 Py_Initialize(); // 2. 调用 Python 代码 int32_t result 0; auto ret add_from_python(3, 2, result); if (ret < 0) { std::cerr << \"add_from_python error ret:\" << ret << std::endl; } else { std::cout << \"3 + 2 \" << result << std::endl; } // 3. 结束 Python 解释器 Py_Finalize(); return 0; } ``` ### 编译文件 ```bash g++ g cpp_call_python.cpp \\ o cpp_call_python \\ I/Users/jiao/miniconda3/include/python3.9 \\ L/Users/jiao/miniconda3/lib \\ Wl, rpath,/Users/jiao/miniconda3/lib \\ lpython3.9 ``` 由于使用的文件是在.目录下面的, 所以需要设置环境变量 ```bash export PYTHONPATH .:$PYTHONPATH ``` ` I/Users/jiao/miniconda3/include/python3.9` 把这个目录加入“头文件搜索路径”。 这样 `#include <Python.h>` 时，编译器会在这个目录里找到 `Python.h`。 ` L/Users/jiao/miniconda3/lib` 把这个目录加入“库文件搜索路径”。 链接 ` lpython3.9` 时，会在这里寻找 `libpython3.9.dylib` / `libpython3.9.a`。 ` Wl, rpath,/Users/jiao/miniconda3/lib` ` Wl,` 表示“把后面的选项传给链接器（ld）”。 ` rpath,/Users/jiao/miniconda3/lib` 指定运行时库搜索路径（runtime library search path）。 也就是把 [lib](vscode file://vscode app/Applications/Visual Studio Code.app/Contents/Resources/app/out/vs/code/electron browser/workbench/workbench.html) 写进可执行文件里，程序运行时 dyld 会在这个目录里找 `libpython3.9.dylib`，解决你之前的 “Library not loaded: @rpath/libpython3.9.dylib” 问题。 ` lpython3.9` 链接名为 `libpython3.9.*` 的库文件（`lib` 前缀和 `.dylib/.a` 后缀省略）。 这是把 Python 解释器“嵌入”进你的 C++ 程序 ## python调用CPP ```python from cpp_math import add print(\"3 + 2 \", add(3, 2)) ``` ```cpp #include <Python.h> #include <cstdint> #include <iostream> int32_t add(int32_t a, int32_t b) { return a + b; } static PyObject* _add(PyObject* self, PyObject* args) { int32_t _a; int32_t _b; int32_t res; // 将Python的参数转换为C++的参数 if (!PyArg_ParseTuple(args, \"ii\", &_a, &_b)) return NULL; // 调用add函数 res add(_a, _b); // 将C++的返回值转换为Python的返回值 return PyLong_FromLong(res); } static PyMethodDef MathModuleMethods[] { { \"add\", _add, METH_VARARGS, \"\" }, { NULL, NULL, 0, NULL } }; static struct PyModuleDef MathModule { PyModuleDef_HEAD_INIT, \"cpp_math\", // 模块名称 NULL, // 模块文档 1, // 模块状态 MathModuleMethods }; // (C扩展)模块初始化 PyMODINIT_FUNC PyInit_cpp_math(void) { // 创建模块对象 return PyModule_Create(&MathModule); } ``` ### 编译 ```bash g++ std c++11 fPIC shared cpp_math.cpp o cpp_math.so \\ I/Users/jiao/miniconda3/include/python3.9 \\ undefined dynamic_lookup ``` `g++`使用 C++ 编译器（和 `gcc` 相比，自动按 C++ 规则编译、链接 C++ 标准库）。 ` std c++11`选择 C++ 语言标准（可换成 `c++14`、`c++17` 等，不加也通常能编，但推荐写清楚）。 ` fPIC`生成“位置无关代码”（Position Independent Code），这是做共享库/动态库时必须的，否则 `.so` 被加载时会有问题。 ` shared`告诉编译器“生成共享库”，而不是普通可执行文件。 结果就是一个可以被 Python `import` 或 `ctypes.CDLL` 加载的cpp_math.so。 ` I/Users/jiao/miniconda3/include/python3.9` 把 Python 头文件目录加入“头文件搜索路径”，这样 `#include <Python.h>` 时能找到头文件。如果你的 C++ 代码里完全没用到 `<Python.h>`，这项是可选的。 ` undefined dynamic_lookup`（macOS 特有，做 Python 扩展时很常用）允许链接时保留“未解析的符号”，等到模块被 Python 加载时，再从 Python 解释器里解析这些符号。"},"/note/编程基础/python/基础语法/2024-4-25-06推导式和拆包.html":{"title":"推导式和拆包","content":" layout: post title: \"推导式和拆包\" date: 2024 4 25 15:39:08 +0800 tags: python基础 # 推导式和拆包 ## 推导式 这是一个快速地生成数据的方式 比如在数组里面存1, 3, 5...99 ```python [x for x in range(1, 100) if x % 2 0] ``` > 只一个不可以生成元组, 可以用于列表, 字典和集合 这一个循环是可以嵌套的 ```python [(x, y) for x in range(1, 3) for y in range(3)] [(1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)] ``` + 实际生成一个[[1, 2, 3], [4, 5, 6] ... ]的列表 ```python a [x for x in range(1, 101)] b [a[x:x+3] for x in range(0, len(a), 3)] ``` 生成字典 ```python {x:x**2 for x in range(1, 11)} ``` ## 拆包 一种快速的提取数据的方式 ```python nums (11, 22, 33) num1, num2, num3 nums ``` > 左侧的数据的个数必须和右侧的个数一样, 拆集合的话这一个的顺序不一定 > > 对字典进行拆包的时候默认获取的是key的值 ```python for temp in dict.items(): a, b temp print(a, b) ``` > 可以使用这一个方式对字典进行拆包 ```python for k, v in dict.items(): print(k, v) ``` > 使用这一个更加简单 可以使用这一种方法实现交换数据 ```python a, b b, a ``` > 在python里面默认把一个`11, 22, 33`这样的数据当做一个元组 ### 使用*和**进行拆包 如果一个函数需要的参数恰好是一个元组, 数组, 集合里面的所有数值 ```python def func(a, b, c): pass nums [11, 22, 33] func(nums[1], nums[2], nums[3]) func(*nums) ``` > 这两种实际是相同的, **是对知字典进行拆包 ```python def func(name, web, age): pass jiao { \"name\": \"jiao\", \"web\": \"www.xvsenfeng.asia\", \"age\": 18 } func(**jiao) ``` > 这一个函数的参数的名字需要是这一个字典里面的key的值 > > 实际传入的参数格式`(name jiao, web \"www.xvsenfeng.asia\", age 18)` 在实际使用的时候推荐使用不定长参数"},"/note/编程基础/python/基础语法/2024-5-4-19垃圾回收.html":{"title":"垃圾回收","content":" layout: post title: \"垃圾回收\" date: 2024 4 27 15:39:08 +0800 tags: python基础 # 垃圾回收 ## Python的机制 ### 小整数对象池 Python为了优化速度使用了小整数对象池, 避免整数频繁申请和销毁 Python的[ 5, 256]这些整数的对象提前建立好了, 不会被垃圾回收, 在Python里面所有的这一些数据实际使用的是同一个对象, 单个的字母也是这样的 如果是一个字符串, 这一个字符串的引用为0的时候这一个字符串会被回收 ### 大整数对象池 每一个大整数实际都是一个新的对象 ### 字符串驻留 相同的字符串默认开启intern机制, 指向同一个对象, 字符串里面有空格等特殊字符的时候不会开启这一个机制 ## 垃圾回收 Garbage collection垃圾回收, 高级语言里面一般都有自己的回收机制, C语言里面的内存为自己管理的 Python里面有一个自己的回收机制, Python使用自动引用计数（Reference Counting）和循环垃圾回收（Cycle Detection）来实现垃圾回收。 1. 引用计数：Python使用引用计数来跟踪内存中的对象引用数量。当对象被创建时，引用计数会增加；当对象被引用时，引用计数会减少。当引用计数为0时，对象被释放并回收内存。 2. 循环垃圾回收(隔代收集)：虽然引用计数可以处理大部分情况下的内存释放，但是循环引用会导致引用计数失效。当对象之间存在循环引用时，Python会使用循环垃圾回收机制来检测和清理这些无法访问到的对象。 Python里面会有一部分没有办法释放的内存, 所以需要使用GC ### 引用计数的优缺点 + 优点 1. 简单 2. 实时性没有使用的时候直接释放, 回收的时间平摊在平时 + 缺点 1. 维护计数消耗资源 2. 无法解决循环引用(多个对象相互记录) ## 零代 Python使用了一个链表记录已经创建了的对象, 这一个链表叫做零代链表 Python会循环遍历这一个链表, 找出里面的相互调用的对象进行统计, 在实际回收的时候, 会把这些循环引用的数值进行减少, 之后把还在使用的对象移动到另一条链子上面 Python里面有一个阈值, 根据创建的对象的个数以及删除的对象的个数进行调用这一个回收机制 ## 测试 ```python import gc class ClassA(): def __init__(self) > None: print(\"object born, id %s\"%str(id(self))) def f2(): while True: c1 ClassA() c2 ClassB() c1.t c2 c2.t c1 del c1 del c2 # 关闭内存管理 gc.disable() f2() ``` ## 触发条件 1. gc模块达到一个阈值的时候自动回收 2. 使用`gc.collect`手动回收 3. 程序退出, 解释器会回收 ## 引用计数变换的条件 + +1 1. 对象创建的时候 2. 对象引用的时候 3. 作为参数传入一个函数 4. 作为一个元素记录在容器里面 + 1 1. 使用del的时候 2. 对象的别名给了他一个新的值 3. 一个对象离开他的作用域 4. 对象所在的容器销毁, 或者从容器里面删除的时候 > 可以使用sys模块里面的`sys.getrefcount()`函数查看这一个对象的引用个数 ## 垃圾回收触发机制 python里面使用隔代收集的方法, 对象在创建的时候在一代列表里面, 一代的检查以后进入二代列表, 以此类推, 最多三代列表 可以使用`gc.get_count`获取这一个列表的计数器 ```python In [6]: import gc In [7]: gc.get_count() Out[7]: (62, 0, 8) ``` > 这里的62是距离上一次一代检查, python分配减去释放的内存个数, 0是距离上一次二代检查一代检查的次数, 8是二代检查的次数 ```python In [8]: gc.get_threshold() Out[8]: (700, 10, 10) ``` > 这一个是阈值"},"/note/编程基础/python/基础语法/2024-4-27-13异常处理.html":{"title":"异常处理","content":" layout: post title: \"异常处理\" date: 2024 4 27 15:39:08 +0800 tags: python基础 # 异常处理 异常即是一个事件，该事件会在程序执行过程中发生，影响了程序的正常执行。 一般情况下，在Python无法正常处理程序时就会发生一个异常。 异常是Python对象，表示一个错误。 当Python脚本发生异常时我们需要捕获处理它，否则程序会终止执行。 ## 异常处理 捕捉异常可以使用try/except语句。 try/except语句用来检测try语句块中的错误，从而让except语句捕获异常信息并处理。 如果你不想在异常发生时结束你的程序，只需在try里捕获它。 语法： 以下为简单的*try....except...else*的语法： ```python try: <语句> #运行别的代码 except <名字>： <语句> #如果在try部份引发了'name'异常 except <名字> as <别名>: <语句> #如果引发了'name'异常，获得附加的数据 else: <语句> #如果没有异常发生 ``` > 这里的expect不带异常表示捕获所有的异常, 也可以使用`except (ZeroDivisionError, ValueError):`这样的格式捕获多个异常 > > ```python > #!/usr/bin/python > # * coding: UTF 8 * > > # 定义函数 > def temp_convert(var): > try: > return int(var) > except ValueError as Argument: > print(\"参数没有包含数字\\n\", Argument) > > # 调用函数 > temp_convert(\"xyz\") > ``` > > > 这一个示例是一个带参数的捕获 ```python try: <语句> finally: <语句> #退出try时总会执行 raise ``` > finally会在退出的时候执行 ## 触发异常 可以使用`raise`这一个参数触发一个异常 ```python raise Exception ``` >语句中 Exception 是异常的类型（例如，NameError）参数标准异常中任一种，args 是自已提供的异常参数。最后一个参数是可选的（在实践中很少使用），如果存在，是跟踪异常对象。 一个异常可以是一个字符串，类或对象。 Python的内核提供的异常，大多数都是实例化的类，这是一个类的实例的参数。 ```python def functionName(level): if level < 1: raise Exception(\"Invalid level!\", level) try: functionName(0) # 触发异常 except Exception as err: print(err) else: print(2) ``` > ```bash > PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" > ('Invalid level!', 0) > ``` ## 用户自定义异常 通过创建一个新的异常类，程序可以命名它们自己的异常。异常应该是典型的继承自Exception类，通过直接或间接的方式。 以下为与RuntimeError相关的实例,实例中创建了一个类，基类为RuntimeError，用于在异常触发时输出更多的信息。 在try语句块中，用户自定义的异常后执行except块语句，变量 e 是用于创建Networkerror类的实例。 ```python class Networkerror(RuntimeError): def __init__(self, arg): self.args arg ``` 在你定义以上类后，你可以触发该异常，如下所示： ```python try: raise Networkerror(\"Bad hostname\") except Networkerror,e: print e.args ``` ## python标准异常 异常名称 描述 : : BaseException 所有异常的基类 SystemExit 解释器请求退出 KeyboardInterrupt 用户中断执行(通常是输入^C) Exception 常规错误的基类 StopIteration 迭代器没有更多的值 GeneratorExit 生成器(generator)发生异常来通知退出 StandardError 所有的内建标准异常的基类 ArithmeticError 所有数值计算错误的基类 FloatingPointError 浮点计算错误 OverflowError 数值运算超出最大限制 ZeroDivisionError 除(或取模)零 (所有数据类型) AssertionError 断言语句失败 AttributeError 对象没有这个属性 EOFError 没有内建输入,到达EOF 标记 EnvironmentError 操作系统错误的基类 IOError 输入/输出操作失败 OSError 操作系统错误 WindowsError 系统调用失败 ImportError 导入模块/对象失败 LookupError 无效数据查询的基类 IndexError 序列中没有此索引(index) KeyError 映射中没有这个键 MemoryError 内存溢出错误(对于Python 解释器不是致命的) NameError 未声明/初始化对象 (没有属性) UnboundLocalError 访问未初始化的本地变量 ReferenceError 弱引用(Weak reference)试图访问已经垃圾回收了的对象 RuntimeError 一般的运行时错误 NotImplementedError 尚未实现的方法 SyntaxError Python 语法错误 IndentationError 缩进错误 TabError Tab 和空格混用 SystemError 一般的解释器系统错误 TypeError 对类型无效的操作 ValueError 传入无效的参数 UnicodeError Unicode 相关的错误 UnicodeDecodeError Unicode 解码时的错误 UnicodeEncodeError Unicode 编码时错误 UnicodeTranslateError Unicode 转换时错误 Warning 警告的基类 DeprecationWarning 关于被弃用的特征的警告 FutureWarning 关于构造将来语义会有改变的警告 OverflowWarning 旧的关于自动提升为长整型(long)的警告 PendingDeprecationWarning 关于特性将会被废弃的警告 RuntimeWarning 可疑的运行时行为(runtime behavior)的警告 SyntaxWarning 可疑的语法的警告 UserWarning 用户代码生成的警告 "},"/note/编程基础/python/基础语法/2024-4-24-05程序获取参数.html":{"title":"获取参数","content":" layout: post title: \"获取参数\" date: 2023 6 15 15:39:08 +0800 tags: python基础 # 获取参数 ```python import sys printf(sys.argv) ``` > 这是一个数组,这里面的信息都是字符串"},"/note/编程基础/python/基础语法/2025-2-25-yaml.html":{"title":"yaml库","content":"# yaml库 ## 基础语法 + 注释 使用`#`进行注释 + 字典 使用键值对的方式进行存储 `key: value`使用冒号（:）表示键值对，键和值之间使用空格分隔。 + 嵌套, 可以使用缩进表示嵌套的结构，使用空格进行缩进。缩进的数量必须一致。不可以使用tab ```yaml parent_key: child_key1: value1 child_key2: value2 ``` + 列表, 使用短横线（ ）表示列表项，每个列表项占一行，使用相同的缩进进行缩进 ```yaml item1 item2 item3 ``` + 字符串, 可以使用单引号（'）或双引号（\"）表示字符串。如果字符串中包含特殊字符或需要转义字符，则使用双引号。 ```yaml key: 'value' key: \"value with special characters: \\n\" ``` + 多行字符串：使用竖线（）可以表示多行字符串，保留字符串的换行符。 ```yaml key: This is a multi line string. ``` + 引用：可以使用&标记创建引用，并使用*标记引用的位置。引用可以用于在不同位置重复使用相同的值。 ```yaml defaults: &defaults key1: value1 key2: value2 user1: <<: *defaults name: John user2: <<: *defaults name: Jane ``` > 通过使用“<<: *defaults”语法，将defaults的内容复制到user1和user2中。user1设置了name为John，而user2设置了name为Jane。 + 特殊值：YAML支持一些特殊的值，如布尔值（true、false）、null和时间戳等。 ```yaml key1: true key2: null key3: 2022 03 14T09:30:00Z ```"},"/note/编程基础/python/基础语法/2024-5-4-18GIL.html":{"title":"GIL全局解释锁","content":" layout: post title: \"GIL全局解释锁\" date: 2024 4 27 15:39:08 +0800 tags: python基础 # GIL全局解释锁 python里面的线程是一个任务, python和GIL没有关系, 这个是解释器的问题 默认的python解释器是使用的C语言, 这一个解释器难以移除GIL GIL: 全局解释锁, 线程在执行的时候需要获取GIL, 保证同一个时刻只有一个线程在执行代码 在线程使用IO的时候会释放GIL, 避免阻塞, python的多线程可以使用多核CPU 在实际的运行的时候, 多线程的python程序最多只有一个核的算力 ## 解决方法 实际执行的时候执行的线程代码使用其他的语言 可以使用python调用C语言的库 ```python from ctypes import * from threading import Thread from ctypes import * lib cdll.LoadLibrary(\"lib.so\") t Thread(target lib.run)\t\t# 执行这一个库里面的函数 t.start() while True: pass ```"},"/note/编程基础/python/基础语法/2024-4-30-16深拷贝浅拷贝.html":{"title":"深拷贝浅拷贝","content":" layout: post title: \"深拷贝浅拷贝\" date: 2023 9 23 15:39:08 +0800 tags: python基础 # 深拷贝浅拷贝 ## 浅拷贝 ```python import copy a [11, 22, 33] b copy.copy(a) ``` > a, b的id是不一样的, 但是里面的数据是一样的 ```python import copy a [11, 22] b [33, 44] c [a, b] d copy.copy(c) print(c) print(d) print(id(c[0])) print(id(d[0])) ``` > ```bash > PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" > [[11, 22], [33, 44]] > [[11, 22], [33, 44]] > 2125479968320 > 2125479968320 > ``` > > 使用这一个拷贝的时候c和d里面的指针指向的内容是一样的, 只拷贝了最顶层 ## 深拷贝 ```python import copy a [11, 22] b [33, 44] c [a, b] d copy.deepcopy(c) print(c) print(d) print(id(c[0])) print(id(d[0])) ``` > ```bash > PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" > [[11, 22], [33, 44]] > [[11, 22], [33, 44]] > 2009340411520 > 2009339899072 > ``` > > 使用这一个拷贝的时候会把这一个数组里面的指向也进行拷贝 ## 切片 使用一个切片进行拷贝的时候实际是一个浅拷贝 ```python import copy a [11, 22] b [33, 44] c [a, b] d c[:] print(c) print(d) print(id(c)) print(id(d)) print(id(c[0])) print(id(d[0])) ``` > ```python > PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" > [[11, 22], [33, 44]] > [[11, 22], [33, 44]] > 2837900324224 > 2837900323328 > 2837900787264 > 2837900787264 > ``` ## 字典的拷贝方法 ```python a { \"name\": \"jiao\", \"age\": 18, \"cars\" : [\"BMW\", \"Audi\", \"Benz\"] } b a.copy() print(id(a)) print(id(b)) print(a) print(b) print(id(a[\"cars\"])) print(id(b[\"cars\"])) ``` > ```bash > PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" > 1603023712768 > 1603023713024 > {'name': 'jiao', 'age': 18, 'cars': ['BMW', 'Audi', 'Benz']} > {'name': 'jiao', 'age': 18, 'cars': ['BMW', 'Audi', 'Benz']} > 1603023806720 > 1603023806720 > ``` > > 这也是一个浅拷贝 ## 浅拷贝注意 + 浅拷贝对于一个可变的类型会进行一个浅拷贝 + 对于一个不可变的类型只会改变指向 ```python import copy a [11, 22, 33] b (11, 22, 33) c copy.copy(a) d copy.copy(b) print(id(a), id(c)) print(id(b), id(d)) ``` > ```bash > PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" > 1404091006720 1404090543424 > 1404090853568 1404090853568 > ``` > 在遇到一个嵌套的数据类型的使用这一个只检测最顶层的那一个是不是可拷贝的类型 ## 实际使用场景 需要使用一个列表又不希望自己的操作影响到原来的列表的时候, 使用可以使用深拷贝(**注意这一个列表的大小!!!**)"},"/note/编程基础/python/基础语法/2025-3-21-包导入.html":{"title":"导入","content":"# 导入 python可以直接导入一个文件夹 如果一个文件夹里面的两个文件之间需要相互调用, 不可以直接进行`import`, 这一个参数的搜索路径是根据sys.path进行的, 所以搜索的时候会出现问题, module1里面的import不会在他的路径里面进行 ![image 20250321180912045](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202503211809291.png) 这时候可以使用`from . import module2` ![image 20250321181251263](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202503211812418.png) 可以使用的..从上一个文件夹里面选择另一个文件夹, 使用这种方式的时候实际的搜索路径会使用`__package__`里面, 第一个运行的文件没有这一个参数, 所以直接运行使用相对路径的文件会报错 直接使用import导入一个文件夹的时候, 这个文件夹里面的文件不会被执行, 如果里面有一个`__init__.py`文件, 会执行这个文件, 这个文件可以用于包的初始化, 可以在这个文件里面进行一部分的初始化导入, 使得一部分变量可以直接使用 入股使用的是`from xxx import *`, 在有这个文件的时候会导入这个文件`__all__`参数`[]`描述的变量 可以使用`__version__`标记这个包的版本, `__author__`记录作者 ```python \"\"\" build A simple, correct Python build frontend \"\"\" from __future__ import annotations from ._builder import ProjectBuilder from ._exceptions import ( BuildBackendException, BuildException, BuildSystemTableValidationError, FailedProcessError, TypoWarning, ) from ._types import ConfigSettings as ConfigSettingsType from ._types import Distribution as DistributionType from ._types import SubprocessRunner as RunnerType from ._util import check_dependency __version__ '1.3.0' __all__ [ 'BuildBackendException', 'BuildException', 'BuildSystemTableValidationError', 'ConfigSettingsType', 'DistributionType', 'FailedProcessError', 'ProjectBuilder', 'RunnerType', 'TypoWarning', '__version__', 'check_dependency', ] def __dir__() > list[str]: return __all__ ```"},"/note/编程基础/python/基础语法/2024-4-25-07引入.html":{"title":"引入","content":" layout: post title: \"引入\" date: 2023 6 15 15:39:08 +0800 tags: python基础 # 引用 引用实际就是一个地址 ```python In [10]: a 1 In [11]: b a In [12]: a 2 In [13]: a Out[13]: 2 In [14]: b Out[14]: 1 ``` > 这一种是直接修改它的指向 ```python In [5]: c [1, 2] In [6]: d c In [7]: c.append(4) In [8]: c Out[8]: [1, 2, 4] In [9]: d Out[9]: [1, 2, 4] ``` > c实际是指向这一个地址, d c也会指向这个地址, 可以使用id()查看这一个变量的地址 > > 这一个没有修改指向的地址, 而是改变了指向地址里面的数据 python里面的` `实际是一个修改引用的操作 实际上函数名也是一个引用"},"/note/编程基础/python/基础语法/2024-4-23-03虚拟环境.html":{"title":"虚拟环境","content":" layout: post title: \"虚拟环境\" date: 2024 4 23 15:39:08 +0800 tags: python基础 # 虚拟环境 建立一个虚拟环境 ```bash python m venv 环境名 ``` > 会在这一个路径下面创建一个虚拟环境 之后可以在这一个路径下面的执行Script/activate启动这一个环境 ## 使用anaconda ```python conda create n 名字 python 3.12 ``` ## 包管理问题 在使用pip进行安装的时候, 如果一个包依赖有其他的包, 在不使用这个包删除的时候不会删除他自己带进来的那个包, 为了解决这个问题, python引入pyproject.toml 配置文件进行管理 这个新的配置文件引入一个推荐的文件架构, 假设我们软件包的名字是 npts ，那么整个项目的目录结构在推荐的风格下看起来应该像这样。 ````bash tree ./ ./ ├── LICENSE ├── README.md ├── pyproject.toml ├── src │ └── npts # src 下面是包名，包下面是业务代码 │ ├── __init__.py └── core.py └── tests 3 directories, 5 files ```` 对应的配置文件如下 ```python [project] name \"npts\" version \"0.0.1\" [build system] requires [\"hatchling\"] build backend \"hatchling.build\" ``` 可以使用工具对整个项目进行打包 ```bash # 安装依赖 python3 m pip install upgrade build # 打包 python3 m build # ... #... ... Successfully built npts 0.0.1.tar.gz and npts 0.0.1 py2.py3 none any.whl ``` ## pyproject.toml文件 ```toml # pyproject.toml # 1. 构建系统声明 (必需) # 告诉 pip 等工具，这个项目需要用什么来构建 (这里是 setuptools) # 是 Python 生态中最核心的包构建、分发和安装工具 [build system] requires [\"setuptools> 61.0\"] build backend \"setuptools.build_meta\" # 2. 项目核心元数据 (必需) # 这部分取代了 setup.py 中的大部分参数 [project] name \"my awesome tool\" version \"0.1.0\" authors [ { name \"你的名字\", email \"你的邮箱@example.com\" }, ] description \"一个功能强大的现代工具\" readme \"README.md\" # 指定 README 文件 requires python \"> 3.9\" license { text \"MIT\" } classifiers [ \"Programming Language :: Python :: 3\", \"License :: OSI Approved :: MIT License\", \"Operating System :: OS Independent\", ] # 3. 依赖项 (核心)使用的各种包 # 这取代了 setup.py 中的 install_requires dependencies [ \"requests> 2.20\", \"numpy\", \"click\", ] # 4. 命令行工具 (可选) # 这取代了 setup.py 中的 entry_points [project.scripts] awesome_tool \"my_awesome_tool.main:cli\" # 5. 可选依赖 (可选) # 允许用户安装额外功能，例如 pip install \"my awesome tool[extra]\" [project.optional dependencies] extra [\"pandas\"] # 6. 项目链接 (可选) [project.urls] Homepage \"https://github.com/your_username/my_modern_project\" \"Bug Tracker\" \"https://github.com/your_username/my_modern_project/issues\" ``` 可以使用`pip install e .`自动识别这个文件进行安装 ### uv管理 + 创建环境, 传统 ```bash # 创建名为 .venv 的虚拟环境（默认） uv venv # 激活环境（macOS/Linux） source .venv/bin/activate ``` + 创建项目 ```bash uv init my_project uv init name my_uv_project version 0.1.0 python 3.11 cd my_project uv sync # 创建虚拟环境, 安装配置文件里面的依赖 source .venv/bin/activate uv add <pkg> # 添加新依赖并更新 pyproject.toml uv remove <pkg> ``` ![image 20251208110801294](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251208110801294.png) ## 项目打包 `python m build` 是 Python 官方推荐的**标准化包构建工具**（基于 `build` 库），核心作用是依据 `pyproject.toml`（PEP 621 标准）或传统 `setup.py`/`setup.cfg`，一键构建符合 PyPI 规范的 Python 包分发文件（`.whl` 二进制包 + `.tar.gz` 源码包），替代了老旧的 `python setup.py sdist/bdist_wheel` 方式。 需要安装build包, 可以使用`uv add build` ![image 20251208114526881](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251208114526881.png) 可以使用`twine check dist/*`检查build编译出来的包是不是符合规范, `uv add twine`即可下载, 符合规范的包可以上传PyPI, 这里的whl是编译好的文件, 下载比较快, tar.gz是没有编译的文件, 使用的时候需要编译但是兼容更多的操作系统"},"/note/编程基础/python/进阶使用/django/2025-7-28-05-静态文件.html":{"title":"静态文件","content":"# 静态文件 开发中在开启调试模式(debug True)时，django可以通过配置，允许用户通过对应的url地址访问django的静态文件。比如说图片, javaScript, CSS等 ![image 20250728104908672](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507281049720.png) `主应用/settings.py`，代码： ```python # 外界访问时候的前缀 STATIC_URL '/static/' # django模板中，可以引用{{STATIC_URL}}变量避免把路径写死。 # 可以访问的文件的列表 STATICFILES_DIRS [ BASE_DIR / 'static' ] # 指定这个目录以后可以直接在http://url.com/static/静态文件 访问 ``` > 项目上线以后，关闭debug模式时，django默认是不提供静态文件的访问支持，项目部署的时候，我们会通过收集静态文件使用nginx这种web服务器来提供静态文件的访问支持。 ## html里面使用 ```html {% load static %} <img src \"{% static 'my_app/example.jpg' %}\" alt \"My image\"> ``` 也可以直接写路径"},"/note/编程基础/python/进阶使用/django/2025-7-24-03-路由.html":{"title":"","content":"## 路由 Route路由, 是一种映射关系!!!**路由是把客户端请求的url地址和用户请求的应用程序**[这里意指django里面的视图]进行一对一绑定映射的一种关系。当然在项目中，我们常常说的路由一般是一个类。 这个类完成了路由要做的事情。 ### 路由分层 经过上面的学习，我们可以发现，每次编写视图函数都需要到路由文件中进行url地址绑定，但是随着项目的开发，以后我们的视图函数肯定是越来越多的。 为了避免将来视图函数太多导致无法明确区分哪些路由属于哪一个子应用的。我们可以现在刚开始项目的时候，把路由代码放回到对应的各个子应用目录下，单独存放。这就是django提供的路由分层。 1. 在子应用home下创建子路由文件,一般路由文件名建议是`urls.py` 2. 把子应用home下面的视图绑定代码转到`home/urls.py ![image 20250725110846739](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507251108800.png) ![image 20250725111232536](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507251112613.png) ### 路由原理 在django中所有的路由最终都被保存到一个变量 `urlpatterns.`, urlpatterns必须声明在主应用下的urls.py总路由中。这是由配置文件settings设置的ROOT_URLCONF指定的。 在django运行中，当客户端发送了一个http请求到服务端，服务端的web服务器则会从http协议中提取url地址, 从程序内部找到项目中添加到urlpatterns里面的所有路由信息的url进行遍历匹配。如果相等或者匹配成功，则调用当前url对应的视图方法。 在给urlpatterns路由列表添加路由的过程中,django一共提供了2个函数用于绑定路由与视图关系。 ```python from django.urls import path # 普通路由 from django.urls import re_path # 正则路由，会把url地址看成一个正则模式与客户端的请求url地址进行正则匹配 ``` > 正则表达式里面的参数, 会作为函数参数一起传进来 ```python from django.urls import path, re_path from . import views urlpatterns [ # re_path(r\"^info/(?P<参数名1>正则)/(?P<参数名2>正则).....$\", views.info1), re_path(r\"^info/(?P<id>\\d+)/(?P<page>0[1 9]+)$\", views.info1), re_path(r\"^mobile/(?P<mobile>1[3 9]\\d{9})$\", views.info2), ] ``` ### 路径问题 假设你的项目中定义了以下两个URL路由（在`urls.py`中）： ``` python# 不加斜杠 path('article', views.article_view), # 加斜杠 path('article/', views.article_view), ``` #### 访问示例 用户访问 **`/article`** 用户访问 **`/article/`** 在Django的配置中，无论你定义哪个路由，Django都能“智能”地重定向到正确的视图（除非你有特殊的`APPEND_SLASH False`配置）。这意味着两个URL都能访问到`article_view`。 #### 静态文件的相对路径问题 假设在你的HTML模板中，你引用静态文件如下： ``` <img src \"images/logo.png\" /> ``` **此时，问题来了：** 如果你的页面路径是`/article`（没有尾斜杠） 相对路径`images/logo.png`会被解析为： ``` /images/logo.png ``` 或者，如果你页面的完整路径是`/article`（没有尾斜杠），浏览器会尝试解析为： ``` /article/images/logo.png ``` 这就很可能导致路径错误，尤其是在你的静态文件目录实际上是在根路径下（比如`/static/images/logo.png`），此时相对路径会引发404错误。 #### 加斜杠与不加斜杠的影响 **加斜杠**： URL地址`/article/`中的相对路径`images/logo.png`会被解析为： ``` /article/images/logo.png ``` 这通常不是你想要的（除非你的路径结构恰好如此），并且会导致静态文件路径不正确。 **不加斜杠**： URL为`/article`，同样，静态文件路径会被相对解析为： ``` /article/images/logo.png ``` 也可能错误（尤其当你希望静态文件在根目录或者特定静态目录时）。 #### 解决方案 **推荐**：在静态文件路径或URL中使用绝对路径或模板标签（如`{% static 'images/logo.png' %}`），这样无论URL是否加尾斜杠，静态资源路径都不会出错。 **在路由设计中**：避免在路由定义中依赖不加斜杠的特性，或者在模板中加上`/`前缀，确保路径不出错。 ### 路由转换器 也可以叫路由验证器，有2个作用： 1. 把路由参数进行类型转换 2. 可以起到验证路由匹配的作用（让字符串路由path发挥正则路由re_path的作用） ```python from django.urls import path from . import views urlpatterns [ path(\"articles/2003/\", views.special_case_2003), path(\"articles/<int:year>/\", views.year_archive), path(\"articles/<int:year>/<int:month>/\", views.month_archive), path(\"articles/<int:year>/<int:month>/<slug:slug>/\", views.article_detail), ] ``` 下面的路径转换器在默认情况下是有效的： `str` 匹配除了 `'/'` 之外的非空字符串。如果表达式内不包含转换器，则会默认匹配字符串。 `int` 匹配 0 或任何正整数。返回一个 `int` 。 `slug` 匹配任意由 ASCII 字母或数字以及连字符和下划线组成的短标签。比如，`building your 1st django site` 。 `uuid` 匹配一个格式化的 UUID 。为了防止多个 URL 映射到同一个页面，必须包含破折号并且字符都为小写。比如，`075194d3 6885 417e a8a8 6c931e272f00`。返回一个 [`UUID`](https://docs.python.org/3/library/uuid.html#uuid.UUID) 实例。 > str包含UUID, 所有在使用的时候str写在后面 `path` 匹配非空字段，包括路径分隔符 `'/'` 。它允许你匹配完整的 URL 路径而不是像 `str` 那样匹配 URL 的一部分。 #### 自定义转换器 在当前子应用下新建`converters.py`下编写的，这里是我们刚学习，所以为了方便直接在路由urls.py下编写，代码： ```python from django.urls.converters import StringConverter, register_converter class MobileConverter(StringConverter): regex r\"1[3 9]\\d{9}\" # 匹配使用的表达式, 这里是匹配一个电话号 # register_converter(路由转换类, \"调用别名\") register_converter(MobileConverter, \"mob\") ``` 可以使用` path(\"sms/<mob:mobile>\", views.info5),`"},"/note/编程基础/python/进阶使用/django/2025-7-26-04-模版.html":{"title":"模版","content":"# 模版 ![image 20250726154405193](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507261544286.png) 1. 在工作中为了更好的展示数据给用户，所以都会使用html+css+js实现网页排版效果，但是很多开发人员并不能做到既擅长服务端开发又擅长前端开发的，当然，即便有，那这个开发人员的工资也不会低，而且同等条件下，1个人干活是怎么也比不过2个人的。所以，怎么让服务端的数据更好的展示到客户端，这就成为问题了。 2. **模板引擎是一种可以让开发者把服务端数据填充到html网页中完成渲染效果的技术**。它实现了把前端代码和服务端代码分离的作用，让项目中的**业务逻辑代码和数据表现代码分离**，让**前端开发者和服务端开发者可以更好的完成协同开发**。 3. Django框架中内置了web开发领域非常出名的一个DjangoTemplate模板引擎（简称：DTL）。 4. DTL官方文档: https://docs.djangoproject.com/zh hans/4.2/topics/templates/ 5. 要在django框架中使用模板引擎把视图中的数据更好的展示给客户端，需要完成3个步骤： 6. 1. 在项目配置文件settings.py中**指定保存**模板文件的模板**目录**。同时添加使用的子项目 一般模板目录都是设置在项目根目录或者主应用目录下。 7. ![image 20250726154805991](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507261548064.png) 8. ![image 20250726155152761](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507261551826.png) 9. 2. 在**视图中**基于django提供的渲染函数**绑定模板文件和需要展示的数据变量** 10. ![image 20250726155428518](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507261554573.png) 11. ```python from django.shortcuts import render def index(request): \"\"\"在index中调用模板引擎，渲染index.html页面, 实现前后端分离\"\"\" return render(request, 'index.html') ``` 12. 3. 在模板目录下创建对应的模板文件，并根据模板引擎内置的**模板语法**，填写输出视图传递过来的数据。 ![image 20250726155540249](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507261555319.png) ## 模板语法 Django的DTL或jinja2模板引擎提供的语法无非4种格式不同的语法，分别是变量，注释，标签，过滤器 ```python \"\"\"变量\"\"\" {{ 变量 }} \"\"\"注释\"\"\" {# 单行注释 #} {% comment %} 多行注释 {% endcomment %} \"\"\"标签\"\"\" {% 标签名 %} # 单标签 {% 开始标签 %} {% 结束标签 %} # 双标签 \"\"\"过滤器\"\"\" # 本质就是函数[可以是python函数，也可以是开发者自定义函数]，常用语在变量或者标签 # 单个无参数过滤器，变量默认作为过滤器的第1个参数，过滤器中return的内容作为结果被输出 {{ 变量 过滤器 }} # 单个有参数过滤器，参数1是变量，英文冒号后面跟着的参数按顺序依次使用英文逗号排列 {{ 变量 过滤器:参数2 }} # 多个无参数过滤器，每个 (竖杠) 左边的内容作为右边过滤器的默认第1个参数 {{ 变量 过滤器1 过滤器2 过滤器3 ..... }} # 多个有参数过滤器，每个过滤器的参数1是 竖杠作为结果。最后一个过滤器返回的结果被输出 {{ 变量 过滤器1:参数2 过滤器2:参数2 .... }} ``` ### 使用参数 ```html <!DOCTYPE html> <html lang \"en\"> <head> <meta charset \"UTF 8\"> <meta name \"viewport\" content \"width device width, initial scale 1.0\"> <title>Document</title> </head> <body> <h1>Hello World</h1> <h2>{{ title }}</h2> <p>{{ content }}</p> </body> </html> ``` ```python from django.shortcuts import render def index(request): \"\"\"在index中调用模板引擎，渲染index.html页面, 实现前后端分离\"\"\" data { \"title\": \"首页\", \"content\": \"这是首页的内容\", } return render(request, 'index.html', context data) ``` ```python from turtle import title from django.shortcuts import render def index(request): \"\"\"在index中调用模板引擎，渲染index.html页面, 实现前后端分离\"\"\" title \"首页\" content \"这是首页的内容\" return render(request, 'index.html', locals()) ``` ![image 20250726205449633](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507262055030.png) > 模版中可以使用`变量.pop`获取复合变量的第一个, 也可以使用`变量.数字`获取其中的指定位置 > > 也可以输出python的对象和自定义的对象 > > 方法的话不需要小括号, 直接输入到方法即可 ### 判断 ```python def index4(request): \"\"\"标签[判断和循环]\"\"\" name \"xiaoming\" lve [\"游泳\", \"收快递\",\"OB\"] user_lve \"www\" return render(request, \"index4.html\", locals()) ``` ```html <!doctype html> <html lang \"en\"> <head> <meta charset \"UTF 8\"> <title>Document</title> </head> <body> {% if request.GET.name %} <p>{{ request.GET.name }}，欢迎，欢迎！</p> {% endif %} {% if name \"root\" %} <p>超级用户，欢迎回家！</p> {% else %} <p>{{ name }},你好，欢迎来到xx网站！</p> {% endif %} {% if user_lve lve.0 %} <p>那么巧，你喜欢游泳，海里也能见到你~</p> {% elif user_lve lve.1 %} <p>那么巧，你也来收快递呀？~</p> {% elif user_lve lve.2 %} <p>那么巧，你也在老男孩？</p> {% else %} <p>看来我们没有缘分~</p> {% endif %} </body> </html> ``` ### 循环 ```html <!DOCTYPE html> <html lang \"en\"> <head> <meta charset \"UTF 8\"> <title>Title</title> </head> <body> {% for name, value in book_dict.items %} <p>{{ name }} {{ value }}</p> {% endfor %} <hr> <table border \"1\" width \"600\"> <tr> <th>ID</th> <th>Name</th> <th>price</th> </tr> {% for book in book_list1 %} <tr> <td>{{ book.id }}</td> <td>{{ book.name}} </td> <td>{{ book.price}}</td> </tr> {% endfor %} </table> </body> </html> ``` 循环标签中, 模板引擎还提供的forloop对象，用于给开发者获取循环次数或者判断循环过程的. 属性 描述 forloop.counter 显示循环的次数,从1开始 forloop.counter0 显示循环的次数,从0开始 forloop.revcounter0 倒数显示循环的次数,从0开始 forloop.revcounter 倒数显示循环的次数,从1开始 forloop.first 判断如果本次是循环的第一次,则结果为True forloop.last 判断如果本次是循环的最后一次,则结果为True forloop.parentloop 在多层嵌套循环中，指向当前循环的上级循环对象 ### 过滤器 过滤器（filter）本质就是一个函数，这种函数允许我们直接在模板中使用（python函数无法直接在模板中基于参数调用）。使用过滤器的情况一般就是希望在模板中对数据进行格式化处理或对数据进行规范输出和调整。 > 多个参数的时候使用`:`进行分割 过滤器 用法 代码 **last** 获取列表/元组的最后一个成员 {{list \\ last}} first 获取列表/元组的第一个成员 {{list\\first}}，也可以使用{{list.0}} **length** 获取数据的长度 {{list \\ length}} **defualt** 当变量没有值的情况下, 系统输出默认值, {{str\\default \"默认值\"}} **safe** 让系统不要对内容中的html代码进行实体转义 {{htmlcontent\\ safe}} upper 字母转换成大写 {{str \\ upper}} lower 字母转换成小写 {{str \\ lower}} title 每个单词首字母转换成大写 {{str \\ title}} **date** 日期时间格式转换 `{{ value date:\"D d M Y\" }}` `cut` 从内容中截取掉同样字符的内容 {{content \\ cut:\"hello\"}} `escape` 把内容中的HTML特殊符号转换成实体字符 {{content \\ escape }} filesizeformat 把文件大小的数值转换成单位表示 {{filesize \\ filesizeformat}} **join** 按指定字符拼接内容 {{list\\ join:\" \"}} `random` 随机提取某个成员 {list \\ random}} `slice` 按切片提取成员 {{list \\ slice:\": 2\"}} **truncatechars** 按字符长度截取内容 {{content \\ truncatechars:30}} `truncatechars_html` 按字符长度截取内容，保留HTML标签的完整性 同上 `truncatewords` 按单词长度截取内容 同上 `truncatewords_html` 按单词长度截取内容，保留HTML标签的完整性 同上 #### safe避免转义/默认值避免空值 ```python def index6(request): \"\"\"过滤器\"\"\" title \"我的标题\" content '我的个人主页：<a href \"http://www.baidu.com\">点击查看</a>' return render(request, \"index6.html\", locals()) ``` ```html <!DOCTYPE html> <html lang \"en\"> <head> <meta charset \"UTF 8\"> <title>Title</title> </head> <body> <p>{{ content }}</p> {# 无参数过滤器 #} <p>{{ content safe }}</p> {# safe 过滤器的作用是告诉django，当前输出内容中的HTML内容属于可信任的安全内容，不要对内容中的html代码进行实体转义#} {# 有参数过滤器 #} <p>title {{ title default:\"无标题\" }}</p> {# default 过滤器的作用是当变量不存在时，使用当前默认值实现 #} </body> </html> ``` #### 自定义 customer filter 要声明自定义过滤器并且能在模板中正常使用,需要完成3个步骤。 1. 确保当前需要使用过滤器的子应用已经注册到了INSTALLED_APPS中。 ```python # Application definition # django注册的子应用列表[用于数据库操作，缓存，日志，admin管理] INSTALLED_APPS [ 'django.contrib.admin', # admin站点的子应用 'django.contrib.auth', # django内置的登录认证功能 'django.contrib.contenttypes', # 内容类型管理 'django.contrib.sessions', # session功能 'django.contrib.messages', # 信号、消息功能的实现 'django.contrib.staticfiles', # 静态文件浏览服务 'tem', # 开发者创建的子应用，这填写就是子应用的导包路径 ] ``` 2. 编写过滤器，过滤器必须在子应用目录下的templatetags包里面创建对应的python文件中。`tem/templatetags/my_filters.py`代码: ```python from django import template # 实例化一个类库 register template.Library() # register.filter(\"过滤器别名\") @register.filter(\"mobile\") def mobile_filter(content, flag \"****\"): # 务必有返回值，否则模板中没有内容显示 return content[:3] + flag + content[ 3:] @register.filter(\"sex\") def sex(content): # 过滤器必须有一个以上的参数，提供给模板调用 if bool(content): return \"男\" return \"女\" ``` 3. 在HTML模板中通过load标签加载当前子应用已经声明的过滤器函数，load标签的使用最好写在HTML模板文件的第一行。 视图代码： ```python def index7(request): \"\"\"自定义过滤器\"\"\" content1 \"13312345678\" return render(request, \"index7.html\", locals()) ``` ```python {% load my_filters %} <!DOCTYPE html> <html lang \"en\"> <head> <meta charset \"UTF 8\"> <title>Title</title> </head> <body> <p>{{ content1 mobile }}</p> <p>{{ 1 sex }}</p> </body> </html> ``` ## 模板复用 ### 模板分离 多个页面有相同的部分的时候不需要多次写 ![image 20250727230424611](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507272304703.png) django中提供了`{% include \"模板文件名\" %}`标签模板分离技术。 视图，`tem/views.py`，代码： 公共模板，`templates/common/footer.html`，代码： ``` <div>footer.html公共脚部</div> ``` 公共模板，`templates/common/slide.html`，代码： ``` <div>slide.html的侧栏内容</div> ``` 视图对应的模板，`templates/12.html`，代码： ```html {% include \"common/head.html\" %} <div> <div>index12.html的主体内容</div> {% include \"common/slide.html\" %} </div> {% include \"common/footer.html\" %} </body> </html> ``` ### 模板继承 ![image 20250728102045007](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507281020107.png) 显示子模板的时候,继承父模板的公共内容 > `{% extends \"base.html\" %}` ```html 父模板, templates/common/base.html <!doctype html> <html lang \"en\"> <head> <meta charset \"UTF 8\"> <title>Document</title> {% block style %} {% endblock style %} </head> <body> {% block header %} <div>公共头部</div> {% endblock header %} <div> {% block content %} <div>公共base.html >主体代码</div> {% endblock content %} <div>侧栏效果</div> </div> <div>公共脚部</div> </body> </html> ``` 子模板代码: ```html {% extends \"common/base.html\" %} {% block style %} <style> body{ background color: rosybrown; } </style> {% endblock style %} {% block content %} <div>index15的主体代码</div> {% endblock %} {% block header %} <div>15的公共头部</div> {% endblock header %} ``` > 会把这部分代码覆盖到父模版里面"},"/note/编程基础/python/进阶使用/django/2025-7-24-05-配置文件.html":{"title":"配置文件","content":"# 配置文件 在django中默认的核心包里面存在了一个全局默认配置文件`django/conf/global_settings.py`, 同时在开发者构建项目的时候, 也生成了一个全局项目配置文件在`主应用目录下/settings.py`文件中。 这两个配置文件,在django项目运行时, django会先加载了`global_settings.py`中的所有配置项到**django.conf.settings**对象中作为配置项存在, 接着加载`主应用目录下/settings.py`的配置项，所以settings.py中填写的配置项的优先级会高于`global_settings.py`的默认配置。 ```python \"\"\" Django settings for djdemo project. Generated by 'django admin startproject' using Django 4.2. For more information on this file, see https://docs.djangoproject.com/en/4.2/topics/settings/ For the full list of settings and their values, see https://docs.djangoproject.com/en/4.2/ref/settings/ \"\"\" from pathlib import Path # Build paths inside the project like this: BASE_DIR / 'subdir'. # BASE_DIR代表了项目一个参考根路径，是当前文件的父级的父级目录路径，主要作用是提供给整个django项目进行路径拼接的。 BASE_DIR Path(__file__).resolve().parent.parent # 项目中一般我们会使用大写的变量来表示一个常量，所谓常量就是在开发中，用于表示一些固定数据的标记符，这种标记符，在其他语言中是基本语法来的，但是在python中并没有常量， # 所以，就有了一些开发者声明一些大写的变量用于充当常量，常量一经定义，不能赋值。 # 因此，我们作为开发人员，就要遵守这种约定，以后如果希望项目中的一些数据不要被人修改，则可以声明成常量。 # django中的配置被强制要求一定要大写！！！否则django不识别 # Quick start development settings unsuitable for production # See https://docs.djangoproject.com/en/4.2/howto/deployment/checklist/ # 秘钥， 用于提供给加密算法的秘钥 # 加密： 哈希串/序列串 加密算法(原始密码, 秘钥) # 验证： 新哈希串 加密算法(原始密码, 秘钥)， 新哈希串 哈希串，则表示原始密码正确 # SECURITY WARNING: keep the secret key used in production secret! SECRET_KEY 'django insecure pz) zkl_m9bgi!!t)ge& 2hmbg^s !vr sbb nb)dr&77)f8mf' # SECURITY WARNING: don't run with debug turned on in production! # 在线下开发，DEBUG True，django会基于测试服务器提供静态资源（图片，css，js）的访问，当服务端出错，会显示详尽错误信息 # 在线上运营，DEBUG False，django不会基于测试服务器提供静态资源访问，当服务端出错，不会显示任何关于系统的错误信息，仅仅提供错误页面 DEBUG True #设置当前django项目允许客户端通过哪些地址访问到django项目，\"*\"表示服务端的任意地址 # ALLOWED_HOSTS [\"*\"] ALLOWED_HOSTS [] # Application definition # django注册的子应用列表[用于数据库操作，缓存，日志，admin管理] INSTALLED_APPS [ \"simpleui\", 'django.contrib.admin', # admin站点的子应用, 需要使用命令添加一下用户, 可以pip install django simpleui \t\t\t\t\t\t # 获取一个比较好的ui界面, 在最前面加一行simpleui 'django.contrib.auth', # django内置的登录认证功能 'django.contrib.contenttypes', # 内容类型管理 'django.contrib.sessions', # session功能 'django.contrib.messages', # 信号、消息功能的实现 'django.contrib.staticfiles', # 静态文件浏览服务 'user', # 子应用的字符串导包路径 ] # 中间件、全局钩子、拦截器 # 中间件，MIDDLEWARE，就是一个django提供给开发者用于在http请求和响应过程中，进行数据拦截的插件系统/钩子系统 # 用于进行拦截请求，或者数据格式转换，权限判断 MIDDLEWARE [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', # 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', ] # django项目的默认总路由模块 ROOT_URLCONF 'djdemo.urls' # html模板引擎配置 TEMPLATES [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [], # 模板引擎目录 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], }, }, ] # web应用程序的模块 WSGI_APPLICATION 'djdemo.wsgi.application' # Database # https://docs.djangoproject.com/zh hans/4.2/ref/settings/#databases # 数据库配置, 默认是使用这个本地的小数据库 DATABASES { 'default': { 'ENGINE': 'django.db.backends.sqlite3', 'NAME': BASE_DIR / 'db.sqlite3', } } # Password validation # https://docs.djangoproject.com/en/4.2/ref/settings/#auth password validators # 密码验证类 AUTH_PASSWORD_VALIDATORS [ { 'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator', }, { 'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator', }, { 'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator', }, { 'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator', }, ] # Internationalization # https://docs.djangoproject.com/en/4.2/topics/i18n/ # 语言 LANGUAGE_CODE 'zh hans' # 时区 TIME_ZONE 'Asia/Shanghai' # 是否开启国际化本地化功能 USE_I18N True # 是否启用时区转换 # USE_TZ的值为False则django会基于TIME_ZONE的时区来转换时间，否则USE_TZ的值为True，则采用基于操作系统时间来转换时间 USE_TZ True # Static files (CSS, JavaScript, Images) # https://docs.djangoproject.com/en/4.2/howto/static files/ # 静态文件的访问url路径 STATIC_URL 'static/' # Default primary key field type # https://docs.djangoproject.com/en/4.2/ref/settings/#default auto field # 默认情况下，django中的数据表的主键ID的数据类型 bigint DEFAULT_AUTO_FIELD 'django.db.models.BigAutoField' # session存储引擎核心类 SESSION_ENGINE \"django.contrib.sessions.backends.file\" # django的全局默认配置文件：django.conf.global_settings # 保存到文件: django.contrib.sessions.backends.file # 保存到数据库: django.contrib.sessions.backends.db # 需要配置数据库连接 # 保存到缓存中: django.contrib.sessions.backends.cache # 需要配置缓存连接 # session存储目录[如果不设置,则默认是系统的缓存目录] # 版本小于3.0的django 通过以下代码配置 # SESSION_FILE_PATH os.path.join(BASE_DIR, \"session\") # 版本大于或等于3.0通过以下配置 SESSION_FILE_PATH BASE_DIR / \"session_path\" # 路径拼接 ``` ## 创建用户 ```bash python manage.py migrate python manage.py createsuperuser ```"},"/note/编程基础/python/进阶使用/django/2025-7-24-04-视图.html":{"title":"","content":"## 视图基础 django的视图主要有2种写法的视图，分别是**函数视图**（Function Base View，FBV）和**类视图**（Class Base View，CBV）。 现在刚开始学习django，我们先学习函数视图(FBV)，后面再学习类视图[CBV]。 ### 函数视图 django中所有的视图都建议编写在子应用的views.py文件中。 ```python from django.http.response import HttpResponse def 函数视图的名字(request): # 代码 return HttpResponse(\"返回内容\") ``` 函数视图名称，同一个模块下不能重复，同时采用变量命名规则. ### 请求对象 视图中的request，实际上是django源码中的HTTPRequest的子类WSGIRequest类的实例对象，主要由django对客户端请求的http协议报文进行解析后得到的请求相关数据都在request对象中。 #### 限制请求方式 HTTP请求方法 描述 POST 添加/上传 GET 获取/下载 PUT 修改/更新，修改整体 PATCH 修改/更新，修改部分 DELETE 删除/废弃 django支持让客户端只能通过指定的Http请求来访问到项目的视图 `home/views.py`,代码: ```python # 让用户发送POST才能访问的页面 from django.views.decorators.http import require_http_methods @require_http_methods([\"POST\"]) # 注意，中括号中的请求方法名务必大写！！！否则无法正常显示 def login(request): return HttpResponse(\"登录成功！\") ``` > 默认在获取POST请求的时候有一个CSRF拦截机制, 可以在setting里面关了 > > CSRF（Cross Site Request Forgery，跨站请求伪造）是一种常见的 Web 安全攻击。攻击者诱导用户在已登录的情况下访问恶意网站，悄悄向目标网站发起请求，执行非用户本意的操作，比如转账、修改密码等。 ![image 20250725105757443](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507251057490.png) #### 视图接收http请求参数 在http请求和响应过程中, 用户往往会在请求过程中发送请求信息给服务端。那么客户端发送请求数据一般无非以下几种格式： 1. 查询字符串[Query String] 所谓的查询字符串就是url地址上面?号后面的数据，例如: http://127.0.0.1:8000/home/index/?name xiaoming&pwd 123 上面name xiaoming&pwd 123 就是查询字符串 可以通过 request.GET 来获取。 注意: `request.GET`不是http请求，也就是说，只要地址上有查询字符串，不管使用什么样的http请求方法，都可以在视图中使用request.GET来获取参数 ![image 20250725113026048](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507251130109.png) > `<QueryDict: {'name': ['jiao'], 'pwd': ['123']}>` > > 如果客户端传过来的数据相同的名字有多个值使用`.getList`方法 2. 请求体数据[request.POST 接受表单 request.body 接受请求体], 只可以获取POST请求的 .POST获取的是一个QueryDict, body获取的是原始的数据 > 表单发送会对数据进行封装 3. 请求头报文信息[request.headers] 获取的是处理以后的, 可以使用META获取客户端以及服务器相关的环境信息, 包括请求头, 是原始数据 ```json // META { 'LANG': 'zh_CN.UTF 8', # 服务端系统的默认语言 'USER': 'moluo', # 服务端运行的系统用户名 'HOME': '/home/moluo', # 服务端运行的系统用户家目录路径 'DJANGO_SETTINGS_MODULE': 'djdemo.settings', # 只有在django下才有的，当前django框架运行时加载的配置文件导包路径 'SERVER_NAME': 'ubuntu', # 服务端系统名称 'SERVER_PORT': '8000', # 服务端的运行端口 'REMOTE_HOST': '', # 客户端的所在IP地址，有时候可能是域名 'SCRIPT_NAME': '', # 客户端本次请求时，服务端执行的程序所在路径 'SERVER_PROTOCOL': 'HTTP/1.1', # 服务端运行的协议 'SERVER_SOFTWARE': 'WSGIServer/0.2', # 服务端运行web服务器的软件打印信息 'REQUEST_METHOD': 'POST', # 客户端本次请求时的http请求方法 'PATH_INFO': '/home/index3/', # 客户端本次请求时的url路径 'QUERY_STRING': '', # 客户端本次请求时的查询字符串 'REMOTE_ADDR': '127.0.0.1', # 客户端的所在IP地址 'CONTENT_TYPE': 'application/json', # 客户端本次请求时的数据MIME格式 'HTTP_USER_AGENT': 'PostmanRuntime/7.26.10', # 客户端本次请求时，所使用的网络代理软件提示信息 'HTTP_ACCEPT': '*/*', # 客户端期望服务端返回的数据MIME格式格式 'HTTP_HOST': '127.0.0.1:8000', # 客户端本次请求时，所使用服务端地址 'HTTP_ACCEPT_ENCODING': 'gzip, deflate, br', # 客户端期望服务端返回的数据的压缩格式 'HTTP_CONNECTION': 'keep alive', # 客户端支持的服务端协议的链接类型,keep alive 表示客户端支持http的长连接 } // request.headers { 'Content Length': '601', // 客户端本次请求的内容大小 'Content Type': 'multipart/form data;', # 客户端本次请求的内容MIME类型 'User Agent': 'PostmanRuntime/7.26.10', # 客户端本次请求的代理软件打印信息 'Accept': '*/*', 'Host': '127.0.0.1:8000', # 客户端本次请求的服务端地址 'Accept Encoding': 'gzip, deflate, br', 'Connection': 'keep alive', # 以下就是自定义请求头了 'Company': 'baidu', 'Num': '1000', } ``` > 常见的请求头： > > SERVER_NAME， 服务端系统名称 > > SERVER_PORT， 服务端的运行端口 > > REMOTE_ADDR，客户端的所在IP地址 > > SERVER_SOFTWARE，服务端运行web服务器的软件打印信息 > > PATH_INFO，客户端本次请求时的url路径 > > 在使用META的时候可以使用get进行获取属性, HTTP里面的属性会自动加上`HTTP_`的前缀, 同时把名字大写, 使用`request.header`的是可以直接使用原始的名字进行get 4. 上传文件[request.FILES], 只可以获取使用POST的文件 django在解析http协议的时候，针对上传文件，会自动实例化一个内存保存文件的文件上传处理对象InMemoryUploadedFile `from django.core.files.uploadedfile import InMemoryUploadedFile` ```python print(request.FILES.get(\"file\")) print(request.FILES.get(\"file\").name) print(request.FILES.get(\"file\").size) print(request.FILES.get(\"file\").content_type) ``` 获取到的数据是`<MultiValueDict: {'file': [<InMemoryUploadedFile: logo.bmp (image/bmp)>]}>` ```python # 处理多个一次性上传文件 for file in request.FILES.getlist(\"avatar\"): with open(f\"{os.path.dirname(__file__)}/{file.name}\", \"wb\") as f: f.write(file.read()) ``` 5. 请求方法method, 请求路径 ### 响应对象 django和大多数的web框架一样，针对http的响应，提供了2种不同的响应方式： 1. 响应内容，就是直接返回数据给客户端 1. 响应html内容【一般用于web前后端不分离的项目】 2. 响应json内容【一般用于开发web前后端分离的项目的api接口开发】 2. 响应页面跳转，就是通过返回页面跳转的信息给浏览器，让浏览器自己进行页面跳转 #### 返回http数据 ```python HttpResponse(\"<h1>hello world!</h1>\", content_type \"text/html\") ``` #### 返回json数据 ```python def index6(request): \"\"\"响应对象：响应json数据\"\"\" # 返回字典数据作为json给客户端 \"\"\" import json data {\"name\":\"xiaoming\", \"age\":16, \"sex\": True} return HttpResponse(json.dumps(data), content_type \"application/json;charset utf 8\") \"\"\" # 原生返回json数据，太麻烦了 # 因此django提供了一个HttpResponse的子类JsonResponse，转换提供给我们返回json数据的 # from django.http.response import JsonResponse # data {\"name\": \"xiaoming\", \"age\": 16, \"sex\": True} # return JsonResponse(data) # JsonResponse返回的数据如果不是字典，则必须要加上safe参数声明，并且值为False # 返回列表数据给客户端 from django.http.response import JsonResponse data [ {\"id\":1, \"name\": \"小明\", \"age\": 16}, {\"id\":3, \"name\": \"小火\", \"age\": 15}, ] \t# safe False表示不是只有字典才可以传输, 可以使用status设置返回码, headers返回响应头 return JsonResponse(data, safe False) ``` #### 返回图片/压缩包 ```python def index7(request): \"\"\"返回图片格式\"\"\" import os with open(f\"{os.path.dirname(__file__)}/avatar.jpg\", \"rb\") as f: content f.read() return HttpResponse(content, content_type \"image/jpeg\") ``` ```c def index8(request): \"\"\"返回压缩包格式\"\"\" import os with open(f\"{os.path.dirname(__file__)}/code.zip\", \"rb\") as f: content f.read() return HttpResponse(content, content_type \"application/zip\") ``` #### 自定义响应头 ```python def index9(request): \"\"\"返回数据的过程中设置响应头\"\"\" response HttpResponse(\"ok\") # 自定义响应头[值和属性都不能是多字节] response[\"company\"] \"baidu\" return response ``` #### 跳转 在站内跳转时,如果使用django.urls.reverse函数进行路由反转解析（可以根据路由的别名反向生成路由的URL地址）,则必须在总路由文件和子路由文件中，对路由的前缀和子路由后缀进行别名绑定 + 站外跳转 ```python ## 1. 基于django提供的Response对象也可以进行页面跳转 from django.http.response import HttpResponse response HttpResponse(status 301) response[\"Location\"] \"https://www.tmall.com\" return response # 2. 基于django提供的Response对象的原生写法[HttpResponseRedirect与HttpResponsePermanentRedirect都是HttpResponse的子类] from django.http.response import HttpResponseRedirect # 临时重定向 # from django.http.response import HttpResponsePermanentRedirect # 永久重定向 return HttpResponseRedirect(\"https://www.qq.com\") # 2. 基于django提供快捷函数（简写函数, shortcuts）来完成[常用] from django.shortcuts import redirect return redirect(\"http://www.baidu.com\") ``` + 在进行站内跳转的时候可以直接使用路径, 也可以起别名 1. 直接跳转 ```python def index11(request): \"\"\"跳转到站内\"\"\" from django.shortcuts import redirect # 根据指定的url地址，进行页面跳转 # 直接基于redirect跳转 return redirect(\"/home/index12\") ``` 2. 起别名(使用比较少) + 命名空间 ```python from django.contrib import admin from django.urls import path, include from users import urls urlpatterns [ path('admin/', admin.site.urls), path('users/', include('users.urls', namespace 'usr')), ] ``` + 子应用中的 urls.py 配置一个app_name的参数, 和namespace是一样的, 之后再给路由命名 ```python from django.urls import path from . import views app_name 'usr' urlpatterns [ path('index/', views.index, name 'index'), path('login/', views.login, name 'login'), ] ``` + 解析 ```python from django.shortcuts import render from django.shortcuts import redirect # 根据指定的url地址，进行页面跳转 from django.urls import reverse # 根据路由别名，反向解析生成url地址 # Create your views here. from django.http.response import JsonResponse, HttpResponse def index(request): # 开始解析 url reverse(\"usr:login\") print(url) return redirect(url) def login(request): return HttpResponse(\"login\") ``` ## 类视图 Class Base View,简称\"CBV\",与我们之前编写的视图函数不同, 类视图是类的结构编写视图代码的.可以让我们实现相关业务代码的整合. 同时还在函数视图的基础上, 可以实现 对于客户端访问的http请求进行分流和限制。 ### 基本定义 实际是通过重写一个页面的各种访问操作实现的 ```python from django.shortcuts import render # Create your views here. # 1. 类视图必须直接或者间接继承于django.views.View # 2. 在django的类视图中，所有提供给外界用户访问的视图方法名必须是 http请求动作的小写名称. # 也就是说，方法名只能是 get, post, put, patch, delete ... # 3. 使用类视图，可以有效的减少路由绑定的代码 # 3.1 可以直接通过视图方法名就可以达到限制客户端访问当前视图方法的http请求。 # 3.2 客户端访问对应的URL地址就会来到视图类中，访问这个地址所使用http请求，就是将来视图类自动执行的方法 # 3.3 有了类视图，我们可以把多个函数视图中原来的公共代码封装到一块进行调用，有利于代码复用。 # 4. 注意：同一个视图中，方法名不能出现重复！！！ from django.views import View from django.http.response import HttpResponse, JsonResponse class UserView(View): # 类视图中的公共方法/公共属性, 自己加的 def ret(self, data): print(self.request.method) # 在类视图中，不仅可以通过视图方法中的参数，接收路由传递过来的请求对象，还可以通过self.request来或路由转发过来的请求对象 return HttpResponse(data) def get(self,request): \"\"\"只允许通过get请求访问,建议编写读取数据的页面,一般例如:首页,列表页,详情页\"\"\" # 视图中的视图方法里面的代码，与原来的函数视图中的代码，是一模一样的。原来怎么写，现在还是怎么写。 return self.ret(\"hello, get\") def post(self,request): \"\"\"只允许通过post请求访问,一般用于上传,添加数据的页面\"\"\" return self.ret(\"hello, post\") def put(self,request): \"\"\"只允许通过put请求访问,一般用于修改,更新数据的页面\"\"\" return self.ret(\"hello, put\") def patch(self,request): \"\"\"只允许通过patch请求访问,一般用于修改,更新数据的页面\"\"\" return self.ret(\"hello, patch\") def delete(self,request): \"\"\"只允许通过delete请求访问,一般用于处理删除数据的页面\"\"\" return self.ret(\"hello, delete\") ``` 绑定 ```python from django.urls import path from . import views # 在django中，路由只识别函数视图，对于类视图，我们必须要通过as_view() 帮我们把类的视图方法转换成函数视图 urlpatterns [ # path(\"index\", views.视图类名.as_view()), path(\"index\", views.IndexView.as_view()), ] ``` > 本质是返回一个函数 ```python def view(request, *args, **kwargs): self cls(**initkwargs) # 实例化一个当前的类(参数this传过来), 获取视图对象 self.setup(request, *args, **kwargs) if not hasattr(self, \"request\"): raise AttributeError( \"%s instance has no 'request' attribute. Did you override \" \"setup() and forget to call super()?\" % cls.__name__ ) return self.dispatch(request, *args, **kwargs) # 初始化一下类里面的参数 def setup(self, request, *args, **kwargs): \"\"\"Initialize attributes shared by all view methods.\"\"\" if hasattr(self, \"get\") and not hasattr(self, \"head\"): self.head self.get self.request request self.args args self.kwargs kwargs def dispatch(self, request, *args, **kwargs): # Try to dispatch to the right method; if a method doesn't exist, # defer to the error handler. Also defer to the error handler if the # request method isn't on the approved list. if request.method.lower() in self.http_method_names: handler getattr( self, request.method.lower(), self.http_method_not_allowed ) else: handler self.http_method_not_allowed return handler(request, *args, **kwargs) ``` ### 相关扩展 ``` 在django提供的视图类View使用中，还提供了一些视图子类和视图基类。 不过这块内容需要结合django的数据库操作才可以使用，所以我们后面再来学习。 视图子类是django为了方便开发者快速提供基于不同http请求视图而提供的。 from django.views.generic import ListView,DetailView,CreateView,UpdateView,DeleteView ListView: 列表视图，可以通过get请求访问，用于展示列表数据，内置了分页功能 DetailView：详情视图，可以通过get请求访问，用于展示单个数据 CreateView：添加视图，可以通过get/post请求访问，用于添加单个数据 UpdateView：更新视图，可以通过get/post请求访问，用于更新单个数据 DeleteView：删除视图，可以通过get请求访问，用于删除单个数据 ```"},"/note/编程基础/python/进阶使用/django/2025-8-2-11-组件.html":{"title":"组件","content":"# 组件 ## 文件上传处理 当Django在处理文件上传的时候，文件数据被保存在request.FILES FILES中的每个键为`<input type \"file\" name \"字段名\" />`中的name 注意：FILES只有在请求的方法为POST 且提交的`<form>`带有enctype \"multipart/form data\" 的情况下才会包含文件。否则requests.FILES 将为一个空的类似于字典的对象 使用模型处理上传文件：将属性定义成`models.ImageField`或者`models.FileField`类型, 相关信息记录在数据库里面 ```python from django.db import models # Create your models here. class Software(models.Model): name models.CharField(max_length 150, verbose_name \"软件名称\") version models.CharField(max_length 50, verbose_name \"版本号\") website models.URLField(max_length 500, verbose_name \"官方网址\") # upload_to 用于设置保存上传文件的存储子路径，跟着settings.py中存储上传文件配置项MEDIA_ROOT的后部分路径 # ImageField是FileField的子类，FileField内部实现了基于日期时间格式生成目录的功能，所以支持使用%日期符号来自动创建目录的。 # 而且，当同一目录下文件同名了，FileField会自动把后面重复的文件名追加补充随机字符串防止重名。 picture models.ImageField(upload_to \"soft/%Y/%m/%d/\", verbose_name \"缩略图\") downloads models.FileField(max_length 500, upload_to \"attr/%Y/%m/%d/\", verbose_name \"下载地址\") created_time models.DateTimeField(auto_now_add True) updated_time models.DateTimeField(auto_now True) class Meta: db_table \"tb_software\" verbose_name \"应用管理管理\" verbose_name_plural verbose_name def __str__(self): return f\"{self.name}.{self.version}\" ``` 注意：如果属性的字段类型为图片类型ImageField，需要在python安装PIL包 ```python pip install Pillow # 把上面User模型进行数据迁移 python manage.py makemigrations python manage.py migrate ``` 图片等文件进行上传处理时，还要在django的配置文件中设置存储文件的根路径才可以 在项目根目录下创建保存上传文件的根文件夹，例如：uploads 图片上传后，会被保存到上面创建的上传文件存储根文件夹下 在settings.py配置文件中，通过MEDIA_ROOT配置项来设置这个根文件夹，让django的上传文件处理类能识别到 ```python # 设置保存上传文件的公共路径 MEDIA_ROOT BASE_DIR / \"uploads\" # MEDIA_URL 可以通过这个位置访问上传的文件 MEDIA_URL \"/uploads/\" # 在根目录的urls.py位置添加这个设置 from django.views.static import serve # 静态文件代理访问模块 urlpatterns [ re_path(r'uploads/(?P<path>.*)', serve, {\"document_root\": settings.MEDIA_ROOT}), ] ``` 使用postman，完成文件上传，或者使用模板引擎或前端代码，实现一个上传文件的表单 ```python <!doctype html> <html lang \"en\"> <head> <meta charset \"UTF 8\"> <title>Document</title> </head> <body> <form method \"post\" action \"http://127.0.0.1:8000/component/soft/\" enctype \"multipart/form data\"> {% csrf_token %} 软件名：<input type \"text\" name \"name\"><br><br> 版本号：<input type \"text\" name \"version\"><br><br> 官方网址：<input type \"text\" name \"website\"><br><br> 版本号：<input type \"text\" name \"version\"><br><br> 软件缩略图：<input type \"file\" name \"picture\"/><br><br> 软件上传：<input type \"file\" name \"downloads\"/><br><br> <input type \"submit\" value \"提交\"> </form> </body> </html> ``` ![image 20250802150527076](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202508021505161.png) ![image 20250802150544800](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202508021505860.png) ![image 20250802150638594](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202508021506667.png) 视图处理上传文件的代码，`views.py`： ```python import os from django.views import View from django.http.response import JsonResponse from . import models # Create your views here. class SoftWareView(View): def post(self, request): \"\"\"添加数据\"\"\" # 接受来自客户端的请求数据 name request.POST.get(\"name\") version request.POST.get(\"version\") website request.POST.get(\"website\") picture request.FILES.get(\"picture\") downloads request.FILES.get(\"downloads\") software models.Software.objects.create( name name, version version, website website, picture picture, downloads downloads ) return JsonResponse({ \"id\": software.id, \"name\": software.name, \"version\": software.version, \"website\": software.website, # 模型字段是图片或者文件的，当前属性是文件对象，是无法直接被json序列化的，所以调用url属性才能获取url访问路径 \"picture\": f\"//{request.META.get('HTTP_HOST')}{software.picture.url}\", \"downloads\": f\"//{request.headers.get('host')}{software.downloads.url}\", }) def delete(self, request): \"\"\"删除操作\"\"\" id request.GET.get(\"id\") software models.Software.objects.filter(pk id).first() # 通过path可以获取当前上传的绝对路径，通过绝对路径可以删除文件 print(software.picture.path) # 删除操作代码： os.remove(software.picture.path) os.remove(software.downloads.path) return JsonResponse({}) ``` > 上传的同名文件会自动添加防止重名的信息 #### 供外界访问 settings.py，代码： ```python # 项目中存储上传文件的根目录[手动创建]，注意，uploads目录需要手动创建否则上传文件时报错 MEDIA_ROOT BASE_DIR / \"uploads\" # 访问上传文件的url地址前缀 MEDIA_URL \"/uploads/\" ``` urls.py，代码： ```python from django.views.static import serve # 静态文件代理访问模块 urlpatterns [ re_path(r'uploads/(?P<path>.*)', serve, {\"document_root\": settings.MEDIA_ROOT}), ] ``` ## 数据分页 分页的本质，实际上就是SQL语句的限制结果而已。 ```sql select * from tb_student # 能查尽查，默认查询全部数据。但是我们用户看不了也不会去看太多数据的。 # 而SQL语句有可能查询出几十万条数据，这是没必要的，所以我们可以采用limit 配合 offset来进行分页查询 select * from db_student limit 10 offset 0; # 第1页数据，limit 0,10; select * from db_student limit 10 offset 10; # 第2页数据，limit 10,10; select * from db_student limit 10 offset 20; # 第3页数据，limit 20,10; select * from db_student limit <size> offset <start>; # 第n页数据，limit (n 1)*size, size; ``` Django提供了一些类实现管理数据分页，这些类位于django/core/paginator.py中。 > 注意： > > django提供的这些分页相关的类，默认是用于前后端不分离的。会生成html代码 ### Paginator对象 `Paginator(数据对象列表，int)`：返回分页器对象，参数1为要进行分页的列表数据，每一页数据的条数（Limit） #### 属性 `count`：数据对象总数，就是 len(数据对象列表) 的结果 `num_pages`：页码总数，就会 count/ Limit的结果 `page_range`：页码列表，从1开始，例如[1, 2, 3, 4] #### 方法 page(num)：创建Page对象，参数num代表页码，以1开始，如果提供的页码不存在，抛出InvalidPage异常 #### 异常exception InvalidPage：当向page()传入一个无效的页码时抛出 PageNotAnInteger：当向page()传入一个不是整数的值时抛出 EmptyPage：当向page()提供一个有效值，但是那个页面上没有任何对象时抛出 ### Page对象 页码对象。 #### 创建对象 Paginator对象的page()方法返回Page对象，不需要手动构建。 #### 属性 `object_list`：当前页要显示给外界的所有数据对象的列表 `number`：当前页码，从1开始 `paginator`：当前Page对象相关的Paginator对象 #### 方法 `has_next()`：如果有下一页返回True `has_previous()`：如果有上一页返回True `has_other_pages()`：如果有上一页或下一页返回True `next_page_number()`：返回下一页的页码，如果下一页不存在，抛出InvalidPage异常 `previous_page_number()`：返回上一页的页码，如果上一页不存在，抛出InvalidPage异常 `len()`：返回当前页面对象的个数 `迭代页面对象`：访问当前页面中的每个对象 ### 代码示例 先设置setttings.py中的TEMPLATE模板引擎的模板目录，代码： ```python TEMPLATES [ { \"BACKEND\": \"django.template.backends.django.DjangoTemplates\", \"DIRS\": [ BASE_DIR / \"templates\" ], # 手动创建模板目录 \"APP_DIRS\": True, \"OPTIONS\": { \"context_processors\": [ \"django.template.context_processors.debug\", \"django.template.context_processors.request\", \"django.contrib.auth.context_processors.auth\", \"django.contrib.messages.context_processors.messages\", ], }, }, ] ``` models.py，代码： ```python from django.db import models class Student(models.Model): STATUS ( (0, \"正常入学\"), (1, \"正常毕业\"), (2, \"已经辍学\"), ) name models.CharField(max_length 15, verbose_name \"学生名字\") age models.SmallIntegerField(verbose_name \"年龄\") sex models.BooleanField(default True, verbose_name \"性别\") classmate models.CharField(db_column \"class\", max_length 50, verbose_name \"班级\") mobile models.CharField(max_length 20, unique True, verbose_name \"下载地址\") description models.TextField(null True, verbose_name \"个性签名\") status models.SmallIntegerField(null True, verbose_name \"状态码\") created_time models.DateTimeField(auto_now_add True) updated_time models.DateTimeField(auto_now True) class Meta: db_table \"student\" verbose_name \"学生信息\" verbose_name_plural verbose_name def __str__(self): return f\"{self.name}\" ``` views.py，代码： ```python from django.shortcuts import render from django.views import View from django.core.paginator import Paginator from . import models class StudentView(View): def get(self, request): \"\"\"数据分页\"\"\" \"\"\"提供了数据对象列表以及单页数据量，创建分页器对象\"\"\" # Paginator(数据对象列表, limit) student_list models.Student.objects.all() # 在实际使用的时候最好使用list固化一下 paginator Paginator(list(student_list), 10) # # 数据列表的长度105 # print(paginator.count) # # 页码总数11 # print(paginator.num_pages) # # 页面列表[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] # print(paginator.page_range) \"\"\"基于分页器对象，创建分页对象\"\"\" # 接受客户端的页码，页面一般都是查询字符串，或者路径参数 current_page request.GET.get(\"page\",1) page paginator.page(current_page) # # 当前页要展示给外界的数据对象列表 # print(page.object_list) # # 当前页码 # print(page.number) # # 逆向查找当前Page分页对象的父级分页器对象 # print(page.paginator) return render(request, \"index.html\", locals()) ``` list.html，模板代码： ```html <!doctype html> <html lang \"en\"> <head> <meta charset \"UTF 8\"> <title>分页</title> <style> /* 表格样式：合并边框，设置宽度 */ .table data{ border collapse: collapse; width: 680px; } /* 表格单元格和表头样式：红色边框，普通字体，居中 */ .table data td, th{ border: 1px solid red; font weight: normal; text align: center; } /* 分页器容器样式：宽度、居中、上边距 */ .paginator{ width: 680px; text align: center; padding top: 10px; } /* 分页链接样式：黑色字体，无下划线，浅橙色边框，内边距，圆角，鼠标指针 */ .paginator a{ color: #000; text decoration: none; border: 1px solid lightsalmon; padding: 4px 8px; cursor: pointer; border radius: 4px; } /* 当前页或鼠标悬停时的分页链接样式：浅橙色背景，米色字体 */ .paginator a.current, .paginator a:hover{ background: lightsalmon; color: wheat; } </style> </style> </head> <body> <! 该页面用于展示学生信息的分页表格。 表格上方可根据需要添加其他内容。 分页器支持首页、上一页、下一页、尾页跳转。 通过遍历page.object_list渲染每一行学生数据。 变量说明： page：Django分页对象，包含当前页数据和分页信息。 student：单个学生对象，包含id、name、age、sex、classmate、mobile字段。 分页器根据page对象的has_previous和has_next属性动态显示上一页和下一页按钮。 > <table class \"table data\"> <tr> <th>ID</th> <th>Name</th> <th>Age</th> <th>Sex</th> <th>Class</th> <th>Mobile</th> </tr> {% for student in page.object_list %} <tr> <td>{{ student.id }}</td> <td>{{ student.name }}</td> <td>{{ student.age }}</td> <td>{{ student.sex }}</td> <td>{{ student.classmate }}</td> <td>{{ student.mobile }}</td> </tr> {% endfor %} </table> <div class \"paginator\"> <a href \"?page 1\">首页</a> {% if page.has_previous %} <a href \"?page {{ page.previous_page_number }}\">上一页</a> <a href \"?page {{ page.previous_page_number }}\">{{ page.previous_page_number }}</a> {% endif %} <a>{{ page.number }}</a> {% if page.has_next %} <a href \"?page {{ page.next_page_number }}\">{{ page.next_page_number }}</a> <a href \"?page {{ page.next_page_number }}\">下一页</a> {% endif %} <a href \"?page {{ page.paginator.num_pages }}\">尾页</a> </div> </body> </html> ``` ### ListView分页 django为了方便开发者快速的实现业务功能，针对简单视图数据的管理操作，例如增删查改操作，都有提供了封装视图类给开发者使用，在`django.views.generic`中定义了所有的封装视图类：ListView,CreateView,UpdateView,DetailView,DeleteView。 > 注意： > > 所有的封装视图类，都是View类的子类，所以View类中提供的http请求，也可以在封装视图类中使用，封装视图要绑定路由，一样需要使用as_view来绑定。 封装视图类 作用 补充 ListView 显示列表数据 支持分页，提供get方法 CreateView 显示添加数据表单和数据添加功能 提供表单，提供get、post方法 UpdateView 显示更新数据表单和数据更新功能 提供表单，提供get、put、patch方法 DetailView 显示详情数据 只显示一条数据，提供get方法 DeleteView 删除一条数据 提供delete方法 视图代码： ```python from django.views.generic import ListView class Student2View(ListView): # # 设置当前视图提供哪些方法，默认支持get # http_method_names [\"get\"] # 设置当前视图类中使用模板文件名 template_name \"index2.html\" # 设置当前视图类中使用的模型 model models.Student # 设置分页的数据量 paginate_by 5 # # 设置分页的页码，默认是\"page\" # page_kwarg \"page\" # 在HTML模板中，代表page对象的object_list变量名 # context_object_name \"student_list\" ``` index2.html，模板代码： ```html <!doctype html> <html lang \"en\"> <head> <meta charset \"UTF 8\"> <title>分页</title> <style> .table data{ border collapse: collapse; width: 680px; } .table data td, th{ border: 1px solid red; font weight: normal; text align: center; } .paginator{ width: 680px; text align: center; padding top: 10px; } .paginator a{ color: #000; text decoration: none; border: 1px solid lightsalmon; padding: 4px 8px; cursor: pointer; border radius: 4px; } .paginator a.current, .paginator a:hover{ background: lightsalmon; color: wheat; } </style> </head> <body> <table class \"table data\"> <tr> <th>ID</th> <th>Name</th> <th>Age</th> <th>Sex</th> <th>Class</th> <th>Mobile</th> </tr> {% for student in page_obj.object_list %} <tr> <td>{{ student.id }}</td> <td>{{ student.name }}</td> <td>{{ student.age }}</td> <td>{{ student.sex }}</td> <td>{{ student.classmate }}</td> <td>{{ student.mobile }}</td> </tr> {% endfor %} </table> <div class \"paginator\"> <a href \"?page 1\">首页</a> {% if page_obj.has_previous %} <a href \"?page {{ page_obj.previous_page_number }}\">上一页</a> <a href \"?page {{ page_obj.previous_page_number }}\">{{ page_obj.previous_page_number }}</a> {% endif %} <a>{{ page_obj.number }}</a> {% if page_obj.has_next %} <a href \"?page {{ page_obj.next_page_number }}\">{{ page_obj.next_page_number }}</a> <a href \"?page {{ page_obj.next_page_number }}\">下一页</a> {% endif %} <a href \"?page {{ page_obj.paginator.num_pages }}\">尾页</a> </div> </body> </html> ``` ## 缓存 Cache 缓存就是一种优化网站性能的方案，是一个利刃，用的好可以给服务器大量降压，用得不好，反而成为压垮骆驼的最后一根草。 所谓的缓存，实际上往往是把数据库中数据提取出来，并临时存放到一个第三方存储介质中，例如：内存/文件中。 一般常见的缓存存储介质：内存(redis/memcached/mysql的内存表)，硬盘文件中(python，json，二进制文件，html)，CDN（内容分发网络，静态文件） 对于中等流量的网站来说，尽可能地减少开销是必要的。缓存数据就是为了保存那些需要很多计算资源的结果，这样的话就不必在下次重复消耗计算资源 Django自带了一个健壮的缓存系统来保存动态页面，避免对于每次请求都重新计算 Django提供了不同级别的缓存粒度：可以缓存特定视图的输出、可以仅仅缓存那些很难生产出来的部分、或者可以缓存整个网站 视图缓存 模板缓存 缓存API 注意i，这3个缓存级别不能同时使用。 ### 初始化缓存 通过设置settings.py中的CACHES配置项决定把数据缓存在哪里，是数据库中、文件系统还是在内存中 参数TIMEOUT：缓存的默认过期时间，以秒为单位，这个参数默认是300秒，即5分钟；设置TIMEOUT为None表示永远不会过期，值设置成0造成缓存立即失效 可以将cache存到redis中，默认采用0号数据库，此处需要保证我们学习的机子上已经预装redis了。 在python中连接并操作redis，需要安装django redis cache包并配置如下： ``` # pip install cryptography # 这个是连接数据库有时候涉及加密时使用的模块 pip install django redis cache ``` settings.py，代码： ```python CACHES { \"default\": { \"BACKEND\": \"redis_cache.cache.RedisCache\", # django redis cache \"LOCATION\": \"redis://127.0.0.1:6379\", # 数据源格式连接写法 mysql://账号:密码@IP:端口/数据库名称? 'TIMEOUT': 60, # 缓存失效时间，这里60秒只是为了测试而已 }, } ``` 可以连接redis查看存的数据 ```bash # 终端下连接redis，进行redis交互终端： redis cli # memurai cli # 切换数据库： select 15 select 0 # 设置一个数据，保存到指定变量名中 set 变量 值 set name xiaoming # 查看数据的变量（键/key）： keys * # 获取指定变量名的数据： get name ``` ### 视图缓存 django.views.decorators.cache定义了cache_page装饰器，用于对视图的输出进行缓存 示例代码如下： ```python \"\"\"缓存函数视图的返回结果\"\"\" from django.http.response import HttpResponse from django.views.decorators.cache import cache_page import random @cache_page(timeout 60 * 60 * 20 + random.randint(1, 9999)) # 一为了避免所有视图缓存同一时间过期，造成服务器需要在短时间内生成大量的缓存，一般是设置随机数过期时间。 def index(request): print(\"执行视图代码了！\") return HttpResponse('hello!') \"\"\"缓存类视图的返回结果\"\"\" # cache_page 是基于函数视图进行缓存的，所以无法直接给类视图使用，需要使用method_decorator进行类视图转换 from django.utils.decorators import method_decorator class IndexView(View): @method_decorator(cache_page(timeout 60)) def get(self, request): print(\"执行视图代码了！\") return HttpResponse('hello! IndexView.get') ``` cache_page接受一个参数：timeout，秒为单位 视图缓存与URL无关，如果多个URL指向同一视图，每个URL将会分别缓存 > 上面的视图缓存，是直接在中间件层面拦截的，当视图缓存存在时，直接在中间件就返回结果了。而开发中经常存在一个视图中提供多个数据，其中只有部分数据是缓存的，其他需要实时从数据库中读取的。这种情况就不适合使用视图缓存，而应该使用粒度更小的缓存方式 缓存API。 ### 缓存API 缓存API是针对于某个变量数据进行单独缓存的，使用上比视图缓存更为灵活。 + `from django.core.cache import cache` + 设置：`cache.set(键,值,有效时间)` + 获取：`cache.get(键)` + 删除：`cache.delete(键)` + 清空：`cache.clear() # 慎用，这个会把整个库所有的 缓存数据全部清空！` 视图，代码： ```python \"\"\"Django提供的缓存对象进行数据缓存[缓存API]\"\"\" from django.http.response import JsonResponse from django.core.cache import cache class HomeView(View): def get(self, request): # 读取缓存 student_list cache.get(\"student_list\") # 判断缓存结果，如果没有，则读取数据库并写入缓存 if not student_list: print(\"读取数据库!\") student_list list(models.Student.objects.values_list()) # 这里的10表示当前数据缓存10秒后过期，当然在实际工作中，不会设置10秒的。 cache.set(\"student_list\", student_list, 10) return JsonResponse(student_list, safe False) def delete(self,request): \"\"\"删除/更新数据时，记得要删除缓存哦\"\"\" # 删除/更新数据时，先删缓存，再删除/更新数据库的数据 cache.delete(\"student_list\") return JsonResponse({}, safe False) ``` 缓存适用于哪些场景？不适用于哪些场景？ 适用于数据稳定，不会经常发生变化的业务中，例如：配置信息，文章、新闻、商品等展示数据。 不适用于实时性要求比较高的业务中，例如：股市k线图，实时直播的新闻、聊天...."},"/note/编程基础/python/进阶使用/django/2025-7-29-07-数据库.html":{"title":"数据库","content":"# 数据库 ``` python manage.py makemigrations python manage.py migrate ``` 常用数据库有2大阵营： 1. 关系型数据库[RDB]: 数据库中存储数据的表之间存在某种内在的关联关系，因为这种关系，所以我们称这一类型的数据为关系型数据库。 常见的数据库：mysql[MariaDB]，PostgreSQL（简称PG），Oracle，MSSQLServer，DB2，sqlite，Access，SequoiaDB 共同的特点：都使用了SQL语句进行数据库操作。 2. 非关系型数据库[NOSQL（Not Only SQL）]：泛指那些不适用SQL语句进行数据库操作的所有其他数据库。 常见的数据库：Redis，MongoDB， Memcached，Elasticsearch，HBase/CouchDB, Neo4j、FlockDB、AllegroGrap，rethinkDB ## ORM框架 django中内置了一个基于面向对象的强大的ORM框架给开发者对数据库进行操作的。 O是Object，也就**类对象**的意思。 R是Relational，翻译成中文是**关系**，也就是关系型数据库中**数据表**的意思。 M是mapping，是**映射**的意思，表示类对象和数据表之间的映射关系。 ORM框架会帮我们把类对象和数据表进行了一对一的映射，让我们可以**通过类对象来操作对应的数据表**。 ORM框架还可以**根据我们设计的类自动帮我们生成数据库中的数据表**，也就是使用代码生成数据库建表语句，省去了我们自己建表的过程。 django中内嵌了ORM框架，不需要直接编写SQL语句进行数据库操作，而是通过定义模型类，操作模型类来完成对数据库中数据的增删改查和数据表的创建删除等操作。 ![image 20250729181017944](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507291810035.png) ### ORM的优点 数据模型类都在一个地方定义，更容易更新和维护，也利于重用代码。 ORM 有现成的工具，很多功能都可以自动完成，比如数据消除、预处理、事务等等。 ORM迫使开发人员使用 MVC 架构，ORM 就是天然的 Model，最终使代码结构更清晰易懂。 基于 ORM 的业务代码比较简单，代码量少，语义性好，容易理解。 新手对于复杂业务容易写出性能不佳的 SQL,有了ORM不必编写复杂的SQL语句, 只需要通过操作模型对象即可同步修改数据表中的数据. 开发中应用ORM将来如果要切换数据库.只需要切换ORM底层对接数据库的驱动【修改配置文件的连接地址即可】 ### ORM 也有缺点 ORM 库不是轻量级工具，需要花很多精力学习和设置，甚至不同的项目框架会存在不同操作的ORM。 对于复杂的业务查询，ORM表达起来比原生的SQL要更加困难和复杂。ORM并非万能的，总有些功能需要我们使用原生SQL语句，当然ORM也提供执行原生SQL语句的功能 ORM操作数据库的性能要比使用原生pymysql执行SQL差。[ORM内部要拼接SQL语句] ORM 抽象掉了数据库层，开发者无法了解底层的数据库操作，也无法定制一些特殊的 SQL。【自己使用pymysql另外操作即可，用了ORM并不表示当前项目不能使用别的数据库操作工具。】 ## 配置数据库连接 在settings.py中保存了数据库的连接配置信息，Django默认初始配置使用**sqlite**数据库。 我们可以通过以下步骤来使用django的数据库操作 1. settings.py配置数据库连接信息 2. 在目标子应用下的models.py中定义模型类 3. 生成数据库迁移文件并执行迁移文件[注意：数据迁移是一个独立的用于创建数据表的功能，这个功能在其他web框架未必和ORM一块的] 第3步非必要，有些公司直接由DBA（数据库管理员）设计与管理数据表的，那么就不需要在django中数据迁移了。直接开撸代码 4. 通过模型类对象提供的方法或属性完成数据表的增删改查操作 ## 安装 需要使用python的MQL库 ```bash pip install PyMySQL pip install cryptography ``` 在Django的主应用目录的`__init__.py`文件中添加如下语句，`djdemo/__init__.py`，代码： ```python from pymysql import install_as_MySQLdb install_as_MySQLdb() # 让pymysql以MySQLDB的运行模式和Django的ORM对接运行 ``` ![image 20250730105035989](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507301050058.png) 启动数据库 ``` mysql.exe h 127.0.0.1 P 3306 u root p ``` 创建数据库 ```sql create database school charset utf8mb4; ``` 修改**DATABASES**配置信息，settings.py配置文件配置数据库的连接信息 ```python # Database # https://docs.djangoproject.com/zh hans/4.2/ref/settings/#databases # 数据库配置 DATABASES { 'default': { # 'ENGINE': 'django.db.backends.sqlite3', # 'NAME': BASE_DIR / 'db.sqlite3', 'ENGINE': 'django.db.backends.mysql', # ORM的底层对接pymysql的核心引擎类 'NAME': 'school', # 数据库名 'PORT': 3306, # 端口 'HOST': '127.0.0.1', # 数据库IP 'USER': 'root', # 账号 'PASSWORD': '123', # 密码 'POOL_OPTIONS': { # pool表示数据库连接池配置，主要为了节省连接数据库的开销，临时存储数据库连接对象 'POOL_SIZE': 10, # 默认情况下，打开的数据库连接对象的数量 [1,2,3,4,5,6,7,8,9,10] 'MAX_OVERFLOW': 30, # 负载情况下，允许溢出的连接数量 [11,12,13,14,15,16,17,18,19,20] } } } ``` ## 定义模型类 模型类被定义在\"子应用/models.py\"文件中。 模型类必须直接或者间接继承于django.db.models.Model类【Model相当于我们之前学习mysql基础时封装的DB类一样，里面提供了大量对数据库的操作方法】。 接下来以学校的学生管理为例进行演示。[系统大概3 4表，学生信息，课程信息，老师信息]，之前我们在mysql基础时直接使用SQL来建表，现在我们可以使用django提供的数据迁移来生成建表SQL语句，并创建数据表。使用数据迁移，必须先定义模型。 再次强调，工作中并非每个公司都使用数据迁移的 ```python from django.db import models \"\"\" 学生表, 继承自models.Model, 表示是一个模型类, 用于定义数据库表结构 create table 'student' ( id int auto_increment primary key, name varchar(15) not null, age int default 18, gender boolean default true, class_id int not null, description text, ) \"\"\" class Student(models.Model): # 姓名, 最大长度15, 索引(db_index True)用于快速查询, 字段名name, 字段描述verbose_name '姓名' name models.CharField(max_length 15, verbose_name '姓名', db_index True) # 年龄, 整数类型, 默认值为18, 字段名age, 字段描述verbose_name '年龄' age models.IntegerField(default 18, verbose_name '年龄') # 性别, 字符串类型, 最大长度10, 字段名gender, 字段描述verbose_name '性别' gender models.BooleanField(default True, verbose_name '性别') # 创建时间, 自动获取当前时间, 字段名create_time, 字段描述verbose_name '创建时间' create_time models.DateTimeField(auto_now_add True, verbose_name '创建时间') # 描述, 文本类型, 字段名description, 字段描述verbose_name '描述', 允许为空(null True) # 允许为空字符串(blank True) description models.TextField(verbose_name '描述', null True, blank True) class Meta: db_table 'student' # 指定表名 verbose_name '学生' # 指定表的别名 verbose_name_plural '学生' # 指定表的别名复数 ``` ```python from django.db import models \"\"\" 1. django中所有的模型，必须直接或间接继承models.Model模型基类 \"\"\" \"\"\" auto generated definition create table student ( id bigint auto_increment primary key, name varchar(15) not null, age smallint not null, sex tinyint(1) not null, class varchar(50) not null, mobile varchar(20) not null, description longtext null, status int null, created_time datetime(6) null, updated_time datetime(6) null, constraint mobile unique (mobile) ); create index student_class_ad9a3931 on student (class); create index student_name_68e26583 on student (name); \"\"\" class BaseModel(models.Model): # auto_now_add 设置新建数据时，把当前时间戳作为默认值保存到当前字段中 created_time models.DateTimeField(auto_now_add True, null True, verbose_name \"创建时间\") # auto_now 设置更新数据时，把当前时间戳作为默认值保存到当前字段中 updated_time models.DateTimeField(auto_now True, null True, verbose_name \"更新时间\") class Meta: # 设置当前类为抽象模型，表示当前模型并不是一个真正的表，django就不会跟踪识别这个模型了。 abstract True # Create your models here. class Student(BaseModel): STATUS ( # (数据库值, \"程序显示给外界看的文本\"), (0, \"正常\"), (1, \"未入学\"), (2, \"已毕业\"), ) # django模型中不需要自己单独声明主键，模型会自动创建主键ID，将来直接可以通过模型对象.id 或者 模型对象.pk就可以调用主键了。 name models.CharField(max_length 15, db_index True, verbose_name \"姓名\") age models.SmallIntegerField(default 0, verbose_name \"年龄\") sex models.BooleanField(default True, verbose_name \"性别\") classmate models.CharField(max_length 50, db_column \"class\", default \"\", db_index True, verbose_name \"班级编号\") mobile models.CharField(max_length 20, unique True, verbose_name \"手机号码\") description models.TextField(blank True, null True, verbose_name \"个性签名\") status models.IntegerField(choices STATUS, default 1, null True, verbose_name \"毕业状态\") class Meta: db_table \"student\" verbose_name \"学生信息\" verbose_name_plural verbose_name def __str__(self): # 当使用print打印django模型对象时的输出内容，返回值必须是字符串，方法名固定 return self.name ``` > 主键不需要自己声明, 会自己创建, 可以使用`.id`或者`.pk`获取 1. 数据库表名 可通过**Meta.db_table** 指明数据库表名。 模型类如果未指明表名Meta.db_table，Django默认以 **小写子应用目录名_小写模型类名** 为数据库表名。 2. 关于主键 ![image 20250730135337437](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507301353519.png) django会为模型自动声明一个自动增长的主键列，每个模型只能有一个主键列。 如果使用选项设置某个字段的约束属性为主键列(primary_key)后，django不会再创建自动增长的主键列。 ```python class Student(models.Model): # django会自动在创建数据表的时候生成id主键/还设置了一个调用别名 pk id models.BigAutoField(primary_key True, verbose_name \"主键\") # 设置主键 ``` 默认创建的主键列属性名为id，也可以使用pk代替id，pk全拼为primary key。 3. 性命名限制 不能是python的关键字或保留字。 不允许使用连续的2个下划线，这是因为django的查询方式提供了很多以`__xx`开头的方法或属性，所以`__xx`是django的模型内部的关键字，不能使用！ 定义属性时需要指定字段类型，通过字段类型的参数指定选项，语法如下： ```python 属性名 models.字段类型(约束选项, verbose_name \"注释\") # 在mysql数据表中的字段名如果在python是一个关键字/保留字。则选项中需要通过db_column()来进行关联绑定 class_name models.SmallIntegerField(db_column \"class\", verbose_name \"班级\") # class就是实际上在mysql数据表中的真实字段名 # class_name 就是python中将来用于操作数据的属性名 ``` 4. 字段类型 文档：https://docs.djangoproject.com/zh hans/4.2/ref/models/fields/#field types 类型 说明 : : AutoField 自动增长的IntegerField，通常不用指定，不指定时Django会自动创建属性名为id的自动增长属性，并且提供了一个pk属性与主键进行关联。django3.0以后，系统默认采用了**BigAutoField**，从原来的int类型变成了bigint类型，其他不变。 BigAutoField 一个 64 位整数，与 [`AutoField`](https://docs.djangoproject.com/zh hans/4.2/ref/models/fields/#django.db.models.AutoField) 很相似，但保证适合 `1` 到 `9223372036854775807` 的数字。 **BooleanField** 布尔字段，值为True或False，实际上在数据库中存储的是smallint，采用0/1表示False/True NullBooleanField 支持None、True、False三种值，在4.0版本的django中已经被声明废弃了。 **CharField** 字符串，参数max_length表示最大字符个数，对应mysql中的varchar **TextField** 大文本字段，一般大段文本（超过4000个字符）才使用，对应mysql中的bigtext。 **IntegerField** 整数，对应mysql中的int BigIntegerField 大整型，对应mysql的bitint **DecimalField** 十进制定点数， 参数max_digits表示总位数， 参数decimal_places表示小数位数，常用于表示分数和价格 Decimal(max_digits 7, decimal_places 2) > 99999.99~ 0.00 FloatField 浮点数 DateField 日期，年 月 日 参数auto_now表示每次创建/更新对象时，自动设置该字段的值为当前时间。 参数auto_now_add表示当对象第一次被创建时自动设置该字段的值为当前时间。 参数auto_now_add和auto_now是相互排斥的，一起使用会发生错误。 TimeField 时间，时分秒，参数同DateField **DateTimeField** 日期时间，年月日时分秒，参数同DateField **FileField** 继承于CharField，上传文件字段类型，但是django在FileField中内置了文件上传保存类, django可以通过模型的字段存储自动保存上传文件, 但是在数据库中本质上保存的仅仅是文件在项目中的`存储路径`!! 参数upload_to，表示设置当前上传文件的存储路径位置，当前路径如果不存在，django会自动生成路径。 **ImageField** 继承于FileField，对上传的内容进行校验，确保是有效的图片 EmailField 继承于CharField，邮件字段类型，但是增加字段值的验证是否为邮件格式 UUIDField 继承于CharField，UUID字段类型，保存内容格式字符串，但是会验证当前字段是否是UUID格式。 5. **约束选项** 文档：https://docs.djangoproject.com/zh hans/4.2/ref/models/fields/#field options 选项 说明 : **null** 如果为True，表示允许为空，默认值是False。相当于python的None **blank** 如果为True，则该字段允许为空白，默认值是False。 相当于python的空字符串：\"\" **db_column** 数据表中真实的字段名称，如果未指定，则使用模型类属性的名称。防止数据字段是python的关键字。 **db_index** 若值为True, 则在表中会为此字段创建索引，默认值是False。 相当于SQL语句中的key **default** 默认值，当不填写数据时，使用该选项的值作为字段的默认值。 **primary_key** 如果为True，则该字段在表中设置为主键，默认值是False，一般不用设置，django会自动默认设置id作为主键。 **unique** 如果为True，则该字段在表中创建唯一索引，默认值是False。相当于SQL语句中的unique **choices** 设置当前字段值的候选值选项，必须是二维序列，子序列必须是2个成员。用于限定可以使用的数值 help_text 设置当前字段的辅助提示文本信息，是一个人类可读的文本信息。一般显示给客户端（前台）的。 **verbose_name** 设置当前字段的提示字段名，是一个人类可读的名称，一般显示给服务端（后台）的。 ### 建立表 完成上面的步骤以后，建表有2种方式：手动SQL语句建表与数据迁移 数据迁移 ```bash python manage.py makemigrations python manage.py migrate ``` > 1. `python manage.py makemigrations` > > **作用**：检测模型变化并生成迁移脚本 > > 扫描所有已安装应用的模型 (`models.py`) > 将检测到的模型变化（新增模型、修改字段、删除字段等）转换为数据库操作指令 > 在应用的 `migrations/` 目录下生成新的迁移文件（如 `0002_auto_20210730.py`） > **不修改实际数据库**，只创建变更记录文件 > > 使用场景： > > 修改模型后首次运行 > 添加新模型时 > 字段增删改时 > 修改模型关系时 > > 2. `python manage.py migrate` > > **作用**：将迁移脚本应用到实际数据库 > > 检查 `django_migrations` 表（记录已应用的迁移） > 按顺序执行所有未应用的迁移文件中的操作 > 修改实际数据库结构（创建表/字段/索引等） > 更新 `django_migrations` 表记录 > > **使用场景**： > > 首次初始化数据库 > 应用新的迁移文件后 > 同步团队成员的数据库变更 ![image 20250730143441552](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507301434610.png) ![image 20250730143746102](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507301437204.png) ## 数据操作 ### 查询数据 #### get获取符合的 **查询单一结果**，如果不存在或者返回多个结果会抛出异常。主要是基于唯一的索引进行的 查询不到, 则返回**模型类.DoesNotExist**异常。 查询多个, 则返回**模型类.MultipleObjectsReturned**异常。 ```python def get(self,request): \"\"\"基本查询数据\"\"\" \"\"\"get 获取一条数据\"\"\" try: # student Student.objects.get(name \"小黄人4号\") # student Student.objects.get(name \"小白\") student Student.objects.get(name \"小黄人\") print(student, type(student)) print(student.name) print(student.description) except Student.DoesNotExist: print(\"没有查询结果！\") except Student.MultipleObjectsReturned: print(\"当前数据不是唯一的结果！\") return HttpResponse(\"OK\") ``` #### first **查询一个结果**, 查询不到，则返回None，查询多个，返回查询结果列表的第一个。 django还提供了last方法，可以获取结果列表中最后一个成员。 ```python \"\"\"基于first来查询第一条数据\"\"\" # first不会报错！ # 当查询结果为多个结果时，只会返回查询到的第一个结果，作为模型对象返回 # 当查询结果为0个结果时，则返回None student Student.objects.first() # SQL: select * from tb_student limit 1; print(student) if student: # 判断如果student不是None print(student.pk, student.id) # pk是id的别名 print(student.description) \"\"\"使用filter来过滤数据，并返回一条\"\"\" # student Student.objects.filter(classmate 301).first() student Student.objects.filter(classmate 333).first() print(student, type(student)) # None <class 'NoneType'> 对于没有结果的查询，使用first则会返回一个None ``` #### all查询所有 查询所有结果。查询不到,则返回空列表对象 ```python \"\"\"all 获取所有数据\"\"\" student_list Student.objects.all() print(student_list) # 获取结果列表 print(len(student_list)) # 获取结果列表的长度 # 把结果列表中的所有模型对象转化成字典结构 student_list Student.objects.all().values() print(student_list) # 把结果列表中的所有模型对象转换成元组结构 student_list Student.objects.all().values_list() print(student_list) \"\"\" 使用filter查询过滤数据，并返回所有符合条件的结果 filter(字段名 条件值) filter(字段名 条件值, 字段名 条件值) # 相当于and \"\"\" student_list Student.objects.filter(classmate 302).all() print(student_list) # <QuerySet [<Student: 王天歌>, <Student: 王天龙>, <Student: 祝华生>]> ``` #### count返回总数 查询结果数量。实际上是一个聚合函数来的 ```python \"\"\"count 获取结果总数\"\"\" # 没有任何条件的统计当前数据表的结果 total Student.objects.count() print(f\"学生总人数：{total}\") # 也可以添加where条件 total Student.objects.filter(classmate \"301\").count() print(f\"学生总人数：{total}\") ``` #### 示例 可以使用以下的代码获取所有的数据 ```python from .models import Student students Student.objects.all() ``` > 获取的是一个`Queryset`的数组, 这个数组是ORM里面提供的查询使用的对象集合, 可以使用索引限定一下索引的数量但是不可以使用负数(伪列表) ```python def get(self, request): student_list [] students Student.objects.all() for student in students: student_list.append({ 'id': student.id, 'name': student.name, 'age': student.age, 'sex': student.sex, 'status': student.get_status_display(), # 获取status的文字描述 }) return JsonResponse(student_list, safe False) ``` #### value获取字典所有 all返回的是模型对象列表, 如果需要获取字典的列表可以使用`list(Student.objects.values())`, 这个函数的才参数是可以选择获取的字段, 默认是获取所有的字段 #### 获取choice对应信息 使用`模型对象.get__字段名__display()`即可获取提示文本 #### 控制台 在admin.py文件里面添加 ```python from django.contrib import admin # Register your models here. from .models import Student admin.site.register(Student) ``` ![image 20250730161056458](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507301610566.png) ![image 20250730161238943](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507301612003.png) > 之前设置的`verbose_net`在这里进行显示 ### 数据回滚 `python manage.py migrate 子应用名 数据记录`例如 `python manage.py migrate test1 0001_initial` ![image 20250730154905617](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507301549662.png) 可以使用zero把表都删了 ### 添加数据 #### save 通过创建模型类对象，执行对象的save()方法保存到数据库中。 ```python \"\"\"添加一条数据\"\"\" # ORM对于数据的所有操作都是有子类objects来提供的。objects，可以被修改，开发中一般叫objects为\"模型管理器\" student Student( name \"刘德华\", age 17, xingbie True, classmate 301, description \"一杯忘情水\", ) # 自动执行添加数据 student.save() # 添加后的模型会多出一个主键数据，可以通过id或者pk来读取 print(student.id) # print(student.pk) ``` ![image 20250730165759324](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507301657426.png) #### create 通过模型类.objects.create()保存。 ```python \"\"\"使用create来完成添加一条数据\"\"\" # 返回值就是添加后的模型对象，会有ID主键的 student Student.objects.create( name \"赵本山\", age 50, xingbie True, classmate 301, description \"一段小品\" ) print(student) print(student.pk) # print(student.id) ``` #### bulk_create批量添加 通过`模型类.objects.bulk_create()`批量添加数据 ```python \"\"\"基于bulk_create添加多条数据\"\"\" stu1 Student(name \"小黄人1号\", age 17, xingbie True, classmate 301, description \"卜乃奈\") stu2 Student(name \"小黄人2号\", age 17, xingbie False, classmate 301, description \"卜乃奈\") stu3 Student(name \"小黄人3号\", age 17, xingbie True, classmate 301, description \"卜乃奈\") stu4 Student(name \"小黄人3号\", age 17, xingbie True, classmate 301, description \"卜乃奈\") stu_list [stu1,stu2,stu3,stu4] ret Student.objects.bulk_create(stu_list) print(ret) return HttpResponse(\"ok\") ``` ### 更新数据 #### save一条 修改模型类对象的属性，然后执行save()方法同步到数据库中 ```python \"\"\"save 更新一条数据\"\"\" # 先把要更新的数据查询出来，得到一个模型类对象 student Student.objects.filter(name \"小白\").first() # SQL: select * from tb_student where name '小白' limit1; if student: student.name \"小黑\" student.age 18 student.save() # 把当前模型的中字段值同步到数据库 # SQL: update student set name '小黑', age 18, sex True, description 'xxx' where id 103; ``` #### update更新多条 使用`模型类.objects.filter().update()`，基于update来完成更新满足条件的所有数据，结果是受影响的行数 ```python \"\"\"update 更新多条数据\"\"\" # 基于update这种操作在数据库操作中，一般称之为\"乐观锁\" # update操作的执行效率比save要高！ # update如果条件设置宽松，可以修改多条数据 Student.objects.filter(name \"刘德华\").update(name \"刘福荣\") # SQL: update tb_student set name \"刘福荣\" where name \"刘德华\"; ``` ### 删除 删除有两种方法，分别是删一条或删多条数据。 #### 模型类对象.delete() ``` def get(self,request): \"\"\"删除数据\"\"\" \"\"\"删除一条数据\"\"\" # 先查询要删除的数据 student Student.objects.filter(name \"小白\").first() if student: # 调用模型对象的delete方法进行删除 student.delete() return HttpResponse(\"Ok\") ``` #### 模型类.objects.filter().delete() ``` \"\"\"删除多条\"\"\" # 把符合条件的数据全部删除，注意：这种删除操作务必加上filter过滤条件，否则会变成全表删除 # 返回值是删除的数量 Student.objects.filter(name \"小黄人\").delete() ```"},"/note/编程基础/python/进阶使用/django/2025-7-29-06-中间件.html":{"title":"中间件","content":"# 中间件 MiddleWare，是 Django 请求/响应处理的钩子框架。它是一个轻量级的、低级的“插件”系统，用于全局改变 Django 的输入或输出。【输入指代的就是客户端向服务端django发送数据，输出指代django根据客户端要求处理数据的结果返回给客户端】 钩子就是编程开发的一个术语，hook，钩子可以理解为一段代码(要么是类，要么是函数)，它的作用就类似日常生活中墙上的钩子，不需要的时候，挂在墙上不会占用房子的空间，但是需要的时候我们可以把一些物件挂在上面。 这种中间件在平时不使用情况下不会耗费任何的性能,如果编写了中间件以后,可以在特定的条件下,全局执行!! 文档: https://docs.djangoproject.com/zh hans/4.2/topics/http/middleware/ ## 内置中间件 django框架内部声明了很多的中间件，这些中间件有着各种各种的用途，有些没有被使用，有些被默认开启使用了。 而被开启使用的中间件，都是在settngs.py的MIDDLEWARE中注册使用的。 ```python # 中间件列表 MIDDLEWARE [ 'django.middleware.security.SecurityMiddleware', # 安全监测相关的中间件,防止页面过期, js跨站脚本攻击xss 'django.contrib.sessions.middleware.SessionMiddleware', # session加密和读取、保存session相关 'django.middleware.common.CommonMiddleware', # 通用中间件,用于给url进行重写，自动给URL后面加上/ 'django.middleware.csrf.CsrfViewMiddleware', # 防止网站遭到csrf攻击的 'django.contrib.auth.middleware.AuthenticationMiddleware', # 用户认证的中间件 'django.contrib.messages.middleware.MessageMiddleware', # 错误提示信息的中间件【提示错误信息，一次性提示】 'django.middleware.clickjacking.XFrameOptionsMiddleware', # 用于防止点击劫持攻击的 iframe标签 ] ``` Csrf攻击 跨站请求伪造, Cross site request forgery，利用用户在不知情的情况下实现伪造表单提交给服务端中进行攻击的手段。 ![image 20250729160911404](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507291609598.png) django中提供了一个Csrfmiddleware的中间件给开发者用于防止网站用户遭到这种攻击的. 中间件主要是每次客户端通过post,patch,put等方式提交数据操作时,判断当前表单是否是隐藏了一个django发放的**csrf_token**的随机字符串令牌.如果有这个随机字符串,则中间件则会判断这个随机字符串是否是由服务端提供的. 我们开发者只需要在每个表单页面中, 内置一个隐藏的输入框里面填写cstf_token则可以让当前页面的表单顺利提交数据到后台. > csrf_token的生成是每次都是基于服务端的秘钥进行随机生成的,所以有一定的生成算法在里面的,所以如果没有秘钥的情况下, 则生成的随机token令牌则会轻易被django识别到. + html获取csrf_token用于post ```python <!DOCTYPE html> <html lang \"en\"> <head> <meta charset \"UTF 8\"> <meta name \"viewport\" content \"width device width, initial scale 1.0\"> <title>CSRF防范</title> </head> <body> <form action \"/usr/form/\" method \"post\"> <! {{ csrf_token }} > <input type \"hidden\" name \"csrfmiddlewaretoken\" value \"{{ csrf_token }}\"> <input type \"text\" name \"username\" placeholder \"用户名\"> <input type \"password\" name \"password\" placeholder \"密码\"> <input type \"submit\" value \"提交\"> </form> </body> </html> ``` + 处理 ```python class UserView(View): def get(self,request): \"\"\"只允许通过get请求访问,建议编写读取数据的页面,一般例如:首页,列表页,详情页\"\"\" # 视图中的视图方法里面的代码，与原来的函数视图中的代码，是一模一样的。原来怎么写，现在还是怎么写。 return render(request, 'form.html', locals()) def post(self,request): print(request.POST) username request.POST.get('username', '') password request.POST.get('password', '') if username and password: return HttpResponse(f\"用户名: {username}, 密码: {password}\") else: return HttpResponse(\"请填写完整的用户名和密码\") ``` ### GZIP压缩 压缩所有现代浏览器的响应，节省带宽和传输时间。 注意，GzipMiddleware目前被认为是一种安全风险，并且容易受到TSL/SSL提供的保护无效的攻击。 settings.py，代码： ```python MIDDLEWARE [ 'django.middleware.gzip.GZipMiddleware', # 实际工作中，我们往往是采用web服务器（uwsgi, nginx）来实现gzip压缩 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', 'django.middleware.common.CommonMiddleware', # 'django.middleware.csrf.CsrfViewMiddleware', # ctrl+/ 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware', ] ``` ### 执行顺序 ![image 20250729164037657](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507291640762.png) 请求的时候执行的是process_request, 返回的时候执行process_response ## 自定义 ### 函数式中间件 在项目的主应用目录下创建一个专门存放中间件函数的模块 主应用djdemo/my_middleware.py,代码: ```python def simple_middleware(get_response): # 自定义中间件 def middleware(request): # Code to be executed for each request before # the view (and later middleware) are called. print(\" 视图执行之前 \") # 记录访问用户记录的信息,识别判断黑名单,白名单,判断用户是否登录, 判断用户是否拥有访问权限..... # 视图执行之前 response get_response(request) # 视图调用 # 视图执行之后 print(\" 视图执行以后 \") # 记录用户的操作历史,访问历史,日志记录, 资源的回收... return response return middleware ``` > `get_response`实际就是执行的视图 ![image 20250729171649592](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507291716642.png) 添加进来即可执行 ### 类中间件 和函数式的中间件一样,我们一般都会保存在一个独立的文件中.把所有的中间件按不同的业务存放在一块,. middle.py,代码: ```python from django.utils.deprecation import MiddlewareMixin from django.http.response import HttpResponse class CustomMiddleware(MiddlewareMixin): \"\"\"中间件类\"\"\" def process_request(self,request): # 方法名是固定的,该方法会在用户请求访问路由解析完成以后,调用视图之前自动执行 print(\"1. process_request在路由解析以后，产生request对象，视图执行之前,会执行这个方法\") # 用途：权限,路由分发,cdn,用户身份识别,白名单,黑名单... # 注意,此方法不能使用return,使用则报错!!! def process_view(self,request,view_func, view_args, view_kwargs): # 用途：进行缓存处理,识别参数,根据参数查询是否建立缓存 print(\"2. process_view在视图接受了参数以后，没有执行内部代码之前\") # 可以返回response对象, 如果返回response对象以后,则当前对应的视图函数将不会被执行 # return HttpResponse(\"ok\") # 也可以不返回response,则默认返回None,django就会自动执行视图函数 def process_response(self,request,response): print(\"4. process_response在视图执行以后,才执行的\") # 用途：记录操作历史, 记录访问历史,修改返回给客户端的数据, 建立缓存 # 必须返回response对象,否则报错!! return response def process_exception(self, request, exception): print(exception) # 用途：进行异常的处理或者记录错误日志 print(\"5. process_exception会在视图执行发生异常的时候才会执行\") def process_template_response(self,request, response): # 用途：建立页面缓存, 调用rander函数以后调用 print(\"6. process_template_response只有在视图调用了模板以后,才会执行!!!\") return response ```"},"/note/编程基础/python/进阶使用/django/2025-7-30-08-进阶数据查询.html":{"title":"进阶数据查询","content":"# 进阶数据查询 ## 过滤条件 ORM在内部生成SQL中的where子句时，提供3个方法可以帮我们实现where过滤操作，包括： **filter** 过滤出符合条件的多个结果 exclude 排除掉符合条件的多个结果，与filter相反，与filter互斥。 **get** 过滤单一结果, 结果不是一个，会报错。 对于过滤条件的使用，上述三个方法相同，但是互斥的，只能使用任意1个，故仅以**filter**进行讲解。 文档：https://docs.djangoproject.com/zh hans/4.2/ref/models/querysets/#field lookups ORM使用过程中，设置查询过滤条件的表达语法，如下： ```python # 单表的过滤: 模型类.objects.filter(属性名称__运算符 值) # 此处的运算符是django的ORM提供的英文单词的运算符，与python的运算符不一样，例如ORM的大于是gt，大于等于是gte。 模型类.objects.exclude(属性名称__运算符 值) 模型类.objects.get(属性名称__运算符 值) # 多表的过滤 模型类.objects.filter(外键属性名称__外键模型的属性名称__运算符 值) 模型类.objects.exclude(外键属性名称__外键模型的属性名称__运算符 值) 模型类.objects.get(外键属性名称__外键模型的属性名称__运算符 值) # 属性名称和比较运算符间使用两个英文下划线，所以这就是为什么，之前声明模型类，规定了属性名不能包括多个下划线 ``` > 1. 外键属性名称 > 当前模型（你正在查询的模型）中定义的**外键字段名** > 即 `models.ForeignKey` 字段的名称 > 它指向另一个模型（关联模型） > 2. 外键模型的属性名称 > 被关联模型（外键指向的模型）中的**字段名** > 你想基于这个字段的值进行查询 #### 1. 相等 **exact：表示判断值是否相等。** 例：查询学生信息。 ```python \"\"\"exact 过滤相等的条件\"\"\" # student_list Student.objects.filter(name__exact \"吴杰\").all() student_list Student.objects.filter(name \"吴杰\").all() # 简写方式，这个最常用！！ print(student_list) return HttpResponse(\"OK\") ``` #### 2. 模糊查询 **contains：是否包含。** > 说明：如果要包含%无需转义，直接写即可。 例：查询姓名包含'华'的学生。 ```python \"\"\"模糊查询[简单数据表才使用这个，数据量大了不要使用这个，改用全文搜索，使用专业的搜索引擎]\"\"\" # name__contains > 包含 > name like \"%华%\" student1 Student.objects.filter(name__contains '华') # print(student1) ``` **startswith、endswith：以指定值开头或结尾。** 例：查询姓名以'华'结尾的学生 ```python # name__endswith > 结尾 > name like \"%华\" student2 Student.objects.filter(name__endswith '华') # print(student2) # name__startswith >开头 > name like \"江%\" student3 Student.objects.filter(name__startswith \"江\") print(student3) ``` > 以上运算符都区分大小写，在这些运算符前加上i表示不区分字母大小写，如iexact、icontains、istartswith、iendswith. #### 3. 空查询 **isnull：字段值是否为null。** 例：查询个性签名不为空的学生。 ```python # 添加测试数据,SQL语句 INSERT INTO student (name, age, sex, class, description, status, created_time, updated_time, mobile) VALUES ('刘德华', 17, 1, '407', null, 0, '2020 11 20 10:00:00.000000', '2020 11 20 10:00:00.000000', '15067895432'); # 代码操作 \"\"\"空查询\"\"\" student Student.objects.filter(description__isnull True) print(student) ``` #### 4. 范围查询 **in：是否包含在范围内。** 例：查询班级编号为301,302或303的学生 ```python \"\"\"范围查询\"\"\" student Student.objects.filter(classmate__in [301, 302, 303]).all().values(\"id\", \"name\", \"classmate\") print(student) ``` #### 5. 取值范围 range 设置开始值与结束值范围，进行数值判断，符合范围的数据被查询出来。不仅可以设置数值范围，也可以设置时间范围。 例如：查询出学号id在51~67之间的。 ```python \"\"\"取值范围\"\"\" # SQL: SELECT ... WHERE id BETWEEN 51 and 67; student_list Student.objects.filter(id__range (51, 67)).values(\"id\", \"name\") print(student_list) return HttpResponse(\"ok\") ``` #### 6. 比较查询 **gt** 大于 (greater then) **gte** 大于等于 (greater then equal) **lt** 小于 (less then) **lte** 小于等于 (less then equal) 例：查询编号大于3的学生 ```python \"\"\"比较查询\"\"\" # # 年龄大于20的 # # age__gt 20 >>> where age > 20 # student_list Student.objects.filter(age__gt 22).values(\"name\", \"age\") # 后面任何方法，默认补充all() # print(student_list) # # 年龄小于19的 # # age__lt 19 >>> where age < 19 # student_list Student.objects.filter(age__gt 19).all().values(\"name\",\"age\") # print(student_list) # 年龄不等于19的 # 使用exclude把符合条件的排除掉 student_list Student.objects.exclude(age 19).all().values(\"name\",\"age\") print(student_list) ``` 不等于的运算符，使用exclude()过滤器。 #### 7. 日期查询 > 注意： > > 1. django的ORM中提供了许多方法用于进行日期的查询过滤，例如：**year、month、day、week_day、hour、minute、second都可以对日期时间类型的属性进行运算。** > 2. 要进行日期时间的过滤查询，必须保证python代码中使用的时间时区与mysql数据库中的时间时区是对应的！如果mysql的时区与python代码的时区不对应，则得到的结果纯在时区的差异。 > > 可以使用`SELECT NOW()`查看mysql的时区 例：查询2017年被添加到数据中的学生。 ```python \"\"\"日期过滤查询 需要调整settings.py的时区配置项为：USE_TZ False \"\"\" # 查询2017年被加入数据表的信息 # created_time__year 2017 > where year(created_time) 2017 student_list Student.objects.filter(created_time__year 2017).values(\"name\", \"created_time\") print(student_list) # 查询11月份被加入数据表的信息 # SQL: where month(created_time) 11; student_list Student.objects.filter(created_time__month 7).values(\"name\", \"created_time\") print(student_list) # 查询出2022年07月份的学生 # SQL: WHERE month(created_time) 7 AND year(created_time) 2022; student_list Student.objects.filter(created_time__year 2022, created_time__month 7).values(\"name\", \"created_time\") print(student_list) # 查询出2017年11月20号的学生 # SQL: WHERE month(created_time) 7 AND year(created_time) 2022 AND day(created_time); student_list Student.objects.filter( created_time__year 2017, created_time__month 7, created_time__day 20 ).values(\"name\", \"created_time\") print(student_list) # 查询07月20号的学生 student_list Student.objects.filter( created_time__month 7, created_time__day 20 ).values(\"name\", \"created_time\") print(student_list) ``` ###### 业务场景：时间判断 例：查询2021 08 18 16:19:38 这个时间点上添加的学生信息。 例：查询时间范围在 \"2021 08 18 16:19:38\" ~ \"2021 08 18 16:21:56\" 的数据。 ```python \"\"\"精确时间查询\"\"\" # 方式1：当在模型使用datetime指定字段的数据类型以后，就不能直接通过字符串的比较来过滤查询了，因为字符串时间格式无法与datetime对象来进行很精确的判断比较 student_objs models.Student.objects.filter(created_time \"2021 08 18 16:19:38\").all() print(student_objs) # 方式2：把字符窜格式的时间转换成datetime对象，也可以查询。 from django.utils.timezone import datetime # 把字符串格式时间转换成datetime时间戳对象 timestamp datetime.strptime(\"2021 08 18 16:19:38\", \"%Y %m %d %H:%M:%S\") student_objs models.Student.objects.filter(created_time timestamp).all() print(student_objs) \"\"\"判断两个时间范围\"\"\" time1 \"2020 11 20 9:00:00\" time2 \"2020 11 20 11:00:00\" # 查询添加时间在time1与time2之间的学生信息 student_objs models.Student.objects.filter( created_time__gte time1, created_time__lte time2, ).all() print(student_objs) # <QuerySet [<Student: 刘德华>]> ``` #### 8. F对象, 字段间 F对象，主要用于在SQL语句中针对字段之间的值进行比较的查询。 之前的查询都是对象的属性与常量值比较，两个属性怎么比较呢？ 答：使用F对象，被定义在django.db.models中。 语法如下： ```python \"\"\"F对象，字段间的值比较查询\"\"\" from django.db.models import F # 查询出入学以后，数据没有被修改过的学生信息, 比较updated_time和created_time student Student.objects.filter(created_time F(\"updated_time\")).values(\"name\",\"created_time\",\"updated_time\") print(student) return HttpResponse(\"ok\") # 除了上面例子，我们还可以从工作中针对公司每月的营收(支出和收入)、股票(每月涨和跌)都可以使用F对象进行查询。 ``` #### 9. Q对象 逻辑比较 **多个过滤器逐个调用表示逻辑与关系，同sql语句中where部分的and关键字。** 例：查询年龄大于20，并且编号小于30的学生。 ```python Student.objects.filter(age__gt 20,id__lt 30) 或 Student.filter(age__gt 20).filter(id__lt 30) ``` **如果需要实现逻辑或or的查询，需要使用Q()对象结合运算符**，Q对象被义在django.db.models中。 语法如下： ```python # And filter( Q(属性名__运算符 值) ) filter(Q(属性名__运算符 值, 属性名__运算符 值, ....)) # OR filter(Q(属性名__运算符 值) Q(属性名__运算符 值)) filter(Q(属性名__运算符 值) Q(属性名__运算符 值) ....) # NOT filter(~Q(属性名__运算符 值)) ``` 例子。 ```python \"\"\"Q对象，复杂逻辑查询，针对多条件进行与或非处理\"\"\" from django.db.models import Q # 多个与 and Q(条件) & Q(条件) # 查询出301班的男生 # student Student.objects.filter(Q(classmate 301) & Q(xingbie 1)).values(\"name\",\"xingbie\",\"classmate\") # 上面完全可以简写成 student Student.objects.filter(classmate 301, xingbie 1).values(\"name\",\"xingbie\",\"classmate\") \"\"\"单纯的多个条件并立的情况下，没必要使用到Q对象进行处理，直接编写多个条件，使用逗号串联即可\"\"\" # 多个或，or Q(条件) Q(条件) # 查询出301班的男生 或者 302班的男生 student Student.objects.filter(Q(classmate 301, xingbie 1) Q(classmate 302, xingbie 1)).values(\"name\",\"xingbie\",\"classmate\") # print(student) # 上面完全可以简写成 student Student.objects.filter(classmate__in [301,302], xingbie 1).values(\"name\",\"xingbie\",\"classmate\") # print(student) # 如果是这样则不能简写了 # 查询出301班年龄大于21男生，或者 302班年龄小于19岁的女生 student Student.objects.filter( Q(classmate 301, age__gt 21, xingbie 1) Q(classmate 302, age__lt 22, xingbie 2) ).values(\"name\",\"age\",\"xingbie\",\"classmate\") # print(student) ``` **Q对象可以使用& 表示逻辑与（and）， 表示逻辑或（or），~表示逻辑非（not）** 例：查询年龄大于20，或编号小于30的学生，只能使用Q对象实现 ``` Student.objects.filter(Q(age__gt 20) Q(pk__lt 30)) ``` `Q对象左边可以使用~操作符，表示非not。但是工作中，我们只会使用Q对象进行或者的操作，只有多种嵌套复杂的查询条件才会使用&和~进行与和非得操作`。 例：查询出年龄不是20岁的 ``` student Student.objects.filter(~Q(age 20)).values(\"name\", \"age\") print(student) # 相当于 exclude student Student.objects.exclude(age 20).values(\"name\", \"age\") print(student) ``` ### 结果排序 使用**order_by**对结果进行排序 ```python \"\"\"结果排序\"\"\" # order_by(\"第一排序字段\",\"第二排序字段\",....) # 当前第一字段的值一样时，参考第二字段进行排序，第二字段的值一样时，参考第三字段进行排序,.... # 如果没有声明order_by()来查询，而值又是一样的时候，则根据MySQL在内部执行查询计划的顺序进行排列，也就是随机排列 # 字段排序写法： # order_by(\"id\") # 表示按id字段的值进行升序排序，id数值从小到大 # order_by(\" id\") # 表示按id字段的值进行降序排序，id数值从大到小 # 先按班级进行第一排序降序处理，当班级数值一样时，再按id进行第二排序升序处理 # student Student.objects.order_by(\" classmate\",\"id\").values(\"classmate\",\"id\",\"name\") # 调用了order_by以后，如果没有后续声明返回结果的all方法时，默认使用all()进行结果查询 student Student.objects.order_by(\" id\") print(student) ``` ### 限制查询 ORM中针对查询结果的数量限制，提供了一个查询集对象[QuerySet].这个QuerySet,是ORM中针对查询结果进行**临时保存**数据的一个容器对象,我们可以通过了解这个QuerySet进行使用,达到**查询优化**的目的，也或者**限制查询结果数量**的作用。 #### 查询集 QuerySet 查询集，也称查询结果集、QuerySet，表示从数据库中获取的对象集合。 当调用如下ORM提供的过滤器方法时，Django会返回查询集（而不是简单的列表）： `all()`：返回所有数据。 `filter()`：返回满足条件的数据。filter会默认调用all方法。 `exclude()`：返回满足条件之外的数据。exclude会默认调用all方法 `order_by()`：对结果进行排序。order_by会默认调用all方法 对查询集可以再次调用过滤器进行过滤，如 ```python Student.objects.filter(pk__gt 30).order_by('age') ``` 也就意味着查询集可以含有零个、一个或多个filter过滤器。过滤器基于所给的参数限制查询的结果。 **从SQL的角度讲，查询集与select语句等价，过滤器像where、limit、order by子句。** 判断某一个查询集中是否有数据： `exists()`：判断查询集中是否有数据，如果有则返回True，没有则返回False。 `values()`: 把结果集中的模型对象转换成**字典**,并可以设置转换的字段列表，达到减少内存损耗，提高性能 `values_list()`: 把结果集中的模型对象转换成**列表**，并可以设置转换的字段列表（元祖），达到减少内存损耗，提高性能 注意：工作中如果需要返回数据的过程中进行优化，则一般我们选择使用`values()`或`values_list()`返回字段，比我们操作模型对象效率更高！当然从提供的功能操作上来说，肯定模型对象更强大灵活。 ```python # 所有基于all方法返回的结果，都是Query（查询集），路径： django.db.models.query.QuerySet # 查询出301班是否有男生 # student_list Student.objects.filter(classmate \"301\") # student_list student_list.order_by(\" age\") # student_list student_list.filter(sex 1) # ret student_list.exists() # values 把查询结果中模型对象转换成字典 student_list Student.objects.filter(classmate \"301\") student_list student_list.order_by(\" age\") student_list student_list.filter(sex 1) ret1 student_list.values() # 默认把所有字段全部转换并返回 ret2 student_list.values(\"id\",\"name\",\"age\") # 可以通过参数设置要转换的字段并返回 ret3 student_list.values_list() # 默认把所有字段全部转换并返回 ret4 student_list.values_list(\"id\",\"name\",\"age\") # 可以通过参数设置要转换的字段并返回 print(ret4) return JsonResponse({},safe False) ``` ##### QuerySet的两大特性 学习之前的准备工作 为了观察QuerySet的2个特性，我们可以直接到mysql配置mysql.ini中配置查看SQL的运行日志 ```python \"\"\" 说明： 开启mysql数据库日志有2种方式： 临时开启, 通过mysql交互终端临时设置，如果服务器重启或者mysql重启，则日志的配置信息还原。 永久开启, 通过mysql的配置文件进行参数设置，将来即便服务器重启或mysql重启，都不会关闭日子功能 此处我们设置的打印日志是输入临时开启，用于辅助学习之用，数据库关闭或重启以后就失效了 \"\"\" 查看日志功能是否开启了，接下来在mysql终端下开启日志显示，根据下面提示输入命令和SQL 进入数据库终端[账户与密码自己修改下] mysql uroot p123 show variables like \"%general_log%\"; + + + Variable_name Value + + + general_log OFF # OFF表示没有开启普通日志功能 general_log_file C:\\tool\\mysql 8.0.28 winx64\\data\\WIN Q0O96JBBIJ2.log # 这里记录的是普通日志开启以后，日志文件路径 + + + set global general_log 'ON'; 设置临时开启，mysql重启后关闭 set global general_log_file 'C:/Users/Administrator/Desktop/rg2305/day06/general.log'; 可以不设置日志路径，默认日志路径[路径不要包括特殊字符也不要出现中文，路径分隔符使用正斜杠] + + + Variable_name Value + + + general_log ON # 日志功能也开启了 general_log_file C:/Users/Administrator/Desktop/rg2305/day06/general.log # 可以看到路径发生改变了，。 + + + mysql日志文件中时间一般跟系统时间是对不上的。原因是mysql的时区是0时区，我们这边是东八区。 select @@log_timestamps; + + @@log_timestamps + + UTC # 可以发现是UTC，0时区 + + set global log_timestamps SYSTEM; # 如果要永久设置，在上面配置文件中，添加 log_timestamps SYSTEM + + @@log_timestamps + + SYSTEM # 时区参考当前操作系统 + + 退出数据库终端 exit 接下来，我们只需要打开上面配置好的日志文件就可以了。 ``` ##### 1）惰性执行 QuerySet查询集在创建时是不会访问数据库执行SQL语句，直到模型对象被调用输出或者调用模型对象的属性时，才会真正的访问数据库执行SQL语句，调用模型的情况包括**循环迭代、序列化、与if合用，print**的时候。 例如，当执行如下语句时，并未进行数据库查询，只是创建了一个查询集对象student_list，并没有执行SQL语句的。 ```python student_list Student.objects.all() ``` 继续执行遍历迭代、或打印操作之后操作后，才真正的进行了数据库的查询 ```python for student in student_list: pass ``` 惰性执行，可以让重复的查询操作，只执行一次。 ##### 2）缓存结果 使用同一个查询集，第一次使用时会发生数据库的查询，然后Django会把结果缓存下来，再次使用这个查询集时会使用缓存的数据，**减少了数据库的查询次数**。 **情况一**：如下是两个查询集，无法重用缓存，每次查询都会与数据库进行一次交互，增加了数据库的负载。 ```python from .models import Student [student.id for student in Student.objects.all()] # 因为没有缓存查询集到变量中，所以此处第一次执行了SQL语句 [student.id for student in Student.objects.all()] # 因为没有缓存查询集到变量中，所以此处第一次执行了SQL语句 ``` **情况二**：经过存储后，可以重用查询集，第二次使用缓存中的数据。 ```python student_list Student.objects.all() [student.id for student in student_list] # 因为上面保存到查询到变量中，所以此处执行了SQL语句 [student.id for student in student_list] # 此处调用了之前的缓存数据 ``` ##### 限制结果数量 django中还可以对查询集QuerySet进行**取下标或切片操作，等同于SQL中的limit和offset子句**。 注意：QuerySet毕竟不是真正的列表，所以它**不支持负数索引**。 **对查询集QuerySet进行切片后返回一个新的查询集，但还是不会立即执行数据库查询。** 如果获取一个对象，直接使用[0]，等同于[0:1].get()，但是如果没有数据，[0]引发IndexError异常，[0:1].get()如果没有数据引发DoesNotExist异常。 示例：获取第1、2项，运行查看。 ```python qs Student.objects.all()[0:2] ``` 代码： ```python # 查询集结果数量的下标和切片操作 qs Student.objects.all() # print(qs[0]) # 第1条数据， ORM会自动识别这个操作并转化成SQL语句的 limit 1 # print(qs[2]) # 第3条数据， ORM会自动识别这个操作并转化成SQL语句的 limit 1 offset 2 # print(qs[:2]) # 前2条数据， ORM会自动识别这个操作并转化成SQL语句的 limit 2 # print(qs[1:4]) # 第1，2，3 数据， ORM会自动识别这个操作并转化成SQL语句的 limit 3 offset 1 # print( qs[ 1] ) # 报错！！！不能使用负数 ``` ### 聚合分组 #### 聚合函数(平均/最大值...) django中，可以使用aggregate()过滤器调用聚合函数。聚合函数包括：**Avg** 平均，**Count** 总数，**Max** 最大，**Min** 最小，**Sum** 求和，被定义在django.db.models中。 例：查询301班学生的平均年龄。 ```python \"\"\"聚合函数\"\"\" from django.db.models import Avg,Max,Min,Sum,Count # 查询301班学生的平均年龄 ret Student.objects.filter(classmate 301).aggregate(Avg(\"age\")) # print(ret) # {'age__avg': 19.6364} # 查询301班年龄最大的学生 ret Student.objects.filter(classmate 301).aggregate(Max(\"age\")) # print(ret) # {'age__max': 23} # 查新301班入学最早的学生[也就是ID最小的] ret Student.objects.filter(classmate 301).aggregate(c Min(\"id\")) print(ret) # {'id__min': 2} > {'c': 2} ``` 注意：aggregate的返回值是一个字典类型，格式如下： ```python {'属性名__聚合类小写':值} 如:{'id__min': 2} > {'c': 2} ``` 使用count时一般不使用aggregate()过滤器。 例：查询301班的学生总数。 ```python # 查询301班的总人数 ret Student.objects.filter(classmate 301).aggregate(t Count(\"id\")) print(ret) # {'t':11} # 统计总数，完全可以调用count方法即可，不需要经过aggregate的调用 ret Student.objects.filter(classmate 301).count() print(ret) # 11 ``` 注意：count函数的返回值是一个数字。 #### 分组查询 可以先使用`values`进行分组, values放在不同的位置的时候含义是不同的 id name class 1 xiaoming 301 2 xiaohong 301 3 xiaoli 302 ```python QuerySet对象.annotate() # annotate() 进行分组统计，按前面values的字段进行 group by # annotate() 返回值依然是 queryset对象，增加了分组统计后的键值对 # SQL原生语句中分组之后可以使用having过滤，在django中并没有提供having对应的方法，但是可以使用filter对分组结果进行过滤 # 所以filter在annotate之前，表示分组查询之间的where子句，在annotate之后代表分组结果的having子句 # 同理，values在annotate之前，代表分组的字段，在annotate之后代表数据查询结果返回的字段列 ``` 代码： ```python # 查询各个班级中的学生数量 from django.db.models import Count,Min # 针对单个字段进行分组 values(\"classmate\").annotate(total Count(\"id\") 按班级统计人数 ret Student.objects.values(\"classmate\").annotate(total Count(\"id\")) # total是返回的参数的名字 # print(ret) \"\"\" <QuerySet [ {'classmate': '307', 'total': 3}, {'classmate': '301', 'total': 11}, {'classmate': '504', 'total': 2}, .... ]> \"\"\" # 针对多个字段进行分组 values(\"classmate\",\"xingbie\").annotate(total Count(\"id\")) 按 班级和性别 统计人数 ret Student.objects.values(\"classmate\",\"xingbie\").annotate(total Count(\"id\")) # print(ret) \"\"\" <QuerySet [ {'classmate': '307', 'xingbie': 1, 'total': 3}, {'classmate': '301', 'xingbie': 1, 'total': 8}, {'classmate': '301', 'xingbie': 2, 'total': 2}, {'classmate': '301', 'xingbie': 0, 'total': 1}, {'classmate': '504', 'xingbie': 1, 'total': 2}, ... ]> \"\"\" # 查询出每一个班级中年龄最小的学生信息 ret Student.objects.values(\"classmate\").annotate(min Min(\"age\")) # print(ret) \"\"\" <QuerySet [ {'classmate': '307', 'min': 19}, {'classmate': '301', 'min': 17}, {'classmate': '504', 'min': 19}, .... ]> \"\"\" ret Student.objects.values(\"classmate\").annotate(min Min(\"age\")).values(\"classmate\",\"min\").order_by(\"classmate\") # print(ret) \"\"\" <QuerySet [ {'classmate': '301', 'min': 17}, {'classmate': '302', 'min': 21}, {'classmate': '303', 'min': 19}, ... ]> \"\"\" # 查询出人数在4个人以上(包括4个人)的班级 # 写在annotate后面的filter实际上表示的是having，表示对于分组后的数据结果进行过滤 # 写在annotate前面的filter实际上表示的是where， 表示对于分组前的数据结果进行过滤 ret Student.objects.values(\"classmate\").annotate(total Count(\"id\")).values(\"classmate\",\"total\").filter(total__gte 4) # print(ret) \"\"\" <QuerySet [ {'classmate': '301', 'total': 11}, {'classmate': '502', 'total': 5}, {'classmate': '306', 'total': 6}, {'classmate': '503', 'total': 7}, {'classmate': '508', 'total': 4}, .... ]> \"\"\" # 查询出女生数量在2个以上的班级 ret Student.objects.filter(sex 2).values(\"classmate\").annotate(total Count(\"id\")).values(\"classmate\",\"total\").filter(total__gte 2) print(ret) \"\"\" <QuerySet [ {'classmate': '306', 'total': 4}, {'classmate': '405', 'total': 2}, {'classmate': '502', 'total': 3}, .... ]> \"\"\" ``` ### 原生查询 执行原生SQL语句，在django中我们可以自己引入pymysql执行SQL，也可以调用ORM提供的raw方法来执行SQL语句 如果使用raw方法执行SQL语句，则返回结果是QuerySet，这个返回结果在操作字段时，会有额外性能损耗。 ```python # 查询所有学生的班级、年龄、姓名和性别 sql \"SELECT id,name,sex,age,class FROM `db_student`\" ret Student.objects.raw(sql) # 针对原生SQL语句中已经查询出来的字段，只会查询一遍 # 但是如果SQL语句没有查询出来的字段，而在模型中调用，则会由ORM再次调用数据库查询，把数据临时查询出来。 for student in ret: print(student) print(student.description) ``` # 多数据库 ## 多库共存 在django中，settings.py配置的DATABASES配置项允许注册多个数据库，当然也就支持在项目中随时切换操作不同的数据库了。 1. 先到`djdemo/settings.py`里面，在DATABASES配置项中新增一个数据库 2. 为了方便快速演示，所以我们直接把school里面的student复制到student数据库 ```mysql use students; # 切换数据 create table student ( id bigint auto_increment primary key, created_time datetime(6) null, updated_time datetime(6) null, name varchar(15) not null, age smallint not null, sex tinyint(1) not null, class varchar(50) not null, mobile varchar(20) not null, description longtext null, status int null, constraint mobile unique (mobile) ); ``` ![image 20250731154900919](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507311549034.png) 3. 使用以下语句复制student表的所有数据 ```mysql insert into `students`.`students` (id, created_time, updated_time, name, age, sex, class, mobile, description, status) select id, created_time, updated_time, name, age, sex, class, mobile, description, status from `school1`.`students`; ``` ![image 20250731154742871](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507311547963.png) 4. 添加到settings.py里面 ```python DATABASES { # 'default': { # 'ENGINE': 'django.db.backends.sqlite3', # 'NAME': BASE_DIR / 'db.sqlite3', # } 'default': { 'ENGINE': 'django.db.backends.mysql', # ORM的底层对接pymysql的核心引擎类 'NAME': 'school1', # 数据库名 'PORT': 3306, # 端口 'HOST': '127.0.0.1', # 数据库IP 'USER': 'root', # 账号 'PASSWORD': 'jhy030116', # 密码 'POOL_OPTIONS': { # pool表示数据库连接池配置，主要为了节省连接数据库的开销，临时存储数据库连接对象 'POOL_SIZE': 10, # 默认情况下，打开的数据库连接对象的数量 [1,2,3,4,5,6,7,8,9,10] 'MAX_OVERFLOW': 30, # 负载情况下，允许溢出的连接数量 [11,12,13,14,15,16,17,18,19,20] } }, \"djdemo\": { 'ENGINE': 'django.db.backends.mysql', 'NAME': 'students', 'PORT': 3306, 'HOST': '127.0.0.1', 'USER': 'root', 'PASSWORD': 'jhy030116', 'POOL_OPTIONS': { 'POOL_SIZE': 10, # 默认情况下，打开的数据库连接对象的数量 [1,2,3,4,5,6,7,8,9,10] 'MAX_OVERFLOW': 30, # 负载情况下，允许溢出的连接数量 [11,12,13,14,15,16,17,18,19,20] } } } ``` 5. 切换链接 ```python def get(self, request): \"\"\"多库共存下，基于django底层安装的pymysql来使用原生SQL语句操作的切换数据连接，完成数据库查询的过程\"\"\" # from django.db import connections # with connections[\"djdemo\"].cursor() as cursor: # # 让游标执行SQL语句 # cursor.execute(\"select * from student\") # # 通过游标获取查询结果 # result cursor.fetchall() # print(result) \"\"\"多库共存下，基于django的ORM模型操作，来切换数据连接完成数据库操作的过程\"\"\" student_objs models.Student.objects.using(\"default\").values(\"name\", \"age\") print(student_objs) return JsonResponse({}) ``` ## 关联模型 关联模型实际上就是ORM提供给开发者用于操作多表数据的功能。因为多个表之间的存在的关联关系，往往都是基于建库建表之初的实体关系分析( ER图 ) 和 范式理论 梳理出来的。 构建数据库和构建数据表：实体、属性、关系。 实体：在现实世界中，客观存在的能够被区分的人事物或集体概念。 属性：具有描述性、修饰性的词语，用于描述实体的特征的。 id title price sale 销量 1 meta40 3299 15 2 id status goods_id 1 已成交 1 2 未支付 已取消 ### 范式理论(三范式、逆范式) 范式理论是关系型模型建库建表的参考标准。 [第一范式](https://baike.baidu.com/item/第一范式/3193590)（1NF，原子性）：数据表的每一列都是不可分割，不能重复。如果出现重复的属性，就可能需要定义一个新的实体（也就是新建一张数据表来进行保存）。 [第二范式](https://baike.baidu.com/item/第二范式/3193760)（2NF，依赖性）：数据表的每一行都是唯一，需要创建ID来进行区分每一行数据。 [第三范式](https://baike.baidu.com/item/第三范式/3193798)（3NF，冗余性）：数据表的数据不能冗余，针对冗余数据应该单独创建一个数据表，并把ID写到新表中进行关联。 逆范式指的是通过增加冗余或重复的数据来提高数据库的读取速度。 往往逆范式遵循的原则是：**空间换时间**。本质就是： 以廉价的硬盘空间，换取珍贵的数据库查询时间，以更快的数据从数据库读取数据返回给客户端。 ORM中针对数据表之间进行的关联操作,也可以外键绑定的操作方式,其中根据数据库表与表之间的关系, 可以有三种以上的关联方式：1对1，1对多，多对多。其中针对外键设置的模型代码，在django中一般有2种**操作方式**： ```python # 正向查询按字段，从主模型查询外键模型的数据 模型对象 当前模型.filter(xxx).first() # 例如，获取商品，查询商品的分类，假设分类属性 category 模型对象.外键 # 商品.category > 商品分类 # 反向查询按表名，从外键模型查询主模型数据 主键对象 主键模型.filter(xxx).first() # 先查询分类 > 当前分类下有多少商品 主键对象.外键模型表名_set # _set方法可以使用related_name代替 [_set操作在一对一里面是没有的] ``` set方法文档：https://docs.djangoproject.com/zh hans/4.0/ref/models/relations/ #### 创建实例 ### 一对一关联(OneToOneField) 创建模型的关联关系，`orm/models.py`，代码： #### 模型实现 使用`OneToOneField`进行关联 > #### `\"Student\"` > > **关联的目标模型**（这里是名为 `Student` 的模型） > 使用字符串形式避免循环导入（Django 会按需解析） > 等效写法：`Student`（需先导入模型类） > > #### ▶ `related_name \"profile\"` > > **反向关系名称**（从 `Student` 访问当前模型的关键字） > > 效果：通过 `student.profile` 直接获取关联对象 > > python > > ``` > student Student.objects.get(id 1) > profile student.profile # 获取该学生的关联档案 > ``` > > 未设置时默认名：`小写模型类名`（如 `studentprofile`） > > #### ▶ `on_delete models.CASCADE` > > **删除联动规则**：当关联的 `Student` 被删除时 > `CASCADE`：同步删除当前模型实例（级联删除） > *例如：删除学生时，其档案自动删除* > 其他选项： > `PROTECT`：阻止删除（引发 `ProtectedError`） > `SET_NULL`：设为 `NULL`（需字段允许 `null True`） > `SET_DEFAULT`：设为默认值（需设置 `default`） > > #### ▶ `verbose_name \"学生\"` > > **可读的字段名称**（用于后台/admin界面展示） > 中文显示为\"学生\"（替代默认的英文显示） ```python from django.db import models # Create your models here. \"\"\" 一对一模型关联 \"\"\" # 主表 class Student(models.Model): name models.CharField(max_length 20, db_index True, verbose_name \"姓名\") age models.IntegerField(verbose_name \"年龄\") sex models.BooleanField(null True, blank True, default None, verbose_name \"性别\") created_time models.DateTimeField(auto_now_add True, verbose_name \"创建时间\") updated_time models.DateTimeField(auto_now True, verbose_name \"更新时间\") class Meta: db_table 'orm_student' verbose_name \"学生信息\" verbose_name_plural verbose_name def __str__(self): return str({\"id\": self.pk, \"name\": self.name, \"age\": self.age}) # 附加的表 class StudentProfile(models.Model): # 设置外键[1对1，models.OneToOneField(\"主键模型类名\", on_delete \"外键约束类型\", ....)] # 设置外键以后，在数据库中会自动生成一个\"属性_id\"的真实字段给开发者进行外键记录 # related_name 主要声明给主模型来使用的，用于反向查询。 # StudentProfile.student 学生信息 # Student.profile 学生详细信息 student models.OneToOneField(\"Student\", related_name \"profile\", on_delete models.CASCADE, verbose_name \"学生\") description models.TextField(default \"\", verbose_name \"个性签名\") address models.CharField(max_length 500, verbose_name \"家庭住址\") mobile models.CharField(max_length 15, verbose_name \"紧急联系电话\") class Meta: db_table \"orm_student_profile\" verbose_name \"学生详细信息\" verbose_name_plural verbose_name def __str__(self): return str({\"address\": self.address, \"mobile\": self.mobile}) ``` ![image 20250731192326508](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507311923571.png) 进行数据迁移 ```bash python manage.py makemigrations python manage.py migrate ``` #### 添加数据 ```python class StudentView(View): \"\"\"1：1模型关联\"\"\" def get1(self, request): \"\"\"添加数据操作\"\"\" \"\"\" 唯一方式：先添加主模型数据Student, 后添加外键模型数据 \"\"\" student models.Student.objects.create( name \"小白\", age 17, sex True, ) profile models.StudentProfile.objects.create( # student student, # 通过指定对象的方式，可以帮我们自动绑定外键 student_id student.id, # 等价于上一句 description \"一段长长长长的个性签名....\", address \"学生小白的家庭住址\", mobile \"13312345618\", ) \"\"\"注意：不要使用以下写法，外键模型的数据无法提添加，但是不会报错。\"\"\" # student models.Student.objects.create( # name \"小辉\", # age 17, # sex True, # profile models.StudentProfile( # description \"一段长长长长的个性签名....\", # address \"学生小辉的家庭住址\", # mobile \"13312345668\", # ) # ) return JsonResponse({}) ``` #### 相互访问筛选 ```python def get2(self, request): \"\"\"查询数据\"\"\" \"\"\" 方式1：从主模型(主表, orm_student)查询到外键模型(附加表, orm_student_profile) \"\"\" # 例如，小明今天没上学，查询他的紧急联系电话和家庭地址 student models.Student.objects.filter(name \"小明\").first() if student: # profile就是在StudentProfile里面定义的 related_name print(student.profile.mobile) print(student.profile.address) \"\"\" 方式2：使用外键模型中查询数据，以主键模型作为条件 \"\"\" # 例如，小白今天没上学，查询他的紧急联系电话和家庭地址 profile models.StudentProfile.objects.filter(student__name \"小白\").first() print(profile.mobile) \"\"\" 方式3：从外键模型(附加表, orm_student_profile)查询到主模型(主表, orm_student) \"\"\" # 例如，根据手机号，13312345618 是谁的手机号码 student_profile models.StudentProfile.objects.filter(mobile \"13312345618\").first() if student_profile: print(student_profile.student.name) \"\"\" 方式4：查询主模型数据，以外键模型作为条件 \"\"\" # 例如，根据手机号，13312345618 是谁的手机号码 student models.Student.objects.filter(profile__mobile \"13312345618\").first() print(student.name) return JsonResponse({}) ``` #### 修改数据 ```python def get3(self, request): \"\"\"更新数据\"\"\" \"\"\"方式1：从主模型更新外键模型数据（save）\"\"\" # 例如，修改小明的家庭地址 student models.Student.objects.filter(name \"小明\").first() if student: print(student) print(student.profile) print(student.profile.address) # 直接修改，并保存即可 student.profile.address \"学生小明的新家庭地址\" # 修改的address是StudentProfile的字段，所以使用StudentProfile的save方法 student.profile.save() \"\"\"方式2：修改外键模型数据，使用主模型作为修改条件(update)\"\"\" # 例如，修改小白的家庭地址 models.StudentProfile.objects.filter(student__name \"小白\").update(address \"学生小白的新家庭地址\") \"\"\"方式3：从外键模型更新主模型数据(save)\"\"\" # 例如，修改手机号：\"13312345618\" 的学生的年龄为21岁 student_profile models.StudentProfile.objects.filter(mobile \"13312345618\").first() if student_profile: print(student_profile) print(student_profile.student) print(student_profile.student.age) student_profile.student.age 21 student_profile.student.save() \"\"\"方式4：修改主模型数据，使用外键模型作为修改条件（update）\"\"\" # 例如，修改手机号：\"13312345118\" 的学生的年龄为18岁 models.Student.objects.filter(profile__mobile \"13312345118\").update(age 18) return JsonResponse({}) ``` #### 删除数据 ```python def get(self,request): \"\"\"删除操作\"\"\" \"\"\"当on_delete models.CASCADE时，删除主模型数据，mysql会自动删除外键模型数据\"\"\" # 例如，删除小明的数据记录 #models.Student.objects.filter(name \"小明\").delete() \"\"\"当on_delete models.CASCADE时，删除外键模型数据，不会影响主模型数据的\"\"\" # 例如，删除手机号为13312345118的学生附加资料 models.StudentProfile.objects.filter(mobile \"13312345118\").delete() return JsonResponse({}) ``` #### 外键约束选项(删除) 在设置外键时，需要通过**on_delete**选项指明主表删除数据时，对于外键引用表数据如何处理，在django.db.models中包含了可选常量： **CASCADE**： 级联/株连，删除主表数据时连通一起删除外键表中数据 **PROTECT**： 删除保护，通过抛出**ProtectedError**异常，来阻止删除主表中被外键应用的数据，意思是必须先删除外键数据以后才能删除主键数据 **SET_NULL**： 设置为NULL，仅在该字段null True允许为null时可用 SET_DEFAULT： 设置为默认值，仅在该字段设置了默认值时可用 SET()： 设置为特定值或者调用特定方法，例如： ```python from django.conf import settings from django.contrib.auth import get_user_model from django.db import models def get_sentinel_user(): return get_user_model().objects.get_or_create(username 'deleted')[0] class UserModel(models.Model): user models.ForeignKey( settings.AUTH_USER_MODEL, on_delete models.SET(get_sentinel_user), ) ``` **DO_NOTHING**： 不做任何操作，如果数据库前置指明级联性，此选项会抛出**IntegrityError**异常 ### 一对多关联(ForeignKey) 一对多模型关联，例如学生和成绩，文章分类和文章，商品分类和商品，商品品牌和商品之间的关系。 使用`ForeignKey`进行关联(在子模型里面) ```python class Author(models.Model): name models.CharField(max_length 20, db_index True, verbose_name \"姓名\") age models.IntegerField(verbose_name \"年龄\") sex models.BooleanField(null True, blank True, default None, verbose_name \"性别\") class Meta: db_table 'orm_author' verbose_name \"作者信息\" verbose_name_plural verbose_name def __str__(self): return str({\"id\": self.pk, \"name\": self.name, \"age\": self.age, \"sex\": self.sex}) class Article(models.Model): title models.CharField(max_length 50, verbose_name \"文章标题\") content models.TextField(null True, verbose_name \"文章内容\") pubdate models.DateTimeField(null True, verbose_name \"发布时间\") created_time models.DateTimeField(auto_now_add True, verbose_name \"创建时间\") updated_time models.DateTimeField(auto_now True, verbose_name \"创建时间\") author models.ForeignKey(\"Author\", on_delete models.DO_NOTHING, related_name \"article_list\", verbose_name \"作者\") class Meta: db_table \"orm_article\" verbose_name \"文章信息\" verbose_name_plural verbose_name def __str__(self): return str({\"id\": self.id, \"title\": self.title, \"pubdate\": self.pubdate}) ``` 进行数据迁移 ```bash python manage.py makemigrations python manage.py migrate ``` 关联操作 ```python # from .models import Achievement # student Student.objects.get(pk 10) # achievement_list [ # Achievement(student student,score 100), # Achievement(student student,score 100), # Achievement(student student,score 100), # Achievement(student student,score 100), # ] # # Achievement.objects.bulk_create(achievement_list) # 获取一个学生的所有成绩 # student Student.objects.get(pk 10) # print(student.score_list.all().values(\"id\",\"score\")) # 必须在外键模型中设置related_name \"score_list\",否则无法获取外键关系 # print(student.achievement_set.all().values(\"id\",\"score\")) # 如果外键模型中没有设置related_name则可以通过模型_set提供给主模型调用数据 # 从外键数据查找主模型 from .models import Achievement student_achievement Achievement.objects.filter(score 80).first() print(student_achievement.student) # 查找外键属性字段 print(student_achievement.student_id) # 直接查数据表中的数值ID ``` #### 添加数据 ```python class ArticleView(View): \"\"\"1:多模型关联\"\"\" def get1(self,request): \"\"\"添加数据\"\"\" \"\"\"1. 先添加主模型，根据主模型添加外键模型\"\"\" author models.Author.objects.create( name \"小明\", age 23, sex True ) article_list [ models.Article(title \"文章标题1\", content \"文章内容1\", pubdate \"2023 03 15 10:30:30\", author author), models.Article(title \"文章标题2\", content \"文章内容2\", pubdate \"2023 03 16 10:30:30\", author_id author.id), ] models.Article.objects.bulk_create(article_list) \"\"\"如果已经有了主模型，则直接通过查询主模型提取主键ID，再添加外键模型数据即可。\"\"\" # 例如，给小明记录多2片文章 author models.Author.objects.filter(name \"小明\").first() if author: article_list [ models.Article(title \"文章标题3\", content \"文章内容3\", pubdate \"2023 03 15 10:30:33\", author author), models.Article(title \"文章标题4\", content \"文章内容4\", pubdate \"2023 03 16 10:30:34\", author_id author.id), ] models.Article.objects.bulk_create(article_list) \"\"\"添加主模型，再添加外键模型的另一种写法\"\"\" models.Article.objects.create( title \"文章标题5\", content \"文章内容5\", pubdate \"2023 10 03 12:05:00\", author models.Author.objects.create(name \"小白\", age 23, sex False) ) return JsonResponse({}) ``` #### 查询数据 ```python def get2(self, request): \"\"\"查询数据\"\"\" \"\"\"通过主模型查找外键模型\"\"\" # 例如，查询小明的所有文章 author models.Author.objects.filter(name \"小明\").first() if author: print(author) # 获取外键，article_list就是Article中related_name定义，提供给Author反向查询使用的 print(author.article_list.all()) \"\"\"使用主模型作为条件，直接查询外键模型的数据\"\"\" # 例如，查询小白的所有文章 article_list models.Article.objects.filter(author__name \"小白\").all() print(article_list) \"\"\"通过外键模型查询主模型\"\"\" # 例如，查询文章标题为《文章标题5》的作者 article models.Article.objects.filter(title \"文章标题5\").first() if article: print(article.author, type(article.author)) print(article.author.name) \"\"\"使用外键模型作为条件，直接查询主模型的数据\"\"\" # 例如，查询文章标题为《文章标题3》的作者 author models.Author.objects.filter(article_list__title \"文章标题3\").first() print(author) print(author.name) return JsonResponse({}) ``` #### 更新数据 ```python def get3(self, request): \"\"\"更新操作\"\"\" \"\"\"获取主模型，再改动外键模型[外键模型可以是1个或多个，如果是多个，则需要循环]\"\"\" # 把小明的所有文章发布时间修改成 2023 10 15 10:00:00 author models.Author.objects.filter(name \"小明\").first() for article in author.article_list.all(): article.pubdate \"2023 10 15 10:00:00\" article.save() \"\"\"以主模型作为更新条件，更新外键模型数据\"\"\" # 把小白的所有文章发布时间修改成 2023 05 05 10:00:00 models.Article.objects.filter(author__name \"小白\").update(pubdate \"2023 05 05 10:00:00\") \"\"\"获取到外键模型，再改动主模型\"\"\" # 例如，修改文章标题《文章标题4》的作者的年龄为27岁 article models.Article.objects.filter(title \"文章标题4\").first() article.author.age 27 article.author.save() \"\"\"以外键模型作为更新条件，更新主模型数据\"\"\" # 例如，修改文章标题《文章标题1》的作者的年龄为22岁 models.Author.objects.filter(article_list__title \"文章标题1\").update(age 22) \"\"\"外键是可以在开发中更改绑定关系\"\"\" # # 例如，修改文章标题《文章标题3》的作者为小白 article models.Article.objects.filter(title \"文章标题3\").first() author models.Author.objects.filter(name \"小白\").first() article.author author article.save() # # 例如，修改文章标题《文章标题3》的作者为小明 # models.Article.objects.filter(title \"文章标题3\").update( # author models.Author.objects.filter(name \"小明\").first() # ) return JsonResponse({}) ``` #### 删除数据 ```python def get(self,request): \"\"\"删除数据\"\"\" models.Author.objects.filter(name \"小白\").delete() return JsonResponse({}) ``` ### 多对多关联（ManyToManyField） #### 模型实现 多对多模型关联, 例如：网课和学生，活动和商品，软件应用和服务器。使用`ManyToManyField`进行关联, 同时没有主次之分 在创建这两个表的时候, 实际还会创建一个关系表 ```python \"\"\"多对多\"\"\" # 一个老师可以授课多个课程 # 一个课程也可以由多个老师授课 # 多对多关联以后，在数据迁移时，在数据库中实际上会创建三张表，分别是：2个模型对象实体表，1张关联2个模型的关系表。 # 一对一，把主模型的主键id，作为外键字段声明在外键模型中【所以外键模型多出一个关联属性字段】 # 一对多，把主模型的主键id，作为外键字段声明在外键模型中【所以外键模型多出一个关联属性字段】 # 多对多，把2个主模型的主键id，作为外键字段记录第三张关系表中，这张表主要有2个外键字段。而且ORM中，我们无法直接访问和操作这个表的，只能通过主模型来操作 class Teacher(models.Model): name models.CharField(max_length 15,verbose_name \"老师\") # 注意：Teacher模型中设置了course外键，就不要设置Course的teacher外键了。2个冲突的。 # course models.ManyToManyField(\"Course\", related_name \"to_teacher\") class Meta: db_table \"tb_teacher\" verbose_name '老师信息表' verbose_name_plural verbose_name class Course(models.Model): name models.CharField(max_length 20, verbose_name \"课程\") # 多对多不需要我们设置on_delete，直接默认就是models.CASCADE级联了。 teacher models.ManyToManyField(\"Teacher\", related_name \"to_course\") class Meta: db_table \"tb_course\" verbose_name '课程信息表' verbose_name_plural verbose_name ``` 进行数据迁移 ``` python manage.py makemigrations python manage.py migrate ``` #### 添加数据 ```python class TeacherView(View): \"\"\"多对多关联操作\"\"\" def get1(self, request): \"\"\"添加数据\"\"\" \"\"\"先添加实体模型，然后通过外键使用add进行关联两个模型\"\"\" # 1. 先添加实体模型 teacher models.Teacher.objects.create(name \"大明\", age 32, sex True) course models.Course.objects.create(name \"python基础课\") # 2. 通过外键使用add绑定关系 teacher.course.add(course) # 也可以给已有的模型绑定关系 teacher models.Teacher.objects.filter(name \"大明\").first() course1 models.Course.objects.create(name \"python框架\") course2 models.Course.objects.create(name \"python项目实战\") teacher.course.add(course1, course2) return JsonResponse({}) ``` #### 查询 ```python def get2(self, request): \"\"\"查询数据\"\"\" \"\"\"先查其中一个模型，接着通过外键，查询另一个模型的数据\"\"\" # 例如，查询大明的授课列表 teacher models.Teacher.objects.filter(name \"大明\").first() print(teacher.course.all()) \"\"\"使用其中一个模型作为条件，查询另一个模型的数据\"\"\" # 例如，查询大明的授课列表 course_objs models.Course.objects.filter(teacher__name \"大明\").all() print(course_objs) \"\"\"反过来，也是如此\"\"\" # 例如，python基础课的授课老师列表 course models.Course.objects.filter(name \"python基础课\").first() print(course.teacher.all()) teacher_list models.Teacher.objects.filter(course__name \"python基础课\").all() print(teacher_list) return JsonResponse({}) ``` #### 更新 ```python def get(self,request): \"\"\"更新数据\"\"\" # 把大明的所有授课课程的名字后面加上（大明专讲） teacher models.Teacher.objects.filter(name \"大明\").first() if teacher: for course in teacher.course.all(): course.name course.name + \"（大明专讲）\" course.save() # # 通过update修改, 字符串的拼接需要使用Concat from django.db.models import F, Value from django.db.models.functions import Concat models.Course.objects.filter(teacher__name \"大白\").update(name Concat(F(\"name\"), Value(\"[精讲]\"))) return JsonResponse({}) ``` #### 删除 ```python def get4(self,request): \"\"\"删除数据\"\"\" \"\"\"删除模型表记录时，对应的关系也会被删除\"\"\" # 删除大明的信息，mysql会自动删除绑定关系 models.Teacher.objects.filter(name \"大明\").delete() \"\"\"解绑关系\"\"\" teacher models.Teacher.objects.filter(name \"大白\").first() course models.Course.objects.filter(name \"java基础课\").first() teacher.course.remove(course) # 注意：这并非删除课程，而是解除绑定关系而已 return JsonResponse({}) ``` ### 自关联 自关联就是1张数据表中，主键和外键都在一张表上。一般会在多级部门，多级菜单，多级权限，省市区行政区划，粉丝关注，好友关系，这些业务中使用到。举例： 行政区划表 tb_area, 这里的一个地区的上一级可以是同一个表里面的另一项 id name parent_id/pid 1 河南省 2 河北省 3 郑州市 1 4 开封市 1 5 石家庄 2 6 邯郸市 2 7 二七区 3 8 新郑区 3 9 郑东新区 3 要理解自关联，就要这个数据表理解成2张或者3张表就可以了。 省级别，province， id name 1 河南省 2 河北省 市级别，city， id name parent_id/pid 3 郑州市 1 4 开封市 1 5 石家庄 2 6 邯郸市 2 区级别，area， id name parent_id/pid 7 二七区 3 8 新郑区 3 9 郑东新区 3 上面很明显是1个省份有多个城市，1个城市有多个地区，这就是属于1对多的自关联 用户与用户之间的好友关系，这就是属于多对多的自关联。 用户表 user id username 1 小明 2 小红 3 小黑 4 小白 5 小辉 好友关系表 user_friend id user1 user2 1 1 2 2 1 3 3 1 4 4 2 3 5 2 4 6 2 5 7 3 4 #### 模型实现 还是使用的`ForeignKey`和`ManyToManyField`但是不是写另一个模型的名字是使用self, 在进行多对多的时候为了避免递归搜寻, 默认是不支持反向查询的, 需要加一下参数`symmetrical True` ```python class Area(models.Model): \"\"\"一对多的自关联\"\"\" name models.CharField(max_length 50) parent models.ForeignKey(\"self\", on_delete models.SET_NULL, related_name \"to_son\", null True, blank True) class Meta: db_table \"orm_area\" verbose_name '行政区划表' verbose_name_plural verbose_name def __str__(self): return str({\"id\":self.id, \"name\":self.name}) class Member(models.Model): \"\"\"多对多的自关联\"\"\" name models.CharField(max_length 50, unique True, verbose_name \"用户名\") age models.SmallIntegerField(default 0, verbose_name \"年龄\") # symmetrical True 默认值，表示双向关系，绑定的关系是双向，一般用于好友关系 # 这种情况下，django不提供反向查询 friends models.ManyToManyField(to \"self\", symmetrical True) # symmetrical False 表示单向关系，绑定的关系是单向，一般用于单向关注，黑名单 focus models.ManyToManyField(to \"self\", symmetrical False, related_name \"fans_list\") class Meta: db_table \"orm_member\" verbose_name '会员信息表' verbose_name_plural verbose_name def __str__(self): return str({\"id\":self.id, \"name\":self.name}) ``` 数据迁移 ``` python manage.py makemigrations python manage.py migrate ``` 分析： ``` 父级对象：area.parent # parent就是自关联模型的外键属性，并非固定属性，看创建模型时的设置 父级获取子级数据对象：area.son_list.all() ``` #### 添加数据 ```python class Student4View(View): \"\"\"自关联\"\"\" def get1(self, request): \"\"\"添加数据\"\"\" # 添加省份数据，因为没有上级辖区，所以不需要声明其他字段 area1 Area.objects.create(name \"河南省\") area2 Area.objects.create(name \"河北省\") # # # 添加城市数据 area3 Area.objects.get(name \"河南省\") area3.to_son.add( Area.objects.create(name \"郑州市\"), Area.objects.create(name \"开封市\") ) area4 Area.objects.get(name \"河北省\") Area.objects.create(name \"石家庄\", parent area4) Area.objects.create(name \"邯郸市\", parent_id area4.id) # # 添加地区数据 area5 Area.objects.get(name \"郑州市\") area5.to_son.add(*[ Area.objects.create(name \"二七区\"), Area.objects.create(name \"新郑区\"), Area.objects.create(name \"郑东新区\") ]) province Area.objects.create(name \"广东省\") area_list [ Area(name \"佛山市\"), Area(name \"广州市\"), Area(name \"珠海市\"), Area(name \"深圳市\"), ] # bulk属性只有在一对多的时候存在，多对多是没有。bulk允许列表中出现没有保存到数据库中的模型对象，django会自动创建到数据库中 province.to_son.add(*area_list, bulk False) return HttpResponse(\"ok\") ``` #### 查找数据 ```python def get2(self, request): \"\"\"查询数据\"\"\" \"\"\"通过子级记录查找父级记录，得到唯一的父级\"\"\" area Area.objects.get(name \"二七区\") print(area.parent) # {'id': 3, 'name': '郑州市'} print(area.parent.parent) # {'id': 1, 'name': '河南省'} \"\"\"通过父级记录查找子级记录，得到多个子级\"\"\" area Area.objects.get(name \"河南省\") son_list area.to_son.all() print(son_list) # <QuerySet [<Area: {'id': 3, 'name': '郑州市'}>, <Area: {'id': 4, 'name': '开封市'}>]> data [] for son_area in son_list: grandson_list son_area.to_son.all() data.extend(list(grandson_list)) print(data) \"\"\"使用子级记录作为查询条件，查询数据\"\"\" area Area.objects.filter(to_son__name__in [\"郑东新区\"]).first() # 因为同一个父级下有多个子级记录，所以必须使用in来查找 print(area) # {'id': 3, 'name': '郑州市'} # 通过孙子找爷爷 area Area.objects.filter(to_son__to_son__name__in [\"郑东新区\"]).first() print(area) # {'id': 1, 'name': '河南省'} \"\"\"使用父级记录作为查询条件，查询数据\"\"\" son_list Area.objects.filter(parent__name \"河南省\").all() print(son_list) # <QuerySet [<Area: {'id': 3, 'name': '郑州市'}>, <Area: {'id': 4, 'name': '开封市'}>]> grandson_list Area.objects.filter(parent__parent__name \"河南省\").all() print(grandson_list) # <QuerySet [<Area: {'id': 7, 'name': '二七区'}>, <Area: {'id': 8, 'name': '新郑区'}>, <Area: {'id': 9, 'name': '郑东新区'}>]> # SQL: SELECT `orm_area`.`id`, `orm_area`.`name`, `orm_area`.`parent_id` FROM `orm_area` INNER JOIN `orm_area` T2 ON (`orm_area`.`parent_id` T2.`id`) INNER JOIN `orm_area` T3 ON (T2.`parent_id` T3.`id`) WHERE T3.`name` '河南省' LIMIT 21 return HttpResponse(\"ok\") ``` #### 多对多建立关联 ```python def get3(self, request): \"\"\"多对多的自关联[双向]：添加数据\"\"\" # 添加数据 member1 Member.objects.create(name \"小明\", age 16) member2 Member.objects.create(name \"小红\", age 15) member3 Member.objects.create(name \"小白\", age 15) member4 Member.objects.create(name \"小黑\", age 15) member5 Member.objects.create(name \"小兰\", age 15) # 小红添加好友 member1 Member.objects.get(name \"小红\") member2 Member.objects.get(name \"小黑\") member3 Member.objects.get(name \"小白\") member1.friends.add(member2, member3) # 小明添加好友 member1 Member.objects.get(name \"小明\") member2 Member.objects.get(name \"小黑\") member3 Member.objects.get(name \"小白\") member4 Member.objects.get(name \"小红\") member1.friends.add(member2, member3, member4) # 小兰添加好友 member1 Member.objects.get(name \"小兰\") member2 Member.objects.get(name \"小黑\") member3 Member.objects.get(name \"小白\") member4 Member.objects.get(name \"小红\") member5 Member.objects.get(name \"小明\") member1.friends.add(member2, member3, member4, member5) # 小白添加好友 member1 Member.objects.get(name \"小白\") member2 Member.objects.get(name \"小黑\") member3 Member.objects.get(name \"小明\") member4 Member.objects.get(name \"小红\") member1.friends.add(member2, member3, member4) return HttpResponse(\"OK\") ``` #### 多对多数据操作 ```python def get4(self, request): \"\"\"多对多的自关联[双向]：查询数据\"\"\" member Member.objects.get(name \"小黑\") # 查找小黑的朋友? print(member.friends.all()) return HttpResponse(\"OK\") def get5(self,request): \"\"\"多对多的自关联[单向]: 添加数据\"\"\" # 小红的关注 member1 Member.objects.get(name \"小红\") member2 Member.objects.get(name \"小黑\") member3 Member.objects.get(name \"小白\") member1.focus.add(member2, member3) # 小明的关注 member1 Member.objects.get(name \"小明\") member2 Member.objects.get(name \"小黑\") member3 Member.objects.get(name \"小白\") member4 Member.objects.get(name \"小红\") member1.focus.add(member2, member3, member4) # 小兰的关注 member1 Member.objects.get(name \"小兰\") member2 Member.objects.get(name \"小黑\") member3 Member.objects.get(name \"小白\") member4 Member.objects.get(name \"小红\") member5 Member.objects.get(name \"小明\") member1.focus.add(member2, member3, member4, member5) # 小白的关注 member1 Member.objects.get(name \"小白\") member2 Member.objects.get(name \"小黑\") member3 Member.objects.get(name \"小明\") member4 Member.objects.get(name \"小红\") member1.focus.add(member2, member3, member4) \"\"\"自关联的添加关系与普通多表关联的关系操作类似，不仅支持add，也支持set，clear,remove等操作\"\"\" return HttpResponse(\"OK\") def get(self,request): \"\"\"多对多的自关联[单向]: 查询数据\"\"\" 查询小红的关注列表 member Member.objects.get(name \"小红\") print(member.focus.all()) # 查询小红的粉丝列表 member Member.objects.get(name \"小红\") print(member.fans_list.all()) return HttpResponse(\"OK\") ```"},"/note/编程基础/python/进阶使用/django/2025-7-24-01-Django.html":{"title":"Django","content":"# Django 开发框架 Django 是一个开放源代码的 Web 应用框架，由 Python 写成。 Django 遵守 BSD 版权，初次发布于 2005 年 7 月, 并于 2008 年 9 月发布了第一个正式版本 1.0 。 Django 采用了 MVT 的软件设计模式，即模型（Model），视图（View）和模板（Template）。 ![image 20250724172202117](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507241722215.png) 目前开源软件发布一般会有2个不同的分支版本： 1. 普通发行版本：经常用于一些新功能,新特性,但是维护周期短，不稳定。 2. 长线支持版本[LongTerm Supper，简称：LTS]：维护周期长，稳定。 [Django 文档 Django documentation Django](https://docs.djangoproject.com/zh hans/5.1/) 安装`pip install django 4.2.5`"},"/note/编程基础/嵌入式C语言/2022-7-22-指针和数组.html":{"title":"指针和数组","content":" layout: article title: \"指针和数组\" # 指针和数组 ### 常用的运算符 + 成员访问 . + 成员简介访问 > + 结构体成员取值 &stu.num + 结构体成员自增自减 ++stu.num stu.num + 间接访问运算符 *stu.p ### 指针访问的基本使用方法 + 一级直接访问 ```c #include <stdio.h> 2 3 struct student{ 4 int num; 5 char sex; 6 char name[10]; 7 int age; 8 9 }; 10 11 int main(void){ 12 struct student stu {100, 'F', \"jim\", 20}; 13 printf(\"stu.num : %d\\n\", stu.num);//直接访问 14 printf(\"stu.sex : %c\\n\", stu.sex); 15 printf(\"stu.name : %s\\n\", stu.name); 16 printf(\"stu.age : %d\\n\", stu.age); 17 puts(\"\"); 18 \t 19 struct student *p; 20 p &stu; 21 printf(\"(*p).num : %d\\n\", (*p).num); 22 printf(\"(*p).sex : %c\\n\", (*p).sex); 23 printf(\"(*p).name : %s\\n\", (*p).name); 24 printf(\"(*p).age : %d\\n\", (*p).age); 25 puts(\"\"); 26 \t//指针访问 27 printf(\"p >num : %d\\n\", p >num); 28 printf(\"p >num : %c\\n\", p >sex); 29 printf(\"p >num : %s\\n\", p >name); 30 printf(\"p >num : %d\\n\", p >age); 31 puts(\"\"); 32 return 0; 33 } result: stu.num : 100 stu.sex : F stu.name : jim stu.age : 20 (*p).num : 100 (*p).sex : F (*p).name : jim (*p).age : 20 p >num : 100 p >num : F p >num : jim p >num : 20 ``` ### 嵌套指针的使用方法 ```c 1 #include <stdio.h> 2 3 struct score{ 4 unsigned int chinese; 5 unsigned int english; 6 unsigned int math; 7 };//没有使用到 8 9 struct student{ 10 unsigned int stu_num; 11 unsigned int score; 12 }; 13 14 struct teacher{ 15 unsigned int work_num; 16 unsigned int salary; 17 }; 18 19 struct people{ 20 char sex; 21 char name[10]; 22 int age; 23 struct student *stup; 24 struct teacher ter; 25 }; 26 27 void struct_print1(void) 28 { 29 struct student stu {1001, 99}; 30 struct teacher ter {8001, 8000}; 31 struct people jim {'F', \"JimGreen\", 20, &stu, 0}; 32 struct people jack {'F', \"Jack\", 50, NULL, ter}; 33 struct people *p; 34 35 p &jim; 36 printf(\"jim score: %d\\n\", jim.stup >score);//访问成员的指针结构体 37 printf(\"jim score: %d\\n\", p >stup >score); 38 p &jack; 39 printf(\"jack score: %d\\n\", jack.ter.salary);//访问成员的普通结构体 40 printf(\"jack score: %d\\n\", p >ter.salary); 41 } 42 void struct_print2(void){ 43 struct student stu {1001, 99}; 44 struct teacher ter {8001, 8000}; 45 //struct people a[2] {'F', \"JimGreen\", 20, &stu, 0}, \\ \t\t//{'F', \"Jack\", 50, 0, ter};这里应该由大括号包裹，但是上传时会出错所以去掉了 46 struct people *p; 47 p a; 48 printf(\"Jim score: %d\\n\", a[0].stup >score++);//通过++来确定是不是访问的同一个数据 49 printf(\"Jim score: %d\\n\", ++p[0].stup >score); 50 printf(\"Jim score: %d\\n\", p[0].stup >score++); 51 52 53 printf(\"Jack salary: %d\\n\", a[1].ter.salary++); 54 printf(\"Jack salary: %d\\n\", p[1].ter.salary++); 55 printf(\"Jack salary: %d\\n\", (p+1) >ter.salary++); 56 } 57 58 int main(){ 59 struct_print1(); 60 puts(\"\"); 61 struct_print2(); 62 puts(\"\"); 63 return 0; 64 } result: jim score: 99 jim score: 99 jack score: 8000 jack score: 8000 Jim score: 99 Jim score: 101 Jim score: 101 Jack salary: 8000 Jack salary: 8001 Jack salary: 8002 ``` **结构体是一个标量，在使用时通过参数传递时候传递整个结构体，最好用指针传递大结构体**"},"/note/编程基础/嵌入式C语言/2022-7-24-文件系统.html":{"title":"文件系统","content":" layout: post title: \"文件系统\" # 文件系统 从底层物理存储是设备上的二进制到不同目录下的具体文件名 是一个存储管理程序，型用户提供一组文件目录以及操作的API **格式化**：文件系统的加载，建立文件名、文件目录到实际储存地址的映射 文件系统把内存分为两部分，纯数据区、元数据区，纯数据区存储真正的文件，元数据区存储文件的相关属性：磁盘中的位置、文件长度、时间戳、读写权限、所属组、链接数据。 ### 文件系统的挂载 挂载(mount): 把文件挂载到某一个目录上实质是改变目录到文件的映射关系，建立关联 ```C mount t vfat /mnt /dev/mmcblock0 //把U盘挂载到/mnt目录下 umount /numt //取消挂载，映射回原来的存储地址 ``` ### Linux的文件系统 /：根目录 Linux初始化过程中会先创建一个根目录，然后mount一个文件到根目录，其他的储存区mount到根目录下的某个目录 **常见的目录**： + /bin /sbin:存放Linux的常用命令，以二进制都格式存储到该目录 + /lib : Linux常用库，比如C标准库 + /include：头文件存放的目录 + /etc：存放系统配置文件、启动脚本 + /mnt：常用来作为挂载目录"},"/note/编程基础/嵌入式C语言/2022-7-21-大小端数据对齐size_t.html":{"title":"大小端数据对齐size_t数","content":" layout: article title: \"大小端数据对齐size_t数\" # 大小端数据对齐size_t ![Image](https://xusenfeng.github.io/myimages/2 6.jpg){:.shadow} ![Image](https://xusenfeng.github.io/myimages/2 7.jpg){:.shadow}"},"/note/编程基础/嵌入式C语言/2022-7-22-代码复用分层思想.html":{"title":"代码复用分层","content":" layout: article title: \"代码复用分层\" # 代码复用分层 ### 代码复用 + 定义一个函数让所有程序都可以调用， + 通用函数封装成库 + 类似的应用抽象成骨架 + 操作系统 ### 代码分层 + 封装的模块之间产生依赖关系 + 通过分层每层实现各自的功能，各层之间通过接口通讯，每一层都是对下一层的封装。留出API供尚上一层调用 **优点** 1. 软件层次清晰 2. 跨平台兼容性提高"},"/note/编程基础/嵌入式C语言/2022-7-23-操作系统基本原理.html":{"title":"操作系统基本原理","content":" layout: article title: \"操作系统基本原理\" # 操作系统基本原理 ### 根据任务的优先级进行分配 ```C 1 #include <stdio.h> //linux的系统函数用来产生中断 2 #include <unistd.h> 3 #include <signal.h> 4 5 int task_delay[4] {0}; 6 void task1(void) 7 { 8 task_delay[0] 10; 9 printf(\"task1..\\n\"); 10 } 11 12 void task2(void) 13 { 14 task_delay[1] 4; 15 printf(\"task2..\\n\"); 16 } 17 void task3(void) 18 { 19 task_delay[2] 4; 20 printf(\"task3..\\n\"); 21 } 22 void task4(void) 23 { 24 task_delay[3] 1; 25 printf(\"task4..\\n\"); 26 } 27 void timer_interrupt(void) 28 { 29 for(int i 0; i < 4; i++) 30 { 31 if(task_delay[i]) 32 task_delay[i] ; 33 } 34 alarm(1);//设定下一次调用这个函数的时间 35 } 36 37 void (*task[])(void) {task1, task2, task3, task4}; 38 39 int main(void) 40 { 41 signal(SIGALRM, timer_interrupt); 42 alarm(1); 43 int i; 44 while(1) 45 { 46 for(i 0;i<4;i++) 47 if(task_delay[i] 0) 48 { 49 task[i](); 50 break; 51 } 52 } 53 } ``` #### 进行封装 ```C 1 #include <stdio.h> 2 #include <unistd.h> 3 #include <signal.h> 4 5 int task_delay[4] {0}; 6 void task1(void) 7 { 8 task_delay[0] 10; 9 printf(\"task1..\\n\"); 10 } 11 12 void task2(void) 13 { 14 task_delay[1] 4; 15 printf(\"task2..\\n\"); 16 } 17 void task3(void) 18 { 19 task_delay[2] 4; 20 printf(\"task3..\\n\"); 21 } 22 void task4(void) 23 { 24 task_delay[3] 1; 25 printf(\"task4..\\n\"); 26 } 27 void timer_interrupt(void) 28 { 29 for(int i 0; i < 4; i++) 30 { 31 if(task_delay[i]) 32 task_delay[i] ; 33 } 34 alarm(1); 35 } 36 37 void (*task[])(void) {task1, task2, task3, task4}; 38 39 void os_init(void) 40 {//初始化任务的时间 41 task_delay[0] 10; 42 task_delay[1] 4; 43 task_delay[2] 4; 44 task_delay[3] 1; 45 signal(SIGALRM, timer_interrupt); 46 alarm(1); 47 } 48 void os_scedule(void) 49 {//进行任务的切换 50 int i; 51 while(1) 52 { 53 for(i 0;i<4;i++) 54 if(task_delay[i] 0) 55 { 56 task[i](); 57 break; 58 } 59 } 60 } 61 62 int main(void) 63 { 64 os_init(); 65 os_scedule(); 66 return 0; 67 68 } ``` + **调度器**：负责任务的切换，分为抢占型和不可抢占型，抢占型针对对时间要求较高的内核，可随时对任务打断不可抢占型是在任务时间段结束后进行切换"},"/note/编程基础/嵌入式C语言/2022-7-21-变量指针.html":{"title":"变量指针","content":" layout: article title: \"变量指针\" # 变量指针 ![Image](https://xusenfeng.github.io/myimages/2 9.jpg){:.shadow} ![Image](https://xusenfeng.github.io/myimages/2 10.jpg){:.shadow}"},"/note/编程基础/嵌入式C语言/2022-7-24-MMU内存管理单元.html":{"title":"MMU内存管理单元","content":" layout: post title: \"MMU内存管理单元\" # MMU内存管理单元 > **作用**：把虚拟的内存地址转化成实际的地址，用来处理不同应用加载到内存以后内存分配的问题。 虚拟地址通过地址和转换表把实际的内存和虚拟的内存相互转换，转换表以4KB为一个基本单位进行记录，所以也叫做页表。 CPU根据页偏移以及页帧号 例： > 虚拟地址10004 0x10 + 0x004 > > 页表 10:30005 > > 物理地址: 30005004 实际上是由硬件软件一同完成的，CPU集成的MMU进行转换，页表是由操作系统进行操控的，地址完成转换之后更新到每一个进程 CPU内部一般会集成一个缓存TLB，缓存一部分页表 ### 权限管理 页表之中还保存有每一块内存的访问权限，通过这种设计，进行权限管理"},"/note/编程基础/嵌入式C语言/2022-7-22-函数指针.html":{"title":"函数指针","content":" layout: article title: \"函数指针\" # 函数指针 ```C 1 #include <stdio.h> 2 3 int add(int a, int b) 4 { 5 return a + b; 6 } 7 8 int main(void){ 9 int sum; 10 int (*fp)(int, int); 11 fp add; 12 sum fp(1, 2); 13 printf(\"sum %d\\n\", sum); 14 return 0; 15 } 16 result: \t\tsum 3 ``` + int func(void); > 定义函数 + int (*fp)(void); > 定义函数指针 + fp func > 指针赋值 + (*fp)() > 调用函数 + fp() >调用函数简化 ## void指针 特点：1.可以指向任何数据类型，赋值给其他类型的时候需要强制转换类型 ​\t\t\t2.任意类型转为void*类型再转回来数据不发生改变 ​\t\t\t3.一般不参加指针运算， 也不可以用*访问 ​\t\t\t ```C 1 #include <stdio.h> 2 #include <stdlib.h> 3 #include <string.h> 4 5 void date_copy(void *dst, const void *src, size_t len) 6 { 7 char *d dst; 8 const char *s src; 9 for(size_t i 0; i<len ;i++) 10 { 11 *d++ *s++; 12 } 13 } 14 int main(void){ 15 char a[10] {1, 2, 3, 4, 5, 6, 7, 8, 9, 0}; 16 char *buf (char *)malloc(10); 17 memset(buf, 0, 10); 18 date_copy(buf, a, 10); 19 for(int j 0 ; j<10 ; j++) 20 printf(\"%d \", buf[j]); 21 puts(\"\"); 22 return 0; 23 } ```"},"/note/编程基础/嵌入式C语言/2022-7-22-Linux中的面向对象思想-封装.html":{"title":"Linux中的面向对象思想-封装","content":" layout: article title: \"Linux中的面向对象思想 封装\" # Linux中的面向对象思想：封装 #### 实现方法 + 使用结构体 + 使用函数指针 ```C struct animal { int age; int weight; void (*fp)(void); }; ``` 可以对函数等进一步封装 ```C struct func_operations { \tvoid (*fp1)(void); void (*fp2)(void); void (*fp3)(void); void (*fp4)(void); }; struct anmal { \tint age; int weight; struct func_operations fp; }; ``` 继承 ```C struct cat{ struct animal *p; struct animal ani; char sex; void (*eat)(void); }; ``` #### 示例 ```C 1 #include <stdio.h> 2 3 void speak(void) 4 { 5 printf(\"aniaml speaking...\\n\"); 6 } 7 8 struct func_operations{ 9 void (*fp1)(void); 10 void (*fp2)(void); 11 void (*fp3)(void); 12 void (*fp4)(void); 13 }; 14 15 struct animal{ 16 int age; 17 int weight; 18 struct func_operations fp; 19 }; 20 struct cat{ 21 struct animal *p; 22 struct animal ani; 23 char sex; 24 }; 25 int main(void) 26 { 27 struct animal ani; 28 ani.age 1; 29 ani.weight 2; 30 ani.fp.fp1 speak; 31 printf(\"%d %d\\n\", ani.age, ani.weight); 32 ani.fp.fp1(); 33 34 struct cat c; 35 c.p &ani; 36 c.p >fp.fp1(); 37 printf(\"%d %d\", c.p >age, c.p >weight); 38 return 0; 39 40 } 1 2 aniaml speaking... aniaml speaking... 1 2 ``` #### 实例 ##### 链表的抽象继承 + 普通链表 ```C struct list_node { int data; struuct *next; struct *prev; }; ``` + Linux中的链表 ```C struct list_head { struct list_head *next, *prev; //分别指向上一个和下一个链表 }; ``` ##### 设备管理器 显示设备：Linux的文件系统/sys下的devices目录 Linux中的一个设备 ```C struct kobject { // ... struct list_head enter; // ... } ``` 通过kset结构体进行管理：/sys目录下的不同设备分类 ##### 总线型结构 实现抽象类设备驱动然后衍生出usb驱动，网卡驱动，由实例继承 ### 继承 + 内嵌结构体，用于差别不大的设备 + 私有指针 + 抽象类添加分层 #### 问题 + 出现多路继承 ​\t\t\t**解决方案**：接口：一个类的行为方法，不允许有数据成员，多继承 >单继承 ### 多态 基类中包含纯虚函数，为函数指针赋予不同的具体函数。 ```C 1 #include <stdio.h> 2 3 struct file_operation 4 { 5 void (*read)(void); 6 void (*write)(void); 7 }; 8 9 struct file_system{ 10 char name[20]; 11 struct file_operation fops; 12 }; 13 14 void ext_read(void) 15 { 16 printf(\"ext read ....\\n\"); 17 } 18 19 void ext_write(void) 20 { 21 printf(\"ext write ....\\n\"); 22 } 23 24 void fat_read(void) 25 { 26 printf(\"fat read ...\\n\"); 27 } 28 void fat_write(void) 29 { 30 printf(\"fat write ...\\n\"); 31 } 32 int main(void) 33 { 34 struct file_system ext {\"ext3\", {ext_read, ext_write}}; 35 struct file_system fat {\"ext3\", {fat_read, fat_write}}; 36 37 struct file_system *fp; 38 fp &ext; 39 fp >fops.read(); 40 fp &fat; 41 fp >fops.write(); 42 return 0; 43 44 } result: ext read .... fat write ... ``` ​"},"/note/编程基础/嵌入式C语言/2022-7-21-内联函数内置内存函数.html":{"title":"内建函数内置内存函数","content":" layout: article title: \"内建函数内置内存函数\" # 内建函数 内置内存函数 ![Image](https://xusenfeng.github.io/myimages/2 5.jpg){:.shadow} ![Image](https://xusenfeng.github.io/myimages/2 6.jpg){:.shadow}"},"/note/编程基础/嵌入式C语言/2022-7-22-main函数的参数.html":{"title":"main函数的参数","content":" layout: article title: \"main函数的参数\" # 函数参数的本质 + 参数1 argc：保存传入的数据的geshu + 参数2 argv[]: 保存传入的字符串的地址， 为指针数组 + 参数3 envp[]: 保存电脑的系统路径 ![Image](https://xusenfeng.github.io/myimages/24.jpg){:.shadow}"},"/note/编程基础/嵌入式C语言/2022-7-23-可重入函数.html":{"title":"可重入函数","content":" layout: article title: \"可重入函数\" # 可重入函数 ```C int a[10] {1, 2, 3, 4, 5, 6, 7, 8, 9, 0}; int b[10] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20}; int sum(int array[], int len) { static int sum 0;//存在静态变量，使得函数不能重入 for(int i 0; i<len ; i++) \tsum + array[i]; return sum; } void task1(void) { sum(a, 10); } void task2(void) { sum(b, 20); } ``` ### 可重入函数 + 可以多次重复调用 + 可以被多个任务重复调用 + 运行过程中可以被打断 + 不影响运行结果 ### 不能存在的因素 + 函数内部使用全局或局部变量 + 返回值是一个全局或局部变量 + 内部使用了malloc()/free() + 函数内部使用了标准的I/O函数 + 调用了其他不可重入的函数 ### 实现的方法 + 和上面相反 ### 操作系统解决方法 在访问公共的资源的时候采取一定的安全措施，实施对资源的互斥访问，或者在访问时不允许被打断 **具体方法**：信号量、互斥量、锁等机制 **临界资源**：公共的资源，如全局变量、静态变量、缓冲区、打印机等 **临界区**：访问临界资源的代码段"},"/note/编程基础/嵌入式C语言/2022-7-24-系统调用.html":{"title":"系统调用","content":" layout: post title: \"系统调用\" # 系统调用 驱动和上层代码由不同的团队开发，不能保证安全性 优点： + 简化程序开发，提供统一的接口 + 保证安全 ### 操作系统的权限管理 > 指令在运行时运行权限、内存访问权限、硬件资源访问权限，Linux在内核态时候可以随意访问资源，在用户态时候受到限制 ### CPU的特权等级 不同的CPU有不同的运行等级如x86有四个等级，ring0 ring3，ring3为应用程序使用的等级，访问系统硬件受到限制，ring0为特权等级，操作系统的等级 ARM平台：用户等级USR\t特权等级SYS、FIQ、IRQ、SVC、ABT、UND > 在特权模式下ARM可以使用一些特权指令，可以访问受限制的资源 ### Linux的系统调用接口 + 文件操作 + 进程操作 + 文件系统 + 系统控制 + 内存管理 + 信号 + Socket控制 POSIX标准：对不同的Linux的接口进行管理"},"/note/编程基础/嵌入式C语言/2022-7-24-中断.html":{"title":"中断","content":" layout: post title: \"中断\" # 中断 异步通讯模式，节约CPU的资源 任何打断系统正常进行的流程：外部中断、内部异常 ### 中断控制器 根据中断屏蔽优先级，中断是否使能等各种条件进行筛选，最后通知CPU，CPU进行跳转执行相应的处理，PC指针跳转到中断向量表中，向量表中存储不同的跳转指令，跳转至相应的中断函数。 在进行跳转之前CPU会对CPSR（程序状态）寄存器进行保存，并重新设置模式，将各种数据、状态压入栈，然后根据中断号跳转到对应的处理函数，处理完毕之后复原。 > **注**：中断返回的语句是当前执行的语句，函数返回的语句是当前语句的下一句。 ### 进程栈与中断栈 栈是C语言的基础，每个任务都有自己的栈，给函数的调用使用以及在被打断是保存现场环境。 调度器为了更好的管理每一个任务，为每一个任务提供了一个结构体 **保存的内容**： + PC、SP指针 + 各种寄存器 + SP一般会保存到任务结构体 **三种栈**： + 进程栈：用户使用 + 内核栈：操作系统使用 + 中断栈：中断函数使用 **中断栈作用**： + 中断函数使用 + 如果在进行中断函数的时候有新的中断，把正在进行的中端函数的信息保存于栈中 > **注**：Linux中断栈一般较小（4KB 8KB），使用时注意分配 ### 中断函数的实现 **注意以下三点** + 调用时间不固定，保护现场 + 调用地点不确定，没有参数 + 返回不确定，没有返回值 基本原则 > 不能有返回值 > > 不能有参数 > > 不能调用不可重入函数如printf > > 不能引起睡眠 > > 应该短小精悍"},"/note/编程基础/嵌入式C语言/2022-7-21-__attribute__.html":{"title":"__attribute__","content":" layout: article title: \"__attribute__\" # __attribute__ ![Image](https://xusenfeng.github.io/myimages/2 3.jpg){:.shadow} ![Image](https://xusenfeng.github.io/myimages/2 4.jpg){:.shadow}"},"/note/编程基础/嵌入式C语言/2022-7-22-二级指针.html":{"title":"二级子指针","content":" layout: article title: \"二级子指针\" # 二级指针 ```c #include <stdio.h> 2 3 int main(){ 4 int a 10; 5 int *p &a; 6 int **pp &p; 7 printf(\" a: %d\\n\", a); 8 printf(\" *p: %d\\n\", *p); 9 printf(\"**pp: %d\\n\", **pp); 10 puts(\"\"); 11 12 printf(\" &a: %p a: %d\\n\", &a, a); 13 printf(\" &p: %p p: %p\\n\", &p, p); 14 printf(\"&pp: %p pp: %p\\n\", &pp, pp); 15 puts(\"\"); 16 return 0; 17 18 } result: a: 10 *p: 10 **pp: 10 &a: 0x7ffcfd66e2f4 a: 10 &p: 0x7ffcfd66e2f8 p: 0x7ffcfd66e2f4 &pp: 0x7ffcfd66e300 pp: 0x7ffcfd66e2f8 ``` ### 作用 #### 指针变量的值 ```C 1 #include <stdio.h> 2 3 int a 10; 4 int b 20; 5 6 void change3(int **pp) 7 { 8 *pp &b;//把指针指向b 9 } 10 11 int main(void){ 12 int *p NULL; 13 p &a; 14 printf(\"p %d\\n\", *p); 15 change3(&p); 16 printf(\"*p %d\\n\", *p); 17 return 0; 18 } result: p 10 *p 20 ``` #### 指针数组传参 实参 可以匹配的参数 : : : : int a[5] int a[] int *p int *a[5] int *a[] int **p int a[3] [5] int a[] [5] int (*a)[5] ##### 二级指针和指针数组 ```C 1 #include <stdio.h> 2 3 char *season[4] {\"Spring\", \"Summer\", \"Autumn\", \"Winter\"}; 4 5 void array_print(char *a[], int len) 6 { 7 int i; 8 for(i 0; i<len ; i++) 9 { 10 printf(\"%s\\n\", a[i]); 11 } 12 } 13 void array_print2(char **a, int len) 14 { 15 int i; 16 for(i 0; i<len ; i++) 17 printf(\"%s\\n\", a[i]); 18 } 19 20 int main(void) 21 { 22 array_print(season, 4); 23 puts(\"\"); 24 array_print2(season, 4); 25 return 0; 26 } 27 28 result: Spring Summer Autumn Winter Spring Summer Autumn Winter ``` #### 操作二维数组 ##### 二级指针和二维数组 + *二维数组b[3][5]的指针指向的还是一个一维数组b[3]，每个一元素的长度为5, 是一维数组int (*p)[5]类型* ```c 1 #include <stdio.h> 2 3 int b[3][5] { 4 1, 2, 3, 4, 5, 5 6, 7, 8, 9, 0, 6 2, 2, 2, 2, 2 7 }; 8 9 int main(void){ 10 int i, j; 11 int (*p)[5]; 12 p b; 13 for(i 0; i<3 ; i++) 14 { 15 for(j 0; j< 5; j++) 16 printf(\"%d \", p[i][j]); 17 puts(\"\"); 18 } 19 return 0; 20 } result: 1 2 3 4 5 6 7 8 9 0 2 2 2 2 2 ``` + 二级指针操作二维数组 ```C 1 #include <stdio.h> 2 3 int a[3][5] { 4 1, 2, 3, 4, 5, 5 6, 7, 8, 9, 0, 6 2, 2, 2, 2, 2 7 }; 8 9 int main(void){ 10 int i, j; 11 int (*p)[5]; 12 p a; 13 int (**pp)[5]; 14 pp &p; 15 for(i 0; i<3 ; i++) 16 { 17 for(j 0;j<5;j++) 18 printf(\"%d \", (*pp)[i][j]); 19 puts(\"\"); 20 } 21 return 0; 22 } ``` + 一级指针操作二位数组 ```C 1 #include <stdio.h> 2 3 int a[3][5] { 4 1, 2, 3, 4, 5, 5 6, 7, 8, 9, 0, 6 2, 2, 2, 2, 2 7 }; 8 9 int main(void){ 10 int i, j; 11 int *pt a[0];//一级指针只能指向一个地址， 所以等价于pt &a[0][0] 12 for(i 0; i<3 ; i++) 13 { 14 for(j 0;j<5;j++) 15 printf(\"%d \", *(pt +i*5 + j)); 16 printf(\"\\n\"); 17 } 18 return 0; 19 } ```"},"/note/编程基础/嵌入式C语言/2022-7-23-头文件剖析.html":{"title":"头文件剖析","content":" layout: article title: \"头文件剖析\" # 头文件剖析 ### 基本概念 ​\t\t在一个C文件中除了main、跳转标号不需要声明之外所有的标识符在使用之前都需要进行声明，一般我们把函数的声明放在头文件中。 **变量声明 ! 变量定义** > 区别：是否分配内存 变量定义：生成相关的汇编指令 变量声明：告诉编译器，有可能存在于别的文件，编译时候先不要报错，在连接的时候到相应的文件中查找，没有\t\t\t\t\t再报错 定义只有一次，声明可以有多次 ```C 1 #include <stdio.h> 2 3 #ifndef __LCD_H__ 4 #define __LCD_H__ 5 6 #define PI 3.14 7 void lcd_init(void); 8 #endif ``` ##### 注： + 如果在头文件定义了新的数据类型，宏定义，就需要包含条件编译防止多次包含 ### 隐式声明 如果没有进行声明只产生一个警告，不会报错，并且增加一个隐式声明 给出的隐式声明可能会与原函数的数据格式有区别，造成错误 ### 变量声明与定义 extern：使用文件外的参数 ```C //1.c 1 int i 0; 2 int a[10] {1, 2, 3, 4, 5,6 ,7 ,8 ,9 , 0}; 3 struct student 4 { 5 int age; 6 int num; 7 }; 8 struct student stu {20, 1001}; 9 int k; 10 //main.c 1 #include <stdio.h> 2 3 extern int i; 4 extern int a[10]; 5 struct student{ 6 int age; 7 int num; 8 }; 9 extern struct student stu; 10 extern int k; 11 12 int main(void) 13 { 14 printf(\"%s: i %d\\n\", __func__, i); 15 for(int j 0; j<10 ; j++) 16 printf(\"s[%d]: %d\\n\", j, a[j]); 17 printf(\"stu.age %d, num %d\\n\", stu.age, stu.num); 18 printf(\"%s: k %d\\n\", __func__, k); 19 return 0; 20 21 } result: main: i 0 s[0]: 1 s[1]: 2 s[2]: 3 s[3]: 4 s[4]: 5 s[5]: 6 s[6]: 7 s[7]: 8 s[8]: 9 s[9]: 0 stu.age 20, num 1001 main: k 0 ``` + 使用了extern无初始化语句则为声明 + 没有使用extern无初始化语句则为试探性定义 + 没有使用extern有初始化语句则为定义 **试探性定义**：该变量可能在别的文件中有声明，如果没有按照规则声明并初始化默认值：NULL， 0， ​\t\t\t\t\t\t undefined value等 。如果别的文件中有定义，那把他当成声明 ### 产生原因 ​\t\t由于内存原因，早期的C语言一次只能编译一个文件，每个源文件单独编译，只编译一次 #### 前向引用 没有声明就可以使用 + 隐式声明（新的标准中被禁用） + 语句标号：跳转向后 + 不完全类型：被定义完整之前用于特定的用途 **不完全类型** + void + 一个不确定大小的种类 + 一个不确定的struct或者union ```C int array_print(int i[], int len); struct LIST_NODE { struct LIST_NONE *next;//在定义结束前已经使用 int data; }; goto error； ``` **注**：在进行对不完全类型的引用时候只能使用类型属性，其他的如变量值，结构成员，大小等不能使用 ​\t\t如果只是用指针就可以不用考虑这些 ```C struct person;\\\\前向声明 struct student{ struct person *p; int score; int no; }; ``` ### 模块的封装 **add.h** ```C int add(int a, int b); ``` **add.c** + 包含自己的头文件：在编译时候进行检查，防止声明与定义不一致 ```C #include \"add.h\" int add(int a, int b) { return \ta+b; } ``` **main.c** ```C #include <stdio.h> #include \"add.h\" int main(void) { int sum; sum add(1, 2); return 0; } ``` ### 头文件路径 + <>:标准头文件，官方路径 + \"\":自定义的文件 **可以使用gcc I来指定目录** 搜索顺序<>： + gcc I + 环境变量指定 + GCC内定文件 搜索顺序\"\": + 当前目录 + gcc I + 环境变量 + GCC内定文件 ### Linux常用的路径 + PATH：可执行文件搜索 + C_INCLUDE_PATH: C语言头文件搜索路径 + CPLUS_INCLUDE_PATH: c++头文件路径 + LIBRARY_PATH:库文件搜索路径 ### 头文件中的内联函数 + 在多个模块调用这个文件的时候，内联函数已经被展开了，通常与static一同使用，确定作用域在本文件之中"},"/note/编程基础/嵌入式C语言/2022-7-23-模块进阶.html":{"title":"模块进阶","content":" layout: article title: \"模块进阶\" # 模块进阶 ### 跨平台设计 不同的操作系统提供的API不同，需要对接口进行封装 > C语言本身与平台无关，是跨平台的，C语言的标准和C语言的标准库里提供的接口也和平台无关，由C语言的标准确定，所以应该尽可能的使用C语言的标准函数而不是操作系统的接口。 不同的CPU的位宽、大小端、内存对齐 > 对于使用合适的数据类型：C语言标准类型、固定大小可移植、内核数据类型 ### 可行的方法 + 把操作系统为相关的调用封装成接口，隐藏不同操作系统之间的差异 + 头文件路径分隔符使用通用的\"/\"而不是windows下的\"\\\" + 禁止使用编译器扩展语法或者特性，只是用C语言的标准程序 + 尽量不要使用内嵌汇编 + 打开所有的警告选项 + 使用条件编译，让代码兼容每个平台 ### 框架 **定义：**可扩展的应用程序框架，降低开发的重复工作，减轻开发的压力"},"/note/编程基础/嵌入式C语言/2022-7-23-异步通信模式.html":{"title":"异步通讯","content":" layout: article title: \"异步通讯\" # 异步通讯 同步通讯：CPU等待通讯的完成 异步通讯：任务完成之后通知CPU 阻塞访问：在任务完成之前CPU不能践行别的任务 非阻塞访问：CPU可以进行别的任务 ### 常用的异步通讯 + 消息机制：和平台有关 + 事件驱动机制：状态机，GUI，前端编程 + 中断 + 异步回调"},"/note/编程基础/嵌入式C语言/2022-7-23-goto关键字.html":{"title":"goto关键字","content":" layout: article title: \"goto关键字\" # goto关键字 ### 作用 如果函数有多个错误出口可以使用goto简化函数，建立一个总出口释放malloc的内存，释放锁、文件句柄等资源 > 作用域为当前函数"},"/note/编程基础/嵌入式C语言/2022-7-23-模块间通讯.html":{"title":"模块间通讯","content":" layout: article title: \"模块间通讯\" # 模块间通讯 ### 全局变量 + 通过extern让全局变量可以被外部文件调用 **优点**：调用简单直接 **缺点**：增加了文件之间的耦合性 + 改进：增加接口对其访问 ```C //module.h void val_set(int value); void val_get(void); //module.c int global_val; void val_set(int value) { global_val value; } void val_get(void) { return global_val; } ``` ### 回调函数 stdio.c ```C 1 #include <stdio.h> 2 int send_data(char *buf, int len) 3 { 4 char data[100]; 5 int i; 6 for(i 0;i<len;i++) 7 data[i] buf[i]; 8 for(i 0;i<len;i++) 9 printf(\"receive data[%d] %d\\n\", i, data[i]); 10 return len; 11 } ``` main.c ```C 1 #include <stdio.h> 2 3 int send_data(char *buf,int len); 4 5 int main(void) 6 { 7 char buffer[10] {1, 2, 3, 4, 5, 6, 7, 8, 9, 0}; 8 int return_data; 9 return_data send_data(buffer, 10); 10 printf(\"send data len :%d\\n\", return_data); 11 return 0; 12 } ``` **缺点**：不能实现双向通讯 + 解决方法：回调函数 module1.c ```C 1 #include <stdio.h> 2 3 void runcallback(void (*fp)(void)) 4 { 5 fp(); 6 } 7 ``` module1.h ```C 1 //module.h 2 3 #ifndef __RUNCALLBACK__H 4 #define __RUNCALLBACK__H 5 void runcallback(void (*fp)(void)); 6 #endif ``` app.c ```C 1 #include <stdio.h> 2 #include \"module1.h\" 3 4 void func1(void) 5 { 6 printf(\"func1 ...\"); 7 } 8 void func2(void) 9 { 10 printf(\"func2 ...\"); 11 } 12 13 int main(void){ 14 runcallback(func1); 15 runcallback(func2); 16 return 0; 17 } ``` + 示例2 device_manager.h ```C 1 #ifndef __STORAGE_DEVICE__H 2 #define __STORAGE_DEVICE__H 3 typedef int (* read_fp)(void); 4 struct storage_device 5 { 6 char name[20]; 7 read_fp read; 8 }; 9 extern int register_device(struct storage_device dev); 10 extern int read_device(char *device_name); 11 12 #endif ``` device_manager.h ```C 1 #include <stdio.h> 2 #include \"device_manger.h\" 3 #include <string.h> 4 //保存登记 5 struct storage_device device_list[100] {0}; 6 unsigned char num;//现有的登记的数据的数量 7 //进行登记 8 int register_device(struct storage_device dev) 9 { 10 device_list[num++] dev; 11 return 0; 12 } 13 int read_device(char *device_name) 14 {//调用对应的函数 15 int i; 16 for(i 0;i<100;i++) 17 { 18 if(!strcmp(device_name,device_list[i].name)) 19 break; 20 } 21 if(i 100) 22 { 23 printf(\"Error! can't find device: %s\\n\", device_name); 24 return 1; 25 } 26 return device_list[i].read(); 27 } 28 29 ``` app.c ```C 1 #include <stdio.h> 2 #include \"device_manger.h\" 3 4 5 int sd_read(void) 6 { 7 printf(\"sd read data ...\\n\"); 8 return 10; 9 } 10 11 int udisk_read(void) 12 { 13 printf(\"udisk read data ...\\n\"); 14 return 20; 15 } 16 struct storage_device sd {\"sdcard\", sd_read}; 17 struct storage_device udisk {\"udisk\", udisk_read}; 18 19 int main(void) 20 { 21 register_device(sd); 22 register_device(udisk); 23 24 read_device(\"udisk\"); 25 read_device(\"udisk\"); 26 read_device(\"sd\"); 27 read_device(\"sdcard\"); 28 read_device(\"sdcard\"); 29 return 0; 30 } result: udisk read data ... udisk read data ... Error! can't find device: sd sd read data ... sd read data ... ```"},"/note/编程基础/嵌入式C语言/2022-7-24-进程线程协程.html":{"title":"进程线程协程","content":" layout: post title: \"进程线程协程\" # 进程线程协程 在多进程时候不能使用全局变量，但是使用了锁、关中断等机制实现互斥反应 在Linux之中可以使用man命令查看是不是安全的函数 ``` man 3 malloc ``` malloc调用了全局链表，但是通过临区实现了互斥访问，所以可以大胆调用 ## 进程 Linux下的每一个程序都会被封装成一个进程，用task_struct管理，在Linux下每一个进程的内存都是独立的，所以无论一个函数是不是可重入都可以调用。 #### 进程之间通讯 使用第三方工具 + 在每一个进程的4GB虚拟空间之中，3GB是各个进程独享，1GB内核是共享的，所以可以在内核中一片内存进行通讯 + 磁盘是共享的，通过文件沟通 + 共享内存，映射到同一块内存直接通讯 #### Linux工具 无名管道：有亲缘关系进程 有名管道：任意两个进程 信息量：进程间同步，包括system V信号量以及POISX信号量 消息队列：数据传输，包括system V消息队列以及POISX消息队列 共享内存：数据传输，包括system V共享内存以及POISX共享内存 信号：进程之间异步通讯 Linux新增API：signalfd、timerfd、eventfd Socket：套接字缓冲区，不同主机，不同进程 D BUS：桌面应用程序 ## 线程 每个进程之间相互独立，不同进程要借助第三方，切换进程开销也很大 > **线程**：一个进程之间可能有多个线程，共享代码段、数据段、地址空间、打开文件、信号处理等资源，每个线程又都有自己的单独的资源，如程序计数器、寄存器上下文、栈 > > **问题**：出现对共享资源安全访问，线程之间同步，一般使用互斥锁、条件锁、读写锁实现对共享资源的安全访问。 > **互斥锁**：在一个线程使用的时候其他的线程不嗯使用，导会导致频繁的切换 > > 使用条件变量，等待条件满足唤醒绑定到这个变量的线程 > **读写锁**：允许多个线程同时读取，但是写的时候只允许一个进程，切禁止读操作 每个线程都有自己的上下文环境，自己的PC指针和栈 ### 线程池 进程是资源分配的基本单元，线程是程序执行调度的最小单元 线程的开销除了开关锁、线程上下文切换，还有线程创建销毁 **线程池**：解决频繁使用线程， > **实现方法**：预先创建一些线程没有任务的时候阻塞，有任务的时候分配到指定的进程 **组成** + 管理线程：分配任务 + 工作线程：实际执行的 + 任务接口：创建任务 ## 协程 线程实行有一定的瓶颈，对共享的资源不再使用锁，交给程序锁，一般是使用在彼此熟悉的合作式多任务 ## 总结 进程最安全，协程效率最高 在不同系统上的分类有所不同"},"/note/编程基础/嵌入式C语言/2022-7-21-语句表达式define.html":{"title":"define和语句表达式","content":" layout: article title: \"define和语句表达式\" # define和语句表达式 + gcc ![Image](https://xusenfeng.github.io/myimages/2 1.jpg){:.shadow} ![Image](https://xusenfeng.github.io/myimages/2 2.jpg){:.shadow}"},"/note/编程基础/嵌入式C语言/2022-7-22-面向对象编程基础.html":{"title":"面向对象编程基础","content":" layout: article title: \"面向对象编程基础\" # 面向对象编程基础（OOP） <u>使用g++对cpp文件进行编译</u> 把共同 的东西进行抽象 #### 对象实现 ```c++ 1 #include <iostream> 2 using namespace std; 3 4 class Animal 5 { 6 public: 7 int age; 8 int weight; 9 Animal(); 10 ~Animal() 11 { 12 cout<<\"~Animal()...\"<<endl; 13 14 } 15 void speak(void) 16 { 17 cout<<\"Animal apeaking....\"<<endl; 18 } 19 }; 20 21 Animal::Animal(void) 22 { 23 cout<<\"Animal().....\"<<endl; 24 } 25 26 int main(void) 27 { 28 Animal animal; 29 animal.age 1; 30 cout << \"animal age \"<< animal.age <<endl; 31 animal.speak(); 32 return 0; 33 } 34 result： Animal()..... animal age 1 Animal apeaking.... ~Animal()... ``` #### 继承与多态 ```c++ 1 #include <iostream> 2 using namespace std; 3 4 class Animal 5 { 6 public: 7 int age; 8 int weight; 9 Animal(); 10 ~Animal() 11 { 12 cout<<\"~Animal() ...\" <<endl; 13 } 14 void speak(void) 15 { 16 cout<<\"Animal speak ...\"<<endl; 17 } 18 }; 19 Animal::Animal(void) 20 { 21 cout<<\"Animal() ...\"<<endl; 22 } 23 24 class Cat : public Animal 25 { 26 public: 27 char sex; 28 Cat(void){cout<<\"Cat()...\"<<endl;} 29 ~Cat(void){cout<<\"~Cat()...\"<<endl;} 30 void speak(void) 31 { 32 cout <<\"cat speak .. miaomiao\"<<endl; 33 } 34 void eat(void){ 35 cout<<\"cat eating ...\"<<endl; 36 } 37 }; 38 39 int main(void) 40 { 41 Cat cat; 42 cat.age 2; 43 cat.sex 'F'; 44 cout << \"cat.age:\"<<cat.age<<endl; 45 cout << \"cat.sex:\"<<cat.sex<<endl; 46 cat.speak(); 47 cat.eat(); 48 return 0; 49 } result: Animal() ... Cat()... cat.age:2 cat.sex:F cat speak .. miaomiao cat eating ... ~Cat()... ~Animal() ... ``` #### 虚函数与纯虚函数 + **virtual修饰的函数** ```C++ 1 #include <iostream> 2 using namespace std; 3 4 class Animal 5 { 6 public: 7 int age; 8 int weight; 9 Animal(); 10 ~Animal() 11 { 12 cout<<\"~Animal() ...\" <<endl; 13 } 14 virtual void speak(void) 15 { 16 cout<<\"Animal speak ...\"<<endl; 17 } 18 }; 19 Animal::Animal(void) 20 { 21 cout<<\"Animal() ...\"<<endl; 22 } 23 24 class Cat : public Animal 25 { 26 public: 27 char sex; 28 Cat(void){cout<<\"Cat()...\"<<endl;} 29 ~Cat(void){cout<<\"~Cat()...\"<<endl;} 30 void speak(void) 31 { 32 cout <<\"cat speak .. miaomiao\"<<endl; 33 } 34 void eat(void){ 35 cout<<\"cat eating ...\"<<endl; 36 } 37 }; 38 39 int main(void) 40 { 41 Cat cat; 42 Animal *p &cat; 43 p >speak();//使用父类的类调用子类的方法 44 cat.speak(); 45 return 0; 46 } result: Animal() ... Cat()... cat speak .. miaomiao cat speak .. miaomiao ~Cat()... ~Animal() ... ``` ####"},"/note/编程基础/嵌入式C语言/2022-7-23-模块化编程.html":{"title":"模块化编程","content":" layout: article title: \"模块化编程\" # 模块化编程 ### 划分 **系统**：各种模块构成的有机整体 **模块**：独立功能的有机实现 当模块数量多时可以对其进行分层 ### 与面向对象的关系 **面向对象**：代码复用 **模块化**：分而治之 系统定义 > 模块化 > 面向对象 ### 构建合理的目录结构 + 常见的结构 1. flat: 所有源文件放在一个目录下 2. shallow: 各个模块在各自的目录之下，主程序在顶层目录下 3. deep：主程序模块分别在不同的目录下 + Linux下没有工程管理器之类的工具需要手动管理 ### 模块的封装 + lcd.c ```C 1 #include <stdio.h> 2 3 void lcd_init(void){ 4 printf(\"lcd init ...\\n\"); 5 } 6 ``` + lcd.h ```C 1 void lcd_init(void); ``` + main.c ```C 1 #include <stdio.h> 2 #include \"lcd.h\" 3 4 int main(void) 5 { 6 printf(\"hello world ...\"); 7 lcd_init(); 8 return 0; 9 } 10 ``` ### 模块设计的原则 + 单个模块的功能尽可能单一，减少对外部函数的依赖 + 模块之间的关联性：调用，控制，数据传递。 耦合方式： 1. 非直接耦合：两个模块之间没有直接联系 2. 数据耦合：通过参数交换数据 3. 标记耦合：通过参数传递记录信息 4. 控制耦合：通过标志、开关、名字等控制另一个模块 5. 外部耦合：访问同一个全局变量 ##### 我们应该降低模块的耦合度 **方法**： 1. 接口设计：隐藏不必要的，引出的封装在头文件中其余的用static修饰 2. 全局变量：尽量少使用 3. 模块设计：独立存在功能单一，接口少简单 4. 模块依赖：单向调用"},"/note/编程基础/嵌入式C语言/2022-7-24-嵌入式启动.html":{"title":"嵌入式启动","content":" layout: post title: \"嵌入式启动\" # 嵌入式启动 [存储器相关知识 (xusenfeng.github.io)](https://xusenfeng.github.io/2022/07/cunchuqi/) ### 启动方式 首先执行CPU芯片内部固化的一小片代码ROMCODE，初始化存储器的接口，建立存储的映射，根据CPU的引脚确定启动方式 如果初始的地址是在SARM和NOR Flash可以随机读写，直接运行代码，其他的需要先复制到内存运行，因为这个时候DDR SDARM还没有初始化，所以会先复制到芯片内部集成的SRAM中进行，完成初始化之后进入DDR SDRAM中 ## 内存与外部设备 计算机的存储设备按照读取速度： + 寄存器 + 缓存 + 内存 + 外存 CPU内部：寄存器、Cache > 物理实现SRAM电路复杂物力成本高 内存(主存)：可以直接寻址RAM、ROM、NOR Flash 外存(辅存)：磁盘、SD卡等 #### 外部设备 和内存相对的外部设备 在一个嵌入式芯片之中存在各种控制IP + 设备控制：打开关闭、运行 + 协议控制：在电气层面实现各种通讯协议 + 数据转换：序列流、字节流 + 数据缓冲：缓冲区、FIFO、发送接收数据缓冲区 **通讯模式**: + 轮询 + 中断 + DMA 在进行设备通讯的时候接收到的数据会暂时存放在FIFO之中，当数据达到一个阈值之后会产生中断，CPU进入处理函数，读取FIFIO中的数据，发送时正好相反。 DMA：自动发送接收数据 ### I/O端口、内存 CPU控制外部设备，把外部设备控制器的寄存器称为I/O端口，每个寄存器对应一个端口，给这些I/O分配地址 + 独立编址：x86内核为他们分配16位的地址，和内存地址无关通过IN/OUT命令读取 + 统一编址：ARM外部设备和寄存器内存共享地址，按照读取内存的方法管理操作外部地址"},"/note/编程基础/嵌入式C语言/2022-7-21-存储器.html":{"title":"存储器相关知识","content":" layout: article title: \"存储器相关知识\" # 存储器 ![Image](https://xusenfeng.github.io/myimages/19.jpg){:.shadow} ### ROM + PRAM：可编程ROM只可写入一次 + EPROM：可多次用紫外线擦除 + EEPROM：多次电擦除，修改任意字节 + Flash：广义上的EEPROM以块为单位进行擦除 <u>flash是嵌入式系统常用的存储器，容量大，价格便宜</u> + NOR Flash：数据线地址线分开，具有随机寻址 + NAND Flash：数据线地址线复用，不支持随机寻址，按页读取 + eMMC：NAND Flash进行封装，可以通过MMC协议进行读写，BGA封装 + SD：NAND Flash进行封装，可以通过SDIO协议进行读写，SIP封装 + 3D/2D NAND:包括SLC、MLC、TLC，SLC一次存储一个字节，MLC有四个电平保存2Bit，TLC8个电平表示3Bit + SSD：NAND Flash存储列阵、读写控制封装在一起 ### RAM + DRAM：需要电容充电 + SDRAM：不需要充电 >不断升级：DDR SDRAM、DDR1SDRAM... ##### 与CPU连接方式 + SRAM接口：全地址寻址，支持随机寻址SRAM和NOR Flash使用 + DRAM接口：行地址+列地址寻址，CPU通过控制器的时序进行访问 + 串口：速度慢，但是接口少 NADA Flash容量大存储成本低，但不支持随机寻址，读取次数多会产生坏块 嵌入式一般采用搭配使用，系统从NOR Flash启动，数据采用NADA Flash存储 ### 存储映射 ARM复位之后PC指向0地址，通过存储映射讲不通的存储器映射到零地址，实现不同的启动方式 现在的CPU一般通过总线与存储单元链接，每个物理单元没有固定的存储地址 **处理器具体实现**： + 配置映射起始结束地址 + 设置BANK基地址 + 位带区、位带区别名"},"/note/编程基础/嵌入式C语言/2022-7-22-函数参数的本质.html":{"title":"函数参数的本质","content":" layout: article title: \"函数参数的本质\" # 函数参数的本质 ![Image](https://xusenfeng.github.io/myimages/25.jpg){:.shadow}"},"/note/编程基础/嵌入式C语言/2022-7-24-寄存器操作.html":{"title":"寄存器操作","content":" layout: post title: \"寄存器操作\" # 寄存器操作 ### 位运算 ```C 1 #include <stdio.h> 2 3 int main(void) 4 { 5 int i 0xff; 6 printf(\"%x\\n\", 0xff&0x0); 7 printf(\"%x\\n\", 0xf0&0x0f); 8 printf(\"%x\\n\", ~0xff); 9 printf(\"%x\\n\", 0x1<<3); 10 printf(\"%x\\n\", 0x1000>>4); 11 12 printf(\"%x\\n\", 0 ^ 0); 13 printf(\"%x\\n\", 0 ^ 1); 14 printf(\"%x\\n\", 1 ^ 0); 15 printf(\"%x\\n\", 1 ^ 1); 16 return 0; 17 } result: 0 0 ffffff00 8 100 0 1 1 0 ``` ##### 实现高低位互换 ```C 1 #include <stdio.h> 2 3 int main(void) 4 { 5 printf(\"%X\\n\", 0xAABB); 6 printf(\"%X\\n\", 0xAABB>>80xAABB<<8&0xff00); 7 return 0; 8 9 } result: AABB BBAA ``` ##### 判断是不是2的整数幂 ```C 1 #include <stdio.h> 2 3 int main(void) 4 { 5 int m 4; 6 if((m & ( m 1 )) 0) 7 printf(\"%d is power of 2\\n\", m); 8 else 9 printf(\"%d isn't power of 2\\n\", m); 10 return 0; 11 } ``` ##### 数字交换 ```C 1 #include <stdio.h> 2 3 void swap(int *a, int *b) 4 { 5 *a *a ^ *b; 6 *b *a ^ *b; 7 *a *a ^ *b; 8 } 9 int main(void) 10 { 11 int a 0x55; 12 int b 0x66; 13 printf(\" a:%X\\n b:%X\\n\", a, b); 14 a a ^ b; 15 b a ^ b; 16 a a ^ b; 17 18 printf(\" a:%X\\n b:%X\\n\", a, b); 19 swap(&a, &b); 20 printf(\" a:%X\\n b:%X\\n\", a, b); 21 return 0; 22 } ``` ### 操作寄存器 ``` 0xffff0000 0x0f 0xffffffff & 0xffffff0f 0xffffffff & ~(0x000000f0) ``` 可以直接宏定义 ```C #define BIT_0 0x1 #define BIT_1 0x01<<1 ... ``` ### 位域 限定几个位长度的数据类型 + 和结构体一块使用 ```C 1 #include <stdio.h> 2 #include <string.h> 3 4 struct register_usb 5 { 6 unsigned short en :1;//设置一个位 7 unsigned short ep :4;//设置四个位 8 unsigned short mode :3;//设置三个位 9 }; 10 11 int main(void) 12 { 13 struct register_usb reg; 14 memset(&reg, 0 , sizeof(reg)); 15 reg.en 1; 16 reg.ep 4; 17 reg.mode 3; 18 printf(\"szieof %d\\n\", sizeof(reg)); 19 printf(\"reg:%x\\n\", reg); 20 printf(\"reg.en:%x\\n\", reg.en); 21 printf(\"reg.ep:%x\\n\", reg.ep); 22 printf(\"reg.mode:%x\\n\", reg.mode); 23 return 0; 24 25 } ``` + 和联合体一块使用 ```C 1 #include <stdio.h> 2 #include <string.h> 3 4 union spsr 5 { 6 unsigned short mode :3; 7 unsigned short ep :4; 8 unsigned short en :1; 9 }; 10 11 int main(void) 12 { 13 union spsr reg2; 14 memset(&reg2, 0, sizeof(reg2)); 15 reg2.mode 3; 16 printf(\"reg2:%x\\n\", reg2); 17 return 0; 18 19 } ``` 对于没有使用的位可以使用匿名 ```C 4 struct spsr 5 { 6 unsigned short mode :3; 7 unsigned short :4;//不设置变量名 8 unsigned short en :1; 9 }; ```"},"/note/编程基础/嵌入式C语言/2022-7-23-多任务.html":{"title":"多任务","content":" layout: article title: \"多任务\" # 多任务 ### 多任务模拟实现 ```C 1 #include <stdio.h> 2 3 void delay(int ms) 4 { 5 for(int i 0 ; i<5000000 ; i++) 6 { 7 for(int j 0 ; j < ms ; j++); 8 } 9 } 10 11 int task_key_scan(void) 12 { 13 int key_value; 14 printf(\"keyboard scan...\\n\"); 15 return key_value; 16 } 17 void task_led_show(void) 18 { 19 printf(\"lec_show\\n\"); 20 } 21 void task_temperature_get(void) 22 { 23 printf(\"DB18S20 init ...\\n\"); 24 } 25 void task_temperature_set(void) 26 { 27 printf(\"set temperature...\\n\"); 28 } 29 int main(void) 30 { 31 while(1) 32 { 33 task_temperature_get(); 34 delay(100); 35 task_led_show(); 36 delay(100); 37 task_key_scan(); 38 delay(100); 39 task_temperature_set(); 40 delay(100); 41 printf(\"\\n\\n\"); 42 43 } 44 return 0; 45 } ``` #### 改变频率 ```C 1 #include <stdio.h> 2 3 unsigned int count; 4 void count_add(void) 5 { 6 for(int i 0;i<5000000;i++); 7 count++; 8 9 } 10 11 int task_key_scan(void) 12 { 13 int key_value; 14 printf(\"keyboard scan...\\n\"); 15 return key_value; 16 } 17 void task_led_show(void) 18 { 19 printf(\"lec_show\\n\"); 20 } 21 void task_temperature_get(void) 22 { 23 printf(\"DB18S20 init ...\\n\"); 24 } 25 void task_temperature_set(void) 26 { 27 printf(\"set temperature...\\n\"); 28 } 29 int main(void) 30 { 31 while(1) 32 { 33 count_add(); 34 if(count % 1000 0) 35 task_temperature_get(); 36 if(count %100 0) 37 task_led_show(); 38 if(count % 200 0) 39 task_key_scan(); 40 if(count % 2000 0) 41 task_temperature_set(); 42 43 } 44 return 0; 45 } ``` ### 改变任务执行时间 > 防止由于某些任务时间过长，影响其他任务的正常执行 **使用状态机** 记录每次的状态，根据状态进行处理，并转换至下一种状态"},"/note/编程基础/python/基础语法/2025-1-31-多任务.html":{"title":"多任务","content":"# 多任务 [Python 异步协程：从 async/await 到 asyncio 再到 async with Piper蛋窝 博客园](https://www.cnblogs.com/piperliu/articles/18625027) Python 引入了 `async`/`await` 语法来支持异步编程。当我们在函数定义前加上 `async` 关键字时，这个函数就变成了一个\"协程\"（coroutine）。而 `await` 关键字则用于等待一个协程完成。 ```python import asyncio import random import time async def process_item(item): print(f\"处理中：{item}\") # async 定义的函数变成了协程 process_time random.uniform(0.5, 2.0) # time.sleep() 换成 asyncio.sleep() await asyncio.sleep(process_time) # await 等待异步操作完成 return f\"处理完成：{item}，耗时 {process_time:.2f} 秒\" async def process_all_items(): items [\"任务A\", \"任务B\", \"任务C\", \"任务D\"] # 创建任务列表 tasks [ asyncio.create_task(process_item(item)) for item in items ] print(\"开始处理\") results await asyncio.gather(*tasks) return results async def main(): start time.time() results await process_all_items() end time.time() print(\"\\n\".join(results)) print(f\"总耗时：{end start:.2f} 秒\") if __name__ \"__main__\": asyncio.run(main()) ``` 1. 当函数被 `async` 关键字修饰后，调用该函数不会直接执行函数体，而是返回一个协程对象 2. await 关键字只能在 `async` 函数内使用，它表示\"等待这个操作完成后再继续\" 3. `asyncio.create_task()` 将协程包装成一个任务，该任务会被事件循环调度执行 4. `asyncio.gather()` 并发运行多个任务，并等待它们全部完成 5. `asyncio.run()` 创建事件循环，运行 `main()` 协程，直到它完成 ## asyncio.wait_for 添加超时控制 ```python import asyncio import random import time async def process_item(item): process_time random.uniform(0.5, 2.0) try: # 设置1秒超时 await asyncio.wait_for( asyncio.sleep(process_time), timeout 1.0 ) return f\"处理完成：{item}，耗时 {process_time:.2f} 秒\" except asyncio.TimeoutError: return f\"处理超时：{item}\" async def main(): items [\"任务A\", \"任务B\", \"任务C\", \"任务D\"] tasks [ asyncio.create_task(process_item(item)) for item in items ] start time.time() results await asyncio.gather(*tasks, return_exceptions True) end time.time() print(\"\\n\".join(results)) print(f\"总耗时：{end start:.2f} 秒\") if __name__ \"__main__\": asyncio.run(main()) ``` ## 使用事件循环执行阻塞操作 run_in_executor 在异步编程中，我们可能会遇到一些无法避免的阻塞操作（比如调用传统的同步API）。这时，`asyncio.get_running_loop()` 和 `run_in_executor` 就显得特别重要： ```python import asyncio import time import requests # 一个同步的HTTP客户端库 async def blocking_operation(): # 获取当前事件循环 loop asyncio.get_running_loop() # 在线程池中执行阻塞操作 result await loop.run_in_executor( None, # 使用默认的线程池执行器 requests.get, # 要执行的阻塞函数 'http://httpbin.org/delay/1' # 函数参数 ) return result.status_code async def non_blocking_operation(): await asyncio.sleep(1) return \"非阻塞操作完成\" async def main(): # 同时执行阻塞和非阻塞操作 tasks [ asyncio.create_task(blocking_operation()), asyncio.create_task(non_blocking_operation()) ] start time.time() results await asyncio.gather(*tasks) end time.time() print(f\"操作结果：{results}\") print(f\"总耗时：{end start:.2f} 秒\") if __name__ \"__main__\": asyncio.run(main()) ``` 输出： ```txt 操作结果：[200, '非阻塞操作完成'] 总耗时：1.99 秒 ``` 这个例子展示了如何在异步程序中优雅地处理同步操作。如果不使用 `run_in_executor`，阻塞操作会阻塞整个事件循环，导致其他任务无法执行： `requests.get()` 是同步操作,会阻塞当前线程 事件循环运行在主线程上 如果直接在协程中调用 `requests.get()` ，整个事件循环都会被阻塞 其他任务无法在这期间执行 `run_in_executor` 会将阻塞操作放到另一个线程中执行 主线程的事件循环可以继续处理其他任务 当线程池中的操作完成时，结果会被返回给事件循环 最佳实践是： 尽量使用原生支持异步的库(如 `aiohttp`) 如果必须使用同步库，就用 `run_in_executor` 对于 CPU 密集型任务也可以用 `run_in_executor` 放到进程池中执行 ## 任务取消：优雅地终止异步操作 有时我们需要取消正在执行的异步任务，比如用户中断操作或超时处理： ```python import asyncio import random async def long_operation(name): try: print(f\"{name} 开始执行\") while True: # 模拟一个持续运行的操作 await asyncio.sleep(0.5) print(f\"{name} 正在执行...\") except asyncio.CancelledError: print(f\"{name} 被取消了\") raise # 重要：继续传播取消信号 async def main(): # 创建三个任务 task1 asyncio.create_task(long_operation(\"任务1\")) task2 asyncio.create_task(long_operation(\"任务2\")) task3 asyncio.create_task(long_operation(\"任务3\")) # 等待1秒后取消task1 await asyncio.sleep(1) task1.cancel() # 等待2秒后取消其余任务 await asyncio.sleep(1) task2.cancel() task3.cancel() try: # 等待所有任务完成或被取消 await asyncio.gather(task1, task2, task3, return_exceptions True) except asyncio.CancelledError: print(\"某个任务被取消了\") if __name__ \"__main__\": asyncio.run(main()) ``` 输出： ```txt 任务1 开始执行 任务2 开始执行 任务3 开始执行 任务1 正在执行... 任务2 正在执行... 任务3 正在执行... 任务1 被取消了 任务2 正在执行... 任务3 正在执行... 任务2 正在执行... 任务3 正在执行... 任务2 被取消了 任务3 被取消了 ``` 这个例子展示了如何正确处理任务取消： 1. 任务可以在执行过程中被取消 2. 被取消的任务会抛出 `CancelledError` 3. 我们应该适当处理取消信号，确保资源被正确清理"},"/note/编程基础/python/基础语法/2023-6-15-修饰器.html":{"title":"修饰器","content":" layout: post title: \"修饰器\" date: 2023 6 15 15:39:08 +0800 tags: python基础 # 修饰器(语法糖) 在python中函数实际上就是一个对象 ```python def outer(x): def inner(y): return x + y return inner print(outer(6)(5)) ``` ```python def double(x): return x * 2 def triple(x): \treturn x * 3 def calc_number(func, x): print(func(x)) calc_number(double, 3) calc_number(triple, 3) ``` 函数自己也可以作为返回值 ## 修饰器 新的代码需要在一个函数的前面或者后面添加一段代码 ```python def dec(f): pass @dec def double(x): return x * 2 #等价于 double dec(double) ``` > 会把下面的函数传给这一个装饰器函数, 装饰器需要返回新的函数, 这一个返回值会成为新的下面的函数 ```python import time def timeit(f): def wrapper(x): start time.time() ret f(x) print(time.time() start) return ret return wrapper @timeit def myfunction(x): time.sleep(x) # myfunction(1) @timeit def other_func(x): return x*2 print(other_func(2)) ``` ## 带参数 ```python import time def timeit(f): def wrapper(*args, **kwargs):\t\t\t#传入的参数不限制 start time.time() ret f(*args, **kwargs)\t\t\t# 会把传入的函数在这里执行 print(time.time() start) return ret return wrapper @timeit def myfunc(x): time.sleep(x) @timeit def add(x, y): return x+y print(add(2, 3)) ``` 接下来就讲装饰器，其实装饰器就是一个闭包，装饰器是闭包的一种应用。什么是装饰器呢，简言之，python装饰器就是用于拓展原来函数功能的一种函数，这个函数的特殊之处在于它的返回值也是一个函数，使用python装饰器的好处就是在不用更改原函数的代码前提下给函数增加新的功能。使用时，再需要的函数前加上@demo即可。 ```python import time def timeit(repeats): def decorator(func): def wrapper(*args, **kwargs): total_time 0 for _ in range(repeats):\t\t# 1000决定这一个函数的执行次数 start_time time.time() result func(*args, **kwargs)\t# 获取一个result end_time time.time() total_time + end_time start_time average_time total_time / repeats print(f\"Average execution time: {average_time} seconds\") return result return wrapper return decorator @timeit(1000) def double(x): return x * 2 # Equivalent to: # double timeit(1000)(double) # Test the function print(double(2)) ``` > 前面的返回的是一个函数(这一个函数会被作为修饰器), 返回的这一个修饰器调用double再返回一个实际可以执行的函数 ## 修饰器闭包 ```python import time def timeit(interation): def inner(f): def wrapper(*args, **kwargs): start time.time() for _ in range(interation): print(\"1\") ret f(*args, **kwargs) ret f(*args, **kwargs) print(time.time() start) return ret return wrapper return inner @timeit(10) def double(x): return x*2 print(double(2)) ``` > 等价于 > > ```python > inner timeit(10) # 返回一个修饰器 > double inner(double)\t# 使用这一个修饰器进行修饰 > ``` > > ```python >import time > > def inner(f): > def wrapper(*args, **kwargs): > start time.time() > for _ in range(10): > print(\"1\") > ret f(*args, **kwargs) > ret f(*args, **kwargs) > print(time.time() start) > return ret > > return wrapper > return inner > > @inner > def double(x): > return x*2 > ``` 装饰器实际装饰的时间是在python解析到这一个函数的时候, 实际执行函数的时候不用再次装饰 > 实际这一个装饰就是一个闭包, 不同的是这一个闭包对它的参数的使用, 修饰器把这一个参数作为可调用的对象使用 ## 多次修饰 ```python def makeBlod(fn): def wrapped(): return \"<b>\" + fn() + \"</b>\" return wrapped def makeItalic(fn): def wrapped(): return \"<i>\" + fn() + \"</i>\" return wrapped @makeBlod @makeItalic def hello(): return \"hello world\" print(hello()) ``` > ```bash > PS E:\\JHY\\python\\2024 4 22> python u \"e:\\JHY\\python\\2024 4 22\\main.py\" > <b><i>hello world</i></b> > ``` > > 装饰的时候会先调用离得近的那一个 ## 类为装饰器 ```python import time class Test(object): def __init__(self, func): print(\"初始化\") print(\"func name is %s\" % func.__name__) self.__func func def __call__(self): print(\"装饰器中的功能\") self.__func() @Test def test(): print(\"test函数\") test() ``` > 这一个实际调用的时候是`test Test(test)`, 创建了一个对象 ```python import time class Test(object): def __init__(self, num): print(\"初始化\") self.__num num def __call__(self, func): print(\"装饰器中的功能\") def inner(): print(\"inner函数, num %d\" % self.__num) func() return inner @Test(10) def test(): print(\"test函数\") test() ``` > 这里是先获取一个对象, 这一个对象的执行是一个修饰器 ```python class Test(object): def __init__(self, num): print(\"初始化\") self.__num num def __call__(self, func): print(\"装饰器中的功能\") self.__func func return self.call_old_func def call_old_func(self): print(\"inner函数\") self.__func() ```"}}