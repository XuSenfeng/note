{"/note/使用软件/ARM/2023-6-26-1ARM汇编.html":{"title":"ARM汇编","content":" layout: post title: \"ARM汇编\" date: 2023 6 26 15:39:08 +0800 tags: stm32 # ARM汇编 ![image 20230626180143014](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300286.png) ARM 处理器有 7 中常见的运行模式： **User(用户模式)、 FIQ(快中断模式)、 IRQ(中断模式)、 SVC(管理模式)、 Abort(终止模式)、 Undef(未定义模式)和 Sys(系统模式)**。其中 User 是非特权模式，其余 6 中都是特权模式。但新的 Cortex A 架构加入了TrustZone 安全扩展，所以就新加了一种运行模式：Monitor(安全模式)，新的处理器架构还支持虚拟化扩展，因此又加入了另一个运行模式： Hyp(虚拟化模式)，所以 Cortex A7 处理器有9 种处理模式（上电后默认进入SVC模式）。 ![image 20230626180244770](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300287.png) 每一种模式都有一组寄存器供异常处理程序使用，这样的目的是为了保证在进入异常模式以后，用户模式下的寄存器不会被破坏。 值得注意的是，一般Cortex A系列的处理器都有常见的7中模式，而Cortex M只有两种运行模式，特权模式和非特权模式，但是 Cortex A 就有 9 种运行模式。 ## 程序状态寄存器 ![image 20230626180607277](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300288.png) N、Z、C、V均为条件码标志位。它们的内容可被算术或逻辑运算的结果所改变 在ARMv5以前的版本Q标志位没有意义，属于带扩展的位。在ARMv5以后的版本Q位用于判断是否发生了溢出。 CPSR的低8位统称为控制位。当发生异常时,这些位也发生了相应的变化。另外，在特权模式下，也可以通过软件编程的方式来改变这些位的值。 > 中断禁止位 > > I 1，IQR被禁止， > F 1，FIQ被禁止。 > 状态控制位 > > T 0是ARM状态， > T 1是Thumb状态。 > 模式控制位 > > M[4:0]为模式控制位。 > > ![image 20230626180846309](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300289.png) 值得注意的是，对于Cortex M3/M4系列的处理器，与CPSR对应的是xPSR。 xPSR实际上对应3个寄存器： ① APSR：Application PSR，应用PSR ② IPSR：Interrupt PSR，中断PSR ③ EPSR：Exectution PSR，执行PSR ![image 20230626180954963](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300290.png) ![image 20230626181013210](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300291.png)"},"/note/使用软件/ai-jupyter/2024-9-10-Jupyter.html":{"title":"Jupyter","content":" layout: post title: \"Jupyter\" date: 2024 8 5 15:39:08 +0800 tags: Jupyter # jupyter 可以使用这一个把Markdown文档和代码放在同一个文件里面"},"/note/使用软件/qt/2022-9-15-07-控件.html":{"title":"控件","content":" layout: post title: \"控件\" date: 2022 9 15 15:39:08 +0800 tags: qt # 常用的控件 + Tool Button 显示图片的按钮, toolButtonStyle设置显示文字以及图片, autoRalse设置透明效果 + RadioButton 单选框, 使用GroupBox进行设置分组, 可以使用代码setChecked进行默认选中 + Check Box 多选按钮 ```c++ connect(ui >checkBox_3, &QCheckBox::stateChanged, [ ](int state){ qDebug() << state; }); ``` + list Widget 列表, 每一行都是QListWidgetItem ```c++ // QListWidgetItem *item new QListWidgetItem(\"锄禾日当午\"); // //把文字放入控件 // ui >listWidget >addItem(item); // //设置居中 // item >setTextAlignment(Qt::AlignHCenter); //一次性添加 \tQStringList list;//列表容器 list << \"锄禾日当午\" << \"汗滴禾下土\" << \"谁知盘中餐\" << \"粒粒皆辛苦\" ; ui >listWidget >addItems(list); ``` + tree Widget树状图 ```c++ //tree Widget //设置水平的头部信息，使用匿名对象 ui >treeWidget >setHeaderLabels(QStringList()<<\"芜湖\"<<\"起飞\"); //添加主节点 QTreeWidgetItem * item new QTreeWidgetItem(QStringList()<<\"力量\"); QTreeWidgetItem * item2 new QTreeWidgetItem(QStringList()<<\"敏捷\"); QTreeWidgetItem * item3 new QTreeWidgetItem(QStringList()<<\"智力\"); ui >treeWidget >addTopLevelItem(item); ui >treeWidget >addTopLevelItem(item2); ui >treeWidget >addTopLevelItem(item3); //追加子节点 QStringList hero; hero<<\"亚瑟\"<<\"前排坦克\"; QTreeWidgetItem * item4 new QTreeWidgetItem(hero); item >addChild(item4); ``` + table Widget表格 ```c //TableWidget控件 //设置列数 ui >tableWidget >setColumnCount(3); //设置水平表头 ui >tableWidget >setHorizontalHeaderLabels(QStringList()<<\"姓名\"<<\"性别\"<<\"年龄\"); //设置行数 ui >tableWidget >setRowCount(5); //正文 ui >tableWidget >setItem(0, 0, new QTableWidgetItem(\"亚瑟\")); ``` > 可以使用循环进行填写, 使用QString::number()把数字转换为字符串 + Group Box 用来进行分组, 对于单选使用 + Scroll Area 滚动框架 + Tool box 相当于联系人分组之类的, 每一个页里面可以放控件 + Tab Widget 相关当于浏览器的不同页面之间 + Staked Widget 手机不同页面之间切换, 需要设专门的切换位置 ```c++ connect(ui >btn_1, &QPushButton::clicked, [ ](){ \tui >stackedWidget >setCurrentIndex(0); }); connect(ui >btn_2, &QPushButton::clicked, [ ](){ \tui >stackedWidget >setCurrentIndex(1); }); connect(ui >btn_3, &QPushButton::clicked, [ ](){ \tui >stackedWidget >setCurrentIndex(2); }); ``` > 也可以用这个进行设置第一个出现的页面 + Fram 边框 + Widget 用来布局 + Dock Widget 浮动窗口 + Combo Box 下拉框 ```c++ //下拉框 ui >comboBox >addItem(\"jiji\"); ui >comboBox >addItem(\"gege\"); ui >comboBox >addItem(\"kun\"); ui >comboBox >addItem(\"basketball\"); ui >comboBox >addItem(\"rap\"); connect(ui >btn_4, &QPushButton::clicked, [ ](){ //ui >comboBox >setCurrentIndex(2); ui >comboBox >setCurrentText(\"basketball\"); }); ``` + Font Combo Box 字体下拉框 + Line Edit 单行输入框 + Text Edit 多行文本, 有加粗下划线等 + Plan Text Edit 纯文本 + Spin Box 数字加减, 选择整数 + Double Spin Box 数字加减, 选择的是小数 + Time Edit + Date Edit + Time/Data Edit + 几个进度条 + Lable 标签, 可以添加图片 ```c++ ui >label >setPixmap(QPixmap(\":/avatar.png\")); ``` 可以放gif动图 ```c++ Qmovie *movie new Qmovie(\":/1.gif\") ui >label >setMovie(movie); movie >start(); ```"},"/note/使用软件/qt/2022-9-15-08-界面布局.html":{"title":"界面布局","content":" layout: post title: \"界面布局\" date: 2022 9 15 15:39:08 +0800 tags: qt # 界面布局 在布局的时候使用Widget可以把几个部件合为一组, 之后选择布局的方式 在布局的时候可以使用弹簧进行弹性的布局界面选择, 也可以选择固定长度的 在进行密码设置的时候echoMode进行设置显示的方式 在设置的时候默认的框架和窗口一样大, 可以通过设置SizePolicy的策略进行设置 ## 边距 有两种, margin以及padding, 这两个是内边距以及外边距 + margin: 外边距 + padding: 内边距 ![image 20251231225208270](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512312252325.png) ```css QPushButton { margin : 50px; border width: 10px; border color: #458B00; border style: solid; } ``` > 设置边框的时候需要设置三个 ![image 20251231225919858](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512312259927.png) ![image 20251231230000957](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512312300019.png) ## 布局 ![image 20260112172627350](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601121726428.png) ### 水平/竖直布局 ![image 20260112172752092](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601121727130.png) > 可以在选择物品以后使用这个按键进行布局的控制 + spacing: 间隔距离, 控件之间的像素 + stretch: 拉伸因子(系数), 输一个数组, 对应所有的控件, 不同的控件的相对的比例大小 + sizePolicy: 大小测策略, 在每一个控件的里面有这个属性 可以直接设置整个窗口使用布局(试了一下好像没用) ```bash this >setLayout(ui >horizontalLayout); ``` ![image 20260112173735883](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601121737934.png) ![image 20260112173823376](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601121738413.png) 可以使用的有七种 + Fixed: 固定的大小 + Minimum: 可以扩大, 但是不可以缩小, 使用`sizeHint`进行设置 + Maximum: 设置同上, 设置一个控件的最大值 + Preferred: 默认属性, 可大可小，无主动争空间的意愿，优先用推荐尺寸 + Expanding: 贪心, 会主动争取布局中的多余空间（优先级高），尽可能占满可用空间 + MinimumExpanding: `sizeHint`是最小尺寸（不能更小），且会主动争取布局的多余空间，尽可能占满可用空间。 + Ignored: 直接无视`sizeHint()`推荐尺寸，控件会尽可能占据布局分配的**所有空间**（能伸能缩，无任何尺寸限制） ![image 20260112174100249](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202601121741299.png) ### 网格布局 QGridLayout 关键的属性还是那几个"},"/note/使用软件/qt/2022-9-13-01-QT项目.html":{"title":"QT项目","content":" layout: post title: \"QT项目\" date: 2022 9 13 15:39:08 +0800 tags: qt # QT项目 ![QQ图片20220913151322](https://blog 1308522872.cos.ap beijing.myqcloud.com/jhy/202212312351905.png) Base class有三个选项 + QMainWindow: 分为三层, 上面是菜单栏, 下面是状态栏 + QWidget: 是一个空白的窗口, 嵌入式使用的最多 + Qdialog 有几个按钮的窗口, 是一个对话框 > 实际的关系是QWidget是父类, 别的两个是子类 ## 项目文件 + 首先是一个工程文件.pro ```cmake # 包含的模块, 一个是模型一个是图形界面 QT + core gui # 版本大于4的话加入这个模块 greaterThan(QT_MAJOR_VERSION, 4): QT + widgets CONFIG + c++11 # The following define makes your compiler emit warnings if you use # any Qt feature that has been marked deprecated (the exact warnings # depend on your compiler). Please consult the documentation of the # deprecated API in order to know how to port your code away from it. DEFINES + QT_DEPRECATED_WARNINGS # You can also make your code fail to compile if it uses deprecated APIs. # In order to do so, uncomment the following line. # You can also select to disable deprecated APIs only up to a certain version of Qt. #DEFINES + QT_DISABLE_DEPRECATED_BEFORE 0x060000 # disables all the APIs deprecated before Qt 6.0.0 # 源文件 SOURCES + \\ main.cpp \\ myvidget.cpp # 头文件 HEADERS + \\ myvidget.h # Default rules for deployment. qnx: target.path /tmp/$${TARGET}/bin else: unix:!android: target.path /opt/$${TARGET}/bin !isEmpty(target.path): INSTALLS + target ``` 在文件中有一个宏 QT + core gui 这是文件默认添加的模块, 之后在文件中添加头文件就可以使用了, 可以在[All Modules Qt 5.15](https://doc.qt.io/archives/qt 5.15/qtmodules.html)查看所有的模块 之后还会定义文件的版本检查 编译的文件 > 可以使用`TARGET`进行定义生成的文件的名字 > > TEMPLATE: 创建的模板的名字一般使用app ## 启动流程 ```c++ #include \"mywindows.h\"\t\t//我自己创建的类 #include <QApplication>\t\t//包含一个应用程序的头文件 //程序的入口 int main(int argc, char *argv[]) { //把命令行参数传递给这个类, 这是一个应用程序对象, 有且只有一个 //这个类是用来管理设置Qt程序的运行, 针对QWidget应用程序 QApplication a(argc, argv); //自定义的类, w是创建的对象, 是一个窗口 MyWindows w; //对象调用函数, 默认不会显示, 使用show才会进行显示 w.show(); //调用的是一个事件循环, 等待鼠标键盘等的输入 return a.exec(); } ``` > 管理使用的类 > > QApplication > > QGuiApplication 针对非QWidget程序, 比如QQuick > > QCoreApplication 针对的是没有界面的应用程序 ### 头文件 ```c++ #ifndef MYWINDOWS_H #define MYWINDOWS_H // 添加的窗口的类 #include <QMainWindow> QT_BEGIN_NAMESPACE namespace Ui { class MyWindows; } QT_END_NAMESPACE class MyWindows : public QMainWindow { //这是一个宏定义, Qt信号槽需要这个, 允许类中使用信号和槽的机制 Q_OBJECT public: //两个函数, 构造函数, 析构函数 MyWindows(QWidget *parent nullptr);\t//默认设置一个父类 ~MyWindows(); private: Ui::MyWindows *ui; }; #endif // MYWINDOWS_H ``` ```c++ #include \"mywindows.h\" #include \"ui_mywindows.h\" #include <QDebug> MyWindows::MyWindows(QWidget *parent) : QMainWindow(parent)\t\t//初始化父类 , i(4) , ui(new Ui::MyWindows) { ui >setupUi(this); // 实际和ui界面联系的位置 qDebug() << \"构造函数执行\" <<endl; } ``` > 使用qDebug()进行打印, 使用setupUi函数和ui文件进行联系 ## 常用的快捷键 + Ctrl + n 新建项目 + Ctrl + r 运行项目 + Ctrl + b 构建项目 + F1 帮助文档 + Ctrl + 滚轮 字体大小 + Ctrl + A Ctrl + I 代码对齐 + Ctrl + Shift + Enter 上面加入新行 + Ctrl + Enter 下面加入新行 + Ctrl + Shift + ↑ 代码上移 + Ctrl + Shift + ↓ 代码下移 + Ctrl + Shift + PgUp 这一行代码复制到上面一行 + Ctrl + Shift + PgDn 这一行代码复制到下面 + Ctrl + 点击 跳转到定义 + Alt + ← 返回 + Ctrl + Shift + T 查看一个类的层次 + F4 头文件源文件之间来回切换 ## 规范 文件的命名：使用小写字母，可以有大写字母，windows文件不区分大小写， 文件名和文件中的类名一样 下载的文件的源码在文件/opt/Qt5.12.9/5.12.9/Src文件夹之中 类名：单词的首字母大写 函数名：除了构造函数，析构函数成员函数的首字母小写，单词之间的字母大写 成员变量：首字母小写，单词之间的字母大写 ```c++ QObject::connect(sender, SIGNAL(signal()), receiver, SLOT(slot())); ``` > 实际使用的函数 > > sender 是发射信号的对象的名称，signal() 是信号名称。信号可以看做是特殊的函数，需要带括号，有参数时还需要指明参数。receiver 是接收信号的对象名称，slot() 是槽函数的名称，需要带括号，有参数时还需要指明参数。 > > 生成的代码在文件mainwindow.h中"},"/note/使用软件/qt/2022-9-14-06-菜单栏工具栏.html":{"title":"菜单栏工具栏","content":" layout: post title: \"菜单栏工具栏\" date: 2022 9 14 15:39:08 +0800 tags: qt # 菜单栏工具栏 是一个为用户提供的类, 包括一个菜单栏(menu bar), 多个工具栏(tool bars), 多个锚点工具也叫浮动工具(dock widgets), 一个状态栏(status bar), 以及一个中心部件(central widget) ```c++ MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) { resize(800, 600); //创建菜单，最多只能有一个 QMenuBar * bar menuBar(); //把文件栏放入 setMenuBar(bar); //创建文件菜单, 有一个返回值 QMenu * fileMenu bar >addMenu(\"文件\"); QMenu * editMenu bar >addMenu(\"编辑\"); //创建菜单项 QAction * newAction fileMenu >addAction(\"新建\"); //添加分隔线 fileMenu >addSeparator(); QAction * openAction fileMenu >addAction(\"打开\"); //工具栏可以有多个 QToolBar * toolBar new QToolBar(this); //进行添加,默认在左边 addToolBar(Qt::LeftToolBarArea, toolBar); //只允许左右停靠 toolBar >setAllowedAreas(Qt::LeftToolBarArea Qt::RightToolBarArea); //设置浮动 toolBar >setFloatable(false); //设置移动（总开关） toolBar >setMovable(false); //在工具栏中设置内容,使用上面的两个 toolBar >addAction(newAction); toolBar >addAction(openAction); //添加控件 QPushButton *btn new QPushButton(\"test\", this); //放在工具栏 toolBar >addWidget(btn); \t //状态栏，最多一个 QStatusBar * stBar statusBar(); setStatusBar(stBar); //放置标签控件 QLabel * label new QLabel(\"提示的信息\", this); stBar >addWidget(label); QLabel * label2 new QLabel(\"右侧提示的信息\", this); stBar >addPermanentWidget(label2); //铆接部件(浮动)可以有多个 QDockWidget *dockWidget new QDockWidget(\"浮动\", this); addDockWidget(Qt::BottomDockWidgetArea, dockWidget); //设置只允许上下 dockWidget >setAllowedAreas(Qt::TopDockWidgetArea); //中心部件只有一个 QTextEdit *edit new QTextEdit; setCentralWidget(edit); } ``` > 最多有一个的使用set进行设置, 有多个的使用add进行添加 ## 总结 + QMenuBar 菜单 + QMenu 菜单栏内容 + QAction 文件项 + QToolBar 工具栏 + QStatusBar 状态栏 + QDockWidget 铆接部件 + QTextEdit 中心部件"},"/note/使用软件/qt/2022-9-13-03-对象树.html":{"title":"对象树","content":" layout: post title: \"对象树\" date: 2022 9 13 15:39:08 +0800 tags: qt # 对象树 设置按钮的父设备，在初始化的时候设置父设备就可以自动联系窗口 可以在初始化的时候进行设置 ```c++ pushButton new QPushButton(this); ``` 在之后赋值 ````c++ pushButton new QPushButton; pushButton >setParent(this); ```` 父对象在析构的时候会**释放所有的子对象**， 目的是为了方便内存管理 所有的对象都有一个父类QObject类, 在创建对象的时候如果传入父类会创建一个表, 在最后释放的时候把所有的子类都释放掉 ```c++ //调用父类的构造函数并且传入prent参数 MyPushButton::MyPushButton(QWidget *parent) : QPushButton(parent) { } ``` 在释放函数的时候会检查有没有子类, 有的话会先对子对象进行释放 ## 常见类 ### QObject 所有类的基类 ### QWidget 这个是组件的基础类, 所有的组件都会使用这个类, 也可以用于布局作为顶层 他继承了`QObject`以及`QPaintDevice`"},"/note/使用软件/qt/2022-9-13-04-样式表以及资源文件.html":{"title":"样式表","content":" layout: post title: \"样式表\" date: 2022 9 13 15:39:08 +0800 tags: qt # 样式表 ## 添加资源文件 + 第一种使用绝对路径 ```c ui >action >setIcon(QIcon(\"/home/jiao/qt/avatar.png\")); ``` > action是在ui界面中添加的一个菜单栏选项 + 使用相对路径 把文件放到这个文件夹里面 项目 >添加新文件 >Qt >Qt Resource File 会创建文件.qrc, 使用open in Editor打开编辑界面 ![image 20251229220546361](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512292205437.png) ![image 20251229220709437](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512292207499.png) ![image 20251229220940365](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512292209399.png) 在这里添加Prefix, 选择文件的分类路径, 然后添加文件 ![image 20251229221105051](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512292211102.png) 使用: 代码不变, 但是路径\" : + 前缀名 + 路径名 \" ```c++ //点击新建弹出一个对话框 connect(ui >actionnew, &QAction::triggered, [ ](){ //对话框 //模态和非模态 //模态就是不可以对其他窗口进行操作，会进行阻塞 QDialog dlg(this); dlg.resize(100,75); dlg.exec(); qDebug() << \"模态对话框弹出\" << endl; }); ``` ```c++ //非模态, 由于不会阻塞, 所以应该使用堆栈, 否则函数结束就会释放 QDialog *dlg2 new QDialog(this); dlg2 >show(); ``` ## 样式表 Qt的样式表(style sheet)和CSS的语法比较类似, 是自定义小组件样式使用的, 图片等资源都是一个样式表 <img src \"https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512292214821.png\" alt \"image 20251229221428779\" style \"zoom:50%;\" /> ![image 20251229221649321](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512292216381.png) ![image 20251229221817070](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512292218110.png) ![image 20251229221847598](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512292218650.png) ```css QFrame, QLabel, QToolTip { border image: url(:/icons/logo.png) } ``` ### 代码实现 ```cpp this >setStyleSheet(\" QWidget {border image: url(:/icons/logo.png)}\"); ``` ### qss文件 ![image 20251229233115863](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512292331508.png) ![image 20251229232830514](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512292328598.png) ![image 20251229233152324](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512292331581.png) ```cpp QFile file(\":/icons/style.qss\"); if(file.exists()){ file.open(QFile::ReadOnly); QString styleSheet QLatin1String(file.readAll()); qApp >setStyleSheet(styleSheet); file.close(); } ``` ```css QWidget { border image: url(:/icons/logo.png) } ``` 这里设置的是这一个类的所有的style, 可以使用`setObjectName`这个单独设置名字进行添加样式 ```css QLabel#label2 { border image: url(:/icons/logo.png) } ``` 可以使用`:`继续指定状态, 比如悬停的时候时候替换图片, 选中时候另一种 ```css QLabel#label2:hover { border image: url(:/icons/logo2.png) } QLabel#label2:checked { border image: url(:/icons/logo3.png) } QLabel#label2:checked:hover { border image: url(:/icons/logo4.png) } ```"},"/note/使用软件/qt/2022-9-14-05-Button.html":{"title":"QPhshButton","content":" layout: post title: \"QPhshButton\" date: 2022 9 14 15:39:08 +0800 tags: qt # QPushButton 下压按钮 ```c++ #include \"myvidget.h\" #include <QPushButton> myVidget::myVidget(QWidget *parent) : QMainWindow(parent) { //创建按键 QPushButton *btn new QPushButton; btn >show(); //以顶层的方式调用控件 btn >setParent(this); btn >setText(\"第一个按钮\"); //方法2 QPushButton *btn2 new QPushButton(\"第二个按钮\", this); //移动 btn2 >move(100, 100); //设置窗口大小 //resize(1024, 480); //设置固定的大小 setFixedSize(1024,480); //设置窗口标题 setWindowTitle(\"第一个窗口\"); } ``` ### 常用的信号 常用的信号是继承`QAbstractButton`的, 有四个 ```cpp void clicked(bool checked false); //点击 void pressed(); // 按下 void released(); // 释放 void toggled(bool checked); // 开关, 可以使用checked获取是否选中 ``` 在使用toggled的时候, 需要设置按键是可以选中的`setCheckable(true)`, 设置这个以后按钮按下以后不会自动抬起来 可以使用这个回调添加一个状态切换的槽函数, 显示不同的样式, 也可以直接使用QSS文件里面配置不同的状态样式 ```css QPushButton#qPushButton:hover { border image: url(:/icons/logo2.png) } QPushButton#qPushButton:checked { border image: url(:/icons/logo3.png) } QPushButton#qPushButton:checked:hover { border image: url(:/icons/logo4.png) } ``` ## QRadioButton 选项按钮, 一般是多个一起使用 ### 样式 可以单独设置前面的圆圈的样式 ```css QRadioButton::indicator:unchecked { image: url(:/icons/logo2.png) } ``` ### 选择 在同一个父对象里面是互斥的, 可以通过指定按钮组的方式进行 ![image 20251230232650350](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512302326410.png) 可以配置按钮组里面是不是多选 ![image 20251230233443660](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512302334776.png) > 实际也可以使用QPushButton添加一个按键组以后, 加上互斥实现这儿效果 ## QCheckBox 这是一个用于多选的框, 可以配置是不是使用三态 ![image 20251231222430160](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512312224215.png) ### 样式 实际是可以使用图片修饰不同的选择状态 ```css QCheckBox::indicator:unchecked { image: url(:/icons/logo0.png) } QCheckBox::indicator:indeterminate { image: url(:/icons/logo1.png) } QCheckBox::indicator:checked { image: url(:/icons/logo2.png) } ``` ### 信号 可以使用的信号多了一个`stateChanged(int)`, 可以使用的状态有 ```cpp Qt::Checked Qt::PartiallyChecked Qt::Unchecked ```"},"/note/使用软件/qt/2022-9-13-02-信号槽.html":{"title":"信号槽","content":" layout: post title: \"信号槽\" date: 2022 9 13 15:39:08 +0800 tags: qt # 信号槽 ​\t\t\t\t**发送者**\\ > **信号**\\ > **接收者**\\ >**槽**(执行的动作) 槽(Slot)就是一个函数，一般和信号(Signal)函数相关联， 信号发生的时候槽函数会被执行 优势: 松散耦合 信号的发送接收本来没有关系, 使用函数`QObject::connect(sender, SIGNAL(signal()), receiver, SLOT(slot())); `进行连接 > connect() 是 QObject 类的一个静态函数，而 QObject 是所有 Qt 类的基类，在实际调用 时可以忽略前面的限定符 信号只用声明不用定义，但是槽需要定义, SIGNAL 和 SLOT 是 Qt 的宏，用于指明信号和槽，并将它们的参数转换为相应的字符串。 当信号和槽函数带有参数时，在 connect()函数里，要写明参数的类型，但可以不写参数名称, 严格的情况下，信号与槽的参数个数和类型需要一致，至少信号的参数不能少于槽的参数。 如果不匹配，会出现编译错误或运行错误 > 在使用信号与槽的类中，必须在类的定义中加入宏 Q_OBJECT 当一个信号被发射时，与其关联的槽函数通常被立即执行，就像正常调用一个函数一样。 只有当信号关联的所有槽函数执行完毕后，才会执行发射信号处后面的代码 断开连接可以使用`bool QObject::disconnect(const QObject *sender, const char *signal, const QObject *receiver, const char *method) ` > 这个函数的参数传0表示这个参数可以填的所有对象全部断开 一个**信号**可以连接**多个槽**， 一个**槽**可以连接**多个信号**， 一个**信号**可以连接**另一个信号** ```c++ button new QPushButton(this); button >setText(\"我是傻逼\"); button >setGeometry(50, 50, 50, 25); this >resize(1024, 600); ``` > 设置按钮， 设置窗口 ```c++ void (Teacher:: *teacherSignal)(QString) &Teacher::hungry; void (Student:: *studentSignal)(QString) &Student::treat; connect(zt, teacherSignal, st, studentSignal); ``` > 使用函数的重载的时候调用的函数, 使用函数指针进行重载, 槽函数和信号函数的参数类型是需要进行匹配, 信号参数的数量需要比槽函数的数量多 信号连接亦可以断开 ```c disconnect() ``` > 参数和上面一样 ## 使用 ### 图形界面 ![image 20251229195704649](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512291957792.png) ![image 20251229195803617](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512291958659.png) 也可以使用连线的方式创建 ![image 20251229195954081](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512291959128.png) ![image 20251229200053730](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512292000783.png) > 退出是点击编辑控件的按钮, 在进入槽的左边 ### 图形自定义槽函数 右键 >转到槽 ![image 20251229200451091](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512292004145.png) ```cpp void MainWindow::on_pushButton_clicked() { qDebug() << \"hello world\" << Qt::endl; } ``` > 自动生成的文件在`#include \"ui_mainwindow.h\"`里面, 实际是定义了一个`class Ui_MainWindow`, 里面定义setupUi进行界面的初始化,最后交给UI命名空间里面的MainWindow > > ```cpp > namespace Ui { > class MainWindow: public Ui_MainWindow {}; > } // namespace Ui > ``` > > 所以可以使用ui对象进行引用界面里面创建的 ### 代码连接 可以使用的槽函数可以在手册里面查找 ![image 20251229203047312](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512292030391.png) ```cpp connect(ui >pushButton, SIGNAL(clicked()), this, SLOT(close())); ``` 这个是使用代码的方式进行连接 ### 代码自定义 ![image 20251229204127525](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512292041620.png) ![image 20251229204209009](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512292042082.png) + 信号 ```c++ #include <QObject> class School : public QObject { Q_OBJECT public: explicit School(QObject *parent nullptr); signals: //信号关键字, 自定义的信号写在这里 //信号, 没有返回值, 只需要声明不需要实现, 可以有参数, 可以重载 void send_messages();\t }; ``` + 槽 ```c++ class Student : public QObject { Q_OBJECT public: explicit Student(QObject *parent nullptr); signals: //槽的关键字, 早期的版本必须写在这里, 现在可以写在public public slots: //槽实现函数, 返回值是void, 可以有参数, 可以发生重载 void comeBackToClass(); }; ``` + 注册以及发送信号 ```c++ //这里使用的是Qt4的连接方法, 连接的是没有参数的两个函数, 编译器不会进行检查 connect(school, SIGNAL(send_messages()), student, SLOT(comeBackToClass())); //实际上就是传递函数的地址 //connect(myBtn, &QPushButton::clicked, this, &myVidget::close); emit school >send_messages();\t//实际产生信号 ``` > 四个参数就是上面的四个结构 在实际打印的时候由于`QString`类型的参数会打印出一个双引号, 所以需要进行一个类型的装换, 转换为char * ```c++ foodName.toUtf8().data() ``` > 首先转换为QByteArray类型, 之后再次转换"},"/note/使用软件/qt/2022-9-15-事件.html":{"title":"事件","content":" layout: post title: \"事件\" date: 2022 9 15 15:39:08 +0800 tags: qt # 事件 所有的事件都被称为QEvent ## 鼠标事件 鼠标进入的事件叫QEnterEvent, 只要鼠标进入就有 ```c++ void myLabel::enterEvent(QEvent *event) { qDebug()<<\"小飞棍来喽\"; } void myLabel::leaveEvent(QEvent *event) { qDebug()<<\"小飞棍走喽\"; } void myLabel::mouseMoveEvent(QMouseEvent *ev) { if(ev >buttons() & Qt::LeftButton){ qDebug()<<\"小飞棍动喽\"; } } void myLabel::mousePressEvent(QMouseEvent *ev) { if(ev >button() Qt::LeftButton){ QString str QString(\"鼠标按下了 x %1 y %2\").arg(ev >x()).arg(ev >y()); qDebug()<<\"按下\"<<str; } QString str2 QString(\"鼠标按下了 Gx %1 Gy %2\").arg(ev >globalX()).arg(ev >globalY()); qDebug()<<\"按下\"<<str2; } void myLabel::mouseReleaseEvent(QMouseEvent *ev) { qDebug()<<\"释放\"; } ``` > 可以从QMouseEvent获取鼠标的信息 > > ```c++ > QString str QString(\"鼠标按下了 x %1 y %2\").arg(ev >x()).arg(ev >y()); > qDebug()<<\"按下\"<<str; > ``` > > > 可以使用格式化字符串, 使用x(), y()获取相对于控件的坐标, 使用globelX(), globelY()获取相对于屏幕的坐标 > > Qt::MouseButton button() const获取按下的按键 > > 使用buttons()获取多个按键的状况, 使用&进行判断, 进行状态的判断, 在移动的时候使用这个进行判断 setMouseTracking(true); > 设置鼠标的追踪状态 ## 定时器 ### 事件 ```c++ //启动定时器, 返回值是定时器的id, 可以定义多个定时器 startTimer(1000);//单位毫秒 void Widget::timerEvent(QTimerEvent *ev) { int id ev >timerid();//获得id可以进行判断 int num 1; ui >label_2 >setText(QString::number(num++)); } ``` ### 定时器类 ```c++ //另一种 QTimer *timer new QTimer(this); timer >start(500); //会产生一个信号 connect(timer, &QTimer::timeout, [ ](){ qDebug() << \"jiji\"; }); ``` ## 事件分发器 应用在调用处理函数之前会先调用事件分发器, 返回值是一个bool, 是true的时候就代表是用户要处理这个事件, 可以对事件进行一个拦截, 使用函数`bool event(QEvent *);` ```c++ bool myLabel::event(QEvent *e) { if(e >type() QEvent::MouseButtonPress) { //鼠标按下进行拦截 QString str QString(\"EVENT鼠标按下了\"); qDebug()<<\"按下\"<<str; //不进行调用 return true; } //父类处理函数 return QLabel::event(e); } ``` > 可以使用强制类型装换装换为鼠标的事件, 然后进行坐标的提取 > > ```c++ > QMouseEvent *ev static_cast<QMouseEvent *>(e); > QString str QString(\"鼠标按下了 x %1 y %2\").arg(ev >x()).arg(ev >y()); > ``` ## 事件过滤器 在事件到事件分发器之前可以使用事件过滤器进行过滤 有两个步骤, 首先给事件安装事件过滤器, 然后重写eventfilter事件 ```c++ //给label安装事件过滤器 ui >label >installEventFilter(this); //重写函数 bool Widget::eventFilter(QObject *obj, QEvent *e) { //重写事件过滤器 if(obj ui >label) { if(e >type() QEvent::MouseButtonPress) { //鼠标按下进行拦截 QMouseEvent *ev static_cast<QMouseEvent *>(e); QString str QString(\"事件过滤器鼠标按下了 x %1 y %2\").arg(ev >x()).arg(ev >y()); qDebug()<<\"按下\"<<str; return true; } } return QWidget::eventFilter(obj, e); } ```"},"/note/使用软件/qt/2022-9-15-绘图.html":{"title":"绘图事件","content":" layout: post title: \"绘图事件\" date: 2022 9 15 15:39:08 +0800 tags: qt # 绘图事件 ## 画家 使用事件paintEvent, 使用画家painter类 在画家事件中 ```c++ void Widget::paintEvent(QPaintEvent *) { } ``` ```c++ //实例化画家对象, 指定的是绘图的位置 QPainter painter(this); //画线 painter.drawLine(QPoint(0, 0), QPoint(100,100)); //设置颜色 QPen pen(QColor(255,125, 125)); pen.setWidth(3); pen.setStyle(Qt::DotLine); painter.setPen(pen); //画椭圆 painter.drawEllipse(QPoint(100, 100), 50, 50); painter.drawRect(0, 0, 50, 100); //画字 painter.drawText(QRect(10, 200, 100, 50), \"我是傻逼 \"); ``` 可以使用画刷对封闭的图形进行填充 ```c QBrush brush(QColor(0, 125, 255)); painter.setBrush(brush); ``` ### 高级设置 ```c++ QPainter painter(this); // painter.drawEllipse(QPoint(100, 50), 50, 50); // //设置抗锯齿, 效率比较低 // painter.setRenderHint(QPainter::Antialiasing); // painter.drawEllipse(QPoint(200, 50), 50, 50); //画一个矩形 painter.drawRect(QRect(20, 20, 50, 50)); //移动画家的起始位置 //保存画家的状态 painter.save(); painter.translate(100,0); painter.drawRect(QRect(20, 20, 50, 50)); //还原状态 painter.restore(); painter.drawRect(QRect(20, 20, 50, 50)); ``` 使用update()可以再次调用绘图函数 ### 画图片 ```c++ posX+ 20; painter.drawPixmap(posX, 20, QPixmap(\":/avatar.png\")); ``` ## 设备 Qt的绘图实际上就是QPainter使用QPaintEngine在QPainDevice上画图 绘图设备是画家画图的对象 + QPixmap: 专门为图象在屏幕上显示做了优化 + QBitmap: 是QPixmap的一个子类, 色深设定为1, 画出的就是黑白两色 + QImage: 专门为像素的访问做了优化 + QPicture: 可以记录重现QPinter命令 > 窗口继承了绘图设备, 也可以直接进行画画 ```c++ QPixmap pix(300, 300); QPainter painter(&pix); painter.setPen(QPen(Qt::green)); painter.drawEllipse(QPoint(150, 150), 100, 100); //保存 pix.save(\"/home/jiao/qt/test.png\"); ``` > 画出来的背景是黑色的, 可以使用`pix >fill`进行填充, 为了不同的平台做出不同的优化 ```c++ // QImage img(300, 300, QImage::Format_ARGB32); // img.fill(Qt::white); // QPainter painter(&img); // painter.setPen(QPen(Qt::green)); // painter.drawEllipse(QPoint(150, 150), 100, 100); // img.save(\"/home/jiao/qt/test.png\"); QPainter painter(this); //利用QImage对像素进行修改 QImage img; img.load(\":/avatar.png\"); //修改像素 for(int i 0; i < 100; i++) { for(int j 50 ; j < 100; j++) { QRgb value qRgb(255, 0, 0); img.setPixel(i, j, value); } } painter.drawImage(0, 0, img); ``` > 可以对像素进行设置 ```c++ QPicture pic; QPainter painter; //设置指令 painter.begin(&pic); painter.setPen(QPen(Qt::cyan)); painter.drawEllipse(QPoint(150, 150), 100, 100); painter.end(); pic.save(\"/home/jiao/qt/test.jiao\"); //重现指令 QPicture pic; pic.load(\"/home/jiao/qt/test.jiao\"); QPainter painter(this); painter.drawPicture(0, 0, pic); ``` > 保存你绘图的指令"},"/note/使用软件/qt/2022-9-15-对话框.html":{"title":"对话框","content":" layout: post title: \"对话框\" date: 2022 9 15 15:39:08 +0800 tags: qt # 对话框 ```c++ //点击新建弹出一个对话框 connect(ui >actionnew, &QAction::triggered, [ ](){ //对话框 //模态和非模态 //模态就是对话框出现的时候不可以对其他窗口进行操作，会进行阻塞 // QDialog dlg(this); // dlg.resize(100,75); // dlg.exec(); // qDebug() << \"模态对话框弹出\" << endl; //非模态对话框 QDialog *dlg2 new QDialog(this); //出现的问题，产生的对话框没有及时的释放掉 //解决 dlg2 >setAttribute(Qt::WA_DeleteOnClose); dlg2 >show(); }); ``` ## 标准对话框 Qt内部内置了一系列的对话框 QColorDialog: 选择颜色 QFileDialog: 选择文件 QFontDialog: 选择字体 QInputDialog: 允许输入一个值, 并进行返回 **QMessageBox: 模拟对话框, 用于显示信息** QPageSetupDialog: 打印机相关的选项 QPrintDialog: 打印机配置 QPrintPreviewDialog: 打印浏览 QProgressDialog: 显示操作过程 + QMessageBox对话框 有四种, critical, information, question, warning ```c++ //点击新建弹出一个对话框 connect(ui >actionnew, &QAction::triggered, [ ](){ //对话框 //模态和非模态 //模态就是不可以对其他窗口进行操作，会进行阻塞 // QDialog dlg(this); // dlg.resize(100,75); // dlg.exec(); // qDebug() << \"模态对话框弹出\" << endl; //非模态对话框 // QDialog *dlg2 new QDialog(this); // //出现的问题，产生的对话框没有及时的释放掉 // //解决 // dlg2 >setAttribute(Qt::WA_DeleteOnClose); // dlg2 >show(); //消息对话框 //错误对话框, 参数：父类，对话框头部，对话框信息 //QMessageBox::critical(this, \"critical\", \"错误\"); //信息对话框 //QMessageBox::information(this, \"information\", \"信息\"); //提问对话框，多出来的参数信息：出现的按钮，默认使用的按钮(关联回车), 返回值：用户选择信息 if(QMessageBox::Save QMessageBox::question(this, \"quesation\", \"提问\", (QMessageBox::SaveQMessageBox::Cancel), QMessageBox::Cancel)) { qDebug() << \"信息已经保存\"<<endl; }else { qDebug() << \"信息取消保存\"<<endl; } QMessageBox::warning(this, \"warning\", \"错误\"); ``` + 其他对话框 ```c //颜色对话框 // QColor color QColorDialog::getColor(QColor(255, 0, 0)); // qDebug() << \"r \" <<color.red()<< \"g \"<<color.green()<<\"b \"<<color.blue()<<endl; //文件对话框 //qDebug() << QFileDialog::getOpenFileName(this, \"打开文件\", \"/home/jiao\", \"(*.c)\") << endl; bool flag; //参数： ，字体的类型，字体的大小 QFont font QFontDialog::getFont(&flag, QFont(\"\", 24)); qDebug() << \"字体\" << font.family() << \"字号：\" <<font.pointSize() <<\"是否加粗：\" <<font.bold() << \"是否倾斜： \" << font.italic(); ```"},"/note/使用软件/qt/2022-9-16-动画.html":{"title":"动画","content":" layout: post title: \"动画\" date: 2022 9 16 15:39:08 +0800 tags: qt $ 动画 ```c++ //创建动画对象 QPropertyAnimation *animation new QPropertyAnimation(this, \"geometry\"); //设置时间间隔 animation >setDuration(500); animation >setStartValue(QRect(this >x(), this >y(), this >width(), this >height())); animation >setEndValue(QRect(this >x(), this >y()+40, this >width(), this >height())); //设置曲线 animation >setEasingCurve(QEasingCurve::OutBounce); animation >start(); ```"},"/note/使用软件/qt/2022-9-15-添加自定义控件.html":{"title":"添加自定义控件","content":" layout: post title: \"添加自定义控件\" date: 2022 9 15 15:39:08 +0800 tags: qt # 添加自定义控件 add New >Qt >设计师界面类 在这个界面进行设计属于你的类, 设计完事后转回主界面, 找到你设计的那个类的父类, 右键提升为, 输入你创建的类 > 全局包含 >下一次创建的时候会记录这一次创建的类型 还需要对外提供一些函数, 并且初始化的时候进行相关的控件的链接"},"/note/使用软件/qt/2022-9-12-QT简介.html":{"title":"QT简介 C++基础","content":" layout: post title: \"QT简介 C++基础\" date: 2022 9 12 15:39:08 +0800 tags: qt # QT简介 是一个C++开发库, 可以跨多个平台 官网www.qt.io 可以使用Qt Creator进行开发 使用C++17标准 # C++ 基础 + 类 ``` class 类名 { public: \t共有数据 protected: \t保护数据 private: \t私有数据 };\t\t ``` > 在不写关键字的时候默认是私有数据, 默认情况下只能访问一个对象的公有属性 + 构造函数, 析构函数 有一个和类名相同没有返回值的函数 ```c++ class Dog { public: \tDog(); }; ``` + 析构函数 ```c++ class Dog { public: \t~Dog(); }; ``` > 在内存被释放或者程序结束的时候调用的函数 + 类的继承 ```c++ class Animal { public: string name; }; class Dog :public Animal { public: private: }; ``` > 设置为使用public形式进行继承, 基类之中的私有属性不会被继承, 只会继承public/protected, 所有的属性会保存父类的属性, 子类之中函数不能调用父类的私有属性 > > 使用保护继承, 所有继承到的属性都是public属性, 只会继承public/protected, 同样不能访问对象的私有属性,但是可以在类中函数中访问别的两种属性 > > 私有继承, 所有继承到的属性都会变为private, 在类中不能访问所有基类中的成员 + 函数重载 在同一个作用域中, 有相同的函数名, 但是函数的参数的类型, 个数, 顺序不同, 或者返回不同的时候叫做函数的重载 + 使用new进行申请堆区, 使用delete进行删除 ```c++ //从堆中实例化对象 Dog *dog2 new Dog; dog2 >age 3; cout << dog2 >age << endl; cout << dog1.name <<endl; cout << \"Hello World!\" << endl; delete dog2; return 0; ``` ## 类型转换 C++增加了四个static_cast, dynamic_cast, const_cast, reinterpret_cast 使用的语法为xxxx_cast<new_type_name>(expression) + static_cast 是一种静态转换, 编译的时候就可以确定装换, 可以完成C语言中的大部分工作 不能转换掉const, volitale, 或者__unsigned的属性 + dynamic_cast 动态转换函数, 和静态转换相对, 只能对指针和引用进行转换, 用于类继承结构中的基类派生类指针引用之间的转换, 在运行的时候还会进行类型检查, 只有是继承关系的类之间才会进行转换, 并且继承的类之中有虚函数的存在 + const_cast 用于修饰不会修改的变量 + reinterpret_cast 不同类型之间的转换, 或者指针数字之间的转换"},"/note/使用软件/qt/2022-9-16-文件读写.html":{"title":"文件","content":" layout: post title: \"文件\" date: 2022 9 16 15:39:08 +0800 tags: qt # 文件读写 ```c++ //点击按钮弹出对话框 connect(ui >pushButton, &QPushButton::clicked, [ ](){ QString path QFileDialog::getOpenFileName(this, \"打开文件\", \"/home/jiao\"); //把路径放到lineEdit中 ui >lineEdit >setText(path); //读取文件 QFile file(path); file.open(QIODevice::ReadOnly); QByteArray array file.readAll(); ui >textEdit >setText(array); }); ``` > 默认支持的格式是utf 8 > > 读取其他文件需要使用类QTextCodec > > ```c++ > connect(ui >pushButton, &QPushButton::clicked, [ ](){ > QString path QFileDialog::getOpenFileName(this, \"打开文件\", \"/home/jiao\"); > > //把路径放到lineEdit中 > ui >lineEdit >setText(path); > QTextCodec * codec QTextCodec::codecForName(\"gbk\"); > //读取文件 > QFile file(path); > file.open(QIODevice::ReadOnly); > QByteArray array file.readAll(); > //ui >textEdit >setText(array); > > ui >textEdit >setText(codec >toUnicode(array)); > }); > ``` 按行进行读取 ```c++ while(!file.atEnd) { array + file.readLine(); } ``` 可以进行写 ```c++ file.open(QIODevice::Append); file.write(\"//over\"); file.close(); ``` ## 文件信息 使用类QFileInfo ```c++ QFileInfo info(path); qDebug() << \"大小： \" << info.size(); qDebug() << \"后缀名：\" << info.suffix(); qDebug() << \"文件名：\" << info.fileName(); qDebug() << \"日期\" << info.created().toString(\"yyyy/MM/dd hh:mm:ss\"); ```"},"/note/使用软件/qt/0000-0-00-lambda表达式.html":{"title":"lambda表达式","content":" layout: post title: \"lambda表达式\" date: 2022 9 14 15:39:08 +0800 tags: qt # lambda表达式 ```c++ [capture](params) opt > ret{body;}; ``` + capture: 捕获列表 + params: 参数列表 + opt: 函数选项 + ret: 返回值类型, 可以返回 + body: 函数体 > 在后面再加上一个括号相当于直接调用这个函数 捕获的方式有以下几种 + \\[ ]: 不捕获任何变量 + \\[&]: 捕获外部作用域的所有变量, 作为引用在函数中使用, 按照引用进行捕获 + \\[ ]: 捕获外部作用域的所有变量, 作为副本在函数中使用, 按照值进行捕获 + \\[ , &foo]: 按照值捕获作用中的所有变量, 但是按照引用进行捕获foo变量 + \\[bar]: 按照值进行捕获bar, 不捕获其他的变量 + \\[this]: 捕获this指针, 让函数有当前类相同的访问权限, 如果已经有了&或者 就默认添加这一个 > 使用关键字mutable可以修改值传递传进来的值 > > ```c++ > connect(myBtn, &QPushButton::clicked, this, [m] ()mutable { m 100 + 10; qDebug() << m; }); > ``` > > 修改的是值, 不是本来的对象 ```c++ connect(btn, &QPushButton::clicked, this, [ ](){ emit zt >hungry(\"ji\"); }); ``` > 可以在这个里面调用多个函数, 并且不受参数的限制 > > 参数的第三个是this, 第四个是lambda表达式的时候可以把this省略掉 注 : 一般使用值传递, 使用引用传递可能会出bug"},"/note/使用软件/数据库/2023-1-20-概述.html":{"title":"数据库概述","content":" layout: post title: \"数据库概述\" date: 2023 1 20 15:39:08 +0800 tags: 数据库 # 数据库概述 在数据进行管理的时候使用, 数据库管理系统DBMS实现对文件的管理 实际的功能:解析指令, 返回数据 有很多的数据库管理系统, MySQL是用的最多(免费＋收费), 其次是Oracle(收费) ## 学习的过程 + 安装数MySQL软件 + 配置数据库 + 创建数据库 + 创建表结构 + 创建用户并且授权 + 安装pymsql(Python操作) + 使用 实际使用有5.6, 5.7, 8.x几个版本, 实际上使用5.6或7的比较多 ## 相关概念 数据库DataBase(DB): 数据有组织的进行存储 数据库管理系统DataBase Management System: 用于操控以及管理数据库 SQL Structured Query Language: 操控数据库的统一标准的"},"/note/使用软件/数据库/2025-2-6-语句.html":{"title":"语句","content":"# 语句 ![image 20250206182937146](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/picture/202502061829207.png) > depart info ## 条件语句 ```sql select * from info where id > 4; select * from info where id between 2 and 4; ``` 可以使用and和or进行链接 ```sql select * from info where id in (1, 2, 4); select * from info where id not in (1, 2, 4); 使用depart里面的id来筛选info里面的数据 select * from info where depart_id in (select id from depart); ``` ```sql select * from info where exists (select *from depart where id 5); 数据存在选择所有 select * from info where not exists (select *from depart where id 5); ``` 也可以进行多次选择 ```sql select * from (select * from info where id > 5) as T where T.age > 16; ``` as可以建立一个临时的表, 实际使用的时候这里面的id实际是info.id的缩写, from的时候可以使用`,`分割查询多个表 ## 通配符 使用`%`是多个字符, `_`是一个字符 ```sql select * from info where name like \"%a%\"; select * from info where name like \"_a\"; ``` ## 映射 获取想要使用的列 ```sql select id, name\t\t\t from info select id, name as NM\t from info 把名字那一列换为NM select id, name as NM, 123 from info 多一个为123的列 ``` > as只改变前面的那一列的名字 ```sql select \tid, \tname, \t666 as num, \t(select max(id) from depart) as mid, 相当于3 as mid \t(select max(id) from depart) as nid, 相当于1 as nid \tage from info ``` ```sql select \tid, \tname, \t666 as num, \t(select title from depart where depart.id info.depart_id) as x2, 1 as nid \tage from info ``` > 按照depart_id去另一个表里面查找重新弄成一个列, 效率比较低 ```sql select \tid, \tname, \tcase depart_id when 1 then \"第一部门\" end v1 建立一个v1列, 有第一部门和NULL两个选项 \tcase depart_id when 1 then \"第一部门\" else \"其他\" end v2 建立一个v2列, 有第一部门和其他两个选项 \tcase depart_id when age<18 then \"少年\" when age < 30 then \"青年\" else \"壮年\" end v6 from info; ``` ## 排序 ```sql select * from info order by age desc; 倒序 select * from info order by age asc; 顺序 select * from info order by age asc, id desc; 按照顺序age顺序, 相同按id倒序 select * from info where age > 20 order by age asc, id desc; 按照顺序age顺序, 相同按id倒序 ``` ## 取部分 ``` sql select * from info limit 5; 取前五个数据 select * from info order by id desc limit 3; select * from info limit 5 offset 3; 从3位置后面开始取5个,实际的数据第一个是4 ``` ## 分组 ```sql select age,max(id),min(id),count(id),sum(id) from info group by age; ``` > 如果其他的列不可以按照这个分类方法进行合并, 不写, 或给出来一个聚合函数 通常使用的是count(id)或count(1)查看一下实际有多少个人每一组, 如果分组以后使用其他条件再次搜索使用having ```sql select age,count(id) info group by age having count(id) > 2; ``` ## 优先级 ```sql join on where group by having order by limit ``` ## 连表 ### 外连接 两个表之间有关联的时候可以使用 ```python select * from info left outer join depart on info.depart_id depart.id 主表 left outer join 从表 on 主表.x 从表.x ``` 使用这两个数据进行链接, 左边的是从表, 依次去和主表里面的数据对应, 主表里面的都需要显示出来, 两个里面的数据全部对应的时候没有区别, 主表里面的数据有没有对应上的会显示一行Null ### 内连接 ```sql 表 left inner join 表 on 表.x 表.x ``` 这两个表没有主从, 互相匹配, 显示有关系的数据 ### 场下连接 ```sql select id, title from depart union select id, name from info 相同的列数, 自动去重, 列的数量是一样的就可以链接 select id, title from depart union all select id, name from info 保留所有的 ```"},"/note/使用软件/数据库/2023-1-20-数据库管理.html":{"title":"数据库管理","content":" layout: post title: \"数据库管理\" date: 2023 1 20 15:39:08 +0800 tags: 数据库 # 数据库管理 **数据操作需要`commmit`保存** 类比概念 数据库: 文件夹 数据表: excel文件 ## 数据库的相关指令 + 查看当前所有的的数据库`show databases;` + 创建数据库`create database 数据库名 DEFAULT CHARSET utf8 COLLATE utf8_general_ci;`后面的是编码以及排序规则 + 删除数据库`drop database 数据库名;` + 进入数据库`use 数据库名` + 进入以后查看tables`show tables;` ```python import pymysql conn pymysql.connect(host \"127.0.0.1\", port 3306, user 'root', passwd \"jhy030116\", charset 'utf8') # 创建光标 cursor conn.cursor() # 参看数据库 cursor.execute(\"show databases\") # 接收数据 result cursor.fetchall() print(result) \"\"\" # 2.创建数据库 cursor.execute(\" create database day2 DEFAULT CHARSET utf8 COLLATE utf8_general_ci\") # 新增删除修改等操作需要添加一个commit # conn.commit() \"\"\" cursor.execute(\"show databases\") result cursor.fetchall() print(result) cursor.execute(\"use mysql\") cursor.execute(\"show tables\") result cursor.fetchall() print(\"mysql文件夹的内容\") print(result) cursor.close() conn.close() ``` ## 数据表的相关内容 + 创建一个表 ```mysql create tables 表名( \t列名 类型, \t列名 类型, \t列名 类型 )default charset utf8; ``` ```mysql mysql> create table tb1( > id int, > name varchar(16) > )default charset utf8; Query OK, 0 rows affected (0.45 sec) mysql> show tables; + + Tables_in_day2 + + tb1 + + 1 row in set (0.00 sec) ``` ```mysql mysql> create table tb2( > id int, name varchar(16) not null, 不允许为空 > email varchar(32) null,\t\t\t 允许为空(默认的) > age int > )default charset utf8; Query OK, 0 rows affected (0.55 sec) ``` ```mysql mysql> create table tb3( >id int, name varchar(16) not null, 不允许为空 > email varchar(32) null,\t\t\t 允许为空(默认的) > age int default 3\t\t\t\t 设置默认值, 如果不赋值默认为3 > )default charset utf8;\t\t Query OK, 0 rows affected (0.55 sec) ``` ```mysql mysql> create table tb4(id int primary key, 设置为主键不允许为空, 不能重复 > name varchar(16) not null, \t\t 不允许为空 > email varchar(32) null,\t\t\t 允许为空(默认的) > age int default 3\t\t\t\t 设置默认值, 如果不赋值默认为3 > )default charset utf8;\t\t Query OK, 0 rows affected (0.55 sec) ``` > 在实际使用的时候由于每次自己添加主键的数字不叫麻烦可以使用自增的方式 ```mysql mysql> create table tb5(id int not null auto_increment primary key, 设置为主键不允许为空, 不能重复,自增 > name varchar(16) not null, \t\t 不允许为空 > email varchar(32) null,\t\t\t 允许为空(默认的) > age int default 3\t\t\t\t 设置默认值, 如果不赋值默认为3 > )default charset utf8;\t\t Query OK, 0 rows affected (0.55 sec) ``` + 删除表`drop table 表名;` + 清空表`delete from 表名`或者`truncate table 表名;`后者速度较快, 不可恢复 + 查看表的数据格式`describe tb1`或`desc tb1` ```sql mysql> describe tb1; + + + + + + + Field Type Null Key Default Extra + + + + + + + id int(11) NO PRI NULL auto_increment name varchar(16) YES NULL pwd varchar(64) YES NULL + + + + + + + 3 rows in set (0.40 sec) ``` + 修改表 1. 添加列 ```mysql alter table 表名 add 列名 类型; alter table 表名 add 列名 类型 DEFAULT 默认值; alter table 表名 add 列名 类型 not null default 默认值; alter table 表名 add 列名 类型 not null primary key auto_increment; ``` 2. 删除列 ```sql alter table 表名 modify column 列名 类型; ``` 3. 修改列 ```sql alter table 表名 change 原来的列名 新的列名 新类型; ``` > 可以用来删除默认值以及主键, 自增 4. 修改列默认值 ```sql ALTER TABLE 表名 ALTER 列名 SET DEFAULT 100; ``` 5. 删除列的默认值 ```sql ALTER TABLE 表名 ALTER 列名 DROP DEFAULT; ``` 6. 添加主键 ```sql alter table 表名 add primary key(列名); ``` 7. 删除主键 ```sql alter table 表名 drop primary key; ``` + 插入数据 `insert into L1(id , uid , zid) values(1, 2, 3);` > L1表名, id, uid和zid是列名, 后面的是数据 ## 常见的数据类型 ### 整形 + `int [(m)][unsigned][zerofill]` ```sql int\t\t\t\t\t\t\t\t有符号, 有范围 int unsigned\t\t\t\t\t 无符号, 有范围, 2^32, 可以在配置文件中设置超过范围就截断 int(5)zerofill \t\t\t\t\t 仅用于显示, 当不满5位的时候左边补充0, 满足的时候正常显示 ``` > 示例 > > ```sql > mysql> create table L1(id int , uid int unsigned , zid int(5) zerofill) > > default charset utf8; > Query OK, 0 rows affected (0.68 sec) > > mysql> insert into L1(id , uid , zid) values(1, 2, 3); > Query OK, 1 row affected (0.42 sec) > > mysql> insert into L1(id , uid , zid) values(2147483614, 4292967294, 300000); > Query OK, 1 row affected (0.32 sec) > > mysql> select * from L1; > + + + + > id uid zid > + + + + > 1 2 00003 > 2147483614 4292967294 300000 > + + + + > 2 rows in set (0.00 sec) > ``` + `tinyitnt[(m)] [unsigned] zerofill`相当于char 2^8 + `bigint [(m)] [unsigned] zerofill`相当于long 2^64 ### 小数 + `decimal [(m[, d])] [unsigned] zerofill` m: 表示数字的整个数(不算符号), d是小数点之后的个数, m最大为65, d最大是30, 小数超出的话遵循四舍五入, 整数超出的会报错 > ```sql > mysql> create table L2(id int not null primary key auto_increment, salary decimal(8, 2))default charset utf8; > Query OK, 0 rows affected (0.49 sec) > mysql> insert into L2(salary) values(1.28); > Query OK, 1 row affected (0.38 sec) > > mysql> insert into L2(salary) values(5.298); > Query OK, 1 row affected, 1 warning (0.00 sec) > > mysql> select * from L2; > + + + > id salary > + + + > 1 1.28 > 2 5.30 > + + + > 2 rows in set (0.00 sec) + `FLOAT[(M,D)] [unsigned] [zerofill]`单精度浮点小数, 非准确小数值 + `DOUBLE[(M,D)] [unsigned] [zerofill]` 双精度浮点数, 同上 ### 字符串 + `char(m)` 定长字符串, m代表存储的字符个数, 最大255, 存储的字符就算是小于m也会按照m进行存储, 超出报错, 非严格模式截断 > 在配置文件中加入`sql mode 'NO_AUTO_CREATE_USER, NO_ENGINE_SUBSTITUTION'`会非严格模式, 超出不报错 > 默认的情况下不用会用空白进行补全, 查询的时候会把空白去除, 想保留空白在`sql mode`中加入`PAD_CHAR_TO_FULL_LENGTH`, 查看`sql mode`模式执行命令:`show variables like 'sql mode'` + `varchar(m)` 变长字符串, m代表字符个数, 最大是65535个字字节 按照实际的存入的字符的个数进行保存, 超出的话进行报错截段 + text 用于保存大字符串, 最多65535, 一般情况下长段的字符会使用 + `mediumtext` 最大2^24^个字符 + longtext 最大2^32^个字符 ### 时间 + `datatime` ``` YYYY MM DD HH:MM:SS (1000 01 01 00:00:00/9999 12 31 23:59:59) ``` + `timestamp` ``` YYYY MM DD HH:MM:SS (1970 01 01 00:00:00/2037) ``` 自己显示的值和时区有关, 存储的时候转换为UTC时间, 在显示的时候会转换为当前时区的时间 ````sql mysql> create table l5 ( > id int not null primary key auto_increment, > dt datetime, > tt timestamp > )default charset utf8; Query OK, 0 rows affected (0.34 sec) mysql> insert into l5(tt, dt) value(\"2020 11 12 11:11:12\", \"2323 12 31 12:23:32\"); Query OK, 1 row affected (0.34 sec) mysql> select * from l5; + + + + id dt tt + + + + 1 2323 12 31 12:23:32 2020 11 12 11:11:12 + + + + 1 row in set (0.00 sec) ```` ```sql mysql> show variables like '%time_zone%'; + + + Variable_name Value + + + system_time_zone time_zone SYSTEM + + + 2 rows in set, 1 warning (0.00 sec) mysql> set time_zone '+0:00'; Query OK, 0 rows affected (0.00 sec) mysql> show variables like '%time_zone%'; + + + Variable_name Value + + + system_time_zone time_zone +00:00 + + + 2 rows in set, 1 warning (0.00 sec) mysql> select * from l5; + + + + id dt tt + + + + 1 2323 12 31 12:23:32 2020 11 12 03:11:12 + + + + 1 row in set (0.00 sec) ``` + data ``` YYYY MM DD(1000 01 01/9999 12 31 ``` + time ``` 838:59:59/8:59:59 ```"},"/note/使用软件/数据库/2023-1-20-安装.html":{"title":"数据库安装","content":" layout: post title: \"数据库安装\" date: 2023 1 20 15:39:08 +0800 tags: 数据库 # 安装 ## linux ```bash (base) jiao@ubuntu:~$ sudo apt get install mysql server (base) jiao@ubuntu:~$ sudo apt get install mysql client ``` server安装的是服务器, 用于生成不同的保存数据以及提供查询 client操作的工具 ```base (base) jiao@ubuntu:~$ systemctl status mysql.service ``` > 查看服务是否运行 > 设置初始化(密码设置等) ```shell (base) jiao@ubuntu:~$ sudo mysql_secure_installation [sudo] jiao 的密码： Securing the MySQL server deployment. Connecting to MySQL using a blank password. VALIDATE PASSWORD PLUGIN can be used to test passwords and improve security. It checks the strength of password and allows the users to set only those passwords which are secure enough. Would you like to setup VALIDATE PASSWORD plugin? Press yY for Yes, any other key for No: y There are three levels of password validation policy: LOW Length > 8 MEDIUM Length > 8, numeric, mixed case, and special characters STRONG Length > 8, numeric, mixed case, special characters and dictionary file Please enter 0 LOW, 1 MEDIUM and 2 STRONG: 0 Please set the password for root here. New password: Re enter new password: Estimated strength of the password: 50 Do you wish to continue with the password provided?(Press yY for Yes, any other key for No) : y By default, a MySQL installation has an anonymous user, allowing anyone to log into MySQL without having to have a user account created for them. This is intended only for testing, and to make the installation go a bit smoother. You should remove them before moving into a production environment. Remove anonymous users? (Press yY for Yes, any other key for No) : y Success. Normally, root should only be allowed to connect from 'localhost'. This ensures that someone cannot guess at the root password from the network. Disallow root login remotely? (Press yY for Yes, any other key for No) : y Success. By default, MySQL comes with a database named 'test' that anyone can access. This is also intended only for testing, and should be removed before moving into a production environment. Remove test database and access to it? (Press yY for Yes, any other key for No) : n ... skipping. Reloading the privilege tables will ensure that all changes made so far will take effect immediately. Reload privilege tables now? (Press yY for Yes, any other key for No) : y Success. All done! (base) jiao@ubuntu:~$ systemctl status mysql.service ● mysql.service MySQL Community Server Loaded: loaded (/lib/systemd/system/mysql.service; enabled; vendor preset: en Active: active (running) since Fri 2023 01 20 15:18:46 CST; 1h 26min ago Main PID: 1215 (mysqld) Tasks: 29 (limit: 2284) CGroup: /system.slice/mysql.service └─1215 /usr/sbin/mysqld daemonize pid file /run/mysqld/mysqld.pid Jan 20 15:18:13 ubuntu systemd[1]: Starting MySQL Community Server... Jan 20 15:18:46 ubuntu systemd[1]: Started MySQL Community Server. ``` > 实际的使用 ``` (base) jiao@ubuntu:~$ sudo mysql u root p Enter password: Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 6 Server version: 5.7.40 0ubuntu0.18.04.1 (Ubuntu) Copyright (c) 2000, 2022, Oracle and/or its affiliates. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. mysql> show schemas > ; + + Database + + information_schema mysql performance_schema sys + + 4 rows in set (0.30 sec) mysql> exit Bye ``` ## windows [MySQL :: Download MySQL Community Server (Archived Versions)](https://downloads.mysql.com/archives/community/) 创建配置文件my.ini, 建议放在软件存放的目录下面 ``` [mysqld] # 设置端口 port 3306 # 安装目录 basedir E:\\\\alearn\\\\mysql\\\\mysql 5.7.31 winx64 # 创建的数据 datadir E:\\\\alearn\\\\mysql\\\\mysql 5.7.31 winx64\\\\data ``` 命令行查找配置文件, 可以安装多个版本 ``` C:\\Users\\JHY>\"E:\\alearn\\mysql\\mysql 5.7.31 winx64\\bin\\mysqld.exe\" help verbose mysqld: Could not create or access the registry key needed for the MySQL application to log to the Windows EventLog. Run the application with sufficient privileges once to create the key, add the key manually, or turn off logging for that application. mysqld: Can't change dir to 'E:\\alearn\\mysql\\mysql 5.7.31 winx64\\data\\' (Errcode: 2 No such file or ... Default options are read from the following files in the given order: C:\\Windows\\my.ini C:\\Windows\\my.cnf C:\\my.ini C:\\my.cnf E:\\alearn\\mysql\\mysql 5.7.31 winx64\\my.ini E:\\alearn\\mysql\\mysql 5.7.31 winx64\\my.cnf ``` > 查找文件的优先级 + 初始化(管理员权限) ``` C:\\Users\\JHY>\"E:\\alearn\\mysql\\mysql 5.7.31 winx64\\bin\\mysqld.exe\" initialize insecure ``` 初始化账户, 账户没有密码 + 启动 1. ``` C:\\Users\\JHY>\"E:\\alearn\\mysql\\mysql 5.7.31 winx64\\bin\\mysqld.exe\" initialize insecure ``` > 缺点, 需要开启终端, 比较麻烦 2. 制作成一个服务 ``` C:\\Windows\\system32>\"E:\\alearn\\mysql\\mysql 5.7.31 winx64\\bin\\mysqld.exe\" install mysql57 Service successfully installed. C:\\Windows\\system32>net start mysql57 mysql57 服务正在启动 . mysql57 服务已经启动成功。 C:\\Windows\\system32>net stop mysql57 mysql57 服务正在停止. mysql57 服务已成功停止。 C:\\Windows\\system32>\"E:\\alearn\\mysql\\mysql 5.7.31 winx64\\bin\\mysqld.exe\" remove mysql57 删除 ``` + 实际使用 ``` C:\\Windows\\system32>\"E:\\alearn\\mysql\\mysql 5.7.31 winx64\\bin\\mysql.exe\" h 127.0.0.1 P 3306 u root p ``` > h使用的服务器, 本机可以忽略 > > P端口号, 同上 > > u用户 > > p密码 ``` C:\\Windows\\system32>net start mysql57 mysql57 服务正在启动 . mysql57 服务已经启动成功。 C:\\Windows\\system32>\"E:\\alearn\\mysql\\mysql 5.7.31 winx64\\bin\\mysql.exe\" h 127.0.0.1 P 3306 u root p Enter password: Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 2 Server version: 5.7.31 MySQL Community Server (GPL) Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type 'help;' or '\\h' for help. Type '\\c' to clear the current input statement. mysql> show databases; + + Database + + information_schema mysql performance_schema sys + + 4 rows in set (0.00 sec) mysql> exit Bye ``` ## 配置文件 目前大多数使用默认的 ## 密码 ### 修改设置密码 ``` mysql> set password password(\"jhy030116\"); Query OK, 0 rows affected, 1 warning (0.00 sec) ``` ### 忘记密码 在配置文件中添加, 会进行跳过登录环节 ``` [mysqld] skip grant tables 1 ``` 重启服务 ``` net stop mysql57 net start mysql57 ``` 重启之后就不需要密码进入 ```mysql mysql u root p ``` 进入之后 ````mysql use mysql; update user set authentication_string password(\"新密码\"),password_last_change now() where user 'root'; ```` 退出之后把之前的配置文件中的信息删除 之后重启就可以使用新的密码进行登录"},"/note/使用软件/数据库/2023-1-23-使用代码进行控制.html":{"title":"数据库管理","content":" layout: post title: \"数据库管理\" date: 2023 1 23 15:39:08 +0800 tags: 数据库 # 使用代码进行控制 ```python import pymysql # 连接数据库在连接之后直接进入day2 conn pymysql.connect(host '127.0.0.1', user 'root', passwd 'jhy030116', charset 'utf8', db 'day2') ``` 首先在数据库中创建对应的表 ```sql mysql> create database usersdb default charset utf8 collate utf8_general_ci; Query OK, 1 row affected (0.00 sec) mysql> create table users(id int not null primary key auto_increment, > name varchar(32), > password varchar(64) > )default charset utf8; Query OK, 0 rows affected (0.45 sec) mysql> describe users > ; + + + + + + + Field Type Null Key Default Extra + + + + + + + id int(11) NO PRI NULL auto_increment name varchar(32) YES NULL password varchar(64) YES NULL + + + + + + + 3 rows in set (0.00 sec) ``` ```python import pymysql def register(): print(\"用户注册\") user input(\"请输入用户名\") passwd input(\"请输入密码\") conn pymysql.connect(host '127.0.0.1', user 'root', passwd 'jhy030116', charset 'utf8', db 'usersdb') cursor conn.cursor() sql 'insert into users(name, password) values(\"{}\", \"{}\")'.format(user, passwd) cursor.execute(sql) conn.commit() cursor.close() conn.close() def login(): print(\"用户登录\") user input(\"请输入用户名\") passwd input(\"请输入密码\") conn pymysql.connect(host '127.0.0.1', user 'root', passwd 'jhy030116', charset 'utf8', db 'usersdb') cursor conn.cursor() sql 'select * from users where name \"{}\" and password \"{}\"'.format(user, passwd) cursor.execute(sql) result cursor.fetchone()\t\t\t# 检查上一个返回的值 cursor.close() conn.close() if result: print(\"成了\") else: print(\"爬\") def run(): choice input(\"1.登录, 2.注册\") if choice '1': login() else: register() if __name__ '__main__': run() ``` ## SQL注入 在实际使用的时候插入的数据如果是一个SQL语句的一部分, 可能会导致实际输入的数据出错 ```python sql \"select * from users where name '{}' and passwd '{}'\".format(user, pwd) ``` 用户输入`'or 1 1 `和`123` 输入变为 ```sql select * from users where name ''or 1 1 ' and passwd '123' ``` 所以使用的时候不要直接使用字符串拼接, 使用execute进行拼接 ```python self.cursor.execute('insert into chat_history%s (chat_history, chat_user) values (%s, %s)', [self.user_id, chat_history, user]) self.cursor.execute(f'insert into chat_history{self.user_id} (chat_history, chat_user) values (%s, %s)', (chat_history, user)) ```"},"/note/使用软件/数据库/2023-1-21-数据行.html":{"title":"数据库管理","content":" layout: post title: \"数据库管理\" date: 2023 1 21 15:39:08 +0800 tags: 数据库 # 数据行 ## 相关指令 + 插入 ```sql insert into 表名(列名, 列名, 列名) values(对应的值, 对应的值, 对应的值); insert into 表名(列名, 列名, 列名) values(对应的值, 对应的值, 对应的值),(对应的值, 对应的值, 对应的值); insert into 表名 values(对应的值, 对应的值, 对应的值); 只有这几列的时候 ``` > 插入数据的时候,value后面的括号可以使用`,`分割连接多个信息 + 删除 ```sql delete from 表名; \t 删除所有 delete from 表名 where 条件; delete from 表名 where name '名字'; delete from 表名 where name '名字' and password '密码'; delete from 表名 where id>9; ``` + 修改 ```sql update 表名 set 列名 值; update 表名 set 列名 值 where 条件; ``` ```sql update tb1 set age age+1; update tb1 set age age+1 where id 2;\t\t age为整形 update users set name concat(name, \"123\") where id 2;\t\t 使用函数进行字符串的连接 ``` + 查询 ```sql select * from 表名; 获取所有的信息 select 列名, 列名 from 表名; select 列名, 列名 as 别名, 列名 from 表名; select 列名, 列名 from 表名 where 条件; ``` ```sql select * from tb1; select id,name,age from tb1; select id,name as N,age from tb1; select id,name,111 from tb1;\t\t 在后面添加一列111 select id,name,111 as age from tb1; 建立一个表头是age, 值是111的列 select id,name as N,age from tb1 where id 1; select id,name as N,age from tb1 where id! 1; select id,name as N,age from tb1 where id>1; ```"},"/note/使用软件/数据库/2025-2-21-Redis.html":{"title":"Redis","content":"# Redis Mysql的数据查询的速度在应对比较大的数据的时候速度不够, Redis是数据库的包装 使用的数据记录在内存里面, 查询Mysql的时候数据记录在硬盘里面 远程缓存: 避免每一个商品服务都单独建立一个内存的缓存, 把所有的服务请求使用统一的线程进行处理 数据过期时间: 数据一定时间不访问, 从内存里面去除, 需要用户设定 如果用户没有设置, 把最近最少使用的部分去除, Least Recently Used 持久化: 如果这部分重启会导致再次加载的时候用时比较长, 同时访问量激增, 所以定期把内存里面的数据记录为一个快照RDB 简化网络协议: 直接使用TCP Redis支持多种数据结构 + 字符串String + 列表List + 集合Set + 有序集合SortedSet + 哈希Hash + 消息队列Stream + 地理空间Geospatial + HyperLogLog + 位图Bitmap + 位域Bitfield 可以使用以下的方式操控 CLI: 命令行 API: 编程语言控制 GPI: 图形工具 ## 安装 docker安装 ```bash docker pull redis docker run d name myredis p 6370:6379 redis ``` > 该命令用于在 Docker 中以后台模式运行名为 myredis 的 Redis 容器，并将主机的6370端口映射到容器的6379端口上，使用的镜像为 redis。可以加参数` requirepass \"123456\"`设置密码 ## 基础使用 使用`redis cli.exe h 127.0.0.1 p 6379`启动客户端 ### 设置 `SET key value` ![image 20250222133531289](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/picture/202502221335051.png) 默认使用字符串二进制进行存储数据 使用`DEL`删除, `EXISTS`查看一个键是不是存在, 可以使用`KEYS *`查找所有的键, 使用`FLUSHALL`删除所键 中文显示, 默认中文会使用二进制的形式进行存储, 可以在启动的时候加一个参数` raw`, 这个参数会使以输入的形式显示 可以使用`TTL`查看键的过期时间, 默认是 1, 使用`EXPIRE 名字 秒`设置一个过期时间, 可以直接使用`SETEX name second val`设置 `SETNX`不存在的时候设置 ### 列表 使用`RPUSH`和`LPUSH`进行添加, 使用`LRANGE`获取 ![image 20250222134547370](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/picture/202502221345429.png) 使用`RPOP`和`LPOP`删除, 可以加一个`letter num`设置取出来几个(低版本不支持) `LLEN`查看长度 `LTRIM`删除范围以外 ### set [Redis 集合(Set) 菜鸟教程](https://www.runoob.com/redis/redis sets.html) 里面的元素是不可以重复的 `SADD`添加元素 `SMEMBERS`获取元素 `SISMEMBER`查看是不是在集合里面 `SREM`删除元素 `SDIFF key1 [key2]`返回第一个集合与其他集合之间的差异。 `SDIFFSTORE destination key1 [key2]`返回给定所有集合的差集并存储在 destination 中 `SINTER key1 [key2]`返回给定所有集合的交集 `SINTERSTORE destination key1 [key2]` 返回给定所有集合的交集并存储在 destination 中 ### sorted set [Redis 有序集合(sorted set) 菜鸟教程](https://www.runoob.com/redis/redis sorted sets.html) 有序集合, 每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。 `ZADD key score1 number1 [score2 number2]`添加 `ZRANGE key 0 1`查看所有的数据, 可以使用`WITHSCORES`加入分数显示 `ZSCORE key number`查看分数 `ZRANK key number`查看排名, 从小到大 `ZRERANK`从大到小 ### 哈希 Redis hash 是一个 string 类型的 field（字段） 和 value（值） 的映射表 `HSET key field value [field vlue ...]` `HGET key field`或`HGETALL key`获取所有 ![image 20250222141107311](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/picture/202502221411378.png) `HDEL field`删除某一个值 `HEXISTS`查看是不是存在 ### 订阅 [Redis 发布订阅 菜鸟教程](https://www.runoob.com/redis/redis pub sub.html) Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。 `subscribe`订阅, `publish`发布 ![image 20250222141758637](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/picture/202502221417703.png) 消息不可以持久化以及无法记录历史消息 ### stream 解决订阅的问题, 是 Redis 5.0 版本新增加的数据结构。 主要用于消息队列（MQ，Message Queue），Redis 本身是有一个 Redis 发布订阅 (pub/sub) 来实现消息队列的功能，但它有个缺点就是消息无法持久化，如果出现网络断开、Redis 宕机等，消息就会被丢弃。 简单来说发布订阅 (pub/sub) 可以分发消息，但无法记录历史消息。 而 Redis Stream 提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。 Redis Stream 的结构如下所示，它有一个消息链表，将所有加入的消息都串起来，每个消息都有一个唯一的 ID 和对应的内容： ![img](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/picture/202502221427064.png) **Consumer Group** ：消费组，使用 XGROUP CREATE 命令创建，一个消费组有多个消费者(Consumer)。 **last_delivered_id** ：游标，每个消费组会有个游标 last_delivered_id，任意一个消费者读取了消息都会使游标 last_delivered_id 往前移动。 **pending_ids** ：消费者(Consumer)的状态变量，作用是维护消费者的未确认的 id。 pending_ids 记录了当前已经被客户端读取的消息，但是还没有 ack (Acknowledge character：确认字符）。 **命令** **XADD** 添加消息到末尾`XADD key ID field value [field value ...]`, ID可以使用*自动生成 **XTRIM** 对流进行修剪，限制长度, 使用`XTRIM key MAXLEN 0`删除所有 **XDEL** 删除消息 **XLEN** 获取流包含的元素数量，即消息长度 **XRANGE** 获取消息列表，会自动过滤已经删除的消息, `XRANGE key start end`可以使用 +表示开头结尾获取所有 ![image 20250222143421856](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/picture/202502221434930.png) **XREVRANGE** 反向获取消息列表，ID 从大到小 **XREAD** 以阻塞或非阻塞方式获取消息列表, COUNT指定个数, BLOCK是时间, `XREAD COUNT 2 BLOCK 3000 STREAMS key 0`, 从0开始读取, 可以使用$获取最新消息(阻塞以后的消息) ![image 20250222144445126](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/picture/202502221444199.png) **消费者组相关命令：** **XGROUP CREATE** 创建消费者组, `XGROUP CREATE stream group1 0`, 最后一个是id **XREADGROUP GROUP** 读取消费者组中的消息 **XACK** 将消息标记为\"已处理\" **XGROUP SETID** 为消费者组设置新的最后递送消息ID **XGROUP DELCONSUMER** 删除消费者 **XGROUP DESTROY** 删除消费者组 **XPENDING** 显示待处理消息的相关信息 **XCLAIM** 转移消息的归属权 **XINFO** 查看流和消费者组的相关信息； **XINFO GROUPS** 打印消费者组的信息； **XINFO STREAM** 打印流信息"},"/note/使用软件/Stable-diffusion/2023-5-2-ai绘画.html":{"title":"ai绘画","content":" layout: post title: \"ai绘画\" date: 2023 5 1 11:29:08 +0800 categories: ai 绘画 # 安装 1. 安装python > python V 2. ``` nvidia smi #检查显卡,安装CUDA C:\\Users\\JHY>nvidia smi Mon May 01 13:03:37 2023 + + NVIDIA SMI 452.06 Driver Version: 452.06 CUDA Version: 11.0 + + + GPU Name TCC/WDDM Bus Id Disp.A Volatile Uncorr. ECC Fan Temp Perf Pwr:Usage/Cap Memory Usage GPU Util Compute M. + + 0 GeForce GTX 166... WDDM 00000000:01:00.0 On N/A N/A 48C P8 5W / N/A 511MiB / 6144MiB 1% Default + + + + + + Processes: GPU GI CI PID Type Process name GPU Memory ID ID Usage 0 N/A N/A 1412 C+G Insufficient Permissions N/A 0 N/A N/A 2412 C+G Insufficient Permissions N/A 0 N/A N/A 3212 C+G ...lPanel\\SystemSettings.exe N/A 0 N/A N/A 4672 C+G ...e\\PhoneExperienceHost.exe N/A 0 N/A N/A 4776 C+G C:\\Windows\\explorer.exe N/A 0 N/A N/A 7044 C+G ...er_engine\\wallpaper32.exe N/A 0 N/A N/A 8908 C+G ...\\typora\\Typora\\Typora.exe N/A 0 N/A N/A 12164 C+G ...8wekyb3d8bbwe\\Cortana.exe N/A 0 N/A N/A 12424 C+G ...2txyewy\\TextInputHost.exe N/A 0 N/A N/A 12804 C+G ...2gh52qy24etm\\Nahimic3.exe N/A 0 N/A N/A 14040 C+G ...oft\\OneDrive\\OneDrive.exe N/A 0 N/A N/A 14748 C+G ...5n1h2txyewy\\SearchApp.exe N/A 0 N/A N/A 17580 C+G ...cw5n1h2txyewy\\LockApp.exe N/A + + ``` 3. 安装整合包https://www.bilibili.com/video/BV1iM4y1y7oA/?spm_id_from 333.788.video.desc.click&vd_source 3771cc8df803eed7244034a762706c24 4. 安装启动器https://www.bilibili.com/video/BV1ne4y1V7QU/ ## 使用 模型, 使用不同的图片训练出来的模型 > ``` > E:\\alearn\\sb webui aki v4\\sd webui aki\\sd webui aki v4\\models\\Stable diffusion > ``` > > 模型地址 VAE可以理解为滤镜 > ``` > E:\\alearn\\sb webui aki v4\\sd webui aki\\sd webui aki v4\\models\\VAE > ``` > > 改为Checkpoint一样的可以自动加载 ### 提示词 + 内容型提示词 直接描写画面内容 只有这个的话画面会不清晰 + 画质 ``` best quality, ultra detailed, masterpiece, hires, 8K, ``` + 画风 ``` 插画 illustration, painting, paintbrush 二次元 anime, comic, game CG 写实 photorealistic, realistic, photograph ``` + 权重 加括号\\ >1.1, 可以有多个, 大括号\\ >1.05, 中括号 >0.9 或者括号加数字(nude:1.5) ![image 20230609191707438](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242257887.png) 采样的步数, ai加噪去噪的步数, 20次即可 ![image 20230609191736763](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242257888.png) 使用的算法, eular 适合插画风格, dpm 2M 2m karras速度快, sde karras细节比较多 ![image 20230609192009013](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242257889.png) 分辨率, 可以使用低分辨率进行绘制再使用高清修复来进行放大 ![image 20230609192323277](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242257890.png) 面部修复对于插画不适合 ![image 20230609192505766](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242257891.png) 7 12即可 ![image 20230609192541917](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242257892.png) 按照相同的提示词进行绘画 ## 咒语 ``` masterpiece, best quality, extremely detailed CG unity 8k wallpaper, close up, junior,(wide shot),(standing), (colorful),((meticulous painting)),((ink washing)),((ink splashing)),floating, beautiful detailed eyes, solo, (playing instrument :1.2),(light smlie:0.9),hair ribbon, gloom, floating grass leaves, original,(best quality), ((masterpiece)), (highres), extremely detailed wallpaper, (an extremely delicate and beautiful),extremely detailed, adult lady,(medium chest), red eyes, (black cloak),studio photography, cinematic highlight hair, oil painting, realistic, photorealistic,(scenery),outdoors ,garden, ivy,(moss:0.9),(florist:1.2),flower pot, lily \\(flower\\),glass wall, wooden floor,(sunlight),(light rays:1.1),handsome, (nude), 1girl, naked, authentic ``` ``` bad_prompt_version2,EasyNegative, fewer digits, low quality, watermark, bad feet, extra fingers, mutated hands, poorly drawn hands, fused fingers, too many fingers, bad anatomy, cropped, wort quality ,low quality, normal quality, jpeg artifacts, signature, watermark, bad feet, mutilated, too many fingers, malformed limbs, more than 2 knee, mutated hands, pregnant, mutilated, morbid, bad proportions, missing legs, extra limbs, multiple breasts, (mutated hands and fingers:1.5 ), (long body :1.3), (mutation, poorly drawn :1.2) , black white, bad anatomy, liquid tongue, disfigured, error, malformed hands, long neck, blurred, lowers, bad proportions, bad shadow, uncoordinated body, unnatural body, fused breasts, bad breasts, huge breasts, poorly drawn breasts, extra breasts, liquid breasts, heavy breasts, missing breasts, huge haunch, huge thighs, huge calf, bad hands, fused hand, missing hands, ``` ## 测试 ```c (a bird), imagining, dreamlike, fancy, magic, colorful, phoenix, divine, dreamland, eidolon, best quality, ultra detailed, masterpiece, hires, 8K, back, detail, [[origami crane]], 2148198808 ``` ![image 20231217221313524](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202312172213963.png)"},"/note/使用软件/Stable-diffusion/2023-5-2-ai图生图.html":{"title":"图生图","content":" layout: post title: \"图生图\" date: 2023 5 1 11:29:08 +0800 categories: ai 绘画 # 图生图 使用图片作为参考 在上面添加参数获得成果 E:\\alearn\\sb webui aki v4\\sd webui aki\\sd webui aki v4\\models\\Stable diffusion文件夹中 # 模型 .ckpt文件, 大模型, 还有一种是safetensors比较小 VAE:变分自解码器, 可以理解为调色滤镜, 特定模型的vae改为和模型相同的名字直接自动加载 ## 模型下载 + Hugging face: 包含多种ai相关的, 在files and versions中vae或者safety_checker里面找 + c站 + + 筛选的时候:右上角小漏斗Checkpoint是大模型 + 上面的一排标签: 风格方向 > 二次元风格: illstration, painting, sketch, drawing, painting, comic, anime, catoon > > + anything, Counterfeit, Dreamlike Diffusion > 真实风格: photography, photo, realistic, photorealistic, RAM photo > > + Deliberate, realistic Vision, LOFI > 2.5D: 3D， render, chibi, digital art, concept art, {realistic} > > + NeverEnding Dream， Protogen， 国风3 ## 图形更加清晰 ### 文生图 > 高清修复： ![image 20230618182453452](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242257559.png) > > 实际上就是进行图生图, 放大倍数可以提高分辨率, 重绘幅度不大于0.5 > > ![image 20230618183216210](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242257560.png) > > 推荐使用, 二次元用第二个 ### 图生图 在图库浏览器中打开, 按比例放大, 设置幅度, 在设置中可以设置算法, 在最下面有放大脚本SD upscale, 设置为2放大为两倍, 重叠像素就是再放大过程中不同绘画位置之间重叠过度的像素 ### 附加功能的放大 相当于重绘幅度为0的高清修复"},"/note/使用软件/微信小程序/2025-8-9-03-第三方UI库.html":{"title":"第三方UI库","content":"# 第三方UI库 可以使用第三方的UI库快速构建, 比如vant ## vant [Vant 4 轻量、可定制的移动端组件库](https://vant ui.github.io/vant/#/zh CN) 有vue端, react端, 微信小程序的, 使用的时候需要小程序支持npm ### 安装 [快速上手 Vant Weapp](https://vant ui.github.io/vant weapp/#/quickstart) 1. 使用小程序安装支持npm(微信小程序支持的, 不是所有都支持, 微信小程序不可以使用一些windows全局变量以及构造器) 2. 电脑安装node.js(js解释器) 3. 项目根目录`npm init y` >`package.json`文件生成 4. 安装 ```bash # 通过 npm 安装 npm i @vant/weapp S production ``` 5. 将 app.json 中的 `\"style\": \"v2\"` 去除，小程序的[新版基础组件](https://developers.weixin.qq.com/miniprogram/dev/reference/configuration/app.html#style)强行加上了许多样式，难以覆盖，不关闭将造成部分组件样式混乱。 6. 在config.json里面加入 ![image 20250809153911357](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202508091539566.png) ```json \"packNpmManually\": true, \"packNpmRelationList\": [ { \"packageJsonPath\": \"./package.json\", \"miniprogramNpmDistDir\": \"./\" } ] ``` ![image 20250809154018626](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202508091540730.png) ### 使用 1. 引入组件, 在`app.json`或`index.json`中引入组件"},"/note/使用软件/微信小程序/2025-8-12-04-上线.html":{"title":"上线","content":"# 上线 1. 购买服务器 2. 安装环境, python, nginx, 安装mysql 3. 编写uwsgi配置文件 4. 上传代码 5. 配置nginx 后端接口 admin管理(http) 6. 配置admin访问后台 7. 购买证书, https访问 8. 域名备案 ## nginx 进行请求的转发, 转发给django框架, 同时配置https ```bash 23 2025 08 13 21:25:03 wget http://nginx.org/download/nginx 1.24.0.tar.gz 24 2025 08 13 21:25:53 tar xf nginx 1.24.0.tar.gz 27 2025 08 13 21:26:21 cd nginx 1.24.0/ 29 2025 08 13 21:29:48 sudo apt get install libpcre3 libpcre3 dev 31 2025 08 13 21:33:20 sudo apt get install libssl dev 32 2025 08 13 21:33:29 ./configure prefix /usr/local/nginx with http_ssl_module 33 2025 08 13 21:33:56 make && make install 34 2025 08 13 21:35:30 ln s /usr/local/nginx/sbin/nginx /usr/bin/nginx 35 2025 08 13 21:35:37 cd 36 2025 08 13 21:35:40 nginx ``` 这时候已经可以访问80端口了, 可以使用`nginx s stop`停止服务 ### 代理静态资源 在django里面加入一个配置选项, 创建这个文件夹 `STATIC_ROOT BASE_DIR / \"static\"` 使用命令`python manage.py collectstatic` 加入nginx代理 ### 端口转发 `vim /usr/local/nginx/conf/nginx.conf` ```json events { worker_connections 1024; } http { include mime.types; default_type application/octet stream; sendfile on; server { listen 80; server_name 127.0.0.1; charset utf 8; client_max_body_size 10M; location / { include uwsgi_params; uwsgi_pass 127.0.0.1:8000; uwsgi_param UWSGI_SCRIPT ElectronicServer.wsgi; uwsgi_param UWSGI_CHDIR /root/ElectronicServer; } location /static { alias /root/ElectronicServer/static; } } } ``` `nginx s reload` ## python环境 ``` pip freeze > requirements.txt ``` ```bash 9 2025 08 13 21:10:58 wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3 py39_25.5.1 0 Linux x86_64.sh 10 2025 08 13 21:11:17 ls 11 2025 08 13 21:11:28 chmod 777 Miniconda3 py39_25.5.1 0 Linux x86_64.sh 12 2025 08 13 21:11:30 ./Miniconda3 py39_25.5.1 0 Linux x86_64.sh 13 2025 08 13 21:14:19 conda create n ElectronicPetServer python 3.10 15 2025 08 13 21:17:37 conda activate ElectronicPetServer 18 2025 08 13 21:19:28 vim requests.txt 19 2025 08 13 21:19:39 pip install r requests.txt ``` ## mysql ### 下载 ```bash 39 2025 08 13 21:40:45 sudo apt install y mysql server 40 2025 08 13 21:41:20 sudo systemctl start mysql 41 2025 08 13 21:41:32 sudo systemctl enable mysql 42 2025 08 13 21:41:41 sudo systemctl status mysql 43 2025 08 13 21:42:00 sudo mysql uroot p ``` ### 远程连接 [远程连接hy CSDN博客](https://blog.csdn.net/qq_34988204/article/details/134830202) 编辑 MySQL 配置文件：打开 MySQL 的配置文件（通常位于 /etc/mysql/mysql.conf.d/mysqld.cnf），找到 bind address 参数，并将其值设置为 MySQL 服务器的 IP 地址或 0.0.0.0（允许所有 IP 访问）。 `bind address 0.0.0.0` 重启 MySQL 服务器：保存并关闭配置文件后，重新启动 MySQL 服务器。 `sudo service mysql restart` 检查主机访问权限：登录到 MySQL 服务器，执行以下命令查看主机访问权限。 `USE mysql;` `SELECT user, host FROM user;` 使用以下命令为你的主机添加访问权限。 `UPDATE user SET host '%' WHERE user 'root';` 刷新权限：执行以下命令刷新 MySQL 的权限表。 `FLUSH PRIVILEGES;` 重新尝试连接：现在应该可以使用你的 MySQL 客户端连接到 MySQL 服务器了。 ![image 20250813220205359](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202508132202572.png) ### 创建数据库 ``` create database school charset utf8mb4; ``` ```bash python manage.py makemigrations python manage.py migrate ``` ## uwsgi ``` <uwsgi> <socket>127.0.0.1:8000</socket> <chdir>/root/ElectronicServer</chdir> <module>ElectronicServer.wsgi</module> <processes>4</processes> <daemonize>ElectronicServer.log</daemonize> </uwsgi> ``` ![image 20250813221631246](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202508132216548.png) django配置 ```python DEBUG False ALLOWED_HOSTS ['*'] BACKEND_URL 'https://www.xvsenfeng.top' ``` ### 安装 ``` pip install uwsgi ln s /root/miniconda3/envs/ElectronicPetServer/bin/uwsgi /usr/bin/uwsgi uwsgi x smart.xml ``` uwsgi不可以代理静态资源, 需要使用nginx代理 文件传输 ``` scp .\\ElectronicServer.zip 用户名@你的ip:路径 ``` ## SSL证书 需要购买, 可以在https://app.zerossl.com/获取免费 申请以后创建证书 ![image 20250815094613102](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202508150946343.png) ``` events { worker_connections 1024; } http { include mime.types; default_type application/octet stream; sendfile on; client_max_body_size 20M; server { listen 443 ssl; ssl_certificate /usr/local/nginx/cert/xvsenfeng.top.pem; ssl_certificate_key /usr/local/nginx/cert/xvsenfeng.top.key; server_name xvsenfeng.top; location / { include uwsgi_params; uwsgi_pass 127.0.0.1:8000; uwsgi_param UWSGI_SCRIPT ElectronicServer.wsgi; uwsgi_param UWSGI_CHDIR /home/ElectronicServer; } location /static { alias /home/ElectronicServer/static/; } } } ``` ## 代码上传 ![image 20250815105409094](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202508151054212.png)"},"/note/使用软件/微信小程序/2025-7-22-01-入门.html":{"title":"微信小程序","content":"# 微信小程序 ## 注册账号 https://mp.weixin.qq.com/ ![image 20250722181030441](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507221810578.png) ## 成员 人员有两种 + 项目成员 + + 开发者 + 运营 + 数据分析 + 体验人员 ## 开发 获取小程序的id ![image 20250722185145914](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507221851035.png) 之后下载开发工具, 必须联网使用 ### 本地开发支持http 使用Django运行在0.0.0.0:8000, 默认不支持http, 需要修改 ## 目录文件 主要的控制文件, 在根目录下面, 控制整个程序 + app.js 小程序入口, 运行的时候先执行这个文件 + app.json 全局配置, 顶部的颜色, 标题, 是不是有下拉刷新 [微信开放文档 / 框架](https://developers.weixin.qq.com/miniprogram/dev/reference/) ![image 20250722192928727](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507221929915.png) ![image 20250722193249729](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507221932771.png) entryPagePath: 默认启动界面 pages: 小程序总共有多少界面 window: 全局的默认表现, 顶部颜色, 是否下拉 style: 微信升级以后ui样式 + app.wxss 全局的样式, 全局生效 + project : 项目文件, 项目配置 ![image 20250722194515844](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507221945942.png) ![image 20250722194551701](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507221945757.png) 记录项目的配置以及开发者的个人信息 + sitemap.json 搜索优化 seo相关的配置, 可以配置是否可以被索引, 允许的时候, 使用爬虫形式在小程序界面建立索引, 搜索触发的展示 ```json { \"desc\": \"关于本文件的更多信息，请参考文档 https://developers.weixin.qq.com/miniprogram/dev/framework/sitemap.html\", \"rules\": [{ \"action\": \"allow\", // 可以查到所有页面, 任意页面关键字 > 可以被搜索 \"page\": \"*\" }] } ``` + .eslintrc.js 语法检查 页面文件 在pages文件夹下面, 下面有很多的文件夹, 里面有多个文件 + xx.js # 页面逻辑, js代码控制 + xx.wxml # 页面结构, 布局 + xx.json # 页面配置, 只影响当前的页面, 覆盖app.json中的相同的属性 属性 类型 默认值 描述 最低版本 : : : : : navigationBarBackgroundColor HexColor #000000 导航栏背景颜色，如 `#000000` navigationBarTextStyle string white 导航栏标题、状态栏颜色，仅支持 `black` / `white` navigationBarTitleText string 导航栏标题文字内容 + xx.wxss # 页面样式 > components: 使用的组件, 按钮等, 一个组件一个文件夹, 实际的和pages里面一样 ## webview和skyline渲染 webview: 老一点, 稳定, 支持新老版本 skyline: 新版本, 不支持老版本 ![image 20250722195349761](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507221953806.png) 删除这个使用老版本 ## 增加页面 ### 方式一 1. 自己在pages里面建立文件夹 2. 右键新建Page, 自动创建四个文件 3. app.json的pages里面多出来一行 ### 方式二 在app.json里面直接新加一句, 自动创建 ## 启动顺序 1. 在app.json里面修改pages的顺序 2. 在默认参数entryPagePath设置默认的启动页面 3. 临时使用 ![image 20250723094832217](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507230948262.png) ![image 20250723094934320](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507230949365.png) ## 调试小程序 ### 基础库 一直在进行升级, 比如转发功能, 发送朋友圈等, 基于老的版本开发的时候有的功能没有, 写了没效果, 需要确认版本 ![image 20250723095241071](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507230952110.png) ![image 20250723095629695](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507230956761.png) ### 真机调试 ![image 20250723095706753](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507230957790.png) 手机连接以后可以显示上面的控制终端 ```c { \"pages\": [ \"pages/index/index\" ], \"window\": { \"navigationBarTextStyle\": \"black\", // 导航栏文字颜色 \"navigationBarTitleText\": \"XvSenfengAI桌宠\", // 导航栏标题 \"navigationBarBackgroundColor\": \"#ffffff\", // 导航栏背景颜色 \"enablePullDownRefresh\": false, // 是否开启下拉刷新 \"backgroundColor\": \"#ff0fff\", // 背景颜色 \"backgroundTextStyle\": \"light\" // 刷新的时候几个点的颜色 }, \"style\": \"v2\", } ``` ### 最简项目 ![image 20250723101424914](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507231014959.png) 最简单的项目 ![image 20250723101633855](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507231016965.png) ## 组件 [微信开放文档 / 组件](https://developers.weixin.qq.com/miniprogram/dev/component/) ### tabbar 顶部或者底部的页面导航 #### 设置 在app.json里面配置 ### text 不换行,放文字 ![image 20250723104050979](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507231040056.png) ### view 是一个换行, 可以放文字和其他东西, 类似于`<div>` ### image 图片。支持 JPG、PNG、SVG、WEBP、GIF 等格式 `<image src \"/images/order.png\" style \"height: 750rpx; width: 400rpx;\"></image>` ![image 20250723105034188](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507231050320.png) mode: 图片裁剪、缩放的模式 合法值 说明 最低版本 : : : scaleToFill 缩放模式，不保持纵横比缩放图片，使图片的宽高完全拉伸至填满 image 元素 aspectFit 缩放模式，保持纵横比缩放图片，使图片的长边能完全显示出来。也就是说，可以完整地将图片显示出来。 aspectFill 缩放模式，保持纵横比缩放图片，只保证图片的短边能完全显示出来。也就是说，图片通常只在水平或垂直方向是完整的，另一个方向将会发生截取。 widthFix 缩放模式，宽度不变，高度自动变化，保持原图宽高比不变 heightFix 缩放模式，高度不变，宽度自动变化，保持原图宽高比不变 [2.10.3](https://developers.weixin.qq.com/miniprogram/analysis/experience/compatibility.html) top 裁剪模式，不缩放图片，只显示图片的顶部区域。仅 Webview 支持。 bottom 裁剪模式，不缩放图片，只显示图片的底部区域。仅 Webview 支持。 center 裁剪模式，不缩放图片，只显示图片的中间区域。仅 Webview 支持。 left 裁剪模式，不缩放图片，只显示图片的左边区域。仅 Webview 支持。 right 裁剪模式，不缩放图片，只显示图片的右边区域。仅 Webview 支持。 top left 裁剪模式，不缩放图片，只显示图片的左上边区域。仅 Webview 支持。 top right 裁剪模式，不缩放图片，只显示图片的右上边区域。仅 Webview 支持。 bottom left 裁剪模式，不缩放图片，只显示图片的左下边区域。仅 Webview 支持。 bottom right 裁剪模式，不缩放图片，只显示图片的右下边区域。仅 Webview 支持。 ### icon ```c <icon type \"success\" size \"93\"></icon> ``` 属性 类型 默认值 必填 说明 最低版本 : : : : : : type string 是 icon的类型，有效值：success, success_no_circle, info, warn, waiting, cancel, download, search, clear [1.0.0](https://developers.weixin.qq.com/miniprogram/analysis/experience/compatibility.html) size number/string 23 否 icon的大小，单位默认为px，[2.4.0](https://developers.weixin.qq.com/miniprogram/analysis/experience/compatibility.html)起支持传入单位(rpx/px)，[2.21.3](https://developers.weixin.qq.com/miniprogram/analysis/experience/compatibility.html)起支持传入其余单位(rem 等)。 [1.0.0](https://developers.weixin.qq.com/miniprogram/analysis/experience/compatibility.html) color string 否 icon的颜色，同css的color [1.0.0](https://developers.weixin.qq.com/miniprogram/analysis/experience/compatibility.html) ### button + size: 合法值 说明 : : default 默认大小 mini 小尺寸 + type: 合法值 说明 : : primary 绿色 default 白色 warn 红色 plain boolean false 否 按钮是否镂空，背景色透明 [1.0.0](https://developers.weixin.qq.com/miniprogram/analysis/experience/compatibility.html) disabled boolean false 否 是否禁用 [1.0.0](https://developers.weixin.qq.com/miniprogram/analysis/experience/compatibility.html) loading boolean false 否 名称前是否带 loading 图标 [1.0.0](https://developers.weixin.qq.com/miniprogram/analysis/experience/compatibility.html) > bool类型的写上就是true, 不写是false ### swiper+swiper item轮播图 ```html <swiper> <swiper item> 1 </swiper item> <swiper item> 2 </swiper item> <swiper item> 3 </swiper item> </swiper> ``` autoplay: 自动播放 indicator dots: 指示点面板是不是有 indicator color, indicator active color: 指示点的颜色 interval: 自动切换时间间隔 duration: 滑动动画时长 circular: 衔接滑动 ### input输入框 ```html <! 输入框, 可以直接绑定到data中的变量 > <input type \"text\" model:value \"{{goodsName}}\" style \"border: 1px solid #ccc;\"/> ``` ## 图标获取 [iconfont 阿里巴巴矢量图标库](https://www.iconfont.cn/?spm a313x.collections_index.i3.d4d0a486a.41cc3a81SqMfep) ![image 20250723141924891](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507231419946.png) ![image 20250723142009752](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507231420810.png) ![image 20250723142214120](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507231422185.png) ![image 20250723142244683](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507231422740.png) > 编码以后不需要下载 ![image 20250723142320016](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507231423063.png) ![image 20250723142845192](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507231428258.png) > 只可以使用wxss结尾的文件 + 实际引入 ![image 20250723143025498](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507231430544.png) ![image 20250723143228056](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507231432151.png) 在标签里面加入这两个类`<text class \"icon jihuo iconfont\">欢迎来到订单页面！</text>` ## 尺寸单位和样式 ### 尺寸 `style \"height: 300rpx;\"` `<view style \"height: 300rpx;background color: aqua;\"></view>` 小程序里面不同的手机的大小是不同的, 所以使用像素的大小的时候会出现问题, 统一使用rpx, 宽度是750rpx, 之后进行等比例缩放 ### 样式 #### 全局样式 在app.wxss里面进行配置, 在这里面写css样式, 整个小程序到生效 #### 局部样式 在 页面.wxss > 一般style不直接在标签里面, 可以使用class创建一个类选择器 ```html <view class \"myview\"><text>测试</text></view> ``` 之后可以在.wxss文件里面进行选择 ```css .myview { height: 500rpx; width: 300rpx; background color: brown !important; } ``` > 如果和默认的样式冲突的话, 可以在后面加一个`!important` #### 奇数偶数 ```js view:nth child(odd){ // 奇数 } view:nth child(odd){ // 奇数 } ``` ## flex布局 是一种布局的方式, , 相比于传统的display属性+position属性+float属性, 对于特殊的对齐比较麻烦任意一个容器都可以指定这个布局 + 简单易懂 + 弹性自适应, 使用不同尺寸的屏幕 + 等高布局 + 对齐排序 + 可以和传统的相互结合 > 使用`display: flex`启用这个布局 ![image 20250724101555096](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507241015179.png) ### 基础概念 容器: container 项目: item 默认存在两根轴, 水平的主轴(main axis), 竖直的(cross axis) , 实际使用的时候可以交换主轴的方向 + 主轴开始的位置 main start, 结束在 main end, 交叉轴开始的位置cross start 结束的位置 cross end + 默认按照主轴进行排列, 单个元素占据的大小是main size, 占据交叉轴的大小是cross size ### 容器的样式属性 1. `flex direction`: 主轴的方向 row: 默认的, 起点 在左端, row reverse: 起点在右端, clumn: 主轴垂直, 起点在上边, clumn: 起点在下边 2. `flex wrap`: 一条轴放不下如何换行, nowrap: 不换行(默认), wrap:换行在第一行在上边, wrap reverse: 换行在下边 3. `flex flow`: 上面两个属性的集合, `flex flow: flex direction flex wrap` 4. `justify content`: 主轴如何对齐, flex start: 左对齐, flex end: 右对齐, center: 居中, space between: 两端对齐, 间距相等, space around: 两侧间距相等, 项目之间间距比边框大一倍, space evenly: 项目之间和项目于边框相等 5. `align items`: 交叉轴的对齐方式, flex start: 交叉轴起点, flex end: 交叉轴终点, center: 居中, baseline: 第一行文字基准线(高度不同的时候里面的文字显示位置是对齐的), stretch(默认): 未设置高度或者auto的时候占满 6. `align content`: 多跟轴线的对齐方式, 只有一根的时候不起作用(换行的时候会有), flex start: 交叉轴起始点对齐, flex end, center, space between: 交叉轴两端对齐, 轴线之间的间距平均分布, space around: 轴线左右两侧的间距相等, 之间间隔比和边框的大一倍, stretch(默认): 轴线占满整个交叉轴 ### 项目属性 1. `flex grow`（放大比例） 控制项目的放大比例，定义在分配剩余空间时，项目如何增长。默认值为0，表示不放大。值越大，项目越可能占用更多剩余空间。**弹簧控制大小** 2. `flex shrink`（缩小比例） 控制项目的缩小比例，定义在空间不足时，项目如何缩小。默认值为1，表示会缩小。值越大，项目越容易缩小。都为1的时候空间不足等比例缩小, 设置为0的时候这个不缩小, 其他的缩小 3. `flex basis`（主轴尺寸基础值） 设置在分配多余空间之前，项目的默认主轴尺寸。可以使用长度值（如px, %)或auto（默认值）。它影响项目的初始大小。这个写定以后其他的再去分配 4. `flex`（简写属性，结合了flex grow, flex shrink, and flex basis） 用于同时设置上面三个属性，语法为：`flex: flex grow flex shrink flex basis;`。通常用简便的写法指定弹性行为。默认是`0 1 auto`, 一般使用`flex:1`进行平均铺满 5. `align self`（单个项目的对齐方式） 控制单个项目在交叉轴（垂直轴）上的对齐方式，覆盖容器的`align items`设置。可以取值如`auto`, `flex start`, `flex end`, `center`, `baseline`, `stretch`。 6. `order`（排序） 控制Flex项目的排列顺序，默认值为0。值越小，越靠前显示；负值或正值都可以，用于调整布局顺序。 ``` .box div:nth child(6){ \torder: 7; } ``` ```css .notice>view{ display: flex; flex direction: column; } ``` ## 触发事件 ```c <image src \"/images/bottom/cute_1.png\" bind:tap \"handleConsole\"/> ``` ```js Page({ handleConsole(){ console.log(\"handleConsole\"); } }) ``` ### 事件冒泡 组件嵌套的时候, 子组件有事件, 父组件也有事件, 触发子组件事件的时候, 父组件的也会触发 + 阻止事件冒泡 绑定事件的时候不再使用bind, 使用catch ### 参数 触发事件的时候会有一个参数event对象, 这个参数是默认的 ![image 20250723213324581](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507232133874.png) 如果想要自定义参数, 参数的名字以`data `进行开头 ` <image src \"/images/bottom/cute_2.png\" bind:tap \"handleConsole\" data index \"2\" data name \"cute_2\"/>` ![image 20250723213815732](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507232138951.png) 可以使用`event.target.dataset`获取实际的数据 还可以使用`make:name 'xxx'`进行传参, 实际获取的使用`event.mark.name` ## 页面跳转 ### 组件跳转(声明式导航) 使用navigator(导航器) ```html <navigator url \"/pages/pet/state/state\"> <view class \"item\"> <image src \"/images/menu/keji.png\" class \"image\" /> <text>状态</text> </view> </navigator> ``` 也可以配合`open type`属性, 实现不同的跳转方式 合法值 说明 : : navigate 对应 [wx.navigateTo](https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateTo.html) 或 [wx.navigateToMiniProgram](https://developers.weixin.qq.com/miniprogram/dev/api/navigate/wx.navigateToMiniProgram.html) 的功能, 保留当前页面(可以返回), 跳转应用内某个页面, 不能是tabbar页面 redirect 对应 [wx.redirectTo](https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.redirectTo.html) 的功能, 关闭当前页面(不可以返回), 跳转应用内某个页面, 不能是tabbar页面 switchTab 对应 [wx.switchTab](https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.switchTab.html) 的功能, 只可以跳tabbar, 关闭所有的非tabbar页面 reLaunch 对应 [wx.reLaunch](https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.reLaunch.html) 的功能, 关闭所有页面, 打开到应用里面的某个页面 navigateBack 对应 [wx.navigateBack](https://developers.weixin.qq.com/miniprogram/dev/api/route/wx.navigateBack.html) 或 [wx.navigateBackMiniProgram](https://developers.weixin.qq.com/miniprogram/dev/api/navigate/wx.navigateBackMiniProgram.html) （基础库 2.24.4 版本支持）的功能, 关闭当前, 返回上一页面或者多级页面, 可以使用`dalta \"2\"`回退两层 exit 退出小程序，`target \"miniProgram\"`时生效 携带参数, 可以在url后面使用`?`添加参数 `<navigator url \"/pages/pet/state/state?name jiao&age 22\">` 获取的结果在js的`onLoad(options)`里面 ### js跳转(编程式导航) 和上面的几种是对应的 ```js wx.navigateTo({ url: 'url' }) wx.redirectTo({ url: 'url' }) wx.switchTab({ url: 'url' }) wx.reLaunch({ url: 'url' }) wx.navigateBack() ``` ```c <button type \"default\" bind:tap \"handlenavigateTo\">navigateTo</button> handlenavigateTo(){ \twx.navigateTo({ url: '/pages/order/order', }) } ``` ## 插值语法(模板语法) 显示的时候使用变量动态替换, 在js里面需要保留js字段 ```js data: { pet: { name: \"小明\", age: 18, } } ``` ```c <view> <text>名字: {{pet.name}}</text> <text>年龄: {{pet.age}}</text> </view> ``` 可以使用键值对, 对象以及数组的形式 可以显示的数据如下 + 变量 + 算数运算 + 三元运算 + 逻辑判断 > 不可以使用js语句以及方法 在js里面调用一个变量的时候使用this, 默认的数据不是响应式的, 变量变化的时候页面不变化, 更新需要使用`SetData`方法 ```js data: { pet: { name: \"小明\", age: 18, } }, // 不更新显示 handleAgeAdd(){ this.age + 1; } // 更新显示 handleAgeAdd(){ // this.age + 1; this.setData({ \"pet.age\": this.data.pet.age + 1 }) }, ``` > 直接改一个不是根目录下边的变量的时候可以不加引号 ```c handleAgeAdd(){ // ... 是ES6的语法，用于对象的浅拷贝, 会拷贝对象的所有属性，包括对象的子对象 const pet2 {...this.data.pet, hobby: \"打篮球\"} this.setData({ pet: pet2 }) console.log(this.data.pet); }, ``` > const, var, let的区别, 老版本的定义使用var, 新版本定义变量使用let, 定义常量使用const + 改变数组 ```c <view wx:for \"{{names}}\"> <text>{{item}}</text> </view> ``` ```js handleAgeAdd(){ this.data.names.push(\"小明\"); this.setData({ names: this.data.names }) }, handleAgeAdd(){ const new_names this.data.names.concat('test') this.setData({ names: new_names }) }, // 改一个 handleAgeAdd(){ this.setData({ \"names[0]\": \"新名字\" }) }, handleAgeAdd(){ this.setData({ names: this.data.names.slice(1) // 删除第一个 }) }, ``` ## for循环 ```js data: { goodsList: [ { id: 1, name: \"苹果\", price: 10, }, { id: 2, name: \"香蕉\", price: 20, }, { id: 3, name: \"橘子\", price: 30, }, ] }, ``` ```html <view> <! 遍历goodsList 使用wx:key \"id\" 表示使用id作为key, 要求id是唯一的 > <view wx:for \"{{goodsList}}\" wx:key \"id\"> <text>{{item.name}}</text> <text>{{item.price}}</text> </view> </view> ``` > 只要在循环里面, 就会有两个值index索引, 以及item元素项, 可以使用`index`作为`wx:key`获取使用`*this`代表item > > 可以使用`wx:for item \"info\"`, `wx:for index \"i\"`来改名字 ![image 20250724141009343](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202507241410426.png) 使用这个循环获取到的是view嵌套text, 可以直接使用block标签 ## 条件if ```c <! 输入框, 可以直接绑定到data中的变量 > <input type \"text\" model:value \"{{money}}\" style \"border: 1px solid #ccc;\"/> <view wx:if \"{{money> 8 && money< 10}}\"> <text>可以购买</text> </view> <view wx:elif \"{{money>10}}\"> <text>可以购买2</text> </view> <view wx:else> <text>不可以购买</text> </view> ``` > `wx:if` 和`hidden` > > 在标签里面直接使用`ws:if`可以控制这个标签的删除以及创建, 使用hidden的时候不会删除元素"},"/note/使用软件/微信小程序/2025-7-24-02-升级.html":{"title":"进阶","content":"# 进阶 ## 发送网络数据 发送网络数据的时候必须有域名, 在微信公众平台设置 ```html <view> 网络请求 </view> <view>ID: {{user.id}}</view> <view>姓名: {{user.name}}</view> <view>年龄: {{user.age}}</view> <view>性别: {{user.sex}}</view> <view>手机号: {{user.mobile}}</view> <view>班级: {{user.classmate}}</view> <button type \"primary\" bind:tap \"handleLoadUser\">获取用户信息</button> ``` ```js data: { user: { }, }, handleLoadUser(){ wx.request({ url: \"http://127.0.0.1:8000/test1/stu/\", method: \"GET\", data: {}, // 请求参数, 实际是放在url的?后面 header: {}, // 请求头 success: (res) > { this.setData({ user: res.data }); // 请求成功 }, fail: (err) > { console.log(err); // 请求失败 }, complete: () > { console.log(\"complete\"); // 请求完成 }, }); }, ``` + 显示加载中 ![image 20250803184445507](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202508031844744.png) ```js wx.showLoading({ title: \"加载中...\", mask: true, // 是否显示透明蒙层，防止触摸穿透(用于防止用户点击穿透) }); 处理... wx.hideLoading(); ``` ## 对话框 ### 模态对话框 ![image 20250803203037087](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202508032030216.png) ```js wx.showModal({ title: \"提示\", content: \"这是一个测试弹窗\", complete: (res) > { console.log(\"complete\"); // 弹窗关闭 console.log(res); if (res.confirm) { console.log(\"用户点击了确定\"); } else if (res.cancel) { console.log(\"用户点击了取消\"); } }, success: (res) > { console.log(res); // 弹窗成功 }, fail: (err) > { console.log(err); // 弹窗失败 }, }); }, ``` ```html <button type \"primary\" bind:tap \"handleShowModel\">测试弹窗</button> ``` ### 消息框 ![image 20250803203553045](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202508032035184.png) ```html <button type \"primary\" bind:tap \"handleShowToast\">测试Toast</button> ``` ```js wx.showToast({ title: \"这是一个测试Toast\", icon: \"success\", // 图标, 可以设置为success, loading, none duration: 2000, // 存活时间 mask: true, // 是否显示透明蒙层，防止触摸穿透(用于防止用户点击穿透) success: (res) > { console.log(res); }, fail: (err) > { console.log(err); }, complete: (res) > { console.log(res); }, }); ``` ## 存储 应用: 登陆以后, 后端返回一个用户登录的token, 把token记录到小程序端, 后续请求携带 微信小程序记录的数据可以直接是一个对象, 自动转换为json进行记录, 分为同步和异步存储 ### 同步保存 ![image 20250803204621104](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202508032046213.png) ```js // 同步保存 handleSave(){ wx.setStorageSync(\"name\", \"张三\"); wx.setStorageSync(\"age\", 18); wx.setStorageSync(\"sex\", \"男\"); wx.setStorageSync(\"communication\", { \"mobile\": \"13800138000\", \"email\": \"zhangsan@163.com\", \"address\": \"北京市海淀区\", }); }, handleLoad(){ const name wx.getStorageSync(\"name\"); const age wx.getStorageSync(\"age\"); const sex wx.getStorageSync(\"sex\"); const communication wx.getStorageSync(\"communication\"); console.log(name, age, sex, communication); }, handleDelete(){ wx.removeStorageSync(\"name\"); wx.removeStorageSync(\"age\"); wx.removeStorageSync(\"sex\"); wx.removeStorageSync(\"communication\"); }, handleClear(){ wx.clearStorageSync(); }, ``` ### 异步操作 ```js async handleSave(){ await wx.setStorage({ key: \"name\", data: \"张三\", }); }, async handleLoad(){ await wx.getStorage({ key: \"name\", success: (res) > { console.log(res.data); }, }); }, async handleDelete(){ await wx.removeStorage({ key: \"name\", success: (res) > { console.log(res.data); }, }); }, async handleClear(){ await wx.clearStorage({ success: (res) > { console.log(res.data); }, }); }, ``` ## 上拉下拉 ### 上拉加载更多 ![image 20250804161905778](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202508041619907.png) ```js /** * 页面上拉触底事件的处理函数 */ onReachBottom() { console.log(\"onReachBottom\"); wx.request({ url: 'https://www.baidu.com', method: 'GET', success: (res) > { console.log(res); this.setData({ good_list: this.data.good_list.concat(this.data.good_list) }) }, fail: (res) > { console.log(res); } }) }, ``` ### 下拉加载更多 ![image 20250804175341414](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202508041753521.png) ```js onPullDownRefresh() { this.setData({ good_list: [] }) this.onShow(); // 刷新页面 wx.stopPullDownRefresh() // 结束刷新 }, ``` ### scroll view实现上下拉 ```html <view class \"notice\"> <image src \"/images/home/board.png\" class \"aspectFit\" style \"width: 200rpx; height: 200rpx;\" /> <scroll view scroll y class \"notice scroll\"> <view class \"notice item\"> <text>通知公告</text> <view wx:for \"{{noticeList}}\" wx:for item \"item\" wx:key \"index\"> <view> <view wx:if \"{{item.isExternal}}\" bind:tap \"openExternalLink\" data url \"{{item.link}}\" class \"notice link\"> <text>{{item.title}}</text> </view> <navigator wx:elif \"{{item.link}}\" url \"{{item.link}}\" open type \"navigate\" class \"notice link\"> <text>{{item.title}}</text> </navigator> <text wx:else>{{item.title}}</text> </view> </view> </view> </scroll view> </view> ``` > 使用`scroll view `标签, 可以使用的参数有 > > 1. `scroll y`:垂直滑动 > 2. `lower threshold`: 距离底部多少触发事件 > 3. `bindscrolltolower`: 绑定触发的事件 > 4. `refresher enable`: 是不是可以下拉刷新 > 5. `refresher default style`: 下拉的颜色 > 6. `refresher background`: 背景色 > 7. `bindrefresherrefresh`: 刷新处理函数 > 8. `enable back to top`: 快速返回 > 9. `refresher triggered {{arg}}`: 记录下拉是不是成功的标志位, 下拉的时候自动设置为true, 改为false结束刷新 ## 生命周期 分为一个页面的周期和一个小程序的周期 + 小程序周期 ```js /** * 当小程序初始化完成时，会触发 onLaunch（全局只触发一次） */ onLaunch() { }, /** * 当小程序启动，或从后台进入前台显示，会触发 onShow */ onShow: function (options) { }, /** * 当小程序从前台进入后台，会触发 onHide */ onHide: function () { }, /** * 当小程序发生脚本错误，或者 api 调用失败时，会触发 onError 并带上错误信息 */ onError: function (msg) { } ``` + 页面周期 ```js // pages/pet/state/state.js Page({ /** * 页面的初始数据 */ data: { }, /** * 生命周期函数 监听页面加载 */ onLoad(options) { }, /** * 生命周期函数 监听页面初次渲染完成 */ onReady() { }, /** * 生命周期函数 监听页面显示 */ onShow() { }, /** * 生命周期函数 监听页面隐藏 */ onHide() { }, /** * 生命周期函数 监听页面卸载 */ onUnload() { }, /** * 页面相关事件处理函数 监听用户下拉动作 */ onPullDownRefresh() { }, /** * 页面上拉触底事件的处理函数 */ onReachBottom() { }, /** * 用户点击右上角分享 */ onShareAppMessage() { } }) ``` ### 强制更新 在微信里面使用过小程序以后, 微信会把小程序拉到本地, 下次打开的时候优先使用本地的代码 为了同步代码的更新, 在app.js文件里面的onLaunch里面加入下面的代码 ```js onLaunch() { // 强制更新逻辑 const updateManager wx.getUpdateManager(); updateManager.onCheckForUpdate(function (res) { // 请求完新版本信息的回调 if (res.hasUpdate) { updateManager.onUpdateReady(function () { wx.showModal({ title: '更新提示', content: '新版本已经准备好，是否重启应用？', showCancel: false, success: function (res) { if (res.confirm) { updateManager.applyUpdate(); } } }); }); updateManager.onUpdateFailed(function () { wx.showModal({ title: '更新失败', content: '新版本下载失败，请删除当前小程序，重新搜索打开。', showCancel: false }); }); } }); } ``` ![image 20250805143620258](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202508051436377.png) ![image 20250805143751855](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202508051437946.png) ### 分享 需要在界面js里面加一个`onShareTimeline` ```js // 分享到好友 onShareAppMessage() { return { title: '分享标题', query: 'name XvSenfeng', // 访问的时候携带的参数 imageUrl: '/images/order2.png', // 分享携带的图片 path: '/pages/mainpage/mainpage', // 实际访问的路径 success: function (res) { console.log('分享成功', res) }, fail: function (res) { console.log('分享失败', res) } } }, // 分享到朋友圈 onShareTimeline() { return { title: '分享标题', query: 'name XvSenfeng', // 访问的时候携带的参数 imageUrl: '/images/order2.png' } } ``` 还可以使用 ```html <button open type \"share\"></button> ``` ## 获取用户数据 ### 头像 ```html <! pages/device/device.wxml 文件是用于小程序设备页面的视图层文件。 参数解释： class \"btn\"：为按钮设置自定义样式，样式定义在 device.wxss 文件中。 open type \"chooseAvatar\"：指定按钮的功能为选择头像，用户点击后可以选择或拍摄头像图片。 bind:chooseavatar \"chooseAvatar\"：当用户选择头像后，触发 chooseAvatar 方法（在 device.js 文件中定义），用于处理头像选择后的逻辑。 <image src \"{{photo}}\" class \"photo\"></image>：显示当前头像图片，photo 是页面 data 中的变量，class \"photo\" 用于设置图片样式。 > <button class \"btn\" open type \"chooseAvatar\" bind:chooseavatar \"chooseAvatar\"> <image src \"{{photo}}\" class \"photo\"></image> </button>\" ``` ```css /* pages/device/device.wxss */ .btn { background color: transparent; /* 透明背景 */ border: none; /* 无边框 */ padding: 0; /* 无内边距 */ margin: 0; /* 无外边距 */ width: 100%; /* 宽度100% */ height: 100%; /* 高度100% */ display: flex; /* 弹性布局 */ } .photo { width: 250rpx; height: 250rpx; border radius: 50%; } ``` ```js data: { photo: '/images/bottom/cute_1.png' }, chooseAvatar(e) { // console.log(e) } ``` > 实际获取到的数据如下 ![image 20250805152710702](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202508051527833.png) ### 昵称 ```html <! 参数解释： type \"nickname\"：输入框类型为昵称，适用于昵称输入。 placeholder \"请输入昵称\"：输入框占位符，提示用户输入昵称。 module:value \"{{nickname}}\"：将输入框的值与 data 中的 nickname 变量进行双向绑定。 bind:tap \"showName\"：点击按钮时触发 showName 方法。 type \"primary\" primary：设置按钮为主要按钮，显示为高亮样式。 > <input type \"nickname\" placeholder \"请输入昵称\" model:value \"{{nickname}}\" /> <button class \"btn\" bind:tap \"showName\" type \"primary\" primary>提交</button> ``` ```js showName() { console.log(this.data.nickname) } ``` ### 手机号 获取手机号以后发送到后端, 在后端实现登录注册, 返回token, 这个接口是非个人的, 付费使用 #### 快速验证 ```html <! 参数解释： open type \"getPhoneNumber\"：指定按钮的功能为获取用户手机号。 bind:getphonenumber \"onGetPhoneNumber\"：当用户同意授权后，触发 onGetPhoneNumber 方法（需在 device.js 中实现）。 > <button class \"btn\" open type \"getPhoneNumber\" bind:getphonenumber \"onGetPhoneNumber\">获取手机号</button> ``` ```js onGetPhoneNumber(e) { console.log(e) }, ``` > 获取的数据里面有一个`e.detail.code`可以使用用于获取手机号 > > [用户信息 / 手机号 / 手机号快速验证](https://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/user info/phone number/getPhoneNumber.html) #### 实时验证(验证码) ```html <! 参数解释： open type \"getRealtimePhoneNumber\"：指定按钮的功能为获取用户手机号（实时验证）。 bind:getrealtimephonenumber \"onGetRealtimePhoneNumber\"：当用户同意授权后，触发 onGetRealtimePhoneNumber 方法（需在 device.js 中实现）。 > <button class \"btn\" open type \"getRealtimePhoneNumber\" bind:getrealtimephonenumber \"onGetRealtimePhoneNumber\">获取实时验证手机号</button> ``` ```python onGetRealtimePhoneNumber(e) { console.log(e) } ``` ### openID 微信的OpenID是微信平台为每个用户分配的唯一标识符，用于在特定的公众号或小程序中唯一识别用户。 [用户信息 / 用户信息 / 获取插件用户openpid](https://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/user info/basic info/getPluginOpenPId.html) #### 获取服务器的访问token [接口调用凭证 / 获取接口调用凭据](https://developers.weixin.qq.com/miniprogram/dev/OpenApiDoc/mp access token/getAccessToken.html) 1. 获取信息 ![image 20250805173850640](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202508051738837.png) 2. 获取临时token ![image 20250912170446711](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202509121704780.png) 获取的token有效时间两个小时 #### 获取实际的数据 ```js onGetUserInfo(e) { // 使用 wx.login 获取登录凭证 wx.login({ success: (res) > { console.log('登录成功:', res) if (res.code) { // 可以将 code 发送到后端换取 openid 等信息 console.log('登录凭证 code:', res.code) } }, fail: (res) > { console.log('登录失败:', res) } }) }, ``` ![image 20250805174509188](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202508051745254.png) ![image 20250805175134376](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202508051751529.png) ## 客服功能 可以实现直接沟通 ![image 20250805175453158](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202508051754335.png) ```html <button open type \"contact\" class \"contact btn theme {{theme}}\" data type \"关于\"> ``` > 使用contact为按钮的open type ## 拍照 调用手机的照相机 [媒体组件 / camera](https://developers.weixin.qq.com/miniprogram/dev/component/camera.html) ```html <! camera.wxml > <camera device position \"back\" flash \"off\" binderror \"error\" style \"width: 100%; height: 300px;\"></camera> <button type \"primary\" bindtap \"takePhoto\">拍照</button> <view>预览</view> <image mode \"widthFix\" src \"{{src}}\"></image> ``` ```js // camera.js Page({ takePhoto() { const ctx wx.createCameraContext() ctx.takePhoto({ quality: 'high', success: (res) > { this.setData({ src: res.tempImagePath }) } }) }, error(e) { console.log(e.detail) } }) ``` ## 获取其他页面 ```js var pages getCurrentPages() // 获取当前开启的页面 var prevPages pages[pages.length 2] // 获取上一级 ``` ## 录音 [媒体 / 录音 / RecorderManager](https://developers.weixin.qq.com/miniprogram/dev/api/media/recorder/RecorderManager.html)"},"/note/使用软件/index.html":{"title":"","content":"# 使用软件"},"/note/使用软件/inventor建模/2023-9-13-001工作界面.html":{"title":"工作界面","content":" layout: post title: \"工作界面\" date: 2023 9 5 15:39:08 +0800 tags: inventor 3D # 工作界面 ## 鼠标的使用 平移: 鼠标中键不放移动鼠标 放大缩小: 前后滚动中间滚轮 旋转1: F4加鼠标左键 旋转2: shift+鼠标中键,移动鼠标 旋转3: 导航按钮 动态观察激活 旋转4: 激活状态下按下Shift移动鼠标 放大到合适的大小: 双击鼠标的中键 ### 快捷键的设置 ![image 20230913104903446](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300226.png) ![image 20230913104919889](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300313.png)"},"/note/使用软件/inventor建模/2023-9-13-001绘制草图.html":{"title":"绘制草图","content":" layout: post title: \"绘制草图\" date: 2023 9 5 15:39:08 +0800 tags: inventor 3D # 绘制草图 首先需要给他一个面 + 在原始的坐标系里面创建面 ![image 20230913122547277](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300688.png) + 在已经有的平面里面绘制草图 ![image 20230913122637945](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300689.png) + 工作平面 ## 绘制草图 ### 直线 在绘制完一条线之后, 下一条线会显示与第一条线的位置 绘制结束之后按住不放会绘制出一个弧线 ![image 20230913123232923](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300690.png) + 样条曲线顶点式 给他一个起点, 再给他一些中间的点, 这一条线起点和终点位置确定, 用其他点帮助绘制这一条曲线 ![image 20230913123438457](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300691.png) + 插值曲线: 会经过这一些点 ![image 20230913123510688](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300692.png) ![image 20230913123555664](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300693.png) 通过这些点可以控制这一条曲线 + 表达式 绘制一条表达式的曲线 ![image 20230913123825935](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300694.png) 变量是t ![image 20230913123859658](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242300695.png) + 桥接曲线, 把两条线连接在一起"},"/note/使用软件/基础软件命令语法/2022-7-21-Linux相关指令.html":{"title":"Linux相关指令","content":" layout: article title: \"Linux相关指令\" ## Linux的相关指令 ![Image](https://xusenfeng.github.io/myimages/3.jpg){:.shadow} ![Image](https://xusenfeng.github.io/myimages/4.jpg){:.shadow} ![Image](https://xusenfeng.github.io/myimages/5.jpg){:.shadow} + 虚拟机共享文件 ![Image](https://xusenfeng.github.io/myimages/6.jpg){:.shadow} ![Image](https://xusenfeng.github.io/myimages/10.jpg){:.shadow} + 文件权限 ![Image](https://xusenfeng.github.io/myimages/8.jpg){:.shadow} ![Image](https://xusenfeng.github.io/myimages/9.jpg){:.shadow} ![Image](https://xusenfeng.github.io/myimages/7.jpg){:.shadow}"},"/note/使用软件/基础软件命令语法/2022-7-21-vim相关指令.html":{"title":"vim文本编译器","content":" layout: article title: \"vim文本编译器\" # vim文本编辑器 有三种模式: 命令模式 文本模式, 末行模式 [vim命令大全 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/61515833) ## 命令模式 ### 插入 ```bash i: 切换到输入模式，在光标当前位置开始输入文本。 a: 进入插入模式，在光标下一个位置开始输入文本。 o: 在当前行的下方插入一个新行，并进入插入模式。 I:在一行的开头添加文本 A: 在一行的结尾处添加文本 O: 在当前行的上方插入一个新行，并进入插入模式。 s: 删除当前光标处的字符并进入到插入模式 S: 删除光标所在处的行，并进入到插入模式 ``` ### 撤销操作 ```c u: 撤销修改 Ctrl + r: 反撤销 ``` ### 删除 ```bash 字符删除 x: 删除当前光标所在处的字符 X: 删除当前光标左边的字符 单词删除 dw: 删除一个单词(从光标处到空格) daw: 无论光标在什么位置，删除光标所在的整个单词(包括空白字符) diw: 删除整个单词文本，但是保留空格字符不删除 d2w: 删除从当前光标开始处的2个单词 d$: 删除从光标到一行末尾的整个文本 d0: 删除从光标到一行开头的所有单词 dl: 删除当前光标处的字符 x dh: 删除当前光标左边的字符 X 行删除 dd: 删除当前光标处的一整行(剪切) 5dd: 删除从光标开始处的5行代码 dgg: 删除从光标到文本开头 dG: 删除从光标到文本结尾 D: 删除从光标到文本结尾 行合并 J: 删除一个分行符，将当前行与下一行合并 ``` ### 移动 ```bash h: 左 j: 下 k: 上 l: 右 行号G 跳转到第n行 gg: 文本开始 G: 文本结束 %: 在一个括号上面使用这一个, 跳转到另一半括号 0: 行首 $: 行尾 ``` ### 查找 ```c *: 找到这一个符号出现的下一个位置 #: 这一个符号的前一个位置 ``` ### 格式化代码 ```c gg G ``` ![image 20240209204844757](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402092048788.png) ![image 20240209204915421](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402092049453.png) ### 替换 ```bash r: 替换单个字符, 按一下再按一下需要的字符 ``` ### 复制 ```bash yy: 复制一行 ``` ### 粘贴 ```bash p: 有复制换行的时候在这一行的下一行粘贴, 没有的话是在这一点的后面 P: 这一行的前一行 ``` ### 看手册 ``` K: 跳转到man手册里面, 默认第一卷匹配的 nK: 在第n卷里面找 ``` ### 查看宏定义 ``` [d: 查看这一个的宏定义 ``` ![image 20240209214401062](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402092144099.png) ### 退出 ```bash ZZ 保存退出 ``` ## 末行模式 ### 进入 ```bash : ``` ### 退出 ```bash ESC 两次 ``` 也可以执行一次末行命令 ```bash w: 保存 q: 退出 ``` ### 跳转 ```bash :行号 ``` ### 查找替换 ```bash /string 正向查找 ?string 反向查找 设置高亮显示 :set hls *按键将当前光标处的单词高亮显示，使用n浏览下一个查找高亮的结果 :s/old/new 将当前行的第一个字符串old替换为new :s/old/new/g 将当前行的所有字符串old替换为new :90s/old/new/g 将指定行的所有字符串old替换为new :90,93s/old/new/g 将指定范围的行的所有字符串old替换为new :%s/old/new/g 将文本中所有的字符串old替换为new :%s/old/new/gc 依次替换每个字符串关键字 :%s/^struct/int/g 将所有以struct开头的字符串替换为int ``` > 回车以后: n: 下一个 N: 上一个 ### 上一次, 下一次的命令 Ctrl p: 上一次 Ctrl n: 下一个 ### 分屏 ```bash :sp 上下分屏(默认光标第一个屏幕) Ctrl + ww: 换屏幕 :q 退出当前窗口 :qall 退出所有 :vsp 竖屏(可以加文件名打开其他的文件) ``` ### 执行命令 ``` :!命令 ``` > 直接执行这一个命令 > > ![image 20240209214629255](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402092146290.png) > > > 在使用之前需要w保存一下 ## 可视模式 ### 进入 ``` v :命令模式按v ``` ### 选中区域删除 ```c d: 选中按d ``` ### 复制 ```c y: 复制选中的区域 ``` ## 配置 ![Image](https://xusenfeng.github.io/myimages/13.jpg){:.shadow} ![Image](https://xusenfeng.github.io/myimages/14.jpg){:.shadow} ## 配置文件 [Vim 配置实用的.vimrc文件 XNQC 博客园 (cnblogs.com)](https://www.cnblogs.com/XNQC1314/p/8692993.html)"},"/note/使用软件/基础软件命令语法/2022-8-3-进程线程协程.html":{"title":"进程、协程、线程","content":" layout: post title: \"进程、协程、线程\" date: 2022 8 3 11:29:08 +0800 tags: Linux # 线程协程线程 进程> 线程> 进程 类比一个进程可以拥有多个线程，一个线程也可以拥有多个协程，因此协程又称微线程和纤程 ## **并发与并行** 并发：在操作系统中，某一时间段，几个程序在同一个CPU上运行，但在任意一个时间点上，只有一个程序在CPU上运行。 并行：当操作系统有多个CPU时，一个CPU处理A线程，另一个CPU处理B线程，两个线程互相不抢占CPU资源，可以同时进行，这种方式成为并行。 **区别** 1. 并发只是在宏观上给人感觉有多个程序在同时运行，但在实际的单CPU系统中，每一时刻只有一个程序在运行，微观上这些程序是分时交替执行。 2. 在多CPU系统中，将这些并发执行的程序分配到不同的CPU上处理，每个CPU用来处理一个程序，这样多个程序便可以实现同时执行。 例子： 你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。 你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。 你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。 并发的关键是你有处理多个任务的能力，不一定要同时。并行的关键是你有同时处理多个任务的能力。所以我认为它们最关键的点就是：是否是**『同时』**。 ## **进程** 一个进程好比是一个程序，它是 **资源分配的最小单位** 。同一时刻执行的进程数不会超过核心数。不过如果问单核CPU能否运行多进程？答案又是肯定的。单核CPU也可以运行多进程，只不过不是同时的，而是极快地在进程间来回切换实现的多进程。举个简单的例子，就算是十年前的单核CPU的电脑，也可以聊QQ的同时看视频。 电脑中有许多进程需要处于「同时」开启的状态，而利用CPU在进程间的快速切换，可以实现「同时」运行多个程序。而进程切换则意味着需要保留进程切换前的状态，以备切换回去的时候能够继续接着工作。所以进程拥有自己的地址空间，全局变量，文件描述符，各种硬件等等资源。操作系统通过调度CPU去执行进程的记录、回复、切换等等。 ## **线程** 它是 **程序执行过程中的最小单元** 。来回切换的**内容保存在内核**之中， 切换需要内核的参与 一个程序内包含了多种任务。打个比方，用播放器看视频的时候，视频输出的画面和声音可以认为是两种任务。当你拖动进度条的时候又触发了另外一种任务。拖动进度条会导致画面和声音都发生变化，如果进程里没有线程的话，那么可能发生的情况就是： 拖动进度条 >画面更新 >声音更新。你会明显感到画面和声音和进度条不同步。 但是加上了线程之后，**线程能够共享进程的大部分资源**，并参与CPU的调度。意味着它能够在进程间进行切换，实现「并发」，从而反馈到使用上就是拖动进度条的同时，画面和声音都同步了。所以我们经常能听到的一个词是「多线程」，就是把一个程序分成多个任务去跑，让任务更快处理。不过线程和线程之间由于某些资源是独占的，会导致锁的问题。例如Python的GIL多线程锁。 ## **进程与线程的区别** 1. 进程是CPU资源分配的基本单位，线程是独立运行和独立调度的基本单位（CPU上真正运行的是线程）。 2. 进程拥有自己的资源空间，一个进程包含若干个线程，线程与CPU资源分配无关，多个线程共享同一进程内的资源。 3. 线程的调度与切换比进程快很多。 **CPU密集型代码(各种循环处理、计算等等)：使用多进程。IO密集型代码(文件处理、网络爬虫等)：使用多线程** ## **阻塞与非阻塞** 阻塞是指调用线程或者进程被操作系统挂起。 非阻塞是指调用线程或者进程不会被操作系统挂起。 ## **同步与异步** 同步是阻塞模式，异步是非阻塞模式。 同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，知道收到返回信息才继续执行下去； 异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回式系统会通知进程进行处理，这样可以提高执行的效率。 由调用方盲目主动问询的方式是同步调用，由被调用方主动通知调用方任务已完成的方式是异步调用。看下图 ![img](https://pic4.zhimg.com/80/v2 f1118cbd6283a2626e6d4b9e7477b21b_720w.jpg) ## **协程** 一句话说明什么是线程：协程是一种用户态的轻量级线程。 协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。**保存的位置位于内核之外**，由程序实现协程的切换, 所以不用来回切换到内核, 由程序自己控制切换协程的好处： 1. 无需线程上下文切换的开销 2. 无需原子操作锁定及同步的开销 3. 方便切换控制流，简化编程模型 高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。 缺点： 1. 无法利用多核资源：协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上,协程需要和进程配合才能运行在多CPU上.当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。 2. 进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序 ## **最佳实践** 1. 线程和协程推荐在IO密集型的任务(比如网络调用)中使用，而在CPU密集型的任务中，表现较差。 2. 对于CPU密集型的任务，则需要多个进程，绕开GIL的限制，利用所有可用的CPU核心，提高效率。 3. 所以大并发下的最佳实践就是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。"},"/note/使用软件/Docker/2025-12-16-02-创建使用.html":{"title":"创建使用","content":"# 创建使用 ## 标准可复现方法 1. 创建一个Dockerfile 2. 使用Dockerfile创建镜像 3. 使用镜像创建运行容器 ### Dockerfile 是一个文本文件, 告诉docker如何创建镜像, 一般有操作系统, 运行时候的环境, 应用的环境, 应用程序的配置文件 ```dockerfile FROM python:3.11 COPY ./main.py /app/main.py WORKDIR /app CMD [\"python\", \"main.py\"] ``` 使用命令创建镜像 ```bash docker build t hellodocker . ``` + t: 指定名字 + .: 上下文路径，是指 docker 在构建镜像，有时候想要使用到本机的文件（比如复制），docker build 命令得知这个路径后，会将路径下的所有内容打包。 > **解析**：由于 docker 的运行模式是 C/S。我们本机是 C，docker 引擎是 S。实际的构建过程是在 docker 引擎下完成的，所以这个时候无法用到我们本机的文件。这就需要把我们本机的指定目录下的文件一起打包提供给 docker 引擎使用。 > > 如果未说明最后一个参数，那么默认上下文路径就是 Dockerfile 所在的位置。 > > **注意**：上下文路径下不要放无用的文件，因为会一起打包发送给 docker 引擎，如果文件过多会造成过程缓慢。 ```bash docker images # 查看所有的镜像 docker run hellodocker ``` 运行创建的镜像 ![image 20251216144621584](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251216144621584.png) ### 常用属性 Dockerfile 指令 说明 : : FROM 指定基础镜像，用于后续的指令构建。 MAINTAINER 指定Dockerfile的作者/维护者。（已弃用，推荐使用LABEL指令） LABEL 添加镜像的元数据，使用键值对的形式。 RUN 在构建过程中在镜像中执行命令。 CMD 指定容器创建时的默认命令。（可以被覆盖） ENTRYPOINT 设置容器创建时的主要命令。（不可被覆盖） EXPOSE 声明容器运行时监听的特定网络端口。 ENV 在容器内部设置环境变量。 ADD 将文件、目录或远程URL复制到镜像中。 COPY 将文件或目录复制到镜像中。 VOLUME 为容器创建挂载点或声明卷。 WORKDIR 设置后续指令的工作目录。 USER 指定后续指令的用户上下文。 ARG 定义在构建过程中传递给构建器的变量，可使用 \"docker build\" 命令设置。 ONBUILD 当该镜像被用作另一个构建过程的基础时，添加触发器。 STOPSIGNAL 设置发送给容器以退出的系统调用信号。 HEALTHCHECK 定义周期性检查容器健康状态的命令。 SHELL 覆盖Docker中默认的shell，用于RUN、CMD和ENTRYPOINT指令。 #### FROM 使用的容器的名字, 可以在https://hub.docker.com/查找可以使用的docker #### RUN 运行命令, 可以直接跟命令, 也可以使用字符串数组的形式 > Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大。例如 > > ```dockerfile > FROM centos > RUN yum y install wget > RUN wget O redis.tar.gz \"http://download.redis.io/releases/redis 5.0.3.tar.gz\" > RUN tar xvf redis.tar.gz > ``` > > 以上执行会创建 3 层镜像。可简化为以下格式 > > ```dockerfile > FROM centos > RUN yum y install wget \\ > && wget O redis.tar.gz \"http://download.redis.io/releases/redis 5.0.3.tar.gz\" \\ > && tar xvf redis.tar.gz > ``` #### COPY ````dockerfile COPY [ chown <user>:<group>] <源路径1>... <目标路径> COPY [ chown <user>:<group>] [\"<源路径1>\",... \"<目标路径>\"] ```` **[ chown <user>:<group>]**：可选参数，用户改变复制到容器内文件的拥有者和属组。 #### ADD自动解压的COPY ADD 指令和 COPY 的使用格类似（同样需求下，官方推荐使用 COPY）。功能也类似，不同之处如下： ADD 的优点：在执行 <源文件> 为 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，会自动复制并解压到 <目标路径>。 ADD 的缺点：在不解压的前提下，无法复制 tar 压缩文件。会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。具体是否使用，可以根据是否需要自动解压来决定 #### CMD 类似于 RUN 指令，用于运行程序，但二者运行的时间点不同: CMD 在docker run 时运行。 RUN 是在 docker build。 **作用**：为启动的容器指定默认要运行的程序，程序运行结束，容器也就结束。CMD 指令指定的程序可被 docker run 命令行参数中指定要运行的程序所覆盖。 **注意**：如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效 ```dockerfile CMD <shell 命令> CMD [\"<可执行文件或命令>\",\"<param1>\",\"<param2>\",...] CMD [\"<param1>\",\"<param2>\",...] # 该写法是为 ENTRYPOINT 指令指定的程序提供默认参数 ``` 可以使用`docker run c \"xxx\"`来覆盖CMD参数 #### ENTRYPOINT定参 使用实际的CMD作为这个命令的参数进行传递, 实际运行的是`ENTRYPOINT CMD` > 如果运行 docker run 时使用了 entrypoint 选项，将覆盖 ENTRYPOINT 指令指定的程序。 **优点**：在执行 docker run 的时候可以指定 ENTRYPOINT 运行所需的参数。 **注意**：如果 Dockerfile 中如果存在多个 ENTRYPOINT 指令，仅最后一个生效。 格式： ```dockerfile ENTRYPOINT [\"<executeable>\",\"<param1>\",\"<param2>\",...] ``` 可以搭配 CMD 命令使用：一般是变参才会使用 CMD ，这里的 CMD 等于是在给 ENTRYPOINT 传参，以下示例会提到。 示例： 假设已通过 Dockerfile 构建了 nginx:test 镜像： ``` FROM nginx ENTRYPOINT [\"nginx\", \" c\"] # 定参 CMD [\"/etc/nginx/nginx.conf\"] # 变参 ``` 1、不传参运行 ``` $ docker run nginx:test ``` 容器内会默认运行以下命令，启动主进程。 ``` nginx c /etc/nginx/nginx.conf ``` 2、传参运行 ``` $ docker run nginx:test c /etc/nginx/new.conf ``` 容器内会默认运行以下命令，启动主进程(/etc/nginx/new.conf:假设容器内已有此文件) ``` nginx c /etc/nginx/new.conf ``` #### ENV 设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量 ```dockerfile ENV <key> <value> ENV <key1> <value1> <key2> <value2>... ``` 示例 ```dockerfile ENV NODE_VERSION 7.2.0 RUN curl SLO \"https://nodejs.org/dist/v$NODE_VERSION/node v$NODE_VERSION linux x64.tar.xz\" \\ && curl SLO \"https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc\" ``` #### ARG 构建参数，与 ENV 作用一致。不过作用域不一样。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量 构建命令 docker build 中可以用 build arg <参数名> <值> 来覆盖 ```dockerfile ARG <参数名>[ <默认值>] ``` #### VOLUME **为容器定义持久化的挂载点**，将容器内指定目录与 Docker 管理的卷（Volume）绑定, VOLUME 指令默认创建「匿名卷」（卷名是随机 UUID），宿主机路径为 `/var/lib/docker/volumes/<随机ID>/_data` **命名卷**：VOLUME 本身无法指定卷名，需在 `docker run` 时通过 ` v` 覆盖 作用： 1. **数据持久化**：容器删除 / 重启时，VOLUME 目录的数据不会丢失（存储在宿主机的 Docker 卷目录中）； 2. **数据共享**：多个容器可挂载同一个卷，实现数据互通； 3. **镜像解耦**：避免镜像包含动态数据（如日志、数据库文件），保证镜像的可移植性； 4. **避免权限问题**：Docker 自动管理卷的权限，无需手动调整宿主机目录权限。 ```dockerfile # 1. JSON 数组格式（推荐） VOLUME [\"/path/1\", \"/path/2\"] # 2. Shell 格式（多个路径用空格分隔） VOLUME /path/1 /path/2 ``` 使用示例 ```dockerfile FROM nginx:alpine # 定义两个匿名卷：日志目录、网页根目录 VOLUME [\"/var/log/nginx\", \"/usr/share/nginx/html\"] CMD [\"nginx\", \" g\", \"daemon off;\"] # 用命名卷覆盖 Dockerfile 中的 VOLUME 挂载 docker run v my nginx log:/var/log/nginx v my nginx html:/usr/share/nginx/html nginx:alpine ``` 如果 Dockerfile 构建时，VOLUME 指定的目录已有数据（如镜像自带的 `index.html`），容器启动时： Docker 会先将镜像中该目录的**原有数据复制到卷中**，再挂载卷到容器； 若运行容器时用 ` v 宿主机路径:/容器路径`（绑定挂载），则**不会自动复制**镜像数据到宿主机路径（需手动复制）。 `docker run v /host/log:/var/log/nginx nginx:alpine` #### EXPOSE EXPOSE 是 Dockerfile 的元数据类指令，用于**声明容器运行时预期监听的网络端口**，仅作为镜像的 “说明文档”，告知使用者容器会使用哪些端口，**不会自动将端口映射到宿主机** 1. **元数据声明**：为镜像添加端口使用的元数据，通过 `docker inspect <镜像/容器>` 可查看，方便开发者 / 运维人员了解容器的网络端口规划； 2. **端口协议说明**：可声明端口使用的协议（TCP/UDP），默认 TCP； 3. **配合端口映射**：`docker run` 时可通过 ` P`（大写）自动映射所有 EXPOSE 声明的端口到宿主机随机端口。 ```dockerfile # 1. 声明单个端口（默认 TCP） EXPOSE <端口号> # 2. 声明单个端口并指定协议（TCP/UDP） EXPOSE <端口号>/<协议> # 3. 声明多个端口（支持混合协议） EXPOSE <端口1> <端口2>/udp <端口3>/tcp ``` ```bash # 仅启动容器，EXPOSE 80 但未映射，宿主机无法访问 docker run d name nginx1 nginx:alpine # 通过 p 手动映射 80 端口，宿主机可访问 http://localhost:8080 docker run d name nginx2 p 8080:80 nginx:alpine # 通过 P 自动映射所有 EXPOSE 端口，宿主机可通过随机端口访问 docker run d name nginx3 P nginx:alpine # 查看自动映射的端口：docker port nginx3 ``` 启动容器时，可通过 ` expose` 参数补充或取消 EXPOSE 声明, 同一 Docker 网络内的容器，无需端口映射即可通过 “容器名 / IP + EXPOSE 端口” 通信（EXPOSE 不影响容器间通信，仅影响外部访问） ```bash # 创建自定义网络 docker network create my net # 启动 nginx 容器（未映射端口） docker run d name nginx net network my net nginx:alpine # 启动 busybox 容器，可直接访问 nginx net:80 docker run rm network my net busybox wget O nginx net:80 ``` #### WORKDIR 指定工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。以后各层的当前目录就被改为指定的目录，如该目录不存在，WORKDIR 会帮你建立目录 #### USER 用于指定执行后续命令的用户和用户组，这边只是切换后续命令执行的用户（用户和用户组必须提前已经存在）。 ## commit方法 + 基于容器修改后提交（`docker commit`） 这是最基础的手动构建方式，通过修改运行中的容器（如安装软件、配置文件），再将容器的文件系统状态 “快照” 为新镜像。 操作步骤： 1. 启动基础容器（以 ubuntu 为例）： ```bash docker run it name temp container ubuntu:22.04 /bin/bash ``` 2. 在容器内修改（如安装 nginx）： ```bash # 容器内执行 apt update && apt install y nginx exit # 修改完成后退出容器 ``` 3. 提交容器为新镜像 ```bash docker commit [选项] 容器名/容器ID 新镜像名:标签 # 示例：提交 temp container 为 my nginx:v1 docker commit author \"Your Name <your@email.com>\" message \"install nginx\" temp container my nginx:v1 ``` 4. 验证镜像 ```bash docker images # 查看新镜像 docker run d my nginx:v1 nginx g \"daemon off;\" # 启动镜像测试 ``` ** m:** 提交的描述信息 ** a:** 指定镜像作者 缺点: 不可复现（无配置文件，其他人无法复刻相同镜像）； 层冗余（容器内的所有操作都会生成冗余层，镜像体积大）； 无标准化（无法追溯修改内容，维护成本高）"},"/note/使用软件/Docker/2025-12-16-05-多个网络.html":{"title":"","content":"## DockerCompose 运行多个独立但是之间有联系的服务的时候, 需要相互配合, 使用docker compose.yml实现管理所有的服务 使用`docker compose up`即可启动 ## Compose文件 可以使用 YML 文件来配置应用程序需要的所有服务。 Compose 使用的三个步骤： 使用 Dockerfile 定义应用程序的环境。 使用 docker compose.yml 定义构成应用程序的服务，这样它们可以在隔离环境中一起运行。 最后，执行 docker compose up 命令来启动并运行整个应用程序。 ### 使用示例 ## 使用 1、准备 创建一个测试目录： ``` $ mkdir composetest $ cd composetest ``` 在测试目录中创建一个名为 app.py 的文件，并复制粘贴以下内容 ```python import time import redis from flask import Flask app Flask(__name__) cache redis.Redis(host 'redis', port 6379) def get_hit_count(): retries 5 while True: try: return cache.incr('hits') except redis.exceptions.ConnectionError as exc: if retries 0: raise exc retries 1 time.sleep(0.5) @app.route('/') def hello(): count get_hit_count() return 'Hello World! I have been seen {} times.\\n'.format(count) ``` 在此示例中，redis 是应用程序网络上的 redis 容器的主机名，该主机使用的端口为 6379。 在 composetest 目录中创建另一个名为 **requirements.txt** 的文件，内容如下： ``` flask redis ``` 2、创建 Dockerfile 文件 在 composetest 目录中，创建一个名为 **Dockerfile** 的文件，内容如下： ```dockerfile FROM python:3.7 alpine WORKDIR /code ENV FLASK_APP app.py ENV FLASK_RUN_HOST 0.0.0.0 RUN apk add no cache gcc musl dev linux headers COPY requirements.txt requirements.txt RUN pip install r requirements.txt COPY . . CMD [\"flask\", \"run\"] ``` **Dockerfile 内容解释：** **FROM python:3.7 alpine**: 从 Python 3.7 映像开始构建镜像。 **WORKDIR /code**: 将工作目录设置为 /code。 ```dockerfile ENV FLASK_APP app.py ENV FLASK_RUN_HOST 0.0.0.0 ``` 设置 flask 命令使用的环境变量。 **RUN apk add no cache gcc musl dev linux headers**: 安装 gcc，以便诸如 MarkupSafe 和 SQLAlchemy 之类的 Python 包可以编译加速。 ```dockerfile COPY requirements.txt requirements.txt RUN pip install r requirements.txt ``` 复制 requirements.txt 并安装 Python 依赖项。 **COPY . .**: 将 . 项目中的当前目录复制到 . 镜像中的工作目录。 **CMD [\"flask\", \"run\"]**: 容器提供默认的执行命令为：flask run。 3、创建 docker compose.yml 在测试目录中创建一个名为 docker compose.yml 的文件，然后粘贴以下内容： docker compose.yml 配置文件 ```yaml version: '3' services: web: build: . ports: \"5000:5000\" redis: image: \"redis:alpine\" ``` 该 Compose 文件定义了两个服务：web 和 redis。 **web**：该 web 服务使用从 Dockerfile 当前目录中构建的镜像。然后，它将容器和主机绑定到暴露的端口 5000。此示例服务使用 Flask Web 服务器的默认端口 5000 。 **redis**：该 redis 服务使用 Docker Hub 的公共 Redis 映像。 ### 基本参数 #### version基于的版本 #### build镜像构建的目录 作为具有在上下文指定的路径的对象，以及可选的 Dockerfile 和 args ```yaml version: \"3.7\" services: webapp: build: ./dir ``` ```yaml version: \"3.7\" services: webapp: build: context: ./dir dockerfile: Dockerfile alternate args: buildno: 1 labels: \"com.example.description Accounting webapp\" \"com.example.department Finance\" \"com.example.label with empty value\" target: prod ``` context：上下文路径。 dockerfile：指定构建镜像的 Dockerfile 文件名。 args：添加构建参数，这是只能在构建过程中访问的环境变量。 labels：设置构建镜像的标签。 target：多层构建，可以指定构建哪一层。 #### cap_add，cap_drop 添加或删除容器拥有的宿主机的内核功能。 ```yaml cap_add: ALL # 开启全部权限 cap_drop: SYS_PTRACE # 关闭 ptrace权限 ``` #### cgroup_parent 为容器指定父 cgroup 组，意味着将继承该组的资源限制。 ```yaml cgroup_parent: m executor abcd ``` #### command 覆盖容器启动的默认命令。 ```yaml command: [\"bundle\", \"exec\", \"thin\", \" p\", \"3000\"] ``` #### container_name 指定自定义容器名称，而不是生成的默认名称。 ```yaml container_name: my web container ``` #### depends_on 设置依赖关系。 ```yaml version: \"3.7\" services: web: build: . depends_on: db redis redis: image: redis db: image: postgres ``` > `docker compose up` ：以依赖性顺序启动服务。在以下示例中，先启动 db 和 redis ，才会启动 web。 > `docker compose up SERVICE` ：自动包含 SERVICE 的依赖项。在以下示例中，`docker compose up web` 还将创建并启动 db 和 redis。 > `docker compose stop` ：按依赖关系顺序停止服务。在以下示例中，web 在 db 和 redis 之前停止。 #### deploy 指定与服务的部署和运行有关的配置。只在 swarm 模式下才会有用 #### devices 指定设备映射列表。 ```yaml devices: \"/dev/ttyUSB0:/dev/ttyUSB0\" ``` #### dns 自定义 DNS 服务器，可以是单个值或列表的多个值。 ```yaml dns: 8.8.8.8 dns: 8.8.8.8 9.9.9.9 ``` #### env_file 从文件添加环境变量。可以是单个值或列表的多个值 ```yaml env_file: ./common.env ./apps/web.env /opt/secrets.env ``` #### environment 添加环境变量。您可以使用数组或字典、任何布尔值，布尔值需要用引号引起来，以确保 YML 解析器不会将其转换为 True 或 False ```yaml environment: RACK_ENV: development SHOW: 'true' ``` #### expose 暴露端口，但不映射到宿主机，只被连接的服务访问。 仅可以指定内部端口为参数： ```yaml expose: \"3000\" \"8000\" ``` #### volumes 将主机的数据卷或者文件挂载到容器里 ```yaml version: \"3.7\" services: db: image: postgres:latest volumes: \"/localhost/postgres.sock:/var/run/postgres/postgres.sock\" \"/localhost/data:/var/lib/postgresql/data\" ```"},"/note/使用软件/Docker/2025-12-16-03-网络.html":{"title":"","content":"## 网络 默认时候建立三个网络, bridge, host和none, 可以使用命令`docker network inspect bridge`查看这个网络的信息, 默认的会把他放入bridge网络里面 每一个建立的网络会建立两个网卡, 其中一个会在镜像里面, 另一个在实际的机器里面用于通信 ![image 20250222114648328](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/picture/202502221146014.png) 默认的bridge不会有网关, 所以机器之间不可以使用主机名进行通信, 可以使用ip地址进行通信(容器内可以使用主机名字进行通信) + 新建网络 `docker network create d bridge 名字` 之后建立的镜像可以使用` network 名字`指定使用的网络, ` d`：参数指定 Docker 网络类型，有 bridge、overlay ```bash docker network create d bridge test net ``` + 创建容器连接进去 ```bash docker run itd name test1 network test net ubuntu /bin/bash docker run itd name test2 network test net ubuntu /bin/bash ``` 可以直接使用`ping test1`和`ping test2`进行网络之间的ping"},"/note/使用软件/Docker/2023-6-16-Docker.html":{"title":"Docker使用","content":" layout: post title: \"Docker使用\" date: 2023 6 16 11:29:08 +0800 tags: docker # Docker 应用打包, 分发, 部署的工具 你也可以把它理解为一个轻量的虚拟机，它只虚拟你软件需要的运行环境，多余的一点都不要， 而普通虚拟机则是一个完整而庞大的系统，包含各种不管你要不要的软件。 性能比较好, 稳定性好 **打包**：就是把你软件运行所需的依赖、第三方库、软件打包到一起，变成一个安装包 **分发**：你可以把你打包好的“安装包”上传到一个镜像仓库，其他人可以非常方便的获取和安装 **部署**：拿着“安装包”就可以一个命令运行起来你的应用，自动模拟出一摸一样的运行环境，不管是在 Windows/Mac/Linux。 > 可以使用Play With Docker网址构建镜像以及运行测试 ### Docker 部署的优势 常规应用开发部署方式：自己在 Windows 上开发、测试 > 到 Linux 服务器配置运行环境部署。 > 问题：我机器上跑都没问题，怎么到服务器就各种问题了 用 Docker 开发部署流程：自己在 Windows 上开发、测试 > 打包为 Docker 镜像（可以理解为软件安装包） > 各种服务器上只需要一个命令部署好 > 优点：确保了不同机器上跑都是一致的运行环境，不会出现我机器上跑正常，你机器跑就有问题的情况。 例如 [易文档](https://easydoc.net/)，[SVNBucket](https://svnbucket.com/) 的私有化部署就是用 Docker，轻松应对客户的各种服务器。 ### Docker 通常用来做什么 应用分发、部署，方便传播给他人安装。特别是开源软件和提供私有部署的应用 快速安装测试/学习软件，用完就丢（类似小程序），不把时间浪费在安装软件上。例如 Redis / MongoDB / ElasticSearch / ELK 多个版本软件共存，不污染系统，例如 Python2、Python3，Redis4.0，Redis5.0 Windows 上体验/学习各种 Linux 系统 ### 重要概念：镜像、容器、仓库 **镜像**：可以理解为软件安装包，可以方便的进行传播和安装。只读, 用于建立容器 **容器**：软件安装后的状态，每个软件运行环境都是独立的、隔离的，称之为容器。实际的运行实例, 可以在这里运行程序 **仓库**： 记录镜像和容器 ### 安装 桌面版：https://www.docker.com/products/docker desktop 服务器版：https://docs.docker.com/engine/install/#server **命令行安装 Linux 内核** `wsl.exe install d Ubuntu` **设置开机启动 Hypervisor** `bcdedit /set hypervisorlaunchtype auto` > 注意要用管理员权限打开 PowerShell **设置默认使用版本2** `wsl.exe set default version 2` **查看 WSL 是否安装正确** `wsl.exe list verbose` 应该如下图，可以看到一个 Linux 系统，名字你的不一定跟我的一样，看你安装的是什么版本。 并且 VERSION 是 2 ![image.png](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242303944.png) **确保 BIOS 已开启虚拟化，下图检查是否已开启好** > 如果是已禁用，请在开机时按 F2 进入 BIOS 开启一下，不会设置的可以网上搜索下自己主板的设置方法，Intel 和 AMD 的设置可能稍有不同 ![image.png](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242303945.png) ### 镜像加速源 镜像加速器 镜像加速器地址 Docker 中国官方镜像 https://registry.docker cn.com DaoCloud 镜像站 http://f1361db2.m.daocloud.io Azure 中国镜像 https://dockerhub.azk8s.cn 科大镜像站 https://docker.mirrors.ustc.edu.cn 阿里云 https://ud6340vz.mirror.aliyuncs.com 七牛云 https://reg mirror.qiniu.com 网易云 https://hub mirror.c.163.com 腾讯云 https://mirror.ccs.tencentyun.com ``` \"registry mirrors\": [\"https://registry.docker cn.com\"] ``` ![1.png](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408242303946.png) ## 实际使用 Docker 官方镜像仓库：https://hub.docker.com/ `docker run d p 6379:6379 name redis redis:latest` > 运行一个软件, d在后台运行, p容器里面的端口暴漏, name给容器命名, 使用的源为最新版本 ### 常用命令 **命令** **功能** **示例** : : : `docker run` 启动一个新的容器并运行命令 `docker run d ubuntu` `docker ps` 列出当前正在运行的容器 `docker ps` `docker ps a` 列出所有容器（包括已停止的容器） `docker ps a` `docker build` 使用 Dockerfile 构建镜像 `docker build t my image .` `docker images` 列出本地存储的所有镜像 `docker images` `docker pull` 从 Docker 仓库拉取镜像 `docker pull ubuntu` `docker push` 将镜像推送到 Docker 仓库 `docker push my image` `docker exec` 在运行的容器中执行命令 `docker exec it container_name bash` `docker stop` 停止一个或多个容器 `docker stop container_name` `docker start` 启动已停止的容器 `docker start container_name` `docker restart` 重启一个容器 `docker restart container_name` `docker rm` 删除一个或多个容器 `docker rm container_name` `docker rmi` 删除一个或多个镜像 `docker rmi my image` `docker logs` 查看容器的日志 `docker logs container_name` `docker inspect` 获取容器或镜像的详细信息 `docker inspect container_name` `docker exec it` 进入容器的交互式终端 `docker exec it container_name /bin/bash` `docker network ls` 列出所有 Docker 网络 `docker network ls` `docker volume ls` 列出所有 Docker 卷 `docker volume ls` `docker compose up` 启动多容器应用（从 `docker compose.yml` 文件） `docker compose up` `docker compose down` 停止并删除由 `docker compose` 启动的容器、网络等 `docker compose down` `docker info` 显示 Docker 系统的详细信息 `docker info` `docker version` 显示 Docker 客户端和守护进程的版本信息 `docker version` `docker stats` 显示容器的实时资源使用情况 `docker stats` `docker login` 登录 Docker 仓库 `docker login` `docker logout` 登出 Docker 仓库 `docker logout` **` d`**：后台运行容器，例如 `docker run d ubuntu`。 **` it`**：以交互式终端运行容器，例如 `docker run it ubuntu /bin/bash`, `docker exec it 243c32535da7 /bin/bash`, exec退出的时候容器不会停止 **` t`**：为镜像指定标签，例如 `docker build t my image .` ### 导出导入 ```bash docker export 1e560fca3906 > ubuntu.tar cat docker/ubuntu.tar docker import test/ubuntu:v1 docker import http://example.com/exampleimage.tgz example/imagerepo ``` ## 代理 [Docker/DockerHub 国内镜像源/加速列表（2月20日更新 长期维护） 腾讯云开发者社区 腾讯云](https://cloud.tencent.com/developer/article/2485043) ![image 20250221221647494](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/picture/202502212216344.png) ## 逻辑卷 docker容器里面的数据是不会持久保存的, 创建一个容器的时候, 通常是一个干净的文件系统, 可以在里面进行操作, 但是容器关闭的时候所有的文件丢失, 想要持久话的话, 可以把容器里面的某一个目录映射到宿主机的某一个目录里面 ```bash # 列出所有卷 docker volume ls # 查看卷的详细信息（含宿主机路径） docker volume inspect <卷名/随机ID> # 删除指定卷 docker volume rm <卷名> # 删除所有未使用的卷（谨慎！） docker volume prune ``` 1. **数据库数据持久化**：如 MySQL 的 `/var/lib/mysql` 目录； 2. **应用日志存储**：如 Nginx/Java 应用的日志目录； 3. **用户上传文件**：如 Web 应用的 `/uploads` 目录； 4. **配置文件共享**：多个容器共享同一套配置文件。"},"/note/使用软件/Docker/2025-12-16-04-分层.html":{"title":"分层","content":"# 分层 **Docker 镜像的分层架构本质** —— 镜像是由多个**只读的、不可修改的文件系统层**（Layer）通过「联合文件系统（UnionFS）」叠加而成的，而 `RUN` 是触发 “新增层” 的核心指令之一 Docker 镜像的底层是**联合文件系统（UnionFS）**，它的核心特点是： 所有层都是**只读的**（Immutable），一旦创建就无法修改； 新层只会记录 “与上一层的差异”（增量存储），而非复制整个文件系统； 容器启动时，会在镜像的只读层之上加一层**可写层**（容器层），容器内的所有修改都只发生在这一层，不影响底层镜像。 简单说：`FROM` 会拉取基础镜像的所有层，之后每执行一次 `RUN`（或 COPY/ADD），就会在现有层的基础上新增一层，仅保存本次命令带来的文件系统变更 可以通过以下命令查看镜像的分层信息 ```python # 查看镜像的分层列表（每层的 ID、大小、创建指令） docker history <镜像名:标签> # 示例：查看 nginx 镜像的分层 docker history nginx:alpine ```"},"/note/使用软件/solidworks-3D建模/2024-7-28-03特征.html":{"title":"特征","content":" layout: post title: \"特征\" date: 2024 7 25 15:39:08 +0800 tags: 3D建模 # 特征 ## 基础功能 二维的草图变为三维的实体 ![image 20240728162816337](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407281628361.png) 拉伸凸台/基体是草图在沿直线运动的时候经过的路径, 旋转凸台基体是草图沿着一条线进行旋转的时候经过的路径 扫描实际是草图按照另一个线性的草图移动扫描出来的路径 放样草图实体是吧两个不同的草图轮廓通过之间的连线成为一个实体 ![image 20240728163154804](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407281631827.png) 使用草图对现有的模型进行切除, 异形体向导可以用于添加螺纹孔, 螺钉间隙孔, 销钉孔, 沉头孔等不同标准的孔 ### 拉伸凸台基体 ![image 20240728162551419](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407281625444.png) > 起始位置可以不在这一个草图上面, 默认是从这一个草图开始进行拉伸 > > ![image 20240728163730622](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407281637675.png) ![image 20240728162444984](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407281624026.png) > 可以设置拉伸的实际方向以及位置 ![image 20240728162521952](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407281625974.png) > 同时设置两个方向的拉伸 > > ![image 20240728163830646](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407281638680.png) > > 也可以使用![image 20240728164236365](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407281642390.png)达到相同的效果 > > ![image 20240728164412764](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407281644855.png) 给这一个区域添加一个外壁 ### 拉伸切除 [终止条件拉伸 2021 SOLIDWORKS 帮助](https://help.solidworks.com/2021/chinese simplified/SolidWorks/sldworks/c_end_condition_extrude.htm) ![image 20240728165400717](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407281654789.png) ![image 20240728165651051](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407281656082.png) > 可以在这里获取基准面 可以自己定义基准面, ![image 20240728165849900](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407281658924.png)选择基准面 ![image 20240728170007242](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407281700317.png) ![image 20240728170140045](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407281701070.png) 可以点击这一个基准面, 弹出来的眼睛可以设置这一个基准面是不是可见的, 也可以在这个位置进行开启以及关闭 ![image 20240728170528761](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407281705788.png) 在使用这个进行切除的时候, 如果是一个圆和直线相切, 这时候进行切除的话会出现一个报错, 出现厚度为0的实体, 但是如果相切的点有两个, 会直接把这一个实体一分为二 ### 扫描 ![image 20240728170912906](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407281709954.png) ![image 20240728171056987](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407281710031.png) ![image 20240728171123880](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407281711932.png) ![image 20240728171332585](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407281713659.png) ![image 20240728171525447](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407281715502.png) ### 旋转 ![image 20240728172203902](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407281722997.png) 会自动使用图里面的构造线进行旋转 ![image 20240728172454105](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407281724154.png) 可以使用这一个方式形成一个螺丝, 可以使用插入 > 注解 > 装饰螺纹线, 之后点击起始线 ![image 20240728172649320](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407281726366.png) ## 基准 ### 基准面 ![image 20240728220654728](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407282206781.png) 可以使用两侧对称获取两个面的中点, 两个面的时候这一个值必须选用 使用一个面的时候可以设置这一个基准面和选取的面的关系![image 20240728221658943](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407282216973.png) 也可以使用三个点确定一个面的位置 在使用线进行定位的时候, 这一个线可以是![image 20240728221508941](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407282215970.png)这三种关系 ### 基准轴 ![image 20240728225150648](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407282251706.png) ## 剖视图 ![image 20240728221821317](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407282218378.png) ![image 20240728221851013](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407282218050.png) ## 圆角 ![image 20240728222348445](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407282223509.png) ![image 20240728222549294](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407282225368.png) ![image 20240728222718195](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407282227267.png) ![image 20240728222800627](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407282228659.png) ![image 20240728223142792](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407282231862.png) 把中间的面变为圆角 ## 异形孔向导 ![image 20240728223632725](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407282236760.png) ![image 20240728223654868](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407282236899.png) 选择使用的螺丝的型号以及大小![image 20240728223901940](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407282239970.png) 之后选择需要打孔的位置, 在这一个界面选择一个面 ![image 20240728223921646](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407282239714.png) 实际是绘制一个点![image 20240728224046035](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407282240076.png) ![image 20240728224126475](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407282241505.png) ![image 20240728224515834](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407282245864.png) 实际是自动生成这一些东西 ## 阵列 ![image 20240728224947539](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407282249575.png) ![image 20240728225309391](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407282253452.png) ### 对称 在这一个软件里面, 不相邻的两个部分叫做实体 ![image 20240728225741678](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407282257763.png) ## 父子关系 如果一个实体使用另一个实体的一个面作为基准面, 这一个实体是另一个实体的子实体, 删除父实体的时候会一同删除子实体 可以通过重新设置基准面取消关联, 可以点击这一个草图, 选择编辑草图平面, 换一个基准平面 ![image 20240729130506733](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407291305815.png) ## 放样 用于连接不同的模型 ![image 20250825102244132](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202508251022228.png) ![image 20250825102326318](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202508251023453.png) 可以设置开始以及结束的方式 ![image 20250825102427329](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202508251024427.png) 引导线是实际需要沿着的边线"},"/note/使用软件/solidworks-3D建模/2024-7-26-02草图绘制.html":{"title":"草图绘制","content":" layout: post title: \"草图绘制\" date: 2024 7 25 15:39:08 +0800 tags: 3D建模 # 草图绘制 ## 基础图形 ### 直线 ![image 20240726170447329](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407261704351.png) 按Esc进行退出, 默认第一点是不可以移动的 ![image 20240726170613951](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407261706978.png) ![image 20240726170657289](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407261706316.png) > 可以直接在这里删除, 属性栏里面的直线长度是可以改变的, 可以使用智能尺寸进行固定尺寸的操作 ![image 20240726170734050](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407261707078.png) 还可以这样 ![image 20240726170842261](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407261708285.png) > 固定一个线的时候还需要固定他的点 ![image 20240726170921671](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407261709703.png) ![image 20240726171026303](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407261710331.png) ![image 20240726171052648](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407261710677.png) 再次编辑的时候可以![image 20240726171140132](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407261711158.png)或者直接点击这一个草图在浮现的按钮里面选择编辑 ### 矩形 ![image 20240726192648715](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407261926756.png) > 鼠标右键长按上移进入智能尺寸 可以设置这一个矩形的长度宽度以及相对原点的位置, 完全约束以后这一个矩形会变成黑色 ### 圆 有中心圆以及周边圆(三个点确定一个圆) ### 槽 前两下确定一个线, 之后拖动绘制一个槽 ![image 20240726220523670](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407262205698.png) ### 圆弧 里面的切线弧绘制的时候起点必须是一个直线的终点, 这一个圆弧会和现在有的圆弧相切 ### 圆角 点击矩形的边角出现一个圆弧 ![image 20240726220923021](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407262209047.png) 之后可以设置这一个圆角的半径 ![image 20240726221008063](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407262210085.png) 这一个标志是相切 ![image 20240726221323282](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407262213321.png) 还可以设置倒角 ### 点 最小的几何特征, 有时候会用在圆周阵列的中心点 ### 多边形 ![image 20240726221703913](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407262217939.png) ## 几何关系 草图的几何关系包括重合, 中点, 相切, 平行, 相等, 共线, 对称 ![image 20240727111838215](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407271118283.png) 同时选中两条直线, 可以设置这些关系 ![image 20240727112300958](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407271123009.png) 圆和直线可以实现相切 选中一条直线, 作为构造线, 在这一个线的两遍画一个圆, 同时选中可以实现对称 ![image 20240727112545367](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407271125419.png) ![image 20240727112517358](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407271125417.png) ### 编辑功能 裁剪实体, 转换实体引用, 等距实体 #### 裁剪实体 ![image 20240727112730273](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407271127303.png) **强劲裁剪:** 鼠标滑过的位置会被裁剪掉 ![image 20240727112858536](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407271128563.png) 可以使用shift对裁剪的部分进行延伸 **裁剪到最近端: **实际的功能和上面的类似, 但是是对选中的部分进行裁剪, 没有延长的功能 #### 转换实体引用 可以理解为转换草图引用或者转换轮廓引用, 把轮廓或者引用的线进行投影到正在绘制的这一个草图 绘制一个圆柱, 使用圆进行拉伸凸台 在实际绘制草图的时候不一定是基准面 可以在使用草图绘制的时候选择其中一个面 ![image 20240727113816978](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407271138064.png) ![image 20240727113921684](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407271139772.png) 在转换实体引用的时候选中这一个圆柱的边线可以把这一个线提取到当前的草图里面 ![image 20240727114117556](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407271141629.png) 也可以使用![image 20240727114147879](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407271141910.png)只显示包含的线, 第一个是默认使用的模式 还可以使用在左侧选中第一幅草图, 然后使用转换实体引用的按钮把第一幅图投影到这一幅图里面 ![image 20240727114634870](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407271146914.png) ##### 实际应用 ![image 20240727222343465](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407272223524.png) 绘制一个这样的图形, 现在想要实现一个L形状的图形, 可以对上面的那一个正方形进行拉伸 ![image 20240727222533445](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407272225503.png) ![image 20240727222543604](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407272225635.png)选中这一个面, 草图绘制, 绘制一个和这一个面一样大的矩形(也可以点击一个面, 之后弹出来的快捷键里面有) ![image 20240727222729689](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407272227760.png) 转换实体引用的功能实际就是绘制这一个同样大小的矩形的操作 #### 等距实体 ![image 20240727114942851](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407271149924.png) 选中顶面点击等距实体, 出现一个预览圆 > 有厚度的实体的边线, 草图的元素都可以进行等距, 这两个都叫做实体 ![image 20240727115159911](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407271151965.png) ## 智能标尺 使用标注角度的时候, 需要依次点击两个直线, 然后把鼠标移动到交点的位置 使用这一个标注的尺寸开始的时候为驱动尺寸, 可以定义这一个图形实际的样式, 之后在使用这一个功能定义的尺寸是从动的, 标注确定以后这一个图形会标为黑色 ![image 20240727224343146](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407272243181.png) ![image 20240727224424752](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407272244786.png) 如果取消, 这一个图形会标为黄色, 这一个图形被过定义 除了图形的尺寸, 还需要定义这一个图形的位置, 这一个图形的位置可以通过选择直线和原点重合, 以及设置和原点的位置 按住Shift可以标注和圆相切的标号 ## 镜像 绘制两个元素, 选择两个对象 ![image 20240728103352638](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407281033695.png) 这一个轴必须是一个直线 ## 线性草图阵列 ![image 20240728103705958](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407281037036.png) ![image 20240728103844939](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407281038012.png) > 不使用等距的时候实际设置的是两个对象之间的角度, 使用这一个选项的时候, 设置的时候所有的生成的对象角度之和 ![image 20240728104030860](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407281040934.png) 可跳过的实实例实际是不显示的实例对象 ## 面的选择 默认的时候不可以在不是平面的面上面进行绘制 也可以绘制一个和圆柱相切的基准面"},"/note/使用软件/solidworks-3D建模/2024-7-31-工程图.html":{"title":"工程图","content":" layout: post title: \"工程图\" date: 2024 7 25 15:39:08 +0800 tags: 3D建模 # 工程图 在文件 >从零件制作工程图 ![image 20240731110213304](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407311102504.png) 选择一个图纸的大小 ![image 20240731110318498](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407311103525.png) 一般使用这一个 ![image 20240731110351787](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407311103925.png) 之后进行拖拽即可"},"/note/使用软件/solidworks-3D建模/2024-7-25-安装.html":{"title":"安装","content":" layout: post title: \"安装\" date: 2024 7 25 15:39:08 +0800 tags: 3D建模 # 安装SOLIDWORKS 下载安装包 ![Solidworks 2022 SP5 安装教程](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407261624890.jpg) ## 默认模板无效 在创建一个零件或者打开一个文件的时候有可能会出现这一个问题 在设置里面有一个默认模板的选项 ![image 20240727214656906](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407272146980.png) 如果这里设置了, 但是找不到的话就会出错, 这里可以点击三个点设置 实际设置的是这一个 ![image 20240727214924132](C:\\Users\\jinhua\\AppData\\Roaming\\Typora\\typora user images\\image 20240727214924132.png) 默认使用的是国标的标准, 也可以进行设置, 但是这一个设置不会改变默认的模板 可以在文件另存为里面 ![image 20240727215401480](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407272154518.png) 保存以后设置这一个为默认的模版的时候就可以了 ![image 20240727215743132](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407272157169.png) 装配体的配置文件是这一个"},"/note/使用软件/solidworks-3D建模/2024-7-29-04装配体.html":{"title":"装配体","content":" layout: post title: \"装配体\" date: 2024 7 25 15:39:08 +0800 tags: 3D建模 # 装配体 把若干个零件或者子装配体通过配合组成在一起的文件 ![image 20240729131708772](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407291317800.png) ![image 20240729132131915](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407291321945.png) 他们两个有独立的基准面 ![image 20240729132332644](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407291323670.png) 这一个显示的零件是使用这一个软件打开的其他零件![image 20240729132525875](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407291325897.png)![image 20240729132536653](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407291325678.png) 最小化以后可以进行切换 也可以在窗口![image 20240729132636852](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407291326875.png)进行切换, 或者Ctrl+Tab 在使用多屏的时候![image 20240729132814103](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407291328204.png) 可以直接按住Ctrl把零件进行拖拽进入装配体, 也可以拖动已经有的零件以及设备树里面的零件 > 第一个零件添加的时候会自动设置为固定, 他的坐标系和装配体相同, 最好使用使用文件打开的方式进行插入, 之后点击确定, 固定零件 > > 在插入的时候也可以使用创建一个新零件的功能 装配体使用左键移动, 右键进行旋转 ## 配合 实际进行零件的安装的操作 ![image 20240729133323778](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407291333815.png) ![image 20240729133543887](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407291335916.png) 在实际使用的时候通常使用多个配合达到理想的状态 ![image 20240729133819798](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407291338850.png) > 可以右击零件编辑零件, 回到初始的零件操控界面 ![image 20240729134112026](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407291341092.png) 编辑结束可以在右上角进行返回 ## 高级配合 ![image 20240729145531328](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407291455353.png) ![image 20240729150209986](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407291502049.png) 会把选中的四个面的中心对齐, 选择的两个面距离相等 ![image 20240729150654016](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407291506045.png) ![image 20240729155717043](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407291557072.png) 在配置的时候如果改变了零件的特征可以使用这一个重新加载 ## 机械配合 ![image 20240729160036122](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407291600174.png) 凸轮需要设置凸轮的面以及接触的面 ![image 20240729160155180](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407291601249.png) ## 隐藏 在观察部件的时候有的零件需要隐藏, 可以点击这一个零件选择弹出来的隐藏按钮, 或者改变这一个零件的透明度, 也可以使用更改透明度的方式 ![image 20240729162133326](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407291621357.png) 使用这一个进行显示, 这一个变化只是显示上面的变化, 配合还在 ## 压缩 零件的视图以及配合全部消失 ## 外观 点击一个零件, 可以在右侧的外观界面设置这一个零件的颜色 ![image 20240730133757540](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407301337852.png) 也可以把这一个拖过去"},"/note/使用软件/solidworks-3D建模/2024-7-26-01基础介绍.html":{"title":"基础介绍","content":" layout: post title: \"基础介绍\" date: 2024 7 25 15:39:08 +0800 tags: 3D建模 # 基础介绍 [‌⁠﻿⁠﻿‍‬‌﻿﻿⁠‬⁠‌‬‌‍﻿[SOLIDWORKS学习地图\\]去哪学？怎么学？点击开启学习之路！ 飞书云文档 (feishu.cn)](https://ifcski218x.feishu.cn/docx/WbhBdLwxYo06CUx4kCxcFTWbnyb) 有三种基本的文件类型, 零件, 装配图以及工程图 ![image 20240726162729260](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407261627318.png) ## 基础使用 > 这一个软件的拖动使用的是鼠标的中键, 使用Ctrl加按压滚轮可以实现移动的效果 ![image 20240726163036392](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407261630414.png) ![image 20240726163058446](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407261630483.png) 主要的过程是在草图里面绘制草图, 然后在特征里面建立实体 ![image 20240726163409751](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407261634777.png) ![image 20240726163440234](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407261634311.png) ![image 20240726163718107](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407261637134.png) ![image 20240726163757798](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407261637825.png) ![image 20240726163846506](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407261638552.png) ![image 20240726163900404](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407261639435.png) ![image 20240726164005721](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407261640771.png) 这一个颜色表示这一个图被完全的定义 ![image 20240726164043348](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407261640373.png) ![image 20240726164115834](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407261641867.png) ![image 20240726164139020](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407261641082.png) ### 视图面 ![image 20240726164435868](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407261644902.png) 可以在这里进行选择, 也可以点击一个面之后再点击这一个选项然后使用![image 20240726164534259](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407261645286.png) ![image 20240726164631336](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407261646365.png) 之前的所有的操作会记录在这里 ## 打印 需要添加一下材质, 可以在设计树里面右击材质, 选择密度相近的材质, 之后使用评估里面的![image 20240729122747213](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202407291227258.png)获取这个物体的具体参数 ## 文件类型 零件是: sldprt 装配体: sldasm 工程图: slddrw 零件中性文件: stp 装配体中性文件: xt >ug使用 stp >proe使用"},"/note/使用软件/WSL/2024-10-14-WSL.html":{"title":"安装","content":"# 安装 从Microsoft store里面下载即可 ## 遇到0x80370102问题 ```bash bcdedit /set hypervisorlaunchtype Auto ``` 使用管理员权限cmd执行这一个 ## 换源 ```bash jiao@LAPTOP BJF9EUQH:~$ vim /etc/apt/sources.list jiao@LAPTOP BJF9EUQH:~$ cp /etc/apt/sources.list /etc/apt/sources.list.copy cp: cannot create regular file '/etc/apt/sources.list.copy': Permission denied jiao@LAPTOP BJF9EUQH:~$ sudo cp /etc/apt/sources.list /etc/apt/sources.list.copy [sudo] password for jiao: jiao@LAPTOP BJF9EUQH:~$ sudo vim /etc/apt/sources.list jiao@LAPTOP BJF9EUQH:~$ sudo apt get update ``` > ``` > # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 > deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse > # deb src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse > deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic updates main restricted universe multiverse > # deb src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic updates main restricted universe multiverse > deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic backports main restricted universe multiverse > # deb src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic backports main restricted universe multiverse > > # 以下安全更新软件源包含了官方源与镜像站配置，如有需要可自行修改注释切换 > deb http://security.ubuntu.com/ubuntu/ bionic security main restricted universe multiverse > # deb src http://security.ubuntu.com/ubuntu/ bionic security main restricted universe multiverse > > # 预发布软件源，不建议启用 > # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic proposed main restricted universe multiverse > # # deb src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic proposed main restricted universe multiverse > ``` ```bash jiao@LAPTOP BJF9EUQH:~$ sudo apt get upgrade ``` ## 安装miniconda ```python jiao@LAPTOP BJF9EUQH:~/app/miniconda$ wget https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3 py39_24.7.1 0 Linux x86_64.sh ```"},"/note/使用软件/BambuStudio/2024-8-14-01软件.html":{"title":"BambuStudio","content":" layout: post title: \"BambuStudio\" date: 2024 8 5 15:39:08 +0800 tags: RISC V # Bambu Studio ## 界面功能 ![image 20240814190946214](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408141909346.png) ![image 20240814191101601](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408141911624.png) ### 材料 ### 不同材料 一般使用的是PLA, PETG, ABS PLA(57℃), PETG(66℃)的强度以及耐高温的能力比较差, ABS有味道, 不环保但是强度比较高(85℃) TPU: 不支持AMS, 数字小硬度小, 打印出来有亮光 TPE: 和上面一样, 打印出来是哑光的, 但是打印的难度比较大 碳纤维: 损耗喷头 > ![image 20240815143351384](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408151433426.png) > > 不同颜色使用的时候有些许不同 ![image 20240814191128828](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408141911878.png) > 使用的耗材 ![image 20240814191533446](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408141915476.png) 层高的范围可以在打印机的配置里面进行更改 ![image 20240815174553618](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408151745684.png) ### 墙 #### 经典模式 ![image 20240814191917653](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408141919688.png) ![image 20240814193832970](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408141938002.png) 首先是原多边形形状，缩小设置的间距宽度（半个外墙线宽）得到第一层路径。然后，再次给第一层墙的多边形收缩设定的间距宽度（两个墙的中心距离），生成第二个墙路径。下图中绿色的多边形可以视作生成墙路径的中心线（也就是这一圈墙的“骨架”），然后实际的路径宽度为设定的内外墙线宽。在经典墙模式下，单条路径的宽度始终是一致的，并且墙路径始终是一个连续的闭环。 如果多边形太小，收缩的结果会为空，所以就不会生成墙路径。 另一个需要提到的概念是“接缝”。“接缝”是墙路径起点和终点之间的间隙。它会在墙上留下一个清晰的点，在打印模型的表面会形成一条明显的缝隙，经典墙体路径是宽度均匀的，所以表面质量会更好，因为它只有一条接缝。不连续的路径可能造成多条缝线。 ![image 20240814193947589](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408141939825.png) 有些模型会有一些比较细小的部分，这些部分太小而无法生成闭合的墙路径，因此切片后会导致模型的部分缺失。例如，下图11中模型表面有很小的文本，因此切片后无法生成文本的墙路径（如图12所示）。当然，如果你更换一个更小尺寸的喷嘴设置，则很有可能将其成功切片。这个问题根本原因是模型的局部太过精细，所需要的打印走线宽度比当前使用喷嘴尺寸的默认线宽还要细小。而设置更小的墙线宽可以解决这个问题。 > 在某些场景下，“检查薄壁”功能可以解决上述这个问题。 如果启用了该参数，则生成墙时的收缩宽度将减小一点，以便为生成墙路径提供空间。如下图所示，生成薄壁后墙中心的间距会更小一些。 “检测薄壁”在某些情况会导致其他问题。如上述所提到的，因为墙间距减小，无法容纳完整的线宽，墙之间可能发生重叠 #### Arachne模式 Arachne也被称为“可变线宽模式”，因为墙路径宽度是可变的。如下图所示，单条墙可以得到不同的宽度。由于可以调节墙体的宽度，所以模型上一些小的细节部分切片后也能生成，且相比“薄壁检测”功能，该模式生成的墙没有重叠。 在某些情况下，arachne将生成非连续的墙路径。例如，部分区域不能生成2个相同宽度的内墙，但可以生成一个宽度稍大的单条内墙（如下图所示）。因此，它与另一个内墙不连续。非连续的墙路径会影响打印表面质量 ![image 20240814194440223](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408141944292.png) ### 强度 #### 填充 ![image 20240814195139606](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408141951639.png) ![image 20240815133749104](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408151337133.png) 在进行填充的时候, 建议使用三角形, 螺旋以及蜂窝形状, 螺旋体的强度是最好的 如果不需要强度, 只是一个演示的话可以使用闪电填充 如果一个模型的不同位置的受力是不同的话可能在不同位置需要不同的填充强度,如果一个比较小的部分需要一个比较大的填充的话, 提高全部的填充会导致浪费 可使用在全局的时候填充的强度为15 在对象界面选中一个零件, 右键添加修改器 ![image 20240815134947714](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408151349750.png) 使用缩放改变一下这一个零件的大小, 之后移动到需要的位置, 改变一下零件的填充度 ![image 20240815135203053](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408151352122.png) ![image 20240815135308256](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408151353291.png) ### 支撑 模型悬空, 或者切片的角度比较大的时候需要支持 大部分的时候可以选择树状自动, 一个比较大的平面在打印的时候需要使用普通的支撑, 如果平面小于45°的话可以不使用支撑进行打印 ![image 20240814195414338](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408141954364.png) ![image 20240815140035770](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408151400797.png) ![image 20240815140150644](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408151401670.png) 树状支撑的样式有这几种, 角度低于阈值角度的时候会有支撑, 比较复杂的模型, 不容易拆卸的时候, 可以使用只在打印版上面生成这一个选项 ![image 20240814195603053](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408141956081.png) SKirt是指在这一个模型底部外侧打印一个圈, 可以用于擦一下打印机的口, 以及对打印机进行调平, 一般设置为3 5圈 Brim是一个贴着这一个模型的一个裙边, 可以使得这一个部件和热床附着的更好 支撑在使用的时候也可以使用多种材料, 使用多种不同的材料的时候, 可以把间距调的小一点 #### 手动支撑 在拐角之类的部分需要增加一个支撑 ![image 20240815141620331](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408151416361.png) 填充模式的时候可以对一个面进行选择以及取消, 左键进行添加, 右键删除 使用第一个圆的时候是对模型进行手绘 #### 多种材料 在使用这一种的时候, 支撑之间的距离需要小一点, 顶部的接触面线距调的小一点, 层数建议是两层 ### 阀层 在模型的底部加一个底座, 把这一个模型拖起来, 一个模型比较高的时候可以增加这一个模型的打印成功几率 以及可以吧不规则的模型的底面变得利于打印, 在实际使用的时候可以把阀层使用另一种材料进行打印, 从而易于拆卸 ![image 20240815141200296](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408151412328.png) ## 顶部栏 ![image 20240814200057530](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408142000562.png) ### 可变层高 ![image 20240814210139690](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408142101717.png) > 大部分时候可以使用这种, 默认也可以 ![image 20240815174953208](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408151749284.png) 可以在右侧手动设置, 左键层高加大, 右键减小, 按住Shift可以使得这一个打印的时候比较平滑, 按住Shift多次点击反向可以返回默认值 这一个可以和熨烫一起配合打印出来的效果更好 ![image 20240815175730081](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408151757152.png) ![image 20240814210303189](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408142103213.png) 选中某一个对象的一个部件的时候, 需要在左侧进行单独选中 ![image 20240814210545822](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408142105844.png) ### 切割 ![image 20240814211317915](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408142113944.png) 在切割的时候选择切割为零件的时候切出来的物品不会进行拆分 ![image 20240818163613603](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408181636671.png) 也可以添加一个螺母的零件然后进行组装, 首先使用负零件进行切除, 之后再添加一下, 缩放的时候取消等比, 调整直径 ### 布尔运算 ![image 20240814211648255](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408142116285.png) 并集: 用于把两个模型组合到一起 ![image 20240815131950509](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408151319565.png) 差集: 选择的时候注意两个模型的顺序, 需要勾选删除输入 ![image 20240815132058798](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408151320831.png) ### 添加支撑 在你想添加支撑的位置选择一下即可 ![image 20240815132347977](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408151323003.png) ### 文字 ![image 20240815132405980](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408151324010.png) 在添加一个文字的时候, 如果一个面对不上可以把这一个零件切割为零件, 之后就可以添加了 可以添加一个文字, 效果为凹陷的时候内嵌深度需要有一个数字 把这一个文字放上去以后, 如果想要这一个字在同一个平面, 可以通过改变这一个字的位置实现 ## 颜色 [涂色工具使用指南 Bambu Lab Wiki](https://wiki.bambulab.com/zh/software/bambu studio/color painting tool) 在实际填充一个零件的颜色之前最好先进行拆分 如果一个模型可以拆分为不同的部件, 可以对不同的部件进行上色 ![image 20240815144616881](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408151446915.png) 手动绘制的时候 ![image 20240815144714585](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408151447617.png) 圆形工具是一种圆形钢笔工具，用于在模型表面绘制任何曲线。 球型绘画工具类似于圆，但它将为球体内的所有面着色，而不仅仅是可见的面。 三角形工具可为鼠标指针所指的三角形面着色。单击可为单个三角形面着色，拖动可连续选择一连串三角形面来上色。三角是根据实际的模型生成的 高度范围工具将给定高度范围内的所有面着色，即使它们可能位于不相交的区域。 填充工具会对从鼠标指针所指的面开始传播的相连面进行着色。当到达具有不同颜色的面时，传播会停止。如果开启了 \"边缘检测 \"功能，则在到达比阈值更锐利的角时也会停止传播。 > 一般使用这一个设置阈值以后使用三角进行微调 使用上述工具进行绘画通常会产生间隙区域。它们可能看起来很丑，并且增加耗材丝更换的次数。空白填充工具将检测小的空白，并采用相邻面的颜色来自动填充它们。 ### 手动实现颜色改变 在打印的时候加入暂停打印, 在预览右侧的进度条部分使用右键进行添加, 使用的所有的颜色都是一种耗材, 可以用于分层比较明显的模型 ![image 20240815204157941](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408152041988.png) ## 流量校准 ![image 20240815165618122](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408151656166.png) ![image 20240815170016989](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408151700111.png) 这一个控制的是打印出来的平面是不是平整的 ## 逐件打印 使用这一个模式可以减少废料出现的概率, 不会一个模型的失误导致整个的错误 ![image 20240815204456433](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408152044472.png) ![image 20240815204549538](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408152045597.png) 超出了这一个框不能再次打印 ## 接缝隐藏 ![image 20240815205011987](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408152050037.png) 这一个是对齐 ![image 20240815205048468](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408152050531.png) 最近 ![image 20240815205108605](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408152051696.png) 背面 ![image 20240815205132957](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408152051038.png) 随机, 需要强度比较高的时候使用这一种 如果想要自己绘制一个位置把这一个缝隙进行隐藏 ![image 20240815205305088](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408152053121.png) 左键添加右键屏蔽 Shift+左键是擦除 再不是一个平面的地方可以使用球形滚动 ## 推荐工具 5400胶水 水口钳 修边刀 美工刀 电动打磨机 变速(无限速) M3螺丝, 磁铁 laC喷雾 ## 添加负零件 在一个元件里面切出来一个空间 选中一个个零件右键, 添加负零件, 选择一下这一个零件的尺寸, 在缩放选项可以设置这一个图形的尺寸, 移动的时候这一个零件以原来的零件的中心位置为原点 如果是一个异形的零件可以把这一个零件修改以后, 等比例缩小一下, 然后负零件导入一下, 调一下位置即可 ## AMS 在设置的时候, 需要在设备一栏按照顺序填入材料的摆放方式, 在实际打印的时候也需要设置一下 也可以使用这一个进行续料, 材料的颜色以及种类是一样的话就可以进行续料, 打开AMS的材料备份 ### 连接比较近的打印 在耗材的设置里面, 参数覆盖, 空驶距离阈值调的小一点, 这一个会让每一圈打印结束以后进行一个回抽 ## 防翘边 最简单的就是添加一个裙边, 把距离调小 也可以右键 >添加标准模型 >小圆片, 放在容易翘边的位置 ## 色差 在打印变化比较大的模型的时候, 会出现不同粗细的位置颜色差距比较大的情况 这时候可以调低外墙的打印速度, 使得外部的打印速度趋于一致 打印的时候出现一条线可以使用逐件打印 ## 预览 ![image 20240818132855021](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202408181328185.png) 可以选择不同的提示, 一般需要检查以下几点 1. 比较薄的地方是不是可以全部打印, 不是的话把墙改为自适应 2. 悬空墙是不是要增加支撑 3. 孔洞里面是不是有支持 4. 接缝的位置 5. 打印的速度, 金色的材料打印速度比较高的话会变色 ## 模型倒伏 手上面有油会使得这平面不能粘东西, 板子需要洗或者喷胶 比较高的位置有悬空的话可以加一个支撑, 防止上翘的位置把这一个模型带倒 耗材吸水比较高的时候会不粘 ## 绒毛表面 在其他的里面, 特殊模式里面有这一个选项, 一般是用在动物, 这一个只能用在有垂直角度的平面, 通过喷头抖动实现 可以实现一个磨砂的效果, 实际使用时候可以和修改器一起使用 ### 单件跳过 在手机上可以控制, 如果某一个零件打印失败可以暂停他的打印暂停打印的左边箭头 ## 装配件搜收缩 打印这一种零件的时候最好使用外墙模式, 外墙模式的接缝比较明显但是尺寸的变化比较小 拓竹的默认打印是内墙, 在质量 >高级里面进行修改 ## 延时摄影 传统模式会把整个过程打印出来, 平滑模式的喷头不变, 但是需要是一个擦料塔, 比较费料 a1mini的传统模式会导致质量下降 ## 花瓶生成器 [MakerLab (makerworld.com.cn)](https://makerworld.com.cn/zh/makerlab?from navbar)"},"/note/使用软件/qemu/2025-2-26-qemu.html":{"title":"qemu","content":"# qemu 源的托管虚拟机, 纯软件虚拟化模拟器, 几乎可以模拟任何硬件设备, 电视性能比较低 ### 两种运行模式 + 用户模式(User mode)：利用动态代码翻译机制来执行不同主机架构的代码，例如：在x86平台上模拟执行ARM代码，也就是说：我们写一条ARM指令，传入整个模拟器中，模拟器会把整个指令翻译成x86平台的指令，然后在x86的CPU中执行。 + 系统模式(System mode)：模拟整个电脑系统，利用其它VMM(Xen, KVM)来使用硬件提供的虚拟化支持，创建接近于主机性能的全功能虚拟机。 计算机的组成 + 运算器 + 控制器 + 存储器 + 输入设备 + 输出设备 ## 创建存储器 ``` qemu img creat f qcow2 drive 16G ``` > 这个命令 `qemu img creat f qcow2 drive 16G` 是用于创建一个虚拟磁盘镜像文件的命令，具体解释如下： > > `qemu img`：这是一个用于创建、转换和修改虚拟硬盘镜像的命令行工具，属于 QEMU（一个开源虚拟化软件）的组成部分。 > `create`：这个参数表示要创建一个新的镜像文件。 > ` f qcow2`：` f` 选项指定要创建的镜像格式，而 `qcow2`（QEMU Copy On Write version 2）是一种支持快照的高效虚拟硬盘格式，具有动态扩展、压缩和加密等特性。 > `drive`：这是要创建的镜像文件的名称。在实际使用时，可以自定义为任何合适的文件名，通常可以在后面加上文件扩展名，如 `drive.qcow2`。 > `16G`：这是创建的镜像文件的大小，这里指定为 16GB（吉字节）。在 `qcow2` 格式中，实际使用的磁盘空间会根据写入的数据量动态变化，而不会一开始就占满指定的大小。 > > 综上所述，这个命令会创建一个名为 `drive`（或其他自定义名称）的 16GB 大小的 qcow2 格式虚拟磁盘镜像文件。虚拟硬件环境 ## 加载 ```bash qemu system x86_64.exe hda .\\qcow2 smp 4 m 1024 boot d cdrom 镜像路径 ``` > 1. `qemu system x86_64.exe`：这是 QEMU 的一个可执行文件，用于在 x86_64 架构（即 64 位架构）上运行虚拟机。 > 2. ` hda .\\qcow2`：这个选项指定了虚拟机的主硬盘驱动器（HDA）。`.\\qcow2` 是虚拟硬盘映像文件的路径，可能是一个 QCOW2 格式的映像文件。`QCOW2` 是 QEMU 的一种虚拟磁盘格式，支持动态分配和快照功能。这里 `.\\` 表示当前目录。 > 3. ` smp 4`：这个选项指定虚拟机使用的 CPU 核心数。在这个例子中，分配了 4 个 CPU 核心给虚拟机。 > 4. ` m 1024`：这个选项指定虚拟机的内存大小。在这个例子中，虚拟机被分配了 1024 MB（1 GB）的内存。 > 5. ` boot d`：这个选项指定启动顺序。在这里，`d` 表示从光盘（CD ROM）启动。这个选项通常用于启动安装操作系统。 > 6. ` cdrom 镜像路径`：这个选项指定了虚拟机的 CD ROM 驱动器中使用的光盘映像文件的路径。您需要将 \"镜像路径\" 替换为实际的光盘映像文件路径，例如 ISO 文件的路径，这个文件通常包含您要安装的操作系统的安装程序。 在linux下面可以使用` enable kvm`进行加速 > KVM（Kernel based Virtual Machine）是一个开源的虚拟化技术，它是Linux内核的一部分，允许Linux作为虚拟机监控器（hypervisor）运行虚拟机。KVM使得用户可以在完整的虚拟机中运行其他操作系统，这些虚拟机称为客虚拟机（guest）。"},"/note/使用软件/git/2025-1-9-Git.html":{"title":"Git","content":"# Git ## 下载 实际使用的时候如果文件比较多可以使用` depth n`, 选择下载的层数 ## vscode 可以使用插件git Grapth ![image 20250109104322267](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202501091043326.png) ![image 20250109104415360](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202501091044444.png) 在实际使用的时候, 由于git不会对字模块进行更新, 可以使用 `git submodule update init recursive`对子模块更新 以及可以使用`git status`查看一下有没有没有被track的模块 ![image 20250109104949550](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202501091049634.png) ![image 20250109105105352](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202501091051399.png) ## 建立分支 `git checkout b 名字`在目前所在的位置建立一个新的分支 ## 提交 ![image 20250109110200357](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202501091102396.png) ![image 20250109105702666](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202501091057717.png) ## 回退 `git reset soft HEAD^`回退一次分支到缓存区, 这时候可以使用图形界面把这一次提交回退删除, 但是远程的没有进行处理, 再次提交可以使用`git push f` ## 添加其他的库 `git remote add name 网站`, 之后可以使用`git fetch depth n`进行更新 ## 合并 `git merge`, 首先需要回到主分支 也使用`git rebase`把当前的分支移动到其他分支的后面 ### 合并某一次 `git cherry pick 哈希值`把这一个的提交合并到当前的分支 ## gitignore问题 在分支合并的时候需要两个分支的这一个文件是相同的 # tmux记录服务器的终端 不会在当前的连接断开以后终端关闭 可以使用`apt get install tmux`安装 `tmux/tmux new s xxx`新建 `tmun ls`查看当前 `tmux attach t name`恢复 `tmun kill session t xx`删除, 不使用 t的时候删除所有的"},"/note/使用软件/git/Untitled.html":{"title":"","content":""},"/note/使用软件/ffmpeg/2025-12-21-02-属性以及查询命令.html":{"title":"查询命令","content":"# 查询命令 ![image 20251221164705450](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251221164705450.png) + 默认使用命令的时候都会把编译使用的参数以及库的版本打印出来, 使用buildconf可以查看详细的编译参数 ## 数据类型 ### formats 在 FFmpeg 中，**muxers（复用器，也译作 “封装器”）** 是核心组件之一，核心作用是：**将多个独立的媒体流（视频流、音频流、字幕流、元数据等）“打包 / 整合” 成一个完整的容器文件（如 MP4、FLV、MKV 等）** ![image 20251221164955430](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251221164955430.png) 这里的D和E指的是支持解码还是编码 ### codecs codec 专门负责**单个媒体流**的「编码（压缩）」和「解码（解压缩）」**解码（decoder）**：把容器文件（如 MP4/FLV）里的压缩流（如 H.264 视频、AAC 音频）还原成原始的未压缩数据（如 YUV 视频帧、PCM 音频采样），供 FFmpeg 处理 ![image 20251221170516099](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251221170516099.png) ```bash DEV.LS h264 H.264 / AVC / MPEG 4 AVC / MPEG 4 part 10 (encoders: libx264 libx264rgb h264_videotoolbox) ``` ### devices 当前支持的设备 ![image 20251221165927479](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251221165927479.png) 标注 含义 D. Demuxing supported → 支持「解复用」 该设备可作为**输入源**（抓取流） .E Muxing supported → 支持「复用」 该设备可作为**输出目标**（输出流） ### bsfs **bsfs** 是 `Bitstream Filters`（比特流过滤器）的缩写，是介于「编解码器（codec）」和「复用 / 解复用器（muxer/demuxer）」之间的轻量级处理组件 —— 核心作用是**对编码后的媒体比特流（如 H.264 视频流、AAC 音频流）做 “微整形” 修改** bsfs 只处理「比特流」，不碰「原始流」—— 做的是 “格式适配、数据裁剪、信息补充” 等轻量操作，而非重新编码 不同的容器格式（如 MP4、FLV、TS）对「比特流的封装格式」有严格要求：比如同样是 H.264 视频流，MP4 要求用「AVCC 格式」存储，而 FLV/TS 要求用「AnnexB 格式」；如果直接打包，会导致播放器无法识别、画面花屏或无声音。 bsfs 就是用来解决这种「比特流格式不兼容」的问题，常见场景： 1. **格式转换**：把 H.264 流从 MP4 兼容的 AVCC 格式转成 FLV 兼容的 AnnexB 格式（`h264_mp4toannexb` 滤镜）； 2. **提取 / 补充元数据**：从比特流中提取编码参数（如 H.264 的 SPS/PPS 信息），或给流补充必要的头部数据； 3. **裁剪 / 过滤**：去掉比特流中的冗余数据（如字幕流的无效帧）、提取关键信息； 4. **格式适配**：把 AAC 流的 ADTS 头部转换成 ASC 格式（`aac_adtstoasc` 滤镜），适配 MP4 容器。 ```bash ffmpeg i test acodec copy vcodec libx264 bsf:v h264_mp4toannexb s 1280x720 test_1280x720.flv ``` ` bsf` 调用比特流过滤器； `:v` 针对视频流（`:a` 针对音频流）； `h264_mp4toannexb` 具体的过滤器名称，把 H.264 流从 MP4 格式转成 FLV 兼容的 AnnexB 格式。 ### protocols **protocols（协议）** 是 FFmpeg 与「本地 / 网络数据源」之间的**数据传输 / 访问通道**—— 简单说，它负责回答「FFmpeg 如何读取 / 写入数据」（比如从本地文件读、从网络直播流拉取、向 RTMP 服务器推流），和你之前问的 `codec`（处理数据内容）、`muxer`（打包数据）、`bsfs`（微调数据格式）、`devices`（对接硬件）是完全不同的维度 #### 本地协议 协议名 标注 核心用途 示例（FFmpeg 命令） `file` I/O 访问本地文件 / 文件夹（默认协议，可省略） ` i file:///Users/test.mp4`（等价于 ` i /Users/test.mp4`） `pipe` I/O 与其他程序通过管道（pipe）交互（Linux/Mac） `cat test.mp4 ffmpeg i pipe:0 c copy output.mp4`（从管道读） `fd` I/O 通过文件描述符（fd）访问文件（高级用法） ` i fd:3`（读取文件描述符 3 对应的数据流） #### 网络协议 协议名 标注 核心用途 示例（FFmpeg 命令） `rtmp` I/O 直播推流 / 拉流（主流直播协议，如抖音 / 快手） 推流：`ffmpeg i test.flv c copy rtmp://server/live/stream` `http`/`https` I/O 拉取 / 推送 HTTP 流（在线视频、HLS 索引） 拉流：`ffmpeg i https://example.com/test.mp4 c copy local.mp4` `hls` I/O 处理 HLS 直播 / 点播流（m3u8 格式） 转 HLS：`ffmpeg i test.mp4 c copy output.m3u8` `rtsp` I 拉取监控摄像头 / IP 相机流（安防常用） `ffmpeg i rtsp://admin:123456@192.168.1.100/stream` `tcp`/`udp` I/O 基于 TCP/UDP 传输裸流（自定义网络传输） `ffmpeg i udp://239.0.0.1:1234 c copy output.mp4` ### filters **filters（滤镜）** 是处理「原始未压缩音视频数据」的核心模块化工具 —— 它介于「解码器（codec）解码后」和「编码器（codec）编码前」，负责对原始视频帧（YUV 格式）、原始音频采样（PCM 格式）做**编辑、特效、格式调整**（比如缩放、加水印、调音量、画中画） 分类 标识 作用 常用示例 视频滤镜 ` vf`/` filter:v` 处理原始视频帧 缩放、裁剪、加水印、字幕 音频滤镜 ` af`/` filter:a` 处理原始音频采样 调音量、重采样、淡入淡出 复杂滤镜 ` filter_complex` 处理多输入 / 多输出、跨流操作 画中画、分屏、音视频混流 #### 视频滤镜 滤镜名 作用 示例（替代 / 增强你的 ` s`） `scale` 分辨率缩放（核心） 👉 保持比例缩放（避免拉伸）：` vf scale 1280: 1`（` 1` 自动计算高度，匹配 16:9）等价于你之前的 ` s 1280x720`（但更智能） `crop` 画面裁剪 裁剪成 1080x720（去掉上下黑边）：` vf crop 1080:720:100:50`（宽：高: 起始 X: 起始 Y） `overlay` 画中画 / 加水印 右下角加水印：` vf \"scale 1280: 1,overlay W w 10:H h 10:watermark.png\"`（W/H 是视频分辨率，w/h 是水印分辨率） `fade` 淡入淡出 5 秒淡入、最后 5 秒淡出：` vf \"fade in:0:30,fade out:end_frame 30:30\"`（30 帧 1 秒，按帧率算） `subtitles` 加字幕 加载 srt 字幕：` vf subtitles test.srt` #### 音频滤镜 滤镜名 作用 示例 `volume` 调整音量 音量放大 2 倍：` af volume 2.0`；静音：` af volume 0` `afade` 音频淡入淡出 3 秒淡入：` af afade in:0:90`（90 帧 3 秒） `aresample` 音频重采样 转成 44100Hz 采样率：` af aresample 44100` `pan` 声道映射（比如单声道转立体声） 单声道转立体声：` af pan stereo ### pix_fmts **pix_fmts** 是 `pixel formats`（像素格式）的缩写，核心描述「原始视频帧中像素数据的存储方式」—— 包括颜色空间（如 YUV/RGB）、色度采样格式（如 4:2:0/4:4:4）、位深（如 8bit/10bit）等，是连接「解码器输出」「滤镜处理」「编码器输入」的关键底层属性，直接影响视频的画质、体积和兼容性 ![image 20251221172447899](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251221172447899.png) 像素格式 含义 适用场景 yuv420p 8bit YUV 4:2:0，平面存储 通用视频编码（MP4/FLV/AVI） yuv420p10le 10bit YUV 4:2:0，小端存储 HDR/4K 视频编码 yuv444p 8bit YUV 4:4:4，平面存储 影视后期 / 无损视频 rgb24 8bit RGB，24 位（R8G8B8） 屏幕抓取 / 图像处理 nv12 YUV 4:2:0，半平面存储 硬件加速编码（如 NVIDIA/Intel） ### Layout **layout** 核心指「音频声道布局（Audio Channel Layout）」—— 描述音频流中「声道数量」和「每个声道的物理位置」（比如左声道、右声道、环绕声道）的规则，是音频处理中定义 “声音空间分布” 的关键属性，和视频的 `pix_fmts`（像素格式）类似，属于音频的 “底层数据组织方式” 布局名称 声道数量 声道位置（物理含义） 常见场景 FFmpeg 标识 Mono（单声道） 1 单声道（无方向，居中） 语音、收音机、老视频 `mono`/`1` Stereo（立体声） 2 左（FL）+ 右（FR） 绝大多数视频、音乐、直播 `stereo`/`2` 2.1 声道 3 左（FL）+ 右（FR）+ 低音炮（LFE） 桌面音响、小型影院 `2.1` 5.1 声道 6 左（FL）+ 右（FR）+ 中置（FC）+ 左后（BL）+ 右后（BR）+ 低音炮（LFE） 电影、游戏、家庭影院 `5.1`/`6` 7.1 声道 8 5.1 基础 + 左环绕（SL）+ 右环绕（SR） 高端影院、4K HDR 视频 `7.1`/`8` ![image 20251221172932121](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251221172932121.png) ### sample_fmts **sample_fmts** 是 `sample formats`（音频采样格式）的缩写，核心描述「原始音频 PCM 采样数据的存储方式」—— 包括数据类型（整数 / 浮点）、位深（8bit/16bit/32bit）、符号类型（有符号 / 无符号）、字节序（大端 / 小端），是音频处理中连接「解码器输出」「滤镜处理」「编码器输入」的底层关键属性，直接影响音频的音质、体积和设备兼容性 ![image 20251221173031033](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251221173031033.png) 采样格式 含义（数据类型 + 位深 + 符号 + 字节序） 核心优势 适用场景 u8 8bit 无符号整数 体积最小、兼容性极强 低端设备、语音文件 s16le 16bit 有符号整数，小端字节序 平衡音质与体积，主流首选 日常编码（AAC/MP3）、视频音频、直播 s32le 32bit 有符号整数，小端字节序 高精度、低失真 无损音频、专业录制 flt 32bit 单精度浮点，小端字节序 动态范围大、无量化失真 音频滤镜处理、后期混音 dbl 64bit 双精度浮点，小端字节序 超高精度 专业音频编辑（极少用） ### colors **`colors` 是「颜色相关属性的统称」**，核心围绕「如何定义和处理视频中的颜色」，包括颜色表示格式、颜色空间（与 `pix_fmts` 强关联）、色域、Gamma 校正等，是视频滤镜（如调色、加水印）、编码适配（如跨设备播放）的关键基础 —— 简单说，`colors` 决定了视频中 “颜色如何被存储、显示和转换” 会输出支持的标准颜色 ## 查询使用 ```bash ffmpeg h type name # type是上面的这些数据, name是实际查询的类型 ffmpeg h muxer flv ```"},"/note/使用软件/ffmpeg/2025-12-26-04-ffmpeg.html":{"title":"ffmpeg","content":"# ffmpeg ## 基础参数 参数 适用领域 核心作用 类比（生活化理解） 采样率 音频 衡量声音信号的 “采样精度”，即每秒对声音波形的采样次数，决定音频的还原度。 用相机拍海浪：采样率越高，每秒拍的照片越多，越能还原海浪的细节。 分辨率 视频 衡量视频画面的 “像素尺寸”，即画面的宽 × 高（如 640x480），决定视频的清晰度上限。 画画的画布大小：分辨率越高，画布越大，能画的细节越多。 码率 音视频通用 衡量每秒音视频的数据量（单位 kbps），是 “数据预算”，直接决定质量和体积。 给画布 / 照片分配的 “颜料 / 存储空间”：预算越多，能画的细节越丰富，照片越清晰。 ### 主要参数 + i: 输入的流, 可以是视频xxx.mp4 + f: 输出的格式, 可以设置为mp4, flv等, 不设置的时候会自动获取输出文件的尾缀 + ss: 开始的时间 + t: 时间长度 ### 音频参数 + aframes: 设置输出的音频帧数 + b\\:a: 音频码率 + ar: 采样率 + ac: 音频的Channel数 + acodec: 音频编解码器, 可以直接使用copy + an: 不处理音频 + af: 音频过滤器 > **示例** > > `ffmpeg i test.mp4 codec copy f flv out.mp4`把MP4文件转换为flv格式, 所有的音视频直接拷贝 > > 可以使用`ffmpeg encoders finds mp3`查找mp3的完整编码器名字 > > `ffmped i test.mp4 b:a 192k ar 48000 ac 2 acodec libmp3lame out.mp3` > > FFmpeg 会读取 `test.mp4` 的视频文件，忽略其中的视频流，只处理音频流，将其按照 `192kbps 比特率、48kHz 采样率、双声道` 的参数，通过 LAME 编码器转码为 MP3 格式，并保存为 `out.mp3`Fmpeg 会根据这个后缀识别输出格式为 MP3 —— 而 MP3 格式的核心定义就是**仅存储音频数据**，不支持封装任何视频流、字幕流等非音频数据 ### 视频参数 + vframes: 输出试音的帧数 + b: 视频的码率 + b\\:v: 视频的码率 + r: 设定帧速率 + s: 宽高 + vn: 不处理视频 + vcodec: 视频解码器, 可以使用copy + vf: 视频过滤器 + pix_fmt: 像素格式 > **示例** > > `ffmpeg i test.mp4 vframe 300 b:v 300k r 30 s 640x480 aspect 16:9 vcodec libx265 out.h265` > > 按照指定的视频参数（300kbps 比特率、30 帧 / 秒、640x480 分辨率、16:9 宽高比），通过 H.265 编码器转码并输出为**裸的 H.265 视频流文件** `out.h265`（无音频、无封装格式）, 播放时播放器会按 16:9 拉伸画面，导致画面变形（比如人物变扁 / 变瘦） ## 示例 ### 提取音视频数据 #### 保留格式 ```bash ffmpeg i test.mp4 acodec copy vn audio.mp4 ffmpeg i test.mp4 vcodec copy an video.mp4 ``` #### 提取视频 ```bash ffmpeg i test.mp4 vcodec copy an test_copy.h264 ffmpeg i test.mp4 vcodec libx264 an test_copy.h264 ``` #### 提取音频 ```bash ffmpeg i test.mp4 acodec copy vn test_copy.mp3 ffmpeg i test.mp4 acodec libmp3lame vn test_copy.mp3 ``` ### 提取像素格式 #### 提取yuv ```bash ffmpeg i test.mp4 t 3 pix_fmt yuv420p yuv420p_orig.yuv ffmpeg i test.mp4 t 3 pix_fmt yuv420p s 320x240 yuv420p_320x240.yuv ``` #### 提取RGB ```bash ffmpeg i test.mp4 t 3 pix_fmt rgb24 rgb24_orig.rgb ``` #### 相互转换 ```bash ffmpeg s 320x240 pix_fmt yuv420p i yuv420p_320x240.yuv pix_fmt rgb24 rgb24_320x240.rgb ``` #### 提取pcm ```bash ffmpeg i test.mp3 ar 48000 ac 2 f s16le 48000_2_s16le.pcm ffmpeg i test.mp3 ar 48000 ac 2 sample_fmt s16 48000_2_s16.wav ffmpeg i test.mp3 ar 48000 ac 2 codec:a pcm_s16le 48000_2_s16le.wav ffmpeg i test.mp3 ar 48000 ac 2 f f32le 48000_2_f32le.pcm ``` f: 的参数可以使用命令`ffmpeg muxers findstr PCM`查看PCM的格式, 存储的是裸数据 sample_fmt: 可以使用命令`ffmpeg sample_fmts`查询, 存储的有一个wav的头部 codec\\:a可以使用命令`ffmpeg encoders findstr pcm`查询, 存储的有一个wav的头部 > ffplay播放的时候pcm数据格式的需要指定参数, wav的不需要 ## 转换封装格式 ### 保持编码 ```bash ffmpeg i test.mp4 vcodec copy vbsf acodec copy test_copy.ts ffmpeg i test.mp4 codec copy test_copy.ts ``` > 在使用v的copy的时候可以加` vbsf` ：**在不重新编码（不损画质、速度快）的前提下，修改已编码视频比特流的 “格式规则 / 元数据”**，解决 “同一种编码（如 H.265）的比特流，因格式 / 元数据不同，导致某些设备认不出来、播不了” 的问题。 > > 它就像给视频流换 “文件格式标签”，不改视频画面本身，只改 “描述格式的文字”—— 比如把 “MP4 专用的 H.265 格式” 改成 “裸流播放器能认的 H.265 格式” > > MP4 里的 H.265 流是 “AVCC 格式”（带 MP4 封装标记），而裸`.h265`文件需要 “Annex B 格式”（通用裸流格式）；不加 ` vbsf`，拷贝出来的流还是 AVCC 格式，播放器认不出；加了之后，格式被转换成 Annex B，就能正常播放 ### 转换编码 ```bash ffmpeg i test.mp4 vcodec libx265 acodec libmp3lame out_h265_mp3.mkv ``` ### 改变帧率 ```bash ffmpeg i test.mp4 r 15 codec copy out.mp4 # (!!!错误!!!!不要有copy) ffmpeg i test.mp4 r 15 out.mp4 ``` ### 视频码率 ```bash ffmpeg i test.mp4 b 400k output.mkv ffmpeg i test.mp4 b:v 400k output.mkv ``` > 不指定codec的时候可能会默认进行格式转码, 只进行一个码率改变的时候, 不指定另一个也可能影响, 需要指定使用copy参数 ### 音频码率 ```bash ffmpeg i test.mp4 b:a 192k output.mp4 ``` > `ffmpeg i test.mp4 b:a 192k b:v 400k output.mp4`音视频 ### 截取视频 ```bash ffmpeg i test.mp4 ss 00:05:00 t 10 codec copy 1.mp4 ``` 才5分钟开始截取10秒视频"},"/note/使用软件/ffmpeg/2025-12-21-01-FFMPEG.html":{"title":"FFMPEG","content":"# FFMPEG 是一个MPEG视频编码标准的, 用于记录转换数字音视频, 转化为流的计算机程序, 可以实现不同的音视频的转换 ## 基础概念 + 容器: 特定的音视频格式, 比如mp4 + 媒体流: 时间轴上面的一段数据, 比如声音, 字幕, 视频数据等, 可以是压缩的和没有压缩的数据, 压缩数据需要有对应的编解码器 + 数据帧/数据包: 通常一个媒体流是大量的数据帧的集合, 记录最小的数据单元, 不同的媒体流帧交错的存在媒体流里面 一般使用Frame记录压缩前的数据, packet记录压缩后的数据 + 编解码器: 帧为单位实现压缩数据以及原始数据转换的, 比如图像的YUV和H264之间的转换, 音频的PCM和AAC之间的转换 + 复用mux: 不同的流按照规则放到容器里面 + 解复用: 不同流从容器里面解析出来 + 码率: 比特率, 确定一个视频音频文件的质量的参数, 秒为单位处理的数据bit数量, 使用bps表示, 和视频的质量是正比的 + 帧率: 视频里面的每一秒的帧数 > 视频文件的基本特征 ## 安装 ```bash brew install ffmpeg ``` ### ffmpeg/ffplay//ffprobe + ffmpeg Hyper fast Audio and Video encoder 音视频编码器 + ffplay 一个简易的音视频播放器 + ffprobe 多媒体流分析器 ### 相关文档 可以使用命令查看信息 ```bash ffmpeg h ffmpeg h long # 高级信息 ffmpeg h full # 所有信息 ffplay h # 只有一个 ffprobe h ``` 可以使用`>`重定向到文件里面进行查看 ```bash usage: ffmpeg [options] [[infile options] i infile]... {[outfile options] outfile}... usage: ffplay [option] input_file usage: ffprobe [OPTIONS] [INPUT_FILE] ``` 有部分的基本参数是通用的, 在使用的时候需要注意 ## 处理基本流程 ```bash ffmpeg i test_1920x1080.mp4 acodec copy vcodec libx264 s 1280x720 test_1280x720.flv ``` ![image 20251221163114506](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251221163114506.png) 音频这里使用的是copy, 所以只处理视频, 先对数据进行拆分解压, 之后处理压缩重组 ` acodec` audio codec（音频编码器），`copy` 直接拷贝输入的音频流（不重新编码）✅ 优点：速度极快、无音质损失；❌ 前提：输出格式（FLV）需支持输入的音频编码（如 AAC/MP3） ` vcodec` video codec（视频编码器），指定视频用 `libx264`（H.264/AVC 编码）💡 最常用的视频编码，兼容性好、压缩率高，是 FLV/MP4 等格式的主流选择 ` s` size（分辨率），指定输出视频的分辨率为 `1280x720`（720P）"},"/note/使用软件/ffmpeg/2025-12-21-03-ffplay控制.html":{"title":"ffplay控制","content":"# ffplay控制 ## 播放时 1. 基础播放控制（最常用） 快捷键 功能说明 实用场景 空格 暂停 ↔ 继续播放 临时暂停看画面 / 听音频 q / ESC 退出 ffplay 播放器 播放完毕 / 无需继续观看 左箭头 后退 10 秒 回看上一段内容 右箭头 前进 10 秒 快进跳过无关内容 下箭头 后退 1 秒 精细回退（比如错过台词） 上箭头 前进 1 秒 精细快进 c 开启 ↔ 关闭循环播放 测试视频循环播放效果 2. 音量 / 音频控制 快捷键 功能说明 补充细节 m 静音 ↔ 取消静音 快速关闭音频，保留画面 9 降低音量（每次约 5%） 音量过大时微调 0（数字零） 提高音量（每次约 5%） 音量过小时微调 a 切换音频轨道（多音频轨文件，如双语视频） 比如切换 “国语 / 英语” 音轨 A 循环切换音频声道（单声道 / 立体声 / 交换左右） 解决声道错乱（如只有左声道有声音） 3. 画面 / 显示控制 快捷键 功能说明 实用场景 f 全屏 ↔ 退出全屏 大屏观看视频 0（字母 o） 切换 OSD 显示（显示 / 隐藏播放信息：时长、进度、帧率） 查看视频帧率 / 码率等信息 w 切换显示模式（仅视频 ↔ 视频 + 音频波形 ↔ 视频 + 音频频谱） 分析音频波形 / 频谱（调试用） r 视频旋转（每次 90 度顺时针） 纠正竖屏 / 横屏颠倒的视频 s 帧步进（暂停时按，播放下一帧） 逐帧分析视频画面（如找故障帧） ,（逗号） 帧后退（暂停时按，回退上一帧） 精细回看某一帧 1 / 2 降低 / 提高画面对比度 调整画面清晰度 3 / 4 降低 / 提高画面亮度 暗画面提亮 5 / 6 降低 / 提高画面饱和度 调整色彩鲜艳度 7 / 8 降低 / 提高 Gamma 值 适配显示器亮度 4. 播放速度 / 轨道控制 快捷键 功能说明 补充细节 /（斜杠） 降低播放速度（每次约 0.5 倍速，最低 0.1 倍） 慢放看细节（如动作视频） *（星号） 提高播放速度（每次约 1.5 倍速，最高 10 倍） 快放看完长视频 v 切换视频轨道（多视频轨文件，极少用） 如视频包含 “原画 / 低清” 双轨 t 切换字幕轨道（多字幕轨文件） 切换不同语言字幕 p 显示 / 隐藏字幕（有字幕轨时） 关闭干扰的字幕 a 切换音频轨道 二、鼠标操作控制（辅助） 操作方式 功能说明 补充细节 点击播放窗口进度条 跳转到对应时间点 进度条左侧 已播放，右侧 未播放 鼠标滚轮（向上） 提高音量（等效按 0 键） 比键盘更顺滑的音量调节 鼠标滚轮（向下） 降低音量（等效按 9 键） 右键点击播放窗口 暂停播放（部分版本支持） 替代空格的快捷操作 ## 命令选项 + x: 强制显示宽度 + y: 强制显示高度 + video_size size: 设置播放的帧尺寸, 原始的YUV没有帧大小的时候 + pixel_foemat format: 设置像素的格式 + fs: 全屏 + an: 禁用音频 + vn: 禁用视频 + sn: 禁用字幕 + ss pos: 根据设置的秒进行定位, 一个数字是秒, 可以使用`hh:mm:ss`的时间格式 + t: 设置播放的长度 + bytes: 按照字节进行拖动, 0 off, 1 on, 1 auto, 需要是帧头和图像一起存储的才可以使用 + nodisplay: 关闭图形显示 + noborder: 无边框 + volume: 起始的音量 + f fmt: 强制使用设置的格式解析 f s16le + window_title title 设置窗口的标题 + loop: 循环次数 + showmode mode: 显示的模型, 0视频, 1音频波形, 2音频频谱, 默认为0, 没有视频使用2 + vf filtergraph: 设置滤镜 + af : 音频滤镜 ### 高级参数 + stats: 打印多个回放统计数据, 显示流持续时间, 编码器的参数, 流的当前位置, 音视频同步同步差值, 默认启用, 可以使用` nostats`, 在代码里面查找这个可以获取到获取各种参数的点代码 + fast: 非标准化规范的多媒体兼容优化 + genpts: 生成pts + sync type: 同步类型, 将主时钟设置为audio(type audio), video或者external(type ext), 默认为audio + ast audio_stream_specifier: 指定音频流索引, vst 视频流, sst 字幕流 + autoexit: 自动退出 + acodec codec_name: 强制使用音频解码器 + vcodec codec_name: 视频解码器 + scodec codec_name: 字幕解码器 + autorotate: 自动旋转 + framedrop: 视频不同步的时候丢弃视频, 主时钟不是视频时钟的时候自动开启, 禁用是` noframedrop` + infbuf: 不限制输入缓冲区的大小, 尽可能快的从输入里面读取数据, 播放实时视频的时候默认开启 ## 播放文件 ![image 20251226090312203](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251226090312203.png) ![image 20251226090451122](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251226090451122.png) > 播放原始数据的时候, 需要自己手动设置视频的参数 ## 简单过滤器 这个内容比较复杂, 了解即可 ![image 20251226090901499](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/mac picture/image 20251226090901499.png) > 直接使用ffplay声音变速的时候会变调"},"/note/使用软件/teedoc/2025-12-16-00-基础使用.html":{"title":"toodoc","content":"# toodoc 是一个可以根据文档以及json文件自动管理文档创建静态网页的工具 ```bash pip install teedoc cd note teedoc install teedoc build teedoc serve ``` ## 配置文件 ### 基础配置文件 在根目录下面有一个site_config.json文件, 里面记录使用目录生成的网页地址, 以及插件github地址等 需要关注的目录是 ```json \"route\": { \"docs\": { \"/get_started/zh/\": \"docs/get_started/zh\", \"/Linux/\": \"doc/Linux\", \"/ai/\": \"doc/ai\", \"/代码分析/\": \"doc/代码分析\", \"/使用软件/\": \"doc/使用软件\", \"/基础软件命令语法/\": \"doc/基础软件命令语法\", \"/嵌入式/\": \"doc/嵌入式\", \"/手机安卓/\": \"doc/手机安卓\", \"/机器学习/\": \"doc/机器学习\", \"/算法基础/\": \"doc/算法基础\", \"/编程基础/\": \"doc/编程基础\", \"/网络/\": \"doc/网络\" }, \"pages\": { \"/\": \"pages/index/zh\" }, \"assets\": { \"/static/\": \"static\", \"/get_started/assets/\": \"docs/get_started/assets\" }, \"blog\": { \"/blog/\": \"blog\" } } ``` 这个里面的docs会生成文档界面, blog生成日直界面, 是比较常用的, 在对应的实际文件目录下面需要有目录里面文件的配置文件 我写了一个自动根据我的文档目录填充的脚本 ```json \"translate\": { \"docs\": { \"/get_started/zh/\": [ { \"url\": \"/get_started/en/\", \"src\": \"docs/get_started/en\" } ] }, \"pages\": { \"/\": [ { \"url\": \"/en/\", \"src\": \"pages/index/en\" } ] } } ``` 和上面的配置是对应的, 中英文之间可以转换的界面, 实际这个位置有一个自动网页翻译的功能 ### 页面目录 #### 使用的配置 ```json { \"import\": \"config_zh\", \"name\": \"网络\" } ``` 导入config_zh的配置文件, 这里面会配置各个页面的logo以及顶栏和底栏的配置 ```json { \"locale\": \"zh_CN\", \"navbar\": { \"title\": \"XvSenfeng\", \"logo\": { \"alt\": \"XvSenfeng logo\", \"src\": \"/static/image/logo.png\" }, \"home_url\": \"/\", \"items\": [ { \"url\": \"/get_started/zh/\", \"label\": \"安装使用\", \"position\": \"left\" }, { \"url\": \"/blog/\", \"label\": \"博客\", \"position\": \"left\" }, { \"url\": \"https://github.com/XuSenfeng/note/\", \"label\": \"github\", \"target\": \"_blank\", \"position\": \"right\" }, { \"id\": \"language\", \"label\": \"Language: \", \"position\": \"right\", \"type\": \"language\" }, { \"url\": \"/Linux/\", \"label\": \"Linux\", \"position\": \"left\" }, { \"url\": \"/ai/\", \"label\": \"ai\", \"position\": \"left\" }, { \"url\": \"/代码分析/\", \"label\": \"代码分析\", \"position\": \"left\" }, { \"url\": \"/使用软件/\", \"label\": \"使用软件\", \"position\": \"left\" }, { \"url\": \"/基础软件命令语法/\", \"label\": \"基础软件命令语法\", \"position\": \"left\" }, { \"url\": \"/嵌入式/\", \"label\": \"嵌入式\", \"position\": \"left\" }, { \"url\": \"/手机安卓/\", \"label\": \"手机安卓\", \"position\": \"left\" }, { \"url\": \"/机器学习/\", \"label\": \"机器学习\", \"position\": \"left\" }, { \"url\": \"/算法基础/\", \"label\": \"算法基础\", \"position\": \"left\" }, { \"url\": \"/编程基础/\", \"label\": \"编程基础\", \"position\": \"left\" }, { \"url\": \"/网络/\", \"label\": \"网络\", \"position\": \"left\" } ] }, \"footer\": { \"top\": [ { \"label\": \"链接\", \"items\": [ { \"label\": \"网站使用 teedoc 生成\", \"url\": \"https://teedoc.neucrack.com\", \"target\": \"_blank\" }, { \"label\": \"Copyright © 2021 Neucrack\", \"url\": \"https://neucrack.com\", \"target\": \"_blank\" }, { \"label\": \"网站地图\", \"url\": \"/sitemap.xml\" } ] }, { \"label\": \"源码\", \"items\": [ { \"label\": \"github\", \"url\": \"https://github.com/XuSenfeng/note/\", \"target\": \"_blank\" }, { \"label\": \"本网站源文件\", \"url\": \"https://github.com/teedoc/teedoc\", \"target\": \"_blank\" } ] } ], \"bottom\": [ { \"label\": \"渝ICP备19015320号\", \"url\": \"https://beian.miit.gov.cn\", \"target\": \"_blank\" }, { \"label\": \"粤公网安备44030602004109号\", \"url\": \"http://www.beian.gov.cn/portal/registerSystemInfo?recordcode 44030602004109\", \"target\": \"_blank\" } ] }, \"plugins\": { \"teedoc plugin ad hint\": { \"config\": { \"label\": \"☆\", \"content\": \"这是一个支持国际化的消息示例</br>喜欢项目请<a target \\\"_blank\\\" href \\\"https://github.com/teedoc/teedoc\\\">点下 ☆ star </a>哦~🦀🦀\" } } }, \"show_source\": \"编辑本页\" } ``` #### 侧边栏配置 依据目录配置显示的侧边栏 ```json { \"items\": [ { \"label\": \"README\", \"file\": \"README.md\" }, { \"label\": \"协议\", \"items\": [ { \"label\": \"2025 3 13 websocket\", \"file\": \"协议\\\\2025 3 13 websocket.md\" } ] }, { \"label\": \"爬虫\", \"items\": [ { \"label\": \"2022 10 2 环境搭建\", \"file\": \"爬虫\\\\2022 10 2 环境搭建.md\" }, { \"label\": \"2022 9 20 python相关知识\", \"file\": \"爬虫\\\\2022 9 20 python相关知识.md\" } ] } ] } ``` ## 脚本 会依据doc下面的目录更新上面的配置文件, 为每一个第一层的目录创建一个READEME文件以及两个配置文件, 同时跟新根目录下面的配置文件以及页面的配置文件 ```python import os import json # 递归生成目录结构 def make_item_for_dir(folder, root): items [] # 先收集本目录下的 .md 文件 for name in sorted(os.listdir(folder)): full os.path.join(folder, name) if os.path.isfile(full) and name.lower().endswith(\".md\"): items.append({ \"label\": os.path.splitext(name)[0], \"file\": os.path.relpath(full, root) # 从 root 开始的相对路径 }) # 再收集子目录，递归生成 for name in sorted(os.listdir(folder)): full os.path.join(folder, name) if os.path.isdir(full): sub make_item_for_dir(full, root) if sub: # 仅在子目录内有内容时加入 items.append({ \"label\": name, \"items\": sub }) return items # 确保根目录下有 config.json 和 README.md def ensure_root_files(root): dir_name os.path.basename(root) # 确保 config.json 存在 config_path os.path.join(root, \"config.json\") if not os.path.exists(config_path): with open(config_path, \"w\", encoding \"utf 8\") as f: json.dump({\"import\": \"config_zh\", \"name\": dir_name}, f, ensure_ascii False, indent 4) print(f\"created: {config_path}\") # 确保 README.md 存在（内容为当前目录名） readme_path os.path.join(root, \"README.md\") if not os.path.exists(readme_path): with open(readme_path, \"w\", encoding \"utf 8\") as f: f.write(f\"# {dir_name}\\n\") print(f\"created: {readme_path}\") # 生成 sidebar.json def create_new_teedoc_sub_dir(file_path None): if file_path None: root os.path.dirname(__file__) else: root file_path print(f\"processing: {root}\") ensure_root_files(root) data {\"items\": make_item_for_dir(root, root)} # 传入 root out_path os.path.join(root, \"sidebar.json\") with open(out_path, \"w\", encoding \"utf 8\") as f: json.dump(data, f, ensure_ascii False, indent 4) print(f\"updated: {out_path}\") # 从支持注释的 JSON 文件加载数据 def _load_json_with_comments(path): # 仅移除不在字符串中的 // 注释 with open(path, \"r\", encoding \"utf 8\") as f: cleaned_lines [] for raw in f: line raw.rstrip(\"\\n\") in_string False escape False i 0 out [] while i < len(line): ch line[i] if escape: out.append(ch) escape False else: if ch \"\\\\\": out.append(ch) escape True elif ch '\"': in_string not in_string out.append(ch) elif not in_string and ch \"/\" and i + 1 < len(line) and line[i+1] \"/\": # 注释开始，丢弃本行后续 break else: out.append(ch) i + 1 cleaned_lines.append(\"\".join(out)) return json.loads(\"\\n\".join(cleaned_lines)) def _dump_json(path, data): with open(path, \"w\", encoding \"utf 8\") as f: json.dump(data, f, ensure_ascii False, indent 4) # 更新 site_config.json 里面的 route.docs, 添加新的文档目录 def update_site_config_routes(doc_dir, site_config_path): if not os.path.isdir(doc_dir): print(f\"doc dir not found: {doc_dir}\") return if not os.path.isfile(site_config_path): print(f\"site_config not found: {site_config_path}\") return site_cfg _load_json_with_comments(site_config_path) route site_cfg.setdefault(\"route\", {}) docs route.setdefault(\"docs\", {}) # 收集 doc 目录下的一级子目录 for name in sorted(os.listdir(doc_dir)): full os.path.join(doc_dir, name) if os.path.isdir(full): key f\"/{name}/\" val f\"doc/{name}\" if docs.get(key) ! val: docs[key] val print(f\"route.docs added/updated: {key} > {val}\") _dump_json(site_config_path, site_cfg) print(f\"updated: {site_config_path}\") # 更新 config_zh.json里面的locale(navbar.items) def update_locale_nav_items(doc_dir, config_template_dir, config_file \"config_zh.json\"): # 目标：更新 config/config_zh.json 的 navbar.items cfg_path os.path.join(config_template_dir, config_file) if not os.path.isfile(cfg_path): print(f\"locale config not found: {cfg_path}\") return cfg _load_json_with_comments(cfg_path) navbar cfg.setdefault(\"navbar\", {}) items navbar.setdefault(\"items\", []) # 已有 URL 集合，避免重复 existing_urls set() for it in items: url it.get(\"url\") if isinstance(url, str): existing_urls.add(url) # 为 doc 下的一级目录添加菜单项 added 0 for name in sorted(os.listdir(doc_dir)): full os.path.join(doc_dir, name) if os.path.isdir(full): url f\"/{name}/\" if url not in existing_urls: items.append({ \"url\": url, \"label\": name, \"position\": \"left\" }) added + 1 print(f\"navbar.items added: {url}\") if added: _dump_json(cfg_path, cfg) print(f\"updated: {cfg_path}\") else: print(\"no navbar items changes\") def main(): doc_dir os.path.dirname(__file__) + \"\\\\doc\" for name in os.listdir(doc_dir): full os.path.join(doc_dir, name) if os.path.isdir(full): create_new_teedoc_sub_dir(full) site_config_path os.path.join(os.path.dirname(__file__), \"site_config.json\") update_site_config_routes(doc_dir, site_config_path) # 新增：更新 locale(navbar.items) config_template_dir os.path.join(os.path.dirname(__file__), \"config\") update_locale_nav_items(doc_dir, config_template_dir) update_locale_nav_items(doc_dir, config_template_dir, config_file \"config_en.json\") if __name__ \"__main__\": main() ```"},"/note/使用软件/teedoc/2025-12-16-01-github脚本.html":{"title":"github脚本","content":"# github脚本 ## github静态界面 [保姆级教程：从零构建GitHub Pages静态网站 CSDN博客](https://blog.csdn.net/qq_20042935/article/details/133920722) 可以获取到github的这个功能是可以使用一个项目的分支作为自己的界面 ![image 20251216094751194](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512160947255.png) 之前创建的这个目录 ```yaml # This is a basic workflow to help you get started with Actions # 拉取仓库的代码, 提交到phpages分支发布网站, 可以使用github Pages同步这个分支到静态网站 name: publish pages # Controls when the action will run. on: # Triggers the workflow on push or pull request events but only for the main branch push: branches: [ main ] pull_request: branches: [ main ] # Allows you to run this workflow manually from the Actions tab workflow_dispatch: # A workflow run is made up of one or more jobs that can run sequentially or in parallel jobs: # This workflow contains a single job called \"build\" build: # The type of runner that the job will run on runs on: ubuntu latest strategy: matrix: python version: [3.8] # Steps represent a sequence of tasks that will be executed as part of the job steps: # Checks out your repository under $GITHUB_WORKSPACE, so your job can access it\t # 下载最新的代码 uses: actions/checkout@v2 # Runs a set of commands using the runners shell name: build doc id: build_doc run: # 下载所有的代码\t git fetch unshallow # fetch all history # 环境安装 pip3 install setuptools pip3 install teedoc ls al ~/.local/bin/ export PATH ~/.local/bin/:$PATH commit_info `git describe all always long` out_dir out`python3 c 'import json; f open(\"site_config.json\");config json.load(f);print(config[\"site_root_url\"])'` teedoc install teedoc build echo \"out dir: ${out_dir}\" cp rf .github $out_dir echo \"out_dir $out_dir\" >> $GITHUB_OUTPUT remote_addr `git remote get url push origin` echo \"remote addr: ${remote_addr}\" cd $out_dir # 获取到用户名字以及邮箱 user_name `git log 1 pretty format:'%an'` user_email `git log 1 pretty format:'%ae'` git config global init.defaultBranch gh pages # 初始化一个新的仓库 git init git config user.name ${user_name} git config user.email ${user_email} git add A # 提交 git commit m \"rebuild website ad $commit_info\" # 获取验证信息 if [[ \"${{ secrets.ACCESS_KEY }}x\" \"x\" ]]; then remote_addr `echo $remote_addr awk F'://' '{print $2}'` remote_addr https://${user_name}:${{ secrets.GITHUB_TOKEN }}@${remote_addr} else SSHPATH \"$HOME/.ssh\" rm rf \"$SSHPATH\" mkdir p \"$SSHPATH\" echo \"${{ secrets.ACCESS_KEY }}\" > \"$SSHPATH/id_rsa\" chmod 600 \"$SSHPATH/id_rsa\" sudo sh c \"echo StrictHostKeyChecking no >>/etc/ssh/ssh_config\" domain `echo $remote_addr awk F'/' '{print $3}'` user_org `echo $remote_addr awk F'/' '{print $4}'` repo `echo $remote_addr awk F'/' '{print $5}'` remote_addr git@${domain}:${user_org}/${repo}.git fi git remote add origin ${remote_addr} # 推送到这个仓库里面的gh pages分支 git push origin HEAD:gh pages force ``` 使用这个脚本, 自动创建新的分支以及提交静态网页 ![image 20251216095816874](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512160958973.png) ![image 20251216095949163](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/lenovo picture/202512160959269.png) ## 同步到gitee ```yaml # This is a basic workflow to help you get started with Actions name: sync code to gitee # Controls when the action will run. Triggers the workflow on push or pull request # events but only for the master branch on: push: branches: [ main ] pull_request: branches: [ main ] # Allows you to run this workflow manually from the Actions tab workflow_dispatch: # A workflow run is made up of one or more jobs that can run sequentially or in parallel jobs: # This workflow contains a single job called \"build\" sync_gitee: name: sync code to gitee # The type of runner that the job will run on runs on: ubuntu latest # Steps represent a sequence of tasks that will be executed as part of the job steps: # Checks out your repository under $GITHUB_WORKSPACE, so your job can access it name: checkout code from github uses: actions/checkout@v2 # Runs a set of commands using the runners shell name: sync source code run: GITEE_GIT_ADDR \"git@gitee.com:teedoc/teedoc.gitee.io.git\" git fetch unshallow SSHPATH \"$HOME/.ssh\" rm rf \"$SSHPATH\" # 重新配置ssh配置 mkdir p \"$SSHPATH\" # 加入秘钥 echo \"${{ secrets.GITEE_SYNC_ACCESSS_KEY }}\" > \"$SSHPATH/id_rsa\" chmod 600 \"$SSHPATH/id_rsa\" sudo sh c \"echo StrictHostKeyChecking no >>/etc/ssh/ssh_config\" git remote add upstream $GITEE_GIT_ADDR # 强制推送 git push upstream main:main force ``` ## 自动部署 **将 GitHub 仓库 `gh pages` 分支的静态页面文件（通常是已构建好的网站 / 文档文件）通过 `rsync` 工具同步到指定的远程服务器**，同时支持通过「Server 酱」发送部署开始的通知，实现静态页面更新后自动部署到服务器 1. 运行环境：基于最新版 Ubuntu 系统（`ubuntu latest`）； 2. 该 Job 是唯一任务，负责完成「检出 gh pages 代码 → 发送部署通知 → 配置 SSH → 同步文件到服务器」 ```yaml # This is a basic workflow to help you get started with Actions name: sync pages to server # Controls when the action will run. Triggers the workflow on push or pull request # events but only for the master branch on: push: branches: [ gh pages ] pull_request: branches: [ gh pages ] # Allows you to run this workflow manually from the Actions tab workflow_dispatch: # A workflow run is made up of one or more jobs that can run sequentially or in parallel jobs: # This workflow contains a single job called \"build\" sync_gitee: name: sync pages to server # The type of runner that the job will run on runs on: ubuntu latest # Steps represent a sequence of tasks that will be executed as part of the job steps: # Checks out your repository under $GITHUB_WORKSPACE, so your job can access it name: checkout code from github uses: actions/checkout@v2 # Runs a set of commands using the runners shell name: sync shell cmd run: git fetch unshallow # 显式切换到`gh pages`分支(确保后续同步的是该分支的静态文件，而非默认检出的分支) git checkout gh pages # 部署通知(基于「Server 酱」工具) # 检查是否配置了 SERVERCHAIN_KEY(Server 酱的发送密钥) # 若配置:调用Server酱API发送通知(标题为正在部署teedoc网站到服务器, # 可推送到微信 /钉钉等) if [[ \"${{ secrets.SERVERCHAIN_KEY }}x\" ! \"x\" ]]; then curl \"https://sctapi.ftqq.com/${{ secrets.SERVERCHAIN_KEY }}.send?title 正在部署teedoc网站到服务器\"; else echo \"no server chain key\"; fi SSHPATH \"$HOME/.ssh\" rm rf \"$SSHPATH\" mkdir p \"$SSHPATH\" # 将GitHub仓库密钥 GITEE_SYNC_ACCESSS_KEY_SERVER # (远程服务器对应的 SSH 私钥)写入 id_rsa 文件 echo \"${{ secrets.GITEE_SYNC_ACCESSS_KEY_SERVER }}\" > \"$SSHPATH/id_rsa\" chmod 600 \"$SSHPATH/id_rsa\" sudo sh c \"echo StrictHostKeyChecking no >>/etc/ssh/ssh_config\" # 核心同步命令（rsync 是高效的文件同步工具，比 scp 更适合增量同步） rsync avz c r exclude '.git' ./* ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_IP }}:${{ secrets.SERVER_PATH }}/ ``` 必须配置的 GitHub Secrets（仓库「Settings → Secrets and variables → Actions」中添加） 密钥名称 作用 `SERVERCHAIN_KEY` Server 酱的发送密钥（可选，仅用于部署通知）； `GITEE_SYNC_ACCESSS_KEY_SERVER` 远程服务器的 SSH 私钥（必须，用于免密登录服务器）； `SERVER_USER` 远程服务器的登录用户名（如 `root`、`ubuntu` 等，必须）； `SERVER_IP` 远程服务器的公网 IP / 域名（必须）； `SERVER_PATH` 服务器上存放静态页面的目标路径（如 `/var/www/teedoc`，必须）； [Server酱·Turbo版 一个请求通过API将消息推送到个人微信、企业微信、手机客户端和钉钉群、飞书群](https://sct.ftqq.com/)"},"/note/使用软件/quicker/2023-12-20-入门.html":{"title":"Quicker入门","content":" layout: post title: \"Quicker入门\" date: 2023 12 1 15:39:08 +0800 tags: 软件使用 Quicker # Quicker入门"},"/note/使用软件/vim/2024-4-10-ctags.html":{"title":"ctags","content":" layout: post title: \"ctags\" date: 2024 4 10 15:39:08 +0800 tags: vim # Ctags 可以使用这一个文件查看代码, 定义以及实际使用之间跳转, 需要生成一个tags文件 使用命令查看是否安装 `sudo aptitude show exuberant ctags` ## 使用 使用命令在项目文件下面`ctags ./* R` 也可以在vim里面ctrl + p生成 1. ctags –R . 上面介绍过了，不再赘述 2. Ctrl+ ] 跳到光标所在变量的定义处 3. Ctrl+ t 返回查找或跳转，从哪里跳过来的跳回哪里，即使用了很多次 Ctrl+]，该命令也会回到最初一次的位置 4. vi –t tag 找到名为 tag 的变量的定义处 5. g] 列出变量的所有引用供用户选择 6. :ts tagslist，同 g] 7. :tp tagspreview，上一个tag标记文件 8. :tn tagsnext)，下一个tag标记文件 ## 文件列表 *#vim命令模式下* ```bash :Explore #当前窗口下打开 :Vexplore #竖直分割窗口打开 :Sexplore #水平分割窗口打开 ``` ## 函数列表 [vim 查看函数列表_vim 函数 list CSDN博客](https://blog.csdn.net/cxj582667366/article/details/41730451) ## vimrc文件 ``` \"使用Ctrl + o打开文件列表 map <C o> :Vexplore \"使用F4打开函数列表 map <F4> :TlistToggle let Tlist_Ctags_Cmd '/usr/bin/ctags' \"告知系统生成tag的程序的位置 let Tlist_Show_One_File 1 \"不同时显示多个文件的tag，只显示当前文件的 let Tlist_Exit_OnlyWindow 1 \"如果taglist窗口是最后一个窗口，则退出vim let Tlist_Use_Right_Window 1 \"在右侧窗口中显示taglist窗口 ```"},"/note/使用软件/vscode/2024-8-5-快捷键.html":{"title":"","content":"[第二篇：前端VSCode常用插件 快捷键 以及常用技巧 pink老师 哔哩哔哩 (bilibili.com)](https://www.bilibili.com/read/cv9699783/?spm_id_from 333.999.0.0)"},"/note/使用软件/vscode/2024-2-2-使用.html":{"title":"Arduino","content":" layout: post title: \"Arduino\" date: 2024 2 2 15:39:08 +0800 tags: vscode # 使用 ## 格式化代码 ![image 20240202213712170](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402022137202.png) > 控制缩进 Alt + Shift + F自动格式化 ## 问题 ```c Processing esp32dev (platform: espressif32; board: esp32dev; framework: arduino) Tool Manager: Installing platformio/tool mkspiffs @ ~2.230.0 ``` > 这一个卡死 > > 解决方法, 在这个文件夹的位置使用命令行 > > ```bash > C:\\Users\\jinhua\\.platformio\\penv\\Scripts\\platformio.exe run target upload > ``` > > 用这一个命令下载 ## 资源 ![image 20240203141735294](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402031417487.png) ### 特殊的引脚 GPIO0: 上电的时候选择是下载还是正常运行 GPIO6 11: 连接Flash GPIO34 39: 只能输入 > 在使用WIFI的时候ADC2不可以使用 两个DAC, 默认3个串口 TouchPad: 检测电容, 看人有没有接触 ## 使用 ### 串口 可以直接使用USB串口 ### GPIO #### TouchPaD ```c #include <Arduino.h> void TouchEvent(){ Serial.printf(\"Touch Event.\\r\\n\"); } void PinIntEvent(){ Serial.printf(\"PinInt Event\\r\\n\"); } void setup() { // put your setup code here, to run once: Serial.begin(115200); } void loop() { // put your main code here, to run repeatedly: Serial.printf(\"touch:%d\\r\\n\", touchRead(T0)); delay(200); } ``` > ![image 20240203143831896](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402031438937.png) > > 没有触摸的时候显示的值比较大 + 可以使用Touch中断 ```c touchAttachInterrupt(T0, TouchEvent, 40); ``` > 可以使用这一个设置一个中断 > > 参数: 引脚, 处理函数, 阈值 ![image 20240203144209744](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402031442787.png) #### 外部中断 ```c pinMode(0, INPUT_PULLUP);//上拉输入 attachInterrupt(0, PinIntEvent, FALLING);//设置为下降沿, 设置一个中断函数, 这一个是板子自带的那一个按键 ``` > ```c > // Changed OUTPUT from 0x02 to behave the same as Arduino pinMode(pin,OUTPUT) > // where you can read the state of pin even when it is set as OUTPUT 使用中断的时候要使用输入模式 > #define OUTPUT 0x03 \t\t//输出 > #define PULLUP 0x04\t\t//上拉 > #define INPUT_PULLUP 0x05\t\t//上拉输入 > #define PULLDOWN 0x08\t\t//下拉 > #define INPUT_PULLDOWN 0x09\t\t//下拉输入 > #define OPEN_DRAIN 0x10\t\t//开漏 > #define OUTPUT_OPEN_DRAIN 0x13\t\t//开漏输出 > #define ANALOG 0xC0\t\t//模拟 > > //Interrupt Modes > #define RISING 0x01\t\t//上升沿 > #define FALLING 0x02\t\t//下降沿 > #define CHANGE 0x03\t\t//电平变化的时候 > #define ONLOW 0x04\t\t//低电平 > #define ONHIGH 0x05\t\t//高电平 > #define ONLOW_WE 0x0C\t\t//多了一个唤醒功能 > #define ONHIGH_WE 0x0D > ``` ```c attachInterruptArg(uint8_t pin, voidFuncPtrArg handler, void * arg, int mode); ``` > 一个带参数的中断处理函数 ```c detachInterrupt(uint8_t pin); ``` > 取消中断 ![image 20240203152953558](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402031529633.png) > 使用SSCOM的时候进入中断不正常 > > ![image 20240203153451626](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402031534648.png) > > 把这个关了 ### 定时器 ESP32一般有2 4个硬件定时器, 一般是64位计数器以及一个16位的预分频器, 可以选择自动重装载 ```c hw_timer_t * timerBegin(uint8_t num, uint16_t divider, bool countUp); ``` > 开启一个时钟以及选择时钟的频率, 使用这一个以后会自动启动 > > num: 开启的时钟标号 divider: 分频系数 countUp: true 向上计数 > > 返回一个timer的句柄, 失败是NULL ```c void timerEnd(hw_timer_t * timer); ``` > 关闭一个时钟 ```c void timerStart(hw_timer_t * timer); ``` > 打开一个时钟 ```c void timerStop(hw_timer_t * timer); ``` > 关闭 ```c void timerRestart(hw_timer_t * timer); ``` ```c void timerWrite(hw_timer_t * timer, uint64_t val); ``` > 改变计数值 ```c uint64_t timerRead(hw_timer_t * timer); ``` > 获取当前的计数值 ```c uint64_t timerReadMicros(hw_timer_t * timer); ``` > 获取计数的微秒值 ```c uint64_t timerReadMilis(hw_timer_t * timer); ``` > 获取一个毫秒值 ```c double timerReadSeconds(hw_timer_t * timer); ``` ```c uint16_t timerGetFrequency(hw_timer_t * timer); ``` > 获取时钟的频率 ```c void timerAttachInterrupt(hw_timer_t *timer, void (*fn)(void), bool edge); ``` > 开启一个中断 > > 最后一个参数设置的是触发方式, true边沿触发 false电平触发 ```c void timerAttachInterruptArg(hw_timer_t * timer, void (*userFunc)(void*), void * arg); ``` ```c void timerDetachInterrupt(hw_timer_t * timer); ``` > 取消中断 ```c void timerAlarm(hw_timer_t * timer, uint64_t alarm_value, bool autoreload, uint64_t reload_count); ``` > 开启一个闹钟 > > alarm_value等待的时钟数 > > autoreload是不是自动重装载 > > reload_count重装载值 ```c void timerAlarmWrite(hw_timer_t *timer, uint64_t alarm_value, bool autoreload){ ``` > 指定时钟的触发时间 > > 时钟, 计数值以及是否重装载 ```c void timerAlarmEnable(hw_timer_t *timer); ``` ```c #include <Arduino.h> int interruptCounter 0; hw_timer_t *timer NULL; void IRAM_ATTR TimerEvent() { Serial.printf(\"interrupt Count %d\\n\", interruptCounter++); if(interruptCounter>5) interruptCounter 1; } void setup() { // put your setup code here, to run once: Serial.begin(115200); //获取一个时钟句柄 timer timerBegin(0, 80, true); timerAttachInterrupt(timer,TimerEvent,true); timerAlarmWrite(timer, 1000000, true); timerAlarmEnable(timer); } void loop() { // put your main code here, to run repeatedly: } ``` ### PWM PWM的产生需要使用一个时钟, 需要尽量避开在使用的时钟 Arduino使用ledc模块来进行控制PWM > LED控制（LEDC）外围设备主要用于控制LED的强度，尽管它也可以用于生成PWM信号用于其他目的。它具有16个通道，可以生成独立的波形，这些波形可以用于驱动RGB LED器件。 ```c /* * LEDC Chan to Group/Channel/Timer Mapping ** ledc: 0 > Group: 0, Channel: 0, Timer: 0 ** ledc: 1 > Group: 0, Channel: 1, Timer: 0 ** ledc: 2 > Group: 0, Channel: 2, Timer: 1 ** ledc: 3 > Group: 0, Channel: 3, Timer: 1 ** ledc: 4 > Group: 0, Channel: 4, Timer: 2 ** ledc: 5 > Group: 0, Channel: 5, Timer: 2 ** ledc: 6 > Group: 0, Channel: 6, Timer: 3 ** ledc: 7 > Group: 0, Channel: 7, Timer: 3 ** ledc: 8 > Group: 1, Channel: 0, Timer: 0 ** ledc: 9 > Group: 1, Channel: 1, Timer: 0 ** ledc: 10 > Group: 1, Channel: 2, Timer: 1 ** ledc: 11 > Group: 1, Channel: 3, Timer: 1 ** ledc: 12 > Group: 1, Channel: 4, Timer: 2 ** ledc: 13 > Group: 1, Channel: 5, Timer: 2 ** ledc: 14 > Group: 1, Channel: 6, Timer: 3 ** ledc: 15 > Group: 1, Channel: 7, Timer: 3 */ ``` > 分为两组，每组8个通道。一组LEDC通道以高速模式运行。此模式在硬件中实现，并提供PWM占空比的自动且无干扰的更改。另一组通道在低速模式下运行，PWM占空比必须由驱动程序在软件中进行更改。每组通道还能够使用不同的时钟源。 #### 实际使用 ```c uint32_t ledcSetup(uint8_t chan, uint32_t freq, uint8_t bit_num) ``` > 选择通道, 频率以及分辨率, 这个实际的分辨率是2^bitnum ```c void ledcAttachPin(uint8_t pin, uint8_t chan) ``` > 绑定通道以及引脚 ```c void ledcWrite(uint8_t chan, uint32_t duty) ``` > 设置一个占空比 #### 示例 ```c #include <Arduino.h> #include \"Motor.h\" /* * LEDC Chan to Group/Channel/Timer Mapping ** ledc: 0 > Group: 0, Channel: 0, Timer: 0 ** ledc: 1 > Group: 0, Channel: 1, Timer: 0 ** ledc: 2 > Group: 0, Channel: 2, Timer: 1 ** ledc: 3 > Group: 0, Channel: 3, Timer: 1 ** ledc: 4 > Group: 0, Channel: 4, Timer: 2 ** ledc: 5 > Group: 0, Channel: 5, Timer: 2 ** ledc: 6 > Group: 0, Channel: 6, Timer: 3 ** ledc: 7 > Group: 0, Channel: 7, Timer: 3 ** ledc: 8 > Group: 1, Channel: 0, Timer: 0 ** ledc: 9 > Group: 1, Channel: 1, Timer: 0 ** ledc: 10 > Group: 1, Channel: 2, Timer: 1 ** ledc: 11 > Group: 1, Channel: 3, Timer: 1 ** ledc: 12 > Group: 1, Channel: 4, Timer: 2 ** ledc: 13 > Group: 1, Channel: 5, Timer: 2 ** ledc: 14 > Group: 1, Channel: 6, Timer: 3 ** ledc: 15 > Group: 1, Channel: 7, Timer: 3 */ // 绑定的IO const int Motor_PWM_PinA 5; const int Motor_PWM_PinB 4; const int Motor_INA1 19; const int Motor_INA2 18; const int Motor_INB1 16; const int Motor_INB2 17; // PWM的通道，共16个(0 15)，分为高低速两组， // 高速通道(0 7): 80MHz时钟，低速通道(8 15): 1MHz时钟 // 0 15都可以设置，只要不重复即可，参考上面的列表 // 如果有定时器的使用，千万要避开!!! const int Motor_channel_PWMA 2; const int Motor_channel_PWMB 3; // PWM频率，直接设置即可 int Motor_freq_PWM 1000; // PWM分辨率，取值为 0 20 之间，这里填写为10，那么后面的ledcWrite // 这个里面填写的pwm值就在 0 2的10次方 之间 也就是 0 1024 int Motor_resolution_PWM 10; void Motor_Init(void) { pinMode(Motor_INA1, OUTPUT); pinMode(Motor_INA2, OUTPUT); pinMode(Motor_INB1, OUTPUT); pinMode(Motor_INB2, OUTPUT); ledcSetup(Motor_channel_PWMA, Motor_freq_PWM, Motor_resolution_PWM); // 设置通道 ledcSetup(Motor_channel_PWMB, Motor_freq_PWM, Motor_resolution_PWM); // 设置通道 ledcAttachPin(Motor_PWM_PinA, Motor_channel_PWMA); //将 LEDC 通道绑定到指定 IO 口上以实现输出 ledcAttachPin(Motor_PWM_PinB, Motor_channel_PWMB); } void PWM_SetDuty(uint16_t DutyA, uint16_t DutyB) { ledcWrite(Motor_channel_PWMA, DutyA); ledcWrite(Motor_channel_PWMB, DutyB); } // 电机的控制程序，分别是左右两个轮子的占空比（0 1024） void Motor_Control(int Cnt_L, int Cnt_R) { if (Cnt_L > 0) // 左轮正向转 { digitalWrite(Motor_INA1, HIGH); digitalWrite(Motor_INA2, LOW); ledcWrite(Motor_channel_PWMA, Cnt_L); } else // 左轮反向转 { digitalWrite(Motor_INA1, LOW); digitalWrite(Motor_INA2, HIGH); ledcWrite(Motor_channel_PWMA, Cnt_L); } if (Cnt_R > 0) // 右轮正向转 { digitalWrite(Motor_INB1, HIGH); digitalWrite(Motor_INB2, LOW); ledcWrite(Motor_channel_PWMB, Cnt_R); } else // 右轮反向转 { digitalWrite(Motor_INB1, LOW); digitalWrite(Motor_INB2, HIGH); ledcWrite(Motor_channel_PWMB, Cnt_R); } } ``` ### WiFi #### API ```c #include <Arduino.h> #include <WiFi.h> void WiFi_Connect() { WiFi.begin(\"TP LINK_5G_2B18\", \"13838106970\");//连接 while(WiFi.status()! WL_CONNECTED) { delay(300); Serial.printf(\".\"); } } void setup() { // put your setup code here, to run once: Serial.begin(115200); delay(100); Serial.printf(\"Connecting..\"); WiFi_Connect(); Serial.println(\"Wifi Connected\"); Serial.println(\"IP Address: \"); Serial.println(WiFi.localIP());//显示一个IP } void loop() { // put your main code here, to run repeatedly: delay(500); } ``` ![image 20240203171525530](https://picture 01 1316374204.cos.ap beijing.myqcloud.com/image/202402031715631.png)"},"/note/使用软件/基础软件命令语法/2022-7-21-typedef.html":{"title":"typedef","content":" layout: article title: \"typedef\" # typedef ![Image](https://xusenfeng.github.io/myimages/2 7.jpg){:.shadow} ![Image](https://xusenfeng.github.io/myimages/2 8.jpg){:.shadow}"},"/note/使用软件/基础软件命令语法/2022-7-21-git相关指令.html":{"title":"git (gcc、makefile)相关笔记","content":" layout: article title: \"git (gcc、makefile)相关笔记\" # git的使用 + gcc + makefile ![Image](https://xusenfeng.github.io/myimages/15.jpg){:.shadow} ![Image](https://xusenfeng.github.io/myimages/16.jpg){:.shadow} ![Image](https://xusenfeng.github.io/myimages/17.jpg){:.shadow} ![Image](https://xusenfeng.github.io/myimages/18.jpg){:.shadow}"},"/note/使用软件/基础软件命令语法/2022-7-21-正则表达式.html":{"title":"正则表达式","content":" layout: article title: \"正则表达式\" # 正则表达式 ![Image](https://xusenfeng.github.io/myimages/12.jpg){:.shadow} ![Image](https://xusenfeng.github.io/myimages/11.jpg){:.shadow}"},"/note/使用软件/基础软件命令语法/2022-7-21-Markdown标记语言的使用.html":{"title":"Markdown语言操作","content":" layout: article title: \"Markdown语言操作\" ## Mark Down ##### 标记语言的使用 ![Image](https://xusenfeng.github.io/myimages/1.jpg){:.shadow} ![Image](https://xusenfeng.github.io/myimages/2.jpg){:.shadow}"}}